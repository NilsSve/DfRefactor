Compiling Program: C:\Projects\DF18\DfRefactor\AppSrc\MaintainFunctions.src
Memory Available: 2147483646
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
67438>>>// these are all the packages used in a standard MDI menubar/toolbar system
67438>>>
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
67438>>>>>Use Dfpanel.pkg
67438>>>>>Use cCJCommandBarSystem.pkg
67438>>>>>Use LanguageText.pkg
67438>>>>>
67438>>>>>
67438>>>>>Class cCJUndoMenuItem is a cCJMenuItem
67439>>>>>    
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>        Set psCaption   to C_$CaptionUndo
67444>>>>>        Set psToolTip to C_$ToolTipUndo
67445>>>>>        Set psDescription to C_$DescUndo
67446>>>>>        Set psImage to "ActionUndo.ico"
67447>>>>>        Set pbActiveUpdate to True
67448>>>>>        Set psCategory to C_$CategoryEdit
67449>>>>>        Set psShortcut to C_$Key_Ctrl_Z
67450>>>>>    End_Procedure
67451>>>>>    
67451>>>>>    Procedure OnExecute Variant vCommandBarControl
67453>>>>>        Send Undo of (focus(Self))
67454>>>>>    End_Procedure
67455>>>>>    
67455>>>>>    Function IsEnabled Returns Boolean
67457>>>>>        Boolean bEnabled
67457>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
67458>>>>>        Function_Return bEnabled
67459>>>>>    End_Function
67460>>>>>    
67460>>>>>End_Class
67461>>>>>
67461>>>>>
67461>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
67462>>>>>    
67462>>>>>    Procedure Construct_Object
67464>>>>>        Forward Send Construct_Object
67466>>>>>        Set psCaption   to C_$CaptionDelete
67467>>>>>        Set psToolTip to C_$ToolTipDelete
67468>>>>>        Set psDescription to C_$DescDelete
67469>>>>>        Set psImage to "actionDelete.ico"
67470>>>>>        Set psShortcut to C_$Key_Delete
67471>>>>>        Set pbActiveUpdate to True
67472>>>>>        Set psCategory to C_$CategoryEdit
67473>>>>>    End_Procedure
67474>>>>>    
67474>>>>>    
67474>>>>>    Procedure OnExecute Variant vCommandBarControl
67476>>>>>        Send Delete of (focus(Self))
67477>>>>>    End_Procedure
67478>>>>>    
67478>>>>>    Function IsEnabled Returns Boolean
67480>>>>>        Boolean bEnabled
67480>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
67481>>>>>        Function_Return bEnabled
67482>>>>>    End_Function
67483>>>>>    
67483>>>>>End_Class
67484>>>>>
67484>>>>>
67484>>>>>Class cCJCutMenuItem is a cCJMenuItem
67485>>>>>    
67485>>>>>    Procedure Construct_Object
67487>>>>>        Forward Send Construct_Object
67489>>>>>        Set psCaption   to C_$CaptionCut
67490>>>>>        Set psToolTip to C_$TooltipCut
67491>>>>>        Set psDescription to C_$DescCut
67492>>>>>        Set psImage to "actionCut.ico"
67493>>>>>        Set psShortcut to C_$Key_Ctrl_X
67494>>>>>        Set pbActiveUpdate to True
67495>>>>>        Set psCategory to C_$CategoryEdit
67496>>>>>    End_Procedure
67497>>>>>    
67497>>>>>    
67497>>>>>    Procedure OnExecute Variant vCommandBarControl
67499>>>>>        Send Cut of (focus(Self))
67500>>>>>    End_Procedure
67501>>>>>    
67501>>>>>    Function IsEnabled Returns Boolean
67503>>>>>        Boolean bEnabled
67503>>>>>        Get CanCut of (Focus(Self)) to bEnabled
67504>>>>>        Function_Return bEnabled
67505>>>>>    End_Function
67506>>>>>    
67506>>>>>End_Class
67507>>>>>
67507>>>>>
67507>>>>>Class cCJCopyMenuItem is a cCJMenuItem
67508>>>>>    
67508>>>>>    Procedure Construct_Object
67510>>>>>        Forward Send Construct_Object
67512>>>>>        Set psCaption   to C_$CaptionCopy
67513>>>>>        Set psToolTip to C_$ToolTipCopy
67514>>>>>        Set psDescription to C_$DescCopy
67515>>>>>        Set psImage to "actionCopy.ico"
67516>>>>>        Set psShortcut to C_$Key_Ctrl_C
67517>>>>>        Set pbActiveUpdate to True
67518>>>>>        Set psCategory to C_$CategoryEdit
67519>>>>>    End_Procedure
67520>>>>>    
67520>>>>>    
67520>>>>>    Procedure OnExecute Variant vCommandBarControl
67522>>>>>        Send Copy of (focus(Self))
67523>>>>>    End_Procedure
67524>>>>>    
67524>>>>>    Function IsEnabled Returns Boolean
67526>>>>>        Boolean bEnabled
67526>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
67527>>>>>        Function_Return bEnabled
67528>>>>>    End_Function
67529>>>>>    
67529>>>>>End_Class
67530>>>>>
67530>>>>>
67530>>>>>Class cCJPasteMenuItem is a cCJMenuItem
67531>>>>>    
67531>>>>>    Procedure Construct_Object
67533>>>>>        Forward Send Construct_Object
67535>>>>>        Set psCaption   to C_$CaptionPaste
67536>>>>>        Set psToolTip to C_$ToolTipPaste
67537>>>>>        Set psDescription to C_$DescPaste
67538>>>>>        Set psImage to "actionPaste.ico"
67539>>>>>        Set pbActiveUpdate to True
67540>>>>>        Set psShortcut to C_$Key_Ctrl_V
67541>>>>>        Set psCategory to C_$CategoryEdit
67542>>>>>    End_Procedure
67543>>>>>    
67543>>>>>    
67543>>>>>    Procedure OnExecute Variant vCommandBarControl
67545>>>>>        Send Paste of (focus(Self))
67546>>>>>    End_Procedure
67547>>>>>    
67547>>>>>    Function IsEnabled Returns Boolean
67549>>>>>        Boolean bEnabled
67549>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
67550>>>>>        Function_Return bEnabled
67551>>>>>    End_Function
67552>>>>>    
67552>>>>>End_Class
67553>>>>>
67553>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
67554>>>>>    
67554>>>>>    Procedure Construct_Object
67556>>>>>        Forward Send Construct_Object
67558>>>>>        Set psCaption   to C_$CaptionSelectAll
67559>>>>>        Set psToolTip to C_$ToolTipSelectAll
67560>>>>>        Set psDescription to C_$DescSelectAll
67561>>>>>        Set pbActiveUpdate to True
67562>>>>>        Set psShortcut to C_$Key_Ctrl_A
67563>>>>>        Set psCategory to C_$CategoryEdit
67564>>>>>    End_Procedure
67565>>>>>    
67565>>>>>    
67565>>>>>    Procedure OnExecute Variant vCommandBarControl
67567>>>>>        Send Select_All of (focus(Self))
67568>>>>>    End_Procedure
67569>>>>>    
67569>>>>>    Function IsEnabled Returns Boolean
67571>>>>>        Boolean bEnabled
67571>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
67572>>>>>        Function_Return bEnabled
67573>>>>>    End_Function
67574>>>>>    
67574>>>>>End_Class
67575>>>>>
67575>>>>>
67575>>>>>Class cCJExitMenuItem is a cCJMenuItem
67576>>>>>    
67576>>>>>    Procedure Construct_Object
67578>>>>>        Forward Send Construct_Object
67580>>>>>        Set psCaption to C_$CaptionExit
67581>>>>>        Set psToolTip to C_$ToolTipExit
67582>>>>>        Set psDescription to C_$ToolTipExit
67583>>>>>        Set psShortcut to C_$Key_Alt_F4
67584>>>>>        Set psCategory to C_$CategoryFile
67585>>>>>    End_Procedure
67586>>>>>    
67586>>>>>    Procedure OnExecute Variant vCommandBarControl
67588>>>>>        Send Exit_Application of Desktop
67589>>>>>    End_Procedure
67590>>>>>    
67590>>>>>End_Class
67591>>>>>
67591>>>>>Class cCJHelpMenuItem is a cCJMenuItem
67592>>>>>    
67592>>>>>    Procedure Construct_Object
67594>>>>>        Forward Send Construct_Object
67596>>>>>        Set psCaption to C_$CaptionHelp
67597>>>>>        Set psDescription to C_$ToolTipHelp
67598>>>>>        Set psToolTip to C_$DescHelp
67599>>>>>        Set psImage to "ActionHelp.ico"
67600>>>>>        Set psShortcut to "F1"
67601>>>>>        Set psCategory to C_$CategoryHelp
67602>>>>>    End_Procedure
67603>>>>>    
67603>>>>>    Procedure OnExecute Variant vCommandBarControl
67605>>>>>        Send Help of (Focus(Self))
67606>>>>>    End_Procedure
67607>>>>>    
67607>>>>>End_Class
67608>>>>>
67608>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
67609>>>>>    
67609>>>>>    Procedure Construct_Object
67611>>>>>        Forward Send Construct_Object
67613>>>>>        Set psCaption to C_$CaptionAddStatusbar
67614>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
67615>>>>>        Set psDescription to  C_$DescAddStatusbar
67616>>>>>        Set psCategory to C_$CategoryWindow
67617>>>>>    End_Procedure
67618>>>>>    
67618>>>>>    Procedure OnExecute Variant vCommandBarControl
67620>>>>>        Handle hoCommandBars hoClientArea
67620>>>>>        Get CommandBarSystemObject to hoCommandBars
67621>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67622>>>>>        If hoClientArea Begin
67624>>>>>            // the clientarea's parent panel has message
67624>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
67625>>>>>        End
67625>>>>>>
67625>>>>>    End_Procedure
67626>>>>>    
67626>>>>>    Function IsChecked Returns Boolean
67628>>>>>        Boolean bOn
67628>>>>>        Handle hoCommandBars hoClientArea
67628>>>>>        Get CommandBarSystemObject to hoCommandBars
67629>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67630>>>>>        If hoClientArea Begin
67632>>>>>            // the clientarea's parent panel has message
67632>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
67633>>>>>        End
67633>>>>>>
67633>>>>>        Function_Return bOn
67634>>>>>    End_Function
67635>>>>>End_Class
67636>>>>>
67636>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
67637>>>>>    
67637>>>>>    Procedure Construct_Object
67639>>>>>        Forward Send Construct_Object
67641>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
67642>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
67643>>>>>        Set psDescription to C_$DescAutoArrangeIcons
67644>>>>>        Set psCategory to C_$CategoryWindow
67645>>>>>    End_Procedure
67646>>>>>    
67646>>>>>    Procedure OnExecute Variant vCommandBarControl
67648>>>>>        Handle hoCommandBars hoClientArea
67648>>>>>        Get CommandBarSystemObject to hoCommandBars
67649>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67650>>>>>        If hoClientArea Begin
67652>>>>>            // the clientarea's parent panel has message
67652>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
67653>>>>>        End
67653>>>>>>
67653>>>>>    End_Procedure
67654>>>>>    
67654>>>>>    Function IsChecked Returns Boolean
67656>>>>>        Boolean bOn
67656>>>>>        Handle hoCommandBars hoClientArea
67656>>>>>        Get CommandBarSystemObject to hoCommandBars
67657>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67658>>>>>        If hoClientArea Begin
67660>>>>>            // the clientarea's parent panel has message
67660>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
67661>>>>>        End
67661>>>>>>
67661>>>>>        Function_Return bOn
67662>>>>>    End_Function
67663>>>>>End_Class
67664>>>>>
67664>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
67665>>>>>    
67665>>>>>    Procedure Construct_Object
67667>>>>>        Forward Send Construct_Object
67669>>>>>        Set psCaption to C_$CaptionRestoreMenus
67670>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
67671>>>>>        Set psDescription to C_$DescRestoreMenus
67672>>>>>        Set psCategory to C_$CategoryWindow
67673>>>>>    End_Procedure
67674>>>>>    
67674>>>>>    Procedure OnExecute Variant vCommandBarControl
67676>>>>>        Handle hoCommandBars
67676>>>>>        Get CommandBarSystemObject to hoCommandBars
67677>>>>>        Send RestoreLayout of hoCommandBars
67678>>>>>    End_Procedure
67679>>>>>    
67679>>>>>End_Class
67680>>>>>
67680>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
67681>>>>>    
67681>>>>>    Procedure Construct_Object
67683>>>>>        Forward Send Construct_Object
67685>>>>>        Set psCaption to C_$CaptionCascade
67686>>>>>        Set psToolTip to C_$ToolTipCascade
67687>>>>>        Set psDescription to  C_$DescCascade
67688>>>>>        Set psImage to "ActionCascade.ico"
67689>>>>>        Set psCategory to C_$CategoryWindow
67690>>>>>    End_Procedure
67691>>>>>    
67691>>>>>    Procedure OnExecute Variant vCommandBarControl
67693>>>>>        Handle hoCommandBars hoClientArea
67693>>>>>        Get CommandBarSystemObject to hoCommandBars
67694>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67695>>>>>        If hoClientArea Begin
67697>>>>>            Send Cascade_Windows of hoClientArea
67698>>>>>        End
67698>>>>>>
67698>>>>>    End_Procedure
67699>>>>>End_Class
67700>>>>>
67700>>>>>Class cCJTileHorizontally is a cCJMenuItem
67701>>>>>    
67701>>>>>    Procedure Construct_Object
67703>>>>>        Forward Send Construct_Object
67705>>>>>        Set psCaption to C_$CaptionTileHorizontally
67706>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
67707>>>>>        Set psDescription to  C_$DescTileHorizontally
67708>>>>>        Set psImage to "ActionTileHorizontally.ico"
67709>>>>>        Set psCategory to C_$CategoryWindow
67710>>>>>    End_Procedure
67711>>>>>    
67711>>>>>    Procedure OnExecute Variant vCommandBarControl
67713>>>>>        Handle hoCommandBars hoClientArea
67713>>>>>        Get CommandBarSystemObject to hoCommandBars
67714>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67715>>>>>        If hoClientArea Begin
67717>>>>>            Send Tile_Windows_Horizontal of hoClientArea
67718>>>>>        End
67718>>>>>>
67718>>>>>    End_Procedure
67719>>>>>End_Class
67720>>>>>
67720>>>>>Class cCJTileVertically is a cCJMenuItem
67721>>>>>    
67721>>>>>    Procedure Construct_Object
67723>>>>>        Forward Send Construct_Object
67725>>>>>        Set psCaption to C_$CaptionTileVertically
67726>>>>>        Set psToolTip to C_$ToolTipTileVertically
67727>>>>>        Set psDescription to  C_$DescTileVertically
67728>>>>>        Set psImage to "ActionTileVertically.ico"
67729>>>>>        Set psCategory to C_$CategoryWindow
67730>>>>>    End_Procedure
67731>>>>>    
67731>>>>>    Procedure OnExecute Variant vCommandBarControl
67733>>>>>        Handle hoCommandBars hoClientArea
67733>>>>>        Get CommandBarSystemObject to hoCommandBars
67734>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67735>>>>>        If hoClientArea Begin
67737>>>>>            Send Tile_Windows_Vertical of hoClientArea
67738>>>>>        End
67738>>>>>>
67738>>>>>    End_Procedure
67739>>>>>End_Class
67740>>>>>
67740>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
67741>>>>>    
67741>>>>>    Procedure Construct_Object
67743>>>>>        Forward Send Construct_Object
67745>>>>>        Set psCaption to C_$CaptionMinimizeWindows
67746>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
67747>>>>>        Set psDescription to  C_$DescMinimizeWindows
67748>>>>>        Set psCategory to C_$CategoryWindow
67749>>>>>    End_Procedure
67750>>>>>    
67750>>>>>    Procedure OnExecute Variant vCommandBarControl
67752>>>>>        Handle hoCommandBars hoClientArea
67752>>>>>        Get CommandBarSystemObject to hoCommandBars
67753>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67754>>>>>        If hoClientArea Begin
67756>>>>>            // the clientarea's parent panel has message
67756>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
67757>>>>>        End
67757>>>>>>
67757>>>>>    End_Procedure
67758>>>>>End_Class
67759>>>>>
67759>>>>>
67759>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
67760>>>>>    
67760>>>>>    Procedure Construct_Object
67762>>>>>        Forward Send Construct_Object
67764>>>>>        Set psCaption to C_$CaptionRestoreWindows
67765>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
67766>>>>>        Set psDescription to  C_$DescRestoreWindows
67767>>>>>        Set psCategory to C_$CategoryWindow
67768>>>>>    End_Procedure
67769>>>>>    
67769>>>>>    Procedure OnExecute Variant vCommandBarControl
67771>>>>>        Handle hoCommandBars hoClientArea
67771>>>>>        Get CommandBarSystemObject to hoCommandBars
67772>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67773>>>>>        If hoClientArea Begin
67775>>>>>            // the clientarea's parent panel has message
67775>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
67776>>>>>        End
67776>>>>>>
67776>>>>>    End_Procedure
67777>>>>>End_Class
67778>>>>>
67778>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
67779>>>>>    
67779>>>>>    Procedure Construct_Object
67781>>>>>        Forward Send Construct_Object
67783>>>>>        Set psCaption to C_$CaptionArrangeIcons
67784>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
67785>>>>>        Set psDescription to  C_$DescArrangeIcons
67786>>>>>        Set psCategory to C_$CategoryWindow
67787>>>>>    End_Procedure
67788>>>>>    
67788>>>>>    Procedure OnExecute Variant vCommandBarControl
67790>>>>>        Handle hoCommandBars hoClientArea
67790>>>>>        Get CommandBarSystemObject to hoCommandBars
67791>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67792>>>>>        If hoClientArea Begin
67794>>>>>            Send Arrange_Icons of hoClientArea
67795>>>>>        End
67795>>>>>>
67795>>>>>    End_Procedure
67796>>>>>    
67796>>>>>End_Class
67797>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
67797>>>>>Use cCJCommandBarSystem.pkg
67797>>>>>Use LanguageText.pkg
67797>>>>>
67797>>>>>// It is expected that if you use this class that you provide an about object that is
67797>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
67797>>>>>// because you may wish to create your own custom about package.
67797>>>>>
67797>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
67798>>>>>
67798>>>>>    Procedure Construct_Object
67800>>>>>        Forward Send Construct_Object
67802>>>>>        Set psCaption to C_$CaptionAbout
67803>>>>>        Set psDescription to C_$ToolTipAbout
67804>>>>>        Set psToolTip to C_$DescAbout
67805>>>>>        Set psImage to "ActionAbout.ico"
67806>>>>>        Set psCategory to C_$CategoryHelp
67807>>>>>    End_Procedure
67808>>>>>    
67808>>>>>    Procedure OnExecute Variant vCommandBarControl
67810>>>>>        Handle hoCommandBars hoClientArea
67810>>>>>        Get CommandBarSystemObject to hoCommandBars
67811>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67812>>>>>        If hoClientArea Begin
67814>>>>>            Send Activate_About of hoClientArea
67815>>>>>        End
67815>>>>>>
67815>>>>>    End_Procedure
67816>>>>>
67816>>>>>End_Class
67817>>>>>
67817>>>>>
67817>>>Use cCJDeoMenuItemClasses.pkg
67817>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
67817>>>>>Use cCJCommandBarSystem.pkg
67817>>>>>
67817>>>>>Register_Function Client_ID Returns Integer
67817>>>>>
67817>>>>>// only used by cCJMDIWIndowsMenuItem
67817>>>>>Class cCJMDIWindowItem is a cCJMenuItem
67818>>>>>    
67818>>>>>    Procedure Construct_Object
67820>>>>>        Forward Send Construct_Object
67822>>>>>        Property Handle phWindow 0 // object id of view
67823>>>>>        Set pbControlFlagNoMovable to True
67824>>>>>        Set pbActiveUpdate to True
67825>>>>>    End_Procedure
67826>>>>>    
67826>>>>>    Procedure OnExecute Variant vCommandBarControl
67828>>>>>        Handle hWindow
67828>>>>>        Get phWindow to hWindow
67829>>>>>        Send Activate_View of hWindow
67830>>>>>    End_Procedure
67831>>>>>    
67831>>>>>End_Class
67832>>>>>
67832>>>>>
67832>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
67833>>>>>    
67833>>>>>    Procedure Construct_Object
67835>>>>>        Forward Send Construct_Object
67837>>>>>        Property Handle[] phArrayOfWindows
67838>>>>>        Set peControlType to xtpControlPopup
67839>>>>>        Set psCategory to C_$CategoryWindow
67840>>>>>    End_Procedure
67841>>>>>    
67841>>>>>    // This adds MDI windows to the existing menu items.
67841>>>>>    // This removes any existing windows menus and always adds a new set to the end
67841>>>>>    
67841>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
67843>>>>>        Handle  hClientArea hView
67843>>>>>        String  sLabel
67843>>>>>        Integer i iWindows
67843>>>>>        Handle[] hArrayOfWindows
67844>>>>>        Variant vItem
67844>>>>>        
67844>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
67844>>>>>        // also assume that destroying an action removes all menu instances of that action
67844>>>>>        Get phArrayOfWindows to hArrayOfWindows
67845>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
67846>>>>>        For i from 0 to (iWindows-1)
67852>>>>>>
67852>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
67853>>>>>        Loop
67854>>>>>>
67854>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
67855>>>>>        
67855>>>>>        // Add all views to this menu. Create the action and add the item
67855>>>>>        Move 0 to i
67856>>>>>        Get Client_Id to hClientArea // object id of client area
67857>>>>>        If (hClientArea > 0) Begin
67859>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
67860>>>>>            While (hView <> 0)
67864>>>>>                If (Active_State(hView)) Begin
67866>>>>>                    // create the action
67866>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
67867>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
67868>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
67869>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
67870>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
67872>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
67873>>>>>                    End
67873>>>>>>
67873>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
67874>>>>>                    If (i=0) Begin
67876>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
67877>>>>>                    End
67877>>>>>>
67877>>>>>                    // Create a menu item for this action
67877>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
67878>>>>>                    Increment i
67879>>>>>                End
67879>>>>>>
67879>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
67880>>>>>            Loop
67881>>>>>>
67881>>>>>        End
67881>>>>>>
67881>>>>>        
67881>>>>>        Set phArrayOfWindows to hArrayOfWindows
67882>>>>>        
67882>>>>>    End_Procedure
67883>>>>>    
67883>>>>>End_Class
67884>
67884>Object oHtmlHelp is a cHtmlHelp
67886>End_Object
67887>
67887>Object oApplication is a cApplication
67889>    Set peHelpType to htHtmlHelp
67890>
67890>    Object oConnection is a cConnection
67892>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\LoginEncryption.pkg)
67892>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cLoginEncryption.pkg)
67892>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
67892>>>>>>>Use VdfBase.pkg
67892>>>>>>>
67892>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
67892>>>>>>>>>//   Author  : Ulbe Stellema
67892>>>>>>>>>// Algorithm classes
67892>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
67892>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
67892>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
67892>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
67892>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
67892>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
67892>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
67892>>>>>>>>>
67892>>>>>>>>>// Algorithm types
67892>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
67892>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
67892>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
67892>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
67892>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
67892>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
67892>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
67892>>>>>>>>>
67892>>>>>>>>>// Generic sub-ids
67892>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
67892>>>>>>>>>
67892>>>>>>>>>// RSA sub-ids
67892>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
67892>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
67892>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
67892>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
67892>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
67892>>>>>>>>>
67892>>>>>>>>>// DSS sub-ids
67892>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
67892>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
67892>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
67892>>>>>>>>>
67892>>>>>>>>>// DES sub_ids
67892>>>>>>>>>Define ALG_SID_DES                      for 1
67892>>>>>>>>>Define ALG_SID_3DES                     for 3
67892>>>>>>>>>Define ALG_SID_DESX                     for 4
67892>>>>>>>>>Define ALG_SID_IDEA                     for 5
67892>>>>>>>>>Define ALG_SID_CAST                     for 6
67892>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
67892>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
67892>>>>>>>>>Define ALG_SID_3DES_112                 for 9
67892>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
67892>>>>>>>>>Define ALG_SID_RC5                      for 13
67892>>>>>>>>>Define ALG_SID_AES_128                  for 14
67892>>>>>>>>>Define ALG_SID_AES_192                  for 15
67892>>>>>>>>>Define ALG_SID_AES_256                  for 16
67892>>>>>>>>>Define ALG_SID_AES                      for 17
67892>>>>>>>>>
67892>>>>>>>>>// Fortezza sub-ids
67892>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
67892>>>>>>>>>Define ALG_SID_TEK                      for 11
67892>>>>>>>>>
67892>>>>>>>>>// RC2 sub-ids
67892>>>>>>>>>Define ALG_SID_RC2                      for 2
67892>>>>>>>>>
67892>>>>>>>>>// Stream cipher sub-ids
67892>>>>>>>>>Define ALG_SID_RC4                      for 1
67892>>>>>>>>>Define ALG_SID_SEAL                     for 2
67892>>>>>>>>>
67892>>>>>>>>>// Diffie-Hellman sub-ids
67892>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
67892>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
67892>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
67892>>>>>>>>>Define ALG_SID_KEA                      for 4
67892>>>>>>>>>
67892>>>>>>>>>// Hash sub ids
67892>>>>>>>>>Define ALG_SID_MD2                      for 1
67892>>>>>>>>>Define ALG_SID_MD4                      for 2
67892>>>>>>>>>Define ALG_SID_MD5                      for 3
67892>>>>>>>>>Define ALG_SID_SHA                      for 4
67892>>>>>>>>>Define ALG_SID_SHA1                     for 4
67892>>>>>>>>>Define ALG_SID_MAC                      for 5
67892>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
67892>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
67892>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
67892>>>>>>>>>Define ALG_SID_HMAC                     for 9
67892>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
67892>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
67892>>>>>>>>>Define ALG_SID_SHA_256                  for 12
67892>>>>>>>>>Define ALG_SID_SHA_384                  for 13
67892>>>>>>>>>Define ALG_SID_SHA_512                  for 14
67892>>>>>>>>>
67892>>>>>>>>>// secure channel sub ids
67892>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
67892>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
67892>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
67892>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
67892>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
67892>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
67892>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
67892>>>>>>>>>
67892>>>>>>>>>// algorithm identifier definitions
67892>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
67892>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
67892>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
67892>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
67892>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
67892>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
67892>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
67892>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
67892>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
67892>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
67892>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
67892>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
67892>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
67892>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
67892>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
67892>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
67892>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
67892>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
67892>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
67892>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
67892>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
67892>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
67892>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
67892>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
67892>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
67892>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
67892>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
67892>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
67892>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
67892>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
67892>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
67892>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
67892>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
67892>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
67892>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
67892>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
67892>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
67892>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
67892>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
67892>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
67892>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
67892>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
67892>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
67892>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
67892>>>>>>>>>
67892>>>>>>>>>// Providers
67892>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
67892>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
67892>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
67892>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
67892>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
67892>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
67892>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
67892>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
67892>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
67892>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
67892>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
67892>>>>>>>>>
67892>>>>>>>>>// dwFlags definitions for CryptAcquireContext
67892>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
67892>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
67892>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
67892>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
67892>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
67892>>>>>>>>>
67892>>>>>>>>>// dwFlag definitions for CryptGenKey
67892>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
67892>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
67892>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
67892>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
67892>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
67892>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
67892>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
67892>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
67892>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
67892>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
67892>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
67892>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
67892>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
67892>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
67892>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
67892>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
67892>>>>>>>>>
67892>>>>>>>>>// Provider types
67892>>>>>>>>>Define PROV_RSA_FULL                    for 1
67892>>>>>>>>>Define PROV_RSA_SIG                     for 2
67892>>>>>>>>>Define PROV_DSS                         for 3
67892>>>>>>>>>Define PROV_FORTEZZA                    for 4
67892>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
67892>>>>>>>>>Define PROV_SSL                         for 6
67892>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
67892>>>>>>>>>Define PROV_DSS_DH                      for 13
67892>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
67892>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
67892>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
67892>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
67892>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
67892>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
67892>>>>>>>>>Define PROV_RNG                         for 21
67892>>>>>>>>>Define PROV_INTEL_SEC                   for 22
67892>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
67892>>>>>>>>>Define PROV_RSA_AES                     for 24
67892>>>>>>>>>
67892>>>>>>>>>// KP_MODE
67892>>>>>>>>>// KP_MODE
67892>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
67892>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
67892>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
67892>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
67892>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
67892>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
67892>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
67892>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
67892>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
67892>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
67892>>>>>>>>>
67892>>>>>>>>>// dwParam definitions for CryptGetKeyParam
67892>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
67892>>>>>>>>>Define KP_SALT                          for 2       // Salt value
67892>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
67892>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
67892>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
67892>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
67892>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
67892>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
67892>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
67892>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
67892>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
67892>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
67892>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
67892>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
67892>>>>>>>>>Define KP_Y                             for 15      // Y value
67892>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
67892>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
67892>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
67892>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
67892>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
67892>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
67892>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
67892>>>>>>>>>Define KP_RP                            for 23
67892>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
67892>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
67892>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
67892>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
67892>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
67892>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
67892>>>>>>>>>Define KP_KEYVAL                        for 30
67892>>>>>>>>>Define KP_ADMIN_PIN                     for 31
67892>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
67892>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
67892>>>>>>>>>Define KP_PREHASH                       for 34
67892>>>>>>>>>Define KP_ROUNDS                        for 35
67892>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
67892>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
67892>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
67892>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
67892>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
67892>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
67892>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
67892>>>>>>>>>
67892>>>>>>>>>// dwParam definitions for CryptGetHashParam
67892>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
67892>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
67892>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
67892>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
67892>>>>>>>>>
67892>>>>>>>>>// key BLOB types
67892>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
67892>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
67892>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
67892>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
67892>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
67892>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
67892>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
67892>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
67892>>>>>>>>>
67892>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
67892>>>>>>>>>
67892>>>>>>>>>//  Structure cryptimportkey
67892>>>>>>>>>Struct PUBLICKEYSTRUC
67892>>>>>>>>>    UChar    bType
67892>>>>>>>>>    UChar    bVersion
67892>>>>>>>>>    UShort   reserved
67892>>>>>>>>>    UInteger aiKeyAlg
67892>>>>>>>>>End_Struct
67892>>>>>>>>>
67892>>>>>>>>>Struct tPLAINTEXTKEYBLOB
67892>>>>>>>>>    PUBLICKEYSTRUC hdr
67892>>>>>>>>>    PUBLICKEYSTRUC hdr
67892>>>>>>>>>    UInteger       dwKeySize
67892>>>>>>>>>//    UChar[]        rgbKeyData
67892>>>>>>>>>End_Struct
67892>>>>>>>>>
67892>>>>>>>>>
67892>>>>>>>>>
67892>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
67892>>>>>>>>>Struct HMAC_INFO
67892>>>>>>>>>    UInteger HashAlgid
67892>>>>>>>>>    Pointer pbInnerString
67892>>>>>>>>>    DWord cbInnerString
67892>>>>>>>>>    Pointer pbOuterString
67892>>>>>>>>>    DWord cbOuterString
67892>>>>>>>>>End_Struct
67892>>>>>>>>>
67892>>>>>>>>>
67892>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
67893>>>>>>>>>
67893>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
67894>>>>>>>>>
67894>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
67895>>>>>>>>>
67895>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
67896>>>>>>>>>
67896>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
67897>>>>>>>>>
67897>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
67898>>>>>>>>>
67898>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
67899>>>>>>>>>
67899>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
67900>>>>>>>>>
67900>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
67901>>>>>>>>>
67901>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
67902>>>>>>>>>    
67902>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
67903>>>>>>>>>
67903>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
67904>>>>>>>>>
67904>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
67905>>>>>>>>>
67905>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
67906>>>>>>>>>    
67906>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
67907>>>>>>>>>    
67907>>>>>>>
67907>>>>>>>Class cCryptographer is a cObject
67908>>>>>>>    
67908>>>>>>>    Procedure Construct_Object
67910>>>>>>>        Forward Send Construct_Object
67912>>>>>>>        
67912>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
67913>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
67914>>>>>>>        Property Integer    piCipher    CALG_RC4
67915>>>>>>>        Property Integer    piHash      CALG_MD5
67916>>>>>>>        
67916>>>>>>>        // Private properties
67916>>>>>>>        Property Handle     Private_phProv
67917>>>>>>>    End_Procedure
67918>>>>>>>    
67918>>>>>>>    
67918>>>>>>>    // Acquire key container handle
67918>>>>>>>    Function AcquireContext Returns Handle
67920>>>>>>>        Integer iProvider
67920>>>>>>>        String sProvider
67920>>>>>>>        Handle hProv
67920>>>>>>>        Boolean bOk
67920>>>>>>>        Address addrProv
67920>>>>>>>        
67920>>>>>>>        Move 0 to hProv
67921>>>>>>>        Get piProvider to iProvider
67922>>>>>>>        Get psProvider to sProvider
67923>>>>>>>        
67923>>>>>>>        //  Determine address to be passed as provider
67923>>>>>>>        If (Trim(sProvider) <> "") Begin
67925>>>>>>>            Move (AddressOf(sProvider)) to addrProv
67926>>>>>>>        End
67926>>>>>>>>
67926>>>>>>>        Else Begin
67927>>>>>>>            Move 0 to addrProv
67928>>>>>>>        End
67928>>>>>>>>
67928>>>>>>>        
67928>>>>>>>        //  Acquire Crypto Context
67928>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
67929>>>>>>>        If (not(bOk) or hProv = 0) Begin
67931>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
67932>>>>>>>        End
67932>>>>>>>>
67932>>>>>>>        
67932>>>>>>>        If (not(bOk) or hProv = 0) Begin
67934>>>>>>>            // Fallback to original
67934>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
67935>>>>>>>            
67935>>>>>>>            If (not(bOk) or hProv = 0) Begin
67937>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
67938>>>>>>>            End
67938>>>>>>>>
67938>>>>>>>        End
67938>>>>>>>>
67938>>>>>>>        Set Private_phProv to hProv
67939>>>>>>>        
67939>>>>>>>        Function_Return hProv
67940>>>>>>>    End_Function
67941>>>>>>>    
67941>>>>>>>    // Releases key container handle
67941>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
67943>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
67944>>>>>>>    End_Function
67945>>>>>>>    
67945>>>>>>>    // Creates hash object
67945>>>>>>>    Function CreateHash Handle hProv Returns Handle
67947>>>>>>>        Integer iAlgorithm
67947>>>>>>>        Handle hHash
67947>>>>>>>        Boolean bOk
67947>>>>>>>        
67947>>>>>>>        Move 0 to hHash
67948>>>>>>>        Get piHash to iAlgorithm
67949>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
67950>>>>>>>        
67950>>>>>>>        Function_Return hHash
67951>>>>>>>    End_Function
67952>>>>>>>    
67952>>>>>>>    // Destroys the hash object
67952>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
67954>>>>>>>        Function_Return (CryptDestroyHash(hHash))
67955>>>>>>>    End_Function
67956>>>>>>>    
67956>>>>>>>    // Adds data to hash object
67956>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
67958>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
67959>>>>>>>    End_Function
67960>>>>>>>    
67960>>>>>>>    // Generates session key
67960>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
67962>>>>>>>        Integer iAlgorithm
67962>>>>>>>        Handle hKey
67962>>>>>>>        Boolean bOk
67962>>>>>>>        
67962>>>>>>>        Move 0 to hKey
67963>>>>>>>        Get piCipher to iAlgorithm
67964>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
67965>>>>>>>        
67965>>>>>>>        Function_Return hKey
67966>>>>>>>    End_Function
67967>>>>>>>    
67967>>>>>>>    // Imports a plain text key
67967>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
67969>>>>>>>        tPLAINTEXTKEYBLOB blobhead
67969>>>>>>>        tPLAINTEXTKEYBLOB blobhead
67969>>>>>>>        Boolean   bSuccess
67969>>>>>>>        Handle    hKey
67969>>>>>>>        Integer   iHeadSize iKeySize
67969>>>>>>>        UChar[]   ucaKeyblob
67970>>>>>>>        Integer iVoid
67970>>>>>>>        
67970>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
67971>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
67972>>>>>>>        
67972>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
67973>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
67974>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
67975>>>>>>>        Move iKeySize           to blobhead.dwKeySize
67976>>>>>>>        
67976>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
67977>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
67978>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
67979>>>>>>>        
67979>>>>>>>        Move 0 to hKey
67980>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
67981>>>>>>>        If (not(bSuccess)) Begin
67983>>>>>>>            Move (ShowLastError()) to iVoid
67984>>>>>>>        End
67984>>>>>>>>
67984>>>>>>>        
67984>>>>>>>        Function_Return hKey
67985>>>>>>>    End_Function
67986>>>>>>>    
67986>>>>>>>    // Destroys the key
67986>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
67988>>>>>>>        Function_Return (CryptDestroyKey(hKey))
67989>>>>>>>    End_Function
67990>>>>>>>    
67990>>>>>>>    // Retrieves key data
67990>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
67992>>>>>>>        Integer iBuffer iLen
67992>>>>>>>        Boolean bOk
67992>>>>>>>        
67992>>>>>>>        Move (SizeOfType(Integer)) to iLen
67993>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
67994>>>>>>>        Function_Return iBuffer
67995>>>>>>>    End_Function
67996>>>>>>>    
67996>>>>>>>    // Retrieves a hash value
67996>>>>>>>    Function HashValue Handle lhHash Returns String
67998>>>>>>>        String  lsHash
67998>>>>>>>        Integer liResult
67998>>>>>>>        DWord   dwDataLen
67998>>>>>>>        
67998>>>>>>>        Move 0 to dwDataLen
67999>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
68000>>>>>>>        If (liResult = 0) ;            Function_Return ""
68003>>>>>>>        
68003>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
68004>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
68005>>>>>>>        If (liResult = 0) ;            Function_Return ""
68008>>>>>>>        
68008>>>>>>>        Function_Return lsHash
68009>>>>>>>    End_Function
68010>>>>>>>
68010>>>>>>>    // Encrypts data
68010>>>>>>>    Function Encrypt String sPassword String sData Returns String
68012>>>>>>>        Handle hProv hHash hKey
68012>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
68012>>>>>>>        Boolean bOk
68012>>>>>>>        
68012>>>>>>>        Get AcquireContext to hProv
68013>>>>>>>        If (hProv) Begin
68015>>>>>>>            Get CreateHash hProv to hHash
68016>>>>>>>            If (hHash) Begin
68018>>>>>>>                Get HashData hHash sPassword to bOk
68019>>>>>>>                If (bOk) Begin
68021>>>>>>>                    Get piCipher to iAlgorithm
68022>>>>>>>                    Get DeriveKey hProv hHash to hKey
68023>>>>>>>                End
68023>>>>>>>>
68023>>>>>>>                Get DestroyHash hHash to bOk
68024>>>>>>>            End
68024>>>>>>>>
68024>>>>>>>            
68024>>>>>>>            If (hKey) Begin
68026>>>>>>>                //  First call to determine resulting data size
68026>>>>>>>                Move (Length(sData)) to iDataLen
68027>>>>>>>                Move (Length(sData)) to iCipherLen
68028>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
68029>>>>>>>                
68029>>>>>>>                //  Reserve space in string
68029>>>>>>>                If (iDataLen < iCipherLen) Begin
68031>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
68032>>>>>>>                End
68032>>>>>>>>
68032>>>>>>>                
68032>>>>>>>                //  Call to really decrypt
68032>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
68033>>>>>>>                //If (not(bOk)) Begin
68033>>>>>>>                //Move "" to sData
68033>>>>>>>                //Move (GetLastError()) to iErr
68033>>>>>>>                //End
68033>>>>>>>                
68033>>>>>>>                Get DestroyKey hKey to bOk
68034>>>>>>>            End 
68034>>>>>>>>
68034>>>>>>>            Get ReleaseContext hProv to bOk
68035>>>>>>>        End 
68035>>>>>>>>
68035>>>>>>>        Function_Return sData
68036>>>>>>>    End_Function
68037>>>>>>>    
68037>>>>>>>    // Decrypts data
68037>>>>>>>    Function Decrypt String sPassword String sData Returns String
68039>>>>>>>        Handle hProv hHash hKey
68039>>>>>>>        Integer iAlgorithm iDataLen
68039>>>>>>>        Boolean bOk
68039>>>>>>>        
68039>>>>>>>        Get AcquireContext to hProv
68040>>>>>>>        If (hProv) Begin
68042>>>>>>>            Get CreateHash hProv to hHash
68043>>>>>>>            If (hHash) Begin
68045>>>>>>>                Get HashData hHash sPassword to bOk
68046>>>>>>>                If (bOk) Begin
68048>>>>>>>                    Get piCipher to iAlgorithm
68049>>>>>>>                    Get DeriveKey hProv hHash to hKey
68050>>>>>>>                End
68050>>>>>>>>
68050>>>>>>>                Get DestroyHash hHash to bOk
68051>>>>>>>            End
68051>>>>>>>>
68051>>>>>>>            
68051>>>>>>>            If (hKey) Begin
68053>>>>>>>                Move (Length(sData)) to iDataLen
68054>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
68055>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
68055>>>>>>>                If (Length(sData) > iDataLen) Begin
68057>>>>>>>                    Move (Left(sData, iDataLen)) to sData
68058>>>>>>>                End
68058>>>>>>>>
68058>>>>>>>                
68058>>>>>>>                Get DestroyKey hKey to bOk
68059>>>>>>>            End
68059>>>>>>>>
68059>>>>>>>            Get ReleaseContext hProv to bOk
68060>>>>>>>        End
68060>>>>>>>>
68060>>>>>>>        Function_Return sData
68061>>>>>>>    End_Function
68062>>>>>>>    
68062>>>>>>>    //  Generates random data.
68062>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
68064>>>>>>>        Handle hProv
68064>>>>>>>        UChar[] uaResult
68065>>>>>>>        Boolean bRes
68065>>>>>>>        
68065>>>>>>>        Get AcquireContext to hProv
68066>>>>>>>        
68066>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
68067>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
68068>>>>>>>        
68068>>>>>>>        Get ReleaseContext hProv to bRes
68069>>>>>>>        
68069>>>>>>>        Function_Return uaResult
68070>>>>>>>    End_Function
68071>>>>>>>    
68071>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
68071>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
68073>>>>>>>        String sResult
68073>>>>>>>        UChar[] aData
68074>>>>>>>        Address pBase64
68074>>>>>>>        Integer iVoid
68074>>>>>>>        
68074>>>>>>>        Get GenerateRandom iLenght to aData
68075>>>>>>>        
68075>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
68076>>>>>>>        Move pBase64 to sResult
68077>>>>>>>        Move (Free(pBase64)) to iVoid
68078>>>>>>>        
68078>>>>>>>        Function_Return (Left(sResult, iLenght))
68079>>>>>>>    End_Function
68080>>>>>>>    
68080>>>>>>>End_Class
68081>>>>>
68081>>>>>Class cLoginEncryption is a cObject
68082>>>>>    
68082>>>>>    Procedure Construct_Object
68084>>>>>        Forward Send Construct_Object
68086>>>>>        // this must be set to a multi (40ish) character random key
68086>>>>>        Property String psEncryptPassword ""
68087>>>>>        
68087>>>>>        Object oDataCrypter is a cCryptographer
68089>>>>>            Set piHash to CALG_SHA_256
68090>>>>>            Set piCipher to CALG_AES_256
68091>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
68092>>>>>            Set piProvider to PROV_RSA_AES
68093>>>>>        End_Object
68094>>>>>    End_Procedure
68095>>>>>    
68095>>>>>    // This can be augmented to return a password encryption key using any
68095>>>>>    // hidden mechanism desired.
68095>>>>>    Function GetEncryptionPassword Returns String
68097>>>>>        String sPassword
68097>>>>>        Get psEncryptPassword to sPassword
68098>>>>>        Function_Return sPassword
68099>>>>>    End_Function
68100>>>>>    
68100>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
68100>>>>>    //
68100>>>>>    // Params:
68100>>>>>    //   sPlainText     String to encrypt.
68100>>>>>    // Returns:
68100>>>>>    //   Base64 encoded hash.
68100>>>>>    Function EncryptPassword String sPlainText Returns String
68102>>>>>        String sEncryptPassword sBinary sBase64
68102>>>>>        Address pBase64
68102>>>>>        Integer iVoid
68102>>>>>        
68102>>>>>        //  Encrypt Key
68102>>>>>        Get GetEncryptionPassword to sEncryptPassword
68103>>>>>        If (sEncryptPassword = "") Begin
68105>>>>>            Error DFERR_PROGRAM "No encryption password set"
68106>>>>>>
68106>>>>>        End
68106>>>>>>
68106>>>>>        
68106>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
68107>>>>>        
68107>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
68109>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
68110>>>>>>
68110>>>>>            Function_Return ""
68111>>>>>        End
68111>>>>>>
68111>>>>>        
68111>>>>>        //  Encode binary hash to Base64
68111>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
68112>>>>>        Move pBase64 to sBase64
68113>>>>>        Move (Free(pBase64)) to iVoid
68114>>>>>        
68114>>>>>        Function_Return sBase64
68115>>>>>    End_Function
68116>>>>>    
68116>>>>>    
68116>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
68116>>>>>    //
68116>>>>>    // Params:
68116>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
68116>>>>>    // Returns:
68116>>>>>    //   Readable plain text password
68116>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
68118>>>>>        String sEncryptPassword sPlainText sBinary
68118>>>>>        Boolean bIsHex
68118>>>>>        Integer iLen iVoid
68118>>>>>        Address pBinary
68118>>>>>        
68118>>>>>        If (sBase64EncryptedPassword <> "") Begin
68120>>>>>            //  Decode from Base64
68120>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
68121>>>>>            
68121>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
68122>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
68123>>>>>            
68123>>>>>            Move (Free(pBinary)) to iVoid
68124>>>>>            
68124>>>>>            //  Encrypted binary hash to string
68124>>>>>            Get GetEncryptionPassword to sEncryptPassword
68125>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
68126>>>>>        End
68126>>>>>>
68126>>>>>        
68126>>>>>        Function_Return sPlainText
68127>>>>>    End_Function
68128>>>>>End_Class
68129>>>
68129>>>Object oLoginEncryption is a cLoginEncryption
68131>>>
68131>>>    // this must be created in your appsrc directory and must contain an encryption
68131>>>    // key that is set to psEncryptPassword. It will look something like this
68131>>>    //
68131>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
68131>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF18\DfRefactor\AppSrc\LoginEncryptionKey.inc)
68131>>>>// Studio generated login encryption key
68131>>>>Set psEncryptPassword to "?VW~>V|>uZxet:ltgovn4}zf<>bxtT%`_$TKH=)<"
68132>>>>
68132>>>    
68132>>>    // use this to register this object to your cConnection Object. This object
68132>>>    // must be created after the cConnection object
68132>>>    Move Self to ghoLoginEncryption
68133>>>End_Object
68134>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DatabaseLoginDialog.dg)
68134>>>
68134>>>Use Windows.pkg
68134>>>Use cConnection.pkg
68134>>>Use dfLine.pkg
68134>>>
68134>>>Object oDatabaseLoginDialog is a ModalPanel
68136>>>    Set Label to "Database Login"
68137>>>    Set Location to 2 2
68138>>>    Set Size to 110 211
68139>>>    
68139>>>    Property String psId
68141>>>    Property Boolean pbOk False
68143>>>    Property Boolean pbChanged False
68145>>>    Property Boolean pbAllowRemember True
68147>>>    
68147>>>    // this registers this object with the cConnection object.
68147>>>    Move Self to ghoLoginConnectDialog
68148>>>    
68148>>>    Object oUserIDForm is a Form
68150>>>        Set Label to "User Name"
68151>>>        Set Size to 12 85
68152>>>        Set Location to 34 79
68153>>>        Set Label_Col_Offset to 64
68154>>>        Set peAnchors to anTopLeftRight
68155>>>    End_Object
68156>>>    
68156>>>    Object oPwdForm is a Form
68158>>>        Set Size to 12 85
68159>>>        Set Location to 49 79
68160>>>        Set Label_Col_Offset to 64
68161>>>        Set Password_State to True
68162>>>        Set peAnchors to anTopLeftRight
68163>>>        Set Label to "Password"
68164>>>    End_Object
68165>>>    
68165>>>    Object oTrustedConnection is a CheckBox
68167>>>        Set Size to 10 50
68168>>>        Set Location to 65 79
68169>>>        Set Label to "Trusted Connection"
68170>>>    End_Object
68171>>>    
68171>>>    Object oRemember is a CheckBox
68173>>>        Set Size to 10 50
68174>>>        Set Location to 79 14
68175>>>        Set Label to "Remember and don't ask again"
68176>>>        Set Checked_State to True
68177>>>    End_Object
68178>>>    
68178>>>    Object oLogin_btn is a Button
68180>>>        Set Label to "&Login"
68181>>>        Set Location to 92 102
68182>>>        Set peAnchors to anBottomRight
68183>>>        Set Default_State to True
68184>>>        
68184>>>        Procedure OnClick
68187>>>            Boolean bTrust
68187>>>            String sUser sPwd sConn sErr sId
68187>>>            Integer iError
68187>>>            Get psId to sId
68188>>>            Get Value of oUserIDForm to sUser
68189>>>            Get Value of oPwdForm to sPwd
68190>>>            Get Checked_State of oTrustedConnection to bTrust
68191>>>            
68191>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
68192>>>            If (iError=0) Begin
68194>>>                Set pbOk to True
68195>>>                Set pbChanged to True
68196>>>                Send Close_Panel
68197>>>            End
68197>>>>
68197>>>            Else Begin
68198>>>                Get psErrorText of ghoConnection to sErr
68199>>>                Send UserError sErr "Login Error"
68200>>>            End
68200>>>>
68200>>>        End_Procedure
68201>>>    End_Object
68202>>>    
68202>>>    Object oCancel_btn is a Button
68204>>>        Set Label to "&Cancel"
68205>>>        Set Location to 92 157
68206>>>        Set peAnchors to anBottomRight
68207>>>        
68207>>>        Procedure OnClick
68210>>>            Send Close_Panel
68211>>>        End_Procedure
68212>>>    End_Object
68213>>>    
68213>>>    Object oConnectionIdInfo is a TextBox
68215>>>        Set Size to 10 50
68216>>>        Set Location to 4 14
68217>>>        Set Label to 'Connection Id='
68218>>>    End_Object
68219>>>    
68219>>>    Object oConnectionServerInfo is a TextBox
68221>>>        Set Size to 10 50
68222>>>        Set Location to 16 14
68223>>>        Set Label to 'Server'
68224>>>    End_Object
68225>>>    
68225>>>    Object oLineControl1 is a LineControl
68227>>>        Set Size to 2 202
68228>>>        Set Location to 29 5
68229>>>    End_Object
68230>>>    
68230>>>    Function LoginConnectIdDialog String sId Returns Boolean
68233>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
68233>>>        String sUser sPwd sDescription
68233>>>        tConnection Connect
68233>>>        tConnection Connect
68233>>>        
68233>>>        Get pbAllowRemember to bAllowRemember
68234>>>        
68234>>>        
68234>>>        If not bAllowRemember Begin
68236>>>            Set Enabled_State of oRemember to bRemember
68237>>>            Set Visible_State of oRemember to bRemember
68238>>>        End
68238>>>>
68238>>>        
68238>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
68239>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
68240>>>        Set Value of oConnectionServerInfo to Connect.sString
68241>>>        
68241>>>        Set psId to sId
68242>>>        Set pbOk to False
68243>>>        Set pbChanged to False
68244>>>        Set Value of oUserIDForm to Connect.sUID
68245>>>        Set Value of oPwdForm to ""
68246>>>        
68246>>>        Send Popup
68247>>>        
68247>>>        Get pbOk to bOk
68248>>>        Get pbChanged to bChanged
68249>>>        If (bChanged and bOk) Begin
68251>>>            If bAllowRemember Begin
68253>>>                Get Checked_State of oRemember to bRemember
68254>>>                If bRemember Begin
68256>>>                    Get Checked_State of oTrustedConnection to bTrusted
68257>>>                    If not (bTrusted) Begin
68259>>>                        Get Value of oUserIDForm to sUser
68260>>>                        Get Value of oPwdForm to sPwd
68261>>>                    End
68261>>>>
68261>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
68262>>>                End
68262>>>>
68262>>>            End
68262>>>>
68262>>>        End
68262>>>>
68262>>>        Function_Return bOk
68263>>>    End_Function
68264>>>    
68264>>>    
68264>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
68265>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
68266>>>End_Object
68267>>>
68267>    End_Object
68268>
68268>End_Object
68269>
68269>Object oToolTipController is a cToolTipController
68271>    Move Self to ghoToolTipController
68272>End_Object
68273>
68273>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
68273>>>Use cCJStandardMenuItemClasses.pkg
68273>>>
68273>>>Object oEditContextMenu is a cCJContextMenu
68275>>>    
68275>>>    Move Self to Default_Form_Floating_Menu_ID
68276>>>    
68276>>>    Object oUndoMenuItem is a cCJUndoMenuItem
68278>>>    End_Object
68279>>>    
68279>>>    Object oCutMenuItem is a cCJCutMenuItem
68281>>>        Set pbControlBeginGroup to True
68282>>>    End_Object
68283>>>    
68283>>>    Object oCopyMenuItem is a cCJCopyMenuItem
68285>>>    End_Object
68286>>>
68286>>>    Object oPasteMenuItem is a cCJPasteMenuItem
68288>>>    End_Object
68289>>>
68289>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
68291>>>    End_Object
68292>>>
68292>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
68294>>>        Set pbControlBeginGroup to True
68295>>>    End_Object
68296>>>
68296>>>End_Object
68297>>>
68297>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu17.pkg)
68297>>>Use Windows.pkg
68297>>>Use cCJStandardMenuItemClasses.pkg
68297>>>Use cCJDeoMenuItemClasses.pkg
68297>>>
68297>>>
68297>>>Object oDEOEditContextMenu17 is a cCJContextMenu
68299>>>    
68299>>>    Move Self to Default_dbFloating_Menu_ID
68300>>>    
68300>>>    Object oUndoMenuItem is a cCJUndoMenuItem
68302>>>    End_Object
68303>>>    
68303>>>    Object oCutMenuItem is a cCJCutMenuItem
68305>>>        Set pbControlBeginGroup to True
68306>>>    End_Object
68307>>>    
68307>>>    Object oCopyMenuItem is a cCJCopyMenuItem
68309>>>    End_Object
68310>>>
68310>>>    Object oPasteMenuItem is a cCJPasteMenuItem
68312>>>    End_Object
68313>>>
68313>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
68315>>>    End_Object
68316>>>
68316>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
68318>>>        Set pbControlBeginGroup to True
68319>>>    End_Object
68320>>>
68320>>>    Object oPromptMenuItem is a cCJPromptMenuItem
68322>>>        Set pbControlBeginGroup to True
68323>>>    End_Object
68324>>>
68324>>>    Object oFindNextMenu is a cCJFindNextMenuItem
68326>>>        Set pbControlBeginGroup to True
68327>>>    End_Object
68328>>>
68328>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
68330>>>    End_Object
68331>>>
68331>>>    Object oClearMenuItem is a cCJClearMenuItem
68333>>>        Set pbControlBeginGroup to True
68334>>>    End_Object
68335>>>
68335>>>    Object oClearAllMenu is a cCJClearAllMenuItem
68337>>>    End_Object
68338>>>
68338>>>    Object oSaveMenu is a cCJSaveMenuItem
68340>>>    End_Object
68341>>>    
68341>>>    Object oDeleteMenu is a cCJDeleteMenuItem
68343>>>    End_Object
68344>>>
68344>>>    Object oRememberitem is a cCJRememberFieldMenuItem
68346>>>        Set pbControlBeginGroup to True
68347>>>    End_Object
68348>>>
68348>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
68350>>>    End_Object
68351>>>
68351>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
68353>>>    End_Object
68354>>>
68354>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
68356>>>    End_Object
68357>>>
68357>>>End_Object
68358>
68358>Object oMain is a Panel
68360>    Set Label To "My Project"
68361>    Set Location to 4 3
68362>    Set Size to 300 450
68363>
68363>    Object oCommandBarSystem is a cCJCommandBarSystem
68365>        Set pbTimerUpdate to True
68366>        Set peVisualTheme to xtpThemeOffice2013Outlook
68367>        Set pbAutoResizeIcons to True
68368>
68368>        Procedure OnCreateCommandBars
68371>            Handle hoOptions
68371>            Get OptionsObject to hoOptions
68372>            Forward Send OnCreateCommandBars
68374>        End_Procedure
68375>
68375>        Object oMenuBar is a cCJMenuBar
68377>
68377>            Object oFileMenu is a cCJMenuItem
68379>                Set peControlType to xtpControlPopup          
68380>                Set psCaption   to "&File"
68381>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
68382>                Set psCategory to "Menus"
68383>
68383>                Object oClearMenuItem is a cCJClearMenuItem
68385>                    Set pbAddToDesignerMenu to True
68386>                End_Object
68387>
68387>                Object oClearAllMenu is a cCJClearAllMenuItem
68389>                    Set pbAddToDesignerMenu to True
68390>                End_Object
68391>
68391>                Object oPromptMenuItem is a cCJPromptMenuItem
68393>                    Set pbAddToDesignerMenu to True
68394>                    Set pbControlBeginGroup to True
68395>                End_Object
68396>
68396>                Object oFindMenuItem is a cCJFindMenuItem
68398>                    Set pbAddToDesignerMenu to True
68399>                    Set pbControlBeginGroup to True
68400>                End_Object
68401>
68401>                Object oFindNextMenu is a cCJFindNextMenuItem
68403>                    Set pbAddToDesignerMenu to True
68404>                End_Object
68405>
68405>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
68407>                    Set pbAddToDesignerMenu to True
68408>                End_Object
68409>
68409>                Object oFindFirstMenu is a cCJFindFirstMenuItem
68411>                    Set pbAddToDesignerMenu to True
68412>                End_Object
68413>
68413>                Object oFindLastMenu is a cCJFindLastMenuItem
68415>                    Set pbAddToDesignerMenu to True
68416>                End_Object
68417>
68417>                Object oSaveMenuItem is a cCJSaveMenuItem
68419>                    Set pbAddToDesignerMenu to True
68420>                    Set pbControlBeginGroup to True
68421>                End_Object
68422>
68422>                Object oDeleteMenuItem is a cCJDeleteMenuItem
68424>                    Set pbAddToDesignerMenu to True
68425>                End_Object
68426>
68426>                Object oExitMenu is a cCJExitMenuItem
68428>                    Set pbControlBeginGroup to True
68429>                End_Object
68430>
68430>            End_Object
68431>
68431>            Object oViewMenu is a cCJMenuItem
68433>                Set peControlType to xtpControlPopup
68434>                Set psCaption to "&View"
68435>                Set psToolTip to "View"
68436>                Set psDescription to "Available Views"
68437>
68437>                Object oMaintainFunctionsMenuItem is a cCJMenuItem
68439>                    Set psCaption to "Maintain Functions"
68440>                    Set psTooltip to "Maintain Functions"
68441>                
68441>                    Procedure OnExecute Variant vCommandBarControl
68444>                        Handle hoClient
68444>                        Get Client_Id to hoClient
68445>                        Send Activate_oMaintainFunctions of hoClient
68446>                    End_Procedure
68447>                End_Object
68448>            End_Object
68449>            
68449>            Object oReportMenu is a cCJMenuItem
68451>                Set peControlType to xtpControlPopup          
68452>                Set psCaption to "&Report"
68453>                Set psToolTip to "Report"
68454>                Set psDescription to "Available Reports"
68455>            End_Object
68456>
68456>            Object oNavigateMenu is a cCJMenuItem
68458>                Set peControlType to xtpControlPopup      
68459>                Set psCaption to "&Navigate"    
68460>                Set psTooltip to "Navigate"    
68461>                Set psDescription to "Move to different areas of the application"
68462>
68462>                Object oNextAreaMenu is a cCJNextAreaMenu
68464>                End_Object
68465>
68465>                Object oPriorAreaMenu is a cCJPriorAreaMenu
68467>                End_Object
68468>
68468>                Object oNextViewMenu is a cCJNextViewMenu
68470>                End_Object
68471>
68471>                Object oPriorViewMenu is a cCJPriorViewMenu
68473>                End_Object
68474>
68474>                Object oPromptMenu is a cCJPromptMenuItem
68476>                    Set pbControlBeginGroup to True
68477>                End_Object
68478>
68478>                Object oZoomMenu is a cCJZoomMenuItem
68480>                End_Object
68481>
68481>            End_Object
68482>
68482>            Object oWindowMenu is a cCJMDIWindowsMenuItem
68484>                Set peControlType to xtpControlPopup
68485>                Set psCaption to "&Window"
68486>                Set psToolTip to "Window"
68487>                Set psDescription to "Display Current Views and set other display options."    
68488>
68488>                // These are the static windows items. More will be created in onInitPopup 
68488>                Object oDisplayOptionsMenu is a cCJMenuItem
68490>                    Set peControlType to xtpControlPopup          
68491>                    Set psCaption to "&Display Options"
68492>                    Set psToolTip to "Display Options"
68493>                    Set psDescription to "Set display options"
68494>
68494>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
68496>                    End_Object
68497>
68497>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
68499>                    End_Object
68500>
68500>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
68502>                        Set pbControlBeginGroup to True
68503>                    End_Object
68504>
68504>                End_Object
68505>
68505>                Object oCascadeMenu is a cCJCascadeMenuItem
68507>                    Set pbControlBeginGroup to True
68508>                End_Object
68509>
68509>                Object oHorizTile is a cCJTileHorizontally
68511>                End_Object
68512>
68512>                Object oVertTile is a cCJTileVertically
68514>                End_Object
68515>
68515>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
68517>                    Set pbControlBeginGroup to True
68518>                End_Object
68519>
68519>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
68521>                End_Object
68522>
68522>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
68524>                    Set pbControlBeginGroup to True
68525>                End_Object
68526>
68526>            End_Object
68527>
68527>            Object oHelpMenu is a cCJMenuItem
68529>                Set peControlType to xtpControlPopup    
68530>                Set psCaption to "&Help"
68531>                Set psDescription to "Access Information for learning and using this DataFlex application."
68532>                Set psToolTip to "Help"
68533>
68533>                Object oHelpMenuItem is a cCJHelpMenuItem 
68535>                End_Object
68536>
68536>                Object oAboutMenuItem is a cCJAboutMenuItem
68538>                End_Object
68539>
68539>            End_Object
68540>
68540>        End_Object
68541>
68541>        Object oFindToolBar is a cCJToolbar
68543>            Set psTitle to "Finding Toolbar"
68544>
68544>            Object oFindFirstTool is a cCJFindFirstMenuItem
68546>            End_Object
68547>
68547>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
68549>            End_Object
68550>
68550>            Object oFindMenuTool is a cCJFindMenuItem
68552>            End_Object
68553>
68553>            Object oFindNextTool is a cCJFindNextMenuItem
68555>            End_Object
68556>
68556>            Object oFindLastTool is a cCJFindLastMenuItem
68558>            End_Object
68559>
68559>            Object oPromptToolItem is a cCJPromptMenuItem
68561>                Set pbControlBeginGroup to True
68562>            End_Object
68563>
68563>        End_Object
68564>
68564>        Object oFileToolBar is a cCJToolbar
68566>            Set psTitle to "Data Entry Toolbar"
68567>
68567>            Object oClearToolItem is a cCJClearMenuItem
68569>                Set peControlStyle to xtpButtonIconAndCaption
68570>            End_Object
68571>
68571>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
68573>                Set peControlStyle to xtpButtonIconAndCaption
68574>            End_Object
68575>
68575>            Object oSaveToolItem is a cCJSaveMenuItem
68577>                Set peControlStyle to xtpButtonIconAndCaption
68578>                Set pbControlBeginGroup to True
68579>            End_Object
68580>
68580>            Object oDeleteToolItem is a cCJDeleteMenuItem
68582>                Set peControlStyle to xtpButtonIconAndCaption
68583>            End_Object
68584>
68584>        End_Object
68585>
68585>        Object oEditToolBar is a cCJToolbar
68587>            Set psTitle to "Edit Toolbar"
68588>
68588>            Object oCutToolbarItem is a cCJCutMenuItem
68590>            End_Object
68591>
68591>            Object oCopyToolbarItem is a cCJCopyMenuItem
68593>            End_Object
68594>
68594>            Object oPasteToolbarItem is a cCJPasteMenuItem
68596>            End_Object
68597>
68597>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
68599>                Set pbControlBeginGroup to True
68600>            End_Object
68601>
68601>        End_Object
68602>
68602>        Object oRememberToolbar is a cCJToolbar
68604>            Set psTitle to C_$Remember
68605>
68605>            Object oRememberItems is a cCJMenuItem
68607>
68607>                Set peControlType to xtpControlPopup
68608>                Set peControlStyle to xtpButtonCaption
68609>                Set psCaption to C_$Remember
68610>                
68610>                Object oMenuItem is a cCJRememberFieldMenuItem
68612>                    Set peControlStyle to xtpButtonIconAndCaption
68613>                End_Object
68614>                
68614>                Object oMenuItem is a cCJRememberLastFieldMenuItem
68616>                    Set peControlStyle to xtpButtonIconAndCaption
68617>                End_Object
68618>                
68618>                Object oMenuItem is a cCJUnRememberFieldMenuItem
68620>                    Set peControlStyle to xtpButtonIconAndCaption
68621>                End_Object
68622>                
68622>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
68624>                    Set peControlStyle to xtpButtonIconAndCaption
68625>                End_Object
68626>
68626>            End_Object
68627>            
68627>        End_Object
68628>        
68628>        Object oStatusBar is a cCJStatusBar
68630>
68630>            Object oStatusPane1 is a cCJStatusBarPane
68632>                Set piID to sbpIDIdlePane
68633>                Set pbStyleStretch to True
68634>            End_Object
68635>
68635>            Object oStatusPane2 is a cCJStatusBarPane
68637>                Set phoViewPane to Self
68638>                Set pbStyleStretch to True
68639>            End_Object
68640>
68640>        End_Object
68641>
68641>    End_Object
68642>
68642>    Object oClientArea is a ClientArea
68644>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\StdAbout.pkg)
68644>>>//************************************************************************
68644>>>// Confidential Trade Secret.
68644>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
68644>>>// as an unpublished work.  All rights reserved.
68644>>>// DataFlex is a registered trademark of Data Access Corporation.
68644>>>//
68644>>>//************************************************************************
68644>>>//************************************************************************
68644>>>//
68644>>>// $File name  : StdAbout.pkg
68644>>>// $File title : Standard about object package for VDF
68644>>>// Notice      :
68644>>>// $Author(s)  : John Tuohy
68644>>>//
68644>>>// $Rev History
68644>>>//
68644>>>// JT 06/27/97   File created
68644>>>//************************************************************************
68644>>>
68644>>>// This provides a quick and simple way to create an about package for a program.
68644>>>// You need to create a message inside you client area called Activate_About.
68644>>>// Within this message you should send the message DoAbout passing needed
68644>>>// string information.
68644>>>//
68644>>>//       Procedure Activate_About
68644>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
68644>>>//       End_Procedure
68644>>>//    where: sTitle =     Name of application. If none provided, uses caption
68644>>>//                        bar title
68644>>>//           sVersion   = Version Line. If none provided, will be blank
68644>>>//           sCopyRight = Copyright Line. If none provided, will be blank
68644>>>//           sAuthor    = Author name, blank if none provided
68644>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
68644>>>//                        is used.
68644>>>// It is expected that you will place this in your own object package. For
68644>>>// example an order about package may look like this:
68644>>>//
68644>>>//   // OrderAbout.pkg
68644>>>//   Use StdAbout.pkg
68644>>>//   Procedure Activate_About
68644>>>//      String sTitle sCopyright sVersion sAuthor
68644>>>//      Move "My Order Entry System" to sTitle
68644>>>//      Move "Version 2.1" to sVersion
68644>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
68644>>>//      Move "John Smith"  to sAuthor
68644>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
68644>>>//   end_procedure
68644>>>//   // end of file.
68644>>>
68644>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\DfAbout.pkg)
68644>>>>>Use LanguageText.pkg
68644>>>>>Use Windows.pkg
68644>>>>>Use Dfclient.pkg
68644>>>>>Use DFbitmap.pkg
68644>>>>>Use GlobalFunctionsProcedures.pkg
68644>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRichEdit.pkg)
68644>>>>>>>Use Windows.pkg
68644>>>>>>>Use cEdit_Mixin.pkg
68644>>>>>>>
68644>>>>>>>// constants used for RichEdit Properties
68644>>>>>>>// peAlignment
68644>>>>>>>Enum_List
68644>>>>>>>    Define alLeft   for 1
68644>>>>>>>    Define alRight  for 2
68644>>>>>>>    Define alCenter for 3
68644>>>>>>>End_Enum_List
68644>>>>>>>
68644>>>>>>>// peBullets
68644>>>>>>>Enum_List
68644>>>>>>>    Define buNone
68644>>>>>>>    Define buBullets
68644>>>>>>>    Define buArabicNumbers
68644>>>>>>>    Define buLowerLetters
68644>>>>>>>    Define buUpperLetters
68644>>>>>>>    Define buLowerRomans
68644>>>>>>>    Define buUpperRomans
68644>>>>>>>End_Enum_List
68644>>>>>>>
68644>>>>>>>// peBulletStyle
68644>>>>>>>Enum_List
68644>>>>>>>    Define busRightParen   for 0
68644>>>>>>>    Define busEncloseParen for 256
68644>>>>>>>    Define busPeriod       for 512
68644>>>>>>>    Define busNumberOnly   for 768
68644>>>>>>>    Define busNoDisplay    for 1024
68644>>>>>>>End_Enum_List
68644>>>>>>>
68644>>>>>>>// peLineSpacingType
68644>>>>>>>Enum_List
68644>>>>>>>    Define lstSingle
68644>>>>>>>    Define lstSingleAndOneHalf
68644>>>>>>>    Define lstDouble
68644>>>>>>>End_Enum_List
68644>>>>>>>
68644>>>>>>>Class cRichEdit is a DFBaseRichEdit
68645>>>>>>>    
68645>>>>>>>    Procedure Construct_Object
68647>>>>>>>        Forward Send Construct_Object
68649>>>>>>>        Send Define_cEdit_Mixin
68650>>>>>>>        
68650>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
68651>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
68652>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
68653>>>>>>>        
68653>>>>>>>    End_Procedure
68654>>>>>>>    
68654>>>>>>>    Import_Class_Protocol cEdit_Mixin
68655>>>>>>>    
68655>>>>>>>    Procedure ToggleBold
68657>>>>>>>        Set pbBold to (not(pbBold(Self)))
68658>>>>>>>    End_Procedure
68659>>>>>>>    
68659>>>>>>>    Procedure ToggleItalics
68661>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
68662>>>>>>>    End_Procedure
68663>>>>>>>    
68663>>>>>>>    Procedure ToggleUnderline
68665>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
68666>>>>>>>    End_Procedure
68667>>>>>>>    
68667>>>>>>>End_Class
68668>>>>>>>
68668>>>>>>>
68668>>>>>Use cTextEdit.pkg
68668>>>>>Use cRichEdit.pkg
68668>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
68668>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
68668>>>>>>>>>Use VDFBase.pkg
68668>>>>>>>>>
68668>>>>>>>>>Class cFormatter is an cObject
68669>>>>>>>>>    
68669>>>>>>>>>    Procedure Construct_object
68671>>>>>>>>>        Integer iCh
68671>>>>>>>>>        Forward Send construct_object
68673>>>>>>>>>        Property String  psCurrencySymbol
68674>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
68675>>>>>>>>>        
68675>>>>>>>>>        Property String  psLeft
68676>>>>>>>>>        Property String  psright
68677>>>>>>>>>        Property Integer pbThousandsSep
68678>>>>>>>>>        Property Integer piPoints
68679>>>>>>>>>        
68679>>>>>>>>>        Property String  psCurPosLeft
68680>>>>>>>>>        Property String  psCurPosright
68681>>>>>>>>>        Property Integer pbCurPosThousandsSep
68682>>>>>>>>>        Property Integer piCurPosPoints
68683>>>>>>>>>        
68683>>>>>>>>>        Property String  psCurNegLeft
68684>>>>>>>>>        Property String  psCurNegright
68685>>>>>>>>>        Property Integer pbCurNegThousandsSep
68686>>>>>>>>>        Property Integer piCurNegPoints
68687>>>>>>>>>        
68687>>>>>>>>>        Property String  psNumPosLeft
68688>>>>>>>>>        Property String  psNumPosright
68689>>>>>>>>>        Property Integer pbNumPosThousandsSep
68690>>>>>>>>>        Property Integer piNumPosPoints
68691>>>>>>>>>        
68691>>>>>>>>>        Property String  psNumNegLeft
68692>>>>>>>>>        Property String  psNumNegright
68693>>>>>>>>>        Property Integer pbNumNegThousandsSep
68694>>>>>>>>>        Property Integer piNumNegPoints
68695>>>>>>>>>        
68695>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
68696>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
68697>>>>>>>>>        
68697>>>>>>>>>    End_Procedure
68698>>>>>>>>>    
68698>>>>>>>>>    // internal
68698>>>>>>>>>    // parse passed format string and set temporary properties with result
68698>>>>>>>>>    Procedure ParseFormat String sFmt
68700>>>>>>>>>        
68700>>>>>>>>>        String sLeft sRight sDigit
68700>>>>>>>>>        Integer bSep iPos i iDigits
68700>>>>>>>>>        
68700>>>>>>>>>        // replace any literals. A "/" followed by anything.
68700>>>>>>>>>        // some literals are special. $ . , / #
68700>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
68701>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
68702>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
68703>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
68704>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
68705>>>>>>>>>        Move (Character(9)) to sDigit
68706>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
68707>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
68708>>>>>>>>>        
68708>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
68709>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
68712>>>>>>>>>        
68712>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
68713>>>>>>>>>        
68713>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
68714>>>>>>>>>        
68714>>>>>>>>>        // Move all the special literals back into place before parsing
68714>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
68715>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
68716>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
68717>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
68718>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
68719>>>>>>>>>        
68719>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
68721>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
68722>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
68724>>>>>>>>>                Move -2 to iDigits
68725>>>>>>>>>                Increment i
68726>>>>>>>>>            End
68726>>>>>>>>>>
68726>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
68730>>>>>>>>>                Increment i
68731>>>>>>>>>            Loop
68732>>>>>>>>>>
68732>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
68733>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
68736>>>>>>>>>            //
68736>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
68737>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
68741>>>>>>>>>                Increment i
68742>>>>>>>>>            Loop
68743>>>>>>>>>>
68743>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
68744>>>>>>>>>        End
68744>>>>>>>>>>
68744>>>>>>>>>        Else Begin                             // we have no decinal
68745>>>>>>>>>            Move 0 to iDigits                  // so points is none
68746>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
68747>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
68749>>>>>>>>>                Move sFmt to sLeft
68750>>>>>>>>>                Move ""   to sRight
68751>>>>>>>>>            End
68751>>>>>>>>>>
68751>>>>>>>>>            Else Begin
68752>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
68753>>>>>>>>>                Move 1 to i
68754>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
68758>>>>>>>>>                    Increment i
68759>>>>>>>>>                Loop
68760>>>>>>>>>>
68760>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
68761>>>>>>>>>            End
68761>>>>>>>>>>
68761>>>>>>>>>        End
68761>>>>>>>>>>
68761>>>>>>>>>        // set temporary format properties and exit
68761>>>>>>>>>        Set pbThousandsSep to bSep
68762>>>>>>>>>        Set psLeft         to sLeft
68763>>>>>>>>>        Set psRight        to sRight
68764>>>>>>>>>        Set piPoints       to iDigits
68765>>>>>>>>>    End_Procedure
68766>>>>>>>>>    
68766>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
68766>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
68766>>>>>>>>>    //
68766>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
68766>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
68768>>>>>>>>>        String sPos sNeg
68768>>>>>>>>>        Integer iPos
68768>>>>>>>>>        
68768>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
68769>>>>>>>>>        If iPos Begin
68771>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
68772>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
68773>>>>>>>>>        End
68773>>>>>>>>>>
68773>>>>>>>>>        Else Begin
68774>>>>>>>>>            Move sFmt         to sPos
68775>>>>>>>>>            Move ("-" + sFmt) to sNeg
68776>>>>>>>>>        End
68776>>>>>>>>>>
68776>>>>>>>>>        Send ParseFormat sPos
68777>>>>>>>>>        If bCurrency Begin
68779>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
68780>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
68781>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
68782>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
68783>>>>>>>>>        End
68783>>>>>>>>>>
68783>>>>>>>>>        Else Begin
68784>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
68785>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
68786>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
68787>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
68788>>>>>>>>>        End
68788>>>>>>>>>>
68788>>>>>>>>>        
68788>>>>>>>>>        Send ParseFormat sNeg
68789>>>>>>>>>        If bCurrency Begin
68791>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
68792>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
68793>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
68794>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
68795>>>>>>>>>        End
68795>>>>>>>>>>
68795>>>>>>>>>        Else Begin
68796>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
68797>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
68798>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
68799>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
68800>>>>>>>>>        End
68800>>>>>>>>>>
68800>>>>>>>>>    End_Procedure
68801>>>>>>>>>    
68801>>>>>>>>>    // low level formatting. Pass parameters
68801>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
68803>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
68803>>>>>>>>>        Integer bIsNegative iDec iLen iCh
68803>>>>>>>>>        
68803>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
68806>>>>>>>>>        Move (Character(iCh)) to sDec
68807>>>>>>>>>        
68807>>>>>>>>>        Move (abs(nNumber)) to sNumber
68808>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
68809>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
68810>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
68811>>>>>>>>>        // format for decimal separator
68811>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
68814>>>>>>>>>        
68814>>>>>>>>>        // format for thousand sep.
68814>>>>>>>>>        If bSep Begin
68816>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
68819>>>>>>>>>            Move (Character(iCh)) to sSep
68820>>>>>>>>>            Move (Length(sLeft)) to iLen
68821>>>>>>>>>            While (iLen>3)
68825>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
68826>>>>>>>>>                Move (iLen-3) to iLen
68827>>>>>>>>>            Loop
68828>>>>>>>>>>
68828>>>>>>>>>        End
68828>>>>>>>>>>
68828>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
68828>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
68831>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
68832>>>>>>>>>    End_Function
68833>>>>>>>>>    
68833>>>>>>>>>    // Public: Format for currency
68833>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
68835>>>>>>>>>        String  sLeft sRight
68835>>>>>>>>>        Integer bSep
68835>>>>>>>>>        If (nNumber<0) Begin
68837>>>>>>>>>            Get pbCurNegThousandsSep to bSep
68838>>>>>>>>>            Get psCurNegLeft         to sLeft
68839>>>>>>>>>            Get psCurNegRight        to sRight
68840>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
68843>>>>>>>>>        End
68843>>>>>>>>>>
68843>>>>>>>>>        Else Begin
68844>>>>>>>>>            Get pbCurPosThousandsSep to bSep
68845>>>>>>>>>            Get psCurPosLeft         to sLeft
68846>>>>>>>>>            Get psCurPosRight        to sRight
68847>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
68850>>>>>>>>>        End
68850>>>>>>>>>>
68850>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
68851>>>>>>>>>    End_Function
68852>>>>>>>>>    
68852>>>>>>>>>    // Public: Format for numeric
68852>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
68854>>>>>>>>>        String  sLeft sRight
68854>>>>>>>>>        Integer bSep
68854>>>>>>>>>        If (nNumber<0) Begin
68856>>>>>>>>>            Get pbNumNegThousandsSep to bSep
68857>>>>>>>>>            Get psNumNegLeft         to sLeft
68858>>>>>>>>>            Get psNumNegRight        to sRight
68859>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
68862>>>>>>>>>        End
68862>>>>>>>>>>
68862>>>>>>>>>        Else Begin
68863>>>>>>>>>            Get pbNumPosThousandsSep to bSep
68864>>>>>>>>>            Get psNumPosLeft         to sLeft
68865>>>>>>>>>            Get psNumPosRight        to sRight
68866>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
68869>>>>>>>>>        End
68869>>>>>>>>>>
68869>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
68870>>>>>>>>>    End_Function
68871>>>>>>>>>    
68871>>>>>>>>>    
68871>>>>>>>>>    // Public: Format passing format string
68871>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
68873>>>>>>>>>        Integer iPos bIsNeg
68873>>>>>>>>>        String  sLeft sRight
68873>>>>>>>>>        Integer iPoints bSep
68873>>>>>>>>>        Move (nNumber<0) to bIsNeg
68874>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
68875>>>>>>>>>        Case Begin
68875>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
68878>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
68882>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
68886>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
68888>>>>>>>>>        Case End
68888>>>>>>>>>        Send ParseFormat sFmt
68889>>>>>>>>>        Get pbThousandsSep to bSep
68890>>>>>>>>>        Get psLeft         to sLeft
68891>>>>>>>>>        Get psRight        to sRight
68892>>>>>>>>>        Get piPoints       to iPoints
68893>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
68894>>>>>>>>>    End_Function
68895>>>>>>>>>    
68895>>>>>>>>>End_Class
68896>>>>>>>
68896>>>>>>>Global_Variable Handle ghoFormatter
68896>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
68897>>>>>>>
68897>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
68899>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
68900>>>>>>>End_Function
68901>>>>>>>
68901>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
68903>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
68904>>>>>>>End_Function
68905>>>>>>>
68905>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
68907>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
68908>>>>>>>End_Function
68909>>>>>>>
68909>>>>>>>Procedure SetCurrencyFormat Global String sFmt
68911>>>>>>>    Send SetFormat of ghoFormatter sFmt True
68912>>>>>>>End_Procedure
68913>>>>>>>
68913>>>>>>>Procedure SetNumberFormat Global String sFmt
68915>>>>>>>    Send SetFormat of ghoFormatter sFmt False
68916>>>>>>>End_Procedure
68917>>>>>>>
68917>>>>>>>
68917>>>>>Use tWinStructs.pkg
68917>>>>>
68917>>>>>Use cli.pkg
68917>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
68917>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
68917>>>>>>>// Notice      : This package contains constants and commands, used to call
68917>>>>>>>//               specific functions in the DFBTRDRV.
68917>>>>>>>Use Ui
68917>>>>>>>//
68917>>>>>>>// Driver Indentification
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>// Driver attributes
68917>>>>>>>//
68917>>>>>>>// Call_Driver functions ID's
68917>>>>>>>//
68917>>>>>>>//
68917>>>>>>>// DFBTRFN_CONVERT_FILE options
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// DFBTRFN_SET_OWNER options
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to create all vars which may be needed
68917>>>>>>>// in other commands.
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to set the owner of a Btrieve file.
68917>>>>>>>// File must have been opened.
68917>>>>>>>// Filenumber needs to be passed.
68917>>>>>>>// To clear set the owner to "".
68917>>>>>>>// Examples:
68917>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
68917>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
68917>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
68917>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
68917>>>>>>>// To clear:
68917>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to parse DFBTR_SET_OWNVER
68917>>>>>>>// options.
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to parse for Callback
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to clear the owner of a Btrieve file.
68917>>>>>>>// File must have been opened.
68917>>>>>>>// Filenumber needs to be passed.
68917>>>>>>>// Examples:
68917>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to add a owner name to the internal list of ownernames
68917>>>>>>>// which will be tries when opening files.
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to remove all owners from the internal list of ownernames
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to set the owner name to be used when opening the DDF files.
68917>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
68917>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
68917>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to change the transaction type.
68917>>>>>>>// Valid types are:
68917>>>>>>>//     DFBTRTT_NONE
68917>>>>>>>//     DFBTRTT_EXCLUSIVE
68917>>>>>>>//     DFBTRTT_CONCURRENT
68917>>>>>>>//
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to get the current transaction type.
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to set explicit_locking
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to get explicit locking
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>//
68917>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
68917>>>>>>>//
68917>>>>>>>
68917>>>>>>>// Purpose: An instance of this class can be used as a broker object to
68917>>>>>>>//          call several Dfbtrdrv releated methods.
68917>>>>>>>
68917>>>>>>>Class cDFBtrDrvHandler is an Array
68918>>>>>>>    
68918>>>>>>>    Procedure Construct_Object Integer iImage
68920>>>>>>>        Forward Send Construct_object iImage
68922>>>>>>>        
68922>>>>>>>        Property String  psDriverID "DFBTRDRV"
68923>>>>>>>    End_Procedure
68924>>>>>>>    
68924>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
68924>>>>>>>    //
68924>>>>>>>    
68924>>>>>>>    Function CKRevision Returns String
68926>>>>>>>        String  sDriverID
68926>>>>>>>        String  sRevision
68926>>>>>>>        String  sVoid
68926>>>>>>>        Integer iRetval
68926>>>>>>>        
68926>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
68926>>>>>>>        // This error would otherwise be raised when we have an older
68926>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
68926>>>>>>>        Send Ignore_error to Error_object_Id 20491
68927>>>>>>>        Get psDriverID to sDriverID
68928>>>>>>>        Move (Repeat(" ", 255)) to sRevision
68929>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
68934>>>>>>>        Send Trap_Error to Error_object_Id 20491
68935>>>>>>>        If (Trim(sRevision) = "") Begin
68937>>>>>>>            // Unable to get the revision. return all zeroes.
68937>>>>>>>            Move "0.0.0.0" to sRevision
68938>>>>>>>        End
68938>>>>>>>>
68938>>>>>>>        Function_Return sRevision
68939>>>>>>>    End_Function
68940>>>>>>>    
68940>>>>>>>    Function CkUsesUri Returns Integer
68942>>>>>>>        String  sDriverID
68942>>>>>>>        String  sVoid1
68942>>>>>>>        String  sVoid2
68942>>>>>>>        Integer iRetval
68942>>>>>>>        
68942>>>>>>>        Get psDriverID to sDriverID
68943>>>>>>>        
68943>>>>>>>        Move 0 to iRetval
68944>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
68944>>>>>>>        // This error would otherwise be raised when we have an older
68944>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
68944>>>>>>>        Send Ignore_error to Error_object_Id 20491
68945>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
68950>>>>>>>        Send Trap_Error to Error_object_Id 20491
68951>>>>>>>        
68951>>>>>>>        Function_Return iRetval
68952>>>>>>>    End_Function
68953>>>>>>>    
68953>>>>>>>    
68953>>>>>>>    
68953>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
68953>>>>>>>    //
68953>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
68953>>>>>>>    //
68953>>>>>>>    
68953>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
68955>>>>>>>        Integer iPartRev
68955>>>>>>>        Integer iCurrentPart
68955>>>>>>>        Integer iSeparatorPos
68955>>>>>>>        
68955>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
68958>>>>>>>        
68958>>>>>>>        Move 0 to iCurrentPart
68959>>>>>>>        Repeat
68959>>>>>>>>
68959>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
68960>>>>>>>            If (iSeparatorPos > 0) Begin
68962>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
68963>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
68964>>>>>>>                Increment iCurrentPart
68965>>>>>>>            End
68965>>>>>>>>
68965>>>>>>>            Else If (sRevision <> "") Begin
68968>>>>>>>                Move sRevision to iPartRev
68969>>>>>>>                Move "" to sRevision
68970>>>>>>>                Increment iCurrentPart
68971>>>>>>>            End
68971>>>>>>>>
68971>>>>>>>            Else ;                Move -1 to iPartRev
68973>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
68975>>>>>>>        
68975>>>>>>>        Function_Return iPartRev
68976>>>>>>>    End_Function
68977>>>>>>>    
68977>>>>>>>    
68977>>>>>>>    
68977>>>>>>>    //
68977>>>>>>>    //  Returns the major revision of the CK
68977>>>>>>>    //
68977>>>>>>>    
68977>>>>>>>    Function CKMajorRevision Returns Integer
68979>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
68980>>>>>>>    End_Function
68981>>>>>>>    
68981>>>>>>>    
68981>>>>>>>    
68981>>>>>>>    //  Returns the minor revision of the CK
68981>>>>>>>    //
68981>>>>>>>    
68981>>>>>>>    Function CKMinorRevision Returns Integer
68983>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
68984>>>>>>>    End_Function
68985>>>>>>>    
68985>>>>>>>    
68985>>>>>>>    //  Returns the release revision of the CK
68985>>>>>>>    //
68985>>>>>>>    
68985>>>>>>>    Function CKReleaseRevision Returns Integer
68987>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
68988>>>>>>>    End_Function
68989>>>>>>>    
68989>>>>>>>    
68989>>>>>>>    //  Returns the major revision of the CK
68989>>>>>>>    //
68989>>>>>>>    
68989>>>>>>>    Function CKBuildRevision Returns Integer
68991>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
68992>>>>>>>    End_Function
68993>>>>>>>    
68993>>>>>>>    
68993>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
68993>>>>>>>    //
68993>>>>>>>    
68993>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
68995>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
68998>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
69001>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
69004>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
69007>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
69010>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
69014>>>>>>>            End
69014>>>>>>>>
69014>>>>>>>        End
69014>>>>>>>>
69014>>>>>>>        
69014>>>>>>>        Function_Return (False)
69015>>>>>>>    End_Function
69016>>>>>>>    
69016>>>>>>>    //   Functions to query the Pervasive.SQL version:
69016>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
69016>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
69016>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
69016>>>>>>>    //
69016>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
69016>>>>>>>    //   in the following format:
69016>>>>>>>    //       <version>.<revision>.<type>
69016>>>>>>>    //   possible values for <type>:
69016>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
69016>>>>>>>    //         server using Workgroup authentication mode
69016>>>>>>>    //       C for client cache engine
69016>>>>>>>    //       D for DOS workstation
69016>>>>>>>    //       N for client Requester
69016>>>>>>>    //       S for NetWare server
69016>>>>>>>    //       T for 32-bit Windows server engine
69016>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
69016>>>>>>>    //
69016>>>>>>>    //   example:
69016>>>>>>>    //       8.50.T
69016>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
69016>>>>>>>    //   32-bits Windows server.
69016>>>>>>>    //
69016>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
69016>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
69016>>>>>>>    //
69016>>>>>>>    //   If the version information is not available or can not be obtained
69016>>>>>>>    //   the functions will return "0.0.0"
69016>>>>>>>    
69016>>>>>>>    //  Returns the version information of the
69016>>>>>>>    //           Pervasive.SQL Client requester.
69016>>>>>>>    
69016>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
69018>>>>>>>        
69018>>>>>>>        String  sDriverID
69018>>>>>>>        String  sVersion
69018>>>>>>>        String  sVoid
69018>>>>>>>        Integer iRetval
69018>>>>>>>        
69018>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69018>>>>>>>        // This error would otherwise be raised when we have an older
69018>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69018>>>>>>>        Send Ignore_error to Error_object_Id 20491
69019>>>>>>>        Get psDriverID to sDriverID
69020>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69021>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69026>>>>>>>        Send Trap_Error to Error_object_Id 20491
69027>>>>>>>        If (Trim(sVersion) = "") Begin
69029>>>>>>>            // Unable to get the revision. return all zeroes.
69029>>>>>>>            Move "0.0.0" to sVersion
69030>>>>>>>        End
69030>>>>>>>>
69030>>>>>>>        Function_Return sVersion
69031>>>>>>>    End_Function
69032>>>>>>>    
69032>>>>>>>    //           Pervasive.SQL Engine
69032>>>>>>>    
69032>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
69034>>>>>>>        
69034>>>>>>>        String  sDriverID
69034>>>>>>>        String  sVersion
69034>>>>>>>        String  sVoid
69034>>>>>>>        Integer iRetval
69034>>>>>>>        
69034>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69034>>>>>>>        // This error would otherwise be raised when we have an older
69034>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69034>>>>>>>        Send Ignore_error to Error_object_Id 20491
69035>>>>>>>        Get psDriverID to sDriverID
69036>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69037>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69042>>>>>>>        Send Trap_Error to Error_object_Id 20491
69043>>>>>>>        If (Trim(sVersion) = "") Begin
69045>>>>>>>            // Unable to get the revision. return all zeroes.
69045>>>>>>>            Move "0.0.0" to sVersion
69046>>>>>>>        End
69046>>>>>>>>
69046>>>>>>>        Function_Return sVersion
69047>>>>>>>    End_Function
69048>>>>>>>    
69048>>>>>>>    //  Returns the version information of the
69048>>>>>>>    //           Pervasive.SQL Server Engine
69048>>>>>>>    
69048>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
69050>>>>>>>        
69050>>>>>>>        String  sDriverID
69050>>>>>>>        String  sVersion
69050>>>>>>>        String  sVoid
69050>>>>>>>        Integer iRetval
69050>>>>>>>        
69050>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
69050>>>>>>>        // This error would otherwise be raised when we have an older
69050>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
69050>>>>>>>        Send Ignore_error to Error_object_Id 20491
69051>>>>>>>        Get psDriverID to sDriverID
69052>>>>>>>        Move (Repeat(" ", 255)) to sVersion
69053>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
69058>>>>>>>        Send Trap_Error to Error_object_Id 20491
69059>>>>>>>        If (Trim(sVersion) = "") Begin
69061>>>>>>>            // Unable to get the revision. return all zeroes.
69061>>>>>>>            Move "0.0.0" to sVersion
69062>>>>>>>        End
69062>>>>>>>>
69062>>>>>>>        Function_Return sVersion
69063>>>>>>>    End_Function
69064>>>>>>>    
69064>>>>>>>End_Class
69065>>>>>>>
69065>>>>>>>
69065>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
69065>>>>>>>//     Package that declares MS SQL driver constants and functions.
69065>>>>>>>//     This package can be used by developers who want to add Data Access
69065>>>>>>>//     MS SQL Client specific code to a DataFlex application.
69065>>>>>>>
69065>>>>>>>Use Cli.pkg
69065>>>>>>>Use SQL.pkg
69065>>>>>>>
69065>>>>>>>//   Driver Indentification
69065>>>>>>>
69065>>>>>>>//   Error number constants
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>// SQL Server spcific types.
69065>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
69065>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
69065>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
69065>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
69065>>>>>>>
69065>>>>>>>// SQL Server spcific types.
69065>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
69065>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
69065>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
69065>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
69065>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
69065>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
69065>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
69065>>>>>>>//
69065>>>>>>>//     Setup a constraint for a file.
69065>>>>>>>
69065>>>>>>>
69065>>>>>>>Class cMSSQLHandler is a cCLIHandler
69066>>>>>>>    
69066>>>>>>>    Procedure Construct_Object
69068>>>>>>>        Forward Send Construct_Object
69070>>>>>>>        
69070>>>>>>>        Set psDriverID to MSSQLDRV_ID
69071>>>>>>>    End_Procedure
69072>>>>>>>    
69072>>>>>>>    
69072>>>>>>>    
69072>>>>>>>    //   Extract the list from the out connect string.
69072>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
69074>>>>>>>        String  sItem
69074>>>>>>>        Integer iStart
69074>>>>>>>        Integer iEnd
69074>>>>>>>        
69074>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
69077>>>>>>>        
69077>>>>>>>        Send Delete_Data to hoStore
69078>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
69079>>>>>>>        While (iStart > 0)
69083>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
69084>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
69087>>>>>>>            Else Begin
69088>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
69089>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
69090>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
69093>>>>>>>                
69093>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
69096>>>>>>>                
69096>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
69099>>>>>>>            End
69099>>>>>>>>
69099>>>>>>>        Loop
69100>>>>>>>>
69100>>>>>>>        
69100>>>>>>>        Function_Return (Item_Count(hoStore))
69101>>>>>>>    End_Function
69102>>>>>>>    
69102>>>>>>>    
69102>>>>>>>    
69102>>>>>>>    //   Call the driver's browse connect function
69102>>>>>>>    Function BrowseConnect String sInConnStr Returns String
69104>>>>>>>        String  sDriver
69104>>>>>>>        String  sOutConnStr
69104>>>>>>>        Integer iArg
69104>>>>>>>        Integer iRetval
69104>>>>>>>        
69104>>>>>>>        Get psDriverID to sDriver
69105>>>>>>>        If (sDriver <> "") Begin
69107>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69108>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69113>>>>>>>        End
69113>>>>>>>>
69113>>>>>>>        
69113>>>>>>>        Function_Return sOutConnStr
69114>>>>>>>    End_Function// BrowseConnect
69115>>>>>>>    
69115>>>>>>>    
69115>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
69117>>>>>>>        String  sDriver
69117>>>>>>>        String  sOutConnStr
69117>>>>>>>        Integer iArg
69117>>>>>>>        Integer iRetval
69117>>>>>>>        
69117>>>>>>>        Move 1 to iArg // Browses only local
69118>>>>>>>        
69118>>>>>>>        Get psDriverID to sDriver
69119>>>>>>>        If (sDriver <> "") Begin
69121>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
69122>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
69127>>>>>>>        End
69127>>>>>>>>
69127>>>>>>>        
69127>>>>>>>        Function_Return sOutConnStr
69128>>>>>>>    End_Function// BrowseConnect
69129>>>>>>>    
69129>>>>>>>    
69129>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
69131>>>>>>>        
69131>>>>>>>        String  sServerList
69131>>>>>>>        Integer iNumServers
69131>>>>>>>        Integer iDriver
69131>>>>>>>        Integer iClientVersion
69131>>>>>>>        String  sDriver
69131>>>>>>>        
69131>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
69132>>>>>>>        
69132>>>>>>>        If (iDriver) Begin
69134>>>>>>>            
69134>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
69137>>>>>>>            
69137>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
69138>>>>>>>            
69138>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
69139>>>>>>>            If (iNetworkLocal = 0) Begin
69141>>>>>>>                Get BrowseConnect sDriver to sServerList
69142>>>>>>>            End
69142>>>>>>>>
69142>>>>>>>            Else Begin
69143>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
69144>>>>>>>            End
69144>>>>>>>>
69144>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
69145>>>>>>>        End
69145>>>>>>>>
69145>>>>>>>        
69145>>>>>>>        Function_Return iNumServers
69146>>>>>>>        
69146>>>>>>>    End_Function
69147>>>>>>>    
69147>>>>>>>    //   Enumerate the available SQL Server database servers
69147>>>>>>>    //   This function will return all SQL Server instances on the network.
69147>>>>>>>    //   This may take a long time.
69147>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
69147>>>>>>>    Function EnumerateServers Returns Integer
69149>>>>>>>        
69149>>>>>>>        Integer iNumServers
69149>>>>>>>        Integer iNetworkLocal
69149>>>>>>>        
69149>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
69150>>>>>>>        
69150>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
69151>>>>>>>        
69151>>>>>>>        Function_Return iNumServers
69152>>>>>>>        
69152>>>>>>>    End_Function
69153>>>>>>>    
69153>>>>>>>    
69153>>>>>>>    //   Enumerate the available SQL Server database servers
69153>>>>>>>    //   This function will return only return SQL Server instance on the local machine
69153>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
69153>>>>>>>    Function EnumerateServersLocal Returns Integer
69155>>>>>>>        
69155>>>>>>>        Integer iNumServers
69155>>>>>>>        Integer iNetworkLocal
69155>>>>>>>        
69155>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
69156>>>>>>>        
69156>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
69157>>>>>>>        
69157>>>>>>>        Function_Return iNumServers
69158>>>>>>>        
69158>>>>>>>    End_Function
69159>>>>>>>    
69159>>>>>>>    
69159>>>>>>>    
69159>>>>>>>    //   Enumerate database in a given server.
69159>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
69161>>>>>>>        Integer hoSQL
69161>>>>>>>        String  sConnect
69161>>>>>>>        String  sDatabase
69161>>>>>>>        Integer hdbc
69161>>>>>>>        Integer hstmt
69161>>>>>>>        Integer iFetchResult
69161>>>>>>>        
69161>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
69164>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
69167>>>>>>>        
69167>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
69170>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
69172>>>>>>>        
69172>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
69174>>>>>>>            Move Current_Object to hoSQL
69175>>>>>>>        End_Object
69176>>>>>>>        
69176>>>>>>>        If (hoSQL <> 0) Begin
69178>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
69179>>>>>>>            If (hdbc <> 0) Begin
69181>>>>>>>                Get SQLOpen of hdbc to hstmt
69182>>>>>>>                If (hstmt <> 0) Begin
69184>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
69184>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
69184>>>>>>>                    //   approach in case meta data might change, the stored procedure will
69184>>>>>>>                    //   stay the same.
69184>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
69185>>>>>>>                    Send SQLCall to hstmt
69186>>>>>>>                    Repeat
69186>>>>>>>>
69186>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
69187>>>>>>>                        If (iFetchResult <> 0) Begin
69189>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
69190>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
69191>>>>>>>                        End
69191>>>>>>>>
69191>>>>>>>                    Until (iFetchResult = 0)
69193>>>>>>>                    
69193>>>>>>>                    Send SQLClose to hstmt
69194>>>>>>>                End
69194>>>>>>>>
69194>>>>>>>                Send SQLDisconnect to hdbc
69195>>>>>>>            End
69195>>>>>>>>
69195>>>>>>>        End
69195>>>>>>>>
69195>>>>>>>        Send Destroy_Object to hoSQL
69196>>>>>>>        
69196>>>>>>>        Function_Return (Item_Count(Current_Object))
69197>>>>>>>    End_Function
69198>>>>>>>    
69198>>>>>>>    
69198>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
69200>>>>>>>        
69200>>>>>>>        String  sSqlServerClientVersionName
69200>>>>>>>        
69200>>>>>>>        
69200>>>>>>>        Case Begin
69200>>>>>>>            
69200>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
69202>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
69203>>>>>>>                Case Break
69204>>>>>>>                
69204>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
69207>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
69208>>>>>>>                Case Break
69209>>>>>>>            
69209>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
69212>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
69213>>>>>>>                Case Break
69214>>>>>>>            
69214>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
69217>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
69218>>>>>>>                Case Break
69219>>>>>>>            
69219>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
69222>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
69223>>>>>>>                Case Break
69224>>>>>>>            
69224>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
69227>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
69228>>>>>>>                Case Break
69229>>>>>>>            
69229>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
69232>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
69233>>>>>>>                Case Break
69234>>>>>>>            
69234>>>>>>>            Case Else
69234>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
69235>>>>>>>                
69235>>>>>>>        Case End
69235>>>>>>>        
69235>>>>>>>        
69235>>>>>>>        Function_Return sSqlServerClientVersionName
69236>>>>>>>        
69236>>>>>>>    End_Function
69237>>>>>>>
69237>>>>>>>
69237>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
69239>>>>>>>        
69239>>>>>>>        String  sSqlServerClientDriverName
69239>>>>>>>        
69239>>>>>>>        Case Begin
69239>>>>>>>            
69239>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
69241>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
69242>>>>>>>                Case Break
69243>>>>>>>                
69243>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
69246>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
69247>>>>>>>                Case Break
69248>>>>>>>            
69248>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
69251>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
69252>>>>>>>                Case Break
69253>>>>>>>            
69253>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
69256>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
69257>>>>>>>                Case Break
69258>>>>>>>            
69258>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
69261>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
69262>>>>>>>                Case Break
69263>>>>>>>            
69263>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
69266>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
69267>>>>>>>                Case Break
69268>>>>>>>            
69268>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
69271>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
69272>>>>>>>                Case Break
69273>>>>>>>            
69273>>>>>>>            Case Else
69273>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
69274>>>>>>>                
69274>>>>>>>        Case End
69274>>>>>>>        
69274>>>>>>>        
69274>>>>>>>        Function_Return sSqlServerClientDriverName
69275>>>>>>>        
69275>>>>>>>    End_Function
69276>>>>>>>    
69276>>>>>>>    
69276>>>>>>>End_Class
69277>>>>>>>
69277>>>>>>>
69277>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
69277>>>>>>>// DB2_DRV.PKG                                                          
69277>>>>>>>//   Package that declares DB2 driver constants and functions.          
69277>>>>>>>//   This package can be used by developers who want to add DB2 driver  
69277>>>>>>>//   specific code to a DataFlex application.                           
69277>>>>>>>
69277>>>>>>>Use Cli.pkg
69277>>>>>>>
69277>>>>>>>// Driver attributes
69277>>>>>>>
69277>>>>>>>
69277>>>>>>>// Driver Indentification
69277>>>>>>>
69277>>>>>>>// Error number constants
69277>>>>>>>
69277>>>>>>>// Call driver function identifiers
69277>>>>>>>
69277>>>>>>>// DB2 specific data types
69277>>>>>>>Define SQL_CLOB           for   (-99)
69277>>>>>>>Define SQL_BLOB           for   (-98)
69277>>>>>>>Define SQL_XML            for   (-370)
69277>>>>>>>// DB2 Graphic types are Unicode types
69277>>>>>>>Define SQL_GRAPHIC        for   (-95)
69277>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
69277>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
69277>>>>>>>Define SQL_DBCLOB         for   (-350)
69277>>>>>>>
69277>>>>>>>
69277>>>>>>>// Extra DB2 commands
69277>>>>>>>
69277>>>>>>>
69277>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
69277>>>>>>>//   Setup a constraint for a file.                                     
69277>>>>>>>
69277>>>>>>>
69277>>>>>>>
69277>>>>>>>Class cDB2Handler is a cCLIHandler
69278>>>>>>>    
69278>>>>>>>    Procedure Construct_Object
69280>>>>>>>        Forward Send Construct_Object
69282>>>>>>>        
69282>>>>>>>        Set psDriverID to DB2_DRV_ID
69283>>>>>>>    End_Procedure
69284>>>>>>>    
69284>>>>>>>    
69284>>>>>>>    
69284>>>>>>>    // Reset the datasource list to the beginning
69284>>>>>>>    Procedure SeedDataSources
69286>>>>>>>        String  sDriver
69286>>>>>>>        String  sVoid
69286>>>>>>>        Integer iRetval
69286>>>>>>>        
69286>>>>>>>        Get psDriverID to sDriver
69287>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
69294>>>>>>>    End_Procedure
69295>>>>>>>    
69295>>>>>>>    
69295>>>>>>>    
69295>>>>>>>    // Call the driver's data sources function
69295>>>>>>>    Function DataSources Returns String
69297>>>>>>>        String  sDriver
69297>>>>>>>        String  sDataSource
69297>>>>>>>        String  sDescription
69297>>>>>>>        Integer iLength
69297>>>>>>>        Integer iRetval
69297>>>>>>>        
69297>>>>>>>        Get psDriverID to sDriver
69298>>>>>>>        If (sDriver <> "") Begin
69300>>>>>>>            Move 8192 to iLength
69301>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
69302>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
69303>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
69308>>>>>>>        End
69308>>>>>>>>
69308>>>>>>>        
69308>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
69311>>>>>>>        Else ;            Function_Return ""
69313>>>>>>>    End_Function
69314>>>>>>>    
69314>>>>>>>End_Class
69315>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
69315>>>>>>>//   Package that declares ODBC driver constants and functions.         
69315>>>>>>>//   This package can be used by developers who want to add Data Access 
69315>>>>>>>//   ODBC Client specific code to a DataFlex application.               
69315>>>>>>>
69315>>>>>>>Use Cli.pkg
69315>>>>>>>
69315>>>>>>>// Driver Indentification
69315>>>>>>>
69315>>>>>>>// Error number constants
69315>>>>>>>
69315>>>>>>>// Call driver function identifiers
69315>>>>>>>
69315>>>>>>>Class cODBCHandler is a cCLIHandler
69316>>>>>>>    
69316>>>>>>>    Procedure Construct_Object
69318>>>>>>>        Forward Send Construct_Object
69320>>>>>>>        
69320>>>>>>>        Set psDriverID to ODBC_DRV_ID
69321>>>>>>>    End_Procedure
69322>>>>>>>    
69322>>>>>>>    
69322>>>>>>>    
69322>>>>>>>    // Setup the type of data sources returned by the datasources function
69322>>>>>>>    Procedure Set DataSourceType Integer iNewType
69324>>>>>>>        String  sDriver
69324>>>>>>>        String  sVoid
69324>>>>>>>        Integer iRetval
69324>>>>>>>        
69324>>>>>>>        Get psDriverID to sDriver
69325>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
69332>>>>>>>    End_Procedure
69333>>>>>>>    
69333>>>>>>>    
69333>>>>>>>    // Call the driver's data sources function
69333>>>>>>>    Function DataSources Returns String
69335>>>>>>>        String  sDriver
69335>>>>>>>        String  sDataSource
69335>>>>>>>        String  sDescription
69335>>>>>>>        Integer iLength
69335>>>>>>>        Integer iRetval
69335>>>>>>>        
69335>>>>>>>        Get psDriverID to sDriver
69336>>>>>>>        If (sDriver <> "") Begin
69338>>>>>>>            Move 8192 to iLength
69339>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
69340>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
69341>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
69346>>>>>>>        End
69346>>>>>>>>
69346>>>>>>>        
69346>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
69349>>>>>>>        Else ;            Function_Return ""
69351>>>>>>>    End_Function
69352>>>>>>>    
69352>>>>>>>End_Class
69353>>>>>>>
69353>>>>>Use seq_chnl.pkg
69353>>>>>
69353>>>>>Register_Function phoWorkspace Returns Handle
69353>>>>>Register_Function Help_filename Returns String
69353>>>>>Register_Function GetHelpFile Returns String
69353>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
69353>>>>>
69353>>>>>// Use of Mertech drivers:
69353>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
69353>>>>>
69353>>>>>    Define ORAFLEX   for "ORA_DRV"
69353>>>>>
69353>>>>>    Define SQLFLEX   for "SQL_DRV"
69353>>>>>
69353>>>>>    Define MDSPgSQL  for "MDSPGSQL"
69353>>>>>
69353>>>>>    Define MDSMySQL  for "MDSMYSQL"
69353>>>>>
69353>>>>>// *** Constant Declarations: ***
69353>>>>>//
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>
69353>>>>>    Define DATAFLEX_ID for "DATAFLEX"
69353>>>>>
69353>>>>>// System icon menu constants. If the upper left hand
69353>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
69353>>>>>    Define SC_RESTORE  for |CI$F120
69353>>>>>    Define SC_MOVE     for |CI$F010
69353>>>>>    Define SC_SIZE     for |CI$F000
69353>>>>>    Define SC_MINIMIZE for |CI$F020
69353>>>>>    Define SC_MAXIMIZE for |CI$F030
69353>>>>>    Define SC_CLOSE    for |CI$F060
69353>>>>>    Define SC_KEYMENU  for |CI$F100
69353>>>>>    Define SC_NEXTWINDOW for |CI$F040
69353>>>>>    Define SC_PREVWINDOW for |CI$F050
69353>>>>>
69353>>>>>Define CS_SignProgram        for "signtool.exe"
69353>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
69353>>>>>Define CS_VerifyCredentials  for "verify"
69353>>>>>Define CS_VerifyFileParam    for "/a"
69353>>>>>Define CS_DefAuthVerPolicy   for "/pa"
69353>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
69353>>>>>
69353>>>>>// *** Struct Declarations: ***
69353>>>>>
69353>>>>>Struct AboutSHELLEXECUTEINFO
69353>>>>>    DWord   cbSize
69353>>>>>    Integer fMask
69353>>>>>    Handle  hwnd
69353>>>>>    Pointer lpVerb
69353>>>>>    Pointer lpFile
69353>>>>>    Pointer lpParameters
69353>>>>>    Pointer lpDirectory
69353>>>>>    Integer nShow
69353>>>>>    Pointer hInstApp
69353>>>>>    Pointer lpIDList
69353>>>>>    Pointer lpClass
69353>>>>>    Handle  hkeyClass
69353>>>>>    DWord   dwHotKey
69353>>>>>    Handle  hIconMonitor // Union
69353>>>>>    //Handle  hMonitor     // Union
69353>>>>>    Handle  hProcess
69353>>>>>End_Struct
69353>>>>>
69353>>>>>
69353>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
69353>>>>>//Type MEMORYSTATUS
69353>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
69353>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
69353>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
69353>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
69353>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
69353>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
69353>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
69353>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
69353>>>>>//End_Type
69353>>>>>
69353>>>>>// *** External Function calls: ***
69353>>>>>//
69353>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
69354>>>>>
69354>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
69355>>>>>
69355>>>>>
69355>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
69356>>>>>
69356>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
69357>>>>>
69357>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
69358>>>>>
69358>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
69359>>>>>
69359>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
69360>>>>>
69360>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
69361>>>>>
69361>>>>>// *** Global/Desktop Function Declarations: ***
69361>>>>>
69361>>>>>Function ComputerName Desktop Returns String
69363>>>>>    String sName
69363>>>>>    Get_Environment "COMPUTERNAME" to sName
69364>>>>>>
69364>>>>>    Function_Return sName
69365>>>>>End_Function
69366>>>>>
69366>>>>>Function Network_User_Name Desktop Returns String
69368>>>>>    String sName
69368>>>>>    Get_Environment "USERNAME" to sName
69369>>>>>>
69369>>>>>    Function_Return sName
69370>>>>>End_Function
69371>>>>>
69371>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
69373>>>>>    String sClient sDriver sClientDriver
69373>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
69373>>>>>    Handle hoMsqlDrv
69373>>>>>
69373>>>>>    Move 0 to iDriver
69374>>>>>    Move "" to sClient
69375>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
69378>>>>>    For iCount from 1 to iNumberOfDrivers
69384>>>>>>
69384>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
69387>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
69389>>>>>            Move iCount to iDriver
69390>>>>>            Move iNumberOfDrivers to iCount // We're done.
69391>>>>>        End
69391>>>>>>
69391>>>>>    Loop
69392>>>>>>
69392>>>>>
69392>>>>>    // This info is (at current) only available for the MS SQL driver:
69392>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
69394>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
69397>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
69398>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
69399>>>>>        Send Destroy of hoMsqlDrv
69400>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
69401>>>>>    End
69401>>>>>>
69401>>>>>
69401>>>>>    Function_Return sClient
69402>>>>>End_Function
69403>>>>>
69403>>>>>// *** Class Declarations: ***
69403>>>>>//
69403>>>>>Class cBitmapContainerDFLink is a BitmapContainer
69404>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
69406>>>>>        Send Mouse_Up iWindowNumber iPosition
69407>>>>>    End_Procedure
69408>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
69410>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
69412>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
69413>>>>>    End_Procedure
69414>>>>>End_Class
69415>>>>>
69415>>>>>Class cCopyEditorContentButton is a Button
69416>>>>>    Procedure Construct_Object
69418>>>>>        Forward Send Construct_Object
69420>>>>>        Property Handle phoEditorHandle
69421>>>>>        Set psToolTip to C_$DescCopy
69422>>>>>    End_Procedure
69423>>>>>
69423>>>>>    Procedure CopyToWindowsClipboard
69425>>>>>        Handle hoEditor
69425>>>>>        Boolean bCanCopy
69425>>>>>        Address aEditorAddress
69425>>>>>
69425>>>>>        Get phoEditorHandle to hoEditor
69426>>>>>        Send Select_All of hoEditor
69427>>>>>        Get CanCopy of hoEditor to bCanCopy
69428>>>>>        If (bCanCopy = True) Begin
69430>>>>>            Get paValue of hoEditor to aEditorAddress
69431>>>>>            Send Copy   of hoEditor
69432>>>>>            // Remove the selection after text is copied to the clipboard.
69432>>>>>            Send Beginning_of_Data of hoEditor
69433>>>>>            Send Info_Box C_$CopyToClipboard_Text
69434>>>>>        End
69434>>>>>>
69434>>>>>    End_Procedure
69435>>>>>End_Class
69436>>>>>
69436>>>>>Class SysinfoDisplay is a cTextEdit
69437>>>>>    Procedure Construct_Object
69439>>>>>        Forward Send Construct_Object
69441>>>>>
69441>>>>>        Set Size to 100 245
69442>>>>>        Set Location to 6 6
69443>>>>>        Set Border_Style to Border_None
69444>>>>>        Set Read_Only_State to True
69445>>>>>        Set pbWrap to True
69446>>>>>        Set peAnchors to anAll
69447>>>>>    End_Procedure
69448>>>>>
69448>>>>>    // Augmented class message to adjust certain text strings that are wrong...
69448>>>>>
69448>>>>>    Procedure AppendTextLn String sText
69450>>>>>        String sWorkspaceWSFile
69450>>>>>
69450>>>>>        // Only works for English:
69450>>>>>        If (ghoApplication > 0) Begin
69452>>>>>            If (sText contains "Workspace Name") Begin
69454>>>>>                Move "Workspace Config Filename:" to sText
69455>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
69456>>>>>                Move (sText * sWorkspaceWSFile) to sText
69457>>>>>            End
69457>>>>>>
69457>>>>>        End
69457>>>>>>
69457>>>>>        Send AppendText sText
69458>>>>>        Send AppendText (character(10))
69459>>>>>    End_Procedure
69460>>>>>
69460>>>>>    //    This method will show the name Of the current directory in the system
69460>>>>>    //    information box
69460>>>>>    Procedure Show_Current_Directory
69462>>>>>        String sDir
69462>>>>>
69462>>>>>        Get_Current_Directory To sDir
69463>>>>>
69463>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
69464>>>>>    End_Procedure
69465>>>>>
69465>>>>>    Procedure Show_Windows_Directory
69467>>>>>        String sWindir
69467>>>>>
69467>>>>>        Get_Windows_Directory To sWindir
69468>>>>>
69468>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
69469>>>>>    End_Procedure
69470>>>>>
69470>>>>>    Procedure Show_Current_User
69472>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
69473>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
69474>>>>>    End_Procedure
69475>>>>>
69475>>>>>    Procedure Show_Number_Format
69477>>>>>        Integer iFormat
69477>>>>>        String sFormatText
69477>>>>>
69477>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
69480>>>>>        Move (Character (iFormat)) To sFormatText
69481>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
69482>>>>>
69482>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
69485>>>>>        Move (Character (iFormat)) to sFormatText
69486>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
69487>>>>>    End_Procedure
69488>>>>>
69488>>>>>    Procedure Show_Filelist_Name
69490>>>>>        String sFilename
69490>>>>>
69490>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
69493>>>>>
69493>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
69494>>>>>    End_Procedure
69495>>>>>
69495>>>>>    Procedure Show_Lock_Delay
69497>>>>>        Integer iLockdelay
69497>>>>>
69497>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
69500>>>>>
69500>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
69501>>>>>    End_Procedure
69502>>>>>
69502>>>>>    Procedure Show_Lock_Timeout
69504>>>>>        Integer iLockTimeout
69504>>>>>
69504>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
69507>>>>>
69507>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
69508>>>>>    End_Procedure
69509>>>>>
69509>>>>>    Procedure Show_Screen_Size
69511>>>>>        Integer iYscreensize iXscreensize
69511>>>>>
69511>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
69512>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
69513>>>>>
69513>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
69514>>>>>    End_Procedure
69515>>>>>
69515>>>>>    Procedure Show_Page_Size
69517>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
69518>>>>>    End_procedure
69519>>>>>
69519>>>>>    Procedure Show_Date
69521>>>>>        Date dToday
69521>>>>>
69521>>>>>        Move (CurrentDateTime()) to dToday
69522>>>>>
69522>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
69523>>>>>    End_procedure
69524>>>>>
69524>>>>>    Procedure Show_Date_Format
69526>>>>>        Integer iDateFormat
69526>>>>>        String sDateFormat
69526>>>>>
69526>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
69529>>>>>        Case Begin
69529>>>>>            Case (iDateFormat = DF_DATE_USA)
69531>>>>>                Move C_$USA To sDateFormat
69532>>>>>                Case Break
69533>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
69536>>>>>                Move C_$European To sDateFormat
69537>>>>>                Case Break
69538>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
69541>>>>>                Move C_$Military To sDateFormat
69542>>>>>                Case Break
69543>>>>>            Case Else
69543>>>>>                Move C_$UnknownDateType To sDateFormat
69544>>>>>                Case Break
69545>>>>>        Case End
69545>>>>>
69545>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
69546>>>>>    End_Procedure
69547>>>>>
69547>>>>>    // 2013-08-14 NGS
69547>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
69547>>>>>    Procedure Show_Systemresources
69549>>>>>        tWinMemoryStatusEx MemoryStatusInfo
69549>>>>>        tWinMemoryStatusEx MemoryStatusInfo
69549>>>>>        Integer iRetval
69549>>>>>        Number nValue
69549>>>>>        String sValue
69549>>>>>
69549>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
69550>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
69551>>>>>        If (iRetval = 0) Begin
69553>>>>>            Move (ShowLastError ()) to iRetval
69554>>>>>            Procedure_Return
69555>>>>>        End
69555>>>>>>
69555>>>>>
69555>>>>>        Send AppendTextLn ""
69556>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
69557>>>>>
69557>>>>>        // Show memory in Gigabytes:
69557>>>>>        Move (nValue/1024/1024/1024) to nValue
69558>>>>>        Move (Round(nValue)) to nValue
69559>>>>>        Get FormatNumber nValue 2 to sValue
69560>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
69561>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
69562>>>>>
69562>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
69562>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
69563>>>>>        Move (Round(nValue)) to nValue
69564>>>>>        Get FormatNumber nValue 0 to sValue
69565>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
69566>>>>>
69566>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
69566>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
69567>>>>>        Move (Round(nValue)) to nValue
69568>>>>>        Get FormatNumber nValue 0 to sValue
69569>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
69570>>>>>
69570>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
69570>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
69571>>>>>        Move (Round(nValue)) to nValue
69572>>>>>        Get FormatNumber nValue 0 to sValue
69573>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
69574>>>>>
69574>>>>>        // Add an empty row after the memory information:
69574>>>>>        Send AppendTextLn ""
69575>>>>>    End_Procedure
69576>>>>>
69576>>>>>    Procedure Show_Registration
69578>>>>>        String sRegName
69578>>>>>        Integer iSN iUsersMax iUserCount
69578>>>>>
69578>>>>>        Registration sRegName iSN
69579>>>>>>
69579>>>>>        Get_Licensed_Max_Users to iUsersMax
69580>>>>>        Get_Current_User_Count to iUserCount
69581>>>>>
69581>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
69582>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
69583>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
69584>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
69585>>>>>    End_Procedure
69586>>>>>
69586>>>>>    //****************************************************************************
69586>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
69586>>>>>    // To the workspace object passing the an object and message To send back
69586>>>>>    // To this object. It is expected that the workspace object will send this
69586>>>>>    // message for every line Of information it wants displayed (passing the
69586>>>>>    // information To be displayed
69586>>>>>    //****************************************************************************
69586>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
69586>>>>>
69586>>>>>    Procedure Show_ServicePack
69588>>>>>        String sKey sVersion sDataFlex
69588>>>>>        Handle hoRegistry
69588>>>>>        Boolean bExists bOpened
69588>>>>>
69588>>>>>        Move "DataFlex"        to sDataFlex
69589>>>>>
69589>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
69590>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
69591>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
69592>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
69593>>>>>
69593>>>>>        If (bExists) Begin
69595>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
69596>>>>>        End
69596>>>>>>
69596>>>>>        Else Begin
69597>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
69598>>>>>        End
69598>>>>>>
69598>>>>>        Get KeyExists of hoRegistry sKey to bExists
69599>>>>>        If (bExists) Begin
69601>>>>>            Get OpenKey of hoRegistry sKey to bOpened
69602>>>>>            If (bOpened) Begin
69604>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
69605>>>>>                If (bExists) Begin
69607>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
69608>>>>>                End
69608>>>>>>
69608>>>>>                Send CloseKey of hoRegistry
69609>>>>>            End
69609>>>>>>
69609>>>>>        End
69609>>>>>>
69609>>>>>        Send Destroy of hoRegistry
69610>>>>>
69610>>>>>        If (sVersion <> "") Begin
69612>>>>>           Send AppendTextLn sVersion
69613>>>>>           Send AppendTextLn ""
69614>>>>>        End
69614>>>>>>
69614>>>>>    End_Procedure
69615>>>>>
69615>>>>>    Procedure Show_WorkspaceInformation
69617>>>>>        Integer hoWorkspace
69617>>>>>
69617>>>>>        If (ghoApplication <> 0) Begin
69619>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
69620>>>>>            If (hoWorkspace <> 0) Begin
69622>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
69623>>>>>            End
69623>>>>>>
69623>>>>>        End
69623>>>>>>
69623>>>>>    End_Procedure
69624>>>>>
69624>>>>>    //****************************************************************************
69624>>>>>    // If connection ids are used, we will send the message EnumerateConnections
69624>>>>>    // to the connection manager object passing the an object and message to send
69624>>>>>    // back to this object. It is expected that the connection manager object will
69624>>>>>    // send this message for every line Of information it wants displayed (passing
69624>>>>>    // the information To be displayed
69624>>>>>    //****************************************************************************
69624>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
69624>>>>>
69624>>>>>    Procedure Show_ConnectionIdInformation
69626>>>>>        If (ghoConnection > 0) Begin
69628>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
69629>>>>>            Send AppendTextLn ""
69630>>>>>        End
69630>>>>>>
69630>>>>>    End_Procedure
69631>>>>>
69631>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
69633>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
69634>>>>>    End_Function
69635>>>>>
69635>>>>>    Procedure Show_Versions
69637>>>>>        Integer iVersion iRevision iBuild
69637>>>>>
69637>>>>>        Version_information iVersion iRevision iBuild
69639>>>>>
69639>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
69640>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
69641>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
69642>>>>>        Send AppendTextLn "This is a 32-bit exe file"
69643>>>>>    End_Procedure
69644>>>>>
69644>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
69646>>>>>        Boolean bOK
69646>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
69647>>>>>        Function_Return bOK
69648>>>>>    End_Function
69649>>>>>
69649>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
69651>>>>>        Boolean bOK
69651>>>>>        Function_Return bOK
69652>>>>>    End_Function
69653>>>>>
69653>>>>>    //***
69653>>>>>    //*** BW
69653>>>>>    //*** Procedure: Show_Drivers
69653>>>>>    //*** Purpose  : Show loaded database drivers
69653>>>>>    //***
69653>>>>>
69653>>>>>    Procedure Show_Drivers
69655>>>>>        String sDriverID sVersion sClient sValue
69655>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
69655>>>>>        Handle hoCLIHandler hoBtrvHandler
69655>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
69655>>>>>
69655>>>>>        Move False to bStudioLicense
69656>>>>>
69656>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
69657>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
69658>>>>>
69658>>>>>        // For testing purposes:
69658>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
69658>>>>>//        Load_Driver MSSQLDRV_ID
69658>>>>>//        Load_Driver ODBC_DRV_ID
69658>>>>>//        Load_Driver DB2_DRV_ID
69658>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
69658>>>>>//
69658>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
69658>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
69658>>>>>//            Load_Driver SQLFLEX
69658>>>>>//            Load_Driver MDSPgSQL
69658>>>>>//            Load_Driver MDSMySQL
69658>>>>>//            Load_Driver ORAFLEX
69658>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
69658>>>>>//        #ENDIF
69658>>>>>        Move False to Err
69659>>>>>
69659>>>>>        // Loop through all loaded drivers.
69659>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
69662>>>>>        If (iNumberOfDrivers > 1) Begin
69664>>>>>            Send AppendTextLn ""
69665>>>>>        End
69665>>>>>>
69665>>>>>        For iDriver from 1 to iNumberOfDrivers
69671>>>>>>
69671>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
69671>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
69671>>>>>            // would be thrown, so we safeguard from that here.
69671>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
69672>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
69675>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
69676>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
69677>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
69678>>>>>
69678>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
69680>>>>>
69680>>>>>                // Pervasive/Btrieve database
69680>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
69682>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
69683>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
69684>>>>>                    If (sClient <> "0.0.0") Begin
69686>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
69687>>>>>                    End
69687>>>>>>
69687>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
69688>>>>>                    If (sClient <> "0.0.0") Begin
69690>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
69691>>>>>                    End
69691>>>>>>
69691>>>>>                End
69691>>>>>>
69691>>>>>
69691>>>>>                Else Begin
69692>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
69693>>>>>                    Move 0 to iNumServers
69694>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
69696>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
69699>>>>>                    End
69699>>>>>>
69699>>>>>
69699>>>>>                    If (bIsDAWDriver = True) Begin
69701>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
69703>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
69704>>>>>                        End
69704>>>>>>
69704>>>>>                        Get CKRevision of hoCLIHandler to sVersion
69705>>>>>                    End
69705>>>>>>
69705>>>>>
69705>>>>>                    If (bIsMertechDriver = True) Begin
69707>>>>>                    End
69707>>>>>>
69707>>>>>
69707>>>>>                    // If the serialnumber is = 0, it means that the
69707>>>>>                    // Studio licens is in use and there is no
69707>>>>>                    // number of max users defined because the driver is
69707>>>>>                    // relying on the info from the VDF license.
69707>>>>>                    If (bStudioLicense = False) Begin
69709>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
69710>>>>>                        Move (iSerialNo = 0) to bStudioLicense
69711>>>>>                    End
69711>>>>>>
69711>>>>>                End
69711>>>>>>
69711>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
69712>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
69714>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
69715>>>>>                End
69715>>>>>>
69715>>>>>                If (iNumServers <> 0) Begin
69717>>>>>                    For iCount from 1 to iNumServers
69723>>>>>>
69723>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
69726>>>>>                        If (not(sValue contains ";PWD=")) Begin
69728>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
69729>>>>>                        End
69729>>>>>>
69729>>>>>                    Loop
69730>>>>>>
69730>>>>>                End
69730>>>>>>
69730>>>>>            End
69730>>>>>>
69730>>>>>        Loop
69731>>>>>>
69731>>>>>
69731>>>>>        Send AppendTextLn ""
69732>>>>>        If (bStudioLicense = False) Begin
69734>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
69735>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
69736>>>>>        End
69736>>>>>>
69736>>>>>        Else Begin
69737>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
69738>>>>>        End
69738>>>>>>
69738>>>>>        Send Destroy of hoCLIHandler
69739>>>>>        Send Destroy of hoBtrvHandler
69740>>>>>    End_Procedure
69741>>>>>
69741>>>>>    Procedure Show_HelpFile
69743>>>>>        String sHelpFile
69743>>>>>        Integer eHelpType
69743>>>>>
69743>>>>>        If (ghoApplication <> 0) Begin
69745>>>>>            Get peHelpType Of ghoApplication To eHelpType
69746>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
69748>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
69749>>>>>            End
69749>>>>>>
69749>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
69752>>>>>                Get Help_filename Of Help_object_id To sHelpFile
69753>>>>>            End
69753>>>>>>
69753>>>>>            Else Begin
69754>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
69755>>>>>            End
69755>>>>>>
69755>>>>>
69755>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
69756>>>>>        End
69756>>>>>>
69756>>>>>    End_Procedure
69757>>>>>
69757>>>>>    Procedure Show_EnterAsTab
69759>>>>>        Boolean bEnterKeyAsTabKey
69759>>>>>        String sText
69759>>>>>
69759>>>>>        If (ghoApplication <> 0) Begin
69761>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
69762>>>>>            If (bEnterKeyAsTabKey) Begin
69764>>>>>                Move "True" To sText
69765>>>>>            End
69765>>>>>>
69765>>>>>            Else Begin
69766>>>>>                Move "False" To sText
69767>>>>>            End
69767>>>>>>
69767>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
69768>>>>>        End
69768>>>>>>
69768>>>>>    End_Procedure
69769>>>>>
69769>>>>>    //    During activation we will remove the old information and add the newly
69769>>>>>    //    found systeminformation
69769>>>>>    Procedure Add_Focus Integer hoRoot
69771>>>>>        Forward Send Add_Focus hoRoot
69773>>>>>
69773>>>>>        Send Delete_Data
69774>>>>>
69774>>>>>        Set Changed_State To False
69775>>>>>        Set Read_Only_State To True
69776>>>>>
69776>>>>>        Send Show_Registration
69777>>>>>        Send Show_Drivers
69778>>>>>        Send Show_ServicePack
69779>>>>>        Send Show_Versions
69780>>>>>        Send AppendTextLn ""
69781>>>>>
69781>>>>>        If (ghoApplication <> 0) Begin
69783>>>>>            Send Show_WorkSpaceInformation
69784>>>>>            Send Show_HelpFile
69785>>>>>            Send AppendTextLn ""
69786>>>>>        End
69786>>>>>>
69786>>>>>        Else Begin
69787>>>>>            Send AppendTextLn ""
69788>>>>>        End
69788>>>>>>
69788>>>>>
69788>>>>>        If (ghoConnection <> 0) Begin
69790>>>>>            Send Show_ConnectionIdInformation
69791>>>>>        End
69791>>>>>>
69791>>>>>
69791>>>>>        Send Show_Current_User
69792>>>>>        Send Show_Windows_Directory
69793>>>>>        Send Show_Current_Directory
69794>>>>>
69794>>>>>        // This is already shown in the workspace details,
69794>>>>>        // unless no workspace object is present:
69794>>>>>        If (ghoApplication = 0) Begin
69796>>>>>            Send Show_Filelist_Name
69797>>>>>        End
69797>>>>>>
69797>>>>>
69797>>>>>        If (ghoApplication <> 0) Begin
69799>>>>>            Send AppendTextLn ""
69800>>>>>            Send Show_EnterAsTab
69801>>>>>        End
69801>>>>>>
69801>>>>>
69801>>>>>        Send Show_Screen_Size
69802>>>>>        Send Show_Page_Size
69803>>>>>        Send Show_Number_Format
69804>>>>>        Send Show_Date_Format
69805>>>>>        Send Show_Lock_Delay
69806>>>>>        Send Show_Lock_Timeout
69807>>>>>        Send Show_Date
69808>>>>>        Send Show_Systemresources
69809>>>>>        Send Beginning_of_Data
69810>>>>>
69810>>>>>        Set Icon to 'default.ico'
69811>>>>>    End_Procedure
69812>>>>>End_Class
69813>>>>>
69813>>>>>Class SysInfoDialog is a ModalPanel
69814>>>>>    Procedure Construct_Object
69816>>>>>        Forward Send Construct_Object
69818>>>>>
69818>>>>>        Set Label to C_$SystemInformation
69819>>>>>        Set Size to 140 267
69820>>>>>        Set Locate_Mode to CENTER_ON_PARENT
69821>>>>>        Set Border_Style to Border_Thick
69822>>>>>        Set Sysmenu_Icon to False
69823>>>>>
69823>>>>>        // "+1" will make the panel to paint correctly.
69823>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
69824>>>>>
69824>>>>>        // 2014-09-14 NGS
69824>>>>>        // Added a container object around the cTexteditor
69824>>>>>        // object to get a border around the text.
69824>>>>>        Object oSysinfoDisplayContainer is a Container3d
69826>>>>>            Set Location to 2 4
69827>>>>>            Set Size to 110 255
69828>>>>>            Set Border_Style to Border_ClientEdge
69829>>>>>            Set Color to clWhite
69830>>>>>            Set peAnchors to anAll
69831>>>>>
69831>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
69833>>>>>            End_Object
69834>>>>>
69834>>>>>        End_Object
69835>>>>>
69835>>>>>        Object oCloseButton is a Button
69837>>>>>            Set Label to C_$Close
69838>>>>>            Set Location to 120 210
69839>>>>>            Set Message item 0 to msg_Close_Panel
69840>>>>>            Set Default_State To True
69841>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
69841>>>>>            // and changes its peAnchors, we might as well prepare this object
69841>>>>>            // for that situation.
69841>>>>>            Set peAnchors to anBottomRight
69842>>>>>        End_Object
69843>>>>>
69843>>>>>        Object oCopyButton is a cCopyEditorContentButton
69845>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
69846>>>>>            Set Size to 14 50
69847>>>>>            Set Location to 120 158
69848>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
69848>>>>>            // we might as well prepare the object for it.
69848>>>>>            Set peAnchors to anBottomRight
69849>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
69850>>>>>        End_Object
69851>>>>>
69851>>>>>        On_Key kCancel Send Close_Panel
69852>>>>>    End_Procedure
69853>>>>>
69853>>>>>    Procedure Page Integer iPageObject
69855>>>>>        Handle hMenu
69855>>>>>        Integer iPrevState
69855>>>>>
69855>>>>>        Forward Send Page iPageObject
69857>>>>>
69857>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
69857>>>>>        //
69857>>>>>    End_Procedure
69858>>>>>
69858>>>>>End_Class
69859>>>>>
69859>>>>>Class cAboutEdit is an cRichEdit
69860>>>>>    Procedure Construct_Object
69862>>>>>        Forward Send Construct_Object
69864>>>>>
69864>>>>>        Property String psContentText
69865>>>>>
69865>>>>>        Set Size to 77 153
69866>>>>>        Set Location to 8 60
69867>>>>>        Set Read_Only_State to True
69868>>>>>        Set Skip_State to True
69869>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
69869>>>>>        // or 1/20 of a printer's point.
69869>>>>>        Set piRightMargin to (0.1 * 1440)
69870>>>>>        Set Border_Style  to Border_None
69871>>>>>    End_Procedure
69872>>>>>
69872>>>>>    // Adds a line of text to the edit object
69872>>>>>    Procedure Add_Line String sText
69874>>>>>        String sContentText
69874>>>>>        Get psContentText to sContentText
69875>>>>>        Move (sContentText + String(sText)) to sContentText
69876>>>>>        Set psContentText to sContentText
69877>>>>>    End_Procedure
69878>>>>>
69878>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
69878>>>>>    // Note that we use a property psContentText and add to it,
69878>>>>>    // because the object isn't paged yet when we add these
69878>>>>>    // values and the COM edit object needs to be paged
69878>>>>>    // for the text to become visible. See Also: Procedure Page below.
69878>>>>>    Procedure Add_LineLn String sText
69880>>>>>        String sContentText sCR
69880>>>>>
69880>>>>>        Move (Character(10) + String(Character(13))) to sCR
69881>>>>>        Get psContentText to sContentText
69882>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
69883>>>>>        Set psContentText to sContentText
69884>>>>>    End_Procedure
69885>>>>>
69885>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
69887>>>>>        String sLinkText
69887>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
69888>>>>>        Send Show_HomePage sLinkText
69889>>>>>    End_Procedure
69890>>>>>
69890>>>>>    Procedure Page Integer iPageObject
69892>>>>>        String sContentText
69892>>>>>
69892>>>>>        Forward Send Page iPageObject
69894>>>>>        Get psContentText to sContentText
69895>>>>>        Send AppendText sContentText
69896>>>>>        send Beginning_of_Data
69897>>>>>    End_Procedure
69898>>>>>
69898>>>>>End_Class
69899>>>>>
69899>>>>>Class AboutDialog is a ModalPanel
69900>>>>>    Procedure Construct_Object
69902>>>>>
69902>>>>>        Forward Send Construct_Object
69904>>>>>
69904>>>>>        Set Label to C_$About
69905>>>>>        Set Size to 118 230
69906>>>>>        Set Locate_Mode to CENTER_ON_PARENT
69907>>>>>        Set Border_Style to Border_Thick
69908>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
69909>>>>>
69909>>>>>        Object oSysInfoDialog is a SysInfoDialog
69911>>>>>        End_Object
69912>>>>>
69912>>>>>        Object oBox is a Container3d
69914>>>>>            Set Border_Style to Border_Normal
69915>>>>>            Set Size to 90 220
69916>>>>>            Set Location to 4 5
69917>>>>>            Set Color to clWhite
69918>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
69918>>>>>            // we might as well prepare the object for it.
69918>>>>>            Set peAnchors to anAll
69919>>>>>
69919>>>>>            Object oAboutGraphic is a BitmapContainer
69921>>>>>                Set Border_Style To Border_None
69922>>>>>                Set Bitmap_Style to Bitmap_Center
69923>>>>>                Set Color to clWhite
69924>>>>>                Set Size to 45 50
69925>>>>>                Set Location to 0 3
69926>>>>>            End_Object
69927>>>>>
69927>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
69929>>>>>                Set Border_Style to Border_None
69930>>>>>                Set Bitmap_Style to Bitmap_Center
69931>>>>>                Set Color to clWhite
69932>>>>>                Set Size to 30 55
69933>>>>>                Set Location to 50 3
69934>>>>>            End_Object
69935>>>>>
69935>>>>>            Object oInfoList_Editor is an cAboutEdit
69937>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
69937>>>>>                // we might as well prepare the object for it.
69937>>>>>                Set peAnchors to anAll
69938>>>>>            End_Object
69939>>>>>
69939>>>>>            // These objects are here for backwards compatability only.
69939>>>>>            // They are not used.
69939>>>>>            Object oProductName is a TextBox
69941>>>>>                Set Label To C_$ProductName
69942>>>>>                Set Size To 10 45
69943>>>>>                Set Location To 8 53
69944>>>>>                Set Visible_State to False
69945>>>>>                Set Focus_Mode to NonFocusable
69946>>>>>            End_Object
69947>>>>>
69947>>>>>            Object oVersion is a TextBox
69949>>>>>                Set Label To C_$Version
69950>>>>>                Set Size To 10 25
69951>>>>>                Set Location To 21 53
69952>>>>>                Set Visible_State to False
69953>>>>>                Set Focus_Mode to NonFocusable
69954>>>>>            End_Object
69955>>>>>
69955>>>>>            Object oCopyright is a TextBox
69957>>>>>                Set Label To C_$Copyright
69958>>>>>                Set Size To 10 31
69959>>>>>                Set Location To 34 53
69960>>>>>                Set Visible_State to False
69961>>>>>                Set Focus_Mode to NonFocusable
69962>>>>>            End_Object
69963>>>>>
69963>>>>>            Object oAuthor is a TextBox
69965>>>>>                Set Label To C_$Author
69966>>>>>                Set Size To 10 22
69967>>>>>                Set Location To 46 53
69968>>>>>                Set Visible_State to False
69969>>>>>                Set Focus_Mode to NonFocusable
69970>>>>>            End_Object
69971>>>>>
69971>>>>>        End_Object
69972>>>>>
69972>>>>>        Object oOKButton is a Button
69974>>>>>            On_Item C_$Close Send Close_Panel
69975>>>>>            Set Location to 98 176
69976>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
69976>>>>>            // we might as well prepare the object for it.
69976>>>>>            Set peAnchors to anBottomRight
69977>>>>>        End_Object
69978>>>>>
69978>>>>>        Object oSysInfoButton is a Button
69980>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
69981>>>>>            Set Location to 98 123
69982>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
69982>>>>>            // we might as well prepare the object for it.
69982>>>>>            Set peAnchors to anBottomRight
69983>>>>>        End_Object
69984>>>>>
69984>>>>>        Object oCopyButton is a cCopyEditorContentButton
69986>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
69987>>>>>            Set Size to 14 50
69988>>>>>            Set Location to 98 70
69989>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
69989>>>>>            // we might as well prepare the object for it.
69989>>>>>            Set peAnchors to anBottomRight
69990>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
69991>>>>>        End_Object
69992>>>>>
69992>>>>>        On_Key Kcancel Send KeyAction of oOKButton
69993>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
69994>>>>>        Set LogoDF to "DF32.bmp"
69995>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
69995>>>>>    End_Procedure
69996>>>>>
69996>>>>>    Procedure Page Integer iPageObject
69998>>>>>        Handle hMenu
69998>>>>>        Integer iPrevState
69998>>>>>
69998>>>>>        Forward Send Page iPageObject
70000>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
70000>>>>>        Set Icon to "Default.ico"
70001>>>>>
70001>>>>>        // Shadow upper left corner menu items: (icon menu items)
70001>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
70002>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
70003>>>>>        // The "Move" menu command may come in handy to have.
70003>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
70003>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
70004>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
70005>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
70006>>>>>        // The "Close" menu command may be good to have.
70006>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
70006>>>>>    End_Procedure
70007>>>>>
70007>>>>>    Procedure Set ProductName String sText
70009>>>>>        Set Value of oProductName to sText
70010>>>>>    End_Procedure
70011>>>>>
70011>>>>>    Procedure Set Copyright String sText
70013>>>>>        Set Value of oCopyright to sText
70014>>>>>    End_Procedure
70015>>>>>
70015>>>>>    Procedure Set Author String sText
70017>>>>>        Set Value of oAuthor to sText
70018>>>>>    End_Procedure
70019>>>>>
70019>>>>>    Procedure Set Version String sVersion
70021>>>>>        Handle hoVersionInfo
70021>>>>>        Boolean bIncluded
70021>>>>>        Integer iMajor iMinor iRelease iBuild
70021>>>>>        Date dCompileDate
70021>>>>>        String sCertInfo
70021>>>>>
70021>>>>>        If (sVersion = "") Begin
70023>>>>>            // This automatically shows the program version of the program, if available.
70023>>>>>            // It will be displayed as the second item in the edit object.
70023>>>>>            If (ghoApplication <> 0) Begin
70025>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
70026>>>>>                If (hoVersionInfo <> 0) Begin
70028>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
70029>>>>>                    If (bIncluded) Begin
70031>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
70032>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
70033>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
70034>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
70035>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
70036>>>>>                    End
70036>>>>>>
70036>>>>>                End
70036>>>>>>
70036>>>>>            End
70036>>>>>>
70036>>>>>        End
70036>>>>>>
70036>>>>>
70036>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
70036>>>>>        Get GetCompileDate to dCompileDate
70037>>>>>        If (sVersion <> "") Begin
70039>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
70040>>>>>        End
70040>>>>>>
70040>>>>>
70040>>>>>        Get IsProgramDigitallySigned to sCertInfo
70041>>>>>        If (sCertInfo <> "-1") Begin
70043>>>>>            If (sCertInfo <> "") Begin
70045>>>>>                Send Add_LineLn sCertInfo
70046>>>>>            End
70046>>>>>>
70046>>>>>            Else Begin
70047>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
70048>>>>>            End
70048>>>>>>
70048>>>>>        End
70048>>>>>>
70048>>>>>    End_Procedure
70049>>>>>
70049>>>>>    Function IsDate String sDate Returns Boolean
70051>>>>>        Boolean bIsDate
70051>>>>>        String sGoodCharacters sChar
70051>>>>>        Integer iCount iLength
70051>>>>>
70051>>>>>        Move True to bIsDate
70052>>>>>        Move "0123456789-/" to sGoodCharacters
70053>>>>>        Move (Length(sDate)) to iLength
70054>>>>>        For iCount from 1 to iLength
70060>>>>>>
70060>>>>>            Move (Left(sDate, 1)) to sChar
70061>>>>>            Move (Mid(sDate, 12, 2)) to sDate
70062>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
70063>>>>>            If (bIsDate = False) Begin
70065>>>>>                Move iLength to iCount
70066>>>>>            End
70066>>>>>>
70066>>>>>        Loop
70067>>>>>>
70067>>>>>        Function_Return bIsDate
70068>>>>>    End_Function
70069>>>>>
70069>>>>>    Function GetCompileDate Returns Date
70071>>>>>        Date dCompileDate
70071>>>>>        String sAppFilename sProgram sData sCompileDate
70071>>>>>        Integer iChannel iPos iDateFormat iCount iSize
70071>>>>>        Boolean bIsValid
70071>>>>>
70071>>>>>        Move 0 to dCompileDate
70072>>>>>        // Get full path to the current running executable
70072>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
70073>>>>>        Get GetApplicationName     of ghoApplication to sProgram
70074>>>>>
70074>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
70074>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
70075>>>>>
70075>>>>>        Get_Argument_Size to iSize
70076>>>>>        Set_Argument_Size 9000000
70077>>>>>>
70077>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
70079>>>>>        Move (Pos(sProgram,sData)) to iPos
70080>>>>>        If (iPos > 0) Begin
70082>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
70082>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
70083>>>>>
70083>>>>>            // If the current date format is non US, we need to temporary
70083>>>>>            // change the format and then move the string to the date variable.
70083>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
70086>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
70089>>>>>            Move (Date(sCompileDate))    to dCompileDate
70090>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
70093>>>>>        End
70093>>>>>>
70093>>>>>        Else Begin
70094>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
70095>>>>>>
70095>>>>>        End
70095>>>>>>
70095>>>>>
70095>>>>>        Send Seq_Close_Channel iChannel
70096>>>>>        Set_Argument_Size iSize
70097>>>>>>
70097>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
70097>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
70097>>>>>
70097>>>>>        // The data is padded with Character(0)s. Strip them out
70097>>>>>//        Move (CString(sData)) to sData
70097>>>>>
70097>>>>>        // The compile date is after the first ", ", so string parsing is required
70097>>>>>//        Move (Pos(", ", sData)) to iPos
70097>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
70097>>>>>        // If the current date format is non US, we need to temporary
70097>>>>>        // change the format and then move the string to the date variable.
70097>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
70097>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
70097>>>>>//
70097>>>>>//        // Note the build in IsDateValid can return the wrong result
70097>>>>>//        // when controls characters are part of the sCompileDate.
70097>>>>>//        Get IsDate sCompileDate))           to bIsValid
70097>>>>>//        If (bIsValid = True) Begin
70097>>>>>//            Move (Date(sCompileDate))       to dCompileDate
70097>>>>>//        End
70097>>>>>//
70097>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
70097>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
70097>>>>>//        // until we encounter the program name that appears just in front of the compile date.
70097>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
70097>>>>>//        If (dCompileDate = 0) Begin
70097>>>>>//            Move "" to sCompileDate
70097>>>>>//            Move 30000 to iSize
70097>>>>>//            For iCount from 1 to iSize
70097>>>>>//                Readln channel iChannel sData
70097>>>>>//                Move (Pos(sProgram, sData)) to iPos
70097>>>>>//                If (iPos <> 0) Begin
70097>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
70097>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
70097>>>>>//                    Move iSize to iCount // We're out of here.
70097>>>>>//                End
70097>>>>>//            Loop
70097>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
70097>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
70097>>>>>//            End
70097>>>>>//            Get IsDate sCompileDate)) to bIsValid
70097>>>>>//            If (bIsValid = True) Begin
70097>>>>>//                Move (Date(sCompileDate)) to dCompileDate
70097>>>>>//            End
70097>>>>>//        End
70097>>>>>//        Send Seq_Close_Channel iChannel
70097>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
70097>>>>>
70097>>>>>        Function_Return dCompileDate
70098>>>>>    End_Function
70099>>>>>
70099>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
70099>>>>>    // (the passed program), has been finished
70099>>>>>    // The DOS box does also _not_ flash briefly.
70099>>>>>    Procedure RunProgramWait String sProgram String sParameter
70101>>>>>        Handle hProcess
70101>>>>>        Integer iVoid
70101>>>>>        AboutSHELLEXECUTEINFO sInfo
70101>>>>>        AboutSHELLEXECUTEINFO sInfo
70101>>>>>
70101>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
70102>>>>>
70102>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
70103>>>>>        Move SW_SHOW                 to sInfo.nShow
70104>>>>>
70104>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
70105>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
70106>>>>>        // This will "hide" the DOS box from showing (no flasing box):
70106>>>>>        Move 0                       to sInfo.nShow
70107>>>>>
70107>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
70108>>>>>        Move sInfo.hProcess to hProcess
70109>>>>>        If (hProcess) Begin
70111>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
70112>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
70113>>>>>        End
70113>>>>>>
70113>>>>>    End_Procedure
70114>>>>>
70114>>>>>    Function AddFolderDelimiter String sPath Returns String
70116>>>>>        String sDirSep
70116>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
70117>>>>>        Move (Trim(sPath)) to sPath
70118>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
70120>>>>>            Move (sPath + sDirSep) to sPath
70121>>>>>        End
70121>>>>>>
70121>>>>>        Function_Return sPath
70122>>>>>    End_Function
70123>>>>>
70123>>>>>    // Returns an empty string if the current program is not digitally signed,
70123>>>>>    // or there is a problem with the certificate.
70123>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
70123>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
70123>>>>>    Function IsProgramDigitallySigned Returns String
70125>>>>>        Boolean bExists
70125>>>>>        String sPath sProgram sParams sRetval
70125>>>>>        Integer iCh
70125>>>>>
70125>>>>>        Move "" to sRetval
70126>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
70127>>>>>        Get AddFolderDelimiter sPath to sPath
70128>>>>>        File_Exist (sPath + CS_SignProgram) bExists
70129>>>>>        If (bExists = False) Begin
70131>>>>>            Function_Return "-1"
70132>>>>>        End
70132>>>>>>
70132>>>>>
70132>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
70133>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
70134>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
70135>>>>>        Move (sParams * String("| clip"))    to sParams
70136>>>>>        Get Seq_New_Channel to iCh
70137>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
70139>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
70142>>>>>        Close_Output channel iCh
70144>>>>>        // New ShellExecute based message that waits for the passed process to end.
70144>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
70145>>>>>        Direct_Input channel iCh "CLIPBOARD:"
70147>>>>>            Readln channel iCh sRetval
70149>>>>>            Readln channel iCh sRetval
70151>>>>>            Readln channel iCh sRetval
70153>>>>>            Readln channel iCh sRetval
70155>>>>>        Close_Input channel iCh
70157>>>>>        Send Seq_Release_Channel iCh
70158>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
70160>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
70161>>>>>        End
70161>>>>>>
70161>>>>>        Else Begin
70162>>>>>            Move "" to sRetval
70163>>>>>        End
70163>>>>>>
70163>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
70163>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
70164>>>>>>
70164>>>>>        Function_Return sRetval
70165>>>>>    End_Function
70166>>>>>
70166>>>>>    Procedure Add_LineLn String sValue
70168>>>>>        Send Add_LineLn of oInfoList_Editor sValue
70169>>>>>    End_Procedure
70170>>>>>
70170>>>>>    Procedure Add_Line String sValue
70172>>>>>        Send Add_Line of oInfoList_Editor sValue
70173>>>>>    End_Procedure
70174>>>>>
70174>>>>>    Procedure Set Logo string sLogo
70176>>>>>        // Square bitmaps of 80x80 work best
70176>>>>>        Set Bitmap of oAboutGraphic to sLogo
70177>>>>>    End_Procedure
70178>>>>>
70178>>>>>    Procedure Set LogoDF String sLogo
70180>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
70181>>>>>    End_Procedure
70182>>>>>
70182>>>>>    Procedure Show_Sysinfo
70184>>>>>        Send Popup_Modal of oSysinfoDialog
70185>>>>>    End_Procedure
70186>>>>>
70186>>>>>    Procedure Show_HomePage String sWebpage
70188>>>>>        Handle hWnd
70188>>>>>        Get Window_Handle to hWnd
70189>>>>>        Runprogram Shell Background (Trim(sWebpage))
70190>>>>>    End_Procedure
70191>>>>>
70191>>>>>End_Class
70192>>>
70192>>>// *************************************************************************
70192>>>//  Public message. This is the default message. It is expected that you will
70192>>>//   create your own message to override this
70192>>>// *************************************************************************
70192>>>
70192>>>Procedure Activate_About
70195>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
70196>>>End_Procedure
70197>>>
70197>>>// *************************************************************************
70197>>>//  Public message. It is expected that you will send this message (most
70197>>>//  likely from Activate_About. This creates an about object, activates it
70197>>>//  and destroys it when done. It is not exepected that you will augment this.
70197>>>// *************************************************************************
70197>>>// Sample usage:
70197>>>//   The first two params will automatically be filled from the application settings if not provided.
70197>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
70197>>>
70197>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
70200>>>    Integer hoObj hoMain iArgs
70200>>>    String sValue
70200>>>
70200>>>    // Create object
70200>>>    Object About is an AboutDialog
70202>>>    // Uncomment these two lines if you would like to have a resizable About object.
70202>>>    //            Set Border_Style to Border_Thick
70202>>>    //            Set peAnchors to anAll
70202>>>
70202>>>    // Add checking for the number of arguments passed to avoid runtime errors
70202>>>    // if one of them is not passed. This makes the interface
70202>>>    // more flexible.
70202>>>        Move num_arguments to iArgs
70203>>>
70203>>>        // If no title is passed use the label of the main panel (if a main panel exists).
70203>>>        If (iArgs > 0 and sTitle = "") Begin
70205>>>            Get Main_Window of Desktop to hoMain
70206>>>            If hoMain Begin
70208>>>                Get Label of hoMain to sValue
70209>>>            End
70209>>>>
70209>>>        End
70209>>>>
70209>>>        Else If (iArgs > 0 and sTitle <> "") Begin
70212>>>            Move sTitle to sValue
70213>>>        End
70213>>>>
70213>>>        Else If (iArgs = 0) Begin
70216>>>            Get Main_Window of Desktop to hoMain
70217>>>            If hoMain Begin
70219>>>                Get Label of hoMain to sValue
70220>>>            End
70220>>>>
70220>>>        End
70220>>>>
70220>>>
70220>>>        If (sValue <> "") Begin
70222>>>            Send Add_LineLn sValue
70223>>>        End
70223>>>>
70223>>>        Move "" to sValue
70224>>>
70224>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
70224>>>        // For this to work the Project Properties Version must have been set in the Studio.
70224>>>        If (iArgs < 2) Begin
70226>>>            Move "" to sValue
70227>>>        End
70227>>>>
70227>>>        Else Begin
70228>>>            Move sVersion to sValue
70229>>>        End
70229>>>>
70229>>>        Set Version to sValue
70230>>>
70230>>>        If (iArgs > 2 and sCopyRight <> "") Begin
70232>>>            Send Add_LineLn sCopyRight
70233>>>        End
70233>>>>
70233>>>
70233>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
70233>>>        // else we do.
70233>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
70235>>>            Send Add_Line sAuthor
70236>>>        End
70236>>>>
70236>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
70239>>>            Send Add_LineLn sAuthor
70240>>>        End
70240>>>>
70240>>>
70240>>>        // Square bitmaps of 80x80 works best
70240>>>        If (iArgs > 4 and sBitmap <> "") Begin
70242>>>            Set Logo to sBitMap
70243>>>        End
70243>>>>
70243>>>
70243>>>        // Here starts handling of the five optional params:
70243>>>        If (iArgs = 6 and sParam6  <> "") Begin
70245>>>            Send Add_Line sParam6
70246>>>        End
70246>>>>
70246>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
70249>>>            Send Add_LineLn sParam6
70250>>>        End
70250>>>>
70250>>>
70250>>>        If (iArgs = 7 and sParam7  <> "") Begin
70252>>>            Send Add_Line sParam7
70253>>>        End
70253>>>>
70253>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
70256>>>            Send Add_LineLn sParam7
70257>>>        End
70257>>>>
70257>>>
70257>>>        If (iArgs = 8 and sParam8  <> "") Begin
70259>>>            Send Add_Line sParam8
70260>>>        End
70260>>>>
70260>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
70263>>>            Send Add_LineLn sParam8
70264>>>        End
70264>>>>
70264>>>
70264>>>        If (iArgs = 9 and sParam9  <> "") Begin
70266>>>            Send Add_Line sParam9
70267>>>        End
70267>>>>
70267>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
70270>>>            Send Add_LineLn sParam9
70271>>>        End
70271>>>>
70271>>>
70271>>>        If (iArgs = 10 and sParam10 <> "") Begin
70273>>>            Send Add_Line sParam10
70274>>>        End
70274>>>>
70274>>>
70274>>>        Move Self to hoObj
70275>>>    End_Object
70276>>>
70276>>>    Send Popup   of hoObj // Popup the about object
70277>>>    Send Destroy of hoObj // When done, it will be destroyed
70278>>>End_Procedure
70279>        Use MaintainFunctions.vw
Including file: MaintainFunctions.vw    (C:\Projects\DF18\DfRefactor\AppSrc\MaintainFunctions.vw)
70279>>>// C:\Projects\DF18\DfRefactor\AppSrc\MaintainFunctions.vw
70279>>>// Maintain Functions
70279>>>//
70279>>>
70279>>>Use DFClient.pkg
70279>>>Use DFEntry.pkg
70279>>>Use DFEnChk.pkg
70279>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridColumnRowIndicator.pkg)
70279>>>>>Use cCJGridColumn.pkg
70279>>>>>
70279>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
70280>>>>>    
70280>>>>>    Procedure Construct_Object
70282>>>>>        Forward Send Construct_Object
70284>>>>>        
70284>>>>>        Property Integer piImage 0
70285>>>>>        
70285>>>>>        Set psCaption to ""
70286>>>>>        Set piWidth to 20
70287>>>>>        Set pbResizable to False
70288>>>>>        Set pbEditable to False
70289>>>>>        Set pbFocusable to False
70290>>>>>        Set pbAllowDrag to False
70291>>>>>        Set psToolTip to "Row Indicator"
70292>>>>>    End_Procedure
70293>>>>>    
70293>>>>>    Procedure OnCreateColumn
70295>>>>>        Integer iImage
70295>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
70297>>>>>        Set piImage to iImage
70298>>>>>    End_Procedure
70299>>>>>    
70299>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
70301>>>>>        Integer iImage iFocusedRow
70301>>>>>        Handle hoDataSource
70301>>>>>        
70301>>>>>        Get phoDataSource to hoDataSource
70302>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
70303>>>>>        Move -1 to iImage
70304>>>>>        If (iRow = iFocusedRow) Begin
70306>>>>>            Get piImage to iImage
70307>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
70308>>>>>        End
70308>>>>>>
70308>>>>>    End_Procedure
70309>>>>>    
70309>>>>>End_Class
70310>>>
70310>>>Use cRDCDbCJGrid.pkg
Including file: cRDCDbCJGrid.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGrid.pkg)
70310>>>>>Use cDbCJGrid.pkg
70310>>>>>Use cRDCDbCJGridColumnHyperLink.pkg
Including file: cRDCDbCJGridColumnHyperLink.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGridColumnHyperLink.pkg)
70310>>>>>>>// Written by Peter Bragg.
70310>>>>>>>// Subclass for using hyperlinks in cDbCJGrid/cCJGrid column objects.
70310>>>>>>>//
70310>>>>>>>// Set pbHyperLink to True and it will call the Function "IsHyperLink" passing the Row Index.
70310>>>>>>>// To be honest you don't really need this property at all - the function on its own would do.
70310>>>>>>>//
70310>>>>>>>// Anyway, code this function accordingly to return True or False If the row value for that column
70310>>>>>>>// should be displayed as a hyperlink or not. (Within this Function you can call "Get RowValue"
70310>>>>>>>// to Get the value for that column)
70310>>>>>>>//
70310>>>>>>>// All you then need to do is Add the following to your Grid Class:
70310>>>>>>>//
70310>>>>>>>//    Procedure OnComHyperlinkClick Variant llRow Variant llItem Integer llHyperlinkIndex
70310>>>>>>>//        Handle  hoRow hoItem hoColumn
70310>>>>>>>//        String  sLink
70310>>>>>>>//        Integer iRow iColumn
70310>>>>>>>//
70310>>>>>>>//        Get phoReportRow to hoRow
70310>>>>>>>//        Get phoReportRecordItem to hoItem
70310>>>>>>>//
70310>>>>>>>//        Set pvComObject of hoItem to llItem
70310>>>>>>>//        Get ComIndex    of hoItem to iColumn
70310>>>>>>>//        Set pvComObject of hoRow to llRow
70310>>>>>>>//        Get ComIndex    of hoRow to iRow
70310>>>>>>>//        Get ColumnObject iColumn to hoColumn
70310>>>>>>>//        Get RowValue of hoColumn iRow to sLink
70310>>>>>>>//
70310>>>>>>>//        Send OnLinkClicked of hoColumn sLink iRow
70310>>>>>>>//    End_Procedure
70310>>>>>>>
70310>>>>>>>Use cDbCJGridColumn.pkg
70310>>>>>>>
70310>>>>>>>Class cDbCJGridColumnHyperLink is a cDbCJGridColumn
70311>>>>>>>
70311>>>>>>>    Procedure Construct_Object
70313>>>>>>>        Forward Send Construct_Object
70315>>>>>>>
70315>>>>>>>        Property Boolean pbHyperlink    False
70316>>>>>>>    End_Procedure
70317>>>>>>>
70317>>>>>>>    Function IsHyperlink Integer iRow Returns Boolean
70319>>>>>>>        Function_Return False
70320>>>>>>>    End_Function
70321>>>>>>>
70321>>>>>>>    Procedure OnLinkClicked String sLink Integer iRow
70323>>>>>>>    End_Procedure
70324>>>>>>>
70324>>>>>>>    Procedure DrawCell Handle hoRow Handle hoItem Handle hoMetrics Integer iRow String sValue
70326>>>>>>>        Boolean bIsHyperlink
70326>>>>>>>        Variant vHyperLinks vHyperLink
70326>>>>>>>        Handle  hoHyperLinks
70326>>>>>>>        Integer iLinks
70326>>>>>>>
70326>>>>>>>        Get pbHyperlink to bIsHyperlink
70327>>>>>>>        If (bIsHyperlink) Begin
70329>>>>>>>            Get IsHyperlink iRow to bIsHyperlink
70330>>>>>>>        End
70330>>>>>>>>
70330>>>>>>>
70330>>>>>>>        Get ComHyperlinks of hoItem to vHyperLinks
70331>>>>>>>        Get Create (RefClass(cCJReportHyperlinks)) to hoHyperLinks
70332>>>>>>>        Set pvComObject of hoHyperLinks to vHyperLinks
70333>>>>>>>        Get ComCount of hoHyperLinks to iLinks
70334>>>>>>>        If (bIsHyperlink) Begin
70336>>>>>>>            If (iLinks=0) Begin
70338>>>>>>>                Get ComAddHyperlink of hoHyperLinks 0 (Length(sValue)) to vHyperLink
70339>>>>>>>            End
70339>>>>>>>>
70339>>>>>>>        End
70339>>>>>>>>
70339>>>>>>>        Else If (iLinks>0) Begin
70342>>>>>>>            Send ComRemoveAll of hoHyperLinks
70343>>>>>>>        End
70343>>>>>>>>
70343>>>>>>>        Send Destroy of hoHyperLinks
70344>>>>>>>
70344>>>>>>>        Forward Send DrawCell hoRow hoItem hoMetrics iRow sValue
70346>>>>>>>    End_Procedure
70347>>>>>>>
70347>>>>>>>    Procedure OnCreateColumn
70349>>>>>>>        Variant vHyperLinkStyle
70349>>>>>>>        Handle  hoPaintManager hoHyperLinkStyle
70349>>>>>>>
70349>>>>>>>        Forward Send OnCreateColumn
70351>>>>>>>        Get phoReportPaintManager to hoPaintManager
70352>>>>>>>        Get ComHyperlinkStyle of hoPaintManager to vHyperLinkStyle
70353>>>>>>>        Get Create (RefClass(cCJReportHyperlinkStyle)) to hoHyperLinkStyle
70354>>>>>>>        Set pvComObject of hoHyperLinkStyle to vHyperLinkStyle
70355>>>>>>>        Set ComTextDecoration of hoHyperLinkStyle to xtpReportTextDecorationUnderline
70356>>>>>>>        Send Destroy of hoHyperLinkStyle
70357>>>>>>>    End_Procedure
70358>>>>>>>
70358>>>>>>>End_Class
70359>>>>>Use SourceCode.inc
Including file: SourceCode.inc    (C:\Projects\DF18\DfRefactor\AppSrc\SourceCode.inc)
70359>>>>>>>Use Windows.pkg
70359>>>>>>>Use DFClient.pkg
70359>>>>>>>Use cFilesystem.pkg
Including file: cFilesystem.pkg    (C:\Projects\DF18\DfRefactor\Libraries\cFileSystem\AppSrc\cFilesystem.pkg)
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>//*** FileSystem - Binary file operations For VDF15+.
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>//*** Based on original package: akefs.pkg
70359>>>>>>>>>//*** Version: 4.0
70359>>>>>>>>>//*** (C) NordTeam Gruppen, NOVAX A/S
70359>>>>>>>>>//***
70359>>>>>>>>>//*** Author......: Allan Kim Eriksen
70359>>>>>>>>>//*** Created.....: 23/08 2001
70359>>>>>>>>>//***
70359>>>>>>>>>//*** Rev History.: 31/08 2018 Nils Svedmyr. Added Functions from Akefs.pkg
70359>>>>>>>>>//***               to get/set file date/time and procedure SetFileLastWriteTime.
70359>>>>>>>>>//***               Refactored functions FileSize & FileDate to only have one Function_Return,
70359>>>>>>>>>//***               and changed a couple of While loops to end with a "loop" word instead of "End".
70359>>>>>>>>>//***
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>// cFilesystem class with functions and procedures to access binary files.
70359>>>>>>>>>// Filenumbers are not limited to 10 but only to system resources.
70359>>>>>>>>>// Also windows API calls For file copy, file move ect.
70359>>>>>>>>>// This class is For vdf 15 and up.
70359>>>>>>>>>// This class is not limited to 2 GB but can handle filesizes up $7FFFFFFFFFFFFFFF (9 exabyte)
70359>>>>>>>>>
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>// Be aware that argument_size has to be larger
70359>>>>>>>>>// than the requested amount of bytes read in the buffer for
70359>>>>>>>>>// BytesFromBinaryFile.
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>// Constants used For the external functions.
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>// fsCreatefile.
70359>>>>>>>>>Define GENERIC_READ for            |CI$80000000
70359>>>>>>>>>Define GENERIC_WRITE for           |CI$40000000
70359>>>>>>>>>Define GENERIC_RANDOM for          (GENERIC_READ + GENERIC_WRITE)
70359>>>>>>>>>Define CREATE_NEW for              |CI$00000001
70359>>>>>>>>>Define CREATE_ALWAYS for           |CI$00000002
70359>>>>>>>>>Define OPEN_EXISTING for           |CI$00000003
70359>>>>>>>>>Define OPEN_ALWAYS for             |CI$00000004
70359>>>>>>>>>Define TRUNCATE_EXISTING for       |CI$00000005
70359>>>>>>>>>
70359>>>>>>>>>
70359>>>>>>>>>Define FILE_SHARE_READ for         |CI$1
70359>>>>>>>>>Define FILE_SHARE_WRITE for        |CI$2
70359>>>>>>>>>Define FILE_SHARE_RANDOM for       (FILE_SHARE_READ + FILE_SHARE_WRITE)
70359>>>>>>>>>
70359>>>>>>>>>// Generel.
70359>>>>>>>>>Define FNULL For                   |CI$0
70359>>>>>>>>>
70359>>>>>>>>>// FormatString.
70359>>>>>>>>>
70359>>>>>>>>>// SetFilePosition.
70359>>>>>>>>>Define FILE_BEGIN For     0
70359>>>>>>>>>Define FILE_CURRENT For  1
70359>>>>>>>>>Define FILE_END For      2
70359>>>>>>>>>Define INVALID_SET_FILE_POINTER For |CI$FFFFFFFF
70359>>>>>>>>>
70359>>>>>>>>>// FindFile.
70359>>>>>>>>>
70359>>>>>>>>>Define ERROR_NO_MORE_FILES    For |CI18
70359>>>>>>>>>Define ERROR_MOD_NOT_FOUND    For |CI126
70359>>>>>>>>>
70359>>>>>>>>>
70359>>>>>>>>>
70359>>>>>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileFlags.
70359>>>>>>>>>
70359>>>>>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileOS.
70359>>>>>>>>>Define VOS_DOS          For |CI$10000
70359>>>>>>>>>Define VOS_NT           For |CI$40000
70359>>>>>>>>>Define VOS_WINDOWS16    For |CI$00001
70359>>>>>>>>>Define VOS_WINDOWS32    For |CI$00004
70359>>>>>>>>>Define VOS_OS216        For |CI$20000
70359>>>>>>>>>Define VOS_OS232        For |CI$30000
70359>>>>>>>>>Define VOS_PM16         For |CI$00002
70359>>>>>>>>>Define VOS_PM32         For |CI$00003
70359>>>>>>>>>Define VOS_UNKNOWN      For |CI$00000
70359>>>>>>>>>
70359>>>>>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileType.
70359>>>>>>>>>Define VFT_APP          For |CI$01
70359>>>>>>>>>Define VFT_DLL          For |CI$02
70359>>>>>>>>>Define VFT_DRV          For |CI$03
70359>>>>>>>>>Define VFT_FONT         For |CI$04
70359>>>>>>>>>Define VFT_STATIC_LIB   For |CI$07
70359>>>>>>>>>Define VFT_UNKNOWN      For |CI$00
70359>>>>>>>>>Define VFT_VXD          For |CI$05
70359>>>>>>>>>
70359>>>>>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_DRV.
70359>>>>>>>>>Define VFT2_DRV_COMM                For |CI$0A
70359>>>>>>>>>Define VFT2_DRV_DISPLAY             For |CI$04
70359>>>>>>>>>Define VFT2_DRV_INSTALLABLE         For |CI$08
70359>>>>>>>>>Define VFT2_DRV_KEYBOARD            For |CI$02
70359>>>>>>>>>Define VFT2_DRV_LANGUAGE            For |CI$03
70359>>>>>>>>>Define VFT2_DRV_MOUSE               For |CI$05
70359>>>>>>>>>Define VFT2_DRV_NETWORK             For |CI$06
70359>>>>>>>>>Define VFT2_DRV_PRINTER             For |CI$01
70359>>>>>>>>>Define VFT2_DRV_SOUND               For |CI$09
70359>>>>>>>>>Define VFT2_DRV_SYSTEM              For |CI$07
70359>>>>>>>>>Define VFT2_DRV_VERSIONED_PRINTER   For |CI$0C
70359>>>>>>>>>
70359>>>>>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_FONT.
70359>>>>>>>>>Define VFT2_FONT_RASTER             For |CI$01
70359>>>>>>>>>Define VFT2_FONT_TRUETYPE           For |CI$03
70359>>>>>>>>>Define VFT2_FONT_VECTOR             For |CI$02
70359>>>>>>>>>
70359>>>>>>>>>Define VFT2_UNKNOWN                 For |CI$00
70359>>>>>>>>>
70359>>>>>>>>>Define FS_FILEHANDLEMISSING For "The filehandle does not exists For the current filenumber."
70359>>>>>>>>>
70359>>>>>>>>>// Filesearch
70359>>>>>>>>>Enum_List
70359>>>>>>>>>    Define DIRMODE_FILES_ONLY For 1
70359>>>>>>>>>    Define DIRMODE_DIRECTORIES_ONLY
70359>>>>>>>>>    Define DIRMODE_FILES_AND_DIRECTORIES
70359>>>>>>>>>End_Enum_List
70359>>>>>>>>>
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>// Declarations of external functions.
70359>>>>>>>>>// Functions that needs variables For output are made global stings or
70359>>>>>>>>>// integers, and can be found on top of the declaration.
70359>>>>>>>>>//************************************************************************
70359>>>>>>>>>External_Function fsCreatefile "CreateFileA" kernel32.dll ;String sFile ;        //filenameDWord dwDesAccess ;   // access modeDWord dwShare ;       // share modePointer lpSecAtt ;    // SDDWord dwCrDisp ;      // how to createDWord dwFlags ;       // file attributesHandle hTempFile ;    // handle to template filReturns Integer       //Returns handle that can be used to access the object
70360>>>>>>>>>
70360>>>>>>>>>External_Function fsGetLastError "GetLastError" kernel32.dll Returns Integer
70361>>>>>>>>>
70361>>>>>>>>>External_Function fsFormatMessage "FormatMessageA" kernel32.dll ;DWord dwFlags ;         // source and processing optionsPointer lpSrc ;         // message sourceDWord dwMsgId ;         // message identifierDWord dwLngId ;         // language identifierPointer lpBuf ;         // message bufferDWord nSize ;           // maximum size of message bufferPointer Arg ;           // array of message insertsReturns Integer
70362>>>>>>>>>
70362>>>>>>>>>External_Function fsLocalFree "LocalFree" kernel32.dll ;Handle hMem ;   // A handle to the local memory object.Returns Integer
70363>>>>>>>>>
70363>>>>>>>>>External_Function fsCloseHandle "CloseHandle" kernel32.dll ;Handle hObject ;        // handle to objectReturns Integer
70364>>>>>>>>>
70364>>>>>>>>>External_Function fsReadFile "ReadFile" kernel32.dll ;Handle hFile ;          // handle to filePointer lpBuffer ;      // data bufferDWord nBytesToRead ;    // number of bytes to readPointer lpBytesRead ;   // number of bytes readPointer lpOverlapped ;  // overlapped bufferReturns Integer
70365>>>>>>>>>
70365>>>>>>>>>External_Function fsWriteFile "WriteFile" kernel32.dll ;Handle hFile ;              // handle to filePointer lpBuf ;             // data bufferDWord nNumBytesWrt ;        // number of bytes to writePointer lpNumBytesWritten ; // number of bytes writtenPointer lpOverlapped ;      // overlapped bufferReturns Integer
70366>>>>>>>>>
70366>>>>>>>>>External_Function fsGetFileSizeEx "GetFileSizeEx" kernel32.dll ;Handle hFile ;           // handle to filePointer lpFileSizeHigh ; // A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.Returns Integer
70367>>>>>>>>>
70367>>>>>>>>>External_Function fsSetFilePointer "SetFilePointer" kernel32.dll ;Handle hFile ;              // handle to fileUInteger lDistanceToMove ;    // The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.Pointer lpDistanceToMoveHigh ;  // A pointer to the high order 32-bits of the signed 64-bit distance to move.DWord dwMoveMethod ;        // The starting point For the file pointer move.Returns UInteger
70368>>>>>>>>>
70368>>>>>>>>>External_Function fsSetEndOfFile "SetEndOfFile" kernel32.dll ;Handle hFile ;              // handle to the file to have its EOF position moved.Returns Integer             // nonzero if success
70369>>>>>>>>>
70369>>>>>>>>>External_Function fsDeleteFile "DeleteFileA" Kernel32.Dll ;String  sFileName ;             // Pointer to a null-terminated string that specifies the file to be deleted.Returns Integer
70370>>>>>>>>>
70370>>>>>>>>>External_Function fsMoveFile "MoveFileA" Kernel32.Dll ;String  sExistingFileName ;     // Pointer to a null-terminated string that names an existing file or directory.String  sNewFileName ;          // Pointer to a null-terminated string that specifies the new name of a file or directory.Returns Integer                 // The new name must Not already exist. A new File may be on A different File system Or drive. A new directory must be on the same drive.
70371>>>>>>>>>
70371>>>>>>>>>External_Function fsCopyFile "CopyFileA" Kernel32.Dll ;String  sExistingFileName ;     // Pointer to a null-terminated string that specifies the name of an existing file.String  sNewFileName ;          // Pointer to a null-terminated string that specifies the name of the new file.Boolean bFailIfExists ;         // If bFailIfExists is TRUE and the new file specified by lpNewFileName already exists, the function fails.Returns Integer                 // If bFailIfExists is FALSE and the new file already exists, the function overwrites the existing file and succeeds.
70372>>>>>>>>>
70372>>>>>>>>>External_Function fsFindFirstFile "FindFirstFileA" Kernel32.Dll ;String  sFileName ;             // Pointer to a null-terminated string that specifies a valid directory or path and file name, which can contain wildcard characters (* and ?).Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
70373>>>>>>>>>
70373>>>>>>>>>External_Function fsFindNextFile "FindNextFileA" Kernel32.Dll ;Handle hFindFile ;              // handle returned by a previous call to the FindFirstFile function.Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
70374>>>>>>>>>
70374>>>>>>>>>External_Function fsFindClose "FindClose" Kernel32.dll ;Handle hFindFile ;              // File search handle. This handle must have been previously opened by the FindFirstFile function.Returns Integer
70375>>>>>>>>>
70375>>>>>>>>>External_Function fsGetFileTime "GetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with read accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
70376>>>>>>>>>
70376>>>>>>>>>External_Function fsSetFileTime "SetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with write accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
70377>>>>>>>>>
70377>>>>>>>>>External_function fsGetSystemTimeAsFileTime "GetSystemTimeAsFileTime" Kernel32.dll ;Pointer lpSystemTimeAsFileTime ;   // Pointer to a FILETIME structure containing the current system time in filetimme formatReturns Integer
70378>>>>>>>>>
70378>>>>>>>>>External_Function fsFileTimeToSystemTime "FileTimeToSystemTime" Kernel32.dll ;Pointer lpFiletime ;            // Pointer to a FILETIME structure containing the file time to convert to system date and time format.Pointer lpSystemtime ;          // Pointer to a SYSTEMTIME structure to receive the converted file time.Returns Integer
70379>>>>>>>>>
70379>>>>>>>>>External_Function fsSystemTimeToTzSpecificLocalTime "SystemTimeToTzSpecificLocalTime" Kernel32.dll ;Pointer lpTimeZone ;            // A pointer to a TIME_ZONE_INFORMATION structure that specifies the time zone of interest.Pointer lpUniversalTime ;       // A pointer to a SYSTEMTIME structure that specifies a time, in UTC.Pointer lpLocalTime ;           // A pointer to a SYSTEMTIME structure that receives the local time.Returns Integer
70380>>>>>>>>>
70380>>>>>>>>>External_Function fsGetTempFileName "GetTempFileNameA" kernel32.dll ;String  sPathname ;String  sPrefixString ;Integer iUnique ;Pointer sTempFileName ;Returns Integer
70381>>>>>>>>>
70381>>>>>>>>>External_Function fsGetTempPath "GetTempPathA" Kernel32.Dll ;Integer nBufferLength ;Pointer lpBuffer ;Returns Integer
70382>>>>>>>>>
70382>>>>>>>>>External_Function fsCreateDirectory "CreateDirectoryA" Kernel32.dll ;String  sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be created.Pointer lpSecAttributes ;       // Pointer to a SECURITY_ATTRIBUTES structure.Returns Integer
70383>>>>>>>>>
70383>>>>>>>>>External_Function fsRemoveDirectory "RemoveDirectoryA" Kernel32.dll ;String  sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be removed.Returns Integer
70384>>>>>>>>>
70384>>>>>>>>>External_Function fsExtractAssociatedIcon "ExtractAssociatedIconA" shell32.dll ;Handle hInst ;Pointer lpIconPath ;Integer lpiIcon ;Returns Handle
70385>>>>>>>>>
70385>>>>>>>>>External_Function fsDestroyIcon "DestroyIcon" User32.dll ;Handle hIcon ;Returns Integer
70386>>>>>>>>>
70386>>>>>>>>>External_Function fsGetFileVersionInfoSize "GetFileVersionInfoSizeA" Version.dll ;String  sFilename ;             // The name of the file of interest. The function uses the search sequence specified by the LoadLibrary function.Pointer lpHandle ;              // A pointer to a variable that the function sets to zero.Returns UInteger
70387>>>>>>>>>
70387>>>>>>>>>External_Function fsGetFileVersionInfo "GetFileVersionInfoA" Version.dll ;String  sFilename ;             // The name of the file. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.DWord   dwHandle ;              // This parameter is ignored.DWord   dwLen ;                 // The size, in bytes, of the buffer pointed to by the lpData parameter.Pointer lpData ;                // Pointer to a buffer that receives the file-version information.Returns Boolean
70388>>>>>>>>>
70388>>>>>>>>>External_Function fsVerQueryValue "VerQueryValueA" Version.dll ;Pointer lpBlock ;               // The version-information resource returned by the GetFileVersionInfo function.String  sSubBlock ;             // The version-information value to be retrieved.Pointer lplpBuffer ;            // When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by lpBlock.Pointer lpLen ;                 // When this method returns, contains a pointer to the size of the requested data pointed to by lpBuffer.Returns Boolean
70389>>>>>>>>>
70389>>>>>>>>>//************************************************************************
70389>>>>>>>>>// Structures
70389>>>>>>>>>//************************************************************************
70389>>>>>>>>>
70389>>>>>>>>>// Nils 2018-08-30 Added For the SourceCodeTools project
70389>>>>>>>>>// so we don't need to use both Akefs.pkg and this package.
70389>>>>>>>>>// A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
70389>>>>>>>>>Struct tFileTime
70389>>>>>>>>>    DWord dwLowDateTime    // Low-order part of the file time.
70389>>>>>>>>>    DWord dwHighDateTime   // High-order part of the file time.
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct structWFD  // Used by FindFirstFile
70389>>>>>>>>>    DWord    dwFileAttributes
70389>>>>>>>>>    UBigInt  ftCreationDateTime
70389>>>>>>>>>    UBigInt  ftLastAccessDateTime
70389>>>>>>>>>    UBigInt  ftLastWriteDateTime
70389>>>>>>>>>    UInteger nFileSizeHigh
70389>>>>>>>>>    UInteger nFileSizeLow
70389>>>>>>>>>    DWord    dares
70389>>>>>>>>>    DWord    dbres
70389>>>>>>>>>    UChar[MAX_PATH] cFileName
70389>>>>>>>>>    UChar[14]       cAlternateFileName
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct structSystemTime
70389>>>>>>>>>    UShort wYear
70389>>>>>>>>>    UShort wMonth
70389>>>>>>>>>    UShort wDayOfWeek
70389>>>>>>>>>    UShort wDay
70389>>>>>>>>>    UShort wHour
70389>>>>>>>>>    UShort wMinute
70389>>>>>>>>>    UShort wSecond
70389>>>>>>>>>    UShort wMillieseconds
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct structFile
70389>>>>>>>>>    Handle hFilehandle
70389>>>>>>>>>    String sFilename    // Assigned filename in OEM format.
70389>>>>>>>>>    Boolean bEndOfFile  // True then the end of the binary file had been read.
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct structFileBufferPointer
70389>>>>>>>>>    Integer iBufferPointer
70389>>>>>>>>>    Integer iBufferSize
70389>>>>>>>>>    BigInt biFromFilePosition
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct tsSearchResult
70389>>>>>>>>>    String sFilename
70389>>>>>>>>>    String sAlternateFileName   // 8.3 format
70389>>>>>>>>>    DateTime dtCreationDateTime
70389>>>>>>>>>    DateTime dtLastAccessDateTime
70389>>>>>>>>>    DateTime dtLastWriteDateTime
70389>>>>>>>>>    BigInt biFileSize
70389>>>>>>>>>    Integer iFileAttributes
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct tsVS_FIXEDFILEINFO
70389>>>>>>>>>    DWord dwSignature
70389>>>>>>>>>    DWord dwStrucVersion
70389>>>>>>>>>    DWord dwFileVersionMS
70389>>>>>>>>>    DWord dwFileVersionLS
70389>>>>>>>>>    DWord dwProductVersionMS
70389>>>>>>>>>    DWord dwProductVersionLS
70389>>>>>>>>>    DWord dwFileFlagsMask
70389>>>>>>>>>    DWord dwFileFlags
70389>>>>>>>>>    DWord dwFileOS
70389>>>>>>>>>    DWord dwFileType
70389>>>>>>>>>    DWord dwFileSubtype
70389>>>>>>>>>    //    DWord dwFileDateMS
70389>>>>>>>>>    //    DWord dwFileDateLS
70389>>>>>>>>>    UBigInt ubiFileDate
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct tsFileVersionInfo
70389>>>>>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
70389>>>>>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
70389>>>>>>>>>    Short[] siFileVersion
70389>>>>>>>>>    Short[] siProductVersion
70389>>>>>>>>>    DateTime dtCreationDateTime
70389>>>>>>>>>    String sComments
70389>>>>>>>>>    String sCompanyName
70389>>>>>>>>>    String sFileDescription
70389>>>>>>>>>    String sFileVersion
70389>>>>>>>>>    String sInternalName
70389>>>>>>>>>    String sLegalCopyright
70389>>>>>>>>>    String sLegalTrademarks
70389>>>>>>>>>    String sOriginalFilename
70389>>>>>>>>>    String sProductName
70389>>>>>>>>>    String sProductVersion
70389>>>>>>>>>    String sPrivateBuild
70389>>>>>>>>>    String sSpecialBuild
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Struct tsLandAndCodePage
70389>>>>>>>>>    UShort wLanguage
70389>>>>>>>>>    UShort wCodePage
70389>>>>>>>>>End_Struct
70389>>>>>>>>>
70389>>>>>>>>>Register_Function FileErrorText Integer iFilenumber Returns String
70389>>>>>>>>>
70389>>>>>>>>>//************************************************************************
70389>>>>>>>>>// The filesystem class
70389>>>>>>>>>//************************************************************************
70389>>>>>>>>>Class cFilesystem is a cObject
70390>>>>>>>>>
70390>>>>>>>>>    Procedure Construct_Object
70392>>>>>>>>>        Forward Send Construct_Object
70394>>>>>>>>>
70394>>>>>>>>>        // True then the end of the binary file had been read - not when $1A (EOF) is met.
70394>>>>>>>>>        // Legacy property. Use the BinaryFileEndOfFile function instead.
70394>>>>>>>>>        Property Boolean pbEOF False
70395>>>>>>>>>
70395>>>>>>>>>        // True if any error has occured during fileoprerations.
70395>>>>>>>>>        Property Boolean pbError False
70396>>>>>>>>>
70396>>>>>>>>>        // If errormessages should be called with dataflex error command set this to true
70396>>>>>>>>>        Property Boolean pbErrorAsVDFError False
70397>>>>>>>>>
70397>>>>>>>>>        // Keeps assigned handles and filenames For each filenumber.
70397>>>>>>>>>        // private
70397>>>>>>>>>        Property structFile[] plsFile
70398>>>>>>>>>
70398>>>>>>>>>        // Keeps read cached buffers For each filenumer. Used For BinaryReadChcheu
70398>>>>>>>>>        // private
70398>>>>>>>>>        Property String[] psaCachedBuffer
70399>>>>>>>>>
70399>>>>>>>>>        // Pointers For cached buffers.
70399>>>>>>>>>        // private
70399>>>>>>>>>        Property structFileBufferPointer[] plsCachedPointer
70400>>>>>>>>>    End_Procedure
70401>>>>>>>>>
70401>>>>>>>>>    // Returns the next available filenumber For a binary file.
70401>>>>>>>>>    Function BinaryFileNextFilenumber Returns Integer
70403>>>>>>>>>        structFile[] lsFile
70403>>>>>>>>>        structFile[] lsFile
70404>>>>>>>>>        Integer iMaxFiles iCurrentFile iNextFileNumber
70404>>>>>>>>>        Get plsFile to lsFile
70405>>>>>>>>>        Move (SizeOfArray(lsFile)) to iMaxFiles
70406>>>>>>>>>        Move -1 to iNextFileNumber
70407>>>>>>>>>        Move 0 to iCurrentFile
70408>>>>>>>>>        While (iCurrentFile < iMaxFiles and iNextFileNumber = -1)
70412>>>>>>>>>            If (lsFile[iCurrentFile].hFilehandle = 0) Begin
70414>>>>>>>>>                Move iCurrentFile to iNextFileNumber
70415>>>>>>>>>            End
70415>>>>>>>>>>
70415>>>>>>>>>            Else Begin
70416>>>>>>>>>                Increment iCurrentFile
70417>>>>>>>>>            End
70417>>>>>>>>>>
70417>>>>>>>>>        Loop
70418>>>>>>>>>>
70418>>>>>>>>>        If (iNextFileNumber = -1) Begin
70420>>>>>>>>>            Move iMaxFiles to iNextFileNumber
70421>>>>>>>>>        End
70421>>>>>>>>>>
70421>>>>>>>>>        Function_Return iNextFileNumber
70422>>>>>>>>>    End_Function
70423>>>>>>>>>
70423>>>>>>>>>    // Opens a binary file.
70423>>>>>>>>>    // If bShared is false or not pharsed the file is opened in exclusive.
70423>>>>>>>>>    // If bShared is True the file is opened with both read and write shared mode
70423>>>>>>>>>    // If bCreate is True the file is created if it does not exist already.
70423>>>>>>>>>    // If bReadOnly is True the file is opened with only read access (and only read shared mode if bShared is also true).
70423>>>>>>>>>    // Returns true if the file was opened or created without error.
70423>>>>>>>>>    Function BinaryFileOpen Integer iFilenumber String sFilename Boolean bShared Boolean bCreate Boolean bReadOnly Returns Boolean
70425>>>>>>>>>        Integer iReturnValue iErrornumber
70425>>>>>>>>>        DWord dwSharedMode dwCreateMode dwAccessMode
70425>>>>>>>>>        structFile[] lsFile
70425>>>>>>>>>        structFile[] lsFile
70426>>>>>>>>>        String sFilenameANSI
70426>>>>>>>>>        Boolean bOk bFilehandleOK
70426>>>>>>>>>        Get plsFile to lsFile
70427>>>>>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70429>>>>>>>>>            If (lsFile[iFilenumber].hFilehandle = 0) Begin
70431>>>>>>>>>                Move True to bFilehandleOK
70432>>>>>>>>>            End
70432>>>>>>>>>>
70432>>>>>>>>>        End
70432>>>>>>>>>>
70432>>>>>>>>>        Else Begin
70433>>>>>>>>>            Move True to bFilehandleOK
70434>>>>>>>>>        End
70434>>>>>>>>>>
70434>>>>>>>>>        If bFilehandleOK Begin
70436>>>>>>>>>            Move sFilename to lsFile[iFilenumber].sFilename
70437>>>>>>>>>            Move (ToAnsi(sFilename)) To sFilenameANSI
70438>>>>>>>>>            Set pbError to False
70439>>>>>>>>>            Move False to bOk
70440>>>>>>>>>            Move GENERIC_RANDOM to dwAccessMode
70441>>>>>>>>>            Move FNULL to dwSharedMode
70442>>>>>>>>>            If (num_arguments > 2) Begin
70444>>>>>>>>>                If (bShared = True) Begin
70446>>>>>>>>>                    Move FILE_SHARE_RANDOM to dwSharedMode
70447>>>>>>>>>                End
70447>>>>>>>>>>
70447>>>>>>>>>            End
70447>>>>>>>>>>
70447>>>>>>>>>            Move OPEN_EXISTING to dwCreateMode
70448>>>>>>>>>            If (num_arguments > 3) Begin
70450>>>>>>>>>                If (bCreate = True) Begin
70452>>>>>>>>>                    Move OPEN_ALWAYS to dwCreateMode
70453>>>>>>>>>                End
70453>>>>>>>>>>
70453>>>>>>>>>            End
70453>>>>>>>>>>
70453>>>>>>>>>            If (num_arguments > 4) Begin
70455>>>>>>>>>                If (bReadOnly = True) Begin
70457>>>>>>>>>                    Move GENERIC_READ to dwAccessMode
70458>>>>>>>>>                    If (bShared = True) Begin
70460>>>>>>>>>                        Move FILE_SHARE_READ to dwSharedMode
70461>>>>>>>>>                    End
70461>>>>>>>>>>
70461>>>>>>>>>                End
70461>>>>>>>>>>
70461>>>>>>>>>            End
70461>>>>>>>>>>
70461>>>>>>>>>            Append sFilenameANSI (Character(0)) (Character(0))
70463>>>>>>>>>            Move (fsCreatefile(sFilenameANSI, dwAccessMode, dwSharedMode, FNULL, dwCreateMode, FILE_ATTRIBUTE_NORMAL, FNULL)) to iReturnValue
70464>>>>>>>>>            If (iReturnValue = INVALID_HANDLE_VALUE) Begin
70466>>>>>>>>>                Move (fsGetLastError()) to iErrornumber
70467>>>>>>>>>                If iErrornumber Begin
70469>>>>>>>>>                    Send DoShowError iErrornumber ("File: "+ sFilename)
70470>>>>>>>>>                End
70470>>>>>>>>>>
70470>>>>>>>>>            End
70470>>>>>>>>>>
70470>>>>>>>>>            Else Begin
70471>>>>>>>>>                Move iReturnValue to lsFile[iFilenumber].hFilehandle
70472>>>>>>>>>                Move False to lsFile[iFilenumber].bEndOfFile
70473>>>>>>>>>                Set plsFile to lsFile
70474>>>>>>>>>                Set pbEOF to False
70475>>>>>>>>>                Move True to bOk
70476>>>>>>>>>            End
70476>>>>>>>>>>
70476>>>>>>>>>        End
70476>>>>>>>>>>
70476>>>>>>>>>        Else Begin
70477>>>>>>>>>            Send warning_box "The filenumber is already used."
70478>>>>>>>>>        End
70478>>>>>>>>>>
70478>>>>>>>>>        Function_Return bOk
70479>>>>>>>>>    End_Function
70480>>>>>>>>>
70480>>>>>>>>>    // Closing a binary file
70480>>>>>>>>>    // Returns true if the file could be closed.
70480>>>>>>>>>    Function BinaryFileClose Integer iFilenumber Returns Boolean
70482>>>>>>>>>        Integer iRetVal iErrorNumber
70482>>>>>>>>>        Handle hHandle
70482>>>>>>>>>        structFile[] lsFile
70482>>>>>>>>>        structFile[] lsFile
70483>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70483>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70484>>>>>>>>>        String[] saCachedBuffer
70485>>>>>>>>>        Boolean bOk
70485>>>>>>>>>        Get BinaryFileHandle iFilenumber to hHandle
70486>>>>>>>>>        Set pbError to False
70487>>>>>>>>>        Move False to bOk
70488>>>>>>>>>        If hHandle Begin
70490>>>>>>>>>            Move (fsCloseHandle(hHandle)) to iRetVal
70491>>>>>>>>>            If (iRetVal = 0) Begin           // Could not close
70493>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
70494>>>>>>>>>                If iErrorNumber Begin
70496>>>>>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70497>>>>>>>>>                End
70497>>>>>>>>>>
70497>>>>>>>>>            End
70497>>>>>>>>>>
70497>>>>>>>>>            Else Begin
70498>>>>>>>>>                Get plsFile to lsFile
70499>>>>>>>>>                Get plsCachedPointer to lsFileBufferPointer
70500>>>>>>>>>                Get psaCachedBuffer to saCachedBuffer
70501>>>>>>>>>                Move 0 to lsFile[iFilenumber].hFilehandle
70502>>>>>>>>>                Move "" to saCachedBuffer[iFilenumber]
70503>>>>>>>>>                Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70504>>>>>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].iBufferSize
70505>>>>>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].biFromFilePosition
70506>>>>>>>>>                Set plsFile to lsFile
70507>>>>>>>>>                Set plsCachedPointer to lsFileBufferPointer
70508>>>>>>>>>                Set psaCachedBuffer to saCachedBuffer
70509>>>>>>>>>                Move True to bOk
70510>>>>>>>>>            End
70510>>>>>>>>>>
70510>>>>>>>>>        End
70510>>>>>>>>>>
70510>>>>>>>>>        Function_Return bOk
70511>>>>>>>>>    End_Function
70512>>>>>>>>>
70512>>>>>>>>>    // Reading from a binary file.
70512>>>>>>>>>    // The data read from the file is placed in sReadBuffer and the function returns the number of bytes read.
70512>>>>>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
70512>>>>>>>>>    // No errors occures if you try to read past end of file.
70512>>>>>>>>>    // To speed up reading process you should read in a block of data at a time (i.e. iNumberOfBytes = 2000) instead of
70512>>>>>>>>>    // reading one byte at a time. No errors occures if you try to read past end
70512>>>>>>>>>    // of file. Note that iNumberOfBytes must not exceed the argument size.
70512>>>>>>>>>    Function BinaryFileRead Integer iFilenumber Integer iNumberOfBytes String ByRef sReadBuffer Returns Integer
70514>>>>>>>>>        Handle hFileHandle
70514>>>>>>>>>        Integer iBytesRead iMaxBuffer iErrorNumber
70514>>>>>>>>>        Boolean bOk
70514>>>>>>>>>        structFile[] lsFile
70514>>>>>>>>>        structFile[] lsFile
70515>>>>>>>>>        Set pbError to False
70516>>>>>>>>>        Move 0 to iBytesRead
70517>>>>>>>>>        Get_Argument_Size to iMaxBuffer
70518>>>>>>>>>        If (iNumberOfBytes > iMaxBuffer) Begin
70520>>>>>>>>>            Send warning_box "Blocksize to read exceeds argument size!"
70521>>>>>>>>>            Function_Return iBytesRead
70522>>>>>>>>>        End
70522>>>>>>>>>>
70522>>>>>>>>>        If (iNumberOfBytes < 1) Begin
70524>>>>>>>>>            Send warning_box "Number of bytes to read can not be less than one."
70525>>>>>>>>>            Function_Return iBytesRead
70526>>>>>>>>>        End
70526>>>>>>>>>>
70526>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70527>>>>>>>>>        If hFileHandle Begin
70529>>>>>>>>>            Move (ZeroString(iNumberOfBytes)) to sReadBuffer
70530>>>>>>>>>            Move (fsReadFile(hFileHandle, AddressOf(sReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
70531>>>>>>>>>            If (bOk = False) Begin
70533>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
70534>>>>>>>>>                If iErrorNumber Begin
70536>>>>>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70537>>>>>>>>>                End
70537>>>>>>>>>>
70537>>>>>>>>>            End
70537>>>>>>>>>>
70537>>>>>>>>>            Else Begin
70538>>>>>>>>>                If (iBytesRead = 0 or iBytesRead <> iNumberOfBytes) Begin
70540>>>>>>>>>                    Get plsFile to lsFile
70541>>>>>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
70542>>>>>>>>>                    Set plsFile to lsFile
70543>>>>>>>>>                    Set pbEOF to True
70544>>>>>>>>>                    Move (Left(sReadBuffer, iBytesRead)) to sReadBuffer
70545>>>>>>>>>                End
70545>>>>>>>>>>
70545>>>>>>>>>            End
70545>>>>>>>>>>
70545>>>>>>>>>        End
70545>>>>>>>>>>
70545>>>>>>>>>        Else Begin
70546>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70547>>>>>>>>>        End
70547>>>>>>>>>>
70547>>>>>>>>>        Function_Return iBytesRead
70548>>>>>>>>>    End_Function
70549>>>>>>>>>
70549>>>>>>>>>    // Reading from a binary file until a string of bytes are matched.
70549>>>>>>>>>    // The data read from the file is placed in the sReturnBuffer and the function returns the number of bytes read until the match is read including the match.
70549>>>>>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
70549>>>>>>>>>    // The return string buffer would also be empty.
70549>>>>>>>>>    // No errors occures if you try to read past end of file.
70549>>>>>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
70549>>>>>>>>>    Function BinaryFileReadCachedUntilMatch Integer iFilenumber String sMatchString String ByRef sReturnBuffer Boolean ByRef bEndOfFile Returns Integer
70551>>>>>>>>>        Handle hFileHandle
70551>>>>>>>>>        Integer iBuffersize iMatchPos iLengthMatch
70551>>>>>>>>>        String sByte
70551>>>>>>>>>        structFile[] lsFile
70551>>>>>>>>>        structFile[] lsFile
70552>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70552>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70553>>>>>>>>>        String[] saCachedBuffer
70554>>>>>>>>>        Get plsFile to lsFile
70555>>>>>>>>>        Move "" to sReturnBuffer
70556>>>>>>>>>        Move 1 to iMatchPos
70557>>>>>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70559>>>>>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
70560>>>>>>>>>            If (hFileHandle <> 0) Begin
70562>>>>>>>>>                Move (Length(sMatchString)) to iLengthMatch
70563>>>>>>>>>                Get plsCachedPointer to lsFileBufferPointer
70564>>>>>>>>>                Get psaCachedBuffer to saCachedBuffer
70565>>>>>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
70567>>>>>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70568>>>>>>>>>                    Move "" to saCachedBuffer[iFilenumber]
70569>>>>>>>>>                End
70569>>>>>>>>>>
70569>>>>>>>>>                Repeat
70569>>>>>>>>>>
70569>>>>>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer > lsFileBufferPointer[iFilenumber].iBufferSize) Begin
70571>>>>>>>>>                        Get_Argument_Size to iBuffersize
70572>>>>>>>>>                        Get BinaryFilePosition iFilenumber to lsFileBufferPointer[iFilenumber].biFromFilePosition
70573>>>>>>>>>                        Get BinaryFileRead iFilenumber iBuffersize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer[iFilenumber].iBufferSize
70574>>>>>>>>>                        Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70575>>>>>>>>>                        Set psaCachedBuffer to saCachedBuffer
70576>>>>>>>>>                    End
70576>>>>>>>>>>
70576>>>>>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer =< lsFileBufferPointer[iFilenumber].iBufferSize) Begin
70578>>>>>>>>>                        Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer[iFilenumber].iBufferPointer)) to sByte
70579>>>>>>>>>                        Increment lsFileBufferPointer[iFilenumber].iBufferPointer
70580>>>>>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
70581>>>>>>>>>                        If (sByte = Mid(sMatchString, 1, iMatchPos)) Begin
70583>>>>>>>>>                            Increment iMatchPos
70584>>>>>>>>>                        End
70584>>>>>>>>>>
70584>>>>>>>>>                        Else Begin
70585>>>>>>>>>                            Move 1 to iMatchPos
70586>>>>>>>>>                        End
70586>>>>>>>>>>
70586>>>>>>>>>                    End
70586>>>>>>>>>>
70586>>>>>>>>>                Until (iMatchPos > iLengthMatch or lsFileBufferPointer[iFilenumber].iBufferSize = 0)
70588>>>>>>>>>                Set plsCachedPointer to lsFileBufferPointer
70589>>>>>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
70591>>>>>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
70592>>>>>>>>>                End
70592>>>>>>>>>>
70592>>>>>>>>>            End
70592>>>>>>>>>>
70592>>>>>>>>>            Else Begin
70593>>>>>>>>>                Send warning_box FS_FILEHANDLEMISSING
70594>>>>>>>>>            End
70594>>>>>>>>>>
70594>>>>>>>>>        End
70594>>>>>>>>>>
70594>>>>>>>>>        Function_Return (Length(sReturnBuffer))
70595>>>>>>>>>    End_Function
70596>>>>>>>>>
70596>>>>>>>>>    // Reading from a binary file as CSV file For next text field.
70596>>>>>>>>>    // The data read from the file is placed in the sReturnBuffer excluding the separator and the function returns true.
70596>>>>>>>>>    // Then the function returns false the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
70596>>>>>>>>>    // When the end of row data has been read the bEndOfRow is set true.
70596>>>>>>>>>    // The end of row is indicated with sCharEOL. If that is not applied the charactersequence character(13) + character(10) is used.
70596>>>>>>>>>    // The return string buffer would also be empty.
70596>>>>>>>>>    // No errors occures if you try to read past end of file.
70596>>>>>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
70596>>>>>>>>>    Function BinaryFileReadCachedCSV Integer iFilenumber String sFieldseparator String sTextQualification String ByRef sReturnBuffer Boolean ByRef bEndOfRow Boolean ByRef bEndOfFile String sCharEOL Returns Integer
70598>>>>>>>>>        Handle hFileHandle
70598>>>>>>>>>        Integer iLengthSeparator iLengthTextQualification iEOLLength iTestLength
70598>>>>>>>>>        String sByte sEOL sTestBuffer
70598>>>>>>>>>        structFile[] lsFile
70598>>>>>>>>>        structFile[] lsFile
70599>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70599>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70600>>>>>>>>>        String[] saCachedBuffer
70601>>>>>>>>>        Boolean bInTextFieldMode bTextFieldReady bFieldSeparator bTextQualificator bEscapeTextQualificatorTest bByteOk
70601>>>>>>>>>        BigInt biAfterTextQualificator
70601>>>>>>>>>        Get plsFile to lsFile
70602>>>>>>>>>        If (num_arguments > 6) Begin
70604>>>>>>>>>            Move sCharEOL to sEOL
70605>>>>>>>>>        End
70605>>>>>>>>>>
70605>>>>>>>>>        Else Begin
70606>>>>>>>>>            Move ((Character(13))+(Character(10))) to sEOL
70607>>>>>>>>>        End
70607>>>>>>>>>>
70607>>>>>>>>>        Move (Length(sEOL)) to iEOLLength
70608>>>>>>>>>        Move "" to sReturnBuffer
70609>>>>>>>>>        Move "" to sByte
70610>>>>>>>>>        Move False to bInTextFieldMode
70611>>>>>>>>>        Move False to bTextFieldReady
70612>>>>>>>>>        Move False to bEndOfRow
70613>>>>>>>>>        Move False to bTextQualificator
70614>>>>>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70616>>>>>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
70617>>>>>>>>>            If (hFileHandle <> 0) Begin
70619>>>>>>>>>                Move (Length(sFieldseparator)) to iLengthSeparator
70620>>>>>>>>>                Move (Length(sTextQualification)) to iLengthTextQualification
70621>>>>>>>>>                Get plsCachedPointer to lsFileBufferPointer
70622>>>>>>>>>                Get psaCachedBuffer to saCachedBuffer
70623>>>>>>>>>
70623>>>>>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
70625>>>>>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
70626>>>>>>>>>                    Move "" to saCachedBuffer[iFilenumber]
70627>>>>>>>>>                End
70627>>>>>>>>>>
70627>>>>>>>>>                Repeat
70627>>>>>>>>>>
70627>>>>>>>>>                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
70628>>>>>>>>>                    If bByteOk Begin
70630>>>>>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
70631>>>>>>>>>                        Move (Right(sReturnBuffer, iLengthSeparator) = sFieldseparator) to bFieldSeparator
70632>>>>>>>>>                        If bFieldSeparator Begin
70634>>>>>>>>>                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthSeparator))) to sReturnBuffer
70635>>>>>>>>>                            Move True to bTextFieldReady
70636>>>>>>>>>                            Move False to bEscapeTextQualificatorTest
70637>>>>>>>>>                        End
70637>>>>>>>>>>
70637>>>>>>>>>                        If (not(bTextFieldReady)) Begin
70639>>>>>>>>>                            Move (Right(sReturnBuffer, iEOLLength) = sEOL) to bEndOfRow
70640>>>>>>>>>                            If bEndOfRow Begin
70642>>>>>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iEOLLength))) to sReturnBuffer
70643>>>>>>>>>                                Move True to bTextFieldReady
70644>>>>>>>>>                            End
70644>>>>>>>>>>
70644>>>>>>>>>                        End
70644>>>>>>>>>>
70644>>>>>>>>>                        If (not(bTextFieldReady)) Begin
70646>>>>>>>>>                            Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
70647>>>>>>>>>                            If bTextQualificator Begin
70649>>>>>>>>>                                // Read until end of text field. Place filepointer after text field.
70649>>>>>>>>>                                Move True to bInTextFieldMode
70650>>>>>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
70651>>>>>>>>>                                Repeat
70651>>>>>>>>>>
70651>>>>>>>>>                                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
70652>>>>>>>>>                                    If bByteOk Begin
70654>>>>>>>>>                                        Move (sReturnBuffer + sByte) to sReturnBuffer
70655>>>>>>>>>                                        Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
70656>>>>>>>>>                                        If bTextQualificator Begin
70658>>>>>>>>>                                            // Either it is the end of the text field or the escape text qualificator has been read.
70658>>>>>>>>>                                            // Read ahead to a new buffer to see if the next bytes are the text qualificator.
70658>>>>>>>>>                                            // If it is, add the new buffer to the return buffer.
70658>>>>>>>>>                                            // If not, restore the filebuffer to this position and mark the text field ended.
70658>>>>>>>>>                                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
70659>>>>>>>>>                                            Set plsCachedPointer to lsFileBufferPointer
70660>>>>>>>>>                                            Get BinaryFileCachedPosition iFilenumber to biAfterTextQualificator
70661>>>>>>>>>                                            Move "" to sTestBuffer
70662>>>>>>>>>                                            Move 0 to iTestLength
70663>>>>>>>>>                                            Move True to bEscapeTextQualificatorTest
70664>>>>>>>>>                                            Repeat
70664>>>>>>>>>>
70664>>>>>>>>>                                                Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
70665>>>>>>>>>                                                If bByteOk Begin
70667>>>>>>>>>                                                    Move (sTestBuffer + sByte) to sTestBuffer
70668>>>>>>>>>                                                    Increment iTestLength
70669>>>>>>>>>                                                    If (Left(sTextQualification, iTestLength) = sTestBuffer) Begin
70671>>>>>>>>>                                                        If (iTestLength = iLengthTextQualification) Begin
70673>>>>>>>>>                                                            Move (sReturnBuffer + sTestBuffer) to sReturnBuffer
70674>>>>>>>>>                                                            Move False to bEscapeTextQualificatorTest
70675>>>>>>>>>                                                        End
70675>>>>>>>>>>
70675>>>>>>>>>                                                    End
70675>>>>>>>>>>
70675>>>>>>>>>                                                    Else Begin
70676>>>>>>>>>                                                        Set BinaryFileChachedPosition iFilenumber to biAfterTextQualificator
70677>>>>>>>>>                                                        Get plsCachedPointer to lsFileBufferPointer
70678>>>>>>>>>                                                        Move False to bEscapeTextQualificatorTest
70679>>>>>>>>>                                                        Move False to bInTextFieldMode
70680>>>>>>>>>                                                    End
70680>>>>>>>>>>
70680>>>>>>>>>                                                End
70680>>>>>>>>>>
70680>>>>>>>>>                                            Until (bEscapeTextQualificatorTest = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
70682>>>>>>>>>                                        End
70682>>>>>>>>>>
70682>>>>>>>>>                                    End
70682>>>>>>>>>>
70682>>>>>>>>>                                Until (bInTextFieldMode = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
70684>>>>>>>>>                            End
70684>>>>>>>>>>
70684>>>>>>>>>                        End
70684>>>>>>>>>>
70684>>>>>>>>>                    End
70684>>>>>>>>>>
70684>>>>>>>>>                Until (bTextFieldReady = True or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
70686>>>>>>>>>                Set plsCachedPointer to lsFileBufferPointer
70687>>>>>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
70689>>>>>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
70690>>>>>>>>>                    If (bEndOfFile = True) Begin
70692>>>>>>>>>                        Move True to bTextFieldReady
70693>>>>>>>>>                        Move True to bEndOfRow
70694>>>>>>>>>                    End
70694>>>>>>>>>>
70694>>>>>>>>>                End
70694>>>>>>>>>>
70694>>>>>>>>>            End
70694>>>>>>>>>>
70694>>>>>>>>>            Else Begin
70695>>>>>>>>>                Send warning_box FS_FILEHANDLEMISSING
70696>>>>>>>>>            End
70696>>>>>>>>>>
70696>>>>>>>>>        End
70696>>>>>>>>>>
70696>>>>>>>>>        Function_Return bTextFieldReady
70697>>>>>>>>>    End_Function
70698>>>>>>>>>
70698>>>>>>>>>    Function NextByteCSV Integer ByRef iFilenumber structFileBufferPointer ByRef lsFileBufferPointer String[] ByRef saCachedBuffer String ByRef sByte Returns String
70700>>>>>>>>>        Integer iBufferSize
70700>>>>>>>>>        Boolean bOk
70700>>>>>>>>>        If (lsFileBufferPointer.iBufferPointer > lsFileBufferPointer.iBufferSize) Begin
70702>>>>>>>>>            Get_Argument_Size to iBufferSize
70703>>>>>>>>>            Get BinaryFilePosition iFilenumber to lsFileBufferPointer.biFromFilePosition
70704>>>>>>>>>            Get BinaryFileRead iFilenumber iBufferSize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer.iBufferSize
70705>>>>>>>>>            Move 1 to lsFileBufferPointer.iBufferPointer
70706>>>>>>>>>            Set psaCachedBuffer to saCachedBuffer
70707>>>>>>>>>        End
70707>>>>>>>>>>
70707>>>>>>>>>        If (lsFileBufferPointer.iBufferPointer <= lsFileBufferPointer.iBufferSize) Begin
70709>>>>>>>>>            Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer.iBufferPointer)) to sByte
70710>>>>>>>>>            Increment lsFileBufferPointer.iBufferPointer
70711>>>>>>>>>            Move True to bOk
70712>>>>>>>>>        End
70712>>>>>>>>>>
70712>>>>>>>>>        Function_Return bOk
70713>>>>>>>>>    End_Function
70714>>>>>>>>>
70714>>>>>>>>>    // Shortcut to read a binary file as lines from a textfile.
70714>>>>>>>>>    // Reads from cached file until sCharEOL are recieved.
70714>>>>>>>>>    // Data is returned without the ending sCharEOL
70714>>>>>>>>>    // If sCharEOL is not applied the charactersequence character(13) + character(10) is used.
70714>>>>>>>>>    // Returns True when the line has been read.
70714>>>>>>>>>    Function BinaryFileReadCachedLN Integer iFilenumber String ByRef sLine Boolean ByRef bEndOfFile String sCharEOL Returns Boolean
70716>>>>>>>>>        Boolean bEndOfRow
70716>>>>>>>>>        Integer iBytesRead iEOLLength
70716>>>>>>>>>        String sEOL
70716>>>>>>>>>        If (num_arguments > 3) Begin
70718>>>>>>>>>            Move sCharEOL to sEOL
70719>>>>>>>>>        End
70719>>>>>>>>>>
70719>>>>>>>>>        Else Begin
70720>>>>>>>>>            Move ((Character(13))+(Character(10))) to sEOL
70721>>>>>>>>>        End
70721>>>>>>>>>>
70721>>>>>>>>>        Move (Length(sEOL)) to iEOLLength
70722>>>>>>>>>        Get BinaryFileReadCachedUntilMatch iFilenumber sEOL (&sLine) (&bEndOfFile) to iBytesRead
70723>>>>>>>>>        If (iBytesRead > 0) Begin
70725>>>>>>>>>            If (Right(sLine, iEOLLength) = sEOL) Begin
70727>>>>>>>>>                Move (Left(sLine, (Length(sLine) - iEOLLength))) to sLine
70728>>>>>>>>>                Move True to bEndOfRow
70729>>>>>>>>>            End
70729>>>>>>>>>>
70729>>>>>>>>>        End
70729>>>>>>>>>>
70729>>>>>>>>>        Function_Return bEndOfRow
70730>>>>>>>>>    End_Function
70731>>>>>>>>>
70731>>>>>>>>>    // Writing to a binary file.
70731>>>>>>>>>    // Returns true if the data was written to the file without error.
70731>>>>>>>>>    Function BinaryFileWrite Integer iFilenumber String ByRef sWriteData Returns Boolean
70733>>>>>>>>>        Integer iBytesWritten iBytesToWrite iErrorNumber
70733>>>>>>>>>        Handle hFileHandle
70733>>>>>>>>>        Boolean bOk
70733>>>>>>>>>        Set pbError to False
70734>>>>>>>>>        Move False to bOk
70735>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70736>>>>>>>>>        If hFileHandle Begin
70738>>>>>>>>>            Move 0 to iBytesWritten
70739>>>>>>>>>            Move (Length(sWriteData)) to iBytesToWrite
70740>>>>>>>>>            Move (fsWriteFile(hFileHandle, AddressOf(sWriteData), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
70741>>>>>>>>>            If (bOk = False) Begin
70743>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
70744>>>>>>>>>                If iErrorNumber Begin
70746>>>>>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70747>>>>>>>>>                End
70747>>>>>>>>>>
70747>>>>>>>>>            End
70747>>>>>>>>>>
70747>>>>>>>>>            If (iBytesToWrite <> iBytesWritten) Begin
70749>>>>>>>>>                Send Warning_box "Not all data could be written!"
70750>>>>>>>>>                Move False to bOk
70751>>>>>>>>>            End
70751>>>>>>>>>>
70751>>>>>>>>>        End
70751>>>>>>>>>>
70751>>>>>>>>>        Else Begin
70752>>>>>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
70753>>>>>>>>>        End
70753>>>>>>>>>>
70753>>>>>>>>>        Function_Return bOk
70754>>>>>>>>>    End_Function
70755>>>>>>>>>
70755>>>>>>>>>    // Write HEX values to a binary file as bytes.
70755>>>>>>>>>    // HEX values in sWriteHEX are first coverted to bytes and then written
70755>>>>>>>>>    // to the binary file.
70755>>>>>>>>>    // Returns true if the HEX data was written to the file without error.
70755>>>>>>>>>    Function BinaryFileWriteHex Integer iFilenumer String ByRef sWriteHex Returns Boolean
70757>>>>>>>>>        String sData
70757>>>>>>>>>        Integer iLength iCount iByte
70757>>>>>>>>>        Boolean bOk
70757>>>>>>>>>        Move (Length(sWritehex)) to iLength
70758>>>>>>>>>        Move 1 to iCount
70759>>>>>>>>>        While (iCount < iLength)
70763>>>>>>>>>            Move ("$"+Mid(sWriteHex, 2, iCount)) to iByte
70764>>>>>>>>>            Move (iCount + 2) to iCount
70765>>>>>>>>>            Move (sData + Character(iByte)) to sData
70766>>>>>>>>>        Loop
70767>>>>>>>>>>
70767>>>>>>>>>        Get BinaryFileWrite iFilenumer (&sData) to bOk
70768>>>>>>>>>        Function_Return bOk
70769>>>>>>>>>    End_Function
70770>>>>>>>>>
70770>>>>>>>>>    // Retrives the file size from a binary file.
70770>>>>>>>>>    Function BinaryFileSize Integer iFilenumber Returns BigInt
70772>>>>>>>>>        BigInt biFilesize
70772>>>>>>>>>        Handle hFileHandle
70772>>>>>>>>>        Boolean bOk
70772>>>>>>>>>        Integer iErrorNumber
70772>>>>>>>>>        Set pbError to False
70773>>>>>>>>>        Move -1 to biFilesize
70774>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70775>>>>>>>>>        If hFileHandle Begin
70777>>>>>>>>>            // The LARGE_INTEGER structure has the same structure as a BigInt.
70777>>>>>>>>>            Move (fsGetFileSizeEx(hFileHandle, AddressOf(biFilesize))) to bOk
70778>>>>>>>>>            If (bOk = -False) Begin
70780>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
70781>>>>>>>>>                If iErrorNumber Begin
70783>>>>>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70784>>>>>>>>>                End
70784>>>>>>>>>>
70784>>>>>>>>>            End
70784>>>>>>>>>>
70784>>>>>>>>>        End
70784>>>>>>>>>>
70784>>>>>>>>>        Else Begin
70785>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70786>>>>>>>>>        End
70786>>>>>>>>>>
70786>>>>>>>>>        Function_Return biFilesize
70787>>>>>>>>>    End_Function
70788>>>>>>>>>
70788>>>>>>>>>    // Retrives the file position from a binary file.
70788>>>>>>>>>    // Returns -1 if an error occured.
70788>>>>>>>>>    Function BinaryFilePosition Integer iFilenumber Returns BigInt
70790>>>>>>>>>        BigInt biFilePosition biBigHi
70790>>>>>>>>>        Handle hFileHandle
70790>>>>>>>>>        Boolean bOk
70790>>>>>>>>>        Integer iErrorNumber iLo iHi
70790>>>>>>>>>        UInteger iNewPos
70790>>>>>>>>>
70790>>>>>>>>>        Set pbError to False
70791>>>>>>>>>        Move -1 to biFilePosition
70792>>>>>>>>>        Move 0 to iHi
70793>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70794>>>>>>>>>        If hFileHandle Begin
70796>>>>>>>>>            Move (2^32) to biBigHi
70797>>>>>>>>>            Move (fsSetFilePointer(hFileHandle, ilo, AddressOf(iHi), FILE_CURRENT)) to iNewPos
70798>>>>>>>>>            If (iNewPos = (biBigHi - 1)) Begin
70800>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
70801>>>>>>>>>                If iErrorNumber Begin
70803>>>>>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70804>>>>>>>>>                End
70804>>>>>>>>>>
70804>>>>>>>>>                Else Begin
70805>>>>>>>>>                    Move True to bOk
70806>>>>>>>>>                End
70806>>>>>>>>>>
70806>>>>>>>>>            End
70806>>>>>>>>>>
70806>>>>>>>>>            Else Begin
70807>>>>>>>>>                Move True to bOk
70808>>>>>>>>>            End
70808>>>>>>>>>>
70808>>>>>>>>>            If bOk Begin
70810>>>>>>>>>                Move ((iHi * biBigHi) + iNewPos) to biFilePosition
70811>>>>>>>>>            End
70811>>>>>>>>>>
70811>>>>>>>>>        End
70811>>>>>>>>>>
70811>>>>>>>>>        Else Begin
70812>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70813>>>>>>>>>        End
70813>>>>>>>>>>
70813>>>>>>>>>        Function_Return biFilePosition
70814>>>>>>>>>    End_Function
70815>>>>>>>>>
70815>>>>>>>>>    // Sets the file position from a binary file to a new position.
70815>>>>>>>>>    Procedure Set BinaryFilePosition Integer iFilenumber BigInt biPosition
70817>>>>>>>>>        Handle hFileHandle
70817>>>>>>>>>        Integer iHi iErrorNumber
70817>>>>>>>>>        UInteger iLo iNewPos
70817>>>>>>>>>        Boolean bOk
70817>>>>>>>>>        BigInt biFileSize biBigHi
70817>>>>>>>>>        structFile[] lsFile
70817>>>>>>>>>        structFile[] lsFile
70818>>>>>>>>>
70818>>>>>>>>>        Set pbError to False
70819>>>>>>>>>        Move False to bOk
70820>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70821>>>>>>>>>        If hFileHandle Begin
70823>>>>>>>>>            Move (2^32) to biBigHi
70824>>>>>>>>>            Move (biPosition / biBigHi) to iHi
70825>>>>>>>>>            Move (biPosition - (iHi * biBigHi)) to iLo
70826>>>>>>>>>            Move (fsSetFilePointer(hFileHandle, iLo, AddressOf(iHi), FILE_BEGIN)) to iNewPos
70827>>>>>>>>>            If (iNewPos = (biBigHi - 1)) Begin
70829>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
70830>>>>>>>>>                If iErrorNumber Begin
70832>>>>>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70833>>>>>>>>>                End
70833>>>>>>>>>>
70833>>>>>>>>>                Else Begin
70834>>>>>>>>>                    Move True to bOk
70835>>>>>>>>>                End
70835>>>>>>>>>>
70835>>>>>>>>>            End
70835>>>>>>>>>>
70835>>>>>>>>>            Else Begin
70836>>>>>>>>>                Move True to bOk
70837>>>>>>>>>            End
70837>>>>>>>>>>
70837>>>>>>>>>            If bOk Begin
70839>>>>>>>>>                Get BinaryFileSize iFilenumber to biFileSize
70840>>>>>>>>>                Get plsFile to lsFile
70841>>>>>>>>>                If (biFileSize > biPosition) Begin
70843>>>>>>>>>                    Move False to lsFile[iFilenumber].bEndOfFile
70844>>>>>>>>>                    Set pbEOF to False
70845>>>>>>>>>                End
70845>>>>>>>>>>
70845>>>>>>>>>                Else Begin
70846>>>>>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
70847>>>>>>>>>                    Set pbEOF to True
70848>>>>>>>>>                End
70848>>>>>>>>>>
70848>>>>>>>>>                Set plsFile to lsFile
70849>>>>>>>>>            End
70849>>>>>>>>>>
70849>>>>>>>>>        End
70849>>>>>>>>>>
70849>>>>>>>>>        Else Begin
70850>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70851>>>>>>>>>        End
70851>>>>>>>>>>
70851>>>>>>>>>        Set pbError to (not(bOk))
70852>>>>>>>>>    End_Procedure
70853>>>>>>>>>
70853>>>>>>>>>    // Returns -1 if an error occured.
70853>>>>>>>>>    Function BinaryFileCachedPosition Integer iFileNumber Returns BigInt
70855>>>>>>>>>        BigInt biPosition
70855>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70855>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70856>>>>>>>>>        Handle hFileHandle
70856>>>>>>>>>        Move -1 to biPosition
70857>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70858>>>>>>>>>        If hFileHandle Begin
70860>>>>>>>>>            Get plsCachedPointer to lsFileBufferPointer
70861>>>>>>>>>            If (iFilenumber < SizeOfArray(lsFileBufferPointer)) Begin
70863>>>>>>>>>                If (lsFileBufferPointer[iFileNumber].iBufferSize > 0) Begin
70865>>>>>>>>>                    Move (lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferPointer - 1) to biPosition
70866>>>>>>>>>                End
70866>>>>>>>>>>
70866>>>>>>>>>                Else Begin
70867>>>>>>>>>                    Get BinaryFilePosition iFileNumber to biPosition
70868>>>>>>>>>                End
70868>>>>>>>>>>
70868>>>>>>>>>            End
70868>>>>>>>>>>
70868>>>>>>>>>            Else Begin
70869>>>>>>>>>                Get BinaryFilePosition iFileNumber to biPosition
70870>>>>>>>>>            End
70870>>>>>>>>>>
70870>>>>>>>>>        End
70870>>>>>>>>>>
70870>>>>>>>>>        Else Begin
70871>>>>>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
70872>>>>>>>>>        End
70872>>>>>>>>>>
70872>>>>>>>>>        Function_Return biPosition
70873>>>>>>>>>    End_Function
70874>>>>>>>>>
70874>>>>>>>>>    // Sets the pointer For the current file cache.
70874>>>>>>>>>    Procedure Set BinaryFileChachedPosition Integer iFileNumber BigInt biNewPosition
70876>>>>>>>>>        Handle hFileHandle
70876>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70876>>>>>>>>>        structFileBufferPointer[] lsFileBufferPointer
70877>>>>>>>>>        String[] saCachedBuffer
70878>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70879>>>>>>>>>        If hFileHandle Begin
70881>>>>>>>>>            Get plsCachedPointer to lsFileBufferPointer
70882>>>>>>>>>            If (lsFileBufferPointer[iFileNumber].biFromFilePosition > biNewPosition) Begin
70884>>>>>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
70885>>>>>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
70886>>>>>>>>>                Set plsCachedPointer to lsFileBufferPointer
70887>>>>>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
70888>>>>>>>>>                Get psaCachedBuffer to saCachedBuffer
70889>>>>>>>>>                Move "" to saCachedBuffer[iFileNumber]
70890>>>>>>>>>                Set psaCachedBuffer to saCachedBuffer
70891>>>>>>>>>            End
70891>>>>>>>>>>
70891>>>>>>>>>            Else If ((lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferSize) < biNewPosition) Begin
70894>>>>>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
70895>>>>>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
70896>>>>>>>>>                Set plsCachedPointer to lsFileBufferPointer
70897>>>>>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
70898>>>>>>>>>                Get psaCachedBuffer to saCachedBuffer
70899>>>>>>>>>                Move "" to saCachedBuffer[iFileNumber]
70900>>>>>>>>>                Set psaCachedBuffer to saCachedBuffer
70901>>>>>>>>>            End
70901>>>>>>>>>>
70901>>>>>>>>>            Else Begin
70902>>>>>>>>>                Move (biNewPosition - lsFileBufferPointer[iFileNumber].biFromFilePosition + 1) to lsFileBufferPointer[iFileNumber].iBufferPointer
70903>>>>>>>>>                Set plsCachedPointer to lsFileBufferPointer
70904>>>>>>>>>            End
70904>>>>>>>>>>
70904>>>>>>>>>        End
70904>>>>>>>>>>
70904>>>>>>>>>        Else Begin
70905>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70906>>>>>>>>>        End
70906>>>>>>>>>>
70906>>>>>>>>>    End_Procedure
70907>>>>>>>>>
70907>>>>>>>>>    // Truncate or extend a binary file to the specified file position
70907>>>>>>>>>    // by setting the binary file End Of File position.
70907>>>>>>>>>    // If biPosition is -1 the current file position is used as EOF position.
70907>>>>>>>>>    Procedure Set BinaryFileEndOfFile Integer iFilenumber BigInt biPosition
70909>>>>>>>>>        Handle hFileHandle
70909>>>>>>>>>        Boolean bError bOk
70909>>>>>>>>>        Integer iErrorNumber
70909>>>>>>>>>        structFile[] lsFile
70909>>>>>>>>>        structFile[] lsFile
70910>>>>>>>>>        Set pbError to False
70911>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70912>>>>>>>>>        If hFileHandle Begin
70914>>>>>>>>>            If (biPosition > -1) Begin
70916>>>>>>>>>                Set BinaryFilePosition iFilenumber to biPosition
70917>>>>>>>>>            End
70917>>>>>>>>>>
70917>>>>>>>>>            Get pbError to bError
70918>>>>>>>>>            If (bError = False) Begin
70920>>>>>>>>>                Move (fsSetEndOfFile(hFileHandle)) to bOk
70921>>>>>>>>>                If (bOk = False) Begin
70923>>>>>>>>>                    Move (fsGetLastError()) to iErrorNumber
70924>>>>>>>>>                    If iErrorNumber Begin
70926>>>>>>>>>                        Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
70927>>>>>>>>>                    End
70927>>>>>>>>>>
70927>>>>>>>>>                End
70927>>>>>>>>>>
70927>>>>>>>>>                Else Begin
70928>>>>>>>>>                    Get plsFile to lsFile
70929>>>>>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
70930>>>>>>>>>                    Set plsFile to lsFile
70931>>>>>>>>>                    Set pbEOF to True
70932>>>>>>>>>                End
70932>>>>>>>>>>
70932>>>>>>>>>            End
70932>>>>>>>>>>
70932>>>>>>>>>        End
70932>>>>>>>>>>
70932>>>>>>>>>        Else Begin
70933>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70934>>>>>>>>>        End
70934>>>>>>>>>>
70934>>>>>>>>>        Set pbError to (not(bOk))
70935>>>>>>>>>    End_Procedure
70936>>>>>>>>>
70936>>>>>>>>>    // Returns true if the last read from the binary file had reached the end.
70936>>>>>>>>>    Function BinaryFileEndOfFile Integer iFilenumber Returns Boolean
70938>>>>>>>>>        structFile[] lsFile
70938>>>>>>>>>        structFile[] lsFile
70939>>>>>>>>>        Handle hFileHandle
70939>>>>>>>>>        Boolean bEndOfFile
70939>>>>>>>>>        Move True to bEndOfFile
70940>>>>>>>>>        Set pbError to False
70941>>>>>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
70942>>>>>>>>>        If hFileHandle Begin
70944>>>>>>>>>            Get plsFile to lsFile
70945>>>>>>>>>            Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
70946>>>>>>>>>        End
70946>>>>>>>>>>
70946>>>>>>>>>        Else Begin
70947>>>>>>>>>            Send warning_box FS_FILEHANDLEMISSING
70948>>>>>>>>>        End
70948>>>>>>>>>>
70948>>>>>>>>>        Function_Return bEndOfFile
70949>>>>>>>>>    End_Function
70950>>>>>>>>>
70950>>>>>>>>>    // Returns the filehandle from the filenumber.
70950>>>>>>>>>    // Returns 0 if the filenumber is not used.
70950>>>>>>>>>    Function BinaryFileHandle Integer iFilenumber Returns Handle
70952>>>>>>>>>        Handle hFileHandle
70952>>>>>>>>>        structFile[] lsFile
70952>>>>>>>>>        structFile[] lsFile
70953>>>>>>>>>        Get plsFile to lsFile
70954>>>>>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70956>>>>>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
70957>>>>>>>>>        End
70957>>>>>>>>>>
70957>>>>>>>>>        Function_Return hFileHandle
70958>>>>>>>>>    End_Function
70959>>>>>>>>>
70959>>>>>>>>>    // Searches For a file
70959>>>>>>>>>    // iMode = DIRMODE_FILES_ONLY (default)
70959>>>>>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
70959>>>>>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES
70959>>>>>>>>>    // Returns True if found
70959>>>>>>>>>    Function FileExists String sFilePathMask Integer iFileDirMode Returns Boolean
70961>>>>>>>>>        Integer iMode
70961>>>>>>>>>        Boolean bFound
70961>>>>>>>>>        tsSearchResult[] lsResult
70961>>>>>>>>>        tsSearchResult[] lsResult
70962>>>>>>>>>        Move False to bFound
70963>>>>>>>>>        Set pbError to False
70964>>>>>>>>>        If (num_arguments < 2) Begin
70966>>>>>>>>>            Move DIRMODE_FILES_ONLY to iMode
70967>>>>>>>>>        End
70967>>>>>>>>>>
70967>>>>>>>>>        Else Begin
70968>>>>>>>>>            Move iFileDirMode to iMode
70969>>>>>>>>>        End
70969>>>>>>>>>>
70969>>>>>>>>>        Get FileSearch sFilePathMask iMode True to lsResult
70970>>>>>>>>>        If (SizeOfArray(lsResult) > 0) Begin
70972>>>>>>>>>            Move True to bFound
70973>>>>>>>>>        End
70973>>>>>>>>>>
70973>>>>>>>>>        Function_Return bFound
70974>>>>>>>>>    End_Function
70975>>>>>>>>>
70975>>>>>>>>>    // Deletes a file.
70975>>>>>>>>>    // Returns True if succeeds.
70975>>>>>>>>>    Function FileDelete String sFilename Integer iRetryAttempts Returns Boolean
70977>>>>>>>>>        Boolean bFound bDeleted
70977>>>>>>>>>        Integer iErrorNumber iRetryLeft
70977>>>>>>>>>
70977>>>>>>>>>        Set pbError to False
70978>>>>>>>>>        If (num_arguments > 1) Begin
70980>>>>>>>>>            Move iRetryAttempts to iRetryLeft
70981>>>>>>>>>        End
70981>>>>>>>>>>
70981>>>>>>>>>        Else Begin
70982>>>>>>>>>            Move 0 to iRetryLeft
70983>>>>>>>>>        End
70983>>>>>>>>>>
70983>>>>>>>>>        Get FileExists sFilename to bFound
70984>>>>>>>>>        If bFound Begin
70986>>>>>>>>>            Repeat
70986>>>>>>>>>>
70986>>>>>>>>>                Move (ToAnsi(sFilename)) To sFilename
70987>>>>>>>>>                Move (sFilename+(Character(0))) to sFilename
70988>>>>>>>>>                Move (fsDeleteFile(sFilename)) to bDeleted
70989>>>>>>>>>                If (bDeleted = False) Begin
70991>>>>>>>>>                    Decrement iRetryLeft
70992>>>>>>>>>                    If (iRetryLeft <= 0) Begin
70994>>>>>>>>>                        Move (fsGetLastError()) to iErrorNumber
70995>>>>>>>>>                        If iErrorNumber Begin
70997>>>>>>>>>                            Send DoShowError iErrorNumber ("Tried to delete file: "+sFilename)
70998>>>>>>>>>                        End
70998>>>>>>>>>>
70998>>>>>>>>>                    End
70998>>>>>>>>>>
70998>>>>>>>>>                    Else Begin
70999>>>>>>>>>                        Sleep 1
71000>>>>>>>>>                    End
71000>>>>>>>>>>
71000>>>>>>>>>                End
71000>>>>>>>>>>
71000>>>>>>>>>            Until (bDeleted = True or iRetryLeft <= 0)
71002>>>>>>>>>        End
71002>>>>>>>>>>
71002>>>>>>>>>        Function_Return bDeleted
71003>>>>>>>>>    End_Function
71004>>>>>>>>>
71004>>>>>>>>>    // Moves a file or directory.
71004>>>>>>>>>    // Returns True if succeeds.
71004>>>>>>>>>    Function FileMove String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
71006>>>>>>>>>        Boolean bMoved
71006>>>>>>>>>        Integer iErrorNumber iRetryLeft
71006>>>>>>>>>
71006>>>>>>>>>        Set pbError to False
71007>>>>>>>>>        If (num_arguments > 2) Begin
71009>>>>>>>>>            Move iRetryAttempts to iRetryLeft
71010>>>>>>>>>        End
71010>>>>>>>>>>
71010>>>>>>>>>        Else Begin
71011>>>>>>>>>            Move 0 to iRetryLeft
71012>>>>>>>>>        End
71012>>>>>>>>>>
71012>>>>>>>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileName
71013>>>>>>>>>        Move (ToAnsi(sNewFileName))      to sNewFileName
71014>>>>>>>>>        Move (sExistingFilename+(Character(0))) to sExistingFilename
71015>>>>>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
71016>>>>>>>>>        Repeat
71016>>>>>>>>>>
71016>>>>>>>>>            Move (fsMoveFile(sExistingFilename, sNewFileName)) to bMoved
71017>>>>>>>>>            If (bMoved = False) Begin
71019>>>>>>>>>                Decrement iRetryLeft
71020>>>>>>>>>                If (iRetryLeft <= 0) Begin
71022>>>>>>>>>                    Move (fsGetLastError()) to iErrorNumber
71023>>>>>>>>>                    If iErrorNumber Begin
71025>>>>>>>>>                        Send DoShowError iErrorNumber ("Tried to move/rename file: "+sExistingFileName+" to "+sNewFileName)
71026>>>>>>>>>                    End
71026>>>>>>>>>>
71026>>>>>>>>>                End
71026>>>>>>>>>>
71026>>>>>>>>>                Else Begin
71027>>>>>>>>>                    Sleep 1
71028>>>>>>>>>                End
71028>>>>>>>>>>
71028>>>>>>>>>            End
71028>>>>>>>>>>
71028>>>>>>>>>        Until (bMoved = True or iRetryLeft <= 0)
71030>>>>>>>>>        Function_Return bMoved
71031>>>>>>>>>    End_Function
71032>>>>>>>>>
71032>>>>>>>>>    // Copies a file. Overwriting an existing file by default.
71032>>>>>>>>>    // Returns True if succeeds.
71032>>>>>>>>>    Function FileCopy String sExistingFileName String sNewFileName Boolean bFailIfExists Integer iRetryAttempts Returns Boolean
71034>>>>>>>>>        Boolean bCopied
71034>>>>>>>>>        Boolean bDoNotOverwrite
71034>>>>>>>>>        Integer iErrorNumber iRetryLeft
71034>>>>>>>>>        Set pbError to False
71035>>>>>>>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileName
71036>>>>>>>>>        Move (ToAnsi(sNewFileName))      to sNewFileName
71037>>>>>>>>>        Move (sExistingFileName+(Character(0))) to sExistingFileName
71038>>>>>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
71039>>>>>>>>>        If (Num_Arguments > 2) Begin
71041>>>>>>>>>            Move bFailIfExists to bDoNotOverwrite
71042>>>>>>>>>        End
71042>>>>>>>>>>
71042>>>>>>>>>        Else Begin
71043>>>>>>>>>            Move False to bDoNotOverwrite
71044>>>>>>>>>        End
71044>>>>>>>>>>
71044>>>>>>>>>        If (num_arguments > 3) Begin
71046>>>>>>>>>            Move iRetryAttempts to iRetryLeft
71047>>>>>>>>>        End
71047>>>>>>>>>>
71047>>>>>>>>>        Else Begin
71048>>>>>>>>>            Move 0 to iRetryLeft
71049>>>>>>>>>        End
71049>>>>>>>>>>
71049>>>>>>>>>        Repeat
71049>>>>>>>>>>
71049>>>>>>>>>            Move (fsCopyFile(sExistingFileName, sNewFileName, bDoNotOverwrite)) to bCopied
71050>>>>>>>>>            If (bCopied = False) Begin
71052>>>>>>>>>                Decrement iRetryLeft
71053>>>>>>>>>                If (iRetryLeft <= 0) Begin
71055>>>>>>>>>                    Move (fsGetLastError()) to iErrorNumber
71056>>>>>>>>>                    If iErrorNumber Begin
71058>>>>>>>>>                        Send DoShowError iErrorNumber ("Tried to copy file: "+sExistingFileName+" to "+sNewFileName)
71059>>>>>>>>>                    End
71059>>>>>>>>>>
71059>>>>>>>>>                End
71059>>>>>>>>>>
71059>>>>>>>>>                Else Begin
71060>>>>>>>>>                    Sleep 1
71061>>>>>>>>>                End
71061>>>>>>>>>>
71061>>>>>>>>>            End
71061>>>>>>>>>>
71061>>>>>>>>>        Until (bCopied = True or iRetryLeft <= 0)
71063>>>>>>>>>        Function_Return bCopied
71064>>>>>>>>>    End_Function
71065>>>>>>>>>
71065>>>>>>>>>    // Renames a file or directory.
71065>>>>>>>>>    // Returns True if succeeds.
71065>>>>>>>>>    Function FileRename String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
71067>>>>>>>>>        Boolean bRenamed
71067>>>>>>>>>        If (num_arguments > 2) Begin
71069>>>>>>>>>            Get FileMove sExistingFileName sNewFileName iRetryAttempts to bRenamed
71070>>>>>>>>>        End
71070>>>>>>>>>>
71070>>>>>>>>>        Else Begin
71071>>>>>>>>>            Get FileMove sExistingFileName sNewFileName to bRenamed
71072>>>>>>>>>        End
71072>>>>>>>>>>
71072>>>>>>>>>        Function_Return bRenamed
71073>>>>>>>>>    End_Function
71074>>>>>>>>>
71074>>>>>>>>>    // Returns the file size of a file.
71074>>>>>>>>>    // Returns -1 if an error occured.
71074>>>>>>>>>    // Use *this* instead of FileSize as it works for both 32 bit as well as 64 bit and can
71074>>>>>>>>>    // always return filesizes over 2GB.
71074>>>>>>>>>    Function FileSizeEx String sFilename Returns Bigint
71076>>>>>>>>>        tsSearchResult[] lsSearchResult
71076>>>>>>>>>        tsSearchResult[] lsSearchResult
71077>>>>>>>>>        BigInt iRetval
71077>>>>>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
71078>>>>>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
71080>>>>>>>>>            Move lsSearchResult[0].biFileSize to iRetval
71081>>>>>>>>>        End
71081>>>>>>>>>>
71081>>>>>>>>>        Else Begin
71082>>>>>>>>>            Move -1 to iRetval
71083>>>>>>>>>        End
71083>>>>>>>>>>
71083>>>>>>>>>        Function_Return iRetval
71084>>>>>>>>>    End_Function
71085>>>>>>>>>
71085>>>>>>>>>//
71085>>>>>>>>>// Check your source code to see if it uses the filesize function and if it does, change it to FileSizeEx
71085>>>>>>>>>// Once you verified that you are no longer using filesize, then add the following line to your code.
71085>>>>>>>>>//
71085>>>>>>>>>// // Source is not using obsolete filesize function
71085>>>>>>>>> Define no_cFileSystem_filesize_here
71085>>>>>>>>>//
71085>>>>>>>>>// and the warning is resolved.
71085>>>>>>>>>
71085>>>>>>>>>    // Returns the last write date of a file.
71085>>>>>>>>>    // Returns 0 if an error occured.
71085>>>>>>>>>    Function FileDate String sFilename Returns Date
71087>>>>>>>>>        tsSearchResult[] lsSearchResult
71087>>>>>>>>>        tsSearchResult[] lsSearchResult
71088>>>>>>>>>        Date dDate
71088>>>>>>>>>        Move 0 to dDate
71089>>>>>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
71090>>>>>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
71092>>>>>>>>>            Move lsSearchResult[0].dtLastWriteDateTime to dDate
71093>>>>>>>>>        End
71093>>>>>>>>>>
71093>>>>>>>>>        Function_Return dDate
71094>>>>>>>>>    End_Function
71095>>>>>>>>>
71095>>>>>>>>>    // Returns the fileversion info.
71095>>>>>>>>>    // Returns false if an error occured.
71095>>>>>>>>>    Function FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Boolean
71097>>>>>>>>>        Boolean bOk
71097>>>>>>>>>        Integer iErrorNumber iStatus
71097>>>>>>>>>        Get _FileVersion sFilename (&lsFileVersionInfo) to iStatus
71098>>>>>>>>>        If (iStatus = -1) Begin
71100>>>>>>>>>            Move (fsGetLastError()) to iErrorNumber
71101>>>>>>>>>            If iErrorNumber Begin
71103>>>>>>>>>                Send DoShowError iErrorNumber ("Tried to get fileversion info from file: "+sFilename)
71104>>>>>>>>>            End
71104>>>>>>>>>>
71104>>>>>>>>>        End
71104>>>>>>>>>>
71104>>>>>>>>>        Move (iStatus = 0) to bOk
71105>>>>>>>>>        Function_Return bOk
71106>>>>>>>>>    End_Function
71107>>>>>>>>>
71107>>>>>>>>>    Function _FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Integer
71109>>>>>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
71109>>>>>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
71109>>>>>>>>>        UInteger iBytesNeeded
71109>>>>>>>>>        Address aBuffer
71109>>>>>>>>>        Boolean bOk
71109>>>>>>>>>        String sSubBlock
71109>>>>>>>>>        DWord dwBufferLen dwBufferPointer
71109>>>>>>>>>        tsLandAndCodePage lsLandAndCodePage
71109>>>>>>>>>        tsLandAndCodePage lsLandAndCodePage
71109>>>>>>>>>        Move (ToANSI(sFilename)) To sFilename
71110>>>>>>>>>        Move (sFilename + (Character(0))) to sFilename
71111>>>>>>>>>        Move 0 to iBytesNeeded
71112>>>>>>>>>        Move 0 to aBuffer
71113>>>>>>>>>        Move 0 to lsFIXEDFILEINFO.dwStrucVersion    // Initialize the variable.
71114>>>>>>>>>        Move 0 to lsLandAndCodePage.wCodePage
71115>>>>>>>>>        Move (fsGetFileVersionInfoSize(sFilename, 0)) to iBytesNeeded
71116>>>>>>>>>        If (iBytesNeeded = 0) Begin
71118>>>>>>>>>            Function_Return False
71119>>>>>>>>>        End
71119>>>>>>>>>>
71119>>>>>>>>>        Move False to bOk
71120>>>>>>>>>        Move (Alloc(iBytesNeeded)) to aBuffer
71121>>>>>>>>>        Move (MemSet(aBuffer, 0, iBytesNeeded)) to bOk
71122>>>>>>>>>        Move (fsGetFileVersionInfo(sFilename, 0, iBytesNeeded, aBuffer)) to bOk
71123>>>>>>>>>        If (not(bOk)) Begin
71125>>>>>>>>>            Move (Free(aBuffer)) to bOk
71126>>>>>>>>>            Function_Return -1
71127>>>>>>>>>        End
71127>>>>>>>>>>
71127>>>>>>>>>        Move "\" to sSubBlock
71128>>>>>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
71129>>>>>>>>>        Move 0 to dwBufferLen
71130>>>>>>>>>        Move 0 to dwBufferPointer
71131>>>>>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
71132>>>>>>>>>        If (not(bOk)) Begin
71134>>>>>>>>>            Move (Free(aBuffer)) to bOk
71135>>>>>>>>>            Function_Return -1
71136>>>>>>>>>        End
71136>>>>>>>>>>
71136>>>>>>>>>        If (dwBufferLen <> 52) Begin
71138>>>>>>>>>            Send warning_box (SFormat("Length of bufferdata For VS_FIXEDFILEINFO struct are not in the expected size.\nLength is %1 and should have been 52.", dwBufferLen))
71139>>>>>>>>>            Move (Free(aBuffer)) to bOk
71140>>>>>>>>>            Function_Return -2
71141>>>>>>>>>        End
71141>>>>>>>>>>
71141>>>>>>>>>        Move (MemCopy(AddressOf(lsFIXEDFILEINFO), dwBufferPointer, dwBufferLen)) to bOk
71142>>>>>>>>>        If (not(bOk)) Begin
71144>>>>>>>>>            Move (Free(aBuffer)) to bOk
71145>>>>>>>>>            Function_Return -1
71146>>>>>>>>>        End
71146>>>>>>>>>>
71146>>>>>>>>>        Move lsFIXEDFILEINFO to lsFileVersionInfo.lsFIXEDFILEINFO
71147>>>>>>>>>        Get ConvertFileTimeToLocalDateTime lsFIXEDFILEINFO.ubiFileDate to lsFileVersionInfo.dtCreationDateTime
71148>>>>>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[0]
71149>>>>>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[1]
71150>>>>>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[2]
71151>>>>>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[3]
71152>>>>>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[0]
71153>>>>>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[1]
71154>>>>>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[2]
71155>>>>>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[3]
71156>>>>>>>>>        Move "\VarFileInfo\Translation" to sSubBlock
71157>>>>>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
71158>>>>>>>>>        Move 0 to dwBufferLen
71159>>>>>>>>>        Move 0 to dwBufferPointer
71160>>>>>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
71161>>>>>>>>>        If (not(bOk)) Begin
71163>>>>>>>>>            Move (Free(aBuffer)) to bOk
71164>>>>>>>>>            Function_Return -1
71165>>>>>>>>>        End
71165>>>>>>>>>>
71165>>>>>>>>>        If (dwBufferLen <> 4) Begin
71167>>>>>>>>>            Send warning_box (SFormat("Length of bufferdata For land and codepage numbers are not in the expected size.\nLength is %1 and should have been 4.", dwBufferLen))
71168>>>>>>>>>            Move (Free(aBuffer)) to bOk
71169>>>>>>>>>            Function_Return -2
71170>>>>>>>>>        End
71170>>>>>>>>>>
71170>>>>>>>>>        Move (MemCopy(AddressOf(lsLandAndCodePage), dwBufferPointer, dwBufferLen)) to bOk
71171>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "Comments" lsLandAndCodePage to lsFileVersionInfo.sComments
71172>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "CompanyName" lsLandAndCodePage to lsFileVersionInfo.sCompanyName
71173>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileDescription" lsLandAndCodePage to lsFileVersionInfo.sFileDescription
71174>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileVersion" lsLandAndCodePage to lsFileVersionInfo.sFileVersion
71175>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "InternalName" lsLandAndCodePage to lsFileVersionInfo.sInternalName
71176>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalCopyright" lsLandAndCodePage to lsFileVersionInfo.sLegalCopyright
71177>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalTrademarks" lsLandAndCodePage to lsFileVersionInfo.sLegalTrademarks
71178>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "OriginalFilename" lsLandAndCodePage to lsFileVersionInfo.sOriginalFilename
71179>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductName" lsLandAndCodePage to lsFileVersionInfo.sProductName
71180>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductVersion" lsLandAndCodePage to lsFileVersionInfo.sProductVersion
71181>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "PrivateBuild" lsLandAndCodePage to lsFileVersionInfo.sPrivateBuild
71182>>>>>>>>>        Get VerQueryValueStringFileInfo aBuffer "SpecialBuild" lsLandAndCodePage to lsFileVersionInfo.sSpecialBuild
71183>>>>>>>>>        Move (Free(aBuffer)) to bOk
71184>>>>>>>>>        Function_Return 0
71185>>>>>>>>>    End_Function
71186>>>>>>>>>
71186>>>>>>>>>    // Convert an short integer to a 4-character hex string.
71186>>>>>>>>>    Function ShortToHex Short siValue Returns String
71188>>>>>>>>>        String sHex
71188>>>>>>>>>        Move "" to sHex
71189>>>>>>>>>        Repeat
71189>>>>>>>>>>
71189>>>>>>>>>            Move (Mid ("0123456789ABCDEF", 1, ((siValue iand |CI$0F) + 1)) + sHex) to sHex
71190>>>>>>>>>            Move (siValue / |CI$10) to siValue
71191>>>>>>>>>        Until (siValue = 0)
71193>>>>>>>>>        Move (Right("0000" + sHex, 4)) to sHex
71194>>>>>>>>>        Function_Return sHex
71195>>>>>>>>>    End_Function
71196>>>>>>>>>
71196>>>>>>>>>    Function VerQueryValueStringFileInfo Address aBuffer String sInfoName tsLandAndCodePage lsLandAndCodePage Returns String
71198>>>>>>>>>        String sSubBlock
71198>>>>>>>>>        String sValue
71198>>>>>>>>>        DWord dwBufferLen dwBufferPointer
71198>>>>>>>>>        Boolean bOk
71198>>>>>>>>>        Move (SFormat("\StringFileInfo\%1%2\%3", ShortToHex(Self, lsLandAndCodePage.wLanguage), ShortToHex(Self, lsLandAndCodePage.wCodePage), sInfoName)) to sSubBlock
71199>>>>>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
71200>>>>>>>>>        Move 0 to dwBufferLen
71201>>>>>>>>>        Move 0 to dwBufferPointer
71202>>>>>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
71203>>>>>>>>>        If (not(bOk)) Begin
71205>>>>>>>>>            Function_Return ""
71206>>>>>>>>>        End
71206>>>>>>>>>>
71206>>>>>>>>>        Move (ZeroString(dwBufferLen)) to sValue
71207>>>>>>>>>        Move (MemCopy(AddressOf(sValue), dwBufferPointer, dwBufferLen)) to bOk
71208>>>>>>>>>        Move (ToOEM(CString(sValue))) To sValue
71209>>>>>>>>>        Function_Return sValue
71210>>>>>>>>>    End_Function
71211>>>>>>>>>
71211>>>>>>>>>    // Returns the file extention without the leading "."
71211>>>>>>>>>    // Example sFile = "x:\text.txt". The function returns "txt".
71211>>>>>>>>>    Function FileExtention String sFilename Returns String
71213>>>>>>>>>        String sExtention
71213>>>>>>>>>        Integer iPos
71213>>>>>>>>>        Move (RightPos(".", sFilename)) to iPos
71214>>>>>>>>>        If (iPos > 0) Begin
71216>>>>>>>>>            Move (Right(sFilename, (Length(sFilename) - iPos))) to sExtention
71217>>>>>>>>>            If (sExtention contains "\" or sExtention contains " ") Begin
71219>>>>>>>>>                Move "" to sExtention
71220>>>>>>>>>            End
71220>>>>>>>>>>
71220>>>>>>>>>        End
71220>>>>>>>>>>
71220>>>>>>>>>        Function_Return sExtention
71221>>>>>>>>>    End_Function
71222>>>>>>>>>
71222>>>>>>>>>    // Gets a handle to an icon stored as a resource in a file or an icon
71222>>>>>>>>>    // stored in a file's associated executable file.
71222>>>>>>>>>    // When the icon handle is no longer needed, close it by using the DestroyFileIcon procedure.
71222>>>>>>>>>    Function FileIcon String sFilename Returns Handle
71224>>>>>>>>>        Handle hIcon
71224>>>>>>>>>        Integer iIcon
71224>>>>>>>>>        Address aFilename
71224>>>>>>>>>        Move (ToANSI(sFilename)) To sFilename
71225>>>>>>>>>        Move (Pad(sFilename, MAX_PATH)) to sFilename
71226>>>>>>>>>        Move (AddressOf(sFileName)) To aFileName
71227>>>>>>>>>        Move 0 to iIcon
71228>>>>>>>>>        Move (fsExtractAssociatedIcon(0, aFilename, AddressOf(iIcon))) to hIcon
71229>>>>>>>>>        Function_Return hIcon
71230>>>>>>>>>    End_Function
71231>>>>>>>>>
71231>>>>>>>>>    // Destroy hIcon, created from FileIcon.
71231>>>>>>>>>    Procedure DestroyFileIcon Handle hIcon
71233>>>>>>>>>        Integer iResult
71233>>>>>>>>>        If (hIcon <> 0) Begin
71235>>>>>>>>>            Move (fsDestroyIcon(hIcon)) to iResult
71236>>>>>>>>>        End
71236>>>>>>>>>>
71236>>>>>>>>>    End_Procedure
71237>>>>>>>>>
71237>>>>>>>>>    // Search a directory For the files with normal windows mask-signs
71237>>>>>>>>>    // Returns an array of matching files and directories
71237>>>>>>>>>    // iMode = DIRMODE_FILES_ONLY
71237>>>>>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
71237>>>>>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
71237>>>>>>>>>    // If bReturnOnlyOne is true only one search result item is returned.
71237>>>>>>>>>    // If bReturnOnlyOne is true and no items where found no error is shown.
71237>>>>>>>>>    Function FileSearch String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
71239>>>>>>>>>        tsSearchResult[] lsSearchResult
71239>>>>>>>>>        tsSearchResult[] lsSearchResult
71240>>>>>>>>>        Integer iSearchResultCount iMode iErrorNumber
71240>>>>>>>>>        structWFD lsFindData
71240>>>>>>>>>        structWFD lsFindData
71240>>>>>>>>>        Handle hFindFile
71240>>>>>>>>>        Boolean bError bStop bFound bOk bOnlyOne
71240>>>>>>>>>        BigInt biBigHi
71240>>>>>>>>>        Address aFileName
71240>>>>>>>>>
71240>>>>>>>>>        If (num_arguments < 2) Begin
71242>>>>>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
71243>>>>>>>>>        End
71243>>>>>>>>>>
71243>>>>>>>>>        Else Begin
71244>>>>>>>>>            Move iFileDirMode to iMode
71245>>>>>>>>>        End
71245>>>>>>>>>>
71245>>>>>>>>>        If (num_arguments < 3) Begin
71247>>>>>>>>>            Move False to bOnlyOne
71248>>>>>>>>>        End
71248>>>>>>>>>>
71248>>>>>>>>>        Else Begin
71249>>>>>>>>>            Move bReturnOnlyOne to bOnlyOne
71250>>>>>>>>>        End
71250>>>>>>>>>>
71250>>>>>>>>>        Move (ToAnsi(sFilePathMask)) To sFilePathMask
71251>>>>>>>>>        Move (sFilePathMask+Character(0)) To sFilePathMask
71252>>>>>>>>>        Move 0 To lsFindData.dwFileAttributes   // Initialize lsFindData
71253>>>>>>>>>        Move (fsFindFirstFile(sFilePathMask, AddressOf(lsFindData))) to hFindFile
71254>>>>>>>>>        If (hFindFile <> INVALID_HANDLE_VALUE) Begin
71256>>>>>>>>>            Move False to bError
71257>>>>>>>>>            Move False to bStop
71258>>>>>>>>>            Move (2^32) to biBigHi
71259>>>>>>>>>            Set pbError to bError
71260>>>>>>>>>            While (bError = False and bStop = False)
71264>>>>>>>>>                Move False to bFound
71265>>>>>>>>>                Case Begin
71265>>>>>>>>>                    Case (iMode = DIRMODE_FILES_ONLY)
71267>>>>>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = 0) Begin
71269>>>>>>>>>                            Move True to bFound
71270>>>>>>>>>                        End
71270>>>>>>>>>>
71270>>>>>>>>>                        Case Break
71271>>>>>>>>>                    Case (iMode = DIRMODE_DIRECTORIES_ONLY)
71274>>>>>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = FILE_ATTRIBUTE_DIRECTORY) Begin
71276>>>>>>>>>                            Move True to bFound
71277>>>>>>>>>                        End
71277>>>>>>>>>>
71277>>>>>>>>>                        Case Break
71278>>>>>>>>>                    Case Else
71278>>>>>>>>>                        Move True to bFound
71279>>>>>>>>>                        Case Break
71280>>>>>>>>>                Case End
71280>>>>>>>>>                If bFound Begin
71282>>>>>>>>>                    Move (AddressOf(lsFindData.cFileName)) to aFilename
71283>>>>>>>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sFilename
71284>>>>>>>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sFilename)) to lsSearchResult[iSearchResultCount].sFilename
71285>>>>>>>>>                    Move (AddressOf(lsFindData.cAlternateFileName)) to aFilename
71286>>>>>>>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sAlternateFileName
71287>>>>>>>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sAlternateFileName)) To lsSearchResult[iSearchResultCount].sAlternateFileName
71288>>>>>>>>>                    Move lsFindData.dwFileAttributes to lsSearchResult[iSearchResultCount].iFileAttributes
71289>>>>>>>>>                    Get ConvertFileTimeToLocalDateTime lsFindData.ftCreationDateTime to lsSearchResult[iSearchResultCount].dtCreationDateTime
71290>>>>>>>>>                    Get ConvertFileTimeToLocalDateTime lsFindData.ftLastAccessDateTime to lsSearchResult[iSearchResultCount].dtLastAccessDateTime
71291>>>>>>>>>                    Get ConvertFileTimeToLocalDateTime lsFindData.ftLastWriteDateTime to lsSearchResult[iSearchResultCount].dtLastWriteDateTime
71292>>>>>>>>>                    Move ((lsFindData.nFileSizeHigh * biBigHi) + lsFindData.nFileSizeLow) to lsSearchResult[iSearchResultCount].biFileSize
71293>>>>>>>>>                    Increment iSearchResultCount
71294>>>>>>>>>                    If bOnlyOne Begin
71296>>>>>>>>>                        Move True to bStop
71297>>>>>>>>>                    End
71297>>>>>>>>>>
71297>>>>>>>>>                End
71297>>>>>>>>>>
71297>>>>>>>>>                If (bStop = False) Begin
71299>>>>>>>>>                    Move (fsFindNextFile(hFindFile, AddressOf(lsFindData))) to bOk
71300>>>>>>>>>                End
71300>>>>>>>>>>
71300>>>>>>>>>                If (bOk = False) Begin
71302>>>>>>>>>                    Move True to bStop
71303>>>>>>>>>                    If (bOnlyOne = False) Begin
71305>>>>>>>>>                        Move (fsGetLastError()) to iErrorNumber
71306>>>>>>>>>                        If (iErrorNumber <> ERROR_NO_MORE_FILES and iErrorNumber <> ERROR_MOD_NOT_FOUND and iErrorNumber <> 0) Begin
71308>>>>>>>>>                            Send DoShowError iErrorNumber ("Search path: "+sFilePathMask)
71309>>>>>>>>>                        End
71309>>>>>>>>>>
71309>>>>>>>>>                    End
71309>>>>>>>>>>
71309>>>>>>>>>                End
71309>>>>>>>>>>
71309>>>>>>>>>                Get pbError to bError
71310>>>>>>>>>            Loop
71311>>>>>>>>>>
71311>>>>>>>>>            Move (fsFindClose(hFindFile)) to bOk
71312>>>>>>>>>        End
71312>>>>>>>>>>
71312>>>>>>>>>        Function_Return lsSearchResult
71313>>>>>>>>>    End_Function
71314>>>>>>>>>
71314>>>>>>>>>    // Search a directory and all subdirectories For the files with normal windows mask-signs.
71314>>>>>>>>>    // lsResult[?].sFileName contains full path and filename.
71314>>>>>>>>>    // iMode = DIRMODE_FILES_ONLY
71314>>>>>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
71314>>>>>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
71314>>>>>>>>>    Function FileSearchRecursive String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
71316>>>>>>>>>        Integer iMode
71316>>>>>>>>>        Boolean bOnlyOne
71316>>>>>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
71316>>>>>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
71318>>>>>>>>>        If (num_arguments < 2) Begin
71320>>>>>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
71321>>>>>>>>>        End
71321>>>>>>>>>>
71321>>>>>>>>>        Else Begin
71322>>>>>>>>>            Move iFileDirMode to iMode
71323>>>>>>>>>        End
71323>>>>>>>>>>
71323>>>>>>>>>        If (num_arguments < 3) Begin
71325>>>>>>>>>            Move False to bOnlyOne
71326>>>>>>>>>        End
71326>>>>>>>>>>
71326>>>>>>>>>        Else Begin
71327>>>>>>>>>            Move bReturnOnlyOne to bOnlyOne
71328>>>>>>>>>        End
71328>>>>>>>>>>
71328>>>>>>>>>        Get FileSearchRecursivePriv sFilePathMask iMode bOnlyOne (&lsFinalResult) to lsSearchResult
71329>>>>>>>>>        Function_Return lsFinalResult
71330>>>>>>>>>    End_Function
71331>>>>>>>>>
71331>>>>>>>>>    // Private
71331>>>>>>>>>    Function FileSearchRecursivePriv String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne tsSearchResult[] ByRef lsFinalResult Returns tsSearchResult[]
71333>>>>>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
71333>>>>>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
71335>>>>>>>>>        Integer iMax iCnt iLast iFinalMax
71335>>>>>>>>>        String sSearchInDir sFileMask
71335>>>>>>>>>        Boolean bStop
71335>>>>>>>>>        
71335>>>>>>>>>        Move False to bStop
71336>>>>>>>>>        Move (RightPos("\", sFilePathMask)) to iLast
71337>>>>>>>>>        If (iLast > 0) Begin
71339>>>>>>>>>            Move (Left(sFilePathMask, iLast - 1)) to sSearchInDir
71340>>>>>>>>>            Move (Mid(sFilePathMask, Length(sFilePathMask), iLast + 1)) to sFileMask
71341>>>>>>>>>        End
71341>>>>>>>>>>
71341>>>>>>>>>        Get FileSearch (sSearchInDir + "\*.*") DIRMODE_DIRECTORIES_ONLY to lsSearchResultDir
71342>>>>>>>>>        Move (SizeOfArray(lsSearchResultDir)) to iMax
71343>>>>>>>>>        Move 0 to iCnt
71344>>>>>>>>>        While (iCnt < iMax and bStop = False)
71348>>>>>>>>>            If (lsSearchResultDir[iCnt].sFilename <> "." and lsSearchResultDir[iCnt].sFilename <> "..") Begin
71350>>>>>>>>>                Get FileSearchRecursivePriv (sSearchInDir + "\" + lsSearchResultDir[iCnt].sFilename + "\" + sFileMask) iFileDirMode bReturnOnlyOne (&lsFinalResult) to lsSearchResult
71351>>>>>>>>>            End
71351>>>>>>>>>>
71351>>>>>>>>>            Increment iCnt
71352>>>>>>>>>            If (bReturnOnlyOne = True) Begin
71354>>>>>>>>>                If (SizeOfArray(lsFinalResult) > 0) Begin
71356>>>>>>>>>                    Move True to bStop
71357>>>>>>>>>                End
71357>>>>>>>>>>
71357>>>>>>>>>            End
71357>>>>>>>>>>
71357>>>>>>>>>        Loop
71358>>>>>>>>>>
71358>>>>>>>>>        If (bStop = False) Begin
71360>>>>>>>>>            Get FileSearch sFilePathMask iFileDirMode to lsSearchResult
71361>>>>>>>>>            Move (SizeOfArray(lsSearchResult)) to iMax
71362>>>>>>>>>            Move (SizeOfArray(lsFinalResult)) to iFinalMax
71363>>>>>>>>>            Move 0 to iCnt
71364>>>>>>>>>            While (iCnt < iMax and bStop = False)
71368>>>>>>>>>                Move lsSearchResult[iCnt] to lsFinalResult[iFinalMax]
71369>>>>>>>>>                Move (sSearchInDir + "\" + lsSearchResult[iCnt].sFilename) to lsFinalResult[iFinalMax].sFilename
71370>>>>>>>>>                Increment iFinalMax
71371>>>>>>>>>                Increment iCnt
71372>>>>>>>>>                If (bReturnOnlyOne = True) Begin
71374>>>>>>>>>                    If (SizeOfArray(lsFinalResult) > 0) Begin
71376>>>>>>>>>                        Move True to bStop
71377>>>>>>>>>                    End
71377>>>>>>>>>>
71377>>>>>>>>>                End
71377>>>>>>>>>>
71377>>>>>>>>>            Loop
71378>>>>>>>>>>
71378>>>>>>>>>        End
71378>>>>>>>>>>
71378>>>>>>>>>        Function_Return lsSearchResult
71379>>>>>>>>>    End_Function
71380>>>>>>>>>
71380>>>>>>>>>    // Finds a list of files.
71380>>>>>>>>>    // sSearchFiles is a list of files to search For separated by semicolon (;).
71380>>>>>>>>>    // sSearchFiles may not contain paths but may contain wildcards.
71380>>>>>>>>>    // sSearchPaths may only contain paths.
71380>>>>>>>>>    // Returns a string array with the files
71380>>>>>>>>>    // Returns only files with full path.
71380>>>>>>>>>    // Use:
71380>>>>>>>>>    // Get ListOfFiles "path1;path2" "*.txt;*.asc"
71380>>>>>>>>>    // This will return all the .txt and .asc files with full path that exists in path1 and path2.
71380>>>>>>>>>    Function ListOfFiles String sSearchPaths String sSearchFiles Returns String[]
71382>>>>>>>>>        String[] saFileList
71383>>>>>>>>>        Integer iFilelistCount iSearchFilesCount iCurSearchFile
71383>>>>>>>>>        Integer iSearchPathsCount iCurSearchPath iFilesFound iCurFileFound
71383>>>>>>>>>        String sCurSearchFile sCurSearchPath
71383>>>>>>>>>        tsSearchResult[] lsSearchResult
71383>>>>>>>>>        tsSearchResult[] lsSearchResult
71384>>>>>>>>>        Get CountOfFields sSearchPaths to iSearchPathsCount
71385>>>>>>>>>        Get CountOfFields sSearchFiles to iSearchFilesCount
71386>>>>>>>>>        If (iSearchFilesCount > 0 and iSearchPathsCount > 0) Begin
71388>>>>>>>>>            For iCurSearchFile from 1 to iSearchFilesCount
71394>>>>>>>>>>
71394>>>>>>>>>                Get FieldAtIndex sSearchFiles iCurSearchFile to sCurSearchFile
71395>>>>>>>>>                Move (Trim(sCurSearchFile)) to sCurSearchFile
71396>>>>>>>>>                If (sCurSearchFile <> "") Begin
71398>>>>>>>>>                    For iCurSearchPath from 1 to iSearchPathsCount
71404>>>>>>>>>>
71404>>>>>>>>>                        Get FieldAtIndex sSearchPaths iCurSearchPath to sCurSearchPath
71405>>>>>>>>>                        If (Right(sCurSearchPath, 1) <> "\") Begin
71407>>>>>>>>>                            Move (sCurSearchPath + "\") to sCurSearchPath
71408>>>>>>>>>                        End
71408>>>>>>>>>>
71408>>>>>>>>>                        Get FileSearch (sCurSearchPath + sCurSearchFile) DIRMODE_FILES_ONLY to lsSearchResult
71409>>>>>>>>>                        Move (SizeOfArray(lsSearchResult)) to iFilesFound
71410>>>>>>>>>                        Decrement iFilesFound
71411>>>>>>>>>                        For iCurFileFound from 0 to iFilesFound
71417>>>>>>>>>>
71417>>>>>>>>>                            Move (sCurSearchPath + lsSearchResult[iCurFileFound].sFilename) to saFileList[iFilelistCount]
71418>>>>>>>>>                            Increment iFilelistCount
71419>>>>>>>>>                        Loop
71420>>>>>>>>>>
71420>>>>>>>>>                    Loop
71421>>>>>>>>>>
71421>>>>>>>>>                End
71421>>>>>>>>>>
71421>>>>>>>>>            Loop
71422>>>>>>>>>>
71422>>>>>>>>>        End
71422>>>>>>>>>>
71422>>>>>>>>>        Function_Return saFileList
71423>>>>>>>>>    End_Function
71424>>>>>>>>>
71424>>>>>>>>>    // Get Windows Temp path
71424>>>>>>>>>    Function FileTempPath Returns String
71426>>>>>>>>>        Integer iRetVal
71426>>>>>>>>>        String  sTempPath
71426>>>>>>>>>        Move (ZeroString(MAX_PATH)) to sTempPath
71427>>>>>>>>>        Move (fsGetTempPath(MAX_PATH, AddressOf(sTempPath))) to iRetVal
71428>>>>>>>>>        If (iRetVal > MAX_PATH) Begin
71430>>>>>>>>>            Move (ZeroString(iRetval)) to sTempPath
71431>>>>>>>>>            Move (fsGetTempPath(iRetVal, AddressOf(sTempPath))) to iRetVal
71432>>>>>>>>>        End
71432>>>>>>>>>>
71432>>>>>>>>>        Move (ToOEM(sTempPath)) To sTempPath
71433>>>>>>>>>        Move (CString(sTempPath)) to sTempPath
71434>>>>>>>>>        Function_Return sTempPath
71435>>>>>>>>>    End_Function
71436>>>>>>>>>
71436>>>>>>>>>    // Generates a temporary file.
71436>>>>>>>>>    // Returns full path and filename or blank if no file could be created.
71436>>>>>>>>>    // sPathName is the place where the temporary file is generated. If it is
71436>>>>>>>>>    // not argumented the TEMP enviroment variable is used. If that is also not
71436>>>>>>>>>    // available the current directory is used.
71436>>>>>>>>>    // You can prefix the first 3 letters of the filename with sPrefix.
71436>>>>>>>>>    Function FileTempFileName String sPathName String sPrefix Returns String
71438>>>>>>>>>        Address aTempFileName
71438>>>>>>>>>        String sPathNameTmp sPrefixTmp sTempFileName
71438>>>>>>>>>        Boolean bOk
71438>>>>>>>>>        Set pbError to False
71439>>>>>>>>>        If (num_arguments > 0) Begin
71441>>>>>>>>>            Move sPathName to sPathNameTmp
71442>>>>>>>>>        End
71442>>>>>>>>>>
71442>>>>>>>>>        Else Begin
71443>>>>>>>>>            Move "" to sPathNameTmp
71444>>>>>>>>>        End
71444>>>>>>>>>>
71444>>>>>>>>>        If (num_arguments > 1) Begin
71446>>>>>>>>>            Move sPrefix to sPrefixTmp
71447>>>>>>>>>        End
71447>>>>>>>>>>
71447>>>>>>>>>        Else Begin
71448>>>>>>>>>            Move "" to sPrefixTmp
71449>>>>>>>>>        End
71449>>>>>>>>>>
71449>>>>>>>>>        Move (Trim(sPathNameTmp)) to sPathNameTmp
71450>>>>>>>>>        If (sPathNameTmp = "") Begin
71452>>>>>>>>>            Get FileTempPath to sPathNameTmp
71453>>>>>>>>>            If (sPathNameTmp = "") Begin
71455>>>>>>>>>                Move "." to sPathNameTmp
71456>>>>>>>>>            End
71456>>>>>>>>>>
71456>>>>>>>>>        End
71456>>>>>>>>>>
71456>>>>>>>>>        Move (ZeroString(MAX_PATH))     To sTempFilename
71457>>>>>>>>>        Move (AddressOf(sTempFileName)) To aTempFileName
71458>>>>>>>>>        Move (ToANSI(sPathNameTmp))     to sPathNameTmp
71459>>>>>>>>>        Move (ToANSI(sPrefixTmp))       To sPrefixTmp
71460>>>>>>>>>        Move (fsGetTempFileName(sPathNameTmp, sPrefixTmp, 0, aTempFileName)) to bOk
71461>>>>>>>>>        If bOk Begin
71463>>>>>>>>>            Move (ToOEM(sTempFileName)) To sTempFileName
71464>>>>>>>>>            Move (CString(sTempFileName)) to sTempFileName
71465>>>>>>>>>        End
71465>>>>>>>>>>
71465>>>>>>>>>        Function_Return sTempFileName
71466>>>>>>>>>    End_Function
71467>>>>>>>>>
71467>>>>>>>>>    // Creates a new directory.
71467>>>>>>>>>    // Returns True if succeeds.
71467>>>>>>>>>    Function DirectoryCreate String sDirectoryName Returns Boolean
71469>>>>>>>>>        Boolean bFound bOk
71469>>>>>>>>>        Integer iErrorNumber
71469>>>>>>>>>        Move False to bOk
71470>>>>>>>>>        Set pbError to False
71471>>>>>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
71472>>>>>>>>>        If (not(bFound)) Begin
71474>>>>>>>>>            Move (toAnsi(sDirectoryName)) To sDirectoryname
71475>>>>>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
71476>>>>>>>>>            Move (fsCreateDirectory(sDirectoryname, FNULL)) to bOk
71477>>>>>>>>>            If (bOk = False) Begin           // Could not create
71479>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
71480>>>>>>>>>                If iErrorNumber Begin
71482>>>>>>>>>                    Send DoShowError iErrorNumber ("Tried to create directory: "+sDirectoryname)
71483>>>>>>>>>                End
71483>>>>>>>>>>
71483>>>>>>>>>            End
71483>>>>>>>>>>
71483>>>>>>>>>        End
71483>>>>>>>>>>
71483>>>>>>>>>        Function_Return bOk
71484>>>>>>>>>    End_Function
71485>>>>>>>>>
71485>>>>>>>>>    // Removes an existing empty directory.
71485>>>>>>>>>    // Returns True if succeeds.
71485>>>>>>>>>    Function DirectoryRemove String sDirectoryName Returns Boolean
71487>>>>>>>>>        Boolean bFound bOk
71487>>>>>>>>>        Integer iErrorNumber
71487>>>>>>>>>        Move False to bOk
71488>>>>>>>>>        Set pbError to False
71489>>>>>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
71490>>>>>>>>>        If bFound Begin
71492>>>>>>>>>            Move (toAnsi(sDirectoryName)) To sDirectoryname
71493>>>>>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
71494>>>>>>>>>            Move (fsRemoveDirectory(sDirectoryname)) to bOk
71495>>>>>>>>>            If (bOk = False) Begin           // Could not delete
71497>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
71498>>>>>>>>>                If iErrorNumber Begin
71500>>>>>>>>>                    Send DoShowError iErrorNumber ("Tried to remove directory: "+sDirectoryName)
71501>>>>>>>>>                End
71501>>>>>>>>>>
71501>>>>>>>>>            End
71501>>>>>>>>>>
71501>>>>>>>>>        End
71501>>>>>>>>>>
71501>>>>>>>>>        Function_Return bOk
71502>>>>>>>>>    End_Function
71503>>>>>>>>>
71503>>>>>>>>>    // Removes a directory and all its contents.
71503>>>>>>>>>    // Returns true on succes.
71503>>>>>>>>>    Function DirectoryRemoveRecursive String sDirectoryName Returns Boolean
71505>>>>>>>>>        tsSearchResult[] alsSearchResults
71505>>>>>>>>>        tsSearchResult[] alsSearchResults
71506>>>>>>>>>        Integer iIndex
71506>>>>>>>>>        Boolean bOk
71506>>>>>>>>>
71506>>>>>>>>>        If (Right(sDirectoryName, 1) = "\") Begin
71508>>>>>>>>>            Move (Left(sDirectoryName, Length(sDirectoryName) - 1)) to sDirectoryName
71509>>>>>>>>>        End
71509>>>>>>>>>>
71509>>>>>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_DIRECTORIES_ONLY to alsSearchResults
71510>>>>>>>>>        For iIndex from 2 to (SizeOfArray(alsSearchResults) - 1)
71516>>>>>>>>>>
71516>>>>>>>>>            Get DirectoryRemoveRecursive (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
71517>>>>>>>>>            If (not(bOk)) Begin
71519>>>>>>>>>                Function_Return False
71520>>>>>>>>>            End
71520>>>>>>>>>>
71520>>>>>>>>>        Loop
71521>>>>>>>>>>
71521>>>>>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_FILES_ONLY to alsSearchResults
71522>>>>>>>>>        For iIndex from 0 to (SizeOfArray(alsSearchResults) - 1)
71528>>>>>>>>>>
71528>>>>>>>>>            Get FileDelete (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
71529>>>>>>>>>            If (not(bOk)) Begin
71531>>>>>>>>>                Function_Return False
71532>>>>>>>>>            End
71532>>>>>>>>>>
71532>>>>>>>>>        Loop
71533>>>>>>>>>>
71533>>>>>>>>>        Get DirectoryRemove sDirectoryName to bOk
71534>>>>>>>>>        Function_Return bOk
71535>>>>>>>>>    End_Function
71536>>>>>>>>>
71536>>>>>>>>>    // Converts the filetime in UTC and returns a datetime in local time.
71536>>>>>>>>>    // private
71536>>>>>>>>>    Function ConvertFileTimeToLocalDateTime UBigInt ubiFileTime Returns DateTime
71538>>>>>>>>>        Boolean bOk
71538>>>>>>>>>        UBigInt ubiZero
71538>>>>>>>>>        structSystemTime lsSystemTime lsLocalTime
71538>>>>>>>>>        structSystemTime lsSystemTime lsLocalTime
71538>>>>>>>>>        DateTime dtLocalTime
71538>>>>>>>>>        Move 0 to lsSystemTime.wDay
71539>>>>>>>>>        Move 0 to lsLocalTime.wDay
71540>>>>>>>>>        Move 0 to ubiZero
71541>>>>>>>>>        If (ubiFileTime <> ubiZero) Begin
71543>>>>>>>>>            Move (fsFileTimeToSystemTime(AddressOf(ubiFileTime), AddressOf(lsSystemTime))) to bOk
71544>>>>>>>>>            If bOk Begin
71546>>>>>>>>>                Move (fsSystemTimeToTzSpecificLocalTime(FNULL, AddressOf(lsSystemTime), AddressOf(lsLocalTime))) to bOk
71547>>>>>>>>>                If bOk Begin
71549>>>>>>>>>                    Move (DateSetYear(dtLocalTime, lsLocalTime.wYear)) to dtLocalTime
71550>>>>>>>>>                    Move (DateSetMonth(dtLocalTime, lsLocalTime.wMonth)) to dtLocalTime
71551>>>>>>>>>                    Move (DateSetDay(dtLocalTime, lsLocalTime.wDay)) to dtLocalTime
71552>>>>>>>>>                    Move (DateSetHour(dtLocalTime, lsLocalTime.wHour)) to dtLocalTime
71553>>>>>>>>>                    Move (DateSetMinute(dtLocalTime, lsLocalTime.wMinute)) to dtLocalTime
71554>>>>>>>>>                    Move (DateSetSecond(dtLocalTime, lsLocalTime.wSecond)) to dtLocalTime
71555>>>>>>>>>                    Move (DateSetMillisecond(dtLocalTime, lsLocalTime.wMillieseconds)) to dtLocalTime
71556>>>>>>>>>                End
71556>>>>>>>>>>
71556>>>>>>>>>            End
71556>>>>>>>>>>
71556>>>>>>>>>        End
71556>>>>>>>>>>
71556>>>>>>>>>        Function_Return dtLocalTime
71557>>>>>>>>>    End_Function
71558>>>>>>>>>
71558>>>>>>>>>    // Returns the filename with full path where the casing is preserved from windows.
71558>>>>>>>>>    Function FilePreservedFilename String sFilename Returns String
71560>>>>>>>>>        Integer iNumOfDirectories iCurrentDirectory
71560>>>>>>>>>        String sPreservedFilename sCurDir sSearchName
71560>>>>>>>>>        tsSearchResult[] lsSearchResult
71560>>>>>>>>>        tsSearchResult[] lsSearchResult
71561>>>>>>>>>
71561>>>>>>>>>        Get CountOfFields sFilename "\" to iNumOfDirectories
71562>>>>>>>>>        For iCurrentDirectory from 1 to (iNumOfDirectories - 1)
71568>>>>>>>>>>
71568>>>>>>>>>            Get FieldAtIndex sFilename iCurrentDirectory "\" to sCurDir
71569>>>>>>>>>            If (sCurDir <> "") Begin
71571>>>>>>>>>                If (Right(sCurDir, 1) <> ":") Begin
71573>>>>>>>>>                    Move (sPreservedFilename + sCurDir) to sSearchName
71574>>>>>>>>>                    Get FileSearch sSearchName DIRMODE_DIRECTORIES_ONLY to lsSearchResult
71575>>>>>>>>>                    If (SizeOfArray(lsSearchResult) > 0) Begin
71577>>>>>>>>>                        Move (sPreservedFilename + lsSearchResult[0].sFilename + "\") to sPreservedFilename
71578>>>>>>>>>                    End
71578>>>>>>>>>>
71578>>>>>>>>>                    Else Begin
71579>>>>>>>>>                        Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
71580>>>>>>>>>                    End
71580>>>>>>>>>>
71580>>>>>>>>>                End
71580>>>>>>>>>>
71580>>>>>>>>>                Else Begin
71581>>>>>>>>>                    Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
71582>>>>>>>>>                End
71582>>>>>>>>>>
71582>>>>>>>>>            End
71582>>>>>>>>>>
71582>>>>>>>>>            Else Begin
71583>>>>>>>>>                Move (sPreservedFilename + "\") to sPreservedFilename
71584>>>>>>>>>            End
71584>>>>>>>>>>
71584>>>>>>>>>        Loop
71585>>>>>>>>>>
71585>>>>>>>>>        Get FileSearch sFilename DIRMODE_FILES_AND_DIRECTORIES to lsSearchResult
71586>>>>>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
71588>>>>>>>>>            Move (sPreservedFilename + lsSearchResult[0].sFilename) to sPreservedFilename
71589>>>>>>>>>        End
71589>>>>>>>>>>
71589>>>>>>>>>        Else Begin
71590>>>>>>>>>            Function_Return ""
71591>>>>>>>>>        End
71591>>>>>>>>>>
71591>>>>>>>>>        Function_Return sPreservedFilename
71592>>>>>>>>>    End_Function
71593>>>>>>>>>
71593>>>>>>>>>    // Returns the number of fields present in a string of fields seperated by a delimiter.
71593>>>>>>>>>    // If sDelimiter is not applied the ";" will be used.
71593>>>>>>>>>    Function CountOfFields String sFields String sDelimiter Returns Integer
71595>>>>>>>>>        Integer iChar icChar iField
71595>>>>>>>>>        String sDlm
71595>>>>>>>>>        If (sFields ="") Begin
71597>>>>>>>>>            Function_Return 0
71598>>>>>>>>>        End
71598>>>>>>>>>>
71598>>>>>>>>>        If (num_arguments > 1) Begin
71600>>>>>>>>>            Move sDelimiter to sDlm
71601>>>>>>>>>        End
71601>>>>>>>>>>
71601>>>>>>>>>        Else Begin
71602>>>>>>>>>            Move ";" to sDlm
71603>>>>>>>>>        End
71603>>>>>>>>>>
71603>>>>>>>>>        Move (Length(sFields) -1) to icChar
71604>>>>>>>>>        For iChar from 1 to icChar
71610>>>>>>>>>>
71610>>>>>>>>>            If (Mid(sFields, 1, iChar) = sDlm) Begin
71612>>>>>>>>>                Increment iField
71613>>>>>>>>>            End
71613>>>>>>>>>>
71613>>>>>>>>>        Loop
71614>>>>>>>>>>
71614>>>>>>>>>        Function_Return (iField +1)
71615>>>>>>>>>    End_Function
71616>>>>>>>>>
71616>>>>>>>>>    // Returns a field from a string containing multiple delimited fields.
71616>>>>>>>>>    // Index is 1-based.
71616>>>>>>>>>    Function FieldAtIndex String sFields Integer iIndex String sDelimiter Returns String
71618>>>>>>>>>        Integer iField iPos
71618>>>>>>>>>        String sField sDlm
71618>>>>>>>>>        If (num_arguments > 2) Begin
71620>>>>>>>>>            Move sDelimiter to sDlm
71621>>>>>>>>>        End
71621>>>>>>>>>>
71621>>>>>>>>>        Else Begin
71622>>>>>>>>>            Move ";" to sDlm
71623>>>>>>>>>        End
71623>>>>>>>>>>
71623>>>>>>>>>        Move (sFields + sDlm) to sFields
71624>>>>>>>>>        For iField from 1 to iIndex
71630>>>>>>>>>>
71630>>>>>>>>>            Move (Pos(sDlm, sFields)) to iPos
71631>>>>>>>>>            If iPos Begin
71633>>>>>>>>>                Move (Left(sFields, iPos -1)) to sField
71634>>>>>>>>>                Move (Right(sFields, Length(sFields) -iPos)) to sFields
71635>>>>>>>>>            End
71635>>>>>>>>>>
71635>>>>>>>>>            Else Begin
71636>>>>>>>>>                Function_Return ""
71637>>>>>>>>>            End
71637>>>>>>>>>>
71637>>>>>>>>>        Loop
71638>>>>>>>>>>
71638>>>>>>>>>        Function_Return sField
71639>>>>>>>>>    End_Function
71640>>>>>>>>>
71640>>>>>>>>>    // Removes the file extention from the sFile string and returns the extention including "."
71640>>>>>>>>>    // Example sFile = "x:\text.txt". The function returns ".txt" and sFile = "x:\text".
71640>>>>>>>>>    Function RemoveExtention String ByRef sFilename Returns String
71642>>>>>>>>>        String sExtention
71642>>>>>>>>>        Integer iLengthExtention
71642>>>>>>>>>        Get FileExtention sFilename to sExtention
71643>>>>>>>>>        Move (Length(sExtention)) to iLengthExtention
71644>>>>>>>>>        If (iLengthExtention > 0) Begin
71646>>>>>>>>>            Move (Left(sFilename, (Length(sFilename) - iLengthExtention - 1))) to sFilename
71647>>>>>>>>>        End
71647>>>>>>>>>>
71647>>>>>>>>>        Function_Return sExtention
71648>>>>>>>>>    End_Function
71649>>>>>>>>>
71649>>>>>>>>>    // Add a directory separator if it is not present.
71649>>>>>>>>>    // Example sFoldername = "x:\FolderA". The function returns "x:\FolderA\"
71649>>>>>>>>>    Function AddFolderSeperator String sFolderName Returns String
71651>>>>>>>>>        String sDirSep
71651>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
71652>>>>>>>>>        Move (Trim(sFolderName)) to sFolderName
71653>>>>>>>>>        If (Right(sFolderName, 1) <> sDirSep) Begin
71655>>>>>>>>>            Move (sFolderName + sDirSep) to sFolderName
71656>>>>>>>>>        End
71656>>>>>>>>>>
71656>>>>>>>>>        Function_Return sFolderName
71657>>>>>>>>>    End_Function
71658>>>>>>>>>
71658>>>>>>>>>    // Removes a directory separator if it is present.
71658>>>>>>>>>    // Example sFoldername = "x:\FolderA\". The function returns "x:\FolderA"
71658>>>>>>>>>    Function RemoveFolderSeperator String sFolderName Returns String
71660>>>>>>>>>        String sDirSep
71660>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
71661>>>>>>>>>        Move (Trim(sFolderName)) to sFolderName
71662>>>>>>>>>        If (Right(sFolderName, 1) = sDirSep) Begin
71664>>>>>>>>>            Move (Left(sFolderName, Length(sFolderName) - 1)) to sFolderName
71665>>>>>>>>>        End
71665>>>>>>>>>>
71665>>>>>>>>>        Function_Return sFolderName
71666>>>>>>>>>    End_Function
71667>>>>>>>>>
71667>>>>>>>>>    Function FileLastWriteTime String sFileName Returns tFileTime
71669>>>>>>>>>        DWord dwAccess
71669>>>>>>>>>        DWord dwShared
71669>>>>>>>>>        DWord dwCreate
71669>>>>>>>>>        Handle hFile
71669>>>>>>>>>        Integer iRetval iErrorNumber
71669>>>>>>>>>        tFileTime ftLastWrite
71669>>>>>>>>>        tFileTime ftLastWrite
71669>>>>>>>>>        //
71669>>>>>>>>>        Append sFilename (Character(0)) (Character(0))
71671>>>>>>>>>        Move (GENERIC_READ iOr GENERIC_WRITE) To dwAccess
71672>>>>>>>>>        Move FILE_SHARE_RANDOM   To dwShared
71673>>>>>>>>>        Move OPEN_EXISTING       To dwCreate
71674>>>>>>>>>
71674>>>>>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) To hFile
71675>>>>>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
71677>>>>>>>>>            Move (fsGetLastError()) To iErrorNumber
71678>>>>>>>>>            If iErrorNumber Begin
71680>>>>>>>>>                Send DoShowError iErrorNumber sFileName
71681>>>>>>>>>            End
71681>>>>>>>>>>
71681>>>>>>>>>            Procedure_Return
71682>>>>>>>>>        End
71682>>>>>>>>>>
71682>>>>>>>>>        Else Begin
71683>>>>>>>>>            Move 0 To ftLastWrite.dwLowDateTime
71684>>>>>>>>>            Move (fsGetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) To iRetval
71685>>>>>>>>>            If (iRetVal = 0) Begin           //Could not close
71687>>>>>>>>>                Move (fsGetLastError()) To iErrorNumber
71688>>>>>>>>>                If iErrorNumber Begin
71690>>>>>>>>>                    Send DoShowError iErrorNumber sFileName
71691>>>>>>>>>                End
71691>>>>>>>>>>
71691>>>>>>>>>            End
71691>>>>>>>>>>
71691>>>>>>>>>            Move (fsCloseHandle(hFile)) To iRetVal
71692>>>>>>>>>            If (iRetVal = 0) Begin           //Could not close
71694>>>>>>>>>                Move (fsGetLastError()) To iErrorNumber
71695>>>>>>>>>                If iErrorNumber Begin
71697>>>>>>>>>                    Send DoShowError iErrorNumber sFileName
71698>>>>>>>>>                End
71698>>>>>>>>>>
71698>>>>>>>>>            End
71698>>>>>>>>>>
71698>>>>>>>>>        End
71698>>>>>>>>>>
71698>>>>>>>>>        Function_Return ftLastWrite
71699>>>>>>>>>    End_Function
71700>>>>>>>>>
71700>>>>>>>>>    Function CurrentSystemTimeAsFileTime Returns tFileTime
71702>>>>>>>>>        Integer iRetVal
71702>>>>>>>>>        Integer iErrorNumber
71702>>>>>>>>>        String  sFileName
71702>>>>>>>>>        tFileTime ftCurrentTime
71702>>>>>>>>>        tFileTime ftCurrentTime
71702>>>>>>>>>
71702>>>>>>>>>        Move 0 to ftCurrentTime.dwLowDateTime
71703>>>>>>>>>        Move (fsGetSystemTimeAsFileTime(AddressOf(ftCurrentTime))) to iRetVal
71704>>>>>>>>>        If (iRetVal = 0) Begin
71706>>>>>>>>>            Move (fsGetLastError()) to iErrorNumber
71707>>>>>>>>>            If iErrorNumber Begin
71709>>>>>>>>>                Send DoShowError iErrorNumber sFileName
71710>>>>>>>>>            End
71710>>>>>>>>>>
71710>>>>>>>>>        End
71710>>>>>>>>>>
71710>>>>>>>>>        Function_Return ftCurrentTime
71711>>>>>>>>>    End_Function
71712>>>>>>>>>
71712>>>>>>>>>    // Nils 2018-08-30 Added this message from Akefs.pkg as we need it For the
71712>>>>>>>>>    // SourceCodeTools project
71712>>>>>>>>>    Procedure Set FileLastWriteTime String sFileName tFileTime ftLastWrite
71714>>>>>>>>>        DWord dwAccess dwShared dwCreate
71714>>>>>>>>>        Handle hFile
71714>>>>>>>>>        Integer iRetval iErrorNumber
71714>>>>>>>>>
71714>>>>>>>>>        Append sFilename (Character(0)) (Character(0))
71716>>>>>>>>>        Move (GENERIC_READ ior GENERIC_WRITE) to dwAccess
71717>>>>>>>>>        Move FILE_SHARE_RANDOM   to dwShared
71718>>>>>>>>>        Move OPEN_EXISTING       to dwCreate
71719>>>>>>>>>
71719>>>>>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) to hFile
71720>>>>>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
71722>>>>>>>>>            Move (fsGetLastError()) to iErrorNumber
71723>>>>>>>>>            If (iErrorNumber <> 0) Begin
71725>>>>>>>>>                Send DoShowError iErrorNumber sFileName
71726>>>>>>>>>            End
71726>>>>>>>>>>
71726>>>>>>>>>            Procedure_Return
71727>>>>>>>>>        End
71727>>>>>>>>>>
71727>>>>>>>>>        Else Begin
71728>>>>>>>>>            Move (fsSetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) to iRetval
71729>>>>>>>>>            If (iRetVal = 0) Begin           //Could not close
71731>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
71732>>>>>>>>>                If (iErrorNumber <> 0) Begin
71734>>>>>>>>>                    Send DoShowError iErrorNumber sFileName
71735>>>>>>>>>                End
71735>>>>>>>>>>
71735>>>>>>>>>            End
71735>>>>>>>>>>
71735>>>>>>>>>            Move (fsCloseHandle(hFile)) to iRetVal
71736>>>>>>>>>            If (iRetVal = 0) Begin           //Could not close
71738>>>>>>>>>                Move (fsGetLastError()) to iErrorNumber
71739>>>>>>>>>                If (iErrorNumber <> 0) Begin
71741>>>>>>>>>                    Send DoShowError iErrorNumber sFileName
71742>>>>>>>>>                End
71742>>>>>>>>>>
71742>>>>>>>>>            End
71742>>>>>>>>>>
71742>>>>>>>>>        End
71742>>>>>>>>>>
71742>>>>>>>>>    End_Procedure
71743>>>>>>>>>
71743>>>>>>>>>    // Fetch the error message from the system message table using the default language.
71743>>>>>>>>>    // If not in unicode then the variable sAppendErrorText is in ANSI
71743>>>>>>>>>    Procedure DoShowError Integer iErrorNumber String sAppendErrorText
71745>>>>>>>>>        Pointer lpOut
71745>>>>>>>>>        Integer iRetChars iRetVal
71745>>>>>>>>>        String sMsg
71745>>>>>>>>>        Boolean bOk
71745>>>>>>>>>
71745>>>>>>>>>        Move 0 to lpOut
71746>>>>>>>>>        Move (fsFormatMessage((FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS+FORMAT_MESSAGE_ALLOCATE_BUFFER), FNULL, iErrorNumber, FNULL, AddressOf(lpOut), 0, FNULL)) to iRetChars
71747>>>>>>>>>        If (iRetChars > 0) Begin
71749>>>>>>>>>            Move (ZeroString(iRetChars)) to sMsg
71750>>>>>>>>>            Move (MemCopy(AddressOf(sMsg), lpOut, iRetChars)) to bOk
71751>>>>>>>>>            Move (fsLocalFree(lpOut)) to iRetVal
71752>>>>>>>>>            Move (ToOEM(sMsg)) To sMsg
71753>>>>>>>>>            Move (ToOEM(sAppendErrorText)) To sAppendErrorText
71754>>>>>>>>>            If (num_arguments > 0) Begin
71756>>>>>>>>>                Move (Trim(sAppendErrorText)) to sAppendErrorText
71757>>>>>>>>>                If (sAppendErrorText <> "") Begin
71759>>>>>>>>>                    Append sMsg "\n" sAppendErrorText
71761>>>>>>>>>                End
71761>>>>>>>>>>
71761>>>>>>>>>            End
71761>>>>>>>>>>
71761>>>>>>>>>            Send warning_box sMsg
71762>>>>>>>>>        End
71762>>>>>>>>>>
71762>>>>>>>>>    End_Procedure
71763>>>>>>>>>
71763>>>>>>>>>    // Shows a warning message to user with OK button and a exclamation icon.
71763>>>>>>>>>    // private
71763>>>>>>>>>    Procedure Warning_Box String sWngMsg
71765>>>>>>>>>        Integer iVoid
71765>>>>>>>>>        Boolean bSendVdfError
71765>>>>>>>>>        Set pbError to True
71766>>>>>>>>>        Get pbErrorAsVDFError to bSendVdfError
71767>>>>>>>>>        If (bSendVdfError = False) Begin
71769>>>>>>>>>            Get Message_Box sWngMsg "Filesystem Error" MB_OK MB_ICONEXCLAMATION to iVoid
71770>>>>>>>>>        End
71770>>>>>>>>>>
71770>>>>>>>>>        Else Begin
71771>>>>>>>>>            Error DFERR_PROGRAM sWngMsg
71772>>>>>>>>>>
71772>>>>>>>>>        End
71772>>>>>>>>>>
71772>>>>>>>>>    End_Procedure
71773>>>>>>>>>
71773>>>>>>>>>    // Fetch the filename from the list of filenames associated with a filenumber.
71773>>>>>>>>>    // This function is used For reporting filenames during an error.
71773>>>>>>>>>    // private
71773>>>>>>>>>    Function FileErrorText Integer iFilenumber Returns String
71775>>>>>>>>>        String sErrorText
71775>>>>>>>>>        structFile[] lsFile
71775>>>>>>>>>        structFile[] lsFile
71776>>>>>>>>>        Get plsFile to lsFile
71777>>>>>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
71779>>>>>>>>>            Move ("File: "+lsFile[iFilenumber].sFilename) to sErrorText
71780>>>>>>>>>        End
71780>>>>>>>>>>
71780>>>>>>>>>        Function_Return sErrorText
71781>>>>>>>>>    End_Function
71782>>>>>>>>>
71782>>>>>>>>>End_Class
71783>>>>>>>
71783>>>>>>>Enum_List
71783>>>>>>>    Define cx_RegKeyAlreadyExist
71783>>>>>>>    Define cx_RegKeyCreated
71783>>>>>>>    Define cx_RegkeyFailed
71783>>>>>>>    Define cx_RegKeyVDFKeyDoesNotExist
71783>>>>>>>    Define cx_InstalledOkVdfUnder16
71783>>>>>>>End_Enum_List
71783>>>>>>>
71783>>>>>>>Struct tWorkspace
71783>>>>>>>    String sWorkspace
71783>>>>>>>    String sWorkspaceFull    
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tRefactorCheckbox
71783>>>>>>>    Handle hObject
71783>>>>>>>    Boolean bChecked
71783>>>>>>>    Boolean bReportFunction
71783>>>>>>>    Integer iRefactorFunction
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tCounters
71783>>>>>>>    Integer iProjectObjectStructure
71783>>>>>>>    //
71783>>>>>>>    Integer iChangeCurrent_ObjectToSelf
71783>>>>>>>    Integer iChangeDfTrueDfFalse
71783>>>>>>>    Integer iChangeFoundLoopIndicator
71783>>>>>>>    Integer iChangeFoundAndFindErrIndicators
71783>>>>>>>    Integer iChangeGetAddress
71783>>>>>>>    Integer iChangeIndicateFoundToMoveTrueToFound
71783>>>>>>>    Integer iChangeIndicatorRepeatToWhile
71783>>>>>>>    Integer iChangeIndicatorToIfBegin
71783>>>>>>>    Integer iChangeIndicatorToMoveStateToVariable
71783>>>>>>>    Integer iChangeInsertCommandToFunction
71783>>>>>>>    Integer iChangeInToContains
71783>>>>>>>    Integer iChangeLegacyOperators
71783>>>>>>>    Integer iChangeLengthCommandToFunction
71783>>>>>>>    Integer iChangePosCommandToFunction
71783>>>>>>>    Integer iChangeReplaceCommandToFunction
71783>>>>>>>    Integer iChangeSysdate4
71783>>>>>>>    Integer iChangeTrimCommandToFunction
71783>>>>>>>    Integer iChangeZeroStringCommandToFunction
71783>>>>>>>    Integer iChangeUntilAndWhileIndicators
71783>>>>>>>    Integer iChangeUClassToRefClass
71783>>>>>>>    
71783>>>>>>>    Integer iReplaceCalcWithMoveStatement
71783>>>>>>>    Integer iRemoveBlankLines
71783>>>>>>>    Integer iRemoveLocalKeyWord
71783>>>>>>>    Integer iRemovePropertyPrivate
71783>>>>>>>    Integer iRemovePropertyPublic
71783>>>>>>>    Integer iRemoveEndComments
71783>>>>>>>    Integer iRemoveOldStudioMarkers
71783>>>>>>>    Integer iRemoveSansSerif
71783>>>>>>>    Integer iRemoveStudioGeneratedComments
71783>>>>>>>    Integer iRemoveTrailingSpaces
71783>>>>>>>    Integer iSplitInlineIfElseLine
71783>>>>>>>
71783>>>>>>>    // Editor functions
71783>>>>>>>    Integer iRefactorDropSelf
71783>>>>>>>    Integer iRefactorNormalizeCase
71783>>>>>>>    Integer iRefactorReIndent
71783>>>>>>>    
71783>>>>>>>    // Separate class and function
71783>>>>>>>    Integer iRemoveUnusedLocals
71783>>>>>>>    
71783>>>>>>>    // Report functions
71783>>>>>>>    Integer iCountNumberOfLines
71783>>>>>>>    Integer iCountNumberOfFiles
71783>>>>>>>    Integer iUnusedSourceFiles    
71783>>>>>>>    
71783>>>>>>>    // Asolvi functions
71783>>>>>>>    Integer iChangewsDoTranslateTo_
71783>>>>>>>    Integer iChangeLegacyShadow_State
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tRefactorSettings
71783>>>>>>>    Integer eSplitBy            // The selected "Split By" radio button
71783>>>>>>>    Integer iTabSize
71783>>>>>>>    Integer iMaxBlankLines
71783>>>>>>>    String  sFileFilter
71783>>>>>>>    String[] asFolderNames   
71783>>>>>>>End_Struct                   
71783>>>>>>>
71783>>>>>>>Struct tRefactorActions
71783>>>>>>>    Boolean bProjectObjectStructure
71783>>>>>>>    //
71783>>>>>>>    Boolean bChangeCurrent_ObjectToSelf
71783>>>>>>>    Boolean bChangeDfTrueDfFalse
71783>>>>>>>    Boolean bChangeFoundLoopIndicator
71783>>>>>>>    Boolean bChangeFoundAndFindErrIndicators
71783>>>>>>>    Boolean bChangeGetAddress
71783>>>>>>>    Boolean bChangeIndicateFoundToMoveTrueToFound
71783>>>>>>>    Boolean bChangeIndicatorRepeatToWhile
71783>>>>>>>    Boolean bChangeIndicatorToIfBegin
71783>>>>>>>    Boolean bChangeIndicatorToMoveStateToVariable
71783>>>>>>>    Boolean bChangeInsertCommandToFunction
71783>>>>>>>    Boolean bChangeInToContains
71783>>>>>>>    Boolean bChangeLegacyOperators
71783>>>>>>>    Boolean bChangeLengthCommandToFunction
71783>>>>>>>    Boolean bChangePosCommandToFunction
71783>>>>>>>    Boolean bChangeReplaceCommandToFunction
71783>>>>>>>    Boolean bChangeSysdate4
71783>>>>>>>    Boolean bChangeTrimCommandToFunction
71783>>>>>>>    Boolean bChangeZeroStringCommandToFunction
71783>>>>>>>    Boolean bChangeUntilAndWhileIndicators
71783>>>>>>>    Boolean bChangeUClassToRefClass
71783>>>>>>>    
71783>>>>>>>    // Editor functions
71783>>>>>>>    Boolean bRefactorDropSelf
71783>>>>>>>    Boolean bRefactorNormalizeCase
71783>>>>>>>    Boolean bRefactorReIndent
71783>>>>>>>    
71783>>>>>>>    Boolean bReplaceCalcWithMoveStatement
71783>>>>>>>    Boolean bRemoveBlankLines
71783>>>>>>>    Boolean bRemoveLocalKeyWord
71783>>>>>>>    Boolean bRemovePropertyPrivate
71783>>>>>>>    Boolean bRemovePropertyPublic
71783>>>>>>>    Boolean bRemoveEndComments
71783>>>>>>>    Boolean bRemoveOldStudioMarkers
71783>>>>>>>    Boolean bRemoveSansSerif
71783>>>>>>>    Boolean bRemoveStudioGeneratedComments
71783>>>>>>>    Boolean bRemoveTrailingSpaces
71783>>>>>>>
71783>>>>>>>    // Separate class and function
71783>>>>>>>    Boolean bRemoveUnusedLocals
71783>>>>>>>    
71783>>>>>>>    Boolean bSplitInlineIfElseLine
71783>>>>>>>//    Boolean bCompareOperators
71783>>>>>>>    
71783>>>>>>>    // Report functions
71783>>>>>>>    Boolean bCountNumberOfLines
71783>>>>>>>    Boolean bUnusedSourceFiles    
71783>>>>>>>    
71783>>>>>>>    // Asolvi Functions                
71783>>>>>>>    Boolean bChangewsDoTranslateTo_
71783>>>>>>>    Boolean bChangeLegacyShadow_State
71783>>>>>>>    
71783>>>>>>>    tCounters         Counters   
71783>>>>>>>    tCounters         Counters   
71783>>>>>>>    tRefactorSettings Settings
71783>>>>>>>    tRefactorSettings Settings
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tParseObject
71783>>>>>>>    String sObject
71783>>>>>>>    String sObjectLabel  // short name
71783>>>>>>>    String sClass
71783>>>>>>>    Handle pElement
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tCJComboBoxContent
71783>>>>>>>    String sText
71783>>>>>>>    Integer eTheme
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tBackupFiles
71783>>>>>>>    String sFileName
71783>>>>>>>    String sPath
71783>>>>>>>    DateTime dtFileDate
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>Struct tCodeComponents
71783>>>>>>>    String sIndentation
71783>>>>>>>    String sCode   
71783>>>>>>>    String sOfStatement   
71783>>>>>>>    String sToStatement
71783>>>>>>>    String sRightComment 
71783>>>>>>>    Boolean bHasEndSemiColon
71783>>>>>>>End_Struct 
71783>>>>>>>
71783>>>>>>>Struct tBooleanIndicator
71783>>>>>>>    Boolean bHasBracket  
71783>>>>>>>    Boolean bHasNot
71783>>>>>>>    String sExpression
71783>>>>>>>    String sCode
71783>>>>>>>End_Struct
71783>>>>>>>
71783>>>>>>>    Define clGreenGrey              for (RGB(64, 84, 93))
71783>>>>>>>    Define clGreenGreyLight         for (RGB(7, 117, 104))
71783>>>>>>>Define clDarkGreen                  for (RGB(49, 60, 83))
71783>>>>>>>
71783>>>>>>>Define CPC_OpenFile                 for 1 // perfcounter on open file
71783>>>>>>>Define CS_Settings                  for "Settings"
71783>>>>>>>Define CS_StarZenSourceExplorer     for "StarZenSourceExplorer"
71783>>>>>>>Define CS_FileCompareProgram        for "FileCompareProgram"
71783>>>>>>>Define CS_ToolbarIconSize           for "ToolbarIconSize"
71783>>>>>>>Define CS_GridRowBackgroundColor    for "GridRowBackgroundColor"
71783>>>>>>>Define CS_MaxBlankLineSize          for "MaxBlankLineSize"
71783>>>>>>>Define CS_SplitByPreference         for "SplitByPreference"
71783>>>>>>>Define CS_DataFlexVersionText       for "DataFlex Version:"
71783>>>>>>>Define CS_SelectWorkspaceText       for "Select Workspace:"
71783>>>>>>>Define CS_CurrentWorkspaceText      for "Current Workspace:"
71783>>>>>>>Define CS_WorkspacesKey             for "Workspaces"
71783>>>>>>>Define CS_WorkspacePaths            for "WorkspacePaths"
71783>>>>>>>Define CS_ConfigFile                for "ConfigFile"
71783>>>>>>>Define CS_WorkspaceRecentKey        for "Recent"
71783>>>>>>>Define CS_PropertiesKeyWord         for "Properties"
71783>>>>>>>Define CS_ThemeKeyWord              for "Theme"
71783>>>>>>>Define CS_VersionKeyWord            for "Version"
71783>>>>>>>Define CS_OpenWorkspace             for "Select &Workspace"
71783>>>>>>>//Define CS_OpenWorkspace             for "Open &Workspace"
71783>>>>>>>Define CS_CurrentWorkspace          for "Current &Workspace:"
71783>>>>>>>Define CS_NoActiveWorkspaceText     for ""
71783>>>>>>>Define CS_SelectWorkspaceFile       for "Select a DataFlex workspace project file (*.sws)"
71783>>>>>>>Define CS_BrowseSourceFileTxt       for "&Open File:"
71783>>>>>>>Define CS_CurrentSourceFileTxt      for "Current File:"
71783>>>>>>>Define CS_NoActiveSourceFileText    for "" 
71783>>>>>>>Define CS_NoWorkspaceSelected       for "- None"
71783>>>>>>>Define CS_WorkspaceFilterString     for "DataFlex Workspace Files (*.sws)|*.sws|Any file (*.*)|*.*"
71783>>>>>>>Define CS_OpenFileStdFilter         for "All files *.*|*.*|Programs *.src|*.src|Views *.vw|*.vw|Report Views *.rv|*.rv|Selection Lists *.sl|*.sl|Web Object *.wo|*.wo|Packages *.pkg|*.pkg"
71783>>>>>>>Define CS_SourceCodeFilters         for "DataFlex Source *.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu|*.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu"
71783>>>>>>>Define CS_SourceFileFilters         for "Programs|*.src|Views|*.vw|Dialogs|*.dg|Data Dictionaries|*.dd|Include files|*.inc|Report Views|*.rv|Selection Lists|*.sl|Web Object|*.wo|Packages|*.pkg|Business Processes|*.bp|Menus|*.mn|Header Files|*.h|Sture's Files|*.nui;*.utl|Any file|*.*"
71783>>>>>>>Define CS_CreateBackupFiles         for "CreateBackupFiles"
71783>>>>>>>Define CS_SummaryLogfileName        for "DFRefactoringLogFile.txt"
71783>>>>>>>
71783>>>>>>>Define CS_UnusedSourceLogFile       for "UnusedSourceFiles.txt"
71783>>>>>>>Define CS_CommentSymbol             for ("/"+"/")
71783>>>>>>>Define CS_ImageNameStart            for "/"
71783>>>>>>>Define CS_ImageNameEnd              for "/*"
71783>>>>>>>Define CS_StudioToolsPathStart      for "Software\Data Access Worldwide\DataFlex Tools\"
71783>>>>>>>Define CS_StudioToolsPathEnd        for "\Studio\Preferences\File Extensions"
71783>>>>>>>Define CS_StudioCodeEditorPath      for "\Studio\Code-Editor"
71783>>>>>>>Define CS_StudioFontName            for "FontName"
71783>>>>>>>Define CS_StudioFontSize            for "FontSize"
71783>>>>>>>Define CS_StudioExpandTabs          for "ExpandTabs"
71783>>>>>>>Define CS_StudioIndentStyle         for "IndentStyle"
71783>>>>>>>Define CS_StudioTabSize             for "TabSize"
71783>>>>>>>Define CS_VdfExtensionsKey          for "VdfExtensions"
71783>>>>>>>Define CS_StudioEditorSettingsStart for "DataFlex Studio"
71783>>>>>>>Define CS_StudioEditorSettingsEnd   for "Code Editor Settings"
71783>>>>>>>Define CS_StudioEditorSettingsExtra for "(Will be applied when indenting code)"
71783>>>>>>>Define CS_IdleText                  for "Idle..."
71783>>>>>>>Define CS_WorkingText               for "Working..."
71783>>>>>>>Define CS_ReadyText                 for "Ready!"
71783>>>>>>>
71783>>>>>>>Define CS_Default_Dialog_Caption    for "Select a source file"
71783>>>>>>>Define CS_Folder_Dialog_Caption     for "Select a Filename - Only the foldername will be returned"
71783>>>>>>>Define CS_Default_Filter_String     for "All Files *.*|*.*|Programs *.src|*.src|Views *.vw|*.vw|Report Views *.rv|*.rv|Selection Lists *.sl|*.sl|Web Object *.wo|*.wo|Packages *.pkg|*.pkg"
71783>>>>>>>Define CS_Folder_Filter_String      for "All files|*.*"
71783>>>>>>>
71783>>>>>>>Define CS_BackupFolder              for "DFRefactor Backup"
71783>>>>>>>Define CS_NoFolderList              for (".|..|.svn|.git|.hg|apphtml|data|bitmaps|help|idesrc|programs|.cab|install")
71783>>>>>>>//Define CS_NoFolderList              for (".|..|.svn|.git|.hg|apphtml|data|bitmaps|help|idesrc|programs|.cab|install" + "|" + CS_BackupFolder)
71783>>>>>>>Define CS_DefaultSourceFolders      for "appsrc|ddsrc|libraries|pkg"
71783>>>>>>>Define CS_LF                        for (Character(10))
71783>>>>>>>Define CS_CR                        for (Character(13))
71783>>>>>>>Define CS_CRLF                      for (Character(13) + Character(10))
71783>>>>>>>Define CS_DirSeparator              for (SysConf(SYSCONF_DIR_SEPARATOR))
71783>>>>>>>
71783>>>>>>>Define CI_EOL                       for 2048
71783>>>>>>>Define CI_SplitBySpaceSemiColumn    for 0
71783>>>>>>>Define CI_SplitBySemiColumn         for 1
71783>>>>>>>Define CI_SplitByBeginEnd           for 2
71783>>>>>>>
71783>>>>>>>// Note: the "Visual" will automatically be replace if a more recent DF version is used.
71783>>>>>>>Define CS_StudioPath                for "Software\Data Access Worldwide\Visual DataFlex Tools\"
71783>>>>>>>Define CS_StudioPathEnd             for  "\Studio\Preferences\File Extensions"
71783>>>>>>>// Running cleanmarkers on web files does break stuff badly
71783>>>>>>>//Define CS_VDFAndWebExt              for "*.src;*.vw;*.sl;*.dg;*.rv;*.bp;*.pkg;*.wo;*.dd;*.inc;*.tpl;*.dfo;*.asp;*.asa;*.htm;*.css;*.js"
71783>>>>>>>//Define CS_HTMLExtOnly               for "*.htm;*.asp;*.css;*.js"
71783>>>>>>>//Define CS_FDTAGExt                  for "*.fd;*.tag;*.def"
71783>>>>>>>Define CS_StdExtensions             for "*.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu"
71783>>>>>>>Define CS_VDFAndTemplExt            for "*.src;*.vw;*.sl;*.dg;*.rv;*.bp;*.pkg;*.wo;*.dd;*.inc;*.dfo;*.tpl"
71783>>>>>>>Define CS_DDDEFExt                  for "*.dd"
71783>>>>>>>Define CS_PkgIncExt                 for "*.pkg;*.inc;*.mac"
71783>>>>>>>Define CS_SrcPkgExt                 for "*.src;*.pkg"
71783>>>>>>>Define CS_AllExt                    for "*.*"
71783>>>>>>>Define CS_VdfExtensionsKey          for "VdfExtensions"
71783>>>>>>>
71783>>>>>>>Define CS_ProjectObjectStructure    for "Project Object Structure"
71783>>>>>>>Define CS_RegisterAllObjects        for "Register all objects"
71783>>>>>>>Define CS_RegisterObject            for "Register_Object "
71783>>>>>>>
71783>>>>>>>Define CS_DFCOMProxyClasses         for "DataFlex COM proxy classes generated from"
71783>>>>>>>
71783>>>>>>>// Refactor Testing program:
71783>>>>>>>Define CS_Compiler       for "DFComp.exe"
71783>>>>>>>Define CS_TestProgram    for "CompiledRefactoredCode.src"
71783>>>>>>>Define CS_TestErrFile    for "CompiledRefactoredCode.err"
71783>>>>>>>Define CS_DFUnitTest     for "DFUnit_TestRunner"
71783>>>>>>>Define CS_CompOptions    for "-e3fv2i0"     
71783>>>>>>>Define CS_SWSFile        for "DFRefactor19.1.sws"
71783>>>>>>>Define CS_LegacyCode     for "LegacyCode.pkg"
71783>>>>>>>Define CS_RefactoredCode for "RefactoredCode.pkg"
71783>>>>>>>
71783>>>>>>>Define CS_Trim           for "Trim"    
71783>>>>>>>Define CS_Length         for "Length"  
71783>>>>>>>Define CS_Pos            for "Pos"   
71783>>>>>>>Define CS_Replace        for "Replace"
71783>>>>>>>Define CS_In             for "In" 
71783>>>>>>>Define CS_If             for "If"   
71783>>>>>>>Define CS_Else           for "Else"
71783>>>>>>>Define CS_Begin          for "Begin"
71783>>>>>>>Define CS_With           for "With" 
71783>>>>>>>Define CS_At             for "At"   
71783>>>>>>>Define CS_As             for "As"  
71783>>>>>>>Define CS_To             for "to"
71783>>>>>>>Define CS_Of             for "of"
71783>>>>>>>Define CS_ZeroString     for "ZeroString"  
71783>>>>>>>Define CS_Insert         for "Insert" 
71783>>>>>>>Define CS_Repeat         for "Repeat"
71783>>>>>>>Define CS_While          for "While" 
71783>>>>>>>Define CS_Loop           for "Loop"
71783>>>>>>>Define CS_Current_Object for "Current_Object"
71783>>>>>>>Define CS_Self           for "Self"
71783>>>>>>>Define CS_Move           for "Move"
71783>>>>>>>Define CS_Indicate       for "Indicate"  
71783>>>>>>>Define CS_Not            for "Not"
71783>>>>>>>Define CS_True           for "True"   
71783>>>>>>>Define CS_False          for "False"
71783>>>>>>>Define CS_DfTrue         for "DfTrue"
71783>>>>>>>Define CS_DfFalse        for "DfFalse"
71783>>>>>>>Define CS_Set            for "Set"
71783>>>>>>>Define CS_Get            for "Get"
71783>>>>>>>Define CS_Enabled_State  for "Enabled_State" 
71783>>>>>>>Define CS_Find           for "Find" 
71783>>>>>>>Define CS_Found          for "Found"
71783>>>>>>>Define CS_Finderr        for "Finderr"
71783>>>>>>>Define CS_Sysdate4       for "Sysdate4"
71783>>>>>>>Define CS_Constrain      for "Constrain"
71783>>>>>>>Define CS_Until          for "Until"
71783>>>>>>>Define CS_Local          for "Local"
71783>>>>>>>Define CS_GetAddress     for "GetAddress" 
71783>>>>>>>Define CS_AddressOf      for "AddressOf"
71783>>>>>>>Define CS_Function       for "Function"
71783>>>>>>>Define CS_Contains       for "contains"
71783>>>>>>>Define CS_Select         for "[Select]"
71783>>>>>>>
71783>>>>>>>// cRegex Expression Constants:
71783>>>>>>>//
71783>>>>>
71783>>>>>Class cRDCDbCJGrid is a cDbCJGrid
71784>>>>>
71784>>>>>    Procedure Construct_Object
71786>>>>>        Forward Send Construct_Object
71788>>>>>
71788>>>>>        // Set to true if an descending index is in use
71788>>>>>        Property Boolean pbDescendingIndexInUse False
71789>>>>>
71789>>>>>        // If you quickly double-right-click, or quickly click around a cCJGrid
71789>>>>>        // (using a combination of middle-clicks, right-clicks and left-clicks), the application can crash.
71789>>>>>        // To guard against this see the augmented procedure OnComRowRClick below.
71789>>>>>        Property Boolean pbRightClickProcessing False   
71790>>>>>        Property Handle phoCheckbox_Col
71791>>>>>
71791>>>>>        Set pbRestoreLayout to True
71792>>>>>        Set psLayoutSection to ((Object_Label(Parent(Self))) + "-" + (Object_Label(Self)))
71793>>>>>        Set pbUseAlternateRowBackgroundColor to True
71794>>>>>        Set pbSelectionEnable to True
71795>>>>>        Set pbShowRowFocus to True
71796>>>>>        Set pbHotTracking to True
71797>>>>>        Set pbSelectionEnable to True
71798>>>>>        Set piSelectedRowBackColor to clGreenGreyLight
71799>>>>>        Set piHighlightBackColor   to clGreenGreyLight
71800>>>>>        Set peAnchors to anAll
71801>>>>>        Set peVisualTheme to xtpReportThemeExplorer
71802>>>>>
71802>>>>>        On_Key Key_End   Send MoveToLastEnterableColumn
71803>>>>>        On_Key Key_Home  Send MoveToFirstEnterableColumn
71804>>>>>        On_Key Key_Space Send ToggleCurrentItem
71805>>>>>    End_Procedure
71806>>>>>
71806>>>>>    Procedure End_Construct_Object
71808>>>>>        Forward Send End_Construct_Object
71810>>>>>
71810>>>>>    End_Procedure
71811>>>>>
71811>>>>>    // Toggles the current row on/off (the checkbox)
71811>>>>>    Procedure ToggleCurrentItem
71813>>>>>        Boolean bChecked
71813>>>>>        Integer iCol
71813>>>>>        Handle hoCol
71813>>>>>        
71813>>>>>        Get phoCheckbox_Col to hoCol
71814>>>>>        If (hoCol <> 0) Begin
71816>>>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCol
71817>>>>>            Get ColumnObject iCol   to hoCol
71818>>>>>            Get SelectedRowValue    of hoCol to bChecked
71819>>>>>            Send UpdateCurrentValue of hoCol (not(bChecked))
71820>>>>>            Send Request_Save
71821>>>>>        End
71821>>>>>>
71821>>>>>    End_Procedure
71822>>>>>
71822>>>>>    Procedure OnCreateGridControl
71824>>>>>        Forward Send OnCreateGridControl
71826>>>>>        Send DoChangeTooltipStyle
71827>>>>>    End_Procedure
71828>>>>>
71828>>>>>    Procedure DoChangeTooltipStyle
71830>>>>>        Handle  hoTooltip
71830>>>>>        Integer iIcon iStyle iWidth
71830>>>>>        Boolean bBaloon
71830>>>>>
71830>>>>>        Get phoToolTipContext to hoTooltip
71831>>>>>
71831>>>>>        // This is the programs global tooltip control defined at desktop level.
71831>>>>>        If (ghoToolTipController > 0) Begin
71833>>>>>            Get piIcon         of ghoToolTipController    to iIcon
71834>>>>>            // The global tooltip controller allows the icons to be
71834>>>>>            // from 0-5, but the tooltip context class only allows
71834>>>>>            // the tooltip icon to be between 0-3.
71834>>>>>            If (iIcon > 3) Begin
71836>>>>>                Move xtpToolTipIconInfo                   to iIcon
71837>>>>>            End
71837>>>>>>
71837>>>>>            Get piMaxWidth     of ghoToolTipController    to iWidth
71838>>>>>            Get pbBalloonStyle of ghoToolTipController    to bBaloon
71839>>>>>            If (bBaloon = True) Begin
71841>>>>>                Move xtpToolTipBalloon                    to iStyle
71842>>>>>            End
71842>>>>>>
71842>>>>>            Else Begin
71843>>>>>                Move xtpToolTipOffice2007                 to iStyle
71844>>>>>            End
71844>>>>>>
71844>>>>>        End
71844>>>>>>
71844>>>>>        Else Begin
71845>>>>>            Move xtpToolTipIconInfo   to iIcon
71846>>>>>            Move xtpToolTipOffice2007 to iStyle
71847>>>>>            Move 400                  to iWidth
71848>>>>>        End
71848>>>>>>
71848>>>>>
71848>>>>>        Set ComStyle                    of hoTooltip to iStyle
71849>>>>>        Set ComMaxTipWidth              of hoTooltip to iWidth
71850>>>>>        // This has not been implemented by CodeJock for the Report class,
71850>>>>>        // although it is for all other classes, go figure!
71850>>>>>        //Send ComShowTitleAndDescription of hoTooltip True iIcon
71850>>>>>    End_Procedure
71851>>>>>
71851>>>>>    // When changing to new row, update the form 'No of Rows'
71851>>>>>    Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
71853>>>>>        Forward Send OnRowChanged iOldRow iNewSelectedRow
71855>>>>>        Send DoSetCurrentRow
71856>>>>>    End_Procedure
71857>>>>>
71857>>>>>    // When loading data, update the footer 'No of Items' text
71857>>>>>    Procedure Refresh Integer eMode
71859>>>>>        Forward Send Refresh eMode
71861>>>>>        Send DoSetCurrentRow
71862>>>>>    End_Procedure
71863>>>>>
71863>>>>>    Procedure DoSetCurrentRow
71865>>>>>    End_Procedure
71866>>>>>
71866>>>>>    Procedure OnComHyperlinkClick Variant llRow Variant llItem Integer llHyperlinkIndex
71868>>>>>        Handle  hoRow hoItem hoColumn
71868>>>>>        String  sLink
71868>>>>>        Integer iRow iColumn
71868>>>>>
71868>>>>>        Get phoReportRow to hoRow
71869>>>>>        Get phoReportRecordItem to hoItem
71870>>>>>
71870>>>>>        Set pvComObject of hoItem to llItem
71871>>>>>        Get ComIndex    of hoItem to iColumn
71872>>>>>        Set pvComObject of hoRow to llRow
71873>>>>>        Get ComIndex    of hoRow to iRow
71874>>>>>        Get ColumnObject iColumn to hoColumn
71875>>>>>        Get RowValue of hoColumn iRow to sLink
71876>>>>>
71876>>>>>        Send OnLinkClicked of hoColumn sLink iRow
71877>>>>>    End_Procedure
71878>>>>>
71878>>>>>    // Redisplay the grid records around the current record.
71878>>>>>    // If the  record no longer exists or no longer conforms to the current constraints
71878>>>>>    // this will redisplay the records with the same iOffset.
71878>>>>>    // If both finds fail the grid will not be updated so we need to clear it.
71878>>>>>    Procedure RefreshGrid
71880>>>>>        Send Find to (Server(Self)) GE (Ordering(Self))   // to refresh grid
71881>>>>>        If (not(Found)) Begin
71883>>>>>            If (pbDescendingIndexInUse(Self) = True or pbReverseOrdering(Self) = True) Begin
71885>>>>>                Send Find to (Server(Self)) FIRST_RECORD (Ordering(Self))
71886>>>>>            End
71886>>>>>>
71886>>>>>            Else If (pbDescendingIndexInUse(Self) = False or pbReverseOrdering(Self) = False) Begin
71889>>>>>                Send Find to (Server(Self)) LAST_RECORD (Ordering(Self))
71890>>>>>            End
71890>>>>>>
71890>>>>>        End
71890>>>>>>
71890>>>>>        If (not(Found) and IsComObjectCreated(Self)) Begin
71892>>>>>            Send ResetGrid
71893>>>>>        End
71893>>>>>>
71893>>>>>    End_Procedure
71894>>>>>
71894>>>>>    Procedure Request_Delete
71896>>>>>        Forward Send Request_Delete
71898>>>>>
71898>>>>>        // Needed to ensure list of remaining records displayed correctly
71898>>>>>        Send RefreshGrid
71899>>>>>    End_Procedure
71900>>>>>
71900>>>>>    // If you quickly double-right-click, or quickly click around a cCJGrid
71900>>>>>    // (using a combination of middle-clicks, right-clicks and left-clicks), the application can crash.
71900>>>>>    // This fixes that little problem.
71900>>>>>    Procedure OnComRowRClick Variant llRow Variant llItem
71902>>>>>        Boolean bProcessing
71902>>>>>        Get pbRightClickProcessing to bProcessing
71903>>>>>        If (not(bProcessing)) Begin
71905>>>>>            Set pbRightClickProcessing to True
71906>>>>>            Forward Send OnComRowRClick llRow llItem
71908>>>>>            Set pbRightClickProcessing to False
71909>>>>>        End
71909>>>>>>
71909>>>>>    End_Procedure
71910>>>>>
71910>>>>>End_Class
71911>>>>>
71911>>>Use cRDCDbCJGridColumn.pkg
Including file: cRDCDbCJGridColumn.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGridColumn.pkg)
71911>>>>>Use cDbCJGridColumn.pkg
71911>>>>>
71911>>>>>Class cRDCDbCJGridColumn is a cDbCJGridColumn
71912>>>>>
71912>>>>>    Procedure Construct_Object
71914>>>>>        Forward Send Construct_Object
71916>>>>>
71916>>>>>    End_Procedure
71917>>>>>
71917>>>>>    Procedure End_Construct_Object
71919>>>>>        Forward Send End_Construct_Object
71921>>>>>
71921>>>>>    End_Procedure
71922>>>>>
71922>>>>>    Function OnGetTooltip Integer iRow String sValue String sText Returns String
71924>>>>>        String sRetVal
71924>>>>>        Forward Get OnGetTooltip iRow sValue sText to sRetVal
71926>>>>>
71926>>>>>        Function_Return sRetVal
71927>>>>>    End_Function
71928>>>>>
71928>>>>>End_Class
71929>>>
71929>>>Use cSysFileDataDictionary.dd
Including file: cSysFileDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cSysFileDataDictionary.dd)
71929>>>>>Use DataDict.pkg
71929>>>>>
71929>>>>>Open SysFile
Including file: SysFile.fd    (C:\Projects\DF18\DfRefactor\DDSrc\SysFile.fd)
71931>>>>>
71931>>>>>Define CS_SplitInFileBeginEnd for "Add a Begin/End block"
71931>>>>>Define CI_SplitInFileBeginEnd for 0
71931>>>>>Define CS_SplitInFileSemiColon for "Split line space and semicolon"
71931>>>>>Define CI_SplitInFileSemiColon for 1
71931>>>>>Define CS_SplitInFileSemiColonSpace for "Split line with semicolon"
71931>>>>>Define CI_SplitInFileSemiColonSpace for 2
71931>>>>>
71931>>>>>Object oSplitInFile is a DescriptionValidationTable
71933>>>>>    Procedure Fill_List
71936>>>>>        Forward Send Fill_List
71938>>>>>        Send Add_Table_Value CI_SplitInFileBeginEnd CS_SplitInFileBeginEnd
71939>>>>>        Send Add_Table_Value CI_SplitInFileSemiColon CS_SplitInFileSemiColon
71940>>>>>        Send Add_Table_Value CI_SplitInFileSemiColonSpace CS_SplitInFileSemiColonSpace
71941>>>>>    End_Procedure
71942>>>>>End_Object
71943>>>>>
71943>>>>>Class cSysFileDataDictionary is a DataDictionary
71944>>>>>    
71944>>>>>    Procedure Construct_Object
71946>>>>>        Forward Send Construct_Object
71948>>>>>        Set Main_File to SysFile.File_Number
71949>>>>>
71949>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
71950>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
71951>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
71952>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
71953>>>>>
71953>>>>>        Set Field_Value_Table Field SysFile.SplitInFileMode to oSplitInFile
71954>>>>>
71954>>>>>    End_Procedure
71955>>>>>
71955>>>>>    Procedure Field_Defaults
71957>>>>>        Forward Send Field_Defaults
71959>>>>>        Set Field_Changed_Value Field SysFile.TabSize to 4
71960>>>>>    End_Procedure
71961>>>>>
71961>>>>>End_Class
71962>>>Use cFunctionsDataDictionary.dd
Including file: cFunctionsDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cFunctionsDataDictionary.dd)
71962>>>>>Use DataDict.pkg
71962>>>>>
71962>>>>>Open Functions
Including file: Functions.fd    (C:\Projects\DF18\DfRefactor\DDSrc\Functions.fd)
71964>>>>>Open SysFile    
71966>>>>>
71966>>>>>Define CS_Normal_Function    for "Normal function"
71966>>>>>Define CI_Normal_Function    for 0
71966>>>>>Define CS_Editor_Function    for "Editor function"
71966>>>>>Define CI_Editor_Function    for 1
71966>>>>>Define CS_Report_function    for "Report function"
71966>>>>>Define CI_Report_function    for 2
71966>>>>>Define CS_Null_Line_function for "Null line function"
71966>>>>>Define CI_Null_Line_function for 3
71966>>>>>
71966>>>>>Object oFunctionTypes is a DescriptionValidationTable
71968>>>>>    Procedure Fill_List
71971>>>>>        Forward Send Fill_List
71973>>>>>        Send Add_Table_Value CI_Normal_Function    CS_Normal_Function
71974>>>>>        Send Add_Table_Value CI_Editor_Function    CS_Editor_Function
71975>>>>>        Send Add_Table_Value CI_Report_function    CS_Report_function
71976>>>>>        Send Add_Table_Value CI_Null_Line_function CS_Null_Line_function
71977>>>>>    End_Procedure
71978>>>>>End_Object
71979>>>>>
71979>>>>>Class cFunctionsDataDictionary is a DataDictionary
71980>>>>>    
71980>>>>>    Procedure Construct_Object
71982>>>>>        Forward Send Construct_Object
71984>>>>>        Set Main_File to Functions.File_Number
71985>>>>>
71985>>>>>        Set Add_System_File to SysFile.File_Number DD_Lock_On_All
71986>>>>>
71986>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
71987>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
71988>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
71989>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
71990>>>>>
71990>>>>>        Set Field_Auto_Increment Field Functions.ID to File_Field SysFile.Functions_ID
71991>>>>>        Set Key_Field_State Field Functions.ID to True
71992>>>>>
71992>>>>>        Set Field_Class_Name Field Functions.Selected to "Checkbox"
71993>>>>>        Set Field_Checkbox_Values Field Functions.Selected to "1" "0"
71994>>>>>
71994>>>>>        Set Field_Value_Table Field Functions.Type to oFunctionTypes
71995>>>>>
71995>>>>>    End_Procedure
71996>>>>>
71996>>>>>    Procedure Field_Defaults
71998>>>>>        Forward Send Field_Defaults
72000>>>>>        Set Field_Changed_Value Field Functions.Selected to 0
72001>>>>>        Set Field_Changed_Value Field Functions.Type to 0
72002>>>>>    End_Procedure  
72003>>>>>    
72003>>>>>    Procedure Update
72005>>>>>        Integer iState
72005>>>>>        Move Functions.Selected to iState
72006>>>>>        Send AdjustSelected iState
72007>>>>>        SaveRecord SysFile
72008>>>>>    End_Procedure
72009>>>>>    
72009>>>>>    Procedure Backout
72011>>>>>        Integer iState
72011>>>>>        Move Functions.Selected to iState
72012>>>>>        Send AdjustSelected (-iState)
72013>>>>>        SaveRecord SysFile
72014>>>>>    End_Procedure  
72015>>>>>    
72015>>>>>    Procedure AdjustSelected Integer iState
72017>>>>>        Add iState to SysFile.TotFunctionsSelected
72018>>>>>    End_Procedure
72019>>>>>    
72019>>>>>    Procedure SelectAll
72021>>>>>        Send HelperSelect True
72022>>>>>    End_Procedure
72023>>>>>    
72023>>>>>    Procedure DeSelectAll
72025>>>>>        Send HelperSelect False
72026>>>>>    End_Procedure
72027>>>>>    
72027>>>>>    Procedure HelperSelect Boolean bSelect
72029>>>>>        RowID riID                                         
72029>>>>>        Boolean bFound   
72029>>>>>        Integer iItems
72029>>>>>        
72029>>>>>        Move (GetRowID(Functions.File_Number)) to riID
72030>>>>>
72030>>>>>        Move 0 to iItems
72031>>>>>        Constraint_Set 1 Clear  
72033>>>>>        Constrained_Clear eq Functions by Index.1
72036>>>>>        Constrained_Find First Functions by Index.1
72041>>>>>        While (Found)
72045>>>>>            Reread Functions
72049>>>>>                Move bSelect to Functions.Selected
72050>>>>>                SaveRecord Functions
72051>>>>>                Increment iItems
72052>>>>>            Unlock
72053>>>>>>
72053>>>>>            Constrained_Find Next
72054>>>>>        Loop
72055>>>>>>
72055>>>>>        
72055>>>>>        If (bSelect = False) Begin
72057>>>>>            Move 0 to iItems
72058>>>>>        End               
72058>>>>>>
72058>>>>>        Reread SysFile
72062>>>>>            Move iItems to SysFile.TotFunctionsSelected
72063>>>>>            SaveRecord SysFile
72064>>>>>        Unlock
72065>>>>>>
72065>>>>>            
72065>>>>>        If (not(IsSameRowID(GetRowID(Functions.File_Number), riId))) Begin
72067>>>>>            Move (FindByRowID(Functions.File_Number, riID)) to bFound
72068>>>>>        End
72068>>>>>>
72068>>>>>        
72068>>>>>    End_Procedure
72069>>>>>
72069>>>>>End_Class
72070>>>
72070>>>ACTIVATE_VIEW Activate_oMaintainFunctions FOR oMaintainFunctions
72080>>>>
72080>>>Object oMaintainFunctions is a dbView
72082>>>    Set Location to 2 4
72083>>>    Set Size to 143 532
72084>>>    Set Label To "Maintain Functions"
72085>>>    Set Border_Style to Border_Thick
72086>>>    Set pbAutoActivate to True
72087>>>    Set Maximize_Icon to True
72088>>>
72088>>>    Object oSysFile_DD is a cSysFileDataDictionary
72090>>>    End_Object
72091>>>
72091>>>    Object oFunctions_DD is a cFunctionsDataDictionary
72093>>>    End_Object 
72094>>>
72094>>>    Set Main_DD To oFunctions_DD
72095>>>    Set Server  To oFunctions_DD
72096>>>
72096>>>    Object oFunction_grd is a cRDCDbCJGrid
72098>>>        Set Size to 125 516
72099>>>        Set Location to 10 7
72100>>>        Set peAnchors to anAll
72101>>>        Set Ordering to 2
72102>>>        Set piLayoutBuild to 3
72103>>>
72103>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
72105>>>            Set piWidth to 17
72106>>>        End_Object
72107>>>
72107>>>        Object oFunctions_ID is a cRDCDbCJGridColumn
72109>>>            Entry_Item Functions.ID
72110>>>            Set piWidth to 30
72111>>>            Set psCaption to "ID"
72112>>>            Set pbEditable to False
72113>>>        End_Object
72114>>>
72114>>>        Object oFunctions_Function_Name is a cRDCDbCJGridColumn
72116>>>            Entry_Item Functions.Function_Name
72117>>>            Set piWidth to 147
72118>>>            Set psCaption to "Function Name"
72119>>>        End_Object
72120>>>
72120>>>        Object oFunctions_Function_Description is a cRDCDbCJGridColumn
72122>>>            Entry_Item Functions.Function_Description
72123>>>            Set piWidth to 146
72124>>>            Set psCaption to "Function Description"
72125>>>        End_Object
72126>>>
72126>>>        Object oFunctions_Function_Summary is a cRDCDbCJGridColumn
72128>>>            Entry_Item Functions.Function_Summary
72129>>>            Set piWidth to 233
72130>>>            Set psCaption to "Function Summary"
72131>>>        End_Object
72132>>>
72132>>>        Object oFunctions_Function_Help is a cRDCDbCJGridColumn
72134>>>            Entry_Item Functions.Function_Help
72135>>>            Set piWidth to 221
72136>>>            Set psCaption to "Function Help"
72137>>>        End_Object
72138>>>
72138>>>        Object oFunctions_Type is a cRDCDbCJGridColumn
72140>>>            Entry_Item Functions.Type
72141>>>            Set piWidth to 66
72142>>>            Set psCaption to "Type"
72143>>>            Set peHeaderAlignment to xtpAlignmentCenter
72144>>>            Set peTextAlignment to xtpAlignmentCenter
72145>>>        End_Object                    
72146>>>        
72146>>>    End_Object
72147>>>
72147>>>End_Object 
72148>
72148>        Procedure Activate_About
72151>            Send DoAbout "" "" "" "" ""
72152>        End_Procedure
72153>
72153>    End_Object
72154>
72154>End_Object
72155>
72155>Start_UI
72156>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 42539
Total Resources: 0
Total Commands : 72155
Total Windows  : 0
Total Pages    : 0
Static Data    : 434990
Message area   : 506798
Total Blocks   : 26276
