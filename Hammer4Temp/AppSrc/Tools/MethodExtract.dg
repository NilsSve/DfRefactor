Use Windows.pkg
Use cSciLexerRefactor.pkg
Use cRefactorMethodExtract.pkg

Object oMethodExtract_dg is a ModalPanel
    Set Size to 168 396
    Set Label to "Method Extract"
    Set piMinSize to 89 211
    Set Location to 2 2
    Set Maximize_Icon to True
    Set Border_Style To Border_Thick

    Property Boolean pbOkButton   False
    Property Integer piMethodStartLine 0
    Property String  psBodyText   ""
    Property String  psComposedMethodText ""
    Property tRefactorVar[] pVariables

    Object oOK_Btn is a Button
        Set Label    to "&OK"
        Set Location to 150 283
        Set peAnchors To anBottomRight
        On_Key kCancel Send Close_Panel

        Procedure OnClick
          Boolean bChanged
          Get Changed_State Of oMethodName To bChanged
          If (bChanged) Begin
            Send UpdateMethodBody Of oMethodText // if somebody forget's to click "update" do it for them.
          End                                    // perhaps not ideal, but better as the alternative
          Set pbOkButton to True
          Send Close_Panel
        End_Procedure

    End_Object

    Object oCancel_Btn is a Button
        Set Label    to "&Cancel"
        Set Location to 150 338
        Set peAnchors to anBottomRight
        On_Key kCancel Send Close_Panel

        Procedure OnClick
          Send Close_Panel
        End_Procedure

    End_Object

  Object oMethodText is a cSciLexerRefactor
    Set Size to 107 368
    Set Location to 37 20
    Set peAnchors to anAll
    Set Enabled_State To False
    On_Key kCancel Send Close_Panel

    Procedure SetAdjustments
        Integer hoIni iRet
        // Font Face
        String  sFontData
        String  sFontTemp
        String  sFontFace
        Integer iFontSize
        Integer iCharSet
        //

        Move (CM_ENABLEGLOBALPROPS(Self,False))    To iRet

        Move ghoEditorProperties  To hoIni
        Move (CM_SetLineNumbering(Self,Low(piLineNumbering(hoIni)),Hi(piLineNumbering(hoIni)),Low(piLineNumbering(hoIni)))) To iRet
        Move (CM_EnableLeftMargin(Self,pbLeftMargin(hoIni)))            To iRet

        Move (CM_SetLanguage(Self,psLanguage(hoIni)))                   To iRet
        Move (CM_ShowScrollBar(Self,True,pbScrollBarH(hoIni)))          To iRet
        Move (CM_ShowScrollBar(Self,False,pbScrollBarV(hoIni)))         To iRet
        // Editor font face?
        Move (psFontFace(ghoEditorProperties))                          to sFontData
        If (sFontData="") Move "11pt; 0; Courier New"                 to sFontData
        // Font Size
        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
        Move (Trim(Replace("PT;", Uppercase(sFontTemp), "")))           to iFontSize
        // Code Page
        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
        Move (Trim(Replace(";", sFontTemp, "")))                        to iCharSet
        // Font Face
        Move (Trim(sFontData))                                          to sFontFace
        //
        Send EditorMessage SCI_STYLESETFONT STYLE_DEFAULT (AddressOf(sFontFace))
        Send EditorMessage SCI_STYLESETSIZE STYLE_DEFAULT iFontSize
        Send EditorMessage SCI_STYLESETCHARACTERSET STYLE_DEFAULT iCharSet
        Send EditorMessage SCI_STYLESETSIZE STYLE_LINENUMBER (iFontSize-1) // Set font size
        //
        Set  pbShowMatchingBraces to (pbShowMatchingBraces(hoIni))
        If  (pbShowIndentGuides(hoIni)) Send ShowIndentationGuides
        Send SelectTillEndOfLine (pbSelectWholeLine(hoIni))

        Move (CM_EnableDragDrop(Self,pbDragDrop(hoIni)))                To iRet
        Move (CM_EnableColumnSel(Self,pbColumnSel(hoIni)))              To iRet
        Move (CM_SetAutoIndentMode(Self,piAutoIndentMode(hoIni)))       To iRet
        Move (CM_SetTabSize(Self,piTabSize(hoIni)))                     To iRet
        Move (CM_EnableTabExpand(Self,pbTabExpand(hoIni)))              To iRet
        Move (CM_EnableNormalizeCase(Self,pbNormalizeCase(hoIni)))      To iRet
        Move (CM_EnableSelBounds(Self,pbSelBounds(hoIni)))              To iRet
        Move (CM_EnableCaseSensitive(Self,pbCaseSensitive(hoIni)))      To iRet
        Move (CM_EnableWholeWord(Self,pbWholeWord(hoIni)))              To iRet
    End_Procedure

    Procedure SetLexer
        Boolean bInit
        Integer iRet
        Integer iLanguage
        Integer iLexer
        String  sKeywords sScopeKeywords1 sScopeKeywords2 sOperators
        String  sTagElements sTagAttributes
        String  sLanguage sLexerLang

        Get psLanguage of ghoEditorProperties  To sLanguage
        Move (CM_SetLanguage(Self,sLanguage))  to iRet
        Get EditorMessage SCI_GETLEXER 0 0     to iLexer
        Move (ZeroString(255)) To sLexerLang
        Get EditorMessage SCI_GETLEXERLANGUAGE 0 (AddressOf(sLexerLang)) to iRet
        Get FindLanguage    of ghoEditorProperties sLanguage    to iLanguage

        If (iLexer=SCLEX_DATAFLEX) Begin
            Get SCKeywords (psLanguages.szKeywords(ghoEditorProperties, iLanguage))         to sKeywords
            Get SCKeywords (psLanguages.szScopeKeywords1(ghoEditorProperties, iLanguage))   to sScopeKeywords1
            Get SCKeywords (psLanguages.szScopeKeywords2(ghoEditorProperties, iLanguage))   to sScopeKeywords2
            Get SCKeywords (psLanguages.szOperators(ghoEditorProperties,iLanguage))         to sOperators
            Move (Replaces("^",sOperators,"")) To sOperators // The ^ char is a wildcard match in scintilla, the result is EVERYTHING is an operator, so remove it before passing it, it is a hardcoded operator in scintilla.
            // Fill the arrays for normalizing case feature when typing
            Get InitializedLanguage of oNormalizeCase SCLEX_DATAFLEX to bInit
            If (bInit=False) Begin
              Send AddKeywords   of oNormalizeCase SCLEX_DATAFLEX sKeywords
              Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords1
              Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords2
            End
            // Supply the keywords/scope keywords in lower case as the lexer matches on lowercase characters
            Move (Lowercase(sKeywords)) to sKeywords
            Move (sKeywords+Character(0)) to sKeywords
            Move (Lowercase(sScopeKeywords1)) To sScopeKeywords1
            Move (Lowercase(sScopeKeywords2)) To sScopeKeywords2
            Move (Lowercase(sOperators))      To sOperators
            Send EditorMessage SCI_SETKEYWORDS 0 (AddressOf(sKeywords))       // language keywords
            Send EditorMessage SCI_SETKEYWORDS 1 (AddressOf(sScopeKeywords1)) // scope open
            Send EditorMessage SCI_SETKEYWORDS 2 (AddressOf(sScopeKeywords2)) // scope close
            Send EditorMessage SCI_SETKEYWORDS 3 (AddressOf(sOperators))      // operators
            //
        End
    End_Procedure

    Function EnumerateVariablesComment Returns String
      Boolean bShowDBFields
      Integer iCount
      Integer iItem
      String  sComment
      String  sStatus
      String  sType
      tRefactorVar Variable
      tRefactorVar[] Variables
      Move "" To sComment
      Get pVariables to Variables
      Get Checked_State of oShowDBFields_cb to bShowDBFields
      Move (SizeOfArray(Variables)) To iCount
      For iItem From 0 To (iCount-1)
        Move Variables[iItem] To Variable
        If (Variable.bUsed) Begin
          Move "Unknown" To sStatus
          If (Variable.bRead and Variable.bWrite) Move "IN OUT " To sStatus
          Else If (Variable.bRead)  Move "IN     " To sStatus
          Else If (Variable.bWrite) Move "OUT    " To sStatus
          If (Variable.iType<>-1) Begin
            Get fVarTypToString Variable.iType To sType
            If (Length(sType)=6) Move (sType+" ") To sType // line out a bit better
          End
          Else Begin
            Move "??      " To sType
          End
          If (Variable.bIsDB=false) Begin
            If (sComment<>"") Move (sComment+CS_CRLF) To sComment
            Move (sComment+"// "+sStatus+" "+sType+" "+Variable.sName) To sComment
          End
          Else Begin
            If (bShowDBFields) Begin
              If (sComment<>"") Move (sComment+CS_CRLF) To sComment
              Move "db     " To sType
              Move (sComment+"// "+sStatus+" "+sType+" "+Variable.sName) To sComment
            End
          End
        End
      Loop
      Function_Return sComment
    End_Function

    Function VariableDeclaration Returns String
      Integer iCount
      Integer iItem
      String  sIndent
      String  sType
      String  sVar
      tRefactorVar Variable
      tRefactorVar[] Variables
      Move "" To sVar
      Get DefaultTabIndent to sIndent
      Get pVariables to Variables
      Move (SizeOfArray(Variables)) To iCount
      For iItem From 0 To (iCount-1)
        Move Variables[iItem] To Variable
        If (Variable.bUsed) Begin
          If (Variable.bLocalParam=false) Begin
            If (Variable.iType <> -1) Begin
              If (sVar<>"") Move (sVar+CS_CRLF)  To sVar
              Get fVarTypToString Variable.iType To sType
              If (Length(sType)=6) Move (sType+" ") To sType // line out a bit better
              Move (sVar+sIndent+sType+" "+Variable.sName) To sVar
            End
          End
        End
      Loop
      Function_Return sVar
    End_Function

    Function ParamDeclaration Returns String
      Integer iCount
      Integer iItem
      String  sIndent
      String  sVar
      tRefactorVar Variable
      tRefactorVar[] Variables
      Move "" To sVar
      Get pVariables to Variables
      Move (SizeOfArray(Variables)) To iCount
      For iItem From 0 To (iCount-1)
        Move Variables[iItem] To Variable
        If (Variable.bUsed) Begin
          If (Variable.bBefore or (Variable.bAfter and Variable.bWrite) or Variable.bParam) Begin
            If (Variable.iType <> -1) Begin
              Move (sVar+" "+fVarTypToString(Variable.iType)) To sVar
              If (Variable.bAfter) Begin
                Move (sVar+" "+"ByRef") To sVar
              End
              Move (sVar+" "+Variable.sName) To sVar
              Move True to Variable.bLocalParam
              Move Variable to Variables[iItem]
            End
          End
        End
      Loop
      Set pVariables To Variables
      Function_Return sVar
    End_Function

    Procedure ComposeMethodBody
      Integer iRet
      Integer iType
      Integer iLineCount
      Integer iGoToLine
      String  sText
      String  sBodyText
      String  sMethodName
      String  sComment
      String  sVar

      Get Value of oMethodName to sMethodName
      If (lowercase(Left(sMethodName,10))="procedure ") Begin
        Move MK_PROCEDURE To iType
      End
      Else If (lowercase(Left(sMethodName,9))="function ") Begin
        Move MK_FUNCTION To iType
      End

      Set Enabled_State To True
      Send Delete_Data // remove all the old data+styling
      Get psBodyText To sBodyText
      Get EnumerateVariablesComment to sComment
      Get VariableDeclaration to sVar
      Move "" To sText
      If (sComment<>"") Begin
        Move (sComment+CS_CRLF+sMethodName+CS_CRLF) To sText
      End
      Else Move (sMethodName+CS_CRLF) To sText
      Get CM_Settext sText  To iRet
      Get SC_LineCount   To iLineCount
      If (iLineCount>1) Move (iLineCount-2) To iGoToLine
      Else Move iLineCount To iGoToLine
      Set piMethodStartLine To iGoToLine
      Move "" To sText
      If (sVar<>"") Begin
        Move (sText+sVar+CS_CRLF+CS_CRLF) To sText
      End
      Move (sText+sBodyText) To sText
      If (iType=MK_PROCEDURE) Begin
        Move (sText+"End_Procedure") To sText
      End
      If (iType=MK_FUNCTION) Begin
        Move (sText+"  Function_Return FIX"+"ME"+CS_CRLF) To sText
        Move (sText+"End_Function") To sText
      End
      Send InsertTextAtPosition iLineCount 0 sText
      //Get CM_Settext sText  To iRet
      Send RefactorReIndent
      Send SetComposedResult
      Get CM_ClearUndoBuffer To iRet
      Set Enabled_State To False
    End_Procedure

    Procedure ClearLocalParams
      Integer iCount
      Integer iItem
      tRefactorVar Variable
      tRefactorVar[] Variables
      Get pVariables to Variables
      Move (SizeOfArray(Variables)) To iCount
      For iItem From 0 To (iCount-1)
        Move Variables[iItem] To Variable
        If (Variable.bUsed) Begin
          Move False To Variable.bLocalParam
          Move Variable To Variables[iItem]
        End
      Loop
      Set pVariables To Variables
    End_Procedure

    Procedure SetLocalParam String sParam Integer iType
      Integer iCount
      Integer iItem
      tRefactorVar Variable
      tRefactorVar[] Variables
      Move (lowercase(sParam)) To sParam
      Get pVariables to Variables
      Move (SizeOfArray(Variables)) To iCount
      For iItem From 0 To (iCount-1)
        Move Variables[iItem] To Variable
        If (Variable.bUsed and sParam=lowercase(Variable.sName)) Begin
          If (iType=Variable.iType) Begin
            Move True To Variable.bLocalParam
            Move Variable To Variables[iItem]
          End
        End
      Loop
      Set pVariables To Variables
    End_Procedure

    //
    // As the user can edit the method name and thus the parameter list,  we need to re-asses
    // our list of parameters so that we can adjust our variables that we need to declare (or not)
    //
    Procedure RecalcParamDeclarations
      Boolean bByRef
      String  sMethod
      String  sName
      String  sElement
      Integer iType
      Integer iPos
      Integer iElement  // 0=type, 1=variable name

      Send ClearLocalParams
      Get Value Of oMethodName To sName
      Move (ltrim(sName)) To sName
      If (lowercase(Left(sName,10))="procedure ") Begin
        Move (Right(sName,Length(sName)-10)) To sName
      End
      Else If (lowercase(Left(sName,9))="function ") Begin
        Move (Right(sName,Length(sName)-9)) To sName
      End
      Move (LTrim(sName)) To sName // if people use more than one space
      Move (Pos(" ",sName)) To iPos
      If (iPos<>0) Begin
        Move (Left(sName,iPos)) To sMethod  // method name
        Move (Replace(sMethod,sName,"")) To sName
        Move 0     To iElement
        Move False To bByRef
        While (sName<>"")                   // walk through the parameters, element 0 = variable type
          Move (LTrim(sName)) To sName                                //    element 1 = variable name
          Move (Pos(" ",sName)) To iPos
          If (iPos<>0) Begin
            Move (Left(sName,iPos)) To sElement
            Move (Replace(sElement,sName,"")) To sName
          End
          Else Begin
            Move sName To sElement
            Move "" To sName
          End
          If (iElement=0) Begin
            Get fStringToVarTyp sElement To iType
            Move 1 To iElement
          End
          Else If (iElement=1) Begin
            If (lowercase(Trim(sElement))="byref") Begin
              Move True To bByRef
            End
            Else If (lowercase(Trim(sElement))="returns") Begin
              Move "" To sName // done
            End
            Else Begin
              If (bByRef) Begin
                Move False To bByRef
              End
              Move 0 To iElement
              Send SetLocalParam sElement iType
              Move -1 To iType
            End
          End
        Loop
      End
    End_Procedure

    Procedure UpdateMethodBody
      Send RecalcParamDeclarations
      Send ComposeMethodBody
    End_Procedure
    
    // Augmentation of the original function as somehow it won't work in here without doing the old
    // "walking over the lines" logic.
    Function ReIndentLineIndentation Integer iLine Integer iLineCount Integer iTabSize Boolean bUseTabs Integer ByRef iPrevLevel Returns String
      String sLine
      Send GotoLine iLine
      Forward Get ReIndentLineIndentation iLine iLineCount iTabSize bUseTabs (&iPrevLevel) to sLine
      Function_Return sLine
    End_Function


    //
    // Stores the lines as are now on the screen into the psComposedMethodText property
    //
    Procedure SetComposedResult
      Integer iLine
      Integer iLineCount
      String  sLine
      String  sText

      Move "" To sText
      Get SC_LineCount to iLineCount
      For iLine From 0 To (iLineCount-1)
        Get Value Item iLine To sLine
        Move (sText+sLine+CS_CRLF) To sText
      Loop
      Set psComposedMethodText To sText
    End_Procedure


    Procedure onPaged
      Integer iLine
      Send ComposeMethodBody
      Get piMethodStartLine To iLine
      Send GoToLine iLine
    End_Procedure
  End_Object

  Object oMethodName is a Form
    Set Size to 13 275
    Set Location to 20 53
    Set Label to "Method:"
    Set Label_Col_Offset to 3
    Set Label_Justification_Mode to JMode_Right
    Set peAnchors to anTopLeftRight
  End_Object

  Object oUpdate_Btn is a Button
    Set Location to 19 338
    Set Label to "Update"
    Set peAnchors to anTopRight
    On_Key kCancel Send Close_Panel

    Procedure OnClick
      Integer iLine
      Send UpdateMethodBody of oMethodText
      Get piMethodStartLine To iLine
      Send GoToLine Of oMethodText iLine
      Set Changed_State Of oMethodName To False
    End_Procedure
  End_Object

  Object oShowDBFields_cb is a CheckBox
    Set Size to 10 50
    Set Location to 152 20
    Set Label to "Show Database Fields"
    Set peAnchors to anBottomLeft
    On_Key kCancel Send Close_Panel

    Procedure OnChange
      If (Focus(Desktop)=Self) Begin
        Send UpdateMethodBody of oMethodText
      End
    End_Procedure
  End_Object

  On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
  On_Key Key_Alt+Key_C Send KeyAction Of oCancel_Btn

  //
  // takes the method name and changes it into something we can call
  //
  Function MethodInvoke Returns String
    Boolean bByRef
    Boolean bHasReturn
    String  sName
    String  sInvoke
    String  sElement
    Integer iType
    Integer iPos
    Integer iElement  // 0=type, 1=variable name

    Get Value Of oMethodName To sName
    Move (ltrim(sName)) To sName
    If (lowercase(Left(sName,10))="procedure ") Begin
      Move (Right(sName,Length(sName)-10)) To sName
      Move MK_PROCEDURE To iType
    End
    Else If (lowercase(Left(sName,9))="function ") Begin
      Move (Right(sName,Length(sName)-9)) To sName
      Move MK_FUNCTION To iType
    End
    Move (LTrim(sName)) To sName // if people use more than one space
    Move (Pos(" ",sName)) To iPos
    If (iPos<>0) Begin
      Move (Left(sName,iPos)) To sInvoke  // method name
      Move (Replace(sInvoke,sName,"")) To sName
      Move 0     To iElement
      Move False To bByRef
      Move False To bHasReturn
      While (sName<>"")                   // walk through the parameters, element 0 = variable type
        Move (LTrim(sName)) To sName                                //    element 1 = variable name
        Move (Pos(" ",sName)) To iPos
        If (iPos<>0) Begin
          Move (Left(sName,iPos)) To sElement
          Move (Replace(sElement,sName,"")) To sName
        End
        Else Begin
          Move sName To sElement
          Move "" To sName
        End
        If (iElement=0) Begin
          Move 1 To iElement   // That's all we do with the variable type here
          If (lowercase(Trim(sElement))="returns") Begin
            Move True To bHasReturn
            Move "" To sName
          End
        End
        Else If (iElement=1) Begin
          If (lowercase(Trim(sElement))="byref") Begin
            Move True To bByRef
            Move (sInvoke+" (&") To sInvoke
          End
          Else If (lowercase(Trim(sElement))="returns") Begin
            Move True To bHasReturn
            Move "" To sName
          End
          Else Begin
            Move (sInvoke+sElement) To sInvoke
            If (bByRef) Begin
              Move (rtrim(sInvoke)+")") To sInvoke
              Move False To bByRef
            End
            Move 0 To iElement
          End
        End
      Loop
    End
    Else Begin
      // There's no parameters
      Move sName To sInvoke
    End
    If (iType=MK_PROCEDURE) Begin
      If (bHasReturn=False) Begin
        // The normal way
        Move ("Send "+sInvoke) To sInvoke
      End
      Else Begin
        // Pah, why?
        Move ("Get msg_"+sInvoke) To sInvoke
        Move (RTrim(sInvoke)+" To FIX"+"ME") To sInvoke // break up fixing tag in our source as I don't want it to show up anywhere
      End
    End
    Else Begin  // it's a function
      Move ("Get "+sInvoke) To sInvoke
      Move (RTrim(sInvoke)+" To FIX"+"ME") To sInvoke
    End
    Function_Return sInvoke
  End_Function


  Function MethodExtractConfirmation String sText tRefactorVar[] Variables Returns Boolean
    Boolean bConfirm
    Integer iRet
    String  sParam
    //Send Delete of oMethodText

    Set pVariables to Variables
    Get ParamDeclaration of oMethodText to sParam
    Set Value         Of oMethodName To ("Procedure MyMethod"+sParam)
    Set Changed_State Of oMethodName To False
    Set psBodyText to sText
    Set pbOkButton to False
    Send Popup
    Get pbOkButton to bConfirm
    Function_Return bConfirm
  End_Function


End_Object
