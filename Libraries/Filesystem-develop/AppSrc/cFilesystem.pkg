//************************************************************************
//*** FileSystem - Binary file operations for VDF20.1+.
//************************************************************************
//*** Based on original package: akefs.pkg
//*** Version: 5.0
//*** (C) NOVAX A/S, Novax Software ApS
//***
//*** Author......: Allan Greis Eriksen
//*** Created.....: 23/08 2001
//************************************************************************
// cFilesystem class with functions and procedures to access binary files. 
// Filenumbers are not limited to 10 but only to system resources.
// Using unicode windows API calls for file copy, file move ect.
// This class is for vdf 20.1 and up.

//************************************************************************
// Constants used for the external functions.
//************************************************************************
// fsCreatefile.
#IFNDEF GENERIC_READ
Define GENERIC_READ for            |CI$80000000
Define GENERIC_WRITE for           |CI$40000000
Define GENERIC_RANDOM for          (GENERIC_READ + GENERIC_WRITE)
Define CREATE_NEW for              |CI$00000001
Define CREATE_ALWAYS for           |CI$00000002
Define OPEN_EXISTING for           |CI$00000003
Define OPEN_ALWAYS for             |CI$00000004
Define TRUNCATE_EXISTING for       |CI$00000005
#ENDIF

#IFNDEF FILE_ATTRIBUTE_NORMAL
Define FILE_ATTRIBUTE_NORMAL for   |CI$00000080
#ENDIF

#IFNDEF FILE_SHARE_READ
Define FILE_SHARE_READ for         |CI$1
Define FILE_SHARE_WRITE for        |CI$2
Define FILE_SHARE_RANDOM for       (FILE_SHARE_READ + FILE_SHARE_WRITE)
#ENDIF

// Generel.
Define FNULL for                   |CI$0

// FormatString.
#IFNDEF FORMAT_MESSAGE_ALLOCATE_BUFFER
Define FORMAT_MESSAGE_ALLOCATE_BUFFER for    |CI$0100
Define FORMAT_MESSAGE_IGNORE_INSERTS for     |CI$0200
Define FORMAT_MESSAGE_FROM_STRING for        |CI$0400
Define FORMAT_MESSAGE_FROM_HMODULE for       |CI$0800
Define FORMAT_MESSAGE_FROM_SYSTEM for        |CI$1000
Define FORMAT_MESSAGE_ARGUMENT_ARRAY for     |CI$2000
Define FORMAT_MESSAGE_MAX_WIDTH_MASK for     |CI$00FF
#ENDIF

// SetFilePosition.
#IFNDEF FILE_BEGIN 
Define FILE_BEGIN for     0
Define FILE_CURRENT for  1
Define FILE_END for      2
Define INVALID_SET_FILE_POINTER for |CI$FFFFFFFF
#ENDIF

// FindFile.
#IFNDEF INVALID_HANDLE_VALUE
Define INVALID_HANDLE_VALUE   For |CI-1
Define INVALID_FILE_SIZE      for |CI$FFFFFFFF
#ENDIF

#IFNDEF ERROR_NO_MORE_FILES
Define ERROR_NO_MORE_FILES    for |CI18
Define ERROR_MOD_NOT_FOUND    for |CI126
#ENDIF

#IFNDEF MAX_PATH
Define MAX_PATH               for 260
#ENDIF
#IFNDEF MAX_ALTPATH
Define MAX_ALTPATH            for 14
#ENDIF

#IFNDEF FILE_ATTRIBUTE_READONLY
Define FILE_ATTRIBUTE_READONLY   for |CI$01
Define FILE_ATTRIBUTE_HIDDEN     For |CI$02
Define FILE_ATTRIBUTE_SYSTEM     For |CI$04
Define FILE_ATTRIBUTE_DIRECTORY  for |CI$10
Define FILE_ATTRIBUTE_ARCHIVE    For |CI$20
Define FILE_ATTRIBUTE_NORMAL     For |CI$80
Define FILE_ATTRIBUTE_TEMPORARY  for |CI$100
Define FILE_ATTRIBUTE_SPARSE_FILE for |CI$200
Define FILE_ATTRIBUTE_REPARSE_POINT for |CI$400
Define FILE_ATTRIBUTE_COMPRESSED for |CI$800
Define FILE_ATTRIBUTE_OFFLINE    for |CI$1000
Define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED for |CI$2000
Define FILE_ATTRIBUTE_ENCRYPTED  for |CI$4000
#ENDIF

// Flags for tsVS_FIXEDFILEINFO.dwFileFlags.
#IFNDEF VS_FF_DEBUG
Define VS_FF_DEBUG          for |CI$01
Define VS_FF_INFOINFERRED   for |CI$10
Define VS_FF_PATCHED        for |CI$04
Define VS_FF_PRERELEASE     for |CI$02
Define VS_FF_PRIVATEBUILD   for |CI$08
Define VS_FF_SPECIALBUILD   for |CI$20
#ENDIF

// Flags for tsVS_FIXEDFILEINFO.dwFileOS.
#IFNDEF VOS_DOS
Define VOS_DOS          for |CI$10000
Define VOS_NT           for |CI$40000
Define VOS_WINDOWS16    for |CI$00001
Define VOS_WINDOWS32    for |CI$00004
Define VOS_OS216        for |CI$20000
Define VOS_OS232        for |CI$30000
Define VOS_PM16         for |CI$00002
Define VOS_PM32         for |CI$00003
Define VOS_UNKNOWN      for |CI$00000
#ENDIF

// Flags for tsVS_FIXEDFILEINFO.dwFileType.
#IFNDEF VFT_APP
Define VFT_APP          for |CI$01
Define VFT_DLL          for |CI$02
Define VFT_DRV          for |CI$03
Define VFT_FONT         for |CI$04
Define VFT_STATIC_LIB   for |CI$07
Define VFT_UNKNOWN      for |CI$00
Define VFT_VXD          for |CI$05
#ENDIF

// Flags for tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_DRV.
#IFNDEF VFT2_DRV_COMM
Define VFT2_DRV_COMM                for |CI$0A
Define VFT2_DRV_DISPLAY             for |CI$04
Define VFT2_DRV_INSTALLABLE         for |CI$08
Define VFT2_DRV_KEYBOARD            for |CI$02
Define VFT2_DRV_LANGUAGE            for |CI$03
Define VFT2_DRV_MOUSE               for |CI$05
Define VFT2_DRV_NETWORK             for |CI$06
Define VFT2_DRV_PRINTER             for |CI$01
Define VFT2_DRV_SOUND               for |CI$09
Define VFT2_DRV_SYSTEM              for |CI$07
Define VFT2_DRV_VERSIONED_PRINTER   for |CI$0C
#ENDIF

// Flags for tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_FONT.
#IFNDEF VFT2_FONT_RASTER
Define VFT2_FONT_RASTER             for |CI$01
Define VFT2_FONT_TRUETYPE           for |CI$03
Define VFT2_FONT_VECTOR             for |CI$02
#ENDIF

#IFNDEF VFT2_UNKNOWN
Define VFT2_UNKNOWN                 for |CI$00
#ENDIF

Define FS_FILEHANDLEMISSING for "The filehandle does not exists for the current filenumber."

// Filesearch
Enum_List
    Define DIRMODE_FILES_ONLY For 1
    Define DIRMODE_DIRECTORIES_ONLY
    Define DIRMODE_FILES_AND_DIRECTORIES
End_Enum_List

Define FS_BUFFERSIZE for |CI$2000

#IFNDEF CR_LF
    Define CR_LF for (Character(13)+Character(10))
#ENDIF

//************************************************************************
// Declarations of external functions.
// Functions that needs variables for output are made global stings or
// integers, and can be found on top of the declaration.
//************************************************************************
External_Function fsCreatefile "CreateFileW" kernel32.dll ;
    WString lpFile ;      // filename
    DWord dwDesAccess ;   // access mode
    DWord dwShare ;       // share mode
    Pointer lpSecAtt ;    // SD
    DWord dwCrDisp ;      // how to create
    DWord dwFlags ;       // file attributes
    Handle hTempFile ;   // handle to template fil
    Returns Integer      //Returns handle that can be used to access the object

External_Function fsGetLastError "GetLastError" kernel32.dll Returns Integer

External_Function fsCloseHandle "CloseHandle" kernel32.dll ;
    Handle hObject ;        // handle to object
    Returns Integer

External_Function fsReadFile "ReadFile" kernel32.dll ;
    Handle hFile ;          // handle to file
    Pointer lpBuffer ;      // data buffer
    DWord nBytesToRead ;    // number of bytes to read
    Pointer lpBytesRead ;   // number of bytes read
    Pointer lpOverlapped ;  // overlapped buffer
    Returns Integer

External_Function fsWriteFile "WriteFile" kernel32.dll ;
    Handle hFile ;              // handle to file
    Pointer lpBuf ;             // data buffer
    DWord nNumBytesWrt ;        // number of bytes to write
    Pointer lpNumBytesWritten ; // number of bytes written
    Pointer lpOverlapped ;      // overlapped buffer
    Returns Integer

External_Function fsGetFileSizeEx "GetFileSizeEx" kernel32.dll ;
    Handle hFile ;           // handle to file
    Pointer lpFileSizeHigh ; // A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.
    Returns Integer         

External_Function fsSetFilePointer "SetFilePointer" kernel32.dll ;
    Handle hFile ;              // handle to file
    UInteger lDistanceToMove ;    // The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer. 
    Pointer lpDistanceToMoveHigh ;  // A pointer to the high order 32-bits of the signed 64-bit distance to move. 
    DWord dwMoveMethod ;        // The starting point for the file pointer move.
    Returns UInteger

External_Function fsSetEndOfFile "SetEndOfFile" kernel32.dll ;
    Handle hFile ;              // handle to the file to have its EOF position moved.
    Returns Integer             // nonzero if success

External_Function fsDeleteFile "DeleteFileW" Kernel32.Dll ;
   WString lpFileName ;         // Pointer to a null-terminated string that specifies the file to be deleted.
   Returns Integer

External_Function fsMoveFile "MoveFileW" Kernel32.Dll ;
    WString lpExistingFileName ;    // Pointer to a null-terminated string that names an existing file or directory.
    WString lpNewFileName ;         // Pointer to a null-terminated string that specifies the new name of a file or directory.
    Returns Integer                 // The new name must Not already exist. A new File may be on A different File system Or drive. A new directory must be on the same drive.

External_Function fsCopyFile "CopyFileW" Kernel32.Dll ;
    WString lpExistingFileName ;    // Pointer to a null-terminated string that specifies the name of an existing file.
    WString lpNewFileName ;         // Pointer to a null-terminated string that specifies the name of the new file.
    Boolean bFailIfExists ;         // If bFailIfExists is TRUE and the new file specified by lpNewFileName already exists, the function fails.
    Returns Integer                 // If bFailIfExists is FALSE and the new file already exists, the function overwrites the existing file and succeeds.

External_Function fsFindFirstFile "FindFirstFileW" Kernel32.Dll ;
    WString lpFileName ;            // Pointer to a null-terminated string that specifies a valid directory or path and file name, which can contain wildcard characters (* and ?).
    Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATAW structure that receives information about the found file or subdirectory.
    Returns Integer

External_Function fsFindNextFile "FindNextFileW" Kernel32.Dll ;
    Handle hFindFile ;              // handle returned by a previous call to the FindFirstFile function.
    Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.
    Returns Integer

External_Function fsFindClose "FindClose" Kernel32.dll ;
    Handle hFindFile ;              // File search handle. This handle must have been previously opened by the FindFirstFile function.
    Returns Integer

External_Function fsFileTimeToSystemTime "FileTimeToSystemTime" Kernel32.dll ;
    Pointer lpFiletime ;            // Pointer to a FILETIME structure containing the file time to convert to system date and time format.
    Pointer lpSystemtime ;          // Pointer to a SYSTEMTIME structure to receive the converted file time.
    Returns Integer

External_Function fsSystemTimeToTzSpecificLocalTime "SystemTimeToTzSpecificLocalTime" Kernel32.dll ;
    Pointer lpTimeZone ;            // A pointer to a TIME_ZONE_INFORMATION structure that specifies the time zone of interest.
    Pointer lpUniversalTime ;       // A pointer to a SYSTEMTIME structure that specifies a time, in UTC.
    Pointer lpLocalTime ;           // A pointer to a SYSTEMTIME structure that receives the local time.
    Returns Integer

External_Function fsGetTempFileName "GetTempFileNameW" kernel32.dll ;
    WString sPathname ;             // The directory path for the file name.
    WString sPrefixString ;         // The null-terminated prefix string.
    Integer iUnique ;               // An unsigned integer to be used in creating the temporary file name.
    Pointer sTempFileName ;         // A pointer to the buffer that receives the temporary file name.
    Returns Integer

External_Function fsGetTempPath "GetTempPathW" Kernel32.Dll ;
    Integer nBufferLength ;         // The size of the string buffer identified by lpBuffer, in TCHARs.
    Pointer lpBuffer ;              // A pointer to a string buffer that receives the null-terminated string specifying the temporary file path.
    Returns Integer

External_Function fsSetFileAttributes "SetFileAttributesW" Kernel32.dll ;
    WString lpFileName ;
    DWord dwFileAttributes ;
    Returns Boolean

External_Function fsCreateDirectory "CreateDirectoryW" Kernel32.dll ;
    WString lpDirName ;             // Pointer to a null-terminated string that specifies the path of the directory to be created.
    Pointer lpSecAttributes ;       // Pointer to a SECURITY_ATTRIBUTES structure.
    Returns Integer

External_Function fsRemoveDirectory "RemoveDirectoryW" Kernel32.dll ;
    WString lpDirName ;             // Pointer to a null-terminated string that specifies the path of the directory to be removed.
    Returns Integer    

External_Function fsExtractAssociatedIcon "ExtractAssociatedIconW" shell32.dll ;
    Handle hInst ;                  // A handle to the instance of the calling application.
    WString lpIconPath ;            // The name of the file whose attributes are to be set.
    Integer lpiIcon ;               // Pointer to a WORD value that, on entry, specifies the index of the icon whose handle is to be obtained.
    Returns Handle
    
External_Function fsDestroyIcon "DestroyIcon" User32.dll ;
    Handle hIcon ;
    Returns Integer    

External_Function fsGetFileVersionInfoSize "GetFileVersionInfoSizeW" Version.dll ;
    WString lpFilename ;            // The name of the file of interest. The function uses the search sequence specified by the LoadLibrary function.
    Pointer lpHandle ;              // A pointer to a variable that the function sets to zero.
    Returns UInteger
    
External_Function fsGetFileVersionInfo "GetFileVersionInfoW" Version.dll ;
    WString lpFilename ;            // The name of the file. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.
    DWord dwHandle ;                // This parameter is ignored.
    DWord dwLen ;                   // The size, in bytes, of the buffer pointed to by the lpData parameter.
    Pointer lpData ;                // Pointer to a buffer that receives the file-version information.
    Returns Boolean
    
External_Function fsVerQueryValue "VerQueryValueW" Version.dll ;
    Pointer lpBlock ;               // The version-information resource returned by the GetFileVersionInfo function.
    WString lpSubBlock ;            // The version-information value to be retrieved.
    Pointer lpBuffer ;              // When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by lpBlock.
    Pointer lpLen ;                 // When this method returns, contains a pointer to the size of the requested data pointed to by lpBuffer.
    Returns Boolean

External_Function fsGetFullPathName "GetFullPathNameW" Kernel32.dll ;
    WString lpFileName ;            // The name of the file.
    DWord dwBufferLength ;          // The size of the buffer to receive the null-terminated string for the drive and path, in TCHARs.
    Pointer lpBuffer ;              // A pointer to a buffer that receives the null-terminated string for the drive and path.
    Pointer lpFilePart ;            // A pointer to a buffer that receives the address (within lpBuffer) of the final file name component in the path.
    Returns Integer

//************************************************************************
// Structures
//************************************************************************
Struct structWFDW
    DWord dwFileAttributes 
    UBigInt ftCreationDateTime
    UBigInt ftLastAccessDateTime 
    UBigInt ftLastWriteDateTime 
    UInteger nFileSizeHigh 
    UInteger nFileSizeLow 
    DWord dares
    DWord dbres
    UShort[MAX_PATH] cFileName    
    UShort[MAX_ALTPATH] cAlternateFileName   
End_Struct

Struct structSystemTime
    UShort wYear
    UShort wMonth
    UShort wDayOfWeek
    UShort wDay 
    UShort wHour
    UShort wMinute
    UShort wSecond
    UShort wMillieseconds
End_Struct

Struct structFile
    Handle hFilehandle
    String sFilename    // Assigned filename.
    Boolean bEndOfFile  // True then the end of the binary file had been read.
End_Struct

Struct structFileBufferPointer
    Integer iBufferPointer
    Integer iBufferSize
    BigInt biFromFilePosition
End_Struct

Struct tsSearchResult
    String sFilename
    String sAlternateFileName   // 8.3 format
    DateTime dtCreationDateTime
    DateTime dtLastAccessDateTime
    DateTime dtLastWriteDateTime
    BigInt biFileSize
    Integer iFileAttributes
End_Struct

Struct tsVS_FIXEDFILEINFO
  DWord dwSignature
  DWord dwStrucVersion
  DWord dwFileVersionMS
  DWord dwFileVersionLS
  DWord dwProductVersionMS
  DWord dwProductVersionLS
  DWord dwFileFlagsMask
  DWord dwFileFlags
  DWord dwFileOS
  DWord dwFileType
  DWord dwFileSubtype
//  DWord dwFileDateMS
//  DWord dwFileDateLS
  UBigInt ubiFileDate
End_Struct

Struct tsFileVersionInfo
    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
    Short[] siFileVersion
    Short[] siProductVersion
    DateTime dtCreationDateTime
    String sComments
    String sCompanyName
    String sFileDescription
    String sFileVersion
    String sInternalName
    String sLegalCopyright
    String sLegalTrademarks
    String sOriginalFilename
    String sProductName
    String sProductVersion
    String sPrivateBuild
    String sSpecialBuild
End_Struct

Struct tsLandAndCodePage
    UShort wLanguage
    UShort wCodePage
End_Struct

Register_Function FileErrorText Integer iFilenumber Returns String

Use GlobalFunctionsProcedures.pkg
Use CharTranslate.pkg
Use gFormatNumbers.pkg

//************************************************************************
// The filesystem class
//************************************************************************
Class cFilesystem is a cObject
    
    Procedure Construct_Object
        Forward Send Construct_Object
        
        // True then the end of the binary file had been read - not when $1A (EOF) is met.
        // Legacy property. Use the BinaryFileEndOfFile function instead.
        Property Boolean pbEOF False
        
        // True if any error has occured during fileoprerations.
        Property Boolean pbError False
        
        // If errormessages should be called with dataflex error command set this to true
        Property Boolean pbErrorAsVDFError False
        
        // True if any file error should be ignored.
        Property Boolean pbIgnoreError False

        // Keeps assigned handles and filenames for each filenumber.
        {Visibility = Private}
        Property structFile[] plsaFile
        
        // Keeps read cached buffers for each filenumer.
        {Visibility = Private}
        Property UChar[][] puaaCachedBuffer
        
        // Pointers for cached buffers.
        {Visibility = Private}
        Property structFileBufferPointer[] plsCachedPointer
    End_Procedure


    // Returns the next available filenumber for a binary file.
    Function BinaryFileNextFilenumber Returns Integer
        structFile[] lsaFile
        Integer iMaxFiles iCurrentFile iNextFileNumber
        Get plsaFile to lsaFile
        Move (SizeOfArray(lsaFile)) to iMaxFiles
        Move -1 to iNextFileNumber
        Move 0 to iCurrentFile
        While (iCurrentFile < iMaxFiles and iNextFileNumber = -1)
            If (lsaFile[iCurrentFile].hFilehandle = 0) Begin
                Move iCurrentFile to iNextFileNumber
            End
            Else Begin
                Increment iCurrentFile
            End
        Loop
        If (iNextFileNumber = -1) Begin
            Move iMaxFiles to iNextFileNumber
        End
        Function_Return iNextFileNumber
    End_Function
    
    
    // Opens a binary file.
    // If bShared is false or not pharsed the file is opened in exclusive.
    // If bShared is True the file is opened with both read and write shared mode
    // If bCreate is True the file is created if it does not exist already.
    // If bReadOnly is True the file is opened with only read access (and only read shared mode if bShared is also true).
    // Returns true if the file was opened or created without error.
    Function BinaryFileOpen Integer iFilenumber String sFilename Boolean bShared Boolean bCreate Boolean bReadOnly Returns Boolean
        Integer iReturnValue iErrornumber
        DWord dwSharedMode dwCreateMode dwAccessMode
        structFile[] lsaFile
        Boolean bOk bFilehandleOK
        Get plsaFile to lsaFile
        If (iFilenumber < SizeOfArray(lsaFile)) Begin
            If (lsaFile[iFilenumber].hFilehandle = 0) Begin
                Move True to bFilehandleOK
            End
        End
        Else Begin
            Move True to bFilehandleOK
        End
        If bFilehandleOK Begin
            Move sFilename to lsaFile[iFilenumber].sFilename
            Set pbError to False
            Move False to bOk
            Move GENERIC_RANDOM to dwAccessMode
            Move FNULL to dwSharedMode
            If (num_arguments > 2) Begin
                If (bShared = True) Begin
                    Move FILE_SHARE_RANDOM to dwSharedMode
                End
            End
            Move OPEN_EXISTING to dwCreateMode
            If (num_arguments > 3) Begin
                If (bCreate = True) Begin
                    Move OPEN_ALWAYS to dwCreateMode
                End
            End
            If (num_arguments > 4) Begin
                If (bReadOnly = True) Begin
                    Move GENERIC_READ to dwAccessMode
                    If (bShared = True) Begin
                        Move FILE_SHARE_READ to dwSharedMode
                    End
                End
            End
            Move (fsCreatefile(sFilename, dwAccessMode, dwSharedMode, FNULL, dwCreateMode, FILE_ATTRIBUTE_NORMAL, FNULL)) to iReturnValue
            If (iReturnValue = INVALID_HANDLE_VALUE) Begin
                Move (fsGetLastError()) to iErrornumber
                If iErrornumber Begin
                    Send DoShowError iErrornumber ("File: "+ sFilename)
                End
            End
            Else Begin
                Move iReturnValue to lsaFile[iFilenumber].hFilehandle
                Move False to lsaFile[iFilenumber].bEndOfFile
                Set plsaFile to lsaFile
                Set pbEOF to False
                Move True to bOk
            End
        End
        Else Begin
            Send warning_box "The filenumber is already used."
        End
        Function_Return bOk
    End_Function

    
    // Closing a binary file
    // Returns true if the file could be closed.
    Function BinaryFileClose Integer iFilenumber Returns Boolean
        Integer iRetVal iErrorNumber
        Handle hHandle
        structFile[] lsaFile
        structFileBufferPointer[] lsaFileBufferPointer
        UChar[][] uaaCachedBuffer
        UChar[] uaEmpty
        Boolean bOk
        Get BinaryFileHandle iFilenumber to hHandle
        Set pbError to False
        Move False to bOk
        If hHandle Begin
            Move (fsCloseHandle(hHandle)) to iRetVal
            If (iRetVal = 0) Begin           // Could not close
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                End
            End
            Else Begin
                Get plsaFile to lsaFile
                Get plsCachedPointer to lsaFileBufferPointer
                Get puaaCachedBuffer to uaaCachedBuffer
                Move 0 to lsaFile[iFilenumber].hFilehandle
                Move uaEmpty to uaaCachedBuffer[iFilenumber]
                Move 1 to lsaFileBufferPointer[iFilenumber].iBufferPointer
                Move 0 to lsaFileBufferPointer[iFilenumber].iBufferSize
                Move 0 to lsaFileBufferPointer[iFilenumber].biFromFilePosition
                Set plsaFile to lsaFile
                Set plsCachedPointer to lsaFileBufferPointer
                Set puaaCachedBuffer to uaaCachedBuffer
                Move True to bOk
            End
        End
        Function_Return bOk
    End_Function


    // Reading text from a binary file as a text file
    // To read data from a binary file use BinaryFileReadUChar method.
    // The text read from the file and returned. It reads the whole file at once.
    // pbEOF will then be true when the file has been read.
    // pbError will then be True if an error has occured.
    Function BinaryFileReadText Integer iFilenumber Returns String
        Handle hFileHandle
        Integer iBytesRead iErrorNumber iNumberOfBytes
        Boolean bOk
        structFile[] lsaFile
        String sReadBuffer
        Get BinaryFileSize iFilenumber to iNumberOfBytes
        If (iNumberOfBytes < 1) Begin
            Send warning_box "Number of bytes to read can not be less than one."
            Function_Return sReadBuffer
        End       
        Set pbError to False
        Move 0 to iBytesRead
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            Move (ZeroString(iNumberOfBytes)) to sReadBuffer
            Move (fsReadFile(hFileHandle, AddressOf(sReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
            If (bOk = False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                End
            End
            Else Begin
                If (iBytesRead = iNumberOfBytes) Begin
                    Get plsaFile to lsaFile
                    Move True to lsaFile[iFilenumber].bEndOfFile
                    Set plsaFile to lsaFile
                    Set pbEOF to True
                End
            End
        End
        Else Begin
            Send warning_box FS_FILEHANDLEMISSING
        End
        Function_Return sReadBuffer
    End_Function

    // Reading from a binary file.
    // The data read from the file is placed in uaReadBuffer and the function returns the number of bytes read.
    // Then the function returns 0 end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
    // No errors occures if you try to read past end of file.
    // To speed up reading process you should read in a block of data at a time (i.e. iNumberOfBytes = FS_BUFFERSIZE) instead of 
    // reading one byte at a time. No errors occures if you try to read past end of file.
    Function BinaryFileReadUChar Integer iFilenumber Integer iNumberOfBytes UChar[] ByRef uaReadBuffer Returns Integer
        Handle hFileHandle
        Integer iBytesRead iMaxBuffer iErrorNumber
        Boolean bOk
        structFile[] lsaFile
        Set pbError to False
        Move 0 to iBytesRead
        If (iNumberOfBytes < 1) Begin
            Send warning_box "Number of bytes to read can not be less than one."
            Function_Return iBytesRead
        End
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            If (SizeOfArray(uaReadBuffer) <> iNumberOfBytes) Begin
                Move (ResizeArray(uaReadBuffer, iNumberOfBytes)) to uaReadBuffer
            End
            Move (fsReadFile(hFileHandle, AddressOf(uaReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
            If (bOk = False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
            End
            Else Begin
                If (iBytesRead = 0 or iBytesRead <> iNumberOfBytes) Begin
                    Set pbEOF to True
                    Get plsaFile to lsaFile
                    Move True to lsaFile[iFilenumber].bEndOfFile
                    Set plsaFile to lsaFile
                    Move (ResizeArray(uaReadBuffer, iBytesRead)) to uaReadBuffer
                End
            End
        End
        Else Begin
            Send warning_box FS_FILEHANDLEMISSING
        End
        Function_Return iBytesRead
    End_Function

    // Reading from a binary file until a search array is matched.
    // The data read from the file is placed in the uaReturnBuffer and the function returns the number of bytes read until the match is read including the match.
    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
    // The return uchar array buffer would also be empty.
    // No errors occures if you try to read past end of file.
    Function BinaryFileReadUCharUntilMatch Integer iFilenumber UChar[] uaMatchString UChar[] ByRef uaReturnBuffer Boolean ByRef bEndOfFile Returns Integer
        Handle hFileHandle
        Integer iBuffersize iMatchPos iLengthMatch
        UChar uByte
        UChar[] uaBuffer uaEmpty
        UChar[][] uaaCachedBuffer 
        structFile[] lsaFile
        structFileBufferPointer[] lsaFileBufferPointer
        Get plsaFile to lsaFile
        Move uaEmpty to uaReturnBuffer
        // ToDo: Buffer pointer is 1-based because of old text (mid()) function. Change to 0-based
        Move 1 to iMatchPos
        Move False to bEndOfFile
        If (iFilenumber < SizeOfArray(lsaFile)) Begin
            Move lsaFile[iFilenumber].hFilehandle to hFileHandle
            If (hFileHandle <> 0) Begin
                Move (SizeOfArray(uaMatchString)) to iLengthMatch
                Get plsCachedPointer to lsaFileBufferPointer
                Get puaaCachedBuffer to uaaCachedBuffer
                If (iFilenumber >= SizeOfArray(lsaFileBufferPointer)) Begin
                    Move 1 to lsaFileBufferPointer[iFilenumber].iBufferPointer
                    Move uaEmpty to uaaCachedBuffer[iFilenumber]
                End
                Repeat
                    If (lsaFileBufferPointer[iFilenumber].iBufferPointer > lsaFileBufferPointer[iFilenumber].iBufferSize) Begin
                        Move FS_BUFFERSIZE to iBuffersize
                        Get BinaryFilePosition iFilenumber to lsaFileBufferPointer[iFilenumber].biFromFilePosition
                        Get BinaryFileReadUChar iFilenumber iBuffersize (&uaaCachedBuffer[iFilenumber]) to lsaFileBufferPointer[iFilenumber].iBufferSize
                        Move 1 to lsaFileBufferPointer[iFilenumber].iBufferPointer
                        Set puaaCachedBuffer to uaaCachedBuffer
                    End
                    If (lsaFileBufferPointer[iFilenumber].iBufferPointer =< lsaFileBufferPointer[iFilenumber].iBufferSize) Begin
                        // ToDo: Change buffer pointer to 0-based
                        Move uaaCachedBuffer[iFilenumber][lsaFileBufferPointer[iFilenumber].iBufferPointer - 1] to uByte
                        Increment lsaFileBufferPointer[iFilenumber].iBufferPointer
                        Move uByte to uaReturnBuffer[SizeOfArray(uaReturnBuffer)]
                        // ToDo: Change match pointer to 0-based
                        If (uByte = uaMatchString[iMatchPos - 1]) Begin
                            Increment iMatchPos
                        End
                        Else Begin
                            Move 1 to iMatchPos
                        End
                    End
                Until (iMatchPos > iLengthMatch or lsaFileBufferPointer[iFilenumber].iBufferSize = 0)   
                Set plsCachedPointer to lsaFileBufferPointer
                If (lsaFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
                    Move lsaFile[iFilenumber].bEndOfFile to bEndOfFile
                End
            End
            Else Begin
                Send warning_box FS_FILEHANDLEMISSING
            End
        End
        Function_Return (SizeOfArray(uaReturnBuffer))
    End_Function

    // Reading text from a binary file as a text file until a search string is matched.
    // The text returns the text read until the match is read including the match.
    // Then the function returns and empty string if the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
    // No errors occures if you try to read past end of file.
    Function BinaryFileReadTextUntilMatch Integer iFilenumber String sMatchString Boolean ByRef bEndOfFile Returns String
        String sText
        UChar[] uaSearch uaReturnBuffer
        Integer iBytesRead
        Move (StringToUCharArray(sMatchString)) to uaSearch
        Get BinaryFileReadUCharUntilMatch iFilenumber uaSearch (&uaReturnBuffer) (&bEndOfFile) to iBytesRead
        Function_Return (UCharArrayToString(uaReturnBuffer))
    End_Function
    
    // Shortcut to read text lines from a binary file as a textfile.
    // Reads until sCharEOL are recieved.
    // The text is returned without the ending sCharEOL.
    // If sCharEOL is not applied the charactersequence character(13) + character(10) is used.
    // Returns True when the line has been read.
    Function BinaryFileReadLN Integer iFilenumber String ByRef sLine Boolean ByRef bEndOfFile String sCharEOL Returns Boolean
        String sEOL
        Integer iEOLLength
        Boolean bEndOfRow
        If (num_arguments > 3) Begin
            Move sCharEOL to sEOL
        End
        Else Begin
            Move CR_LF to sEOL
        End
        Get BinaryFileReadTextUntilMatch iFilenumber sEOL (&bEndOfFile) to sLine
        If (Length(sLine) > 0) Begin
            Move (Length(sEOL)) to iEOLLength
            If (Right(sLine, iEOLLength) = sEOL) Begin
                Move (Left(sLine, (Length(sLine) - iEOLLength))) to sLine
                Move True to bEndOfRow
            End
        End
        Function_Return bEndOfRow
    End_Function

    // Writing text to a binary file.
    // To write data to a binary file use BinaryFileWriteUChar method.
    // Returns true if the string was written to the file without error.
    Function BinaryFileWriteText Integer iFilenumber String ByRef sWriteData Returns Boolean
        Integer iBytesWritten iBytesToWrite iErrorNumber
        Handle hFileHandle
        Boolean bOk
        Set pbError to False
        Move False to bOk
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            Move 0 to iBytesWritten
            Move (SizeOfString(sWriteData)) to iBytesToWrite
            Move (fsWriteFile(hFileHandle, AddressOf(sWriteData), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
            If (bOk = False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
            End
            If (iBytesToWrite <> iBytesWritten) Begin
                Send Warning_box "Not all text could be written!"
                Move False to bOk
            End
        End
        Else Send warning_box FS_FILEHANDLEMISSING
        Function_Return bOk
    End_Function

    // Writing to a binary file.
    // Returns true if the data in uaWriteBuffer was written to the file without error.
    Function BinaryFileWriteUChar Integer iFilenumber UChar[] ByRef uaWriteBuffer Returns Boolean
        Integer iBytesWritten iBytesToWrite iErrorNumber
        Handle hFileHandle
        Boolean bOk
        Set pbError to False
        Move False to bOk
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            Move 0 to iBytesWritten
            Move (SizeOfArray(uaWriteBuffer)) to iBytesToWrite
            Move (fsWriteFile(hFileHandle, AddressOf(uaWriteBuffer), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
            If (bOk = False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                End
            End
            If (iBytesToWrite <> iBytesWritten) Begin
                Send Warning_box "Not all data could be written!"
                Move False to bOk
            End
        End
        Else Begin
            Send warning_box FS_FILEHANDLEMISSING
        End
        Function_Return bOk
    End_Function    


    // Write HEX values to a binary file as bytes.
    // HEX values in sWriteHEX are first coverted to bytes and then written
    // to the binary file.
    // Returns true if the HEX data was written to the file without error.
    Function BinaryFileWriteHex Integer iFilenumer String ByRef sWriteHex Returns Boolean
        UChar[] uaData
        Integer iLength iCount iDataCount iByte
        Boolean bOk
        Move (Length(sWritehex)) to iLength
        Move (ResizeArray(uaData, iLength / 2)) to uaData
        Move 1 to iCount
        Move 0 to iDataCount
        While (iCount < iLength)
            Move ("$"+Mid(sWriteHex, 2, iCount)) to uaData[iDataCount]
            Move (iCount + 2) to iCount
            Increment iDataCount
        Loop
        Get BinaryFileWriteUChar iFilenumer (&uaData) to bOk
        Function_Return bOk
    End_Function
    
    // Shortcut to write text to a binary file as a textfile.
    // Writes the string and appends character(13) and character(10) to the binary file.
    // Returns true if the data was written to the file without error.
    Function BinaryFileWriteLN Integer iFilenumber String sWriteData Returns Boolean
        Boolean bOk
        Move (sWriteData + CR_LF) to sWriteData
        Get BinaryFileWriteText iFilenumber (&sWriteData) to bOk
        Function_Return bOk
    End_Function 
    
    // Retrives the file size from a binary file.
    Function BinaryFileSize Integer iFilenumber Returns BigInt
        BigInt biFilesize
        Handle hFileHandle
        Boolean bOk
        Integer iErrorNumber
        Set pbError to False
        Move -1 to biFilesize
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            // The LARGE_INTEGER structure has the same structure as a BigInt.
            Move (fsGetFileSizeEx(hFileHandle, AddressOf(biFilesize))) to bOk
            If (bOk = -False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                End
            End
        End
        Else Begin
            Send warning_box FS_FILEHANDLEMISSING
        End
        Function_Return biFilesize
    End_Function


    // Retrives the file position from a binary file.
    // Returns -1 if an error occured.
    Function BinaryFilePosition Integer iFilenumber Returns BigInt
        BigInt biFilePosition biBigHi
        Handle hFileHandle
        Boolean bOk
        Integer iErrorNumber iLo iHi 
        UInteger iNewPos
        Set pbError to False
        Move -1 to biFilePosition
        Move 0 to iHi
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            Move (2^32) to biBigHi
            Move (fsSetFilePointer(hFileHandle, ilo, AddressOf(iHi), FILE_CURRENT)) to iNewPos
            If (iNewPos = (biBigHi - 1)) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                Else Move True to bOk
            End
            Else Move True to bOk
            If bOk Begin
                Move ((iHi * biBigHi) + iNewPos) to biFilePosition
            End
        End
        Else Send warning_box FS_FILEHANDLEMISSING
        Function_Return biFilePosition
    End_Function


    // Sets the file position from a binary file to a new position.
    Procedure Set BinaryFilePosition Integer iFilenumber BigInt biPosition
        Handle hFileHandle
        Integer iHi iErrorNumber
        UInteger iLo iNewPos
        Boolean bOk
        BigInt biFileSize biBigHi
        structFile[] lsaFile
        Set pbError to False
        Move False to bOk
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            Move (2^32) to biBigHi
            Move (biPosition / biBigHi) to iHi
            Move (biPosition - (iHi * biBigHi)) to iLo
            Move (fsSetFilePointer(hFileHandle, iLo, AddressOf(iHi), FILE_BEGIN)) to iNewPos
            If (iNewPos = (biBigHi - 1)) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                Else Move True to bOk
            End
            Else Move True to bOk
            If bOk Begin
                Get BinaryFileSize iFilenumber to biFileSize
                Get plsaFile to lsaFile
                If (biFileSize > biPosition) Begin
                    Move False to lsaFile[iFilenumber].bEndOfFile
                    Set pbEOF to False
                End
                Else Begin
                    Move True to lsaFile[iFilenumber].bEndOfFile
                    Set pbEOF to True
                End
                Set plsaFile to lsaFile
            End
        End
        Else Send warning_box FS_FILEHANDLEMISSING
        Set pbError to (not(bOk))
    End_Procedure

    // Truncate or extend a binary file to the specified file position
    // by setting the binary file End Of File position.
    // If biPosition is -1 the current file position is used as EOF position.
    Procedure Set BinaryFileEndOfFile Integer iFilenumber BigInt biPosition
        Handle hFileHandle
        Boolean bError bOk 
        Integer iErrorNumber
        structFile[] lsaFile
        Set pbError to False
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            If (biPosition > -1) Begin
                Set BinaryFilePosition iFilenumber to biPosition
            End
            Get pbError to bError
            If (bError = False) Begin
                Move (fsSetEndOfFile(hFileHandle)) to bOk
                If (bOk = False) Begin
                    Move (fsGetLastError()) to iErrorNumber
                    If iErrorNumber Begin
                        Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
                    End
                End
                Else Begin
                    Get plsaFile to lsaFile
                    Move True to lsaFile[iFilenumber].bEndOfFile
                    Set plsaFile to lsaFile
                    Set pbEOF to True
                End
            End
        End
        Else Begin
            Send warning_box FS_FILEHANDLEMISSING
        End
        Set pbError to (not(bOk))
    End_Procedure

    
    // Returns true if the last read from the binary file had reached the end.
    Function BinaryFileEndOfFile Integer iFilenumber Returns Boolean
        structFile[] lsaFile
        Handle hFileHandle
        Boolean bEndOfFile
        Move True to bEndOfFile
        Set pbError to False
        Get BinaryFileHandle iFilenumber to hFileHandle
        If hFileHandle Begin
            Get plsaFile to lsaFile
            Move lsaFile[iFilenumber].bEndOfFile to bEndOfFile
        End
        Else Begin
            Send warning_box FS_FILEHANDLEMISSING
        End
        Function_Return bEndOfFile
    End_Function
    

    // Returns the filehandle from the filenumber.
    // Returns 0 if the filenumber is not used.
    Function BinaryFileHandle Integer iFilenumber Returns Handle
        Handle hFileHandle
        structFile[] lsaFile
        Get plsaFile to lsaFile
        If (iFilenumber < SizeOfArray(lsaFile)) Begin
            Move lsaFile[iFilenumber].hFilehandle to hFileHandle
        End
        Function_Return hFileHandle
    End_Function


    // Searches for a file
    // iMode = DIRMODE_FILES_ONLY (default)
    // iMode = DIRMODE_DIRECTORIES_ONLY
    // iMode = DIRMODE_FILES_AND_DIRECTORIES
    // Returns True if found
    Function FileExists String sFilePathMask Integer iFileDirMode Returns Boolean
        Integer iMode
        Boolean bFound
        tsSearchResult[] lsResult
        Move False to bFound
        Set pbError to False
        If (num_arguments < 2) Begin
            Move DIRMODE_FILES_ONLY to iMode
        End
        Else Begin
            Move iFileDirMode to iMode
        End
        Get FileSearch sFilePathMask iMode True to lsResult
        If (SizeOfArray(lsResult) > 0) Begin
            Move True to bFound
        End
        Function_Return bFound
    End_Function       
    

    // Deletes a file.
    // Returns True if succeeds.
    Function FileDelete String sFilename Integer iRetryAttempts Returns Boolean
        Boolean bFound bDeleted
        Integer iErrorNumber iRetryLeft
        Set pbError to False
        If (num_arguments > 1) Begin
            Move iRetryAttempts to iRetryLeft
        End
        Else Begin
            Move 0 to iRetryLeft
        End
        Get FileExists sFilename to bFound
        If (bFound) Begin
            Repeat
                Move (fsDeleteFile(sFilename)) to bDeleted
                If (bDeleted = False) Begin     
                    Decrement iRetryLeft
                    If (iRetryLeft <= 0) Begin
                        Move (fsGetLastError()) to iErrorNumber
                        If iErrorNumber Begin
                            Send DoShowError iErrorNumber ("Tried to delete file: "+sFilename)
                        End
                    End
                    Else Begin
                        Sleep 1
                    End
                End
            Until (bDeleted = True or iRetryLeft <= 0)
        End
        Function_Return bDeleted
    End_Function


    // Moves a file or directory.
    // Returns True if succeeds.
    Function FileMove String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
        Boolean bMoved
        Integer iErrorNumber iRetryLeft
        Set pbError to False
        If (num_arguments > 2) Begin
            Move iRetryAttempts to iRetryLeft
        End
        Else Begin
            Move 0 to iRetryLeft
        End
        Repeat
            Move (fsMoveFile(sExistingFileName, sNewFileName)) to bMoved
            If (bMoved = False) Begin           
                Decrement iRetryLeft
                If (iRetryLeft <= 0) Begin
                    Move (fsGetLastError()) to iErrorNumber
                    If iErrorNumber Begin
                        Send DoShowError iErrorNumber (SFormat("Tried to move/rename: file %1 to %2", sExistingFileName, sNewFileName))
                    End
                End
                Else Begin
                    Sleep 1
                End
            End
        Until (bMoved = True or iRetryLeft <= 0)
        Function_Return bMoved
    End_Function


    // Copies a file. Overwriting an existing file by default.
    // Returns True if succeeds.
    Function FileCopy String sExistingFileName String sNewFileName Boolean bFailIfExists Integer iRetryAttempts Returns Boolean
        Boolean bCopied bDoNotOverwrite
        Integer iErrorNumber iRetryLeft
        Set pbError to False
        If (Num_Arguments > 2) Begin
            Move bFailIfExists to bDoNotOverwrite
        End
        Else Begin
            Move False to bDoNotOverwrite
        End
        If (num_arguments > 3) Begin
            Move iRetryAttempts to iRetryLeft
        End
        Else Begin
            Move 0 to iRetryLeft
        End
        Repeat
            Move (fsCopyFile(sExistingFileName, sNewFileName, bDoNotOverwrite)) to bCopied
            If (bCopied = False) Begin  
                Decrement iRetryLeft
                If (iRetryLeft <= 0) Begin
                    Move (fsGetLastError()) to iErrorNumber
                    If iErrorNumber Begin
                        Send DoShowError iErrorNumber ("Tried to copy file: "+sExistingFileName+" to "+sNewFileName)
                    End
                End
                Else Begin
                    Sleep 1
                End
            End
        Until (bCopied = True or iRetryLeft <= 0)
        Function_Return bCopied
    End_Function


    // Renames a file or directory.
    // Returns True if succeeds.
    Function FileRename String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
        Boolean bRenamed
        If (num_arguments > 2) Begin
            Get FileMove sExistingFileName sNewFileName iRetryAttempts to bRenamed
        End
        Else Begin
            Get FileMove sExistingFileName sNewFileName to bRenamed
        End
        Function_Return bRenamed
    End_Function


    // Returns the file size of a file.
    // Returns -1 if an error occured.
    CompilerLevelWarning AmbiguousFunctions Off 
    // A function with the same name name is defined in the DF packages but with Integer as return value.
    // To avoid any problems always use Get FileSize of oFilesystem sFilename to biSize instead of Move (Filesize(oFilesystem, sFilename)) to biSize
    Function FileSize String sFilename Returns BigInt
        tsSearchResult[] lsSearchResult
        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
        If (SizeOfArray(lsSearchResult) > 0) Begin
            Function_Return lsSearchResult[0].biFileSize
        End
        Function_Return -1
    End_Function
    CompilerLevelWarning AmbiguousFunctions On


    // Returns the last write date of a file.
    // Returns 0 if an error occured.
    Function FileDate String sFilename Returns Date
        tsSearchResult[] lsSearchResult
        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
        If (SizeOfArray(lsSearchResult) > 0) Begin
            Function_Return lsSearchResult[0].dtLastWriteDateTime
        End
        Function_Return 0
    End_Function


    // Returns the fileversion info.
    // Returns false if an error occured.
    Function FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Boolean
        Boolean bOk
        Integer iErrorNumber iStatus
        Get _FileVersion sFilename (&lsFileVersionInfo) to iStatus
        If (iStatus = -1) Begin
            Move (fsGetLastError()) to iErrorNumber
            If iErrorNumber Begin
                Send DoShowError iErrorNumber ("Tried to get fileversion info from file: "+sFilename)
            End
        End
        Move (iStatus = 0) to bOk
        Function_Return bOk
    End_Function
        
    {Visibility = Private}
    Function _FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Integer
        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
        UInteger iBytesNeeded
        Pointer lpBuffer  
        Boolean bOk
        String sSubBlock
        DWord dwBufferLen dwBufferPointer
        tsLandAndCodePage lsLandAndCodePage
        Move 0 to iBytesNeeded
        Move 0 to lsFIXEDFILEINFO.dwStrucVersion    // Initialize the variable.
        Move 0 to lsLandAndCodePage.wCodePage
        Move (fsGetFileVersionInfoSize(sFilename, 0)) to iBytesNeeded
        If (iBytesNeeded = 0) Begin
            Function_Return 0
        End
        Move False to bOk
        Move (Alloc(iBytesNeeded)) to lpBuffer
        Move (MemSet(lpBuffer, 0, iBytesNeeded)) to bOk
        Move (fsGetFileVersionInfo(sFilename, 0, iBytesNeeded, lpBuffer)) to bOk
        If (not(bOk)) Begin
            Move (Free(lpBuffer)) to bOk
            Function_Return -1
        End
        Move "\" to sSubBlock
        Move 0 to dwBufferLen
        Move 0 to dwBufferPointer
        Move (fsVerQueryValue(lpBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
        If (not(bOk)) Begin
            Move (Free(lpBuffer)) to bOk
            Function_Return -1
        End
        If (dwBufferLen <> 52) Begin
            Send warning_box (SFormat("Length of bufferdata for VS_FIXEDFILEINFO struct are not in the expected size.\nLength is %1 and should have been 52.", dwBufferLen))
            Move (Free(lpBuffer)) to bOk
            Function_Return -2
        End
        Move (MemCopy(AddressOf(lsFIXEDFILEINFO), dwBufferPointer, dwBufferLen)) to bOk
        If (not(bOk)) Begin
            Move (Free(lpBuffer)) to bOk
            Function_Return -1
        End
        Move lsFIXEDFILEINFO to lsFileVersionInfo.lsFIXEDFILEINFO
        Get ConvertFileTimeToLocalDateTime lsFIXEDFILEINFO.ubiFileDate to lsFileVersionInfo.dtCreationDateTime
        Move (Hi(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[0]
        Move (Low(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[1]
        Move (Hi(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[2]
        Move (Low(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[3]
        Move (Hi(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[0]
        Move (Low(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[1]
        Move (Hi(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[2]
        Move (Low(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[3]
        Move "\VarFileInfo\Translation" to sSubBlock
        Move 0 to dwBufferLen
        Move 0 to dwBufferPointer
        Move (fsVerQueryValue(lpBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
        If (not(bOk)) Begin
            Move (Free(lpBuffer)) to bOk
            Function_Return -1
        End
        If (dwBufferLen <> 4) Begin
            Send warning_box (SFormat("Length of bufferdata for land and codepage nunbers are not in the expected size.\nLength is %1 and should have been 4.", dwBufferLen))
            Move (Free(lpBuffer)) to bOk
            Function_Return -2
        End
        Move (MemCopy(AddressOf(lsLandAndCodePage), dwBufferPointer, dwBufferLen)) to bOk
        Get VerQueryValueStringFileInfo lpBuffer "Comments" lsLandAndCodePage to lsFileVersionInfo.sComments
        Get VerQueryValueStringFileInfo lpBuffer "CompanyName" lsLandAndCodePage to lsFileVersionInfo.sCompanyName
        Get VerQueryValueStringFileInfo lpBuffer "FileDescription" lsLandAndCodePage to lsFileVersionInfo.sFileDescription
        Get VerQueryValueStringFileInfo lpBuffer "FileVersion" lsLandAndCodePage to lsFileVersionInfo.sFileVersion
        Get VerQueryValueStringFileInfo lpBuffer "InternalName" lsLandAndCodePage to lsFileVersionInfo.sInternalName
        Get VerQueryValueStringFileInfo lpBuffer "LegalCopyright" lsLandAndCodePage to lsFileVersionInfo.sLegalCopyright
        Get VerQueryValueStringFileInfo lpBuffer "LegalTrademarks" lsLandAndCodePage to lsFileVersionInfo.sLegalTrademarks
        Get VerQueryValueStringFileInfo lpBuffer "OriginalFilename" lsLandAndCodePage to lsFileVersionInfo.sOriginalFilename
        Get VerQueryValueStringFileInfo lpBuffer "ProductName" lsLandAndCodePage to lsFileVersionInfo.sProductName
        Get VerQueryValueStringFileInfo lpBuffer "ProductVersion" lsLandAndCodePage to lsFileVersionInfo.sProductVersion
        Get VerQueryValueStringFileInfo lpBuffer "PrivateBuild" lsLandAndCodePage to lsFileVersionInfo.sPrivateBuild
        Get VerQueryValueStringFileInfo lpBuffer "SpecialBuild" lsLandAndCodePage to lsFileVersionInfo.sSpecialBuild
        Move (Free(lpBuffer)) to bOk
        Function_Return 0
    End_Function

    Register_Function ShortToHex Short siValue Returns String
    {Visibility = Private}
    Function VerQueryValueStringFileInfo Pointer lpBuffer String sInfoName tsLandAndCodePage lsLandAndCodePage Returns String
        String sSubBlock
        String sValue
        DWord dwBufferLen dwBufferPointer
        Boolean bOk
        Move (SFormat("\StringFileInfo\%1%2\%3", ShortToHex(Self, lsLandAndCodePage.wLanguage), ShortToHex(Self, lsLandAndCodePage.wCodePage), sInfoName)) to sSubBlock
        Move 0 to dwBufferLen
        Move 0 to dwBufferPointer
        Move (fsVerQueryValue(lpBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
        If (not(bOk)) Begin
            Function_Return ""
        End
        Move (PointerToWString(dwBufferPointer)) to sValue  // Auto convert from wstring to string.
        Function_Return sValue
    End_Function
    
    
    // Returns the files status for the readonly attribute.
    Function FileReadOnly String sFilename Returns Boolean
        Integer iFileAttributes
        Boolean bReadonly
        Get FileAttributes sFilename to iFileAttributes
        If (iFileAttributes <> -1) Begin
            Move (IsFlagIn(FILE_ATTRIBUTE_READONLY, iFileAttributes)) to bReadonly
        End
        Function_Return bReadonly
    End_Function
    
    
    // Sets the files status for the readonly attribute.
    Procedure Set FileReadOnly String sFilename Boolean bProtected
        Integer iFileAttributes
        Get FileAttributes sFilename to iFileAttributes
        If (iFileAttributes <> -1) Begin
            If (bProtected) Begin
                Move (AddBitValue(FILE_ATTRIBUTE_READONLY, iFileAttributes)) to iFileAttributes
            End
            Else Begin
                Move (RemoveBitValue(FILE_ATTRIBUTE_READONLY, iFileAttributes)) to iFileAttributes
            End
            Set FileAttributes sFilename to iFileAttributes
        End
    End_Procedure
    
    
    // Returns the files status for the hidden attribute.
    Function FileHidden String sFilename Returns Boolean
        Integer iFileAttributes
        Boolean bHidden
        Get FileAttributes sFilename to iFileAttributes
        If (iFileAttributes <> -1) Begin
            Move (IsFlagIn(FILE_ATTRIBUTE_HIDDEN, iFileAttributes)) to bHidden
        End
        Function_Return bHidden
    End_Function
    
    
    // Sets the files status for the hidden attribute.
    Procedure Set FileHidden String sFilename Boolean bProtected
        Integer iFileAttributes
        Get FileAttributes sFilename to iFileAttributes
        If (iFileAttributes <> -1) Begin
            If (bProtected) Begin
                Move (AddBitValue(FILE_ATTRIBUTE_HIDDEN, iFileAttributes)) to iFileAttributes
            End
            Else Begin
                Move (RemoveBitValue(FILE_ATTRIBUTE_HIDDEN, iFileAttributes)) to iFileAttributes
            End
            Set FileAttributes sFilename to iFileAttributes
        End
    End_Procedure

    
    // Returns all the attributes of the file.
    // Returns -1 if the attributes could not be retrived.
    Function FileAttributes String sFilename Returns Integer
        Integer iFileAttributes
        tsSearchResult[] lsSearchResult
        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
        If (SizeOfArray(lsSearchResult) > 0) Begin
            Move lsSearchResult[0].iFileAttributes to iFileAttributes
        End        
        Else Begin
            Move -1 to iFileAttributes
        End
        Function_Return iFileAttributes
    End_Function 


    // Sets all the attributes of the file.
    Procedure Set FileAttributes String sFilename Integer iAttributes
        Boolean bOk
        Integer iErrorNumber
        Move False to bOk
        Move (fsSetFileAttributes(sFilename, iAttributes)) to bOk
        If (not(bOk)) Begin
            Move (fsGetLastError()) to iErrorNumber
            If iErrorNumber Begin
                Send DoShowError iErrorNumber ("Tried to set fileattributes for file: "+sFilename)
            End
        End
    End_Procedure
    
    
    // Convert an short integer to a 4-character hex string.
    Function ShortToHex Short siValue Returns String
        String sHex
        Move "" to sHex
        Repeat
            Move (Mid ("0123456789ABCDEF", 1, ((siValue iand |CI$0F) + 1)) + sHex) to sHex
            Move (siValue / |CI$10) to siValue
        Until (siValue = 0)
        Move (Right("0000" + sHex, 4)) to sHex
        Function_Return sHex
    End_Function


    // Returns the file extention without the leading "."
    // Example sFile = "x:\text.txt". The function returns "txt".
    Function FileExtention String sFilename Returns String
        String sExtention
        Integer iPos
        Move (RightPos(".", sFilename)) to iPos
        If (iPos > 0) Begin
            Move (Right(sFilename, (Length(sFilename) - iPos))) to sExtention
            If (sExtention contains "\" or sExtention contains " ") Begin
                Move "" to sExtention
            End
        End
        Function_Return sExtention
    End_Function


    // Gets a handle to an icon stored as a resource in a file or an icon 
    // stored in a file's associated executable file.
    // When the icon handle is no longer needed, close it by using the DestroyFileIcon procedure.
    Function FileIcon String sFilename Returns Handle
        Handle hIcon    
        DWord dwIcon 
        Move 0 to dwIcon       
        Move (Pad(sFilename, MAX_PATH)) to sFilename
        Move (fsExtractAssociatedIcon(0, sFilename, AddressOf(dwIcon))) to hIcon    
        Function_Return hIcon
    End_Function
    
    // Destroy hIcon, created from FileIcon.
    Procedure DestroyFileIcon Handle hIcon
        Integer iResult
        If (hIcon <> 0) Begin
            Move (fsDestroyIcon(hIcon)) to iResult
        End
    End_Procedure
    
    // Returns the file name without the path.
    // Example sFilename = "x:\PathToFile\File.txt". The function returns "File.txt".
    Function FileName String sFilename Returns String
        String sFilenameOnly sDirSep
        Integer iPos
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Move (RightPos(sDirSep, sFilename)) to iPos
        If (iPos > 0) Begin
            Move (Right(sFilename, (Length(sFilename) - iPos))) to sFilenameOnly
        End
        Function_Return sFilenameOnly
    End_Function
    
    
    // Returns the file path without the filename. Does not return ending directory separator.
    // Example sFilename = "x:\PathToFile\File.txt". The function returns "x:\PathToFile".
    Function FilePath String sFilename Returns String
        String sPathOnly sDirSep
        Integer iPos
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Move (RightPos(sDirSep, sFilename)) to iPos
        If (iPos > 0) Begin
            Move (Left(sFilename, iPos - 1)) to sPathOnly
        End
        Function_Return sPathOnly
    End_Function
    
    
    // Returns the full path and file name of the specified file.
    // This takes the relative path build from the current application path.
    Function FullPathName String sFilename Returns String
        String sAppPath sFullPath sOldCurrentDir
        Boolean bChanged
        Integer iResult iErrorNumber
        UShort[MAX_PATH] uaBuffer
        If (ghoApplication) Begin
            Get GetApplicationPath of ghoApplication to sAppPath
            Get_Current_Directory to sOldCurrentDir
            If (sOldCurrentDir <> sAppPath) Begin
                Set_Directory sAppPath
                Move True to bChanged
            End
            Move 0 to iResult
            Move (fsGetFullPathName(sFilename, MAX_PATH, AddressOf(uaBuffer), FNULL)) to iResult
            If (iResult = 0) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber ("File: "+sFilename)
                End
            End
            Else Begin
                Move (PointerToWString(AddressOf(uaBuffer))) to sFullPath
            End
            If (bChanged) Begin
                Set_Directory sOldCurrentDir
            End
        End
        Function_Return sFullPath
    End_Function
    
    
    // Search a directory for the files with normal windows mask-signs
    // Returns an array of matching files and directories
    // iMode = DIRMODE_FILES_ONLY
    // iMode = DIRMODE_DIRECTORIES_ONLY
    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
    // If bReturnOnlyOne is true only one search result item is returned. 
    // If bReturnOnlyOne is true and no items where found no error is shown.
    // If bSkipRelativePaths is true and iMode = DIRMODE_DIRECTORIES_ONLY or DIRMODE_FILES_AND_DIRECTORIES search results that contains 
    //  "." or ".." are not returned in the array.
    Function FileSearch String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Boolean bSkipRelativePaths Returns tsSearchResult[]
        tsSearchResult[] lsSearchResult
        Integer iSearchResultCount iMode iErrorNumber iFileNameOffset iAltFileNameOffset
        structWFDW lsFindData
        String sTempFilename
        Handle hFindFile
        Boolean bError bStop bFound bOk bOnlyOne bNoRelativePaths
        BigInt biBigHi
        Pointer lpFindData
        If (num_arguments < 2) Begin
            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
        End
        Else begin
            Move iFileDirMode to iMode
        End
        If (num_arguments < 3) Begin
            Move False to bOnlyOne
        End
        Else Begin
            Move bReturnOnlyOne to bOnlyOne
        End
        If (num_arguments < 4) Begin
            Move False to bNoRelativePaths
        End
        Else Begin
            Move bSkipRelativePaths to bNoRelativePaths
        End
        Move 0 to lsFindData.dwFileAttributes   // Initialize lsFindData
        Move (fsFindFirstFile(sFilePathMask, AddressOf(lsFindData))) to hFindFile
        If (hFindFile <> INVALID_HANDLE_VALUE) Begin
            Move False to bError
            Move False to bStop
            Move (2^32) to biBigHi
            Move (SizeOfType(structWFDW) - (MAX_PATH * 2) - (MAX_ALTPATH * 2)) to iFileNameOffset
            Move (SizeOfType(structWFDW) - (MAX_ALTPATH * 2)) to iAltFileNameOffset
            Set pbError to bError
            While (bError = False and bStop = False) 
                Move False to bFound
                Case Begin
                    Case (iMode = DIRMODE_FILES_ONLY)
                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = 0) Begin
                            Move True to bFound
                        End
                        Case Break
                    Case (iMode = DIRMODE_DIRECTORIES_ONLY)
                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = FILE_ATTRIBUTE_DIRECTORY) Begin
                            Move True to bFound
                        End
                        Case Break
                     Case Else
                        Move True to bFound
                        Case Break
                Case End
                If (bFound = True and iMode <> DIRMODE_FILES_ONLY) Begin
                    If (bFound = True and bNoRelativePaths = True) Begin
                        If (lsFindData.cFileName[0] = 46 and lsFindData.cFileName[1] = 0) Begin
                            Move False to bFound
                        End
                        Else If (lsFindData.cFileName[0] = 46 and lsFindData.cFileName[1] = 46 and lsFindData.cFileName[2] = 0) Begin
                             Move False to bFound
                        End
                    End
                End
                If bFound Begin
                    Move (AddressOf(lsFindData)) to lpFindData
                    Move (PointerToWString(lpFindData + iFileNameOffset)) to lsSearchResult[iSearchResultCount].sFilename // Auto convert from wstring to string.
                    Move (PointerToWString(lpFindData + iAltFileNameOffset)) to lsSearchResult[iSearchResultCount].sAlternateFileName   // Auto convert from wstring to string.
                    Move lsFindData.dwFileAttributes to lsSearchResult[iSearchResultCount].iFileAttributes
                    Get ConvertFileTimeToLocalDateTime lsFindData.ftCreationDateTime to lsSearchResult[iSearchResultCount].dtCreationDateTime
                    Get ConvertFileTimeToLocalDateTime lsFindData.ftLastAccessDateTime to lsSearchResult[iSearchResultCount].dtLastAccessDateTime
                    Get ConvertFileTimeToLocalDateTime lsFindData.ftLastWriteDateTime to lsSearchResult[iSearchResultCount].dtLastWriteDateTime
                    Move ((lsFindData.nFileSizeHigh * biBigHi) + lsFindData.nFileSizeLow) to lsSearchResult[iSearchResultCount].biFileSize
                    Increment iSearchResultCount 
                    If (bOnlyOne) Begin
                        Move True to bStop
                    End
                End
                If (bStop = False) Begin
                    Move (fsFindNextFile(hFindFile, AddressOf(lsFindData))) to bOk
                End
                If (bOk = False) Begin
                    Move True to bStop
                    If (bOnlyOne = False) Begin
                        Move (fsGetLastError()) to iErrorNumber
                        If (iErrorNumber <> ERROR_NO_MORE_FILES and iErrorNumber <> ERROR_MOD_NOT_FOUND and iErrorNumber <> 0) Begin
                            Send DoShowError iErrorNumber ("Search path: "+sFilePathMask)
                        End
                    End
                End
                Get pbError to bError
            Loop
            Move (fsFindClose(hFindFile)) to bOk
        End
        Function_Return lsSearchResult
    End_Function


    // Search a directory and all subdirectories for the files with normal windows mask-signs.
    // lsResult[?].sFileName contains full path and filename.
    // iMode = DIRMODE_FILES_ONLY
    // iMode = DIRMODE_DIRECTORIES_ONLY
    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
    Function FileSearchRecursive String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
        Integer iMode
        Boolean bOnlyOne
        tsSearchResult[] lsFinalResult lsSearchResult
        If (num_arguments < 2) Begin
            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
        End
        Else Begin
            Move iFileDirMode to iMode
        End
        If (num_arguments < 3) Begin
            Move False to bOnlyOne
        End
        Else Begin
            Move bReturnOnlyOne to bOnlyOne
        End
        Get FileSearchRecursivePriv sFilePathMask iMode bOnlyOne (&lsFinalResult) to lsSearchResult
        Function_Return lsFinalResult
    End_Function
    
    {Visibility = Private}
    Function FileSearchRecursivePriv String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne tsSearchResult[] ByRef lsFinalResult Returns tsSearchResult[]
        tsSearchResult[] lsSearchResultDir lsSearchResult
        Integer iMax iCnt iLast iFinalMax
        String sSearchInDir sFileMask
        Boolean bStop
        Move (RightPos("\", sFilePathMask)) to iLast
        If (iLast > 0) Begin
            Move (Left(sFilePathMask, iLast - 1)) to sSearchInDir
            Move (Mid(sFilePathMask, Length(sFilePathMask), iLast + 1)) to sFileMask
        End
        Get FileSearch (sSearchInDir + "\*.*") DIRMODE_DIRECTORIES_ONLY to lsSearchResultDir
        Move (SizeOfArray(lsSearchResultDir)) to iMax
        Move 0 to iCnt
        While (iCnt < iMax and bStop = False)
            If (lsSearchResultDir[iCnt].sFilename <> "." and lsSearchResultDir[iCnt].sFilename <> "..") Begin
                Get FileSearchRecursivePriv (sSearchInDir + "\" + lsSearchResultDir[iCnt].sFilename + "\" + sFileMask) iFileDirMode bReturnOnlyOne (&lsFinalResult) to lsSearchResult
            End
            Increment iCnt
            If (bReturnOnlyOne = True) Begin
                If (SizeOfArray(lsFinalResult) > 0) Begin
                    Move True to bStop
                End
            End
        Loop
        If (bStop = False) Begin
            Get FileSearch sFilePathMask iFileDirMode to lsSearchResult
            Move (SizeOfArray(lsSearchResult)) to iMax
            Move (SizeOfArray(lsFinalResult)) to iFinalMax
            Move 0 to iCnt
            While (iCnt < iMax and bStop = False)
                Move lsSearchResult[iCnt] to lsFinalResult[iFinalMax]
                Move (sSearchInDir + "\" + lsSearchResult[iCnt].sFilename) to lsFinalResult[iFinalMax].sFilename
                Increment iFinalMax
                Increment iCnt
                If (bReturnOnlyOne = True) Begin
                    If (SizeOfArray(lsFinalResult) > 0) Begin
                        Move True to bStop
                    End
                End
            End
        End
        Function_Return lsSearchResult
    End_Function
    

    // Finds a list of files.
    // sSearchFiles is a list of files to search for separated by semicolon (;).
    // sSearchFiles may not contain paths but may contain wildcards.
    // sSearchPaths may only contain paths.
    // Returns a string array with the files
    // Returns only files with full path.                   
    // Use:
    // Get ListOfFiles "path1;path2" "*.txt;*.asc"
    // This will return all the .txt and .asc files with full path that exists in path1 and path2.
    Function ListOfFiles String sSearchPaths String sSearchFiles Returns String[]
        String[] saFileList                    
        Integer iFilelistCount iSearchFilesCount iCurSearchFile
        Integer iSearchPathsCount iCurSearchPath iFilesFound iCurFileFound
        String sCurSearchFile sCurSearchPath 
        tsSearchResult[] lsSearchResult
        Get CountOfFields sSearchPaths to iSearchPathsCount
        Get CountOfFields sSearchFiles to iSearchFilesCount   
        If (iSearchFilesCount > 0 and iSearchPathsCount > 0) Begin 
            For iCurSearchFile from 1 to iSearchFilesCount
                Get FieldAtIndex sSearchFiles iCurSearchFile to sCurSearchFile
                Move (Trim(sCurSearchFile)) to sCurSearchFile
                If (sCurSearchFile <> "") Begin    
                    For iCurSearchPath from 1 to iSearchPathsCount     
                        Get FieldAtIndex sSearchPaths iCurSearchPath to sCurSearchPath
                        Get AddFolderSeperator sCurSearchPath to sCurSearchPath
                        Get FileSearch (sCurSearchPath + sCurSearchFile) DIRMODE_FILES_ONLY to lsSearchResult
                        Move (SizeOfArray(lsSearchResult)) to iFilesFound
                        Decrement iFilesFound
                        For iCurFileFound from 0 to iFilesFound
                            Move (sCurSearchPath + lsSearchResult[iCurFileFound].sFilename) to saFileList[iFilelistCount]
                            Increment iFilelistCount
                        Loop
                    Loop
                End
            Loop
        End
        Function_Return saFileList
    End_Function


    // Get Windows Temp path
    Function FileTempPath Returns String
        Integer iRetVal
        WString sTempPath
        Move (ZeroString(MAX_PATH + 1)) to sTempPath    // Auto convert from string to wstring.
        Move (fsGetTempPath(MAX_PATH + 1, AddressOf(sTempPath))) to iRetVal
        Function_Return (CString(sTempPath))   // Auto convert from wstring to string.
    End_Function


    // Generates a temporary file.
    // Returns full path and filename or blank if no file could be created.
    // sPathName is the place where the temporary file is generated. If it is
    // not argumented the TEMP enviroment variable is used. If that is also not
    // available the current directory is used.
    // You can prefix the first 3 letters of the filename with sPrefix.
    // sPrefix may only be in the OEM defined character set.
    Function FileTempFileName String sPathName String sPrefix Returns String
        String sPathNameTmp sPrefixTmp 
        Boolean bOk
        WString sTempFileName
        Set pbError to False
        If (num_arguments > 0) Begin
            Move (Trim(sPathName)) to sPathNameTmp
        End
        Else Begin
            Move "" to sPathNameTmp
        End
        If (num_arguments > 1) Begin
            Move sPrefix to sPrefixTmp
        End
        Else Begin
            Move "" to sPrefixTmp
        End
        If (sPathNameTmp = "") Begin
            Get FileTempPath to sPathNameTmp
            If (sPathNameTmp = "") Begin
                Move "." to sPathNameTmp
            End
        End
        Move (ZeroString(MAX_PATH)) to sTempFilename    // Auto convert from string to wstring.
        Move (fsGetTempFileName(sPathNameTmp, sPrefixTmp, 0, AddressOf(sTempFileName))) to bOk
        If bOk Begin
            Function_Return (CString(sTempFileName))    // Auto convert from wstring to string.
        End
        Function_Return ""
    End_Function

    // Returns the filename with full path where the casing is preserved from windows.
    Function FilePreservedFilename String sFilename Returns String
        Integer iNumOfDirectories iCurrentDirectory iSearchMode
        String sPreservedFilename sCurDir sSearchName sDirSep
        tsSearchResult[] lsaSearchResult
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Get CountOfFields sFilename sDirSep to iNumOfDirectories
        For iCurrentDirectory from 1 to (iNumOfDirectories - 1)
            Get FieldAtIndex sFilename iCurrentDirectory sDirSep to sCurDir
            If (sCurDir <> "") Begin
                If (Right(sCurDir, 1) <> ":") Begin
                    Move (sPreservedFilename + sCurDir) to sSearchName
                    Get FileSearch sSearchName DIRMODE_DIRECTORIES_ONLY to lsaSearchResult
                    If (SizeOfArray(lsaSearchResult) > 0) Begin
                        Move (sPreservedFilename + lsaSearchResult[0].sFilename + sDirSep) to sPreservedFilename
                    End
                    Else Begin
                        Move (sPreservedFilename + sCurDir + sDirSep) to sPreservedFilename
                    End
                End
                Else Begin
                    Move (sPreservedFilename + sCurDir + sDirSep) to sPreservedFilename
                End
            End
            Else Begin
                Move (sPreservedFilename + sDirSep) to sPreservedFilename
            End
        Loop
        Get FileSearch sFilename DIRMODE_FILES_AND_DIRECTORIES to lsaSearchResult
        If (SizeOfArray(lsaSearchResult) > 0) Begin
            Move (sPreservedFilename + lsaSearchResult[0].sFilename) to sPreservedFilename
        End
        Else Begin
            Function_Return ""
        End
        Function_Return sPreservedFilename
    End_Function
    

    // Creates a new directory.
    // Returns True if succeeds.
    Function DirectoryCreate String sDirectoryName Returns Boolean
        Boolean bFound bOk
        Integer iErrorNumber
        Move False to bOk
        Set pbError to False
        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
        If (not(bFound)) Begin
            Move (fsCreateDirectory(sDirectoryName, FNULL)) to bOk
            If (bOk = False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber ("Tried to create directory: "+sDirectoryname)
                End
            End
        End
        Function_Return bOk
    End_Function

    // Creates a new directory and all missing parent directories in the sPath.
    // If the sPath contains a filename set bPathContainsFileName to true. This will create all the parent directories for the filename. The filename itself will not be created.
    // If a parent directory already exists it will be skipped.
    // Requires an absolute path.
    // Returns true if all the directories could be created or was already created.
    Function DirectoryCreateEx String sPath Boolean bPathContainsFileName Returns Boolean
        Boolean bOk bExists bFilePath
        Integer iPos iDirSepLength
        String sCurrentPath sDirSep
        If (num_arguments > 1) Begin
            Move bPathContainsFileName to bFilePath
        End
        If (bFilePath) Begin
            Get FilePath sPath to sPath
        End
        Get RemoveFolderSeperator sPath to sPath
        Get FileExists sPath DIRMODE_DIRECTORIES_ONLY to bExists
        If (bExists) Begin
            Function_Return True
        End
        Get AddFolderSeperator sPath to sPath
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Move (Length(sDirSep)) to iDirSepLength
        Move True to bOk
        // Check for absolute path an skip device or volume.
        Move (Pos((":" + sDirSep), sPath)) to iPos
        If (iPos > 0) Begin
            Increment iPos
        End
        Else Begin
            // UNC path
            If (Left(sPath, 2) = "\\") Begin
                // Host name
                Move (Pos("\", sPath, 3)) to iPos
                If (iPos > 0) Begin
                    Increment iPos
                    // Share name
                    Move (Pos("\", sPath, iPos)) to iPos
                    If (iPos > 0) Begin
                        Increment iPos
                    End
                End
            End
        End
        If (iPos = 0) Begin
            Send warning_box (SFormat("The path %1 is not an absolute path.", sPath))
            Function_Return False
        End
        While (iPos > 0 and bOk)
            Move (Pos(sDirSep, sPath, iPos + iDirSepLength)) to iPos
            If (iPos > 0) Begin
                Move (Left(sPath, (iPos - 1))) to sCurrentPath
                Get FileExists sCurrentPath DIRMODE_DIRECTORIES_ONLY to bExists
                If (not(bExists)) Begin
                    Get DirectoryCreate sCurrentPath to bOk
                End
            End
        Loop
        Function_Return bOk
    End_Function

    // Removes an existing empty directory.
    // Returns True if succeeds.
    Function DirectoryRemove String sDirectoryName Returns Boolean
        Boolean bFound bOk
        Integer iErrorNumber
        Move False to bOk
        Set pbError to False
        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
        If bFound Begin
            Move (fsRemoveDirectory(sDirectoryName)) to bOk
            If (bOk = False) Begin
                Move (fsGetLastError()) to iErrorNumber
                If iErrorNumber Begin
                    Send DoShowError iErrorNumber ("Tried to remove directory: "+sDirectoryName)
                End
            End
        End
        Function_Return bOk
    End_Function
    
    
    // Removes a directory and all its contents.
    // Returns true on succes.
    Function DirectoryRemoveRecursive String sDirectoryName Returns Boolean
        tsSearchResult[] lsaSearchResult
        Integer iIndex
        Boolean bOk bExists
        String sDirSep
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Get RemoveFolderSeperator sDirectoryName to sDirectoryName
        Get FileSearch (SFormat("%1%2*", sDirectoryName, sDirSep)) DIRMODE_DIRECTORIES_ONLY to lsaSearchResult
        For iIndex from 2 to (SizeOfArray(lsaSearchResult) - 1)
            Get DirectoryRemoveRecursive (SFormat("%1%2%3", sDirectoryName, sDirSep, lsaSearchResult[iIndex].sFilename)) to bOk
            If (not(bOk)) Begin
                Function_Return False
            End
        Loop
        Get FileSearch (SFormat("%1%2*", sDirectoryName, sDirSep)) DIRMODE_FILES_ONLY to lsaSearchResult
        For iIndex from 0 to (SizeOfArray(lsaSearchResult) - 1)
            Get FileDelete (SFormat("%1%2%3", sDirectoryName, sDirSep, lsaSearchResult[iIndex].sFilename)) 3 to bOk
            If (not(bOk)) Begin
                Function_Return False
            End
        Loop
        Get DirectoryRemove sDirectoryName to bOk
        Function_Return bOk
    End_Function

    
    // Returns true if the directory does not contain any subdirectories or files.
    Function DirectoryIsEmpty String sDirectoryName Returns Boolean
        tsSearchResult[] lsaSearchResult
        Boolean bEmpty
        Get AddFolderSeperator sDirectoryName to sDirectoryName
        Get FileSearch (sDirectoryName + "*") DIRMODE_FILES_AND_DIRECTORIES True True to lsaSearchResult
        Move (SizeOfArray(lsaSearchResult) = 0) to bEmpty
        Function_Return bEmpty
    End_Function

    // Converts the filetime in UTC and returns a datetime in local time.
    {Visibility = Private}
    Function ConvertFileTimeToLocalDateTime UBigInt ubiFileTime Returns DateTime
        Boolean bOk
        UBigInt ubiZero
        structSystemTime lsSystemTime lsLocalTime
        DateTime dtLocalTime
        Move 0 to lsSystemTime.wDay
        Move 0 to lsLocalTime.wDay
        Move 0 to ubiZero
        If (ubiFileTime <> ubiZero) Begin
            Move (fsFileTimeToSystemTime(AddressOf(ubiFileTime), AddressOf(lsSystemTime))) to bOk
            If bOk Begin
                Move (fsSystemTimeToTzSpecificLocalTime(FNULL, AddressOf(lsSystemTime), AddressOf(lsLocalTime))) to bOk
                If bOk Begin
                    Move (DateSetYear(dtLocalTime, lsLocalTime.wYear)) to dtLocalTime
                    Move (DateSetMonth(dtLocalTime, lsLocalTime.wMonth)) to dtLocalTime
                    Move (DateSetDay(dtLocalTime, lsLocalTime.wDay)) to dtLocalTime
                    Move (DateSetHour(dtLocalTime, lsLocalTime.wHour)) to dtLocalTime
                    Move (DateSetMinute(dtLocalTime, lsLocalTime.wMinute)) to dtLocalTime
                    Move (DateSetSecond(dtLocalTime, lsLocalTime.wSecond)) to dtLocalTime
                    Move (DateSetMillisecond(dtLocalTime, lsLocalTime.wMillieseconds)) to dtLocalTime
                End
            End
        End
        Function_Return dtLocalTime
    End_Function

    
    // Returns the number of fields present in a string of fields seperated by a delimiter.  
    // If sDelimiter is not applied the ";" will be used.
    Function CountOfFields String sFields String sDelimiter Returns Integer
        Integer iChar icChar iField                                
        String sDlm
        If (sFields ="") Begin
            Function_Return 0
        End
        If (num_arguments > 1) Begin
            Move sDelimiter to sDlm 
        End
        Else Begin
            Move ";" to sDlm
        End
        Move (Length(sFields) -1) to icChar
        For iChar from 1 to icChar
            If (Mid(sFields, 1, iChar) = sDlm) Begin
                Increment iField
            End
        Loop
        Function_Return (iField +1)
    End_Function


    // Returns a field from a string containing multiple delimited fields. 
    // Index is 1-based.
    Function FieldAtIndex String sFields Integer iIndex String sDelimiter Returns String
        Integer iChar iField iPos
        String sField sDlm
        If (num_arguments > 2) Begin
            Move sDelimiter to sDlm
        End
        Else begin
            Move ";" to sDlm
        End
        Move (sFields + sDlm) to sFields
        For iField from 1 to iIndex
            Move (Pos(sDlm, sFields)) to iPos
            If iPos Begin
                Move (Left(sFields, iPos -1)) to sField
                Move (Right(sFields, Length(sFields) -iPos)) to sFields
            End
            Else Begin
                Function_Return ""
            End
        Loop
        Function_Return sField
    End_Function                     

    
    // Removes the file extention from the sFile string and returns the extention including "."
    // Example sFile = "x:\text.txt". The function returns ".txt" and sFile = "x:\text".
    Function RemoveExtention String ByRef sFilename Returns String
        String sExtention
        Integer iLengthExtention
        Get FileExtention sFilename to sExtention
        Move (Length(sExtention)) to iLengthExtention
        If (iLengthExtention > 0) Begin
            Move (Left(sFilename, (Length(sFilename) - iLengthExtention - 1))) to sFilename
        End
        Function_Return sExtention
    End_Function


    // Add a directory separator if it is not present.
    // Example sFoldername = "x:\FolderA". The function returns "x:\FolderA\"
    Function AddFolderSeperator String sFolderName Returns String
        String sDirSep
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Move (Trim(sFolderName)) to sFolderName
        If (Right(sFolderName, 1) <> sDirSep) Begin
            Move (sFolderName + sDirSep) to sFolderName
        End
        Function_Return sFolderName
    End_Function

    
    // Removes a directory separator if it is present.
    // Example sFoldername = "x:\FolderA\". The function returns "x:\FolderA"
    Function RemoveFolderSeperator String sFolderName Returns String
        String sDirSep
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Move (Trim(sFolderName)) to sFolderName
        If (Right(sFolderName, 1) = sDirSep) Begin
            Move (Left(sFolderName, Length(sFolderName) - 1)) to sFolderName
        End
        Function_Return sFolderName
    End_Function

    
    // Changes all invalid chacters in sFilename with sReplaceCharacter according to Naming Conventions.
    // sReplacecharacter has to be a valid chararacter.
    Function ValidFileName String sFilename String sReplaceCharacter Returns String
        String sValidFilename
        Integer iAscii 
        Move sFilename to sValidFilename
        For iAscii from 0 to 31
            Move (Replaces(Character(iAscii), sValidFilename, sReplaceCharacter)) to sValidFilename
        Loop
        Move (Replaces('<', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('>', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces(':', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('"', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('/', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('\', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('|', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('?', sValidFilename, sReplaceCharacter)) to sValidFilename
        Move (Replaces('*', sValidFilename, sReplaceCharacter)) to sValidFilename
        If (Uppercase(sValidFilename) = "CON") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "PRN") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "AUX") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "NUL") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM1") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM2") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM3") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM4") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM5") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM6") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM7") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM8") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "COM9") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT1") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT2") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT3") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT4") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT5") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT6") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT7") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT8") Move sReplaceCharacter to sValidFilename
        Else If (Uppercase(sValidFilename) = "LPT9") Move sReplaceCharacter to sValidFilename
        If (Right(sValidFilename, 1) = " " or Right(sValidFilename, 1) = ".") Begin
            Move (Left(sValidFilename, (Length(sValidFilename) - 1)) + sReplaceCharacter) to sValidFilename
        End
        Function_Return sValidFilename
    End_Function
    

    // Fetch the error message from windows.
    {Visibility = Private}
    Procedure DoShowError Integer iErrorNumber String sAppendErrorText
        Pointer lpOut
        Integer iRetChars iRetVal
        String sFilename sMessage
        WString wsMsg
        Move 0 to lpOut
        Move (FormatMessageW((FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS+FORMAT_MESSAGE_ALLOCATE_BUFFER), FNULL, iErrorNumber, FNULL, AddressOf(lpOut), 0, FNULL)) to iRetChars
        If (iRetChars > 0) Begin
            Move (ZeroString(iRetChars)) to wsMsg
            Move (CopyMemory(AddressOf(wsMsg), lpOut, iRetChars * 2)) to iRetVal
            Move (Free(lpOut)) to iRetVal
            Move wsMsg to sMessage
            If (num_arguments > 0) Begin
                Move (Trim(sAppendErrorText)) to sAppendErrorText
                If (sAppendErrorText <> "") Begin
                    Move (sMessage + "\n" + sAppendErrorText) to sMessage
                End
            End
            Send warning_box sMessage
        End
    End_Procedure


    // Shows a warning message to user with OK button and a exclamation icon.
    {Visibility = Private}
    Procedure warning_box String sWngMsg
        Integer iVoid
        Boolean bSendVdfError bIgnoreError
        Get pbIgnoreError to bIgnoreError
        If (bIgnoreError) Begin
            Procedure_Return
        End
        Set pbError to True
        Get pbErrorAsVDFError to bSendVdfError
        If (bSendVdfError = False) Begin
            Get Message_Box sWngMsg "Filesystem Error" MB_OK MB_ICONEXCLAMATION to iVoid
        End
        Else Begin
            Error DFERR_PROGRAM sWngMsg
        End
    End_Procedure


    // Fetch the filename from the list of filenames associated with a filenumber.
    // This function is used for reporting filenames during an error.
    {Visibility = Private}
    Function FileErrorText Integer iFilenumber Returns String
        String sErrorText
        structFile[] lsaFile
        Get plsaFile to lsaFile
        If (iFilenumber < SizeOfArray(lsaFile)) Begin
            Move ("File: "+lsaFile[iFilenumber].sFilename) to sErrorText
        End
        Function_Return sErrorText
    End_Function


    // Dump a string to a file
    // Good for debugging strings.
    Procedure DoDumpString String ByRef sString String sFile
        Boolean bOk        
        Integer iFilenumber
        Get BinaryFileNextFilenumber to iFilenumber
        Get BinaryFileOpen iFilenumber sFile False True to bOk        
        Get BinaryFileWriteText iFilenumber (&sString) to bOk        
        Set BinaryFileEndOfFile iFilenumber to (SizeOfString(sString))        
        Get BinaryFileClose iFilenumber to bOk
    End_Procedure

    // Returns true if the file is in use.
    Function CheckForFileInUse String sFile Returns Boolean
        Boolean bFileInUse bExists bOk bOldIgnoreStatus
        Integer iFilenumber
        
        Get FileExists sFile DIRMODE_FILES_ONLY to bExists
        If (bExists) Begin
            Get pbIgnoreError to bOldIgnoreStatus
            Set pbIgnoreError to True
            Get BinaryFileNextFilenumber to iFilenumber
            Get BinaryFileOpen iFilenumber sFile False False False to bOk
            If (bOk) Begin
                Get BinaryFileClose iFilenumber to bOk
            End
            Else Begin
                Move True to bFileInUse
            End
            Set pbIgnoreError to bOldIgnoreStatus
        End
        
        Function_Return bFileInUse
    End_Function
    
    // Returns the file size in KB rounded up (ceiling).
    // This is the same behavior as in Microsoft Explorer.
    Function FileSizeInKB BigInt biValue Returns String
        String sValue
        Number nKB
        BigInt biTest
        If (biValue > |CH99999999999999999) Begin // 99 PB file size. The NTFS system only allows for 16 TB for each file.
             Function_Return (String(biValue))
        End
        Move (biValue / 1024) to nKB
        Move (Cast(nKB, BigInt)) to biTest
        Move (biTest * 1024) to biTest
        If (biTest < biValue) Begin
            Move (nKB + 1) to nKB
        End
        Move (SFormat("%1 KB", FormatNumber(nKB, 0))) to sValue
        Function_Return sValue
    End_Function

End_Class
