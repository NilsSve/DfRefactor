//****************************************************************************
// $Module type: Class
// $Module name: cBaseDbUpdateFuncLib
// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
// Web-site    : http://www.rdctools.com
// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
//
// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
//               It contains helper functions for the cDbUpdateFunctionLibrary class
//
// $Rev History:
//    2023-11-06  Module header created
//
//****************************************************************************
Use cApplication.pkg
Use seq_chnl.pkg
Use GlobalFunctionsProcedures.pkg
Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
Use Dfcursor.pkg
Use DUFStatusPanel.pkg
Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Use cSQLConnectionHandler.pkg
Use vWin32fh.pkg
Use Dfabout.pkg

#IFNDEF piOrgErrorHandlerID
    Function piOrgErrorHandlerID Returns Integer
    End_Function
#ENDIF

Class cBaseDbUpdateFuncLib is a cObject
    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
    #Include ParseKeyWord.pkg
    
    Procedure Construct_Object
        Handle ho
        Forward Send Construct_Object
        Move Self to ghoDbUpdateFunctionLibrary
        
        Send CreateDbUpdateLibraryProperties
        { Visibility=Private }
        Property String private.psCollation "Latin1_General_CS_AS"

        // If no ghoSQLConnectionHandler object has been created prior to this object,
        // we will create one as it is used for all ConnectionID, ConnectionString
        // etc settings.
        If (ghoSQLConnectionHandler = 0) Begin
            Get Create (RefClass(cSQLConnectionHandler)) to ho
            Set phoSQLConnectionHandler to ho
        End

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object

    End_Procedure

    // Latin1_General_CI_AS = General Insensitive collation
    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
    // Good read about which collation to select:
    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
    { MethodType=Property Category="Convert to SQL" InitialValue="Latin1_General_CS_AS" }
    { InitialValue="Latin1_General_CS_AS" EnumList="Latin1_General_CS_AS, Latin1_General_CI_AS, SQL_Latin1_General_Cp1_CS_AS, Finnish_Swedish_CI_AS" }
    Procedure Set psCollation String sCollation
        Set private.psCollation to sCollation
        If (ghoDbUpdateHandler > 0) Begin
            Set psCollation of ghoDbUpdateHandler to sCollation
        End
    End_Procedure

    Function psCollation Returns String
        String sCollation
        If (ghoDbUpdateHandler > 0) Begin
            Get psCollation of ghoDbUpdateHandler to sCollation
        End   
        Else Begin
            Get private.psCollation to sCollation
        End
        Function_Return sCollation
    End_Function

    // Array sorting helper functions:
    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;
            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;
            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;
            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
            Function_Return (EQ)
        End

        Function_Return (GT)
    End_Function

    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;
            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;
            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;
            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;
            Function_Return (EQ)

        Function_Return (GT)
    End_Function

    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
    // Note that it first removes any driver prefixes in the rootname.
    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
        Handle hTable
        Boolean bIsSame

        Move APITableInfo.iTableNumber      to hTable
        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
        Get _TableNoPrefix sRootNameTo                to sRootNameTo
        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo

        If (bCompareFilelistUppercase = True) Begin
            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;
                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
        End
        Else Begin
            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
        End

        Function_Return bIsSame
    End_Function

    Function AutoSetConnectionID String sConnectionID Returns Boolean
        Integer iRetval
        Move 1 to iRetval
        If (ghoSQLConnectionHandler <> 0) Begin
            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
        End
        Function_Return (iRetval = 0)
    End_Function

    Function _AddFolderDelimiter String sPath Returns String
        String sDirSep
        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
        Move (Trim(sPath)) to sPath
        If (Right(sPath, 1) <> sDirSep) Begin
            Move (sPath + sDirSep) to sPath
        End
        Function_Return sPath
    End_Function

    Procedure _SqlColumnInfo Handle hoStmt
        Integer i iCols iItem
        tSqlColumnNew[] aQueryColumns

        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
        For i from 1 to iCols
            Move (SizeOfArray(aQueryColumns)) to iItem
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
        Loop
        Set piColumns to iCols
        Set paQueryColumns to aQueryColumns
    End_Procedure

    // *** Property Messages ***
    //
    // These "properties" are settings for the cSQLConnectionHandler class, but have been
    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
    //
    Function pSQLConnection Returns tSQLConnection
        tSQLConnection SQLConnection
        If (ghoSQLConnectionHandler = 0) Begin
            // Note: No point in translating as the programmer will see this immediately after compiling the program...
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Function_Return SQLConnection
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function OTHER_CLASS_PROPERTIES Returns Boolean
        Function_Return False
    End_Function

    Procedure Set psServer String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            // Note: No point in translating as the programmer will see this immediately after compiling the program...
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psServer of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psServer Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psServer of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psDatabase String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psDatabase of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDatabase Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psDatabase of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psUserID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psUserID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psUserID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psUserID of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psPassword String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psPassword of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psPassword Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psPassword of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set pbTrusted Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbTrusted of ghoSQLConnectionHandler to bValue
    End_Procedure

    Function pbTrusted Returns Boolean
        Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbTrusted of ghoSQLConnectionHandler to bValue
        Function_Return bValue
    End_Function

    Procedure Set pbSilentLogin Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
    End_Procedure

    Function pbSilentLogin Returns Boolean
        Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
        Function_Return bValue
    End_Function

    Procedure Set psConnectionID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psConnectionID of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psConnectionString String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionString of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionString Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psConnectionString of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    // The normal connection string looks something like this;
    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
    // ...and the full connection string looks like this;
    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
    Function psFullConnectionString Returns String
        String sConnectionID sConnectionString
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
        Move (Trim(sConnectionID)) to sConnectionID
        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
    End_Function

    Function piConnectionOptions Returns Integer
        Integer iValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
        Function_Return iValue
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psSchema String sValue
        tSQLConnection SQLConnection
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psSchema of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psSchema Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psSchema of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psBaseTableSpace String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psBaseTableSpace Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psLongTableSpace String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psLongTableSpace Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psIndexTableSpace String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psIndexTableSpace Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbUseConnectionID Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbUseConnectionID Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbToANSI Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbToANSI of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbToANSI Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbToANSI of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbRecnum Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbRecnum of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbRecnum Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbRecnum of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbCopyData Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCopyData of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCopyData Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCopyData of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbApiTableUpdateAuto Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbApiTableUpdateAuto Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbCompareDate_DateTime Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCompareDate_DateTime Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbCompareIndexAscending Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCompareIndexAscending Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbCompareIndexUppercase Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCompareIndexUppercase Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueASCII String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueASCII Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueBinary String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueBinary Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueDate String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueDate Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueDateTime String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueDateTime Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueNumeric String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueNumeric Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueText String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueText Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableASCII Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableASCII Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableBinary Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableBinary Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableDate Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableDate Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableDateTime Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableNumeric Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableText Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableText Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    // Note: If the psDriverID + other connection properties are to be changed,
    //       the psDriverID *must* be the first property that gets changed!
    //       Otherwise errors might be raised by the driver when e.g. the format
    //       for a connection string has the wrong format for that driver.
    { MethodType=Property Category="Database" InitialValue="Default" }
    { EnumList="DATAFLEX, MSSQLDRV, DB2_DRV, ODBC_DRV" }
    Procedure Set psDriverID String sValue
        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Delegate Set psDriverID to sValue
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Set psDriverID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverID Returns String
        String sDriverID

        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        // This should get it from the parent object (when using the cDbUpdateHandler class)
        Delegate Get psDriverID to sDriverID
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Move False to Err

        // ...and in case it didn't use property of this class. Then the library is
        // probably used as "utilites" from a special made program and
        // the ghoSQLConnectionHandler must have been setup
        If (sDriverID = "") Begin
            Get psDriverID of ghoSQLConnectionHandler to sDriverID
        End
        Function_Return sDriverID
    End_Function

    { MethodType=Property Category="Database" InitialValue=Default }
    { EnumList="EN_DbTypeMSSQL, EN_DbTypeMySQL, EN_DbTypeOracle, EN_DbTypeDB2, EN_DbTypePostgre, EN_DbTypeDataFlex" }
    Procedure Set piDbType Integer iValue
        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Delegate Set piDbType to iValue
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Set piDbType of ghoSQLConnectionHandler to iValue
    End_Procedure

    Function piDbType Returns Integer
        Integer iRetval
        Get piDbType of ghoSQLConnectionHandler to iRetval
        Function_Return iRetval
    End_Function

    // Returns the index for the passed sTableName
    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
        Integer iIndex iSize iCount
        String[] sTablesArray
        String sDatabase sSchema sVal sConnectionString

        Move -1 to iIndex
        Get psConnectionString to sConnectionString
        Get psDatabase to sDatabase
        Get psSchema   to sSchema
        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move iCount to iIndex // We found it!
                Move iSize to iCount  // End the loop
            End
        Loop

        Function_Return iIndex
    End_Function

    // Returns all schemas as a string array for the passed driver id.
    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
        String[] sReturnArray
        Boolean bOK

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Case Begin
            Case (sDriverID = DB2_DRV_ID)
                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns a string array with all tables for the current database.
    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
        String[] sReturnArray sArray
        String sConnectionString sSelect
        Integer iSize iCount iDbType
        Boolean bOK

        If (sDriverID = DATAFLEX_ID) Begin
            Function_Return sArray
        End

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        Get psConnectionString to sConnectionString

        // We need to treat DAW's ODBC driver a bit different, as the output depends on
        // the dbType.
        Get piDbType to iDbType
        If (sDriverID = ODBC_DRV_ID) Begin
            If (iDbType = EN_DbTypeMSSQL) Begin
                Move MSSQLDRV_ID to sDriverID
            End
            If (iDbType = EN_DbTypeDB2) Begin
                Move DB2_DRV_ID to sDriverID
            End
            If (iDbType = EN_DbTypePostgre) Begin
                Move ODBC_DRV_ID to sDriverID
            End
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get _SqlTableArrayDAW to sReturnArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Get _SqlTableArrayDAW to sReturnArray
                Case Break

            Case (sDriverID = ODBC_DRV_ID)
                Get _SqlTableArrayDAW to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns all table spaces as a string array for the passed driver id.
    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
        String[] sReturnArray
        Boolean bOK

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Case Begin
            Case (sDriverID = DB2_DRV_ID)
                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns a string array with all table columns/fields for the passed table handle and driver id.
    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
        String[] sReturnArray
        String sConnectionString sSelect sSchema
        Boolean bOK
        Integer iDbType

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
            Function_Return sReturnArray
        End

        Get psConnectionString to sConnectionString
        Get psSchema to sSchema

        // We need to treat DAW's ODBC driver a bit different, as the output depends on
        // the dbType.
        Get piDbType to iDbType

        Case Begin
            Case (sDriverID = ODBC_DRV_ID)
                If (iDbType = EN_DbTypeMySQL) Begin
                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
                End
                If (iDbType = EN_DbTypePostgre) Begin
                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
                End
                If (iDbType = EN_DbTypeMSSQL) Begin
                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
                End

                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = MSSQLDRV_ID)
                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function


    // Returns a string array with all table indexes for the passed table handle and driver id.
    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
        String[] sReturnArray sReturnArray2
        String sConnectionString sSelect sSchema
        Boolean bOK
        Integer iCount iSize

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
            Function_Return sReturnArray
        End

        Get psConnectionString to sConnectionString
        Get psSchema to sSchema

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
                Case Break
        Case End

        Move (SizeOfArray(sReturnArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            If (Trim(sReturnArray[iCount]) <> "") Begin
                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
            End
        Loop

        Function_Return sReturnArray2
    End_Function

    // Returns a string array with all table names the passed table handle has relation ships with.
    // The format of the array is "TableName.FieldName"
    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
        String[] sFileNameArray sFieldNameArray
        tSQLRelation[] sRelationsArray
        String sConnectionString sSelect sSchema sFileName sFieldName
        Boolean bOK
        Integer iCount iSize iLength

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
            Function_Return sRelationsArray
        End

        Get psConnectionString to sConnectionString
        Get psSchema to sSchema

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
                Case Break
        Case End

        Move (Length(sTableName)) to iLength
        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
        Move (SizeOfArray(sFileNameArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            If (Trim(sFileNameArray[iCount]) <> "") Begin
                Move sFileNameArray[iCount]         to sFileName
                Move sFieldNameArray[iCount]        to sFieldName
                Move (Mid(sFieldName, 99, iLength)) to sFieldName
                Move sFileName  to sRelationsArray[iCount].sFileName
                Move sFieldName to sRelationsArray[iCount].sFieldName
            End
        Loop

        Function_Return sRelationsArray
    End_Function

    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
        tSQLLoggedInUser[] SQLLoggedInUser
        String[] sUsers sPrograms
        String sSelect
        Integer iSize iCount

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;
                + sDatabase + "') ORDER by Inlog") to sSelect
                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
                Case Break
            Case Else
                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
        Case End

        Move (SizeOfArray(sUsers)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
        Loop

        Function_Return SQLLoggedInUser
    End_Function

    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
        String[] sFilesData
        Boolean bExists
        Integer iCh
        String sFileName sExt

        Get vFolderExists sDataPath to bExists
        If (bExists = True) Begin
            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
            Move ("dir:" + sDataPath)      to sDataPath
            Get Seq_New_Channel to iCh  // get free channel for input
            Direct_Input channel iCh sDataPath
                Repeat
                    Readln channel iCh sFileName
                    Get ParseFileExtension sFileName to sExt
                    If (Uppercase(sExt) = "INT") Begin
                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
                        End
                    End
                Until (SeqEof = True)
            Close_Input channel iCh
            Send Seq_Release_Channel iCh
        End
        Function_Return sFilesData
    End_Function

    // Only done for MSSQLDRV_ID so far...
    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
        String sSQL sConnectionID sConnectionString sSelect sName sPre
        String sDescription sFrom sSys sValue sPrevious
        Handle hStmt hoSQLManager hoSQLConnect
        Integer iFetchResult iRows iColumn iPos
        tSQLConnection SQLConnection
        String[] asCollations
        
        If (sDriverID = "") Begin
            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
            Function_Return asCollations
        End

        // Only done for MSSQLDRV_ID so far...
        If (sDriverID <> MSSQLDRV_ID) Begin
            Function_Return asCollations
        End                 

        Get phoSQLManager to hoSQLManager
        Get psConnectionID     to sConnectionID
        Get psConnectionString to sConnectionString
        Move 0 to LastErr

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
            Function_Return asCollations
        End

        Get SqlOpen of hoSQLConnect to hStmt

        If (hStmt = 0) Begin
            Send SqlDisconnect of hoSQLManager
            Error DFERR_PROGRAM CS_DUF_ConnectError
            Function_Return asCollations
        End

        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
        Get _SqlFindKeyWord CI_SQLName        to sName
        Get _SqlFindKeyWord CI_SQLDescription to sDescription
        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
        Get _SqlFindKeyWord CI_SQLSys         to sSys

        // MS-SQL Syntax:  
        // SELECT name, description
        //   from sys.fn_helpcollations();
        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL

        Move 1 to iColumn
        Send SqlExecDirect of hStmt sSQL
        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
        Repeat
            Get SQLFetch of hStmt to iFetchResult
            If (iFetchResult <> 0) Begin
                Get SQLColumnValue of hStmt iColumn to sValue 
                If (sValue <> sPrevious) Begin         
                    // We need to skip all collations starting with "SQL" because they
                    // are obsolete and for pre-SQL Server 2000.
                    Move (Pos("SQL", Uppercase(sValue))) to iPos
                    If (iPos <> 1) Begin
                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
                    End
                End
                Move sValue to sPrevious
            End
        Until (iFetchResult = 0)
        Send SQLClose of hStmt
        Send SQLDisconnect of hoSQLConnect

        Function_Return asCollations
    End_Function

    // To enumerate SQL database resources with ESQL and return the result as a string array,
    // for DAW drivers.
    // Returns: A string array.
    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
        String[] sReturnArray
        String sValue sPrevious
        Handle hoSQLHandler hoSQLConnect hstmt
        Integer iFetchResult iRows
        tSQLConnection SQLConnection

        Get phoSQLManager to hoSQLHandler

        If (hoSQLHandler <> 0) Begin
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect

            If (hoSQLConnect <> 0) Begin
                Get SQLOpen of hoSQLConnect to hstmt
                If (hstmt <> 0) Begin
                    Send SqlExecDirect of hstmt sStmt
                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
                    Repeat
                        Get SQLFetch of hstmt to iFetchResult
                        If (iFetchResult <> 0) Begin
                            Get SQLColumnValue of hstmt iColumn to sValue
                            If (sValue <> sPrevious) Begin
                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
                            End
                            Move sValue to sPrevious
                        End
                    Until (iFetchResult = 0)
                    Send SQLClose of hstmt
                End
                Send SQLDisconnect of hoSQLConnect
            End
        End

        Function_Return sReturnArray
    End_Function

    { Visibility=Private }
    Function _SqlDatabasesArrayDB2 Returns String[]
        String[] sReturnArray
        String sDataSource
        Handle hoSQLHandler
        Integer iItem

        Get phoDB2SQLHandler to hoSQLHandler
        Send SeedDataSources of hoSQLHandler

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Repeat
            Get DataSources of hoSQLHandler to sDataSource
            Move (Replaces(",", sDataSource, "")) to sDataSource
            Move (Trim(sDataSource)) to sReturnArray[iItem]
            Increment iItem
        Until (sDataSource = "")

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    { Visibility=Private }
    Function _SqlDatabaseSourcesArrayODBC Returns String[]
        String[] sReturnArray
        String sDataSource
        Handle hoSQLHandler
        Integer iItem

        Get phoODBCSQLHandler to hoSQLHandler
        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Send SeedDataSources of hoSQLHandler

        Repeat
            Get DataSources of hoSQLHandler to sDataSource
            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
                Move (Trim(sDataSource)) to sReturnArray[iItem]
                Increment iItem
            End
        Until (sDataSource = "")

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
        String[] sDataSources
        tSQLConnection SQLConnection
        tSQLIntTableInfo[] sReturnArray
        Integer iDataSources iCount iItem
        String sConnection sServer sDatabase sKey sSubKey
        Handle hoIniFile hoRegistry hoODBCDataSources
        Boolean bExists bKeyOpened

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sConnectionString to sConnection
        Move SQLConnection.sServer           to sServer

        // FileDSN - read DATABASE name from DSN ini-file
        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
            Get Create (RefClass(cIniFile)) to hoIniFile
            Set psFileName of hoIniFile to sServer
            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
            Move sDatabase to sReturnArray[0].sDatabaseName
            Send Destroy of hoIniFile
        End

        // DSN - read DATABASE name from the registry
        Else Begin
            Get Create (RefClass(cRegistry)) to hoRegistry

            // We start with checking the "System DNS" area in the registry as it is the
            // most probably place the info is kept that we're after.
            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
            Set pfAccessRights of hoRegistry to Key_Read
            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
            If (bExists = True) Begin
                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
            End
            Else Begin
                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
            End

            Get KeyExists of hoRegistry sKey to bExists
            If (bExists) Begin
                Get OpenKey of hoRegistry sKey to bKeyOpened
                If (bKeyOpened) Begin
                    Get Create (RefClass(Array)) to hoODBCDataSources
                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
                    If (iDataSources > 0) Begin
                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
                        Decrement iDataSources
                        for iCount from 0 to iDataSources
                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
                        Loop
                        Move 0 to iItem
                        for iCount from 0 to iDataSources
                            Move sDataSources[iCount] to sSubKey
                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
                            If (bKeyOpened = True) Begin
                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
                                If (bExists = True) Begin
                                    Move sSubKey to sReturnArray[iItem].sServerName
                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
                                    Increment iItem
                                End
                            End
                        Loop
                    End
                    Send CloseKey of hoRegistry
                    Send Destroy of hoODBCDataSources
                End
            End

            // We then check the "User DNS" area in the registry.
            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
            Set pfAccessRights of hoRegistry to Key_Read
            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
            Get KeyExists of hoRegistry sKey to bExists

            If (bExists) Begin
                Get OpenKey of hoRegistry sKey to bKeyOpened
                If (bKeyOpened) Begin
                    Get Create (RefClass(Array)) to hoODBCDataSources
                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
                    If (iDataSources > 0) Begin
                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
                        Decrement iDataSources
                        for iCount from 0 to iDataSources
                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
                        Loop
                        for iCount from 0 to iDataSources
                            Move sDataSources[iCount] to sSubKey
                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
                            If (bKeyOpened = True) Begin
                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
                                If (bExists = True) Begin
                                    Move sSubKey to sReturnArray[iItem].sServerName
                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
                                    Increment iItem
                                End
                            End
                        Loop
                    End
                    Send CloseKey of hoRegistry
                    Send Destroy of hoODBCDataSources
                End
            End

            Send Destroy of hoRegistry
        End

        Function_Return sReturnArray
    End_Function

    // We might have a split Sql script where the info about which database to use is
    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
    // insert it for scriplets to come after the first one.
    Function _SqlFormatStatement String sStmt Returns String
        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
        Integer iStart iEnd iDbType
        Boolean bOK

        Get piDbType to iDbType
        Get psDriverID to sDriverID
        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
        Move (Replaces(" ", sStmt, "")) to sTmp
        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
            Move (Pos("[", (Uppercase(sTmp)))) to iStart
            Move (Pos("]", sTmp)) to iEnd
            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
            Set Private.psUseDatabase to sUseDatabase
        End
        Else Begin
            Move (Uppercase(sStmt)) to sTmp

            // A "Create View" statement _must_ be the very first words in a Sql statement.
            If (not(sTmp contains sCreateViewKeyWord)) Begin
                Get Private.psUseDatabase to sUseDatabase
                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
            End

            // This is a bit special to place here but was done so because it was easier that way.
            // We will get an error when trying to create a view if it already exists.
            // So to avoid such errors; we first remove it & then recreate it.
            Else If (sTmp contains sCreateViewKeyWord) Begin
                // Make sure we only have one space between statements/words.
                Move (Replaces("  ", sTmp, " ")) to sTmp
                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
                Move (Trim(sTmp)) to sTmp
                Move (Pos(" ", sTmp)) to iEnd
                Move (Left(sTmp, iEnd)) to sTmp
                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
                End
                Move (Trim(sTmp)) to sTmp
                // Remove data view as it already exists!
                Get _SqlViewRemove sDriverID sTmp to bOK
            End
        End

        Function_Return sStmt
    End_Function

    // First deletes the data cache file and then drops the passed Sql data view.
    Function _SqlViewRemove String sDataView Returns Boolean
        String sDriverID sSQLString sDropViewKeyWord
        Integer iRetval
        Boolean bOK

        Get psDriverID to sDriverID
        Get _UtilDeleteCacheFile sDataView to iRetval

        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
        Set psSQLStatementString to sSQLString

        // As we don't check if the view exist or not, it might happen
        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
        Move False to Err
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send SqlUtilExecuteQuery sSQLString sDriverID
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Move 0 to LastErr

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sDataView to bOK

        Function_Return (Err = False)
    End_Function

    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
        String sRetval
        Integer iDbType iIndex
        tSQLKeyWords[] SQLKeywordArray
        tSQLKeyWords   SQLKeyWords

        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
        Move "" to sRetval
        Get piDbType to iDbType
        Move iDbType             to SQLKeyWords.iSQLDbType
        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord

        Get paSQLKeywordArray to SQLKeywordArray
        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
        If (iIndex >= 0) Begin
            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
        End

        Function_Return sRetval
    End_Function

    // Function will "clean/sanitize" the script by removing all comments and blank lines.
    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
        String[] sSQLScriptArray
        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
        Integer iSize iCount
        Boolean bCommentStart bCommentEnd bDashComment

        Move False to bCommentStart
        Move False to bCommentEnd
        Move False to bDashComment
        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
        Move "*/"  to sCommentEnd
        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".

        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
        Decrement iSize
        Move "" to sText

        for iCount from 0 to iSize
            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
            Move (Trim(sLine)) to sTmp
            If (sTmp <> "") Begin
                Move (Left(sTmp, 2) = sDashComment) to bDashComment
                If (bCommentStart = False) Begin
                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
                    If (bCommentStart = False) Begin
                    End
                End
                Move (sTmp contains sCommentEnd) to bCommentEnd
                If (bCommentEnd = True) Begin
                    Move False to bCommentStart
                End
                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
                End
            End
        Loop

        // Update the retval struct array:
        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
        Function_Return SqlScriptArray
    End_Function

    // Helper function that builds a string like;
    // "SELECT name from [Master].[sys].[databases] where name"
    Function _SqlSelectFromWhereName Returns String
        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO

        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
        Get _SqlFindKeyWord CI_SQLName         to sName
        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
        Get _SqlFindKeyWord CI_SQLSys          to sSys
        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
        Function_Return sRetval
    End_Function

    // Helper function to create a SQL statement like;
    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
    // Used for checking if an index exists.
    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName

        Get _SqlFindKeyWord CI_SQLSelect to sSelect
        Get _SqlFindKeyWord CI_SQLFrom to sFrom
        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
        Get _SqlFindKeyWord CI_SQLWhere to sWhere
        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
        Get _SqlFindKeyWord CI_SQLAND to sAnd
        Get _SqlFindKeyWord CI_SQLName to sName

        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval

        Function_Return sRetval
    End_Function

    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
        String sRetval
        If (iLength <> 0) Begin
            Move ("(" + String(iLength)) to sRetval
            If (iDecimals <> 0) Begin
                Move (sRetval + "," + String(iDecimals)) to sRetval
            End
            Move (sRetval + ")") to sRetval
        End
        Function_Return sRetval
    End_Function

    // Checks that the passed sDriverID is defined.
    // Also checks if the driver has been loaded; else it gets loaded.
    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
        Boolean bOK
        Integer iDriver

        If (sDriverID = DATAFLEX_ID) Begin
            Function_Return False
        End

        Get IsDAWSQLDriver sDriverID to bOK

        If (bOK = False) Begin
            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
            Function_Return False
        End

        Get DriverIndex sDriverID to iDriver
        If (iDriver = 0) Begin
            Load_Driver sDriverID
        End

        Function_Return True
    End_Function

    // Checks that the length parameter has been passed correctly.
    // This is only of concern for certain SQL data types.
    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
        Integer iLength
        Boolean bOK bCheckTypeLength

        If (num_arguments > 1) Begin
            Move iLen to iLength
        End
        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;
              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;
              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength

        If (bCheckTypeLength = True) Begin
            Move (iLength > 0) to bOK
        End

        Function_Return (bOK = True)
    End_Function

    Function _SqlProperTableName String sTableName Returns String
        String sVal sSchema sDriverID
        Integer iDbType

        If (Trim(sTableName) = "") Begin
            Function_Return ""
        End

        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        If (iDbType = EN_dbTypeOracle) Begin
            Get psUserID to sSchema
            // Not sure about this uppercasing but it seems like Oracle wants that?
            Move (Uppercase(sSchema)) to sSchema
            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
            Function_Return sTableName
        End
        If (iDbType = EN_DbTypeMySQL) Begin
            Get psDatabase to sVal
            Move (sVal + "." + sTableName) to sTableName
            Function_Return sTableName
        End
        If (iDbType = EN_DbTypePostgre) Begin
            Move ('"' + sTableName + '"') to sTableName
            Function_Return sTableName
        End

        Get psSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        Move (Uppercase(sTableName)) to sVal
        If (not(sVal contains (sSchema + "."))) Begin
            If (iDbType = EN_dbTypeDB2) Begin
                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
            End
            Else Begin
                Move (sSchema + "." + sTableName) to sTableName
            End
        End

        Function_Return sTableName
    End_Function

    // SQL column names can be case-sensitive. This function is used to check that
    // the passed sFieldName has the correct spelling.
    // Used with Embedded SQL statement calls.
    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
    Function _SqlFindColumnName String sTableName String sColumnName Returns String
        String sRetval sValue sDriverID
        String[] sColumnNamesArray
        Integer iCount iColumns

        Move "" to sRetval
        Get psDriverID to sDriverID
        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
        Move (SizeOfArray(sColumnNamesArray)) to iColumns
        Decrement iColumns

        For iCount from 0 to iColumns
            Move sColumnNamesArray[iCount] to sValue
            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
                Move sValue to sRetval
                Move iColumns to iCount // We're done.
            End
        Loop

        Function_Return sRetval
    End_Function

    { Visibility=Private }
    Function _SqlDatabasesArrayMSSQL Returns String[]
        String[] sReturnArray
        Handle hoSQLHandler
        Integer iCount iSize iItem
        String sServer
        tSQLConnection SQLConnection

        Get phoMSSQLHandler to hoSQLHandler
        Send Delete_Data    of hoSQLHandler
        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Get String_Value of hoSQLHandler iCount to sServer
            Move (Trim(sServer)) to sReturnArray[iItem]
            Increment iItem
        Loop

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    Function _SqlTableArrayDAW Returns String[]
        String[] sReturnArray
        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
        Handle hoSQLHandler
        Integer iCount iSize iItem iPos
        Boolean bOK
        tSQLConnection SQLConnection

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        If (SQLConnection.sConnectionString = "") Begin
            Function_Return sReturnArray
        End

        Move SQLConnection.sSchema      to sDefSchema
        Move (Uppercase(sDefSchema))    to sDefSchema
        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord

        Get phoCLIHandler to hoSQLHandler
        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
        Send Delete_Data  of hoSQLHandler

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Move SQLConnection.sConnectionString to sConnectionString
        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
//                Move (Pos(";", sConnectionString)) to iPos
//                If (iPos > 0) Begin
//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
//                    Move (Trim(sConnectionString)) to sConnectionString
//                End
//            End
//        End

        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
        Move False to Err
        Move 0 to iItem

        // Note that the enumeration starts from table no 1. (not zero)
        For iCount from 1 to iSize
            Get TableName    of hoSQLHandler iCount to sTable
            Get TableType    of hoSQLHandler iCount to sTableType
            Get SchemaName   of hoSQLHandler iCount to sSchema
            If (sSchema = "") Begin
                Get _SqlFindKeyWord CI_SQLDBO to sSchema
            End
            Get TableComment of hoSQLHandler iCount to sComment
            Move (Trim(sTable)) to sTable
            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
            End
            Else Begin
                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
            End
            If (bOK = True) Begin
                Move sTable to sReturnArray[iItem]
                Increment iItem
            End
        Loop

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
        String[] sReturnArray
        String sValue
        Handle hoSQLHandler hoSQLConnect hStmt
        Integer iRetval iCols iFetchResult
        tSQLConnection SQLConnection

        Get phoSQLManager to hoSQLHandler
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect

        If (hoSQLConnect <> 0) Begin
            Get SqlOpen of hoSQLConnect to hStmt
            If (hStmt <> 0) Begin
                Send SqlSetProcedurename of hStmt sStmt
                If (sArgument <> "") Begin
                    Send SqlSetArgument  of hStmt 1 sArgument
                End

                Send SqlCall             of hStmt
                Get SqlReturnValue       of hStmt to iRetval
                If (iRetval = 0) Begin
                    Repeat
                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
                        If (iCols > 0) Begin
                            Repeat
                                Get SqlFetch of hStmt to iFetchResult
                                If (iFetchResult <> 0) Begin
                                    Get SqlColumnValue of hStmt 1 to sValue
                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
                                End
                            Until (iFetchResult = 0)
                        End
                        Get SqlNextResultSet of hStmt to iRetval
                    Until (iRetval = 0)
                    Send SqlClose of hStmt
                End
            End
            Send SqlDisconnect of hoSQLConnect
        End
        Function_Return sReturnArray
    End_Function

    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
        Boolean bOpened bOK

        // For some reason this .int file update screws up of CodeMast & CodeType .int files
        // which makes the program unable to run because they can't be opened.
        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
        // proper .int files for the two tables.
        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
            Function_Return True
        End

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Get _TableNameOnly sRootName to sDatabaseName
        Move CS_OEM_Txt  to sOrgFormat
        Move CS_ANSI_Txt to sNewFormat
        Get AutoConnectionIDLogin to bOK

        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
        Sleep 1

        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Open hTable
            Get_Attribute DF_FILE_OPENED of hTable to bOpened
        End
        If (bOpened = False) Begin
            Function_Return False
        End

        Get psDriverID to sDriverID

        Move False to Err
        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
        Move (Uppercase(sOrgFormat)) to sOrgFormat
        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
        // to "touch" the table so the driver feels there has been a change and updates the .int file.
        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat

        Move False to Err

        If (hTable > 0) Begin
            Structure_Start hTable
                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        End
        Else Begin
            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
        End
        Function_Return (Err = False)
    End_Function

    // Subfunction to the ApiTableUpdate function (et al)
    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
        Handle hTable
        String sConnectionID
        Boolean bTableExists bSameTableNames bANSI bOK

        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
        If (bSameTableNames = True) Begin
            Function_Return True
        End

        Move True to bOK
        Move APITableNameInfoFrom.iTableNumber  to hTable
        Set Private.phCurrentTable              to hTable
        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName

        If (APITableNameInfoFrom.bIsSQL = True) Begin
            Get psConnectionID to sConnectionID
            Get _UtilTableExists hTable to bTableExists
            If (bTableExists = True) Begin
                Get _SqlUtilUpdateIntFile hTable to bOK
            End
            Else Begin
                Get pbToANSI to bANSI
                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
            End
        End

        Function_Return bOK
    End_Function

    // The table must already exist in the filelist for this function to work.
    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
        Boolean bOK bExists bUseConnectionID 
        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
        String[] sIndexArray
        Integer iCount iCh iSize

        Move (Trim(sConnectionID) <> "") to bUseConnectionID
        Get psConnectionString to sConnectionString

        Move CS_ANSI_Txt to sANSI_OEM
        If (bANSI = False) Begin
            Move CS_OEM_Txt to sANSI_OEM
        End

        Get psDataPathFirstPart to sDataPath
        Get vFolderExists sDataPath to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
            Function_Return False
        End
        Get vFolderFormat sDataPath to sDataPath

        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get _TableNameOnly sRootName to sDatabaseName
        Move sLogicalName  to sPhysicalFileName
        Move (sPhysicalFileName + ".int") to sPhysicalFileName

        Get psSchema hTable to sSchemaName
        If (sSchemaName = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
        End

        // If the .int file already exists; we rename it to "FileName" + ".bak"
        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
        If (bExists = True) Begin
            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
        End

        Get _UtilDeleteCacheFile sRootName to bOK
        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray

        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
            If (bUseConnectionID = True) Begin
                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
            End
            Else Begin
                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
            End
            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
            // There seems to be a new order how these are set from DF19.
            If (bSysFile = True) Begin
                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
            End
            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
            If (bSysFile = True) Begin
                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
            End

            If (bSysFile = False) Begin
                Move (SizeOfArray(sIndexArray)) to iSize
                Move (SortArray(sIndexArray)) to sIndexArray
                If (iSize > 0) Begin
                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
                    Writeln channel iCh // Just an empty line
                End
                Decrement iSize
                for iCount from 0 to iSize
                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
                    Writeln channel iCh
                Loop
            End
        Send Seq_Close_Channel iCh

        // Wait a sec for Windows to finish writing the file:
        Sleep 1

        Function_Return (bOK = True)
    End_Function

    Function _UtilDeleteCacheFile String sTableName Returns Boolean
        String sDataPath sDriverID
        Boolean bOK
        Integer iPos

        If (sTableName contains ".") Begin
            Move (Pos(".", sTableName)) to iPos
            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
        End

        Get psDriverID to sDriverID
        Get psDataPathFirstPart to sDataPath
        // First delete the cache file:
        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK

        Function_Return bOK
    End_Function

    // Checks that the passed hTable number both exists in Filelist.cfg and
    // that the embedded .dat file exists on disk _or_ that the SQL table exists
    // if it is an SQL table
    Function _UtilTableExists Handle hTable Returns Boolean
        Boolean bExists bIsSQLTable
        String sDataPath sRootName

        Get _UtilTableNumberIsInUse hTable to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Move False to bIsSQLTable
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Move (sRootName contains ":") to bIsSQLTable
        End
        If (bIsSQLTable = True) Begin
            Get _UtilTableIsSql hTable to bExists
            Function_Return bExists
        End
        Else Begin
            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
            Get vFolderFormat sDataPath to sDataPath
            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
        End

        Function_Return bExists
    End_Function

    // Pass a table handle
    // Returns True if the table exists in filelist.cfg.
    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
        Handle hTable
        Boolean bFound

        Move False to bFound
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                If (hTable = hCheckTable) Begin
                    Move True to bFound
                End
            End
            If (bFound = True) ;
                Break
        Until (hTable = 0)

        Function_Return (bFound = True)
    End_Function

    // DataFlex Embedded Database Data Types:
    // Helper function for _UtilEnumerateColumnTypes
    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        Move DF_ASCII           to ColumnType[i].iSQLType
        Move "ASCII"            to ColumnType[i].sSQLType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move DF_BCD             to ColumnType[i].iSQLType
        Move "Numeric"          to ColumnType[i].sSQLType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move DF_DATE            to ColumnType[i].iSQLType
        Move "Date"             to ColumnType[i].sSQLType
        Move DF_DATE            to ColumnType[i].iDataFlexType
        Move "Date"             to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bCanEditSize
        Increment i

        Move DF_TEXT            to ColumnType[i].iSQLType
        Move "Text"             to ColumnType[i].sSQLType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move DF_BINARY          to ColumnType[i].iSQLType
        Move "Binary"           to ColumnType[i].sSQLType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move DF_DATETIME        to ColumnType[i].iSQLType
        Move "DateTime"         to ColumnType[i].sSQLType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "23"               to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bCanEditSize
        Increment i

        Move DF_OVERLAP         to ColumnType[i].iSQLType
        Move "Overlap"          to ColumnType[i].sSQLType
        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
        Move "Overlap"          to ColumnType[i].sDataFlexType
        Move "0.0"              to ColumnType[i].sPrecision

        Function_Return ColumnType
    End_Function

    Function _UtilEnumerateDB2Types Returns tColumnType[]
        tColumnType[] aColumnType
        Integer i

        #Include DB2_DRV_DriverDef.inc
//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
//        Move "DBCLOB"           to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_BIGINT         to ColumnType[i].iSQLType
//        Move "BIGINT"           to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.0"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_BLOB           to ColumnType[i].iSQLType
//        Move "BLOB"             to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "BINARY"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_CHAR           to ColumnType[i].iSQLType
//        Move "CHAR"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        // ToDo: We need to change the sType when using this!
//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
//        Move DF_BINARY              to ColumnType[i].iDataFlexType
//        Move "Binary"               to ColumnType[i].sDataFlexType
//        Move "254"                  to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_DATE           to ColumnType[i].iSQLType
//        Move "DATE"             to ColumnType[i].sSQLType
//        Move DF_DATE            to ColumnType[i].iDataFlexType
//        Move "Date"             to ColumnType[i].sDataFlexType
//        Move "6.0"              to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move SQL_CLOB           to ColumnType[i].iSQLType
//        Move "CLOB"             to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
//        Move "DECIMAL"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
//        Move "DOUBLE"           to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_FLOAT          to ColumnType[i].iSQLType
//        Move "FLOAT"            to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
//        Move "GRAPHIC"          to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "255"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_INTEGER        to ColumnType[i].iSQLType
//        Move "INTEGER"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "9.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "32000"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "32000"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "32000"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
//        Move "NUMERIC"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_REAL           to ColumnType[i].iSQLType
//        Move "REAL"             to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
//        Move "SMALLINT"         to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
//        Move "5.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_TIME           to ColumnType[i].iSQLType
//        Move "TIME"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "19.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
//        Move "DATETIME"         to ColumnType[i].sDataFlexType
//        Move "23.6"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
//        Move "VARCHAR"          to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        // ToDo: We need to change the sType when using this!
//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
//        Move DF_TEXT                to ColumnType[i].iDataFlexType
//        Move "TEXT"                 to ColumnType[i].sDataFlexType
//        Move "16384"                to ColumnType[i].sPrecision
//        Increment i
//
//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//
//        Move SQL_XML            to ColumnType[i].iSQLType
//        Move "XML"              to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision

        Function_Return aColumnType
    End_Function

    // Microsoft SQL Server Database Data Types:
    // Helper function for _UtilEnumerateColumnTypes
    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
        tColumnType[] aColumnType
        Integer i

        If (sDriverID = MSSQLDRV_ID) Begin
            #Include MSSQLDRV_DriverDef.inc

//            Move SQL_BIGINT         to ColumnType[i].iSQLType
//            Move "bigint"           to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "Numeric"          to ColumnType[i].sDataFlexType
//            Move "14.0"             to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_BINARY         to ColumnType[i].iSQLType
//            Move "binary"           to ColumnType[i].sSQLType
//            Move DF_BINARY          to ColumnType[i].iDataFlexType
//            Move "Binary"           to ColumnType[i].sDataFlexType
//            Move "8000"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_BIT            to ColumnType[i].iSQLType
//            Move "bit"              to ColumnType[i].sSQLType
//            Move DF_ASCII           to ColumnType[i].iDataFlexType
//            Move "ASCII"            to ColumnType[i].sDataFlexType
//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_CHAR           to ColumnType[i].iSQLType
//            Move "char"             to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "8000"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_DATE           to ColumnType[i].iSQLType
//            Move "date"             to ColumnType[i].sSQLType
//            Move DF_DATE            to ColumnType[i].iDataFlexType
//            Move "Date"             to ColumnType[i].sDataFlexType
//            Move "6.0"              to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_DATETIME       to ColumnType[i].iSQLType
//            Move "datetime"         to ColumnType[i].sSQLType
//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
//            Move "DateTime"         to ColumnType[i].sDataFlexType
//            Move "23.3"             to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
//            Move "datetime2"         to ColumnType[i].sSQLType
//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
//            Move "DateTime"          to ColumnType[i].sDataFlexType
//            Move "23.6"              to ColumnType[i].sPrecision
//            Move True                to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
//            Move "datetimeoffset"       to ColumnType[i].sSQLType
//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
//            Move "DateTime"             to ColumnType[i].sDataFlexType
//            Move "34.0"                 to ColumnType[i].sPrecision
//            Move True                   to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
//            Move "decimal"          to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "Numeric"          to ColumnType[i].sDataFlexType
//            Move "14.8"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_FLOAT          to ColumnType[i].iSQLType
//            Move "float"            to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "Numeric"          to ColumnType[i].sDataFlexType
//            Move "14.8"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_INTEGER        to ColumnType[i].iSQLType
//            Move "int"              to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "Numeric"          to ColumnType[i].sDataFlexType
//            Move "8.0"              to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
//            Move "money"            to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "Numeric"          to ColumnType[i].sDataFlexType
//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
//            Increment i
//
//            Move SQL_WCHAR          to ColumnType[i].iSQLType
//            Move "nchar"            to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "4000"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
//            Move "ntext"            to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "16384"            to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
//            Move "numeric"          to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "Numeric"          to ColumnType[i].sDataFlexType
//            Move "14.8"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
//            Move "nvarchar"         to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "Text"             to ColumnType[i].sDataFlexType
//            Move "4000"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "16384"            to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_REAL           to ColumnType[i].iSQLType
//            Move "real"             to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
//            Move "14.8"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
//            Move "smalldatetime"        to ColumnType[i].sSQLType
//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
//            Move "DATETIME"             to ColumnType[i].sDataFlexType
//            Move "23.0"                 to ColumnType[i].sPrecision
//            Move True                   to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
//            Move "smallint"         to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
//            Move "4.0"              to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
//            Move "smallmoney"        to ColumnType[i].sSQLType
//            Move DF_BCD              to ColumnType[i].iDataFlexType
//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
//            Move "10.0"              to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_TEXT           to ColumnType[i].iSQLType
//            Move "text"             to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "8000"             to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TIME           to ColumnType[i].iSQLType
//            Move "time"             to ColumnType[i].sSQLType
//            Move DF_ASCII           to ColumnType[i].iDataFlexType
//            Move "ASCII"            to ColumnType[i].sDataFlexType
//            Move "19.0"             to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TINYINT        to ColumnType[i].iSQLType
//            Move "tinyint"          to ColumnType[i].sSQLType
//            Move DF_BCD             to ColumnType[i].iDataFlexType
//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
//            Move "2.0"              to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_GUID           to ColumnType[i].iSQLType
//            Move "uniqueidentifier" to ColumnType[i].sSQLType
//            Move DF_ASCII           to ColumnType[i].iDataFlexType
//            Move "ASCII"            to ColumnType[i].sDataFlexType
//            Move "36"               to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
//            Move "varbinary"        to ColumnType[i].sSQLType
//            Move DF_BINARY          to ColumnType[i].iDataFlexType
//            Move "BINARY"           to ColumnType[i].sDataFlexType
//            Move "16384"            to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
//            Move "varbinary(max)"   to ColumnType[i].sSQLType
//            Move DF_BINARY          to ColumnType[i].iDataFlexType
//            Move "BINARY"           to ColumnType[i].sDataFlexType
//            Move "16384"            to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
//            Move "varchar"          to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "8000"             to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
//            Move "varchar(max)"     to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "16384"            to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_SS_XML         to ColumnType[i].iSQLType
//            Move "xml"              to ColumnType[i].sSQLType
//            Move DF_TEXT            to ColumnType[i].iDataFlexType
//            Move "TEXT"             to ColumnType[i].sDataFlexType
//            Move "16384"            to ColumnType[i].sPrecision
//            Increment i
//
//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
//            Move "DATE"             to ColumnType[i].sSQLType
//            Move DF_DATE            to ColumnType[i].iDataFlexType
//            Move "date"             to ColumnType[i].sDataFlexType
//            Move "6.0"              to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
//            Move "time"             to ColumnType[i].sSQLType
//            Move DF_ASCII           to ColumnType[i].iDataFlexType
//            Move "ASCII"            to ColumnType[i].sDataFlexType
//            Move "8.7"              to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i
//
//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
//            Move "datetime"         to ColumnType[i].sSQLType
//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
//            Move "DateTime"         to ColumnType[i].sDataFlexType
//            Move "23.6"             to ColumnType[i].sPrecision
//            Move True               to ColumnType[i].bCanEditSize
//            Increment i

        End

        Function_Return aColumnType
    End_Function

    // MySQL Data Types
    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
        tColumnType[] aColumnType
        Integer i

        #Include mdsmysql_DriverDef.inc

//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
//        Move "bigint"           to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.0"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_BIT         to ColumnType[i].iSQLType
//        Move "bit"              to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
//        Move "blob"             to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "BINARY"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_STRING      to ColumnType[i].iSQLType
//        Move "char"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "TEXT"             to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_DATE        to ColumnType[i].iSQLType
//        Move "date"             to ColumnType[i].sSQLType
//        Move DF_DATE            to ColumnType[i].iDataFlexType
//        Move "Date"             to ColumnType[i].sDataFlexType
//        Move "6.0"              to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
//        Move "datetime"         to ColumnType[i].sSQLType
//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
//        Move "DateTime"         to ColumnType[i].sDataFlexType
//        Move "23.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
//        Move "decimal"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
//        Move "double"           to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
//        Move "enum"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
//        Move "float"            to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_INT24       to ColumnType[i].iSQLType
//        Move "int"              to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
//        Move "11.0"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
//        Move "longblob"         to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
//        Move "longtext"         to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
//        Move "mediumblob"       to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_INT24       to ColumnType[i].iSQLType
//        Move "mediumint"        to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "9.0"              to ColumnType[i].sPrecision
//
//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
//        Move "mediumtext"       to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_SET         to ColumnType[i].iSQLType
//        Move "set"              to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
//        Move "smallint"         to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "6.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
//        Move "text"             to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_TIME        to ColumnType[i].iSQLType
//        Move "time"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "10.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
//        Move "timestamp"        to ColumnType[i].sSQLType
//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
//        Move "DateTime"         to ColumnType[i].sDataFlexType
//        Move "23.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
//        Move "tinyblob"         to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_TINY        to ColumnType[i].iSQLType
//        Move "tinyint"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "4.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
//        Move "tinytext"         to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
//        Move "varchar"          to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
//        Move "year"             to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
//        Move "4.0"              to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i

        Function_Return aColumnType
    End_Function

    // Oracle Data Types
    Function _UtilEnumerateOracleTypes Returns tColumnType[]
        tColumnType[] aColumnType
        Integer i

        #Include ora_drv_DriverDef.inc

//        Move eOracle_BLOB       to ColumnType[i].iSQLType
//        Move "BLOB"             to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_CHAR       to ColumnType[i].iSQLType
//        Move "CHAR"             to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "2000"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_CLOB       to ColumnType[i].iSQLType
//        Move "CLOB"             to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_DATE       to ColumnType[i].iSQLType
//        Move "DATE"             to ColumnType[i].sSQLType
//        Move DF_Date            to ColumnType[i].iDataFlexType
//        Move "Date"             to ColumnType[i].sDataFlexType
//        Move "6.0"              to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
//        Move "FLOAT"            to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Number"           to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_INT        to ColumnType[i].iSQLType
//        Move "INT"              to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Number"           to ColumnType[i].sDataFlexType
//        Move "14.0"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
//        Move "DateTime"         to ColumnType[i].sDataFlexType
//        Move "23.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
//        Move "DateTime"          to ColumnType[i].sDataFlexType
//        Move "23.0"              to ColumnType[i].sPrecision
//        Move True                to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eOracle_RAW        to ColumnType[i].iSQLType
//        Move "LONG"             to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
//        Move "LONG RAW"         to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
//        Move "NCHAR"            to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "2000"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
//        Move "NCLOB"            to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
//        Move "NUMBER"           to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Number"           to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "4000"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_RAW        to ColumnType[i].iSQLType
//        Move "RAW"              to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "2000"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_ROWID      to ColumnType[i].iSQLType
//        Move "ROWID"            to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
//        Move "TimeStamp"        to ColumnType[i].sSQLType
//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
//        Move "DateTime"         to ColumnType[i].sDataFlexType
//        Move "11.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
//        Move "DateTime"             to ColumnType[i].sDataFlexType
//        Move "13.0"                 to ColumnType[i].sPrecision
//        Move True                   to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
//        Move "DateTime"             to ColumnType[i].sDataFlexType
//        Move "11.0"                 to ColumnType[i].sPrecision
//        Move True                   to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
//        Move "VARCHAR"          to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision

        Function_Return aColumnType
    End_Function

    // PostgreSQL Data Types
    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
        tColumnType[] aColumnType
        Integer i

        #Include mdspgsql_DriverDef.inc

//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
//        Move "bigint"           to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "14.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
//        Move "bit"              to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
//        Move "boolean"          to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "1"                to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
//        Move "bytea"            to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
//        Move "char"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "2000"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
//        Move "citext"           to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "254"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
//        Move "date"             to ColumnType[i].sSQLType
//        Move DF_DATE            to ColumnType[i].iDataFlexType
//        Move "Date"             to ColumnType[i].sDataFlexType
//        Move "6.0"              to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
//        Move "decimal"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Decimal"          to ColumnType[i].sDataFlexType
//        Move "14.8"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
//        Move "double"           to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "22"               to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
//        Move "integer"          to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "8.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
//        Move "money"            to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "8.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_OID         to ColumnType[i].iSQLType
//        Move "oid"              to ColumnType[i].sSQLType
//        Move DF_BINARY          to ColumnType[i].iDataFlexType
//        Move "Binary"           to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
//        Move "real"             to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Real"             to ColumnType[i].sDataFlexType
//        Move "6.6"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
//        Move "regproc"          to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "64"               to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
//        Move "smallint"         to ColumnType[i].sSQLType
//        Move DF_BCD             to ColumnType[i].iDataFlexType
//        Move "Numeric"          to ColumnType[i].sDataFlexType
//        Move "6.0"              to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
//        Move "text"             to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "Text"             to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
//        Move "time"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "DateTime"         to ColumnType[i].sDataFlexType
//        Move "15.0"             to ColumnType[i].sPrecision
//        Increment i
//
//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
//        Move "timestamp"        to ColumnType[i].sSQLType
//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
//        Move "DateTime"         to ColumnType[i].sDataFlexType
//        Move "23.0"             to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
//        Move "uuid"             to ColumnType[i].sSQLType
//        Move DF_ASCII           to ColumnType[i].iDataFlexType
//        Move "ASCII"            to ColumnType[i].sDataFlexType
//        Move "40"               to ColumnType[i].sPrecision
//        Move True               to ColumnType[i].bCanEditSize
//        Increment i
//
//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
//        Move "varchar"          to ColumnType[i].sSQLType
//        Move DF_TEXT            to ColumnType[i].iDataFlexType
//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
//        Move "16384"            to ColumnType[i].sPrecision
//        Increment i

        Function_Return aColumnType
    End_Function

    // Internal usage. Use the UtilColumnTypeXXX functions instead.
    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
        Integer iValue iSize iCount iStart
        tColumnType[] ColumnTypeArray
        tColumnType RetvalType
        String sValue
        Boolean bFrameworkDataFlexType

        Move "Undefined" to RetvalType.sSQLType
        Move -1999       to RetvalType.iSQLType

        Move 0 to iStart
        Move (Uppercase(sType)) to sType
        Move (iType <= -1490) to bFrameworkDataFlexType
        If (bFrameworkDataFlexType = True) Begin
            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
            Function_Return RetvalType
        End

        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray

        Move (SizeOfArray(ColumnTypeArray)) to iSize
        Decrement iSize

        For iCount from iStart to iSize
            Move ColumnTypeArray[iCount].iSQLType to iValue
            Move ColumnTypeArray[iCount].sSQLType to sValue
            If (bIntegerInputType = True) Begin
                If (iValue = iType) Begin
                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
                    Move iType                                  to RetvalType.iSQLType
                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
                    Move iSize to iCount // We're done!
                End
            End
            Else Begin
                Move (Uppercase(sValue)) to sValue
                If (sValue = sType) Begin
                    Move sType                                  to RetvalType.sSQLType
                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
                    Move iSize to iCount // We're done!
                End
            End
        Loop

        // If no match was found it was probably because it was a DataFlex standard type that was passed.
        // In which case we search for a match in DataFlex standard types:
        If (RetvalType.sSQLType = "Undefined") Begin
            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
            Move (SizeOfArray(ColumnTypeArray)) to iSize
            Decrement iSize

            For iCount from iStart to iSize
                Move ColumnTypeArray[iCount].iSQLType to iValue
                Move ColumnTypeArray[iCount].sSQLType to sValue
                If (iValue = iType) Begin
                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
                    Move iType                                  to RetvalType.iSQLType
                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
                    Move iSize to iCount // We're done!
                End
            Loop
        End

        Function_Return RetvalType
    End_Function

    // Returns a struct array with all data types for the passed driver & dbtype.
    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
        tColumnType[] ColumnType

        // We need to treat DAW's ODBC driver a bit different, as the output depends on
        // the dbType.
        If (sDriverID = ODBC_DRV_ID) Begin
            If (iDbType = EN_DbTypeMySQL) Begin
                Move ODBC_DRV_ID to sDriverID
            End
            If (iDbType = EN_DbTypeMSSQL) Begin
                Move MSSQLDRV_ID to sDriverID
            End
            If (iDbType = EN_DbTypeDB2) Begin
                Move DB2_DRV_ID to sDriverID
            End
            If (iDbType = EN_DbTypePostgre) Begin
                Move ODBC_DRV_ID to sDriverID
            End
        End

        Case Begin
            Case (iDbType = EN_dbTypeDataFlex)
                Get _UtilEnumerateDataFlexTypes to ColumnType
                Case Break

            Case (iDbType = EN_DbTypeDB2)
                Get _UtilEnumerateDB2Types to ColumnType
                Case Break

            Case (iDbType = EN_DbTypeMSSQL)
                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
                Case Break
        Case End

        Function_Return ColumnType
    End_Function

    // Returns a struct with the default column types for the SQL back-end and how they
    // are mapped to a DUF data type.
    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
        tColumnType ColumnType
        String sDataType
        Integer iDriverID iCount

        Move 0 to iCount
        Get DriverIndex sDriverID to iDriverID

        Case Begin
            // DF_ASCII
            Case (iType = DF_ASCII_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_ASCII    to ColumnType.iDataFlexType
                Move "ASCII"     to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sSQLType
                Move DF_ASCII    to ColumnType.iSQLType
                Move False       to ColumnType.bCanEditSize
                Case Break

            // DF_BINARY
            Case (iType = DF_BINARY_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_BINARY   to ColumnType.iDataFlexType
                Move "Binary"    to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sSQLType
                Move DF_BINARY   to ColumnType.iSQLType
                Move False       to ColumnType.bCanEditSize
                Case Break

            // DF_DATE
            Case (iType = DF_DATE_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_DATE     to ColumnType.iDataFlexType
                Move "Date"      to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sSQLType
                Move DF_DATE     to ColumnType.iSQLType
                Move True        to ColumnType.bCanEditSize
                Case Break

            // DF_DATETIME
            Case (iType = DF_DATETIME_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_DATETIME to ColumnType.iDataFlexType
                Move "DateTime"  to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sSQLType
                Move DF_DATETIME to ColumnType.iSQLType
                Move True        to ColumnType.bCanEditSize
                Case Break

            // DF_NUMERIC
            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
            // we make them here all "Numeric"...
            // If (sDriverID = ODBC_DRV_ID) Begin
            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
            // End
            // Else Begin
            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
            // End
            // ToDo: How should we find the best "Numeric" data type here?
            Case (iType = DF_BCD_DUF)
                Move DF_BCD      to ColumnType.iDataFlexType
                Move "Numeric"   to ColumnType.sDataFlexType
                Move "Numeric"   to ColumnType.sSQLType
                Move SQL_NUMERIC to ColumnType.iSQLType
                Move False       to ColumnType.bCanEditSize
                Case Break

            // DF_TEXT
            Case (iType = DF_TEXT_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_TEXT     to ColumnType.iDataFlexType
                Move "Text"      to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sSQLType
                Move DF_TEXT     to ColumnType.iSQLType
                Move False       to ColumnType.bCanEditSize
                Case Break

            Case Else
                Move -1999       to ColumnType.iDataFlexType
                Move "Undefined" to ColumnType.sDataFlexType
                Move "Undefined" to ColumnType.sSQLType
                Move -1999       to ColumnType.iSQLType
                Move True        to ColumnType.bCanEditSize

        Case End

        Function_Return ColumnType
    End_Function

    Function _AllTablesToConvert Returns Integer[]
        Integer[] aTableConvertExceptions iTablesArray
        Handle hTable
        Integer iIndex
        String sTableName
        Boolean bFlexErrs

        // a) Get the exception table array the developer has specified
        Get paTableConvertExceptions to aTableConvertExceptions

        // b) Add CodeMast, CodeType & DbVersion to exceptions
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
                If (bFlexErrs = False) Begin
                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
                        If (iIndex = -1) Begin
                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
                        End
                    End
                End
            End
        Until (hTable = 0)

        Move 0 to hTable

        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
                If (bFlexErrs = False) Begin
                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
                    If (iIndex = -1) Begin
                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
                    End
                End
            End
        Until (hTable = 0)

        Function_Return iTablesArray
    End_Function

    Function _AllTablesDateCorrections Returns Integer[]
        Integer[] aTableDateCorrectionExceptions iTablesArray
        Handle hTable
        Integer iIndex
        String sTableName
        Boolean bFlexErrs

        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
        Move 0 to hTable

        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
                If (bFlexErrs = False) Begin
                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
                    If (iIndex = -1) Begin
                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
                    End
                End
            End
        Until (hTable = 0)

        Function_Return iTablesArray
    End_Function

    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
        tAPIColumn NewAPIColumn

        Move sFieldName to NewAPIColumn.sFieldName
        Move iType      to NewAPIColumn.iType
        Move iLength    to NewAPIColumn.iLength
        Move iPrecision to NewAPIColumn.iPrecision
        Move iOptions   to NewAPIColumn.iOptions

        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]

        Function_Return aCurrent
    End_Function

    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
        String sRetval sFieldName
        Integer iCount iSize

        Move (SizeOfArray(APIIndexSegment)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move APIIndexSegment[iCount].sFieldName to sFieldName
            Move (sRetval * (String(sFieldName))) to sRetval
        Loop
        Move (Trim(sRetval)) to sRetval

        Function_Return sRetval
    End_Function

    // *** Miscellaneous other functions ***
    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
    //

    // Callback functionality used when e.g. calling driver functions directly.
    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
        Integer iPerc
        Number nReady nTotal

        Send DoAdvance of ghoProgressBar

        If (sCallback_Text contains "Copy records") Begin
            Move CS_DUF_CopyingData to sCallback_Text
        End
        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
        End
        If (sCallback_Text contains "Creating index") Begin
            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
        End

        Case Begin
            Case (iCallback_Type = DF_Message_Text)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_1)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_2)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_3)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_4)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_5)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Warning)
                Send None
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Title)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Value)
                //*** Interpret numbers
                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
                Move ((nReady / nTotal) * 100)                                                    to iPerc
                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
                Case Break
            Case Else
                Set Message_Text to ""
                Set Action_Text  to ""
        Case End

        Send ProcessEvents of ghoStatusPanel
        Function_Return False
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // *** Helper functions with compiled sql script code ***
    //
    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
    // For data types that are stored inline in the rows (int for example) it may even take up space on
    // the new rows added after the alter statement. to get around this you need to create a clustered
    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
    //   ALTER TABLE MyTable
    //       REBUILD
    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
        Boolean bOK

        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
            Function_Return False
        End

        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK

        Function_Return (bOK = True)
    End_Function

    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
    // For data types that are stored inline in the rows (int for example) it may even take up space on
    // the new rows added after the alter statement. To get around this you need to create a clustered
    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
    //   ALTER TABLE MyTable
    //       REBUILD
    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
        tSQLScriptArray SQLScriptArray
        String sDriverID
        Boolean bOK
        Integer iSize iCount

        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
            Function_Return False
        End

        Get psDriverID to sDriverID
        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
        If (SQLScriptArray.bError = True) Begin
            Function_Return False
        End

        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
        Loop

        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK

        Function_Return (bOK = True)
    End_Function

    // Reads a SQL script file that has been compiled into the .exe program as a resource.
    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
        Integer iChannel iArgumentSize iCount
        Number nByteCount
        String sSQLScript
        tSQLScriptArray SqlScriptArray
        UChar[] uCharData

        Move False to Err
        Get Seq_New_Channel to iChannel
        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM 'No channel available...'
            Move True to SqlScriptArray.bError
            Function_Return SqlScriptArray
        End

        // First decide the size of the script
        Direct_Input channel iChannel ("Resource: " + sMemFileName)
        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
        Close_Input channel iChannel

        Move (SizeOfArray(uCharData)) to nByteCount
        If (nByteCount  < 1) Begin
            Send Seq_Release_Channel iChannel
            Move True to SqlScriptArray.bError
            Function_Return SqlScriptArray
        End

        // If necessary change the string argument_size
        // Read the script file from memory line-by-line
        Direct_Input channel iChannel ("Resource: " + sMemFileName)
            Move 0 to iCount
            Repeat
                Readln channel iChannel sSQLScript
                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
                Increment iCount
            Until (SeqEof = True)
        Close_Input channel iChannel
        Send Seq_Release_Channel iChannel

        // Finally "sanitize" the script by removing all comments.
        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray

        Function_Return SqlScriptArray
    End_Function

    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
        Handle hoSql hoSQLConnect hoStmt hoError
        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
        String[] sMsg aSQLQueryMessages
        DateTime dtQueryExecStart dtQueryExecEnd
        TimeSpan tsQuery
        tSqlErrorArray aSqlErrorArray
        tSQLConnection SQLConnection
        Boolean bShowProgress

        If (num_arguments > 4) Begin
            Move bShowProgr to bShowProgress
        End
        Get phoSQLManager to hoSql

        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
        // There seems to be a problem to pass strings when their value gets really big, aka
        // above the argument_size level. It isn't clear when these problems starts but sooner
        // or later SqlExecDirect stops working correctly with no error messages!
        // To guard from this we set a max number of lines (iChunkMax) that can be processed
        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
        // A bonus of this is that it turns out that it is actually faster to run in chunks!
        Get piChunkMax to iChunkMax
        Move 0 to iChunkCounter
        Move "" to sStmt

        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
        Move (Character(13) + Character(10)) to sCR

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection

        Get phoSQLManager  to hoSQL
        If (sDriverID = ODBC_DRV_ID) Begin
            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
                If (iPos > 0) Begin
                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
                End
            End
        End
        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
        Get SqlConnect     of hoSQL "" "" to hoSQLConnect

        If (hoSQLConnect <> 0) Begin
            Move False to Err
            Get SqlOpen of hoSQLConnect to hoStmt
            If (hoStmt <> 0) Begin

                // If the embedded resource should be written as a script file to disk:
                If (bCreateScriptFile = True) Begin
                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
                    Get vFolderFormat sExportFile to sExportFile
                    Move (sExportFile + sMemFileName) to sExportFile
                    Get Seq_New_Channel to iOut
                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
                        Direct_Output channel iOut sExportFile
                    End
                End

                // Record starting date/time stamp
                Move (CurrentDateTime()) to dtQueryExecStart
                // Turn on error handling if enabled
                If (pbHandleQueryErrors(Self)) Begin
                    Set pbSqlError to False
                    Set paSqlErrorArray to aSqlErrorArray
                    Move Error_Object_Id to hoError
                    Move Self to Error_Object_Id
                End

                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
                Decrement iRows
                If (sDriverID = MSSQLDRV_ID) Begin
                    Move (sNoCountKeyWord + sCR) to sStmt
                End

                for iCount from 0 to iRows
                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal

                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
                        If (sSQLVal <> "") Begin
                            Move (sSQLVal + sCR) to sSQLVal
                        End
                        Move (Append(sStmt, (sSQLVal))) to sStmt
                    End

                    // - Each time we encounter a "GO" statement we execute it,
                    // or if at the very end of the script.
                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin

                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
                        // instead of all in one go.
                        Send SqlExecDirect of hoStmt sStmt

                        If (bCreateScriptFile = True) Begin
                            Write channel iOut sStmt
                        End
                        Move "" to sStmt
                        Move 0 to iChunkCounter
                    End
                    Increment iChunkCounter
                Loop

                Repeat
                    If (pbHandleQueryErrors(Self)) Begin
                        Move hoError to Error_Object_Id
                    End
                    Move (CurrentDateTime()) to dtQueryExecEnd

                    Send _SqlColumnInfo hoStmt
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
                    Set piRows    to iRows
                    Set piRowType to iRowType

                    If (iMsgs <> 0) Begin
                        If (ghoDbUpdateHandler > 0) Begin
                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                        End
                        for i from 1 to iMsgs
                            Get SqlGetMessage of hoStmt i to sMessage
                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
                            If (bShowProgress = True) Begin
                                If (Active_State(ghoStatusPanel)) Begin
                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
                                End
                                Else Begin
                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
                                End
                            End
                            Move sMessage to sMsg[SizeOfArray(sMsg)]
                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
                        Loop


                        If (ghoDbUpdateHandler > 0) Begin
                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                        End
                        Set paQueryMessages to sMsg
                    End

                    Get SQLNextResultSet of hoStmt to iNextSet
                Until (iNextSet = 0)

                Move (CurrentDateTime()) to dtQueryExecEnd
            End

            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
            Set ptsQueryExec to tsQuery
            Send SqlClose of hoStmt

            If (bCreateScriptFile = True) Begin
                Close_Output channel iOut
                Send Seq_Release_Channel iOut
            End
        End
        Send SqlDisconnect of hoSQLConnect

        Function_Return (hoSQLConnect <> 0 and Err = False)
    End_Function

    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
        tSQLScriptArray SQLScriptArray
        String sDriverID sCollation
        Boolean bOK
        Integer iSize iCount

        If (Trim(sDatabaseName) = "") Begin
            Function_Return False
        End

        Get psDriverID  to sDriverID
        Get psCollation to sCollation
        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
        If (SQLScriptArray.bError = True) Begin
            Function_Return False
        End

        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
        Loop

        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK

        Function_Return (bOK = True)
    End_Function

    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
        tSQLScriptArray SQLScriptArray
        String sDriverID sCollation
        Boolean bOK
        Integer iSize iCount

        If (Trim(sDatabaseName) = "") Begin
            Function_Return False
        End

        Get psDriverID  to sDriverID
        Get psCollation to sCollation
        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
        If (SQLScriptArray.bError = True) Begin
            Function_Return False
        End

        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
        Loop
        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK

        Function_Return (bOK = True)
    End_Function

    Function _StrToFieldNumber Integer iFile String sField Returns Integer
        Integer iMax iPos
        String sName

        Move (Lowercase(sField)) to sField
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
        For iPos from 0 to iMax
            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
            Move (Lowercase(sName)) to sName
            If (sName = sField) Begin
                Function_Return iPos
            End
        Loop
        Function_Return -1
    End_Function

    // Checks if the passed connection id exists in the CLI interface.
    // This might be needed by API-methods when a connection id is to be used and
    // the connection id hasn't been established with the driver's CLI interface.
    // NOTE: Only applicable for DAW drivers.
    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
        String sID sConnString
        Integer iDriver iNumConn iCount
        Handle hoCLI
        Boolean bOK

        Get IsDAWSQLDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
            Function_Return False
        End

        Move False to bOK
        Get phoCLIHandler to hoCLI
        If (hoCLI <> 0) Begin
            Set psDriverID of hoCLI to sDriverID
            Get DriverIndex of hoCLI sDriverID to iDriver

            // If driver not loaded; load it.
            If (iDriver = 0) Begin
                Load_Driver sDriverID
                Get DriverIndex sDriverID to iDriver
            End
            If (iDriver <> 0) Begin
                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
                Decrement iNumConn
                For iCount from 0 to iNumConn
                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
                    If (sID = sConnectionID) Begin
                        Move True to bOK
                    End
                Loop
            End
        End

        Function_Return bOK
    End_Function

    Function IsDAWSQLDriver String sDriverID Returns Boolean
        Boolean bOK
        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
        Function_Return bOK
    End_Function

    Function IsMSSQLDriver Returns Boolean
        Integer iDriverIndex
        Get DriverIndex MSSQLDRV_ID to iDriverIndex
        Function_Return (iDriverIndex <> 0)
    End_Function

    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
    // attempt to load the driver.
    // Returns true if the passed driver is SQL based.
    Function IsSQLDriver String sDriverID Returns Boolean
        Boolean bOK
        Get IsDAWSQLDriver sDriverID to bOK
        Function_Return bOK
    End_Function

    // *** Error Handler ***
    //
    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
        Integer iSize iErrorMode
        tSqlErrorArray aSqlErrorArray

        If (pbProcessingError(Self)) Begin
            Procedure_Return
        End

        Get Error_Report_Mode to iErrorMode
        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
            Procedure_Return
        End

        Set pbProcessingError to True
        Set pbSqlError to True
        Get paSqlErrorArray      to aSqlErrorArray
        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
        Set paSqlErrorArray      to aSqlErrorArray
        Set pbProcessingError to False
    End_Procedure

    // *** Miscellanous Helper Functions ***
    //
    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
    // returns the table name only; stripped of any path or filename extension.
    Function _TableNameOnly String sName Returns String
        String sPath sExt

        Get ParseFolderName sName to sPath
        If (sPath <> "") Begin
            Move (Replace(sPath, sName, "")) to sName
        End
        Get ParseFileExtension sName to sExt
        If (sExt <> "") Begin
            Move (Replace(("." + sExt), sName, "")) to sName
        End

        Function_Return sName
    End_Function

    // Removes any prefix to a table name.
    // Example mssqldrv:mytable returns mytable
    //         dbo.mytable returns mytable
    Function _TableNoPrefix String sName Returns String
        Integer iPos

        Move (Pos(":", sName)) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sName, 999, (iPos + 1))) to sName
        End
        Move (Pos(".", sName)) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sName, 999, (iPos + 1))) to sName
        End

        Function_Return sName
    End_Function

    // Returns the first datapath found in the psDataPath property.
    // The returned path always ends with a "\"
    Function psDataPathFirstPart Returns String
        String sDataPath
        Integer iCount

        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
        End
        If (sDataPath <> "") Begin
            Get vFolderFormat sDataPath to sDataPath
        End

        Function_Return sDataPath
    End_Function

    Function psLogTextFileWithPath Returns String
        String sFileName
        Handle hoLogFile
        Get phoLogFile to hoLogFile
        Get psLogTextFileWithPath of hoLogFile to sFileName
        Function_Return sFileName
    End_Function

    Function phoLogFile Returns Handle
        Handle hoLogFile   
        Boolean bErr
        
        Move Err to bErr
        Move 0 to hoLogFile
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Delegate Get phoLogFile to hoLogFile
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Move bErr to Err
        
        Function_Return hoLogFile
    End_Function

    Function pnCurrentVersionUpdate Returns Number
        Number nCurrentVersionUpdate

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return nCurrentVersionUpdate
    End_Function

    Procedure LogError String sText Boolean bError
        Handle hoLogFile
        Number nCurrentVersionUpdate

        Get phoLogFile to hoLogFile
        If (hoLogFile = 0) Begin
            Procedure_Return
        End
        Get pnCurrentVersionUpdate to nCurrentVersionUpdate

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
        Set Error_Report_Mode to DUF_ERROR_REPORT
    End_Procedure

    Function pbContinueOnError Returns Boolean
        Boolean bContinueOnError
        If (ghoDbUpdateHandler > 0) Begin
            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
        End
        Function_Return bContinueOnError
    End_Function

    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
        Integer iChIn iChOut // iCount
        Boolean bExists
        String sExistingColumn

        Move False to bExists
        Get Seq_New_Channel to iChIn
        Get Seq_New_Channel to iChOut
        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Function_Return True
        End

        Move False to Err
        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
        While (not(SeqEof))
            Readln channel iChIn sExistingColumn
            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
                Move True to bExists
            End
            If (Trim(sExistingColumn) = "") Begin
                Move True to SeqEof
            End
        Loop
        Close_Input channel iChIn
        Send Seq_Release_Channel iChIn

        If (bExists = False) Begin
            Append_Output channel iChOut sFullTAGFileName
            Writeln channel iChOut sColumnName
            Close_Output channel iChOut
            Send Seq_Release_Channel iChOut
        End

        Function_Return (Err = False)
    End_Function

    // Changes source code files.
    // Pass a file name with full path and a value to search for, together with the value
    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
    // to use a Connection ID.
    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
    // Returns True if no errors occured.
    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
        Integer iCh iRow iItems iCount
        String sValue sRow
        String[] sFileArray
        Boolean bExists bIsActive

        Move False to Err
        Move 0 to iRow

        If (ghoStatusPanel <> 0) Begin
            Get Active_state of ghoStatusPanel to bIsActive
        End

        Get vFilePathExists sFileName to bExists
        If (bExists = False) Begin
            If (bShowResult = True) Begin
                If (bIsActive = True) Begin
                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
                End
                Else Begin
                    Showln "File does not exist: " sFileName
                End
            End
            Function_Return False
        End

        Get Seq_Open_Input_Channel sFileName to iCh
        If (iCh < 1) Begin
            Function_Return False
        End

        If (bShowResult = True) Begin
            If (ghoStatusPanel <> 0) Begin
                Get Active_state of ghoStatusPanel to bIsActive
                If (bIsActive = True) Begin
                    Set Message_Text of ghoStatusPanel to sFileName
                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
                    Send DoAdvance of ghoProgressBar
                End
            End
            Else Begin
                Showln ""
                Showln "sFileName = " sFileName
                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
            End
        End

        While (not(SeqEof))
            Readln channel iCh sRow
            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
//                If (bShowResult = True) Begin
//                    If (bIsActive = True) Begin
//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
//                    End
//                    Else Begin
//                        Showln "Changed from: " sRow " to: " sChangeTo
//                    End
//                End
                // Change the whole line to the new connection id:
                Move sChangeTo to sRow
                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
            End
            Move sRow to sFileArray[iRow]
            Increment iRow
        Loop
        Send Seq_Close_Channel iCh

        Sleep 1 // Wait for Windows to close the file

        Get Seq_Open_Output_Channel sFileName to iCh
        If (iCh < 1) Begin
            Function_Return False
        End
        Move (SizeOfArray(sFileArray)) to iItems
        Decrement iItems

        for iCount from 0 to iItems
            Move sFileArray[iCount] to sValue
            Writeln channel iCh sValue
        Loop
        Send Seq_Close_Channel iCh

        Function_Return (Err = False)
    End_Function

    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
    // and opens it in "notepad.exe".
    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
    Procedure _UtilShowErrorList
        tSqlErrorArray aSqlErrorArray
        Integer iRows iCount iCh iErrorNum
        String sPath sFileName sErrorTxt sStatement

        Get psHome of (phoWorkspace(ghoApplication)) to sPath
        Get vFolderFormat sPath to sPath
        Move "SQLErrorLog.txt"  to sFileName
        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
            Get paSqlErrorArray to aSqlErrorArray
            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
            If (iRows > 0) Begin
                Decrement iRows
                for iCount from 0 to iRows
                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
                    Writeln channel iCh "SQL Statement: " sStatement
                Loop
            End
        Send Seq_Close_Channel iCh

        If (iRows > 0) Begin
            Runprogram Shell Background (sPath + sFileName)
        End
    End_Procedure

    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
    // and the table needs to exist as an SQL table.
    Function _UtilTableIsSql Handle hTable Returns Boolean
        String sRootName sDriverID
        Boolean bIsSQL

        Move False to bIsSQL
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
            If (bIsSQL = True) Begin
                Get psDriverID to sDriverID
                Get _TableNameOnly sRootName to sRootName
                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
            End
        End

        Function_Return bIsSQL
    End_Function

    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
        Boolean bIsSQL
        Move (sRootName contains ":") to bIsSQL
        Function_Return bIsSQL
    End_Function

    // Checks if a table exists as an SQL table. Returns = True if it does.
    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
        String sDatabase sSchema sVal
        Boolean bExists
        String[] sTablesArray
        Integer iSize iCount

        Move False to bExists
        Get psDatabase to sDatabase
        Get psSchema   to sSchema
        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move True to bExists
                Move iSize to iCount // We're done!
            End
        Loop

        Function_Return bExists
    End_Function

    // Checks that the passed hTable number both exists in Filelist.cfg and
    // that the embedded .dat file exists on disk.
    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
        Boolean bExists bIsEmbedded
        String sDataPath sRootName

        Get _UtilTableNumberIsInUse hTable to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Move False to bIsEmbedded
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Move (not(sRootName contains ":")) to bIsEmbedded
        End
        If (bIsEmbedded = True) Begin
            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
            Get vFolderFormat sDataPath to sDataPath
            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
        End

        Function_Return bIsEmbedded
    End_Function

End_Class
