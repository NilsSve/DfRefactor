//****************************************************************************
// $Module type: Class
// $Module name: cDbUpdateFunctionLibrary
// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
// Web-site    : http://www.rdctools.com
// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
//
// Description : The class consists of a function library for database manipulations, aka make changes to a database.
//               It has top level functions that uses the DataFlex db API, _but_ also specialized
//               functions to make db changes to Sql databases with DAW drivers,
//               with the help of Sql-scripts.
//
// $Rev History:
//    2014-09-05  Module header created
//
//****************************************************************************
//
// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
// decimals you may Get truncation that again may cause problems with finding.
//
// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
// This is important to realize. The conversion will actually change the data in the database (done by the driver)


// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
//
Use cBaseDbUpdateFuncLib.pkg

Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib

    Procedure Construct_Object
        Forward Send Construct_Object
        Move Self to ghoDbUpdateFunctionLibrary
    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
    End_Procedure

    // *** SQL Messages for making changes to the SQL back-end ***
    //
    // * Dummy function for the Studio's Code Explorer *
    Function SQL_DATABASE_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Function for creating a new *Database*.
    // Note: This is for creating SQL DATABASES - not tables!
    // Returns True if successful.
    // ToDo: Currently only works for MS-SQL...
    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
        String sSQL sSQL1 sConnectionID sConnectionString
        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
        Handle hConnection hStmt hoSQLManager
        Integer iFetchResult iDbType
        Boolean bOK bExists

        Get piDbType to iDbType
        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
            Function_Return False
        End

        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
        If (bExists = True) Begin
            Function_Return True
        End

        Get phoSQLManager to hoSQLManager

        Get psConnectionID     to sConnectionID
        Get psConnectionString to sConnectionString
        Move 0 to LastErr

        If (sDriverID = ODBC_DRV_ID) Begin
            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
//                Move (Pos(";", sConnectionString)) to iPos
//                If (iPos > 0) Begin
//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
//                    Move (Trim(sConnectionString)) to sConnectionString
//                End
//            End
        End

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
            Function_Return False
        End

        Get SqlOpen of hConnection to hStmt

        If (hStmt = 0) Begin
            Send SqlDisconnect of hoSQLManager
            Error DFERR_PROGRAM CS_DUF_ConnectError
            Function_Return False
        End

        Get psCollation to sCollation

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
                Get _SqlSelectFromWhereName to sSelectFromWhereName
                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL

                // Check if database exists
                Send SqlExecDirect of hStmt sSQL
                Get SqlFetch of hStmt to iFetchResult
                Send SqlClose of hStmt
                Send SqlDisconnect of hConnection
                // If database already exists we're out of here!
                // Note that we return True as this is not an error.
                If (iFetchResult > 0) Begin
                    Function_Return True
                End
                // Database doesn't exist, create it.
                If (iFetchResult = 0) Begin
                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
                    If (sCollation <> "") Begin
                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
                    End
                    Send SqlUtilExecuteQuery sSQL1 sDriverID
                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
                        Function_Return False
                    End
                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
                    Sleep 1
                    Send SqlUtilExecuteQuery sSQL sDriverID
                End
                Case Break

            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
                // ToDo: How should this be set/checked?
//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
//                    Set psCollation to "utf8"
//                End
                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported database type"
        Case End

        If (Err = False) Begin
            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
        End
        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
        // the one we just created.
        If (bUpdateConnectionString = True and Err = False) Begin
            Set psDatabase to sDatabase
            //...and perhaps also the SQLConnections.ini file setting.
            If (bPermanantly = True) Begin
                If (ghoSQLConnectionHandler <> 0) Begin
                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
                End
            End
        End

        Function_Return (Err = False)
    End_Function

    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
    // will be used.
    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
        Boolean bOK bExists bShowProgress bErr
        String sStatement sDriverID
        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
        Integer iDbType

        If (sDatabase = "") Begin
            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
            Function_Return False
        End
        If (sBackupName = "") Begin
            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
            Function_Return False
        End

        // Create backup-folder if it doesn't exist
        Get vFolderExists sPath to bExists
        If (bExists = False) Begin
            Get vCreateDirectory sPath to bErr
            If (bErr = True) Begin
                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
                Function_Return False
            End
        End
        // Make sure the path ends with a back-slash
        If (sPath <> "") Begin
            Get vFolderFormat sPath to sPath
        End

        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        If (num_arguments > 3) Begin
            Move bShowProg to bShowProgress
        End

        Case Begin
            Case (iDbType = EN_DbTypeMSSQL)
                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady

                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
                Case Break
            Case Else
                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
        Case End

        Function_Return bOK
    End_Function

    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
        String sStatement sDriverID sRetval //sPrevious
        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
        Integer iDbType iRows iFetchResult //iColumn
        Handle hoSQLHandler hoSQLConnect hstmt
        tSQLConnection SQLConnection

        If (sDatabase = "") Begin
            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
            Function_Return ""
        End

        Move "" to sRetval
        Get psDriverID to sDriverID
        Get piDbType   to iDbType

        Case Begin
            Case (iDbType = EN_DbTypeMSSQL)
                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray

                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
                Get phoSQLManager to hoSQLHandler

                If (hoSQLHandler <> 0) Begin
                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect

                    If (hoSQLConnect <> 0) Begin
                        Get SQLOpen of hoSQLConnect to hstmt
                        If (hstmt <> 0) Begin
                            Send SqlExecDirect of hstmt sStatement
                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
                            Get SQLFetch of hstmt to iFetchResult
                            If (iFetchResult <> 0) Begin
                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
                            End
                            Send SQLClose of hstmt
                        End
                        Send SQLDisconnect of hoSQLConnect
                    End
                End
                Case Break
            Case Else
                If (bSilent = False) Begin
                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
                End
        Case End

        Function_Return sRetval
    End_Function

    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
        Handle hConnection hStmt hoSQLManager
        Integer iDbType // iFetchResult

        If (sDatabase = "") Begin
            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
            Function_Return False
        End

        If (sSQLCollation = "") Begin
            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
            Function_Return False
        End

        Get psDriverID to sDriverID
        Get piDbType   to iDbType

        Get phoSQLManager to hoSQLManager
        Get psConnectionID     to sConnectionID
        Get psConnectionString to sConnectionString
        Move 0 to LastErr

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
            Function_Return False
        End

        Get SqlOpen of hConnection to hStmt

        If (hStmt = 0) Begin
            Send SqlDisconnect of hoSQLManager
            Error DFERR_PROGRAM CS_DUF_ConnectError
            Function_Return False
        End

        // Check if collation already exists
        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
        // If the current collate is the same as the new; do nothing.
        If (sSQLCollation = sSQLCollationCheck) Begin
            Function_Return True
        End

        Get _SqlFindKeyWord CI_SQLSet               to sSet
        Get _SqlFindKeyWord CI_SQLWith              to sWith
        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord

        // MS-SQL Syntax:
        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
        // ALTER DATABASE [database] SET MULTI_USER;
        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL

        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Send SqlUtilExecuteQuery sSQL sDriverID False
        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        If (LastErr = CLIERR_GENERAL_ERROR) Begin
           Function_Return False
        End

        Function_Return (Err = False)
    End_Function


    // * Dummy function for the Studio's Code Explorer *
    Function SQL_TABLE_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Converts from SQL to Embedded (DataFlex .dat files).
    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
        Handle hToTable
        Boolean bOK bExists bOpened bCopyData
        String sDriverID sPhysicalName sRootName sDisplayName
        tSQLConnection SQLConnection
        Integer iPos iMaxRecords

        Get psDriverID to sDriverID
        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        If (num_arguments > 1) Begin
            Move bCpyDat to bCopyData
        End
        Else Begin
            Move False to bCopyData
        End

        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
            Function_Return False
        End
        Move 0 to hToTable

        Move 16711679 to iMaxRecords
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
        Move (Pos(".", sDisplayName)) to iPos
        If (iPos > 0) Begin
            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
        End
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Get _TableNameOnly sRootName                 to sRootName
        Move (sRootName + ".dat")                    to sPhysicalName

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
        End

        Move False to Err

        Structure_Start hToTable DATAFLEX_ID
            Structure_Copy hTable to hToTable

            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
            Set Action_Text of ghoStatusPanel to "Restructures table..."

        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Move (not(Err)) to bOK
        If (bOK = True and bCopyData = True) Begin
            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
        End

        // This must be after copying data...
        If (Err = False) Begin
            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
        End
        Move (not(Err)) to bOK

        Function_Return (bOK = True)
    End_Function

    // Creates an SQL Table at the SQL end by its filelist number;
    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
    Function SqlTableCreate Integer hTable Returns Boolean
        String sTableName sSQLString sPath sCreateTable sDriverID
        Integer iDbType
        Boolean bExists

        Get psDriverID to sDriverID
        Get UtilTableHandleToString hTable to sTableName
        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Get psDataPathFirstPart to sPath
        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists

        Get piDbType to iDbType
        Get _SqlProperTableName sTableName to sTableName
        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        Function_Return (Err = False)
    End_Function

    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
    Function SqlTableCreateByTableName String sTableName  Returns Boolean
        String sSQLString sPath sCreateTable sDriverID
        Integer iDbType
        Boolean bExists

        Get psDriverID to sDriverID
        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Get psDataPathFirstPart to sPath
        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
        If (bExists = True) Begin
            // ToDo: What should we do if an .int file already exists?
        End

        Get piDbType to iDbType
        Get _SqlProperTableName sTableName to sTableName
        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        Function_Return (Err = False)
    End_Function
    
    // ToDo: 2019-09-23 This needs to be finilized 
    // It resets SQL constraints after a Structure_End, if necessary.
    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
        Boolean bOK                                                            
        String sStatement
        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
        Function_Return bOK
    End_Function
    
    // First deletes the data cache file and then drops the passed SQL table.
    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
    //       else try using the SqlTableRemoveByTableName message.
    Function SqlTableRemove Handle hTable Returns Boolean
        String sSQLString sPath sDropTable sTableName sDriverID
        Integer iRetval iDbType
        Boolean bExists bOK

        Get psDriverID to sDriverID
        Get UtilTableHandleToString hTable to sTableName
        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Get psDataPathFirstPart to sPath
        Get _UtilDeleteCacheFile sTableName to iRetval

        Get piDbType to iDbType
        Get _SqlProperTableName sTableName to sTableName
        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
        Move (sDropTable * String(sTableName)) to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sTableName to bOK

        Function_Return (Err = False)
    End_Function

    // First deletes the data cache file and then drops the passed data table.
    Function SqlTableRemoveByTableName String sTableName Returns Boolean
        String sSQLString sPath sDropTable sVal sSchema sDriverID
        Integer iRetval iDbType
        Boolean bOK

        Get psDriverID to sDriverID
        Get psDataPathFirstPart to sPath
        Get _UtilDeleteCacheFile sTableName to iRetval

        Get piDbType to iDbType
        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
        Get psSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End
        Move (Uppercase(sTableName)) to sVal
        If (not(sVal contains (sSchema + "."))) Begin
            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
        End
        Move (sDropTable * String(sTableName)) to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sTableName to bOK

        Function_Return (Err = False)
    End_Function

    // *** Sql View Messages ***

    // First deletes the data cache file and then drops the passed Sql data view.
    Function SqlViewRemove String sDataView Returns Boolean
        String sDriverID sSQLString sDropViewKeyWord
        Integer iRetval
        Boolean bMertechDriver bOK

        Get psDriverID to sDriverID
        Get IsMertechDriver sDriverID to bMertechDriver
        Get _UtilDeleteCacheFile sDataView to iRetval

        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
        Set psSQLStatementString to sSQLString

        // As we don't check if the view exist or not, it might happen
        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
        Move False to Err
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send SqlUtilExecuteQuery sSQLString sDriverID
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Move 0 to LastErr

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sDataView to bOK

        Function_Return (Err = False)
    End_Function

    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
        Boolean bOK
        Integer iDbType
        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString

        Get psDriverID to sDriverID
        Get piDbType   to iDbType

        Case Begin
            Case (iDbType = EN_DbTypeDB2)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
            Break

            Case (iDbType = EN_DbTypeMSSQL)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
            Break

            Case (iDbType = EN_DbTypeOracle)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
            Break

            Case (iDbType = EN_DbTypePostgre)
                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
            Break

            Case (iDbType = EN_DbTypeMySQL)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
            Break
        Case End

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID
        Move (Err = False) to bOK

        Function_Return bOK
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function SQL_COLUMN_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
        Integer iLength iDecimals
        String sColumnValue
        String sTableName sDriverID
        Boolean bOK bInitializeValue

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        If (num_arguments > 3) Begin
            Move iLen     to iLength
            Move iDec     to iDecimals
            Move bInitVal to bInitializeValue
            Move sColVal  to sColumnValue
        End

        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK

        Function_Return (bOK = True)
    End_Function

    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
        Integer iDbType iLength iDecimals iDriver
        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
        String sDriverID sNotNull
        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
        Handle hTable

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return True
        End

        Get UtilTableNameToHandle sTableName to hTable
        If (hTable = 0) Begin
            Get NextFreeFilelistSlot to hTable
        End

        Get piDbType to iDbType
        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
        Get _SqlFindColumnName sTableName sColumnName to sVal
        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
            Function_Return True
        End

        Get DriverIndex sDriverID to iDriver
        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True

        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
        If (num_arguments > 3) Begin
            Move iLen     to iLength
            Move iDec     to iDecimals
            Move bInitVal to bInitializeValue
            Move sColVal  to sColumnValue
        End

        Get _SqlProperTableName sTableName   to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull

        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
        If (bFixed = False) Begin
            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
        End
        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt

        Move False to Err
        Send SqlUtilExecuteQuery sStmt sDriverID

        If (bInitializeValue = True and Err = False) Begin
            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
        End

        If (Err = False) Begin
            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
        End

        Move (not(Err)) to bRetval

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sTableName to bOK
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState

        Function_Return bRetval
    End_Function

    // To update all current rows for a table column with a common value.
    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
        Boolean bRetval bSQLDriver
        Integer iCurrErr iDbType

        Move False to bRetval
        Get piDbType to iDbType
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver = False) Begin
            Function_Return bRetval
        End
        Get UtilTableHandleToString hTable to sTableName

        Move Err to iCurrErr
        Move False to Err
        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
        Get _SqlFindKeyWord CI_SQLSet          to sSet
        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
        If (iDbType = EN_DbTypeMySQL) Begin
            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
        End
        Else Begin
            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
        End

        Send SqlUtilExecuteQuery sStmt sDriverID
        Move (Err = False) to bRetval
        Move iCurrErr to Err

        Function_Return bRetval
    End_Function

    // The fourth & fifth arguments are optional, depending on the iDataType
    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
        String sDriverID sTableName
        Boolean bOK

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK

        Function_Return (Err = False)
    End_Function

    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
    // The fourth & fifth arguments are optional, depending on the iDataType
    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
        Integer iDbType iLength iDecimals
        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
        Boolean bExists bOK bFixed
        Handle hTable

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableNameToHandle sTableName to hTable
        If (hTable = 0) Begin
            Get NextFreeFilelistSlot to hTable
        End
        Get SQLUtilColumnExists sTableName sColumnName to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        If (num_arguments > 3) Begin
            Move iLen to iLength
        End
        If (num_arguments > 4) Begin
            Move iDec to iDecimals
        End

        Get piDbType to iDbType
        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType

        Move False to Err
        Get _SqlProperTableName sTableName    to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull

        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
        If (bFixed = False) Begin
            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
        End

        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sTableName to bOK

        Function_Return (Err = False)
    End_Function

    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
        Boolean bOK bErr bIsSQLDriver
        String sDriverID
        Integer iDataType

        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bIsSQLDriver
        If (bIsSQLDriver = False) Begin
            Function_Return False
        End

        Move Err to bErr
        Move False to bErr

        // There seems to be a problem with the ODBC_DRV driver that sometimes
        // inserts randomly character(10) and spaces, so we correct from that here:
        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
            Move ("[" + String(sValue) + "]") to sValue
        End

        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
        Move (not(Err)) to bOK
        Move bErr to Err

        Function_Return bOK
    End_Function

    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
        String sDriverID

        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bIsSQLDriver
        If (bIsSQLDriver = False) Begin
            Function_Return False
        End

        Move Err to bErr
        Move False to bErr
        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
        If (bNullable = bCurrentState) Begin
            Function_Return True
        End

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Get AutoConnectionIDLogin to bOK
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
        End
        If (bOpen = True) Begin
            Structure_Start hTable sDriverID
                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End

        Move (not(Err)) to bOK
        Move bErr to Err

        Function_Return bOK
    End_Function

    // Drop column by its table handle
    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
        String sDriverID sTableName
        Boolean bOK

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK

        Function_Return (bOK = True)
    End_Function

    // Drop column by its table name as a string.
    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
        Integer iDbType iDriver
        String sDriverID sStmt sAlterTable sDropColumn
        Boolean bExists bOK bRetval bDriverIgnoreErrorState
        Handle hTable

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get DriverIndex sDriverID to iDriver
        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True

        Get UtilTableNameToHandle sTableName to hTable
        If (hTable <> 0) Begin
            Get SQLUtilColumnExists sTableName sColumnName to bExists
            If (bExists = False) Begin
                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
                Function_Return False
            End
        End

        Get piDbType to iDbType
        If (iDbType = EN_DbTypeMSSQL) Begin
            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
            Get _UtilDeleteCacheFile sTableName to bOK
            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
            Function_Return bOK
        End

        Move False to Err
        Get _SqlProperTableName sTableName    to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn

        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID
        Move (not(Err)) to bRetval

        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sTableName to bOK
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState

        Function_Return bRetval
    End_Function

    // Rename a field/column by table handle (filelist number)
    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
        String sDriverID sTableName
        Boolean bOK

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK

        Function_Return (Err = False)
    End_Function

    // Rename a field/column by table name.
    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
        Integer iDbType iDataType
        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
        Boolean bOK bRetval
        Handle hTable

        Move sTableName to sOrgTableName
        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get _SqlFindColumnName sTableName sColumnName to sVal
        If (sVal = "") Begin
            Function_Return False
        End

        Get piDbType to iDbType
        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
        Get _SqlProperTableName sTableName     to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn

        Case Begin
            Case (iDbType = EN_dbTypeMSSQL)
                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
                Case Break
            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
            Case (iDbType = EN_dbTypeOracle)
                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
                Case Break
            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
            Case (iDbType = EN_dbTypeDB2)
                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
                Case Break
            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
            Case (iDbType = EN_dbTypePostgre)
                Move sOrgTableName to sTableName
                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
                Case Break
            Case (iDbType = EN_dbTypeMySQL)
                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
                Move sOrgTableName to sTableName
                Get psDatabase to sDatabase
                Get UtilTableNameToHandle sTableName to hTable
                If (hTable = 0) Begin
                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                    Get NextFreeFilelistSlot to hTable
                End
                Else Begin
                    Open hTable
                End
                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
                Case Break
            Case Else
                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
        Case End

        Move False to Err
        Send SqlUtilExecuteQuery sStmt sDriverID
        Move (Err = False) to bRetval
        // We also need to remove the cache-file since the table has been changed
        Get _UtilDeleteCacheFile sTableName to bOK

        Function_Return bRetval
    End_Function

    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
        Handle hoSQLHandler hSQLConnect hStmt
        Integer iNumCols iCount iDataType
        String sValue

        Get phoSQLManager to hoSQLHandler
        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
        If (hSQLConnect <> 0) Begin
            Get SQLOpen of hSQLConnect to hStmt
            If (hStmt <> 0) Begin
                Send SQLExecDirect of hStmt ("select * from" * sTableName)

                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
                For iCount from 1 to iNumCols
                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
                        Move iNumCols to iCount // We're out of here
                    End
                Loop

                Send SQLClose of hStmt
            End
            Send SQLDisconnect of hSQLConnect
        End

        Function_Return iDataType
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
        String sMessage // sConnectionString
        Handle hoSqlHandler hoSQLConnect hoStmt hoError
        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
        String[] sMsg aSQLQueryMessages aSQLFetchResults
        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
        TimeSpan tsQuery tsFetch
        tSqlErrorArray aSqlErrorArray
        Boolean bOK bShowProgress
        tSQLConnection SQLConnection

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Procedure_Return
        End

        If (num_arguments > 2) Begin
            Move bShowProgr to bShowProgress
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Get phoSQLManager to hoSqlHandler
        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect

        If (hoSQLConnect <> 0) Begin
            Get SqlOpen of hoSQLConnect to hoStmt
            If (hoStmt <> 0) Begin
                // record starting date/time stamp
                Move (CurrentDateTime()) to dtQueryExecStart
                // turn on error handling if enabled
                If (pbHandleQueryErrors(Self)) Begin
                    Set pbSqlError to False
                    Set paSqlErrorArray to aSqlErrorArray
                    Move Error_Object_Id to hoError
                    If (ghoDbUpdateHandler <> 0) Begin
                        Move ghoDbUpdateHandler to Error_Object_Id
                    End
                    Else Begin
                        Move Self to Error_Object_Id
                    End
                End

                // Before we execute the statement; save it so we can display the faulty statement in the error log.
                Set psSQLStatementString to sStmt
                Send Cursor_Wait of Cursor_Control
                Send SqlExecDirect of hoStmt sStmt
                Send Cursor_Ready of Cursor_Control

                If (pbHandleQueryErrors(Self)) Begin
                    Move hoError to Error_Object_Id
                End

                Move 0 to iMsgs
                Move Err to iErr
                Move LastErr to iLastErr
                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
                Send _SqlColumnInfo hoStmt
                Send Ignore_Error of Error_Object_Id 12289
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Repeat
                    Get SqlFetch of hoStmt to iFetchResult
                    If (iFetchResult <> 0) Begin
                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
                    End
                Until (iFetchResult = 0)
                Send Trap_Error of Error_Object_Id 12289
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Move iErr to Err
                Move iLastErr to LastErr
                Set paSQLFetchResults to aSQLFetchResults

                Set piRows    to iRows
                Set piRowType to iRowType
                Move (CurrentDateTime()) to dtQueryExecEnd
                Move (CurrentDateTime()) to dtFetchStart

                If (iMsgs <> 0) Begin
                    If (ghoDbUpdateHandler > 0) Begin
                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                    End
                    For i from 1 to iMsgs
                        Get SqlGetMessage of hoStmt i to sMessage
                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
                        If (bShowProgress = True) Begin
                            If (Active_State(ghoStatusPanel)) Begin
                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
                            End
                            Else Begin
                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
                            End
                        End
                        Move sMessage to sMsg[SizeOfArray(sMsg)]
                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
                    Loop
                    If (ghoDbUpdateHandler > 0) Begin
                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                    End
                    Set paQueryMessages to sMsg
                End
                Else Begin
                    If (bShowProgress = True) Begin
                        Get paSqlErrorArray to aSqlErrorArray
                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
                            Decrement iMsgs
                            For i from 0 to iMsgs
                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
                            Loop
                        End
                    End
                End
                Move (CurrentDateTime()) to dtFetchEnd
            End
            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
            Move (dtFetchStart - dtFetchEnd) to tsFetch
            Set ptsQueryExec to tsQuery
            Set ptsFetchResults to tsFetch
            Send SqlClose of hoStmt
        End

        Send SqlDisconnect of hoSQLConnect
    End_Procedure

    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
    // Returns False if no error occured.
    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
        Boolean bOK bShowProgress
        tSQLScriptArray SQLScriptArray
        DateTime dtTotalQueryStart dtTotalQueryEnd
        TimeSpan tsTotalTime

        Move (CurrentDateTime()) to dtTotalQueryStart
        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
        If (SQLScriptArray.bError = True) Begin
            Function_Return False
        End

        If (num_arguments > 3) Begin
            Move bShowProgr to bShowProgress
        End

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Move (CurrentDateTime()) to dtTotalQueryEnd
        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
        Set ptsTotalQueryTime to tsTotalTime

        Function_Return bOK
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function SQL_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Does three things with auxilirary files;
    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
        String sDataPath sDDSrcPath sDriverID
        Boolean bOK bExists
        Integer iCount iCh iPos

        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
        If (sTableName contains ".") Begin
            Move (Pos(".", sTableName)) to iPos
            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
        End

        Get psDriverID to sDriverID
        Get psDataPathFirstPart to sDataPath
        Get vFolderExists sDataPath to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
            Function_Return False
        End

        // First delete the cache file:
        Get _UtilDeleteCacheFile sTableName to bOK

        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Function_Return False
        End

        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Get _SqlUtilUpdateIntFile hTable to bOK
        // Add the new column name to the .tag filen (if it doesn't exist):
        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK

        // If in development environment; output new .fd file:
        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
        End
        Get vFolderExists sDDSrcPath to bExists
        If (bExists = True) Begin
            Get vFolderFormat sDDSrcPath to sDDSrcPath
            Move False to Err
            Get AutoConnectionIDLogin to bOK
            If (hTable <> 0) Begin
                Open hTable
            End
            Else Begin
                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
            End

            Get_Attribute DF_FILE_OPENED of hTable to bOK
            If (bOK = True) Begin
                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
            End
            If (Err = True) Begin
                Move False to bOK
            End
        End

        Function_Return (bOK = True)
    End_Function

    // Message for changing .int files to use connection ID's
    //
    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
    // OR changes an existing connection id to a new id.
    // Pass the full path to the data folder and the name of the connection id (string value).
    // Pass a True for the bShowResult parameter to show work in progress (showln's).
    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
        String sFileName sDriverID sDriverFile sConnectionString
        String[] sFilesData
        Boolean bOK bCancel
        Integer iSize iCount

        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
        Move (SizeOfArray(sFilesData))    to iSize
        If (iSize = 0) Begin
            If (ghoStatusPanel <> 0) Begin
                If (Active_State(ghoStatusPanel)) Begin
                    Send Stop_StatusPanel of ghoStatusPanel
                End
            End
            Send Info_Box CS_DUF_NoIntFilesFound
            Procedure_Return
        End

        Move (Trim(sConnectionID)) to sConnectionID
        Get vFolderFormat sDataPath to sDataPath
        Decrement iSize
        For iCount from 0 to iSize
            Move sFilesData[iCount] to sFileName
            // This makes sure that we also can change an existing connection id to something new:
            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
            If (ghoStatusPanel <> 0) Begin
                If (Active_State(ghoStatusPanel)) Begin
                    Get Check_StatusPanel of ghoStatusPanel to bCancel
                    If (bCancel = True) Begin
                        Send Deactivate of ghoStatusPanel
                        Procedure_Return
                    End
                End
            End
        Loop

        Get psDriverID to sDriverID

         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
        Move "" to sFileName
        If (sDriverID = MSSQLDRV_ID) Begin
            Move "MSSQLDrv.int" to sFileName
        End
        If (sDriverID = DB2_DRV_ID) Begin
            Move "DB2_Drv.int" to sFileName
        End
        If (sDriverID = ODBC_DRV_ID) Begin
            Move "ODBC_Drv.int" to sFileName
        End
        If (sFileName <> "") Begin
            Move "" to sDriverFile
            Get_File_Path sFileName to sDriverFile
            If (sDriverFile <> "") Begin
                Get psConnectionString to sConnectionString
                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
            End
        End
    End_Procedure

    // Checks if the database exists in SQL. Returns = True if it does.
    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
        String[] sDatabaseArray
        String sVal sServer sDriverID
        Integer iCount iSize iPos
        Boolean bExists
        tSQLConnection SQLConnection

        Move False to bExists
        Get psDriverID to sDriverID
        // DB2 doesn't have a "Database" name, so we always return True.
        If (sDriverID = DB2_DRV_ID) Begin
            Function_Return bExists
        End

        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
        If (SizeOfArray(sDatabaseArray) = 0) Begin
            Function_Return False
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sServer to sServer

        // Special code to handle a FILEDSN that also can contain "/"
        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
            Move sDatabaseArray[0] to sVal  // Dummy!
        End
        Else If (sServer contains "/") Begin
            Move (Pos("/", sServer)) to iPos
            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
        End

        Move (SizeOfArray(sDatabaseArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sDatabaseArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
                Move True to bExists
                If (bExists = True) Begin
                    Move iSize to iCount // We're done.
                End
            End
        Loop

        Function_Return bExists
    End_Function

    // Checks if a table exists as an SQL table. Returns = True if it does.
    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
        String sDatabase sSchema sTableName sVal
        Boolean bExists
        String[] sTablesArray
        Integer iSize iCount

        Move False to bExists
        Get UtilTableHandleToString hTable to sTableName
        Get psDatabase to sDatabase
        Get psSchema   to sSchema
        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move True to bExists
                Move iSize to iCount // We're done!
            End
        Loop

        Function_Return bExists
    End_Function

    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
        String sVal sTableSpelledCorrectly
        Boolean bExists
        String[] sTablesArray
        Integer iSize iCount

        Move False to bExists
        Move sTableName to sTableSpelledCorrectly
        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move sVal to sTableSpelledCorrectly
                Move iSize to iCount // We're done!
            End
        Loop

        Function_Return sTableSpelledCorrectly
    End_Function

    // ToDo: This index name function needs to be finished...
    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
        String sSchema sTableName sDriverID
        Boolean bExists

        Get psDriverID to sDriverID
        Get psSchema to sSchema
        Get UtilTableHandleToString hTable to sTableName

        Function_Return bExists
    End_Function

    // Checks if a column/field name exists in a SQL table definition
    // Returns True if it does
    // Sample:
    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
        Integer iNumColumns iColumn
        String sColumn sDriverID
        String[] sColumnsArray
        Boolean bExists bOK

        Move False to bExists
        Get AutoConnectionIDLogin to bOK
        Get psDriverID to sDriverID

        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
        Move (SizeOfArray(sColumnsArray)) to iNumColumns
        Decrement iNumColumns
        For iColumn from 0 to iNumColumns
            Move sColumnsArray[iColumn] to sColumn
            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
                Move True to bExists
                Move iNumColumns to iColumn // We're out of here
            End
        Loop

        Function_Return bExists
    End_Function

    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
        Integer iNumColumns iColumn iDFType iNativeType
        Boolean bOpened bOK
        String sColumnName sNativeTypeName

        Get AutoConnectionIDLogin to bOK
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
            Function_Return False
        End

        Move False to Err

        Structure_Start hTable
            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns

            For iColumn from 1 to iNumColumns
                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName

                Case Begin
                    Case (iDFType = DF_DATE)
                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
                            // Convert datetime to date
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
                        End
                        Case Break
                    Case (iDFType = DF_DATETIME)
                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
                            // Convert datetime to datetime2
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
                        End
                        Case Break
                    Case (iDFType = DF_ASCII)
                        If (iNativeType = SQL_CHAR) Begin
                            // Convert char to varchar
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
                        End
                        Case Break
                    Case (iDFType = DF_TEXT)
                        If (iNativeType = SQL_LONGVARCHAR) Begin
                            // Convert text to varchar(max)
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
                        End
                        Case Break
                    Case (iDFType = DF_BINARY)
                        If (iNativeType = SQL_LONGVARBINARY) Begin
                            // Convert image to varbinary(max)
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
                        End
                        Case Break
                Case End
            Loop
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function


    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
    // the DbUpdateVersion database revision in.
    // Also pass the file number of the current (embedded?) table number used in development.
    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
        Boolean bOK bOpened
        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
        Get _TableNameOnly sTableName to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        // This just creates the table and a "dummy" column.
        Get SqlTableCreate hTable sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Close hTable
        Move False to Err

        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
        Move "Decimal" to sDataType
        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals

        // Adds the "sColumnName" passed to the function
        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID

        // Now we can delete the dummy column:
        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK

        // Finally, we attach to the newly created table.
        If (Err = False) Begin
            Get ApiTableAttachToSQL hTable True to bOK
        End
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened

        Function_Return (Err = False and bOK = True and bOpened = True)
    End_Function

    // Returns a handle to the SQL server associated with the passed driver ID.
    // Pass e.g. the psServer property to determine the current connection server.
    // Returns a handle to the database connection, or a zero (0) if it fails.
    // This handle can be used to obtain attributes about the server, such as default
    // column types.
    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
        Handle hDatabase
        Integer iDriver iServers iCount
        String sValue

        If (sServer = "") Begin
            Function_Return 0
        End

        Get DriverIndex sDriverID to iDriver
        If (iDriver = 0) Begin
            Function_Return 0
        End

        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
        For iCount from 1 to iServers
            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
            End
        Loop

        Function_Return hDatabase
    End_Function

//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
//        String sRootName
//        Boolean bOK
//
//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
//        Move (sRootName contains sDriverID) to bOK
//
//        Function_Return bOK
//    End_Function

//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
//        String sDriverID sRootName sDisplayName sSchema sVal
//        Integer iDbType
//        Boolean bOK
//
//        Get UtilIsFilelistEntryDriverBased to bOK
//        If (bOK = True) Begin
//            Function_Return False
//        End
//
//        Get psDriverID to sDriverID
//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
//        Move (sDriverID + ":" + sRootName)           to sRootName
//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
//
//        Get psDriverID to sDriverID
//        Get piDbType   to iDbType
//        Get psSchema   to sSchema
//        If (sSchema = "") Begin
//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
//        End
//
//        Move (Uppercase(sDisplayName)) to sVal
//        If (not(sVal contains (sSchema + "."))) Begin
//            If (iDbType = EN_dbTypeDB2) Begin
//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
//            End
//            Else Begin
//                Move (sSchema + "." + sDisplayName) to sDisplayName
//            End
//        End
//
//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
//
//        Function_Return True
//    End_Function

    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
    // from the passed filelist.
    // Returns the number of tables affected.
    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
        Integer iRetval
        Handle hTable

        // We first save the current filelist as the passed filelist name
        // may come from another workspace, to restore it when we're ready.
        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
        Set_Attribute DF_FILELIST_NAME to sFilelist
        Move 0 to hTable
        Move 0 to iRetval

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
                Move (Uppercase(sRootName)) to sVal
                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
                    // Prefixes:
                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
                    // Suffixes:
                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName

                    // Change Filelist entry:
                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName

                    Move (Lowercase(sDisplayName)) to sVal
                    If (sVal contains "dbo.") Begin
                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName

                        // Change Filelist entry:
                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
                    End
                    Increment iRetval
                End
            End
        Until (hTable = 0)

        Set_Attribute DF_FILELIST_NAME to sCurrentFileList

        Function_Return iRetval
    End_Function

    // To open all Sql based tables in Filelist.cfg
    Procedure SqlUtilOpenAllTables
        Handle hTable
        String sRoot sDriverID
        Boolean bOK

        Move 0 to hTable
        Move "" to sDriverID
        Get AutoConnectionIDLogin to bOK

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
                        Open hTable
                    End
                End
            End

        Until (hTable = 0)
    End_Procedure

//    Function SqlUtilSchemaName Handle hTable Returns String
//        String sRetval sDriverID
//        String sTableName
//        Integer iDbType iIndex
//        Boolean bOK
//
//        Get psDriverID to sDriverID
//        Get _SqlCheckCurrentDriver sDriverID to bOK
//        If (hTable = 0 or bOK = False) Begin
//            Function_Return ""
//        End
//
//        Move False to Err
//        Get UtilTableHandleToString hTable to sTableName
//        Get piDbType to iDbType
//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
//        If (iIndex = -1) Begin
//            Function_Return ""
//        End
//
//        Function_Return sRetval
//    End_Function

    // Checks if the passed Table;
    // 1) Already has a Filelist entry that points to SQL and
    // 2) It has an .int file.
    // If both is True it should already be connected to SQL
    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
        Boolean bExists bRootName
        String sRootName sDataPath

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Move (sRootName contains sDriverID) to bRootName

        Get psDataPathFirstPart to sDataPath
        Get vFolderExists sDataPath to bExists
        If (bExists = False) Begin
            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
            Function_Return False
        End

        Get vFolderFormat sDataPath to sDataPath
        Get _TableNameOnly sRootName to sRootName
        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists

        Function_Return (bRootName = True and bExists = True)
    End_Function

    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
        Boolean bViewTableType bOpen bOK
        Integer iTableCount iNumTables
        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
        Handle hoCliHandler
        tSQLConnection SQLConnection

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Get AutoConnectionIDLogin to bOK
            Open hTable
        End

        Get pSQLConnection to SQLConnection
        Get phoCLIHandler to hoCliHandler
        Set psDriverID of hoCliHandler to sDriverID

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
        Get _TableNameOnly sTableName to sTableName
        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables

        For iTableCount from 1 to iNumTables
            Get TableName  of hoCliHandler iTableCount to sEnumTableName
            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
                Get TableType of hoCliHandler iTableCount to sTableType
                Move iNumTables to iTableCount // We're done.
            End
        Loop

        Move (sTableType = "VIEW") to bViewTableType
        If (bOpen = False) Begin
            Close hTable
        End

        Function_Return bViewTableType
    End_Function

    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
    //
    // SQL utility function that returns a database type (string) constant
    // corresponding to the passed iDbType.
    Function SqlUtilDbTypeToString Integer iDbType Returns String
        String sRetval
        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
        Function_Return sRetval
    End_Function

    // SQL utility function that returns a database type constant (integer)
    // corresponding to the passed sDbType string constant.
    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
        Integer iRetval
        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
        Function_Return iRetval
    End_Function

    // Pass an integer DbType and function returns the database type integer as a string value.
    // Used e.g. when reading a connection ini-file to display the database type in
    // the SQL Connection program's grid.
    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
        String sRetval
        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
        Function_Return sRetval
    End_Function

    // Pass a driver name as a string and the function will return
    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
    // quite work and always returns "MS SQL Server"
    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
        Integer iRetval
        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
        Function_Return iRetval
    End_Function

    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
    // that "fits" in the max allowed length for table names.
    // Max number of characters allowed for table names;
    // IBM DB2      = 128
    // MS-SQL       = 128
    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
    // MySQL        = 64
    // PostgreSQL   = 64
    Function SqlUtilGUIDTempTableName String sRootName Returns String
        String sGUIDName
        Integer iDbType iLength

        Get piDbType to iDbType
        Move (RandomHexUUID()) to sGUIDName
        Move (sRootName + "_" + sGUIDName) to sGUIDName
        Move (Length(sGUIDName)) to iLength

        Case Begin
            Case (iDbType = EN_DbTypeDB2)
            If (iLength > 128) Begin
                Move (Left(sGUIDName, 128)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypeMSSQL)
            If (iLength > 128) Begin
                Move (Left(sGUIDName, 128)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
            If (iLength > 128) Begin
                Move (Left(sGUIDName, 128)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypeMySQL)
            If (iLength > 64) Begin
                Move (Left(sGUIDName, 64)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypePostgre)
            If (iLength > 64) Begin
                Move (Left(sGUIDName, 64)) to sGUIDName
            End
        Case End

        Function_Return sGUIDName
    End_Function

    // Reads a resource that has been embedded by the compiler and writes it to disk.
    // Pass the memory resource file reference and the filename to be created,
    // including full path.
    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
        String sText
        Integer iCh iSize iArgSize

        Move ("Resource:" + sMemFileName) to sMemFileName
        Get Seq_Open_Input_Channel sMemFileName to iCh
        Get_Channel_Size iCh to iSize
        Read_Block channel iCh sText iSize
        Send Seq_Close_Channel iCh

        Get Seq_Open_Output_Channel sFileName to iCh
            Write channel iCh sText
        Send Seq_Close_Channel iCh

        // Wait for file to be written to disk.
        Sleep 2
    End_Procedure

    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
        String sNotNull sRetval sDefaultValue
        Boolean bOK

        Get IsSQLDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return ""
        End

        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull

        Case Begin
            Case (iDbType = EN_dbTypeMSSQL)
                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
                Case Break
            Case (iDbType = EN_dbTypeMySQL)
                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
                Case Break
            Case (iDbType = EN_dbTypePostgre)
                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
                Case Break
            Case (iDbType = EN_dbTypeDB2)
                Move (String(sNotNull))                                     to sRetval
                Case Break

            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
            // ToDo: We need to look deeper into how Oracle handles NULL
            Case (iDbType = EN_dbTypeOracle)
                Move  ""                                                    to sRetval
                Case Break

            Case Else
                Move  ""                                                    to sRetval
        Case End

        Function_Return sRetval
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Enumerate SQL Servers.
    // Pass a driver id. Returns a string array.
    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
        String[] sReturnArray
        Handle hoSQLHandler
        String sServer
        Integer iCount iNumItems iDataSourceType

        If (num_arguments > 1) Begin
            Move iDatSrcType to iDataSourceType
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get phoMSSQLHandler to hoSQLHandler
                Get EnumerateServers of hoSQLHandler to iNumItems
                For iCount from 0 to (iNumItems - 1)
                    Get String_Value of hoSQLHandler iCount to sServer
                    Move (Trim(sServer)) to sReturnArray[iCount]
                Loop
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Get phoDB2SQLHandler to hoSQLHandler
                Send SeedDataSources of hoSQLHandler
                Move 0 to iCount
                Repeat
                    Get DataSources of hoSQLHandler to sServer
                    If (sServer <> "") Begin
                        Move (Replace(",", sServer, "")) to sServer
                        Move sServer to sReturnArray[iCount]
                    End
                    Increment iCount
                Until (sServer = "")
                Case Break

            Case (sDriverID = ODBC_DRV_ID)
                Get phoODBCSQLHandler to hoSQLHandler
                Set DataSourceType of hoSQLHandler to iDataSourceType
                Move 0 to iCount
                Repeat
                    Get DataSources of hoSQLHandler to sServer
                    If (sServer <> "") Begin
                        Move (Replace(",", sServer, ", ")) to sServer
                        Move sServer to sReturnArray[iCount]
                    End
                    Increment iCount
                Until (sServer = "")
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns all databases as a string array for the passed driver id.
    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
        String[] sReturnArray
        String sServer sVal
        tSQLIntTableInfo[] sReturnStructArray
        tSQLConnection SQLConnection
        Boolean bOK
        Integer iCount iSize

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get _SqlDatabasesArrayMSSQL to sReturnArray
                Case Break
            Case (sDriverID = DB2_DRV_ID)
                Get _SqlDatabasesArrayDB2 to sReturnArray
                Case Break

            // This is needed to be able to check if a database exists or not.
            Case (sDriverID = ODBC_DRV_ID)
                Get _SqlDatabasesArrayODBC to sReturnStructArray
                If (SizeOfArray(sReturnStructArray)) Begin
                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
                        // If a FILEDSN: (can only be one database name)
                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
                    End
                    Else Begin
                        // Else the DSN's were read from the registry.
                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
                        Move SQLConnection.sServer to sServer
                        Move (SizeOfArray(sReturnStructArray)) to iSize
                        Decrement iSize
                        for iCount from 0 to iSize
                            Move (sReturnStructArray[iCount].sServerName) to sVal
                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
                                Move iSize to iCount // We're done.
                            End
                        Loop
                    End
                End
                Case Break

            Case Else
//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
        Case End

        Function_Return sReturnArray
    End_Function

    
    // *** Database API Functions: ***
    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
    // make changes/updates to the database.

    // * Dummy function for the Studio's Code Explorer *
    Function API_TABLE_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // This might not do what you think - Here's what it does:
    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
    // to the SQL table.
    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
    // already exists in SQL.
    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
    // restructuring an existing table.
    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
        Handle hToTable

        Move True to bUseConnectionID
        If (num_arguments > 1) Begin
            Move bUseConnID to bUseConnectionID
        End

        Get psDriverID to sDriverID
        // If the table doesn't exist on the SQL back-end we do nothing.
        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Get UtilTableIsAlias hTable to bIsAlias

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        // Then we need to check that the function hasn't been called before; which in case
        // we do nothing
        Get SQLUtilTableIsAttached sDriverID hTable to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Get psConnectionID     to sConnectionID
        Get psConnectionString to sConnectionString
        If (sConnectionID = "" or sConnectionString = "") Begin
            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
            Function_Return False
        End

        Set Private.phCurrentTable to hTable
        Get psSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        // If we should use a connection id we need to check it exists;
        // else we create it before attempting creating the table
        If (bUseConnectionID = True) Begin
            Get AutoConnectionIDLogin to bOK
            If (bOk = False) Begin
                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
                Function_Return False
            End
        End

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Get _TableNameOnly sRootName to sRootName
        If (sRootName = "") Begin
            Function_Return False
        End
        Move (sRootName + ".int")                    to sPhysicalName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
        //
        // We don't want to change the display name if it starts with an ampersand ("@"),
        // because then the table should not be visible to users.
//        Move (Pos("@", sDisplayName)) to iPos
//        If (iPos <> 1) Begin
//            If (sDisplayName contains ".") Begin
//                Move (Pos(".", sDisplayName)) to iPos
//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
//                Move (sSchema + "." + sDisplayName)       to sDisplayName
//            End
//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
//            End
//        End

        If (bIsAlias = False) Begin
            Get OpenTableExclusive hTable to bOpened
            If (bOpened = False) Begin
                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
                Function_Return False
            End
        End

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set Message_Text of ghoStatusPanel to ""
            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
        End
        // Note: The hToTable will get changed by the Structure_xxx command...
        Move hTable to hToTable
        Move False to Err

        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
        // a proper and updated .int file.
        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK

        If (bIsAlias = False) Begin
            Structure_Start hToTable sDriverID
                Set Private.phCurrentTable to hTable
                If (bUseConnectionID = True) Begin
                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
                End
                Else Begin
                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
                End
                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
                Move False to Err
                Move 0 to LastErr
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End

        Move (not(Err)) to bOK
        If (bOK = True) Begin
            // The attributes set above will always trigger an error
            // We also adjust the Filelist entries
            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

            // This updates the .int file to make it up-to-date with the SQL back-end.
            Get _SqlUtilUpdateIntFile hTable to bOK
        End

        Function_Return (bOK = True)
    End_Function

    // Sample usage:
    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
        Boolean bOK bIsSQLTable

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        // ToDo: Add to all table change functions!
        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Set Private.phCurrentTable to hTable
        Structure_Start hTable
            Set_Attribute iAttribute of hTable to iValue
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
        Boolean bOK
        
        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
        If (bOK = True) Begin
            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
        End
        
        Function_Return (bOK = True)
    End_Function
    
    // To use a filelist slot for the passed FileName, TableName & DisplayName,
    // or to change the filelist slot names.
    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
        String sFileListName
        
        Move False to Err

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
        End
        // If all strings are empty it means that we should remove this entry from filelist.
        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
            Function_Return (Err = False) // And we're done.
        End

        If (sDriverID <> DATAFLEX_ID) Begin
//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
            Move (sDriverID + ":" + sRootName) to sRootName
        End
//        Else Begin
//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
//        End
//
//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName

        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
        
        Function_Return (Err = False)
    End_Function

    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Set Private.phCurrentTable to hTable
        Structure_Start hTable
            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
        Boolean bOK bIsSQLTable

        Move False to Err
        Get AutoConnectionIDLogin to bOK
        Open hToTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Set Private.phCurrentTable to hTable
        Structure_Start hTable
            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    Procedure ApiTableConvertAllAddException Integer hTable
        Integer[] aTableConvertExceptions
        Get paTableConvertExceptions to aTableConvertExceptions
        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
        Set paTableConvertExceptions to aTableConvertExceptions
    End_Procedure

    Procedure ApiTableDateCorrectionAddException Integer hTable
        Integer[] aTableDateCorrectionExceptions
        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
    End_Procedure

    Procedure ApiTableConvertALLToSql
        Integer[] iTablesArray
        Integer iSize iCount
        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
        String sDriverID

        Get psDriverID to sDriverID
        Get pbUseConnectionID to bUseConnectionID
        Get pbToANSI          to bToANSI
        Get pbRecnum          to bRecnum
        Get pbCopyData        to bCopyData
        If (ghoDbUpdateHandler > 0) Begin
            Get pbContinueOnError to bContinueOnError
        End

        Get _AllTablesToConvert to iTablesArray
        Move (SizeOfArray(iTablesArray)) to iSize
        Set pbVisible   of ghoProgressBarOverall to True
        Set piPosition  of ghoProgressBarOverall to 0
        Set piAdvanceBy of ghoProgressBarOverall to 1
        Set piMaximum   of ghoProgressBarOverall to iSize

        Decrement iSize
        For iCount from 0 to iSize
            Set piPosition of ghoProgressBarOverall to iCount
            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
            // Probably the right logic here is to just continue trying to convert every table even
            // if there was an error converting one table...
            //If (bContinueOnError = False and bOK = False) Break
        Loop

    End_Procedure

    Procedure ApiTableAttachALLToSql
        Integer[] iTablesArray
        Integer iSize iCount
        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
        String sDriverID

        Get psDriverID to sDriverID
        Get pbUseConnectionID to bUseConnectionID
        Get pbToANSI          to bToANSI
        Get pbRecnum          to bRecnum
        Get pbCopyData        to bCopyData
        If (ghoDbUpdateHandler > 0) Begin
            Get pbContinueOnError to bContinueOnError
        End

        Get _AllTablesToConvert to iTablesArray
        Move (SizeOfArray(iTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
        Loop

    End_Procedure

    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
        Handle hToTable hoLogFile
        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
        tSQLConnection SQLConnection

        Get _UtilTableExists hTable to bExists
        If (bExists = False) Begin
            Set Private.phCurrentTable to hTable
            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
            Function_Return False
        End

        Get UtilTableIsAlias hTable to bIsAlias
        // If this is an Alias file there is nothing to convert to SQL.
        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
        If (bIsAlias = True) Begin
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
                Get psConnectionID to sConnectionID
                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
            End
            Function_Return True
        End

        Set Private.phCurrentTable to hTable
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
            Set Message_Text   of ghoStatusPanel to ""
            Set Action_Text    of ghoStatusPanel to ""
        End

        // Marco Kuipers suggestion;
        // If Filelist.cfg points to an embedded .dat table and the table already exists as
        // an SQL table; Instead of creating the table in SQL, attach it to the existing
        // SQL table.
        Get _UtilTableIsSql hTable to bOK
        If (bOK = False) Begin
            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
            If (bExists = True) Begin
//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
                Get phoLogFile to hoLogFile
                If (hoLogFile <> 0) Begin          
                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
                    Send LogError sWarning False
                End
                Else Begin
                    Error DFERR_PROGRAM sWarning
                End                                                       
                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
            End
        End

        // Does the rootname contain a driver?
        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
            // Does the table already exist as an SQL table?
            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
            // It can happen that the table is missing from Filelist.cfg but still
            // exist on the SQL side, in case we want to search for the table by its name.
            If (bExists = False) Begin
                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
            End
            If (bExists = True) Begin
                Set TableName_Text of ghoStatusPanel to ""
                Function_Return False
            End
        End
        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM

        Get IsDAWSQLDriver sDriverID to bDAWDriver
        If (bUseConnectionID = True) Begin
            Move False to bUseConnectionID
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sSchema           to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
            Move (Lowercase(sSchema))        to sSchema
        End

        Move SQLConnection.sDatabase         to sDatabase
        Move SQLConnection.sConnectionID     to sConnectionID
        Move SQLConnection.sConnectionString to sConnectionString
        If (sConnectionID = "" or sConnectionString = "") Begin
            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
            Function_Return False
        End

        Get AutoConnectionIDLogin to bOK
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
            Function_Return False
        End

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
        End

        Move 0 to hToTable
        Get _TableNameOnly sRootName                 to sRootName
        Move (sRootName + ".int")                    to sPhysicalName

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Case Break
            Case (sDriverID = ODBC_DRV_ID)
                Case Break
            Case (sDriverID = DB2_DRV_ID)
                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
                Move SQLConnection.sLongTableSpace  to sLongTableSpace
                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
                Case Break
            Case (sDriverID = DATAFLEX_ID)
                Case Break
            Case Else
                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
                Case Break
        Case End

        Move False to Err

        Structure_Start hToTable sDriverID
            Structure_Copy hTable to hToTable
            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName

            If (sDriverID <> DATAFLEX_ID) Begin
                If (bUseConnectionID = True) Begin
                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
                End
                Else Begin
                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
                End

                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum

                If (sSchema <> "") Begin
                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
                End

                If (sDriverID = DB2_DRV_ID) Begin
                    If (sLongTableSpace <> "") Begin
                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
                    End
                    If (sBaseTableSpace <> "") Begin
                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
                    End
                    If (sIndexTableSpace <> "") Begin
                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
                    End
                End
            End

            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        Set Action_Text of ghoStatusPanel to ""

        Move (not(Err)) to bOK

        If (bOK = True and bCopyData = True) Begin
            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK

            If (ghoDbUpdateHandler > 0) Begin
                Get pbContinueOnError to bContinueOnError
            End
            // If the data copy failed we will keep the newly created SQL table but
            // rename it by adding a GUID to the end of the table name
            // - or as much as "fit" because different SQL back-ends have
            // different rules how long a table name can be.
            // The new table will probably contain data but something went
            // wrong while converting the data from embedded to SQL.
            If (bOK = False and bContinueOnError = False) Begin
                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
            End
        End

        // This must be after copying data...
        If (Err = False) Begin
            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
            // It seems the Studio does not do this any more, so commented out.
            // We also adjust the display name by prefixing it by the schema name;
            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
            //                // The max length for the display_name is 31 characters...
            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
            //                End
            //            End
        End

        Close hTable
        Move (not(Err)) to bOK
        Function_Return bOK
    End_Function

    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
    // It will first drop all indicies, copy the data and then recreate indicies.
    // An error log file with the sRootname + ".err" will be created in the Data folder.
    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
        Boolean bOpened bOK
        Integer hToTable iIndex iRetval iVoid iOrgFreq
        String sErrorFile sEmpty sPath

        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
        Get AutoConnectionIDLogin to bOK
        If (sDriverID = DATAFLEX_ID) Begin
            Send IncreaseSortBufferSize
//            Send SetAllIndexesToBatch hToTable
        End

        Move False to Err
        Open sPhysicalName as hToTable
        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
        If (bOpened = False) Begin
            Function_Return False
        End

        If (ghoStatusPanel <> 0) Begin
            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
            Set piMinimum of ghoProgressBar to 0
            Set piMaximum of ghoProgressBar to 100 // 100%
        End

        Move "" to sEmpty
        Move False to Err
        Move True to bOK
        Set Private.phCurrentTable to hToTable

        // No need to get the record identifier
        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
        If (sDriverID <> DATAFLEX_ID) Begin
            // Remove all indices to speed up copying of data:
            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
            If (iRetval <> 0) Begin       
                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
                Close hToTable
                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
                Function_Return False
            End
        End

        Move (sRootName + ".err") to sErrorFile
        Move 0 to iIndex
        Move False to Err

        If (sDriverID = MSSQLDRV_ID) Begin
            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
            If (iRetval <> 0) Begin
                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
                Close hToTable
                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
                Function_Return False
            End
        End
        Else Begin
            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
        End

        If (Err = False) Begin
            Get psHome of (phoWorkspace(ghoApplication)) to sPath
            Get vDeleteFile (sPath + sErrorFile) to iRetval
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            // Recreate indices:
            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
            If (iRetval <> 0) Begin
                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
                Close hToTable
                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
                Function_Return False
            End
        End

        Close hToTable
        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq

        If (bOK = True) Begin
            Move (not(Err)) to bOK
        End

        If (ghoStatusPanel <> 0) Begin
            Set TableName_Text of ghoStatusPanel to ""
            Set Message_Text   of ghoStatusPanel to ""
            Set Action_Text    of ghoStatusPanel to ""
        End

        Function_Return (bOK = True)
    End_Function

    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
        Handle hFile
        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
        Integer iIdentityType iDataType iDbType iCount iSize
        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
        tSQLConnection SQLConnection
        tAPIColumn[] aColumns
        tColumnType ColumnType

        // First check if the passed filenumber already exists; in case we do nothing
        Get _UtilTableExists hTable to bOk
        If (bOk = True) Begin
            Function_Return False
        End

        Set Private.phCurrentTable to hTable
        Move sLogicalName to sTableName
        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
        End

        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSqlDriver
        Get piDbType to iDbType

        // If no columns passed in, we need to create a "dummy" column
        Move False to bDeleteDummy
        If (Num_Arguments = 8) Begin
            Move aColumnIn to aColumns
        End
        If ((SizeOfArray(aColumns)) = 0) Begin
            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
            Move ColumnType.iSQLType to iDataType
            If (bRecnum = False) Begin
                Move C_tAPIColumn_Identity to iIdentityType
            End
            Else Begin
                Move C_tAPIColumn_None     to iIdentityType
            End
            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
            Move True to bDeleteDummy
        End

        // If columns have been passed as an array we need to check if an identity column
        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
        // if so auto-set the bRecnum to FALSE. This is because else there would be
        // two identity columns and SQL doesn't like that and throws an error.
        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
            Move (SizeOfArray(aColumns)) to iSize
            Decrement iSize
            for iCount from 0 to iSize
                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
                    Move False to bRecnum
                    Move iSize to iCount
                End
            Loop
        End

        // If this is a SQL based driver we also check if the table exists
        // in the SQL back end; in case we do nothing.
        If (bSqlDriver = True) Begin
            // Get all connection properties
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Move SQLConnection.sSchema to sSchema
            If (sSchema = "") Begin
                Get _SqlFindKeyWord CI_SQLDBO to sSchema
            End

            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
            // It can happen that the table is missing from Filelist.cfg but still
            // exist on the SQL side, in case we want to search for the table by its name.
            If (bExists = False) Begin
                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
            End
            // If the table exists on the SQL back-end but not in Filelist.cfg,
            // we will just add it to Filelist.cfg
            If (bExists = True) Begin
                If (bExistsInFilelist = False) Begin
                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
                        Move (sDriverID + ":" + sRootName) to sRootName
                    End
                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
                    Move False to bSysFile
                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
                End
                Function_Return False
            End
        End

        Move CS_ANSI_Txt to sANSI_OEM
        If (num_arguments > 6) Begin
            If (bANSI = False) Begin
                Move CS_OEM_Txt to sANSI_OEM
            End
        End

        Move False to Err
        If (sDriverID = DATAFLEX_ID) Begin
            Move sRootName to sPhysicalFile
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            Move SQLConnection.sConnectionID to sConnectionID

            // If DAW driver and we should use a connection id we need to
            // check if the connection ID exists; else we create it before attempting creating the table
            If (bUseConnectionID = True) Begin
                Get IsConnectionID sConnectionID sDriverID to bExists
                If (bExists = False) Begin
                    Get AutoSetConnectionID sConnectionID to bOk
                    If (bOk = False) Begin
                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
                        Function_Return False
                    End
                End
            End

            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
                Move (sTableName + ".int") to sPhysicalFile
            End
            Else Begin
                Move (sRootName + ".int") to sPhysicalFile
            End
            Move (Uppercase(sDisplayName)) to sVal
//            If (not(sVal contains (sSchema + "."))) Begin
//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
//            End
        End
        Move False to Err
        Move 0 to hFile

        Structure_Start hFile sDriverID
            If (sDriverID <> DATAFLEX_ID) Begin
                If (bUseConnectionID = True) Begin
                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
                End
                Else Begin
                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
                End
                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum

                If (sSchema <> "") Begin
                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
                End

                If (sDriverID = DB2_DRV_ID) Begin
                    If (SQLConnection.sLongTableSpace <> "") Begin
                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
                    End
                End
                If (sDriverID = DB2_DRV_ID) Begin
                    If (SQLConnection.sBaseTableSpace <> "") Begin
                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
                    End
                    If (SQLConnection.sIndexTableSpace <> "") Begin
                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
                    End
                End
            End

            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
            Get ApiColumnsAddToTable hFile aColumns True to bOk
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        Set Action_Text of ghoStatusPanel to ""

        Move (not(Err)) to bOK
        If (bOk = True) Begin
            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
                Move (sDriverID + ":" + sRootName) to sRootName
            End
            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName

            // Lastly we remove the temporary column we created above, if all went well.
            If (bDeleteDummy) Begin
                Get ApiColumnRemove hTable "temp" to bOk
            End
        End

        Set TableName_Text of ghoStatusPanel to ""
        Close hTable
        Function_Return (bOK = True)
    End_Function

    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
        Move False to Err
        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName

        Function_Return (Err = False)
    End_Function

    // ToDo: Needs to be revised
    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
        Handle hTable
        String sDEFName sDataPath
        Boolean bExists

        // Do nothing if MSSQL Driver.
//        Get IsMSSQLDriver to bExists
//        If (bExists = True) Begin
//            Procedure_Return
//        End

        Get psDataPathFirstPart to sDataPath
        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
        If (bExists = True) Begin
            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
            // still be missing from the filelist and needs to be added.
            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
            If (bExists = True) Begin
                Procedure_Return
            End
            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
            Else Begin
                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
                Procedure_Return
            End
        End

        Move (sPath + sFileName + ".def") to sDEFName
        Move 0 to hTable
        Move False to Err

        Structure_Start hTable DATAFLEX_ID
            Load_Def sDEFName Onto hTable
            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        Set Action_Text of ghoStatusPanel to ""

        Move iFilelistSlot to hTable
        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

    End_Procedure

    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
        Boolean bTmp bErr bOK
        String sTableName sDisplayName sFileName

        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
        Move Err to bTmp
        Move False to Err

        Get AutoConnectionIDLogin to bOK
        // First get the info for the current filelist slot:
        Open iFromFileSlot
        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
        If (bOK = True) Begin
            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName

            //...then move it.
            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName

            //...and finally remove the old filelist values.
            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
        End
        Close iFromFileSlot

        Move Err to bErr
        Move bTmp to Err
        Function_Return (bErr = False)
    End_Function

    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
        Handle hTable
        Boolean bOK
        String sDriverID

        Get _UtilTableExists hTableFrom to bOK
        If (bOK = False) Begin
            Set Private.phCurrentTable to hTableFrom
            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
            Function_Return False
        End

        Get _UtilTableExists hTableTo to bOK
        If (bOK = False) Begin
            Set Private.phCurrentTable to hTableTo
            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
            Function_Return False
        End

        Get AutoConnectionIDLogin to bOK
        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Move False to Err
        Open hTableTo

        Move hTableFrom to hTable
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Set Private.phCurrentTable to hTable

        Structure_Start hTable sDriverID
            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
            If (iColumnTo <> 0) Begin
                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
            End
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        Set Action_Text of ghoStatusPanel to ""

        If (hTableTo > 0) Begin
            Close hTableTo
        End

        Function_Return (Err = False)
    End_Function

    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
    Function ApiTableRemove Handle hTable Returns Boolean
        String sTableName sDriverID
        Boolean bOk
        String sDataPath

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get psDriverID to sDriverID
        Get UtilTableHandleToString hTable sDriverID to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        Set Private.phCurrentTable to hTable
        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
        Delete_db sTableName
        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE

        If (sDriverID <> DATAFLEX_ID) Begin
//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
            Get psDataPathFirstPart to sDataPath
            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
        End
        // Also remove table from filelist.cfg in case the physical file didn't exist.
        If (hTable <> 0) Begin
            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
        End

        Close hTable
        Function_Return (hTable <> 0)
    End_Function

    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
        Handle hTable
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Open hTableFrom Mode DF_EXCLUSIVE
        Move hTableFrom to hTable

        Structure_Start hTable
            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        Set Action_Text of ghoStatusPanel to ""

        Close hTableFrom
        Function_Return (Err = False)
    End_Function

    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
        Boolean bOK bExists bOpened
        tAPITableNameInfo APITableNameInfo

        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Get OpenTableExclusive hTable to bOpened
            If (bOpened = False) Begin
                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
                Function_Return False
            End
        End

        Set Private.phCurrentTable to hTable
        Move hTable         to APITableNameInfo.iTableNumber
        Move sRootName      to APITableNameInfo.sRootName
        Move sLogicalName   to APITableNameInfo.sLogicalName
        Move sDisplayName   to APITableNameInfo.sDisplayName
        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
        If (bExists = True) Begin
            Function_Return True
        End

        Set Private.phCurrentTable to hTable
        Move False to Err
        Get psDataPathFirstPart to sDataPath
        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Close hTable
        If (sDriverID = DATAFLEX_ID) Begin
            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
            If (bExists = True) Begin
                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
                    // We need a short break here before attempting to delete the physical old files or Windows
                    // might report "File in use..." and the deletion will fail.
                    Sleep 2
                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
                End
            End
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            If (not(sPhysicalName contains ".")) Begin
                Move (sPhysicalName + String(".int")) to sPhysicalName
            End

            // Change the table name in the .int file to the new table new:
            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
            If (bOK = False) Begin
                Function_Return False
            End

            // Change table name at the SQL side:
            Get psSchema to sSchema
            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK

            Get _TableNameOnly sRootName to sPhysicalNameTo
            // Remove cache file and Rename the physical file names:
            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
            Move (sDriverID + ":" + sRootName) to sRootName

            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
//            If (not(sDisplayName contains ".")) Begin
//                Move (sSchema + "." + sDisplayName) to sDisplayName
//            End
        End

        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName

        Function_Return (Err = False)
    End_Function

    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
        Move False to Err
        Set Private.phCurrentTable to hTable
        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName

        Function_Return (Err = False)
    End_Function

    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
        Handle hTable
        String sTableName
        String sDriverIDFrom sDriverIDTo
        Integer iDbType
        Boolean bOk bOpened bApiTableUpdateAuto
        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
        tSQLConnection SQLConnection
        tAPITable      APITableFrom APITableTo
        tColumnType    ColumnType
        tAPIColumnCompare[]   aAPIColumnCompare
        tAPIIndexCompare[]    aAPIIndexCompare
        tAPIRelationCompare[] aAPIRelationCompare

        // We don't allow changes to the framework's DbVersion table.
        If (Lowercase(sTableName) = "dbversion") Begin
            Function_Return False
        End

        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
        Get piDbType                            to iDbType
        Get pbRecnum                            to bRecnum
        Get pbToANSI                            to bToANSI
        Get pbCopyData                          to bCopyData
        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
        Get pbCompareDate_DateTime              to bCompareDate_DateTime
        Get pbCompareIndexAscending             to bCompareIndexAscending
        Get pbCompareIndexUppercase             to bCompareIndexUppercase
        Get pbUseConnectionID                   to bUseConnectionID

        Move APITableNameInfoFrom.iTableNumber  to hTable
        Set Private.phCurrentTable              to hTable
        Get _UtilTableExists  hTable             to bTableExists

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
            Set Message_Text   of ghoStatusPanel to ""
            Set Action_Text    of ghoStatusPanel to ""
        End

        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
        Get _UtilTableIsSql hTable               to bIsSQLTableTo
        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
        Move True                               to APITableFrom.bFromTable
        Move hTable                             to APITableFrom.hTable
        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
        Move aColumnsFrom                       to APITableFrom.aApiColumns
        Move aIndexesFrom                       to APITableFrom.aApiIndexes
        Move aRelationsFrom                     to APITableFrom.aApiRelations

        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
            If (bOk = True) Begin
                Get ApiTableAttachToSql hTable True to bOk
                Function_Return bOk
            End 
        End

        If (bTableExists = True) Begin
            If (bIsSQLTableTo = True) Begin
                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
            End

            Get OpenTableExclusive hTable to bOpened
            If (bOpened = False) Begin
                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
                Function_Return False
            End
            Get UtilTableStructFill hTable False                                                        to APITableTo
            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
        End

        Move False to Err
        Case Begin
            // Alias table:
            Case (bIsAliasFrom = True)
                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
                Case Break

            // New Table:
            Case (bTableExists = False)
                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
                If (APITableNameInfoFrom.bIsSystemFile) Begin
                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
                End                                                                 
                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
                Case Break

            // Update table:
            Case (bTableExists = True)
                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
                If (bIsSame = True) Begin
                    Case Break
                End
                If (bFilelistError = True) Begin
                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
                    If (bOk = False) Begin
                        Case Break
                    End
                End

                If (ghoProgressBar <> 0) Begin
                    Send DoAdvance of ghoProgressBar
                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
                End

                // Columns:
                Move True to bOk
                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
                If (bIsSame = False) Begin
                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
                End
                If (bOk = False) Begin
                    Case Break
                End

                // Indexes:
                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
                If (bIsSame = False) Begin
                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
                End

                // Relations:
                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
                If (bIsSame = False) Begin
                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
                    If (bOk = False) Begin
                        Case Break
                    End
                End

                Case Break

            Case Else
                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
                Move False to bOk
        Case End
        
        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
        // or convert an embedded table to SQL
        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
            If (bOk = False) Begin
                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
            End
        End
        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
            Get SqlTableConvertToEmbedded hTable True to bOk
        End
        
        // Filelist Names:
        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
        Close hTable
        Set TableName_Text of ghoStatusPanel to ""

        Function_Return (bOK = True)
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function API_COLUMN_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Adds a column name to the passed table number.
    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
        Integer iColumn iCount iFile iPrecision iLastErr
        Boolean bExists bOK bInitializeValue bRetval
        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID

        Get UtilColumnExists hTable sFieldName to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Move False to Err
        If (num_arguments > 4) Begin
            Move iPrec to iPrecision
        End
        If (num_arguments > 6) Begin
            Move bInitVal to bInitializeValue
            Move sColVal  to sColumnValue
        End
        If (iType < -1490) Begin
            Move (iType + 1500) to iType
        End

        Move hTable to iFile
        Get psDriverID to sDriverID
        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Move LastErr to iLastErr
        Get OpenTableExclusive iFile to bOK
        Set Private.phCurrentTable to hTable

        Structure_Start iFile sDriverID
            Move 0 to iColumn
            Set Private.piCurrentField to iColumn
            Create_Field hTable At iColumn
            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""

        // If in development environment; create .fd file:
        Open hTable
        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
        End
        Get vFolderExists sDDSrcPath to bExists
        If (bExists = True) Begin
            Get vFolderFormat sDDSrcPath to sDDSrcPath
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
            Get _TableNameOnly sTableName to sTableName
            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
        End
        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
            If (iCount > 1) Begin
                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
            End
            Get vFolderFormat sDataPath to sDataPath
            // Add the new column name to the .tag filen (if it doesn't exist):
            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
        End
        // Check for a default value
        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
        End
        Close hTable

        Function_Return (Err = False)
    End_Function

    // Adds a column name to the passed table number.
    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
        Integer iCount iFile iPrecision iNumberOfFields iDbType
        Boolean bExists bOK bIsDateType bIsSQLTypeTo
        String sDdSrcPath sTableName

        Get UtilColumnExists hTable sFieldName to bExists
        Move False to Err
        If (bExists = True) Begin
            Function_Return False
        End
        If (num_arguments > 4) Begin
            Move iPrec to iPrecision
        End
        If (iType < -1490) Begin
            Move (iType + 1500) to iType
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get _UtilTableIsSql hTable to bIsSQLTypeTo
        // If one of the two tables are SQL and the other Embedded we need to "translate"
        // data types between Embedded and SQL, else we can't compare the data types. 
        Get piDbType to iDbType
        If (bIsSQLTypeTo = False) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
                Move DF_DATE to iType
            End
        End

        // Structure_start will change the value of hTable...
        Move hTable to iFile
        Get OpenTableExclusive iFile to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields

        // If the passed column number is higher than the current number of fields
        // in the table, this means we should _not_ insert a field but rather add
        // a new field to the end:
        If (iColumn > iNumberOfFields) Begin
            Move 0 to iColumn
        End

        Set Private.phCurrentTable to hTable
        Set Private.piCurrentField to iColumn

        Structure_Start iFile
            Create_Field iFile At iColumn
            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
            If (bIsSQLTypeTo = False) Begin
                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
            End
            Else Begin
                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
            End
            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
            If (bIsDateType = False) Begin
                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
            End
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        // If in development environment; create .fd file:
        Open hTable
        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
        End
        Get vFolderExists sDDSrcPath to bExists
        If (bExists = True) Begin
            Get vFolderFormat sDDSrcPath to sDDSrcPath
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
            Get _TableNameOnly sTableName to sTableName
            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
        End

        // Check for a default value
        Close hTable

        Function_Return (Err = False)
    End_Function

    // To update all records for a table column with a fixed value.
    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
        Integer iRecs iCurrErr iField iRecord
        Boolean bRetval bOpen

        Move 0 to iRecs
        Move False to bRetval
        Move Err to iCurrErr
        Move False to Err

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Open hTable
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
            If (bOpen = False) Begin
                Function_Return bRetval
            End
        End

        Field_Map hTable sFieldName to iField
        If (iField <> 0) Begin
            Set Private.phCurrentTable to hTable
            Set Private.piCurrentField to iField
            Clear hTable
            Repeat
                Vfind hTable 0 GT
                If (Found) Begin
                    If (ghoStatusPanel <> 0) Begin
                        Get_Field_Value hTable 0 to iRecord
                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
                    End
                    Reread hTable
                        Set_Field_Value hTable iField to sColumnValue
                        SaveRecord hTable
                    Unlock
                End
           Until (not(Found))
        End

        Move (Err = False) to bRetval
        Move iCurrErr to Err

        Function_Return bRetval
    End_Function

    // Note: This can only be used from within a Structure_Start/End construct.
    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
        String sFieldName sDriverID sTableName sDefaultValue

        Get psDriverID to sDriverID
        Get piDbType to iDbType
        Get UtilTableHandleToString hTable to sTableName
        Get IsSQLDriver    sDriverID to bIsSQLDriver
        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
        Get _UtilTableIsSql hTable to bIsSqlTable
        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
            Move True to bIsSqlTable
        End
        Move False to bIsOpen
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        End
        If (bIsOpen = True) Begin
            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
        End
        Else Begin
            Get pbRecnum to bRecnumTable
        End

        Move False to Err
        Move (SizeOfArray(aColumns)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Move aColumns[iCount].sFieldName to sFieldName
            If (hTable > 0) Begin
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
                Move (Trim(sFieldName) <> "") to bFieldExists
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
            End
            Else Begin
                Move False to bFieldExists
            End

            If (bFieldExists = False) Begin
                Move 0 to iColumn
                Create_Field hTable At iColumn
            End
            Else Begin
                Move iCount to iColumn
            End

            Set Private.piCurrentField to iColumn

            Move                                        iColumn to aColumns[iCount].iFieldNumber
            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName

            Move aColumns[iCount].iType to iType
            Move (not(iType < -1490)) to bNativeType
            If (iType < -1490) Begin
                Move (iType + 1500) to iType
            End

            If (bIsSqlTable = True) Begin
                If (aColumns[iCount].bIsSQLType = True) Begin
                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL

                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
                    End
                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue

                End
                Else Begin
                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
                End
            End
            Else Begin
                If (bCreating = False) Begin
                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
                        Move DF_DATE to iType
                    End
                End
                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
            End

            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
            If (bIsDateType = False) Begin
                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
            End

            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
                Move 0 to iIndex
                Create_Index hTable at iIndex
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1

                // If we have an identity table - we must create a primary_key table.
                If (bIsSqlTable = True) Begin
                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
                End
            End
        Loop

        Function_Return (Err = False)
    End_Function

    // Changes a field type, length and precision for the passed table number and field name
    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
        Boolean bOK bIsSqlTable
        String sFieldNameTo

        If (num_arguments > 4) Begin
            Move iPrec to iPrecFrom
        End
        If (iTypeFrom < -1490) Begin
            Move (iTypeFrom + 1500) to iTypeFrom
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Field_Map hTable sFieldNameFrom to iColumn
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        If (Err = True) Begin
            Function_Return False
        End

        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
        Get _UtilTableIsSql hTable to bIsSqlTable
        If (bIsSqlTable = False) Begin
            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
        End
        Else Begin
            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
        End
        // Let the driver decide the other values;
        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo

        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
            Function_Return False
        End

        Set Private.phCurrentTable to hTable
        Set Private.piCurrentField to iColumn

        Structure_Start hTable
            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
//            If (bIsSqlTable = False) Begin
                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
//            End
//            Else Begin
//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
//            End
            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    // Changes a field type, length and precision for the passed table number and field name
    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
        String sFieldNameTo sDriverIDTo
        tColumnType ColumnType

        Get pbCompareDate_DateTime to bCompareDate_DateTime
        Get piDbType to iDbType
        If (num_arguments > 4) Begin
            Move iPrec to iPrecFrom
            Move iOpt  to iOptionFrom
        End
        If (iTypeFrom < -1490) Begin
            Move (iTypeFrom + 1500) to iTypeFrom
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Close hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
            Move DF_DATE to iDataFlexType
        End
        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo

        If (bIsSQLTableTo = True) Begin
            Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
        End
        Else Begin
            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
        End

        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
        Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo

        // If one of the two tables are SQL and the other Embedded we need to "translate"
        // data types between Embedded and SQL, else we can't compare the data types.
        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
                Move DF_DATE to iTypeTo  
            End
        End
        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
        End
        Move (iTypeFrom = iTypeTo) to bIsSameDataType

        If (bCompareDate_DateTime = False) Begin
            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
            If (bSkip = True) Begin
                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
                    Function_Return True
                End
            End
        End
        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
            Function_Return True
        End

        Set Private.phCurrentTable to hTable
        Set Private.piCurrentField to iColumn

        Structure_Start hTable
            If (sFieldNameFrom <> sFieldNameTo) Begin
                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
            End

            If (bIsSameDataType = False) Begin
                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
                If (bIsSQLTableTo = True) Begin
                    Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
                End
            End

            If (iLengthFrom <> iLengthTo) Begin
                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
            End
            If (iPrecFrom <> iPrecTo) Begin
                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
            End

            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
                If (bRecnumTable = True) Begin
                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
                End

                // We might need to create an index here.
                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
                // index update checking logic.
                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
                    Create_Index hTable At iIndex
                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
                End
                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
                Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
                If (bIsSQLTableTo = True) Begin
                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
                End
            End
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Structure_Start hTable
            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    // To move an existing field to another position in a table.
    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
        String sColumn sDriverID
        Integer iType
        Boolean bOK bIsDate

        Close hTable
        Get AutoConnectionIDLogin to bOK
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        If (sDriverID = DFBTRDRV_ID) Begin
            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
            Function_Return False
        End

        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate

        Set Private.phCurrentTable to hTable
        Set Private.piCurrentField to iOld

//        If (bIsDate = False) Begin
//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
//        End
//        Else Begin
//            Move 6 to iLength
//            Move 0 to iPrecision
//        End

        Move False to Err

        Structure_Start hTable
            Delete_Field hTable iOld
            Create_Field hTable At iNew
            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld

            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
            If (bIsSQLType = False) Begin
                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
            End
            Else Begin
                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
            End

            If (bIsDate = False) Begin
                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
            End

            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    // Deletes a column name for the passed table number (and column number).
    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
        Integer iColumn
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Close hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        If (not(Err)) Begin
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
            Field_Map hTable sFieldName to iColumn
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
            If (iColumn = 0) Begin
                Move 0 to LastErr
                Function_Return False
            End
            Move False to Err

            Set Private.phCurrentTable to hTable
            Set Private.piCurrentField to iColumn

            Structure_Start hTable
                Delete_Field hTable iColumn
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End
        Else Begin
            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
        End

        Function_Return (Err = False)
    End_Function

    // Renames a field for the passed table number & old field name & new field name
    // Returns True if no errors occured.
    // Sample usage:
    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
        Integer iField
        Boolean bOK bExists bIsOpen

        Get UtilColumnExists hTable sNewFieldName to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        // Note: The Field_Map command does _not_ work if the table has been
        //       opened exclusively, so we first open it in normal mode.
        Close hTable
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Function_Return False
        End
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Field_Map hTable sOldFieldName to iField
        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Get AutoConnectionIDLogin to bOK
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Move False to Err
        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
        Set Private.phCurrentTable to hTable
        Set Private.piCurrentField to iField

        If (iField > 0) Begin
            Structure_Start hTable
                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        End
        Else Begin
            Move 0 to LastErr
            Move False to Err
        End

        Set Action_Text of ghoStatusPanel to ""
        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return (Err = False)
    End_Function

    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
        tAPIColumnCompare[] aAPIColumnsToInsert
        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
        Boolean bRenameField

        Open hTable
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Move (SizeOfArray(aAPIColumnCompare)) to iSize
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
        Move (iSize max iNumberOfFieldsTo) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD

                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
                    If (iColumnNumber = -1 and bRenameField = False) Begin
                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
                        Increment iItem
                    End
                End
            End
        Loop

        Move False to Err
        Move 0 to LastErr
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Function_Return aAPIColumnsToInsert
    End_Function

    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
        Integer iSize iCount
        Boolean bOK
        tAPIColumn[] aColumnsTo
        tAPIColumnCompare[] aAPIColumnCompare

        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
        If (iSize = 0) Begin
            Function_Return True
        End

        Move False to Err
        Decrement iSize
        for iCount from 0 to iSize
            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
        Loop

        Function_Return bOK
    End_Function

    // Returns a struct array with fields that has the same names but different field numbers.
    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
        tAPIColumnCompare[] aAPIColumnsToMove
        Integer iSize iCount iItem iShouldMove

        Move 0 to iItem
        Move (SizeOfArray(aAPIColumnCompare)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
                If (iShouldMove <> -1) Begin
                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
                    Increment iItem
                End
            End
        Loop

        Move False to Err
        Move 0 to LastErr
        Function_Return aAPIColumnsToMove
    End_Function

    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
        Integer iSize iCount
        Boolean bOK
        tAPIColumnCompare[] aAPIColumnCompare

        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
        If (iSize = 0) Begin
            Function_Return True
        End

        Move False to Err
        Decrement iSize
        for iCount from 0 to iSize
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
                Get UtilColumnsStructFill hTable to aColumnsTo
                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
                If (SizeOfArray(aAPIColumnsToMove)) Begin
                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
                    Decrement iSize
                    Move 0 to iCount
                End
            End
        Loop

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
            Move 0 to LastErr
        End
        Function_Return bOK
    End_Function

    // Takes a tAPIColumnCompare struct as parameter and returns True if;
    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
    // - The "FROM" field name is <> "TO" field name
//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
        Boolean bShouldRename
        String sFieldNameFrom sFieldNameTo

        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
        If (sFieldNameFrom = sFieldNameTo) Begin
            Function_Return False
        End

        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;
              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;
              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;
              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;
              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;
              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
//        If (bShouldRename = False) Begin
//            Function_Return False
//        End
//
//        If (sFieldNameFrom contains sFieldNameTo) Begin
//            Function_Return True
//        End

        Function_Return bShouldRename
    End_Function

    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
    // Else it returns the column/field number of the field that exists in another position.
    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
        Integer iCount iSize iRetval
        String sFieldNameFrom

        Move -1 to iRetval
        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
            Function_Return iRetval
        End

        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
        Move (SizeOfArray(aAPIColumnCompare)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            // We're only interested in fields other than the passed field/column number:
            If (iCount <> iColumn) Begin
                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
                    Move (iCount + 1) to iRetval
                End
            End
        Loop

        Move 0 to LastErr
        Function_Return iRetval
    End_Function

    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
        tAPIColumnCompare[] aAPIColumnsToRename
        Integer iSize iCount iItem iFieldTo iShouldMove
        Boolean bRenameField

        Open hTable
        Move 0 to iItem
        Move (SizeOfArray(aAPIColumnCompare)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
                // Check if the field exists in another position (other field number)
                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
                    Increment iItem
                End
            End
        Loop

        Move False to Err
        Move 0 to LastErr
        Function_Return aAPIColumnsToRename
    End_Function

    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
        Integer iSize iCount
        Boolean bOK
        tAPIColumn[] aColumnsTo
        tAPIColumnCompare[] aAPIColumnCompare

        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
        If (iSize = 0) Begin
            Function_Return True
        End

        Move False to Err
        Decrement iSize
        For iCount from 0 to iSize
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
        Loop

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return bOK
    End_Function

    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
        Boolean bDateType

        If (bIsSQLTableTo = True) Begin
            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
        End
        Else Begin
            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
        End

        Function_Return bDateType
    End_Function

    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
        Integer iCount2 iColumn2
        Handle hFile
        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
        tColumnType ColumnType

        Move False to Err
        Close hTable
        Get OpenTableExclusive hTable to bIsOpen
        If (bIsOpen = False) Begin
            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
            Function_Return False
        End 
        
        Get piDbType to iDbType
        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
        Move bIsSQLTableFrom to bIsSQLDriver
        Get _UtilTableIsSql hTable to bIsSQLTableTo
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo

        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare

        // Before we start to change the table we need to do three things;
        // 1) Insert any new fields
        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
        If (SizeOfArray(aApiInsertColumns)) Begin
            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
            If (bOK = False) Begin
                Function_Return False
            End
            // Update info with changes made.
            Get UtilColumnsStructFill hTable to aColumnsTo
            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
        End

        // 2) Move fields with same names
        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
        If (SizeOfArray(aAPIMoveColumns)) Begin
            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
            If (bOK = False) Begin
                Function_Return False
            End
            Get UtilColumnsStructFill hTable to aColumnsTo
            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
        End
        
        // 3) Rename fields
        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
        If (SizeOfArray(aAPIRenameColumns)) Begin
            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
            If (bOK = False) Begin
                Function_Return False
            End
            Get UtilColumnsStructFill hTable to aColumnsTo
            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
        End

        // 4) Remove fields if more fields currently exists compared to the new table definition.
//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
//        If (SizeOfArray(aAPIRemoveColumns)) Begin
//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
//            If (bOK = False) Begin
//                Function_Return False
//            End
//            Get UtilColumnsStructFill hTable to aColumnsTo
//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
//        End

        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
            If (bIsSame = True) Begin
                Function_Return True
            End
        End

        // We can now continue to make standard field changes:
        Get OpenTableExclusive hTable to bIsOpen
        Set Private.phCurrentTable to hTable
        Move hTable to hFile
        Structure_Start hFile sDriverIDTo

            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
            Decrement iColumns
            for iCount from 0 to iColumns
                Send DoAdvance of ghoProgressBar

                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
                Set Private.piCurrentField                  to iColumn
                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
                If (bIsSame = False) Begin

                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
                    If (bFieldExistsFrom = True) Begin
                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom

                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
                        If (iTypeFrom < -1490) Begin
                            Move (iTypeFrom + 1500)                     to iTypeFrom
                        End

                        // If one of the two tables are SQL and the other Embedded we need to "translate"
                        // data types between Embedded and SQL, else we can't compare the data types.
                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
                                Move DF_DATE to iTypeFrom
                            End
                        End
                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
                        End

                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo

                        Move False to bSkipTypeChange
                        If (bCompareDate_DateTime = False) Begin
                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
                        End

                        If (bFieldExistsTo = False) Begin
                            Move 0 to iColumn
                            Create_Field hFile At iColumn
                            Set Private.piCurrentField to iColumn
                        End

                        If (sFieldNameFrom <> sFieldNameTo) Begin
                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
                        End

                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
                            End
                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
                        End

                        If (bSkipTypeChange = False) Begin
                            If (iTypeFrom <> iTypeTo) Begin
                                If (bIsSQLTableTo = True) Begin
                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
                                End
                                Else Begin                                                   
                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
                                        Move DF_DATE to iDataFlexType  // Date
                                    End
                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
                                End
                            End
                        End

                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
                        // We can't set the length or precision for Date type columns (they are fixed).
                        If (bIsDateType = False) Begin
                            If (iLengthFrom <> iLengthTo) Begin
                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
                            End
                            If (iPrecisionFrom <> iPrecisionTo) Begin
                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
                            End
                        End

                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
                            If (bRecnumTable = True) Begin
                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
                            End

                            // We might need to create an index here.
                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
                            // index update checking logic.
                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
                                Create_Index hFile at iIndex
                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
                            End

                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
                            // Note: The order here is crucial!
                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
                            Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
                        End
                    End
                    Else Begin
                        Delete_Field hFile iColumn
                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
                        Move (SizeOfArray(aColumnsTo)) to iCount2
                        Decrement iCount2
                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
                        // starting with the array number we just deleted the field for.
                        for iColumn2 from iCount to iCount2
                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
                        Loop
                        Decrement iCount
                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
                            Move iColumns to iCount 
                        End
                    End
                End
            Loop

            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function API_INDEX_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
        String sDriverID
        Boolean bOK bExists bIsSQLTable

        Get AutoConnectionIDLogin to bOK
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID

        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
        Move (iIndexSegments > 0) to bExists
        If (bExists = True) Begin
            Function_Return True
        End

        Move -1 to iSegment1
        Move -1 to iSegment2
        Move -1 to iSegment3
        Move -1 to iSegment4
        Move -1 to iSegment5
        Move -1 to iSegment6
        Move -1 to iSegment7
        Move -1 to iSegment8
        Move -1 to iSegment9
        Move -1 to iSegment10

        If (num_arguments > 3) Begin
            Move iSgmnt1 to iSegment1
        End
        If (num_arguments > 4) Begin
            Move iSgmnt2 to iSegment2
        End
        If (num_arguments > 5) Begin
            Move iSgmnt3 to iSegment3
        End
        If (num_arguments > 6) Begin
            Move iSgmnt4 to iSegment4
        End
        If (num_arguments > 7) Begin
            Move iSgmnt5 to iSegment5
        End
        If (num_arguments > 8) Begin
            Move iSgmnt6 to iSegment6
        End
        If (num_arguments > 9) Begin
            Move iSgmnt7 to iSegment7
        End
        If (num_arguments > 10) Begin
            Move iSgmnt8 to iSegment8
        End
        If (num_arguments > 11) Begin
            Move iSgmnt9 to iSegment9
        End
        If (num_arguments > 12) Begin
            Move iSgmnt10 to iSegment10
        End

        Move False to Err
        Move hTable to iTableNo
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR

        // We start by deleting the index, if it exists.
        If (bExists = True) Begin
            Structure_Start hTable sDriverID
                Delete_Index iTableNo iIndex
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        End

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
        Set Action_Text of ghoStatusPanel to ""
        Move False to Err
        Move 0 to LastErr

        // Need to re-open if index deleted.
        Move iTableNo to hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Structure_Start hTable sDriverID
            Create_Index hTable At iIndex
            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments

            If (iSgmnt1 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
            End
            If (iSegment2 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
            End
            If (iSegment3 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
            End
            If (iSegment4 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
            End
            If (iSegment5 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
            End
            If (iSegment6 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
            End
            If (iSegment7 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
            End
            If (iSegment8 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
            End
            If (iSegment9 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
            End
            If (iSegment10 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
            End
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR

        Function_Return (Err = False)
    End_Function

    // Example:
    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
        Integer iTableNo iNumSgmnt iNumSgmnts
        String sDriverID
        Boolean bOK bIsSQLTable

        Get AutoConnectionIDLogin to bOK

        Move False to Err
        Move hTable to iTableNo
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        // We start by deleting the index
        Structure_Start hTable sDriverID
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
            Delete_Index iTableNo iIndex
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Move False to Err
        Move iTableNo to hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Structure_Start hTable sDriverID
            Move (SizeOfArray(iSgmnts)) to iNumSgmnts

            Create_Index hTable at iIndex
            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts

            for iNumSgmnt from 0 to (iNumSgmnts - 1)
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
            Loop
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR

        Function_Return (Err = False)
    End_Function

    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
        String sDriverID sSQLIndexName
        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists

        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
        If (iSegmentsFrom = 0) Begin
            Function_Return False
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bIsOpen
        If (bIsOpen = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Move 0     to iSegmentsTo
        Move 0     to iSQLIndexType
        Move ""    to sSQLIndexName
        Move False to bIsSQLTemporaryIndex
        Move False to bIsSQLPrimaryKey
        Move False to bIsSQLClustered

        Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
        Move (iSegmentsTo > 0) to bExists
        If (bExists = True) Begin
            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
                Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
                Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
                Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
                Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
            End
        End

        Move hTable to iTableNo
        Move False to Err
        Move 0 to LastErr

        Structure_Start hTable sDriverID
            If (bExists = True) Begin
                Delete_Index iTableNo APIIndex.iIndexNumber
            End

            Create_Index hTable At APIIndex.iIndexNumber

            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
            End

		    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom

            for iCount from 0 to (iSegmentsFrom -1)
                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
                If (iFieldFrom <> -1 ) Begin
            		Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
            		Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
            		Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
                End
            Loop

            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""

        Function_Return (Err = False)
    End_Function

    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
        Integer iLastIndex iCount iTableNo iSegments
        String sSQLIndexNameCompare sTmpIndexName
        Boolean bIsOpen bExists bIsSQLDriver 

        Get IsSQLDriver sDriverID to bIsSQLDriver
        
        If (bIsSQLDriver = False) Begin
            Function_Return False
        End

        Move False to Err
        Move hTable to iTableNo
        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
        for iCount from 0 to iLastIndex
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
            Move (iSegments > 0) to bExists
            If (bExists = True) Begin
                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
                    Structure_Start iTableNo sDriverID
                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
                    Open hTable
                End
            End
        Loop

        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Get OpenTableExclusive hTable to bIsOpen
        End
        If (bIsOpen = False) Begin
            Function_Return False
        End

        Function_Return (Err = False)
    End_Function

    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
    // but with another Index number. We can then not rename the SQL index name for the TO database table.
    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
        Integer iSize iCount
        Integer iRetVal

        Move 0 to iRetVal
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
        If (iRetVal = 0) Begin
            Function_Return 0
        End
        Move (SizeOfArray(APIIndexTo)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
                End
            End
        Loop

        Function_Return iRetVal
    End_Function

    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
        Boolean bIsSQLTable
        
        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iSegment = iNumSegments) Begin
//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
        End

        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
            for iCurSegment from iSegment to (iNumSegments - 1)
                //*** Move index segment attributes
                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn

                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
            Loop

            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
        End

        Function_Return (Err = False)
    End_Function

    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
        Integer iCount iSize iIndex
        String sDriverID
        Boolean bOK bIsSQLTable bIsOpen

        Move (SizeOfArray(APIIndex)) to iSize
        If (iSize = 0) Begin
            Function_Return True
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Get OpenTableExclusive hTable to bIsOpen
            If (bIsOpen = False) Begin
                Function_Return False
            End
        End

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Move False to Err
        Move 0 to LastErr
        Decrement iSize

        Structure_Start hTable sDriverID
            for iCount from 0 to iSize
//                Move False to bIsSQLPrimaryKey
//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
//                    Set Error_Report_Mode to DUF_ERROR_REPORT
                // We can't delete if this is a primary key index:
//                If (bIsSQLPrimaryKey = False) Begin
                    Move APIIndex[iCount].iIndexNumber to iIndex
                    Delete_Index hTable iIndex
//                    Set Error_Report_Mode to DUF_ERROR_REPORT
//                End
            Loop
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
//        Move False to Err
        Move 0 to LastErr

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Structure_Start hTable
            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
        Integer iCase
        Boolean bOK

        If (bUppercase = True) Begin
            Move DF_CASE_IGNORED to iCase
        End
        Else Begin
            Move DF_CASE_USED to iCase
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Structure_Start hTable
            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    // To delete an index
    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
        Integer iTableNo iNumSegments
        String sDriverID
        Boolean bOK bIsSQLTable

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Move hTable to iTableNo
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        // Check to see if the index exists or not...
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iNumSegments = 0) Begin
            Function_Return True // Then nothing to do.
        End

        Structure_Start hTable sDriverID
            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
            Delete_Index iTableNo iIndex
            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
            Set Action_Text of ghoStatusPanel to "Restructures table..."
        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler

        Set Action_Text of ghoStatusPanel to ""
        Function_Return (Err = False)
    End_Function

    // Delete an Index Segment
    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
        Integer iIndexType
        String sDriverID

        Get AutoConnectionIDLogin to bOK
        Move False to Err

        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        // Check to see if the index exists or not...
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iNumSegments = 0) Begin
            Function_Return False
        End

        Move False to bIndexTemporary
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver) Begin
           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
           Get_Attribute DF_INDEX_TYPE to iIndexType
           Move True to bIndexTemporary
        End

        // If SQL and Temporary Index must not use Structure_Start/Structure_End
        If (bSQLDriver = True and bIndexTemporary = True) Begin
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
            If (iSegment = iNumSegments) Begin
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
            End
            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
                For iCurSegment from iSegment to (iNumSegments - 1)
                    //*** Move index segment attributes
                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
                Loop
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
            End
        End

        Else Begin
           Structure_Start hTable
               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
               If (iSegment = iNumSegments) Begin
                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
               End
               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
                   for iCurSegment from iSegment to (iNumSegments - 1)
                       //*** Move index segment attributes
                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
                   Loop
                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
               End
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End

        Function_Return (Err = False)
    End_Function

    // Add/Insert an Index Segment
    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
        Integer iIndexType
        String sDriverId

        Get AutoConnectionIDLogin to bOK
        Move False to Err

        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get _UtilTableIsSql hTable to bIsSQLTable
        If (bIsSQLTable = True) Begin
            Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
        End

        Move False to bIndexTemporary
        // Check to see if the index exists or not...
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iNumSegments = 0) Begin
            Function_Return False
        End

        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver) Begin
            Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
            Get_Attribute DF_INDEX_TYPE to iIndexType
            Move True to bIndexTemporary
        End

        // If SQL and Temporary Index must not use Structure_Start/Structure_End
        If (bSQLDriver = True and bIndexTemporary = True) Begin
           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments

           If (iSegment > iNumSegments) Begin
               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
               Move (iNumSegments + 1) to iCurSegment
           End
           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
               Move iNumSegments to iCurSegment

               While (iCurSegment > iSegment)
                   //*** Move index segment attributes
                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
                   Decrement iCurSegment
               Loop

               //*** Now set new segment attributes
               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
           End
        End

        Else Begin
        Structure_Start hTable
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments

            If (iSegment > iNumSegments) Begin
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
                Move (iNumSegments + 1) to iCurSegment
            End
            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
                Move iNumSegments to iCurSegment

                While (iCurSegment > iSegment)
                    //*** Move index segment attributes
                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
                    Decrement iCurSegment
                Loop

                //*** Now set new segment attributes
                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
            End
            Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End

        Function_Return (Err = False)
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function  
    
    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
    // for an SQL conversion.
    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
        
        Move True to bConvertTo30FormatbOK
        Move True to bRepairAndReindexOK
        Move True to bFixBogusDatesOK
        Move True to bMoveMiscFilesToBackupOK
        
        If (bMoveMiscFilesToBackup = True) Begin   
            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
        End                                                                                
        If (bFixALLBogusFilelistEntries = True) Begin
            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
        End
        If (bConvertTo30Format = True) Begin
            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
        End                                                 
        If (bRepairAndReindex = True) Begin
            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
        End  
        If (bFixBogusDates = True) Begin
            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
        End                                    
        
        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
    End_Function

    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
        Boolean bOK bFlexErrs bTemp
        Handle hTable
        String sTableName
        Integer iCount iSize
        
        Move True to bOK
        Move 0 to hTable    

        Get UtilFilelistNoOfTables to iSize
        Set pbVisible    of ghoProgressBarOverall to True
        Set piPosition   of ghoProgressBarOverall to 0
        Set piMaximum    of ghoProgressBarOverall to iSize
        Set piAdvanceBy  of ghoProgressBarOverall to 1

        Repeat
            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
            Set piPosition of ghoProgressBarOverall to iCount  
            Increment iCount
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
                If (bFlexErrs = False) Begin
                    Get UtilTableConvertFrom23Format hTable to bTemp
                    If (bTemp = False) Begin
                        Move False to bOK
                    End
                End
            End
        Until (hTable = 0)
        
        Set Action_Text of ghoStatusPanel to ""
        Function_Return bOK
    End_Function
    
    // Converts an embedded table from 2.3 -> 3.0.
    // Returns: FALSE only if the table can't be opened or the conversion fails.
    // It will return a TRUE if successful or the table is an SQL table.
    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
        Boolean bOK bIsEmbedded bIsAlias
        String sRevision
        
        Get AutoConnectionIDLogin to bOK
        If (bOK = False) Begin
            Function_Return True
        End
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return True
        End
        Get _UtilTableIsEmbedded hTable to bIsEmbedded
        If (bIsEmbedded = False) Begin
            Function_Return True
        End                             
        Get UtilTableIsAlias hTable to bIsAlias
        If (bIsAlias = True) Begin
            Function_Return True
        End                     
        
        Move False to Err
        Get_Attribute DF_FILE_REVISION of hTable to sRevision
        If (sRevision contains "2.3") Begin
            Move False to Err
            Set Private.phCurrentTable to hTable
            Structure_Start hTable    
                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End
        
        Function_Return (Err = False)
    End_Function

    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
        Boolean bIgnore bExists bOK bResponse
        Handle hTable   
        String sTableName
        
        Move False to Err 
        Move True to bOK
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
                If (bIgnore = False) Begin
                    Get _UtilTableExists hTable to bExists
                    If (bExists = False) Begin
                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
                        If (bResponse = False) Begin
                            Move False to bOK
                        End
                        
                    End
                End
            End
        Until (hTable = 0)                     
        
        Set Action_Text of ghoStatusPanel to "" 
        Function_Return bOK
    End_Function
    
    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
    //
    // The root of the problem is the following:
    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
    // an SQL error will be thrown;
    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
        Boolean bOK bIsAlias bIsSQL
        Integer iCount iSize iDateSize
        Handle hTable
        String sLogicalName
        Integer[] aTablesToCheck aDateFields

        Get _AllTablesDateCorrections to aTablesToCheck
        Move (SizeOfArray(aTablesToCheck)) to iSize
        Set pbVisible    of ghoProgressBarOverall to True
        Set piPosition   of ghoProgressBarOverall to 0
        Set piMaximum    of ghoProgressBarOverall to iSize
        Set piAdvanceBy  of ghoProgressBarOverall to 1

        Move True to bOK
        Decrement iSize
        for iCount from 0 to iSize
            Move aTablesToCheck[iCount] to hTable
            Set piPosition of ghoProgressBarOverall to iCount
            Get UtilTableIsAlias hTable to bIsAlias
            Get _UtilTableIsSql   hTable to bIsSQL

            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."

            If (bIsAlias = False and bIsSQL = False) Begin
                Get UtilCheckForDateFields hTable to aDateFields
                Move (SizeOfArray(aDateFields)) to iDateSize
                If (iDateSize > 0) Begin
                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
                    Close hTable
                End
            End
        Loop

        Close DF_ALL
        Function_Return bOK
    End_Function

    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
    Function UtilCheckForDateFields Handle hTable Returns Integer[]
        Integer[] aDateFields aDateFieldsEmpty
        Integer iSize iCount iType
        Boolean bOpen bOK
        
        Get _UtilTableExists hTable to bOK
        If (bOK = False) Begin
            Set Private.phCurrentTable to hTable
            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
            Function_Return aDateFieldsEmpty
        End
        Set Private.phCurrentTable to hTable
        Set Private.piCurrentField to 0

//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
//        Set Error_Report_Mode to DUF_ERROR_REPORT
        If (bOpen = False) Begin
//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
            Function_Return aDateFieldsEmpty
        End

        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
        For iCount from 1 to iSize
            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
            If (iType = DF_DATE or iType = DF_DATETIME) Begin
                Move iCount to aDateFields[SizeOfArray(aDateFields)]
            End
        Loop

        Function_Return aDateFields
    End_Function

    // Loops through all records for the passed hTable, and checks that all Date values
    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
    // and the record is saved
    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
    // Note: It first sets all indexes to BATCH and reset them at the end.
    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
        String sDriverID sDateMin
        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
        Date dDate dDateMin
        Integer[] iaChangeField

        Get _UtilTableExists hTable to bOK
        // I believe we should just skip files not found and not report an error.
        // This is because a filelist may have entries but no files/tables on disk, but
        // this may be adjusted by other calls to DUF in a later update package. 
        // Especially considering that this call is probably done at the very
        // beginning of a DUF update.
        If (bOK = False) Begin
//            Set Private.phCurrentTable to hTable
//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
//            Function_Return False
            Function_Return True
        End

        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
        // date format to "USA" = "MM/DD/YYYY"
        Get_Attribute DF_DATE_FORMAT to iDateFormat
        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA

//        Send SetAllIndexesToBatch hTable True
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Function_Return False
        End
        
        Set Private.phCurrentTable to hTable
        Move 0 to iRecord
        Move (SizeOfArray(aDateFields)) to iSize
        Decrement iSize

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get DriverIndex sDriverID to iDriverIndex
        If (iDriverIndex <> 0) Begin
            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
            If (sDateMin = "") Begin
                Move CS_DUFLowestAllowedDateValue to dDateMin
            End
            Else Begin
                If (IsDate(sDateMin)) Begin
                    Move sDateMin to dDateMin
                End
                Else Begin
                    Move CS_DUFLowestAllowedDateValue to dDateMin
                End
            End
        End
        Else Begin
            Move CS_DUFLowestAllowedDateValue to dDateMin
        End

        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
        Set piPosition   of ghoProgressBar to 0
        Set piAdvanceBy  of ghoProgressBar to 100
        Set piMaximum    of ghoProgressBar to iTotalRecords
        Move False to Err
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT

        Clear hTable
        Repeat
            Vfind hTable 0 GT
            Move Found to bFound
            If (bFound = True) Begin
                Move False to bSaveChanges
                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
                Move (SizeOfArray(aDateFields)) to iSize
                Decrement iSize
                For iCount from 0 to iSize
                    Move aDateFields[iCount] to iField
                    Get_Field_Value hTable iField to dDate
                    If (bFixZeroDates = True) Begin
                        Move (dDate = 0 or dDate < dDateMin) to bChange
                    End
                    Else Begin
                        Move (dDate <> 0 and dDate < dDateMin) to bChange
                    End
                    If (bChange = True) Begin
                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
                    End
                Loop

                // Only change Date fields that needs to be changed.
                If (SizeOfArray(iaChangeField)) Begin
                    Reread hTable
                        Move (SizeOfArray(iaChangeField)) to iSize
                        Decrement iSize
                        For iCount from 0 to iSize
                            Move iaChangeField[iCount] to iField
                            Set Private.piCurrentField to iField
                            Set_Field_Value hTable iField to dDateMin
                        Loop
                        Move False to Err
                        SaveRecord hTable
                    Unlock
                End

                Increment iRecord
                // Increment the StatusPanel counter and check the
                // cancel status every 100 records rather than every
                // record, it's way faster.
                If (Mod(iRecord, 100) = 0) Begin
                    Send DoAdvance of ghoProgressBar
                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
                    Get Check_StatusPanel of ghoStatusPanel to bCancel
                End
            End
        Until (bFound = False)

        Set_Attribute DF_DATE_FORMAT to iDateFormat
        If (bResetIndexesToOnLine = True) Begin
            Send SetAllIndexesToBatch hTable False
        End
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return (Err = False)
    End_Function

    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
    // Note that it first removes any driver prefixes in the rootname.
    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
        Boolean bIsSame
        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo

        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo

        If (bCompareFilelistUppercase = True) Begin
            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
        End
        Else Begin
            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
        End
        If (bIsSame = False) Begin
            Function_Return False
        End

        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        Function_Return bIsSame
    End_Function

    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
        Handle hTableFrom hTableTo
        Boolean bIsSame bIsSQLFrom bIsSQLTo
        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
        String sRootName sDriverIDFrom sDriverIDTo
        tAPIColumnCompare[]   aAPIColumnCompare
        tAPIIndexCompare[]    aAPIIndexCompare
        tAPIRelationCompare[] aAPIRelationCompare

        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
        If (bIsSame = True) Begin
            Function_Return True
        End

        Move False to bFilelistError
        Move True to bIsSame
        Get pbCompareDate_DateTime  to bCompareDate_DateTime
        Get pbCompareIndexAscending to bCompareIndexAscending
        Get pbCompareIndexUppercase to bCompareIndexUppercase
        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo

        Move APITableFrom.ApiTableInfo.sRootName to sRootName
        Get _TableNameOnly sRootName             to sRootName
        Move sRootName to APITableTo.ApiTableInfo.sRootName

        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
        // bCodeGenerateMode = True = Code Generation mode.
        If (bCodeGenerateMode = True) Begin
            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
                Function_Return False
            End
            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
            If (bIsSame = False) Begin
                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
                Move True to bFilelistError
                Function_Return False
            End
        End

        If (bCodeGenerateMode = False) Begin
            // Then we want to create this table
            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
                Function_Return False
            End

            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
            If (bIsSame = False) Begin
                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
                Move True to bFilelistError
                Function_Return False
            End
        End

        // Check columns:
        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        // ...then check indexes:
        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        // ...and finally relationships:
        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame

        Function_Return (bIsSame = True)
    End_Function

    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
        Handle hTable
        Boolean bIsSame bIsSQLFrom bIsSQLTo
        String sRootName sDriverIDFrom sDriverIDTo

        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
            Move True to bFilelistError
            Function_Return False
        End

        Move APITableCompare.hTable to hTable
        Move True  to bIsSame
        Move False to bFilelistError

        If (APITableCompare.bExistsFrom = True) Begin
            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
        End
        Else Begin
            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
        End
        Get _TableNameOnly sRootName                                   to sRootName

        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo

        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
        // bCodeGenerateMode = True = Code Generation mode.
        If (bCodeGenerateMode = True) Begin
            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
            If (APITableCompare.bExistsTo = False) Begin
                Function_Return False
            End
            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
            If (bIsSame = False) Begin
                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;
                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;
                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
                Move True to bFilelistError
                Function_Return False
            End
        End

        If (bCodeGenerateMode = False) Begin
            If (APITableCompare.bExistsTo = False) Begin
                // Then we might want to create this table
                Function_Return False
            End

            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End

            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End

            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End

            // Check table names et al.
            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End

        // Check Columns:
        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        // ...then check Indexes:
        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        // ...and finally Relationships:
        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame

        Function_Return (bIsSame = True)
    End_Function

    // To fill a complete Table array structure (tAPITable[]) with data.
    // The data + filelist.cfg path, login et al must have been setup properly first.
    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
        tAPITableNameInfo ApiTableNameInfo
        tAPITable[]     aApiTables aApiTablesEmpty
        tAPIColumn[]    aApiColumns
        tAPIIndex[]     aApiIndexes
        tAPIRelation[]  aApiRelations
        Handle hTable
        Integer iCount
        Boolean bUserCancel bOK
        String sLogicalName sMessageText

        Get AutoConnectionIDLogin to bOK
        Move 0 to hTable
        If (bFromTables = True) Begin
            Move "Reading 'FROM' Table Structure:" to sMessageText
            If (bCompareUtil = True) Begin
                Move (sMessageText * "(1 of 3)") to sMessageText
            End
        End
        Else Begin
            Move "Reading 'TO' Table Structure:" to sMessageText
            If (bCompareUtil = True) Begin
                Move (sMessageText * "(2 of 3)") to sMessageText
            End
        End
        Set Message_Text of ghoStatusPanel to sMessageText

        Get UtilFilelistNoOfTables to iCount
        Set piMaximum of ghoProgressBar to iCount
        Move 0 to iCount

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0 and hTable <> 50) Begin

                Open hTable
                // ToDo: Needs to be revised
                // For some reason tables may be reported as "unopened", while in
                // fact the open was successful (!)
//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
//                If (bIsOpen = False) Begin
//                    Move True to aApiTablesEmpty[0].bError
//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
//                    Function_Return aApiTablesEmpty
//                End

                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
                Set piPosition of ghoProgressBar to iCount
                Send DoAdvance of ghoProgressBarOverall
                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))

                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
//                Close hTable DF_PERMANENT
                Increment iCount
            End

            If (bStatusPanel = True) Begin
                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
                If (bUserCancel = True) Begin
                    Move True to aApiTablesEmpty[0].bCancel
                    Function_Return aApiTablesEmpty
                End
            End

        Until (hTable = 0)

        Function_Return aApiTables
    End_Function

    // Returns a 'single' table APITable struct.
    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
        tAPITableNameInfo ApiTableNameInfo
        tAPITable         ApiTable ApiTableEmpty
        tAPIColumn[]     aApiColumns
        tAPIIndex[]      aApiIndexes
        tAPIRelation[]   aApiRelations
        Boolean bIsOpen

        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Move True to ApiTableEmpty.bError
            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
            Function_Return ApiTableEmpty
        End

        // Fill Table Name Info
        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo

        // Fill columns
        Get UtilColumnsStructFill hTable to aApiColumns
        If (SizeOfArray(aApiColumns)) Begin
            If (aApiColumns[0].bCancel = True) Begin
                Move True to ApiTableEmpty.bError
                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
                Function_Return ApiTableEmpty
            End
        End

        // Fill indexes
        Get UtilIndexesStructFill hTable to aApiIndexes
        If (SizeOfArray(aApiIndexes)) Begin
            If (aApiIndexes[0].bCancel = True) Begin
                Move True to ApiTableEmpty.bError
                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
                Function_Return ApiTableEmpty
            End
        End

        // Fill relationships
        Get UtilRelationsStructFill hTable to aApiRelations
        If (SizeOfArray(aApiRelations)) Begin
            If (aApiRelations[0].bCancel = True) Begin
                Move True to ApiTableEmpty.bError
                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
                Function_Return ApiTableEmpty
            End
        End

        Move hTable             to ApiTable.hTable
        Move bFromTables        to ApiTable.bFromTable
        Move (not(bFromTables)) to ApiTable.bToTable

        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
        Move aApiColumns        to ApiTable.aApiColumns
        Move aApiIndexes        to ApiTable.aApiIndexes
        Move aApiRelations      to ApiTable.aApiRelations

        Function_Return ApiTable
    End_Function

    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
        Boolean bIsOpen

        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Move True   to APITableNameInfoEmpty.bError
            Move hTable to APITableNameInfoEmpty.iTableNumber
            Function_Return APITableNameInfoEmpty
        End

        Move hTable                                  to APITableNameInfo.iTableNumber
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID

        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL

        Function_Return APITableNameInfo
    End_Function

    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
        Integer iSize iCount iItem
        tAPITableNameInfo ApiTableNameInfo

        Move -1 to iItem
        Move (SizeOfArray(aTableStructure)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
                Move iCount to iItem
                Move iSize  to iCount // We're done.
            End
        Loop

        Function_Return iItem
    End_Function

    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
        If (APITableFrom.hTable  > APITableTo.hTable) ;
            Function_Return (GT)
        If (APITableFrom.hTable  < APITableTo.hTable) ;
            Function_Return (LT)

        If (APITableFrom.bFromTable = True)  ;
            Function_Return (LT)
        If (APITableFrom.bFromTable = False) ;
            Function_Return (GT)

        Function_Return (EQ)
    End_Function

    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
        Handle hTable
        tAPITable[] aAPITableFromAndTo
        tAPITable   APITableFrom APITableTo APITableEmpty
        tAPITableNameInfoCompare APITableNameInfoCompare
        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
        tAPIColumnCompare[]   aAPIColumnCompare
        tAPIIndexCompare[]    aAPIIndexCompare
        tAPIRelationCompare[] aAPIRelationCompare
        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo

        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
        Move (SizeOfArray(aAPITableTo))   to iSizeTo
        If (iSizeFrom = 0 and iSizeTo = 0) Begin
            Function_Return aAPITableCompare
        End

        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo

        Move 0 to iItem
        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
        Decrement iSize
        for iCount from 0 to iSize

            Move iCount to iItemFrom
            Move iCount to iItemTo
            Move APITableEmpty to APITableFrom
            Move APITableEmpty to APITableTo

            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
                Move aAPITableFromAndTo[iCount]     to APITableFrom
            End
            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
                Move aAPITableFromAndTo[iCount]     to APITableTo
            End
            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
                Move aAPITableFromAndTo[iCount]     to APITableFrom
                Move (iCount + 1) to iItemTo
                Move aAPITableFromAndTo[iItemTo]    to APITableTo
            End
            If (APITableFrom.hTable > APITableTo.hTable) Begin
                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
                If (iItemTo <> -1) Begin
                    Move aAPITableTo[iItemTo] to APITableTo
                End
                Else Begin
                    Move APITableEmpty to APITableTo
                End
            End

            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
            Move APITableFrom.aApiColumns   to aApiColumnsFrom
            Move APITableFrom.aApiIndexes   to aApiIndexFrom
            Move APITableFrom.aApiRelations to aApiRelationFrom

            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
            Move APITableTo.aApiColumns     to aApiColumnsTo
            Move APITableTo.aApiIndexes     to aApiIndexTo
            Move APITableTo.aApiRelations   to aApiRelationTo

            Move aAPITableFromAndTo[iCount].hTable to hTable

            If (hTable > 0) Begin

                // Table info:
                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare

                // Column info:
                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare

                // Index info:
                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare

                // Relation info:
                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare

                Move False                                                              to aAPITableCompare[iItem].bShouldChange
                Move False                                                              to aAPITableCompare[iItem].bCancel
                Move False                                                              to aAPITableCompare[iItem].bError
                If (iItemTo > iItemFrom) Begin
                    Increment iCount
                End
                Increment iItem
            End

        Loop

        Function_Return aAPITableCompare
    End_Function

    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
        Integer iSize iCount iItem
        tAPITableNameInfo ApiTableNameInfo

        Move -1 to iItem
        Move (SizeOfArray(aTableStructure)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
            If (ApiTableNameInfo.iTableNumber = hTable) Begin
                Move iCount to iItem
                Move iSize  to iCount // We're done.
            End
        Loop

        Function_Return iItem
    End_Function

    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
        tAPITableNameInfoCompare APITableNameInfoCompare

        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
            Function_Return APITableNameInfoCompare
        End

        // FROM database info:
        If (APITableNameInfoFrom.iTableNumber > 0) Begin
            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
            Move True                               to APITableNameInfoCompare.bExistsFrom
        End

        // TO database info:
        If (APITableNameInfoTo.iTableNumber > 0) Begin
            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
            Move True                               to APITableNameInfoCompare.bExistsTo
        End

        Function_Return APITableNameInfoCompare
    End_Function

    // Note:
    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
    // In most cases the back end name will be the same as the table name used in DataFlex.
    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
    Function UtilTableHandleToString Handle hTable Returns String
        String sTableName
        Boolean bOpen bExists bOK

        Get _UtilTableNumberIsInUse hTable to bExists
        If (bExists = False) Begin
            Function_Return ""
        End

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Get AutoConnectionIDLogin to bOK
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
        End
        If (bOpen = True) Begin
            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
            // If blank it is an embedded table:
            If (sTableName = "") Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move 0 to LastErr
                Move False to Err
            End
            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
        End
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Move 0 to LastErr

        Function_Return sTableName
    End_Function

    // Returns the filenumber for the passed Table name from Filelist.cfg.
    // Returns 0 if unsuccessful.
    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
    Function UtilTableNameToHandle String sTableName Returns Integer
        String sValue sPrefixTableName sDriverID
        Handle hTable hRetval

        Get psDriverID to sDriverID
        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
            Move (sDriverID + ":" + sTableName) to sPrefixTableName
        End
        Move 0 to hTable
        Move 0 to hRetval
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
                    Move hTable to hRetval
                    Move 0 to hTable
                End
            End
        Until (hTable = 0)

        Function_Return hRetval
    End_Function

    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
    // _after_ all tables have successfully been converted to SQL (.int files)
    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
        Boolean bOK bExists
        String sDataPath sBackupFolder

        Close DF_ALL DF_PERMANENT
        Send DoAdvance of ghoProgressBar

        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
        Move CS_DUFBackupDataFolder to sBackupFolder
        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
        Get vFolderFormat sDataPath to sDataPath

        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
        If (bExists = False) Begin
            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
            If (bExists = False) Begin
                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
                Function_Return False
            End
        End

        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
        // We need to wait for Windows before we can copy files back
        Sleep 2  
        
        //...except for these files that needs to be copied back to the Data folder:
        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
        

        Set Message_Text of ghoStatusPanel to ""
        Function_Return True
    End_Function
    
    Function UtilTableRepairAndReindexALL Returns Boolean
        Boolean bOK bRetval
        Handle hTable
        Integer iSize iCount
        
        Move True to bOK
        Get UtilFilelistNoOfTables to iSize
        Set pbVisible    of ghoProgressBarOverall to True
        Set piPosition   of ghoProgressBarOverall to 0
        Set piMaximum    of ghoProgressBarOverall to iSize
        Set piAdvanceBy  of ghoProgressBarOverall to 1

        Repeat
            Set piPosition of ghoProgressBarOverall to iCount
            Increment iCount
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
                Get UtilTableRepairAndReindex hTable to bRetval
                If (bRetval = False) Begin
                    Move False to bOK
                End
            End
        Until (hTable = 0)
                
        Function_Return bOK
    End_Function           
    
    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
    // After the header has been repaired - also makes a re-index.  
    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
        Integer iRetval
        String sRootName sFileName sDataPath
        
        Move False to Err
        Move 0 to LastErr 
        Move True to bOK
        
        Get _UtilTableIsEmbedded hTable to bIsEmbedded
        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
            Function_Return True
        End
        Get UtilTableIsAlias hTable to bIsAlias 
        If (bIsAlias = True) Begin
            Function_Return True
        End
        
        // Check for bad file and remove if exists
        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Set private.phCurrentTable to hTable  
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
        
        // This is important! Else it can happen that the table can't be opened,
        // with a "4077 - File in use" error.
        Close DF_ALL DF_PERMANENT    
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        Set Error_Report_Mode to DUF_ERROR_REPORT
        If (bIsOpen = False) Begin
            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
            Function_Return False        
        End

        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
        If (bBadExists = True) Begin
            Get_File_Path (sRootName + ".BAD") to sFileName
            Get vDeleteFile sFileName to iRetval
        End
        
        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
        
        Move False to Err
        // **** Repair and reindex the table. ****
        Get UtilTableRepairEmbedded hTable sRootName to bOK

        // Check for bad file: if it exists, something went wrong
        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
        Get vFolderFormat sDataPath to sDataPath
        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
        If (bBadExists = True) Begin
            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
            Move False to bOK
        End
        Close hTable

        Function_Return bOK
    End_Function

    // Repair and reindex the named DataFlex data-table.
    // No checks are done if the passed table name is an embedded or SQL,
    // so use with care (make sure you only pass embedded table names).
    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
        String sMode
        Integer iVoid

        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
        Move "0" to sMode   // 0=Reindex after repair!    
        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
        Set Message_Text of ghoStatusPanel to ""
        Function_Return (iVoid = 0)
    End_Function

    // Returns _two_ arrays.
    // Returns all files that are Master files in array ByRef iaFileIsMaster
    // Also returns all files that are Alias files in a second array.
    // IMPORTANT: All master & alias files _must_ have been included into
    //            the DoSetAllMasterAndAlias message.
    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
        Integer[] iaFileIsAlias
        Integer hTable iFileAlias iSize
        Boolean bOpen

        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Open hTable
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                If (bOpen = True) Begin
                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
                        Move (SizeOfArray(iaFileIsMaster)) to iSize
                        Move hTable to iaFileIsMaster[iSize]
                    End
                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
                        Move (SizeOfArray(iaFileIsAlias)) to iSize
                        Move hTable to iaFileIsAlias[iSize]
                    End
                End
            End
        Until (hTable = 0)

        Function_Return iaFileIsAlias
    End_Function  
    
    // Is a repair of the data-header necessary? (Embedded tables only)
    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
        String sMode
        Integer iRepairNeeded bIsOpen

        Move "0" to sMode
        Set private.phCurrentTable to hTable 
        Close hTable
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded

        Function_Return iRepairNeeded
    End_Function

    // Helper function
    // Takes two params:
    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
    // Returns:
    //  DF_FILE_ALIAS_DEFAULT if no master or alias
    //  DF_FILE_IS_MASTER if master
    //  DF_FILE_IS_ALIAS if alias
    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
        Integer i iSize

        Move (SizeOfArray(iaFileIsMaster)) to iSize
        Decrement iSize
        for i from 0 to iSize
            If (hTable = iaFileIsMaster[i]) Begin
                Function_Return DF_FILE_IS_MASTER
            End
        Loop

        Move (SizeOfArray(iaFileIsAlias)) to iSize
        Decrement iSize
        for i from 0 to iSize
            If (hTable = iaFileIsAlias[i]) Begin
                Function_Return DF_FILE_IS_ALIAS
            End
        Loop

        Function_Return DF_FILE_ALIAS_DEFAULT
    End_Function

    // Determine the available indexes of a table.
    //
    // Arguments:
    //   Handle hTable - The number of the table
    //
    // Returns:
    //   String - A string to be used with the sort command
    //   to re-index all indexes of a table.
    Function UtilTableIndexString Handle hTable Returns String
        String  sSortString
        Integer iLastIndex iNumSegments iCount

        Move "" to sSortString
        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex

        for iCount from 1 to iLastIndex
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
            If iNumSegments Begin
                If (Length(sSortString)) ;
                    Move (Append(sSortString, " ")) to sSortString
                Move (Append(sSortString, iCount)) to sSortString
            End
        Loop

        Function_Return sSortString
    End_Function

    
    // * Dummy function for the Studio's Code Explorer *
    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Compare multiple columns. (For 'FROM' & 'TO' tables)
    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
        Boolean bIsSame
        Integer iCount iColumns iColumn

        Move True to bIsSame
        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
        Set piMaximum of ghoProgressBar  to iColumns
        Decrement iColumns

        for iCount from 0 to iColumns
            Set piPosition of ghoProgressBar to iCount
            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        Loop

        Function_Return (bIsSame = True)
    End_Function

    // Compares a single column (For 'FROM' & 'TO' tables)
    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
        Integer iFromType iToType iDbType
        tColumnType ColumnType
        Boolean bIsDateTypeFrom bIsDateTypeTo

        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
            Function_Return False
        End
        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
            Function_Return False
        End
        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
            Function_Return False
        End                                                                

        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
                Function_Return False
            End
            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;
                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
                    End
                Else Begin
                    Function_Return False
                End
            End
        End

        Get piDbType                       to iDbType
        Move APIColumnCompare.iTypeFrom    to iFromType
        Move APIColumnCompare.iTypeTo      to iToType

        // If one of the two tables are SQL and the other Embedded we need to "translate"
        // data types between Embedded and SQL.
        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
        End
        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
        End

        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo

        // Make Date and DateTime comparison?
        If (bCompareDate_DataTime = True) Begin
            If (iFromType <> iToType) Begin
                Function_Return False
            End
        End

        // This is when not checking for Date/DateTime differences but all other other field types...
        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
            If (iFromType <> iToType) Begin
                Function_Return False
            End
        End

        // Only if the field is not a Date type (any of them) we compare length & precision.
        If (bIsDateTypeFrom = False) Begin
            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
                Function_Return False
            End
            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
                Function_Return False
            End
        End

        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
            Function_Return False
        End

        Function_Return True
    End_Function

    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
        tAPIColumn[] APIColumns APIColumnsEmpty
        String sDriverID sRootName sLogicalName

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get piDbType to iDbType
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName

        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
            If (bIsOpen = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Move True to APIColumnsEmpty[0].bError
                Function_Return APIColumnsEmpty
            End
        End

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get IsSQLDriver    sDriverID to bSqlDriver
        Get IsDAWSQLDriver sDriverID to bDawSqlDriver

        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
        If (bIsSqlTable = True) Begin
            Get _UtilTableExists hTable to bExists
            If (bExists = False) Begin
                Move True to APIColumnsEmpty[0].bError
                Function_Return APIColumnsEmpty
            End
        End

        Move 0 to iCount
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        Set piMaximum of ghoProgressBar to iNumColumns

        for iColumn from 1 to iNumColumns
            Move 0 to iOptions
            Move False to bIdentityKey
            Move False to Err
            Move 0     to LastErr
            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
            Set piPosition of ghoProgressBar to iColumn
            If (bDawSqlDriver = True) Begin
                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
                If (bIsSqlTable = True) Begin
                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
                    Move iType                                                to APIColumns[iCount].iType
                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
                End
                Else Begin
                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
                End

                // If the array value is out of bounce it means that this column doesn't exist on the backend.
                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
                Move (iCheckFieldNumber >= 0) to bExists
                If (bExists = False) Begin
                    Move 0 to APIColumns[iCount].iType
                End
                If (bExists = True) Begin
                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
                End
                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
                If (bIdentityKey = True) Begin
                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
                End
            End
            Else Begin
                Move False to Err
                Move 0     to LastErr
                If (bIsSqlTable = True) Begin
                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
                End
                Else Begin
                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
                End
                // If the array value is out of bounce it means that this column doesn't exist on the backend.
                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
                If (bExists = False) Begin
                    Move 0 to APIColumns[iCount].iType
                End
            End

            If (bExists = True) Begin
                Move iColumn to APIColumns[iCount].iFieldNumber
                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
//                If (bIsSqlTable = True) Begin
//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
//                End
                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision

                // If the length was zero we might have an Overlap(!) field.
                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
                If (APIColumns[iCount].iLength = 0) Begin
                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
                    If (iType = DF_OVERLAP) Begin
                        Move 0 to APIColumns[iCount].iFieldNumber
                        Move 0 to APIColumns[iCount].iLength
                        Move 0 to APIColumns[iCount].iOptions
                        Move 0 to APIColumns[iCount].iPrecision
                        Move DF_OVERLAP to APIColumns[iCount].iType
                        Move "" to APIColumns[iCount].sFieldName
                        Decrement iCount
                    End
                End
            End
            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
            If (bUserCancel = True) Begin
                Move True to APIColumnsEmpty[0].bCancel
                Function_Return APIColumnsEmpty
            End
            Increment iCount
        Loop

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return APIColumns
    End_Function

    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
    // The combined data will be sorted on the first struct member: iIndexNumber
    // This is needed because index numbers can start at any number. The range for a particular table might also
    // have "holes" in the series of index numbers.
    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
        tAPIColumnCompare[] aAPIColumnCompare
        tAPIColumnCompare   APIColumnCompare
        Integer iSizeFrom iSizeTo iSize iCount iItem

        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
        Decrement iSizeFrom
        for iCount from 0 to iSizeFrom
            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
        Loop

        Move (SizeOfArray(APIColumnTo)) to iSizeTo
        Decrement iSizeTo
        for iCount from 0 to iSizeTo
            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
            // Search if the field number already exists in the array; else add it.
            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
            If (iItem = -1) Begin
                Move (SizeOfArray(aAPIColumnCompare))   to iItem
            End

            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
        Loop

        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare

        Function_Return aAPIColumnCompare
    End_Function

    // Checks if a field name exists in a table definition
    // Returns True if it does
    // Sample:
    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
        Integer iNumColumns iColumn
        String sColumn
        Boolean bExists bOK bOpen

        Get AutoConnectionIDLogin to bOK
        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Open hTable
        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Function_Return False
        End

        Move False to bExists
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        for iColumn from 1 to iNumColumns
            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
                Move iNumColumns to iColumn
                Move True to bExists
            End
        Loop
        Close hTable

        Function_Return bExists
    End_Function

    // Returns the field/column number for the passed FieldName as an integer.
    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
        Integer iNumColumns iColumn iRetval
        String sColumn
        Boolean bOK bOpen

        Get AutoConnectionIDLogin to bOK
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Open hTable
        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Function_Return False
        End

        Move 0 to iColumn
        Move 0 to iRetval
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        for iColumn from 1 to iNumColumns
            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
                Move iColumn to iRetval
                Move iNumColumns to iColumn
            End
        Loop
        Close hTable

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return iRetval
    End_Function

    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
    // The reciprocal function is UtilColumnTypeToInteger.
    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
        tColumnType RetvalType

        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
        Function_Return RetvalType.iSQLType
    End_Function

    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
    // The reciprocal function is UtilColumnTypeToString.
    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
        tColumnType RetvalType

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Function_Return RetvalType.sSQLType
    End_Function

    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
        tColumnType RetvalType

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Function_Return RetvalType.sPrecision
    End_Function

    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
        tColumnType RetvalType

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
        // if the column type length is _not_ fixed.
        Function_Return (RetvalType.bCanEditSize = False)
    End_Function

    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
        tColumnType RetvalType
        String sValue
        Integer iRetval iPos

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.sPrecision to sValue
        Move (Pos(".", sValue)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sValue, (iPos -1))) to iRetval
        End
        Else Begin
            Move sValue to iRetval
        End
        Function_Return iRetval
    End_Function

    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
        tColumnType RetvalType
        String sValue
        Integer iRetval iPos

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.sPrecision to sValue
        Move (Pos(".", sValue)) to iPos
        If (iPos = 0) Begin
            Function_Return 0
        End
        Move (Mid(sValue, 99, (iPos + 1))) to iRetval

        Function_Return iRetval
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Compares multiple indexes for a 'FROM' and a 'TO' table.
    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
        Boolean bIsSame
        Integer iCount iSize

        Move True to bIsSame
        Move (SizeOfArray(aAPIIndexCompare)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
            Set Error_Report_Mode to DUF_ERROR_REPORT
            If (bIsSame = False) Begin
                Function_Return False
            End
        Loop

        Function_Return bIsSame
    End_Function

    // Compares a single index for a 'FROM' and a 'TO' table.
    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
        Boolean bIsSame
        Integer iSegment

        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
            // * We should probably not compare SQL index names?
            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
            //     Function_Return False
            // End
            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End

        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
        Move (iSegment = -1) to bIsSame

        Function_Return (bIsSame = True)
    End_Function

    // Compares each segment for the passed index.
    // Returns -1 if same; else returns the index segment that differs.
    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
        Boolean bIsSame

        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments

        Decrement iNumSegments
        for iSegment from 0 to iNumSegments
            Move False to bIsSame
            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
            End
            If (bIsSame = False) Begin
                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Function_Return iSegment
            End
        Loop

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return -1 // This means bIsSame = True
    End_Function

    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
        Boolean bIsSame

        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        If (bCompareIndexUppercase = True) Begin
            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End
        If (bCompareIndexAscending = True) Begin
            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End

        Function_Return True
    End_Function

    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
        Boolean bIsSame bOK
        Integer iSize iSizeTo iCount
        tAPIIndexCompare[] aAPIIndexCompare

        Move (SizeOfArray(aIndexesFrom)) to iSize
        If (iSize = 0) Begin
            Function_Return True
        End
        Move (SizeOfArray(aIndexesTo)) to iSizeTo
        Get _UtilTableIsSql hTable to bIsSQLTableTo
        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare

        for iCount from 0 to (iSize - 1)
            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
            If (bIsSame = False) Begin
                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
            End
        Loop

        // We probably should delete other indexes if they exists.
        for iCount from (iSize +1) to iSizeTo
            Get ApiIndexRemove hTable iCount to bOK
        Loop

        Function_Return bOK
    End_Function

    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
        tAPIIndex[] APIIndexes
        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
        String sDriverID
        Boolean bDAWSQLDriver bIsOpen bIsSQLTable

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
        Get _UtilTableIsSql hTable to bIsSQLTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Open hTable
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
            If (bIsOpen = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Move True to APIIndexes[0].bError
                Function_Return APIIndexes
            End
        End

        Move 0 to iCount
        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
        for iIndex from 1 to iIndexes
            // This is a test that the index exists as there might be "holes" aka the index
            // numbers doesn't not need to be consequitive:
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
            If (iNumSegments > 0) Begin

                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
                If (bIsSQLTable = True) Begin
                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
                    Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
                    Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
                End

                Move 0 to iSegmentCount
                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
                For iSegment from 1 to iNumSegments
                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
                    Increment iSegmentCount
                Loop
                Increment iCount
            End
        Loop
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return APIIndexes
    End_Function

    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
    // The combined data will be sorted on the first struct member: iIndexNumber
    // This is needed because index numbers can start at any number. The range for a particular table might also
    // have "holes" in the series of index numbers.
    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
        tAPIIndexCompare[] aAPIIndexCompare
        tAPIIndexCompare   APIIndexCompare
        Integer iSizeFrom iSizeTo iSize iCount iItem

        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
        Move (SizeOfArray(APIIndexTo)) to iSizeTo
        If (iSizeFrom = 0 and iSizeTo = 0) Begin
            Function_Return aAPIIndexCompare
        End

        Decrement iSizeFrom
        for iCount from 0 to iSizeFrom
            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
        Loop

        Decrement iSizeTo
        for iCount from 0 to iSizeTo
            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
            // Search if the Index number already exists in the array; else add it.
            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
            If (iItem = -1) Begin
                Move (SizeOfArray(aAPIIndexCompare))    to iItem
            End

            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
        Loop

        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare

        Function_Return aAPIIndexCompare
    End_Function

    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
        Boolean bIsSame bDAWSQLDriver bIsSqlTable
        String sDriverID

        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
        Get IsSQLDriver sDriverID to bIsSqlTable
        If (bIsSqlTable = True) Begin
            Get _UtilTableIsSql hTable to bIsSqlTable
        End

        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End

        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
            // Don't think we should do this. Or should we?
            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame

            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End

        Function_Return bIsSame
    End_Function

    // DF_INDEX_SQL_TYPE values
    // Pass one of the DF_INDEX_XXX integer constants and the function
    // returns a string with the name.
    Function UtilIndexTypeToString Integer iIndexType Returns String
        String sRetval
            Case Begin
                Case (iIndexType = DF_INDEX_CLIENT)
                    Move "DF_INDEX_CLIENT" to sRetval
                    Case Break
                Case (iIndexType = DF_INDEX_SERVER)
                    Move "DF_INDEX_SERVER" to sRetval
                    Case Break
                Case (iIndexType = DF_INDEX_SERVER_ONLY)
                    Move "DF_INDEX_SERVER_ONLY" to sRetval
                    Case Break
                Case (iIndexType = DF_INDEX_TEMPORARY)
                    Move "DF_INDEX_TEMPORARY" to sRetval
                    Case Break
                Case Else
                    Move "UNKNOWN INDEX TYPE" to sRetval
            Case End
        Function_Return sRetval
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Compares multiple relationships for a 'FROM' and a 'TO' databases
    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
        Boolean bIsSame
        Integer iSize iCount

        Move True to bIsSame
        Move (SizeOfArray(aAPIRelationCompare)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        Loop

        Function_Return bIsSame
    End_Function

    // Compares a single relationship for a 'FROM' and a 'TO' table
    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
        Boolean bIsSame

        Move True to bIsSame
        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
            Function_Return False
        End
        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
            Function_Return False
        End

        // We could also compare field names, but I don't think that is necessary...

        Function_Return bIsSame
    End_Function

    // This message is different from ApiTableCreate in that it will not do a function_return if the table
    // already exists.
    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
        Boolean bOK
        Integer iSizeTo iSize iCount iColumn
        String sDriverID

        Move True to bOK
        Move (SizeOfArray(aRelationsTo))   to iSizeTo
        If (iSizeTo > 0) Begin
            Get AutoConnectionIDLogin to bOK
            Move False to Err
            Open hTable Mode DF_EXCLUSIVE
            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
            Decrement iSizeTo

            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
            // for the "TO" database. But start by deleting all current "TO" relations:
            Structure_Start hTable sDriverID
                for iCount from 0 to iSizeTo
                    Move aRelationsTo[iCount].iColumnFrom to iColumn
                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
                Loop
                Set Action_Text of ghoStatusPanel to "Restructures table..."
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
            Set Action_Text of ghoStatusPanel to ""
        End

        Move (SizeOfArray(aRelationsFrom)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
        Loop

        Function_Return bOK
    End_Function

    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
        tAPIRelation[] APIRelations
        Integer iColumn iColumnTo iNumColumns iCount
        Handle hParent
        Boolean bIsOpen

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move 0 to iCount
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
            If (bIsOpen = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Move True to APIRelations[0].bError
                Function_Return APIRelations
            End
        End

        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        For iColumn from 1 to iNumColumns
            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
            If (hParent <> 0) Begin
                Open hParent
                Move hTable                                             to APIRelations[iCount].hTableFrom
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
                Move iColumn                                            to APIRelations[iCount].iColumnFrom
                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom

                Move hParent                                            to APIRelations[iCount].hTableTo
                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
                Move False                                              to APIRelations[iCount].bShouldChange
                Move False                                              to APIRelations[iCount].bCancel
                Move False                                              to APIRelations[iCount].bError
                Close hParent
                Increment iCount
            End
        Loop

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return APIRelations
    End_Function

    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
        tAPIRelation[] aAPIRelationFromAndTo
        tAPIRelationCompare[] aAPIRelationCompare
        tAPIRelationCompare   APIRelationCompare
        Integer iSizeFrom iSizeTo iSize iCount iItem

        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
        If (iSizeFrom = 0 and iSizeTo = 0) Begin
            Function_Return aAPIRelationCompare
        End

        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo

        Decrement iSizeFrom
        for iCount from 0 to iSizeFrom
            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
        Loop

        Decrement iSizeTo
        for iCount from 0 to iSizeTo
            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo

            // Search if the relation already exists in the array; else add it.
            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
            If (iItem = -1) Begin
                Move (SizeOfArray(aAPIRelationCompare))     to iItem
            End

            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
        Loop

        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare

        Function_Return aAPIRelationCompare
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
        Boolean bFound

        Move False to Err
        Open CodeMast
        Open CodeType

        If (bCodeType = True) Begin
            Set Private.phCurrentTable to CODETYPE.File_Number
            Clear CodeType
            Move sTypeValue to CODETYPE.Type
            Find eq CODETYPE by 1
            Move Found to bFound
            If (bFound = True) Begin
                Reread CodeType
            End
            Else Begin
                Clear CodeType
            End

            Move sTypeValue to CODETYPE.Type
            Move sValue2    to CODETYPE.Description
            Move sValue3    to CODETYPE.Comment
            SaveRecord CODETYPE

            If (bFound = True) Begin
                Unlock
            End
        End

        If (bCodeType = False) Begin
            Set Private.phCurrentTable to CODEMAST.File_Number
            Clear CODEMAST
            Move sTypeValue to CODEMAST.Type
            Move sValue2    to CODEMAST.Code
            Find eq CODEMAST by 1
            Move Found to bFound
            If (bFound = True) Begin
                Reread CODEMAST
            End
            Else Begin
                Clear CODEMAST
            End

            Move sTypeValue to CODEMAST.Type
            Move sValue2    to CODEMAST.Code
            Move sValue3    to CODEMAST.Description
            SaveRecord CODEMAST

            If (bFound = True) Begin
                Unlock
            End
        End

        Close CodeMast
        Close CodeType

        Function_Return (Err = False)
    End_Function

    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
    // CodeType and then spins through all CodeMast records to change all related records.
    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
        Boolean bFound

        Move False to Err
        Open CodeMast
        Open CodeType

        Clear CodeType
        Move sFromValue to CODETYPE.Type
        Find eq CODETYPE.Type
        If (Found = True) Begin
            Reread CODETYPE
                Move sToValue to CODETYPE.Type
                SaveRecord CODETYPE
            Unlock
        End

        Clear CODEMAST
        Find gt CODEMAST by Recnum
        While (Found = True)
            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
            If (bFound = True) Begin
                Reread CODEMAST
                    Move sToValue to CODEMAST.Type
                    SaveRecord CODEMAST
                Unlock
            End
            Find gt CODEMAST by Recnum
        Loop

        Close CodeMast
        Close CodeType

        Function_Return (Err = False)
    End_Function

    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
        Boolean bFound

        Move False to Err
        Open CodeMast

        Clear CODEMAST
        Move sTypeValue to CODEMAST.Type
        Move sValue2    to CODEMAST.Code
        Find eq CODEMAST.Code
        Move Found to bFound
        If (bFound = True) Begin
            Delete CODEMAST
        End

        Close CodeMast

        Function_Return (Err = False)
    End_Function

    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
        Boolean bRecnum bToAnsi
        Integer iCh
        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM

        If (Trim(sDataPath) = "") Begin
            Function_Return False
        End

        Move False to Err
        Get psDriverID     to sDriverID
        Get psConnectionID to sConnectionID
        Get psSchema       to sSchemaName
        Get True           to bRecnum
        Get pbToANSI       to bToAnsi
        Move CS_ANSI_Txt to sANSI_OEM
        If (bToAnsi = False) Begin
            Move CS_OEM_Txt to sANSI_OEM
        End

        Get vFolderFormat sDataPath to sDataPath
        Move "CodeMast.int"         to sFileName
        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
            Writeln channel iCh ("DATABASE_NAME CODEMAST")
            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
            Writeln channel iCh ("")
            Writeln channel iCh ("RECNUM_TABLE YES")
            Writeln channel iCh ("PRIMARY_INDEX 0")
            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
            Writeln channel iCh ("")
            Writeln channel iCh ("INDEX_NUMBER 1")
            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
            Writeln channel iCh ("")
        Send Seq_Close_Channel iCh

        Get vFolderFormat sDataPath to sDataPath
        Move "CodeType.int"         to sFileName
        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
            Writeln channel iCh ("DATABASE_NAME CODETYPE")
            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
            Writeln channel iCh ("")
            Writeln channel iCh ("RECNUM_TABLE YES")
            Writeln channel iCh ("PRIMARY_INDEX 0")
            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
            Writeln channel iCh ("")
            Writeln channel iCh ("INDEX_NUMBER 0")
            Writeln channel iCh ("INDEX_NAME CODETYPE000")
            Writeln channel iCh ("")
            Writeln channel iCh ("INDEX_NUMBER 1")
            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
            Writeln channel iCh ("")
        Send Seq_Close_Channel iCh

        Function_Return (Err = False)
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
        Boolean bOK bExists
        String sDataPath sBackupFolder

        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
        Move CS_DUFBackupDataFolder to sBackupFolder
        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
        Get vFolderFormat sDataPath to sDataPath

        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
        If (bExists = False) Begin
            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
            If (bExists = False) Begin
                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
                Function_Return False
            End
            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
        End

        Set Message_Text of ghoStatusPanel to ""
        Function_Return True
    End_Function
    
    // Check if the file exists in the Data folder,
    // else creates it from memory as it has been compiled into the program as a resource:
    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
        String sPath
        Boolean bExists

        Get psDataPathFirstPart to sPath
        Move (sPath + sFileName) to sFileName
        Get vFilePathExists sFileName to bExists

        If (bExists = False) Begin
            // Read from memory & create file on disk.
            Send SqlUtilCreateFileFromMemory sResourceName sFileName
            Get vFilePathExists sFileName to bExists
        End
        Function_Return bExists
    End_Function

    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
        tColumnType RetvalType
        Integer iRetval

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.iDataFlexType to iRetval
        If (RetvalType.iDataFlexType = DF_TEXT) Begin
            If (iLength <= 255) Begin
                Move DF_ASCII to iRetval
            End
        End
        Function_Return iRetval
    End_Function

    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
        String sRetval

        Case Begin
            Case (iDataType = DF_ASCII)
                Move "DF_ASCII" to sRetval
                Case Break
            Case (iDataType = DF_BCD)
                Move "DF_BCD" to sRetval
                Case Break
            Case (iDataType = DF_BINARY)
                Move "DF_BINARY" to sRetval
                Case Break
            Case (iDataType = DF_DATE)
                Move "DF_DATE" to sRetval
                Case Break
            Case (iDataType = DF_DATETIME)
                Move "DF_DATETIME" to sRetval
                Case Break
            Case (iDataType = DF_TEXT)
                Move "DF_TEXT" to sRetval
                Case Break
            Case Else
                Move "" to sRetval
        Case End

        Function_Return sRetval
    End_Function

    // The default value used for a datatype as specified in the driver int file.
    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
        String sRetval sServer
        tColumnType RetvalType
        Integer iDriver iDataFlexType
        Handle hDatabase

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.iDataFlexType to iDataFlexType
        Get DriverIndex sDriverID to iDriver
        Get psServer to sServer
        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
        If (hDatabase = 0) Begin
            Function_Return ""
        End

        Case Begin
            Case (iDataFlexType = DF_ASCII)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_BCD)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_BINARY)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_DATE)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_DATETIME)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_TEXT)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
                Case Break
            Case Else
                Move "" to sRetval
        Case End

        Function_Return sRetval
    End_Function

    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
        String sDriverID sServer
        tColumnType RetvalType
        Integer iDbType iDriver
        Handle hDatabase

        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        Get DriverIndex sDriverID to iDriver
        Get psServer to sServer
        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
        If (hDatabase = 0) Begin
            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
            Procedure_Return
        End

        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue

    End_Procedure

    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
        String sDriverID sServer
        tColumnType RetvalType
        Integer iDbType iDriver
        Handle hDatabase

        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        Get DriverIndex sDriverID to iDriver
        Get psServer to sServer
        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
        If (hDatabase = 0) Begin
            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
            Procedure_Return
        End

        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue

    End_Procedure

    // Returns a struct array with the default column types for the SQL back-end and how they
    // are mapped to the standard DataFlex data types.
    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
        tColumnType[] ColumnTypeArray EmptyArray
        String sDataType
        Integer iDataType iDriverID iCount
        Boolean bSQLDriver

        Move 0 to iCount
        Get DriverIndex sDriverID to iDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver = False) Begin
            Function_Return EmptyArray
        End

        // DF_ASCII
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sSQLType
        Move iDataType   to ColumnTypeArray[iCount].iSQLType
        Increment iCount

        // DF_BINARY
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sSQLType
        Move iDataType   to ColumnTypeArray[iCount].iSQLType
        Increment iCount

        // DF_DATE
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sSQLType
        Move iDataType   to ColumnTypeArray[iCount].iSQLType
        Increment iCount

        // DF_DATETIME
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sSQLType
        Move iDataType   to ColumnTypeArray[iCount].iSQLType
        Increment iCount

        // DF_NUMERIC
        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
        // we make them here all "Numeric"...
        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move SQL_NUMERIC to iDataType
                Move "numeric"   to sDataType
                Case Break
            Case (sDriverID = DB2_DRV_ID)
                Move SQL_NUMERIC to iDataType
                Move "NUMERIC"   to sDataType
                Case Break
            Case Else
                Move DF_BCD      to iDataType
                Move "Numeric"   to sDataType
        Case End
        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sSQLType
        Move iDataType   to ColumnTypeArray[iCount].iSQLType
        Increment iCount

        // DF_TEXT
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sSQLType
        Move iDataType   to ColumnTypeArray[iCount].iSQLType

        Function_Return ColumnTypeArray
    End_Function

    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
        tColumnType[] ColumnTypeArray
        tColumnType   ColumnType
        Integer iCount iSize

        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
        Move (SizeOfArray(ColumnTypeArray)) to iSize
        Decrement iSize

        for iCount from 0 to iSize
            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
                Move iSize to iCount
            End
        Loop

        Function_Return ColumnType
    End_Function

    // Returns True if the passed hTable (filelist slot number) is an Alias table.
    // An Alias file/table is a filelist number that share the same Physical filename
    // but the Logical name is different.
    // Note: If the table cannot be opened; the table is not considered to be an Alias.
    Function UtilTableIsAlias Handle hTable Returns Boolean
        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
        Handle hInTable hMasterTable 
        Boolean bIsAlias
        
        Move hTable to hInTable
        Move False to bIsAlias
        Move 0 to hMasterTable
        
        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        // Remove any prefix with a driver name.
        Get _TableNameOnly sRootName to sRootName     
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get _TableNameOnly sLogicalName to sLogicalName     
        
        // If the table has the same root and logical name it can't be an alias,
        // so we can safely return a "False".
        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
            Function_Return False
        End
        
        // Now we need to find a master table with the same root name (sRootName above),
        // as the passed hTable root name.
        // A master table always has the same root and logical name.
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0 and hTable <> 50) Begin
                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
                Get _TableNameOnly sRootNameCompare to sRootNameCompare
                // If we found another table with the same root and logical name
                // we have found a master table.
                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
                        Move hTable to hMasterTable   
                        Move 0 to hTable // To end the loop.
                    End
                End
            End
        Until (hTable = 0)
        
        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
            Move True to bIsAlias
        End
        
        Function_Return bIsAlias
    End_Function

    // To Open a table with any driver.
    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
    //       that the proper login properties has been setup properly with the cSQLConnections object.
    //
    // If the open command fails the Err flag will be reset to false, at the end of the function!
    // The found flag is still used to indicate if the open was successful or not. The function
    // returns a True if successful (table could be opened).
    //
    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
    // This is good because with DFConnectionID's those credentials doesn't need to be available in
    // the .int file (and probably aren't). As long as the login properties of this object have been
    // set properly we can open the table.
    //
    // DAW Driver Syntax:
    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
    //
    // DAW Driver Sample:
    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
    //
    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
        String sTableNameOrg
        Boolean bOpen bOK
        tSQLConnection SQLConnection
        
        Move False to bOpen
        Move sTableName to sTableNameOrg
        If (hTable > 0) Begin
            Send Ignore_Error of Error_Object_Id 20529
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
            Send Ignore_Error of Error_Object_Id 10
            Open hTable Mode iMode
            Send Trap_Error of Error_Object_Id 20529
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
            Send Trap_Error of Error_Object_Id 10
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
            If (bOpen = True) Begin
                Function_Return True
            End
        End

        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
        End

        Function_Return bOpen
    End_Function

    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
        Boolean bOpen bOK
        tSQLConnection SQLConnection

        If (hTable < 1) Begin
            Function_Return False
        End

        Move sTableName to sTableNameOrg
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sDriverID to sDriverID
        Move SQLConnection.sConnectionString to sConnection
        Move SQLConnection.sSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        // We need to remove the ".int" part of the table name because
        // the table name after the "#" in the connection syntax below wants the
        // "bare" table name without any extension.
        If (sDriverID <> DATAFLEX_ID) Begin
            If (Lowercase(sTableName) contains ".int") Begin
                Get ParseFileExtension sTableName to sExt
                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
            End
            Else Begin
                Move sTableName to sTableNameShort
                Move (Append(sTableName, ".int")) to sTableName
            End
            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
            Move sConnection to sTableName
        End

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
        If (hTable = 0) Begin
            Get NextFreeFilelistSlot to hTable
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Close hTable
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Close hTable
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = ODBC_DRV_ID)
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode = DF_SHARE) Begin
                    Close hTable
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = DATAFLEX_ID)
                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
                    Close hTable
                    Open sTableName as hTable
                End
                Else If (iMode = DF_EXCLUSIVE) Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Else Begin
                    Open hTable
                End
                Case Break

            Case Else
                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
        Case End

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
            Move False to Found
        End
        // If open failed, the Err is set to true,
        // but we don't want that because it could end our loop.
        Move False to Err
        Get_Attribute DF_FILE_OPENED of hTable to bOpen

        Function_Return bOpen
    End_Function

    // Pass a table's logical name
    // Returns True if the table exists in filelist.cfg.
    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
        Handle hTable
        Boolean bFound
        String sCompareTable

        Move False to bFound
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
                    Move True to bFound
                End
            End
            If (bFound = True) ;
                Break
        Until (hTable = 0)

        Function_Return (bFound = True)
    End_Function

    // Function will report the default driver "DATAFLEX" if table can't be opened
    Function UtilDriverFromTableNumber Handle hTable Returns String
        Boolean bOK bExists
        String sDriverID

        Get _UtilTableExists hTable to bExists
        If (bExists = False) Begin
            Function_Return DATAFLEX_ID
        End
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return DATAFLEX_ID
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Function_Return sDriverID
    End_Function

    // Number of tables in Filelist.cfg. Returns integger
    Function UtilFilelistNoOfTables Returns Integer
        Handle hTable
        Integer iRetval

        Move 0 to hTable
        Move 0 to iRetval

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Increment iRetval
            End
        Until (hTable = 0)

        Function_Return iRetval
    End_Function

    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
    Function UtilIsAnyFilelistEntrySQLtable Returns String
        Handle hTable
        String sRoot sDriverID
        Boolean bIsSQLTable
        Integer iPos

        Move 0 to hTable
        Move "" to sDriverID
        Move False to bIsSQLTable

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
                If (sRoot contains ":") Begin
                    Move (Pos(":", sRoot)) to iPos
                    Move (Left(sRoot, (iPos -1))) to sDriverID
                End
                Get IsSQLDriver sDriverID to bIsSQLTable
            End

        Until (hTable = 0 or bIsSQLTable = True)

        Function_Return sDriverID
    End_Function

    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
        String sRootName
        Boolean bIsSQL
        Handle hTable

        Move False to bIsSQL
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
                If (bIsSQL = True) Begin
                    Move 0 to hTable
                End
            End
        Until (hTable = 0)

        Function_Return (bIsSQL = False)
    End_Function

    // * Dummy function for the Studio's Code Explorer *
    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
        Function_Return False
    End_Function

    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
        String  sRetval
        String[] sOverlapFieldsArray
        Integer iType iColumn iColumns
        Boolean bOpen bOverlap

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Open hTable
        End

        Move "" to sRetval

        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns

        for iColumn from 0 to iColumns
            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
                If (bOverlap) Begin
                    If (sRetval <> "") Begin
                        Append sRetval ","
                    End
                    Append sRetval iColumn
                End
            End
        Loop

        If (bOpen = False) Begin
            Close hTable
        End

        Get StrSplitToArray sRetval "," to sOverlapFieldsArray

        Function_Return sOverlapFieldsArray
    End_Function

    Function UtilEnumerateODBCDrivers Returns String
        Handle hoRegistry hoODBCDriverNames
        Boolean bExists bKeyOpened
        String sKey
        String[] sDrivers
        Integer iDriverNames iDriverName

        Get Create (RefClass (cRegistry)) to hoRegistry
        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
        Set pfAccessRights of hoRegistry to Key_Read
        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
        Get KeyExists of hoRegistry sKey to bExists
        If (bExists) Begin
            Get OpenKey of hoRegistry sKey to bKeyOpened
            If (bKeyOpened) Begin
                Get Create (RefClass (Array)) to hoODBCDriverNames
                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
                If (iDriverNames > 0) Begin
                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
                    Decrement iDriverNames
                    for iDriverName from 0 to iDriverNames
                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
                    Loop
                End
                Send CloseKey of hoRegistry
            End
        End
        Send Destroy of hoRegistry

        Function_Return sDrivers
    End_Function

    Procedure IncreaseSortBufferSize
        String sNull
        Integer iSortBufferSize
        Boolean bBufferSet

        Move "" to sNull
        Move (1024 * 128) to iSortBufferSize
        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet

    End_Procedure

    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
        Integer iLastIndex iIndex iNumSegments
        Boolean bOK
        String sDriverID

        If (hTable > 0) Begin
            Get UtilDriverFromTableNumber hTable to sDriverID
            Close hTable
            Get OpenTableExclusive hTable to bOK
            If (bOK = False) Begin
                Procedure_Return
            End
            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
            Structure_Start hTable sDriverID
                for iIndex from 1 to iLastIndex
                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
                    If (iNumSegments > 0) Begin
                        If (bSetToBatch = True) Begin
                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
                        End
                        Else Begin
                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
                        End
                    End
                Loop
            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
        End
    End_Procedure

    Function NextFreeFilelistSlot Returns Handle
        Handle hTable

        Move 0 to hTable
        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable

        Function_Return hTable
    End_Function

    // For debugging purposes. To print Sql statements as they are build...
    Procedure DebugPrint String sStmt String sFileName
        Integer iCh
        Get Seq_Append_Output_Channel sFileName to iCh
            Write channel iCh sStmt
        Send Seq_Close_Channel iCh
    End_Procedure

    // Returns the integer number for the passed Driver ID that is
    // needed by some database API calls.
    Function DriverIndex String sDriverID Returns Integer
        String  sCurrentDriver
        Integer iNumberOfDrivers iDriver iCount

        Move 0 to iDriver

        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
        for iCount from 1 to iNumberOfDrivers

            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
                Move iCount to iDriver
            End
        Loop

        // In case it was not found, it wasn't loaded so we do that now.
        If (iDriver = 0) Begin
            Move False to Err
            Load_Driver sDriverID
            If (Err = False) Begin
                Get_Attribute DF_NUMBER_DRIVERS to iDriver
            End
        End

        Function_Return iDriver
    End_Function

    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
        String  sSqlServerClientVersionName
        
        Case Begin
            Case (iClientVersion = SQLSERVER2017CLIENT)
                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
                Case Break
                
            Case (iClientVersion = SQLSERVER2016CLIENT)
                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
                Case Break
            
            Case (iClientVersion = SQLSERVER2014CLIENT)
                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
                Case Break
            
            Case (iClientVersion = SQLSERVER2012CLIENT)
                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
                Case Break
            
            Case (iClientVersion = SQLSERVER2008CLIENT)
                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
                Case Break
            
            Case (iClientVersion = SQLSERVER2005CLIENT)
                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
                Case Break
            
            Case (iClientVersion = SQLSERVER2000CLIENT)
                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
                Case Break
            
            Case Else
                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
        Case End
        
        Function_Return sSqlServerClientVersionName
    End_Function

    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
        String  sSqlServerClientDriverName
        
        Case Begin
            Case (iClientVersion = SQLSERVER2017CLIENT)
                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
                Case Break
                
            Case (iClientVersion = SQLSERVER2016CLIENT)
                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
                Case Break
            
            Case (iClientVersion = SQLSERVER2014CLIENT)
                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
                Case Break
            
            Case (iClientVersion = SQLSERVER2012CLIENT)
                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
                Case Break
            
            Case (iClientVersion = SQLSERVER2008CLIENT)
                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
                Case Break
            
            Case (iClientVersion = SQLSERVER2005CLIENT)
                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
                Case Break
            
            Case (iClientVersion = SQLSERVER2000CLIENT)
                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
                Case Break
            
            Case Else
                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
        Case End
        
        Function_Return sSqlServerClientDriverName
    End_Function
    
    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
        String sDriverID sVersion sClient sClientLowest sRetval
        Integer iNumberOfDrivers iDriver iClient
        Handle hoCLIHandler hoMSSQLHandler   
        Boolean bOK
        
        Move "" to sRetval
        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
        Load_Driver MSSQLDRV_ID

        // Loop through all loaded drivers.
        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
        For iDriver from 1 to iNumberOfDrivers
            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
            If (sDriverID = MSSQLDRV_ID) Begin
                Set psDriverID of hoCLIHandler to sDriverID
                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
                Get CKRevision of hoCLIHandler to sVersion
                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
                If (sClient <> "" and sRetval <> "") Begin
                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
                End                                
                Else Begin
                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
                End
            End
        Loop
        Send Destroy of hoCLIHandler  
        Send Destroy of hoMSSQLHandler  
        If (bShowErrorDialog = True) Begin
            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
            If (bOK = False or (iClient < iClientVersion)) Begin
                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
                If (bExitProgram = True) Begin
                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
                End
                Send Stop_Box sRetval  
                If (bExitProgram = True) Begin
                    Send Exit_Application
                End
            End
        End
        
        Function_Return sRetval
    End_Function  
    
    // Returns True if first "." separated string is greater than the second.
    // It checks from left to right, one part of the string at a time.
    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
        String[] asVersion asSQLVersion          
        Integer iSize iCount iVersion iSQLVersion
        
        Move (StrSplitToArray(sVersion, "."))    to asVersion
        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
        Move (SizeOfArray(asVersion)) to iSize
        // Make sure the two arrays are of the same size:
        If (SizeOfArray(asSQLVersion) < iSize) Begin
            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
        End
        Decrement iSize
        for iCount from 0 to iSize
            Move asVersion[iCount]    to iVersion
            Move asSQLVersion[iCount] to iSQLVersion
            CompilerWarnings Off
            If (iVersion > iSQLVersion) Break
            CompilerWarnings On
        Loop
        
        Function_Return (iVersion > iSQLVersion)
    End_Function

    // Returns TRUE if table is opened exclusive, otherwise FALSE
    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
    //       so in that case we "cheat" and report those tables were opened OK.
    Function OpenTableExclusive Handle hTable Returns Boolean
        Integer iMode iErrorObject
        Boolean bOpened
        String sTableName 
        Handle hoCurrentErrorHandler

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        // Can't open a table properly if run through the Debugger/Studio,
        // so we generate an error here.
        // Note: Commented out for the DFRefactor project!
//        If (IsDebuggerPresent()) Begin
//            Move Error_Object_Id to hoCurrentErrorHandler
//            Get piOrgErrorHandlerID to iErrorObject
//            If (iErrorObject <> 0) Begin
//                Move iErrorObject to Error_Object_Id
//            End
//            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
//            Move hoCurrentErrorHandler to Error_Object_Id
//            Set Error_Report_Mode to DUF_ERROR_REPORT
//            Function_Return False
//        End
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened) Begin
            If (IsDebuggerPresent()) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                    Function_Return True
                End
            End
            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
            If (iMode=DF_EXCLUSIVE) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Function_Return True
            End
            Close hTable
        End
        Else Begin
            Open hTable
            Get_Attribute DF_FILE_OPENED of hTable to bOpened
            If (bOpened and IsDebuggerPresent()) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                    Function_Return True
                End
            End

        End

        Close hTable    
        Close 11
        Open hTable Mode DF_EXCLUSIVE
        Get_Attribute DF_FILE_OPENED of hTable to bOpened

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return bOpened
    End_Function

    Function AutoConnectionIDLogin Returns Boolean
        String sConnectionID sConnectionString sDriverID
        Boolean bExists bOK bSQLDriver
        Handle hoCLI hoDriver
        Integer iRetval
        tSQLConnection SQLConnection

        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver = False) Begin
            Function_Return True
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sDriverID                  to sDriverID
        Move SQLConnection.sConnectionString          to sConnectionString
        Move SQLConnection.sConnectionID to sConnectionID

        Get IsConnectionID sConnectionID sDriverID to bExists
        If (bExists = False) Begin
            // We always start by deleting the current connection - if any - because the
            // login details my have changed.
            Get phoCLIHandler to hoCLI
            Set psDriverID    of hoCLI to sDriverID
            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
            Get AutoSetConnectionID sConnectionID to bOk
            If (bOk = False) Begin
                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
                Function_Return False
            End
            Move bOK to bExists
        End

        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
        Set psDriverID of hoDriver to SQLConnection.sDriverID
        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
        Send Destroy of hoDriver

        Function_Return (bExists = True)
    End_Function

    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
    // Returns: False if nobody else is running
    //          True if at least one table is open by another process (e.g. another user is running the application)
    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
    //      tables are not locked as DataFlex tables are.
    Function IsDatabaseInUse Returns Boolean
        Handle  hTable
        String  sRootName
        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
        Integer iCount iTables

        Move 0 to iTables
        Set Action_Text of ghoStatusPanel to "Database in use check..."
        Get AutoConnectionIDLogin to bOK
        Get UtilFilelistNoOfTables to iTables
        Set piPosition   of ghoProgressBar to 0
        Set piAdvanceBy  of ghoProgressBar to 1
        Set piMaximum    of ghoProgressBar to iTables    
        Close DF_ALL
        Move 0 to hTable
        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
        Move False to bErr
        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION

        Repeat
            Set piPosition of ghoProgressBar to iCount
            Increment iCount
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs

            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
            Move False to bOpen
            Get _UtilTableExists hTable to bExists
            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Open hTable
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                Set Error_Report_Mode to DUF_ERROR_REPORT
                If (bOpen = True) Begin
                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
                    Get UtilTableIsAlias hTable to bAlias
                    If (bAlias = False) Begin
                        Close hTable
                        Get OpenTableExclusive hTable to bOpen
                        If (bOpen = False) Begin
                            Move True to bErr
                        End
                    End
                End
                Close hTable
            End
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (bErr = True ) ;
                Break
        Until (not(hTable))

        Set Action_Text of ghoStatusPanel to ""
        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
        Move False to Err

        Function_Return bErr
    End_Function

End_Class
