//****************************************************************************
// $Module type: Class
// $Module name: cDbUpdateHandler
// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
// Web-site    : http://www.rdctools.com
// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
//
// Purpose     : A framework for doing automated code based updates of a database from within
//               a program, when it is started.
//
// Description : Place _one_ object of this class right after the cApplication object.
//               Then inside this object place a series of cDbUpdateVersion objects
//               as childs. One child object for each new database update.
//
//               - OnPreUpdate is a pre-processing event called
//               before any database changes are started.
//               - OnPostUpdate is a post-processing event called after all
//               database changes have taken place.
//
// Note        : If tables have been opened prior to an object of this class
//               (e.g. in the cApplication object), those tables will be closed.
//               In that case you need to use the OnPostUpdate hook event to re-open
//               tables after the last update has finished.
//
// Security    : Before an update is attempted; three things are checked to ensure the
//               database is not in use. Aka nobody else is running the application.
//               - All tables are tested for "Open in Exclusive_Mode"
//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
//                 pbCheckDataFlexUserCount is set to False (Default = True)
//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
//                 folder and a bit-lock is performed for each start of the application and this
//                 user counter is checked before an update is attempted.
//                 Important: Even if it seems like both garters & suspenders are used to guard
//                            against the database being "in use", there is no such guarantee! The
//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
//                 automatically be released after the update is completed.
//
//
// Usage       :  Use cDbUpdateHandler.pkg
//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
//                    // Declare the table that contains a "database version" field.
//                    Declare_Datafile Sys
//                    // Either one of these syntaxes is fine:
//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
//
//                    // Don't forget to increase the pnVersionNumber property for each
//                    // cDbUpdateVersion object!
//                    // The VersionTableColumn field/column specified above will be updated automatically
//                    // with the value of pnVersionNumber after each update has been finished.
//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
//                        Set pnVersionNumber to 1.1
//                        Use VersionUpdate1_1.pkg
//                    End_Object
//
//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
//                        Set pnVersionNumber to 1.2
//                        Use VersionUpdate1_2.pkg
//                    End_Object
//
//                End_Object
//
//
// $Rev History:
//    2016-09-27  Module header created
//    2016-09-28  Removed the Master/Alias logic. All update code must
//                take place before any tables have been opened, or errors
//                could occur if the client database is out of sync with the
//                compiled program.
//                Added user counting checks + lockout while database is being
//                updated.
//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
//                as it is more in line with the child class cDbUpdateVersion name.
//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
//****************************************************************************
Use VdfBase.pkg
Use Dferror.pkg
Use seq_chnl.pkg
Use Datadict.pkg
Use DUFLanguageConstants.inc
Use DUFStatusPanel.pkg
Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Use cDbUpdateLogFile.pkg
Use cDbUpdateVersion.pkg
Use cDbUpdateUserCount.pkg
Use cDbUpdateFunctionLibrary.pkg

{ ClassType=Normal }
//{ DataBindable=True }
{ OverrideProperty=peNeighborhood Visibility=Private }
{ OverrideProperty=Delegation_Mode Visibility=Private }
{ OverrideProperty=pbApiTableUpdateAuto Visibility=Private }
{ OverrideProperty=pbCompareDate_DateTime Visibility=Private }
{ OverrideProperty=pbCompareIndexAscending Visibility=Private }
{ OverrideProperty=pbCompareIndexUppercase Visibility=Private }
    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
Class cDbUpdateHandler is a cDbUpdateFunctionLibrary // cObject
//    Import_Class_Protocol cDbUpdateFunctionLibrary
//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin

    Procedure Construct_Object
        tUserCount UserCount
        Integer iUserCount
        Handle ho                     

        Forward Send Construct_Object
        Move Self to ghoDbUpdateHandler  
        
        { MethodType=Property Category="Convert to SQL" InitialValue="Latin1_General_CS_AS" }
        // Latin1_General_CI_AS = General Insensitive collation
        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
        // Good read about which collation to select:
        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
        { InitialValue="Latin1_General_CS_AS" EnumList="Latin1_General_CS_AS, Latin1_General_CI_AS, SQL_Latin1_General_Cp1_CS_AS" }
        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"

        // Struct array that will contain pnVersionNumbers & object id's of
        // all child cDbVersion objects.
        { Visibility=Private }
        Property tDbVersionInfo[] paDbVersionInfoArray

        { Visibility=Private }
        Property Integer Error_Processing_State False  // internal usage
        
        { Visibility=Private }
        Property Boolean Private.pbDbVersionCheckDone False

        { MethodType=Property Category="DbVersion Table" InitialValue=False }
        Property Boolean pbUseCustomDbVersion False  
        
        // If this property = True _and_ no DbVersion table exists 
        // when the framework is started, a DbVersion table will be created automatically.
        { MethodType=Property Category="DbVersion Table" InitialValue=True }
        Property Boolean pbAutoCreateDbVersionTable True

        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
        // the Filelist.cfg slot number indicated by this property will be used
        // if a DbVersion table is to be created. If this value = -1 at runtime
        // an Unhandled Exception Error will be genereted and the program halted. So
        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
        // to a value that corresponds to a free Filelist.cfg slot number.
        { Visibility=Private }
        Property Integer Private.piDbVersionFileNumber -1
        { Visibility=Private }
        Property Integer Private.piDbVersionFieldNumber 1

        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
        // that creates all library properties
        Send CreateDbUpdateLibraryProperties

        { Visibility=Private }
        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias

        // Error handling:
        { Visibility=Private }
        Property Boolean Private.pbOnCreateExecuted False
        { Visibility=Private }
        Property Boolean Private.pbOnPreUpdateExecuted False
        { Visibility=Private }
        Property Boolean Private.pbProcessingError False
        { Visibility=Private }
        Property Boolean pbDbUpdateErrorHasOccured False
        { Visibility=Private }
        // Don't touch. It is being used by the cDbUpdateVersion
        // subclass to tell if that particular update went OK or not.
        Property Boolean Private.pbUpdateVersionObjectError False
        { Category="Error Handling" MethodType=Property Visibility=Private }
        Property String[] paSQLQueryMessages

        { Visibility=Private }
        Property Integer piOrgErrorHandlerID Error_Object_Id
        { Visibility=Private }
        Move Self to Error_Object_Id
        // Error handling:
        // Temporarily redirect all errors to this object so we can silently
        // log all errors that might appear while updating the database.
        // We temporarily redirect all errors to this object so we can
        // log and write errors to the log file. It will be reset after
        // the database updates have been finished.
        Property Integer piCurrentErrorHandlerID Error_Object_Id

        { DesignTime=False }
        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))

        // Error Reporting Related
        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
        { Visibility=Private }
        Property Integer Error_Report_Mode DUF_ERROR_REPORT

        // If the pbContinueOnError = False, an update
        // of another cDbUpdateVersion object will _not_ be
        // performed if an error occured in a previous
        // cDbUpdateVersion object.
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbContinueOnError False
        // Stops execution in other cDbUpdateVersion objecs,
        // if errors occurred in one cDbUpdateVersion object.
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbStopOnFirstError False
        // If True errors that occured while updating the database
        // will be shown in the default app for .txt files when done.
        // Note: The log file will _always_ be created in the Data folder.
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbShowErrorLogPostRun True

        // Be _very_ careful to set this property to true!
        // If = True, no question will be asked if the update
        // should begin. Also, even if the pbShowErrorLogPostRun=True,
        // the error log won't be shown. The logfile itself will still be created though.
        // You have to know what you're doing!
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbSilentMode False
        
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbEnableCancelButton False

        { Visibility=Private }
        // Don't touch! Very private. The value is used by the error log to write for which
        // cDbUpdateVersion object an error occured.
        Property Number pnCurrentVersionUpdate 0

        { Visibility=Private }
        // The user counting logic is used to safe-guard agains anybody else is
        // using the application when a database update is to be performed.
        // (Garters & suspenders!)
        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!

        { Visibility=Private }
        // This lock file is used to guard against somebody else tries to start the
        // application while updates are in progress.
        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
                                                                                      // Only the current user allowed.
        { Visibility=Private }
        // Properties for the table & column of a system file field/column where
        // the database version update number gets saved.
        Property Integer Private.Data_File  0
        { Visibility=Private }
        Property Integer Private.Data_Field 0

        { Visibility=Private }
        // Property that is used to indicate that we have already
        // started the database update.
        Property Boolean Private.pbDatabaseUpdateStarted False

        { Visibility=Private }
        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
        // at least one OnUpdate child event has been triggered. Thus at least one active
        // change of the database has been made.
        Property Boolean Private.pbDatabaseWasUpdated False

        // We need to trigger the user counting system so that a bit in the
        // user counting file is locked. This is to guard that not more than one user
        // is currently runnning the program.
        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount

        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
        If (iUserCount > 0) Begin
            Send Stop_Box CS_DUF_UpdateInProgressTxt
            Send Exit_Application
        End

        Set pbHandleQueryErrors to False
            
        { Visibility=Private }
        Property Handle phoSQLConnectionHandler 0
        // If no ghoSQLConnectionHandler object has been created prior to this object,
        // we will create one as it is used for all ConnectionID, ConnectionString
        // etc information.
        If (ghoSQLConnectionHandler = 0) Begin
            Get Create (RefClass(cSQLConnectionHandler)) to ho
            Set phoSQLConnectionHandler to ho
        End             
        
        { MethodType=Property Category="Check int. Files" InitialValue=False }
        Property Boolean pbCheckIntFiles False   
        { MethodType=Property Category="Check int. Files" InitialValue=False }
        Property Handle  phIntFilesTable 2048
        { Visibility=Private }
        Property Boolean Private.pbIntFilesTablesCheckDone False
        
        Set Icon to "Default.ico"
    End_Procedure

    Procedure End_Construct_Object
        Boolean bCheckIntFiles
        
        Forward Send End_Construct_Object
        If (Private.pbOnCreateExecuted(Self) = False) Begin  
            Send OnCreate
            Set Private.pbOnCreateExecuted to True
        End
        Send Cleanup
    End_Procedure
    
    { MethodType=Event Visibility = Public }
    // Programmers hook event.
    Procedure OnCreate
    End_Procedure        
                                 
    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
    //                                                
    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
    // cDbUpdateHandler object.
    //
    // Checks that all .int files are intact, or else writes new copies to disk. 
    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
    //
    // If not done previously the phIntFilesTable will be created and filled with data
    // from the current set of .int files - iif (if-and-only-if) this is a development
    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
    // of Filelist.cfg is made for backup purposes.
    //
    // Note: If an error occurrs the application will exit, as it means that at least one
    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
    Procedure CheckIntFilesIntegrity
        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
        String sFileListZipFile sParam sProgram sFile 
        Integer iDataPaths iCount
        Handle hTable hIntFilesTable                    
        UChar[] asFileListArray 
        String[] asSavedIntFile
        tDUFIntFile[] DUFIntFiles
        
        Get pbCheckIntFiles to bCheckIntFiles
        If (bCheckIntFiles = False) Begin
            Procedure_Return
        End
        
        Move True to bResult        
        
        // Note: Include_Resource is a compiler directive!
        // It will embedd the Filelist.cfg from the developers machine
        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
        // need to change the next code line.         
        //
        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
        // when we get here and then the compiler can't embedd it!        
        // ToDo: Change compiler directives in Project properties (?)
//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
        
        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
        Get vFilePathExists sFileListName to bExists 
        If (bExists = True) Begin
            Get ParseFolderName sFileListName to sDataPath    
            Get vFolderFormat sDataPath to sDataPath                              
            Get ParseFileName sFileListName to sFile
            // We need to create a backup copy of Filelist.cfg.
            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
            If (bOK = False) Begin
                Move False to bResult
                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
            End
        End
        // If the Filelist.cfg is missing - create it from a previous backup copy.
        Else Begin
            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
//            Get WriteFileListResource asFileListArray sFileListName to bOK  
            If (bOK = False) Begin   
                Move False to bResult
                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
            End
        End
        
        Get phIntFilesTable to hIntFilesTable
        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
        Get _TableNoPrefix sRootFileNname to sRootFileNname
        // This will automatically create the phIntFilesTable if not exists.
        // It is used to save data from the current set of .int files.
        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
            Send AutoCreateIntFilesTable
            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
            If (bIntFilesTablesCheckDone = False) Begin
                Send Info_Box CS_DUF_DbUpdatedErrorText
                Send Exit_Application of ghoApplication
            End
        End                                                       
        
        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
        // ToDo: Or should this always be attempted? Else the 
        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
        Move (IsDebuggerPresent()) to bDevelop
        If (bDevelop = False) Begin
            Get vFolderExists sDDSrcPath to bDevelop
        End
        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
        For iCount from 1 to iDataPaths
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
            Get vFolderFormat sDataPath to sDataPath 
            Get vFolderExists sDataPath to bExists
            If (bExists = True) Begin                  
                Move 0 to hTable
                Repeat
                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
                    If (hTable <> 0) Begin
                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
                        If (bIsSQL = True) Begin     
                            Get _TableNameOnly sIntFileName to sIntFileName
                            Move (sIntFileName + ".int")    to sIntFileName
                            Get IsIntFileSaved sIntFileName to bSaved  
                            Move True to bOK            
                            
                            // Save .int file to database if not done previously.
                            // We only attempt to read .int files on a development machine.
                            If (bDevelop = True) Begin
                                If (bSaved = False) Begin
                                    Get SaveIntFileData sDataPath sIntFileName to bOK
                                    If (bOK = False) Begin
                                        Move False to bResult    
                                    End
                                End         
                                If (bOK = True) Begin
                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
                                    If (SizeOfArray(asSavedIntFile)) Begin
                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
                                        If (bOK = False) Begin
                                            Move False to bResult
                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
                                        End
                                    End
                                End
                            End
                            
                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
                            If (bExists = False) Begin                           
                                // If the .int file is missing on disk; create it from database.
                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
                                If (bOK = False) Begin         
                                    Move False to bResult
                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
                                End
                            End
                        End
                    End
                Until (hTable = 0)
            End
        Loop       
        
        // If an error occured we need to exit the application.
        If (bResult = False) Begin  
            Send Info_Box CS_DUF_DbUpdatedErrorText 
            Send Exit_Application
        End
        
    End_Procedure               

    // To update currently saved IntFile data to the database.
    // Because it is much easier, we first delete all current records and
    // then saves the changed .int file to the database.
    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
        Boolean bOK
        
        Move False to bOK

        Get DeleteIntFileData sDataPath sIntFileName to bOK
        If (bOK = True) Begin
            Get SaveIntFileData sDataPath sIntFileName to bOK
        End
        
        Function_Return bOK
    End_Function
    
    Function IsIntFileSaved String sIntFileName Returns Boolean
        Handle hTable
        Boolean bOK
        Integer iColumn iIndex   
        String sFileName
        
        Move False to bOK
        Get phIntFilesTable to hTable
        Move 2              to iColumn // This is the "InfFileName" field no.
        Move 2              to iIndex  // This is the IntFileName + ID index.

        Open hTable
        Set_Field_Value hTable iColumn to sIntFileName
        Vfind hTable iIndex GE
        Get_Field_Value hTable iColumn to sFileName
        If (Trim(sIntFileName) = Trim(sFileName)) Begin
            Move True to bOK    
        End
        Close hTable
        
        Function_Return bOK       
    End_Function   
    
    // Checks that the passed .int file is the same as what is saved in the database.
    // If not same, the return string array will contain the read .int file,
    // else the returned array will be empty.
    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
        Boolean bIsSame
        
        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
        Get RemoveBlankLines asIntFileOrg   to asIntFile
        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
        
        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
        If (bIsSame = False) Begin
            Move asIntFileOrg to asReturnIntFile    
        End
        
        Function_Return asReturnIntFile    
    End_Function                                   
    
    // Takes a string array as parameter and returns a new
    // string array without any empty rows and all rows trimmed.
    // This is e.g. used by the HasIntFileChanged message to compare
    // two .int file arrays. 
    Function RemoveBlankLines String[] asIntFile Returns String[]
        Integer iSize iCount iRow
        String sVal        
        String[] asRetValArray
        
        Move (SizeOfArray(asIntFile)) to iSize
        If (iSize = 0) Begin
            Function_Return asRetValArray
        End                          
        Decrement iSize         
        Move 0 to iRow
        
        For iCount from 0  to iSize
            Move asIntFile[iCount] to sVal
            Move (Trim(sVal)) to sVal
            If (sVal <> "") Begin
                Move sVal to asRetValArray[iRow]
                Increment iRow        
            End
        Loop
        
        Function_Return asRetValArray
    End_Function
    
    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
        Handle hTable
        Boolean bOK bErr
        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
        Number iID
        String sFileName
        String[] asIntFile
        
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Get phIntFilesTable to hTable  
        Move 1              to iIDCol
        Move 2              to iFileCol
        Move 3              to iTextCol // This is the "InfFileName" field no.
        Move 1              to iIDIdx   // Main ID index.
        Move 2              to iIndex   // This is the IntFileName + ID index.

        Get ReadIntFileData sPath sIntFileName to asIntFile
        Move (SizeOfArray(asIntFile)) to iSize
        If (iSize = 0) Begin
            Function_Return False
        End
        Decrement iSize
        Open hTable  
                  
        // Find the last used ID no:
        Fill_Field hTable iIDCol with DF_HIGH
        Vfind hTable iIDIdx LE
        Get_Field_Value hTable iIDCol to iID 
        // This only happens the very first time we save a record.
        If (iID = 999999999999) Begin
            Move 0 to iID
        End
        Increment iID        
        
        Lock
            For iCount from 0 to iSize
                Clear hTable
                Set_Field_Value hTable iIDCol   to iID     
                Set_Field_Value hTable iFileCol to sIntFileName
                Set_Field_Value hTable iTextCol to asIntFile[iCount]
                SaveRecord hTable
                Increment iID
            Loop
        Unlock
        Close hTable
        
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function
    
    // Deletes all records for the passed sIntFileName value,
    // from the phIntFilesTable.
    // Returns True if no errors occured.
    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
        Handle hTable
        Boolean bOK bErr bFound
        Integer iFileCol iIndex
        String sVal
        String[] asIntFile
        
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Move 2              to iFileCol
        Move 2              to iIndex  // This is the IntFileName + ID index.
        Get phIntFilesTable to hTable  
        Open hTable  
                  
        // Find the first record
        Set_Field_Value hTable iFileCol to sIntFileName
        Vfind hTable iIndex GE
        Get_Field_Value hTable iFileCol to sVal
        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
        While (bFound = True)
            Delete hTable
            Vfind hTable iIndex GT
            Get_Field_Value hTable iFileCol to sVal
            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
        Loop
        Unlock
        Close hTable
        
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function

    // Returns all saved phIntFilesTable records for the passed 
    // sIntFileName value as a string array.
    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
        Handle hTable
        Boolean bOK bErr bFound
        Integer iFileCol iTextCol iIndex
        String sVal sFileName
        String[] asIntFile asEmptyArray
        
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Move 2              to iFileCol
        Move 3              to iTextCol // This is the "InfFileName" field no.
        Move 2              to iIndex  // This is the IntFileName + ID index.
        Get phIntFilesTable to hTable  
        Open hTable  

        // Find the first record
        Set_Field_Value hTable iFileCol to sIntFileName
        Vfind hTable iIndex GE
        Get_Field_Value hTable iFileCol to sFileName
        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
        While (bFound = True)
            Get_Field_Value hTable iFileCol to sFileName
            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
            If (bFound = True) Begin
                Get_Field_Value hTable iTextCol to sVal
                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
            End
            Vfind hTable iIndex GT
        Loop
        
        Close hTable
        Move (not(Err)) to bOK
        If (bOK = False) Begin
            Move asEmptyArray to asIntFile
        End
        Move bErr to Err               
        
        Function_Return asIntFile
    End_Function

    // Reads the passed sIntFileName from disk and returns its value
    // as a string array.
    Function ReadIntFileData String sPath String sIntFileName Returns String[]
        String[] asIntFile       
        String sFileName sLine
        Integer iCh iSize iCount
        
        Get vFolderFormat sPath to sPath
        If (not(sIntFileName contains ".")) Begin
            Move (sIntFileName + ".int") to sIntFileName
        End
        Move (sPath + sIntFileName) to sFileName
        Get Seq_Open_input_Channel sFileName to iCh
        If (iCh < 0) Begin
            Function_Return asIntFile
        End                                 
        
        Repeat
            Readln channel iCh sLine
            If (SeqEof = False) Begin
                Move sLine to asIntFile[SizeOfArray(asIntFile)]
            End
        Until (SeqEof = True)
        Send Seq_Close_Channel iCh    
        
        Function_Return asIntFile
    End_Function
    
    // Reads the Filelist.cfg from memeory as a resource.
    // The Filelist.cfg has been compiled into the program.
    Function ReadFileListResource String sMemFileName Returns UChar[]
        Integer iCh iCount
        Number nByteCount
        String[] asFileListArray sEmptyArray
        String sLine
        UChar[] uCharData
        
        Move False to Err
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM 'No channel available...'
            Function_Return sEmptyArray
        End

        // First decide the size of the script
        Direct_Input channel iCh ("Resource: " + sMemFileName)
        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
        Close_Input channel iCh
        Send Seq_Release_Channel iCh

        Function_Return uCharData
    End_Function    
    
    // Writes a copy of the workspace Filelist.cfg to disk.
    // It does so by reading from a memory resource, as the file has
    // been compiled into the program.
    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
        Boolean bOK bErr
        Integer iSize iCh
        
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Move (SizeOfArray(asFileListArray)) to iSize
        If (iSize = 0) Begin
            Function_Return False
        End

        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM 'No channel available...'
            Function_Return False
        End                      
        
        Direct_Output channel iCh sFileListName
        Writeln channel iCh asFileListArray
                
        Close_Input channel iCh
        Send Seq_Release_Channel iCh
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function

    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
    // It first deletes the .cch file (if any).
    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
        Boolean bOK bFound bExists bErr
        Integer iCh iSize iCount
        String sFileName sCCHFileName sVal
        String[] asIntFile
        
        Move Err to bErr   
        Move False to Err
        Move False to bOK

        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
        Move (SizeOfArray(asIntFile)) to iSize
        If (iSize = 0) Begin
            Function_Return False        
        End                      
        Decrement iSize
        
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Function_Return False
        End   
        
        // Before we start to actually create the new .int file, make sure we delete
        // the .cch file first.                                     
        Move (Uppercase(sIntFileName)) to sCCHFileName
        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
        If (bExists = True) Begin
            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
            If (bOK = False) Begin
                Function_Return False
            End
        End
        
        Direct_Output channel iCh (sDataPath + sIntFileName)
        For iCount from 0 to iSize
            Writeln channel iCh asIntFile[iCount]
        Loop
        
        Close_Input channel iCh
        Send Seq_Release_Channel iCh
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function   
              
    // Automatically writes .int files to disk that is missing.
    // We only need to make this test this once, but because the message is called
    // from each child cDbUpdateVersion object (and it needs to be called from there),
    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
    Procedure AutoCreateIntFilesTable 
        Integer hTable 
        Boolean bIntFilesTablesCheckDone bTableExists
        String sInfoTxt 
        
        Get phIntFilesTable to hTable  
        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
        If (bIntFilesTablesCheckDone = True) Begin
            Procedure_Return
        End

        If (hTable < 1) Begin
            Set Private.pbIntFilesTablesCheckDone to False
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
            Procedure_Return
        End

        Get _UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
        If (bTableExists = True) Begin
            Set Private.pbIntFilesTablesCheckDone to True
            Procedure_Return
        End

        Send CreateIntFilesTable hTable
        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
    End_Function
                
    Procedure CreateIntFilesTable Handle hTable
        String sTableName sColumnName sInfoTxt sDriverID sDataPath
        Boolean bTableExists bOK bUseConnectionID bExists
        tAPIColumn[] APIColumn

        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
        If (bTableExists = True) Begin
            Procedure_Return
        End

        Move False to Err
        Get psDriverID to sDriverID
        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID

        Move CS_IntFilesTableRootName to sTableName

        Move 1                  to APIColumn[0].iFieldNumber
        Move "ID"               to APIColumn[0].sFieldName
        Move DF_BCD             to APIColumn[0].iType
        Move False              to APIColumn[0].bIsSQLType
        Move 12                 to APIColumn[0].iLength
        Move 0                  to APIColumn[0].iPrecision

        Move 2                  to APIColumn[1].iFieldNumber
        Move "IntFileName"      to APIColumn[1].sFieldName
        Move DF_ASCII           to APIColumn[1].iType
        Move False              to APIColumn[1].bIsSQLType
        Move 50                 to APIColumn[1].iLength
        Move 0                  to APIColumn[1].iPrecision

        Move 3                  to APIColumn[2].iFieldNumber
        Move "IntLineText"      to APIColumn[2].sFieldName
        Move DF_ASCII           to APIColumn[2].iType
        Move False              to APIColumn[2].bIsSQLType
        Move 100                to APIColumn[2].iLength
        Move 0                  to APIColumn[2].iPrecision

        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
        
        If (bOK = True and Err = False) Begin
            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
        End
        Else Begin
            Set Private.pbIntFilesTablesCheckDone to False
            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
            Error DFERR_PROGRAM sInfoTxt
            Procedure_Return
        End
        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
        
        Open hTable
        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
        If (bOK = True) Begin
            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
        End
        If (bOK = False) Begin
            Set Private.pbIntFilesTablesCheckDone to False
            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
            Error DFERR_PROGRAM sInfoTxt
            Procedure_Return
        End                    
        
        // Check if the new .int file was created. If so and a .dat file exists - delete it.
        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
        Get vFolderFormat sDataPath to sDataPath
        Move (CS_IntFilesTableRootName + ".int") to sTableName
        Get vFilePathExists (sDataPath + sTableName) to bExists
        If (bExists = True) Begin
            Move CS_IntFilesTableRootName to sTableName
            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
            If (bExists = True) Begin
                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
            End
        End
        
        Set Private.pbIntFilesTablesCheckDone to True
    End_Procedure

    Procedure CheckAutoCreateDbVersionTable
        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
        Integer iDbVersionFileNumber

        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
        If (bDbVersionCheckDone = True) Begin
            Procedure_Return
        End
        Get pbUseCustomDbVersion to bUseCustomDbVersion
        If (bUseCustomDbVersion = True) Begin
            Procedure_Return
        End

        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
            Send Exit_Application
        End

        Get piDbVersionFileNumber to iDbVersionFileNumber
        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
        If (bTableExists = True) Begin
            Set Private.pbDbVersionCheckDone to True
            Procedure_Return
        End

        Send CreateDbVersionTable iDbVersionFileNumber

        // We only need to these DbVersion checks once, but because this message is called
        // from each child cDbUpdateVersion object (and it needs to be called from there),
        // we use a property to only run these tests once.
        Set Private.pbDbVersionCheckDone to True
    End_Procedure

    Procedure CreateDbVersionTable Handle hTable
        String sTableName sColumnName sInfoTxt sDriverID 
        Boolean bTableExists bOK bUseConnectionID
        tAPIColumn[] APIColumn

        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
        If (bTableExists = True) Begin
            Procedure_Return
        End

        Get psDriverID to sDriverID
        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID

        Move "DbVersion"        to sTableName
        Move 1                  to APIColumn[0].iFieldNumber
        Move "DatabaseVersion"  to APIColumn[0].sFieldName
        Move DF_BCD             to APIColumn[0].iType
        Move False              to APIColumn[0].bIsSQLType
        Move 4                  to APIColumn[0].iLength
        Move 2                  to APIColumn[0].iPrecision

        Move False to Err                                
        
        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
        Set psDriverID to DATAFLEX_ID
        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
        Set psDriverID to sDriverID
        
        If (bOK = True and Err = False) Begin
//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
        End
        Else Begin
            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
        End

        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
    End_Procedure

    { MethodType=Property Category="Error Handling" InitialValue=False }
    Procedure Set pbVerboseState Boolean bVerboseState
        Handle ho
        Get phoLogFile to ho
        Set pbVerboseState of ho to bVerboseState
    End_Procedure

    { MethodType=Property }
    Function pbVerboseState Returns Boolean
        Boolean bVerboseState
        Handle ho
        Get phoLogFile to ho
        Get pbVerboseState of ho to bVerboseState
        Function_Return bVerboseState
    End_Function

    // Callback functionality used when e.g. calling driver functions directly.
    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
        Integer iPerc
        Number nReady nTotal nVersion
        Boolean bVerboseState
        Handle hoLogFile

        Get pbVerboseState to bVerboseState
        Get pnCurrentVersionUpdate to nVersion
        Get phoLogFile     to hoLogFile
        Send DoAdvance of ghoProgressBar

        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
        End
        If (sCallback_Text contains "Creating index") Begin
            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
        End

        Case Begin
            Case (iCallback_Type = DF_Message_Text)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Heading_1)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Heading_2)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Heading_3)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Heading_4)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Heading_5)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Warning)
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Title)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                If (bVerboseState = True) Begin
                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
                End
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Value)
                //*** Interpret numbers
                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
                Move ((nReady/nTotal) * 100)                                                      to iPerc
                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
                Set piPosition of ghoProgressBar to iPerc
                Case Break
            Case Else
                Set Message_Text to ""
                Set Action_Text  to ""
        Case End

        Send ProcessEvents of ghoStatusPanel
        Function_Return False
    End_Function

    // This was made to be a procedure/function pair so we
    // at the same time can set the property of the cDbUpdateFunctionLibrary

    { MethodType=Property Category="Database" InitialValue=Default }
    { EnumList="EN_DbTypeMSSQL, EN_DbTypeMySQL, EN_DbTypeOracle, EN_DbTypeDB2, EN_DbTypePostgre, EN_DbTypeDataFlex" }
    Procedure Set piDbType Integer iDbType
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set piDbType of ghoSQLConnectionHandler to iDbType
    End_Procedure

    Function piDbType Returns Integer
        Integer iDbType
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get piDbType of ghoSQLConnectionHandler to iDbType
        Function_Return iDbType
    End_Function

    { MethodType=Property Category="Database" InitialValue="Default" }
    { EnumList="DATAFLEX, MSSQLDRV, DB2_DRV, ODBC_DRV, SQL_DRV, MDSPGSQL, MDSMYSQL, ORA_DRV" }
    Procedure Set psDriverID String sDriverID
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverID of ghoSQLConnectionHandler to sDriverID
    End_Procedure

    Function psDriverID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psDriverID of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
    End_Procedure

    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
        Integer iRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return 2
        End

        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
        Function_Return iRetval
    End_Function

    Procedure Set psConnectionID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psConnectionID of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    // These "properties" are settings of the cCLIHandler class, but are being
    // relayed to the ghoSQLConnectionHandler object
    // simply by changing one of its parameters.
    Procedure Set psServer String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psServer of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psServer Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psServer of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set psDatabase String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psDatabase of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDatabase Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psDatabase of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set psUserID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psUserID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psUserID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psUserID of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set psPassword String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psPassword of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psPassword Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psPassword of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set pbTrusted Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbTrusted of ghoSQLConnectionHandler to bValue
    End_Procedure

    Function pbTrusted Returns Boolean
        Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return False
        End
        Get pbTrusted of ghoSQLConnectionHandler to bValue

        Function_Return bValue
    End_Function

    Procedure Set psConnectionString String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionString of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionString Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psConnectionString of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    { MethodType=Property }
    Function piConnectionOptions Returns Integer
        Integer iValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return 0
        End
        Get piConnectionOptions of ghoSQLConnectionHandler to iValue

        Function_Return iValue
    End_Function


    { Category="Error Handling" MethodType=Property InitialValue=True }
    Procedure Set pbCheckDataFlexUserCount Boolean bState
        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
    End_Procedure

    Function pbCheckDataFlexUserCount Returns Boolean
        Boolean bState
        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
        Function_Return bState
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue="DUFUpdateLog.txt" }
    Procedure Set psLogTextFile String sValue
        Set psLogTextFile of (phoLogFile(Self)) to sValue
    End_Procedure

    Function psLogTextFile Returns String
        String sValue
        Get psLogTextFile of (phoLogFile(Self)) to sValue
        Function_Return sValue
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue="Windows Default Program" }
    Procedure Set psEditorProgram String sValue
        Set psEditorProgram of (phoLogFile(Self)) to sValue
    End_Procedure

    Function psEditorProgram Returns String
        String sValue
        Get psEditorProgram of (phoLogFile(Self)) to sValue
        Function_Return sValue
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue=False }
    Procedure Set pbUseDataTableLog Boolean bState
        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
    End_Procedure

    Function pbUseDataTableLog Returns Boolean
        Boolean bState
        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
        Function_Return bState
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue=True }
    Procedure Set pbQuickWrite Boolean bState
        Set pbQuickWrite of (phoLogFile(Self)) to bState
    End_Procedure

    Function pbQuickWrite Returns Boolean
        Boolean bState
        Get pbQuickWrite of (phoLogFile(Self)) to bState
        Function_Return bState
    End_Function

    Procedure Set pbDatabaseWasUpdated Boolean bState
        Boolean bUpdateVersionObjectError bVerboseState
        Integer iSize iCount
        Number nVersion
        String[] aSQLQueryMessages

        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
        Set Private.pbDatabaseWasUpdated to bState
        // If no errors occurred in the current cDbUpdateVersion object - write
        // to the log that it was OK.
        If (bUpdateVersionObjectError = False) Begin
            Get pnCurrentVersionUpdate to nVersion
            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
        End

        Get pbVerboseState to bVerboseState
        If (bVerboseState = True) Begin
            Get paSQLQueryMessages to aSQLQueryMessages
            Move (SizeOfArray(aSQLQueryMessages)) to iSize
            Decrement iSize
            For iCount from 0 to iSize
                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
            Loop
        End

    End_Procedure 
    
    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Procedure Set piDbVersionFileNumber Integer iFileNumber
        Set Private.piDbVersionFileNumber to iFileNumber
    End_Procedure                                         
    
    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Function piDbVersionFileNumber Returns Integer
        Function_Return (Private.piDbVersionFileNumber(Self))
    End_Function

    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
        Set Private.piDbVersionFieldNumber to iFieldNumber
    End_Procedure                                         
    
    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Function piDbVersionFieldNumber Returns Integer
        Function_Return (Private.piDbVersionFieldNumber(Self))
    End_Function

    Function pbDatabaseWasUpdated Returns Boolean
        Function_Return (Private.pbDatabaseWasUpdated(Self))
    End_Function
    
    //
    { Visibility=Public }
    Procedure ReinitializeFramework  
        tDbVersionInfo[] aDbVersionInfoArray
        Handle hoDbVersionObject
        Integer iSize iCount
        
        Set Private.pbDatabaseUpdateStarted to False
        Get paDbVersionInfoArray to aDbVersionInfoArray
        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
        Decrement iSize
        
        For iCount from 0 to iSize
            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
            Send ProcessUpdate                  of hoDbVersionObject False
        Loop
        Send Cleanup
    End_Procedure
    
    { Visibility=Private }
    // This event is triggered by the cDbUpdateVersion child class when
    // a database change is to be started, and is considered private.
    // It is only executed once for the first cDbUpateVersion object!
    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
        Integer iRetval iDataFlexUsers iUserCount
        Handle hoUserCountSystem
        tUserCount UserCount
        DateTime dtUpdateStarted
        tSQLConnection SQLConnection

        // *Important:* If we already started the update; we do no further checking.
        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
        If (bDatabaseUpdateStarted = True) Begin
            Procedure_Return
        End

        // If not silent mode; Ask user if OK to start database update.
        If (pbSilentMode(Self) = False) Begin
            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
            If (iRetval <> MBR_Yes) Begin
                Send Exit_Application
            End
        End
        
        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
        Send Start_StatusPanel      of ghoStatusPanel

        // This will save the status of all open tables including Master/Alias settings,
        // so we can restore them later;
        Send SaveOpenTables

        Move 0 to iDataFlexUsers
        // Make various tests to check that the database is not in use.
        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
        // We also use our own user counting mechanism to guard against the
        // database isn't opened already as we need exclusive access to the tables.:
        Get phoUserCountSystem to hoUserCountSystem
        Get CheckUserCount of hoUserCountSystem to UserCount
        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount

        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
        // Check DataFlex user count to see if anybody else is using the DataFlex license...
        If (bCheckDataFlexUserCount = True) Begin
            Get_Current_User_Count to iDataFlexUsers
            // For some reason DataFlex - in some cases - might think that 2 users
            // are in use while debugging from the Studio.
            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
                Decrement iDataFlexUsers
            End
        End 
        Else Begin
            Move 1 to iDataFlexUsers 
            Move 1 to iUserCount
            Move False to bInUse
        End

        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
            If (iRetval <> MBR_Yes) Begin
                Send Exit_Application
            End
        End

        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
            Send Stop_Box CS_DUF_DatabaseInUseText
            Send Exit_Application
        End

        // This will put a look on the DbUpdateLock.ucf file.
        // It is released when the update process is finished
        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount

        Move (CurrentDateTime()) to dtUpdateStarted
        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
        Set Private.pbDatabaseUpdateStarted to True

        // We need to close all tables before starting to make changes.
        Close DF_ALL DF_PERMANENT

        // If these properties has not exclicitly been set in the object, set them
        // to settings from the SQLConnections.ini file;
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        If (psSchema(Self) = "") Begin
            Set psSchema            to SQLConnection.sSchema
        End
        If (psBaseTableSpace(Self) = "") Begin
            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
        End
        If (psLongTableSpace(Self) = "") Begin
            Set psLongTableSpace    to SQLConnection.sLongTableSpace
        End
        If (psIndexTableSpace(Self) = "") Begin
            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
        End
        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
            Procedure_Return
        End

        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Send Stop_StatusPanel of ghoStatusPanel
            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
            Send Exit_Application
        End
    End_Procedure

    { MethodType=Event }
    // *** Hook message for pre-processing ***
    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
    // Aka, when another table than the standard "DbVersion" is used.
    Procedure OnCreateCustomDbVersionTable
    End_Procedure
    
    { MethodType=Event }
    // *** Hook message for pre-processing ***
    // The programmer can use this event for putting code that
    // needs to be executed _before_ code in any of the cDbUpdateVersion
    // child objects are executed.
    Procedure OnPreUpdate
    End_Procedure

    { MethodType=Event }
    // *** Hook message for post-processing ***
    // The programmer should use this event for putting code that
    // needs to be executed _after_ all database updates have finished.
    Procedure OnPostUpdate
    End_Procedure

    { MethodType=Event }
    // *** Hook message for custom DbVersion record find ***
    // The programmer can use this event for putting code that
    // needs to be executed to find a *custom* DbVersion table record.
    // By default the DbVersion table is used but this can be
    // customized by adding this line to the code;
    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
    // Note: You do _not_ need to use this event if the DbVersion table is used
    //       to save the current database version to. Only if you use your own
    //       table _and_ it is not a system table (contains only one record).
    Procedure OnFindVersionRecord
        // Open MyTable
        // Move xx to MyTable.Field1
        // Move yy to MyTable.Field2
        // Find le MyTable by Index.x
    End_Procedure

    { MethodType=Event }
    // Hook event for writing header error text (pre-update) to
    // a datatable. Only called if the pbUseDataTableLog property = True.
    // Don't forget to Open the table first (!) as all
    // tables have been closed at this stage.
    // The start date & time is passed.
    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
    End_Procedure

    { MethodType=Event }
    // Hook event to log errors to a database table.
    // Only called if the pbUseDataTableLog = True.
    // Don't forget to Open the table first (!) as all
    // tables have been closed at this stage.
    // If pbQuickWrite = True the DbUpdateErrorArray
    // will contain just one row, as it is called for each error
    // that occurred. Else it is called once at the end after all updates
    // have run and contains all errors.
    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
    End_Procedure

    { Visibility=Private }
    // Automatically send after all processing is done, but before the OnPostUpdate event.
    Procedure Cleanup
        Boolean bDatabaseWasUpdated bError

        Send CheckAutoCreateDbVersionTable
        Send RestoreOpenTables

        // The function library have two purposes; one is to use it in the
        // Database Update Framework, but it can also be used on its own.
        // If that is the case it has its own error handling system, which
        // we temporarily disbled when running updates because we have
        // error handling/logging here too... We now restore its setting.
        If (ghoDbUpdateFunctionLibrary > 0) Begin
            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
        End
        Set pbHandleQueryErrors to True

        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
        Get pbDbUpdateErrorHasOccured to bError
        If (bDatabaseWasUpdated = True or bError = True) Begin

            // We should always create the log as it also contains info about
            // the update being successful.
            Send WriteErrorLog of (phoLogFile(Self))

            // This is a programmer's hook message:
            Send OnPostUpdate

            Send Stop_StatusPanel of ghoStatusPanel

            If (pbSilentMode(Self) = False) Begin
                If (bError = True) Begin
                    If (pbShowErrorLogPostRun(Self) = True) Begin
                        Send ShowErrorLog of (phoLogFile(Self))
                    End
                    Send Info_Box CS_DUF_DbUpdatedErrorText
                    Send Exit_Application
                End
                Else Begin
                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
                        Send Info_Box CS_DUF_DatabaseUpdatedText
                    End
                    Else Begin
                        Send Info_Box CS_DUF_DatabaseCheckedText
                    End

                End
            End
        End

        // Restore the standard error handler:
        Get piOrgErrorHandlerID to Error_Object_Id
    End_Procedure

    // We do this _before_ we close the database to make changes, and save
    // all 'Master' & 'Alias' tables settings so we can restore when
    // we reopen the database.
    Procedure SaveOpenTables
        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
    End_Procedure

    // Returns a struct array with all currently open tables and a "state" that indicates if the table
    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
        Integer hTable iMasterAliasType iSize
        Boolean bOpen

        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                If (bOpen = True) Begin
                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
                End
            End
        Until (hTable = 0)

        Function_Return aDbUpdateHandlerMasterAlias
    End_Function

    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
    // Takes one parameter:
    //   A struct array with all master & alias
    Procedure RestoreOpenTables
        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
        Integer hTable iFileAlias iSize iCount
        Boolean bOpen
        String sRootName

        Move 0 to hTable
        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
            // We also need to check that the table hasn't been removed...
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            If (hTable <> 0 and sRootName <> "") Begin
                Open hTable
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                If (bOpen = True) Begin
                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
                    End
                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
                    End
                End
            End
        Loop
    End_Procedure

    // This checks for both duplicate pnVersionNumbers _and_ that
    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
    Procedure CheckForDuplicates Number nVersion
        tDbVersionInfo[] DbVersionInfoArray
        Integer iCount iSize iHits iDuplicateIndex
        Number nCompare
        Handle hObject1 hObject2
        String sObjectName1 sObjectName2
        Boolean bObjectOrderError

        Get paDbVersionInfoArray to DbVersionInfoArray
        Move (SizeOfArray(DbVersionInfoArray)) to iSize
        Decrement iSize
        Move 0 to iHits
        Move 0 to nCompare
        Move False to bObjectOrderError
        For iCount from 0 to iSize
            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
                Increment iHits
                If (iHits > 1) Begin
                    Move iCount to iDuplicateIndex
                    If (nCompare <> 0) Begin
                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
                    End
                End
            End
            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
        Loop
        If (iHits > 1) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
            Move (Name(hObject1)) to sObjectName1
            Move (Name(hObject2)) to sObjectName2
            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
            Send Exit_Application
        End
        Else If (bObjectOrderError = True) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
            Send Exit_Application
        End
    End_Procedure

    // We take care of all errors in the Error_Report below and
    // collect them all to an array property. So just ignore any
    // "Ignore_Error" & "Trap_Error" messages that might be send/used
    // in some other package.
    Procedure Ignore_Error Integer iError
    End_Procedure

    Procedure Trap_Error Integer iError
    End_Procedure

    // Build complete error description from Flexerrs and user error message.
    { Visibility=Private }
    Function Error_Description Integer Error# String ErrMsg Returns String
        String Full_Error_Text
        
        Move (Trim(ErrMsg)) to ErrMsg
        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
        
        If (ErrMsg <> "") Begin
            
            If ((Full_Error_Text<>"" ) and ;
                Error_Text_Available( DESKTOP, Error# ) ) Begin
                // Make sure last character of error text is a separating symbol.
                // if not, add a "." So we have format of "error-text. error-detail"
                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;
                    Move (Full_Error_Text - ".") to Full_Error_Text
                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
            End
            Else ;
                Move ErrMsg to Full_Error_Text
            
        End
        
        Function_Return Full_Error_Text
    End_Function

    // While we update the database we collect all errors in
    // the struct array paDbUpdateErrorArray.
    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
        Number nVersion
        Handle hoLogFile 
//        String sErrExtraText
        
        If (Private.pbProcessingError(Self)) Begin
            Procedure_Return
        End

        // The UtilTableNameFromHandleToString function does a:
        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
        // and it generates an error if the table is of the embedded type.
        // As we don't want to trigger an error in that very specific case,
        // we just ignore it here.
        //
        // If no report mode, just set the err indicator to true.
        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
            Move False to Err
            Procedure_Return
        End

        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
            Procedure_Return
        End

        Set Private.pbProcessingError to True
        Set Private.pbUpdateVersionObjectError to True

        Set pbDbUpdateErrorHasOccured to True
        Get pnCurrentVersionUpdate to nVersion
        Get phoLogFile to hoLogFile
        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True

        Set Private.pbProcessingError to False
    End_Procedure

End_Class
