//
// File: cSciLexer.pkg
// Author: Wil van Antwerpen
// Date: March 2017
//
//
// The scintilla control is made accessible here via the cSciLexer class and it's implementation has been designed to
// be almost a drop-in replacement for the codemax control that was previously the control used for editing by the Hammer.
//
// As development on codemax has ceased years ago and we need to go forward, scintilla ended up being the best match.
//
// Note that the intention is to phase out codemax and that the backwards compatibility is likely to fade over time as
// new scintilla only feature(s) will make it into the product.
//
// This is only designed this way to make the transition period from codemax to scintilla as smooth as can be.
//
// Codemax compatible methods are prefixed by CM_
//
// Documentation for the scintilla control can be found here:
// http://www.scintilla.org/ScintillaDoc.html
//
// This wrapper is licensed under the 2 clause BSD license as to make it as easy as possible to re-use if needed.
//
//
// BSD License content start
// *********************************************************************************************************
//
// Copyright (c) 2017, Wil van Antwerpen
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The views and conclusions contained in the software and documentation are those
// of the authors and should not be interpreted as representing official policies,
// either expressed or implied, of the VDF-Guidance / Hammer Project.
// *********************************************************************************************************


Use cWinFunc.pkg
Use seq_chnl.pkg
Use cSciLexer.h
Use cSciCommandHotKeySupport.pkg
Use cNormalizeCase.pkg
Use cSciLexerLanguageMixin.pkg
Use DllHandler.pkg
Use Tools\Find.dg
Use Tools\Replace.dg
Use Tools\Goto.dg

#IFDEF IS$WIN64
Define SCIMAGE_DLL For SCIMAGE64.DLL
#ELSE
Define SCIMAGE_DLL For SCIMAGE32.DLL
#ENDIF

//
//function specific for scintilla, create xpm icons
//
External_Function SciEditorIconXpm      "SciEditorIconXpm"      SCIMAGE_DLL Integer iIcon Returns Pointer
External_Function SciLoadImageAsRGBA    "SciLoadImageAsRGBA"    SCIMAGE_DLL Pointer pFileName Pointer pImage Pointer pWidth Pointer pHeight Returns integer
External_Function SciFreeRGBAImage      "SciFreeRGBAImage"      SCIMAGE_DLL Pointer pImage Returns integer


{ DesignerClass=cDTEdit }

Class cSciLexer is a DFControl // cUIObject  cObject

  Import_Class_Protocol cSciLexerLanguageMixin

  Register_Procedure OnWmSetFocus
  Register_Procedure OnWmKillFocus
  Register_Procedure OnWmPaint
  Register_Procedure DoKeyReturn
  Register_Procedure DoFileDropping
  Register_Procedure onWmContextMenu



  Procedure Construct_Object
    // the scintilla DLL to load is in the programs folder, preload it
    Set psDllLoadPath of oDllHandler to (psProgramPath(phoWorkspace(ghoApplication)))
#IFDEF IS$WIN64
    Send doLoadLibrary Of oDllHandler "SciLexer64.dll"
#ELSE
    Send doLoadLibrary Of oDllHandler "SciLexer32.dll"
#ENDIF

    Forward Send Construct_Object
    Set External_Class_Name "cScintillaEditor"  to CODEMAXWNDCLASS
    Set External_Message WM_SETFOCUS            to msg_OnWmSetFocus
    Set External_Message WM_KILLFOCUS           to msg_OnWmKillFocus
    Set External_Message WM_PAINT               to msg_OnWmPaint
    Set External_Message WM_DROPFILES           to msg_DoFileDropping
    Set External_Message WM_RBUTTONUP           to msg_onWmContextMenu
    //Set External_Message WM_KEYDOWN             to msg_onWmKeyDown  <<-- does not work



    //
    // Put any NEW properties HERE
    Property String  psFileName              ""
    Property Number  pnFileTimeStamp         0


    // These Properties are filled by CM_GetSel
    Property Integer piSelStartLine          0
    Property Integer piSelStartCol           0
    Property Integer piSelEndLine            0
    Property Integer piSelEndCol             0

    // Used to insert a self defined popup menu.
    Property Integer Floating_Menu_Object    0

    // These colors are stored in separate properties for easy access.
    Property Integer piWindowColor			     0	// Set during CM_GetColor / CM_SetColor
    Property Integer piTextColor				     0	// ...

    Property Integer peAutoIndentMode        CM_INDENT_PREVLINE
    Property Boolean pbShowMatchingBraces    True
    Property Boolean pbBraceHighLightState   False   // keeps track of brace highlight state so we can turn it off just one time instead of on each navigational action
    Property String  psEOLChar               CS_CRLF // default End Of Line character to use
    Property Handle  phMarkerLineHighLight   0       // scintilla marker handle that keeps track of the highlighted line
    Property String  piMarginLineNumberDigits 3      // character width of the line number margin (counts the digits)
    Property String[] psClearKeyBindings             // array that holds keyboard shortcut's that have to be cleared
    Property String  psSearchText            ""      // text to use in a search
    Property Boolean pbFindDocumentStart     False   // start search from begin of document, this property remembers the state of the checkbox
    Property String  psLineOnEnter           ""      // content of the line when the cursor enters it (for line_changed_tracking)
    //
    //
    // These properties used with CodeTip (SVN)
    Property Integer phoCodeTipHandler           0
    Property Integer pbCodetipRequest           False
    Property Boolean pbQuickInfo                True // QuickInfo, tooltips that have info about your source structure
    Property Integer piQuickInfoTime            1000 // default dwell time of the mouse before quickinfo triggers
    Property Integer piCodeTipStyle              0   // not used for scintilla
    Property Integer piCodeTipHighlightedStart  -1   // not used in scintilla, we set it directly
    Property Integer piCodeTipHighlightedEnd    -1   // not used in scintilla, we set it directly
    Property Integer piCodeTipArgument          -1   // denotes the current argument number that we are editing
    Property Integer piCodeTipCurrLine          -1
    Property String  psCodeTipCurrent           ""   // contains the actual tip string to display
    Property Integer piCodeTipType              C_TIPTYPE_UNDEFINED
    Property Boolean pbHadTipBeforeAutocomplete False// if codetip before autocomplete then please restore tip after the autocomplete is from the screen

    Property Boolean pbIsCodelistActive         False

    Property Boolean pbFileLoading              False // Set to true while loading file (for ex. in CM_Openfile)
    Property Boolean pbBlockSelectActive        False // Set to true when in block select mode
    Property Integer piBlockSelectAnchorPos     0
    Property Integer piBlockSelectCaretPos      0
    Property Boolean pbBlockSelectBackspace     False // Bug fix, backspace in a block select drops the block select state even while still visible
    Property Boolean pbNormalizeCase            True  // Adjust scope/key word text case on enter
    Property Integer piLinesToScrollAfterGoto   5     // Number of lines to scroll after you locate a line with a goto line
    Property Integer piUndoRedoStartLine        0     // If an undo/redo actions starts, after the operation is done, we might be at a different line


    // ****************************************************************************
    // properties below are from old codemax, the might be removed if not needed or
    // moved up if they can stay.
    //
    Property Integer phoIniHandler         Self

    Property Integer piDragAcceptFilesState        True

    // These Properties are filled by CM_PosFromChar.
    Property Integer piPosStartX           0
    Property Integer piPosStartY           0
    Property Integer piPosEndX             0
    Property Integer piPosEndY             0
    // Thes Properties are filled by FillCurrentPosition
    Property Integer piAbsPosXStart        0
    Property Integer piAbsPosYStart        0
    Property Integer piAbsPosXEnd          0
    Property Integer piAbsPosYEnd          0
    // Is used to do some actions when the find is done.
    Property Integer piFindWrapMode        FindWrapMode_NoWrapMsg
    // Is ised to Block keys.
    Property String  psBlockedKeysNo                   (Repeat("0",255))
    Property String  psBlockedKeysAlt                  (Repeat("0",255))
    Property String  psBlockedKeysShift                (Repeat("0",255))
    Property String  psBlockedKeysCtrl                 (Repeat("0",255))
    // Is used to Block keys but only once.
    Property String  psBlockedKeysNoOnce               (Repeat("0",255))
    Property String  psBlockedKeysAltOnce              (Repeat("0",255))
    Property String  psBlockedKeysShiftOnce            (Repeat("0",255))
    Property String  psBlockedKeysCtrlOnce             (Repeat("0",255))
    // Used with CMM_GetAllBookMarks.
    Property Integer piBookMarkCnt         0
    // To use with Absolute_GUIOrigin -> Overwrite it to force SelectionLists
    // to popup relative to the cursor position.
    Property Integer piDontOverwriteGUIOrigin          False
    Property Integer piGUIOriginOffsetY                0
    Property Integer piGUIOriginOffsetX                0
    //
    // These properties used with CodeList (SVN)
    Property Integer phoCodeListHandler                0
    //
    // OEM/Ansi/UTF8
    Property Boolean pbOemMode                         True    // If true then text in the editor is in OEM, if false then it is ANSI
    Property Boolean pbUtf8Mode                        False   // Set this to true when editing in UTF8
    Property Boolean pbHasUtf8BOM                      False   // File has Utf8BOM
    //
    Property Boolean pbNormalizeLineEndings            False   // If set to true it will change non CRLF line endings into CRLF on loading of the document.
    
    Property Boolean pbReindentStudioCommentOut        False   // If true, do not reindent comment lines starting at line 0, to keep studio comment out feature via ctrl+/
    //
    // I want to have a client border as default
    Set Border_Style         to Border_ClientEdge
    // Simulate these keys because they are overwritten by the DFControl.
    On_Key key_Tab           Send Default_Key
    On_Key Key_Shift+key_Tab Send Default_Key
    On_Key kEnter            Send DoKeyReturn
    On_Key KEY_INSERT        Send DoToggleOvertype

    Property Integer piRedrawState          True

    Send Define_cSciLexerLanguageMixin
  End_Procedure

  Procedure End_Construct_Object
    Forward Send End_Construct_Object

  End_Procedure

  Function SciLoadImageErrorText Integer iError Returns String
    String  sErrorText

    //ZeroString 300 to sErrorText
    //Move (SciLoadImageErrorText(iError,AddressOf(sErrorText))) To iVoid
    Move ("SciLoadImageAsRGBA, error "+trim(iError)) to sErrorText
    Function_Return (CString(sErrorText))
  End_Function


  // Allows dropping files from Windows.
  Procedure DoFileDropping Longptr wParam Longptr lParam
    Handle  hDrop
    Integer iCount iSize iC iRet
    String  sFile
    
    Move wParam             to hDrop
    Move (DragQueryFile(hDrop,|CI$FFFFFFFF,0,0))    to iCount
    For iC from 0 to (iCount-1)
      Move (DragQueryFile(hDrop,iC,0,0))          to iSize
      Move (Repeat(Character(0),iSize+1))         to sFile
      Move (DragQueryFile(hDrop,iC,AddressOf(sFile),iSize+1))    to iRet
      If iRet Begin
        Move (CString(sFile))                   to sFile
        Send onFileDropped sFile
      End
    Loop
    Move (DragFinish(hDrop))                        to iRet
  End_Procedure
  Procedure OnFileDropped String sFile
  End_Procedure

  Procedure onWmContextMenu Longptr wParam Longptr lParam
    Send DoRightClick wParam
  End_Procedure

  // This popups the SelectionList reltive to the cursor position
  Function Absolute_GUIOrigin Returns Integer
    Integer iX iY iRet
    Forward Get Absolute_GUIOrigin  to iRet
    If (piDontOverwriteGUIOrigin(Self)) Begin
      Function_Return iRet
    End
    Move (Hi(iRet))                                                 to iY
    Move (Low(iRet))                                                to iX
    Get  CM_GetSel False                                            to iRet
    Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
    Move (iY+piPosEndY(Self))                                       to iY
    Move (iX+piPosEndX(Self))                                       to iX
    Move (iY+piGUIOriginOffsetY(Self))                              to iY
    Move (iX+piGUIOriginOffsetX(Self))                              to iX
    Function_Return (MAKEWPARAM(iX,iY))
  End_Function

  // So the real GUIOrigin is always available too.
  Function Absolute_GUIOriginEx Returns Integer
    Integer iRet iOld
    Get piDontOverwriteGUIOrigin    to iOld
    Set piDontOverwriteGUIOrigin    to True
    Get Absolute_GUIOrigin          to iRet
    Set piDontOverwriteGUIOrigin    to iOld
    Function_Return iRet
  End_Function

  // Implementing Dyn.Update.State with using WM_SETREDRAW
  Procedure Set Dynamic_Update_State1 Integer iFlag
    Integer iRet
    If (window_handle(Self)) Eq 0 Begin
      Procedure_Return
    End
    Set piRedrawState   to iFlag
    Move (SendMessage(Window_Handle(Self),WM_SETREDRAW,iFlag,0))            to iRet
    If iFlag Begin
      Move (RedrawWindow(Window_Handle(Self),0,0,RDW_INVALIDATE))    to iRet
    End
  End_Procedure

  Function Dynamic_Update_State1 Returns Integer
    Function_Return (piRedrawState(Self))
  End_Function

  Procedure OnWmPaint
  End_Procedure


  Function CreateIndentation Integer iIndent Integer iTabSize Boolean bInsertSpaces Returns String
    String sIndent

    Move "" to sIndent
    If (bInsertSpaces=False) Begin
      While (iIndent>=iTabSize)
        Move (sIndent+"\t") to sIndent
        Move (iIndent-iTabSize) to iIndent
      Loop
      Move (Replaces("\t",sIndent,Character(9))) to sIndent
      While (iIndent>0)
        Move (sIndent+" ") to sIndent
        Decrement iIndent
      Loop
    End
    Else Begin
      Move (Repeat(" ",iIndent)) To sIndent
    End
    Function_Return sIndent
  End_Function

  Function DefaultTabIndent Returns String
    Boolean bUseTabs
    Integer iTabSize
    String  sIndent

    Get EditorMessage SCI_GETTABWIDTH to iTabSize
    Get EditorMessage SCI_GETUSETABS  to bUseTabs
    Get CreateIndentation iTabSize iTabSize (not(bUseTabs)) To sIndent
    Function_Return sIndent
  End_Function

  // Creates an Indent String while obeying the current settings
  //
  Function IndentString Integer iIndentWanted Returns String
    Boolean bUseTabs
    Integer iTabSize
    String  sIndent

    Get EditorMessage SCI_GETTABWIDTH to iTabSize
    Get EditorMessage SCI_GETUSETABS  to bUseTabs
    Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) To sIndent
    Function_Return sIndent
  End_Function

  Function IndentStringForLine Integer iLine Returns String
    Integer iIndent
    String  sIndent

    Get EditorMessage SCI_GETLINEINDENTATION iLine to iIndent
    Get IndentString iIndent To sIndent
    Function_Return sIndent
  End_Function

  //
  // iLine is the new line we are on and iIndentWanted is the indentation from the previous
  // line. We will insert the wanted indentation and then place the cursor at the end of
  // the line.
  //
  Procedure IndentAsPreviousLine Integer iLine Integer iIndentWanted
    Integer iPos
    Integer iLen
    String  sIndent

    Get IndentString iIndentWanted to sIndent
    Move (Length(sIndent)) To iLen
    Move (sIndent+Character(0)) to sIndent
    Get EditorMessage SCI_POSITIONFROMLINE iLine to iPos
    Send EditorMessage SCI_SETTARGETRANGE iPos iPos
    Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sIndent))
    Send EditorMessage SCI_SETSEL -1 (iPos+iLen) // position the cursor to the new line indentation point and remove the selection
  End_Procedure

  Procedure DoKeyReturn
    Boolean bNormalizeCase
    Integer iLine
    Integer iIndent
    Integer iPos
    Integer iCol
    Integer iTabSize
    Integer iFoldLevel iNextFoldLevel
    Integer eMode

    Get pbNormalizeCase to bNormalizeCase
    If (bNormalizeCase) Begin
      Send doNormalizeCase
    End
    If (pbIsCodelistActive(Self)) Begin
      // We're in a autocomplete list, don't send enter, send TAB instead
      Send EditorMessage SCI_TAB
    End
    Else Begin
      Get peAutoIndentMode to eMode
      Set psLineOnEnter    to ""
      If (eMode=CM_INDENT_PREVLINE) Begin
        Get  Current_Item To iLine
        Get LineFoldLevel iLine To iFoldLevel
        Send EditorMessage SCI_BEGINUNDOACTION
        Get  EditorMessage SCI_GETLINEINDENTATION iLine 0 to iIndent
        Get  EditorMessage SCI_GETCURRENTPOS 0 0 To iPos
        Get  EditorMessage SCI_GETCOLUMN  iPos 0 to iCol
        Send EditorMessage SCI_NEWLINE
        Get LineFoldLevel (iLine+1) To iNextFoldLevel
        If (iNextFoldLevel>iFoldLevel) Begin
          Get EditorMessage SCI_GETTABWIDTH 0 0 to iTabSize
          Move (iTabSize+iIndent) To iIndent // we're just after a new scope, so indent 1 extra position
        End
        If (iCol>=iIndent) Begin
          Send IndentAsPreviousLine (iLine+1) iIndent
        End
        Send EditorMessage SCI_ENDUNDOACTION
      End
      Else Begin
        Send EditorMessage SCI_NEWLINE
      End
    End
  End_Procedure
  
  Procedure DoToggleOvertype
    Send EditorMessage SCI_EDITTOGGLEOVERTYPE
    Send onOvertypeChange
  End_Procedure
  
  // To ensure that the Object with the WinFocus also owns the DF focus.
  Procedure OnWmSetFocus
    Send Activate
  End_Procedure
  
  Procedure OnWmKillFocus
  End_Procedure


  Procedure EditorMessage Handle uMsg Longptr wParam Longptr lParam
    Handle  hWnd
    Integer iRet

    Get Window_Handle to hWnd
    If (hWnd) Begin
      If num_arguments Eq 3 Begin
        Move (SendMessage(hWnd,uMsg,wParam,lParam)) to iRet
      End
      Else If num_arguments eq 2 Begin
        Move (SendMessage(hWnd,uMsg,wParam,0)) to iRet
      End
      Else If num_arguments eq 1 Begin
        Move (SendMessage(hWnd,uMsg,0,0)) to iRet
      End
    End
  End_Procedure
  
  Procedure EditorError String sMessage
    String sStack
    
    CallStackDump sStack
    Error DfErr_Program (sMessage+"\n"+sStack)
  End_Procedure

  Function EditorMessage Handle uMsg Longptr wParam Longptr lParam Returns Longptr
    Handle  hWnd
    Longptr iRet

    Move 0 To iRet
    Get Window_Handle to hWnd
    If (hWnd) Begin
      Case Begin
        Case (Num_Arguments = 0)
          Send EditorError "Programmer error, get editormessage without a parameter."
          Case Break
        Case (Num_Arguments = 1)
          Move (SendMessage(hWnd,uMsg,0,0)) To iRet
          Case Break
        Case (Num_Arguments = 2)
          Move (SendMessage(hWnd,uMsg,wParam,0)) To iRet
          Case Break
        Case (Num_Arguments = 3)
          Move (SendMessage(hWnd,uMsg,wParam,lParam)) To iRet
          Case Break
      Case End
    End
    Function_Return iRet
  End_Function

  Procedure EditorMessageString Handle uMsg String ByRef sName String ByRef sValue
    Handle  hWnd
    Integer iRet

    Get Window_Handle to hWnd
    If (hWnd) Begin
      Move (sName+ Character(0)) to sName
      Move (sValue+Character(0)) to sValue
      Move (SendMessage(hWnd,uMsg,AddressOf(sName),AddressOf(sValue))) to iRet
    End
  End_Procedure

  // By SVN - Apply Colorer
  Procedure DefaultFontStyles
    Integer iLexer
    Integer iBackColor
    String  sFont

    Send EditorMessage SCI_STYLECLEARALL
    // We have setup a default font for all, now set the specific fonts.
    //
    Set piTextColor   to gtColorer[EC_TEXT].iForeC //iTextColor
    Set piWindowColor to gtColorer[EC_WINDOW].iForeC //iBackColor
    // Caret
    Send EditorMessage SCI_SETCARETFORE       gtColorer[EC_TEXT].iForeC
    Send EditorMessage SCI_SETCARETWIDTH      3
    //Send EditorMessage SCI_SETCARETSTYLE      CARETSTYLE_BLOCK // Good for overwrite mode (Default is Underline)
    // Selection
    //Send EditorMessage SCI_SETSELFORE True (Rgb($FF, $FF, $FF)) // Will overwrite selection highlighting
    Move gtColorer[EC_WINDOW].iForeC to iBackColor
    If (iBackColor<0) Begin
      Move clWhite to iBackColor
    End
    // *** Lets check either Selection color is set and if not, then allocate default selection
    // Probably not the best algorithm, but we may improve at some stage if required ***
    If (gtColorer[EC_SELECTION].iForeC<=0) Begin
      If (iBackColor < (RGB($FF, $FF, $FF)/2-10000)) ;
        Send EditorMessage SCI_SETSELBACK True (Rgb($00, $00, $AA)) // Set darker
      Else ;
        Send EditorMessage SCI_SETSELBACK True (RGB(170,195,240))   // Set lighter
    End
    Else ;
      Send EditorMessage SCI_SETSELBACK True gtColorer[EC_SELECTION].iForeC   // Set as per options
    // # White space
    // style.dataflex.0=fore:#808080
    Send EditorMessage SCI_STYLESETFORE STYLE_DEFAULT gtColorer[EC_TEXT].iForeC
    Send EditorMessage SCI_STYLESETBACK STYLE_DEFAULT iBackColor
    Send EditorMessage SCI_STYLESETBACK 0             iBackColor
    // Retrieve lexer type for current window (eg. language) and apply the appearance for the language set.
    Get EditorMessage SCI_GETLEXER to iLexer
    Send SetAppearanceForLanguage iLexer
    Send SetAppearance  STYLE_BRACELIGHT     EC_BRACEHLIGHT      // Colors for matching braces
    Send SetAppearance  STYLE_BRACEBAD       EC_UNMATCHEDBRACE   // Colors for an unmatched brace (bracebad)
    Send SetAppearance  STYLE_LINENUMBER     EC_LINENUMBERS      // Line Numbers Margin
    Send EditorMessage  SCI_STYLESETSIZE     STYLE_LINENUMBER 10 // Set font size
    //
    // Colors for codetip tooltip
    // font style to use for call tip
    Move ("Segoe UI"+Character(0)) to sFont
    //      Move ("Verdana"+Character(0)) to sFont
    Send EditorMessage SCI_STYLESETFONT STYLE_CALLTIP   (AddressOf(sFont))
    Send EditorMessage SCI_STYLESETSIZE STYLE_CALLTIP   9
    Send EditorMessage SCI_STYLESETBACK STYLE_CALLTIP   (rgb($FF,$FF,$E1))
    Send EditorMessage SCI_STYLESETFORE STYLE_CALLTIP   (rgb($00,$00,$00)) // Code tooltip text color
    Send EditorMessage SCI_CALLTIPSETFOREHLT            (rgb($00,$00,$00)) // Code tooltip parameters color
    Send EditorMessage SCI_CALLTIPUSESTYLE 10 // tabs are filtered out of calltips, but we need to call this to have scintilla use our defined colors.
    //
    // tell the control we want to use our own font style for autocomplete
    Send EditorMessage SCI_AUTOCUSESTYLE
    // font style to use for autocomplete (codelist)
    //      Move ("DejaVu Sans Mono"+Character(0)) to sFont
    Move ("Segoe UI"+Character(0)) to sFont
    Send EditorMessage SCI_STYLESETFONT STYLE_AUTOCOMPLETE (AddressOf(sFont))
    Send EditorMessage SCI_STYLESETSIZE STYLE_AUTOCOMPLETE 10
    // Status is bookmarks, debug pointer and breakpoints
    Send EditorMessage SCI_SETMARGINBACKN MARGIN_STATUS       gtColorer[EC_LEFTMARGIN].iForeC
    // Changed line
    Send EditorMessage SCI_SETMARGINBACKN MARGIN_CHANGED_LINE gtColorer[EC_LEFTMARGIN].iForeC
  End_Procedure

  Procedure Set LexerProperty String sName String sValue
    Send EditorMessageString SCI_SETPROPERTY (&sName) (&sValue)
  End_Procedure

  Procedure SetLexer
  End_Procedure

  Procedure SetDefaultFoldingStyle
    Integer iFore
    Integer iBack
    Pointer pExpandIconXpm
    Pointer pCollapseIconXpm
    Pointer pBookmarkIconXpm
    Pointer pChangedLineIconXpm
    Pointer pSavedLineIconXpm
    //
    //line.margin.width=4
    //margin.width=$(scale 16)
    //fold.margin.width=$(scale 14)
    Set LexerProperty "line.margin.width" to "4"
    //Set LexerProperty "margin.width"      to "$(scale 16)"
    //Set LexerProperty "fold.margin.width" to "$(scale 14)"
    Set LexerProperty "margin.width"      to "16"
    Set LexerProperty "fold.margin.width" to "14"
    //
    // set folding defaults (can be changed if you want different behavior)
    //
    Set LexerProperty "fold"              to "1"
    Set LexerProperty "fold.compact"      to "1"
    Set LexerProperty "fold.flags"        to "1"
    Set LexerProperty "fold.comment"      to "1"
    Set LexerProperty "fold.preprocessor" to "1"
    Set LexerProperty "fold.dataflex.compilerlist" To "0"  // fold PRN files (is set to true when you open a prn/prp file)
    //
    // Now resize all the margins to zero
    // (This will be done in a RecalcLineMargin method...)
    //
    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 0
    //
    // Then Set the margin type and margin mask and resize it...
    //      Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING SC_MARGIN_SYMBOL
    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CODE_FOLDING SC_MASK_FOLDERS
    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 20
    Send EditorMessage SCI_SETFOLDMARGINCOLOUR    True gtColorer[EC_LINENUMBERS].iBackC
    Send EditorMessage SCI_SETFOLDMARGINHICOLOUR  True gtColorer[EC_LEFTMARGIN].iForeC
    //
    // Needs marker defines
    Move (RGB($00,$00,$00)) to iBack
    Move (RGB($bb,$bb,$bb)) to iFore
    //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDEROPEN    SC_ALPHA_TRANSPARENT
    Move (SciEditorIconXpm(0)) To pExpandIconXpm       // get xpm icon from parser DLL
    Move (SciEditorIconXpm(1)) To pCollapseIconXpm     // These icons are created by hand by Sergey!
    Move (SciEditorIconXpm(2)) To pBookmarkIconXpm
    Move (SciEditorIconXpm(3)) To pChangedLineIconXpm
    Move (SciEditorIconXpm(4)) To pSavedLineIconXpm

    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPEN    iBack
    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPEN    iFore
    If (pCollapseIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPEN pCollapseIconXpm
    End
    //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPEN    SC_MARK_CIRCLEMINUS
    //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDER        SC_ALPHA_TRANSPARENT
    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDER        iBack
    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDER        iFore
    If (pExpandIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDER    pExpandIconXpm
    End
    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERSUB     iBack
    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERSUB     iFore
    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERSUB     SC_MARK_EMPTY //SC_MARK_VLINE       //SC_MARK_EMPTY
    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERTAIL    iBack
    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERTAIL    iFore
    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERTAIL    SC_MARK_EMPTY //SC_MARK_LCORNERCURVE
    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEREND     iBack
    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEREND     iFore
    If (pExpandIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEREND    pExpandIconXpm
    End
    ///Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEREND     SC_MARK_EMPTY //SC_MARK_CIRCLEPLUSCONNECTED
    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPENMID iBack
    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPENMID iFore
    If (pCollapseIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPENMID pCollapseIconXpm
    End
    //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPENMID SC_MARK_EMPTY //SC_MARK_CIRCLEMINUSCONNECTED
    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERMIDTAIL iBack
    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERMIDTAIL iFore
    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERMIDTAIL SC_MARK_EMPTY //SC_MARK_TCORNERCURVE
    //
    //
    // SendEditor(SCI_SETFOLDFLAGS, 16, 0); // 16  	Draw line below if not expanded
    Send EditorMessage SCI_SETFOLDFLAGS 16 0
    //
    // Tell scintilla we want to be notified about mouse clicks in the codefolding margin
    Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_CODE_FOLDING 1
    //
    // Tell scintilla we want to be notified about mouse clicks in the status margin
    Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_STATUS 1
    //
    // for marker 10 define a background color instead of the marker symbol
    Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_LINEHIGHLIGHT SC_MARK_BACKGROUND
    Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_LINEHIGHLIGHT gtColorer[EC_HLIGHTEDLINE].iForeC //(rgb($DE,$DE,$EF))
    //
    // for marker 11 connect it to sergey's bookmark symbol
    //
    If (pBookmarkIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_BOOKMARK pBookmarkIconXpm
    End
    Else Begin // fall back on default
      Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_BOOKMARK  SC_MARK_BOOKMARK
      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_BOOKMARK  (rgb($DE,$00,$00))
    End
    //Send EditorMessage SCI_MARKERSETFORE SC_MARKNUM_BOOKMARK  (rgb($EE,$00,$00))
    //
    // for marker 12 and 13 connect it to the changedline icon
    If (pChangedLineIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINE pChangedLineIconXpm
    End
    Else Begin
      // We're using the SC_MARK_FULLRECT instead as we can set the color and width
      // dynamically.
      Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINE SC_MARK_FULLRECT
      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINE  (rgb($FF,$F2,$00)) // yellow
    End

    If (pSavedLineIconXpm<>0) Begin
      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINESAVED pSavedLineIconXpm
    End
    Else Begin
      Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINESAVED SC_MARK_FULLRECT
      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINESAVED  (rgb($00,$FF,$00)) // green
    End
    // for marker 14 set the debug breakpoint marker
    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_DEBUGBREAKPOINT SC_MARK_CIRCLE
    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_DEBUGBREAKPOINT (rgb($FE,$00,$00)) // red
    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_DEBUGBREAKPOINT iBack
    // for marker 15 set the debug current position pointer
    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_DEBUGCURRENTPOSITION SC_MARK_SHORTARROW
    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_DEBUGCURRENTPOSITION (rgb($00,$FE,$00)) // green
    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_DEBUGCURRENTPOSITION iBack
  End_Procedure

  Procedure SetDefaultWordStyle
    //
    // Use the default sets of word and whitespace characters. This sets whitespace to space, tab and
    // other characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
    //
    Send EditorMessage SCI_SETCHARSDEFAULT
  End_Procedure

  // Should try to destroy the font object.
  Procedure Destroy_Object
    Forward Send Destroy_Object
    //Move (CMUnregisterControl()) to iRet
  End_Procedure

  Procedure ApplyEditorOptions
    Send SetLexer
    Send DefaultFontStyles
    Send SetDefaultFoldingStyle
    Send SetDefaultWordStyle
    Send EditorMessage SCI_USEPOPUP        SC_POPUP_NEVER  // Don't use the embedded popup menu, send WM_CONTEXTMENU to parent window
    Send EditorMessage SCI_SETMODEVENTMASK SC_MODEVENTMASKALL // show ALL events in SCN_MODIFIED
    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_LINE_NUMBERS SC_MARGIN_NUMBER // margin 0 is for line numbers
    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_STATUS       (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_STATUS       16
    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_STATUS       SC_MASK_STATUS
    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CHANGED_LINE (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CHANGED_LINE 3
    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CHANGED_LINE SC_MASK_CHANGEDLINE
    //
    Send ClearRegisteredKeyBindings
    If (pbQuickInfo(Self)) Begin
      Send EditorMessage SCI_SETMOUSEDWELLTIME (piQuickInfoTime(Self))
    End
  End_Procedure

  // Used to create the window...
  Procedure Page_Object Integer iFlag
    Integer iRet
    Handle  hWnd
    Forward Send Page_Object iFlag
    If iFlag begin
      If (piDragAcceptFilesState(Self)) Begin // Allow Dragging files into it.
        Move (DragAcceptFiles(Window_Handle(Self),True)) to iRet
      End
      Get Window_Handle to hWnd
      If (hWnd<>0) Begin
        Send SetAdjustments True
        Send ApplyEditorOptions
        Send onPaged
      End
    End
  End_Procedure

  // Procedures for overwriting. (sent by page after Object is paged.)
  Procedure SetAdjustments Boolean bIsPaged
  End_Procedure
  Procedure onPaged
    // some temp code to find out defaults (to be removed)
    //Integer i iCount iWidth
    //Get EditorMessage SCI_GETMARGINS to iCount
    //For i from 0 to (iCount-1)
    //  Get EditorMessage SCI_GETMARGINWIDTHN i to iWidth
    //Loop
  End_Procedure

  // Procedures for overwriting. (sent by copy and cut functions)
  // 28.1.2003 BP
  Procedure onBeforePaste
  End_Procedure
  Procedure onAfterPaste
  End_Procedure
  Procedure onBeforeCut
  End_Procedure
  Procedure onAfterCut
  End_Procedure


  //____CODEMAX_NATIVE_METHODs...___________________________________________________


  //
  //
  Function CM_SetLanguage String sLanguage Returns Integer
    String sLexer

    Get ScintillaLexerForLanguage sLanguage to sLexer
    Move (sLexer+Character(0)) to sLexer
    Send EditorMessage SCI_SETLEXERLANGUAGE 0 (AddressOf(sLexer))
    Function_Return CME_SUCCESS
  End_Function

  //
  //
  Function CM_GetLanguage Returns String
    Integer iRet
    String  sName
    String  sLexer
    String  sFileName

    Get psFileName to sFileName
    Move (ZeroString(250)) to sLexer
    Get EditorMessage SCI_GETLEXERLANGUAGE 0 (AddressOf(sLexer)) to iRet
    //Move "VDF" To szName
    If (sLexer="cpp") Begin // cpp lexer hosts a number of languages
      // use our filename extension logic instead
      Get LanguageForFile of (phoIniHandler(Self)) sFileName  To sName
    End
    If (sName="") Begin
      Get LanguageForScintillaLexer sLexer to sName
    End
    Function_Return sName
  End_Function
  
  Function TextEncoding Returns Integer
    Integer iEncoding
    Integer iCodePage
    Boolean bIsUtf8
    Boolean bIsOem
    
    Move eTE_Unknown to iEncoding //0
    Get pbUtf8Mode To bIsUtf8
    Get EditorMessage SCI_GETCODEPAGE to iCodePage
    If (bIsUtf8) Begin
      Move eTE_UTF8 to iEncoding //1
    End
    Else Begin
      //If (iCodePage=0) Begin
      Get pbOemMode To bIsOem
      If (bIsOem) Begin
        Move eTE_OEM to iEncoding //2
      End
      Else Begin
        Move eTE_ANSI to iEncoding //3
      End
      //End
    End
    Function_Return iEncoding
  End_Function

  Function CM_EnableColorSyntax Integer bEnable Returns Integer
    //        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLORSYNTAX,  ( bEnable ), 0 ) )
    Function_Return 0
  End_Function

  Function CM_IsColorSyntaxEnabled Returns Integer
    //        Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLORSYNTAXENABLED, 0, 0 ) )
    Function_Return 0
  End_Function

  Procedure onPreOpenFile String sFile
  End_Procedure
  Procedure onPostOpenFile String sFile
  End_Procedure



  Function CM_OpenFile String szFileName Returns Integer
    Boolean bIsCRLF
    Boolean bHasBom
    Integer iChannel
    Integer iResult
    Integer iVoid
    Integer iArgSize
    Integer iNewArgSize
    Integer iPerf
    Integer iFileExists
    String  sLine
    String  sTextData
    Pointer aTextData
    UChar[] TextData

    Send Cursor_Wait of Cursor_Control

    Get StartPerfCounter of ghoApplication CPC_OpenFile szFileName to iPerf

    Get vFilePathExists szFileName to iFileExists
    If (iFileExists<>0) Begin

      Set pbFileLoading to True
      Send onPreOpenFile szFileName

      Move True To bIsCRLF  // default, we are on windows
      Get Seq_New_Channel to iChannel
      If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
        Error DFERR_PROGRAM "No Channel Available for reading from a new file"
        function_return CME_FAILURE
      End
      // Need to use binary read mode if we want to preserve tab characters and not have automatic tab replacement
      // First we look at the line ending of the first line for how the document is likely to be formatted.
      Direct_Input channel iChannel ("binary:"+szFileName)
      Readln Channel iChannel sLine
      Close_Input Channel iChannel
      // As we read in binary mode, the readln reads until it sees a LF, the LF is dropped from the line we
      // read.
      If (sLine<>"") Begin
        If (Pos(CS_CR,sLine)>0) Begin  // if last char at line is CR then strip it
          If (Right(sLine,1)=CS_CR) Begin
            Move True To bIsCRLF
          End
        End
        Else Begin
          Move False To bIsCRLF
        End
        Get CM_EnableCRLF bIsCRLF to iVoid
      End

      //
      Direct_Input channel iChannel ("binary:"+szFileName)
      Read_Block Channel iChannel TextData -1
      Close_Input channel iChannel
      
      // Checking if the file has a BOM, because if it does then we should change to UTF8 mode
      // regardless of what was set globally.
      Move (SizeOfArray(TextData) >= 3 and ( ;
            (TextData[0] = C_BOM_UTF8c1    and TextData[1] = C_BOM_UTF8c2 and TextData[2] = C_BOM_UTF8c3) or ;
            (TextData[0] = C_BOM_UTF16LEc1 and TextData[1] = C_BOM_UTF16LEc2))) to bHasBom
      If (bHasBom) Begin
        Set pbHasUtf8BOM To True
        If (pbUtf8Mode(Self)=false) Begin
          Set pbUtf8Mode      to True
          Set pbOemMode       to False
          Send EditorMessage SCI_SETCODEPAGE SC_CP_UTF8
          Send EditorMessage SCI_STYLESETCHARACTERSET STYLE_DEFAULT SC_CHARSET_ANSI
        End
      End 

      Move 0 To TextData[SizeOfArray(TextData)]  // add a zero at the end
      Move (AddressOf(TextData)) To aTextData
      If (bHasBom) Begin  // don't load the BOM in the editor control itself.
        Move (aTextData+3) To aTextData
      End
      Send Seq_Release_Channel iChannel

      // SCI_SETTEXT(<unused>, const char *text)
      If (aTextData<>0) Begin
        Send EditorMessage SCI_SETTEXT 0 aTextData
        Send EditorMessage SCI_EMPTYUNDOBUFFER
      End
      Move CME_SUCCESS to iResult

      Send onPostOpenFile szFileName
      Set pbFileLoading to False
    End
    Else Begin
      Error DfErr_Operator ("File"*szFileName*"cannot be found.")
    End

    Send StopPerfCounter of ghoApplication iPerf
    Send Cursor_Ready of Cursor_Control
    Function_Return iResult
  End_Function

  Function CM_InsertText String szText Integer iLine Integer iCol Returns Integer
    Integer iStartPos
    Integer iRet
    String  sBuffer
    //
    If (pbUtf8Mode(Self)=False) Begin
      Get Utf8ToEditorFormat szText to szText
    End
    Move (szText+Character(0)) to sBuffer
    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
    Get EditorMessage SCI_INSERTTEXT iStartPos (AddressOf(sBuffer)) to iRet
    Move CME_SUCCESS To iRet
    Function_Return iRet
  End_Function

  // **WvA 23-07-2003 Modified to fix a crash
  // Quickly changing workspaces caused the window_handle to
  // be zero. Sending a message to a window with address 0 is fatal.
  Function CM_SetText String szText Returns Integer
    Integer hoWnd iRetVal
    String  sBuffer
    Get Window_Handle to hoWnd
    If (hoWnd) Begin
      If (pbUtf8Mode(Self)=False) Begin
        Get Utf8ToEditorFormat szText to szText
      End
      Move (szText+Character(0)) to sBuffer
      Get EditorMessage SCI_SETTEXT 0 (AddressOf(sBuffer)) to iRetVal
      Move CME_SUCCESS To iRetVal
    End
    Else Begin
      Send Info_Box "Windows handle is ZERO"
      Move CME_FAILURE to iRetVal
    End
    Function_Return iRetVal
  End_Function

  Function CM_EnableWhitespaceDisplay Integer bEnable Returns Integer
    Integer iRet
    Integer eStyle
    If (bEnable) Begin
      Move SCWS_VISIBLEALWAYS To eStyle
    End
    Else Begin
      Move SCWS_INVISIBLE To eStyle
    End
    Get EditorMessage SCI_SETVIEWWS eStyle to iRet
    Set DisplayEOLCharacters to eStyle
    Function_Return iRet
  End_Function

  Function CM_IsWhitespaceDisplayEnabled Returns Integer
    Boolean bEnabled
    Integer eStyle

    Move False to bEnabled
    Get EditorMessage SCI_GETVIEWWS to eStyle
    If (eStyle<>SCWS_INVISIBLE) Begin
      Move True To bEnabled
    End
    Function_Return bEnabled
  End_Function

  Procedure ShowIndentationGuides
    Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
  End_Procedure
  Function CM_IsIndentationGuidesEnabled Returns Integer
    Integer eStyle
    Get EditorMessage SCI_GETINDENTATIONGUIDES to eStyle
    Function_Return eStyle
  End_Function
  Procedure ToggleIndentationGuides
    Integer eStyle
    Get EditorMessage SCI_GETINDENTATIONGUIDES to eStyle
    If (eStyle) ;
      Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_NONE
    Else ;
      Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
  End_Procedure
    
  Procedure ToggleScopeBlocks Integer iMode
    Send EditorMessage SCI_FOLDALL iMode
  End_Procedure
    
  Function LineHasFoldPoint Integer iLine Returns Boolean
    Boolean bFoldPoint
    Integer uFoldLevel
      
    Move False To bFoldPoint
    Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel
    Move ((uFoldLevel iAnd SC_FOLDLEVELHEADERFLAG)=SC_FOLDLEVELHEADERFLAG) To bFoldPoint
    Function_Return bFoldPoint
  End_Function
    
  Procedure CodeFoldOnScope String sScope Integer eMode
    Boolean bFoldPoint
    Integer iCurrentLine
    Integer iLine
    Integer iLineCount
    Integer iScopeLength
    String  sLine
        
    Get CurrentLine To iCurrentLine
    Move (Length(sScope)) to iScopeLength
    Get SC_LineCount To iLineCount
    Move (iLineCount-1) To iLine
    While (iLine>0)
      If ((iLineCount-1)>iLine) Begin
        Send GotoLine (iLine+1) // the line has to be visible in order to be able to get the fold level
      End
      Get LineHasFoldPoint iLine To bFoldPoint
      If (bFoldPoint) Begin
        Get Value Item iLine To sLine
        Move (lowercase(ltrim(sLine))) To sLine
        If (Left(sLine,iScopeLength)=sScope) Begin
          Send EditorMessage SCI_FOLDLINE iLine eMode
          //Send EditorMessage SCI_SETFOLDEXPANDED iLine (Not(bFold))
        End
      End
      Decrement iLine
    Loop
    If (iCurrentLine<iLineCount) Begin
      Send GotoLine iCurrentLine
      Send EditorMessage SCI_ENSUREVISIBLE iCurrentLine
    End
  End_Procedure
    
  Procedure CodeCollapseProcedures
    Send CodeFoldOnScope "procedure " SC_FOLDACTION_CONTRACT
  End_Procedure
    
  Procedure CodeExpandProcedures
    Send CodeFoldOnScope "procedure " SC_FOLDACTION_EXPAND
  End_Procedure
    
  Procedure CodeCollapseFunctions
    Send CodeFoldOnScope "function " SC_FOLDACTION_CONTRACT
  End_Procedure
    
  Procedure CodeExpandFunctions
    Send CodeFoldOnScope "function " SC_FOLDACTION_EXPAND
  End_Procedure
    
  Procedure CodeCollapseObjects
    Send CodeFoldOnScope "object " SC_FOLDACTION_CONTRACT
  End_Procedure
    
  Procedure CodeExpandObjects
    Send CodeFoldOnScope "object " SC_FOLDACTION_EXPAND
  End_Procedure
    
  Procedure CodeCollapseClasses
    Send CodeFoldOnScope "class " SC_FOLDACTION_CONTRACT
  End_Procedure
    
  Procedure CodeExpandClasses
    Send CodeFoldOnScope "class " SC_FOLDACTION_EXPAND
  End_Procedure
    
  Procedure CodeCollapseLineComments
    Send CodeFoldOnScope "//" SC_FOLDACTION_CONTRACT
  End_Procedure
    
  Procedure CodeExpandLineComments
    Send CodeFoldOnScope "//" SC_FOLDACTION_EXPAND
  End_Procedure

  Procedure SelectTillEndOfLine Integer iMode
    Integer iVirtualSpace
    Boolean bBlockEdit
    Send EditorMessage SCI_SETSELEOLFILLED iMode
    Move SCVS_NONE to iVirtualSpace
    Move False     to bBlockEdit
    If (iMode) Begin
      Move (SCVS_RECTANGULARSELECTION+SCVS_USERACCESSIBLE) to iVirtualSpace
      Move True To bBlockEdit
    End
    Send EditorMessage SCI_SETVIRTUALSPACEOPTIONS iVirtualSpace
    // This supposedly supports blockedit as in codemax, but it is extremely buggy, let's roll it ourself.
    Send EditorMessage SCI_SETADDITIONALSELECTIONTYPING bBlockEdit
  End_Procedure

  Function CM_EnableTabExpand Integer bEnable  Returns Integer
    Integer iRet
    // bEnable = tabs change into spaces
    Get EditorMessage SCI_SETUSETABS (not(bEnable)) to iRet
    Function_Return iRet
  End_Function
  Function CM_IsTabExpandEnabled Returns Integer
    Boolean bUseTabs

    Get EditorMessage SCI_GETUSETABS to bUseTabs
    Function_Return (not(bUseTabs))
  End_Function

  Function CM_SetTabSize Integer iTabSize Returns Integer

    Send EditorMessage SCI_SETTABWIDTH iTabSize
    Function_Return CME_SUCCESS
  End_Function

  Function CM_GetTabSize Returns Integer
    Integer iSize

    Get EditorMessage SCI_GETTABWIDTH To iSize
    Function_Return iSize
  End_Function

  Function CM_SetReadOnly Integer bReadOnly Returns Integer

    Send EditorMessage SCI_SETREADONLY bReadOnly
    Function_Return CME_SUCCESS
  End_Function

  Procedure Set Enabled_State Boolean bEnabled
    Integer iRet
    Get CM_SetReadOnly (not(bEnabled)) to iRet
  End_Procedure

  Function CM_IsReadOnly Returns Integer
    Boolean bReadOnly
    Get EditorMessage SCI_GETREADONLY To bReadOnly
    Function_Return bReadOnly
  End_Function

  // Does not exist in scintilla
  //
  // Line tooltips are:
  // enable or disable the display of a tooltip window showing the topmost visible line number while scrolling with the vertical scrollbar
  //    Function CM_EnableLineToolTips Integer bEnable Returns Integer
  //    Function CM_IsLineToolTipsEnabled Returns Integer

  // codemax: CMM_ENABLELEFTMARGIN
  // show or hide the left margin display area. The left margin area is used for line selection and the display of bookmarks.
  // scintilla has 5 margins, by default only margin 1 is set to 20 pixels, we keep it simple for now and
  // pretend we only have 1 margin. (MARGIN_CODE_FOLDING=1)
  Function CM_EnableLeftMargin Integer bEnable Returns Integer
    Integer iWidth
    If (bEnable) Begin
      Move 20 To iWidth
    End
    Else Begin
      Move 0 To iWidth
    End
    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING iWidth
    Function_Return CME_SUCCESS
  End_Function
  Function CM_IsLeftMarginEnabled Returns Integer
    Integer iWidth
    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_CODE_FOLDING to iWidth
    Function_Return (iWidth<>0)
  End_Function

  Procedure Set DisplayEOLCharacters Boolean bEnabled
    Send EditorMessage SCI_SETVIEWEOL   bEnabled               // show end of line characters
  End_Procedure

  Function DisplayEOLCharacters Returns Boolean
    Boolean bEnabled
    Get EditorMessage SCI_GETVIEWEOL to bEnabled
    Function_Return bEnabled
  End_Function

  Procedure WriteBlock Integer iChannel Pointer aTextData Integer iPosition Integer iBlockSize
    Boolean bOk
    String  sBlock

    Move ""   To sBlock
    Move (ZeroString(iBlockSize)) To sBlock
    Move (memcopy(AddressOf(sBlock), aTextData+iPosition, iBlockSize)) To bOk
    Write channel iChannel sBlock
  End_Procedure
  
  Procedure WriteBOM Integer iChannel
    Boolean bIsUtf8
    Boolean bHasBOM
    UChar[] ucBOM
    
    Get pbUtf8Mode   To bIsUtf8
    Get pbHasUtf8BOM To bHasBOM
    If (bIsUtf8) Begin
      If (bHasBOM) Begin
        Move (ResizeArray(ucBOM,3)) To ucBOM
        Move C_BOM_UTF8c1 To ucBOM[0]
        Move C_BOM_UTF8c2 To ucBOM[1]
        Move C_BOM_UTF8c3 To ucBOM[2]
        Write Channel iChannel ucBOM
      End  
    End
  End_Procedure

  // An application sends CMM_SAVEFILE to save the buffer contents to a specific file.
  // bClearUndo
  // If TRUE, the undo buffer is cleared if the file is successfully saved.
  // If FALSE, the undo buffer is untouched and the user can undo past the last file save operation.
  //CME_SUCCESS=1
  Function CM_SaveFile String szFileName Integer bClearUndo  Returns Integer
    Integer iBlockSize
    Integer iChannel
    Integer iPosition
    Integer iResult
    Pointer aTextData
    Integer iTextLength

    Send Cursor_Wait Of Cursor_Control
    If (pbNormalizeLineEndings(Self)) Begin
      Send EditorMessage SCI_CONVERTEOLS SC_EOL_CRLF
    End
    Move 0    To iPosition
    Move 1024 To iBlockSize
    Move True To bClearUndo // looks like this was ignored by codemax and always true
    Send EditorMessage SCI_SETREADONLY 1
    Get EditorMessage SCI_GETCHARACTERPOINTER to aTextData
    Move (CStringSize(aTextData)) to iTextLength
    If (iTextLength>=0) Begin

      Get Seq_New_Channel to iChannel
      If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
        Error DFERR_PROGRAM "No Channel Available for saving file"
        Send EditorMessage SCI_SETREADONLY 0
        Function_Return CME_FAILURE
      End

      Direct_Output Channel iChannel szFileName
      Send WriteBOM iChannel
      While ((iPosition+iBlockSize)<iTextLength)
        Send WriteBlock iChannel aTextData iPosition iBlockSize

        Move (iPosition+iBlockSize) To iPosition
      Loop
      If (iPosition<iTextLength) Begin
        Send WriteBlock iChannel aTextData iPosition (iTextLength-iPosition)
      End
      Close_Output Channel iChannel
      Send Seq_Release_Channel iChannel

      If (bClearUndo) Begin
        Send EditorMessage SCI_SETSAVEPOINT
      End

      Move CME_SUCCESS To iResult
    End
    Send EditorMessage SCI_SETREADONLY 0
    Send Cursor_Ready of Cursor_Control
    Function_Return iResult
  End_Function

  // This returns the number of lines in the document.
  // An empty document contains 1 line.
  // A document holding only an end of line sequence has 2 lines.
  Function SC_LineCount Returns Integer
    Integer iLineCount
    Get EditorMessage SCI_GETLINECOUNT to iLineCount
    Function_Return iLineCount
  End_Function

  // An application sends CMM_GETLINELENGTH to determine the length of a specific line in the edit buffer
  // nLine
  // The zero-based index of the line to retrieve the length of.
  // bLogical
  // TRUE to return the number of logical characters. FALSE to return the number of bytes (or double-bytes if Unicode version used).
  // SCI_LINELENGTH returns bytes, we ignore bLogical
  Function CM_GetLineLength Integer iLine Integer bLogical Returns Integer
    Integer iLineLength
    Integer iEOLPos
    Integer iStartPos
    // SCI_LINELENGTH also counts the EOL characters, not always handy
    //Get EditorMessage SCI_LINELENGTH iLine to iLineLength
    Get EditorMessage SCI_GETLINEENDPOSITION iLine to iEOLPos
    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iStartPos
    Move (iEOLPos-iStartPos) To iLineLength
    Function_Return iLineLength
  End_Function

  // An application sends CMM_GETLINE to retrieve the text on a specific line.
  // nLine - The zero-based line number of the line text to retrieve. nLine must be the index of a valid line number.
  // The number of lines in the buffer can be determined with CMM_GETLINECOUNT.
  // pszBuff - A pointer to a TCHAR buffer where to receive the line text.
  // The necessary buffer size can be determined by first sending CMM_GETLINELENGTH. pszBuff must not be NULL.
  Function CM_GetLine Integer iLine Returns String
    Integer iEOLPos
    Integer iStartPos
    Integer iLineLength
    Integer iRet
    String  sBuffer
    tSci_TextRange Sel

    // Can't use sci_linelength and sci_getline as we need the text without EOL characters
    //Get EditorMessage SCI_LINELENGTH iLine to iLineLength
    //Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) to iRet
    Move "" To sBuffer
    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iStartPos
    If (iStartPos>-1) Begin
      Get EditorMessage SCI_GETLINEENDPOSITION iLine to iEOLPos
      Move (iEOLPos-iStartPos) To iLineLength
      If (iLineLength<>0) Begin
        Move iStartPos To Sel.chrg.cpMin
        Move iEOLPos   To Sel.chrg.cpMax
        Move (ZeroString(iLineLength+1)) To sBuffer
        Move (AddressOf(sBuffer)) To Sel.lpstrText
        Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
        Move (CString(sBuffer)) to sBuffer
        If (pbUtf8Mode(Self)=False) Begin
          Get EditorFormatToUtf8 sBuffer to sBuffer
        End
      End
    End
    Function_Return sBuffer
  End_Function

  //
  // This gets the complete line including the EOL character(s) of that line
  // ** Rarely used as it does not convert the text to utf8 **
//  Function SC_GetLineNativeFormat Integer iLine Returns String
//    Integer iLineLength
//    Integer iRet
//    String  sLine
//    String  szText
//
//    Move "" to szText
//    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
//    Move (ZeroString(iLineLength)) to szText
//    Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) to iRet
//    Move (CString(szText)) to sLine
//    Function_Return sLine
//  End_Function

  //
  // This gets the complete line including the EOL character(s) of that line
  //
  Function SC_GetLine Integer iLine Returns String
    Integer iLineLength
    Integer iRet
    String  sLine
    String  szText

    Move "" to szText
    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
    Move (ZeroString(iLineLength)) To szText
    Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) To iRet
    Move (CString(szText)) To sLine
    If (pbUtf8Mode(Self)=False) Begin
      Get EditorFormatToUtf8 sLine to sLine
    End
    Function_Return sLine
  End_Function
  
  //
  // In our functions we always use utf8 as that's now DataFlex's native string format.
  // This means we have to convert text from/to utf8 if it isn't utf8 already.
  //
  Function Utf8ToEditorFormat String sText Returns String
    Boolean bIsUtf8
    Boolean bIsOem
    
    Get pbUtf8Mode      to bIsUtf8
    If (bIsUtf8=False) Begin
      Get pbOemMode to bIsOem
      If (bIsOem) Begin
        Move (Utf8ToOem(sText))  to sText
      End
      Else Begin
        Move (Utf8ToAnsi(sText)) to sText
      End
    End
    Function_Return sText
  End_Function
  
  Function EditorFormatToUtf8 String sText Returns String
    Boolean bIsUtf8
    Boolean bIsOem
    
    Get pbUtf8Mode      to bIsUtf8
    If (bIsUtf8=false) Begin  // DataFlex works with utf8 strings now, so use that in our functions to avoid 
                              // too much confusion.
      Get pbOemMode to bIsOem
      If (bIsOem) Begin
        Move (OemToUtf8(sText))  to sText
      End
      Else Begin
        Move (AnsiToUtf8(sText)) to sText
      End
    End  
    Function_Return sText
  End_Function
  

  //
  // An application sends CMM_GETWORDLENGTH to calculate the length of the word at a specific position in the buffer.
  // pPos
  // Pointer to a CM_POSITION structure that contains the buffer position of the word to be retrieved.
  // If NULL, the current caret position is used.
  // The hammer ONLY uses it internally in CM_GetWord, so we discard it and add it directly to
  // CM_GetWord.
  //Function CM_GetWordLength Integer pPos Integer bLogical Returns Integer
  //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETWORDLENGTH,  ( pPos ), ( bLogical ) ) )
  //End_Function

  // An application sends CMM_GETWORD to retrieve the word at a specific position in the buffer.
  Function CM_GetWord Integer iLine Integer iCol Returns String
    Integer iPos
    Integer iStartPos iEndPos
    Integer iRet iSize
    String  sBuffer
    tSci_TextRange Sel

    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
    Get EditorMessage SCI_WORDSTARTPOSITION iPos True to iStartPos
    Get EditorMessage SCI_WORDENDPOSITION   iPos True to iEndPos
    If (iStartPos>=0 and iStartPos<>iEndPos) Begin
      Move iStartPos To Sel.chrg.cpMin
      Move iEndPos   To Sel.chrg.cpMax
      Move ((iEndPos-iStartPos)+2) To iSize
      Move (ZeroString(iSize)) To sBuffer
      Move (AddressOf(sBuffer)) To Sel.lpstrText
      Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
      Move (CString(sBuffer)) To sBuffer
      If (pbUtf8Mode(Self)=False) Begin
        Get EditorFormatToUtf8 sBuffer to sBuffer
      End
    End
    Else Begin
      Move "" To sBuffer
    End
    Function_Return sBuffer
  End_Function
  // Gets the current word in a code max way.
  Function CM_GetCurrentWord Returns String
    String  sWord
    Integer iRet
    Get CM_GetSel False                                         to iRet
    Get CM_GetWord (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
    Function_Return sWord
  End_Function

  // Selfmade word getter, which doesnt stop the word on a "."
  // So its easy to use it for getting a file under cursor.
  Function CM_GetWordIncludingDot Integer iLine Integer iCol Returns String
    Integer iStart iEnd iLen iC
    String sLine
    Get value item iLine    to sLine
    Move (Length(sLine))    to iLen
    For iEnd from (iCol+1) to iLen
      If (Mid(sLine,1,iEnd)) Eq " " Break
    Loop
    For iC from 1 to iCol
      Move (iCol-iC+1)            to iStart
      If (Mid(sLine,1,iStart)) Eq " " Break
    Loop
    Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
  End_Function
  // Gets the current word under the cursor, but does not stop at a dot (.)
  // only a space character ends the word.
  Function CM_GetCurrentWordIncludingDot Returns String
    String  sWord
    Integer iRet
    Get CM_GetSel False                                         to iRet
    Get CM_GetWordIncludingDot (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
    Function_Return sWord
  End_Function

  //
  // Gets the whole variable as a word.
  //
  // Tried using CM_GetWordIncludingDot, but that function also includes () characters as part of the
  // word and that's a problem. We really only want the variable "as a word".
  //
  Function WordVariable Integer iLine Integer iPos Returns String
    Integer iWordCharLength
    Integer iVoid
    String  sDefaultWordChars // default characters that are part of a word
    String  sWordChars
    String  sWord

    Get EditorMessage SCI_GETWORDCHARS To iWordCharLength
    Move (ZeroString(iWordCharLength)) To sDefaultWordChars
    Get EditorMessage SCI_GETWORDCHARS 0 (AddressOf(sDefaultWordChars)) To iVoid
    Move (sDefaultWordChars+".") To sWordChars
    Send EditorMessage SCI_SETWORDCHARS 0 (AddressOf(sWordChars))
    Get CM_GetWord iLine iPos to sWord
    // restore default
    Send EditorMessage SCI_SETWORDCHARS 0 (AddressOf(sDefaultWordChars))
    Function_Return sWord
  End_Function

  // **WvA; Really, why? WHY is this here?
  //@RRS Selfmade word getter, which find the word from where the cursor is
  Function CM_GetWord3 Integer iLine Integer iCol Returns String
    Integer iStart iEnd iLen iC
    String sLine

    Get value item iLine    to sLine
    Move (Length(sLine))    to iLen

    Move iCol to iEnd
    For iC from 1 to iCol
      Move (iCol-iC+1) to iStart
      If (Mid(sLine,1,iStart)) Eq " " Break
    Loop
    Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
  End_Function


  // **WvA; Again, why? WHY is this here, what is wrong with GetCurrentWord itself?
  //@RRS Gets the current word in selfmade way.
  Function CM_GetCurrentWord3 Returns String
    String  sWord
    Integer iRet
    Get CM_GetSel False                                        to iRet
    Get CM_GetWord3 (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
    Function_Return sWord
  End_Function

  //@ RRS New Procedure Used by isReasonForFieldList
  Procedure AdjustFileNameCase String sNew
    String  sWord sTmp sLine
    Integer iRet iLine iCol iColStart
    Integer iStart iEnd iLen iC iPos iTmp

    Move (piSelEndLine(Self))  to iLine
    Move (piSelEndCol(Self))   to iCol

    Get value item iLine to sLine
    Move (Length(sLine)) to iLen

    For iEnd from iCol to iLen
      If (Mid(sLine,1,iEnd)) Eq " " Break
    Loop
    For iC from 1 to iCol
      Move (iCol-iC+1)            to iStart
      If (Mid(sLine,1,iStart)) Eq " " Break
    Loop
    Move sLine to sTmp
    Repeat
      Move (Pos(Uppercase(sNew),Uppercase(sTmp))) to iTmp
      If (iTmp) Begin
        Move (Remove(sTmp,1,iTmp)) to sTmp
        Move (iTmp+iPos) to iPos
      End
    Until ((iPos>=iStart) or (iTmp=0))
    //@if (iPos>=iStart) Move iPos to iStart
    If (iPos) ;
      Move iPos to iStart
    Move (Overstrike(sNew,sLine,iStart)) to sLine
    Send EditorMessage SCI_BEGINUNDOACTION
    Get CM_DeleteLine iLine to iRet
    Get CM_InsertLine iLine sLine to iRet
    Send EditorMessage SCI_ENDUNDOACTION
    // our selection just got removed, put back the cursor where we expect it
    Get CM_SetSel iLine iCol iLine iCol False to iRet
  End_Procedure


  // An application sends the CMM_ADDTEXT message to add the specified text to the end of the edit buffer.
  //
  Function CM_AddText String szText Returns Integer
    Boolean bIsUtf8
    Integer iLen
    
    Get pbUtf8Mode      to bIsUtf8
    If (bIsUtf8) Begin
      Move (SizeOfString(szText)) to iLen
    End
    Else Begin
      Move (Length(szText)) to iLen // length only works with utf8
      Get Utf8ToEditorFormat szText to szText
    End
    Send EditorMessage SCI_APPENDTEXT iLen (AddressOf(szText))
    Function_Return CME_SUCCESS
  End_Function

  //
  // An application sends CMM_DELETELINE to delete a line from the buffer.
  //
  Function CM_DeleteLine Integer iLine  Returns Integer
    Integer iCol
    Integer iStartPos
    Integer iLineLength
    Integer iRet

    Move 0 To iCol
    Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
    Get EditorMessage SCI_LINELENGTH  iLine                 to iLineLength
    Get EditorMessage SCI_DELETERANGE iStartPos iLinelength to iRet
    Function_Return CME_SUCCESS
  End_Function

  //
  // An application sends CMM_INSERTLINE to insert a line of text into the edit buffer.
  // iLine
  // The zero-based index of the line to insert before.
  // pszText
  // The text of the line to insert. This text should not contain any carriage returns or linefeeds.
  //
  Function CM_InsertLine Integer iLine String szText Returns Integer
    Integer iCol
    Integer iStartPos
    Integer iRet
    String  sEOLChar

    Move 0 To iCol
    Get psEOLChar to sEOLChar
    Move (CString(szText)+sEOLChar+Character(0)) To szText
    Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
    Get EditorMessage SCI_INSERTTEXT iStartPos  (AddressOf(sztext)) to iRet
    Function_Return CME_SUCCESS
  End_Function

  // Gets the active selection and fills it into the properties.
  // Normalized: True=StartPosition always before EndPosition
  // CMM_GETSEL
  Function CM_GetSel Integer bNormalized Returns Integer
    Integer iRet iLine iCol
    Integer iStartPos iEndPos

    // With Scintilla we ignore the bNormalized option as it returns the start position as
    // smaller anyways.
    Get EditorMessage SCI_GETSELECTIONSTART to iStartPos
    Get EditorMessage SCI_GETSELECTIONEND   to iEndPos

    Get EditorMessage SCI_LINEFROMPOSITION iStartPos to iLine
    Get EditorMessage SCI_GETCOLUMN        iStartPos to iCol
    Set piSelStartLine  to iLine
    Set piSelStartCol   to iCol
    If (iStartPos<>iEndPos) Begin
      Get EditorMessage SCI_LINEFROMPOSITION iEndPos   to iLine
      Get EditorMessage SCI_GETCOLUMN        iEndPos   to iCol
    End
    Set piSelEndLine  to iLine
    Set piSelEndCol   to iCol
    Move CME_SUCCESS To iRet
    Function_Return iRet
  End_Function

  //
  // This returns the current line for the current cursor position.
  // Beware that the first line is line 0 and not line 1.
  //
  Function CurrentLine Returns Integer
    Integer iPos
    Integer iLine

    Get EditorMessage SCI_GETCURRENTPOS To iPos
    Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
    Function_Return iLine
  End_Function

  Function CurrentColumn Returns Integer
    Integer iPos
    Integer iCol

    Get EditorMessage SCI_GETCURRENTPOS to iPos
    Get EditorMessage SCI_GETCOLUMN     iPos to iCol
    Function_Return iCol
  End_Function

  Function CursorPosition Returns Integer
    Integer iSel iY iX iRet
    Get CM_GetSel True to iSel
    Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
    Move (piPosEndY(Self))                                       to iY
    Move (piPosEndX(Self))                                       to iX

    Function_Return (MAKEWPARAM(iX, iY))
  End_Function

  // CMM_SETSEL
  // bMakeVisible
  // If TRUE, the selection will be scrolled into view. If FALSE, the window contents will not be scrolled.
  Function CM_SetSel Integer iStartLine Integer iStartCol Integer iEndLine Integer iEndCol  Integer bMakeVisible Returns Integer
    Integer iStartPos
    Integer iEndPos
    Integer iRet

    Get EditorMessage SCI_FINDCOLUMN iStartLine iStartCol to iStartPos
    Get EditorMessage SCI_FINDCOLUMN iEndLine   iEndCol   to iEndPos
    If (bMakeVisible) Begin
      Send EditorMessage SCI_SETSEL iStartPos iEndPos
    End
    Else Begin
      Send EditorMessage SCI_SETEMPTYSELECTION iEndPos  // set caret at end pos to start with and empty previous selections
      Send EditorMessage SCI_SETSELECTIONSTART iStartPos
      Send EditorMessage SCI_SETSELECTIONEND   iEndPos
    End

    Move CME_SUCCESS To iRet
    Function_Return iRet
  End_Function

  // An application sends CMM_DELETESEL to delete the currently selected text from the buffer.
  Function CM_DeleteSel Returns Integer
    Integer iRet
    Integer iStartPos iEndPos
    Integer iLength

    Move CME_FAILURE To iRet
    Get EditorMessage SCI_GETSELECTIONSTART to iStartPos
    Get EditorMessage SCI_GETSELECTIONEND   to iEndPos
    Move (iEndPos-iStartPos) To iLength
    If (iLength>0) Begin
      Send EditorMessage SCI_DELETERANGE iStartPos iLength
      Move CME_SUCCESS To iRet
    End
    Function_Return iRet
  End_Function

  // An application sends CMM_REPLACESEL to replace the current buffer selection with a body of text
  Function CM_ReplaceSel String szText  Returns Integer
    Move (szText+Character(0)) To szText
    Send EditorMessage SCI_REPLACESEL 0 (AddressOf(szText))
    Function_Return CME_SUCCESS
  End_Function

  //
  // ToDo: CM_ExecuteCmd
  //
  Function CM_ExecuteCmd Integer wCmd Integer dwCmdData Returns Integer
    Integer iSCICmd
    Integer iLine
    Integer iVoid

    Move 0 To iSCICmd
    Case Begin
      Case (wCmd=CMD_SELECTLINE)
        Get piSelEndLine to iLine
        Get CM_SelectLine iLine True to iVoid
        Case Break
      Case (wCmd=CMD_LINEDELETE)
        Get piSelEndLine to iLine
        Get CM_DeleteLine iLine to iVoid
        Case Break
      Case (wCmd=CMD_Find)
        Send Find
        Case Break
      Case (wCmd=CMD_FindNext)
        Send FindNext
        Case Break
      Case (wCmd=CMD_FINDPREV)
        Send FindPrevious
        Case Break
      Case (wCmd=CMD_FindReplace)
        // ToDo: CMD_FindReplace
        Case Break
      Case (wCmd=CMD_UPPERCASESELECTION)
        Send SC_UppercaseSelection
        Case Break
      Case (wCmd=CMD_LOWERCASESELECTION)
        Send SC_LowercaseSelection
        Case Break
      Case (wCmd=CMD_BOOKMARKTOGGLE)
        Send BookmarkToggle
        Case Break
      Case (wCmd=CMD_BOOKMARKCLEARALL)
        Send BookmarkClearAll
        Case Break
      Case (wCmd=CMD_BOOKMARKJUMPTOFIRST)
        Send BookmarkJumpToFirst
        Case Break
      Case (wCmd=CMD_BOOKMARKJUMPTOLAST)
        Send BookmarkJumpToLast
        Case Break
      Case (wCmd=CMD_BOOKMARKNEXT)
        Send BookmarkNext
        Case Break
      Case (wCmd=CMD_BOOKMARKPREV)
        Send BookmarkPrevious
        Case Break
      Case (wCmd=CMD_GOTOINDENTATION)
        Case Break
      Case (wCmd=CMD_GOTOMATCHBRACE)
        Send GotomatchBrace
        Case Break
      Case (wCmd=CMD_RECORDMACRO)
        Case Break
      Case (wCmd=CMD_PLAYMACRO1)
        Case Break
      Case (wCmd=CMD_PLAYMACRO2)
        Case Break
      Case (wCmd=CMD_PLAYMACRO3)
        Case Break
      Case (wCmd=CMD_PLAYMACRO4)
        Case Break
      Case (wCmd=CMD_PLAYMACRO5)
        Case Break
      Case (wCmd=CMD_PLAYMACRO6)
        Case Break
      Case (wCmd=CMD_PLAYMACRO7)
        Case Break
      Case (wCmd=CMD_PLAYMACRO8)
        Case Break
      Case (wCmd=CMD_PLAYMACRO9)
        Case Break
      Case (wCmd=CMD_PLAYMACRO10)
        Case Break
      Case (wCmd=CMD_CODETIP)
        Get Msg_DoCodeTip to iVoid
        Case Break
      Case (wCmd=CMD_CODELIST)
        Get Msg_DoCodeList 0 to iVoid
        Case Break
    Case End
    If (iSCICmd) Begin
      Send EditorMessage iSCICmd
    End
    //  Function_Return (SendMessage(Window_Handle(Self), CMM_EXECUTECMD,  ( wCmd ), ( dwCmdData ) ) )
    Function_Return CME_SUCCESS
  End_Function

  //
  // ToDo: Currently no support for splitter screen
  //
  //    Function CM_SetSplitterPos Integer bHorz  Integer nPos Returns Integer
  //        Function_Return (SendMessage(Window_Handle(Self), CMM_SETSPLITTERPOS,  ( bHorz ), ( nPos ) ) )
  //    End_Function
  //    Function CM_GetSplitterPos Integer bHorz Returns Integer
  //        Function_Return (SendMessage(Window_Handle(Self), CMM_GETSPLITTERPOS,  ( bHorz ), 0 ) )
  //    End_Function

  //
  // An application sends CMM_SETAUTOINDENTMODE to set the current auto-indent mode.
  // The auto-indent mode determines how a new line is indented when ENTER is pressed
  //
  Function CM_SetAutoIndentMode Integer eMode Returns Integer
    If (eMode=CM_INDENT_SCOPE) Begin
      Move CM_INDENT_PREVLINE to eMode
    End
    Set peAutoIndentMode to eMode
    Function_Return CME_SUCCESS
  End_Function
  //
  // CMM_GETAUTOINDENTMODE
  // An application sends CMM_GETAUTOINDENTMODE to determine the current auto-indent mode. The auto-indent mode determines how
  // a new line is indented when ENTER is pressed.
  //
  // CM_INDENT_OFF - No indentation occurs. The next line begins at column zero (0).
  // CM_INDENT_SCOPE - Language-specific scoping is used to determine the correct indentation level for the next line.
  //                   This setting parses the buffer contents, looking backward for scope keywords until the start of
  //                   the current scope is encountered. Once found, the indentation is copied to the next line.
  //                   If no language is set, CM_INDENT_PREVLINE is used.
  // CM_INDENT_PREVLINE - Indentation is copied from the previous line.
  // The default setting is CM_INDENT_PREVLINE.
  // CM_INDENT_SCOPE is not supported for Scintilla now
  Function CM_GetAutoIndentMode Returns Integer
    Integer eMode

    Get peAutoIndentMode to eMode
    Function_Return eMode
  End_Function
  Function CM_CanUndo Returns Integer
    Integer iRet
    Get EditorMessage SCI_CANUNDO to iRet
    Function_Return iRet
  End_Function
  Function CM_CanRedo Returns Integer
    Integer iRet
    Get EditorMessage SCI_CANREDO to iRet
    Function_Return iRet
  End_Function
  Function CM_Redo Returns Integer
    Integer iRet
    Get EditorMessage SCI_REDO to iRet
    Function_Return iRet
  End_Function
  Function CM_Undo Returns Integer
    Integer iRet
    Get EditorMessage SCI_UNDO to iRet
    Function_Return iRet
  End_Function
  Function CM_ClearUndoBuffer Returns Integer
    Integer iRet
    // This command tells Scintilla to forget any saved undo or redo history.
    // It also sets the save point to the start of the undo buffer, so the document will appear to be unmodified.
    Get EditorMessage SCI_EMPTYUNDOBUFFER to iRet
    Function_Return iRet
  End_Function
  Function CM_CanCut Returns Integer
    Integer iRet
    Get EditorMessage SCI_GETSELECTIONEMPTY to iRet
    Function_Return (iRet=0)
  End_Function
  Function CM_CanCopy Returns Integer
    Integer iRet
    Get EditorMessage SCI_GETSELECTIONEMPTY to iRet
    Function_Return (iRet=0)
  End_Function
  Function CM_CanPaste Returns Integer
    Integer iRet
    Get EditorMessage SCI_CANPASTE to iRet
    Function_Return iRet
  End_Function
  Function CM_Cut Returns Integer
    Integer iRet
    Send OnBeforeCut
    Get EditorMessage SCI_CUT to iRet
    Send OnAfterCut
    Function_Return iRet
  End_Function
  Function CM_Copy Returns Integer
    Integer iRet
    Get EditorMessage SCI_COPY to iRet
    Function_Return iRet
  End_Function
  Function CM_Paste Returns Integer
    Integer iRet
    Send OnBeforePaste
    Get EditorMessage SCI_PASTE to iRet
    Send OnAfterPaste
    Function_Return iRet
  End_Function
  Function CM_IsRecordingMacro Returns Integer
    // Not sure if the function is for starting to record.
    //Integer iRet
    //Get EditorMessage SCI_STARTRECORD to iRet
    //Function_Return iRet
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISRECORDINGMACRO, 0, 0 ) )
  End_Function
  Function CM_IsPlayingMacro Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPLAYINGMACRO, 0, 0 ) )
  End_Function
  //
  // There is no undo limit in scintilla, the amount of free memory is the limit.
  //
  //    Function CM_SetUndoLimit Integer nLimit Returns Integer
  //    Function CM_GetUndoLimit Returns Integer

  Procedure ToggleLineChanged
    Integer iLine

    Get Current_Line to iLine
    Send LineChangedMark iLine
  End_Procedure

  Function CM_IsModified Returns Integer
    Integer iRet
    Get EditorMessage SCI_GETMODIFY to iRet
    Function_Return iRet
  End_Function
  //
  // Does not seem to exist in Scintilla
  //
  //    Function CM_SetModified Integer bModified Returns Integer

  Function CM_EnableOvertype Integer bEnable Returns Integer
    Integer iRet
    Get EditorMessage SCI_SETOVERTYPE bEnable to iRet
    Function_Return iRet
  End_Function
  Function CM_IsOvertypeEnabled Returns Integer
    Integer iRet
    Get EditorMessage SCI_GETOVERTYPE to iRet
    Function_Return iRet
  End_Function
  Function CM_EnableCaseSensitive Integer bEnable Returns Integer
    Integer iFlags
    Integer iRet
    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    If (bEnable) Begin
      //
      Move (iFlags iOr SCFIND_MATCHCASE) To iFlags
    End
    Else Begin
      Move (iFlags iAnd (iNot(SCFIND_MATCHCASE))) To iFlags
    End
    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet
    Function_Return iRet
  End_Function
  Function CM_IsCaseSensitiveEnabled Returns Integer
    Integer iFlags
    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    Move (iFlags iAnd SCFIND_MATCHCASE) To iFlags
    Function_Return (iFlags<>0)
  End_Function

  // Weird codemax feature, not in scintilla
  // If TRUE, subsequent Find/Replace operations will format the Replace text such that it follows
  // the same case pattern of the Find text:
  //Function CM_EnablePreserveCase Integer bEnable Returns Integer
  //    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEPRESERVECASE,  ( bEnable ), 0 ) )
  //End_Function
  //Function CM_IsPreserveCaseEnabled Returns Integer
  //    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPRESERVECASEENABLED, 0, 0 ) )
  //End_Function

  // An application sends CMM_ENABLEWHOLEWORD to enable or disable whole word searching during a find or find and replace operation
  Function CM_EnableWholeWord Integer bEnable Returns Integer
    Integer iFlags
    Integer iRet
    //
    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    If (bEnable) Begin
      //
      Move (iFlags iOr SCFIND_WHOLEWORD) To iFlags
    End
    Else Begin
      Move (iFlags iAnd (iNot(SCFIND_WHOLEWORD))) To iFlags
    End
    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet
    Function_Return iRet
  End_Function
  Function CM_IsWholeWordEnabled Returns Integer
    Integer iFlags
    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    Move (iFlags iAnd SCFIND_WHOLEWORD) To iFlags
    Function_Return (iFlags<>0)
  End_Function


  Function CM_EnableRegExp Integer bEnable Returns Integer
    Integer iFlags
    Integer iRet
    //
    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    If (bEnable) Begin
      //
      Move (iFlags iOr SCFIND_REGEXP) To iFlags
    End
    Else Begin
      Move (iFlags iAnd (iNot(SCFIND_REGEXP))) To iFlags
    End
    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet // CMM_ENABLEREGEXP
    Function_Return iRet
  End_Function

  Function CM_IsRegExpEnabled Returns Integer
    Integer iFlags
    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags // CMM_ISREGEXPENABLED
    Move (iFlags iAnd SCFIND_REGEXP) To iFlags
    Function_Return (iFlags<>0)
  End_Function

  // An application sends CMM_SETTOPINDEX to set the topmost visible line in a specific view.
  // This might be the same as SCI_SETFIRSTVISIBLELINE(int displayLine) but not completely clear to me now.
  //Function CM_SetTopIndex Integer nView Integer nLine Returns Integer
  //    Function_Return (SendMessage(Window_Handle(Self), CMM_SETTOPINDEX,  ( nView ), ( nLine ) ) )
  //End_Function
  //Function CM_GetTopIndex Integer nView Returns Integer
  //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETTOPINDEX,  ( nView ), 0 ) )
  //End_Function

  // SCI_LINESONSCREEN
  Function CM_GetVisibleLineCount Integer nView Integer bFullyVisible Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETVISIBLELINECOUNT,  ( nView ), ( bFullyVisible ) ) )
  End_Function

  // An application sends CMM_ENABLECRLF to enable or disable the inclusion of carriage returns when
  // multiple lines of text are retrieved from the edit buffer
  // bEnable - If TRUE, multiple lines of text retrieved from the edit buffer are delimited by a
  //  carriage return (\r) and a linefeed (\n). If FALSE, lines are delimited by only a linefeed (\n).
  //  The default setting is TRUE.
  Function CM_EnableCRLF Integer bEnable Returns Integer
    Integer eMode

    If (bEnable) Begin
      Move SC_EOL_CRLF to eMode
      Set psEOLChar    to CS_CRLF
    End
    Else Begin
      Move SC_EOL_LF   To eMode
      Set psEOLChar    to CS_LF
    End
    Send EditorMessage SCI_SETEOLMODE eMode
    Function_Return CME_SUCCESS
  End_Function

  // The return value is TRUE if multiple lines of text retrieved from the edit buffer are delimited by
  // a carriage return (\r) and a linefeed (\n). The return value is FALSE if lines are delimited by
  // only a linefeed (\n). The default setting is TRUE.
  Function CM_IsCRLFEnabled Returns Boolean
    Integer eMode
    Boolean bEnabled
    Move False to bEnabled
    Get EditorMessage SCI_GETEOLMODE to eMode
    If (eMode=SC_EOL_CRLF) Begin
      Move True to bEnabled
    End
    Function_Return True
  End_Function

  Function CM_GetCurrentView Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTVIEW, 0, 0 ) )
  End_Function
  // SVN
  Function CM_SetCurrentView Integer nLine Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_SETCURRENTVIEW, nLine, 0 ) )
  End_Function
  // SVN
  Function CM_GetViewCount Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETVIEWCOUNT, 0, 0 ) )
  End_Function
  Function CM_ShowScrollBar Integer bHorz  Integer bShow Returns Integer
    Integer iRet
    If (bHorz) Begin
      Send EditorMessage SCI_SETHSCROLLBAR bShow
    End
    Else Begin
      Send EditorMessage SCI_SETVSCROLLBAR bShow
    End
    Function_Return iRet
  End_Function
  Function CM_HasScrollBar Integer bHorz Returns Integer
    Integer iRet
    If (bHorz) Begin
      Get EditorMessage SCI_GETHSCROLLBAR to iRet
    End
    Else Begin
      Get EditorMessage SCI_GETVSCROLLBAR to iRet
    End
    Function_Return iRet
  End_Function

  Function CM_GetSelFromPoint Integer xClient Integer yClient Returns Integer
    Integer iLine iCol
    Integer iPos

    Get EditorMessage SCI_POSITIONFROMPOINT xClient yClient to iPos
    If (iPos>-1) Begin
      Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
      Get EditorMessage SCI_GETCOLUMN        iPos to iCol

      Set piSelStartLine                              to iLine
      Set piSelStartCol                               to iCol
      Set piSelEndLine                                to iLine
      Set piSelEndCol                                 to iCol
    End
    Function_Return iPos
  End_Function

  Procedure SC_LineCut
    Send EditorMessage SCI_LINECUT
  End_Procedure

  Procedure SC_UppercaseSelection
    Send EditorMessage SCI_UPPERCASE
  End_Procedure

  Procedure SC_LowercaseSelection
    Send EditorMessage SCI_LOWERCASE
  End_Procedure

  // An application sends CMM_SELECTLINE to select a line of text in the edit buffer
  // bMakeVisible
  // If TRUE, the line will be scrolled into view if necessary. If FALSE, the line will never be scrolled.
  //
  Function CM_SelectLine Integer iLine Integer bMakeVisible Returns Integer
    Integer iAnchor
    Integer iCaret
    Integer iRet

    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iAnchor
    Get EditorMessage SCI_GETLINEENDPOSITION iline to iCaret
    If (bMakeVisible) Begin
      Get EditorMessage SCI_SETSEL iAnchor iCaret to iRet
    End
    Else Begin
      Send EditorMessage SCI_SETSELECTIONSTART iAnchor
      Send EditorMessage SCI_SETSELECTIONEND   iCaret
    End
    Function_Return CME_SUCCESS
  End_Function
  Function CM_HitTest Integer xClient Integer yClient Returns Integer
    Integer iPos
    Integer iRet

    Move CM_NOWHERE to iRet
    Get EditorMessage SCI_CHARPOSITIONFROMPOINT xClient yClient to iPos
    If (iPos>-1) Begin
      Move CM_EDITSPACE To iRet
    End
    Function_Return (65536*iRet)
  End_Function
  Function CM_EnableDragDrop Integer bEnable Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEDRAGDROP,  ( bEnable ), 0 ) )
  End_Function
  Function CM_IsDragDropEnabled Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISDRAGDROPENABLED, 0, 0 ) )
  End_Function

  //
  // ToDo: Currently no support for splitter screen
  //
  //    Function CM_EnableSplitter Integer bHorz Integer bEnable Returns Integer
  //        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESPLITTER,  ( bHorz ), ( bEnable ) ) )
  //    End_Function
  //    Function CM_IsSplitterEnabled Integer bHorz Returns Integer
  //        Function_Return (SendMessage(Window_Handle(Self), CMM_ISSPLITTERENABLED,  ( bHorz ), 0 ) )
  //    End_Function
  Function CM_EnableColumnSel Integer bEnable Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLUMNSEL,  ( bEnable ), 0 ) )
  End_Function
  Function CM_IsColumnSelEnabled Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLUMNSELENABLED, 0, 0 ) )
  End_Function
  Function CM_EnableGlobalProps Integer bEnable Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEGLOBALPROPS,  ( bEnable ), 0 ) )
  End_Function
  Function CM_IsGlobalPropsEnabled Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISGLOBALPROPSENABLED, 0, 0 ) )
  End_Function
  Function CM_SetDlgParent Integer hWndParent Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_SETDLGPARENT,  ( hWndParent ), 0 ) )
  End_Function
  Function CM_EnableSelBounds Integer bEnable Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESELBOUNDS,  ( bEnable ), 0 ) )
  End_Function
  Function CM_IsSelBoundsEnabled Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISSELBOUNDSENABLED, 0, 0 ) )
  End_Function

  Function CM_SetLineStyle Integer nLine Integer dwStyle Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_SETLINESTYLE,  ( nLine ), ( dwStyle ) ) )
  End_Function
  Function CM_GetLineStyle Integer nLine Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETLINESTYLE,  ( nLine ), 0 ) )
  End_Function
  Procedure LineChangedMark Integer iLine
    Boolean  bChanged
    Handle   hMarkers
    Handle   hChangedMark

    Get EditorMessage SCI_MARKERGET iLine to hMarkers
    If ((hMarkers iAnd SC_MASK_CHANGEDLINEUNSAVED)=0) Begin
      Get CM_IsModified to bChanged
      If (bChanged) Begin
        If (hMarkers iAnd SC_MASK_CHANGEDLINE) Begin
          // There is a saved change line marker. We have to remove it or we won't see our current changed line mark
          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINESAVED
        End
        Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_CHANGEDLINE to hChangedMark
      End
    End
    Else Begin  // if the line has marker we need to check if the user brought the line back to original state so
      // that we can remove the line. This code needs to be fast, so we start by comparing length.
      If (Length(CM_GetLine(Self,iLine))=Length(psLineOnEnter(Self))) Begin
        If (CM_GetLine(Self,iLine)=psLineOnEnter(Self)) Begin // again we want speed, so don't copy to local variables
          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
        End
      End
    End
  End_Procedure

  //
  // Enumerates through all of the Changed Line markers in the document and sets them as saved
  // changed line markers
  //
  Procedure MarkChangedLinesAsSaved
    Integer iLine
    Handle  hMark

    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_CHANGEDLINEUNSAVED to iLine
    While (iLine>-1)
      Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
      Get  EditorMessage SCI_MARKERADD    iLine SC_MARKNUM_CHANGEDLINESAVED   to hMark
      Get  EditorMessage SCI_MARKERNEXT  (iLine+1) SC_MASK_CHANGEDLINEUNSAVED to iLine
    Loop
  End_Procedure

  Function CM_SetBookmark Integer nLine Integer bEnable Returns Integer
    Handle   hMarkers
    Handle   hBookMark

    Get EditorMessage SCI_MARKERGET nLine to hMarkers
    If (bEnable) Begin
      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)=false) Begin
        Get EditorMessage SCI_MARKERADD nLine SC_MARKNUM_BOOKMARK to hBookMark
      End
    End
    Else Begin
      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
        Send EditorMessage SCI_MARKERDELETE nLine SC_MARKNUM_BOOKMARK
      End
    End
    Function_Return CME_SUCCESS
  End_Function
  Function CM_GetBookmark Integer nLine Returns Integer
    Boolean bHasBookMark
    Handle hMarkers

    Move False to bHasBookMark
    Get EditorMessage SCI_MARKERGET nLine to hMarkers
    If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
      Move True To bHasBookMark
    End
    Function_Return bHasBookMark
  End_Function

  Procedure BookmarkToggle
    Boolean bHasBookmark
    Integer iLine
    Integer iVoid

    Get Current_Line to iLine
    If (iLine>-1) Begin
      Get CM_GetBookmark iLine to bHasBookmark
      Get CM_SetBookmark iLine (not(bHasBookmark)) to iVoid
    End
  End_Procedure

  Procedure BookmarkNext
    Integer iLine
    Integer iLineStart
    Get Current_Line to iLineStart
    Get EditorMessage SCI_MARKERNEXT (iLineStart+1) SC_MASK_BOOKMARK to iLine
    If (iLine>-1) Begin
      Send EditorMessage SCI_GOTOLINE iLine
    End
  End_Procedure

  Procedure BookmarkPrevious
    Integer iLine
    Integer iLineStart
    Get Current_Line to iLineStart
    Get EditorMessage SCI_MARKERPREVIOUS (iLineStart-1) SC_MASK_BOOKMARK to iLine
    If (iLine>-1) Begin
      Send EditorMessage SCI_GOTOLINE iLine
    End
  End_Procedure

  Procedure BookmarkJumpToFirst
    Integer iLine
    Integer iLineStart

    Move 0 to iLineStart
    Get EditorMessage SCI_MARKERNEXT iLineStart SC_MASK_BOOKMARK to iLine
    If (iLine>-1) Begin
      Send EditorMessage SCI_GOTOLINE iLine
    End
  End_Procedure

  Procedure BookmarkJumpToLast
    Integer iLine
    Integer iLineStart

    Get SC_LineCount to iLineStart
    Get EditorMessage SCI_MARKERPREVIOUS iLineStart SC_MASK_BOOKMARK to iLine
    If (iLine>-1) Begin
      Send EditorMessage SCI_GOTOLINE iLine
    End
  End_Procedure

  Procedure BookmarkClearAll
    Integer iLine
    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
    While (iLine>-1)
      Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_BOOKMARK
      Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
    Loop
  End_Procedure

  Function CM_SetAllBookmarks Integer iCountNotUsed String sData Returns Integer
    Integer   iCount
    Integer   iItem
    Integer   iLine
    Integer   iVoid
    Integer[] Bookmarks

    Move (ConvertAsciiToIntegerArray(sData)) To Bookmarks
    Move (SizeOfArray(Bookmarks)) To iCount
    If (iCount>0) Begin
      For iItem From 0 To (iCount-1)
        Move Bookmarks[iItem] To iLine
        If (iLine>0) Begin
          Get CM_SetBookmark iLine True to iVoid
        End
      Loop
    End
    Function_Return CME_SUCCESS
  End_Function

  Function SC_AllBookmarksToIntegerArray Returns Integer[]
    Integer iLine
    Integer[] Bookmarks

    Move (ResizeArray(Bookmarks,0)) To Bookmarks
    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
    While (iLine>-1)
      Move iLine To Bookmarks[SizeOfArray(Bookmarks)]
      Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
    Loop
    Function_Return Bookmarks
  End_Function

  Function CM_GetAllBookmarks Returns String
    String sData
    Integer[] Bookmarks

    Get SC_AllBookmarksToIntegerArray to Bookmarks
    Get ConvertIntegerArrayToAscii Bookmarks to sData
    Function_Return sData
  End_Function

  //
  // We're only offering On/Off, the iStart and iMode options are ignored.
  //
  Function CM_SetLineNumbering Integer bEnable Integer iStart Integer iMode Returns Integer
    Integer iMarginWidth
    Integer iDigits
    Integer iLineCount
    String  sMaxLine

    If (bEnable) Begin
      // figure out the width we need based on max line count
      Get SC_LineCount to iLineCount
      If (iLineCount>999) Begin
        Move (Length(Trim(iLineCount))) To iDigits
        Move ("_"+repeat("9",iDigits)+Character(0)) To sMaxLine
      End
      Else Begin  // so if it is called at that time then hardwire a fixed width
        Move 3 To iDigits // we don't count the "_" offset, this is our default, we don't get lower as 3
        Move ("_999"+Character(0)) To sMaxLine
      End
      Set piMarginLineNumberDigits to iDigits
      Get EditorMessage SCI_TEXTWIDTH STYLE_LINENUMBER (AddressOf(sMaxLine)) to iMarginWidth
      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS iMarginWidth
      Send EditorMessage SCI_SETMARGINMASKN  MARGIN_LINE_NUMBERS SC_MASK_MARGIN
    End
    Else Begin
      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS 0
    End
    Function_Return CME_SUCCESS
  End_Function
  //
  // Returns 0 if not enabled or CM_DECIMAL if it is
  //
  Function CM_GetLineNumbering Returns Integer
    Integer iRet iWidth

    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS to iWidth
    If (iWidth>0) Begin
      Move CM_DECIMAL To iRet
    End
    Else Begin
      Move 0 To iRet
    End
    Function_Return iRet
  End_Function
  Function CM_PosFromChar Integer iLine Integer iCol Returns Integer
    Integer iX iY iPos
    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
    Get EditorMessage SCI_POINTXFROMPOSITION 0 iPos to iX
    Get EditorMessage SCI_POINTYFROMPOSITION 0 iPos to iY
    Set piPosStartX                     to iX
    Set piPosStartY                     to iY
    Set piPosEndX                       to iX
    Set piPosEndY                       to iY
    Function_Return CME_SUCCESS
  End_Function
  Function CM_EnableHideSel Integer bEnable Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEHIDESEL,  ( bEnable ), 0 ) )
  End_Function
  Function CM_IsHideSelEnabled Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_ISHIDESELENABLED, 0, 0 ) )
  End_Function

  //
  // If a line is already highlighted then this will remove the highlight
  //
  Procedure ResetHighlightedLine
    Handle  hMarker
    Integer iLine
    // Is there already a highlighted line? If so first delete the highlight on that line
    Get phMarkerLineHighLight to hMarker
    If (hMarker<>0) Begin
      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
      If (iLine>-1) Begin
        Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_LINEHIGHLIGHT
      End
      Set phMarkerLineHighLight to 0
    End
  End_Procedure

  Function CM_SetHighlightedLine Integer iLine Returns Integer
    Handle  hMarker

    If (iLine>0) Begin
      Send ResetHighlightedLine
      Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_LINEHIGHLIGHT to hMarker
      Set phMarkerLineHighLight to hMarker
    End
    Function_Return CME_SUCCESS
  End_Function
  //
  // An application sends CMM_GETHIGHLIGHTEDLINE to retrieve the index of the currently highlighted line.
  // The highlighted line can be used for marking the currently executing line when used in a debugger
  // application
  // Return Values
  // The zero-based index of the line that is currently highlighted.
  // If no line is highlighted, the return value is -1.
  Function CM_GetHighlightedLine Returns Integer
    Handle  hMarker
    Integer iLine

    Move -1 To iLine
    Get phMarkerLineHighLight to hMarker
    If (hMarker<>0) Begin
      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
    End
    Function_Return iLine
  End_Function
  Function CM_EnableNormalizeCase Integer bEnable Returns Integer
    Set pbNormalizeCase to bEnable
    Function_Return CME_SUCCESS
  End_Function
  Function CM_IsNormalizeCaseEnabled Returns Integer
    Boolean bNormalized
    Get pbNormalizeCase to bNormalized
    Function_Return bNormalized
  End_Function
  Function CM_SetDivider Integer nLine Integer bEnable Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_SETDIVIDER,  ( nLine ), ( bEnable ) ) )
  End_Function
  Function CM_GetDivider Integer nLine Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETDIVIDER,  ( nLine ), 0 ) )
  End_Function

  //
  // An application sends CMM_ENABLEOVERTYPECARET to control the size of the text caret when in overtype mode.
  Function CM_EnableOvertypeCaret Integer bEnable Returns Integer
    Integer iRet
    Integer eCaretStyle
    //
    If (bEnable) Begin
      Move CARETSTYLE_BLOCK To eCaretStyle
    End
    Else Begin
      Move CARETSTYLE_LINE  To eCaretStyle
    End
    Get EditorMessage SCI_SETCARETSTYLE eCaretStyle to iRet
    Function_Return iRet
  End_Function
  Function CM_IsOvertypeCaretEnabled Returns Integer
    Boolean bEnabled
    Integer eCaretStyle
    //
    Move False to bEnabled
    Get EditorMessage SCI_SETCARETSTYLE to eCaretStyle  // CMM_ISOVERTYPECARETENABLED
    If (eCaretStyle=CARETSTYLE_BLOCK) Begin
      Move True To bEnabled
    End
    Function_Return bEnabled
  End_Function
  // An application sends CMM_SETFINDTEXT to change the text used in the most current search operation.
  Function CM_SetFindText String szText  Returns Integer
    Move (CString(szText)) To szText
    Set psSearchText to szText
    Function_Return CME_SUCCESS
  End_Function
  Function CM_GetFindText Returns String
    String szText
    Get psSearchText to szText
    Move (szText+Character(0)) to szText // check if it makes sense to make this a zero terminated string
    Function_Return szText
  End_Function

  Function CM_Print Handle hDC Integer dwFlags Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_PRINT,  ( hDC ), ( dwFlags ) ) )
  End_Function
  Function CM_SetCaretPos Integer nLine Integer nCol Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_SETCARETPOS,  ( nLine ), ( nCol ) ) )
  End_Function
  Function CM_ViewColToBufferCol Integer nLine Integer nViewCol  Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_VIEWCOLTOBUFFERCOL,  ( nLine ), ( nViewCol ) ) )
  End_Function
  Function CM_BufferColToViewCol Integer nLine Integer nBufferCol Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_BUFFERCOLTOVIEWCOL,  ( nLine ), ( nBufferCol ) ) )
  End_Function
  Function CM_SetBorderStyle Integer dwStyle Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_SETBORDERSTYLE,  ( dwStyle ), 0 ) )
  End_Function
  Function CM_GetBorderStyle Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETBORDERSTYLE, 0, 0 ) )
  End_Function
  // SVN
  Function CM_GetCurrentToken Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTTOKEN, 0, 0 ) )
  End_Function
  Function CM_UpdateControlPositions Returns Integer
    Function_Return (SendMessage(Window_Handle(Self), CMM_UPDATECONTROLPOSITIONS, 0, 0 ) )
  End_Function
  // SVN

  //_ADDITION_METHODS_for_an_easier_use.._________________


  // ToDo: Out of Scope - Splitting window support in scintilla is not as natural. It can be done
  // but for the moment I consider it out of scope. The documentation has this to say about it:
  //
  // The system is arranged in this way so that you can work with many documents in a single Scintilla
  // window and so you can display a single document in multiple windows (for use with splitter windows).
  //
  //        // Tiling windows...
  //    Procedure SplitWindowHorizontal
  //        Integer iRet iPos
  //        Move (CM_GetSplitterPos(Self,True))         to iPos
  //        If iPos Eq 0 Move (Low(GuiSize(Self)))      to iPos
  //        Else         Move 0                         to iPos
  //        Move (iPos/2)                               to iPos
  //        Move (CM_SetSplitterPos(Self,True,iPos))    to iRet
  //    End_Procedure
  //    Function isSplittedHorizonztal Returns Integer
  //        Function_Return (CM_GetSplitterPos(Self,True) Ne 0)
  //    End_Function
  //    Procedure SplitWindowVertical
  //        Integer iRet iPos
  //        Move (CM_GetSplitterPos(Self,False))        to iPos
  //        If iPos Eq 0 Move (Hi(GuiSize(Self)))       to iPos
  //        Else         Move 0                         to iPos
  //        Move (iPos/2)                               to iPos
  //        Move (CM_SetSplitterPos(Self,False,iPos))   to iRet
  //    End_Procedure
  //    Function isSplittedVertical Returns Integer
  //        Function_Return (CM_GetSplitterPos(Self,False) Ne 0)
  //    End_Function
  //        // Is a special usage for the splitter window.
  //        // gren werden immer angepasst!
  //    Procedure DuplicateWindow
  //        If not (isSplittedHorizonztal(Self))     Send SplitWindowHorizontal
  //        Else If not (isSplittedVertical(Self))   Send SplitWindowVertical
  //    End_Procedure
  //        // If all 4 sub windows are used. no more is possible.
  //    Function isDuplicatePossible Returns Integer
  //        If (isSplittedHorizonztal(Self)) If (isSplittedVertical(Self)) Function_Return 0
  //        Function_Return 1
  //    End_Function
  //        // Check if some of the splitters are set.
  //    Function isWindowDuplicated Returns Integer
  //        If (isSplittedHorizonztal(Self)) Function_Return 1
  //        If (isSplittedVertical(Self))    Function_Return 1
  //        Function_Return 0
  //    End_Function

  // Removes all Splitter windows and
  Procedure CloseWindow
    //        If (isSplittedVertical(Self))           Send SplitWindowVertical
    //        Else If (isSplittedHorizonztal(Self))   Send SplitWindowHorizontal
  End_Procedure
  // Select All
  Procedure SelectAll
    Send EditorMessage SCI_SELECTALL
  End_Procedure

  // Select this line...
  Procedure SelectLine
    Integer iRet
    Get CM_ExecuteCmd CMD_SELECTLINE 0 to iRet
  End_Procedure
  // Deletes this line...
  Procedure DeleteLine
    Integer iRet
    Get CM_ExecuteCmd CMD_LINEDELETE 0 to iRet
  End_Procedure



  Procedure MoveLineUp
    Send EditorMessage SCI_MOVESELECTEDLINESUP
  End_Procedure

  Procedure MoveLineDown
    Send EditorMessage SCI_MOVESELECTEDLINESDOWN
  End_Procedure

  Procedure DuplicateSelection
    Send EditorMessage SCI_SELECTIONDUPLICATE
  End_Procedure

  Function SetSearchOptions tFindReplaceOptions FindOptions Returns Integer
    Integer iFlags

    Move 0 to iFlags
    Move (If(FindOptions.bWordMatch,iFlags iOr SCFIND_WHOLEWORD,iFlags)) To iFlags
    Move (If(FindOptions.bMatchCase,iFlags iOr SCFIND_MATCHCASE,iFlags)) To iFlags
    Move (If(FindOptions.bRegExp   ,iFlags iOr SCFIND_REGEXP   ,iFlags)) To iFlags
    Set pbFindDocumentStart To FindOptions.bDocumentStart
    Send EditorMessage SCI_SETSEARCHFLAGS iFlags
    Function_Return iFlags
  End_Function

  Function CurrentSearchOptions String sSearchText Returns tFindReplaceOptions
    Integer iFlags
    tFindReplaceOptions FindOptions

    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    Move sSearchText                    To FindOptions.sSearchText
    Move (iFlags iAnd SCFIND_WHOLEWORD) To FindOptions.bWordMatch
    Move (iFlags iAnd SCFIND_MATCHCASE) To FindOptions.bMatchCase
    Move (iFlags iAnd SCFIND_REGEXP)    To FindOptions.bRegExp
    Get pbFindDocumentStart To FindOptions.bDocumentStart
    Function_Return FindOptions
  End_Function


  // Find...
  Procedure Find
    Boolean bIsUtf8
    Integer iFlags
    Integer iCaretPos
    Integer iPos
    Integer iLen
    Integer iLine
    Integer iVoid
    String  sSearchText
    tFindReplaceOptions FindOptions

    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
    //
    Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
    Get CurrentSearchOptions sSearchText to FindOptions
    Move FindDown         To FindOptions.eFindOptions // search down by default
    Send RequestDetails of oFindDialog (&FindOptions)
    If (FindOptions.bStartFind) Begin
      // First update any changed search flags
      Get SetSearchOptions FindOptions to iFlags
      Move FindOptions.sSearchText To sSearchText
      Set psSearchText to sSearchText
      Get pbUtf8Mode      to bIsUtf8
      If (bIsUtf8) Begin
        Move (SizeOfString(sSearchText)) to iLen
      End
      Else Begin
        Move (Length(sSearchText)) to iLen // length is utf8 only!
        Get Utf8ToEditorFormat sSearchText to sSearchText
      End  
      If (iLen>0) Begin
        If (FindOptions.bDocumentStart=False) Begin
          Get EditorMessage SCI_GETCURRENTPOS To iCaretPos
          Send EditorMessage SCI_SETTARGETSTART iCaretPos
        End

        Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
        If (iPos > -1) Begin
          If (FindOptions.bMarkAll=false) Begin
            Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
          End
          Else Begin  // Mark All logic
            Move iPos To iCaretPos
            While (iPos>-1)
              // set bookmark for found position
              Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
              Get CM_SetBookmark iLine True to iVoid
              // find next
              Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
              Send EditorMessage SCI_SEARCHANCHOR
              Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
            Loop
            If (iCaretPos>-1) Begin
              // select first found
              Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
            End
          End
        End
      End
    End

    //
    // There's an alternative interface that works like this, not seeing why this would be more
    // convenient.
    //
    //Integer iStartPos
    //Integer iEndPos
    //Sci_TextToFind ft
    //
    //Move 0 To iStartPos
    //Move 100 to iEndPos
    //Move iStartPos To ft.chrg.cpMin
    //Move iEndPos   To ft.chrg.cpMax
    //Move (sSearchText+Character(0)) To sSearchText
    //Move (AddressOf(sSearchText)) To ft.pszText
    //Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
    //Get EditorMessage SCI_FINDTEXT iFlags (AddressOf(ft)) to iRet
    //If (iRet > -1) Begin
    //  Send none
    //End
  End_Procedure

  // Find First
  Procedure FindFirst
    Boolean bIsUtf8
    Integer iCaretPos
    Integer iLen
    Integer iPos
    String  sSearchText

    Send EditorMessage SCI_TARGETWHOLEDOCUMENT

    Get psSearchText to sSearchText
    Get pbUtf8Mode      to bIsUtf8
    If (bIsUtf8) Begin
      Move (SizeOfString(sSearchText)) to iLen
    End
    Else Begin
      Move (Length(sSearchText)) to iLen // length is utf8 only!
      Get Utf8ToEditorFormat sSearchText to sSearchText
    End  
    If (iLen>0) Begin
      Move (sSearchText+character(0)) To sSearchText
      Get  EditorMessage SCI_GETCURRENTPOS to iCaretPos
      Send EditorMessage SCI_SETTARGETSTART 0
      
      Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
      If (iPos>-1) Begin
        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
      End
      Else Begin
        Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
        Set Status_Help to (_T("Find Next: No more occurrences found.",1606))
        Send Request_Status_Help True
      End
    End
  End_Procedure

  // Find next
  Procedure FindNext
    Boolean bIsUtf8
    Integer iCaretPos
    Integer iFlags
    Integer iLen
    Integer iPos
    Integer iStartPos
    String  sSearchText

    Get psSearchText to sSearchText
    Get pbUtf8Mode      to bIsUtf8
    If (bIsUtf8) Begin
      Move (SizeOfString(sSearchText)) to iLen
    End
    Else Begin
      Move (Length(sSearchText)) to iLen // length is utf8 only!
      Get Utf8ToEditorFormat sSearchText to sSearchText
    End  
    If (iLen>0) Begin
      Move (sSearchText+character(0)) To sSearchText
      Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iCaretPos
      Move (iCaretPos+iLen) To iStartPos
      Send EditorMessage SCI_SETCURRENTPOS iStartPos

      Send EditorMessage SCI_SEARCHANCHOR
      Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags

      Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
      If (iPos>-1) Begin
        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
      End
      Else Begin
        Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
        Set Status_Help to (_T("Find Next: No more occurrences found.",1606))
        Send Request_Status_Help True
      End
    End
  End_Procedure

  Procedure FindPrevious
    Boolean bIsUtf8
    Integer iFlags
    Integer iLen
    Integer iPos
    String  sSearchText

    Get psSearchText to sSearchText
    Get pbUtf8Mode      to bIsUtf8
    If (bIsUtf8) Begin
      Move (SizeOfString(sSearchText)) to iLen
    End
    Else Begin
      Move (Length(sSearchText)) to iLen // length is utf8 only!
      Get Utf8ToEditorFormat sSearchText to sSearchText
    End  
    If (iLen>0) Begin
      Move (sSearchText+character(0)) To sSearchText

      Send EditorMessage SCI_SEARCHANCHOR
      Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 To iFlags
      
      Get  EditorMessage SCI_SEARCHPREV iFlags (AddressOf(sSearchText)) to iPos
      If (iPos>-1) Begin
        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
      End
      Else Begin
        Set Status_Help to (_T("Find Previous: No more occurrences found.",1607))
        Send Request_Status_Help True
      End
    End
  End_Procedure

  Procedure Replace
    Boolean bIsUtf8
    Integer iCaretPos
    Integer iPos
    Integer iStartPos
    Integer iLen
    Integer iFlags
    String  sSearchText
    tFindReplaceOptions ReplaceOptions

    Move 0 To iCaretPos
    Move 0 To iStartPos
    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
    //
    Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
    Get CurrentSearchOptions sSearchText to ReplaceOptions

    Send RequestDetails of oReplaceDialog (&ReplaceOptions) (Object_Id(Self))
    If (ReplaceOptions.bReplaceAll) Begin
      // First update any changed search flags
      Get SetSearchOptions ReplaceOptions to iFlags
      Move ReplaceOptions.sSearchText To sSearchText
      Set psSearchText to sSearchText
      Get pbUtf8Mode      to bIsUtf8
      If (bIsUtf8) Begin
        Move (SizeOfString(sSearchText)) to iLen
      End
      Else Begin
        Move (Length(sSearchText)) to iLen // length is utf8 only!
        Get Utf8ToEditorFormat sSearchText to sSearchText
      End  
      If (iLen>0) Begin
        Move 0 To iStartPos
        If (ReplaceOptions.bDocumentStart=False) Begin
          Get EditorMessage SCI_GETCURRENTPOS To iCaretPos
          Move iCaretPos To iStartPos
        End
        Send EditorMessage SCI_SETTARGETSTART iStartPos

        Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
        If (iPos > -1) Begin
          Move iPos To iCaretPos
          Send EditorMessage SCI_BEGINUNDOACTION
          While (iPos>-1)
            // select found text then replace it
            Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
            Send ReplaceText ReplaceOptions.sReplaceText
            Send EditorMessage SCI_SETSEL (iPos+iLen) (iPos+iLen) // remove selection
            // find next
            Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
            Send EditorMessage SCI_SEARCHANCHOR
            Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
          Loop
          Send EditorMessage SCI_ENDUNDOACTION
          // select first replaced
          Move (Length(ReplaceOptions.sReplaceText)) To iLen
          Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
        End
      End
    End
  End_Procedure

  Procedure ReplaceText String sReplaceWith
    String sTargetText
    String sReplaceText
    String sSearchText
    Integer iVoid

    Get psSearchText to sSearchText
    If (sSearchText<>"") Begin
      Move (sReplaceWith+"") To sReplaceText
      Move (ZeroString(300)) to sTargetText
      Send EditorMessage SCI_TARGETFROMSELECTION
      Get EditorMessage SCI_GETTARGETTEXT 0 (AddressOf(sTargetText)) to iVoid
      If (lowercase(Cstring(sTargetText)) = lowercase(sSearchText)) Begin
        //Send EditorMessage SCI_SETTARGETRANGE iPos iPos
        Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sReplaceText))
      End
    End
  End_Procedure

  //        // Replace
  //    Procedure Replace
  //        Integer iRet
  //        Get CM_ExecuteCmd CMD_FindReplace 0 to iRet
  //    End_Procedure

  // Goto line...
  // CMD_GOTOLINE - Moves to a user-specified line.
  // ( int ) The zero-based line number to jump to.
  // If no argument is passed then the user is prompted.
  Procedure GotoLine Integer iNrEx
    Integer iLine iRet
    Integer iScreenLines
    Integer iFirstLine
    Integer iLinesToScroll

    If NUM_Arguments Gt 0 Begin
      Move iNrEx    to iLine
    End
    Else Begin
      Send RequestDetails to oGotoDialog (&iLine)
      If (iLine<0) Begin
        Procedure_Return
      End
    End
    Send EditorMessage SCI_GOTOLINE iLine
    Get CM_SetHighlightedLine iLine to iRet
    // SCI_LINESONSCREEN = get lines visible on screen
    Get EditorMessage SCI_LINESONSCREEN to iScreenLines
    Get EditorMessage SCI_GETFIRSTVISIBLELINE to iFirstLine
    Get piLinesToScrollAfterGoto to iLinesToScroll // scroll a few lines to display more context if at
    If (iScreenLines > iLinesToScroll) Begin       // first or last line in the window after the goto line.
      If (iLine=iFirstLine) Begin
        Send EditorMessage SCI_LINESCROLL 0 (-iLinesToScroll)
      End
      Else If (iLine=(iFirstLine+iScreenLines-1)) Begin
        Send EditorMessage SCI_LINESCROLL 0 iLinesToScroll
      End
    End
  End_Procedure

  //
  // useful for debugging
  //
  Procedure showCurrentLineStyle
    Integer iVoid iStartLine //iStartCol iEndLine iEndCol
    Integer iPosStart
    Integer iPosChar iPos
    Integer eStyle
    Integer iLineLength
    String  sLine

    Get CM_GetSel False  to iVoid
    Get piSelStartLine   to iStartLine
    Get value item iStartLine to sLine
    Get EditorMessage SCI_FINDCOLUMN iStartLine to iPosStart
    Get EditorMessage SCI_LINELENGTH iStartLine to iLineLength
    Showln sLine
    For iPosChar from iPosStart to (iPosStart+iLineLength)
      Get EditorMessage SCI_GETSTYLEAT iPosChar to eStyle
      Move (iPosChar-iPosStart+1) To iPos // to keep it simple,  this is the position in the sLine string
      Showln "Style for [" (Mid(sLine,1,iPos)) "] " (iPosChar-iPosStart) " " eStyle
    Loop
  End_Procedure

  //
  // Normalizes the selected line by finding the DataFlex keywords in the line and then
  // matching those up with how they are defined and adjusting the case if needed.
  // If bUndo is true then it will add an undo action for this line.
  // Will return true if the line was changed.
  //
  Function LineNormalizeCase Integer iLine Boolean bUndo Returns Boolean
    Boolean bChanged
    Integer iPosStart
    Integer iPosChar iPos
    Integer eStyle eLastStyle
    Integer iLineLength
    Integer iWordStart
    String  sLine sTALine
    String  sWord sTAWord

    Move False To bChanged
    Get value item iLine to sLine
    Get EditorMessage SCI_FINDCOLUMN iLine to iPosStart
    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
    Move sLine To sTALine
    For iPosChar from iPosStart to (iPosStart+iLineLength)
      Get EditorMessage SCI_GETSTYLEAT iPosChar to eStyle
      Move (iPosChar-iPosStart+1) To iPos // to keep it simple,  this is the position in the sLine string
      //Showln "Style " (iPosChar-iPosStart) " " eStyle
      If (eStyle=SCE_DF_WORD and eLastStyle<>SCE_DF_WORD) Begin
        Move SCE_DF_WORD To eLastStyle
        Move iPos to iWordStart
      End
      Else If (eStyle=SCE_DF_SCOPEWORD and eLastStyle<>SCE_DF_SCOPEWORD) Begin
        Move SCE_DF_SCOPEWORD To eLastStyle
        Move iPos To iWordStart
      End
      If (eLastStyle=SCE_DF_WORD and eStyle<>SCE_DF_WORD) Begin
        //Show " [" (Mid(sLine,iPos-iWordStart,iWordStart)) "]"
        Move (Mid(sLine,iPos-iWordStart,iWordStart)) To sWord
        Get FindKeyWord of oNormalizeCase SCLEX_DATAFLEX sWord to sTAWord
        Move (Overstrike(sTAWord,sTALine,iWordStart)) To sTALine
        Move 0 To eLastStyle
      End
      Else If (eLastStyle=SCE_DF_SCOPEWORD and eStyle<>SCE_DF_SCOPEWORD) Begin
        //Show " <" (Mid(sLine,iPos-iWordStart,iWordStart)) ">"
        Move (Mid(sLine,iPos-iWordStart,iWordStart)) To sWord
        Get FindScopeWord of oNormalizeCase SCLEX_DATAFLEX sWord to sTAWord
        Move (Overstrike(sTAWord,sTALine,iWordStart)) To sTALine
        Move 0 To eLastStyle
      End
    Loop
    If (sLine<>sTALine) Begin
      Move True To bChanged
      If (bUndo) Begin
        Send EditorMessage SCI_BEGINUNDOACTION
      End
      Set Value Item iLine To sTALine
      Send EditorMessage SCI_COLOURISE iPosStart (iPosStart+iLineLength)  // apply style to the changed text!
      If (bUndo) Begin
        Send EditorMessage SCI_ENDUNDOACTION
      End
    End
    Function_Return bChanged
  End_Function


  Procedure doNormalizeCase
    Boolean bChanged
    Integer iVoid iStartLine iStartCol iEndLine iEndCol

    //Send EditorMessage SCI_CLEARCMDKEY ((65536*(SCMOD_CTRL))+Ascii("O"))

    Get CM_GetSel False  to iVoid
    Get piSelStartLine   to iStartLine
    Get piSelStartCol    to iStartCol
    Get piSelEndLine     to iEndLine
    Get piSelEndCol      To iEndCol
    Get LineNormalizeCase iStartLine True To bChanged
    If (bChanged) Begin
      // move cursor back to where it was
      Get CM_SetSel iStartLine iStartCol iEndLine iEndCol True to iVoid
    End
  End_Procedure

  Procedure StartUndoTransaction
    Send EditorMessage SCI_BEGINUNDOACTION
  End_Procedure

  Procedure EndUndoTransaction
    Send EditorMessage SCI_ENDUNDOACTION
  End_Procedure


  // Fills the position of the cursor in pixels into Properties.
  // - getting the curren postion in Line / Col
  // - Retrieving this Position in Pixesl with CM_PosFromChar
  // - Retrieving the absolute position of the Window
  // =  ABSOLUTE CURSOR POSITION in the Edit.
  Procedure FillCurrentPosition
    Integer iRet
    Move (CM_GetSel(Self,False))                                        to iRet
    Move (CM_PosFromChar(Self,piSelEndLine(Self),piSelEndCol(Self)))    to iRet
    Set piAbsPosYEnd    to (Hi (Absolute_GuiOriginEx(Self))+piPosEndY(Self))
    Set piAbsPosXEnd    to (Low(Absolute_GuiOriginEx(Self))+piPosEndX(Self))
    Set piAbsPosYStart  to (Hi (Absolute_GuiOriginEx(Self))+piPosStartY(Self))
    Set piAbsPosXStart  to (Low(Absolute_GuiOriginEx(Self))+piPosStartX(Self))
  End_Procedure

  // Delivers the current line.
  Function Current_Item Returns Integer
    Integer iRet
    Get CM_GetSel False                 to iRet
    Function_Return (piSelEndLine(Self))
  End_Function
  //  As I'm a bit thick, let's create a function with that name to make my life easier
  Function Current_Line Returns Integer
    Integer iRet
    Get CM_GetSel False                 to iRet
    Function_Return (piSelEndLine(Self))
  End_Function
  // For VDF closer access.    - number of lines.
  Function Item_Count Returns Integer
    Function_Return (SC_LineCount(Self))
  End_Function
  // Value of the line with the given LineNr.
  Function Value Integer iItem Returns String
    If iItem Eq -99 Begin
      Move (Current_Item(Self)) to iItem
    End
    Function_Return (CM_GetLine(Self,iItem))
  End_Function

  // Sets the value of a given line. (For compatibility with VDF)
  Procedure Set Value Integer iItem String sValue
    Integer iRet iC iCol iLine

    Get CM_GetSel False                to iRet
    Get piSelEndCol                    to iCol
    Get piSelEndLine                   to iLine
    If iItem Eq -99 Begin
      Get Current_Item  to iItem
    End
    Get CM_SelectLine iItem False      to iRet // select line up to EOL character
    Get CM_DeleteSel                   to iRet
    Get CM_InsertText sValue iItem 0   to iRet
    If (iLine <> iItem) Begin
      Get CM_SetSel iLine iCol iLine iCol False  to iRet
    End
  End_Procedure

  Procedure Delete_Data
    // Unless the document is read-only, this deletes all the text.
    Send EditorMessage SCI_CLEARALL
    Send EditorMessage SCI_EMPTYUNDOBUFFER
    // Clear all styling information and reset the folding state.
    Send EditorMessage SCI_CLEARDOCUMENTSTYLE
  End_Procedure


  // Inserts the Sting into the current Position.
  Procedure Insert String sValue
    Integer iRet
    Get CM_GetSel False to iRet
    Move (CM_InsertText(Self,sValue,piSelEndLine(Self),piSelEndCol(Self))) to iRet
  End_Procedure

  // This is en advanced set value which automatically indents the new
  // value text as far as the text in the line was, or if empty the text of the line before.
  Procedure Set ValueSmart Integer iLine String sVal
    Integer iPos
    String sValOld
    Get value item iLine    to sValOld
    If (Trim(sValOld)) Eq "" If iLine Gt 0 Begin
      Get Value Item (iLine-1) to sValOld
    End
    If (Trim(sValOld)) Ne "" Begin
      For iPos from 1 to (Length(sValOld))

        If (Mid(sValOld,1,iPos)) Ne " " Break
      Loop

      Move (LTrim(sVal))      to sVal
      Move (Append(Repeat(" ",iPos-1),sVal))  to sVal
    End

    Set value item iLine                        to sVal
  End_Procedure

  // To determine if an object is a cCodeMaxEdit
  Function iscWinMaxEdit Returns Integer
    Function_Return 1
  End_Function

  //____NOTIFICATION_TRAPPING..._____________________________________________
  // all of the followinf procedures and functions are sent by the
  // procedure Notify - which is caused by WM_Notify message.

  // Key capturing...

  // Blocks iKeyCode
  Procedure BlockKey Integer iKeyCode Integer iExtKey Integer iFlag
    If iExtKey Eq CM_KEY_NOEXT ;
      Set psBlockedKeysNo    to (Overstrike(String(iFlag),psBlockedKeysNo   (Self),iKeyCode))
    If iExtKey Eq CM_KEY_SHIFT ;
      Set psBlockedKeysShift to (Overstrike(String(iFlag),psBlockedKeysShift(Self),iKeyCode))
    If iExtKey Eq CM_KEY_ALT   ;
      Set psBlockedKeysAlt   to (Overstrike(String(iFlag),psBlockedKeysAlt  (Self),iKeyCode))
    If iExtKey Eq CM_KEY_CTRL  ;
      Set psBlockedKeysCtrl  to (Overstrike(String(iFlag),psBlockedKeysCtrl (Self),iKeyCode))
  End_Procedure

  Function isKeyBlocked Integer iKeyCode Integer iExtKey Returns Integer
    If iExtKey Eq CM_KEY_NOEXT ;
      Function_Return (Mid(psBlockedKeysNo   (Self),1,iKeyCode))
    If iExtKey Eq CM_KEY_SHIFT ;
      Function_Return (Mid(psBlockedKeysShift(Self),1,iKeyCode))
    If iExtKey Eq CM_KEY_ALT   ;
      Function_Return (Mid(psBlockedKeysAlt  (Self),1,iKeyCode))
    If iExtKey Eq CM_KEY_CTRL  ;
      Function_Return (Mid(psBlockedKeysCtrl (Self),1,iKeyCode))
    Function_Return 0
  End_Function


  // Like Block Key but the Blocked key is reset with onKeyUp.
  Procedure BlockKeyOnce Integer iKeyCode Integer iExtKey Integer iFlag
    If iExtKey Eq CM_KEY_NOEXT ;
      Set psBlockedKeysNoOnce    to (Overstrike(String(iFlag),psBlockedKeysNoOnce   (Self),iKeyCode))
    If iExtKey Eq CM_KEY_SHIFT ;
      Set psBlockedKeysShiftOnce to (Overstrike(String(iFlag),psBlockedKeysShiftOnce(Self),iKeyCode))
    If iExtKey Eq CM_KEY_ALT   ;
      Set psBlockedKeysAltOnce   to (Overstrike(String(iFlag),psBlockedKeysAltOnce  (Self),iKeyCode))
    If iExtKey Eq CM_KEY_CTRL  ;
      Set psBlockedKeysCtrlOnce  to (Overstrike(String(iFlag),psBlockedKeysCtrlOnce (Self),iKeyCode))
  End_Procedure
  Function isKeyBlockedOnce Integer iKeyCode Integer iExtKey Returns Integer
    If iExtKey Eq CM_KEY_NOEXT  ;
      Function_Return (Mid(psBlockedKeysNoOnce   (Self),1,iKeyCode))
    If iExtKey Eq CM_KEY_SHIFT  ;
      Function_Return (Mid(psBlockedKeysShiftOnce(Self),1,iKeyCode))
    If iExtKey Eq CM_KEY_ALT    ;
      Function_Return (Mid(psBlockedKeysAltOnce  (Self),1,iKeyCode))
    If iExtKey Eq CM_KEY_CTRL   ;
      Function_Return (Mid(psBlockedKeysCtrlOnce (Self),1,iKeyCode))
    Function_Return 0
  End_Function

  Procedure onCMKeyUp Longptr iKeyCode Longptr iKeyExt
  End_Procedure
  Procedure onCMKeyDown Longptr iKeyCode Longptr iKeyExt
  End_Procedure
  Procedure onCMKeyPress Longptr iKeyCode Longptr iKeyExt
  End_Procedure

  //
  // We apparently can't use WM_KEYDOWN event, but our higher class depends on that. So from a keypress we now
  // simulate that by only watching the specific keys that are handled. While hackish, this appears to work.
  //
  Procedure SimulateOnKeyDown
    Integer iKeyCode iKeyExt iRet
    Move 0 To iKeyCode
    Move 0 To iKeyExt
    If (GetKeyState(VK_HOME)) ;
      Move VK_HOME To iKeyCode
    Else If (GetKeyState(VK_END)) ;
      Move VK_END To iKeyCode
    Else If (GetKeyState(VK_RETURN)) ;
      Move VK_RETURN To iKeyCode
    If (GetKeyState(VK_CONTROL)) ;
      Move CM_KEY_CTRL To iKeyExt
    Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
  End_Procedure

  Procedure DoKeyAction Integer iChar  Longptr lParam
    Integer iKeyExt iRet // iKeyCode iBlocked
    Boolean bHasCallTip
    //        Local_BUFFER_CPY sKeyData pKeyData CM_KEYDATA pCM_KeyData
    //        GetBuff from sKeyData At CM_KeyData.nKeyCode        to iKeyCode
    //        GetBuff from sKeyData At CM_KeyData.nKeyModifier    to iKeyExt
    //        If (iMode=CMN_KEYUP   ) Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
    //        If (iMode=CMN_KEYDOWN ) Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
    //        If (iMode=CMN_KEYPRESS) Get Msg_onCMKeyPress   iKeyCode iKeyExt  to iRet

    Send SimulateOnKeyDown
    Get Msg_onCMKeyPress   iChar iKeyExt  to iRet

    If (pbCodeTipRequest(Self)=False) Begin
      Get EditorMessage SCI_CALLTIPACTIVE to bHasCallTip
      If (bHasCallTip) Begin
        Set pbCodetipRequest to True // code tip is still on the screen, keep calculating to see if it has to be deactivated.
      End
    End

    //            // Blocks keystrokes. (only with every ExtKey, dont need this at the moment)
    //        If (isKeyBlocked(Self,iKeyCode,iKeyExt)) Begin
    //            Procedure_Return 1
    //        End
    //            // Same as above but the Key blocking is released with KeyUp -> Block Key only once!
    //        If (isKeyBlockedOnce(Self,iKeyCode,iKeyExt)) Begin
    //            If (iMode=CMN_KEYUP) Send BlockKeyOnce iKeyCode iKeyExt False   // Reset Key.
    //            Procedure_Return 1
    //        End
    Procedure_Return iRet
  End_Procedure

  Procedure onKeyUp Longptr iKey Longptr lParam
    Boolean bHasCodeList
    Integer iRet iKeyCode iKeyExt
    Move iKey To iKeyCode
    Forward Send onKeyUp iKey lParam
    Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
    If (pbIsCodelistActive(Self)) Begin
      Get EditorMessage SCI_AUTOCACTIVE to bHasCodeList
      If (bHasCodeList=False) Begin
        Send DoCodeListCancel
      End
    End
  End_Procedure


  Procedure Key Integer iKey
    Boolean bBlockSelect
    Boolean bDisableKey

    Move False to bDisableKey
    Set pbBlockSelectBackspace to False
    If iKey Eq 2166 Begin
      Send OnBeforePaste // Paste Ctrl+V
    End
    If iKey Eq 2168 Begin
      Send OnBeforeCut   // Cut Ctrl+X
    End
    Get pbBlockSelectActive to bBlockSelect
    If (bBlockSelect) Begin
      Send BlockSelectRemoveTextBlockBugfix

      If (iKey=KEY_TAB) Begin
        // tab works, but not when only space characters at first line, then it is a mess.
        // But if we then move the selection to the first column it works again. It's a bit ugly, but it works
        Send BlockSelectTabKeyBugfix
        Move True to bDisableKey
      End
    End
    //IfNot (bDisableKey) Forward Send Key iKey
    Forward Send Key iKey
    If iKey Eq 2166 Begin
      Send OnAfterPaste  // Paste Ctrl+V
    End
    If iKey Eq 2168 Begin
      Send OnAfterCut    // Cut Ctrl+X
    End
    If (bBlockSelect) Begin
      If (iKey=KEY_BACK_SPACE) Begin  // in block select the backspace reselection only works one time, to make it work well, we have to reselect by hand
        Set pbBlockSelectBackspace to True
      End
    End
  End_Procedure

  Procedure onDrawLine Handle hDC Integer iTop Integer iLeft Integer iBottom Integer iRight Integer iColLeft Integer iColRight Integer iLine Pointer pItemData Integer iStyle
    Integer iRet
    String sTxt
    
    Move (Repeat(Character(0),20))  To sTxt
    Move "Michis TestText"  to sTxt
    Move (TextOut(hDC,iLeft,iTop,AddressOf(sTxt),15)) to iRet
    Showln "iRet: " iRet

    Procedure_Return
    Showln "hDC "   hDC
    Showln "iTop "  iTop
    Showln "iLeft " iLeft
    Showln "iBottom " iBottom
    Showln "iRight " iRight
    Showln "iColLeft " iColLeft
    Showln "iColRight " iColRight
    Showln "iLine " iLine
    Showln "pItemData " pItemData
    Showln "iStyle " iStyle
  End_Procedure

  Procedure DoDrawline Pointer pCM_DrawLineData
    //        Local_BUFFER_CPY sDrawData pDrawData CM_DRAWLINEDATA pCM_DrawLineData
    //        Integer iTop iBottom iLeft iRight iColLeft iColRight iLine iStyle
    //        Pointer pItemData
    //        Handle  hDC
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.top    to iTop
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.bottom to iBottom
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Left   to iLeft
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Right  to iRight
    //
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.hDC           to hDC
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nLeftCol      to iColLeft
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nRightCol     to iColRight
    //
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nLine         to iLine
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.lParam        to pItemData
    //
    //        GetBuff from sDrawData At CM_DRAWLINEDATA.dwStyle       to iStyle
    //        Send onDrawLine hDC iTop iLeft iBottom iRight iColLeft iColRight iLine pItemData iStyle
  End_Procedure


  // Trap buffer modification...
  Procedure DoModifiedChange
    Send onModifiedChange (CM_IsModified(Self))
  End_Procedure
  Procedure onModifiedChange Integer bModified
  End_Procedure
  // Property change notification...
  Procedure onPropsChange
  End_Procedure

  Function IsBraceOpenCharacter Integer iChar Returns Boolean
    Boolean bIsBraceChar
    String  sChar

    Move False to bIsBraceChar
    Move (Character(iChar)) To sChar
    If (sChar="(" or sChar="[" or sChar="{") Begin
      Move True to bIsBraceChar
    End
    Function_Return bIsBraceChar
  End_Function

  Function IsBraceCloseCharacter Integer iChar Returns Boolean
    Boolean bIsBraceChar
    String  sChar

    Move False to bIsBraceChar
    Move (Character(iChar)) To sChar
    If (sChar="]" or sChar=")" or sChar="}") Begin
      Move True to bIsBraceChar
    End
    Function_Return bIsBraceChar
  End_Function

  Function IsBraceCharacter Integer iChar Returns Boolean
    Boolean bIsBraceChar

    Get IsBraceOpenCharacter iChar to bIsBraceChar
    If (bIsBraceChar=False) Begin
      Get IsBraceCloseCharacter iChar to bIsBraceChar
    End
    Function_Return bIsBraceChar
  End_Function

  // Selection has changed. (Position is included!)
  Procedure onSelChange
  End_Procedure

  //
  // Ordinary method to swap the contents of 2 integer variables
  //
  Procedure SwapIntegerVariables Integer ByRef iLine1 Integer ByRef iLine2
    Integer iTemp
    Move iLine1 To iTemp
    Move iLine2 To iLine1
    Move iTemp  To iLine2
  End_Procedure

  Function IsValidBraceCharMatch Integer iPos Integer iMatchPos Returns Boolean
    Boolean bIsValid
    Integer iLoop
    Integer iLine
    Integer iMatchLine
    String  sLine

    Move False to bIsValid
    If (iMatchPos<>INVALID_POSITION) Begin
      // check if the matched brace is on the same line
      Get EditorMessage SCI_LINEFROMPOSITION iPos      to iLine
      Get EditorMessage SCI_LINEFROMPOSITION iMatchPos to iMatchLine
      If (iLine=iMatchLine) Begin
        Move True To bIsValid
      End
      Else Begin
        // not on the same line, so can only be valid if the line ends with a ;
        If (iLine>iMatchLine) Begin
          Send SwapIntegerVariables (&iLine) (&iMatchLine)
        End
        Move True To bIsValid
        For iLoop from iLine to (iMatchLine-1)
          Get Value iLoop to sLine
          Move (Rtrim(sLine)) To sLine
          If (Right(sLine,1)<>";") Begin
            Move False To bIsValid
            Move iMatchLine To iLoop // stop
          End
        Loop
      End
    End
    Function_Return bIsValid
  End_Function

  //
  // Check if the style at the position supplied is either a comment or a DataFlex image
  //
  Function StyleAtPosIsComment Integer iPos Returns Boolean
    Boolean bIsComment
    Integer eStyle

    Move False to bIsComment
    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
    If (eStyle=SCE_DF_IMAGE or eStyle=SCE_DF_COMMENTLINE) Begin
      Move True to bIsComment
    End
    Function_Return bIsComment
  End_Function

  Function StyleAtCurrentPosIsComment Returns Boolean
    Boolean bIsComment
    Integer iPos

    Get EditorMessage SCI_GETCURRENTPOS To iPos
    Get StyleAtPosIsComment iPos To bIsComment
    Function_Return bIsComment
  End_Function

  Function StyleAtPosIsDfImage Integer iPos Returns Boolean
    Boolean bIsComment
    Integer eStyle

    Move False to bIsComment
    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
    If (eStyle=SCE_DF_IMAGE) Begin
      Move True to bIsComment
    End
    Function_Return bIsComment
  End_Function

  Function StyleAtPosIsDfKeyword Integer iPos Returns Boolean
    Boolean bIsKeyword
    Integer eStyle

    Move False to bIsKeyword
    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
    If (eStyle=SCE_DF_SCOPEWORD) Begin // SCE_DF_WORD
      Move True to bIsKeyword
    End
    Function_Return bIsKeyword
  End_Function

  //
  // Check if the style at the position supplied is a string
  //
  Function StyleAtPosIsString Integer iPos Returns Boolean
    Boolean bIsString
    Integer eStyle

    Move False to bIsString
    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
    If (eStyle=SCE_DF_STRING) Begin
      Move True to bIsString
    End
    Function_Return bIsString
  End_Function

  Function PosAtEndOfLine Integer iPos Returns Boolean
    Boolean bAtEOL
    Integer iLine
    Integer iPosAtEOL

    Move False To bAtEOL
    Get Editormessage SCI_LINEFROMPOSITION   iPos  To iLine
    Get Editormessage SCI_GETLINEENDPOSITION iLine To iPosAtEOL
    If (iPos=(iPosAtEOL-1)) Begin
      Move True to bAtEOL
    End
    Function_Return bAtEOL
  End_Function

  // Shows matching braces for the characters ({[]})
  // Note that SCI_BRACEHIGHLIGHT can only highlight two characters so it will not
  // work for highlighting words like begin/end.
  Procedure ShowMatchingBraces Integer iPos
    Integer iChar
    Integer imaxReStyle
    Integer iMatchPos
    Integer iMainSelection
    Integer iVirtSpace
    Boolean bMatchPreviousChar
    Boolean bIsMatch
    Boolean bIsBraceChar
    Boolean bIsComment
    Boolean bPosAtEOL
    // get the char
    Move 0 To iVirtSpace
    Get EditorMessage SCI_GETMAINSELECTION to iMainSelection
    If (imainSelection>=0) Begin
      Get EditorMessage SCI_GETSELECTIONNCARETVIRTUALSPACE iMainSelection to iVirtSpace
    End
    If (iVirtSpace>0) Begin  // we are navigating the cursor past the end of line into "virtual space"
      If (pbBraceHighLightState(Self)) Begin
        // remove the highlight
        Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
        Set pbBraceHighLightState to False
      End
    End
    Else Begin
      Move True to bMatchPreviousChar // this seems to make more sense as you see match while you type
      Move False to bIsBraceChar
      If (iPos>0 and bMatchPreviousChar) Begin
        Move (iPos-1) To iPos
      End
      Get EditorMessage SCI_GETCHARAT iPos to iChar
      Get IsBraceCharacter iChar To bIsBraceChar
      If (bIsBraceChar) Begin
        Get StyleAtPosIsComment iPos To bIsComment
        If (bIsComment=false) Begin
          Move 0 to imaxReStyle
          Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
          Get IsValidBraceCharMatch iPos iMatchPos to bIsMatch
          If (bIsMatch) Begin
            Send EditorMessage SCI_BRACEHIGHLIGHT iPos iMatchPos
            Set pbBraceHighLightState to True
          End
          Else Begin
            Get PosAtEndOfLine iPos To bPosAtEOL
            If (bPosAtEOL=false) Begin
              Send EditorMessage SCI_BRACEBADLIGHT iPos
              Set pbBraceHighLightState to True
            End
          End
        End
      End
      Else Begin
        If (pbBraceHighLightState(Self)) Begin
          // remove the highlight
          Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
          Set pbBraceHighLightState to False
        End
      End
    End
  End_Procedure

  //
  // A preparsed line is a "normal" line but it has some of the parsing difficulties removed.
  // Eg. all string literals are now underscores, eg. "abc" becomes ____
  //                             or plus symbols  eg. 'abc' becomes ++++
  //     all comments are cut off
  //     all space characters on the right are trimmed
  // So the relevant part of the line has just as much characters as before, but no longer creates
  // parsing issues with parse targets that are embedded in strings or comments.
  Function PreParsedLine Integer iLine Returns String
    Boolean bDoubleQuote
    Boolean bSingleQuote
    Integer iChar
    Integer iLength
    String  sLine
    String  sChar

    Get CM_GetLine iLine to sLine
    Move (Length(sLine)) To iLength
    For iChar From 1 To iLength
      Move (Mid(sLine,1,iChar)) To sChar
      If (sChar=Character(9)) Begin // tab characters should be treated as a single space char, this keeps the
        Move (Overstrike(" ",sLine,iChar)) To sLine // position in the string the same.
        Move " " To sChar
      End
      If (bDoubleQuote and sChar='"') Begin
        Move (Overstrike("_",sLine,iChar)) To sLine
        Move "" To sChar
        Move False To bDoubleQuote
      End
      If (bSingleQuote and sChar="'") Begin
        Move (Overstrike("+",sLine,iChar)) To sLine
        Move "" To sChar
        Move False To bSingleQuote
      End
      If (sChar='"') ;
        Move True To bDoubleQuote
      If (sChar="'") ;
        Move True To bSingleQuote
      If bDoubleQuote ;
        Move (Overstrike("_",sLine,iChar)) To sLine
      Else ;
        If bSingleQuote ;
        Move (Overstrike("+",sLine,iChar)) To sLine
      Else If (sChar="/") Begin
        If (Mid(sLine,2,iChar)="//") Begin
          Move (Left(sLine,iChar-1)) To sLine
          Move iLength to iChar // end loop
        End
      End
    Loop
    Move (Rtrim(sLine)) To sLine
    Function_Return sLine
  End_Function


  Procedure BraceMatchLocation Integer iChar String sLine Integer iCol Integer ByRef iBraceCount Integer ByRef iBraceMatch
    Boolean bOpenChar
    Boolean bCloseChar
    Integer iLinePos
    Integer iLineChar
    Integer iLength

    Move (Length(sLine)) To iLength
    If (iCol<=iLength) Begin
      Get IsBraceOpenCharacter iChar to bOpenChar
      If (bOpenChar) Begin
        For iLinePos from iCol to iLength
          Move False to bOpenChar
          Move False To bCloseChar
          Move (Ascii(Mid(sLine,1,iLinePos))) To iLineChar
          Get IsBraceOpenCharacter iLineChar to bOpenChar
          If (bOpenChar) ;
            Increment iBraceCount
          Else ;
            Get IsBraceCloseCharacter iLineChar to bCloseChar
          If (bCloseChar) Begin
            Decrement iBraceCount
            If (iBraceCount=0) Begin
              Move iLinePos To iBraceMatch
              Move iLength  To iLinePos
            End
          End
        Loop
      End
      Else Begin  // We're on a close brace
        Move iCol To iLinePos
        While (iLinePos>0)
          Move False To bOpenChar
          Move False To bCloseChar
          Move (Ascii(Mid(sLine,1,iLinePos))) To iLineChar
          Get IsBraceCloseCharacter iLineChar to bCloseChar
          If (bCloseChar) ;
            Increment iBraceCount
          Else ;
            Get IsBraceOpenCharacter iLineChar to bOpenChar
          If (bOpenChar) Begin
            Decrement iBraceCount
            If (iBraceCount=0) Begin
              Move iLinePos To iBraceMatch
              Move -1 To iLinePos
            End
          End
          Decrement iLinePos
        Loop
      End
    End
  End_Procedure

  Function FoldLevelWhiteLine Integer iLine Returns Boolean
    Boolean bWhiteLine
    Integer uFoldLevel

    Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel // unmasked level
    Move ((uFoldLevel iAnd SC_FOLDLEVELWHITEFLAG)=SC_FOLDLEVELWHITEFLAG) To bWhiteLine
    Function_Return bWhiteLine
  End_Function

  Function MatchKeywordPosition Integer iMatchLine Boolean bFoldPoint Integer iFoldLevel Returns Integer
    Boolean bWhiteLine
    Integer eStyle
    Integer iStartPos
    Integer iEndPos
    Integer iPos
    Integer iMatchPos

    Move -1 To iMatchPos
    If (iMatchLine>-1) Begin
      If (bFoldPoint) Begin // white lines are also part of the fold, move up if needed
        Get FoldLevelWhiteLine iMatchLine to bWhiteLine
        While (bWhiteLine)
          Decrement iMatchLine
          Get FoldLevelWhiteLine iMatchLine to bWhiteLine
        Loop
      End
      Get EditorMessage SCI_POSITIONFROMLINE   iMatchLine to iStartPos
      Get EditorMessage SCI_GETLINEENDPOSITION iMatchLine to iEndPos
      For iPos From iStartPos To iEndPos
        Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
        If (eStyle=SCE_DF_SCOPEWORD) Begin
          Move iPos To iMatchPos
          Move iEndPos To iPos
        End
      Loop
    End
    Function_Return iMatchPos
  End_Function

  Function LineFoldLevel Integer iLine Returns Integer
    Integer uFoldLevel
    Integer iFoldLevel

    Get EditorMessage SCI_GETFOLDLEVEL iLine To uFoldLevel // unmasked level
    Move (uFoldLevel iAnd SC_FOLDLEVELNUMBERMASK) To iFoldLevel
    Move (iFoldLevel-SC_FOLDLEVELBASE) To iFoldLevel
    Function_Return iFoldLevel
  End_Function

  Procedure GotoMatchBraceKeyword Integer iPos Integer iLine
    Boolean bFoldPoint
    Integer eStyle
    Integer uFoldLevel
    Integer iFoldLevel
    Integer iMatchLine
    Integer iMatchPos

    Move -1 To iMatchPos
    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
    If (eStyle=SCE_DF_SCOPEWORD) Begin
      Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel // unmasked level
      Move (uFoldLevel iAnd SC_FOLDLEVELNUMBERMASK) To iFoldLevel
      Move ((uFoldLevel iAnd SC_FOLDLEVELHEADERFLAG)=SC_FOLDLEVELHEADERFLAG)To bFoldPoint
      If (bFoldPoint) Begin
        Get Editormessage SCI_GETLASTCHILD iLine -1 to iMatchLine
        //If (iMatchLine>-1 and iFoldLevel=(SC_FOLDLEVELBASE+1)) Decrement iMatchLine
        Get MatchKeywordPosition iMatchLine bFoldPoint iFoldLevel to iMatchPos
      End
      Else Begin
        Get EditorMessage SCI_GETFOLDPARENT iLine to iMatchLine
        Get MatchKeywordPosition iMatchLine bFoldPoint iFoldLevel to iMatchPos
      End
    End
    If (iMatchPos>-1) Begin
      Send EditorMessage SCI_GOTOPOS iMatchPos
    End
  End_Procedure


  Procedure GotoMatchBrace
    Boolean bIsBraceChar
    Boolean bOpenChar
    Integer iBraceCount
    Integer iPos
    Integer iCol
    Integer iChar
    Integer iLine
    Integer iLineLength
    Integer iBraceMatch
    String  sLine

    Move -1 To iBraceMatch
    Get EditorMessage SCI_GETCURRENTPOS To iPos
    Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
    If (iPos>0) Begin
      Get EditorMessage SCI_GETCHARAT (iPos-1) to iChar
    End
    Get IsBraceCharacter iChar To bIsBraceChar
    If (bIsBraceChar) Begin
      Get PreParsedLine iLine to sLine
      Get EditorMessage SCI_GETCOLUMN (iPos-1) to iCol // zero based
      Send BraceMatchLocation iChar sLine (iCol+1) (&iBraceCount) (&iBraceMatch)
      If (iBraceMatch=-1) Begin
        Move (iPos-iCol) To iPos
        Move 0 To iCol // current column no longer relative as we are trying to match against another line
        Get IsBraceOpenCharacter iChar to bOpenChar
        If (bOpenChar) Begin
          While (iBraceMatch=-1 and Right(sLine,1)=";")
            Get EditorMessage SCI_LINELENGTH iLine to iLineLength
            Move (iPos+iLineLength) To iPos
            Increment iLine
            Get PreParsedLine iLine to sLine
            Send BraceMatchLocation iChar sLine 1 (&iBraceCount) (&iBraceMatch)
          Loop
        End
        Else Begin // it's a closed char
          If (iLine>1) Begin
            Get PreParsedLine (iLine-1) to sLine
            While (iBraceMatch=-1 and Right(sLine,1)=";" and iLine>1)
              Send BraceMatchLocation iChar sLine (Length(sLine)) (&iBraceCount) (&iBraceMatch)
              Decrement iLine
              Get EditorMessage SCI_LINELENGTH iLine to iLineLength
              Move (iPos-iLineLength) To iPos
              Get PreParsedLine (iLine-1) to sLine
            Loop
          End
        End
      End
      If (iBraceMatch>-1) Begin
        Send EditorMessage SCI_GOTOPOS (iPos-(iCol+1)+iBraceMatch)
      End
    End
    Else Begin // not a brace char, is there a scope keyword under our cursor?
      Send GotoMatchBraceKeyword iPos iLine
    End
  End_Procedure

  //
  // Navigation, the cursor changed lines event
  //
  Procedure onLineChanged Integer iLineOld Integer iLineNew
  End_Procedure

  //
  // Navigation, called when the cursor changes lines
  //
  Procedure LineChanged Integer iLineOld Integer iLineNew
    Handle  hMarker
    Integer iLine
    String  sLine

    Get phMarkerLineHighLight to hMarker
    If (hMarker<>0) Begin
      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
      If (iLine<>iLineNew) Begin
        Send ResetHighlightedLine
      End
    End
    If (iLineOld<>iLineNew) Begin
      Get CM_GetLine iLineNew to sLine
      Set psLineOnEnter       to sLine
      Set Status_Help to "" // remove status help if anything in there
      Send Request_Status_Help True
    End
    Send onLineChanged iLineOld iLineNew
  End_Procedure

  Procedure onNavigate Integer iPos
    Integer iLineOld
    Integer iLineNew
    Boolean bShowMatchingBraces

    Get piSelEndLine to iLineOld
    Get pbShowMatchingBraces to bShowMatchingBraces
    If (bShowMatchingBraces) Begin
      Send ShowMatchingBraces iPos
    End
    Send onSelChange
    Get piSelEndLine to iLineNew
    If (iLineOld<>iLineNew) Begin
      Send LineChanged iLineOld iLineNew
    End
  End_Procedure

  //
  // Is called when the user has inserted or deleted text, so effectively when our document
  // line count changes.
  //
  Procedure LineCountChanged
    Integer iOldDigits
    Integer iNewDigits
    Integer iMinDigits
    Integer iLineCount
    Integer iVoid
    Integer iWidth

    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS to iWidth
    If (iWidth<>0) Begin  // we have a line number margin, how many lines?
      Get Item_Count to iLineCount // the margin width is determined based on number of digits
      Move 3 To iMinDigits         // we set a minimum digits width of 3 digits
      Get piMarginLineNumberDigits    To iOldDigits
      Move (Length(Trim(iLineCount))) To iNewDigits
      If (inewDigits<iMinDigits) Begin
        Move iMinDigits to iNewDigits
      End
      If (iOldDigits<>iNewDigits) Begin
        Get CM_SetLineNumbering True 0 0 to iVoid  // by enabling line numbering we tell the logic to update the width
      End
    End
  End_Procedure

  // Insert mode / Overwrite mode
  Procedure onOvertypeChange
  End_Procedure

  Procedure RegisterKeyBindingToClear String sKey
    String[] KeyBindings

    Get psClearKeyBindings to KeyBindings
    Move sKey To KeyBindings[SizeOfArray(KeyBindings)]
    Set psClearKeyBindings to KeyBindings
  End_Procedure

  Procedure RemoveSCIKeyBinding String sKey
    Integer iModKeys
    Integer iKey
    String  sKeyDefine
    //
    Move 0 To iModKeys
    Move sKey To sKeyDefine
    Move (Replaces(" ",sKey,"")) To sKey // in Sci we can have "Ctrl + F" so get rid of the space characters
    Move (Uppercase(sKey)) To sKey
    If (pos("CTRL+",sKey)<>0) Begin
      Move (iModKeys iOr SCMOD_CTRL)   To iModKeys
      Move (Replace("CTRL+",sKey,""))  To sKey
    End
    If (Pos("ALT+",sKey)<>0) Begin
      Move (iModKeys iOr SCMOD_ALT)    To iModKeys
      Move (Replace("ALT+",sKey,""))   To sKey
    End
    If (Pos("SHIFT+",sKey)<>0) Begin
      Move (iModKeys iOr SCMOD_SHIFT)  To iModKeys
      Move (Replace("SHIFT+",sKey,"")) To sKey
    End
    If (Length(sKey)=1) Begin
      Move (Ascii(sKey)) To iKey
    End
    Else Begin
      Case Begin  // It isn't clear to me if SCI uses VK_xxx keys, but it seems so
        Case (sKey="F1")
          Move VK_F1 To iKey
          Case break
        Case (sKey="F2")
          Move VK_F2 To iKey
          Case break
        Case (sKey="F3")
          Move VK_F3 To iKey
          Case break
        Case (sKey="F4")
          Move VK_F4 To iKey
          Case break
        Case (sKey="F5")
          Move VK_F5 To iKey
          Case break
        Case (sKey="F6")
          Move VK_F6 To iKey
          Case break
        Case (sKey="F7")
          Move VK_F7 To iKey
          Case break
        Case (sKey="F8")
          Move VK_F8 To iKey
          Case break
        Case (sKey="F9")
          Move VK_F9 To iKey
          Case break
        Case (sKey="F10")
          Move VK_F10 To iKey
          Case break
        Case (sKey="F11")
          Move VK_F11 To iKey
          Case break
        Case (sKey="F12")
          Move VK_F12 To iKey
          Case break
        Case (sKey="ENTER")
          Move SCK_RETURN To iKey
        Case (sKey="DOWN")
          Move SCK_DOWN To iKey
        Case (sKey="UP")
          Move SCK_UP To iKey
      Case End
    End
    If (iKey<>0) Begin
      Send EditorMessage SCI_CLEARCMDKEY ((65536*(iModKeys))+iKey)
    End
    Else Begin
      Send none
      // might be handy for debugging, or just annoying :) so use send none instead
      //Send Info_Box ("Scintilla unknown key to clear "+sKeyDefine)
    End
  End_Procedure

  Procedure ClearRegisteredKeyBindings
    Integer iKey
    Integer iCount
    String[] KeyBindings

    Get psClearKeyBindings to KeyBindings
    Move (SizeOfArray(KeyBindings)) To iCount
    If (iCount>0) Begin
      For iKey from 0 to (iCount-1)
        Send RemoveSCIKeyBinding KeyBindings[iKey]
      Loop
      //Send EditorMessage SCI_CLEARALLCMDKEYS
    End
    // each scintilla window can run this 1 time only
    Move (ResizeArray(KeyBindings,0)) To KeyBindings
    Set psClearKeyBindings to KeyBindings
  End_Procedure
  // Is sent when the end of the files was reached.
  Procedure onFindWrapping
  End_Procedure

  Procedure DoFindWrapping
    Integer iRet
    Move False To Found // Sets the std. Found Indicator.
    Get Msg_onFindWrapping    to iRet
    If iRet Begin
      Procedure_Return iRet
    End
    If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrap Begin
      Procedure_Return 1
    End
    If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrapMsg Begin
      If (Window_Handle(Self)) Eq (GetFocus()) Begin
        Send Info_Box "Not Found." // Not so pretty but prevents object from loosing the focus.
      End
      Procedure_Return 1
    End
    If (piFindWrapMode(Self)) Eq FindWrapMode_WrapSilent Begin
      Procedure_Return 0
    End
    If (piFindWrapMode(Self)) Eq FindWrapMode_WrapAsk Begin
      Get YesNo_Box "End of file reached restart from the beginning?" to iRet
      If iRet Eq MBR_Yes ;
        Procedure_Return 0
      Else ;
        Procedure_Return 1
    End
  End_Procedure

  // Should be overwrited, returns True if Ok or false if failed
  Function CM_InitCodeList Handle hCodeList Returns Integer
    Function_Return 0
  End_Function
  // This procedure should Set codetip text etc...
  Procedure OnCodeTip
  End_Procedure
  Procedure OnCodeTipInitialize
  End_Procedure
  Procedure OnCodeTipUpdate
  End_Procedure
  Procedure OnCodeTipCancel
  End_Procedure
  Function DoCodeListInit Handle hCodeList Returns Integer
    Function_Return 0
  End_Function
  Procedure CM_CodeListItemSelected String sItem Integer iRefVal
  End_Procedure

  Function LoadAutoCompleteImage String sBitmap Integer iType Returns Boolean
    Boolean bOK
    Pointer pImage
    UInteger uSize uWidth uHeight
    UInteger iErr iVoid
    String  sFileName
    String  sError

    Move False to bOK
    Move (sBitmap+Character(0)) To sFileName
    Move 0 To uWidth
    Move 0 To uHeight
    Move 0 To uSize
    Move 0 To pImage
    //Move (SciLoadPngAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight),AddressOf(uSize))) To iErr
    Move (SciLoadImageAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight))) To iErr
    If (iErr=0) Begin
      //Send Info_Box ("Image Width= "+Trim(uWidth)+" Height= "+Trim(uHeight)+" Size = "+Trim(uSize))
      Send EditorMessage SCI_RGBAIMAGESETWIDTH  uWidth
      Send EditorMessage SCI_RGBAIMAGESETHEIGHT uHeight
      Send EditorMessage SCI_REGISTERRGBAIMAGE  iType pImage
      Move (SciFreeRGBAImage(pImage)) To iVoid
      Move True to bOK
    End
    Else Begin
      Get SciLoadImageErrorText iErr to sError
      Send Info_Box (sError+"\nImage: "+sFileName+"\nNote that only uncompressed 24 bits and 32 bits bmp files are supported.") "Error loading CodeList image"
    End

    Function_Return bOK
  End_Function

  //
  // Scintilla calls the codelist feature autocomplete.
  // When this is called the array phoCodelistHandler has our list that we want to display
  // sWord is the word to select on
  //
  Procedure ShowAutoComplete String sWord
    Boolean bAutoCompleteActive
    Boolean bHasBmp
    Handle  hoArray
    Integer iChar
    Integer iItem
    Integer iCount
    String  sItem
    String  sBitmap
    String  sList
    String  sSelect

    //Get EditorMessage SCI_AUTOCACTIVE to bAutoCompleteActive  // doesn't work already gone before recursion
    Get pbIsCodelistActive to bAutoCompleteActive
    If (bAutoCompleteActive=False) Begin
      Send EditorMessage SCI_AUTOCSETIGNORECASE True
      Send EditorMessage SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE
      //Send EditorMessage SCI_AUTOCSETORDER SC_ORDER_PERFORMSORT // we sort on our end as we need to know the item number
      Send EditorMessage SCI_AUTOCSETSEPARATOR (Ascii("|"))
      Send EditorMessage SCI_CLEARREGISTEREDIMAGES
      Move "" To sList
      Get phoCodelistHandler to hoArray
      Send SortAscending of hoArray  // Our list MUST be ascending order or the autocomplete won't work!
      Get Codelist_Item_Count of hoArray to iCount
      If (iCount>0) Begin
        For iItem from 0 To (iCount-1)
          Get Codelist_value  of hoArray Item iItem To sItem
          Get Codelist_bitmap of hoArray item iItem to sBitmap
          Move False to bHasBmp
          If (sBitmap<>"") Begin  // bitmap exists and found
            Get LoadAutoCompleteImage sBitmap (iItem+1) to bHasBmp
          End
          If (bHasBmp) Begin
            Move (sList+sItem+"?"+Trim(iItem+1)) To sList
          End
          Else Begin
            Move (sList+sItem) to sList
          End
          If (iItem<(iCount-1)) Begin // separator character is pipe symbol, add everywhere except on last
            Move (sList+"|") To sList
          End
        Loop
        Move (Length(sWord)) To iChar
        Send EditorMessage SCI_AUTOCSHOW iChar (AddressOf(sList))
        Move (String(sWord)+Character(0)) To sSelect
        Send EditorMessage SCI_AUTOCSELECT 0 (AddressOf(sSelect))
      End
    End
  End_Procedure

  //
  // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter
  // counting and doesn't look nice in presenting in tooltip et al.
  // We reduce the spaces here to just one.
  //
  Procedure StripConcatenatingSpaces String ByRef sText
    While (Pos("  ",sText)<>0)
      Move (Replaces("  ",sText," ")) To sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
    Loop
  End_Procedure

  //
  // Takes care of the argument highlighting
  //
  Procedure CodetipParameterHighLight
    Integer iType
    Integer iPos
    Integer iLastPos
    Integer iArg
    Integer iSelectedArg
    Integer iHighlightStart
    Integer iHighlightEnd
    String  sTip

    Move 0 To iHighLightStart
    Move 0 To iHighLightEnd
    Get psCodeTipCurrent to sTip
    If (sTip<>"") Begin
      Move (Pos(Character(10),sTip)) To iPos
      If (iPos>0) Begin
        Move (Left(sTip,iPos-1)) to sTip // first line has the expression/function/method, next line is the description
      End
      Send StripConcatenatingSpaces (&sTip)        // no double spaces as it confuses the argument counting logic
      Get piCodeTipArgument to iSelectedArg
      Get piCodeTipType to iType
      If (iType=C_TIPTYPE_EXPRESSION) Begin
        Move (Pos("(",sTip)) To iPos // start first argument
        Move 0 To iArg
        While (iPos>0)

          If (iSelectedArg=iArg) Begin
            Move (iPos+1) to iHighLightStart
          End
          Move (Pos(",",sTip,iPos+1)) To iPos
          If (iHighLightStart<>0) Begin
            If (iPos=0) Begin
              Move (Pos(")",sTip,iHighlightStart)) to iPos
            End
            If (iPos<>0) Begin
              Move (iPos-1) To iHighLightEnd
              Move 0 To iPos
            End
          End
          Increment iArg
          If (iArg>100) Begin
            Move 0 to iPos // should not happen, but .. never loop and hang!
          End
        Loop
        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
        End
        Else Begin
          Send EditorMessage SCI_CALLTIPSETHLT 0 0
        End
      End
      Else If (iType=C_TIPTYPE_FUNCTION) Begin
        // function foo string sBar Integer iVoid Returns integer
        // function foo string sBar Integer ByRef iVoid Returns integer
        Move (Pos(" ",sTip)) To iPos // start function name
        Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above function
        Move 0 To iArg
        While (iPos>0)

          If (iSelectedArg=iArg) Begin
            Move iPos to iHighLightStart
          End
          Move (Pos(" ",sTip,iPos+1)) To iPos
          Move iPos To iLastPos
          If (iPos<>0) Begin
            Move (Pos(" ",sTip,iPos+1)) To iPos
            If (Mid(lowercase(sTip),iPos-(iLastPos+1),iLastPos+1)="byref") Begin
              Move (Pos(" ",sTip,iPos+1)) To iPos
            End
          End
          If (iHighLightStart<>0) Begin
            If (iPos=0) Begin
              Move (Length(sTip)+1) to iPos
            End
            If (iPos<>0) Begin
              Move (iPos-1) To iHighLightEnd
              Move 0 To iPos
            End
          End
          Increment iArg
          If (iArg>100) Begin
            Move 0 to iPos // should not happen, but .. never loop and hang!
          End
        Loop
        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
        End
        Else Begin
          Send EditorMessage SCI_CALLTIPSETHLT 0 0
        End
      End
      Else If (iType=C_TIPTYPE_PROCEDURE) Begin
        // procedure foo string sBar Integer iVoid Returns integer
        // procedure foo string sBar Integer iVoid
        // procedure foo string sBar Integer ByRef iVoid
        // procedure set foo string sBar Integer iVoid
        Move (Pos(" ",sTip)) To iPos // start procedure name or set
        If (Mid(lowercase(sTip),3,iPos+1)="set") Begin
          Move (Pos(" ",sTip,iPos+1)) To iPos // at start procedure name
        End
        Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above method
        Move 0 To iArg
        While (iPos>0)

          If (iSelectedArg=iArg) Begin
            Move iPos to iHighLightStart
          End
          Move (Pos(" ",sTip,iPos+1)) To iPos
          Move iPos To iLastPos
          If (iPos<>0) Begin
            Move (Pos(" ",sTip,iPos+1)) To iPos
            If (Mid(lowercase(sTip),iPos-(iLastPos+1),iLastPos+1)="byref") Begin
              Move (Pos(" ",sTip,iPos+1)) To iPos
            End
          End
          If (iHighLightStart<>0) Begin
            If (iPos=0) Begin
              Move (Length(sTip)+1) to iPos
            End
            If (iPos<>0) Begin
              Move (iPos-1) To iHighLightEnd
              Move 0 To iPos
            End
          End
          Increment iArg
          If (iArg>100) Begin
            Move 0 to iPos // should not happen, but .. never loop and hang!
          End
        Loop
        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
        End
        Else Begin
          Send EditorMessage SCI_CALLTIPSETHLT 0 0
        End
      End
    End
  End_Procedure

  // Codetip requested: return the type of Codetip to display or CM_TIPSTYLE_NONE to not displaying a codetip
  // 12.2.2003 BP
  Procedure DoCodeTip
    Boolean bCallTipActive
    Integer iOk
    Integer iPos
    Integer iChar
    String  sTip

    Get EditorMessage SCI_CALLTIPACTIVE to bCallTipActive // calltip active on screen
    If (bCallTipActive) Begin
      If (piCodeTipType(Self)=C_TIPTYPE_EXPRESSION) Begin
        Get EditorMessage SCI_GETCURRENTPOS to iPos
        Get EditorMessage SCI_GETCHARAT (iPos-1) to iChar
        If (iChar=Ascii(")")) Begin
          Send DoCodeTipCancel
        End
        Else Begin
          Send DoCodeTipUpdate
        End
      End
      Else Begin
        Send DoCodeTipUpdate
      End
    End
    Else Begin

      Get msg_OnCodeTip to iOk
      If (iOk) Begin
        Get psCodeTipCurrent to sTip
        If (sTip<>"") Begin
          Send StripConcatenatingSpaces (&sTip)   // no gap of more than one space
          Move (Replaces("//",sTip,"\n")) To sTip // display description on a new line
          Move (Replaces("\n",sTip,Character(10))) To sTip
          Move (sTip+"  ") To sTip // HACK to make the tip a tiny bit wider at the end, so that the bold argument does not cut anything off at the end.
          // Cannot calc afterwards as dynamic bolding is done on existing tooltip.
          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
        End
      End
    End
  End_Procedure
  // Codetip is to be displayed: return TRUE if changes applied to the codetip structure or FALSE if not
  // 12.2.2003 BP
  Procedure DoCodeTipInitialize   Integer lParam
    Integer iOk
    Get msg_OnCodeTipInitialize to iOk
    If (iOk) Begin
      Send CodetipParameterHighLight
      Procedure_Return 1
    End
    Procedure_Return 0
  End_Procedure

  // Reset CodeTip Properties
  Procedure CodeTipReset
    Set piCodeTipHighlightedStart  to -1
    Set piCodeTipHighlightedEnd    to -1
    Set piCodeTipArgument          to -1
    //
    Set psCodeTipCurrent           to ""
    Set piCodeTipCurrLine          to -1
  End_Procedure

  // Codetip is to be removed: return FALSE if the codetip should be removed or TRUE if to codetip should remain visible
  // 12.2.2003 BP
  Procedure DoCodeTipCancel
    Integer iOk
    //
    Send EditorMessage SCI_CALLTIPCANCEL
    // Reset CodeTip Properties
    Send CodeTipReset
    Get msg_OnCodeTipCancel to iOk
    Procedure_Return iOk
  End_Procedure
  // Codetip is to be updated (position, values...): return TRUE if changes applied to the codetip structure or FALSE if not
  // 12.2.2003 BP
  Procedure DoCodeTipUpdate
    Integer iOk
    Get msg_OnCodeTipUpdate to iOk
    If (iOk) Begin
      Send CodetipParameterHighLight
      Procedure_Return 1
    End
    Procedure_Return 0
  End_Procedure

  Procedure RestoreTipBeforeAutoComplete
    Boolean bCallTipActive
    Integer iPos
    String  sTip

    If (pbHadTipBeforeAutocomplete(Self)) Begin
      Set pbCodetipRequest to True
      Set pbHadTipBeforeAutocomplete to False
      Get EditorMessage SCI_CALLTIPACTIVE To bCallTipActive
      If (bCallTipActive=False) Begin
        // We first need to put the tooltip back up on the screen again
        Get psCodeTipCurrent to sTip
        If (sTip<>"") Begin
          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
        End
      End
      Send CodetipParameterHighLight
    End
  End_Procedure

  // Remove the codelist window
  // 12.2.2003 BP
  Procedure CancelCodelist
    Send EditorMessage SCI_AUTOCCANCEL
    Send RestoreTipBeforeAutoComplete
  End_Procedure

  // Remove the codetip window
  // 12.2.2003 BP
  Procedure CancelCodetip
    Set pbCodeTipRequest  To False
    Send EditorMessage SCI_CALLTIPCANCEL
  End_Procedure

  Procedure Request_Cancel
    Boolean bCodeListActive

    Get pbIsCodelistActive to bCodeListActive
    If (bCodeListActive) Begin
      Send CancelCodeList
      Send DoCodeListCancel
    End
  End_Procedure

  // BP CodeList Support
  // DoCodeList: Notification that a Codelist is requested
  // Connect the VDF-Codelist Object to the delivered codelist handle, adjust some features
  // and fill in the requested lines.
  Procedure DoCodeList            Integer lParam
    Integer iRet
    Handle hCodeList

    If (not(phoCodeListHandler(Self))) Begin
      Procedure_Return False
    End

    Move 0 To hCodeList
    Get DoCodeListInit hCodeList to iRet
    If (iRet) Begin
      Procedure_Return True
    End
    Procedure_Return False
  End_Procedure

  Procedure OnCodelistCancel
  End_Procedure

  // DoCodelistCancel
  // Notification that the listview was canceled without selecting a value
  Procedure DoCodeListCancel
    Send OnCodelistCancel
    Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
    Set pbIsCodelistActive To False
    Procedure_Return False // return FALSE to remove the listview from screen
  End_Procedure


  // DoCodelistSelMade
  // Notification that a item was selected within the listview
  // Originally called DoCodelistSelMade, renamed as we have different parameters
  Procedure DoAutoCompleteSelection Pointer aText
    String sItem sText
    Integer iRet iItem iRefVal iRetVal

    If (not(phoCodeListHandler(Self))) Begin
      Procedure_Return False
    End

    If (aText<>0) Begin
      Move (PointerToString(aText)) To sText
    End
    Else Begin
      Move "" to sText
    End
    If (sText<>"") Begin
      Send CancelCodelist // we handle insertion of the value by ourself
      Move sText to sItem // we still need the iRefVal as it is a helper variable for finding the relevant parts
      Get Codelist_find_item of (phoCodeListHandler(Self)) sText To iItem
      If iItem Ne -1 Begin
        Get Codelist_value of (phoCodelistHandler(Self)) iItem to sItem  // get the item text of the selected item
        Get piRefValue of (phoCodelistHandler(Self)) to iRefVal
        Get msg_CM_CodeListItemSelected sItem iRefVal to iRetVal
      End
    End
    Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
  End_Procedure

  // To be filled in at higher class
  Function TranslateCharacter Integer iKey Returns Integer
    Function_Return 0
  End_Function

  // To be filled in at higher class
  Function ShouldTranslateCharacter Integer iKeyCode Returns Boolean
    Function_Return false
  End_Function


  Procedure doCharacterTranslation Pointer aText Integer iLength
    Boolean bTranslateChar
    Integer iKey
    Integer iNewKey
    String  sText
    String  sNewChar

    If (pbFileLoading(Self)=false) Begin // don't translate text when loading from disk
      If (aText<>0) Begin
        Move (PointerToString(aText)) To sText
      End
      Else Begin
        Move "" to sText
      End
      If (sText<>"" and iLength=1) Begin
        Move (Ascii(sText)) To iKey
        Get ShouldTranslateCharacter iKey to bTranslateChar
        If (bTranslateChar) Begin
          Get TranslateCharacter iKey to iNewKey
          If (iNewKey<>0) Begin
            Move (Character(iNewKey)) To sNewChar
            Send EditorMessage SCI_CHANGEINSERTION 1 (AddressOf(sNewChar))
          End
        End
      End
    End
  End_Procedure

  Procedure UpdateUIBlockSelectEdit
    Boolean bBlockSelect
    Integer iCaretPos iAnchorPos

    If (pbBlockSelectBackspace(Self)) Begin
      // bugfix
      Send EditorMessage SCI_SETSELECTIONMODE SC_SEL_RECTANGLE
    End
    Get EditorMessage SCI_SELECTIONISRECTANGLE to bBlockSelect
    //Set pbBlockSelectActive to bBlockSelect
    If (bBlockSelect) Begin
      Get EditorMessage SCI_GETRECTANGULARSELECTIONANCHOR to iAnchorPos
      Get EditorMessage SCI_GETRECTANGULARSELECTIONCARET  to iCaretPos
      Set piBlockSelectAnchorPos to iAnchorPos
      Set piBlockSelectCaretPos  to iCaretPos
    End
    If (bBlockSelect=False) Begin
      Set piBlockSelectAnchorPos to 0
      Set piBlockSelectCaretPos  to 0
    End
  End_Procedure

  // tab works, but not when only space characters at first line, then it is a mess.
  // But if I move the selection to the first column it works again. It's a bit ugly, but it works
  Procedure BlockSelectTabKeyBugfix
    Boolean bNeedBugfix
    Integer iAnchorPos iCaretPos iColumn
    Integer iLine iStartLine iEndLine
    String  sLine sValue

    Move True to bNeedBugfix
    Get piBlockSelectAnchorPos to iAnchorPos
    Get piBlockSelectCaretPos  to iCaretPos
    // As it is a block select, the start column is the end column and thus we check the text of
    // all selected lines from column 0 to iColumn
    Get EditorMessage SCI_GETCOLUMN  iAnchorPos to iColumn
    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
    For iLine from iStartLine to iEndLine
      Get Value item iLine to sLine
      Move (Left(sLine,iColumn)) To sValue
      If (sValue<>"") Begin
        Move False To bNeedBugfix
        Move iEndLine to iLine
      End
    Loop
    If (bNeedBugfix) Begin
      Send BlockSelectAdjustSelectionColumn iAnchorPos iCaretPos (-iColumn)
    End
  End_Procedure

  // If you do a block select and then start typing it should remove the selected block of text
  // before it does the multiline text type.
  Procedure BlockSelectRemoveTextBlockBugfix
    Integer iCaretPos iAnchorPos
    Integer iStartLine iStartColumn
    Integer iEndLine   iEndColumn

    Get piBlockSelectAnchorPos to iAnchorPos
    Get piBlockSelectCaretPos  to iCaretPos
    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn

    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
    If (iStartColumn<>iEndColumn) Begin
      Send EditorMessage SCI_DELETEBACK  //<--  this actually works ?\_(?)_/?
    End
  End_Procedure

  //
  // Move the block selection by iAdjust positions to the left or right
  //
  Procedure BlockSelectAdjustSelectionColumn Integer iAnchorPos Integer iCaretPos Integer iAdjust
    Integer iStartLine iStartColumn
    Integer iEndLine   iEndColumn

    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn

    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
    If (iStartColumn=iEndColumn) Begin
      //
      Get EditorMessage SCI_FINDCOLUMN iStartLine (iStartColumn+iAdjust) to iAnchorPos
      Get EditorMessage SCI_FINDCOLUMN iEndLine   (iEndColumn+iAdjust)   to iCaretPos
      // move selection to the new position
      Send EditorMessage SCI_SETRECTANGULARSELECTIONANCHOR iAnchorPos
      Send EditorMessage SCI_SETRECTANGULARSELECTIONCARET  iCaretPos
    End
  End_Procedure

  Procedure BlockSelectEdit Integer iChar Longptr lParam
    Integer iCaretPos iAnchorPos
    Integer iStartLine iStartColumn iLine
    Integer iEndLine   iEndColumn iRet
    String  sChar

    Move (character(iChar)) To sChar
    Get piBlockSelectAnchorPos to iAnchorPos
    Get piBlockSelectCaretPos  to iCaretPos

    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn

    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
    If (iStartColumn=iEndColumn) Begin
      If (iStartLine>iEndLine) Begin
        Send SwapIntegerVariables (&iStartLine) (&iEndLine)
      End
      // easy type over multiple lines, cursor is on endline and will type itself
      Send EditorMessage SCI_BEGINUNDOACTION
      For iLine from iStartLine to (iEndLine-1)
        Get CM_InsertText sChar iLine iStartColumn to iRet
      Loop
      Send EditorMessage SCI_ENDUNDOACTION
      //
      Get EditorMessage SCI_FINDCOLUMN iStartLine (iStartColumn+1) to iAnchorPos
      Get EditorMessage SCI_FINDCOLUMN iEndLine   (iEndColumn+1)   to iCaretPos
      Send EditorMessage SCI_SETRECTANGULARSELECTIONANCHOR iAnchorPos
      Send EditorMessage SCI_SETRECTANGULARSELECTIONCARET  iCaretPos
      //Send BlockSelectAdjustSelectionColumn iAnchorPos iCaretPos 1  // this one doesn't work, don't quite understand why
    End
  End_Procedure

  // BP

  Procedure onBeforeFloatingMenu
  End_Procedure
  Procedure onAfterFloatingMenu
  End_Procedure

  // Is sent when a WM_Notify with NM_RCLICK occusrs.
  // I use it to implement the Popup of the floating_poup_menu.
  Procedure DoRightClick Longptr lParam
    If (Floating_Menu_Object(Self)) Ne 0 Begin
      Set phoServedObject of (Floating_menu_object(Self)) to Self
      Send OnBeforeFloatingMenu
      Send Popup  to (Floating_Menu_Object(Self))
      Send OnAfterFloatingMenu
      Procedure_Return 1
    End
  End_Procedure

  Procedure onSetFocus
  End_Procedure
  Procedure onKillFocus
  End_Procedure
  Procedure onChange
  End_Procedure


  Procedure OnCharAdded
  End_Procedure

  Procedure OnStyleNeeded
  End_Procedure

  Procedure OnSavePointReached
  End_Procedure

  Procedure OnSavePointLeft
  End_Procedure

  Procedure OnDoubleClick
    //Send Info_Box "double click"
  End_Procedure
  
  // If you double click on a brace character then we select
  // the text underneath until the matching brace character
  Procedure MatchingBracesSelectText Integer iPos
    Boolean bIsBraceChar
    Boolean bIsComment
    Boolean bIsMatch
    Integer iChar
    Integer iMatchPos
    Integer imaxRestyle
    
    Get EditorMessage SCI_GETCHARAT iPos 0 to iChar
    Get IsBraceCharacter iChar To bIsBraceChar
    If (bIsBraceChar) Begin
      Get StyleAtPosIsComment iPos To bIsComment
      If (bIsComment=false) Begin
        Move 0 to imaxReStyle
        Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
        Get IsValidBraceCharMatch iPos iMatchPos to bIsMatch
        If (bIsMatch) Begin
          Send EditorMessage SCI_SETEMPTYSELECTION iMatchPos  // remove existing selections
          Send EditorMessage SCI_SETSELECTIONSTART iPos
          Send EditorMessage SCI_SETSELECTIONEND   (iMatchPos+1)
        End
      End
    End
  End_Procedure
  
  Procedure DoDoubleClick Integer iPos
    Send MatchingBracesSelectText iPos
    Send OnDoubleClick
  End_Procedure

  Procedure OnModified
  End_Procedure
  
  Procedure onUpdateCursorPosition
  End_Procedure
  
  Procedure onStatusMarginClicked Integer iLine
  End_Procedure

  Procedure OnMarginClick Integer iMargin Integer iLine
    Boolean bFoldPoint

    Case Begin
      Case (iMargin=MARGIN_CODE_FOLDING)
        Get LineHasFoldPoint iLine To bFoldPoint
        If (bFoldPoint) Begin
          Send EditorMessage SCI_TOGGLEFOLD iLine
        End
        Case Break
      Case (iMargin=MARGIN_STATUS)
        Send onStatusMarginClicked iLine
        Case Break
    Case End
  End_Procedure

  Procedure OnMarginRightClick
  End_Procedure

  //
  // Brace matching wasn't done on typing only when navigating, so we now call it from onCharAdd
  //
  Procedure BraceMatchingCharAdded
    Boolean bShowMatchingBraces
    Integer iPos
    Get pbShowMatchingBraces to bShowMatchingBraces
    If (bShowMatchingBraces) Begin
      Get EditorMessage SCI_GETCURRENTPOS to iPos
      Send ShowMatchingBraces iPos
    End
  End_Procedure

  Procedure onQuickInfo Integer iPos String ByRef sTooltip
  End_Procedure
  
  Procedure ShowScopeQuickInfo Integer iPos String ByRef sTooltip
    Integer iLine
    Integer iMatchLine
    Integer iColumn
    Integer eStyle
    String  sWord
    String  sLine

    Get EditorMessage SCI_GETSTYLEAT       iPos 0 To eStyle
    Get EditorMessage SCI_LINEFROMPOSITION iPos 0 To iLine
    Get EditorMessage SCI_GETCOLUMN        iPos 0 To iColumn
    Get CM_GetWord iLine iColumn To sWord
    If (sWord<>"" and eStyle=SCE_DF_SCOPEWORD) Begin
      Move (lowercase(sWord)) To sWord
      If (sWord="end_procedure" or sWord="end_function" or sWord="end_object" or sWord="end_class") Begin
        Get EditorMessage SCI_GETFOLDPARENT iLine 0 To iMatchLine
        If (iMatchLine) Begin
          Get CM_GetLine iMatchLine to sLine
          Move (Ltrim(sLine)) To sTooltip
        End
      End
    End
  End_Procedure
  
  Procedure doQuickInfo Integer iPos
    String  sTip
    
    Get psCodeTipCurrent To sTip
    Send ShowScopeQuickInfo iPos (&sTip)
    Send onQuickInfo iPos (&sTip)
    If (iPos>-1 and sTip<>"") Begin
      Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
    End
  End_Procedure

  Procedure Notify Longptr wParam Longptr lParam
    Integer iRet
    Integer iCode
    Integer iLine
    Integer iPos
    tSCNotification SCNotify

    Move 0 To SCNotify.line // variable exists and is initialized
    Move (CopyMemory(AddressOf(SCNotify),lParam,SizeOfType(tSCNotification))) to iRet
    Move SCNotify.Nmhdr.uCode  to iCode

    // Trap Events...________________________
    Move 0 to iRet

    Case Begin
      Case (iCode=SCN_STYLENEEDED)
        Send OnStyleNeeded
        Case Break
      Case (iCode=SCN_CHARADDED)
        Send OnCharAdded
        Get Msg_onChange                    to iRet
        Get Msg_DoKeyAction SCNotify.ch lParam    to iRet
        If (pbBlockSelectActive(Self)) Begin
          Send BlockSelectEdit SCNotify.ch lParam
        End
        Send BraceMatchingCharAdded
        Case Break
      Case (iCode=SCN_SAVEPOINTREACHED   )
        Send OnSavePointReached
        Get Msg_DoModifiedChange            to iRet
        Case Break
      Case (iCode=SCN_SAVEPOINTLEFT      )
        Send OnSavePointLeft
        Get Msg_DoModifiedChange            to iRet
        Case Break
      Case (iCode=SCN_MODIFYATTEMPTRO    )
        //Send Info_Box "Document cannot be changed, it is readonly"
        Case Break
      Case (iCode=SCN_KEY                )  //  Used on GTK+ because of some problems with keyboard focus and is not sent by the Windows version.
        //Get Msg_DoKeyAction iCode lParam    to iRet
        Send none
        Case Break
      Case (iCode=SCN_DOUBLECLICK        )
        Send DoDoubleClick SCNotify.position
        Case Break
      Case (iCode=SCN_UPDATEUI           )
        If (SCNotify.updated iAnd (SC_UPDATE_SELECTION+SC_UPDATE_V_SCROLL)) Begin
          Get EditorMessage SCI_GETCURRENTPOS to iPos
          Send onNavigate iPos
        End
        If (SCNotify.updated iAnd SC_UPDATE_SELECTION) Begin
          Send UpdateUIBlockSelectEdit
        End
        Case Break
      Case (iCode=SCN_MODIFIED           )
        Send OnModified
        If (SCNotify.modificationType iAnd (SC_MOD_INSERTTEXT+SC_MOD_DELETETEXT)) Begin
          Send LineCountChanged
          If ((SCNotify.modificationType iAnd SC_STARTACTION)=0) Begin
            If (SCNotify.modificationType iAnd (SC_PERFORMED_REDO+SC_PERFORMED_UNDO+SC_PERFORMED_USER)) Begin
              Get Msg_onChange                    to iRet
            End
          End

        End
        If (SCNotify.modificationType = SC_MOD_INSERTCHECK) Begin
          Send doCharacterTranslation SCNotify.Text SCNotify.length
        End
        Case Break
      Case (iCode=SCN_MACRORECORD        )
        Case Break
      Case (iCode=SCN_MARGINCLICK        )
        Get EditorMessage SCI_LINEFROMPOSITION SCNotify.position to iLine
        Send OnMarginClick SCNotify.margin iLine
        Case Break
      Case (iCode=SCN_NEEDSHOWN          )
        Case Break
      Case (iCode=SCN_PAINTED            )
        Case Break
      Case (iCode=SCN_USERLISTSELECTION  )
        Case Break
      Case (iCode=SCN_URIDROPPED         )
        Case Break
      Case (iCode=SCN_DWELLSTART         )
        Send doQuickInfo SCNotify.position
        Case Break
      Case (iCode=SCN_DWELLEND           )
        Send CancelCodetip
        Case Break
      Case (iCode=SCN_ZOOM               )
        Case Break
      Case (iCode=SCN_HOTSPOTCLICK       )
        Case Break
      Case (iCode=SCN_HOTSPOTDOUBLECLICK )
        Case Break
      Case (iCode=SCN_CALLTIPCLICK       )
        Case Break
      Case (iCode=SCN_AUTOCSELECTION     )
        Get Msg_DoAutoCompleteSelection SCNotify.Text to iRet
        Case Break
      Case (iCode=SCN_INDICATORCLICK     )
        Case Break
      Case (iCode=SCN_INDICATORRELEASE   )
        Case Break
      Case (iCode=SCN_AUTOCCANCELLED     )
        Send DoCodeListCancel
        Case Break
      Case (iCode=SCN_AUTOCCHARDELETED   )
        Send none
        Case Break
      Case (iCode=SCN_HOTSPOTRELEASECLICK)
        Case Break
      Case (iCode=SCN_FOCUSIN            )
        Send onUpdateCursorPosition
        Get Msg_onSetFocus                  to iRet
        Case Break
      Case (iCode=SCN_FOCUSOUT           )
        Get Msg_onKillFocus                 to iRet
        Case Break
      Case (iCode=SCN_AUTOCCOMPLETED     )
        // Only called when using built-in selection method, we do it manually
        Case Break
      Case (iCode=SCN_MARGINRIGHTCLICK   )
        Send OnMarginRightClick
        Case Break
      Case (iCode=SCEN_CHANGE            )
        Send none
        Case Break
      Case (iCode=SCEN_SETFOCUS          )
        Case Break
      Case (iCode=SCEN_KILLFOCUS         )
        Case Break
    Case End

    //// SVN CodeTip Support
    //If iCode Eq CMN_CODETIPINITIALIZE   Get Msg_DoCodeTipInitialize lParam to iRet
    //If iCode Eq CMN_CODETIPCANCEL       Get Msg_DoCodeTipCancel     to iRet
    //If iCode Eq CMN_CODETIPUPDATE       Get Msg_DoCodeTipUpdate     to iRet
    //// SVN
    //
    //If iCode Eq CMN_PROPSCHANGE         Get Msg_onPropsChange               to iRet
    //If iCode Eq CMN_OVERTYPECHANGE      Get Msg_onOvertypeChange            to iRet
    //If iCode Eq CMN_REGISTEREDCMD       Get Msg_DoRegisteredCmd   lParam    to iRet
    //If iCode Eq CMN_FINDWRAPPED         Get Msg_DoFindWrapping              to iRet
    //If iCode Eq CMN_DRAWLINE            Get Msg_DoDrawLine        lParam    to iRet
    Procedure_Return iRet
  End_Procedure

  // Delivers line and row (complex) from the given position
  // -> Position local to the Edit!
  Function LineRowFromRelativePosition Integer iY Integer iX  Returns Integer
    Integer iLine iCol iRet
    Integer iRow
    Move -1 To iRow
    If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin
      Get CM_GetSelFromPoint iX iY        to iRet
      Move (piSelStartLine(Self))         to iLine
      Move (piSelStartCol (Self))         to iCol
      Move (MAKEWPARAM(iCol,iLine)) To iRow
    End
    Function_Return iRow
  End_Function

  // Same as above but uses absolute Screen coordinates.
  Function LineRowFromAbsolutePosition Integer iY Integer iX  Returns Integer
    Integer iPY iPX
    Integer iRow
    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
    Move (Low(iPy))                     to iPx
    Move (Hi(iPy))                      to iPy
    Move (iY-iPy)                       to iY
    Move (iX-iPx)                       to iX
    Get LineRowFromRelativePosition iY iX to iRow
    Function_Return iRow
  End_Function

  // Delivers the Line and Col under the Mouse Cursor.
  Function LineRowUnderMouseCursor Returns Integer
    Integer iX iY iRet
    Integer iRow
    tWinPoint wPoint

    Move 0 to wPoint.x
    Move (GetCursorPos(AddressOf(wPoint)))     to iRet
    Move wPoint.x to iX
    Move wPoint.y to iY
    Get LineRowFromAbsolutePosition iY iX to iRow
    Function_Return iRow
  End_Function


  // To find the Scope for Inserting a Text.
  Function GetScopeAboveFromLine Integer iLine Returns Integer
    Integer iEnd
    Integer iScope
    String  sLine

    Move 0  To iScope
    Move "" To sLine
    Move 0  To iEnd
    Repeat
      If (Trim(sLine)) Ne "" ;
        Move 1 to iEnd
      If iLine Lt 0 ;
        Move 1 to iEnd
      If not iEnd ;
        Get value item iLine to sLine
      Decrement iLine
    Until (iEnd)
    If (sLine<>"") ;
      Move (Pos(Trim(sLine),sLine)-1) To iScope
    Function_Return iScope
  End_Function
  
  Procedure NormalizeCaseRange Integer iLine Integer iCol Integer iLen
    Boolean bChanged
    Integer iStartPos iEndPos
    Integer iStartLine iStopLine
    
    If (pbNormalizeCase(Self)) Begin
      Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
      Move (iStartPos+iLen) To iEndPos
      Send EditorMessage SCI_COLOURISE iStartPos iEndPos  // apply style to the inserted text!
      Move iLine To iStartLine
      Get EditorMessage SCI_LINEFROMPOSITION iEndPos 0 to iStopLine
      For iLine from iStartLine to iStopLine
        Get LineNormalizeCase iLine False To bChanged
      Loop
    End
  End_Procedure


  // Inserts a Text at this Position.
  // Understands commands like:
  //  \n  ... New Line
  //  \t  ... Keep ScopeLevel
  //  \s  ... New Line and InsertColumn
  Procedure InsertTextAtPosition Integer iLine Integer iCol String sTxt
    Integer iRet iScopeCol
    Integer iNewLineCount iMarker
    String  sCR
    Move 0 To iNewLineCount
    Append sCR (Character(13)) (Character(10))
    If (Left(sTxt,2)) Eq "\s" Begin
      Move iCol              to iScopeCol
    End
    Else Begin
      Get GetScopeAboveFromLine iLine             to iScopeCol
    End
    While (Pos("\n",sTxt))
      Increment iNewLineCount
      Move (Replace("\n",sTxt,sCR))               to sTxt               // TO insert a new Line.
    Loop
    Move (Replaces("\t",sTxt,Repeat(" ",iScopeCol))) to sTxt               // To keep the scope level.
    If (Left(sTxt,2)) Eq "\s" Begin                                        // Insert in new line.
      Move (Replace("\s",sTxt,Append("",Repeat(" ",iCol))))   to sTxt    // TO insert a new Line.
      Move 0                                                  to iCol
    End
    Move (CM_InsertText(Self,sTxt,iLine,iCol))                  to iRet
    Send NormalizeCaseRange iLine iCol (Length(sTxt))
    For iMarker from 0 To (iNewLineCount-1)
      Set psLineOnEnter to ""
      Increment iLine
      Send LineChangedMark iLine
    Loop
  End_Procedure

  // Tries to insert a text after the character with the given relative
  // position (Used for Drag and Drop)
  Procedure Request_InsertTextAfterPosRel Integer iY Integer iX String sTxt
    Integer iRet iLine iCol

    If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin // Only if the Coord. are over the editspace.
      Get CM_GetSelFromPoint iX iY    to iRet
      If iRet Begin
        Move (piSelStartLine(Self))         to iLine
        Move (piSelStartCol (Self))         To iCol
        Send GotoLine iLine // Move the cursor to the line where you insert the text
        Send InsertTextAtPosition iLine iCol sTxt
      End
    End
  End_Procedure




  // Tries to insert a text after the character with the given absolut
  // position (Used for Drag and Drop)
  Procedure Request_InsertTextAfterPosAbs Integer iY Integer iX String sTxt
    Integer iPY iPX
    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
    Move (Low(iPy))                     to iPx
    Move (Hi(iPy))                      to iPy
    Move (iY-iPy)                       to iY
    Move (iX-iPx)                       to iX
    Send Request_InsertTextAfterPosRel iY iX sTxt
  End_Procedure
  // Inserts text under the mouse cursor position.
  Procedure Request_InsertTextUnderMouseCursor String sTxt
    Integer iRet iX iY
    tWinPoint wPoint

    Move 0 to wPoint.x
    Move (GetCursorPos(AddressOf(wPoint)))     to iRet
    Move wPoint.x to iX
    Move wPoint.y to iY
    Send Request_InsertTextAfterPosAbs iY iX sTxt
  End_Procedure

  Function HitTestCurrentMouse Returns Integer
    Integer iRet iX iY iPy iPx
    tWinPoint wPoint
    Move 0 to wPoint.x
    Move (GetCursorPos(AddressOf(wPoint))) to iRet
    Move wPoint.x to iX
    Move wPoint.y to iY
    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
    Move (Low(iPy))                     to iPx
    Move (Hi(iPy))                      to iPy
    Move (iY-iPy)                       to iY
    Move (iX-iPx)                       to iX
    Function_Return (Hi(CM_HitTest(Self,iX,iY)))
  End_Function

  //
  // For re-indenting when a line is a comment line or if it is a DataFlex image line it should not do
  // the extra indent. So we have to figure out what it is...
  //
  Function LineIsComment Integer iLine String sLine Returns Boolean
    Boolean bIsComment
    Integer iPos
    Integer iFirstChar

    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
    Move (iPos+iFirstChar) To iPos
    Get StyleAtPosIsComment iPos To bIsComment
    Function_Return bIsComment
  End_Function

  //
  // For re-indenting when a line is a multiline string line it should not do
  // the extra indent. So we have to figure out what it is...
  //
  Function LineIsMultiLineString Integer iLine String sLine Returns Boolean
    Boolean bIsMultiLineString
    Integer iPos
    Integer iChar
    Integer iFirstChar
    Integer iLastChar

    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
    Move (iPos+iFirstChar) To iChar
    Get StyleAtPosIsString iChar To bIsMultiLineString // if first char is a string.. it's a multiline string (du'h)
    If (bIsMultiLineString=False) Begin
      Move (Length(sLine)) To iLastChar // last character on line is at this pos
      Move (iPos+iLastChar) To iChar
      Get StyleAtPosIsString iChar To bIsMultiLineString // if last char is a string.. it's probably a multiline string too :)
    End
    Function_Return bIsMultiLineString
  End_Function

  //
  // For re-indenting a DataFlex image should not be touched, so we cannot treat it the same as a comment
  //
  Function LineIsDfImage Integer iLine String sLine Returns Boolean
    Boolean bIsImage
    Integer iPos
    Integer iFirstChar

    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
    Move (iPos+iFirstChar) To iPos
    Get StyleAtPosIsDfImage iPos To bIsImage
    Function_Return bIsImage
  End_Function
    
  Function LineIsGotoLabel Integer iLine String sLine Returns Boolean
    Boolean bIsLabel
    Integer iPos
    Integer iColonPos
      
    Move False To bIsLabel
    Get PreParsedLine iLine To sLine
    If (Right(sLine,1)=":") Begin
      Move True to bIsLabel
      Move (Trim(sLine)) to sLine
      Move (Pos(":",sLine)-1) to iColonPos
      For iPos from 1 to iColonPos
        If (Mid(sLine,1,iPos)=" ") Begin
          Move False To bIsLabel
          MOve iColonPos To iPos // stop
        End
      Loop
    End
    Function_Return bIsLabel
  End_Function


  Function ReIndentLineIndentation Integer iLine Integer iLineCount Integer iTabSize Boolean bUseTabs Integer ByRef iPrevLevel Returns String
    Boolean bIsComment
    Boolean bIsLabel
    Boolean bIsMultiLineString
    Integer iFoldLevel
    Integer iNextLevel
    Integer iLevel
    Integer iIndentWanted
    Integer iFirstChar
    String  sLine
    String  sIndent

    If ((iLineCount-1)>iLine) Begin
      //Send GotoLine (iLine+1) // the line has to be visible in order to be able to get the fold level
    End
    Get LineFoldLevel iLine To iFoldLevel
    If (iLine<(iLineCount-1)) Begin
      Get LineFoldLevel (iLine+1) to iNextLevel
    End
    Else Begin
      Move 0 to iNextLevel
    End
    Move iFoldLevel To iLevel
    If (iNextLevel<iFoldLevel) Begin
      Move iNextLevel to iLevel
    End
    Get Value Item iLine To sLine
    Get LineIsComment iLine sLine to bIsComment // a multi-line comment is also a code fold point, don't indent on that.
    If (bIsComment) Begin
      Move false To bIsComment
      If (iLine>0) Begin
        Get Value Item (iLine-1) to sLine
        Get LineIsComment (iLine-1) sLine to bIsComment
      End
      If (bIsComment) ;
        Move iPrevLevel to iLevel
      Get Value Item iLine to sLine  // get the correct line data again.
      If (Left(sLine,2)="//" and pbReindentStudioCommentOut(Self)) Begin // if a comment starts at column 0, leave it alone
        Move 0 To iLevel                                                 // (for Df Studio comment-out feature, see feature # 126)
        Move False To bIsComment
      End
    End
    Get LineIsMultilineString iLine sLine To bIsMultiLineString
    If (bIsMultiLineString) Begin
      If (bIsMultiLineString) ;
        Move iPrevLevel to iLevel
    End
    Move (iLevel*iTabSize) To iIndentWanted
    Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) To sIndent
    Move (Length(sLine)-length(LTrim(sLine))+1) To iFirstChar // first non white space character on line is at this pos
    // For macro's preserve the existing indentation
    If (Mid(sLine,1,iFirstChar)="#" or (bIsMultiLineString)) Begin
        Move (Left(sLine,iFirstChar-1)) To sIndent
    End
    Move (LTrim(sLine))  To sLine
    // It is my opinion that a use should always be at the start of a line
    // so I make exceptions for indenting on that and set the indent to ""
    If (lowercase(Left(sLine,4))="use ") Begin
        Move "" To sIndent
    End
    // On labels and goto's you don't want indentation either
    If (bIsMultiLineString=False) Begin
    Get LineIsGotoLabel iLine sLine To bIsLabel
    If (bIsLabel) Begin
      Move "" To sIndent
      End
    End
    Move iLevel To iPrevLevel
    //Showln iLine " -> " iFoldLevel " [-->] " iNextLevel " result {" sIndent "}" sLine

    Function_Return sIndent
  End_Function

  // Standard Interface Support
  // By SVN on 23/03/2017
  Function CanCut Returns Integer
    Function_Return (CM_CanCut(Self))
  End_Function
  Function CanCopy Returns Integer
    Function_Return (CM_CanCopy(Self))
  End_Function
  Function CanPaste Returns Integer
    Function_Return (CM_CanPaste(Self))
  End_Function
  Function CanUndo Returns Integer
    Function_Return (CM_CanUndo(Self))
  End_Function
  Function CanRedo Returns Integer
    Function_Return (CM_CanRedo(Self))
  End_Function
  Function CanDelete Returns Integer
    Function_Return (CM_CanCut(Self))
  End_Function
  Procedure Redo
    Integer iRet
    Get CM_Redo to iRet
  End_Procedure
  Procedure Undo
    Integer iRet
    Get CM_Undo to iRet
  End_Procedure
  Procedure Cut
    Integer iRet
    Get CM_Cut to iRet
  End_Procedure
  Procedure Delete
    Integer iRet
    Get CM_Cut to iRet
  End_Procedure
  Procedure Copy
    Integer iRet
    Get CM_Copy to iRet
  End_Procedure
  Procedure Paste
    Integer iRet
    Get CM_Paste to iRet
  End_Procedure
  //

  // Should Start the Properties.
  Procedure Properties
    //        Integer iRet
    //Move (CM_ExecuteCmd(Self,CMD_PROPERTIES,0)) to iRet
    //Send Info_Box "Start configuration screen for editor component"
    //Send PopupEditorSettingsDialog Self
  End_Procedure

End_Class

Define CM_NewFileName   For "Untitled"  // sometimes ver useful.