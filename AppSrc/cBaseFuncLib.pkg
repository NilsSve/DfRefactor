// Copyright (c) 2018 Nils Svedmyr, RDC Tools International
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to Do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in All
// copies or substantial portions of the Software.
//
// THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
// IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
// FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
// LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
// OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
// SOFTWARE.

Use Windows.pkg
Use seq_chnl.pkg
Use cSCWsGrid.pkg
Use cRegex.pkg
Use RefactorConstants.h.pkg 
Use WsGlobalFunctions.pkg
Use RefactorStatusPanel.pkg

#IFNDEF ghoRefactorEngine
    Global_Variable Handle ghoRefactorEngine
    Move 0 to ghoRefactorEngine
#ENDIF

#IFNDEF ghoRefactorFuncLib
    Global_Variable Handle ghoRefactorFuncLib
    Move 0 to ghoRefactorFuncLib
#ENDIF

Register_Function phoRemoveUnusedLocals Returns Handle
Register_Function phoReportUnusedSourceFiles Returns Handle
Register_Function pSCLanguage tSCLanguage param Returns tSCLanguage  

Declare_Datafile SysFile
Declare_Datafile FunctionsA

Class cBaseFuncLib is a cObject
    Procedure Construct_Object
        Forward Send Construct_Object

        Property Integer piLastErr 0
        Property Boolean pbErr False

        Property Handle phoEditor
        Property Integer piTabSize
        Property Boolean pbReadOnly False  // If = True, no changes will be made and only shows statistics.
        Property String[] pasOtherLogFiles

        Property tRefactorSettings pRefactorSettings
        //
        Property Boolean pbToggleState True
//        Property Boolean pbInRepeatLoop False
        Property Boolean pbInCommand False
        Property Boolean pbIsInPage False
        Property Boolean pbInProcedure False
        Property Boolean pbInFunction False  
        Property Boolean pbInClass False
        Property Boolean pbInStruct False
        // Old school string contants that ends each line with a semi-colon (;)
        // Used in conjunction with the tTokenizer bHasEndSemiColon member.
        Property Boolean pbIsInSemiColonMultiLineString False
        // New DF 23 multi-line comments. Starts with a /* and ends with */
        Property Boolean pbIsInDF23MultiLineComment False
        // New DF 23 school multi-line strings
        Property Boolean pbIsInDF23MultiLineString False
        Property Boolean pbIsOpenString False
        Property Boolean pbIsInSingleQuote False

        // Contains all info from the current "sLine" source.
        // *** To be used by all cRefactorFuncLib functions ***
        Property tTokenizer pTokenizer

        // All commands from the manual list in this class.
        Property String[] pasCommands
        // These are commands that has been depriated (removed) since DF 18.1
        Property String[] pasRemovedCommands
        // Commands that also exists as functions.
        Property String[] pasCommandFunctions
        Property String[] pasLocalVariableTypes
        Property String[] pasLocalVariableArrayTypes
        Property String[] pasSystemBooleans
        // Data from the Scintilla editor. See ScintillaParameters.dg
        // Scoped words are; Begin/End While/Loop, Procedure/End_Procedure etc.
        Property String[] pasScopeStart
        // The closing scoped part. There is a 1-1 relationship between the two arrays.
        Property String[] pasScopeEnd
        // All keywords from the Scintilla editor.
        Property String[] pasKeyWords
        // All operators from the Scintilla editor.
        Property String[] pasOperators

        // Properties for the RemoveProjectObjectStructure function:
        Property Boolean pbProjectObjectStructureStart False
        Property Boolean pbProjectObjectStructureEnd False
        Property Boolean pbRegisterAllObjectsStart False
        Property Boolean pbRegisterAllObjectsEnd False
        Property String[] pasObjectNames

    End_Procedure

    Procedure ARRAY_SEARCH_FUNCTIONS
    End_Procedure
    //
    // As this is an array compare function it needs to be on top (double underscores in name)
    // It returns true if there is an equal value to sSearchText in the string array.
    Function __FindStringArrayContent tQuotedString QuotedOverwrite tQuotedString QuotedSearch Returns Integer  
        If (Lowercase(QuotedOverwrite.sOverwrite) = Lowercase(QuotedSearch.sOverwrite)) ;
            Function_Return (EQ)
    End_Function
    
    Function __FindExpressionArrayContains tExpression ExpressionVal tExpression ExpressionSearch Returns Integer  
        If (Lowercase(ExpressionVal.sExpression) contains Lowercase(ExpressionSearch.sExpression)) ;
            Function_Return (EQ)
    End_Function
                
    Function _StringConstantExpressionReplace tTokenizer ByRef TokenizerData String sExpression String ByRef sExpressionWS String ByRef sExpressionNP String sOrg Boolean bParanthesis Integer iStop Returns String
        Integer iSize iCount iPos iStartPos iEndPos iPosNS iLength
        String sContent sOverStrikeLine sOverStrikeLineNS sText
        Boolean bFound
        
        Move (SizeOfArray(TokenizerData.asStringConstant)) to iSize
        If (iSize = 0) Begin
            Function_Return sExpression
        End

        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        Get TrimInsideSpaces sOrg to sOverStrikeLineNS 
        If (bParanthesis = True) Begin
            Move (Pos(sExpression, sOrg)) to iPos
            // The expression array has been stripped for concatenating spaces,
            // so we need to do the same here to be able to "find matches" below.
            If (iPos = 0) Begin
                Move (Pos(sExpression, sOverstrikeLineNS)) to iPos
            End
            Get ReplaceParanthesis sExpression to sExpressionNP
        End
        Else Begin
            Move sExpression to sExpressionNP
            Move (Pos(sExpressionNP, sOrg)) to iPos
            // The expression array has been stripped for concatenating spaces,
            // so then we need to do the same here to be able to "find matches" below.
            If (iPos = 0) Begin
                Move (Pos(sExpressionNP, sOverstrikeLineNS)) to iPos
            End
        End

        Decrement iSize
        For iCount from 0 to iSize
            Move TokenizerData.asStringConstant[iCount].sContent  to sContent
            Move TokenizerData.asStringConstant[iCount].iStartPos to iStartPos
            Move TokenizerData.asStringConstant[iCount].iEndPos   to iEndPos
            
            If (iStartPos > iPos and iEndPos <= (Length(sExpressionWS) + iPos)) Begin
                Move (Length(sExpressionWS) - Length(sExpression)) to iPosNS
                If (iPosNS <> 0) Begin
                    Move (iStartPos - iPosNS) to iStartPos
                End
                
                Move (sContent <> '""' and sContent <> "''") to bFound
                If (bFound = True) Begin
                    Move (iStartPos >= iPos and (iPos <= iEndPos)) to bFound
                End
                If (bFound = True) Begin                                     
                    Move (iPos + Length(sExpression)) to iLength
                    If (iStartPos < iLength and iStartPos > iPos and bFound = True and iStartPos < iStop) Begin 
                        If (bParanthesis = True) Begin 
                            Move (Overstrike(sContent, sExpression, iStartPos - iPos +1)) to sExpression
                        End
                        Else Begin
                            If (Left(sExpressionNP, 1) <> "(") Begin
                                Decrement iPos
                            End
                            Move (Overstrike(sContent, sExpression, (iStartPos - iPos))) to sExpression
                            Move sExpression to sExpressionNP 
                            Move sExpression to sExpressionWS
                        End
                    End
                End
            End
        Loop
        Function_Return sExpression
    End_Function
                
    // *** System (private) Messages ***
    //
    // This is called from _InitializeFuncLib and fills some keyword string array properties.
    Procedure _AddAllKeyWords
        String[] Empty asScopeStart asScopeEnd asKeywords asOperators asCommands asOther
        tSCLanguage SCLanguage

        Get pSCLanguage of ghoApplication to SCLanguage

        // Scoped words
        Move SCLanguage.saScopeStart to asScopeStart
        Get _LowercaseArrayValues asScopeStart to asScopeStart
        Move (SortArray(asScopeStart)) to asScopeStart
        Set pasScopeStart to asScopeStart

        Move SCLanguage.saScopeStop to asScopeEnd
        Get _LowercaseArrayValues asScopeEnd to asScopeEnd
        Move (SortArray(asScopeEnd)) to asScopeEnd
        Set pasScopeEnd to asScopeEnd

        // Keywords
        Move SCLanguage.saKeywords to asKeywords
        Get _LowercaseArrayValues asKeywords to asKeywords
        Move (SortArray(asKeywords)) to asKeywords
        Set pasKeyWords to asKeywords

        // Operators
        Move SCLanguage.saOperators to asOperators
        Get _LowercaseArrayValues asOperators to asOperators
        Move (SortArray(asOperators)) to asOperators
        Set pasOperators to asOperators

        // Command list used for testing against inline if/else statements et. al.
        // Note that it is not a complete command list and that we should be careful
        // about commands that might be used as functions or in functions!
        // For example, it is by intention that none of the variable declaration commands
        // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
        //
        // Standalone commands can end on a end of line, such as Abort.
        // Other commands need more parameters and in such case we can improve our success rate
        // by adding a space character.
        //
        Send _CreateDecpreatedCommandsArray
        Send _CreateLocalVariableTypes
        Send _CreateCommandFunctionArray
        Send _CreateSystemBooleansArray

        // Using keywords from Scintilla instead of our own list (above).
        Move asKeywords to asCommands
        Move (SortArray(asCommands)) to asCommands
        Get _RemoveCommandsArray to asOther
        
        // Remove commands that starts with a hash-mark: "#", from pasCommands,
        // as we use the helper function - _IsCommandDeclaration.
        Get _RemoveHashMarkCommands asCommands to asCommands
        // Remove local variable types;
        Get _RemoveKeyWordsFromArray asCommands (pasLocalVariableTypes(Self)) to asCommands
        // Remove all functions that are also commands from pasCommands
        Get _RemoveKeyWordsFromArray asCommands (pasCommandFunctions(Self)) to asCommands
        // Remove "other" keywords from pasCommands
        Get _RemoveKeyWordsFromArray asCommands asOther to asCommands
        // Remove system booleans from pasCommands
        Get _RemoveKeyWordsFromArray asCommands (pasSystemBooleans(Self)) to asCommands
        
        Set pasCommands to asCommands  
    End_Procedure

    // Commands that were removed after DF 18.2:
    Procedure _CreateDecpreatedCommandsArray
        String sCommands
        String[] asRemovedCommands
        
        Move (Lowercase("accept,backfield,clear_option,endgroup,entagain,entdisplay,enter, ;
            enterend,entergroup,entermode,entfind,entsfind,entry,entupdate,file$mode,find$page,;
            format,format$range,getxy,help,inherit_screen,inkey,inkey$,os$call, ;
            outclose,outfile,page,report,reportend,section,set_option,setchange,sub_page, ;
            screen_optimize,get_cursor_visible,set_cursor_visible,compute_screen_crc,set_video_mode,get_video_mode, ;
            set_file_owner,get_file_owner,compiler_desktop_method_warnings")) to sCommands
            Move (StrSplitToArray(sCommands, ",")) to asRemovedCommands
            
        Set pasRemovedCommands to asRemovedCommands
    End_Procedure
    
    // Local variable declarations
    Procedure _CreateLocalVariableTypes
        String[] asLocalVariableTypes
        Move (StrSplitToArray(CS_VarTypes, ";")) to asLocalVariableTypes
        Get _LowercaseArrayValues asLocalVariableTypes to asLocalVariableTypes
        Move (SortArray(asLocalVariableTypes)) to asLocalVariableTypes
        Set pasLocalVariableTypes to asLocalVariableTypes
        Set _LocalVariableArrayTypes to asLocalVariableTypes
    End_Procedure

    // Commands that also exists as DataFlex functions;
    Procedure _CreateCommandFunctionArray
        String[] asCommandFunctions
        String sCommandFunctions

        Move (Lowercase("Append,Ascii,Character,Else,If,Insert,Left,Length,Mid,Pad,Pos,Repeat,Replace,Right,Trim,Uppercase")) to sCommandFunctions
        Move (StrSplitToArray(sCommandFunctions, ",")) to asCommandFunctions
        
        Set pasCommandFunctions to asCommandFunctions
    End_Procedure

    // DataFlex system booleans
    Procedure _CreateSystemBooleansArray
        String[] asSystemBooleans
        String sSystemBooleans
        
        Move (Lowercase("err,false,finderr,found,is,local,seqeof,seqeol,true")) to sSystemBooleans
        Move (StrSplitToArray(sSystemBooleans, ",")) to asSystemBooleans
        Set pasSystemBooleans to asSystemBooleans
    End_Procedure

    Procedure _InitTabSize
        Integer iID iTabSize

        Move FunctionsA.ID to iID
        Clear FunctionsA
        Move CS_EditorReIndent to FunctionsA.Function_Name
        Find eq FunctionsA.Function_Name
        If (Found = False) Begin
            Error ("Could not find function:" * CS_EditorReIndent +"\nin the 'Functions' table. It is used for setting the tab-size. Cannot continue.")
            Abort
        End
        Move (Trim(FunctionsA.Parameter)) to iTabSize
        // Reset record buffert:
        If (iID <> 0) Begin
            Move iID to FunctionsA.ID
            Find Eq FunctionsA.ID
        End
        Set piTabSize to iTabSize
    End_Procedure

    // Helper message for _ClearFirstCompoundBeforeMethod
    // Overwrites the string content with blanks up to the iPos position.
    Procedure _WipeUntilPosition String ByRef sLine Integer iPos
        Integer iChar
        If (iPos > 0) Begin
            For iChar from 1 to (iPos - 1)
                Move (Overstrike(" ", sLine, iChar)) to sLine
            Loop
        End
    End_Procedure

    // Must be send before the refactoring process is started
    // It initializes necessary parameters.
    Procedure _InitializeFuncLib
        String[] asEmtpty
        Set pasOtherLogFiles to asEmtpty
        Send SaveErrorState
        Send _InitTabSize
        Send ClearFuncLibProperties
    End_Procedure

    Procedure _ClearRefactoringProperties
        Set pbIsInPage to False        
        Set pbInProcedure to False
        Set pbInFunction to False
        Set pbInCommand to False
        Set pbInClass to False
        Set pbInStruct to False
        Set pbIsInSemiColonMultiLineString to False
        Set pbIsInDF23MultiLineComment to False 
        Set pbIsInDF23MultiLineString to False 
        Set pbIsOpenString to False
        Set pbIsInSingleQuote to False
    End_Procedure
    
    // Sets the pasLocalVariableArrayTypes array property based on content
    // from a pasLocalVariableTypes array.
    // The pasLocalVariableTypes array contains variable declarations like; string, integer...
    // The pasLocalVariableArrayTypes will be filled wtih declarations like; string[], string[][], integer[], integer[][] etc.
    Procedure Set _LocalVariableArrayTypes String[] asLocalVariableTypes
        Integer iSize iCount
        String[] asLocalVariableArrayTypes
        String sVariable

        Move (SizeOfArray(asLocalVariableTypes)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asLocalVariableTypes[iCount] to sVariable
            Append sVariable "[]"
            Move sVariable to asLocalVariableArrayTypes[-1]
            Append sVariable "[]"
            Move sVariable to asLocalVariableArrayTypes[-1]
        Loop
        Move (SortArray(asLocalVariableArrayTypes)) to asLocalVariableArrayTypes
        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes
    End_Procedure

    // Note: It must only be the code part of a source line that is passed here.
    //       Use the Tokenizer helper function first.
    Function _AddExpressionParenthesis tTokenizer TokenizerData String ByRef sLine Returns Boolean
        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
        Boolean bFound bChanged bStartOperators bSecondCommand bWhile
        Integer iPos iPos2

        Move sLine to sText
        Move sLine to sOrg
        // Do nothing if a Constrain command.
        Get _HasCommand TokenizerData.sOverstrikeLine (CS_Constrain + " ") to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move "" to sStart
        Move "" to sLast
        Get _FetchExpression TokenizerData.aExpressions eLeftExpression1 to sExpression
        If (Trim(sExpression) = "") Begin
            Get _FetchExpression TokenizerData.aExpressions eLeftExpression2 to sExpression
        End
        If (Trim(sExpression) = "") Begin
            Get _FetchExpression TokenizerData.aExpressions eOfExpression to sExpression
            If (Trim(sExpression) = "") Begin
                Get _FetchExpression TokenizerData.aExpressions eToTexpression to sExpression
            End
        End
        If (Trim(sExpression) = "") Begin
            Function_Return False
        End
        Move (Pos(sExpression, sText)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sLine, (iPos - 1))) to sStart
            If (sStart <> "") Begin
                Move (Replace(sStart, sLine, "")) to sText
                Move (Replace(sExpression, sText, "")) to sLast
            End
        End

        If (sExpression <> "") Begin
            Move sExpression to sText
            Get TrimInsideSpaces sExpression to sExpression
            Move (Trim(sExpression)) to sExpression
            Get _HasDoubleExpression sExpression to bFound
            Move (Left(sExpression, 1)) to sChar
            If (sChar <> "(" or bFound = True) Begin
                Move ("(" + sExpression + ")") to sExpression
            End
            If (sText = sLine) Begin
                Move sExpression to sLine
            End
        End
        If (sStart <> "" or sLast <> "") Begin
            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
        End

        Function_Return (sLine <> sOrg)
    End_Function

    // Helper function for the BreakupCompoundStatement function.
    {Visibility = Private}
    Function _TestCommands String sTest Returns Integer
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommands

        Move 0 to iPos
        Get pasCommands to asCommands
        Move (SizeOfArray(asCommands)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommands[iCount] to sCommand
            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it, after it not always
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop

        Function_Return iPos
    End_Function

    // With our refactoring logic if a line starts with if, else or on_key then the logic won't "see"
    // send/get/set as the first word and that complicates our detection.
    // What this does is simply overwrite everything with spaces before our methods if
    // there is such a compound statement.
    // The variable sLine is not always lowercase.
    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
        Integer iPos
        String  sLtrimLine sOrgLine

        Move sLine to sOrgLine
        Move (Lowercase(LTrim(sLine))) to sLTrimLine
        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
            // A line that starts with an "if" or "else" can still call a method
            Move (Pos("send ", Lowercase(sLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos("get ", Lowercase(sLine))) to iPos
            End
            If (iPos = 0) Begin
                Move (Pos("set ", Lowercase(sLine))) to iPos
            End
            Send _WipeUntilPosition (&sLine) iPos
        End

        Function_Return (sLine <> sOrgLine)
    End_Function
   
    // ToDo: BooleanIndicator.FirstBoolean & BooleanIndicator.SecondBoolean
    //       is only used by ChangeLegacyIndicators!
    // *** How about changing the struct into a boolean array of indicator variables? ***
    // 
    Function _ConstructDoubleBooleanExpression tTokenizer TokenizerData Returns String
        String sExpression sToken
        Boolean bNot
        
        If (TokenizerData.BooleanIndicator.FirstBoolean.bDoubleBoolean = False and;
            TokenizerData.BooleanIndicator.SecondBoolean.bDoubleBoolean = False) Begin
            Function_Return ""
        End                   
        
        Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sExpression
        Get ReplaceParanthesis sExpression to sExpression
        Move ("(" + String(sExpression) * "and") to sExpression
        
        Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
        If (TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True) Begin
            Append sExpression " " sToken ")"
        End
        Else Begin
            Get ReplaceParanthesis sToken to sToken
            Move TokenizerData.BooleanIndicator.SecondBoolean.bHasNot to bNot
            If (bNot = True) Begin
                Append sExpression " " CS_Not "("
            End                                  
            Append sExpression sToken ")"
            If (bNot = True) Begin
                Append sExpression ")"
            End                                  
        End
        Function_Return sExpression
    End_Function
    
    // Counts total number of source lines for the passed file name.
    // It does *not* count empty or commented lines.
    // it does *not* count COM proxy class files generated by the Studio for COM/ActiveX components.
    Function _CountNumberOfLines String sFullSourceFileName String sParameter Returns Integer
        Integer iLines iCh
        String sLine
        Boolean bExists bBlank bIsCOM

        File_Exist sFullSourceFileName bExists
        If (bExists = False) Begin
            Send UserError ("Couldn't find file:" * String(sFullSourceFileName) * "No source lines added to counter for this file.")
            Function_Return 0
        End

        Get _IsDataFlexCOMProxyClassesFile sFullSourceFileName to bIsCOM
        If (bIsCOM = True) Begin
            Function_Return 0
        End
        Move 0 to iLines

        Get OpenInput sFullSourceFileName to iCh
        If (iCh < 0) Begin
            Function_Return 0
        End
        While (SeqEof = False)
            Readln channel iCh sLine
            Get IsCommentLineOrBlank sLine to bBlank
            If (bBlank = False) Begin
                Increment iLines
            End
        Loop

        Send CloseInput iCh
        Function_Return iLines
    End_Function

    // DF 23 multi-line *comment* style start with a /* and ends with a */
    // Just fill the line with hash-marks (#) and return.
    // The tokenizer members bIsMultiLineCommentStart & bIsMultiLineCommentEnd will
    // be Set by the Tokenizer Function, after this function has been called.
    Function _DF23CommentOverwrite String sLine Returns String
        Boolean bIsInDF23MultiLineComment
        String sOverstrikeLine
        Integer iLength

        Move "" to sOverstrikeLine
        Get pbIsInDF23MultiLineComment to bIsInDF23MultiLineComment
        If (bIsInDF23MultiLineComment = False) Begin
            Get _IsDF23CommentStart sLine to bIsInDF23MultiLineComment
            If (bIsInDF23MultiLineComment = False) Begin
                Get _IsDF23CommentEnd sLine to bIsInDF23MultiLineComment
            End
        End
        If (bIsInDF23MultiLineComment = True) Begin
            Move (Length(sLine)) to iLength
            // Just overstrike the content
            Move (Repeat("#", iLength)) to sOverstrikeLine
        End
        Function_Return sOverstrikeLine
    End_Function

    Function _FixSimpleExpressionParanthesis String sExpression Returns String
        String sParenthesis
        Boolean bFound bHasStartParanthesis bHasEndParanthesis
        Integer iPos iItem iLeftParanthesis iRightParanthesis
        
        Move (Trim(sExpression)) to sExpression
        If (sExpression = "") Begin
            Function_Return sExpression
        End                      
        
        Get _HasTokenParanthesis sExpression to bFound
        If (bFound = False) Begin
            Move ("(" + String(sExpression) + ")") to sExpression
        End
        Else Begin     
            Move (Left(sExpression, 1) = "(")  to bHasStartParanthesis 
            Move (Right(sExpression, 1) = ")") to bHasEndParanthesis
            Get _NumberOfParanthesis sExpression (&iLeftParanthesis) to iRightParanthesis
            If (iLeftParanthesis = iRightParanthesis) Begin
                If (bHasStartParanthesis = False) Begin
                    Move ("(" + String(sExpression) + ")") to sExpression
                End
            End
            Else Begin
                If (iLeftParanthesis < iRightParanthesis) Begin
                    Move (FillString("(", (iRightParanthesis - iLeftParanthesis))) to sParenthesis
                    Move (sParenthesis + String(sExpression)) to sExpression
                End                                                         
                If (iLeftParanthesis > iRightParanthesis) Begin
                    Move (FillString(")", (iLeftParanthesis - iRightParanthesis))) to sParenthesis
                    Move (sExpression + String(sParenthesis)) to sExpression
                End
            End
        End
        
        Function_Return sExpression
    End_Function   

    Function _ExpressionTail tTokenizer ByRef TokenizerData String sCode Returns String
        Boolean bFound bFirst bParanthesis
        Integer iLength iCount iSpaceCount iLeftParanthesis iRightParanthesis iParenthesisCount iPos
        String sChar sTail sKeyWord
        String[] asArray
        tToken TokenData
        
        Move "" to sTail
        Move False to bFound 
        Move False to bFirst  
        Move 0 to iSpaceCount
        Move 0 to iParenthesisCount
        // We migh have a sCode like e.g. "Gt   (SYS.APDATE + 31) Error 107"
        //    which in case we wan't to break after the right paranthesis ")".
        //    But *not* with expressions like "Eq  iB Move (Trim (FlexErrs.Error_Descr)) to sData",
        //    in case we only want the "Eq  iB" part.
        Get _NumberOfParanthesis sCode (&iLeftParanthesis) to iRightParanthesis
        Move (iLeftParanthesis > 0 or iRightParanthesis > 0) to bParanthesis 
        If (bParanthesis = True) Begin
            Move (StrSplitToArray(sCode, " ")) to asArray
            Move asArray to TokenizerData.asLineTokens
            Get _FirstKeyWordInArray TokenizerData.sOverstrikeLine asArray to TokenData
            If (TokenData.iStartPos <> 0) Begin
                Move (Pos(TokenData.sCode, sCode) -1) to iLength
                If (iLength <> 0) Begin
                    Move (Left(sCode, iLength)) to sCode
                End
            End
        End
        Move 0 to iParenthesisCount
        
        Move (Pos(" to ", Lowercase(sCode))) to iPos
        If (iPos = 0) Begin
            Move (Pos(" of ", Lowercase(sCode))) to iPos
        End
        If (iPos <> 0) Begin
            Move (Left(sCode, iPos)) to sCode
        End
        Move (Trim(sCode)) to sCode
        Move (Length(sCode)) to iLength
        
        For iCount from 1 to iLength
            Move (Mid(sCode, 1, iCount)) to sChar
            Append sTail sChar
            If (bParanthesis = False) Begin
                If (sChar = " ") Begin
                    Increment iSpaceCount    
                End
                Else Begin
                    If (iSpaceCount > 0) Begin
                        If (bFirst = True) Begin
                            Move True to bFound
                            Move (Length(sTail)) to iLength
                            Move (Left(sTail, iLength -1)) to sTail
                            Move (Length(sCode)) to iCount        
                        End
                        Else Begin
                            Move True to bFirst
                        End
                    End  
                    Move 0 to iSpaceCount
                End
            End
            Else Begin
                If (sChar = ")") Begin
                    Increment iParenthesisCount
                    If (iParenthesisCount = iRightParanthesis) Begin
                        Move iLength to iCount    
                    End
                End
            End
        Loop
        
        Function_Return (Trim(sTail))
    End_Function 
    
    // Returns the first and last position of an expression for the passed sOverStrikeLine param.
    // Returns -1 if no parenthesis expression was found.
    Function _ExpressionExtractorWithParenthesis String sOverStrikeLine Integer ByRef iStartPos Returns Integer
        Integer iEndPos iLength iPos iItem iCount iSize
        String sExpression sCommand sToken
        String[] asArray asCommands
        
        Move (Pos("(", sOverStrikeLine)) to iStartPos
        If (iStartPos = 0) Begin
            Function_Return -1
        End

        Move (RightPos(")", sOverStrikeLine, iStartPos + 1)) to iEndPos
        If (iEndPos = 0) Begin
            Function_Return -1
        End

        Move (iEndPos - iStartPos - 1) to iLength
        Move (Mid(sOverStrikeLine, iStartPos + 1, iLength)) to sExpression

        // Finally, check that we don't have a DataFlex command in between Start & End,
        // which in case we got the wrong iEndPos, and we return -1.
        Move (StrSplitToArray(sExpression, " ")) to asArray
        Move (SizeOfArray(asArray)) to iSize
        Decrement iSize

        Move "" to sCommand
        Get pasCommands   to asCommands
        For iCount from 0 to iSize
            Move asArray[iCount] to sToken
            Move (SearchArray(sToken, asCommands, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move asCommands[iItem] to sCommand
                Move iSize to iCount // We're out of here.
            End
        Loop
        
        Move (Pos(sCommand, sOverStrikeLine)) to iPos
        If (iPos > 0 and iPos < iEndPos) Begin
            Move -1 to iEndPos
        End
        Else Begin
            Move (Pos(" to ", Lowercase(sExpression))) to iPos
            If (iPos = 0) Begin
                Move (Pos(" of ", Lowercase(sExpression))) to iPos
            End
            If (iPos <> 0 and iPos < iEndPos) Begin
                Move -1 to iEndPos
            End
        End
        
        Function_Return iEndPos
    End_Function
    
    // Takes a "sOverstrikeLine" param that *must* have been
    // "cleaned" with the _OverstrikeStrings function so string constant content
    // cannot interfere while scanning the source line for expressions.
    // Returns a struct array with the start, length & expression(s).
    // Returns an empty struct array if no opening parenthesis was found aka "(".
    // Note: This is a recursive message, if needed it calls itself.  
    //       The sOrg is the same as the sOverstrikeLine value when calling this message the first time (before any recursion).
    //       However, the sOverStrikeLine will get shorter and shorter for each recursive call
    //       and thus we also need the "sOrg" value as a reference to get the iStart value correctly.
    Procedure _ExtractExpressions String sOverStrikeLine String sOrg tTokenizer ByRef TokenizerData tExpression[] ByRef aExpressions
        String sExpression sExpressionOS sExpressionNP sChar sTest sContent sOverstrikeLineNS sExpressionWS sNose sTail sShort
        Integer iSize iSizeSC iCount iStart iStartPos iEndPos iStop iItem iClauseOpen iClauseClosed iLength iPos iPosOperator iPosNS iPosLeft iPosRight iString 
        Integer iLeftP1 iLeftP2 iRightP1 iRightP2
        Boolean bParanthesis bHasLegacyOperators bFound bIsMultiLine bCut
        tExpression[] aExpressionsEmpty
        tToken TokenData 
        String[] asArray
        
        Move (Pos("(", sOverstrikeLine) <> 0) to bParanthesis
        If (bParanthesis = False) Begin
            Get HasLegacyOperator sOverstrikeLine to bHasLegacyOperators
            If (bHasLegacyOperators = False) Begin
                Function_Return aExpressionsEmpty
            End
        End
        
        Get HasLegacyOperatorPos sOverstrikeLine to iPosOperator
        If (bParanthesis = False and iPosOperator <> 0) Begin
            Move (Pos("(", sOverstrikeLine)) to iPosLeft
            Move (RightPos(")", sOverstrikeLine)) to iPosRight
            Move (iPosOperator > iPosLeft and iPosOperator < iPosRight) to bParanthesis
        End
        
        If (bParanthesis = True) Begin
            Move "" to sExpression
            Move -1 to iStop  
            
            Get pbIsInDF23MultiLineString to bIsMultiLine
            If (bIsMultiLine = False) Begin
                Get pbIsInSemiColonMultiLineString to bIsMultiLine    
            End 
//            If (bIsMultiLine = False) Begin
//                Get _ExpressionExtractorWithParenthesis sOverStrikeLine (&iStart) to iStop
//            End
            
            If (iStop = -1) Begin
                Move (Length(sOverstrikeLine))   to iSize
                Move (Pos("(", sOverstrikeLine)) to iStart 
                If (iStart <> 0) Begin
                    Move (Mid(sOverStrikeLine, Length(sOverStrikeLine), iStart)) to sTail
                    If (Length(sTail) <> 0) Begin
                        Get _ExpressionTail (&TokenizerData) sTail to sExpression
                        Move (Pos(sExpression, sOverStrikeLine)) to iPos
                        Move (iPos + Length(sExpression)) to iStop 
                        Move sExpression to sExpressionOS
                    End
                End
                Else Begin
                    Move 0 to iClauseOpen
                    Move 0 to iClauseClosed
                    Move False to bCut
                    Move "" to sShort
                    Move (Pos("(", sOverstrikeLine)) to iStart
                    
                    For iCount from iStart to iSize
                        Move (Mid(sOverstrikeLine, 1, iCount)) to sChar
                        If (sChar = "(") Begin
                            Increment iClauseOpen
                            If (iClauseOpen = 1) Begin
                                Move iCount to iStart
                            End
                        End
                        If (sChar = ")") Begin
                            Increment iClauseClosed
                            Move iCount to iStop
                        End                                                
                        If (bIsMultiLine = False) Begin
                            If (iClauseOpen > 0 and iClauseOpen = iClauseClosed and iCount > (iPosOperator +2)) Break
                        End
                        Else Begin
                            If (iClauseOpen > 0 and iClauseOpen = iClauseClosed) Break
                        End
                    Loop
                    
                    If (bCut = True) Begin
                        Move sShort to sOverStrikeLine
                    End
                End
            End

            // If found, extract the expression and move into struct array:
            If (iStart < iStop) Begin
                Move (iStop - iStart +1) to iLength
                Move (Mid(sOverstrikeLine, iLength, iStart)) to sExpression
                Move (Trim(sExpression)) to sExpression
                Move sExpression to sExpressionWS
            End    
            Get HasLegacyOperator sExpression to bHasLegacyOperators
            If (bHasLegacyOperators = True) Begin
                Get HasLegacyOperatorPos sExpression to iPos
                Move (Left(sExpression, iPos -1))  to sNose
                Get _NumberOfParanthesis (Trim(sNose)) (&iLeftP1) to iRightP1
                Move (Mid(sExpression, Length(sExpression), iPos +2)) to sTail
                Get _NumberOfParanthesis (Trim(sTail)) (&iLeftP2) to iRightP2 
                If (iLeftP1 = iLeftP2 and iRightP1 = iRightP2) Begin
                    Move ("(" + sExpression + ")") to sExpression
                    Move sExpression to sExpressionWS
                End
            End
        End
        
        // No paranthesis but contains at least one legacy operator expression.
        Else Begin
            Get _ExtractExpressionNoParenthesis (&TokenizerData) sOverstrikeLine to sExpressionWS
            Get TrimInsideSpaces sExpressionWS to sExpression 
            If (TokenizerData.sOverstrikeLine = "") Begin
                Move sOverStrikeLine to TokenizerData.sOverstrikeLine
            End
            Move (Pos(sExpression, sOverstrikeLine)) to iStart
            If (iStart = 0) Begin
                Move (Pos(sExpressionWS, sOverstrikeLine)) to iStart
            End
            Move (Length(sOverstrikeLine)) to iStop
            // Then nothing to save
            If (iStart = 0) Begin         
                Move 2 to iStart // Lets jump past the next If statement.
                Move 1 to iStop        
                Move "" to sOverstrikeLine
            End
        End 

        // If found, extract the expression and move info to struct array:
        If (iStart < iStop and sExpression <> "") Begin
            Move sExpression to sExpressionOS
            Move (SizeOfArray(aExpressions)) to iSize
            // If we previously have replaced string content with "++++" or "____",
            // find the original text and insert in expression.
            Move (SizeOfArray(TokenizerData.asStringConstant)) to iSizeSC
            If (iSizeSC <> 0) Begin
                Get _StringConstantExpressionReplace (&TokenizerData) sExpression (&sExpressionWS) (&sExpressionNP) sOrg bParanthesis iStop to sExpression
            End 
            Else Begin
                If (bParanthesis = True) Begin
                    Get ReplaceParanthesis sExpression to sExpressionNP
                End
                Else Begin
                    Move sExpression to sExpressionNP
                End                        
            End
                
            Move 0 to iStart
            If (bParanthesis = False) Begin
                Move ("(" + Trim(sExpressionNP) + ")") to sExpression
                Move (Pos(sExpressionNP, sOrg)) to iStart
                Move (Length(sExpressionNP)) to iLength
                If (iStart = 0) Begin
                    Move (Pos(sExpressionOS, sOrg)) to iStart
                    If (iStart <> 0) Begin
                        Move (Length(sExpressionOS)) to iLength
                    End
                    Else Begin
                        Move (Pos(sExpressionWS, sOrg)) to iStart
                        If (iStart <> 0) Begin
                            Move (Length(sExpressionNP)) to iLength
                        End
                    End
                End
            End
            Else Begin
                Move (Pos(sExpression, sOrg)) to iStart
                Move (Length(sExpression)) to iLength
                If (iStart = 0) Begin
                    Move (Pos(sExpressionOS, sOrg)) to iStart
                    Move (Length(sExpressionOS)) to iLength
                End
                If (iStart = 0) Begin
                    Move (Pos(sExpressionNP, sOrg)) to iStart
                    Move (Length(sExpressionNP)) to iLength
                End
            End             
            If (iStart = 0 and (Pos(sExpressionOS, sOverstrikeLine))) Begin
                Move (Pos(sExpressionOS, sOrg)) to iStart
                Move (Length(sExpressionOS)) to iLength
            End
            Move iStart         to aExpressions[iSize].iStartPos
            Move iLength        to aExpressions[iSize].iLength
            Move sExpression    to aExpressions[iSize].sExpression
            Move sExpressionOS  to aExpressions[iSize].sExpressionOS
            Move sExpressionNP  to aExpressions[iSize].sExpressionNP
            Move sExpressionWS  to aExpressions[iSize].sExpressionWS
            
            // Finally set the expression mode:
            { EnumList="{CI_LeftExpression, eLeftExpression2, eOfExpression, eToTexpression}" }
            If (iSize = 0) Begin
                Move eLeftExpression1 to aExpressions[iSize].eExpressionMode
            End
            Else Begin
                Move eLeftExpression2 to aExpressions[iSize].eExpressionMode
            End

            Move (Pos(Lowercase(" " + CS_Of + " "), Lowercase(sOrg))) to iPos
            If (iPos <> 0 and iPos < iStart) Begin
                Move eOfExpression to aExpressions[iSize].eExpressionMode
            End
            Move (Pos(Lowercase(" " + CS_To + " "), Lowercase(sOrg))) to iPos
            If (iPos <> 0 and iPos < iStart) Begin
                Move eToTexpression to aExpressions[iSize].eExpressionMode
            End
        End
        
        // Is there more than one expression? Then call this function *recursively*!
        Move (Length(sOverstrikeLine)) to iSize   
        Move (Length(sExpression)) to iLength
        Move (Pos(sExpression, sOverStrikeLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos(sExpressionNP, sOverStrikeLine)) to iPos
            Move (Length(sExpressionNP)) to iLength
        End
        If (iPos = 0) Begin
            Move (Pos(sExpressionOS, sOverStrikeLine)) to iPos
            Move (Length(sExpressionOS)) to iLength
        End
        If (iPos = 0) Begin
            Move (Pos(sExpressionWS, sOverStrikeLine)) to iPos
            Move (Length(sExpressionWS)) to iLength
        End
        Move (Mid(sOverstrikeLine, iSize, (iPos + iLength))) to sTest
        Move (Pos("(", sTest)) to iItem
        If (iItem <> 0) Begin
            Move (Trim(sTest)) to sOverstrikeLine
            Send _ExtractExpressions sOverstrikeLine sOrg (&TokenizerData) (&aExpressions)
        End
    End_Procedure 
    
    // Finds and extracts the first legacy expression with "gt, ge, lt, le, eq or ne" operators
    // and returns that part as an expression surrounded with paranthesis.
    // Note: It only extracts the first expression in the sOverstrikeLine.
    //       You need to call it again if needed.
    Function _ExtractExpressionNoParenthesis tTokenizer ByRef TokenizerData String sOverstrikeLine Returns String
        String sText sExpression sChar sChar2 sNose sTail sKeyWord sOverstrikeLineNS // NS = "No concatenating Spaces"
        Integer iCount iLength iStart iPos
        Boolean bStart bStop bSpace bFound bSpace2 bTwo
        
        Move "" to sExpression
        If (Lowercase(sOverstrikeLine) contains (Lowercase(CS_Find) + " ") or ;
            Lowercase(sOverstrikeLine) contains (Lowercase(CS_Constrain) + " ")) Begin
            Function_Return sExpression
        End
        Get TrimInsideSpaces sOverstrikeLine to sOverstrikeLineNS
        Move (Length(sOverstrikeLineNS)) to iLength
        Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(sOverstrikeLineNS))) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sOverstrikeLineNS, Length(sOverstrikeLineNS), (iPos + 3))) to sExpression
            Function_Return (Trim(sExpression))
        End 
        
        Get HasLegacyOperatorPos sOverstrikeLine to iPos
        // Tail - Get the right part of the expression:
        If (iPos <> 0) Begin
            Move iPos to iStart
        End                    
        Else Begin
            Move iLength to iStart
        End
        
        Move (Mid(sOverstrikeLine, Length(sOverstrikeLine), (iStart + iCount))) to sText
        Move (Length(sText)) to iLength
        Move "" to sTail  
        Get _ExpressionTail (&TokenizerData) sText to sTail
        If (Pos("(", sTail) and not(Pos(")", sTail))) Begin
            Move (Append(Rtrim(sTail), ")")) to sTail
        End

        // Nose - Get the left part of the expression:
        Move 0 to iCount
        Move False to bStart
        Move False to bStop
        Move False to bSpace
        Move False to bSpace2
        Move "" to sNose
        Move (iStart -1) to iPos
        Move sOverstrikeLine to sText
        Repeat
            Move (Mid(sText, 1, (iPos - iCount))) to sChar
            Move (Insert(sChar, sNose, 1)) to sNose 
            Move (sChar = " " and bSpace2 = True) to bStop
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace 
            End
            If (sChar <> " " and bSpace = True and bSpace2 = False) Begin
                Move True to bSpace2    
            End
            Increment iCount
        Until (bStop = True or iCount > Length(sText))

        Move (sNose + String(sTail)) to sExpression 
        Function_Return (Trim(sExpression))
    End_Function

    // Takes a string like: [not Seqeof] Begin
    // and returns struct as: True, True and "(not(Seqeof))".
    // bHasBracket denotes that the expression contains a "not" as in [not Seqeof].
    // Note: It does *not* act on lines with the legacy "Indicate" in it.
    Function _ExtractIndicatorContent tTokenizer TokenizerData Returns tBooleanIndicator
        String sOverstrikeLine
        Boolean bFound bIndicateWord
        tBooleanIndicator BooleanIndicator
        tOperatorsInfo OperatorsInfo

        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        // This also checks that it isn't an array declaration.
        Get _IsIndicatorStatement sOverstrikeLine to bFound
        Move (Lowercase(sOverstrikeLine) contains Lowercase(CS_Indicate)) to bIndicateWord
        If (bFound = False and bIndicateWord = False) Begin
            Function_Return BooleanIndicator
        End
        Get _ExtractLegacyBooleanContent TokenizerData to BooleanIndicator

        Function_Return BooleanIndicator
    End_Function

    // Takes a tTokenizer struct as parameter and returns a tBooleanIndicator struct.
    // Works on strings containing e.g. "[not Seqeof] Begin"
    //                             and  "Indicate Found as bTrue"
    // If brackets "[ ]" are found they will be *removed* and the corresponding
    // struct member bHasBracket will be set to True.
    // If the "Not" keyword is found, it will be *removed* and
    // the corresponding struct member bHasNot will be set to True.
    // The first boolean is placed in the FirstBoolean struct member,
    // the next one (if any) before the "as" or "to" keyword in the second struct member,
    // and anything to the right of "as" or "to" keyword in the ToBoolean struct member.
    //
    // Iif (if-and-only-if) there are more than one variable on the right hand side of the "as"
    // keyword, those words will be surrounded with paranthesis, to make them an expression.
    // E.g. "Indicate Select as WindowIndex Eq FieldIndex"
    // will result in the ToBoolean.sCode member be populated with: "(WindowIndex Eq FieldIndex)"   
    // *Known limitation*:
    //   It can handle max two booleans within the same square bracket. E.g. "[Found Select]"
    Function _ExtractLegacyBooleanContent tTokenizer TokenizerData Returns tBooleanIndicator
        Integer iItem iSize iCount
        String sToken
        Boolean  bFound bIndicate bExpression bSystemBoolean bHasNot bTo bAs bIsListedWord bMove
        Boolean bHasLeftBracket bHasRightBracket
        tBooleanIndicator BooleanIndicator
        tOperatorsInfo OperatorsInfo

        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True or TokenizerData.bIsInImage = True) Begin
            Function_Return BooleanIndicator
        End
        // This checks if there is an "Indicate" command *or* a boolean within brackets, eg. "[Found]"
        // It also checks that it isn't an array declaration.
        Get _IsIndicatorStatement TokenizerData.sOverstrikeLine to bFound
        If (bFound = False) Begin
            Function_Return BooleanIndicator
        End

        Move (SearchArray(CS_Indicate, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP)) <> -1) ;
            to BooleanIndicator.bHasIndicateCommand

        Move False to bHasLeftBracket        
        Move False to bHasRightBracket        
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize
        
        For iItem from 0 to iSize
            // Get next token
            Move TokenizerData.asLineTokens[iItem] to sToken

            // If the sToken is a keyword, scoped word or a command, it can't be a boolean variable.
            Get _IsListedWord    sToken to bIsListedWord
            Get _IsSystemBoolean sToken to bSystemBoolean
            Get _IsTokenEqual sToken CS_To to bTo
            Get _IsTokenEqual sToken CS_As to bAs
            If (bIsListedWord = False or bSystemBoolean = True or bTo = True or bAs = True) Begin
                
                // Get next token?
                If (bTo = True or bAs = True) Begin
                    Increment iItem
                    Move TokenizerData.asLineTokens[iItem] to sToken 
                End
                
                Get HasBracketNotOperator sToken to bHasNot
                // Get next token?
                If (bHasNot = True) Begin
                    If (not(sToken contains CS_Tilde)) Begin
                        Increment iItem      
                        Move TokenizerData.asLineTokens[iItem] to sToken
                    End
                    Else Begin
                        Move (Replace(CS_Tilde, sToken, "")) to sToken
                    End
                    Move True to bHasLeftBracket
                End
                Else Begin
                    Get _HasTokenLeftBracket sToken to bHasLeftBracket
                End
                Get _HasTokenRighttBracket sToken to bHasRightBracket
                Get ReplaceBrackets sToken to sToken
                
                If (bTo = False and bAs = False) Begin
                    If (BooleanIndicator.FirstBoolean.sCode = "") Begin
                        Move bHasLeftBracket to BooleanIndicator.FirstBoolean.bHasBracket
                        Move bHasNot         to BooleanIndicator.FirstBoolean.bHasNot
                        Move sToken          to BooleanIndicator.FirstBoolean.sCode
                    End
                    Else If (BooleanIndicator.FirstBoolean.sCode <> "" and BooleanIndicator.SecondBoolean.sCode = "") Begin
                        // We don't want to save tokens that follows any sort of command. Just square bracket, Indicate & Move.
                        If (bHasLeftBracket = True or bIndicate = True or bMove = True) Begin
                            Move bHasLeftBracket to BooleanIndicator.SecondBoolean.bHasBracket
                            Move bHasNot         to BooleanIndicator.SecondBoolean.bHasNot
                            Move sToken          to BooleanIndicator.SecondBoolean.sCode
                            // Note that a square bracket, e.g. "[Found Select]", can contain two booleans.
                            // We do *not* handle more than two boolean within a bracket pair.
                            // Save info in "FirstBoolean.bDoubleBoolean" if the bracket expression contains
                            // a double-boolean e.g. '[Select ~Found]'
                            If (bHasLeftBracket = True and bHasRightBracket = True) Begin
                                Move True to BooleanIndicator.FirstBoolean.bDoubleBoolean
                            End
                        End
                        Else If (bHasRightBracket = True) Begin
                            Move True   to BooleanIndicator.FirstBoolean.bDoubleBoolean
                            Move sToken to BooleanIndicator.SecondBoolean.sCode
                            Move bHasRightBracket to BooleanIndicator.SecondBoolean.bHasBracket
                        End
                    End
                End                 
                If (bTo = True) Begin
                    Move bHasLeftBracket to BooleanIndicator.ToBoolean.bHasBracket
                    Move bHasNot         to BooleanIndicator.ToBoolean.bHasNot
                    Move sToken          to BooleanIndicator.ToBoolean.sCode
                End
                If (bAs = True) Begin
                    Move bHasLeftBracket to BooleanIndicator.AsBoolean.bHasBracket
                    Move bHasNot         to BooleanIndicator.AsBoolean.bHasNot
                    If (iItem = iSize) Begin
                        Move sToken      to BooleanIndicator.AsBoolean.sCode
                    End
                    // Do we have an expression after the "as"?
                    Else Begin          
                        Increment iItem
                        For iCount from iItem to iSize
                            Append sToken " " TokenizerData.asLineTokens[iCount]
                        Loop
                        Move (Trim(sToken)) to sToken
                        Move (Pos("(", sToken) and Pos(")", sToken)) to bExpression
                        If (bExpression = False) Begin
                            Move ("(" + sToken + ")") to sToken
                        End
                        Move sToken to BooleanIndicator.AsBoolean.sCode 
                        Move iSize to iItem // Get out of loop.
                    End
                End
                If (bHasLeftBracket = True and bHasRightBracket = True) Begin
                    Move False to bHasLeftBracket
                    Move False to bHasRightBracket
                End
            End
            Get _IsTokenEqual sToken CS_Indicate to bIndicate
            Get _IsTokenEqual sToken CS_Move     to bMove
        Loop
        
        Function_Return BooleanIndicator
    End_Function

    // Returns the first expression that exist in the passed string, that is within parenthesis (),
    // else it returns a blank string.
    Function _ExtractParenthesisExpression tTokenizer ByRef TokenizerData Returns String
        String sOverstrikeLine sExpression sChar
        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
        tOperatorsInfo OperatorInfo

        Move "" to sExpression
        Move 0  to iLeftParantheses
        Move 0  to iRightParantheses
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine

        If (sOverstrikeLine <> "") Begin
            Move (Pos("(", sOverstrikeLine)) to iStart
            Move (RightPos(")", sOverstrikeLine)) to iEnd
            Get _LogicalOperators (&TokenizerData) to OperatorInfo
            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
                Function_Return ""
            End

            Move (Length(sOverstrikeLine)) to iLength
            For iCount from iStart to iLength
                Move (Mid(sOverstrikeLine, 1, iCount)) to sChar
                If (sChar = "(" or sChar = ")") Begin
                    Add (sChar = "(") to iLeftParantheses
                    Add (sChar = ")") to iRightParantheses
                    Move iCount to iPos
                End
                If (iLeftParantheses = iRightParantheses) Break
            Loop
            Move (Mid(sOverstrikeLine, (iPos - iStart + 1), iStart)) to sExpression
        End
        Function_Return sExpression
    End_Function

    Function _ExtractFirstStringConstant String sLine Returns String
        String sStringConstant sChar
        Integer iPos iLength iCount 
        Boolean bDoubleQuote bStop
        
        Move "" to sStringConstant
        Move True to bDoubleQuote  
        Move False to bStop
        Move (Trim(sLine)) to sLine
        Move (Pos('"', sLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos("'", sLine)) to iPos
            Move False to bDoubleQuote
        End
        
        If (iPos > 0) Begin                
            Move (Length(sLine)) to iLength
            Increment iPos
            For iCount from iPos to iLength
                Move (Mid(sLine, 1, iCount)) to sChar
                If (sChar <> '"' and sChar <> "'" and bStop = False) Begin
                    Append sStringConstant sChar                       
                End
                Else Begin
                    Move (sChar = '"' or sChar = "'") to bStop
                    If (bStop = True) Begin
                        Move iLength to iCount // We're out of here.
                    End
                End
            Loop            
        End
        If (bDoubleQuote = True) Begin
            Move ('"' + String(sStringConstant) + '"') to sStringConstant
        End                                                              
        Else Begin
            Move ("'" + String(sStringConstant) + "'") to sStringConstant
        End
        Function_Return sStringConstant
    End_Function

    // Function to return expressions from the source line;
    // Only expressions in parenthesis "()" are acted upon and returned (Not square brackets)
    // Note: It fetches the class property paExpression, where the expressions was saved by the Tokenizer function.
    { EnumList="{eLeftExpression1, eLeftExpression2, eOfExpression, eToTexpression}" }
    Function _FetchExpression tExpression[] aExpressions Integer eExpressionMode Returns String
        String sExpression
        Integer iSize iCount iItem
        tExpression Expression
        Boolean bFound
        
        Move (SizeOfArray(aExpressions)) to iSize
        If (iSize = 0) Begin
            Function_Return ""
        End

        Move "" to sExpression
        Move eExpressionMode to Expression.eExpressionMode
        // Can't use searcharray as the struct has the tExpression.Expression at top,
        // which is needed elsewhere.
        //Move (SearchArray(Expression, aExpressions)) to iItem
        Decrement iSize
        For iCount from 0 to iSize
            If (aExpressions[iCount].eExpressionMode = eExpressionMode) Begin
                Move aExpressions[iCount].sExpression to sExpression
                Move iSize to iCount // We're done.
            End
        Loop

        Function_Return sExpression
    End_Function

    // Searches for the first DataFlex command in a source line.
    // Returns the Pos or 0 if not found.
    Function _FindCommand tTokenizer ByRef TokenizerData String sSource Returns Integer
        Integer iSize iPos iTest iLength
        String  sToken sLowerCase
        String[] asCommands

        Move 0 to iPos
        Get pasCommands to asCommands
        Move (Length(sSource)) to iLength
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize

        While (iLength > 0)
            Move (Pos(" ", sSource)) to iPos
            If (iPos > 0) Begin
                Move (Left(sSource, (iPos -1))) to sToken
                Move (Pos(Lowercase(sToken), Lowercase(sSource))) to iPos
                Move (Trim(Lowercase(sToken))) to sLowerCase
                Move (SearchArray(sLowerCase, asCommands)) to iTest
                // If command not found, try next "word" in sSource;
                If (iTest = -1) Begin
                    Move (Pos(" ", sSource)) to iPos
                    Move (Mid(sSource, iLength, iPos)) to sSource
                    Move (Trim(sSource)) to sSource
                    Move (Length(sSource)) to iLength
                End
                Else Begin
                    Move 0 to iLength // Jump out.
                End
            End
            Else Begin
                Move 0 to iLength // Jump out.
            End
        Loop

        Function_Return iPos
    End_Function

    // If (found) Move -> If
    // [Not Found] Get -> Get
    Function _FirstBracketToken String sLine Returns String
        String sWord
        Integer iPos iPosBracket
        Boolean bIsCommentLineOrBlank

        Get IsCommentLineOrBlank sLine to bIsCommentLineOrBlank
        If (bIsCommentLineOrBlank = True) Begin
            Function_Return ""
        End

        Move (Trim(sLine)) to sLine
        Move (Pos("]", sLine)) to iPosBracket
        Move (Pos(" ", sLine)) to iPos
        If (iPos > 0) Begin
            // Do we have a '[Not Found] Move' type of line? Then look for a second space " ".
            If (iPosBracket > iPos) Begin
                Move (Left(sLine, iPosBracket)) to sWord
            End
            Else Begin
                Move (Left(sLine, iPos - 1)) to sWord
            End
        End
        Else Begin
            // If the line consist of a single token/word
            Move sLine to sWord
        End
        Function_Return sWord
    End_Function                       
    
    Function _NumberOfParanthesis String sExpression Integer ByRef iLeftParanthesis Returns Integer
        Integer iRightParanthesis
        UChar[] uExpression
        UChar uComp
        
        Move (Trim(sExpression)) to sExpression
        Move (StringToUCharArray(sExpression)) to uExpression  
        Move (Ascii("(")) to uComp
        Move (CountArray(uComp, uExpression)) to iLeftParanthesis
        Move (Ascii(")")) to uComp
        Move (CountArray(uComp, uExpression)) to iRightParanthesis
        Function_Return iRightParanthesis
    End_Function

    Function _FixExpressionParanthesis String sLine String sExpression tTokenizer TokenizerData Returns String
        String sExpressionNo 
        Boolean bFound 
        Integer iPos iItem iLeftParanthesis iRightParanthesis
        
        Move (Trim(sExpression)) to sExpression
        If (sExpression = "") Begin
            Function_Return sExpression
        End                      
        
        Get _NumberOfParanthesis sExpression (&iLeftParanthesis) to iRightParanthesis
        If (iLeftParanthesis <> 0 and iLeftParanthesis = iRightParanthesis) Begin
            Function_Return sExpression
        End
        Get _HasTokenParanthesis sExpression to bFound
        If (bFound = False) Begin
            Move sExpression to sExpressionNo
            Move ("(" + String(sExpression) + ")") to sExpression
        End
        Else Begin
            Get ReplaceParanthesis sExpression to sExpressionNo    
        End
        
        If (TokenizerData.bHasOverstrikeChars = True) Begin  
            Get _FindExpressionArrayValue sExpression TokenizerData to iItem
            If (iItem <> -1) Begin
                Get _HasTokenParanthesis sExpression to bFound
                If (bFound = False) Begin   
                    Move sExpression to sExpressionNo
                    Move ("(" + Trim(sExpression) + ")") to sExpression
                End
                Else Begin
                    Get ReplaceParanthesis sExpression to sExpressionNo    
                End
            End
        End
            
        Move (Pos(sExpression, sLine)) to iPos 
        // If the expression in sLine has one or many spaces between the "(" and the rest of the expression we
        // won't find a match which can result in double-parentesis. So we strip the sLine from such spaces.
        If (iPos = 0) Begin
            Move ("(" + Trim(sExpressionNo) + ")") to sExpression
            Get TrimInsideSpaces sLine to sLine
        End
        Move (Pos(sExpression, sLine)) to iPos 
        If (iPos = 0) Begin    
            Move (Trim(sExpressionNo)) to sExpressionNo
            Move (Replace(sExpressionNo, sLine, sExpression)) to sLine
        End
        
        Function_Return sLine
    End_Function   
    
    // We need this as we cannot change the tExpression member order, as the first member
    // is used ty the Tokenizer function.
    Function _FindExpressionArrayValue String sExpression tTokenizer TokenizerData Returns Integer
        Integer iItem iSize iCount
        tExpression[] asExpressions
        
        Move -1 to iItem
        Move TokenizerData.aExpressions to asExpressions
        Move (SizeOfArray(asExpressions)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            If (sExpression = asExpressions[iCount].sExpression) Begin
                Move iCount to iItem
                Move iSize to iCount // Get out of here.
            End
        Loop
        
        Function_Return iItem
    End_Function
    
    // Returns True iif the source line contains a "Begin" statement.
    Function _HasBeginStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + CS_Begin) to bFound
        Function_Return bFound
    End_Function

    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
    Function _HasCommand String sOverstrikeLine String sCommand Returns Boolean
        Boolean bFound
        String sText

        Move False to bFound
        Get _RemoveEndComment sOverstrikeLine to sText
        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound

        Function_Return bFound
    End_Function

    Function _HasDoubleExpression String sExpression Returns Boolean
        Boolean bFound
        Integer iCount iSize iOpCount iParanthesis
        String sChar sOperators

        Move False to bFound
        Move 0 to iParanthesis
        Move "<=>" to sOperators
        Move (Length(sExpression)) to iSize
        For iCount from 1 to iSize
            Move (Mid(sExpression, 1, iCount)) to sChar
            If (sChar = "(") Begin
                Increment iOpCount
                Increment iParanthesis
            End
            If (sChar = ")") Begin
                Decrement iOpCount
            End
            If (iParanthesis <> 0 and sOperators contains sChar) Begin
                If (iOpCount = 0) Begin
                    Move True to bFound
                    Move iSize to iCount // We're done.
                End
            End
        Loop

        Function_Return bFound
    End_Function

    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
    // Note: The source line must first have been stripped of any comments
    Function _HasIfAndBeginStatement tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bisIfBegin bHasBeginStatement

        Get _HasIfCommand TokenizerData.sOverstrikeLine to bisIfBegin
        Get _HasBeginStatement TokenizerData.sOverstrikeLine to bHasBeginStatement
        Function_Return (bisIfBegin = True and bHasBeginStatement = True)
    End_Function

    Function _HasIfCommand String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (CS_If + " ") to bFound
        Function_Return bFound
    End_Function

    Function HasLegacyOperatorPos String sOverstrikeLine Returns Integer
        Integer iPos iPosFirst
        
        Move (Lowercase(sOverstrikeLine)) to sOverstrikeLine
        Move 2048 to iPosFirst
        
        If (sOverStrikeLine contains " gt ") Begin
            Move (Pos(" gt ", sOverstrikeLine) + 1) to iPos
            Move (iPos min iPosFirst) to iPosFirst
        End
        If (sOverStrikeLine contains " ge ") Begin
            Move (Pos(" ge ", sOverstrikeLine) + 1) to iPos
            Move (iPos min iPosFirst) to iPosFirst
        End
        If (sOverStrikeLine contains " lt ") Begin
            Move (Pos(" lt ", sOverstrikeLine) + 1) to iPos
            Move (iPos min iPosFirst) to iPosFirst
        End
        If (sOverStrikeLine contains " le ") Begin
            Move (Pos(" le ", sOverstrikeLine) + 1) to iPos
            Move (iPos min iPosFirst) to iPosFirst
        End
        If (sOverStrikeLine contains " eq ") Begin
            Move (Pos(" eq ", sOverstrikeLine) + 1) to iPos
            Move (iPos min iPosFirst) to iPosFirst
        End
        If (sOverStrikeLine contains " ne ") Begin
            Move (Pos(" ne ", sOverstrikeLine) + 1) to iPos
            Move (iPos min iPosFirst) to iPosFirst
        End
        If (iPosFirst = 2048) Begin
            Move 0 to iPosFirst
        End

        Function_Return iPosFirst
    End_Function

    Function HasLegacyOperatorPosNoParanthesis String sOverStrikeLine Returns Integer
        Boolean bParanthesis
        Move (Pos("(", sOverstrikeLine) <> 0) to bParanthesis
    End_Function
    
    Function _HasLineEndSemiColon String sOverstrikeLine Returns Boolean
        String sLine
        Get _RemoveEndComment sOverstrikeLine to sLine
        Move (RTrim(sLine)) to sLine
        If (Right(sLine, 1) = ";") Begin
            Function_Return True
        End
        Function_Return False
    End_Function

    Function _HasNot tBooleanIndicator BooleanIndicator Returns Boolean
        Boolean bTrue
        Move (BooleanIndicator.FirstBoolean.bHasNot = True or ;
              BooleanIndicator.SecondBoolean.bHasNot = True or ;
              BooleanIndicator.ToBoolean.bHasNot = True) to bTrue
        Function_Return bTrue
    End_Function

    // Pass only the code part of a source line.
    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
    Function _HasOperator tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bHas
        String sOverStrikeLine

        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        Get RemoveComments (&sOverStrikeLine) to bHas

        Case Begin
            Case (sOverStrikeLine contains ">=")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains ">")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "<=")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "<")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "=")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "<>")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End

        Function_Return bHas
    End_Function

    {Visibility = Private}
    Function _HasTokenLeftBracket String sToken Returns Boolean
        Boolean bHasBracket
        Move (Left(Trim(sToken), 1) = "[") to bHasBracket
        Function_Return bHasBracket
    End_Function

    {Visibility = Private}
    Function _HasTokenRighttBracket String sToken Returns Boolean
        Boolean bHasBracket
        Move (Right(Trim(sToken), 1) = "]") to bHasBracket
        Function_Return bHasBracket
    End_Function

    {Visibility = Private}
    Function _HasTokenParanthesis String sToken Returns Boolean
        Integer iPos
        String sChar   
        Move (Trim(sToken)) to sToken
        Move (Pos("(", sToken)) to iPos
        If (iPos <> 0) Begin
            Move (Right(sToken, 1)) to sChar
            If (sChar <> ")") Begin
                Move 0 to iPos
            End
        End
        Function_Return (iPos <> 0)
    End_Function

    {Visibility = Private}
    Function HasBracketNotOperator String sToken Returns Boolean
        Boolean bHasNot bHasBracket
        Move False to bHasNot
        Get _HasTokenLeftBracket sToken to bHasBracket
        If (bHasBracket = False) Begin
            Get _HasTokenRighttBracket sToken to bHasBracket
        End
        If (bHasBracket = True) Begin
            Move (Lowercase(sToken) contains Lowercase(CS_Not)) to bHasNot
            If (bHasNot = True) Begin
                // Make sure the "Not" is not part of a variable name. Cannot use " " (space) because the sTokens from
                // the asLineTokens array does not contain ending spaces.
                Move (Length(sToken) = 4) to bHasNot
            End
            If (bHasNot = False) Begin
                Move (sToken contains CS_Tilde) to bHasNot
            End
        End
        Function_Return bHasNot
    End_Function

    // Returns True iif the source line contains a "While" statement.
    Function _HasWhileStatement tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bFound
        Get _HasCommand (&TokenizerData) (CS_While + " ") to bFound
        Function_Return bFound
    End_Function

    Function _Indentation tTokenizer ByRef TokenizerData Returns String
        String sLine sText sIndentation
        Move "" to sIndentation
        Move TokenizerData.sLine to sLine
        Move (Ltrim(sLine)) to sText
        If (sText <> sLine) Begin
            Move (Replace(sText, sLine, "")) to sIndentation
        End
        Function_Return sIndentation
    End_Function
    
    // Convert Integer to binary
    // Curtesy of Frank Cheng
    Function _IntToBinary Integer iInt Returns String
        String sResult
        If (iInt < 0) Begin
            Function_Return ""
        End
        Move "" to sResult
        Repeat
            Move (String(Mod(iInt, 2)) + sResult) to sResult
            Move (iInt / 2) to iInt
        Until (iInt = 0)
        Function_Return sResult
    End_Function

    Function _IsBlankLine String sLine Returns Boolean
        Boolean bIsBlank

        Move False to bIsBlank
        Move (Trim(sLine)) to sLine
        If (Length(sLine) = 0) Begin
            Move True to bIsBlank
        End

        Function_Return bIsBlank
    End_Function

    // Is it a Class declaration?
    // Pass a source line param with overstriked string literals.
    Function _IsClassDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Pos(Lowercase("class "), Lowercase(sOverstrikeLine)) <> 0) to bFound

        Function_Return bFound
    End_Function

    Function _IsClassEnd String sOverstrikeLine Returns Boolean
        Boolean bClassEnd

        Move (Lowercase(Trim(sOverstrikeLine))) to sOverstrikeLine
        Move (Left(sOverstrikeLine, 9) = Lowercase(CS_EndClass)) to bClassEnd

        Function_Return bClassEnd
    End_Function

    // Is the line a command declaration?
    Function _IsCommandDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Pos(Lowercase("#" + CS_Command), Lowercase(sOverstrikeLine)) <> 0) to bFound

        Function_Return bFound
    End_Function

    Function _IsCommandEnd String sOverstrikeLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Left(Uppercase(sOverstrikeLine), Length("#ENDCOMMAND")) = "#ENDCOMMAND") to bFound

        Function_Return bFound
    End_Function

    // Is the line a struct declaration?
    Function _IsStructDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Trim(Lowercase(sOverstrikeLine))) to sOverstrikeLine
        Move (Pos(Lowercase("Struct "), sOverstrikeLine) <> 0) to bFound

        Function_Return bFound
    End_Function

    Function _IsStructEnd String sOverstrikeLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Left(Uppercase(sOverstrikeLine), Length("END_STRUCT")) = "END_STRUCT") to bFound

        Function_Return bFound
    End_Function

    Function _IsCommentLine String sLine Returns Boolean
        Boolean bIsComment

        Move (Trim(sLine)) to sLine
        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment

        Function_Return bIsComment
    End_Function

    // Returns False if the first line in the passed file is _not_ an automatically generated
    // COM wrapper file created by the Studio.
    // If it returns True, we should not process that file.  
    Function _IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
        Boolean bIsDFCOMProxyClasses bExists
        Integer iCh iPos
        String sLine

        Move False to bIsDFCOMProxyClasses
        File_Exist sFileName bExists
        If (bExists = False) Begin
            Error DfErr_Program ("The file doesn't exist:" * String(sFileName))
            Function_Return False
        End  
        Get OpenInput sFileName to iCh
        If (iCh < 0) Begin
            Function_Return False
        End
        
        Readln channel iCh sLine
        Send CloseInput iCh
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End

        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses
        Function_Return bIsDFCOMProxyClasses
    End_Function

    // New DF 23 comment syntax.
    Function _IsDF23CommentEnd String sOverstrikeLine Returns Boolean
        Boolean bOK
        Integer iPos iPos2
        
        Move 0 to iPos2                   
        Move False to bOK
        Move (Pos(CS_DF23CommentEnd, sOverstrikeLine)) to iPos
        If (iPos <> 0) Begin
            Move (Pos(CS_CommentSymbol, sOverstrikeLine))  to iPos2
            If (iPos2 <> 0) Begin
                Move (iPos < iPos2) to bOK
            End
            Else Begin
                Move True to bOK
            End
        End
        Function_Return bOK
    End_Function

    // New DF 23 comment syntax.
    Function _IsDF23CommentStart String sOverstrikeLine Returns Boolean
        Integer iPos iPos2 
        Boolean bFound          
        Move False to bFound
        Move (Pos(CS_DF23CommentStart, sOverstrikeLine)) to iPos
        Move (Pos(CS_CommentSymbol, sOverstrikeLine))    to iPos2
        If (iPos > 0) Begin
            If (iPos2 = 0) Begin
                Move True to bFound
            End
            Else If (iPos2 > 0 and iPos < iPos2) Begin
                Move True to bFound
            End                    
        End
        Function_Return bFound
    End_Function

    // It is assumed that blank and commented lines has been checked prior
    // using this function.
    // It will return True if the source line contains any of the DF23's new multi-line string starts.
    Function _IsDF23String tTokenizer ByRef TokenizerData Returns Boolean
        Integer iPos
        Boolean bFound
        String sOverStrikeLine

        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        // First check for tripple double-quotes:
        Move (Pos('"""', sOverstrikeLine) <> 0) to bFound

        // Second check is for "@" type multi-line string:
        If (bFound = False) Begin
            Move (Pos('@"', sOverstrikeLine) <> 0) to bFound
            If (bFound = False) Begin
                Move (Pos("@'", sOverstrikeLine) <> 0) to bFound
            End
            // We have passed a sOverStrike string, thus the quotes surrounding
            // that string constant has been replaced with "_" and/or "+" characters.
            If (bFound = False) Begin
                Move (Pos("@_", sOverstrikeLine) <> 0) to bFound
            End
            If (bFound = False) Begin
                Move (Pos("@+'", sOverstrikeLine) <> 0) to bFound
            End
            If (bFound = False) Begin
                Move (Pos(Lowercase("@SQL"), Lowercase(sOverstrikeLine)) <> 0) to bFound
            End
        End
        Function_Return bFound
    End_Function

    Function _IsDoubleQuoteStart String sOverstrikeLine Returns Boolean
        Integer iPosDouble iPosSingle
        Boolean bDoubleQuotedString

        Move True to bDoubleQuotedString
        Move (Pos('"', sOverstrikeLine)) to iPosDouble
        Move (Pos("'", sOverstrikeLine)) to iPosSingle
        If (iPosSingle <> 0) Begin
            Move (iPosDouble < iPosSingle) to bDoubleQuotedString
        End
        Else Begin
            Move (iPosDouble > iPosSingle) to bDoubleQuotedString
        End
        Function_Return bDoubleQuotedString
    End_Function

    // Returns True iif (if-and-only-if) the source line starts with the sCommand statement.
    Function _IsFirstWord String sLine String sCommand Returns Boolean
        Boolean bFound
        Integer iPos
        String sFirstWord

        Move (Ltrim(Lowercase(sLine))) to sLine
        Move (Ltrim(Lowercase(sCommand))) to sCommand
        If (sLine = sCommand) Begin
            Function_Return True
        End
        Move (sCommand + " ") to sCommand
        Move (Pos(" ", sLine)) to iPos
        Move (Left(sLine, iPos)) to sFirstWord
        Move (sFirstWord = sCommand) to bFound
        Function_Return bFound
    End_Function

    // Returns True if source line contains a "[Found]", or "[FindErr]".
    Function _IsFoundOrFindErrIndicator tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bFound
        Integer iLeft iRight iPos
        String sLine sText

        Get HasBracket TokenizerData.BooleanIndicator to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move TokenizerData.sOverstrikeLine to sText
        Get TrimInsideSpaces sText to sLine
        Move (Pos("[", sLine)) to iLeft
        Move (Pos("]", sLine)) to iRight
        Move (Pos(("[" + Lowercase(CS_Found)), Lowercase(sLine))) to iPos
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos(("[" + Lowercase(CS_Finderr)), Lowercase(sLine))) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Finderr) + "]"), Lowercase(sLine))) to iPos
        End

        Function_Return (iPos <> 0)
    End_Function

    // Is it a Function declaration?
    // Pass a source line param with overstriked string literals.
    Function _IsFunctionDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound
        Move (Trim(Lowercase(sOverstrikeLine))) to sOverstrikeLine
        Move (Left(sOverstrikeLine, Length(CS_Function)) = Lowercase(CS_Function)) to bFound
        Function_Return bFound
    End_Function

    Function _IsGotoLabel String sOverstrikeLine Returns Boolean
        Integer iPos iColonPos
        Boolean bIsLabel
          
        Move False to bIsLabel
        If (Right(sOverstrikeLine, 1 ) =":") Begin
            Move True to bIsLabel
            Move (Trim(sOverstrikeLine)) to sOverstrikeLine
            Move (Pos(":", sOverstrikeLine) -1) to iColonPos
            For iPos from 1 to iColonPos
                If (Mid(sOverstrikeLine, 1, iPos) = " ") Begin
                    Move False to bIsLabel
                    Move iColonPos to iPos // Get out
                End
            Loop
        End
        Function_Return bIsLabel
    End_Function

    // Takes a string as argument.
    // Returns: True if all is numeric.
    //          False if string contains any other character than digits.
    Function _IsNumeric String sValue Returns Boolean
        Boolean bOk
        Integer iLen iCount
        String sChar

        Move (Trim(sValue))   to sValue
        Move (Length(sValue)) to iLen
        If (not(iLen)) Begin
            Function_Return False
        End
        Move True to bOk
        For iCount from 1 to iLen
            Move (Mid(sValue, 1, iCount)) to sChar
            If (not("-0123456789" contains sChar)) Begin
                Move (False) to bOk
            End
            If (not(bOk)) Begin
                Move iLen to iCount // End loop
            End
        Loop
        Function_Return bOk
    End_Function

    Function _IsPrnLine String sLine Returns Boolean
        Integer iPos
        Boolean bFound
        String sInteger
          
        Move False to bFound
        Move (Pos(">", sLine)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sLine, iPos -1)) to sInteger  
            Get _IsNumeric sInteger to bFound
        End
        Function_Return bFound
    End_Function

    // Returns True if source line contains the "Indicate" keyword *or* a "[" and a "]", but not a "[]", which is an array declaration.
    Function _IsIndicatorStatement String sOverStrikeLine Returns Boolean
        Boolean bFound bIndicatorWord
        Integer iLeft iRight
        String sChar sLeftBracket

        Get IsCommentLineOrBlank sOverStrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get RemoveComments (&sOverstrikeLine) to bFound
        Move (Left(sOverstrikeLine, 1)) to sChar
        If (sChar = "[") Begin
            Move "[" to sLeftBracket
        End
        Else Begin
            Move " [" to sLeftBracket
        End
        Move (Lowercase(sOverstrikeLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
        Move (bIndicatorWord = True or (sOverstrikeLine contains sLeftBracket and sOverstrikeLine contains "]")) to bFound
        If (bFound = True) Begin
            Move (Pos(sLeftBracket, sOverstrikeLine)) to iLeft
            Move (Pos("]", sOverstrikeLine)) to iRight
            Move ((iRight - iLeft) > 1) to bFound
        End
        Function_Return (bIndicatorWord or bFound)
    End_Function

    // It is assumed that the sWord is neither blank or part of a comment or text constant.
    Function _IsKeyWord String sWord Returns Boolean
        Integer iItem
        String[] asKeyWords

        Get pasKeyWords to asKeyWords
        Move (Trim(Lowercase(sWord))) to sWord
        Move (SearchArray(sWord, asKeyWords)) to iItem

        Function_Return (iItem <> -1)
    End_Function

    Function _IsListedWord String sToken Returns Boolean
        Integer iItem
        String[] asKeyWords asScopeStart asScopeEnd asCommands
        
        Get pasKeyWords   to asKeyWords
        Get pasScopeStart to asScopeStart
        Get pasScopeEnd   to asScopeEnd
        Get pasCommands   to asCommands
        
        Move (SearchArray(sToken, asKeyWords, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Move (SearchArray(sToken, asScopeStart, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem = -1) Begin
                Move (SearchArray(sToken, asScopeEnd, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem = -1) Begin
                    Move (SearchArray(sToken, asCommands, Desktop, RefFunc(DFSTRICMP))) to iItem
                End
            End
        End    
        Function_Return (iItem <> -1)        
    End_Function

    Function _FirstKeyWordInArray String sOverstrike String[] asArray Returns String 
        tToken TokenData
        Integer iSize iCount
        Boolean bFound
        
        Move (SizeOfArray(asArray)) to iSize
        If (iSize = 0) Begin
            Function_Return TokenData
        End
        Decrement iSize
        For iCount from 0 to iSize
            Get _IsKeyWord asArray[iCount] to bFound
            If (bFound = True) Begin
                Move asArray[iCount] to TokenData.sCode
                Move (Pos(TokenData.sCode, sOverstrike)) to TokenData.iStartPos
                Move iSize to iCount
            End
        Loop
        
        Function_Return TokenData
    End_Function

    Function _IsOpenCommand String sLine Returns Boolean
        Boolean bFound             
        Get _IsCommentLine sLine to bFound
        If (bFound = True) Begin
            Function_Return False                  
        End
        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 4) = "open") to bFound
        Function_Return bFound
    End_Function
        
    // Returns True iif the source line is a "Loop" statement.
    Function _IsLoopStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + CS_Loop) to bFound
        Function_Return bFound
    End_Function

    Function _IsMethodEnd String sOverstrikeLine Returns Boolean
        Boolean bMethodEnd

        Move (Lowercase(Trim(sOverstrikeLine))) to sOverstrikeLine
        Move (Left(sOverstrikeLine, 14) = Lowercase(CS_EndProcedure) or Left(sOverstrikeLine, 13) = Lowercase(CS_EndFunction)) to bMethodEnd

        Function_Return bMethodEnd
    End_Function

    // Returns True if the sOverStrikeLine is the start of a Function *or* a Procedure.
    Function _IsMethodStart String sOverStrikeLine Returns Boolean
        Boolean bMethodStart

        Get _IsFunctionDeclaration sOverStrikeLine to bMethodStart
        If (bMethodStart = False) Begin
            Get _IsProcedureDeclaration sOverStrikeLine to bMethodStart
        End
        Function_Return bMethodStart
    End_Function

    Function _IsMoveCommand String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + String(CS_Move) + " ") to bFound
        If (bFound = False) Begin
            Get _HasCommand sOverstrikeLine (String(CS_Move) + " ") to bFound
        End
        Function_Return bFound
    End_Function

    // It is assumed that blank and commented lines has been checked prior
    // to using this function.
    // It will return True if the "sOverStrikeLine" parameter contains the DF23's new string's end,
    // which can be three """ characters and a 'to' keyword.
    // If not found it returns false.
    Function _IsMultiLineStringEnd String sOverStrikeLine Returns Boolean
        Boolean bFound
        String sChar
        Integer iPos

        // If a multi string hasn't been started; no point in testing further.
        If (pbIsInDF23MultiLineString(Self) = False) Begin
            Function_Return False
        End

        Move (Trim(Lowercase(sOverStrikeLine))) to sOverStrikeLine
        // Check for """ multi-line string end
        // On the last line, to the left of the """, should be only white space.
        Move (Pos('"""', sOverStrikeLine) = 1 and Pos(" to ", sOverStrikeLine) <> 0) to bFound
        // Check @ multi-line string or legacy ";" line endings
        If (bFound = False) Begin
            Move (Pos(" to ", sOverStrikeLine) and ((Pos('"', sOverStrikeLine) or Pos("'", sOverStrikeLine)) and Pos(";", sOverStrikeLine) = 0)) to bFound
        End
//        Move (Right(sOverStrikeLine, 1)) to sChar
//        Move (sChar = '"' or sChar = "'") to bFound
//        If (bFound = False) Begin
//            Move (Right(sOverStrikeLine, 3)) to sChar
//            Move (sChar = '"""') to bFound
//        End
//        // Old style multi-line string that ends with a semi-colon: ;
//        If (bFound = False) Begin
//            Get _HasLineEndSemiColon sOverStrikeLine to bFound
//        End

        Function_Return bFound
    End_Function

    // It is assumed that blank and commented lines has been checked prior
    // using this function.
    // It will return True if the "sLine" parameter contains any of the DF23's new string's start,
    // or if it is a "classic" multi-line string ending with a semi-colon (;).
    // Else it returns False.
    Function _IsMultiLineStringStart tTokenizer ByRef TokenizerData Returns Boolean
        Integer iPos
        Boolean bFound
        String sLine sSource

        Get _IsDF23String (&TokenizerData) to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        // On the first line, to the right of the """, should be only white space. 
        Move False to bFound
        Move (Trim(Lowercase(TokenizerData.sOverstrikeLine))) to sLine

        Move (Pos('"""', sLine)) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sLine, Length(sLine), iPos)) to sSource
            Move (sSource = '"""') to bFound 
            If (bFound = True) Begin
                Move (Trim(Lowercase(sLine)) contains "move ") to bFound
                If (bFound = True) Begin
                    Function_Return True
                End
            End
        End

        Move (Pos('@"', sLine)) to iPos
        // Check for a 'Move' command
        If (iPos <> 0) Begin
            Move (Trim(Lowercase(sLine)) contains "move ") to bFound
            If (bFound = True) Begin
                Function_Return True
            End
        End
        
        // Check for a @SQL multi-line string start. Can exist without a 'Move' command.
        Move (Pos('@sql"', sLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos('@sql"""', sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos("@sql'", sLine)) to iPos
        End
        Move (iPos <> 0) to bFound
//        If (iPos <> 0) Begin
//            Move (Mid(sLine, Length(sLine), (iPos + 1))) to sSource
//            Move (Pos('sql"""', sSource)) to iPos
//            If (iPos <> 0) Begin
//                Function_Return False
//            End
//            Move (iPos = 0) to bFound
//        End
//        Else Begin
//            Move (Pos("@", sLine)) to iPos
//            If (iPos <> 0) Begin
//                // We need to make sure that the "@" char is not in a quotes string  constant.
//                Move (Pos("@", sLine)) to iPos
//                Move (iPos <> 0) to bFound
//            End
//        End

        Function_Return bFound
    End_Function

    // Returns True if the number of single- and double-quotes in the sLine param is not even.
    Function _IsOpenString String sLine Returns Boolean
        Boolean bIsOpenString
        Integer iDoubleQuotes iSingleQuotes
        UChar[] uaLine

        Move (StringToUCharArray(sLine)) to uaLine
        Move (CountArray(Ascii('"'), uaLine)) to iDoubleQuotes
        Move (Mod(iDoubleQuotes, 2)) to bIsOpenString
        If (bIsOpenString = False) Begin
            Move (CountArray(Ascii("'"), uaLine)) to iSingleQuotes
            Move (Mod(iSingleQuotes, 2)) to bIsOpenString
        End

        Function_Return bIsOpenString
    End_Function

    // Is it a Procedure declaration?
    // Pass a source line param with overstriked string literals.
    Function _IsProcedureDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound
        Move (Pos(Lowercase("procedure "), Lowercase(sOverstrikeLine)) <> 0) to bFound
        Function_Return bFound
    End_Function

    Function _IsRegisterObjectLine String sLine Returns Boolean
        Boolean bFound
        Integer iPos

        Move False to bFound
        Move (Pos(CS_RegisterObject, sLine)) to iPos
        If (iPos = 1) Begin
            Move True to bFound
        End
        Function_Return bFound
    End_Function

    // Returns True iif the source line contains a "Repeat" statement.
    Function _IsRepeatStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand (&sOverstrikeLine) (" " + CS_Repeat) to bFound
        Function_Return bFound
    End_Function

    // To check if the sToken from a Tokenizer.asLineTokens array is a string constant
    Function _IsStringArrayConstant String sToken Returns Boolean
        String sOrg
        Move sToken to sOrg
        Move (Replaces("_", sToken, "")) to sToken
        Function_Return (sOrg <> sToken)    
    End_Function

    Function _IsSystemBoolean String sToken Returns Boolean
        Integer iItem
        String[] asSystemBooleans
        
        Move (Lowercase(sToken))       to sToken
        Get ReplaceBrackets    sToken to sToken
        Get ReplaceParanthesis sToken to sToken
        Get pasSystemBooleans  to asSystemBooleans
        Move (SearchArray(sToken, asSystemBooleans)) to iItem
        Function_Return (iItem <> -1)
    End_Function

    Function _IsTokenEqual String sToken String sKeyWord Returns Boolean
        Function_Return (Lowercase(sToken) = Lowercase(sKeyWord))    
    End_Function
    
    // Returns True iif the source line is a "Until" statement.
    Function _IsUntilStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + CS_Until) to bFound
        If (bFound = False) Begin
            Get _HasCommand sOverstrikeLine (CS_Until + " ") to bFound
            If (bFound = False) Begin
                Get _HasCommand sOverstrikeLine (CS_Until) to bFound
            End
        End

        Function_Return bFound
    End_Function

    // It is assumed that the sOverstrikeLine is neither blank or part of a comment or text constant.
    // Check if the "sOverstrikeLine" is a global or a local variable declaraction (exist in pasLocalVariableTypes)
    Function _IsVariableDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound
        String[] asLocalVariableTypes 
        String sVariableType
        Integer iItem iPos

        Move "" to sVariableType
        Move (Trim(Lowercase(sOverstrikeLine))) to sOverstrikeLine
        Move (Left(sOverstrikeLine, Length(CS_Local) +1) = (Lowercase(CS_Local) + " ")) to bFound
        If (bFound = False) Begin
            Move (sOverstrikeLine contains "global_variable") to bFound
        End
        If (bFound = False) Begin
            Move (Pos(" ", sOverstrikeLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sOverstrikeLine, (iPos -1))) to sVariableType
            End
            Get pasLocalVariableTypes to asLocalVariableTypes
            Move (SearchArray(sVariableType, asLocalVariableTypes)) to iItem
            Move (iItem <> -1) to bFound
        End
        Function_Return bFound
    End_Function

    Function _IsVariableInLine String sOverstrikeLine String sVariableName Returns Boolean
        Boolean bIsUseLine
        String sChar
        Integer iPos

        Move False to bIsUseLine
        Move (Lowercase(sOverStrikeLine)) to sOverStrikeLine
        Move (Lowercase(sVariableName))   to sVariableName

        If (sOverStrikeLine contains sVariableName) Begin
            Move (Pos(sVariableName, sOverStrikeLine)) to iPos
            If (iPos > 0) Begin
                Repeat
                    Move (Mid(sOverStrikeLine, 1, (iPos - 1))) to sChar
                    If (CS_ValidLeftCharacters contains sChar) Begin
                        Move True to bIsUseLine
                    End
                    If (bIsUseLine = False) Begin
                        Move (Replace(sVariableName, sOverStrikeLine, "")) to sOverStrikeLine
                        Move (Pos(sVariableName, sOverStrikeLine)) to iPos
                    End
                Until (bIsUseLine = True or iPos = 0)
            End
        End

        Function_Return bIsUseLine
    End_Function

    // Returns either the first or second command in the sLine, depending
    // on the eCommandNumber parameter.
    { EnumList = "eFirstCommand, eSecondCommand, eThirdCommand" }
    Function _LeftCommand tTokenizer ByRef TokenizerData Integer eCommandNumber Returns tToken
        Integer iSize iCount iItem iCommand iNumber
        String[] asScopeStart asScopeEnd asCommands
        tToken Data

        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return Data
        End
        Get pasCommands   to asCommands
        // These arrays contains lowercased keywords/scoped words.
        Get pasScopeStart to asScopeStart
        Get pasScopeEnd   to asScopeEnd
        Move -1 to iCommand
        Move 0 to iNumber
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (SearchArray(TokenizerData.asLineTokens[iCount], asCommands, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem = -1) Begin
                Move (SearchArray(TokenizerData.asLineTokens[iCount], asScopeStart, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem = -1) Begin
                    Move (SearchArray(TokenizerData.asLineTokens[iCount], asScopeEnd, Desktop, RefFunc(DFSTRICMP))) to iItem
                End
            End
            If (iItem <> -1) Begin
                If (eCommandNumber = iNumber) Begin
                    Move iCount to iCommand
                    Move iSize to iCount    // Jump out.
                End
                Increment iNumber
            End
            Else If (Lowercase(TokenizerData.asLineTokens[iCount]) = Lowercase(CS_If)) Begin
                Increment iNumber
                // The "If" statement is not included in the pasKeyWords array, but we want it here
                If (eCommandNumber = eFirstCommand) Begin
                    Move iCount to iCommand
                    Move iSize to iCount    // Jump out.
                    Move 1 to iItem
                End
            End
        Loop

        If (iItem <> -1 and iCommand <> -1) Begin
            Move TokenizerData.asLineTokens[iCommand] to Data.sCode
            Move (Pos(Data.sCode, TokenizerData.sOverstrikeLine)) to Data.iStartPos
        End
        Function_Return Data
    End_Function

    // Get the left part of the line up to but not including the "of or to" part, and not any end comment.
    Function _LeftStatement tTokenizer ByRef TokenizerData Returns tToken
        String sOverStrikeLine
        Integer iPos iItem iEnd
        tToken Data
        
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return Data
        End       
        Move 0 to iPos
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine

        Move (SearchArray(CS_Of, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move (Pos(Lowercase(CS_Of), Lowercase(sOverstrikeLine))) to iPos
            Move (Left(sOverStrikeLine, iPos -1)) to sOverStrikeLine
        End
        If (iItem = -1) Begin
            Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move (Pos(Lowercase(CS_To), Lowercase(sOverstrikeLine))) to iPos
                Move (Left(sOverStrikeLine, iPos -1)) to sOverStrikeLine
            End
        End
        If (iItem = -1) Begin
            Move (SearchArray(CS_As, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move (Pos(Lowercase(CS_As), Lowercase(sOverstrikeLine))) to iPos
                Move (Left(sOverStrikeLine, iPos -1)) to sOverStrikeLine
            End
        End
        If (iPos <> 0) Begin
            Move (Left(Trim(TokenizerData.sOverstrikeLine), iPos -1)) to sOverstrikeLine
        End
        If (iPos = 0) Begin
            Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        End
        Move 1                        to Data.iStartPos
        Move (Rtrim(sOverstrikeLine)) to Data.sCode
        
        Function_Return Data
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>"
    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator.
    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
    Function _LogicalOperators tTokenizer ByRef TokenizerData Returns tOperatorsInfo
        Boolean bHas
        tOperatorsInfo OperatorsInfo
        String sOverStrikeLine

        Get IsCommentLineOrBlank TokenizerData.sLine to bHas
        If (TokenizerData.bIsBlank = True or TokenizerData.bIsComment = True) Begin
            Function_Return OperatorsInfo
        End
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        Get RemoveComments (&sOverStrikeLine) to bHas
        Move (Lowercase(sOverStrikeLine)) to sOverStrikeLine

        Case Begin
            // "Legacy" operators;
            Case (sOverstrikeLine contains " gt ")
                Move (Pos(" gt ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "gt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " ge ")
                Move (Pos(" ge ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ge"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " lt ")
                Move (Pos(" lt ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "lt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " le ")
                Move (Pos(" le ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "le"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " eq ")
                Move (Pos(" eq ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "eq"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " ne ")
                Move (Pos(" ne ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ne"                   to OperatorsInfo.sOperator
                Case Break

            // "Modern" operators;
            Case (sOverstrikeLine contains ">")
                Move (Pos(">", sOverstrikeLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">"                    to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains ">=")
                Move (Pos(">=", sOverstrikeLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">="                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "<")
                Move (Pos("<", sOverstrikeLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<"                    to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "<=")
                Move (Pos("<=", sOverstrikeLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<="                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "=")
                Move (Pos("=", sOverstrikeLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "="                    to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "<>")
                Move (Pos("<>", sOverstrikeLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<>"                   to OperatorsInfo.sOperator
                Case Break
            Case Else
                Move -1                     to OperatorsInfo.iPos
                Move False                  to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ""                     to OperatorsInfo.sOperator
        Case End

        Function_Return OperatorsInfo
    End_Function

    // Lowercases all values in the passed asArray, and then returns the changed array.
    // This is to make it easier to find keywords kept in string array properties.
    Function _LowercaseArrayValues String[] asArray Returns String[]
        String sValue
        Integer iSize iCount
        Move (SizeOfArray(asArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asArray[iCount] to sValue
            Move (Lowercase(sValue)) to asArray[iCount]
        Loop
        Function_Return asArray
    End_Function

    // Parses the method name from the string
    Function _MethodName String sOverstrikeLine Returns String
        Integer iPos
        String sMethod sStart
        
        Move (Trim(sOverstrikeLine)) to sOverstrikeLine
        Move (Pos(" ", sOverstrikeLine)) to iPos
        Move (Left(sOverstrikeLine, (iPos - 1))) to sStart
        If (Lowercase(sStart) <> Lowercase(CS_Procedure) and Lowercase(sStart) <> Lowercase(CS_Function)) Begin
            Function_Return ""
        End
        
        Get _RemoveFirstToken sOverstrikeLine sMethod to sMethod
        If (Lowercase(Left(Trim(sMethod), 4)) = "set ") Begin
            Get _RemoveFirstToken sOverstrikeLine sMethod to sMethod
        End
        // Remove any trailing arguments
        Move (Pos(" ", sMethod)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sMethod, (iPos - 1))) to sMethod
        End
        Function_Return (Trim(sMethod))
    End_Function

    // A declaration like "String [] asAddress",
    //     is changed to: "String[] asAddress"
    // If the sLine is a local variable declaration, it starts
    // with either a "local" keyword or one of the members
    // in pasLocalVariableTypes.
    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
        Boolean bChanged bFound
        String sText sWord

        Move sLine to sText
        Get _FirstBracketToken sLine to sWord
        If (sWord = "") Begin
            Function_Return False
        End
        Get _IsVariableDeclaration sWord to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        While (Pos(" [", sText) > 0)
            Move (Replace(" [", sText, "[")) to sText
        Loop
        Move (sLine = sText) to bChanged
        If (bChanged = True) Begin
            Move sText to sLine
        End
        Function_Return bChanged
    End_Function

    // Returns the number of single or double quotes contained in the "sLine" param.
    { EnumList="{ eSingleQuotes, eDoubleQuotes}" }
    Function _NumberOfStringQuotes String sLine Integer eQuoteMode Returns Integer
        Integer iQuotes
        UChar[] uaLine

        Move (Trim(sLine)) to sLine
        Get _RemoveEndComment sLine to sLine
        Move (StringToUCharArray(sLine)) to uaLine
        If (eQuoteMode = eDoubleQuotes) Begin
            Move (CountArray(Ascii('"'), uaLine)) to iQuotes
        End
        If (eQuoteMode = eSingleQuotes) Begin
            Move (CountArray(Ascii("'"), uaLine)) to iQuotes
        End

        Function_Return iQuotes
    End_Function

    // Get the "of xxxx " part from a source line. But not the "to xxx" part and the "of" keyword.
    Function _OfStatement tTokenizer ByRef TokenizerData Returns tToken
        String sOfStatement sOverWrite sLine
        Integer iPos iCount iStart iItem iEnd
        tToken Data
        
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return Data
        End
        Move (SearchArray(CS_Of, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return Data
        End
        Move (iItem + 1) to iStart
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iEnd
        Decrement iEnd
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move (iItem -1) to iEnd
        End

        For iCount from iStart to iEnd
            Append sOfStatement TokenizerData.asLineTokens[iCount] " "
        Loop           
        Move (Rtrim(sOfStatement)) to Data.sCode 
        Move (Pos(Lowercase(CS_Of * String(Data.sCode)), Trim(Lowercase(TokenizerData.sLine)))) to iStart
        Move (iStart + 2)          to Data.iStartPos // "Of" = +2
        
        Function_Return Data
    End_Function  
    
    Function _IsOverwriteValue String sOverwrite Returns Boolean
        Boolean bFound
        Move (sOverwrite contains "'++" or sOverwrite contains "'+'" or sOverwrite contains "'__" or sOverwrite contains "'_'") to bFound
        If (bFound = False) Begin
            Move (sOverwrite contains '"++' or sOverwrite contains '"+"' or sOverwrite contains '"__' or sOverwrite contains '"_"') to bFound
        End
        Function_Return bFound
    End_Function
    
    // Tries to find the corresponding original string constant in a source line.
    // Params: sOverwrite = the over written string constant from e.g. the Tokenizer's asLineTokens array.
    //         asQuatedArray = tokenizer's asStringConstant array.
    // Note:   It will return the "sOverwrite" value if no value found.
    Function _FindOverwriteToContent String sOverwrite Integer iItem tQuotedString[] asQuatedArray Returns String
        Boolean bFound
        Integer iItemFound iSize iCount
        String sValue sChar
        tQuotedString QuotedString
        
        Get _IsOverwriteValue sOverwrite to bFound
        If (bFound = False) Begin
            Function_Return sOverwrite
        End
        
        Move "" to sValue
        Move False to bFound
        Move (Left(sOverwrite, 1)) to sChar
        If (Right(sOverwrite, 1) <> sChar) Begin
            Append sOverwrite sChar
        End
        Move sOverwrite to QuotedString.sOverwrite
        Move (SizeOfArray(asQuatedArray)) to iSize
        Decrement iSize
        For iCount from (iItem -1) to iSize
            Move (asQuatedArray[iCount].sOverwrite = sOverwrite) to bFound
            If (bFound = True) Break
        Loop
        If (bFound = True) Begin
            Move asQuatedArray[iCount].sContent to sValue
        End
        Function_Return sValue
    End_Function
    
    Function _OverWriteStringAdd String sContent String sOverwrite Integer iStart Integer iArrayItem tTokenizer ByRef TokenizerData Returns Integer
        Integer iLength iEnd               
        String sChar
        
        Move (Left(sOverwrite, 1)) to sChar
        If (Right(sOverwrite, 1) <> sChar) Begin
            Append sOverwrite sChar
        End
        Move (Trim(sOverwrite)) to sOverwrite
        Move (Trim(sContent))   to sContent
        Move (Length(sContent)) to iLength
        Move sContent           to TokenizerData.asStringConstant[iArrayItem].sContent
        Move sOverwrite         to TokenizerData.asStringConstant[iArrayItem].sOverwrite
        Move iStart             to TokenizerData.asStringConstant[iArrayItem].iStartPos
        Move (iStart + iLength) to TokenizerData.asStringConstant[iArrayItem].iEndPos
        Move iLength            to TokenizerData.asStringConstant[iArrayItem].iLength
        Function_Return (iArrayItem + 1) // Increase array item for next call.
    End_Function

    // ToDo: I do not lake the multi-line string logic used here at all. It is overcomplicated and
    //       it should be possible to simplify, but how?
    // This will replace the string literals in a line with overstrike characters
    // E.g. all string literals are now underscores, eg. "abc" becomes "___"
    //                              or plus symbols  eg. 'abc' becomes '+++'
    // It overstrikes DF 23 multi-line string literals with hash-marks '###'
    // It will also remove any end comment like; "Move x to y // Some comment",
    // and trim the return string.
    // If no quotes ("" or '') were found, the untouched TokenizerData.sLine is returned.
    Function _OverstrikeStrings tTokenizer ByRef TokenizerData Returns String
        Boolean bDoubleQuote bSingleQuote bChanged bHasEndSemiColon bIsInDF23MultiLineString  bIsInSemiColonMultiLineString
        Boolean bIsOpenString bIsInSingleQuote bOK
        Integer iChar iLength iPos iDoubleQuotes iSingleQuotes iString iStart
        String  sChar sText sTrippelDoubleQuote sContent sOverwrite
        
        // If we already have applied this function to a source line, do nothing.
        If (TokenizerData.bHasOverstrikeChars = True) Begin
            Function_Return TokenizerData.sOverstrikeLine
        End

        If (pbIsInPage(Self) = True or pbIsInDF23MultiLineComment(Self) = True) Begin
            If (pbIsInDF23MultiLineComment(Self) = True) Begin
                Move TokenizerData.sLine to sText
                Move (Length(sText)) to iLength
                Move (Repeat("#", iLength)) to sText
            End
            Else Begin
                Move TokenizerData.sLine to sText
            End
            Function_Return sText
        End
        
        // Does the sLine end with a semi-colon ";"?
        Get _HasLineEndSemiColon TokenizerData.sLine to bHasEndSemiColon
        Get pbIsInSemiColonMultiLineString to bIsInSemiColonMultiLineString
        // Are we already in an "open" multi-line string? An "open" string is a string constant
        // spread out over several lines. So there may be *no* quotes or an uneven number of quotes
        // in the sLine content, in which case we need to treat the line differently.
        Get pbIsInDF23MultiLineString to bIsInDF23MultiLineString
        Get pbIsOpenString to bIsOpenString
        If (bIsOpenString = False) Begin
            Get _IsOpenString TokenizerData.sLine to bIsOpenString
        End

        Move (Replace(TokenizerData.sEndComment, TokenizerData.sLine, "")) to sText
        Move (Trim(sText)) to sText
        Move False to bChanged
        Move (Length(sText)) to iLength
        If (bIsInDF23MultiLineString = False and bIsOpenString = False) Begin
            Move (Pos('"', sText)) to iPos
            If (iPos = 0) Begin
                Move (Pos("'", sText)) to iPos
                If (iPos = 0) Begin
                    Function_Return (Trim(sText))
                End
            End
        End
        
        Move (SizeOfArray(TokenizerData.asStringConstant)) to iString
        Move False to bDoubleQuote
        Move False to bSingleQuote
        Get _NumberOfStringQuotes sText eSingleQuotes to iSingleQuotes
        Get _NumberOfStringQuotes sText eDoubleQuotes to iDoubleQuotes
        
        // This property is set when a multi-line string is started, to indicate
        // if the beginning of the string was a single- or double-quote character.
        Get pbIsInSingleQuote to bIsInSingleQuote
        If (bIsInDF23MultiLineString = True or bIsInSemiColonMultiLineString = True) Begin
            If (bIsInSingleQuote = False) Begin
                If (iDoubleQuotes = 0 and iSingleQuotes < 2) Begin 
                    Move sText to sContent
                    Move (Length(sText)) to iLength
                    Move (Repeat("_", iLength)) to sText
                    If (bHasEndSemiColon = True) Begin
                        Move (Left(sText, (Length(sText) -1))) to sText
                        Append sText ";"
                    End           
                    Move sContent to TokenizerData.asStringConstant[iString].sContent
                    Move sText    to TokenizerData.asStringConstant[iString].sOverwrite
                    Move 1        to TokenizerData.asStringConstant[iString].iStartPos
                    Move iLength  to TokenizerData.asStringConstant[iString].iEndPos
                    Move iLength  to TokenizerData.asStringConstant[iString].iLength
                    Move sText to TokenizerData.sOverstrikeLine
                    Function_Return TokenizerData.sOverstrikeLine
                End
            End
            Else Begin
                If (iSingleQuotes = 0) Begin
                    Move sText to sContent
                    Move (Length(sText)) to iLength
                    Move (Repeat("+", iLength)) to sText
                    Move sContent to TokenizerData.asStringConstant[iString].sContent
                    Move sText    to TokenizerData.asStringConstant[iString].sOverwrite
                    Move 1        to TokenizerData.asStringConstant[iString].iStartPos
                    Move iLength  to TokenizerData.asStringConstant[iString].iEndPos
                    Move iLength  to TokenizerData.asStringConstant[iString].iLength
                    Move sText to TokenizerData.sOverstrikeLine
                    Function_Return TokenizerData.sOverstrikeLine
                End
            End
            If (iDoubleQuotes = 0 and bIsInSingleQuote = False) Begin
                Move True to bDoubleQuote
            End
            If (bDoubleQuote = False) Begin
                Move (Mod(iSingleQuotes, 2) = 0 and iSingleQuotes <> 0) to bDoubleQuote
            End
            If (bDoubleQuote = False) Begin
                Move (Mod(iDoubleQuotes, 2) = 0 and iDoubleQuotes <> 0) to bSingleQuote
            End
            If (bDoubleQuote = False) Begin
                Move (iDoubleQuotes = 1) to bDoubleQuote
            End
        End
        Else If (iSingleQuotes = 0 and iDoubleQuotes = 0) Begin
            Function_Return sText
        End

        Move 0 to iStart
        For iChar from 1 to iLength
            Move (Mid(sText, 1, iChar)) to sChar
            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
                Move True to bChanged
                Move " " to sChar
            End
            // If closing double quote:
            If (bDoubleQuote and sChar= '"') Begin
                Move True to bChanged
                Append sContent sChar
                Get _OverWriteStringAdd sContent ('"' + sOverwrite + '"') iStart iString (&TokenizerData) to iString
                Move 0 to iStart
                Move "" to sContent    
                Move "" to sOverwrite
                Move "" to sChar
                Move False to bDoubleQuote
            End
            // If closing single quote:
            If (bSingleQuote and sChar = "'") Begin
                Move True to bChanged  
                Append sContent sChar
                Get _OverWriteStringAdd sContent ("'" + sOverwrite + "'") iStart iString (&TokenizerData) to iString
                Move 0 to iStart
                Move "" to sContent
                Move "" to sOverwrite
                Move "" to sChar
                Move False to bSingleQuote
            End
            If (bIsInDF23MultiLineString = True and bIsOpenString = True) Begin
                If (bDoubleQuote and sChar = "'") Begin
                    Move False to bDoubleQuote
                    Move True to bSingleQuote
                End
                Else If (bSingleQuote and sChar = '"') Begin
                    Move False to bSingleQuote
                    Move True to bDoubleQuote
                End
                Else If (bDoubleQuote = False and bSingleQuote = False) Begin
                    Move (Mid(sText, 1, iChar)) to sChar
                    If (sChar = "'") Begin
                        Move True to bDoubleQuote
                    End
                    If (sChar = '"' and bHasEndSemiColon = True) Begin
                        Move True to bSingleQuote
                    End
                    Move "" to sChar
                End
            End

            If (bSingleQuote = False and sChar ='"') Begin
                Move (Mid(sText, 3, iChar)) to sTrippelDoubleQuote
                If (sTrippelDoubleQuote = '"""') Begin
                    Move (iChar + 2) to iChar
                End
                Else Begin
                    Move True to bDoubleQuote
                End
            End
            If (bDoubleQuote = False and sChar = "'") Begin
                Move True to bSingleQuote  
            End
            If bDoubleQuote Begin
                If (sChar <> '"') Begin    
                    Append sOverwrite "_"      
                    Move (Overstrike("_", sText, iChar)) to sText
                    Append sContent sChar
                End
                If (iStart = 0) Begin
                    Move iChar to iStart
                    Append sContent sChar
                End
                Move True to bChanged
            End
            Else If bSingleQuote Begin
                If (sChar <> "'") Begin
                    Append sOverwrite "+" 
                    Move (Overstrike("+", sText, iChar)) to sText
                    Append sContent sChar 
                End
                If (iStart = 0) Begin
                    Move iChar to iStart
                    Append sContent sChar
                End
                Move True to bChanged
            End
        Loop

        If (bChanged = True) Begin
            If (bIsOpenString = True) Begin
                If (bDoubleQuote = True) Begin
                    Get _OverWriteStringAdd sContent ('"' + sOverwrite + '"') iStart iString (&TokenizerData) to iString
                End
                Else If (bSingleQuote = True) Begin
                    Get _OverWriteStringAdd sContent ("'" + sOverwrite + "'") iStart iString (&TokenizerData) to iString
                End
            End
            Move True to TokenizerData.bHasOverstrikeChars 
            // Add back the end-of-line semi-colon:
            If (bHasEndSemiColon = True) Begin
                Move (Left(sText, (Length(sText) -1))) to sText
                Append sText ";"
            End
            Move sText to TokenizerData.sOverstrikeLine
        End
        Else Begin
            Move TokenizerData.sLine to TokenizerData.sOverstrikeLine
        End
        Function_Return TokenizerData.sOverstrikeLine
    End_Function

    //  This will overstrike string literals in a sLine with
    //  _ characters for a "string" and + characters for a 'string'
    Function _OverstrikeSimpleLine String sLine Returns String
        Boolean bDoubleQuote bSingleQuote bChanged bComment
        Integer iChar iLength
        String  sChar sText

        Get _IsCommentLine sLine to bComment
        If (bComment = True or Trim(sLine) = "") Begin
            Function_Return sLine    
        End                      
        
        Move False to bChanged
        Move (sLine contains '"') to bDoubleQuote
        Move (sLine contains "'") to bSingleQuote
        If (bDoubleQuote = False and bSingleQuote = False) Begin
            Function_Return sLine
        End

        Move False to bDoubleQuote
        Move False to bSingleQuote
        Move sLine to sText
        Move (Length(sText)) to iLength
        For iChar from 1 to iLength
            Move (Mid(sText, 1, iChar)) to sChar
            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
                Move True to bChanged
                Move " " to sChar
            End
            If (bDoubleQuote and sChar= '"') Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bDoubleQuote
            End
            If (bSingleQuote and sChar = "'") Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bSingleQuote
            End
            If (bSingleQuote = False and sChar ='"') Begin
                Move True to bDoubleQuote
            End
            If (bDoubleQuote = False and sChar = "'") Begin
                Move True to bSingleQuote
            End
            If bDoubleQuote Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
            End
            Else If bSingleQuote Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
            End
        Loop

        If (bChanged = True) Begin
            Move sText to sLine
        End
        Function_Return sLine
    End_Function

    // A list of items that should be removed from the pasCommands array
    Function _RemoveCommandsArray Returns String[]
        String sOtherCommands
        String[] asOther
        Move (Lowercase("byref,to,of,at,do,from,field,file_field,returns")) to sOtherCommands
        Move (StrSplitToArray(sOtherCommands, ",")) to asOther
        Function_Return asOther
    End_Function

    Function _RemoveKeyWordsFromArray String[] asReduceArray String[] asRemoveItemsArray Returns String[]
        String sValue
        Integer iSize iCount iItem

        Move (SizeOfArray(asRemoveItemsArray)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move asRemoveItemsArray[iCount] to sValue
            Move (SearchArray(sValue, asReduceArray)) to iItem
            If (iItem <> -1) Begin  
                Move (RemoveFromArray(asReduceArray, iItem)) to asReduceArray
            End
        Loop

        Function_Return asReduceArray
    End_Function

    Function _RemoveHashMarkCommands String[] asCommands Returns String[]
        String sCommand sChar
        Integer iSize iCount iItem

        Move (SizeOfArray(asCommands)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move asCommands[iCount] to sCommand
            Move (Left(sCommand, 1)) to sChar
            If (sChar = "#") Begin
                Move (RemoveFromArray(asCommands, iCount)) to asCommands
                Decrement iSize
                Decrement iCount
            End
        Loop

        Function_Return asCommands
    End_Function
    
    // It takes any source line as a parameter and
    // returns the same string without the end comment.
    Function _RemoveEndComment String sLine Returns String
        Integer iPos
        String sTest

        Move sLine to sTest
        Move (Trim(sTest)) to sTest
        Move (Pos(CS_CommentSymbol, sTest)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (RightPos(CS_CommentSymbol, sLine)) to iPos
            Move (Left(sLine, iPos - 1)) to sLine
        End
        Function_Return (Rtrim(sLine))
    End_Function  
    
    // Removes the first token, i.e first part of the input string
    // until the first space and returns the reminder, unless the string
    // only consists of a single token, in which that value will be returned.
    Function _RemoveFirstToken String sOverStrikeLine Returns String
        Integer iPos
        Boolean bChanged
        String sToken
        
        Move (Trim(sOverStrikeLine)) to sOverStrikeLine
        Get _NormalizeArrayNotation (&sOverStrikeLine) to bChanged
        Move (Pos(" ", sOverStrikeLine)) to iPos
        Move (Left(sOverStrikeLine, iPos)) to sToken
        Move (Trim(sToken)) to sToken
        Move (Replace(sToken, sOverStrikeLine, "")) to sOverStrikeLine

        Function_Return (Ltrim(sOverStrikeLine))
    End_Function

    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
    // RemoveLeft("D", "ABC")                   -> "ABC"
    // RemoveLeft("is ", "This is an example")  -> "an example"
    // Note: It it also works within strings e.g. "This is a string"
    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
        Integer iPosStart iPosEnd
        String sText

        Move sHostString to sText
        Move (Pos(sSubString, sText)) to iPosStart
        Move (iPosStart + Length(sSubString) - 1) to iPosEnd

        If (iPosStart) Begin
            If (iPosEnd = Length(sText)) Begin
                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
            End
            Else Begin
                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
            End
        End

        Function_Return (sHostString <> sText)
    End_Function

    // ReplaceLast returns a string with the last occurrence of a specified substring in a
    // host String replaced with a new substring.
    Function _ReplaceLast String sFrom String sSource String sTo Returns String
        String sRetval
        Integer iLastPos
    
        Move (RightPos(sFrom, sSource)) to iLastPos
        If (iLastPos > 0) Begin
            Move (Mid(sSource, iLastPos - 1, iLastPos - 1) + Replace(sFrom, Mid(sSource, Length(sSource) - iLastPos, (Length(sSource) - iLastPos) + 1), sTo)) to sRetval
        End
        Else Begin
            Move sSource to sRetval
        End
    
        Function_Return sRetval
    End_Function

    Function _ReplaceLegacyOperators String sOverStrikeLine String sFromOperator String sToOperator Returns String
        Integer iPos
        String sCharleft sCharRight sCharNew
        
        Move (Trim(sFromOperator)) to sFromOperator
        Move (Left(sFromOperator, 1))  to sCharleft
        Move (Right(sFromOperator, 1)) to sCharRight
        Move (" " + String(sFromOperator) + " ") to sFromOperator
        Move (" " + String(sToOperator) + " ") to sToOperator
        
        // Lowercase all
        Move (Lowercase(sFromOperator)) to sFromOperator
        Move (Pos(sFromOperator, sOverStrikeLine)) to iPos
        If (iPos > 0) Begin
            Move (Replaces(sFromOperator, sOverStrikeLine, sToOperator)) to sOverStrikeLine
        End
        
        // Uppercase first character
        Move (Uppercase(sCharleft)) to sCharNew
        Move (Replace(sCharleft, sFromOperator, sCharNew)) to sFromOperator
        Move (Pos(sFromOperator, sOverStrikeLine)) to iPos
        If (iPos > 0) Begin
            Move (Replaces(sFromOperator, sOverStrikeLine, sToOperator)) to sOverStrikeLine
        End
        
        // Uppercase last character
        Move (Uppercase(sCharRight)) to sCharNew
        Move (Replace(sCharRight, sFromOperator, sCharNew)) to sFromOperator
        Move (Pos(sFromOperator, sOverStrikeLine)) to iPos
        If (iPos > 0) Begin
            Move (Replaces(sFromOperator, sOverStrikeLine, sToOperator)) to sOverStrikeLine
        End
        
        // Uppercase all
        Move (Uppercase(sFromOperator)) to sFromOperator
        Move (Pos(sFromOperator, sOverStrikeLine)) to iPos
        If (iPos > 0) Begin
            Move (Replaces(sFromOperator, sOverStrikeLine, sToOperator)) to sOverStrikeLine
        End
        
        Function_Return sOverStrikeLine
    End_Function

    // Returns the first word of any input string
    // all up to the first space encountered
    Function _RetrieveFirstToken String sOverStrikeLine Returns String
        String sFirstWord
        Integer iPos
        Boolean bChanged

        Get _NormalizeArrayNotation (&sOverStrikeLine) to bChanged
        Move (Trim(sOverStrikeLine)) to sOverStrikeLine
        Move (Pos(" ", sOverStrikeLine)) to iPos
        If (iPos = 0) Begin
            Move "" to sFirstWord
        End
        Else Begin
            Move (Left(sOverStrikeLine, (iPos -1))) to sFirstWord
        End
        Move (Trim(sFirstWord)) to sFirstWord
        Function_Return sFirstWord
    End_Function    
    
    // This is a *private* helper function for the ChangeLegacyIndicators function.
    //
    // It only acts on a sOverStikeLine that starts with an indicator e.g. "[Found]"
    // '[Found] Reread // End comment'
    // '[Found] Repeat // End comment'
    // '[not Found] While // End comment'
    // '[not Seqeof] Repeat // End comment'
    // '[Not Found]   Reread'
    // '[Not Found] Move iA to iB // End comment'
    // '[Found] Loop // End comment'
    // '[not Seqeof] Loop // End comment'
    // '[Select] Indicate Select as WindowIndex Eq FieldIndex'
    // '[Found] Delete hTable'
    // '[Found] If (iA <> iB) Move False to Found'
    {Visibility = Private}
    Function _ChangeLegacyIndicators_Sub tTokenizer TokenizerData String sOverStrikeLine Boolean ByRef bChanged Returns String
        String sToken sLine sMove sIf sTo sFirstCmd sSecondCmd sFirstBoolean
        Integer iItem iSize iPos iCount iLeftParanthesis iRightParanthesis
        Boolean bHasIf bHasMove bHasTo bIndicateCmd

        Move TokenizerData.asLineTokens[iItem] to sToken
        If (Left(sToken, 1) <> "[") Begin
            Function_Return sOverStrikeLine
        End

        // Has If-statement?
        Move (TokenizerData.bHasIfCommand = True) to bHasIf
        If (bHasIf = True) Begin
            Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move TokenizerData.asLineTokens[iItem] to sIf
            End
        End
        Else Begin
            Move CS_If to sIf
        End

        // Has an "Indicate" command?
        Move TokenizerData.BooleanIndicator.bHasIndicateCommand to bIndicateCmd

        // Has Move-statement?
        Move (SearchArray(CS_Move, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sMove
        End
        Else Begin
            Move CS_Move to sMove
        End
        Move (iItem <> -1) to bHasMove

        // Has To-statement?
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sTo
        End
        Else Begin
            Move CS_To to sTo
        End
        Move (iItem <> -1) to bHasTo

        Move TokenizerData.FirstLeftCommand.sCode  to sFirstCmd
        Move TokenizerData.SecondLeftCommand.sCode to sSecondCmd
        Move TokenizerData.BooleanIndicator.FirstBoolean.sCode  to sFirstBoolean
        Move 0 to iItem

        // Take care of the part before the "to" keyword:
        Case Begin
            Case (Lowercase(sFirstCmd) = Lowercase(CS_Indicate))
                If (TokenizerData.BooleanIndicator.FirstBoolean.bHasBracket = True) Begin
                    Move (sIf * String(TokenizerData.BooleanIndicator.FirstBoolean.sCode) * String(sMove)) to sOverStrikeLine
                End
                Else Begin
                    Move sMove to sOverStrikeLine
                End
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                   Move TokenizerData.BooleanIndicator.AsBoolean.sCode to sToken
                End
                Else Begin
                    Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                End
                Append sOverStrikeLine " " sToken
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_If))
                Move sIf to sOverStrikeLine
                If (sFirstBoolean <> "" and TokenizerData.sLeftExpression1 <> "") Begin
                    Append sOverStrikeLine " (" sFirstBoolean " and " TokenizerData.sLeftExpression1 ")"
                    If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                        Append sOverStrikeLine " " TokenizerData.SecondLeftCommand.sCode
                        Append sOverStrikeLine " " TokenizerData.BooleanIndicator.SecondBoolean.sCode
                    End
                    Else Begin
                        Move (SearchArray(TokenizerData.sLeftExpression1, TokenizerData.asLineTokens)) to iItem
                        If (iItem <> -1) Begin
                            For iCount from (iItem +1) to (SizeOfArray(TokenizerData.asLineTokens) -1)
                                Append sOverStrikeLine " " TokenizerData.asLineTokens[iCount]
                            Loop
                        End
                    End
                End
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_Move))
                Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                Move (sIf * String(sToken) * String(sMove)) to sOverstrikeLine
                If (TokenizerData.bHasEndSemiColon = True) Begin
                    Move TokenizerData.sLine to sLine
                    Get _RemoveEndComment sLine to sLine
                    Move (Pos(" " + Lowercase(CS_Move) + " ", Lowercase(sLine))) to iPos
                    If (iPos <> 0) Begin
                        Move (Mid(sLine, Length(sLine), (iPos + Length(CS_Move) + 2))) to sToken
                        Append sOverStrikeLine " " sToken
                    End
                End
                Else Begin
                    Append sOverStrikeLine " " TokenizerData.BooleanIndicator.SecondBoolean.sCode
                End
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_Repeat))
                If (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "") Begin
                    Move CS_While to sOverStrikeLine
                    If (Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) <> "(") Begin
                        Move ("(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + ")") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
                    End
                    Append sOverStrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                Else Begin
                    Move sFirstCmd to sOverStrikeLine
                End
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_While))
                Move sFirstCmd to sOverStrikeLine
                If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                    Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                End
                Else Begin
                    Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                End
                Append sOverStrikeLine " " sToken
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_Until) or Lowercase(sFirstCmd) = Lowercase(CS_Loop))
                Move sFirstCmd to sOverstrikeLine
                If (Lowercase(sFirstCmd) = Lowercase(CS_Until)) Begin
                    If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                        Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                    End
                    Else Begin
                        Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                    End
                    Append sOverStrikeLine " " sToken
                End
                Case Break

            Case (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "")
                Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
                Decrement iSize
                Move CS_If to sOverstrikeLine
                If (TokenizerData.BooleanIndicator.FirstBoolean.bDoubleBoolean = True) Begin
                    Get _ConstructDoubleBooleanExpression TokenizerData to sToken
                    Append sOverStrikeLine " " sToken
                    Move 0 to iSize
                End
                Else Begin
                    Append sOverStrikeLine " " sFirstBoolean
                End
                If (sFirstCmd = "") Begin
                    Increment iItem
                    If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
                        Increment iItem
                    End
                    Move TokenizerData.asLineTokens[iItem] to sFirstCmd
                End
                Append sOverstrikeLine " " sFirstCmd
                Move 1 to iItem
                If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
                    Increment iItem
                End
                If (iSize > iItem) Begin
                    Increment iItem
                    While (iItem <= iSize)
                        Move TokenizerData.asLineTokens[iItem] to sToken
                        If (Lowercase(sToken) = Lowercase(CS_To)) Begin
                            Move iSize to iItem // Get out of here
                        End
                        Else If (Trim(sToken) <> "") Begin
                            Append sOverstrikeLine " " sToken
                        End
                        Increment iItem
                    Loop
                End
                Case Break

            Case Else

        Case End

        // "To" part:
        If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
            Append sOverStrikeLine " " sTo
            Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
            Get ReplaceParanthesis sToken to sToken
            Append sOverStrikeLine " " sToken
        End
        Else If (TokenizerData.BooleanIndicator.ToBoolean.sCode <> "") Begin
            Append sOverStrikeLine " " sTo
            Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken  
            Get _NumberOfParanthesis sToken (&iLeftParanthesis) to iRightParanthesis
            If (iLeftParanthesis = 1 or iRightParanthesis = 1) Begin
                Get ReplaceParanthesis sToken to sToken
            End
            Append sOverStrikeLine " " sToken
        End

        Function_Return sOverStrikeLine
    End_Function

    // Splits up the tokens/elements of the input string into two string arrays, but without indentation and end comment.
    // The line will be broken up by spaces " ", *except* for expressions. Each expression will exist as a
    // separate member/item.
    Function _SplitSourceLineToTokens tTokenizer ByRef TokenizerData Returns tTokenizer
        String sOverstrikeLine sItem sReplace sOrg sOverWrite sExpression sToken
        String[] asLineTokens
        Integer iSize iSizeSC iCount iCountSC iItem iPos iString iStringConstantSize
        Boolean bFound
        tExpression[] aExpressions aExpressionsEmpty 
        tExpression Expression  
        tQuotedString[] asStringConstant 
        tQuotedString QuotedString

        // We need to retrieve expressions from the sOverstrikeLine, as they else will
        // be splitted on several items (if expression contains spaces) in the array and
        // we want each expression as one array member.
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        Move TokenizerData.sOverstrikeLine to sOrg
        
        // _ExtractExpression is called recursively. This is why we use a procedure as it simplifies the work for us.
        Send _ExtractExpressions sOverstrikeLine sOrg (&TokenizerData) (&aExpressions)
        // The overstrikeline may have been changed by the _ExtractExpressions function (if concatenated spaces found in expression)
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        Move (SizeOfArray(aExpressions)) to iSize
        Decrement iSize

        // If expressions exists, temporarily replace them with the "|" symbol, before
        // splitting string to array.
        If (iSize <> -1) Begin
            Move aExpressions to TokenizerData.aExpressions
            For iCount from 0 to iSize
                Move (FillString("|", aExpressions[iCount].iLength)) to sReplace
                Move (Pos(aExpressions[iCount].sExpression, sOverstrikeLine)) to iPos 
                If (iPos = 0) Begin
                    Move (Pos(aExpressions[iCount].sExpressionOS, sOverstrikeLine)) to iPos
                    If (iPos <> 0) Begin
                        Move aExpressions[iCount].sExpressionOS to sExpression 
                        Move iPos to aExpressions[iCount].iStartPos
                    End
                    Else Begin
                        Move aExpressions[iCount].sExpressionNP to sExpression
                    End
                    Move (Pos(sExpression, sOverstrikeLine)) to iPos
                End
                If (iPos <> 0) Begin
                    Move (Overstrike(sReplace, sOverstrikeLine, aExpressions[iCount].iStartPos)) to sOverstrikeLine
                End
            Loop
        End
        Else Begin
            Move aExpressionsEmpty to TokenizerData.aExpressions
        End

        Move (StrSplitToArray(sOverstrikeLine, " ")) to asLineTokens
        Move (SizeOfArray(asLineTokens)) to iSize
        Decrement iSize
        // Remove any empty items:
        For iCount from 0 to iSize
            If (asLineTokens[iCount] = "") Begin
                Move (RemoveFromArray(asLineTokens, iCount)) to asLineTokens
                Decrement iSize
                Decrement iCount
            End
            Else If (asLineTokens[iCount] = "]") Begin
                Move (asLineTokens[iCount - 1] + "]") to asLineTokens[iCount - 1]
                Move (RemoveFromArray(asLineTokens, iCount)) to asLineTokens
                Decrement iSize
                Decrement iCount
            End
        Loop   
        
        // If there are any string constants, replace the overstriked value with the original text string:
        Move (SizeOfArray(TokenizerData.asStringConstant)) to iSizeSC
        If (iSizeSC <> 0) Begin
            Decrement iSizeSC    
            Move 0 to iCountSC
            Move (SizeOfArray(asLineTokens)) to iSize
            Decrement iSize
            For iCount from 0 to iSize
                Move asLineTokens[iCount] to sToken 
                Get _IsOverwriteValue sToken to bFound
                // Also check that the asStringConstant content is not part of an expression.
                If (bFound = True and iCountSC <= iSizeSC) Begin 
                    Move TokenizerData.asStringConstant[iCountSC].sContent to sItem
                    Move sItem to Expression.sExpression
                    Move (SearchArray(Expression, aExpressions, Self, RefFunc(__FindExpressionArrayContains))) to iItem
                    If (iItem <> -1 and iCountSC < iSizeSC) Begin
                        Move TokenizerData.asStringConstant[iCountSC + 1].sContent to sItem       
                    End
                    Move sItem to asLineTokens[iCount]  
                    Increment iCountSC
                End
            Loop
        End
        
        Move (SizeOfArray(TokenizerData.asStringConstant)) to iStringConstantSize
        Decrement iStringConstantSize
        Move 0 to iString 
        Move False to Err
        // If there were any expressions, place them back into the asLineTokens array as items.
        Move (SizeOfArray(aExpressions)) to iSize
        Decrement iSize 
        If (iSize <> -1) Begin
            For iCount from 0 to iSize
                Move (FillString("|", aExpressions[iCount].iLength)) to sReplace
                Move (Pos(aExpressions[iCount].sExpressionOS, sOverstrikeLine)) to iPos 
                Move (SearchArray(sReplace, asLineTokens)) to iItem
                If (iItem <> -1) Begin 
                    If (iString <= iStringConstantSize) Begin
                        Move TokenizerData.asStringConstant[iString].sOverwrite to sOverWrite
                        Move (Pos(sOverWrite, aExpressions[iCount].sExpressionOS)) to iPos
                        If (iPos <> 0) Begin
                            Move (Replace(sOverwrite, aExpressions[iCount].sExpression, TokenizerData.asStringConstant[iString].sContent)) ;
                                to aExpressions[iCount].sExpression
                            Increment iString
                        End
                    End
                    Move aExpressions[iCount].sExpression to asLineTokens[iItem]
                End
            Loop
        End

        Move asLineTokens to TokenizerData.asLineTokens
        Function_Return TokenizerData
    End_Function

    // Stack interface: (strings) LiFo - Last In First Out 
    Procedure _PushStack String sValue String[] ByRef aValues
        Move sValue to aValues[-1]
    End_Procedure
    
    // Returns "-1" if stack is empty
    Function _PopStack String[] ByRef asValues Returns String
        Integer iSize
        String sValue
        Move (SizeOfArray(asValues) -1) to iSize
        If (iSize >= 0) Begin
            Move asValues[iSize -1] to sValue
            Move (ResizeArray(asValues, iSize -1)) to asValues
        End
        Else Begin
            Move "-1" to sValue
        End
        Function_Return sValue
    End_Function
    
    // Does the stack contain any values?
    Function _StackIsEmpty String[] asValues Returns Boolean
        Function_Return (SizeOfArray(asValues) = 0)
    End_Function
    
    // Initialize stack to be empty
    Procedure _InitStack String[] ByRef asValues
        Integer iSize
        Move (SizeOfArray(asValues)) to iSize
        Move (ResizeArray(asValues, iSize -1)) to asValues
    End_Procedure
    
    // Helper function. This is a list of commands that also exists as DataFlex string functions.
    Function _TestCommandFunctions String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommandFunctions

        Move 0 to iPos
        Get RemoveComments (&sTest) to bRemoved
        Get pasCommandFunctions to asCommandFunctions
        Move (SizeOfArray(asCommandFunctions)) to iSize
        If (iSize = 0) Begin
            Get pasCommandFunctions to asCommandFunctions
            Move (SizeOfArray(asCommandFunctions)) to iSize
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommandFunctions[iCount] to sCommand
            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop

        Function_Return iPos
    End_Function

    // Get the "to xxx" part, but without the "to" keyword.
    Function _ToStatement tTokenizer ByRef TokenizerData Returns tToken
        String sToStatement sOverWrite sLine
        Integer iPos iSize iCount iStart iItem iEnd
        tToken Data
        
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return Data
        End
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return Data
        End
        
        Move (iItem + 1) to iStart    
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize     
        For iCount from iStart to iSize
            Append sToStatement TokenizerData.asLineTokens[iCount] " "
        Loop           

        Move (Pos(Lowercase(CS_To * String(Data.sCode)), Trim(Lowercase(TokenizerData.sLine)))) to iStart
        Move (iStart + 2)         to Data.iStartPos // "Of" = +2
        Move (Trim(sToStatement)) to Data.sCode

        Function_Return Data
    End_Function

    Function _CollectTokenizerFromProperties tTokenizer TokenizerData Returns tTokenizer
        Get pbInCommand                    to TokenizerData.bIsInCommand
        Get pbIsInPage                     to TokenizerData.bIsInImage
        Get pbInFunction                   to TokenizerData.bIsInFunction
        Get pbInProcedure                  to TokenizerData.bIsInProcedure
        Get pbInClass                      to TokenizerData.bIsInClass
        Get pbInStruct                     to TokenizerData.bIsInStruct
        Get pbIsInSemiColonMultiLineString to TokenizerData.bHasEndSemiColon
        Get pbIsInDF23MultiLineComment     to TokenizerData.bIsInDF23MultiLineComment
        Get pbIsInDF23MultiLineString      to TokenizerData.bIsInDF23MultiLineString
        Get pbIsOpenString                 to TokenizerData.bIsOpenString
        Function_Return TokenizerData
    End_Function
        
    // * Dummy function for the Studio's Code Explorer *
    // *** MAIN PUBLIC MESSAGE for this system class is the Tokenizer ***
    Procedure MAIN_PUBLIC_MESSAGE_TOKENIZER
    End_Procedure
    
    // Syntax:
    //    Get Tokenizer sSourceLine to TokenizerData (struct variable)
    // It splits up the passed source line (sLine) to members of the tTokenizer struct.
    // It then sets the pTokenizer struct property, so that any message of the
    // cRefactorFuncLib class can use those member values to do their thing.
    //
    // Note: If the line is a compound statement (one that spans over several lines),
    //       e.g. it contains a ";" or one '"""', the function will set the
    //       properties; pbIsOpenString or pbInMultiLineString.
    Function Tokenizer String sLine Returns tTokenizer
        tTokenizer TokenizerData
        tExpression[] aExpression
        Boolean bFound bEnd bInMultiLineString bIsDoubleQuoteStart bIsOpenCommand bStatus

        Move sLine to TokenizerData.sLine
        // Place all cases for when we are done at the top of
        // of this function so we can jump out.
        //
        // Standard commented lines that uses double-slashes "//":
        Get _IsCommentLine TokenizerData.sLine to TokenizerData.bIsComment
        Get _IsBlankLine   TokenizerData.sLine to TokenizerData.bIsBlank
        Get _IsOpenCommand TokenizerData.sLine to bIsOpenCommand
        If (TokenizerData.bIsComment = True or TokenizerData.bIsBlank = True or bIsOpenCommand = True) Begin 
            Get _CollectTokenizerFromProperties TokenizerData to TokenizerData
            Move True                                      to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        
        // Note. This needs to before the new DF23 multi-line string/comment logic.
        // Old DataFlex 2.3 and earlier syntax that used "image pages". Looks like; "/MyPage" and ends with a "/*"
        // We will do nothing with such lines.
        If (pbIsInPage(Self) = True) Begin
            Get IsImageEnd TokenizerData.sLine to bFound
            If (bFound = True) Begin
                Send _ClearRefactoringProperties
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End 
            Else Begin
                Move True to TokenizerData.bIsInImage
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End
        Else If (pbIsInPage(Self) = False) Begin
            Get IsImageStart TokenizerData.sLine to TokenizerData.bIsInImage
            If (TokenizerData.bIsInImage = True) Begin
                Send _ClearRefactoringProperties
                Set pbIsInPage to True
                Move True to TokenizerData.bIsInImage
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End
        
        // DF 23 multi-line commented line style. Starts with a /* and ends with */
        If (pbIsInDF23MultiLineComment(Self) = True) Begin
            Get _IsDF23CommentEnd TokenizerData.sLine to bFound
            If (bFound = True) Begin
                Send _ClearRefactoringProperties
            End
            Else Begin
                Get _CollectTokenizerFromProperties TokenizerData to TokenizerData
            End
            Move True to TokenizerData.bIsInDF23MultiLineComment
            Get _DF23CommentOverwrite TokenizerData.sLine to TokenizerData.sOverstrikeLine
            Move True to TokenizerData.bIsComment
            Move True to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        Else Begin
            Get _IsDF23CommentStart TokenizerData.sLine to TokenizerData.bIsInDF23MultiLineComment
            If (TokenizerData.bIsInDF23MultiLineComment = True) Begin
                Get _DF23CommentOverwrite TokenizerData.sLine to TokenizerData.sOverstrikeLine
                Send _ClearRefactoringProperties
                Set pbIsInDF23MultiLineComment to True
                Move True to TokenizerData.bIsComment
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End

        // Get the indentation part
        Get _Indentation (&TokenizerData) to TokenizerData.sIndentation
        // Get the end comment part
        Get EndComment sLine             to TokenizerData.sEndComment

        // This will overstrike string constant characters with "_" characters for a "some text" and
        // '+' characters for a 'some other text'
        // This is so the refactoring functions does not get confused by the content of string literals.
        // E.g. Move "We will *move* some of the warehouse" to sText is changed to: Move "________________________________" to sText
        // Thus, most refactoring funtions should be using the sOverstrikeLine member value, rather then the
        // original sLine content itself.
        Get _OverstrikeStrings (&TokenizerData) to TokenizerData.sOverstrikeLine
        
        Get _IsPrnLine TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Move True to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        
        Get _IsGotoLabel TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Move True to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        
        // Old school multi-line, ending with a semi-colon (;)
        Get _HasLineEndSemiColon TokenizerData.sOverstrikeLine to TokenizerData.bHasEndSemiColon
        Set pbIsInSemiColonMultiLineString  to TokenizerData.bHasEndSemiColon

        // DF 23 Multi-line strings are lines ending with a @, @SQL or """
        // The property pbIsInDF23MultiLineString is set as soon as such a
        // multi-line string is started (and not ended):
        If (pbIsInDF23MultiLineString(Self) = True) Begin
            Get _IsDF23String (&TokenizerData) to TokenizerData.bIsDF23String
            Get _IsMultiLineStringEnd TokenizerData.sOverstrikeLine to bFound
            If (bFound = True) Begin
                Send _ClearRefactoringProperties
                Move True to TokenizerData.bLineIsReady 
                Move False to TokenizerData.bIsDF23String
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
            Else Begin
                Get pbIsOpenString to TokenizerData.bIsOpenString
                If (TokenizerData.bIsOpenString = False) Begin
                    Get _IsOpenString TokenizerData.sOverstrikeLine to TokenizerData.bIsOpenString
                    Set pbIsOpenString to TokenizerData.bIsOpenString
                End
                If (TokenizerData.bIsOpenString = True or TokenizerData.bIsDF23String = True) Begin
                    Get _CollectTokenizerFromProperties TokenizerData to TokenizerData
                    Move True to TokenizerData.bIsInDF23MultiLineString
                    Move False to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
                Else Begin
                    Send _ClearRefactoringProperties
                End
            End
        End
        // Check if we have the start of a DF 23 multi-line string.
        Else Begin
            Get _IsDF23String (&TokenizerData) to TokenizerData.bIsDF23String
            Get _IsMultiLineStringStart (&TokenizerData) to bInMultiLineString
            If (bInMultiLineString = True) Begin
                Move bInMultiLineString       to TokenizerData.bIsInDF23MultiLineString
                Set pbIsInDF23MultiLineString to bInMultiLineString
                Get _IsOpenString TokenizerData.sOverstrikeLine to TokenizerData.bIsOpenString
                Set pbIsOpenString                              to TokenizerData.bIsOpenString
                Get _IsDoubleQuoteStart TokenizerData.sOverstrikeLine to bIsDoubleQuoteStart
                Set pbIsInSingleQuote to (bIsDoubleQuoteStart = False)
            End
            If (TokenizerData.bIsDF23String = True or bInMultiLineString = True) Begin
                Get _CollectTokenizerFromProperties TokenizerData to TokenizerData
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End
        // *** End of tests that sets the TokenizerData.bLineIsReady = True.

        // Note: This also fills the TokenizerData.aExpressions member with data.
        Get _SplitSourceLineToTokens (&TokenizerData) to TokenizerData

        // Set properties to indicate if we are inside a function or a procedure.
        // Needs to be after calls to _OverstrikeStrings & _SplitSourceLineToTokens
        If (pbInFunction(Self) = True) Begin
            // Note: We will also indicate "end-of-function" if a new Funtion declaration is found (missing End_Function)
//            If (Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_FunctionEnd)) or Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_Function))) Begin
            If (Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_FunctionEnd))) Begin
                Move False to TokenizerData.bIsInFunction
                Set pbInFunction to False
                If (Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_FunctionEnd))) Begin
                    Send _ClearRefactoringProperties
                    Move True to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End
            Else Begin
                Move True to TokenizerData.bIsInFunction
                Get _IsProcedureDeclaration TokenizerData.sOverstrikeLine to bStatus
                If (bStatus = True) Begin
                    Move True to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End
        End
        Else Begin
            Get _IsFunctionDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInFunction
            Set pbInFunction to TokenizerData.bIsInFunction
            If (TokenizerData.bIsInFunction = True) Begin
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End

        If (pbInProcedure(Self) = True) Begin
            // Note: We will also indicate "end-of-procedure" if a new Procedure declaration is found (missing End_Procedure)
//            If (Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_ProcedureEnd)) or Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_Procedure))) Begin
            If (Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_ProcedureEnd))) Begin
                Move False to TokenizerData.bIsInProcedure
                Set pbInProcedure to False
                If (Lowercase(TokenizerData.asLineTokens[0]) = (Lowercase(CS_ProcedureEnd))) Begin
                    Send _ClearRefactoringProperties
                    Move True to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End
            Else Begin
                Move True to TokenizerData.bIsInProcedure
                Get _IsProcedureDeclaration TokenizerData.sOverstrikeLine to bStatus
                If (bStatus = True) Begin
                    Move True to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End
        End
        Else Begin
            Get _IsProcedureDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInProcedure
            Set pbInProcedure to TokenizerData.bIsInProcedure
            If (TokenizerData.bIsInProcedure = True) Begin
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End

        If (pbInCommand(Self) = True) Begin 
            Get _IsCommandEnd TokenizerData.sLine to bFound
            If (bFound = True) Begin
                Send _ClearRefactoringProperties
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End  
            Else Begin
                Move True to TokenizerData.bIsInCommand
            End
        End
        Else Begin
            Get _IsCommandDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInCommand
            Set pbInCommand to TokenizerData.bIsInCommand
        End

        If (pbInClass(Self) = True) Begin 
            Get _IsClassEnd TokenizerData.sLine to bFound
            If (bFound = True) Begin
                Send _ClearRefactoringProperties
                Move True  to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End  
            Else Begin
                Move True to TokenizerData.bIsInClass
            End
        End
        Else Begin
            Get _IsClassDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInClass
            Set pbInClass to TokenizerData.bIsInClass
        End

        If (pbInStruct(Self) = True) Begin 
            Get _IsStructEnd TokenizerData.sLine to bFound
            If (bFound = True) Begin
                Send _ClearRefactoringProperties
                Move True  to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End  
            Else Begin
                Move True to TokenizerData.bIsInStruct
            End
        End
        Else Begin
            Get _IsStructDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInStruct
            Set pbInStruct to TokenizerData.bIsInStruct
        End

        Get IsVariableDeclarationLine TokenizerData.sOverstrikeLine to TokenizerData.bIsVariableDeclaration
        If (TokenizerData.bIsVariableDeclaration = True and (TokenizerData.bIsInFunction = True or TokenizerData.bIsInProcedure = True or TokenizerData.bIsInCommand = True)) Begin
            Set pbIsInDF23MultiLineString   to False
            Set pbIsOpenString              to False
            Set pbIsInSingleQuote           to False
            Move False to TokenizerData.bLineIsReady
            Move False to TokenizerData.bIsInDF23MultiLineString
            Move False to TokenizerData.bIsOpenString
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End

        Get _HasIfCommand TokenizerData.sOverstrikeLine to TokenizerData.bHasIfCommand
        // Get start and end indicators
        // "Indicate [Select] as [not Found]" -> bHasIndicateCommand = True
        Get _ExtractLegacyBooleanContent (&TokenizerData) to TokenizerData.BooleanIndicator

        // Get the "*Move iA* to xxx" part
        Get _LeftStatement (&TokenizerData) to TokenizerData.LeftStatement
        // Get the "of xxx" part
        Get _OfStatement (&TokenizerData) to TokenizerData.OfStatement
        // Get the "to xxx" part
        Get _ToStatement (&TokenizerData) to TokenizerData.ToStatement

        Get _LeftCommand (&TokenizerData) eFirstCommand  to TokenizerData.FirstLeftCommand
        Get _LeftCommand (&TokenizerData) eSecondCommand to TokenizerData.SecondLeftCommand

        // Note: The aExpressions member contains all of these together with the position in the source line.
        //       And yes, this is tautological, but helps when creating cRefactorFuncLib functions.
        Get _FetchExpression TokenizerData.aExpressions eLeftExpression1 to TokenizerData.sLeftExpression1
        Get _FetchExpression TokenizerData.aExpressions eLeftExpression2 to TokenizerData.sLeftExpression2
        Get _FetchExpression TokenizerData.aExpressions eOfExpression    to TokenizerData.sOfExpression
        Get _FetchExpression TokenizerData.aExpressions eToTexpression   to TokenizerData.sToExpression
        Get _LogicalOperators (&TokenizerData) to TokenizerData.OperatorsInfo

        // *** Note ***
        // Intead of calling this Tokenizer function from the cRefactorFuncLib,
        // each function should do a "Get pTokenizer to TokenizerData" and use that ready-made tokenized data,
        // that was created once for each source line by this function.
        // This tokenizer call will be made automatically by the logic in DFRefactor.src & TestBenchRefactorFunctions.src.
        Set pTokenizer to TokenizerData

        Function_Return TokenizerData
    End_Function

End_Class
