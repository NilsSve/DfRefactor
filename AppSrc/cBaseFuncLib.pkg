Use Windows.pkg
Use RefactorConstants.inc
Use cRemoveUnusedLocals.pkg
Use cUnusedSourceFiles.pkg
Use cDDOReStyler.pkg
Use cScintillaRefactorEditor.pkg
Use cRegex.pkg

Register_Function phoEditor Returns Handle 
Register_Function phoRemoveUnusedLocals Returns Handle
Register_Function phoReportUnusedSourceFiles Returns Handle

#IFNDEF ghoRefactorFunctionLibrary
Global_Variable Handle ghoRefactorFunctionLibrary
#ENDIF

#IFNDEF ghoStatusLog
Global_Variable Handle ghoStatusLog
#ENDIF

Use cSysFileDataDictionary.dd  
Open FunctionsA

Class cBaseFuncLib is a cObject
    Procedure Construct_Object
        Handle ho
        
        Forward Send Construct_Object
        Move Self to ghoRefactorFunctionLibrary
        
        Property Integer piLastErr 0 
        Property Boolean pbErr False
        
        Property Handle phoEditor
        Property Integer peNewStyle eDDUnknown 
        Property Integer piTabSize

        Property tRefactorSettings pRefactorSettings
        //
        Property Boolean pbToggleState True     
        Property Boolean pbInRepeatLoop False     
        Property Boolean pbInProcedure False
        Property Boolean pbInFunction False
        Property Boolean pbIsInPage False
        // New DF 23 multi-line comments. Starts with a /* and ends with */
        Property Boolean pbIsInDF23MultiLineComment False
        
        // Old school string contants that ends each line with a semi-colon (;) 
        // Used in conjunction with the tTokenizer bHasEndSemiColon member.
        Property Boolean pbIsInSemiColonMultiLineString False
        // New DF 23 school multi-line strings
        Property Boolean pbIsInDF23MultiLineString False
        Property Boolean pbIsOpenString False 
        Property Boolean pbIsInSingleQuote False
        
        // Contains all info from the current "sLine" source.
        // *** To be used by all cRefactorFuncLib functions ***
        Property tTokenizer pTokenizer          

//        // Array of string constants that has been overwritten by the _OverstrikeStrings function. The
//        // content of the overstriked data is kept in the tTokenizer.sOverstrikeLine member and the 
//        // original string content(s) is kept in this paStringContent array property for the current source line.
//        Property tQuotedString[] paStringContent
        
        // All commands from the manual list in this class.
        Property String[] pasCommands
        // Commands that also exists as functions.
        Property String[] pasCommandFunctions    
        Property String[] pasLocalVariableTypes
        Property String[] pasLocalVariableArrayTypes
         
        // Data from the Scintilla editor. See ScintillaParameters.dg
        // Scoped words are; Begin/End While/Loop, Procedure/End_Procedure etc.
        Property String[] pasScopeStart
        // The closing scoped part. There is a 1-1 relationship between the two arrays.
        Property String[] pasScopeEnd   
        // All keywords from the Scintilla editor.
        Property String[] pasKeyWords
        // All operators from the Scintilla editor.
        Property String[] pasOperators

        // Properties for the RemoveProjectObjectStructure function:
        Property Boolean pbProjectObjectStructureStart False 
        Property Boolean pbProjectObjectStructureEnd False
        Property Boolean pbRegisterAllObjectsStart False    
        Property Boolean pbRegisterAllObjectsEnd False
        Property String[] pasObjectNames

        // Object handles for special refactoring functions,
        // written by other developers:
        Property Handle phoRemoveUnusedLocals
        Get Create (RefClass(cRemoveUnusedLocals)) to ho
        Set phoRemoveUnusedLocals to ho 
        
        Property Handle phoReportUnusedSourceFiles 
        Get Create (RefClass(cUnusedSourceFiles)) to ho
        Set phoReportUnusedSourceFiles to ho 

        Property Handle phoDDOReStyler
        Get Create (RefClass(cDDOReStyler)) to ho
        Set phoDDOReStyler to ho 

    End_Procedure

    // ToDo: *** MAIN PUBLIC MESSAGE for this system class ***
    //     The "ToDo" used above is only for informational purposes in the Code Explorer.
    // Syntax:
    //    Get Tokenizer sSourceLine to TokenizerData (struct variable)
    // It splits up the passed source line (sLine) to members of the tTokenizer struct.
    // It then sets the pTokenizer struct property, so that any message of the
    // cRefactorFuncLib class can use those member values to do their thing.
    //
    // Note: If the line is a compound statement (one that spans over several lines),
    //       e.g. it contains a ";" or one '"""', the function will set the
    //       properties; pbIsOpenString or pbInMultiLineString.
    Function Tokenizer String sLine Returns tTokenizer
        tTokenizer TokenizerData
        tExpression[] aExpression        
        String sText sText2 sChar sCommand
        Boolean bFound bMoveCommand bInMultiLineString bIsDoubleQuoteStart
        Integer iPos iStart iEnd
                                                
        Move sLine to TokenizerData.sLine
        // Place all cases for when we are done at the top of
        // of this function so we can jump out.
        //
        // Standard commented lines that uses double-slashes "//":
        Get _IsCommentLine sLine to TokenizerData.bIsComment
        Get _IsBlankLine   sLine to TokenizerData.bIsBlank
        If (TokenizerData.bIsComment = True or TokenizerData.bIsBlank = True) Begin
            Set pbIsInSemiColonMultiLineString  to False
            Set pbIsInDF23MultiLineString       to False   
            Set pbIsOpenString                  to False
            Set pbIsInSingleQuote               to False
            Move True                           to TokenizerData.bLineIsReady 
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End  
        
        // DF 23 multi-line commented line style. Starts with a /* and ends with */ 
        If (pbIsInDF23MultiLineComment(Self) = True) Begin
            Get _IsDF23CommentEnd TokenizerData.sLine to bFound 
            If (bFound = True) Begin
                Set pbIsInDF23MultiLineComment to False
            End
            Move True to TokenizerData.bIsInDF23MultiLineComment
            Get _DF23CommentOverwrite TokenizerData.sLine to TokenizerData.sOverstrikeLine
            Set pbIsInDF23MultiLineString       to False   
            Set pbIsOpenString                  to False
            Set pbIsInSingleQuote               to False
            Set pbIsInSemiColonMultiLineString  to False
            Move True  to TokenizerData.bIsComment
            Move True  to TokenizerData.bLineIsReady
            Move False to TokenizerData.bIsInDF23MultiLineString
            Move False to TokenizerData.bIsOpenString
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        Else Begin
            Get _IsDF23CommentStart TokenizerData.sLine to TokenizerData.bIsInDF23MultiLineComment
            If (TokenizerData.bIsInDF23MultiLineComment = True) Begin
                Get _DF23CommentOverwrite TokenizerData.sLine to TokenizerData.sOverstrikeLine
                Set pbIsInDF23MultiLineComment      to True
                Set pbIsInDF23MultiLineString       to False   
                Set pbIsOpenString                  to False
                Set pbIsInSingleQuote               to False
                Set pbIsInSemiColonMultiLineString  to False
                Move True  to TokenizerData.bIsComment
                Move True  to TokenizerData.bLineIsReady
                Move False to TokenizerData.bIsInDF23MultiLineString
                Move False to TokenizerData.bIsOpenString
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End
        
        // Get the indentation part
        Get _Indentation (&TokenizerData) to TokenizerData.sIndentation
        // Get the end comment part
        Get _EndComment (&TokenizerData) to TokenizerData.sEndComment
        
        // This will overstrike string constant characters with "_" characters for a "some text" and
        // '+' characters for a 'some other text' 
        // This is so the refactoring functions does not get confused by the content of string constants.
        // E.g. Move "We will *move* some of the warehouse" to sText is changed to: Move "________________________________" to sText
        // Thus, most refactoring funtions should be using the sOverstrikeLine member value, rather then the
        // original sLine content itself.
        Get _OverstrikeStrings (&TokenizerData) to TokenizerData.sOverstrikeLine  

        // Old DataFlex 2.3 and earlier syntax that used "image pages". Looks like; "/MyPage" and ends with a "/*"
        // We will do nothing with such lines.
        If (pbIsInPage(Self) = True) Begin
            Get _IsImageEnd TokenizerData.sOverstrikeLine to bFound
            If (bFound = True) Begin
                Set pbIsInPage                  to False
            End
            Set pbIsOpenString                  to False
            Set pbIsInSingleQuote               to False
            Set pbIsInDF23MultiLineString       to False   
            Set pbIsInDF23MultiLineComment      to False
            Set pbIsInSemiColonMultiLineString  to False
            Move True  to TokenizerData.bLineIsReady
            Move False to TokenizerData.bIsInDF23MultiLineString
            Move False to TokenizerData.bIsOpenString
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        Else If (pbIsInPage(Self) = False and pbIsInDF23MultiLineComment(Self) = False) Begin
            Get _IsImageStart TokenizerData.sOverstrikeLine to TokenizerData.bIsInImage
            If (TokenizerData.bIsInImage = True) Begin
                Set pbIsInPage                      to True
                Set pbIsInDF23MultiLineString       to False   
                Set pbIsOpenString                  to False
                Set pbIsInSingleQuote               to False
                Set pbIsInSemiColonMultiLineString  to False
                Set pbIsInDF23MultiLineComment      to False
                Move True  to TokenizerData.bLineIsReady
                Move False to TokenizerData.bIsInDF23MultiLineString
                Move False to TokenizerData.bIsOpenString
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End               
        
        // Old school multi-line, ending with a semi-colon (;)
        Get _HasLineEndSemiColon TokenizerData.sOverstrikeLine to TokenizerData.bHasEndSemiColon
        If (TokenizerData.bHasEndSemiColon = True) Begin
            Set pbIsInSemiColonMultiLineString  to True
            Set pbIsInDF23MultiLineComment      to False
            Set pbIsInDF23MultiLineString       to False   
            Set pbIsOpenString                  to False
            Set pbIsInSingleQuote               to False
            Move True  to TokenizerData.bLineIsReady
            Move False to TokenizerData.bIsInDF23MultiLineString
            Move False to TokenizerData.bIsOpenString
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        Else Begin
            Set pbIsInSemiColonMultiLineString  to False
        End

        // DF 23 Multi-line strings are lines ending with a @, @SQL or """
        // The property pbIsInDF23MultiLineString is set as soon as such a
        // multi-line string is started (and not ended):
        If (pbIsInDF23MultiLineString(Self) = True) Begin
            Get _IsDF23String (&TokenizerData) to TokenizerData.bIsDF23String
            Get _IsMultiLineStringEnd TokenizerData.sOverstrikeLine to bFound
            If (bFound = True) Begin
                Set pbIsInDF23MultiLineString       to False
                Set pbIsOpenString                  to False
                Set pbIsInSingleQuote               to False
                Set pbIsInSemiColonMultiLineString  to False
                Move False to TokenizerData.bIsInDF23MultiLineString
                Move False to TokenizerData.bIsOpenString
                Move True  to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End 
            Else Begin
                If (TokenizerData.bIsDF23String = True) Begin
                    Get pbIsOpenString to TokenizerData.bIsOpenString
                    If (TokenizerData.bIsOpenString = False) Begin
                        Get _IsOpenString TokenizerData.sOverstrikeLine to TokenizerData.bIsOpenString
                        Set pbIsOpenString to TokenizerData.bIsOpenString
                    End
                    Set pbIsInDF23MultiLineString       to False
                    Set pbIsInSingleQuote               to False
                    Set pbIsInSemiColonMultiLineString  to False
                    Move True to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End
        End
        // Check if we have the start of a DF 23 multi-line string.
        Else Begin
            Get _IsDF23String (&TokenizerData) to TokenizerData.bIsDF23String
            Get _IsMultiLineStringStart (&TokenizerData) to bInMultiLineString  
            If (bInMultiLineString = True) Begin
                Move bInMultiLineString       to TokenizerData.bIsInDF23MultiLineString
                Set pbIsInDF23MultiLineString to bInMultiLineString
                Get _IsOpenString TokenizerData.sOverstrikeLine to TokenizerData.bIsOpenString
                Set pbIsOpenString                              to TokenizerData.bIsOpenString
                Get _IsDoubleQuoteStart TokenizerData.sOverstrikeLine to bIsDoubleQuoteStart
                Set pbIsInSingleQuote to (bIsDoubleQuoteStart = False)
            End
            If (TokenizerData.bIsDF23String = True or bInMultiLineString = True) Begin
                Move True to TokenizerData.bLineIsReady
                Set pbIsInSemiColonMultiLineString  to False
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End                       
        // *** End of tests that sets the TokenizerData.bLineIsReady = True.
        
        // Note: This also fills the TokenizerData.aExpressions member with data.
        Get _SplitSourceLineToTokens (&TokenizerData) to TokenizerData

        // Set properties to indicate if we are inside a function or a procedure.
        // Needs to be after calls to _OverstrikeStrings & _SplitSourceLineToTokens
        If (pbInFunction(Self) = True) Begin
            // Note: We will also indicate "end-of-function" if a new Funtion declaration is found (missing End_Function)
            If (TokenizerData.asLineTokensLC[0] = (Lowercase(CS_FunctionEnd)) or TokenizerData.asLineTokensLC[0] = (Lowercase(CS_Function))) Begin
                Move False to TokenizerData.bIsInFunction
                Set pbInFunction to False
                If (TokenizerData.asLineTokensLC[0] = (Lowercase(CS_FunctionEnd))) Begin
                    Set pbIsInSemiColonMultiLineString  to False
                    Set pbIsInDF23MultiLineString       to False
                    Set pbIsOpenString                  to False
                    Set pbIsInSingleQuote               to False
                    Move False to TokenizerData.bIsInDF23MultiLineString
                    Move False to TokenizerData.bIsOpenString
                    Move True  to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End
        End
        Else Begin
            Get _IsFunctionDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInFunction
            Set pbInFunction to TokenizerData.bIsInFunction
        End
        
        If (pbInProcedure(Self) = True) Begin
            // Note: We will also indicate "end-of-procedure" if a new Procedure declaration is found (missing End_Procedure)
            If (TokenizerData.asLineTokensLC[0] = (Lowercase(CS_ProcedureEnd)) or TokenizerData.asLineTokensLC[0] = (Lowercase(CS_Procedure))) Begin
                Set pbInProcedure to False
                If (TokenizerData.asLineTokensLC[0] = (Lowercase(CS_ProcedureEnd))) Begin
                    Set pbIsInSemiColonMultiLineString  to False
                    Set pbIsInDF23MultiLineString       to False
                    Set pbIsOpenString                  to False
                    Set pbIsInSingleQuote               to False
                    Move False to TokenizerData.bIsInDF23MultiLineString
                    Move False to TokenizerData.bIsOpenString
                    Move True  to TokenizerData.bLineIsReady
                    Set pTokenizer to TokenizerData
                    Function_Return TokenizerData
                End
            End               
        End
        Else Begin
            Get _IsProcedureDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsInProcedure  
            Set pbInProcedure to TokenizerData.bIsInProcedure
        End
        
        Get _IsVariableDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsVariableDeclaration
        Get _IsCommandDeclaration  TokenizerData.sOverstrikeLine to TokenizerData.bIsInCommand
        If (TokenizerData.bIsInFunction = True or TokenizerData.bIsInProcedure = True or TokenizerData.bIsInCommand = True) Begin
            Set pbIsInDF23MultiLineString   to False
            Set pbIsOpenString              to False
            Set pbIsInSingleQuote           to False
            Move False to TokenizerData.bIsInDF23MultiLineString
            Move False to TokenizerData.bIsOpenString
            Move True  to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        
        // Get start and end indicators
        // "Indicate [Select] as [not Found]" -> bHasIndicateCommand = True
        Get _ExtractLegacyBooleanContent (&TokenizerData) to TokenizerData.IndicatorInfo
            
        // Get the "*Move iA* to xxx" part
        Get _LeftStatement (&TokenizerData) to TokenizerData.LeftStatement 
        // Get the "of xxx" part
        Get _OfStatement (&TokenizerData) to TokenizerData.OfStatement 
        // Get the "to xxx" part
        Get _ToStatement (&TokenizerData) to TokenizerData.ToStatement
        
        Get _LeftCommand (&TokenizerData) CI_FirstCommand  to TokenizerData.FirstLeftCommand
        Get _LeftCommand (&TokenizerData) CI_SecondCommand to TokenizerData.SecondLeftCommand

        // Note: The aExpressions member contains all of these together with the position in the source line.
        //       And yes, this is tautological, but helps when creating cRefactorFuncLib functions.
        Get _FetchExpression TokenizerData.aExpressions CI_LeftExpression1 to TokenizerData.sLeftExpression1
        Get _FetchExpression TokenizerData.aExpressions CI_LeftExpression2 to TokenizerData.sLeftExpression2
        Get _FetchExpression TokenizerData.aExpressions CI_OfExpression    to TokenizerData.sOfExpression
        Get _FetchExpression TokenizerData.aExpressions CI_ToTexpression   to TokenizerData.sToExpression

        // *** Note ***
        // Intead of calling this Tokenizer function from the cRefactorFuncLib,
        // each function should do a "Get pTokenizer to TokenizerData" and use that ready-made tokenized data,
        // that was created once for each source line by this function.
        // This tokenizer call will be made automatically by the logic in DFRefactor.src & TestBenchRefactorFunctions.src. 
        Set pTokenizer to TokenizerData
                                      
        Function_Return TokenizerData
    End_Function 
    
    // ToDo: *** HELPER FUNCTIONS ***   
    // Note that the ToDo marker above is used to show the *** text *** in the Studio's Code Explorer(!)
    // 
    // Splits up the tokens/elements of the input string into two string arrays, but without indentation and end comment.
    // The line will be broken up by spaces " ", *except* for expressions. Each expression will exist as a
    // separate member/item.
    // The TokenizerData.asLineTokensLC will contain the same values, but LowerCased.
    Function _SplitSourceLineToTokens tTokenizer ByRef TokenizerData Returns tTokenizer
        String sOverstrikeLine 
        String[] asLineTokens asLineTokensLC asLineTokensEmpty                     
        String sLineTokens sExpression sReplace 
        Integer iSize iCount iItem iPos
        tExpression[] aExpressions aExpressionsEmpty
        
        // We need to retrieve expressions from the sOverstrikeLine, as they else will
        // be splitted on several items (if expression contains spaces) in the array and 
        // we want each expression as one array member.
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        // _ExtractExpression is called recursively. This is why we use a procedure as it simplifies the work for us.
        Send _ExtractExpressions sOverstrikeLine TokenizerData.sLine (&aExpressions)
        Move (SizeOfArray(aExpressions)) to iSize
        Decrement iSize    
        
        // If expressions exists, temporarily replace them with the "|" symbol, before
        // splitting string to array.
        If (iSize <> -1) Begin                 
            Move aExpressions to TokenizerData.aExpressions
            For iCount from 0 to iSize
                Move (FillString("|", aExpressions[iCount].iLength)) to sReplace
                Move (Pos(aExpressions[iCount].sExpression, sOverstrikeLine)) to iPos
                If (iPos <> 0) Begin
                    Move (Overstrike(sReplace, sOverstrikeLine, aExpressions[iCount].iStartPos)) to sOverstrikeLine
                End
            Loop
        End
        Else Begin
            Move aExpressionsEmpty to TokenizerData.aExpressions
        End

        Move (StrSplitToArray(sOverstrikeLine, " ")) to asLineTokens 

        // If there were any expressions, place them back into asLineTokens as items.
        If (iSize <> -1) Begin                 
            For iCount from 0 to iSize
                Move (FillString("|", aExpressions[iCount].iLength)) to sReplace
                Move (SearchArray(sReplace, asLineTokens)) to iItem
                If (iItem <> -1) Begin
                    Move aExpressions[iCount].sExpression to asLineTokens[iItem]
                End
            Loop
        End

        // ToDo: Not sure we should remove empty members from the array.
        //       It could be easier to re-assamble the source line if these are kept.
        // Remove members that is just a space as we don't need/want them.
        // They appear if multiple spaces exists between tokens.
//        Move (SizeOfArray(asLineTokens)) to iSize
//        Decrement iSize    
//        For iCount from 0 to iSize
//            Move (SearchArray(" ", asLineTokens)) to iItem
//            If (iItem <> -1) Begin
//                Move (RemoveFromArray(asLineTokens, iItem)) to asLineTokens
//            End
//            Else Begin
//                Move iSize to iCount // Jump out.
//            End
//        Loop   
        
        // Also create an array with lowercased tokens;
        Move (SizeOfArray(asLineTokens)) to iSize  
        Decrement iSize
        For iCount from 0 to iSize
            Move (Lowercase(asLineTokens[iCount])) to asLineTokensLC[iCount]
        Loop
        
        Move asLineTokens   to TokenizerData.asLineTokens
        Move asLineTokensLC to TokenizerData.asLineTokensLC
        Function_Return TokenizerData
    End_Function 
    
    // Function to return expressions from the source line;
    // Only expressions in parenthesis "()" are acted upon and returned (Not square brackets)
    // Note: It fetches the class property paExpression, where the expressions was saved by the Tokenizer function.
    { EnumList="{CI_LeftExpression1, CI_LeftExpression2, CI_OfExpression, CI_ToTexpression}" }
    Function _FetchExpression tExpression[] aExpressions Integer eExpressionMode Returns String
        String sExpression
        Integer iSize iItem     
        tExpression Expression
        
        Move (SizeOfArray(aExpressions)) to iSize
        If (iSize = 0) Begin
            Function_Return ""
        End       

        Move "" to sExpression
        Move eExpressionMode to Expression.eExpressionMode
        Move (SearchArray(Expression, aExpressions)) to iItem
        If (iItem = -1) Begin
            Function_Return ""
        End                   
        Move aExpressions[iItem].sExpression to sExpression

        Function_Return sExpression
    End_Function

    // Returns either the first or second command in the sLine, depending
    // on the eCommandNumber parameter.
    { EnumList="CI_FirstCommand, CI_SecondCommand, CI_ThirdCommand"}
    Function _LeftCommand tTokenizer ByRef TokenizerData Integer eCommandNumber Returns tToken
        String sOverstrikeLine 
        Integer iPos iSize iCount iItem iCommand iNumber
        String[] asCommands 
        tToken Data
        
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return Data
        End                     
        // This array contains lowecased commands
        Get pasCommands to asCommands
        Move -1 to iCommand
        Move 0 to iNumber
        Move (SizeOfArray(TokenizerData.asLineTokensLC)) to iSize
        Decrement iSize
        
        For iCount from 0 to iSize
            Move (SearchArray(TokenizerData.asLineTokensLC[iCount], asCommands)) to iItem 
            If (iItem <> -1) Begin
                If (eCommandNumber = iNumber) Begin
                    Move iCount to iCommand
                    Move iSize to iCount    // Jump out.
                End
                Increment iNumber
            End 
            Else If (TokenizerData.asLineTokensLC[iCount] = Lowercase(CS_If)) Begin
                Increment iNumber
                // The "If" statement is not included in the pasCommands array, but we want it here
                If (eCommandNumber = CI_FirstCommand) Begin
                    Move iCount to iCommand
                    Move iSize to iCount    // Jump out.  
                    Move 1 to iItem
                End
            End
        Loop
        
        If (iItem <> -1 and iCommand <> -1) Begin
            Move TokenizerData.asLineTokens[iCommand] to Data.sCode
            Move (Pos(Data.sCode, TokenizerData.sOverstrikeLine)) to Data.iStartPos
        End
        Function_Return Data
    End_Function

    // ToDo: Needs to be revised. E.g. a line like "[not Found] Move x to y" will fail.
    Function _FirstToken String sLine Returns String
        String sWord
        Integer iPos
        Boolean bIsCommentLineOrBlank bFound
        
        Get _IsCommentLineOrBlank sLine to bIsCommentLineOrBlank
        If (bIsCommentLineOrBlank = True) Begin
            Function_Return ""
        End                   
        
        Move (Trim(sLine)) to sLine
        Move (Pos(" ", sLine)) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, iPos - 1)) to sWord
        End                                      
        Else Begin             
            // If the line consist of a single token/word
            Move sLine to sWord
        End
        Function_Return sWord
    End_Function  
    
    // Searches for the first DataFlex keyword for "sSource" in a source line line.
    // Returns the Pos or 0 if not found.
    Function _FindCommand tTokenizer ByRef TokenizerData String sSource Returns Integer
        Boolean bRemoved
        Integer iSize iStart iEnd iPos iTest iLength
        String  sOverStrikeLine sWord sLowerCase  
        String[] asCommands

        Move 0 to iPos          
        Get pasCommands to asCommands
        Move (Length(sSource)) to iLength
        Move (SizeOfArray(TokenizerData.asLineTokensLC)) to iSize
        Decrement iSize
        

        While (iLength > 0)                                
            Move (Pos(" ", sSource)) to iPos
            If (iPos > 0) Begin
                Move (Left(sSource, (iPos -1))) to sWord
                Move (Pos(Lowercase(sWord), Lowercase(sSource))) to iPos
                Move (Trim(Lowercase(sWord))) to sLowerCase
                Move (SearchArray(sLowerCase, asCommands)) to iTest
                // If command not found, try next "word" in sSource;
                If (iTest = -1) Begin     
                    Move (Pos(" ", sSource)) to iPos
                    Move (Mid(sSource, iLength, iPos)) to sSource
                    Move (Trim(sSource)) to sSource
                    Move (Length(sSource)) to iLength
                End
                Else Begin
                    Move 0 to iLength // Jump out.
                End
            End
            Else Begin
                Move 0 to iLength // Jump out.
            End
        Loop              

        Function_Return iPos
    End_Function   
    
    // It is assumed that the sWord is neither blank or part of a comment or text constant. 
    // Check if the "sLine" is a global or a local variable declaraction (exist in pasLocalVariableTypes)
    Function _IsVariableDeclaration String sLine Returns Boolean
        Boolean bFound
        String[] asLocalVariableTypes                          
        Integer iItem iPos
        
        Move (Lowercase(sLine)) to sLine
        Move (sLine = "local") to bFound
        If (bFound = False) Begin
            Move (sLine = "global_variable") to bFound
        End
        If (bFound = False) Begin
            Move (Pos(" ", sLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sLine, (iPos -1))) to sLine
            End
            Get pasLocalVariableTypes to asLocalVariableTypes
            Move (SearchArray(sLine, asLocalVariableTypes)) to iItem
            Move (iItem <> -1) to bFound
        End                             
        Function_Return bFound
    End_Function

    // It is assumed that the sWord is neither blank or part of a comment or text constant.
    // Check if the "sWord" is a local variable declaraction *array* (exist in pasLocalVariableTypes)
    Function _IsVariableArrayDeclaration String sLine Returns Boolean
        Boolean bFound
        String[] asLocalVariableArrayTypes                          
        Integer iItem
        
        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
        Move (Lowercase(sLine)) to sLine
        
        Move (sLine = "local") to bFound
        If (bFound = False) Begin
            Move (sLine = "global_variable") to bFound
        End
        If (bFound = False) Begin
            Move (SearchArray(sLine, asLocalVariableArrayTypes)) to iItem
            Move (iItem <> -1) to bFound
        End                             
        Function_Return bFound
    End_Function

    // It is assumed that the sWord is neither blank or part of a comment or text constant.
    Function _IsKeyWord String sWord Returns Boolean
        Integer iItem
        String[] asKeyWords
        
        Get pasKeyWords to asKeyWords
        Move (Trim(Lowercase(sWord))) to sWord
        Move (SearchArray(sWord, asKeyWords)) to iItem
        
        Function_Return (iItem <> -1)
    End_Function
    
    // Is it a Function declaration?
    // Pass a source line param with overstriked string constants.
    Function _IsFunctionDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound bComment 
        Move (Pos(Lowercase("function "), Lowercase(sOverstrikeLine)) <> 0) to bFound
        Function_Return bFound
    End_Function
    
    // Is it a Procedure declaration?
    // Pass a source line param with overstriked string constants.
    Function _IsProcedureDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound bComment 
        Move (Pos(Lowercase("procedure "), Lowercase(sOverstrikeLine)) <> 0) to bFound
        Function_Return bFound
    End_Function
    
    // Returns True if the sOverStrikeLine is the start of a Function *or* a Procedure.
    Function _IsMethodStart String sOverStrikeLine Returns Boolean
        Boolean bMethodStart        
        
        Get _IsFunctionDeclaration sOverStrikeLine to bMethodStart
        If (bMethodStart = False) Begin
            Get _IsProcedureDeclaration sOverStrikeLine to bMethodStart
        End
        Function_Return bMethodStart
    End_Function

    Function _IsMethodEnd String sOverstrikeLine Returns Boolean
        Boolean bMethodEnd
        
        Move (Lowercase(Trim(sOverstrikeLine))) to sOverstrikeLine
        Move (Left(sOverstrikeLine, 14) = Lowercase(CS_EndProcedure) or Left(sOverstrikeLine, 13) = Lowercase(CS_EndFunction)) to bMethodEnd

        Function_Return bMethodEnd
    End_Function

    // Is it a Class declaration?
    // Pass a source line param with overstriked string constants.
    Function _IsClassDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound bComment 
        
        Move False to bFound
        Move (Pos(Lowercase("class "), Lowercase(sOverstrikeLine)) <> 0) to bFound
        
        Function_Return bFound
    End_Function
    
    Function _IsClassEnd String sOverstrikeLine Returns Boolean
        Boolean bClassEnd
        
        Move (Lowercase(Trim(sOverstrikeLine))) to sOverstrikeLine
        Move (Left(sOverstrikeLine, 9) = Lowercase(CS_EndClass)) to bClassEnd

        Function_Return bClassEnd
    End_Function

    // Is the line a command declaration?
    Function _IsCommandDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound bComment 
        
        Move False to bFound                                      
        Move (Pos(Lowercase("#" + CS_Command), Lowercase(sOverstrikeLine)) <> 0) to bFound
        
        Function_Return bFound
    End_Function
    
    // Counts total number of source lines for the passed file name.
    // It does *not* count empty or commented lines. 
    // it does *not* count COM proxy class files generated by the Studio for COM/ActiveX components.
    Function _CountNumberOfLines String sFullSourceFileName String sParameter Returns Integer
        Integer iLines iChannel 
        String sLine     
        Boolean bExists bBlank bIsCOM
        
        File_Exist sFullSourceFileName bExists
        If (bExists = False) Begin
            Send UserError ("Couldn't find file:" * String(sFullSourceFileName) * "No source lines added to counter for this file.")
            Function_Return 0
        End                  

        Get _IsDataFlexCOMProxyClassesFile sFullSourceFileName to bIsCOM
        If (bIsCOM = True) Begin
            Function_Return 0
        End
        
        Get Seq_New_Channel to iChannel
        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DfErr_Program "No Channel Available for: 'Function _CountNumberOfLines'"
            Function_Return 0
        End

        Move 0 to iLines
        Direct_Input channel iChannel sFullSourceFileName
        While (SeqEof = False)
            Readln channel iChannel sLine 
            Get _IsCommentLineOrBlank sLine to bBlank
            If (bBlank = False) Begin
                Increment iLines
            End
        Loop
        Close_Input channel iChannel
        Send Seq_Release_Channel iChannel
        
        Function_Return iLines
    End_Function

    // Note: It must only be the code part of a source line that is passed here.
    //       Use the Tokenizer helper function first.
    Function _AddExpressionParenthesis tTokenizer TokenizerData String ByRef sLine Returns Boolean
        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
        Boolean bFound bChanged bStartOperators bIfCommand bSecondCommand bWhile
        Integer iPos iPos2
        
        Move sLine to sText    
        Move sLine to sOrg             
        // Do nothing if a Constrain command.
        Get _HasCommand TokenizerData.sOverstrikeLine (CS_Constrain + " ") to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move "" to sStart
        Move "" to sLast              
        Get _FetchExpression TokenizerData.aExpressions CI_LeftExpression1 to sExpression
        If (Trim(sExpression) = "") Begin
            Get _FetchExpression TokenizerData.aExpressions CI_LeftExpression2 to sExpression
        End
        If (Trim(sExpression) = "") Begin
            Get _FetchExpression TokenizerData.aExpressions CI_OfExpression to sExpression
            If (Trim(sExpression) = "") Begin
                Get _FetchExpression TokenizerData.aExpressions CI_ToTexpression to sExpression
            End
        End
        If (Trim(sExpression) = "") Begin
            Function_Return False
        End 
        Move (Pos(sExpression, sText)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sLine, (iPos - 1))) to sStart
            If (sStart <> "") Begin
                Move (Replace(sStart, sLine, "")) to sText
                Move (Replace(sExpression, sText, "")) to sLast
            End
        End
//        If (sStart <> "") Begin
//            Move sStart to sLine
//        End                     
        If (sExpression <> "") Begin               
            Move sExpression to sText
            Get _StripConcatenatingSpaces sExpression to sExpression
            Move (Trim(sExpression)) to sExpression 
            Get _HasDoubleExpression sExpression to bFound
            Move (Left(sExpression, 1)) to sChar
            If (sChar <> "(" or bFound = True) Begin
                Move ("(" + sExpression + ")") to sExpression
            End                      
            If (sText = sLine) Begin
                Move sExpression to sLine
            End
        End                                                    
        If (sStart <> "" or sLast <> "") Begin    
            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
        End
        
        Function_Return (sLine <> sOrg)
    End_Function   
                                              
    // Helper message for _ClearFirstCompoundBeforeMethod
    // Overwrites thr string content with blanks up to the iPos position.
    Procedure _WipeUntilPosition String ByRef sLine Integer iPos 
        Integer iChar
        If (iPos > 0) Begin
            For iChar from 1 to (iPos - 1)
                Move (Overstrike(" ", sLine, iChar)) to sLine
            Loop
        End
    End_Procedure

    // With our refactoring logic if a line starts with if, else or on_key then the logic won't "see"
    // send/get/set as the first word and that complicates our detection.
    // What this does is simply overwrite everything with spaces before our methods if
    // there is such a compound statement.
    // The variable sLine is not always lowercase.
    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
        Integer iPos
        String  sLtrimLine sOrgLine
        Boolean bChanged
        
        Move sLine to sOrgLine
        Move (Lowercase(LTrim(sLine))) to sLTrimLine
        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
            // A line that starts with an "if" or "else" can still call a method
            Move (Pos("send ", Lowercase(sLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos("get ", Lowercase(sLine))) to iPos
            End
            If (iPos = 0) Begin
                Move (Pos("set ", Lowercase(sLine))) to iPos
            End
            Send _WipeUntilPosition (&sLine) iPos
        End       
        
        Function_Return (sLine <> sOrgLine)
    End_Function
  
//    Function _FirstLeftExpression String sLine tTokenizer TokenizerData Returns String
//        String sExpression
//        
//        Move "" to sExpression
//        Get _ExtractParenthesisExpression sLine to sExpression
//        If (sExpression = "") Begin
//            Get _ExtractExpressionNoParenthesis sLine to sExpression
//        End
//        Function_Return sExpression    
//    End_Function
//    
//    Function _SecondLeftExpression String sLine tTokenizer TokenizerData Returns String
//        String sExpression
//        Integer iPos
//        
//        Move "" to sExpression
//        If (TokenizerData.sLeftExpression = "") Begin
//            Get _ExtractParenthesisExpression sLine to sExpression
//            If (sExpression = "") Begin
//                Get _ExtractExpressionNoParenthesis sLine to sExpression
//            End
//        End
//        If (sExpression <> "") Begin
//            Move (Pos(sExpression, sLine)) to iPos
//            Move (Mid(sLine, Length(sLine), (iPos + 1))) to sLine
//            Get _ExtractParenthesisExpression sLine to sExpression
//            If (sExpression = "") Begin
//                Get _ExtractExpressionNoParenthesis sLine to sExpression
//            End
//        End
//        Function_Return sExpression    
//    End_Function
    
    // Takes a source line as input. The "sOverstrikeLine" param *must* have been
    // "cleaned" with the _OverstrikeStrings function so string constant content
    // cannot interfere while scanning the source line for expressions.
    // Returns a struct array with the start, length & expression(s).
    // Returns an empty struct array if no opening parenthesis was found aka "(".
    // Note: This is a recursive message, if needed it calls itself.
    Procedure _ExtractExpressions String sOverstrikeLine String sLine tExpression[] ByRef aExpressions
        String sExpression sChar sTest 
        Integer iSize iCount iStart iStop iItem iClauseOpen iClauseClosed iLength iPos  
        tExpression[] aExpressionsEmpty

        Move (Pos("(", sOverstrikeLine)) to iPos
        If (iPos = 0) Begin  
            Function_Return aExpressionsEmpty
        End
        
        Move "" to sExpression          
        Move -1 to iStop
        
        // We need to establish the first and last *matching* paranthesis positions.
        Move 0 to iClauseOpen
        Move 0 to iClauseClosed                                           
        Move (Length(sOverstrikeLine)) to iSize
        For iCount from iPos to iSize
            Move (Mid(sOverstrikeLine, 1, iCount)) to sChar
            If (sChar = "(") Begin
                Increment iClauseOpen
                If (iClauseOpen = 1) Begin
                    Move iCount to iStart
                End
            End
            If (sChar = ")") Begin
                Increment iClauseClosed  
                Move iCount to iStop
            End
            If (iClauseOpen > 0 and iClauseOpen = iClauseClosed) Break
        Loop
        
        // If found, extract the expression and move info to struct array:
        If (iStart < iStop) Begin  
            Increment iStop
            Move (iStop - iStart) to iLength
            Move (Mid(sOverstrikeLine, iLength, iStart)) to sExpression
            Move (SizeOfArray(aExpressions)) to iSize
            Move (Pos(sExpression, sLine))   to aExpressions[iSize].iStartPos
            Move iLength     to aExpressions[iSize].iLength
            Move sExpression to aExpressions[iSize].sExpression 
            
            // Finally set the expression mode:
            { EnumList="{CI_LeftExpression, CI_OfExpression, CI_ToTexpression}" }
            If (iSize = 0) Begin
                Move CI_LeftExpression1 to aExpressions[iSize].eExpressionMode  
            End 
            Else Begin
                Move CI_LeftExpression2 to aExpressions[iSize].eExpressionMode  
            End
                
            Move (Pos(Lowercase(" " + CS_Of + " "), Lowercase(sOverstrikeLine))) to iPos
            If (iPos <> 0 and iPos < iStart) Begin
                Move CI_OfExpression to aExpressions[iSize].eExpressionMode
            End
            Move (Pos(Lowercase(" " + CS_to + " "), Lowercase(sOverstrikeLine))) to iPos
            If (iPos <> 0 and iPos < iStart) Begin
                Move CI_ToTexpression to aExpressions[iSize].eExpressionMode
            End
        End
        
        // Is there more than one expression? Then call this function *recursively*!
        Move (Length(sOverstrikeLine)) to iSize
        Move (Mid(sOverstrikeLine, iSize, iStop)) to sTest
        Move (Pos("(", sTest)) to iItem
        If (iItem <> 0) Begin
            Move sTest to sOverstrikeLine
            Send _ExtractExpressions sOverstrikeLine sLine (&aExpressions)
        End                        
        
    End_Procedure
    
    // ToDo: Needs to be revised!
    Function _ExtractExpressionNoParenthesis tTokenizer ByRef TokenizerData tOperatorsInfo OperatorsInfo Returns String
        String sOverstrikeLine sText sExpression sChar sFirst sLast sLeft sRight
        Integer iCount iLength iSize iStart iEnd iPos
        Boolean bStop bSpace bParanthesis
        
        // ToDo: Is this really correct in all cases?
        If (OperatorsInfo.bIsOperator = False) Begin
            Function_Return ""
        End
        Move "" to sExpression  
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
//        Move (Pos(Lowercase(" " + CS_As + " "), sOverstrikeLine)) to iPos 
//        If (iPos <> 0) Begin
//            Move (Mid(sOverstrikeLine, Length(sOverstrikeLine), (iPos + 3))) to sText    
//        End
//        Else Begin
            Move (OperatorsInfo.iPos - Length(OperatorsInfo.sOperator)) to iStart
            Move (Left(sOverstrikeLine, (iStart + 1))) to sText
//        End
        Get _StripConcatenatingSpaces (&TokenizerData) to sText
        Get _OverstrikeStrings (&TokenizerData) to sText
        Move (Length(sText)) to iLength   
        Move (Pos(Lowercase(" " + CS_As + " "), sText)) to iPos 
        If (iPos <> 0) Begin
            Move (Mid(sText, Length(sText), (iPos + 3))) to sText    
        End
        
        // First get the left part of the expression:
        Move iLength to iStart
        Move 0 to iCount
        Move False to bSpace
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sText, 1, (iStart - iCount))) to sChar
            If (bParanthesis = True) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar <> " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
        Move (Left(sText, (iStart - iCount + 1))) to sFirst  
        Move (Replace(sFirst, sText, "")) to sLeft
        If (sLeft = "") Begin
            Move sText to sLeft
        End
        Move (Length(sOverstrikeLine)) to iLength   
        
        // Then get the right part of the expression:
        Move 1 to iCount   
        Move False to bSpace
        Move (OperatorsInfo.iPos) to iStart
        Move (Mid(sOverstrikeLine, iLength, (iStart + 1))) to sText  
        Move (Length(sText)) to iLength
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sOverstrikeLine, 1, (iStart + iCount))) to sChar
            If (bParanthesis = False) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar = " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
                                                     
        Move (Left(sText, (iCount - 1))) to sRight
        Move (String(sLeft) * String(sRight)) to sExpression
        
        Function_Return (Trim(sExpression))
    End_Function
 
    // Takes a source line as input. The "sOverstrikeLine" param *must* have been
    // "cleaned" with the _OverstrikeStrings function so string constant content
    // cannot interfere when scanning the source line for expressions.
    // Returns a struct array with the start, length & expression(s).
    // Returns an empty struct array if no opening parenthesis was found aka "(".
    // Note: This is a recursive message, if needed it calls itself.
//    Procedure _ExtractStrings String sLine tQuotedString[] ByRef aStringContent
//        String sString sChar sTest                                    
//        Integer iSize iCount iStart iStop iItem iLength iPos iSingleQuotes iDoubleQuotes 
//        Integer iDoubleQuotePos iSingleQuotePos
//        Boolean bDoubleQuote bIsInDF23MultiLineString bIsOpenString bFound
//        
//        Get _NumberOfStringQuotes sLine CI_DoubleQuotes to iDoubleQuotes
//        Get _NumberOfStringQuotes sLine CI_SingleQuotes to iSingleQuotes
//        If (iSingleQuotes = 0 and iDoubleQuotes = 0) Begin  
//            Function_Return aStringContent
//        End
//        
//        Move (Trim(sLine)) to sLine
//        Get _RemoveEndComment sLine to sLine
//        Move -1 to iStop
//        
//        Move (Length(sLine)) to iSize
//        Get pbIsInDF23MultiLineString to bIsInDF23MultiLineString
//        Get pbIsOpenString            to bIsOpenString
//        
//        // Not sure we should have this;
//        If (bIsInDF23MultiLineString = True and bIsOpenString = True) Begin
//            Get _IsMultiLineStringEnd sLine to bIsInDF23MultiLineString
//            If (bIsInDF23MultiLineString = True) Begin
//                Set pbIsInDF23MultiLineString to False
//                Set pbIsOpenString            to False
//            End
//        End
//        
//        Move 0 to iSingleQuotePos
//        Move (Pos('"', sLine)) to iDoubleQuotePos
//        // There might be an apostrophe in the string
//        If (iSingleQuotes > 1) Begin
//            Move (Pos("'", sLine)) to iSingleQuotePos
//        End  
//        
//        Move (iDoubleQuotes > 0 and iSingleQuotes < iDoubleQuotes and iDoubleQuotePos < iSingleQuotePos) to bDoubleQuote
//        // If found, extract the string content and move it to the struct array:
//        If (bDoubleQuote = True) Begin
//            Move (SizeOfArray(aStringContent)) to iSize
//            Move (Pos('"', sLine)) to iStart
//            Move (Overstrike("|", sLine, iStart)) to sLine
//            Move (Pos('"', sTest)) to iStop
//            If (iStop = 0) Begin
//                Move (Length(sLine)) to iStop
//            End
//            Move (iStop - iStart) to iLength
//            Move iLength to aStringContent[iSize].iLength
//            Move iStart  to aStringContent[iSize].iStartPos
//            Move iStop   to aStringContent[iSize].iEndPos
//            Move (Mid(sLine, (iStop - iStart), (iStart + 1))) to aStringContent[iSize].sStringContent  
//            // Finally "shorten" the sLine
//            Move (Mid(sLine, iLength, (iStop + 1))) to sLine
//        End
//        Else If (iSingleQuotes > 1) Begin
//         
//        End
//        
////        If (iStart < iStop) Begin  
////            Increment iStop
////            Move (iStop - iStart) to iLength
////            Move (Mid(sLine, iLength, iStart)) to sString
////            Move (SizeOfArray(aStringContent)) to iSize
////            Move iStart      to aStringContent[iSize].iStartPos
////            Move sExpression to aStringContent[iSize].sCode 
////            
////            // Finally set the expression mode:
////            { EnumList="{CI_LeftExpression, CI_OfExpression, CI_ToTexpression}" }
////            If (iSize = 0) Begin
////                Move CI_LeftExpression1 to aStringContent[iSize].eExpressionMode  
////            End 
////            Else Begin
////                Move CI_LeftExpression2 to aStringContent[iSize].eExpressionMode  
////            End
////                
////            Move (Pos(Lowercase(" " + CS_Of + " "), Lowercase(sOverstrikeLine))) to iPos
////            If (iPos <> 0 and iPos < iStart) Begin
////                Move CI_OfExpression to aStringContent[iSize].eExpressionMode
////            End
////            Move (Pos(Lowercase(" " + CS_to + " "), Lowercase(sOverstrikeLine))) to iPos
////            If (iPos <> 0 and iPos < iStart) Begin
////                Move CI_ToTexpression to aStringContent[iSize].eExpressionMode
////            End
////        End
//        
//        // Are there any more string constants? Then call this function *recursively*!
//        Move (Length(sLine)) to iSize
//        Move (Mid(sLine, iSize, iStop)) to sTest
//        Move (Pos("(", sTest)) to iItem
//        If (iItem <> 0) Begin
//            Move sTest to sLine
//            Send _ExtractStrings sLine (&aStringContent)
//        End                        
//        
//    End_Procedure
    
    // ToDo: Needs to be revised. How should it work?
    Function _ExtractCommand tTokenizer ByRef TokenizerData Integer iPos Returns String
        String sOverstrikeLine sCommand sChar
        Integer iSize iCount
                                                            
        Move "" to sCommand   
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        Move (Length(sOverstrikeLine)) to iSize
        For iCount from iPos to iSize
            Move (Mid(sOverstrikeLine, 1, iCount)) to sChar
            If (sChar <> " ") Begin
                Append sCommand sChar    
            End                      
            Else Begin
                Move iSize to iCount // Jump out.
            End
        Loop
            
        Function_Return sCommand
    End_Function
    
    // Rturns the first expression that exist in the passed string and that is within parenthesis (),
    // else it returns a blank string.
    Function _ExtractParenthesisExpression tTokenizer ByRef TokenizerData Returns String
        String sOverstrikeLine sExpression sChar
        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
        tOperatorsInfo OperatorInfo
        
        Move "" to sExpression
        Move 0  to iLeftParantheses
        Move 0  to iRightParantheses
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        
        If (sOverstrikeLine <> "") Begin
            Move (Pos("(", sOverstrikeLine)) to iStart
            Move (RightPos(")", sOverstrikeLine)) to iEnd
            Get _LogicalOperators (&TokenizerData) to OperatorInfo
            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
                Function_Return ""
            End 

            Move (Length(sOverstrikeLine)) to iLength
            For iCount from iStart to iLength
                Move (Mid(sOverstrikeLine, 1, iCount)) to sChar
                If (sChar = "(" or sChar = ")") Begin
                    Add (sChar = "(") to iLeftParantheses
                    Add (sChar = ")") to iRightParantheses
                    Move iCount to iPos
                End                        
                If (iLeftParantheses = iRightParantheses) Break
            Loop
            Move (Mid(sOverstrikeLine, (iPos - iStart + 1), iStart)) to sExpression
        End
        Function_Return sExpression
    End_Function

    // Returns info about the start indicator part from a sOverstrikeLine line
    // Returns e.g. info about: *[Found]*, in line "If [Found] Move (True = bTrue) to [Select]"
    // Returns an empty struct if not found.
    { EnumList="{CI_FirstIndicator, CI_SecondIndicator, CI_ToIndicator}" }
//    Function _FindIndicator String sOverstrikeLine Integer eIndicatorMode Returns tBooleanIndicator
//        String sIndicator sText sChar
//        Integer iPos iStart
//        Boolean bFound                                            
//        tBooleanIndicator BooleanIndicator
//        
////        // This also checks that it isn't an array declaration.
////        Get _IsIndicatorStatement sOverstrikeLine to bFound
////        If (bFound = False) Begin
////            Function_Return BooleanIndicator
////        End   
//
//        Case Begin
//            Case (eIndicatorMode = CI_FirstIndicator)
//                Get _ExtractLegacyBooleanContent sOverstrikeLine to BooleanIndicator
//                Case Break
//            Case (eIndicatorMode = CI_SecondIndicator)
//                Get _ExtractLegacyBooleanContent sOverstrikeLine to BooleanIndicator
//                Case Break
//            Case (eIndicatorMode = CI_FirstIndicator)
//                Get _ExtractLegacyBooleanContent sOverstrikeLine to BooleanIndicator
//                Case Break
//        Case End
//
////        Move "" to sIndicator
////        Move (Pos("[", sOverstrikeLine)) to iStart
////        If (iStart <> 0) Begin    
////            Move iStart to Data.iStartPos
////            Move (Pos("]", sOverstrikeLine)) to iPos
////            Move (Mid(sOverstrikeLine, (iPos - iStart -1), (iStart +1))) to sIndicator
////        End     
////        Move sIndicator to Data.sCode
////        If (sIndicator = "") Begin
////            Move 0 to Data.iStartPos
////        End
//        Function_Return BooleanIndicator
//    End_Function
        
    // Returns info about the end indicator part that comes after the "to" operator.
    // Returns e.g info about *[Seqeof]*, in line "Move [bFound] to [Seqeof]"
    // Returns an empty struct if not found.
//    Function _RightMostIndicator String sOverstrikeLine Returns tBooleanIndicator 
//        String sIndicator sChar
//        Integer iPos iStart iEnd
//        Boolean bFound
//        tBooleanIndicator BooleanIndicator
//        
//        // This also checks that it isn't an array declaration.
//        Get _IsIndicatorStatement sOverstrikeLine to bFound
//        If (bFound = False) Begin
//            Function_Return BooleanIndicator
//        End
//        
//        Move (Right(sOverstrikeLine, 1)) to sChar
//        If (sChar = "]") Begin  
//            Move (Pos(Lowercase(" " + CS_To + " "), Lowercase(sOverstrikeLine))) to iPos
//            If (iPos > 0) Begin
//                // Remove the first part of the sOverstrikeLine string to get the last indicator part.
//                Move (Mid(sOverstrikeLine, Length(sOverstrikeLine), (iPos + 4))) to sOverstrikeLine
//                Get _ExtractLegacyBooleanContent sOverstrikeLine to BooleanIndicator
////                Move (iPos + 4) to Data.iStartPos
////                Move (Replace("[", sIndicator, "")) to sIndicator
////                Move (Replace("]", sIndicator, "")) to sIndicator
//            End
//        End
//        
//        Function_Return BooleanIndicator 
//    End_Function
    
    // Takes a string like: [not Seqeof] Begin
    // and returns struct as: True, True, iStartPos and "(not(Seqeof))".
    Function _ExtractLegacyBooleanContent tTokenizer TokenizerData Returns tBooleanIndicator
        Integer iPos iStart iStop                                            
        String sChar sNot sBoolean sFirstWord sCommand sExpression sOverstrikeLine 
        Boolean bRightSideIndicator bFound bIndicateWord
        tBooleanIndicator BooleanIndicator  
        tOperatorsInfo OperatorsInfo
        
        // This also checks that it isn't an array declaration.          
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        Get _IsIndicatorStatement sOverstrikeLine to bFound
        If (bFound = False) Begin
            Function_Return BooleanIndicator
        End

        Move (Lowercase(sOverstrikeLine) contains Lowercase(CS_Indicate)) to BooleanIndicator.bHasIndicateCommand 

        // Get first indicator;
        Move (Pos("[", sOverstrikeLine)) to iStart
        Move (Pos("]", sOverstrikeLine)) to iStop
        If (iStart <> 0 and iStop <> 0) Begin
            Move (Mid(sOverstrikeLine, (iStop - iStart -1), (iStart + 1))) to sBoolean
            Move sBoolean to BooleanIndicator.FirstIndicator.sCode
            Move iStart   to BooleanIndicator.FirstIndicator.iStartPos  
            Move True to BooleanIndicator.bHasBracket
            Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
            Move (iPos <> 0) to BooleanIndicator.bHasNot
            
            // Is there a second indicator before the "to" keyword?
            Move (Mid(sOverstrikeLine, Length(sOverstrikeLine), (iStop + 1))) to sOverstrikeLine
            Move (Pos("[", sOverstrikeLine)) to iStart
            Move (Pos("]", sOverstrikeLine)) to iStop
            If (iStart <> 0 and iStop <> 0) Begin
                Move (Mid(sOverstrikeLine, (iStop - iStart -1), (iStart + 1))) to sBoolean
                Move sBoolean to BooleanIndicator.SecondIndicator.sCode
                Move iStart   to BooleanIndicator.SecondIndicator.iStartPos  
                Move True to BooleanIndicator.bHasBracket
                Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
                Move (iPos <> 0) to BooleanIndicator.bHasNot
            End    
        End
        
        // Get any indicator after the "to" keyword;
        Move (Pos(Lowercase(" " + CS_To + " "), Lowercase(sOverstrikeLine))) to iPos
        If (iPos > 0) Begin
            Move (Mid(sOverstrikeLine, Length(sOverstrikeLine),(iPos +1))) to sOverstrikeLine
            Move (Pos("[", sOverstrikeLine)) to iStart
            Move (Pos("]", sOverstrikeLine)) to iStop
            If (iStart > 0 and iStop <> 0) Begin
                Move (Mid(sOverstrikeLine, (iStop - iStart -1), (iStart + 1))) to sBoolean
                Move sBoolean to BooleanIndicator.ToIndicator.sCode
                Move iStart   to BooleanIndicator.ToIndicator.iStartPos
                Move True to BooleanIndicator.bHasBracket
                Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
                Move (iPos <> 0) to BooleanIndicator.bHasNot
            End
        End

//        Move (RightPos("[", sOverstrikeLine)) to iStart
//        Move (RightPos("]", sOverstrikeLine)) to iStop
//        Move (Mid(sOverstrikeLine, (iStop - iStart -1), (iStart + 1))) to sBoolean
//        Move iStart to BooleanIndicator.ToIndicator.iStartPos
//        If (iStart <> 0 and iStop <> 0) Begin
//            Move True to BooleanIndicator.bHasBracket
//        End
//        Move (Trim(sFirstWord)) to sCommand    
//        Move (Trim(sBoolean)) to sBoolean
//
//        Move "" to sNot
//        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
//        If (iPos <> 0) Begin
//            Move (Mid(sBoolean, Length(sBoolean), (iPos + 4))) to sBoolean
//            Move (String(CS_Not)) to sNot
//        End                    
//        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
//        If (sNot <> "") Begin
//            Move True to BooleanIndicator.bHasNot
//        End 
//        Move (Trim(sCommand)) to BooleanIndicator.FirstIndicator.sCode
            
        Function_Return BooleanIndicator
    End_Function
    
    // Takes a string like: [not Seqeof] Begin
    // and returns struct as: True, True, iStartPos and "(not(Seqeof))".
    // bHasBracket denotes that the expression contains a "not" as in [not Seqeof]. 
    // Note: It does not act on lines with the legacy "Indicate" in it.
    Function _ExtractIndicatorContent tTokenizer TokenizerData Integer eIndicatorMode Returns tBooleanIndicator
        Integer iPos                                             
        String sChar sNot sBoolean sFirstWord sCommand sExpression sOverstrikeLine
        Boolean bRightSideIndicator bFound bIndicateWord
        tBooleanIndicator BooleanIndicator  
        tOperatorsInfo OperatorsInfo
        
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        // This also checks that it isn't an array declaration.
        Get _IsIndicatorStatement sOverstrikeLine to bFound
        Move (Lowercase(sOverstrikeLine) contains Lowercase(CS_Indicate)) to bIndicateWord
        If (bFound = False and bIndicateWord = False) Begin
            Function_Return BooleanIndicator
        End
        Get _ExtractLegacyBooleanContent TokenizerData to BooleanIndicator        
            
        Function_Return BooleanIndicator
    End_Function
    
    // Helper function for the SplitInlineIfElseLine function.
    Function _BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
        Boolean bChanged
        Integer iPos
        String  sLineIndent sIndent sLine1 sLine2 sText
        tTokenizer TokenizerData
        
        Move False to bChanged
        Move (Lowercase(sLine)) to sText
        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
        Move (Repeat(" ", iLineIndent)) to sLineIndent
        Get pTokenizer to TokenizerData
        Get _FindCommand (&TokenizerData) sText to iPos
        If (iPos <> 0) Begin
            Move True to bChanged
            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitBySemiColumn) Begin
                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitByBeginEnd) Begin
                Move (Insert((" Begin" + CS_CRLF + sLineIndent + sIndent), sLine, iPos)) to sLine
                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
            End

            // Remove any spaces before the point on which we break the line
            Move (Left(sLine, iPos - 1)) to sLine1
            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
            Move (RTrim(sLine1)) to sLine1
            Move (sLine1 + sLine2) to sLine
        End
        Function_Return bChanged
    End_Function

    // Parses the method name from the string
    Function _MethodName String sOverstrikeLine Returns String
        Integer iPos
        String sMethod
        Get _RemoveFirstToken sOverstrikeLine sMethod to sMethod
        Move (Right(sMethod, (Length(sMethod) - iPos))) to sMethod
        If (Uppercase(Left(Trim(sMethod), 4)) = "SET ") Begin
            Get _RemoveFirstToken sOverstrikeLine sMethod to sMethod
        End
        // Remove any trailing arguments
        Move (Pos(" ", sMethod)) to iPos
        Function_Return (Left(sMethod, (iPos - 1)))
    End_Function                      
    
    // For declarations like "String [] asAddress" 
    // Is changed to: "String[] asAddress
    // If the sLine is a local variable declaration, it starts
    // with either a "local" keyword or one of the members
    // in pasLocalVariableTypes.
    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
        Boolean bChanged bFound
        String sText sWord
        
        Move sLine to sText  
        Get _FirstToken sLine to sWord
        If (sWord = "") Begin
            Function_Return False
        End
        Get _IsVariableDeclaration sWord to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        While (Pos(" [", sText) > 0)
            Move (Replace(" [", sText, "[")) to sText
        Loop                                       
        Move (sLine = sText) to bChanged             
        If (bChanged = True) Begin
            Move sText to sLine
        End
        Function_Return bChanged
    End_Function   
    
    // Returns True if the number of single- and double-quotes in the sLine param is not even.
    Function _IsOpenString String sLine Returns Boolean
        Boolean bIsOpenString                    
        Integer iDoubleQuotes iSingleQuotes
        UChar[] uaLine
        
        Move (StringToUCharArray(sLine)) to uaLine 
        Move (CountArray(Ascii('"'), uaLine)) to iDoubleQuotes
        Move (Mod(iDoubleQuotes, 2)) to bIsOpenString
        If (bIsOpenString = False) Begin
            Move (CountArray(Ascii("'"), uaLine)) to iSingleQuotes
            Move (Mod(iSingleQuotes, 2)) to bIsOpenString
        End

        Function_Return bIsOpenString        
    End_Function

    Function _IsDoubleQuoteStart String sOverstrikeLine Returns Boolean
        Integer iPosDouble iPosSingle 
        Boolean bDoubleQuotedString
        
        Move True to bDoubleQuotedString
        Move (Pos('"', sOverstrikeLine)) to iPosDouble
        Move (Pos("'", sOverstrikeLine)) to iPosSingle
        If (iPosSingle <> 0) Begin
            Move (iPosDouble < iPosSingle) to bDoubleQuotedString
        End
        Else Begin
            Move (iPosDouble > iPosSingle) to bDoubleQuotedString
        End
        Function_Return bDoubleQuotedString
    End_Function
    
    // Returns the number of single or double quotes contained in the "sLine" param.
    { EnumList="{CI_SingleQuotes, CI_DoubleQuotes}" }
    Function _NumberOfStringQuotes String sLine Integer eQuoteMode Returns Integer
        Integer iQuotes
        UChar[] uaLine
        
        Move (Trim(sLine)) to sLine
        Get _RemoveEndComment sLine to sLine
        Move (StringToUCharArray(sLine)) to uaLine 
        If (eQuoteMode = CI_DoubleQuotes) Begin
            Move (CountArray(Ascii('"'), uaLine)) to iQuotes
        End
        If (eQuoteMode = CI_SingleQuotes) Begin
            Move (CountArray(Ascii("'"), uaLine)) to iQuotes
        End

        Function_Return iQuotes        
    End_Function
    
    
    // This will pad out the string constants in a line and overstrike characters
    // with _ characters for a "string" and + characters for a 'string'
    // It will also remove any end comment like; "Move x to y // Some comment",
    //       and trim the return string.  
    // If no quotes ("" or '') were found, the TokenizerData.sLine is returned. 
    // It overstrikes DF 23 multi-line comments with hash-marks.
    Function _OverstrikeStrings tTokenizer ByRef TokenizerData Returns String
        Boolean bDoubleQuote bSingleQuote bChanged bFound bHasEndSemiColon bIsInDF23MultiLineString  bIsInSemiColonMultiLineString
        Boolean bIsOpenString bIsInSingleQuote bIsInDF23MultiLineComment
        Integer iChar iLength iPos iDoubleQuotes iSingleQuotes
        String  sChar sText sTrippelDoubleQuote sComment sContent sSingleQ sDoubleQ
        
        // If we already have applied this function to a source line, do nothing.
        If (TokenizerData.bHasOverstrikeChars = True) Begin
            Function_Return TokenizerData.sOverstrikeLine
        End              

        If (pbIsInPage(Self) = True or pbIsInDF23MultiLineComment(Self) = True) Begin
            If (pbIsInDF23MultiLineComment(Self) = True) Begin
                Move TokenizerData.sLine to sText
                Move (Length(sText)) to iLength
                Move (Repeat("#", iLength)) to sText
            End             
            Else Begin
                Move TokenizerData.sLine to sText
            End
            Function_Return sText
        End
        
        // Does the sLine end with a semi-colon ";"?
        Get _HasLineEndSemiColon TokenizerData.sLine to bHasEndSemiColon    
        Get pbIsInSemiColonMultiLineString to bIsInSemiColonMultiLineString
        // Are we already in an "open" multi-line string? An "open" string is a string constant
        // spread out over several lines. So there may be *no* quotes or an uneven number of quotes 
        // in the sLine content, in which case we need to treat the line differently.
        Get pbIsInDF23MultiLineString to bIsInDF23MultiLineString
        Get pbIsOpenString to bIsOpenString
        If (bIsOpenString = False) Begin
            Get _IsOpenString TokenizerData.sLine to bIsOpenString
        End 
        
        Get _EndComment (&TokenizerData) to sComment 
        Move TokenizerData.sLine to sText 
        // Don't think we should trim, especially considering multi-line comments.
//        Move (Trim(sText)) to sText
        If (sComment <> "") Begin
            Move (Replace(sComment, sText, "")) to sText
        End
        Move False to bChanged 
        Move (Length(sText)) to iLength
        If (bIsInDF23MultiLineString = False and bIsOpenString = False) Begin
            Move (Pos('"', sText)) to iPos
            If (iPos = 0) Begin
                Move (Pos("'", sText)) to iPos
                If (iPos = 0) Begin
                    Function_Return (Trim(sText))
                End
            End                                          
        End
        
        Move False to bDoubleQuote
        Move False to bSingleQuote
        Get _NumberOfStringQuotes sText CI_SingleQuotes to iSingleQuotes  
        Get _NumberOfStringQuotes sText CI_DoubleQuotes to iDoubleQuotes  
        // ToDo: I *really* dislake this multi-line string logic! It seems overcomplicated and
        //       should be possible to simplify, but how?
        // This property is set when a multi-line string is started, to indicate
        // if the beginning of the string was a single- or double-quote character.
        Get pbIsInSingleQuote to bIsInSingleQuote
        If (bIsInDF23MultiLineString = True or bIsInSemiColonMultiLineString = True) Begin  
            If (bIsInSingleQuote = False) Begin
                If (iDoubleQuotes = 0 and iSingleQuotes < 2) Begin  
                    Move (Length(sText)) to iLength
                    Move (Repeat("_", iLength)) to sText
                    If (bHasEndSemiColon = True) Begin
                        Move (Left(sText, (Length(sText) -1))) to sText
                        Append sText ";"              
                    End
                    Move sText to TokenizerData.sOverstrikeLine
                    Function_Return TokenizerData.sOverstrikeLine
                End     
            End 
            Else Begin
                If (iSingleQuotes = 0) Begin  
                    Move (Length(sText)) to iLength
                    Move (Repeat("+", iLength)) to sText
                    Move sText to TokenizerData.sOverstrikeLine
                    Function_Return TokenizerData.sOverstrikeLine
                End     
            End
            If (iDoubleQuotes = 0 and bIsInSingleQuote = False) Begin
                Move True to bDoubleQuote    
            End
            If (bDoubleQuote = False) Begin
                Move (Mod(iSingleQuotes, 2) = 0 and iSingleQuotes <> 0) to bDoubleQuote
            End
            If (bDoubleQuote = False) Begin
                Move (Mod(iDoubleQuotes, 2) = 0 and iDoubleQuotes <> 0) to bSingleQuote
            End
            If (bDoubleQuote = False) Begin
                Move (iDoubleQuotes = 1) to bDoubleQuote
            End
        End 
//        If (bIsInSemiColonMultiLineString = True) Begin
//            If (bHasEndSemiColon = True) Begin
//                    
//            End
//        End
//        Else Begin
//            
//        End

        For iChar from 1 to iLength
            Move (Mid(sText, 1, iChar)) to sChar
            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
                Move True to bChanged
                Move " " to sChar
            End
            If (bDoubleQuote and sChar= '"') Begin
                Move True to bChanged
                Move "" to sChar
                Move False to bDoubleQuote
            End
            If (bSingleQuote and sChar = "'") Begin
                Move True to bChanged
                Move "" to sChar
                Move False to bSingleQuote
            End
            If (bIsInDF23MultiLineString = True and bIsOpenString = True) Begin
                If (bDoubleQuote and sChar = "'") Begin
                    Move False to bDoubleQuote
                    Move True to bSingleQuote
                End
                Else If (bSingleQuote and sChar = '"') Begin
                    Move False to bSingleQuote
                    Move True to bDoubleQuote
                End   
                Else If (bDoubleQuote = False and bSingleQuote = False) Begin
                    Move (Mid(sText, 1, iChar)) to sChar
                    If (sChar = "'") Begin
                        Move True to bDoubleQuote
                    End
                    If (sChar = '"' and bHasEndSemiColon = True) Begin
                        Move True to bSingleQuote
                    End                          
                    Move "" to sChar
                End
            End
            If (bIsOpenString = True) Begin
                
            End
            If (bSingleQuote = False and sChar ='"') Begin
                Move (Mid(sText, 3, iChar)) to sTrippelDoubleQuote
                If (sTrippelDoubleQuote = '"""') Begin
                    Move (iChar + 2) to iChar
                End                          
                Else Begin
                    Move True to bDoubleQuote
                End
            End
            If (bDoubleQuote = False and sChar = "'") Begin
                Move True to bSingleQuote
            End
            If bDoubleQuote Begin    
                If (sChar <> '"') Begin
                    Move (Overstrike("_", sText, iChar)) to sText 
                    Append sContent sChar
                End
                Move True to bChanged
            End
            Else If bSingleQuote Begin
                If (sChar <> "'") Begin
                    Move (Overstrike("+", sText, iChar)) to sText
                    Append sContent sChar
                End
                Move True to bChanged
            End
        Loop    
        
        If (bChanged = True) Begin   
            Move True          to TokenizerData.bHasOverstrikeChars
            Move (Trim(sText)) to sText    
            // Add back the end-of-line semi-colon:
            If (bHasEndSemiColon = True) Begin
                Move (Left(sText, (Length(sText) -1))) to sText
                Append sText ";"              
            End
            Move sText to TokenizerData.sOverstrikeLine
        End    
        Else Begin
            Move TokenizerData.sLine to TokenizerData.sOverstrikeLine
        End
        Function_Return TokenizerData.sOverstrikeLine
    End_Function

    Function _Indentation tTokenizer ByRef TokenizerData Returns String
        String sLine sText sIndentation
        Move "" to sIndentation                          
        Move TokenizerData.sLine to sLine
        Move (Ltrim(sLine)) to sText
        If (sText <> sLine) Begin
            Move (Replace(sText, sLine, "")) to sIndentation
        End
        Function_Return sIndentation
    End_Function
        
    // Get the left part of the line up to but not including the "of or to" part..
    Function _LeftStatement tTokenizer ByRef TokenizerData Returns tToken
        String sOverstrikeLine sStatement
        Integer iPos                                           
        tToken Data
        
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        // Start by assuming there is no "of" or "to" keyword;
        Move 1 to Data.iStartPos
        Move (Trim(sOverstrikeLine)) to Data.sCode
        
        // Search for a "to" keyword;
        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sOverstrikeLine))) to iPos
        If (iPos <> 0) Begin
            Move (Left(sOverstrikeLine, (iPos - 1))) to sOverstrikeLine
            Move (iPos + 4) to Data.iStartPos
            Move (Trim(sOverstrikeLine)) to Data.sCode
        End             

        // Then search for a "of" keyword;
        Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sOverstrikeLine))) to iPos
        If (iPos <> 0) Begin
            Move (Left(sOverstrikeLine, (iPos -1))) to sOverstrikeLine
            Move (iPos + 4) to Data.iStartPos
            Move (Trim(sOverstrikeLine)) to Data.sCode
        End
    
        Function_Return Data 
    End_Function

    // Get the "of xxxx " part from a source line. But not the "to xxx" part and the "of" keyword.
    Function _OfStatement tTokenizer ByRef TokenizerData Returns tToken
        String sOverstrikeLine sOfStatement
        Integer iPos                                           
        tToken Data
        
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sOverstrikeLine))) to iPos
        If (iPos = 0) Begin
            Function_Return Data
        End
        
        Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sOverstrikeLine))) to iPos
        Move (iPos + 4) to Data.iStartPos
        Move (Mid(sOverstrikeLine, (Length(sOverstrikeLine) -1), (iPos + Length(CS_Of) + 1))) to sOfStatement
        Move (Left(sOverstrikeLine, (iPos - 1))) to sOverstrikeLine
        // If an "to sVariable" expression exist, remove it.
        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sOfStatement))) to iPos
        If (iPos <> 0) Begin
            Move (Left(sOfStatement, (iPos - 1))) to sOfStatement    
        End
        Move (Trim(sOfStatement)) to sOfStatement
    
        Move sOfStatement to Data.sCode
        Function_Return Data 
    End_Function

    // Get the "to xxx" part, but without the "to" keyword.
    Function _ToStatement tTokenizer ByRef TokenizerData Returns tToken
        String sOverstrikeLine sToStatement
        Integer iPos                               
        tToken Data
        
        Move "" to sToStatement
        Move TokenizerData.sOverstrikeLine to sOverstrikeLine
        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sOverstrikeLine))) to iPos
        If (iPos = 0) Begin
            Function_Return Data
        End
        Move (iPos + 4) to Data.iStartPos
        Move (Mid(sOverstrikeLine, (Length(sOverstrikeLine) -1), (iPos + Length(CS_To) + 1))) to sToStatement
        Move (Trim(sToStatement)) to Data.sCode
        
        Function_Return Data
    End_Function
    
    // Returns the end comment if one exists.
    // Else returns an empty string
    Function _EndComment tTokenizer ByRef TokenizerData Returns String
        Integer iPos
        String sLine sComment

        Move "" to sComment                             
        Move TokenizerData.sLine to sLine
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (Pos(CS_CommentSymbol, sLine)) to iPos
            Move (Mid(sLine, Length(sLine), iPos)) to sComment
        End
        Function_Return sComment
    End_Function

    // It takes any source line as a parameter and
    // returns the same string without the end comment.
    Function _RemoveEndComment String sLine Returns String
        Integer iPos
        String sTest
        
        Move sLine to sTest
        Move (Trim(sTest)) to sTest
        Move (Pos(CS_CommentSymbol, sTest)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (RightPos(CS_CommentSymbol, sLine)) to iPos
            Move (Left(sLine, iPos - 1)) to sLine
        End
        Function_Return (Rtrim(sLine))
    End_Function

    Function _RemoveComments String ByRef sLine Returns Boolean
        Boolean bRemoved
        Integer iPos

        Move False to bRemoved   
        Move sLine to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, iPos - 1)) to sLine
            Move True to bRemoved
        End
        Function_Return bRemoved
    End_Function  
    
    Function _IsKeyWord String sToken Returns Boolean
        String[] asKeyWords
        Integer iItem
        Get pasKeyWords to asKeyWords
        Move (Trim(Lowercase(sToken))) to sToken
        Move (SearchArray(sToken, asKeyWords)) to iItem
        Function_Return (iItem <> -1)
    End_Function

    // Removes the first token, i.e first part of the input string
    // until the first space and returns the reminder, unless the string
    // only consists of a single token, in case the same value will be returned.
    Function _RemoveFirstToken String sOverStrikeLine Returns String
        Integer iPos iItem
        Boolean bChanged  
        String sToken
        
        Get _NormalizeArrayNotation (&sOverStrikeLine) to bChanged
        Move (Pos(" ", sOverStrikeLine)) to iPos
        Move (Right(sOverStrikeLine, (Length(sOverStrikeLine) - iPos))) to sToken
        Move (Trim(sToken)) to sToken             
        Move (Replace(sToken, sOverStrikeLine, "")) to sOverStrikeLine
        
        Function_Return sOverStrikeLine
    End_Function

    // Returns the first word of any input string
    // all up to the first space encountered
    Function _RetrieveFirstToken String sOverStrikeLine Returns String
        String sFirstWord
        Integer iPos
        Boolean bChanged
        
        Get _NormalizeArrayNotation (&sOverStrikeLine) to bChanged  
        Move (Trim(sOverStrikeLine)) to sOverStrikeLine
        Move (Pos(" ", sOverStrikeLine)) to iPos
        If (iPos = 0) Begin
            Move "" to sFirstWord
        End                      
        Else Begin
            Move (Left(sOverStrikeLine, (iPos -1))) to sFirstWord
        End
        Move (Trim(sFirstWord)) to sFirstWord
        Function_Return sFirstWord
    End_Function

    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
    // RemoveLeft("D", "ABC")                   -> "ABC"
    // RemoveLeft("is ", "This is an example")  -> "an example"    
    // Note: It it also looks within strings e.g. "This is a string"
    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
        Integer iPosStart iPosEnd 
        String sText
        
        Move sHostString to sText
        Move (Pos(sSubString, sText)) to iPosStart
        Move (iPosStart + Length(sSubString) - 1) to iPosEnd

        If (iPosStart) Begin                                
            If (iPosEnd = Length(sText)) Begin
                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
            End 
            Else Begin
                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
            End
        End                                              
        
        Function_Return (sHostString <> sText)
    End_Function

    // Helper function
    Function _RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
        Boolean bChanged
        String sText
        Integer iPos

        Move False to bChanged
        Move (LTrim(sLine))     to sText
        Move (Left(sText, 9))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = "property ") Begin
            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
            If (iPos = 0) Begin // if there's a tab char instead of a space then..
                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
            End
            If (iPos > 0) Begin
                Move (Overstrike(Repeat(" ", Length(sPubPriv)), sLine, iPos + 1)) to sLine // skip first character, don't overwrite a tab with a space
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // helper function for _IsKeywordInLine, when a keyword is found in a string declaration
    Function _RemoveStringsFromLine String sLine Returns String
        Integer iLength iPos
        Boolean bSep1 bSep2
        String  sChar sSep1 sSep2 sReturn

        Move False to bSep1
        Move False to bSep2
        Move "'" to sSep1
        Move '"' to sSep2
        Move ""  to sReturn
        Move (Length(sLine)) to iLength

        For iPos from 1 to iLength
            Move (Mid(sLine, 1, iPos)) to sChar
            If (bSep1 = False and bSep2 = False) Begin
                If (sChar = sSep1) Begin
                    Move True to bSep1
                End
                Else If (sChar = sSep2) Begin
                    Move True to bSep2
                End
                If (bSep1 = False and bSep2 = False) Begin
                    Move (sReturn + sChar) to sReturn
                End
            End
            Else Begin
                If (bSep1) Begin
                    If (sChar = sSep1) Begin
                        Move False to bSep1
                    End
                End
                Else If (bSep2) Begin
                    If (sChar = sSep2) Begin
                        Move False to bSep2
                    End
                End
            End
        Loop

        Function_Return sReturn
    End_Function 
    
    // Returns true if the passed sKeyword exists in the TokenizerData.asLineTokensLC,
    // else returns False.
    // Note that the asLineTokensLC doesn't contain any string constants and expressions are
    // kept together as one item in the array.
    Function IsKeyWordInLine tTokenizer TokenizerData String sKeyword Returns Boolean
        Boolean bFound
        Move (Lowercase(sKeyword)) to sKeyword
        Move (SearchArray(Lowercase(sKeyword), TokenizerData.asLineTokensLC)) to bFound 
        Function_Return bFound  
    End_Function

    // ToDo: Redo!!!
    Function _SingleCommandSyntaxToFunction tExpression[] aExpression String sLine String sKeyWord Returns Boolean
        Boolean bChanged bIsCommentOrBlank bFound bIfStatement bIsFirstKeyWord
        String sText sLowerKeyWord sLowerCase sFirstWord sExpression
        Integer iPos
        
Function_Return // Temp!       
        Move False to bChanged
        Move False to bIsFirstKeyWord  
        Move "" to sExpression
        Move sLine to sText
        Get _IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End      
        
        Get _HasCommand sText sKeyWord to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Get _HasIfCommand sText to bIfStatement
        Move (Lowercase(sKeyWord)) to sLowerKeyWord
        If (bIfStatement = False) Begin
            Get _RetrieveFirstToken sText to sFirstWord
            If (Lowercase(sFirstWord) = Lowercase(sKeyWord)) Begin
                Get _RemoveFirstToken sText to sLine
            End    
//            If (Lowercase(sFirstWord) <> sLowerKeyWord) Begin
//                Function_Return False
//            End
        End
        If (bIfStatement = True) Begin
            Get _FetchExpression aExpression CI_LeftExpression1 to sExpression  
            If (Trim(sExpression) <> "") Begin
                Move (Pos(sExpression, sText)) to iPos
                Move (Mid(sText, Length(sText), (iPos + Length(sExpression)))) to sText
                Move (Mid(sLine, Length(sLine), (iPos + Length(sExpression)))) to sLine
            End
            // Do we still have the keyword in the line?
            Get _HasCommand sLine sKeyWord to bFound
            If (bFound = False) Begin   
                Move (String(sExpression) + String(sLine)) to sLine 
                If (bIfStatement = True) Begin
                    Move (CS_If * String(sLine)) to sLine
                End
                Function_Return False
            End
        End
        
//        Move (Pos(sLowerKeyWord, Lowercase(sText))) to iPos
        Move sLine to sText
        
        // If the line starts with the Key word.
//        If (Pos(sLowerKeyWord, Lowercase(TokenizerData.sCode)) = 1) Begin
//            Move (sLowerKeyWord + " ") to sLowerKeyWord
//        End                                  
//        Else Begin
//            Move (" " + String(sLowerKeyWord) + " ") to sLowerKeyWord
//        End
//        Move (Lowercase(TokenizerData.sCode) contains sLowerKeyWord) to bFound
        Get _RetrieveFirstToken sLine to sFirstWord
        Move (Lowercase(sFirstWord) = Lowercase(sKeyWord)) to bFound
        If (bFound = False) Begin      
//            If (sExpression <> "") Begin
//                Move (CS_If * String(sExpression) + String(sLine)) to sLine
//            End
            Function_Return False
        End
        
        Move (Lowercase(sLine)) to sText
        Move (Mid(sLine, (Length(sLine)), (Length(sKeyWord) + 1))) to sText
        Move (Ltrim(sText)) to sText   
        If (sKeyWord = CS_Pos) Begin
            Move (Lowercase(sText)) to sLowerCase
            Move (Pos(" in ", sLowerCase)) to iPos
            If (iPos <> 0) Begin
                Move (Overstrike("____", sText, iPos)) to sText
                Move (Replace("____", sText, ", ")) to sText
                Move True to bChanged
            End
        End                                                                                                                              

        // ToDo: temp commented out to be able to compile!
//        If (Length(TokenizerData.sEndComment)  > 0) Begin
//            Move (TokenizerData.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(TokenizerData.ToStatement.sCode) * String(TokenizerData.sEndComment)) to sLine
//            Move True to bChanged
//        End
//        Else Begin
//            Move (TokenizerData.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(TokenizerData.ToStatement.sCode)) to sLine
//            Move True to bChanged
//        End
        
        Function_Return bChanged
    End_Function

    // ToDo: Redo logic with (SearchArray(xxx))
    // Helper function. This is a list of commands that also exists as DataFlex string functions.
    Function _TestCommandFunctions String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommandFunctions

        Move 0 to iPos
        Get _RemoveComments (&sTest) to bRemoved
        Get pasCommandFunctions to asCommandFunctions
        Move (SizeOfArray(asCommandFunctions)) to iSize
        If (iSize = 0) Begin
            Get pasCommandFunctions to asCommandFunctions
            Move (SizeOfArray(asCommandFunctions)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommandFunctions[iCount] to sCommand
            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop

        Function_Return iPos
    End_Function

    Function _HasDoubleExpression String sExpression Returns Boolean
        Boolean bFound      
        Integer iCount iSize iOpCount iParanthesis
        String sChar sOperators
        
        Move False to bFound  
        Move 0 to iParanthesis           
        Move "<=>" to sOperators
        Move (Length(sExpression)) to iSize
        For iCount from 1 to iSize
            Move (Mid(sExpression, 1, iCount)) to sChar
            If (sChar = "(") Begin
                Increment iOpCount          
                Increment iParanthesis
            End
            If (sChar = ")") Begin
                Decrement iOpCount
            End
            If (iParanthesis <> 0 and sOperators contains sChar) Begin
                If (iOpCount = 0) Begin
                    Move True to bFound
                    Move iSize to iCount // We're done.
                End
            End
        Loop
        
        Function_Return bFound
    End_Function
    
    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
    Function _HasCommand String sOverstrikeLine String sCommand Returns Boolean
        Boolean bFound bOk
        String sText

        Move False to bFound 
        Get _RemoveEndComment sOverstrikeLine to sText
        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound
        
        Function_Return bFound
    End_Function
    
    // Returns True iif the source line contains a "Begin" statement.
    Function _HasBeginStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + CS_Begin) to bFound
        Function_Return bFound
    End_Function   
    
    Function _IsBlankLine String sLine Returns Boolean
        Boolean bIsBlank
        
        Move False to bIsBlank
        Move (Trim(sLine)) to sLine
        If (Length(sLine) = 0) Begin
            Move True to bIsBlank
        End
        
        Function_Return bIsBlank        
    End_Function
    
    Function _IsCommentLine String sLine Returns Boolean
        Boolean bIsComment
        
        Move (Trim(sLine)) to sLine
        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment
        
        Function_Return bIsComment
    End_Function

    // Returns True if this is a comment line with "//" to the left,
    // or if the line is blank.
    Function _IsCommentLineOrBlank String sLine Returns Boolean
        Boolean bIsComment bIsBlank
        
        Get _IsCommentLine sLine to bIsComment
        Get _IsBlankLine sLine to bIsBlank
        
        Function_Return (bIsComment = True or bIsBlank = True)
    End_Function

    // Returns False if the first line in the passed file is _not_ an automatically generated
    // COM wrapper file created by the Studio.
    // If it returns True, we should not process that file.
    Function _IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
        Boolean bIsDFCOMProxyClasses bExists        
        Integer iCh iPos
        String sLine
        
        Move False to bIsDFCOMProxyClasses  
        File_Exist sFileName bExists
        If (bExists = False) Begin
            Error DfErr_Program ("The file doesn't exist:" * String(sFileName))
            Function_Return False
        End
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DfErr_Program "No Channel Available for: 'Function _IsDataFlexCOMProxyClassesFile'"
            Function_Return False
        End
        
        Direct_Input channel iCh sFileName
        Readln channel iCh sLine
        Close_Input channel ich
        Send Seq_Release_Channel iCh
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End

        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses        
        Function_Return bIsDFCOMProxyClasses
    End_Function
    
    // Returns True iif the source line starts with the sCommand statement.
    Function _IsFirstWord String sLine String sCommand Returns Boolean
        Boolean bFound
        Integer iPos  
        String sFirstWord 
        
        Move (Ltrim(Lowercase(sLine))) to sLine
        Move (Ltrim(Lowercase(sCommand))) to sCommand
        If (sLine = sCommand) Begin
            Function_Return True
        End
        Move (sCommand + " ") to sCommand
        Move (Pos(" ", sLine)) to iPos
        Move (Left(sLine, iPos)) to sFirstWord
        Move (sFirstWord = sCommand) to bFound
        Function_Return bFound
    End_Function   
    
    // Returns True if source line contains a "[Found]", or "[FindErr]".
    Function _IsFoundOrFindErrIndicator tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bFound
        Integer iLeft iRight iPos
        String sLine sText 
        
        If (TokenizerData.IndicatorInfo.bHasIndicateCommand = False) Begin
            Function_Return False
        End

        Move TokenizerData.sOverstrikeLine to sText  
        Get _StripConcatenatingSpaces sText to sLine
        Move (Pos("[", sLine)) to iLeft
        Move (Pos("]", sLine)) to iRight
        Move (Pos(("[" + Lowercase(CS_Found)), sLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos(("[" + Lowercase(CS_Finderr)), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Finderr) + "]"), sLine)) to iPos
        End
            
        Function_Return (iPos <> 0)    
    End_Function
    
    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
    // Note: The source line must first have been stripped of any comments
    Function _HasIfAndBeginStatement tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bisIfBegin bHasBeginStatement                       
        
        Get _HasIfCommand TokenizerData.sOverstrikeLine to bisIfBegin
        Get _HasBeginStatement TokenizerData.sOverstrikeLine to bHasBeginStatement
        Function_Return (bisIfBegin = True and bHasBeginStatement = True)
    End_Function   
    
    Function _HasIfCommand String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (CS_If + " ") to bFound
        Function_Return bFound
    End_Function                                                  
    
    Function _IsImagePageStartOrEnd String sOverstrikeLine Boolean bCheckImageStart Returns Boolean
        Boolean bFound
        Integer iPos
        
        Move False to bFound
        If (bCheckImageStart = True) Begin
            Get _IsImageStart sOverstrikeLine to bFound
        End
        Else Begin                 
            Get _IsImageEnd sOverstrikeLine to bFound
        End

        Function_Return bFound
    End_Function

    // Old DF syntax that used pages, e.g. "/MyPage"
    Function _IsImageStart String sOverstrikeLine Returns Boolean
        Boolean bIsChar
        Integer iPos
        String sChar

        Move False to bIsChar
        Move (Pos(CS_ImageNameStart, sOverstrikeLine)) to iPos
        If (iPos = 1) Begin
            Move (Mid(sOverstrikeLine, 1, 2)) to sChar
            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsChar
        End

        Function_Return bIsChar
    End_Function 
    
    // Old DF syntax that used pages. To mark end of a page these two characters were used: "/*"
    Function _IsImageEnd String sOverstrikeLine Returns Boolean
        Boolean bFound
        Integer iPos
        Move (Pos(CS_ImageNameEnd, sOverstrikeLine)) to iPos
        Move (iPos = 1) to bFound
        Function_Return bFound
    End_Function

    // New DF 23 comment syntax.
    Function _IsDF23CommentStart String sOverstrikeLine Returns Boolean
        Integer iPos
        Move (Pos(CS_DF23CommentStart, sOverstrikeLine)) to iPos
        Function_Return (iPos <> 0)
    End_Function 
    
    // New DF 23 comment syntax.
    Function _IsDF23CommentEnd String sOverstrikeLine Returns Boolean
        Integer iPos
        Move (Pos(CS_DF23CommentEnd, sOverstrikeLine)) to iPos
        Function_Return (iPos <> 0)
    End_Function

    // DF 23 multi-line *comment* style start with a /* and ends with a */
    // Just fill the line with hash-marks (#) and return. 
    // The tokenizer members bIsMultiLineCommentStart & bIsMultiLineCommentEnd will 
    // be Set by the Tokenizer Function, after this function has been called.
    Function _DF23CommentOverwrite String sLine Returns String
        Boolean bIsInDF23MultiLineComment  
        String sOverstrikeLine 
        Integer iLength
        
        Move "" to sOverstrikeLine
        Get pbIsInDF23MultiLineComment to bIsInDF23MultiLineComment
        If (bIsInDF23MultiLineComment = False) Begin
            Get _IsDF23CommentStart sLine to bIsInDF23MultiLineComment
            If (bIsInDF23MultiLineComment = False) Begin
                Get _IsDF23CommentEnd sLine to bIsInDF23MultiLineComment
            End
        End
        If (bIsInDF23MultiLineComment = True) Begin
            Move (Length(sLine)) to iLength
            // Just overstrike the content
            Move (Repeat("#", iLength)) to sOverstrikeLine
        End
        Function_Return sOverstrikeLine
    End_Function

    // Returns True if source code contains both a "[" and a "]", but not a "[]"
    Function _IsIndicatorStatement String sOverStrikeLine Returns Boolean
        Boolean bFound bIndicatorWord
        Integer iLeft iRight iPos
        String sChar sLeftBracket
        
        Get _IsCommentLineOrBlank sOverStrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sOverstrikeLine) to bFound
        Move (Left(sOverstrikeLine, 1)) to sChar
        If (sChar = "[") Begin
            Move "[" to sLeftBracket
        End                         
        Else Begin
            Move " [" to sLeftBracket
        End
//        Move (Lowercase(sOverstrikeLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
        Move (bIndicatorWord = True or (sOverstrikeLine contains sLeftBracket and sOverstrikeLine contains "]")) to bFound
        If (bFound = True) Begin
            Move (Pos(sLeftBracket, sOverstrikeLine)) to iLeft
            Move (Pos("]", sOverstrikeLine)) to iRight
            Move ((iRight - iLeft) > 1) to bFound
        End
        Function_Return (bIndicatorWord or bFound)
    End_Function

    // Note: The sKeywords string must be separated by "|".
    Function _IsKeywordInLine String sKeywords String[] asLineTokensLC Returns Boolean
        String sKeyword sChar  
        String[] asKeywords 
        Integer iPos iSize iCount iTo iFrom iItem
        Boolean bOK 

        Move (Lowercase(sKeywords)) to sKeywords
        Move (StrSplitToArray(sKeywords, "|")) to asKeywords
        Move (SizeOfArray(asKeywords)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move (SearchArray(asKeywords[iCount], asLineTokensLC)) to iItem
            If (iItem <> -1) Begin
                Function_Return True    
            End
        Loop
        
//        Get _RemoveStringsFromLine sOverstrikeLine to sOverstrikeLine
//        Move (Pos(" ", sOverstrikeLine)) to iPos
//        // Then there is only one "word" in sOverstrikeLine. Check if the sKeywords = sOverstrikeLine
//        If (iPos = 0) Begin
//            Move (Replace("|", sKeywords, "")) to sKeyword
//            If (Trim(sKeyword) = Trim(sOverstrikeLine)) Begin
//                Function_Return True
//            End
//        End
//        
//        While (sKeywords <> "")
//            Move (Left(sKeywords, (Pos("|", sKeywords)))) to sKeyword
//            Move (Replace(sKeyword, sKeywords, "")) to sKeywords
//            Move (Trim(Replace("|", sKeyword, ""))) to sKeyword
//            Move ((sKeyword <> "") and ((Pos((" " + sKeyword + " "), sOverstrikeLine)) <> 0)) to bOK
//            If (bOK = False) Begin
//                Move ((sKeyword <> "") and ((Pos((sKeyword + " "), sOverstrikeLine)) <> 0) ) to bOK
//            End
//            // Also check if this might be the very first statement on the sOverstrikeLine 
//            If (bOK = True) Begin    
//                Move (Left(sKeyword, 1)) to sChar
//                // Is this a command?
//                If (sChar = "#") Begin
//                    Function_Return False
//                End
//                Else Begin
//                    Function_Return True
//                End
//            End
//        Loop

        Function_Return False
    End_Function

    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>" 
    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator. 
    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
    Function _LogicalOperators tTokenizer ByRef TokenizerData Returns tOperatorsInfo
        Boolean bHas 
        tOperatorsInfo OperatorsInfo
        String sOverStrikeLine
        
        Get _IsCommentLineOrBlank TokenizerData.sLine to bHas
        If (TokenizerData.bIsBlank = True or TokenizerData.bIsComment = True) Begin
            Function_Return OperatorsInfo
        End
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        Get _RemoveComments (&sOverStrikeLine) to bHas
        Move (Lowercase(sOverStrikeLine)) to sOverStrikeLine

        Case Begin                
            // "Legacy" operators;
            Case (sOverstrikeLine contains " gt ")
                Move (Pos(" gt ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "gt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " ge ")
                Move (Pos(" ge ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ge"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " lt ")
                Move (Pos(" lt ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "lt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " le ")
                Move (Pos(" le ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "le"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " eq ")
                Move (Pos(" eq ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "eq"                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains " ne ")
                Move (Pos(" ne ", sOverstrikeLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ne"                   to OperatorsInfo.sOperator
                Case Break
            
            // "Modern" operators;
            Case (sOverstrikeLine contains ">")
                Move (Pos(">", sOverstrikeLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">"                    to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains ">=")
                Move (Pos(">=", sOverstrikeLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">="                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "<")
                Move (Pos("<", sOverstrikeLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<"                    to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "<=")
                Move (Pos("<=", sOverstrikeLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<="                   to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "=")
                Move (Pos("=", sOverstrikeLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "="                    to OperatorsInfo.sOperator
                Case Break
            Case (sOverstrikeLine contains "<>")
                Move (Pos("<>", sOverstrikeLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<>"                   to OperatorsInfo.sOperator
                Case Break
            Case Else
                Move -1                     to OperatorsInfo.iPos
                Move False                  to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ""                     to OperatorsInfo.sOperator
        Case End
                
        Function_Return OperatorsInfo
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
    Function _HasLegacyOperators tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bHas bFound
        String sOverStrikeLine
        
        If (TokenizerData.bIsBlank = True or TokenizerData.bIsComment = True) Begin
            Function_Return False
        End
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        Get _RemoveComments (&sOverStrikeLine) to bHas
        Move (Lowercase(sOverStrikeLine)) to sOverStrikeLine

        Case Begin
            Case (sOverStrikeLine contains " gt ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " ge ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " lt ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " le ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " eq ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " ne ")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
    Function _IsOperators tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bHas
        String sOverStrikeLine
        
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine
        Get _RemoveComments (&sOverStrikeLine) to bHas 

        Case Begin
            Case (sOverStrikeLine contains ">")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains ">=")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "<")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "<=")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "=")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains "<>")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    // It is assumed that blank and commented lines has been checked prior
    // using this function.
    // It will return True if the source line contains any of the DF23's new string's.
    Function _IsDF23String tTokenizer ByRef TokenizerData Returns Boolean
        Integer iPos
        Boolean bFound  
        String sOverStrikeLine
        
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine        
        // First check for tripple double-quotes:
        Move (Pos('"""', sOverstrikeLine)) to iPos
        Move (iPos <> 0) to bFound
        
        // Second check is for "@" type multi-line string:
        If (bFound = False) Begin
            Move (Pos('@"', sOverstrikeLine) <> 0) to bFound
            If (bFound = False) Begin
                Move (Pos("@'", sOverstrikeLine) <> 0) to bFound
            End           
            // We have passed a sOverStrike string, thus the quotes surrounding
            // that string constant has been replaced with "_" and/or "+" characters.
            If (bFound = False) Begin
                Move (Pos("@_", sOverstrikeLine) <> 0) to bFound
            End
            If (bFound = False) Begin
                Move (Pos("@+'", sOverstrikeLine) <> 0) to bFound
            End
            If (bFound = False) Begin
                Move (Pos(Lowercase("@SQL"), Lowercase(sOverstrikeLine)) <> 0) to bFound
            End
        End
        Function_Return bFound
    End_Function  
    
    // It is assumed that blank and commented lines has been checked prior
    // using this function.
    // It will return True if the "sLine" parameter contains any of the DF23's new string's start,
    // or if it is a "classic" multi-line string ending with a semi-colon (;).
    // Else it returns False.
    Function _IsMultiLineStringStart tTokenizer ByRef TokenizerData Returns Boolean
        Integer iPos
        Boolean bFound  
        String sLine sSource
        
        // ToDo: Not sure we should have this here
//        Get _HasLineEndSemiColon TokenizerData.sOverstrikeLine to bFound
//        If (bFound = True) Begin
//            Function_Return True
//        End  
        Get _IsDF23String (&TokenizerData) to bFound
        If (bFound = False) Begin
            Function_Return False
        End                      
        
        Move False to bFound              
        Move (Trim(TokenizerData.sLine)) to sLine
        // Check for first tripple double-quotes:
        Move (Pos('"""', sLine)) to iPos
        Move (iPos <> 0) to bFound
        // Check for second tripple quote """ as in;
        // @SQL""" SELECT * FROM Customer WHERE Customer.Name = 'John Doe' """
        If (bFound = True) Begin
            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sSource
            Move (Pos('"""', sSource)) to iPos
            // If found we should return False as the multi-line string is contained on a single line.
            If (iPos <> 0) Begin
                Function_Return False
            End
            Move (iPos = 0) to bFound        
        End  
        Else Begin
            Move (Pos("@", sLine)) to iPos
            If (iPos <> 0) Begin
                // We need to make sure that the "@" char is not in a quotes string  constant.
                Move (Pos("@", sLine)) to iPos
                Move (iPos <> 0) to bFound        
            End
        End
        
        Function_Return bFound
    End_Function  
    
    // ToDo: Needs to be revised to also check for an "open" string ending with a 'ending string words" to iVariable' line.
    //
    // It is assumed that blank and commented lines has been checked prior
    // to using this function.
    // It will return True if the "sLine" parameter contains any of the DF23's new string's end,
    // which can be these characters; ', " or """.
    // If not found it returns false.
    Function _IsMultiLineStringEnd String sOverStrike Returns Boolean
        Boolean bFound
        String sChar
        
        // If a multi string hasn't been started; no point in testing further.
        If (pbIsInDF23MultiLineString(Self) = False) Begin
            Function_Return False
        End
        
        Move (Trim(sOverStrike)) to sOverStrike
        Move (Right(sOverStrike, 1)) to sChar
        Move (sChar = '"' or sChar = "'") to bFound
        If (bFound = False) Begin
            Move (Right(sOverStrike, 3)) to sChar
            Move (sChar = '"""') to bFound        
        End 
        If (bFound = False) Begin
            Get _HasLineEndSemiColon sOverStrike to bFound
        End
        
        Function_Return bFound
    End_Function

    Function _HasLineEndSemiColon String sOverstrikeLine Returns Boolean
        Boolean bRemoved
        String sLine
        Get _RemoveEndComment sOverstrikeLine to sLine
        Move (RTrim(sLine)) to sLine
        If (Right(sLine, 1) = ";") Begin
            Function_Return True
        End
        Function_Return False
    End_Function  
    
    // Used by the SplitInlineIfElseLine function.
    Function _IsLineEndSemiColonOrBegin String sLine Returns Boolean
        Boolean bRemoved
        Boolean bFound
        
        Get _HasLineEndSemiColon sLine to bFound
        If (bFound = False) Begin              
            Move (Trim(Lowercase(sLine))) to sLine
            If (Right(sLine, 5) = "begin") Begin
                Move True to bFound
            End
        End
        Function_Return bFound
    End_Function    
    
    // Returns True iif the source line is a "Loop" statement.
    Function _IsLoopStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + CS_Loop) to bFound
        Function_Return bFound
    End_Function   

    Function _IsMoveCommand String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + String(CS_Move) + " ") to bFound
        If (bFound = False) Begin
            Get _HasCommand sOverstrikeLine (String(CS_Move) + " ") to bFound
        End
        Function_Return bFound
    End_Function                                                  
    
    // Returns True iif the source line is a "Until" statement.
    Function _IsUntilStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand sOverstrikeLine (" " + CS_Until) to bFound
        If (bFound = False) Begin
            Get _HasCommand sOverstrikeLine (CS_Until + " ") to bFound
            If (bFound = False) Begin
                Get _HasCommand sOverstrikeLine (CS_Until) to bFound
            End
        End  
            
        Function_Return bFound
    End_Function   

    Function _IsVariableDeclarationLine String sOverstrikeLine Returns Boolean
        Boolean bVariableDeclaration
        String[] asLocalVariableTypes asLocalVariableArrayTypes
        Integer iRetval
        String sFirstWord

        Move False to bVariableDeclaration
        Get pasLocalVariableTypes      to asLocalVariableTypes
        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
        
        Get _RetrieveFirstToken sOverstrikeLine to sFirstWord
        Move (Uppercase(sFirstWord)) to sFirstWord
        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
        If (iRetval <> -1) Begin
            Move True to bVariableDeclaration
        End
        Else Begin
            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
            If (iRetval <> -1) Begin
                Move True to bVariableDeclaration
            End
        End

        Function_Return bVariableDeclaration
    End_Function

    Function _IsVariableInLine String sOverstrikeLine String sVariableName Returns Boolean
        Boolean bIsUseLine
        String sChar
        Integer iPos

        Move False to bIsUseLine                              
        Move (Lowercase(sOverStrikeLine)) to sOverStrikeLine
        Move (Lowercase(sVariableName))   to sVariableName

        If (sOverStrikeLine contains sVariableName) Begin
            Move (Pos(sVariableName, sOverStrikeLine)) to iPos
            If (iPos > 0) Begin
                Repeat
                    Move (Mid(sOverStrikeLine, 1, (iPos - 1))) to sChar
                    If (CS_ValidLeftCharacters contains sChar) Begin
                        Move True to bIsUseLine
                    End
                    If (bIsUseLine = False) Begin
                        Move (Replace(sVariableName, sOverStrikeLine, "")) to sOverStrikeLine
                        Move (Pos(sVariableName, sOverStrikeLine)) to iPos
                    End
                Until (bIsUseLine = True or iPos = 0)
            End
        End

        Function_Return bIsUseLine
    End_Function

    // ToDo: Needs to be revised
    Function _IsProjectObjectStructureLine String sOverstrikeLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine
        Integer iPos iSize
        String sLine sObjectName

        Move sOverstrikeLine to sLine
        Move (Trim(sLine)) to sLine
        Move True to bWriteLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Lowercase(sLine)) to sLine
            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
            If (bWriteLine = False) Begin
                Move (SizeOfArray(asObjectNames)) to iSize
                Move (Pos(" is a", sLine)) to iPos
                Move (Left(sLine, (iPos -1))) to sObjectName
                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
                Move (Trim(sObjectName)) to sObjectName
                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
            End
        End
        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
            Move False to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // Returns True iif the source line contains a "Repeat" statement.
    Function _IsRepeatStatement String sOverstrikeLine Returns Boolean
        Boolean bFound
        Get _HasCommand (&sOverstrikeLine) (" " + CS_Repeat) to bFound
        Function_Return bFound
    End_Function   
    
    Function _IsRegisterObjectInArray String sOverstrikeLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine bRegisterObjectStart
        Integer iPos
        
        Move False to bWriteLine                          
        Get _IsRegisterAllObjectsStart sOverstrikeLine to bRegisterObjectStart
        If (bRegisterObjectStart = False) Begin
            Move (Lowercase(sOverstrikeLine)) to sOverstrikeLine
            Move (Replace("register_object", sOverstrikeLine, "")) to sOverstrikeLine
            Move (Trim(sOverstrikeLine)) to sOverstrikeLine
            Move (SearchArray(sOverstrikeLine, asObjectNames)) to iPos
            Move (iPos = -1) to bWriteLine
        End

        Function_Return bWriteLine
    End_Function

    Function _IsStudioGeneratedComment String sLine String sComment Returns Boolean
        String sText
        
        Move sLine to sText      
        Move (Trim(sText)) to stext
        
        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
            Function_Return True 
        End
        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) Begin
            Function_Return True 
        End                 
        
        Function_Return False
    End_Function
    
    // Returns True iif the source line contains a "While" statement.
    Function _HasWhileStatement tTokenizer ByRef TokenizerData Returns Boolean
        Boolean bFound
        Get _HasCommand (&TokenizerData) (CS_While + " ") to bFound
        Function_Return bFound
    End_Function   
    
    Function _IsProjectObjectStructureStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
        Function_Return bFound
    End_Function

    Function _IsRegisterAllObjectsStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
        Function_Return bFound
    End_Function

    Function _IsRegisterAllObjectsEnd String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        String sFirstWord

        Move False to bFound
        Move (Lowercase(sLine)) to sLine
        Move (Trim(sLine)) to sLine
        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
            Move (Pos(" ", sLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sLine, (iPos -1))) to sFirstWord
                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
            End
        End
        Function_Return bFound
    End_Function

    Function _IsRegisterObjectLine String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        
        Move False to bFound
        Move (Pos(CS_RegisterObject, sLine)) to iPos
        If (iPos = 1) Begin
            Move True to bFound
        End
        Function_Return bFound
    End_Function

    // Tests if the lowercase character passed in sLine on position iPos is
    // a valid character for a class name
    Function _IsValidClassCharacter String sLine Integer iPos Returns Boolean
        Boolean bIsValid
        String  sChar
        Move False to bIsValid
        Move (Mid(sLine, 1, iPos)) to sChar
        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
            Move True to bIsValid
        End
        Function_Return bIsValid
    End_Function
      
    // (nicked from cSciLexer.pkg)
    // Sometimes a method has extra embedded spaces between its parameters. This can confuse the parameter counting.
    // We reduce the spaces here to just one.
    Function _StripConcatenatingSpaces String sLine Returns String
        While (Pos("  ", sLine) <> 0)
            Move (Replaces("  ", sLine, " ")) to sLine  // as doc says you can't reduce 3+ spaces to 1 without running a loop
        Loop    
        Function_Return sLine
    End_Function

    // Lowercases all values in the passed asArray, and then returns the changed array. 
    // This is to make it easier to find keywords kept in string array properties.
    Function _LowercaseArrayValues String[] asArray Returns String[]
        String sValue
        Integer iSize iCount
        Move (SizeOfArray(asArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asArray[iCount] to sValue
            Move (Lowercase(sValue)) to asArray[iCount]
        Loop
        Function_Return asArray
    End_Function
    
    // *** System (private) Messages ***
    //    
    Procedure AddCommand String sCommand
        String[] asCommands asCommandsLC

        Get pasCommands to asCommands   
        // Note: The value is lowercased.
        Move (Trim(Lowercase(sCommand))) to sCommand
        Move sCommand to asCommands[SizeOfArray(asCommands)]
        Set pasCommands   to asCommands
    End_Procedure

    Procedure AddCommandFunction String sCommand
        String[] asCommandFunctions

        Get pasCommandFunctions to asCommandFunctions
        Move (Trim(Lowercase(sCommand))) to sCommand
        Move sCommand to asCommandFunctions[SizeOfArray(asCommandFunctions)]
        Set pasCommandFunctions to asCommandFunctions
    End_Procedure

    // Removes any keyword from the pasCommands array that also exists
    // in the pasCommandFunctions array.
    Procedure RemoveFunctionsFromCommandsArray 
        String[] asCommands
        String[] asCommandFunctions
        String sFunction sDeleteItem sKeyword
        Integer iSize iCount iItem
        
        Get pasCommands to asCommands
        Get pasCommandFunctions to asCommandFunctions
        Move (SizeOfArray(asCommandFunctions)) to iSize
        Decrement iSize
        Move "ZZZZZ" to sDeleteItem 
        
        For iCount from 0 to iSize
            Move asCommandFunctions[iCount] to sFunction
            Move (SearchArray(sFunction, asCommands)) to iItem
            If (iItem <> -1) Begin
                Move sDeleteItem to asCommands[iItem]
            End
        Loop
        
        Move (SortArray(asCommands)) to asCommands
        Move (SearchArray(sDeleteItem, asCommands)) to iItem
        If (iItem <> -1) Begin
            Move (ResizeArray(asCommands, (iSize - (iSize - iItem)))) to asCommands
        End
        
        Set pasCommands to asCommands
    End_Procedure  
    
    // Sets the pasLocalVariableArrayTypes array property based on content
    // from a pasLocalVariableTypes array.
    // The pasLocalVariableTypes array contains variable declarations like; string, integer...
    // The pasLocalVariableArrayTypes will be filled wtih declarations like; string[], string[][], integer[], integer[][] etc.
    Procedure Set LocalVariableArrayTypes String[] asLocalVariableTypes
        Integer iSize iCount
        String[] asLocalVariableArrayTypes
        String sVariable
        
        Move (SizeOfArray(asLocalVariableTypes)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asLocalVariableTypes[iCount] to sVariable
            Append sVariable "[]" 
            Move sVariable to asLocalVariableArrayTypes[SizeOfArray(asLocalVariableArrayTypes)]
            Append sVariable "[]" 
            Move sVariable to asLocalVariableArrayTypes[SizeOfArray(asLocalVariableArrayTypes)]
        Loop
        Move (SortArray(asLocalVariableArrayTypes)) to asLocalVariableArrayTypes
        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes
    End_Procedure
    
    // This is called from End_Construct_Object and fills several keyword string array properties.
    Procedure AddAllKeyWords
        String[] Empty asScopeStart asScopeEnd asKeywords asOperators asCommands
        String[] asLocalVariableTypes asLocalVariableArrayTypes
        String sPath sFileName
        Integer iCh 
        tSCLanguage SCLanguage

        // Local variable declarations
        Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
        Get _LowercaseArrayValues asLocalVariableTypes to asLocalVariableTypes
        Move (SortArray(asLocalVariableTypes)) to asLocalVariableTypes
        Set pasLocalVariableTypes to asLocalVariableTypes
        Set LocalVariableArrayTypes to asLocalVariableTypes

        Get pSCLanguage of ghoApplication to SCLanguage

        // Scoped words
        Move SCLanguage.saScopeStart to asScopeStart
        Get _LowercaseArrayValues asScopeStart to asScopeStart
        Move (SortArray(asScopeStart)) to asScopeStart
        Set pasScopeStart to asScopeStart
        
        Move SCLanguage.saScopeStop to asScopeEnd
        Get _LowercaseArrayValues asScopeEnd to asScopeEnd
        Move (SortArray(asScopeEnd)) to asScopeEnd
        Set pasScopeEnd to asScopeEnd

        // Keywords
        Move SCLanguage.saKeywords to asKeywords
        Get _LowercaseArrayValues asKeywords to asKeywords
        Move (SortArray(asKeywords)) to asKeywords
        Set pasKeyWords to asKeywords
        
        // Operators
        Move SCLanguage.saOperators to asOperators
        Get _LowercaseArrayValues asOperators to asOperators
        Move (SortArray(asOperators)) to asOperators
        Set pasOperators to asOperators
        
        // ToDo: Not sure we need this array property any more, instead we could use the above arrays.
        //
        // Command list used for testing against inline if/else statements et. al.
        // Note that it is not a complete command list and that we should be careful
        // about commands that might be used as functions or in functions!
        // For example, it is by intention that none of the variable declaration commands
        // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
        //
        // Standalone commands can end on a end of line, such as Abort.
        // Other commands need more parameters and in such case we can improve our success rate
        // by adding a space character.
        //
        // Start by resetting array property to "blank", in case it was called before.
        Set pasCommands to Empty
        Send AddCommand "Abort"
        Send AddCommand "Abort_Transaction"
        Send AddCommand "Activate_View "
        Send AddCommand "Add "
        Send AddCommand "Address "
        Send AddCommand "Append "
        Send AddCommand "Append_Output "
        Send AddCommand "Ascii"
        Send AddCommand "Attach "
        Send AddCommand "Begin_Constraints"
        Send AddCommand "Begin_Transaction"
        Send AddCommand "Broadcast "
        Send AddCommand "Broadcast_Focus "
        Send AddCommand "Calc "
        Send AddCommand "Calculate "
        Send AddCommand "Call_Driver "
        Send AddCommand "CallStackDump "  
        Send AddCommand "Character"
        Send AddCommand "Case "
        Send AddCommand "Clear "
        Send AddCommand "Close "
        Send AddCommand "Close_Input"
        Send AddCommand "Close_Output"
        Send AddCommand "Constrain "
        Send AddCommand "Constrained_Clear "
        Send AddCommand "Constrained_Find "
        Send AddCommand "Constraint_Set"
        Send AddCommand "Constraint_Validate"
        Send AddCommand "Copy_db "
        Send AddCommand "Copy_Records "
        Send AddCommand "Copyfile "
        Send AddCommand "Create_Field "
        Send AddCommand "Create_Index "
        Send AddCommand "Declare_DataFile "
        Send AddCommand "Decrement "
        Send AddCommand "Delegate "
        Send AddCommand "Delete "
        Send AddCommand "Delete_db "
        Send AddCommand "Delete_Field "
        Send AddCommand "Delete_Index "
        Send AddCommand "Direct_Input "
        Send AddCommand "Direct_Output "
        Send AddCommand "DiskFree "
        Send AddCommand "EraseFile "
        Send AddCommand "Error "
        Send AddCommand "Field_Map "
        Send AddCommand "File_Exist "
        Send AddCommand "Fill_Field "
        Send AddCommand "Find "
        Send AddCommand "For "
        Send AddCommand "For_All "
        Send AddCommand "Forward "
        Send AddCommand "Function"
        Send AddCommand "Function_Return " // you might have code that does not return a value, I'd consider that a warning
        Send AddCommand "Get "
        Send AddCommand "Get_Argument_Size "
        Send AddCommand "Get_Attribute "
        Send AddCommand "Get_Channel_Position "
        Send AddCommand "Get_Channel_Size "
        Send AddCommand "Get_Current_Directory "
        Send AddCommand "Get_Current_Input_Channel "
        Send AddCommand "Get_Current_Output_Channel "
        Send AddCommand "Get_Current_User_Count "
        Send AddCommand "Get_Date_Attribute "
        Send AddCommand "Get_Directory "
        Send AddCommand "Get_Environment "
        Send AddCommand "Get_Field_Value "
        Send AddCommand "Get_FieldNumber "
        Send AddCommand "Get_File_Mod_Time "
        Send AddCommand "Get_File_Path "
        Send AddCommand "Get_FileNumber "
        Send AddCommand "Get_Licensed_Max_Users "
        Send AddCommand "Get_StrictEval "
        Send AddCommand "Get_Transaction_Retry "
        Send AddCommand "Get_Windows_Directory "
        Send AddCommand "GetAddress "
        Send AddCommand "GetBuff "
        Send AddCommand "GetBuff_String "
        Send AddCommand "GetDskInfo "
        Send AddCommand "Global_Variable "
        Send AddCommand "Gosub"
        Send AddCommand "Goto"
        Send AddCommand "GotoXY"
        Send AddCommand "Include_Resource "
        Send AddCommand "Include_Text"
        Send AddCommand "Increment "
        Send AddCommand "Indicate "
        Send AddCommand "Indicator "
        Send AddCommand "Input"
        Send AddCommand "Load_Def "
        Send AddCommand "Left"
        Send AddCommand "Length"
        Send AddCommand "Load_Driver "
        Send AddCommand "Lock"
        Send AddCommand "Login "
        Send AddCommand "Logout"
        Send AddCommand "Make_Directory "
        Send AddCommand "Make_File "
        Send AddCommand "Make_Temp_File "
        Send AddCommand "Mid"
        Send AddCommand "Move "
        Send AddCommand "Movedate "
        Send AddCommand "Moveint "
        Send AddCommand "Movenum "
        Send AddCommand "Movereal "
        Send AddCommand "Movestr "
        Send AddCommand "MoveVar"
        Send AddCommand "NewRecord "
        Send AddCommand "On_Item"
        Send AddCommand "On_key "
        Send AddCommand "Open "
        Send AddCommand "Output "
        Send AddCommand "Output_Aux_File "
        Send AddCommand "Output_Wrap"
        Send AddCommand "Pad"
        Send AddCommand "Pos"
        Send AddCommand "Playwave "
        Send AddCommand "Procedure"
        Send AddCommand "Procedure_Return"
        Send AddCommand "Property "
        Send AddCommand "Put "
        Send AddCommand "Read "
        Send AddCommand "Read_Block "
        Send AddCommand "Read_hex "
        Send AddCommand "Readln "
        Send AddCommand "Reg_Close_Key "
        Send AddCommand "Reg_Enum_Key "
        Send AddCommand "Reg_Enum_Key_Info "
        Send AddCommand "Reg_Enum_Value "
        Send AddCommand "Relate "
        Send AddCommand "Remove_Directory "
        Send AddCommand "Renamefile "
        Send AddCommand "Repeat"
        Send AddCommand "Replace"
        Send AddCommand "Report_Breaks "
        Send AddCommand "Reread"
        Send AddCommand "Right"
        Send AddCommand "RunProgram "
        Send AddCommand "Save "
        Send AddCommand "SaveRecord "
        Send AddCommand "Send "
        Send AddCommand "Set "
        Send AddCommand "Set_Argument_Size "
        Send AddCommand "Set_Attribute "
        Send AddCommand "Set_Channel_Position "
        Send AddCommand "Set_Date_Attribute "
        Send AddCommand "Set_Directory "
        Send AddCommand "Set_Field_Value "
        Send AddCommand "Set_File_Mod_Time "
        Send AddCommand "Set_Foreign_Profile_String "
        Send AddCommand "set_registry_root "
        Send AddCommand "Set_Relate "
        Send AddCommand "Set_StrictEval "
        Send AddCommand "Set_Transaction_Retry "
        Send AddCommand "Shift_State "
        Send AddCommand "Show "
        Send AddCommand "Showln"
        Send AddCommand "Sleep "
        Send AddCommand "Sort "
        Send AddCommand "Start_UI"
        Send AddCommand "Structure_Abort "
        Send AddCommand "Structure_Copy "
        Send AddCommand "Structure_End "
        Send AddCommand "Structure_Start "
        Send AddCommand "Subtract "
        Send AddCommand "Sysdate "
        Send AddCommand "Sysdate4 "
        Send AddCommand "Trim"
        Send AddCommand "Unload_Driver "
        Send AddCommand "Unlock"   
        Send AddCommand "Until"
        Send AddCommand "Uppercase"
        Send AddCommand "Valid_Drive "
        Send AddCommand "ValueTreeDeserializeParameter "
        Send AddCommand "ValueTreeSerializeParameter "
        Send AddCommand "VConstrain "
        Send AddCommand "Version_Information "
        Send AddCommand "VFind "
        Send AddCommand "Virtual_Key "
        Send AddCommand "WebGet "
        Send AddCommand "WebPublishFunction "
        Send AddCommand "WebPublishProcedure "
        Send AddCommand "WebSet "
        Send AddCommand "WebSetResponsive "
        Send AddCommand "While "
        Send AddCommand "Write "
        Send AddCommand "Write_Hex "
        Send AddCommand "WriteLn"
        Send AddCommand "ZeroFile "
        Send AddCommand "ZeroString "
        Send AddCommand "ZeroType "
        
        Get pasCommands to asCommands
        Move (SortArray(asCommands)) to asCommands
        Set pasCommands to asCommands 
        
        // ToDo: Not sure if we should remove the functions from the commands array;
        //Send RemoveFunctionsFromCommandsArray
    End_Procedure

    // Commands that also exists as DataFlex functions;
    Procedure AddAllCommandFunctions
        String[] Empty

        Set pasCommandFunctions to Empty

        Send AddCommandFunction "Append"
        Send AddCommandFunction "Ascii"
        Send AddCommandFunction "Character"
        Send AddCommandFunction "Else"  
        Send AddCommandFunction "If"
        Send AddCommandFunction "Insert"
        Send AddCommandFunction "Left"
        Send AddCommandFunction "Length"
        Send AddCommandFunction "Mid"  
        Send AddCommandFunction "Pad"
        Send AddCommandFunction "Pos"
        Send AddCommandFunction "Repeat"  
        Send AddCommandFunction "Replace"
        Send AddCommandFunction "Right"
        Send AddCommandFunction "Trim"
        Send AddCommandFunction "Uppercase"
    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        Send AddAllCommandFunctions
        Send AddAllKeyWords     
        // Although this is done automatically here,
        // it should also be send before each refactoring starts,
        // in case e.g. the tab-size has been changed.
        // This has been put here for the DFUnit_Testrunner.
        Send InitializeInterface
    End_Procedure        
    
    Procedure InitTabSize
        Integer iID iTabSize
        
        Move FunctionsA.ID to iID
        Clear FunctionsA
        Move CS_EditorReIndent to FunctionsA.Function_Name
        Find eq FunctionsA by Index.5
        If (Found = False) Begin
            Error ("Could not find function:" * CS_EditorReIndent +"\nin the 'Functions' table. It is used for setting the tab-size. Cannot continue.")
            Abort
        End
        Move (Trim(FunctionsA.Parameter)) to iTabSize
        // Reset record buffert:
        If (iID <> 0) Begin
            Move iID to FunctionsA.ID
            Find Eq FunctionsA by Index.1
        End
        Set piTabSize to iTabSize
    End_Procedure
    
    Procedure SaveErrorState
        Set piLastErr to LastErr
        If (Err = True) Begin
            Set pbErr to True
        End
        Else Begin
            Set pbErr to False
        End   
        Move False to Err
        Move 0 to LastErr
    End_Procedure
    
    Procedure RestoreErrorState
        Get piLastErr to LastErr
        If (pbErr(Self)) Begin
            Move True to Err
        End
        Else Begin
            Move False to Err
        End
    End_Procedure    
    
    // Must be send before the refactoring process is started
    // It initializes necessary parameters.
    Procedure InitializeInterface
        Send SaveErrorState
        Send InitTabSize
    End_Procedure
    
    Procedure ResetProjectObjectStructureProperties
        String[] asObjectNames
        Set pbProjectObjectStructureStart to False 
        Set pbProjectObjectStructureEnd   to False
        Set pbRegisterAllObjectsStart     to False    
        Set pbRegisterAllObjectsEnd       to False
        Set pasObjectNames                to asObjectNames
    End_Procedure

//    Procedure AddEditorCommands String[] asKeyWords
//        String[] asCommandFunctions
//        String sFunction sDeleteItem sKeyword
//        Integer iSize iCount iItem
//        
//        Move "ZZZZZ" to sDeleteItem
//        // Start by lowercasing all asKeyWords values.
//        // We do that so it is easier to find and match keywords/commands.
//        Get _LowercaseArrayValues asKeyWords to asKeyWords       
//               
//        Get pasCommandFunctions to asCommandFunctions
//        Move (SizeOfArray(asCommandFunctions)) to iSize
//        Decrement iSize
//        for iCount from 0 to iSize
//            Move asCommandFunctions[iCount] to sFunction
//            Move (SearchArray(sFunction, asKeyWords)) to iItem
//            If (iItem <> -1) Begin
//                Move sDeleteItem to asKeyWords[iItem]
//            End
//        Loop
//        Move (SortArray(asKeywords)) to asKeywords
//        Move (SearchArray(sDeleteItem, asKeyWords)) to iItem
//        If (iItem <> -1) Begin
//            Move (ResizeArray(asKeyWords, (iSize - (iSize - iItem)))) to asKeyWords
//        End
//        
//        Set pasKeyWords to asKeywords
//    End_Procedure  
    
    // *** Other low level functions ***
    //
    //     These functions are commented out for now, but if any of them is needed, just un-comment.
    // Splits a line to a string array.
    // Ignores any special characters, spaces or new line, CR "multi line"

    // Returns True if the "sCheckFieldName" field exists in the passed iFile datbase table.
    // If it doesn't exist, False is returned
//    Function _IsFieldExisting Integer iFile String sCheckFieldName Returns Boolean
//        Integer iNumFields iCount                                      
//        String sFieldName
//      
//        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
//        Decrement iNumFields
//        For iCount from 0 to iNumFields  
//            Get_Attribute DF_FIELD_NAME of iFile iCount to sFieldName        
//            If ((Uppercase (sFieldName)) = (Uppercase (sCheckFieldName))) Begin
//                Function_Return True
//            End
//        Loop
//      
//        Function_Return False
//    End_Function
//
//    Function _SplitTextByLengthPure String sText Integer iCount Returns String[]
//        String sLine
//        String[] saText
//    
//        Move sText to sLine
//    
//        While (Length(sLine) > 0)
//            Move (Mid(sLine, iCount, 1)) to saText[(SizeOfArray(saText))]
//            Move (Mid(sLine, (Length(sLine) - iCount), (iCount + 1))) to sLine
//        Loop
//    
//        Function_Return saText
//    End_Function
//
//    // Splits a string to a string array.
//    Function _Split String sSplitKey String sText Returns String[]
//        String[] sArray
//        Integer iLeftPos
//        Boolean bAtLeastOneSplit
//    
//        Move (ResizeArray(sArray, 0)) to sArray
//        If ((sSplitKey = "") and ((Length(sSplitKey)) = 0)) Begin
//            For iLeftPos from 1 to ((Length(sText)))
//                Move (Mid(sText, 1, iLeftPos)) to sArray[SizeOfArray(sArray)]
//            Loop
//        End
//        Else Begin
//            Move (Pos(sSplitKey, sText)) to iLeftPos
//    
//            While (iLeftPos > 0)
//                Move True to bAtLeastOneSplit
//                Move (Left(sText, iLeftPos - 1)) to sArray[SizeOfArray(sArray)]
//                Move (Right(sText, ((Length(sText) - (iLeftPos + (Length(sSplitKey))) )+1))) to sText
//                Move (Pos(sSplitKey, sText)) to iLeftPos
//            Loop
//    
//            // Include text to the right of the last split character.
//            Move sText to sArray[SizeOfArray(sArray)]
//        End
//    
//        Function_Return sArray
//    End_Function
//
//    // Creates a string by joining array elements using a separator (e.g. ",")
//    Function _JoinArray Global String[] saValues String sSeparator Returns String
//        Integer i iLength
//        String sRet
//        Move "" to sRet
//        Move (SizeOfArray(saValues)-1) to iLength
//        For i from 0 to iLength
//            // First element
//            If (i = 0) Begin
//                Append sRet saValues[i]
//            End
//            // Other elements
//            Else Begin
//                Append sRet sSeparator saValues[i]
//            End
//        Loop
//        Function_Return sRet
//    End_Function
//
//    // Convert Integer to a binary value
//    // Courtesy of Frank Cheng.
//    Function _IntToBinary Global Integer i Returns String
//        String sResult
//        If (i < 0) Function_Return ""
//        Move "" to sResult
//        Repeat
//            Move (String(Mod(i, 2)) + sResult) to sResult
//            Move (i / 2) to i
//        Until (i = 0)
//        Function_Return sResult
//    End_Function
//
//    // Courtesy of Frank Cheng.
//    // There is another verion (HexToInt) in mStrConv.pkg
//    Function _HexToInt2 Global String sNum Returns Integer
//        Integer iLength iDigit iNum iPower
//        Move (Length(sNum)) to iLength
//        Move 1 to iPower
//        Move 0 to iNum
//        While (iLength > 0)
//            Move (Ascii(Mid(sNum,1,iLength))) to iDigit
//            Subtract (If(iDigit > 57, 55, 48)) from iDigit
//            Add (iDigit * iPower) to iNum
//            Move (iPower * 16) to iPower
//            Decrement iLength
//        Loop
//        Function_Return iNum
//    End_Function
//
//    // Curtesy of Evertjan Dondergoor DAE
//    Function _SQLDateTimeToDFDateTime String s Returns DateTime
//        DateTime dt
//        Integer iYear iMonth iDay
//        Integer iHour iMinute iSecond
//
//        Move (Mid(s, 4,  1)) to iYear
//        Move (Mid(s, 2,  6)) to iMonth
//        Move (Mid(s, 2,  9)) to iDay
//        Move (Mid(s, 2, 12)) to iHour
//        Move (Mid(s, 2, 15)) to iMinute
//        Move (Mid(s, 2, 18)) to iSecond
//
//        Move (DateSetYear  (dt, iYear  )) to dt
//        Move (DateSetMonth (dt, iMonth )) to dt
//        Move (DateSetDay   (dt, iDay   )) to dt
//        Move (DateSetHour  (dt, iHour  )) to dt
//        Move (DateSetMinute(dt, iMinute)) to dt
//        Move (DateSetSecond(dt, iSecond)) to dt
//
//        Function_Return dt
//    End_Function
//
//    Function _IntToHex Number iInput Returns String 
//        String sOutput
//        Boolean bNegative
//        UChar[] ucData
//        Integer iRemain
//        
//        If (iInput < 0) Begin
//            Move (iInput * -1) to iInput
//            Move True to bNegative
//        End
//        While (iInput >= 16)
//            Move (Mod (iInput, 16)) to iRemain
//            Move (iInput / 16)        to iInput
//            If (iRemain < 10) Begin
//                Move (Cast (48 + iRemain, UChar)) to ucData[SizeOfArray(ucData)]
//            End
//            Else Begin
//                Move (Cast (65 + iRemain - 10, UChar)) to ucData[SizeOfArray(ucData)]
//            End
//        Loop
//        If (iInput < 10) Begin
//            Move (Cast (48 + iInput, UChar)) to ucData[SizeOfArray(ucData)]
//        End
//        Else Begin
//            Move (Cast (65 + iInput - 10, UChar)) to ucData[SizeOfArray(ucData)]
//        End
//        Move (ReverseArray(ucData)) to ucData
//        If (bNegative) Begin
//            Move (sOutput + "-" + UCharArrayToString (ucData)) to sOutput
//        End
//        Else Begin
//            Move (sOutput + UCharArrayToString (ucData)) to sOutput
//        End
//        Function_Return sOutput
//    End_Function
        
End_Class
