// Copyright (c) 2018 Nils Svedmyr, RDC Tools International
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to Do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in All
// copies or substantial portions of the Software.
//
// THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
// IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
// FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
// LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
// OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
// SOFTWARE.

Use cBaseFuncLib.pkg

Class cRefactorFuncLib is a cBaseFuncLib
    Procedure Construct_Object
        Forward Send Construct_Object
    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
    End_Procedure

    // *** External function package(s) must be included here. ***
    // Use this to add your own special function package(s).
// Define CS_Use_MyPackage for "UseMyPackage"
    #IFDEF CS_Use_MyPackage
//        #Include MyRefactorFunctions.pkg
    #ENDIF

    // *** Important ***
    // This *must* be called *once* per source line, *before* any refactor function is called.
    // It calls the Tokenizer function and sets the class property pTokenizer that is to be
    // used by refactor functions!
    Procedure InitializeTokenizer String sLine
        tTokenizer TokenizerData
        // Note: This function call also sets the pTokenizer property.
        Get Tokenizer sLine to TokenizerData
    End_Procedure

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
    // This would compile but not work well with the ChangeCalcToMoveStatement function.
    Function ChangeCalcToMoveStatement String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound bIsCommentOrBlank
        String sTest sStart sStop sOverStrikeLine
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady or TokenizerData.bIsInCommand or TokenizerData.bIsInImage or TokenizerData.bIsVariableDeclaration) Begin
            Function_Return False
        End

        // Check if line contains one of the keywords and that none of the keywords are within quotes.
        Get _IsKeywordInLine "calc|moveint|movenum|movereal|movestr" TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        Move (Lowercase(sLine)) to sTest
        Move False to bChanged

        Case Begin
            Case (Pos("calc ", sTest))
                Move (Pos("calc ", sTest))            to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("moveint ", sTest))
                Move (Pos("moveint ", sTest))         to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movenum ", sTest))
                Move (Pos("movenum ", sTest))         to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movereal ", sTest))
                Move (Pos("movereal ", sTest))        to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movestr ", sTest))
                If (Lowercase(TokenizerData.FirstLeftCommand.sCode) <> Lowercase(CS_Move)) Begin
                    Move (Pos("movestr ", sTest))         to iPos
                    Move (Left(sLine, (iPos -1))) to sStart
                    Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                    Move (sStart + CS_Move + sStop)       to sLine
                    Move True                             to bChanged
                End
                Case Break
        Case End
        
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "Current_Object" to "Self"
    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
        String sStart sStop
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos = 0) Begin
            Function_Return False
        End

        Get _ReplaceLineToken TokenizerData sLine CS_Current_Object CS_Self to sLine
        // Note! We call ourself recursively if there are more than one "current_object".
        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos <> 0) Begin
            Get ChangeCurrent_ObjectToSelf (&sLine) "" to bFound
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sNewBoolean
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData

        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get _IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Move (Trim(sLine)) to sLine
        Repeat
            Move CS_True to sNewBoolean
            Move (Pos(Lowercase(CS_DfTrue), Lowercase(TokenizerData.sOverstrikeLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos(Lowercase(CS_DfFalse), Lowercase(TokenizerData.sOverstrikeLine))) to iPos
                Move CS_False to sNewBoolean
            End
            If (iPos <> 0) Begin
                Move (Overstrike("||" + sNewBoolean, sLine, iPos)) to sLine
                Move (Replace("||", sLine, "")) to sLine
                Move (Overstrike("||" + sNewBoolean, TokenizerData.sOverstrikeLine, iPos)) to TokenizerData.sOverstrikeLine
                Move (Replace("||", TokenizerData.sOverstrikeLine, "")) to TokenizerData.sOverstrikeLine
            End
        Until (iPos = 0)
        
        Move (TokenizerData.sIndentation + String(sLine)) to sLine
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
    // For the function to do anything, the line needs to contain a "GetAddress" command.
    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sText sToVar sOfVar sCommand
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText

        If (TokenizerData.bLineIsReady or TokenizerData.bHasEndSemiColon or TokenizerData.bIsInFunction or ;
            TokenizerData.bIsInProcedure = True ) Begin
            Function_Return False
        End

        Get _IsKeywordInLine (CS_GetAddress + "|") TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode)) to sLine
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: 'Insert "," In sText At 2' --> 'Move (Insert(",", sText, 2)) to sText'
    //          ' If sOne Eq "A" Insert "B" in sOne at 2' --> ' If sOne Eq "A" Move (Insert("B", sOne, 2)) to sOne'
    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentOrBlank bIsReplace bFound
        String sNose sTail sLineLC sToken sVar1 sVar2 sText //sStart sStop sVariableName sPlace sChar sLineLC
        Integer iPos iItem iInPos
        tTokenizer TokenizerData
        
        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True) Begin
            Function_Return False
        End 
        
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End
        
        Move (Trim(sLine)) to sLine
        
        Move "" to sNose       
        Move (Lowercase(sLine)) to sLineLC
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        // If anything left of the CS_Insert command, save it in "sNose" (start string)
        If (iItem > 0) Begin
            Move (Pos(Lowercase(CS_Insert), sLineLC)) to iPos
            Move (Left(sLine, (iPos -1))) to sNose
            Move (Replace(sNose, sLine, "")) to sLine
        End
        
        // Remove the CS_Insert command
        Move TokenizerData.asLineTokens[iItem] to sToken
        Move (Replace(sToken, sLine, "")) to sLine
        // Get the first variable
        Move TokenizerData.asLineTokens[iItem + 1] to sVar1
        // Check if this is a string constant, in case the array value contains underscores only.
        Get _IsStringArrayConstant sVar1 to bFound
        If (bFound = True) Begin
            Get _ExtractFirstStringConstant sLine to sVar1    
        End

        // Find and remove the "IN" keyword.
        Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sToken
            Move (Replace(sToken, sLine, "")) to sLine
            Move TokenizerData.asLineTokens[iItem + 1] to sVar2
            Get _IsStringArrayConstant sVar2 to bFound
            If (bFound = True) Begin
                Get _ExtractFirstStringConstant sLine to sVar2    
            End
        End

        // Find and remove the "AT" keyword, and save the next parameter which is the position to insert at.
        Move (SearchArray(CS_At, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sToken
            Move (Replace(sToken, sLine, "")) to sLine
            Move TokenizerData.asLineTokens[iItem + 1] to iInPos
        End
        
        Move "" to sText
        If (sNose <> "") Begin
            Move sNose to sText
            Move (Trim(sText) + " ") to sText    
        End
        Append sText CS_Move " " "(" CS_Insert "(" sVar1 "," sVar2 "," iInPos "))" " " CS_To " " sVar2

        Move (TokenizerData.sIndentation + String(sText)) to sLine
        If (TokenizerData.sEndComment <> "") Begin
            Append sLine TokenizerData.sEndComment
        End
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces 'IN' with 'Contains, it also swaps places for the two variables involved and addes paranthesis.
    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
        String sOrg sPattern sMatched sRemain sHost sSub sText
        tRegexMatch[] myReg
        Integer iPos iItem
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End  
        Move (SearchArray(CS_With, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End  
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End  
        Move (SearchArray(CS_Pos, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End  
        
        Move sLine to sOrg
        Move sLine to sText
        Move (Replaces('`', '(".*"|`.*`|\S+)\s+in\s+(".*"|`.*`|\S+)', "'")) to sPattern
        Get Regex_Match sText sPattern True to myReg
        If (SizeOfArray(myReg)) Begin
            Move myReg[0].Val to sMatched
            Move (Replaces('`', '(".*"|`.*`|\S+)\s+', "'")) to sPattern
            Get Regex_Match sMatched sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sSub
            Move (Trim(Replace(sSub, sMatched, ''))) to sRemain // Remove the subString
            Move (Remove(sRemain,0 ,2)) to sRemain // Remove the 'In'
            Move (Replaces('`', '\s+(".*"|`.*`|\S+)', "'")) to sPattern
            Get Regex_Match sRemain sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sHost
            Move (Replace(sMatched, sText, ("(" + sHost + ' contains ' + sSub + ")"))) to sLine
        End
        
        Function_Return (sLine <> sOrg)
    End_Function

    // This is a *private* helper function for the ChangeLegacyIndicators function.
    //
    // It only acts on a sOverStikeLine that starts with an indicator e.g. "[Found]"
    // '[Found] Reread // End comment'  
    // '[Found] Repeat // End comment'  
    // '[not Found] While // End comment' 
    // '[not Seqeof] Repeat // End comment'
    // '[Not Found]   Reread'                  
    // '[Not Found] Move iA to iB // End comment'  
    // '[Found] Loop // End comment' 
    // '[not Seqeof] Loop // End comment'  
    // '[Select] Indicate Select as WindowIndex Eq FieldIndex'
    // '[Found] Delete hTable'        
    // '[Found] If (iA <> iB) Move False to Found'
    {Visibility = Private}
    Function ChangeLegacyIndicators_Sub tTokenizer TokenizerData String sOverStrikeLine Boolean ByRef bChanged Returns String  
        String sToken sLine sMove sIf sTo sFirstCmd sSecondCmd sFirstBoolean sSecondBoolean sToBoolean
        Integer iItem iSize iCount
        Boolean bHasIf bHasMove bHasTo bIndicateCmd
        
        Move TokenizerData.asLineTokens[iItem] to sToken
        If (Left(sToken, 1) <> "[") Begin
            Function_Return sOverStrikeLine
        End
        
        // Has If-statement?     
        Move (TokenizerData.bHasIfCommand = True) to bHasIf
        If (bHasIf = True) Begin
            Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move TokenizerData.asLineTokens[iItem] to sIf
            End
        End
        Else Begin
            Move CS_If to sIf
        End
        
        // Has an "Indicate" command?   
        Move TokenizerData.BooleanIndicator.bHasIndicateCommand to bIndicateCmd
        
        // Has Move-statement?
        Move (SearchArray(CS_Move, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sMove
        End
        Else Begin
            Move CS_Move to sMove
        End    
        Move (iItem <> -1) to bHasMove
        
        // Has To-statement?
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sTo
        End
        Else Begin
            Move CS_To to sTo
        End
        Move (iItem <> -1) to bHasTo

        Move TokenizerData.FirstLeftCommand.sCode  to sFirstCmd
        Move TokenizerData.SecondLeftCommand.sCode to sSecondCmd
        Move TokenizerData.BooleanIndicator.FirstBoolean.sCode  to sFirstBoolean
        Move 0 to iItem
        
        // Take care of the part before the "to" keyword:
        Case Begin
            Case (Lowercase(sFirstCmd) = Lowercase(CS_Indicate))   
                If (TokenizerData.BooleanIndicator.FirstBoolean.bHasBracket = True) Begin
                    Move (sIf * String(TokenizerData.BooleanIndicator.FirstBoolean.sCode) * String(sMove)) to sOverStrikeLine
                End
                Else Begin
                    Move sMove to sOverStrikeLine
                End
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                   Move TokenizerData.BooleanIndicator.AsBoolean.sCode to sToken
                End
                Else Begin
                    Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                End
                Append sOverStrikeLine " " sToken
                Case Break
        
            Case (Lowercase(sFirstCmd) = Lowercase(CS_If))
                Case Break
        
            Case (Lowercase(sFirstCmd) = Lowercase(CS_Move))
                Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                Move (sIf * String(sToken) * String(sMove)) to sOverstrikeLine   
                Append sOverStrikeLine " " TokenizerData.BooleanIndicator.SecondBoolean.sCode
                Case Break
        
            Case (Lowercase(sFirstCmd) = Lowercase(CS_Repeat))
                If (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "") Begin
                    Move CS_While to sOverStrikeLine
                    Append sOverStrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End                                                                       
                Else Begin
                    Move sFirstCmd to sOverStrikeLine
                End
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_While))
                Move sFirstCmd to sOverStrikeLine
                If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                    Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                End
                Else Begin
                    Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                End                                                                       
                Append sOverStrikeLine " " sToken
                Case Break

            Case (Lowercase(sFirstCmd) = Lowercase(CS_Until) or Lowercase(sFirstCmd) = Lowercase(CS_Loop))
                Move sFirstCmd to sOverstrikeLine           
                If (Lowercase(sFirstCmd) = Lowercase(CS_Until)) Begin 
                    If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                        Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                    End                                                                  
                    Else Begin
                        Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                    End
                    Append sOverStrikeLine " " sToken
                End
                Case Break

            Case (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "")
                Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
                Decrement iSize  
                Move CS_If to sOverstrikeLine
                If (TokenizerData.BooleanIndicator.FirstBoolean.bDoubleBoolean = True) Begin
                    Get _ConstructDoubleBooleanExpression TokenizerData to sToken
                    Append sOverStrikeLine " " sToken
                    Move 0 to iSize
                End
                Else Begin
                    Append sOverStrikeLine " " sFirstBoolean
                End
                Append sOverstrikeLine " " sFirstCmd        
                Move 1 to iItem 
                If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
                    Increment iItem
                End
                If (iSize > iItem) Begin
                    Increment iItem
                    While (iItem <= iSize)
                        Move TokenizerData.asLineTokens[iItem] to sToken
                        If (Trim(sToken) <> "") Begin
                            Append sOverstrikeLine " " sToken
                        End
                        Increment iItem    
                    Loop
                End
                Case Break
            
            Case Else
            
        Case End
        
        // "To" part:
        If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
            Append sOverStrikeLine " " sTo
            Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
            Get _ReplaceParanthesis sToken to sToken
            Append sOverStrikeLine " " sToken
        End
        Else If (TokenizerData.BooleanIndicator.ToBoolean.sCode <> "") Begin
            Append sOverStrikeLine " " sTo
            Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
            Get _ReplaceParanthesis sToken to sToken
            Append sOverStrikeLine " " sToken
        End
//        Else If (Lowercase(sFirstCmd) <> Lowercase(CS_Repeat) and Lowercase(sFirstCmd) <> Lowercase(CS_While) and Lowercase(sFirstCmd) <> Lowercase(CS_Loop) and Lowercase(sFirstCmd) <> Lowercase(CS_Until)) Begin
//        End    
        
        Function_Return sOverStrikeLine
    End_Function
        
    // *** LINE-BY-LINE FUNCTION ***
    // Changes legacy: Indicate Found as True" --> Move True to Found
    //                 [Select] Indicate Select as Windowindex Eq Fieldindex --> Move (WindowInex = FieldIndex) to Select
    //                 [Found] and [FindErr] indicator statements.
    //                 [Found| Command -> e.g. If Found Command
    //                 While [Not Found]   -> e.g. While (Not(Found))
    //                 [Found|Not Found|FindErr|Not FindErr] While   -> e.g. While (Not(Found))  
    //                 [Found] Indicate Found as Invoice.CustNum eq Customer.Number -> If (Found) Move (Invoice.CustNum eq Customer.Number) to Found
    //                 If [Not Found] Reread hTable -> If (Not(Found)) Reread hTable     
    //                 [~Found] begin -> If (Not(Found)) Begin     
    //                 [Found ~Found] Begin -> If (Found and Not(Found)) Begin
    // *Known limitation*:
    //   It can handle max two booleans within the same square bracket. E.g. "[Found Select]"
    Function ChangeLegacyIndicators String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bStartBracket bHasBracket bIndicateStart bIfStart
        String sToken sOverstrikeLine sNot sTo sMove sAs sIf sFirstCmd sSecondCmd sCommand
        Integer iPos iItem
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True or TokenizerData.bIsInImage = True) Begin
            Function_Return False
        End   
        Get _HasBracket TokenizerData.BooleanIndicator to bHasBracket
        If (TokenizerData.BooleanIndicator.bHasIndicateCommand = False and bHasBracket = False) Begin
            Function_Return False
        End   
        
        If (Lowercase(sLine) contains (Lowercase(CS_Find) + " ") or ;
            Lowercase(sLine) contains (Lowercase(CS_Send) + " ") or ;
            Lowercase(sLine) contains (Lowercase(CS_Constrain) + " ")) Begin
            Function_Return False
        End

        // Has If-statement?     
        Move (TokenizerData.bHasIfCommand = True) to bIfStart
        If (bIfStart = True) Begin
            Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move TokenizerData.asLineTokens[iItem] to sIf
            End
        End
        Else Begin
            Move CS_If to sIf
        End
        
        // Has Move-statement?
        Move (SearchArray(CS_Move, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sMove
        End
        Else Begin
            Move CS_Move to sMove
        End
        Move TokenizerData.FirstLeftCommand.sCode  to sFirstCmd
        Move TokenizerData.SecondLeftCommand.sCode to sSecondCmd
        
        // Has To-statement?
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sTo
        End
        Else Begin
            Move CS_To to sTo
        End
        
        Move 0 to iItem
        Move TokenizerData.asLineTokens[iItem] to sToken
        // Starts with a indicator bracket?
        Move (Left(sToken, 1) = "[") to bStartBracket
        
        // Get the "Not" keyword:
        If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot  = True or ;
            TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True or ;
            TokenizerData.BooleanIndicator.ToBoolean.bHasNot     = True or ;
            TokenizerData.BooleanIndicator.AsBoolean.bHasNot     = True) Begin
            Move (SearchArray("[not", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Get _ReplaceBrackets TokenizerData.asLineTokens[iItem] to sNot
            End
        End

        // Has an "Indicate" command?
        Move (SearchArray(CS_Indicate, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        Move (iItem <> -1) to bIndicateStart
        
        // Add "Not" operator and add paranthesis to boolean expressions/variables;
        If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + "))") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
        End
        Else If (Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + ")") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.SecondBoolean.sCode + "))") to TokenizerData.BooleanIndicator.SecondBoolean.sCode
        End
        Else If (Left(TokenizerData.BooleanIndicator.SecondBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.SecondBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.SecondBoolean.sCode + ")") to TokenizerData.BooleanIndicator.SecondBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.ToBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.ToBoolean.sCode + "))") to TokenizerData.BooleanIndicator.ToBoolean.sCode
        End
        If (Left(TokenizerData.BooleanIndicator.ToBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.ToBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.ToBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.ToBoolean.sCode + ")") to TokenizerData.BooleanIndicator.ToBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.AsBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.AsBoolean.sCode + "))") to TokenizerData.BooleanIndicator.AsBoolean.sCode
        End
        If (Left(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.AsBoolean.sCode + ")") to TokenizerData.BooleanIndicator.AsBoolean.sCode
            End
        End

        Case Begin         
            
            // 'If [False] Indicate Select as Windowindex Eq Fieldindex // Comment' 
            // 'If [not found] Move (Windowindex Eq Fieldindex) to Select // Comment'
            Case (bIfStart = True)
                Move sIf to sOverstrikeLine
                Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                    Append sOverstrikeLine " " sMove " " TokenizerData.BooleanIndicator.AsBoolean.sCode
                    Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                    Get _ReplaceParanthesis sToken to sToken
                    Append sOverstrikeLine " " sTo   " " sToken
                End
                Else Begin
                    Append sOverstrikeLine " " sMove " " TokenizerData.BooleanIndicator.SecondBoolean.sCode
                    Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
                    Get _ReplaceParanthesis sToken to sToken
                    Append sOverstrikeLine " " sTo   " " sToken
                End
                Case Break

            // This gets even messier, so it was broken out to a helper-function (sub):
            Case (bStartBracket = True)
                Get ChangeLegacyIndicators_Sub TokenizerData TokenizerData.sOverstrikeLine (&bChanged) to sOverstrikeLine
                Case Break

            // 'Indicate Found as True'  
            // 'Indicate [Found] as True' 
            // 'Indicate Select as Windowindex Eq Fieldindex // Comment'
            Case (bIndicateStart = True) 
                Move CS_Move to sOverstrikeLine
                If (Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) = "(") Begin  
                    Get _ReplaceParanthesis TokenizerData.BooleanIndicator.FirstBoolean.sCode to TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                If (Left(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> "(") Begin
                    Move ("(" + TokenizerData.BooleanIndicator.AsBoolean.sCode +")") to TokenizerData.BooleanIndicator.AsBoolean.sCode
                End
                Append sOverstrikeLine " " TokenizerData.BooleanIndicator.AsBoolean.sCode " " CS_To " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                Case Break

            // Starts with any other than: "If", "Indicate" or a square bracket indicator as e.g. "[Not Found]". I.e. another command.
            Case Else
                // Do we have a e.g. "While [Not Found]" construct?
                If (Pos(sFirstCmd, TokenizerData.sOverstrikeLine) < Pos("[", TokenizerData.sOverstrikeLine)) Begin
                    Move sFirstCmd to sOverstrikeLine    
                    Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                Else Begin                 
                    Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
                    If (sToken = "") Begin
                        Move TokenizerData.BooleanIndicator.AsBoolean.sCode to sToken
                    End
                    Move (CS_Move * String(sToken)) to sOverstrikeLine
                    If (SearchArray(sTo, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP)) <> -1) Begin
                        Append sOverstrikeLine " " sTo " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                    End
                    Else Begin
                        Move TokenizerData.asLineTokens[(SizeOfArray(TokenizerData.asLineTokens) -1)] to sToken
                        Move (SearchArray(CS_As, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                        If (iItem <> -1) Begin
                            Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                            Append sOverstrikeLine " " sTo " " sToken
                        End
                        Else Begin
                            Append sOverstrikeLine " " sToken
                        End
                    End
                End
        Case End

        Move (TokenizerData.sIndentation + sOverstrikeLine) to sOverstrikeLine
        If (TokenizerData.sEndComment <> "") Begin
            Append sOverstrikeLine " " TokenizerData.sEndComment
        End
        Move sOverstrikeLine to sLine
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>" for If-Begin lines and While statements.
    // Pass only the code part of a source line.
    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
        String sExpression sOrg  sExpressionNo sNose sTail
        Boolean bFound bChanged
        Integer iPos iLength iItem
        tTokenizer TokenizerData
        tOperatorsInfo OperatorInfo

        Get pTokenizer to TokenizerData    
        If (TokenizerData.OperatorsInfo.bIsLegacy = False) Begin
            Function_Return False
        End   
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Find) or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Find)) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Constrain, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End   
        
        Move (Ltrim(sLine)) to sLine 
        Get _StripConcatenatingSpaces sLine to sLine
        Move sLine to sOrg

        Move TokenizerData.sLeftExpression1 to sExpression
        Get _HasTokenParanthesis sExpression to bFound
        If (bFound = True) Begin 
            Get _ReplaceParanthesis sExpression to sExpressionNo
            Move (Replace(sExpressionNo, sLine, sExpression)) to sLine
        End
            
        Move TokenizerData.sLeftExpression2 to sExpression
        Get _HasTokenParanthesis sExpression to bFound
        If (bFound = True) Begin
            Get _ReplaceParanthesis sExpression to sExpressionNo
            Move (Replace(sExpressionNo, sLine, sExpression)) to sLine
        End

        Move TokenizerData.sOfExpression to sExpression
        Get _HasTokenParanthesis sExpression to bFound
        If (bFound = True) Begin
            Get _ReplaceParanthesis sExpression to sExpressionNo
            Move (Replace(sExpressionNo, sLine, sExpression)) to sLine
        End

        Move TokenizerData.sToExpression to sExpression
        Get _HasTokenParanthesis sExpression to bFound
        If (bFound = True) Begin
            Get _ReplaceParanthesis sExpression to sExpressionNo
            Move (Replace(sExpressionNo, sLine, sExpression)) to sLine
        End
        
        Get _ReplaceLegacyOperators sLine "gt" ">"  to sLine
        Get _ReplaceLegacyOperators sLine "ge" ">=" to sLine
        Get _ReplaceLegacyOperators sLine "lt" "<"  to sLine
        Get _ReplaceLegacyOperators sLine "le" "<=" to sLine
        Get _ReplaceLegacyOperators sLine "eq" "="  to sLine
        Get _ReplaceLegacyOperators sLine "ne" "<>" to sLine  
        
        Move (TokenizerData.sIndentation + String(sLine)) to sLine
        
        Function_Return (sLine <> sOrg)
    End_Function   
    
    // *** LINE-BY-LINE FUNCTION ***
    // Changes: "Set Shadow_State [of oObject] to True" -> "Set Enabled_State [of oObject] to False"
    //          "Set Object_Shadow_State [of oObject] to True" -> "Set Enabled_State [of oObject] to False"
    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
        String sToState sText sLineLC sEndComment sSpaces
        Boolean bFound bIsComment
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bIsComment
        If (bIsComment = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Object_Shadow_State TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Get _IsKeywordInLine CS_Shadow_State TokenizerData.asLineTokens to bFound
        End
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Get _EndComment sLine to sEndComment
            Move (Replace(sEndComment, sLine, "")) to sLine
            Move (Rtrim(sLine)) to sText
            Move (Replace(sText, sLine, "")) to sSpaces
            Move (sSpaces + String(sEndComment)) to sEndComment
        End

        Move (Lowercase(sLine)) to sLineLC
        Move (Pos(Lowercase(CS_Object_Shadow_State), sLineLC)) to iPos
        If (iPos <> 0) Begin
            Get _ReplaceLineToken TokenizerData sLine CS_Object_Shadow_State CS_Enabled_State to sLine
        End
        Else Begin
            Move (Pos(Lowercase(CS_Shadow_State), sLineLC)) to iPos
            If (iPos <> 0) Begin
                Get _ReplaceLineToken TokenizerData sLine CS_Shadow_State CS_Enabled_State to sLine
            End
        End

        // We also need to negate any "True" or "False" in the "to" part of the line
        Move TokenizerData.ToStatement.sCode to sToState
        If (Lowercase(sToState) = Lowercase(CS_True) or Lowercase(sToState) = Lowercase(CS_False)) Begin
            Get _IsKeywordInLine CS_True TokenizerData.asLineTokens to bFound
            If (bFound = True) Begin
                Move (Pos(Lowercase(CS_True), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_True CS_False to sLine
                End
            End
            Else Begin
                Get _IsKeywordInLine CS_False TokenizerData.asLineTokens to bFound
                Move (Pos(Lowercase(CS_False), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_False CS_True to sLine
                End
            End
        End
        // Or any self defined boolean variable at end of line:
        Else Begin
            Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
            // Add "not" keyword
            If (iPos = 0) Begin
                Move (Replace(sToState, sLine, ("(" + CS_Not + "(" + sToState + "))"))) to sLine
            End
            // Remove "not" keyword and its parantheses. Note that it can contain spaces.
            Else Begin
                Move (Replace("(", sToState, "")) to sText
                Move (Replace(CS_Not, sText, "")) to sText
                Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
                Move (Overstrike("   ", sToState, iPos)) to sToState
                Move (Replaces("(", sToState, "")) to sToState
                Move (Replaces(")", sToState, "")) to sToState
                Move (Trim(sToState))              to sToState
                Move (Pos(Lowercase(CS_To), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Move (Left(sLine, (iPos + 3))) to sLine
                    Append sLine " " CS_To " " sToState
                End
            End
        End

        If (TokenizerData.sEndComment <> "") Begin
            Append sLine sEndComment
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // "Length sVar to iLength' -> 'Move (Length(sVar)) to iLength'
    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged  
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***    
    // 'Pos "-"  in sIns to iPos' --> 'Move (Pos("-",sIns)) to iPos'
    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged 

        Get _SingleCommandSyntaxToFunction (&sLine) CS_Replace to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes the command "Sysdate4" -> "Sysdate", as the SysDate4 command is obsolete.
    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
        String sText
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData
        tToken Token

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move TokenizerData.FirstLeftCommand to Token
        Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
        If (bFound = False) Begin
            Move TokenizerData.SecondLeftCommand to Token
            Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End

        Move (Replace("4", sLine, "")) to sLine
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Example: Trim sVal to sVal -> Move (Trim(sVal)) to sVal
    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        Integer iItem iPos
        tTokenizer TokenizerData
        String sVarName sKeyword sKeywordLC sLineLC

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Trim TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move CS_Trim              to sKeyword
        Move (Lowercase(CS_Trim)) to sKeywordLC
        Move (Lowercase(sLine))   to sLineLC
        Move (SearchArray(sKeywordLC, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        Move TokenizerData.asLineTokens[iItem + 1] to sVarName
        If (sVarName = "") Begin
            Function_Return False
        End
        Move (Pos(sKeywordLC, sLineLC)) to iPos
        If (iPos <> 0) Begin
            Move (Replace(sKeyword, sLine, "")) to sLine
            Move (Replace(" " + sVarName + " ", sLine, "")) to sLine
            Move (Insert(CS_Move + " (" + CS_Trim + "(" + String(sVarName) + ")) ", sLine, iPos)) to sLine
            Move True to bChanged
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bValid bIgnore
        String sTest sClassName sOldStyle sNewStyle
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move "" to sClassName
        Move (Lowercase(sLine)) to sTest
        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
        Get _StripConcatenatingSpaces sTest to sTest
        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
        If (Pos(" create u_", sTest)) Begin
            Move (Lowercase(sLine)) to sTest
            Move (Pos("u_", sTest)) to iPos
            Get _IsValidClassCharacter sTest iPos to bValid
            While (bValid)
                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
                Increment iPos
                Get _IsValidClassCharacter sTest iPos to bValid
            Loop
        End
        If (sClassName <> "") Begin
            Move True to bChanged
            Move sClassName to sOldStyle
            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
            Move ("(RefClass(" + sClassName + "))") to sNewStyle
            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
        End
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***    
    // 'ZeroString iLength to sParameter' --> 'Move (ZeroString(iLength)) to sParameter'
    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
        Function_Return bChanged
    End_Function

    // *** EDITOR FUNCTION ***
    // Pass the *full* source file as a string array
    Function EditorDropSelf String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Move False to Err
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorDropSelf)"
            Function_Return 0
        End
        Send RefactorDropSelf of hoEditor
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** EDITOR FUNCTION ***
    // Wrapper functions for the cScintillaEdit editor
    // Note that a full visible instantiation of the cScintillaEdit class
    // should be used for usage, and the phoEditor property for that
    // object _must_ be set to that editor object id.
    //
    Function EditorNormalizeCase String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorNormalizeCase)"
            Function_Return 0
        End
        Send RefactorNormalizeCase of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** EDITOR FUNCTION ***
    Function EditorReIndent String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorReIndent)"
            Function_Return 0
        End
        Set piTabSize of hoEditor to sParameter
        Send RefactorReIndent of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
        Boolean bFound bChanged 
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bIsBlank = True or TokenizerData.bIsComment = True or TokenizerData.sEndComment = "") Begin
            Function_Return False
        End
        Get _IsValidRemoveEndCommentsLine sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End                      
        
        Get _RemoveComments (&sLine) to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes local statement if present.
    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound bVariableDeclaration bLocalVariableArrayDeclaration
        String sText
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get _IsVariableDeclarationLine  of ghoRefactorFunctionLibrary TokenizerData.sOverstrikeLine  to bVariableDeclaration
        Get _IsVariableArrayDeclaration of ghoRefactorFunctionLibrary TokenizerData.sOverstrikeLine to bLocalVariableArrayDeclaration
        If (bVariableDeclaration = False and bLocalVariableArrayDeclaration = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move (LTrim(sLine)) to sText
        Move (Left(sText, 6)) to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_Local) + " ")) Begin
            // local must be the first word on the line.
            // Now find the local statement and remove it.
            Move (Lowercase(sLine)) to sText
            Move (Pos((Lowercase(CS_Local) + " "), sText)) to iPos
            If (iPos > 0) Begin
                Move (Remove(sLine, iPos, 6)) to sLine
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // *** FULL SOURCE FILE FUNCTION ***
    // Pass the whole source file as a string array.
    // Removes  consecutive empty blank lines if more than piMaxNoOfEmptyLines.
    // Returns the passed string array but with removed duplicated empty lines.
    Function RemoveMultipleBlankLines String[] ByRef asSourceFile String sParameter Returns Integer
        String[] asSourceFileOut
        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines
        String sLine
        Boolean bImageStart bImageEnd bMakeImageTest

        Move False to bImageStart
        Move False to bImageEnd
        Move True  to bMakeImageTest
        Move 0 to iCurrentNoOfEmptyLines
        Move sParameter to iMaxNoOfEmptyLines

        Move (SizeOfArray(asSourceFile)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (Trim(asSourceFile[iCount])) to sLine

            If (bMakeImageTest = True) Begin
                If (bImageStart = False and bImageEnd = False) Begin
                    Get _IsImagePageStartOrEnd sLine True to bImageStart
                End
            End

            If (bImageStart = False and bImageEnd = False) Begin
                If (sLine = "") Begin
                    Increment iCurrentNoOfEmptyLines
                End
                Else Begin
                    Move 0 to iCurrentNoOfEmptyLines
                End
            End
            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
                Move asSourceFile[iCount] to asSourceFileOut[SizeOfArray(asSourceFileOut)]
            End

            If (bMakeImageTest = True) Begin
                If (bImageStart = True) Begin
                    Get _IsImagePageStartOrEnd sLine False to bImageEnd
                    If (bImageEnd = True) Begin
                        Move False to bImageStart
                        Move False to bImageEnd
                        Move False to bMakeImageTest
                    End
                End
            End
        Loop

        Move (SizeOfArray(asSourceFile) - SizeOfArray(asSourceFileOut)) to iEmptyLines
        Move asSourceFileOut to asSourceFile

        Function_Return iEmptyLines
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Returns True if a legacy IDE (Studio) source code marker is found.
    // This is a "Remove Type Function".
    Function RemoveOldStudioMarkers String sLine Returns Boolean
        Boolean bFound
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bFound
        Move (Trim(sLine)) to sLine

        Case Begin
            Case (sLine = "//AB-IgnoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-IgnoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-DDOStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-DDOEnd")
                Move True to bFound
                Case Break
            Case (Left(sLine, 6) = "//AB/ ")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-MenuPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-End")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ToolbarPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ViewStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ViewEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StatusBarPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//IDE-FileType=ftApplication")
                Move True to bFound
                Case Break
        Case End

        Function_Return bFound
    End_Function

    // *** LINE-BY-LINE FUNCTION ***     
    // ToDo: Needs to be revised.
    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
        String[] asObjectNames
        tTokenizer TokenizerData

        Move True to bWriteLine
        Get pTokenizer to TokenizerData
        If (TokenizerData.bIsVariableDeclaration or TokenizerData.bIsInCommand or ;
            TokenizerData.bIsInClass or TokenizerData.bIsInImage or TokenizerData.bIsInFunction or ;
            TokenizerData.bIsInProcedure or TokenizerData.bIsInDF23MultiLineString) Begin
            Function_Return False
        End
            
        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd
        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
        Get pasObjectNames                to asObjectNames

        If (bRegisterAllObjectsEnd = False) Begin
            If (bRegisterAllObjectsStart = False) Begin
                Get _IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
                Set pbRegisterAllObjectsStart        to bRegisterAllObjectsStart
            End
            If (bRegisterAllObjectsStart = True) Begin
                Get _IsRegisterObjectInArray sLine asObjectNames to bWriteLine
                Move False to bProjectObjectStructureStart
                Set           pbProjectObjectStructureStart to False
            End
            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
                Get _IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
            End
            If (bProjectObjectStructureStart = True) Begin
                Get _IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
            End
            Get _IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
            If (bRegisterAllObjectsEnd = True) Begin
                Send ResetProjectObjectStructureProperties
                // This means that we won't bother with the rest of the file.
                Set pbRegisterAllObjectsEnd to True
            End  
        End
        If (bWriteLine = False) Begin
            Move "" to sLine
        End
        Function_Return (bWriteLine = False)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // To remove hardcoded MS Sans Serif fonts if present.
    Function RemoveSansSerif String sLine Returns Boolean
        String sTest
        Boolean bWriteLine

        Move False to bWriteLine
        Move (Lowercase(Trim(sLine))) to sTest
        Move (Replaces(" ", sTest, ""))  to sTest
        Move (Replaces("'", sTest, "*")) to sTest
        Move (Replaces('"', sTest, "*")) to sTest
        If (sTest contains 'settypefaceto*mssansserif*') Begin
            Move True to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes Studio generated comments:
    //               "// fires when the button is clicked"
    //               "//OnChange is called on every changed character
    //               "// Visual DataFlex xx.x Client Size Adjuster
    //               "// Visual DataFlex xx.x Migration Utility,"
    //               ...and so on
    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
        String sText sComment sComment2
        Boolean bFound bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move (Trim(sLine)) to sText
        If (sText = "" or sText = CS_CommentSymbol or sText contains (CS_CommentSymbol + "AB") or TokenizerData.bIsComment = False) Begin
            Function_Return False
        End

        Move "fires when the button is clicked" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "onchange is called on every changed character" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex"      to sComment
        Move "client size adjuster" to sComment2
        Get _IsStudioGeneratedComment sLine sComment sComment2 to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex"    to sComment
        Move "migration utility," to sComment2
        Get _IsStudioGeneratedComment sLine sComment sComment2 to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "If you set Current_radio you must set this after the" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "radio objects have been created AND after Notify_select_State has been" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "created. i.e. Set in bottom-code at end!!" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Remove trailing spaces if present.
    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
        Integer iBefore iAfter
        Boolean bChanged
        tTokenizer TokenizerData

        Move (Length(sLine))     to iBefore
        Move (RTrim(sLine))      to sLine
        Move (Length(sLine))     to iAfter
        Move (iBefore <> iAfter) to bChanged

        Function_Return bChanged
    End_Function

    // *** FULL SOURCE FILE FUNCTION ***
    // ToDo: How to handle this in the TestBench??
    // Pass the whole source file as a string array
    // Removes all unusad locally defined (in Procedures & Functions) for the
    // passed string array. Returns number of removed unused local variables.
    Function RemoveUnusedLocals String[] ByRef asSourceFile String sParameter Returns Integer
        Handle ho
        Integer iRetval
        Get phoRemoveUnusedLocals to ho
        If (ho = 0) Begin
            Send UserError "phoRemoveUnusedLocals = 0"
            Function_Return 0
        End
        Get MainProcedure of ho (&asSourceFile) to iRetval
//        If (iRetval > 1) Begin
//            Reread SysFile
//                Add iRetval to SysFile.iCountUnusedLocals
//                SaveRecord SysFile
//            Unlock
//        End

        Function_Return iRetval
    End_Function

    // *** REPORT FUNCTION ***
    // ToDo: *** To be finished! ***
    // Makes no change to the source code.
    // Pass an array with *all source files*
    Function ReportUnusedSourceFiles String[] ByRef asSourceFiles String sParameter Returns Integer
        Handle ho
        String sFilter
        Integer iRetval
        tRefactorSettings RefactorSettings

        Get phoReportUnusedSourceFiles to ho
        If (ho = 0) Begin
            Function_Return 0
        End

        Get pRefactorSettings to RefactorSettings
        Set psFileFilter  of ho to RefactorSettings.sFileFilter
//        Set pasAllFolders of ho to RefactorSettings.asFolderNames
//        Set pasSourceFiles of ho to asSourceFiles
Function_Return 0

        Send DoProcess    of ho

        Get piNoOfUnusedSourceFiles of ho to iRetval
        Reread SysFile
            Move iRetval to SysFile.iCountUnusedSourceFiles
            SaveRecord SysFile
        Unlock
        Function_Return iRetval
    End_Function

    // *** ALL SOURCE FILES FUNCTION ***
    // Pass the all source files as a string array, including path.
    //  The naming style of datadictionaries over time has not been constant.
    //  The new style is
    //    Object o<tablename>_DD is a c<TableName>Datadictionary
    //  They also have a switch so you can keep on using the legacy style name which is
    //    Object o<tablename>_DD is a <tablename>_Datadictionary
    //
    //  However before VDF12, the
    //    Object <tableName>_DD is a <tablename>_Datadictionary
    //
    //  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
    //  all over the place. Copying old code into new views/dialogs simply breaks and if your
    //  codebase has mixed styles then the compiler will not catch that.
    //  A code nightmare.
    //
    //  This program allows you to switch between the following code styles:
    //  <TableName>_DD  == eDDOldStyle
    //  TO: o<TableName>_DD == eDDStudioStyle
    Function RestylelDDOs String[] ByRef asSourceFile String sParameter Returns Integer
        String sHomePath
        Handle ho
        Integer iRetval iSize iCount
        tRefactorSettings RefactorSettings
        tsSearchResult[] asAllSourceFiles
        String[] asFilesArray

        Get phoDDOReStyler to ho
        If (ho = 0) Begin
            Send UserError "phoDDORestyler = 0"
            Function_Return 0
        End

        Get psHomePath of ghoApplication to sHomePath
        Get pRefactorSettings to RefactorSettings
        Get AllSourceFiles of ghoApplication RefactorSettings.asFolderNames RefactorSettings.sFileFilter to asAllSourceFiles

        Set psHomePath of ho to sHomePath
        Set peDDOStyle of ho to RefactorSettings.eDDOStyle
        Move (SizeOfArray(asAllSourceFiles)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asAllSourceFiles[iCount].sFilename to asFilesArray[SizeOfArray(asFilesArray)]
        End
        Set pasAllSourceFiles of ho to asFilesArray

        Get MainDDORestyler of ho to iRetval
        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // The older version's passed parameters eSplitBy and iTabSize, but the iTabSize was been made into
    // a class property. This way we can have a uniform calling interface for all functions.
    // The eSplitBy is passed in the sParamater param.
    // Valid sParameter values;
    //    CI_SplitWithSpaceAndSemicolon
    //    CI_SplitWithSemicolon
    //    CI_SplitAddBeginEndBlock
    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
        Boolean bStop bChanged
        Integer iIndent eSplitBy iTabSize iItem
        String  sText
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Move (SearchArray(CS_Else, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem = -1) Begin
                Function_Return False
            End
        End
            
        Move False to bChanged
        Move sParameter to eSplitBy
        Get piTabSize to iTabSize

        Move (LTrim(sLine))     to sText
        Move (Pos(sText,sLine) - 1) to iIndent
        Move (Left(sText, 3))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_If) + " ")) Begin
            Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
            If (bStop = False) Begin
                // It's one of those single line if statements, break it up
                Move (Lowercase(sLine)) to sText
                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
            End
        End
        Else Begin
            Move (LTrim(sLine))     to sText
            Move (Left(sText, 5))   to sText
            Move (Lowercase(sText)) to sText
            If (sText = (Lowercase(CS_Else) + " ")) Begin
                Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
                If (bStop = False) Begin
                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
                End
            End
        End
        Function_Return bChanged
    End_Function

// NOTE: Do *not* add any code after this "End_Class"!
//       It will be removed by the Json Export/Import logic.
End_Class
