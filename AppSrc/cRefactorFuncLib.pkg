// Copyright (c) 2018 Nils Svedmyr, RDC Tools International
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to Do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in All
// copies or substantial portions of the Software.
//
// THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
// IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
// FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
// LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
// OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// *** To add a function to this class two things are needed:
//
//     1) Add the code as a function in the class below with the same parameters
//        as the existing functions are using.
//     2) Register the function, using the TestBench - FunctionsMaintenance view.
//        There you can also learn more about different types of functions and
//        their requested parameters.
//
// This class is automatically instantiated by the cRefactorApplication class. See: End_Construct_Object
//
Use cBaseFuncLib.pkg
//
// Use statement for YOUR USER DEFINED refactoring classes,
// that are used in the UserDefinedRefactorFunctions.pkg
// file is automatically included by the cRefactorFuncLib class.
Use UserDefinedUseStatement.pkg

Class cRefactorFuncLib is a cBaseFuncLib
    Procedure Construct_Object
        Forward Send Construct_Object

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
    End_Procedure

    // This *must* be called *once* per source line, *before* any of the refactor functions are called.
    // It calls the Tokenizer function and sets the class property pTokenizer that is used
    // by refactoring functions in this class!
    // The call lis made automatically by the refactoring engine, but there are special cases were
    // this also needs to be done manually.
    Procedure InitializeTokenizer String sLine
        tTokenizer TokenizerData
        // Note: This function call also sets the pTokenizer property.
        Get Tokenizer sLine to TokenizerData
    End_Procedure

    // *** User defined functions of type: eStandard_Function (line-by-line) are included here ***
    //     Use the file to add your own special refactoring function(s) that are particular to
    //     a special code base/project, and has no general interest.
    //     (Dummy method for the Code Explorer)
    Procedure INCLUDE_USER_DEFINED_FUNCTIONS
    End_Procedure
    #Include UserDefinedRefactorFunctions.pkg

    // *** Type: eStandard_Function ***
    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
    // This would compile but not work well with the ChangeCalcToMoveStatement function.
    Function ChangeCalcToMoveStatement String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sTest sStart sStop
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady or TokenizerData.bIsInCommand or TokenizerData.bIsInImage or TokenizerData.bIsVariableDeclaration) Begin
            Function_Return False
        End

        // Check if line contains one of the keywords and that none of the keywords are within quotes.
        Get _IsKeywordInLine "calc|moveint|movenum|movereal|movestr" TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        Move (Lowercase(sLine)) to sTest
        Move False to bChanged

        Case Begin
            Case (Pos("calc ", sTest))
                Move (Pos("calc ", sTest))            to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("moveint ", sTest))
                Move (Pos("moveint ", sTest))         to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movenum ", sTest))
                Move (Pos("movenum ", sTest))         to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movereal ", sTest))
                Move (Pos("movereal ", sTest))        to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movestr ", sTest))
                If (Lowercase(TokenizerData.FirstLeftCommand.sCode) <> Lowercase(CS_Move)) Begin
                    Move (Pos("movestr ", sTest))         to iPos
                    Move (Left(sLine, (iPos -1))) to sStart
                    Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                    Move (sStart + CS_Move + sStop)       to sLine
                    Move True                             to bChanged
                End
                Case Break
        Case End

        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Replaces "Current_Object" to "Self"
    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
        String sChar
        Boolean bFound
        Integer iPos iItem
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move (SearchArray(CS_Current_Object, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
            If (iPos <> 0) Begin
                Move (Mid(sLine, 1, (iPos -1))) to sChar
                If (sChar <> "(") Begin
                    Function_Return
                End
            End
            Else Begin
                Function_Return False
            End
        End

        Get _ReplaceLineToken TokenizerData sLine CS_Current_Object CS_Self to sLine
        // Note! We call ourself recursively if there are more than one "current_object".
        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos <> 0) Begin
            Get ChangeCurrent_ObjectToSelf (&sLine) "" to bFound
        End

        Function_Return True
    End_Function

    // *** Type: eStandard_Function ***
    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sNewBoolean
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData

        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get _IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Trim(sLine)) to sLine
        Repeat
            Move CS_True to sNewBoolean
            Move (Pos(Lowercase(CS_DfTrue), Lowercase(TokenizerData.sOverstrikeLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos(Lowercase(CS_DfFalse), Lowercase(TokenizerData.sOverstrikeLine))) to iPos
                Move CS_False to sNewBoolean
            End
            If (iPos <> 0) Begin
                Move (Overstrike("||" + sNewBoolean, sLine, iPos)) to sLine
                Move (Replace("||", sLine, "")) to sLine
                Move (Overstrike("||" + sNewBoolean, TokenizerData.sOverstrikeLine, iPos)) to TokenizerData.sOverstrikeLine
                Move (Replace("||", TokenizerData.sOverstrikeLine, "")) to TokenizerData.sOverstrikeLine
            End
        Until (iPos = 0)

        Move (TokenizerData.sIndentation + String(sLine)) to sLine
        Function_Return True
    End_Function

    // *** Type: eStandard_Function ***
    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
    // For the function to do anything, the line needs to contain a "GetAddress" command.
    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sText
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText

        If (TokenizerData.bLineIsReady or TokenizerData.bHasEndSemiColon or TokenizerData.bIsInFunction or ;
            TokenizerData.bIsInProcedure = True ) Begin
            Function_Return False
        End

        Get _IsKeywordInLine (CS_GetAddress + "|") TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode)) to sLine
        End

        Function_Return True
    End_Function

    // *** Type: eStandard_Function ***
    // Changes: 'Insert "," In sText At 2' --> 'Move (Insert(",", sText, 2)) to sText'
    //          ' If sOne Eq "A" Insert "B" in sOne at 2' --> ' If sOne Eq "A" Move (Insert("B", sOne, 2)) to sOne'
    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sNose sLineLC sToken sVar1 sVar2 sText
        Integer iPos iItem iInPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True) Begin
            Function_Return False
        End

        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End

        Move (Trim(sLine)) to sLine

        Move "" to sNose
        Move (Lowercase(sLine)) to sLineLC
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        // If anything left of the CS_Insert command, save it in "sNose" (start string)
        If (iItem > 0) Begin
            Move (Pos(Lowercase(CS_Insert), sLineLC)) to iPos
            Move (Left(sLine, (iPos -1))) to sNose
            Move (Replace(sNose, sLine, "")) to sLine
        End

        // Remove the CS_Insert command
        Move TokenizerData.asLineTokens[iItem] to sToken
        Move (Replace(sToken, sLine, "")) to sLine
        // Get the first variable
        Move TokenizerData.asLineTokens[iItem + 1] to sVar1

        // Find and remove the "IN" keyword.
        Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sToken
            Move (Replace(sToken, sLine, "")) to sLine
            Move TokenizerData.asLineTokens[iItem + 1] to sVar2
        End

        // Find and remove the "AT" keyword, and save the next parameter which is the position to insert at.
        Move (SearchArray(CS_At, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sToken
            Move (Replace(sToken, sLine, "")) to sLine
            Move TokenizerData.asLineTokens[iItem + 1] to iInPos
        End

        Move "" to sText
        If (sNose <> "") Begin
            Move sNose to sText
            Move (Trim(sText) + " ") to sText
        End
        Append sText CS_Move " " "(" CS_Insert "(" sVar1 "," sVar2 "," iInPos "))" " " CS_To " " sVar2

        Move (TokenizerData.sIndentation + String(sText)) to sLine
        If (TokenizerData.sEndComment <> "") Begin
            Append sLine TokenizerData.sEndComment
        End
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Replaces 'IN' with 'Contains, it also swap places for the two variables involved and adds paranthesis.
    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
        String sOrg sPattern sMatched sRemain sHost sSub sText sAfter sBefore sItem sExpression
        Integer iSize iCount iItem
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        Move (SearchArray(CS_With, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Pos, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End

        Move sLine to sOrg
        Move sLine to sText
        Move TokenizerData.asLineTokens[iItem -1] to sAfter
        Move TokenizerData.asLineTokens[iItem +1] to sBefore
        Decrement iItem
        Move ("(" + sBefore * CS_Contains * String(sAfter) + ")") to sExpression
        // Set the "Before" array item to the expression
        Move sExpression            to TokenizerData.asLineTokens[iItem]
        // Add expression to the expression array:
        Move (SizeOfArray(TokenizerData.aExpressions)) to iSize
        Move sExpression            to TokenizerData.aExpressions[iSize].sExpression
        Move (Length(sExpression))  to TokenizerData.aExpressions[iSize].iLength
        Move (Pos(sAfter, sOrg))    to TokenizerData.aExpressions[iSize].iStartPos
        If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
            Move sExpression to TokenizerData.BooleanIndicator.AsBoolean.sCode
        End
        Increment iItem
        // Remove the two items we have concatenated.
        Move (RemoveFromArray(TokenizerData.asLineTokens, iItem)) to TokenizerData.asLineTokens
        Move (RemoveFromArray(TokenizerData.asLineTokens, iItem)) to TokenizerData.asLineTokens
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize
        Move "" to sText
        For iCount from 0 to iSize
            Move TokenizerData.asLineTokens[iCount] to sItem
            Append sText sItem " "
        Loop

        If (sText <> sOrg) Begin
            Move (TokenizerData.sIndentation + Trim(sText)) to sLine
            If (TokenizerData.sEndComment <> "") Begin
                Append sLine " " TokenizerData.sEndComment
            End
            Set pTokenizer to TokenizerData
        End

        Function_Return (sLine <> sOrg)
    End_Function

    // *** Type: eStandard_Function ***
    // (Left( {string-value}, {length} )) -> 'Move (Left(sVar, 5)) to sLeft'
    Function ChangeLeftCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Left to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Changes legacy: Indicate Found as True" --> Move True to Found
    //                 [Select] Indicate Select as Windowindex Eq Fieldindex --> Move (WindowInex = FieldIndex) to Select
    //                 [Found] and [FindErr] indicator statements.
    //                 [Found| Command -> e.g. If Found Command
    //                 While [Not Found]   -> e.g. While (Not(Found))
    //                 [Found|Not Found|FindErr|Not FindErr] While   -> e.g. While (Not(Found))
    //                 [Found] Indicate Found as Invoice.CustNum eq Customer.Number -> If (Found) Move (Invoice.CustNum eq Customer.Number) to Found
    //                 If [Not Found] Reread hTable -> If (Not(Found)) Reread hTable
    //                 [~Found] begin -> If (Not(Found)) Begin
    //                 [Found ~Found] Begin -> If (Found and Not(Found)) Begin
    // *Known limitation*:
    //   It can only handle max two booleans within the same square bracket. E.g. "[Found Select]"
    //   It can't handle "GROUP" and/or "ALL" indicator directives. If any of those two are found,
    //   this function will leave the sLine as it is.
    Function ChangeLegacyIndicators String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bStartBracket bHasBracket bIndicateStart bIfStart
        String sToken sOverstrikeLine sNot sTo sMove sIf sFirstCmd sSecondCmd sExpression
        Integer iItem iSize iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True or TokenizerData.bIsInImage = True) Begin
            Function_Return False
        End
        Get _HasBracket TokenizerData.BooleanIndicator to bHasBracket
        If (TokenizerData.BooleanIndicator.bHasIndicateCommand = False and bHasBracket = False) Begin
            Function_Return False
        End

        If (Lowercase(sLine) contains (Lowercase(CS_Find) + " ") or ;
            Lowercase(sLine) contains (Lowercase(CS_Send) + " ") or ;
            Lowercase(sLine) contains (Lowercase(CS_Constrain) + " ")) Begin
            Function_Return False
        End

        Move (SearchArray("GROUP", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray("ALL", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End

        // Has If-statement?
        Move (TokenizerData.bHasIfCommand = True) to bIfStart
        If (bIfStart = True) Begin
            Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move TokenizerData.asLineTokens[iItem] to sIf
            End
        End
        Else Begin
            Move CS_If to sIf
        End

        // Has Move-statement?
        Move (SearchArray(CS_Move, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sMove
        End
        Else Begin
            Move CS_Move to sMove
        End
        Move TokenizerData.FirstLeftCommand.sCode  to sFirstCmd
        Move TokenizerData.SecondLeftCommand.sCode to sSecondCmd

        // Has To-statement?
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sTo
        End
        Else Begin
            Move CS_To to sTo
        End

        Move 0 to iItem
        Move TokenizerData.asLineTokens[iItem] to sToken
        // Starts with a indicator bracket?
        Move (Left(sToken, 1) = "[") to bStartBracket
        Move CS_Not to sNot

        // Get the "Not" keyword:
        If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot  = True or ;
            TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True or ;
            TokenizerData.BooleanIndicator.ToBoolean.bHasNot     = True or ;
            TokenizerData.BooleanIndicator.AsBoolean.bHasNot     = True) Begin
            Move (SearchArray("[not", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem = -1) Begin
                Move (Pos(("[" + CS_Tilde), TokenizerData.sLine)) to iItem
                If (iItem = 0) Begin
                    Move -1 to iItem
                End
                Else If (iItem > 0) Begin
                    Move -1 to iItem
                End
            End
            If (iItem <> -1) Begin
                Get _ReplaceBrackets TokenizerData.asLineTokens[iItem] to sNot
            End
        End

        // Has an "Indicate" command?
        Move (SearchArray(CS_Indicate, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        Move (iItem <> -1) to bIndicateStart

        // Add "Not" operator and add paranthesis to boolean expressions/variables;
        If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + "))") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
        End
        Else If (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "" and Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) <> "(") Begin
            Move ("(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + ")") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
        End
        If (TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.SecondBoolean.sCode + "))") to TokenizerData.BooleanIndicator.SecondBoolean.sCode
        End
        Else If (Left(TokenizerData.BooleanIndicator.SecondBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.SecondBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.SecondBoolean.sCode + ")") to TokenizerData.BooleanIndicator.SecondBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.ToBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.ToBoolean.sCode + "))") to TokenizerData.BooleanIndicator.ToBoolean.sCode
        End
        If (Left(TokenizerData.BooleanIndicator.ToBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.ToBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.ToBoolean.sCode <> "" and not(TokenizerData.BooleanIndicator.ToBoolean.sCode contains " ")) Begin
                Move ("(" + TokenizerData.BooleanIndicator.ToBoolean.sCode + ")") to TokenizerData.BooleanIndicator.ToBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.AsBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.AsBoolean.sCode + "))") to TokenizerData.BooleanIndicator.AsBoolean.sCode
        End
        If (Left(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.AsBoolean.sCode + ")") to TokenizerData.BooleanIndicator.AsBoolean.sCode
            End
        End

        Case Begin

            // This was too much code, so it was broken out to a helper-function (sub):
            Case (bStartBracket = True)
                Get _ChangeLegacyIndicators_Sub TokenizerData TokenizerData.sOverstrikeLine (&bChanged) to sOverstrikeLine
                Case Break

            // 'If [False] Indicate Select as Windowindex Eq Fieldindex // Comment'
            // 'If [not found] Move (Windowindex Eq Fieldindex) to Select // Comment'
            // 'If dDate LE '01/01/1984' Indicate ERROR_DATE True'
            Case (bIfStart = True)
                Move sIf to sOverstrikeLine
                Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                Get _ReplaceParanthesis sToken to sToken
                Move (Pos(Lowercase(sToken), Lowercase(Trim(sLine)))) to iPos
                If (iPos < TokenizerData.SecondLeftCommand.iStartPos) Begin
                    Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                    Move (SearchArray(sToken, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                    If (iItem = -1) Begin
                        Get _ReplaceParanthesis sToken to sToken
                        Move (SearchArray(sToken, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                    End
                    If (iItem <> -1) Begin
                        Increment iItem
                        If (iItem <= SizeOfArray(TokenizerData.asLineTokens)) Begin
                            Move TokenizerData.asLineTokens[iItem] to sToken
                            If (Lowercase(sToken) = Lowercase(CS_As)) Begin
                                Increment iItem
                                Move TokenizerData.asLineTokens[iItem] to sToken
                            End
                        End
                        If (Lowercase(sToken) = Lowercase(CS_To)) Begin
                            Increment iItem
                            Move TokenizerData.asLineTokens[iItem] to sToken
                            Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode " " sMove
                            Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sExpression
                            Append sOverstrikeLine " " sExpression " " sTo " " sToken
                        End
                        Else Begin
                            Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode " " sMove
                            Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sExpression
                            Get _ReplaceParanthesis sExpression to sExpression
                            Append sOverstrikeLine " " sToken " " sTo " " sExpression
                        End
                    End
                End
                Else Begin
                    Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                    If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                        Append sOverstrikeLine " " sMove " " TokenizerData.BooleanIndicator.AsBoolean.sCode
                        Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                        Append sOverstrikeLine " " sTo   " " sToken
                    End
                    Else Begin
                        Append sOverstrikeLine " " sMove " " TokenizerData.BooleanIndicator.SecondBoolean.sCode
                        Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
                        Get _ReplaceParanthesis sToken to sToken
                        Append sOverstrikeLine " " sTo   " " sToken
                    End
                End

                Case Break

            // 'Indicate Found as True'
            // 'Indicate [Found] as True'
            // 'Indicate Select as Windowindex Eq Fieldindex // Comment'
            Case (bIndicateStart = True)
                Move CS_Move to sOverstrikeLine
                If (Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) = "(") Begin
                    Get _ReplaceParanthesis TokenizerData.BooleanIndicator.FirstBoolean.sCode to TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                // If AsBoolean.sCode = "" we have a missing "as" keyword on line, so we adjust for that here.
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode = "") Begin
                    Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
                    Move TokenizerData.asLineTokens[iSize -1] to TokenizerData.BooleanIndicator.AsBoolean.sCode
                End
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "" and Left(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> "(") Begin
                    Move ("(" + TokenizerData.BooleanIndicator.AsBoolean.sCode +")") to TokenizerData.BooleanIndicator.AsBoolean.sCode
                End
                Append sOverstrikeLine " " TokenizerData.BooleanIndicator.AsBoolean.sCode " " CS_To " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                Case Break

            // Starts with any other than: "If", "Indicate" or a square bracket indicator as e.g. "[Not Found]". I.e. another command.
            Case Else
                // Do we have a e.g. "While [Not Found]" construct?
                If (Pos(sFirstCmd, TokenizerData.sOverstrikeLine) < Pos("[", TokenizerData.sOverstrikeLine)) Begin
                    Move sFirstCmd to sOverstrikeLine
                    Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                Else Begin
                    Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
                    If (sToken = "") Begin
                        Move TokenizerData.BooleanIndicator.AsBoolean.sCode to sToken
                    End
                    Move (CS_Move * String(sToken)) to sOverstrikeLine
                    If (SearchArray(sTo, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP)) <> -1) Begin
                        Append sOverstrikeLine " " sTo " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                    End
                    Else Begin
                        Move TokenizerData.asLineTokens[(SizeOfArray(TokenizerData.asLineTokens) -1)] to sToken
                        Move (SearchArray(CS_As, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                        If (iItem <> -1) Begin
                            Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                            Append sOverstrikeLine " " sTo " " sToken
                        End
                        Else Begin
                            Append sOverstrikeLine " " sToken
                        End
                    End
                End
        Case End

        Move (TokenizerData.sIndentation + sOverstrikeLine) to sOverstrikeLine
        If (TokenizerData.sEndComment <> "") Begin
            Append sOverstrikeLine " " TokenizerData.sEndComment
        End
        Move sOverstrikeLine to sLine
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>"
    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
        String sExpression sOrg sOrgNS sOverStrikeLine
        Boolean bFound
        Integer iItem iCount iSize iPos iLeftParanthesis iRightParanthesis
        tTokenizer TokenizerData
        tOperatorsInfo OperatorInfo

        Get pTokenizer to TokenizerData
        If (TokenizerData.OperatorsInfo.bIsLegacy = False) Begin
            Function_Return False
        End
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Find) or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Find)) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Constrain, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Get _HasLegacyOperator TokenizerData.sOverstrikeLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Ltrim(sLine)) to sOrg
        Get _TrimInsideSpaces sOrg to sOrgNS 
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine

        Move (SizeOfArray(TokenizerData.aExpressions)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move TokenizerData.aExpressions[iCount].sExpression to sExpression
            Move (Pos(sExpression, sOrgNS)) to iPos
            If (iPos = 0) Begin
                Move TokenizerData.aExpressions[iCount].sExpressionNP to sExpression
                Move (Pos(sExpression, sOrgNS)) to iPos
            End      
            If (iPos <> 0) Begin
                Move (Replace(sExpression, sOrgNS, "")) to sOrgNS
                Move TokenizerData.aExpressions[iCount].sExpression to sExpression
                Move (Insert(sExpression, sOrgNS, iPos)) to sOrgNS
            End
            Else Begin
                Move (Pos(sExpression, sOverStrikeLine)) to iPos
                If (iPos <> 0) Begin                   
                    Move sOverStrikeLine to sOrgNS
                    Move (Replace(sExpression, sOrgNS, "")) to sOrgNS
                    Move TokenizerData.aExpressions[iCount].sExpression to sExpression
                    Get _TrimInsideSpaces sExpression to sExpression
                    Move (Insert(sExpression, sOrgNS, iPos)) to sOrgNS
                End
            End
        Loop

        Get _ReplaceAllLegacyOperators sOrgNS to sOrgNS

        Move (TokenizerData.sIndentation + String(sOrgNS)) to sOrgNS
        If (sOrg <> sOrgNS) Begin
            Move sOrgNS to sLine
        End
        Function_Return (sOrg <> sOrgNS)
    End_Function

    // *** Type: eStandard_Function ***
    // Changes: "Set Shadow_State [of oObject] to True" -> "Set Enabled_State [of oObject] to False"
    //          "Set Object_Shadow_State [of oObject] to True" -> "Set Enabled_State [of oObject] to False"
    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
        String sToState sText sLineLC sEndComment sSpaces
        Boolean bFound bIsComment
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bIsComment
        If (bIsComment = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Object_Shadow_State TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Get _IsKeywordInLine CS_Shadow_State TokenizerData.asLineTokens to bFound
        End
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Get _EndComment sLine to sEndComment
            Move (Replace(sEndComment, sLine, "")) to sLine
            Move (Rtrim(sLine)) to sText
            Move (Replace(sText, sLine, "")) to sSpaces
            Move (sSpaces + String(sEndComment)) to sEndComment
            Move (Rtrim(sLine)) to sLine
        End

        Move (Lowercase(sLine)) to sLineLC
        Move (Pos(Lowercase(CS_Object_Shadow_State), sLineLC)) to iPos
        If (iPos <> 0) Begin
            Get _ReplaceLineToken TokenizerData sLine CS_Object_Shadow_State CS_Enabled_State to sLine
        End
        Else Begin
            Move (Pos(Lowercase(CS_Shadow_State), sLineLC)) to iPos
            If (iPos <> 0) Begin
                Get _ReplaceLineToken TokenizerData sLine CS_Shadow_State CS_Enabled_State to sLine
            End
        End
        Move (Lowercase(sLine)) to sLineLC

        // We also need to negate any "True" or "False" in the "to" part of the line
        Move TokenizerData.ToStatement.sCode to sToState
        If (Lowercase(sToState) = Lowercase(CS_True) or Lowercase(sToState) = Lowercase(CS_False)) Begin
            Get _IsKeywordInLine CS_True TokenizerData.asLineTokens to bFound
            If (bFound = True) Begin
                Move (Pos(Lowercase(CS_True), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_True CS_False to sLine
                End
            End
            Else Begin
                Get _IsKeywordInLine CS_False TokenizerData.asLineTokens to bFound
                Move (Pos(Lowercase(CS_False), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_False CS_True to sLine
                End
            End
        End
        // Or any self defined boolean variable at end of line:
        Else Begin
            Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
            // Add "not" keyword
            If (iPos = 0) Begin
                Move (Replace(sToState, sLine, ("(" + CS_Not + "(" + sToState + "))"))) to sLine
            End
            // Remove "not" keyword and its parantheses. Note that it can contain spaces.
            Else Begin
                Move (Replace("(", sToState, "")) to sText
                Move (Replace(Lowercase(CS_Not), sText, "")) to sText
                Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
                Move (Overstrike("   ", sToState, iPos)) to sToState
                Move (Replaces("(", sToState, "")) to sToState
                Move (Replaces(")", sToState, "")) to sToState
                Move (Trim(sToState))              to sToState
                Move (Pos(Lowercase(" " + CS_To + " "), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Move (Left(sLine, (iPos -1))) to sLine
                    Append sLine " " CS_To " " sToState
                End
            End
        End   
        Move (Rtrim(sLine)) to sLine
        If (sEndComment <> "") Begin
            Append sLine sEndComment
        End
        Else If (TokenizerData.sEndComment <> "") Begin
            Append sLine " " TokenizerData.sEndComment
        End

        Function_Return True
    End_Function

    // *** Type: eStandard_Function ***
    // "Length sVar to iLength' -> 'Move (Length(sVar)) to iLength'
    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // 'Pos "-"  in sIns to iPos' --> 'Move (Pos("-",sIns)) to iPos'
    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged

        Get _SingleCommandSyntaxToFunction (&sLine) CS_Replace to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // (Rigth( {string-value}, {length} )) -> 'Move (Rigth(sVar, 5)) to sLeft'
    Function ChangeRightCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Right to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Changes the command "Sysdate4" -> "Sysdate", as the SysDate4 command is obsolete.
    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        tTokenizer TokenizerData
        tToken Token

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move TokenizerData.FirstLeftCommand to Token
        Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
        If (bFound = False) Begin
            Move TokenizerData.SecondLeftCommand to Token
            Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End

        Move (Replace("4", sLine, "")) to sLine
        Function_Return True
    End_Function

    // *** Type: eStandard_Function ***
    // Example: Trim sVal to sVal -> Move (Trim(sVal)) to sVal
    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        Integer iItem iPos
        tTokenizer TokenizerData
        String sVarName sKeyword sKeywordLC sLineLC

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Trim TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move CS_Trim              to sKeyword
        Move (Lowercase(CS_Trim)) to sKeywordLC
        Move (Lowercase(sLine))   to sLineLC
        Move (SearchArray(sKeywordLC, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        Move TokenizerData.asLineTokens[iItem + 1] to sVarName
        If (sVarName = "") Begin
            Function_Return False
        End
        Move (Pos(sKeywordLC, sLineLC)) to iPos
        If (iPos <> 0) Begin
            Move (Replace(sKeyword, sLine, "")) to sLine
            Move (Replace(" " + sVarName + " ", sLine, "")) to sLine
            Move (Insert(CS_Move + " (" + CS_Trim + "(" + String(sVarName) + ")) ", sLine, iPos)) to sLine
            Move True to bChanged
        End

        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bValid bIgnore
        String sTest sClassName sOldStyle sNewStyle
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move "" to sClassName
        Move (Lowercase(sLine)) to sTest
        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
        Get _TrimInsideSpaces sTest to sTest
        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
        If (Pos(" create u_", sTest)) Begin
            Move (Lowercase(sLine)) to sTest
            Move (Pos("u_", sTest)) to iPos
            Get _IsValidClassCharacter sTest iPos to bValid
            While (bValid)
                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
                Increment iPos
                Get _IsValidClassCharacter sTest iPos to bValid
            Loop
        End
        If (sClassName <> "") Begin
            Move True to bChanged
            Move sClassName to sOldStyle
            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
            Move ("(RefClass(" + sClassName + "))") to sNewStyle
            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
        End
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // 'ZeroString iLength to sParameter' --> 'Move (ZeroString(iLength)) to sParameter'
    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
        Function_Return bChanged
    End_Function

    // *** Type eEditor_Function ***
    // Pass the *full* source file as a string array
//    Function EditorDropSelf String[] ByRef asCode String sParameter Returns Boolean
//        Handle hoEditor
//        Boolean bOK bChanged
//        String[] asRefactoredCode
//        tRefactorSettings RefactorSettings
//
//        Move False to Err
//        Get phoEditor to hoEditor
//        If (hoEditor = 0) Begin
//            Error "phoEditor = 0 (Function: EditorDropSelf)"
//            Function_Return 0
//        End
//        Get WriteDataToEditor of hoEditor asCode to bOK
//        If (bOK = False) Begin
//            Function_Return False
//        End
//        Send RefactorDropSelf of hoEditor
//
//        Get pRefactorSettings to RefactorSettings
//        If (RefactorSettings.bReadOnly = False) Begin
//            Get EditorDataAsStringArray of hoEditor to asRefactoredCode
//            If (not(IsSameArray(asRefactoredCode, asCode))) Begin
//                Move asRefactoredCode to asCode
//                Move True to bChanged
//            End
//        End
//        Else Begin
//            Move True to bChanged
//        End
//        Function_Return bChanged
//    End_Function

    // *** Type eEditor_Function ***
    // Wrapper functions for the cScintillaEdit editor
    // Note that a full visible instantiation of the cScintillaEdit class
    // should be used for usage, and the phoEditor property for that
    // object _must_ be set to that editor object id.
    //
    Function EditorNormalizeCase String[] ByRef asCode String sParameter Returns Boolean
        Handle hoEditor
        Boolean bOK bChanged
        String[] asRefactoredCode
        tRefactorSettings RefactorSettings

        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Error "phoEditor = 0 (Function: EditorNormalizeCase)"
            Function_Return 0
        End

        Set Changed_State of hoEditor to False
        Send RefactorNormalizeCase of hoEditor
        Send PumpMsgQueue of Desktop
        Get Changed_State of hoEditor to bChanged

        Function_Return bChanged
    End_Function

    // *** Type eEditor_Function ***
    Function EditorReIndent String[] ByRef asCode String sParameter Returns Boolean
        Handle hoEditor
        Boolean bOK bChanged
        String[] asRefactoredCode
        tRefactorSettings RefactorSettings

        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Error "phoEditor = 0 (Function: EditorReIndent)"
            Function_Return 0
        End
        // This is automatically set by the _InitTabSize message in cBaseFuncLib
        // when the program is started.
        If (num_arguments > 1) Begin
            Set piTabSize of hoEditor to sParameter
        End

        Set Changed_State of hoEditor to False
        Send RefactorReIndent of hoEditor
        Send GotoLine of hoEditor 0
        Send PumpMsgQueue of Desktop
        Get Changed_State of hoEditor to bChanged

        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
        Boolean bFound bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bIsBlank = True or TokenizerData.bIsComment = True or TokenizerData.sEndComment = "") Begin
            Function_Return False
        End
        Get _IsValidRemoveEndCommentsLine sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get _RemoveComments (&sLine) to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Removes local statement if present.
    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound bVariableDeclaration bLocalVariableArrayDeclaration
        String sText
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get _IsVariableDeclarationLine  of ghoRefactorFuncLib TokenizerData.sOverstrikeLine  to bVariableDeclaration
        Get _IsVariableArrayDeclaration of ghoRefactorFuncLib TokenizerData.sOverstrikeLine to bLocalVariableArrayDeclaration
        If (bVariableDeclaration = False and bLocalVariableArrayDeclaration = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move (LTrim(sLine)) to sText
        Move (Left(sText, 6)) to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_Local) + " ")) Begin
            // local must be the first word on the line.
            // Now find the local statement and remove it.
            Move (Lowercase(sLine)) to sText
            Move (Pos((Lowercase(CS_Local) + " "), sText)) to iPos
            If (iPos > 0) Begin
                Move (Remove(sLine, iPos, 6)) to sLine
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // *** Type: eOther_Function ***
    //  Pass a source file as a string array.
    // Removes consecutive empty blank lines if more than piMaxNoOfEmptyLines.
    // Returns the passed string array but with removed duplicated empty lines.
    Function RemoveMultipleBlankLines String[] ByRef asCode String sParameter Returns Integer
        String[] asCodeOut
        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines
        String sLine
        Boolean bImageStart bImageEnd bMakeImageTest

        Move False to bImageStart
        Move False to bImageEnd
        Move True  to bMakeImageTest
        Move 0 to iCurrentNoOfEmptyLines
        Move sParameter to iMaxNoOfEmptyLines

        Move (SizeOfArray(asCode)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (Trim(asCode[iCount])) to sLine

            If (bMakeImageTest = True) Begin
                If (bImageStart = False and bImageEnd = False) Begin
                    Get _IsImageStart sLine to bImageStart
                End
            End

            If (bImageStart = False and bImageEnd = False) Begin
                If (sLine = "") Begin
                    Increment iCurrentNoOfEmptyLines
                End
                Else Begin
                    Move 0 to iCurrentNoOfEmptyLines
                End
            End
            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
                Move asCode[iCount] to asCodeOut[SizeOfArray(asCodeOut)]
            End

            If (bMakeImageTest = True) Begin
                If (bImageStart = True) Begin
                    Get _IsImageEnd sLine to bImageEnd
                    If (bImageEnd = True) Begin
                        Move False to bImageStart
                        Move False to bImageEnd
                        Move False to bMakeImageTest
                    End
                End
            End
        Loop

        Move (SizeOfArray(asCode) - SizeOfArray(asCodeOut)) to iEmptyLines
        Move asCodeOut to asCode

        Function_Return iEmptyLines
    End_Function

    // *** Type: eStandard_Function ***
    //           Returns True if a legacy IDE (Studio) source code marker is found.
    //           This is a "Remove Type Function".
    Function RemoveOldStudioMarkers String sLine Returns Boolean
        Boolean bFound
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bFound
        Move (Trim(sLine)) to sLine

        Case Begin
            Case (sLine = "//AB-IgnoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-IgnoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-DDOStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-DDOEnd")
                Move True to bFound
                Case Break
            Case (Left(sLine, 6) = "//AB/ ")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-MenuPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-End")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ToolbarPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ViewStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ViewEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StatusBarPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//IDE-FileType=ftApplication")
                Move True to bFound
                Case Break
        Case End

        Function_Return bFound
    End_Function

    // *** Type: eStandard_Function ***
    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
        String[] asObjectNames
        tTokenizer TokenizerData

        Move True to bWriteLine
        Get pTokenizer to TokenizerData
        If (TokenizerData.bIsVariableDeclaration or TokenizerData.bIsInCommand or ;
            TokenizerData.bIsInClass or TokenizerData.bIsInImage or TokenizerData.bIsInFunction or ;
            TokenizerData.bIsInProcedure or TokenizerData.bIsInDF23MultiLineString) Begin
            Function_Return False
        End

        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd
        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
        Get pasObjectNames                to asObjectNames

        If (bRegisterAllObjectsEnd = False) Begin
            If (bRegisterAllObjectsStart = False) Begin
                Get _IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
                Set pbRegisterAllObjectsStart        to bRegisterAllObjectsStart
            End
            If (bRegisterAllObjectsStart = True) Begin
                Get _IsRegisterObjectInArray sLine asObjectNames to bWriteLine
                Move False to bProjectObjectStructureStart
                Set           pbProjectObjectStructureStart to False
            End
            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
                Get _IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
            End
            If (bProjectObjectStructureStart = True) Begin
                Get _IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
            End
            Get _IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
            If (bRegisterAllObjectsEnd = True) Begin
                Send _ResetProjectObjectStructureProperties
                // This means that we won't bother with the rest of the file.
                Set pbRegisterAllObjectsEnd to True
            End
        End
        If (bWriteLine = False) Begin
            Move "" to sLine
        End
        Function_Return (bWriteLine = False)
    End_Function

    // *** Type: eStandard_Function ***
    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // To remove hardcoded MS Sans Serif fonts if present.
    Function RemoveSansSerif String sLine Returns Boolean
        String sTest
        Boolean bWriteLine

        Move False to bWriteLine
        Move (Lowercase(Trim(sLine))) to sTest
        Move (Replaces(" ", sTest, ""))  to sTest
        Move (Replaces("'", sTest, "*")) to sTest
        Move (Replaces('"', sTest, "*")) to sTest
        If (sTest contains 'settypefaceto*mssansserif*') Begin
            Move True to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // *** Type: eStandard_Function ***
    // Removes Studio generated comments:
    //               "// fires when the button is clicked"
    //               "//OnChange is called on every changed character
    //               "// Visual DataFlex xx.x Client Size Adjuster
    //               "// Visual DataFlex xx.x Migration Utility,"
    //               ...and so on
    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
        String sText sComment sComment2
        Boolean bFound bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move (Trim(sLine)) to sText
        If (sText = "" or sText = CS_CommentSymbol or sText contains (CS_CommentSymbol + "AB") or TokenizerData.bIsComment = False) Begin
            Function_Return False
        End

        Move "fires when the button is clicked" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "onchange is called on every changed character" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex"      to sComment
        Move "client size adjuster" to sComment2
        Get _IsStudioGeneratedComment sLine sComment sComment2 to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex"    to sComment
        Move "migration utility," to sComment2
        Get _IsStudioGeneratedComment sLine sComment sComment2 to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "If you set Current_radio you must set this after the" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "radio objects have been created AND after Notify_select_State has been" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "created. i.e. Set in bottom-code at end!!" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Function_Return bChanged
    End_Function

    // *** Type: eStandard_Function ***
    // Remove trailing spaces if present.
    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
        Integer iBefore iAfter
        Boolean bChanged
        tTokenizer TokenizerData

        Move (Length(sLine))     to iBefore
        Move (RTrim(sLine))      to sLine
        Move (Length(sLine))     to iAfter
        Move (iBefore <> iAfter) to bChanged

        Function_Return bChanged
    End_Function

    // *** Type: eOther_Function ***
    // Pass a source file as a string array
    // Removes all unusad locally defined (in Procedures & Functions) for the
    // passed string array. Returns number of removed unused local variables.
    Function RemoveUnusedLocals String[] ByRef asCode String sParameter Returns Integer
        Handle ho
        Integer iRetval

        Get Create (RefClass(cRemoveUnusedLocals)) to ho
        If (ho = 0) Begin
            Error "Could not create cRemoveUnusedLocals object."
            Function_Return 0
        End

        Set piNoOfUnusedLocalVariables of ho to 0
        Get RemoveUnusedLocals of ho (&asCode) to iRetval
        Send Destroy of ho

        Function_Return iRetval
    End_Function

    // *** Type: eReport_Function ***
    // Makes no change to the source code.
    // Pass an array with *all source files*
    Function ReportUnusedSourceFiles String[] ByRef asFiles String sParameter Returns Integer
        Handle ho
        Integer iRetval
        String sLogFile
        String[] asOtherLogFiles
        tRefactorSettings RefactorSettings

        Get Create (RefClass(cUnusedSourceFiles)) to ho
        If (ho = 0) Begin
            Error "Could not create cUnusedSourceFiles object."
            Function_Return 0
        End

        Get pRefactorSettings to RefactorSettings
        Get FindUnusedSourceFiles of ho RefactorSettings.FileData.asFullFileNames to iRetval

        If (iRetval <> 0) Begin
            Get pasOtherLogFiles to asOtherLogFiles
            Get psLogFile of ho to asOtherLogFiles[SizeOfArray(asOtherLogFiles)]
            Set pasOtherLogFiles to asOtherLogFiles
        End
        Send Destroy of ho
        Function_Return iRetval
    End_Function

    // *** Type eOther_FunctionAll ***
    // Pass all source files including path, as a string array.
    //  The naming style of datadictionaries over time has not been constant.
    //  The new style is
    //    Object o<tablename>_DD is a c<TableName>Datadictionary
    //  They also have a switch so you can keep on using the legacy style name which is
    //    Object o<tablename>_DD is a <tablename>_Datadictionary
    //
    //  However before VDF12, the
    //    Object <tableName>_DD is a <tablename>_Datadictionary
    //
    //  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
    //  all over the place. Copying old code into new views/dialogs simply breaks and if your
    //  codebase has mixed styles then the compiler will not catch that.
    //  A code nightmare.
    //
    //  This program allows you to switch between the following code styles:
    //  <TableName>_DD  == eDDOldStyle
    //  TO: o<TableName>_DD == eDDStudioStyle
    Function RestylelDDOs String[] ByRef asFiles String sParameter Returns Integer
        String sHomePath
        Handle ho
        Integer iRetval iSize iCount eDDOStyle
        tRefactorSettings RefactorSettings

        If (SizeOfArray(asFiles) <= 0) Begin
            Function_Return False
        End

        Get Create (RefClass(cDDOReStyler)) to ho
        If (ho = 0) Begin
            Error "Could not create cDDORestyler object (Function: RestyleDDOs)"
            Function_Return 0
        End

        If (num_arguments > 1) Begin
            Move sParameter to eDDOStyle
        End

        // Path for the workspace we are refactoring:

        // ToDo: Check e.g. this code on how to set a temp filelist path etc:
        //  Procedure LoadTablesList Integer iSortBy String sFilter
        // Or perhaps do that in a "Procedure Set psHomePath" of the class??
        Get psHomePath  of ghoApplication to sHomePath
        If (sHomePath = "") Begin
            Get psHome of (phoWorkspace(ghoApplication)) to sHomePath
        End
        Set psHomePath  of ho to sHomePath
        Set peDDOStyle  of ho to eDDOStyle
        Set pasAllFiles of ho to asFiles
        Get StartDDORestyler of ho to iRetval
        Send Destroy of ho

        Function_Return iRetval
    End_Function

    // *** Type: eStandard_Function ***
    // The older version's passed parameters eSplitBy and iTabSize, but the iTabSize was been made into
    // a class property. This way we can have a uniform calling interface for all functions.
    // The eSplitBy is passed as sParamater.
    // Valid sParameter values are;
    { EnumList="{CI_SplitBySpaceAndSemicolon, CI_SplitBySemicolon, CI_SplitToBeginEndBlock}" }
    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
        Boolean bStop bChanged bFound
        Integer iIndent eSplitBy iTabSize iItem
        String  sText
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Move (Trim(sLine)) to sText
            Move (Left(sText, 3)) to sText
            Move (Lowercase(sText) = Lowercase(CS_If)) to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End

        Move False to bChanged
        Move sParameter to eSplitBy
        Get piTabSize to iTabSize
        If (eSplitBy = CI_SplitToBeginEndBlock) Begin
            Move (SearchArray(CS_Begin, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Function_Return False
            End
        End

        Move (LTrim(sLine))     to sText
        Move (Pos(sText,sLine) - 1) to iIndent
        Move (Left(sText, 3))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_If) + " ")) Begin
            Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
            If (bStop = False) Begin
                // It's one of those single line if statements, break it up
                Move (Lowercase(sLine)) to sText
                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
            End
        End
        Else Begin
            Move (LTrim(sLine))     to sText
            Move (Left(sText, 5))   to sText
            Move (Lowercase(sText)) to sText
            If (sText = (Lowercase(CS_Else) + " ")) Begin
                Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
                If (bStop = False) Begin
                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
                End
            End
        End
        Function_Return bChanged
    End_Function

// NOTE: Do *not* add any code after this "End_Class"!
//       It will be removed by the Export/Import logic.
End_Class
