Use cBaseFuncLib.pkg

Class cRefactorFuncLib is a cBaseFuncLib

    Procedure Construct_Object
        Forward Send Construct_Object
    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
    End_Procedure

    // *** External function package(s) must be included here. ***
    // Use this to add your own special function package(s).
// Define CS_Use_MyPackage for "UseMyPackage"
    #IFDEF CS_Use_MyPackage
//        #Include MyRefactorFunctions.pkg
    #ENDIF

    // *** Important ***
    // This *must* be called *once* per source line, *before* any refactor function is called.
    // It calls the Tokenizer function and sets the class property pTokenizer that is to be
    // used by all refactor functions!
    Procedure InitializeTokenizer String sLine
        tTokenizer TokenizerData
        // Note: This function call also sets the pTokenizer property.
        Get Tokenizer sLine to TokenizerData
    End_Procedure

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "Current_Object" to "Self"
    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
        String sStart sStop
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos = 0) Begin
            Function_Return False
        End

        Get _ReplaceLineToken TokenizerData sLine CS_Current_Object CS_Self to sLine
        // Note! We call ourself recursively if there are more than one "current_object".
        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos <> 0) Begin
            Get ChangeCurrent_ObjectToSelf (&sLine) "" to bFound
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData

        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get _IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) TokenizerData.asLineTokensLC to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        While (bFound = True)
            Move (Pos(Lowercase(CS_DfTrue), Lowercase(sLine))) to iPos
            If (iPos > 0) Begin
                Get _ReplaceLineToken TokenizerData sLine CS_DfTrue CS_True to sLine
            End
            Move (iPos > 0) to bFound
            Move (Pos(Lowercase(CS_DfFalse), Lowercase(sLine))) to iPos
            If (iPos > 0) Begin
                Get _ReplaceLineToken TokenizerData sLine CS_DfFalse CS_False to sLine
            End
            If (bFound = False) Begin
                Move (iPos > 0) to bFound
            End
        Loop

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION *** 
    // Changes legacy [Found] and [FindErr] indicator statements.
    // Changes: [Found|Not Found|FindErr|Not FindErr] Command -> e.g. If (Not(Found)) Command
    // Changes: While [Found|Not Found|FindErr|Not FindErr]   -> e.g. While (Not(Found))
    // Changes: [Found|Not Found|FindErr|Not FindErr] While   -> e.g. While (Not(Found))
    //
    Function ChangeLegacyIndicators String ByRef sLine String sParameter Returns Boolean
        String sText sIndicator sEndString sFirstToken sEndComment sNewCode sBoolean sBooleanExpr sCommandLC
        Boolean bChanged bFound bIfStart
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        If (TokenizerData.IndicatorInfo.bHasBracket = False) Begin
            Function_Return False
        End 

        Move sLine to sText
        If (TokenizerData.sEndComment <> "") Begin
            Get _RemoveEndComment sText to sText
        End 
        Move (Lowercase(sText)) to sText

        Move TokenizerData.IndicatorInfo.FirstIndicator.sCode to sBoolean
        Move ("[" + sBoolean + "]") to sIndicator
        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
        Move (iPos <> 0) to TokenizerData.IndicatorInfo.bHasNot 
        If (TokenizerData.IndicatorInfo.bHasNot = False) Begin
            Move ("(" + sBoolean + ")") to sBooleanExpr
        End 
        Else Begin
            Move (Overstrike("####", sBoolean, iPos)) to sBoolean
            Move (Replace("####", sBoolean, "")) to sBoolean
            Move ("(" + CS_Not + "(" + sBoolean + "))") to sBooleanExpr
        End               
        // Does the line start with an "if" statement?
        Get _FirstToken sLine to sFirstToken
        Move (Lowercase(CS_If) = Lowercase(sFirstToken)) to bIfStart
        Move (Lowercase(TokenizerData.FirstLeftCommand.sCode)) to sCommandLC
        
        Case Begin
            Case (sCommandLC = Lowercase(CS_Reread))              
                If (bIfStart = False) Begin
                    Move (CS_If * sBooleanExpr) to sNewCode
                End
                Else Begin
                    Move sBooleanExpr to sNewCode
                End
                Move (Replace(sIndicator, sLine, sNewCode)) to sLine
                Case Break
            Case (sCommandLC = Lowercase(CS_Loop))   
                // If line has an indicator *before* the "Loop" command, remove it.
                If (Lowercase(sIndicator) = Lowercase(sFirstToken)) Begin
                    Move (Replace((sIndicator + " "), sLine, "")) to sLine
                End
                Case Break
            Case (sCommandLC = Lowercase(CS_Until))
                // If line has an indicator *before* the "Until" command, remove it.
                If (Lowercase(sIndicator) = Lowercase(sFirstToken)) Begin
                    Move (Replace((sIndicator + " "), sLine, "")) to sLine  
                    If (TokenizerData.IndicatorInfo.SecondIndicator.sCode <> "") Begin
                        Move (Replace("[", sLine, "(")) to sLine
                        Move (Replace("]", sLine, ")")) to sLine
                    End
                End
                Else Begin
                    Move sBooleanExpr to sNewCode
                    Move (Replace(sIndicator, sLine, sNewCode)) to sLine
                End
                Case Break
            Case (sCommandLC = Lowercase(CS_Repeat))
                // If line has an indicator *before* the "Repeat" command, replace with a "While (Found)" construct.
                If (Lowercase(sFirstToken) contains Lowercase(sIndicator)) Begin
                    Move (Replace((sIndicator + " "), sLine, "")) to sLine
                    Move sBooleanExpr to sNewCode
                    Move (TokenizerData.sIndentation + CS_While * String(sNewCode)) to sLine 
                    If (Length(TokenizerData.sEndComment) <> 0) Begin
                        Append sLine " "  TokenizerData.sEndComment
                    End
                End
                Case Break
            Case (sCommandLC = Lowercase(CS_While))
                // If line has an indicator *before* the "While" command, remove it.
                If (Lowercase(sIndicator) = Lowercase(sFirstToken)) Begin
                    Move (Replace((sIndicator + " "), sLine, "")) to sLine
                End
                If (Lowercase(sFirstToken) contains Lowercase(sIndicator)) Begin
                    If (TokenizerData.sEndComment <> "") Begin
                        Get _RemoveEndComment sLine to sLine
                    End 
                    Append sLine " " sBooleanExpr 
                    If (TokenizerData.sEndComment <> "") Begin
                        Append sLine " " TokenizerData.sEndComment
                    End
                End
                Case Break
            Case Else                                                                
                If (TokenizerData.IndicatorInfo.bHasNot = False) Begin
                    Move (CS_If * "(" + String(sBoolean) + ")") to sNewCode
                End                         
                Else Begin
                    Move (CS_If * "(" + (CS_Not + "(" + sBoolean + "))")) to sNewCode
                End
                If (Lowercase(sFirstToken) contains Lowercase(sBoolean)) Begin
                    Move (Replace(sFirstToken, sLine, sNewCode)) to sLine
                End
        Case End 
        
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes; [Found] Loop --> Loop
    Function ChangeFoundLoopIndicator String ByRef sLine String sParameter Returns Boolean
        tBooleanIndicator BooleanIndicator
        String sText
        Boolean bIsLoopStatement bIsRepeatStatement bFound
        Integer iFoundIndicator iPosLoop
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        If (TokenizerData.IndicatorInfo.FirstIndicator.sCode = "") Begin
            Function_Return False
        End
        Get _IsLoopStatement TokenizerData.sOverstrikeLine to bIsLoopStatement
        If (bIsLoopStatement = False) Begin
            Function_Return False
        End

        Get _IsRepeatStatement TokenizerData.sOverstrikeLine to bIsRepeatStatement
//        Get _ExtractIndicatorContent (&TokenizerData) to BooleanIndicator
        If (bIsRepeatStatement = True) Begin
            // We save the start of a Repeat/Loop in a class property, which gets set to False when a Loop statement is found.
            If (BooleanIndicator.bHasBracket = False) Begin
                Set pbInRepeatLoop to True
                Function_Return False
            End
        End

        // If no indicator e.g. "[Found]" before the Loop command, we're done.
        If (BooleanIndicator.bHasBracket = False) Begin
            Set pbInRepeatLoop to False
            Function_Return False
        End

        If (pbInRepeatLoop(Self) = True) Begin
            Move CS_Until to TokenizerData.FirstLeftCommand.sCode
            Move (String(TokenizerData.FirstLeftCommand.sCode) * String(TokenizerData.sLeftExpression1)) to sText
        End
        Else Begin
            Move CS_Loop to sText
        End
        Move (TokenizerData.sIndentation + String(sText) + String(TokenizerData.OfStatement.sCode * CS_To * String(TokenizerData.ToStatement.sCode) + String(TokenizerData.sEndComment))) to sLine
        Set pbInRepeatLoop to False

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
    // For the function to do anything, the line needs to contain a "GetAddress" command.
    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sText sToVar sOfVar sCommand
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText

        If (TokenizerData.bLineIsReady = True or TokenizerData.bHasEndSemiColon = True) Begin
            Function_Return False
        End

        If (TokenizerData.bIsInFunction = True or TokenizerData.bIsInProcedure = True ) Begin
            Function_Return False
        End

        Get _IsKeywordInLine (CS_GetAddress + "|") TokenizerData.asLineTokensLC to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode)) to sLine
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes e.g. "Indicate Found as True" --> "Move (True) to Found"
    //              "[Select] Indicate Select as Windowindex Eq Fieldindex" --> Move (WindowInex = FieldIndex) to Select
    Function ChangeIndicateFoundToMoveTrueToFound String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis
        String sText sVariable sExpression sIndicate sChar
        Integer iPos
        tTokenizer TokenizerData

        Move False to bChanged

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        If (TokenizerData.IndicatorInfo.bHasIndicateCommand = False) Begin
            Function_Return False
        End

        Move (Ltrim(Lowercase(sText))) to sText
        Move (Pos(" ", TokenizerData.sLine)) to iPos
//        Move (Left(TokenizerData.sCode, (iPos -1))) to sIndicate
//        Move (Pos(" ", TokenizerData.sCode)) to iPos // Indicate (a < b) as False
//        Move (Left(TokenizerData.sCode, (iPos -1))) to sText //   (a < b) as False
//        Move (Replace(sText, TokenizerData.sCode, "")) to TokenizerData.sCode
//        Move (Trim(TokenizerData.sCode)) to TokenizerData.sCode
//        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(TokenizerData.sCode))) to iPos
//        Move (Left(TokenizerData.sCode, (iPos -1))) to sExpression // (a < b)
//        Move (Replace(sExpression, TokenizerData.sCode, "")) to TokenizerData.sCode //  as False
//        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(TokenizerData.sCode))) to iPos
//        Move (Mid(TokenizerData.sCode, Length(TokenizerData.sCode), (iPos + Length(CS_As) + 2))) to sVariable
        Move (Left(sVariable, 1)) to sChar
        Move (sChar = "(") to bIsParanthesis
        If (bIsParanthesis = False) Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + String(sVariable) + ")" * CS_To * String(sExpression) + TokenizerData.sEndComment) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * String(sVariable) * CS_To * String(sExpression) + TokenizerData.sEndComment) to sLine
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes; [Found] Repeat --> While (Found)
    //          [not Seqeof] Repeat --> While (not(Seqeof))
    Function ChangeIndicatorRepeatToWhile String ByRef sLine String sParameter Returns Boolean
        tBooleanIndicator BooleanIndicator
        String sChar sText sBoolean sNot sOrgLine sCode
        Boolean bIsRepeatStatement bFound
        Integer iPosIndicator iPosRepeat iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) <> Lowercase(CS_Repeat)) Begin
            Function_Return False
        End
        If (TokenizerData.IndicatorInfo.FirstIndicator.sCode = "") Begin
            Function_Return False
        End

        Move sLine to sOrgLine
        Move (CS_While * TokenizerData.sLeftExpression1) to sCode
        Move (TokenizerData.sIndentation + String(sCode) + String(TokenizerData.OfStatement.sCode * String(TokenizerData.ToStatement.sCode) + String(TokenizerData.sEndComment))) to sLine

        Function_Return (sLine <> sOrgLine)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes; E.g. [Found] Begin --> If (Found) Begin
    //               [not Seqeof] Begin --> If (not(Seqeof)) Begin
    Function ChangeIndicatorToIfBegin String ByRef sLine String sParameter Returns Boolean
        tBooleanIndicator BooleanIndicator
        String sText sNot sLogical sCode
        Boolean bFound bBegin
        Integer iFoundIndicator iPosBegin iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        Move (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Begin) or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Begin)) to bBegin
        If (bBegin = False) Begin
            Function_Return False
        End
        If (TokenizerData.IndicatorInfo.bHasIndicateCommand = False) Begin
            Function_Return False
        End

        Move sLine to sText
        Move (CS_If * String(TokenizerData.sLeftExpression1)) to sCode
        If (bBegin = True) Begin
            Move (TokenizerData.sIndentation + String(sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + String(sCode) + String(TokenizerData.OfStatement.sCode * CS_To + String(TokenizerData.ToStatement.sCode) * String(TokenizerData.sEndComment))) to sLine
        End

        Function_Return (sLine <> sText)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // ToDo: Needs to be revised!
    // Changes:
    //     [Select] Indicate Select as Windowindex Eq Fieldindex // End comment
    // --> If (Select) Move (Windowindex = Fieldindex) to Select // End comment
    Function ChangeIndicatorToMoveStateToVariable String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis bStartIndicator bFound bIsIfStatement
        String sText sVariable sExpression sIndicator sChar sOrgLine sIfStatement sCommand
        Integer iPos iStart iEnd
        tBooleanIndicator BooleanIndicator
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        If (TokenizerData.bIsInCommand = True) Begin
            Function_Return False
        End
        // While, Repeat, Loop and Until are delt with by other functions.
        Get _HasBeginStatement TokenizerData.sOverstrikeLine to bFound
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Begin) = True or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Begin) = True) Begin
            Function_Return False
        End
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Repeat) = True or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Repeat) = True) Begin
            Function_Return False
        End
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Loop) = True or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Loop) = True) Begin
            Function_Return False
        End
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Until) = True or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Until) = True) Begin
            Function_Return False
        End

        Move False to bChanged
        Move sLine to sText
        Move sLine to sOrgLine
        Get _RetrieveFirstToken TokenizerData.sOverstrikeLine to sIfStatement
        Move (Lowercase(sIfStatement) = Lowercase(CS_If)) to bIsIfStatement
        If (bIsIfStatement = True) Begin
            Move "" to sIfStatement
        End

        If (TokenizerData.IndicatorInfo.bHasBracket = False and TokenizerData.IndicatorInfo.bHasIndicateCommand = False) Begin
            Function_Return False
        End

        // ToDo: Review after the Tokenizer has been finished!
        // There are other function dealing with loop, while & move statements.
        Get _IsRepeatStatement TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _HasBeginStatement TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _IsMoveCommand TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        // ToDo: Review after the tokenizer is finalized!
        // I have commented out several lines below to be able to remove the tBooleanIndicator sCode menber.
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) contains Lowercase(CS_Indicate)) Begin
            Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(TokenizerData.sOverstrikeLine))) to iEnd
            If (iEnd <> 0) Begin
                Move (Pos(Lowercase(CS_Indicate + " "), Lowercase(TokenizerData.sOverstrikeLine))) to iStart
                Move (Left(TokenizerData.sOverstrikeLine, (iStart + Length(CS_Indicate)))) to sText
//                Move (Replace(sText, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
//                Move (Pos(Lowercase(CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
//                Move (Left(BooleanIndicator.sCode, (iPos - 1))) to sIndicator
//                Move (Replace(sIndicator, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
//                Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
//                Move (Mid(BooleanIndicator.sCode, Length(BooleanIndicator.sCode), (iPos + 1 + Length(CS_As)))) to BooleanIndicator.sCode
//                Move (Trim(sIndicator)) to sIndicator
//                Move (String(CS_Move) * Trim(BooleanIndicator.sCode) * CS_To * String(sIndicator)) to BooleanIndicator.sCode
//                Get _HasLegacyOperators BooleanIndicator.sCode to bFound
                If (bFound = True) Begin
                    Move TokenizerData.sLeftExpression1 to sText
                    Get _AddExpressionParenthesis TokenizerData (&sText) to bFound
//                    If (bFound = True) Begin
//                        Move sText to BooleanIndicator.sExpression
//                    End
                End
            End
        End

        If (bIsIfStatement = True) Begin
            Get _RetrieveFirstToken (&TokenizerData) to sCommand
            If (Lowercase(sCommand) = Lowercase(CS_If)) Begin
//                Move (String(TokenizerData.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
            Else Begin
//                Move (String(TokenizerData.sIndentation) + String(CS_If) * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
        End
//        Else If (BooleanIndicator.sExpression <> "" or BooleanIndicator.sCode <> "") Begin
//            If (Left(BooleanIndicator.sExpression, 1) = "(") Begin
//                If (TokenizerData.LeftMostIndicator.sCode <> "") Begin
//                    If (Left(TokenizerData.LeftMostIndicator.sCode, 1) <> "(") Begin
//                        Move ("(" + String(TokenizerData.LeftMostIndicator.sCode) + ")") to TokenizerData.LeftMostIndicator.sCode
//                    End
//                    Move (CS_If * String(TokenizerData.LeftMostIndicator.sCode)) to sLine
//                    Move BooleanIndicator.sCode to sText
//                    Get _AddExpressionParenthesis TokenizerData (&sText) to bFound  // XXXX
//                    If (bFound = True) Begin
//                        Move sText to BooleanIndicator.sCode
//                    End
//                    Move (String(sLine) * String(BooleanIndicator.sCode)) to BooleanIndicator.sCode
//                    Move "" to BooleanIndicator.sExpression
//                End
//                Else Begin
//                    Move (CS_If * String(BooleanIndicator.sExpression)) to sLine
//                    Move (String(TokenizerData.sIndentation) + String(sLine) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
//                End
//            End
//            If (BooleanIndicator.sExpression <> "") Begin
//                Move (String(TokenizerData.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
//            End
//            Else Begin
//                Move (String(TokenizerData.sIndentation) + String(BooleanIndicator.sCode)) to sLine
//            End
//        End

        If (TokenizerData.OfStatement.sCode <> "") Begin
            Move (String(sLine) * CS_Of * String(TokenizerData.OfStatement.sCode)) to sLine
        End
        If (TokenizerData.ToStatement.sCode <> "") Begin
            Move (String(sLine) * CS_To * String(TokenizerData.ToStatement.sCode)) to sLine
        End
        If (TokenizerData.sEndComment <> "") Begin
            Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
        End
        Function_Return (sLine <> sOrgLine)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: Insert "," In sText At 2 --> Move (Inert(",", sText, 2)) to sText
    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentOrBlank bIsReplace
        String sText sStart sStop sVariableName sPlace sChar
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sText
        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End
        Move (Ltrim(sText)) to sText
        Move (Pos(Lowercase(CS_Insert + " "), Lowercase(sText))) to iPos
        If (iPos < 1) Begin
            Function_Return False
        End

        // Also check that the keyword is not part of a variable name:
        Move (Mid(sText, 1, (iPos -1))) to sChar
        If (sChar <> " " and sChar <> "(") Begin
            Function_Return False
        End

        Get _SingleCommandSyntaxToFunction (&sLine) CS_Insert to bChanged
        Get pTokenizer to TokenizerData
        Move (Replace(TokenizerData.sIndentation, sLine, "")) to sLine
        Get _StripConcatenatingSpaces sLine to sLine
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Replace("||||", sLine, ", ")) to sLine
        Move (Mid(sLine, Length(sLine), (iPos + 2))) to sStop
        Move (Pos(" ", sStop)) to iPos
        Move (Left(sStop, (iPos -1))) to sVariableName
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_At + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Replace("||||", sLine, ", ")) to sLine

        Move (TokenizerData.sIndentation + String(sLine) * String(sVariableName)) to sLine
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces 'IN' with 'Contains
    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsPosCommand bIsCommentOrBlank bFound
        String sPattern sOrg
        String sMatched sRemain sHost sSub sText sKeyWord sStart
        tRegexMatch[] myReg
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move sLine to sText
        Move sLine to sOrg
        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sLine to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End

        Move TokenizerData.sOverstrikeLine to sText
        Move (Lowercase(sText)) to sText
        Move (Ltrim(sText)) to sText
        // First check if there is a "In" keyword in the source code.
        Move (Lowercase((" " + CS_In + " "))) to sKeyWord
        If (Pos(sKeyWord, sText) = 0) Begin
            Function_Return False
        End

        // Check for "home cocked" commands; in case we do nothing.
        // If we are in a "Pos", "Insert" or "Replace" command line, we're done.
        Get _IsKeywordInLine (CS_Pos + "|" + CS_Insert + "|" + CS_Replace + "|") TokenizerData.asLineTokensLC to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        If (TokenizerData.OfStatement.sCode <> "") Begin
            Move (TokenizerData.LeftStatement.sCode * CS_Of * String(TokenizerData.OfStatement.sCode)) to sText
        End
        If (TokenizerData.ToStatement.sCode <> "") Begin
            Move (TokenizerData.LeftStatement.sCode * CS_To * String(TokenizerData.ToStatement.sCode)) to sText
        End

        Get _RetrieveFirstToken (&TokenizerData) to sStart
        Move (" " + Lowercase(sStart) + " ") to sStart
        Get _FindCommand (&TokenizerData) sStart to iPos
        If (iPos = 0) Begin
            Get _TestCommandFunctions sStart to iPos
        End
        If (iPos = 0) Begin
            Function_Return False
        End

        Move TokenizerData.sLine to sText
        Move (Replaces('`', '(".*"|`.*`|\S+)\s+in\s+(".*"|`.*`|\S+)', "'")) to sPattern
        Get Regex_Match sText sPattern True to myReg
        If (SizeOfArray(myReg)) Begin
            Move myReg[0].Val to sMatched
            Move (Replaces('`', '(".*"|`.*`|\S+)\s+', "'")) to sPattern
            Get Regex_Match sMatched sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sSub
            Move (Trim(Replace(sSub, sMatched, ''))) to sRemain // Remove the subString
            Move (Remove(sRemain,0 ,2)) to sRemain // Remove the 'In'
            Move (Replaces('`', '\s+(".*"|`.*`|\S+)', "'")) to sPattern
            Get Regex_Match sRemain sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sHost

            Move (Replace(sMatched, sText, ("(" + sHost + ' contains ' + sSub + ")"))) to sLine
            If (Length(TokenizerData.sIndentation)) Begin
                Move (TokenizerData.sIndentation + String(sLine)) to sLine
            End
            If (TokenizerData.OfStatement.sCode <> "") Begin
                Move (String(sLine) * String(CS_Of) * String(TokenizerData.OfStatement.sCode)) to sLine
            End
            If (TokenizerData.ToStatement.sCode <> "") Begin
                Move (String(sLine) * String(CS_To) * String(TokenizerData.ToStatement.sCode)) to sLine
            End
            If (TokenizerData.sEndComment <> "") Begin
                Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
            End
        End

        Function_Return (sLine <> sOrg)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>" for If-Begin lines and While statements.
    // Pass only the code part of a source line.
    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
        String sSource sText sLeftExpression sRightExpression sStart sCommand sFirstChar sLastChar sOrg
        Boolean bFound bChanged
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sText
        Move sLine to sOrg
        Get pTokenizer to TokenizerData
        // Skip line if it is a comment or blank
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon ?? Should we??
        Get _HasLineEndSemiColon TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _IsFirstWord sLine CS_Find to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _IsFirstWord sLine CS_Send to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _IsFirstWord sLine CS_Constrain to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _HasLegacyOperators (&TokenizerData) to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        Move (Lowercase(sText)) to sSource

        Move (Pos(" gt ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" >_ ", sText, iPos)) to sText
            Move (Replace(" >_ ", sText, " > ")) to sText
            Move (Pos(" gt ", sText)) to iPos
        Loop

        Move (Pos(" ge ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" >= ", sText, iPos)) to sText
            Move (Pos(" ge ", sText)) to iPos
        Loop

        Move (Pos(" lt ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <_ ", sText, iPos)) to sText
            Move (Replace(" <_ ", sText, " < ")) to sText
            Move (Pos(" lt ", sText)) to iPos
        Loop

        Move (Pos(" le ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <= ", sText, iPos)) to sText
            Move (Pos(" le ", sText)) to iPos
        Loop

        Move (Pos(" eq ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" =_ ", sText, iPos)) to sText
            Move (Replace(" =_ ", sText, " = ")) to sText
            Move (Pos(" eq ", sText)) to iPos
        Loop

        Move (Pos(" ne ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <> ", sText, iPos)) to sText
            Move (Pos(" ne ", sText)) to iPos
        Loop

        Move (String(sText) <> String(sLine)) to bChanged
        If (bChanged = False) Begin
            Function_Return False
        End

        // For some reason we can get an exception error passing a struct member as
        // a ByRef argument. Just moving to a local variable cures it.
        Move TokenizerData.sOverstrikeLine to sText
        Get _AddExpressionParenthesis TokenizerData (&sText) to bChanged
        If (bChanged = True) Begin
            Move sText to TokenizerData.LeftStatement
        End

        Move (String(TokenizerData.sIndentation + String(TokenizerData.LeftStatement.sCode))) to sLine
        If (TokenizerData.OfStatement.sCode <> "") Begin
            Move (String(sLine) * TokenizerData.OfStatement.sCode) to sLine
        End
        If (TokenizerData.ToStatement.sCode <> "") Begin
            Move (String(sLine) * String(CS_To) * String(TokenizerData.ToStatement.sCode)) to sLine
        End
        If (TokenizerData.sEndComment <> "") Begin
            Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
        End

        Function_Return (sLine <> sOrg)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: "Set Shadow_State [of oObject] to True" -> "Set Enabled_State [of oObject] to False"
    //          "Set Object_Shadow_State [of oObject] to True" -> "Set Enabled_State [of oObject] to False"
    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
        String sToState sText sLineLC
        Boolean bFound bIsComment
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bIsComment
        If (bIsComment = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Object_Shadow_State TokenizerData.asLineTokensLC to bFound
        If (bFound = False) Begin
            Get _IsKeywordInLine CS_Shadow_State TokenizerData.asLineTokensLC to bFound
        End
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Lowercase(sLine)) to sLineLC
        Move (Pos(Lowercase(CS_Object_Shadow_State), sLineLC)) to iPos
        If (iPos <> 0) Begin
            Get _ReplaceLineToken TokenizerData sLine CS_Object_Shadow_State CS_Enabled_State to sLine
        End
        Else Begin
            Move (Pos(Lowercase(CS_Shadow_State), sLineLC)) to iPos
            If (iPos <> 0) Begin
                Get _ReplaceLineToken TokenizerData sLine CS_Shadow_State CS_Enabled_State to sLine
            End
        End

        // We also need to negate any "True" or "False" in the "to" part of the line
        Move TokenizerData.ToStatement.sCode to sToState
        If (Lowercase(sToState) = Lowercase(CS_True) or Lowercase(sToState) = Lowercase(CS_False)) Begin
            Get _IsKeywordInLine CS_True TokenizerData.asLineTokensLC to bFound
            If (bFound = True) Begin
                Move (Pos(Lowercase(CS_True), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_True CS_False to sLine
                End
            End
            Else Begin
                Get _IsKeywordInLine CS_False TokenizerData.asLineTokensLC to bFound
                Move (Pos(Lowercase(CS_False), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_False CS_True to sLine
                End
            End
        End
        // Or any self defined boolean variable at end of line:
        Else Begin
            Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
            // Add "not" keyword
            If (iPos = 0) Begin
                Move (Replace(sToState, sLine, ("(" + CS_Not + "(" + sToState + "))"))) to sLine
            End
            // Remove "not" keyword and its parantheses. Note that it can contain spaces.
            Else Begin
                Move (Replace("(", sToState, "")) to sText
                Move (Replace(CS_Not, sText, "")) to sText
                Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
                Move (Overstrike("   ", sText, (iPos -1))) to sText
                Move (Replace("(", sText, ""))    to sText
                Move (Replace("))", sText, ""))   to sText
                Move (Trim(sText))                to sText
                Move (Pos(Lowercase(sToState), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Move (Left(sLine, (iPos - 1))) to sLine
                    Append sLine " " sText TokenizerData.sEndComment
                End
            End
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sText sStart sStop sVariableName sOrg sFirstWord
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sOrg
        Move sLine to sText
        Get pTokenizer to TokenizerData
        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _IsKeywordInLine (CS_Replace + "|") TokenizerData.asLineTokensLC to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        // If a "#Replace" command line, we're done.
        Move (Pos(("#"+ CS_Replace), TokenizerData.sOverstrikeLine)) to iPos
        If (iPos <> 0) Begin
            Function_Return False
        End

        Move TokenizerData.sOverstrikeLine to sLine
        Move (Lowercase(sLine)) to sText

        Get _RetrieveFirstToken (&TokenizerData) to sFirstWord
        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
            // ToDo: *** !!!!
            Get _RemoveFirstToken sLine to sLine
            Get _RemoveFirstToken sText to sText
        End

        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Mid(sLine, Length(sLine), (iPos + Length(" " + CS_In + " ")))) to sStop
        Move (Pos(" ", sStop)) to iPos
        Move (Left(sStop, (iPos -1))) to sVariableName
        Move (Replace("||||", sLine, ", ")) to sLine
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_With + " "), sText)) to iPos
        Move (Overstrike("||||||", sLine, iPos)) to sLine
        Move (Replace("||||||", sLine, ", ")) to sLine

        Move (CS_Move * "(" + CS_Replace + "(" + String(sLine)) to sLine
//        Get pTokenizer to TokenizerData
//        Get _AddExpressionParenthesis TokenizerData (&sLine) to bChanged
        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
            Move (sLine + "))") to sLine
        End

        Move (TokenizerData.sIndentation + String(sLine) * CS_To * String(sVariableName)) to sLine
        If (TokenizerData.sEndComment <> "") Begin
            Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
        End
        Function_Return (sLine <> sOrg)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes the command "Sysdate4" -> "Sysdate", as the SysDate4 command is obsolete.
    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
        String sText
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData
        tToken Token

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move TokenizerData.FirstLeftCommand to Token
        Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
        If (bFound = False) Begin
            Move TokenizerData.SecondLeftCommand to Token
            Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End

        Move (Replace("4", sLine, "")) to sLine
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Example: Trim sVal to sVal -> Move (Trim(sVal)) to sVal
    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        Integer iItem iPos
        tTokenizer TokenizerData
        String sVarName sKeyword sKeywordLC sLineLC

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Trim TokenizerData.asLineTokensLC to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move CS_Trim              to sKeyword
        Move (Lowercase(CS_Trim)) to sKeywordLC
        Move (Lowercase(sLine))   to sLineLC
        Move (SearchArray(sKeywordLC, TokenizerData.asLineTokensLC)) to iItem
        Move TokenizerData.asLineTokens[iItem + 1] to sVarName
        If (sVarName = "") Begin
            Function_Return False
        End
        Move (Pos(sKeywordLC, sLineLC)) to iPos
        If (iPos <> 0) Begin
            Move (Replace(sKeyword, sLine, "")) to sLine
            Move (Replace(" " + sVarName + " ", sLine, "")) to sLine
            Move (Insert(CS_Move + " (" + CS_Trim + "(" + String(sVarName) + ")) ", sLine, iPos)) to sLine
            Move True to bChanged
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bValid bIgnore
        String sTest sClassName sOldStyle sNewStyle
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move "" to sClassName
        Move (Lowercase(sLine)) to sTest
        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
        Get _StripConcatenatingSpaces sTest to sTest
        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
        If (Pos(" create u_", sTest)) Begin
            Move (Lowercase(sLine)) to sTest
            Move (Pos("u_", sTest)) to iPos
            Get _IsValidClassCharacter sTest iPos to bValid
            While (bValid)
                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
                Increment iPos
                Get _IsValidClassCharacter sTest iPos to bValid
            Loop
        End
        If (sClassName <> "") Begin
            Move True to bChanged
            Move sClassName to sOldStyle
            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
            Move ("(RefClass(" + sClassName + "))") to sNewStyle
            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
        End
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // ToDo: ReDo after Tokenizer has been finalized!
    //       BooleanIndicator.sCode no longer exist.
    // Changes: Until [expression] to Until (expression) and the same for the While command.
    Function ChangeUntilAndWhileIndicators String ByRef sLine String sParameter Returns Boolean
        String sText sCommand sNot
        Boolean bFound
        Integer iPos
        tBooleanIndicator BooleanIndicator
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText
        // Skip line if it is a comment or blank
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon
        Get _HasLineEndSemiColon TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get _HasBeginStatement TokenizerData.sOverstrikeLine to bFound
        If (bFound = False) Begin
            Get _IsUntilStatement TokenizerData.sOverstrikeLine to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End
        If (TokenizerData.IndicatorInfo.bHasBracket = False) Begin
            Function_Return False
        End

//        Move (TokenizerData.sIndentation + String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression) + TokenizerData.sEndComment) to sLine

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        tTokenizer TokenizerData
        Get pTokenizer to TokenizerData
        Get _SingleCommandSyntaxToFunction sLine CS_ZeroString to bChanged
        Function_Return bChanged
    End_Function

    // *** EDITOR FUNCTION ***
    // Pass the *full* source file as a string array
    Function EditorDropSelf String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Move False to Err
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorDropSelf)"
            Function_Return 0
        End
        Send RefactorDropSelf of hoEditor
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** EDITOR FUNCTION ***
    // Wrapper functions for the cScintillaEdit editor
    // Note that a full visible instantiation of the cScintillaEdit class
    // should be used for usage, and the phoEditor property for that
    // object _must_ be set to that editor object id.
    //
    Function EditorNormalizeCase String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorNormalizeCase)"
            Function_Return 0
        End
        Send RefactorNormalizeCase of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** EDITOR FUNCTION ***
    Function EditorReIndent String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorReIndent)"
            Function_Return 0
        End
        Set piTabSize of hoEditor to sParameter
        Send RefactorReIndent of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String  sTestLine sTest
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move (LTrim(sLine)) to sTestLine
        Move (Lowercase(sTestLine)) to sTestLine
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move False to bFound
        // We check both for a space between the key word and the comment _and_
        // comments placed directly after the key word _without_ a space between, aka "end_object//this is a comment"
        //
        // end_class:
        Move (Left(sTestLine, 10)) to sTest
        Move (sTest = Lowercase(CS_EndClass) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 11)) to sTest
            Move (sTest = (Lowercase(CS_EndClass) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_object:
        Move (Left(sTestLine, 11)) to sTest
        Move (sTest = Lowercase(CS_EndObject) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 12)) to sTest
            Move (sTest = (Lowercase(CS_EndObject) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_function:
        Move (Left(sTestLine, 13)) to sTest
        Move (sTest = Lowercase(CS_EndFunction) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 14)) to sTest
            Move (sTest = (Lowercase(CS_EndFunction) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_procedure:
        Move (Left(sTestLine, 14)) to sTest
        Move (sTest = Lowercase(CS_EndProcedure) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 15)) to sTest
            Move (sTest = (Lowercase(CS_EndProcedure) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes local statement if present.
    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sText
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move False to bChanged
        Move (LTrim(sLine)) to sText
        Move (Left(sText, 6)) to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_Local) + " ")) Begin
            // local must be the first word in the line.
            // Now find the local statement in the line and remove it.
            Move (Lowercase(sLine)) to sText
            Move (Pos((Lowercase(CS_Local) + " "), sText)) to iPos
            If (iPos > 0) Begin
                Move (Remove(sLine, iPos, 6)) to sLine
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // *** FULL SOURCE FILE FUNCTION ***
    // Pass the whole source file as a string array.
    // Removes  consecutive empty blank lines if more than piMaxNoOfEmptyLines.
    // Returns the passed string array but with removed duplicated empty lines.
    Function RemoveMultipleBlankLines String[] ByRef asSourceFile String sParameter Returns Integer
        String[] asSourceFileOut
        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines
        String sLine
        Boolean bImageStart bImageEnd bMakeImageTest

        Move False to bImageStart
        Move False to bImageEnd
        Move True  to bMakeImageTest
        Move 0 to iCurrentNoOfEmptyLines
        Move sParameter to iMaxNoOfEmptyLines

        Move (SizeOfArray(asSourceFile)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (Trim(asSourceFile[iCount])) to sLine

            If (bMakeImageTest = True) Begin
                If (bImageStart = False and bImageEnd = False) Begin
                    Get _IsImagePageStartOrEnd sLine True to bImageStart
                End
            End

            If (bImageStart = False and bImageEnd = False) Begin
                If (sLine = "") Begin
                    Increment iCurrentNoOfEmptyLines
                End
                Else Begin
                    Move 0 to iCurrentNoOfEmptyLines
                End
            End
            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
                Move asSourceFile[iCount] to asSourceFileOut[SizeOfArray(asSourceFileOut)]
            End

            If (bMakeImageTest = True) Begin
                If (bImageStart = True) Begin
                    Get _IsImagePageStartOrEnd sLine False to bImageEnd
                    If (bImageEnd = True) Begin
                        Move False to bImageStart
                        Move False to bImageEnd
                        Move False to bMakeImageTest
                    End
                End
            End
        Loop

        Move (SizeOfArray(asSourceFile) - SizeOfArray(asSourceFileOut)) to iEmptyLines
        Move asSourceFileOut to asSourceFile

        Function_Return iEmptyLines
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Returns True if a legacy IDE (Studio) source code marker is found.
    // This is a "Remove Type Function".
    Function RemoveOldStudioMarkers String sLine Returns Boolean
        Boolean bFound
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bFound
        Move (Trim(sLine)) to sLine

        Case Begin
            Case (sLine = "//AB-IgnoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-IgnoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-DDOStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-DDOEnd")
                Move True to bFound
                Case Break

            Case (Left(sLine, 6) = "//AB/ ")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-MenuPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-End")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ToolbarPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ViewStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ViewEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StatusBarPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//IDE-FileType=ftApplication")
                Move True to bFound
                Case Break

        Case End

        Function_Return bFound
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
        Move False to bWriteLine
        String[] asObjectNames
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd
        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
        Get pasObjectNames                to asObjectNames

        If (bRegisterAllObjectsEnd = False) Begin
            If (bRegisterAllObjectsStart = False) Begin
                Get _IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
                Set pbRegisterAllObjectsStart       to bRegisterAllObjectsStart
            End
            If (bRegisterAllObjectsStart = True) Begin
                Get _IsRegisterObjectInArray sLine asObjectNames to bWriteLine
                Move False to bProjectObjectStructureStart
                Set           pbProjectObjectStructureStart to False
            End
            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
                Get _IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
            End
            If (bProjectObjectStructureStart = True) Begin
                Get _IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
            End
            Get _IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
            If (bRegisterAllObjectsEnd = True) Begin
                Send ResetProjectObjectStructureProperties
                // This means that we won't bother with the rest of the file.
                Set pbRegisterAllObjectsEnd to True
            End
        End
        Function_Return bWriteLine
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // To remove hardcoded MS Sans Serif fonts if present.
    Function RemoveSansSerif String sLine Returns Boolean
        String sTest
        Boolean bWriteLine
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bWriteLine
        Move (Trim(TokenizerData.sOverstrikeLine)) to sTest
        Move (Lowercase(sTest)) to sTest
        Move (Replaces(" ", sTest, ""))  to sTest
        Move (Replaces("'", sTest, "*")) to sTest
        Move (Replaces('"', sTest, "*")) to sTest
        If (sTest contains 'settypefaceto*mssansserif*') Begin
            Move True to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes Studio generated comments:
    //               "// fires when the button is clicked"
    //               "//OnChange is called on every changed character
    //               "// Visual DataFlex 14.0 Client Size Adjuster
    //               "// Visual DataFlex 14.0 Migration Utility,"
    //               ...and so on
    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
        String sText sComment
        Boolean bFound bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move sLine to sText
        Get _IsCommentLine sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move "fires when the button is clicked" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "onchange is called on every changed character" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex 14.0 client size adjuster" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex 14.0 migration utility," to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "If you set Current_radio you must set this after the" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "radio objects have been created AND after Notify_select_State has been" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "created. i.e. Set in bottom-code at end!!" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Remove trailing spaces if present.
    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
        Integer iBefore iAfter
        Boolean bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.sEndComment <> "") Begin
            Move (Replace(TokenizerData.sEndComment, sLine, "")) to sLine
            Move True to bChanged
        End
//        Move (Length(sLine))     to iBefore
//        Move (RTrim(sLine))      to sLine
//        Move (Length(sLine))     to iAfter
//        Move (iBefore <> iAfter) to bChanged

        Function_Return bChanged
    End_Function

    // *** FULL SOURCE FILE FUNCTION ***
    // Pass the whole source file as a string array
    // Removes all unusad locally defined (in Procedures & Functions) for the
    // passed string array. Returns number of removed unused local variables.
    Function RemoveUnusedLocals String[] ByRef asSourceFile String sParameter Returns Integer
        Handle ho
        Integer iRetval
        Get phoRemoveUnusedLocals to ho
        If (ho = 0) Begin
            Send UserError "phoRemoveUnusedLocals = 0"
            Function_Return 0
        End
        Get MainProcedure of ho asSourceFile to iRetval
//        If (iRetval > 1) Begin
//            Reread SysFile
//                Add iRetval to SysFile.iCountUnusedLocals
//                SaveRecord SysFile
//            Unlock
//        End

        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
    // This would compile but not work well with the ReplaceCalcWithMoveStatement function.
    // ToDo: Reported by: JJ
    //    Procedure Testing
    //        // Before refactor
    //        String moveStr
    //        String s
    //        Move moveStr to s
    //
    //        // After refactor
    //        String moveStr
    //        String s
    //        Move Move to s
    //    End_Procedure
    Function ReplaceCalcWithMoveStatement String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsIn bIsCommentOrBlank
        String sTest sStart sStop
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move sLine to sTest
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sLine to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End

        Move TokenizerData.sOverstrikeLine to sTest

        // Check if line contains one of the keywords and that none of the keywords are within quotes.
        Get _IsKeywordInLine "calc|moveint|movenum|movereal|movestr|" TokenizerData.asLineTokensLC to bIsIn
        If (bIsIn = False) Begin
            Function_Return False
        End

        Case Begin
            Case (Pos("calc ", sTest))
                Move (Pos("calc ", sTest))         to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("moveint ", sTest))
                Move (Pos("moveint ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movenum ", sTest))
                Move (Pos("movenum ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movereal ", sTest))
                Move (Pos("movereal ", sTest))     to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movestr ", sTest))
                Move (Pos("movestr ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break
        Case End

        Function_Return bChanged
    End_Function

    // *** REPORT FUNCTION ***
    // Makes no change to the source code.
    // Pass an array with *all source files*
    Function ReportUnusedSourceFiles String[] ByRef asSourceFiles String sParameter Returns Integer
        Handle ho
        String sFilter
        Integer iRetval
        tRefactorSettings RefactorSettings

        Get phoReportUnusedSourceFiles to ho
        If (ho = 0) Begin
            Function_Return 0
        End

        Get pRefactorSettings to RefactorSettings
        Set psFileFilter  of ho to RefactorSettings.sFileFilter
//        Set pasAllFolders of ho to RefactorSettings.asFolderNames
// ToDo: *** Change interface!!! ***
//        Set pasSourceFiles of ho to asSourceFiles
Function_Return 0

        Send DoProcess    of ho

        Get piNoOfUnusedSourceFiles of ho to iRetval
        Reread SysFile
            Move iRetval to SysFile.iCountUnusedSourceFiles
            SaveRecord SysFile
        Unlock
        Function_Return iRetval
    End_Function

    // *** ALL SOURCE FILES FUNCTION ***
    // Pass the all source files as a string array, including path.
    //  The naming style of datadictionaries over time has not been constant.
    //  The new style is
    //    Object o<tablename>_DD is a c<TableName>Datadictionary
    //  They also have a switch so you can keep on using the legacy style name which is
    //    Object o<tablename>_DD is a <tablename>_Datadictionary
    //
    //  However before VDF12, the
    //    Object <tableName>_DD is a <tablename>_Datadictionary
    //
    //  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
    //  all over the place. Copying old code into new views/dialogs simply breaks and if your
    //  codebase has mixed styles then the compiler will not catch that.
    //  A code nightmare.
    //
    //  This program allows you to switch between the following code styles:
    //  <TableName>_DD  == eDDOldStyle
    //  TO: o<TableName>_DD == eDDStudioStyle
    Function RestylelDDOs String[] ByRef asSourceFile String sParameter Returns Integer
        String sHomePath
        Handle ho
        Integer iRetval iSize iCount
        tRefactorSettings RefactorSettings
        tsSearchResult[] asAllSourceFiles
        String[] asFilesArray

        // ToDo: This needs to be available for the unit tester as well.
        Get phoDDOReStyler to ho
        If (ho = 0) Begin
            Send UserError "phoDDORestyler = 0"
            Function_Return 0
        End

        Get psHomePath of ghoApplication to sHomePath
        Get pRefactorSettings to RefactorSettings
        Get AllSourceFiles of ghoApplication RefactorSettings.asFolderNames RefactorSettings.sFileFilter to asAllSourceFiles

        Set psHomePath of ho to sHomePath
        Set peDDOStyle of ho to RefactorSettings.eDDOStyle
        Move (SizeOfArray(asAllSourceFiles)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asAllSourceFiles[iCount].sFilename to asFilesArray[SizeOfArray(asFilesArray)]
        End
        Set pasAllSourceFiles of ho to asFilesArray

        Get MainDDORestyler of ho to iRetval
        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // The older version's passed parameters; eSplitBy and iTabSize has been made into
    // class properties. This way we can have a uniform calling interface for all functions.
    // The two user selected values can be found in Sysfile.
    // Valid sParameter values;
    //    CI_SplitWithSpaceAndSemicolon
    //    CI_SplitWithSemicolon
    //    CI_SplitAddBeginEndBlock
    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
        Boolean bStop bChanged
        Integer iIndent eSplitBy iTabSize
        String  sText
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        // ToDo: *** Make this into a class property, set before refactoring starts!
        //           This is not something that is changed during the run of a refactoring process.
        // We need to get a second parameter; the tab-size:

        Move False to bChanged
        Move sParameter to eSplitBy
        Get piTabSize to iTabSize

        Move (LTrim(sLine))     to sText
        Move (Pos(sText,sLine) - 1) to iIndent
        Move (Left(sText, 3))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_If) + " ")) Begin
            Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
            If (bStop = False) Begin
                // It's one of those single line if statements, break it up
                Move (Lowercase(sLine)) to sText
                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
            End
        End
        Else Begin
            Move (LTrim(sLine))     to sText
            Move (Left(sText, 5))   to sText
            Move (Lowercase(sText)) to sText
            If (sText = (Lowercase(CS_Else) + " ")) Begin
                Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
                If (bStop = False) Begin
                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
                End
            End
        End
        Function_Return bChanged
    End_Function

// NOTE: Do *not* add any code after this "End_Class"!
//       It will be removed by the Export/Import logic.
End_Class
