/* Copyright (c) 2018 Nils Svedmyr, RDC Tools International

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to Do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in All
 copies or substantial portions of the Software.

 THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
 IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
 FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
 LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
 OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
 SOFTWARE.

     
     About this class:
        NOTE: Code refactoring functions were moved to object package: oRefactorFunclib.pkg

        To add a function for that package, two things are needed:
     1) Add the code as a function to the oRefactorFuncLib.pkg object package,
        with the same parameters as the existing functions are using.
     2) Register the function using meta-tags. See the functions in the
        oRefactorFuncLib.pkg file for samples.
        There you can also learn more about different types of functions and
        their requested parameters.
     3) (Optional). If you need to include your own personal refactoring functions,
                    add them to the 'UserDefinedRefactorFunctions.inc'. The file
                    is included by the oRefactorFuncLib object file.
*/
Use cBaseFuncLib.pkg
Use cFunctionsDataDictionary.dd

{ Visibility = Private }
{ Description = "Helper function for the Procedure RegisterInterface." }
{ Description += "Made into global function to be used in Case expressions." }
Function IsMetaTag Global String sMetaTag Integer eTagType Returns Boolean
    Boolean bFound
    
    Move (Trim(Lowercase(sMetaTag))) to sMetaTag
    Move (Replaces(" ", sMetaTag, "")) to sMetaTag
    
    Case Begin
        Case (eTagType = eMethodType)
            Move (sMetaTag contains "{methodtype=") to bFound
            Case Break
        Case (eTagType = eSummaryText)
            Move (sMetaTag contains "{summarytext=") to bFound
            Case Break
        Case (eTagType = eEnumList)
            Move (sMetaTag contains "{enumlist=") to bFound
            Case Break
        Case (eTagType = eInitValue)
            Move (sMetaTag contains "{initialvalue=") to bFound
            Case Break
        Case (eTagType = eHelpTopic)
            Move (sMetaTag contains "{helptopic=") to bFound
            Case Break
        Case Else
            Move False to bfound
    Case End
    
    Function_Return bFound
End_Function
    

Class cRefactorFuncLib is a cBaseFuncLib

    Procedure Construct_Object
        Forward Send Construct_Object

        { Visibility = Public }
        { MethodType = Property }
        { Description = "Struct array containing all function names and info associated with those functions." }
        { Description = "Set by the RegisterInterface procedure." }
        Property tFuncLib[] pFuncLibArray
    End_Procedure

    Procedure End_Construct_Object
        Handle hoDD
        tFuncLib[] FuncLibArray

        Forward Send End_Construct_Object
        // Init class interface
        Send _AddAllKeyWords
        Send _InitializeFuncLib

        // Update Functions table with meta-tag data.
        Get Create (RefClass(cFunctionsDataDictionary)) to hoDD
        Get pFuncLibArray to FuncLibArray
        Send UpdateDataFromMetaTags of hoDD FuncLibArray
        Send Destroy of hoDD
        Set pFuncLibArray to FuncLibArray
    End_Procedure

    Procedure PRIVATE_MESSAGES // For the Studio's Code Explorer
    End_Procedure

    { Visibility = Private }
    { Description  = "Collects data for all functions from the oRefactorFuncLib object." }
    { Description += "Saves the data in the pFuncLibArray struct array property." }
    Procedure RegisterInterface Handle hMsg String sMsgName String sParams String sComment
        Handle hNewTest       
        String sReturnType
        tFuncLib   FuncLib
        tFuncLib[] FuncLibArray
        tFuncParam[] FuncParamArray
        tFuncEnumList FuncEnumList
        
        If (Left(sMsgName, 4) = "msg_") Begin
            Move (Replace("msg_", sMsgName, "")) to sMsgName
        End
        If (Left(sMsgName, 4) = "get_") Begin
            Move (Replace("get_", sMsgName, "")) to sMsgName
        End
        
        If (sComment = "") Begin 
            // This is considered to be a fatal error:
            Error DFERR_PROGRAM "Library Function's meta tag '{ Description}' missing! Program will now Exit!"
            Send Exit_Application
        End

        Get ParseComment sComment to FuncLib

        If (sParams <> "") Begin
            Get ParseParams sParams (&sReturnType) to FuncParamArray
            Move FuncParamArray to FuncLib.FuncParamArray 
            Move sReturnType    to FuncLib.sReturnType
        End
        
        Get pFuncLibArray to FuncLibArray
        Move sMsgName     to FuncLib.sName
        Move FuncLib      to FuncLibArray[-1] 
        Set pFuncLibArray to FuncLibArray
    End_Procedure
    
    { Visibility = Private }
    { Description = "Helper function for the Procedure RegisterInterface." }
    Function ParseParams String sParams String ByRef sReturnType Returns tFuncParam[]
        tFuncParam[] FuncParamArray
        String[] asParams
        Integer iCount iSize iParam

        Move 0 to iParam
        Move (StrSplitToArray(sParams, " ")) to asParams
        Move (SizeOfArray(asParams)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            If (Lowercase(asParams[iCount]) = "returns") Begin
                Increment iCount
                Move asParams[iCount] to sReturnType
                Move iSize to iCount // Get out of here.
            End
            Else Begin
                Move asParams[iCount] to FuncParamArray[iParam].sType
                Increment iCount
                If (Lowercase(asParams[iCount]) = "byref") Begin
                    Move True to FuncParamArray[iParam].bByRef
                    Increment iCount
                End
                Move asParams[iCount] to FuncParamArray[iParam].sVarName 
                Increment iParam
            End
        Loop    
        Function_Return FuncParamArray
    End_Function 
    
    { Visibility = Private }
    { Description = "Helper function for the Procedure RegisterInterface." }
    Function ParseComment String sComment Returns tFuncLib
        tFuncLib FuncLib
        tFuncEnumList FuncEnumList
        String[] asComments asEnumList
        String sFunctionType sInitialValue sSummaryText
        Integer iSize iCount iItem i iPos
        Boolean bIsMultiLine bFound
        
        Get IsMultiLineComment sComment to bIsMultiLine
        If (bIsMultiLine = False) Begin
            Move sComment to FuncLib.sHelp
            Function_Return FuncLib
        End 
        
        Get ParseHelpText sComment to FuncLib.sHelp
        If (FuncLib.sHelp <> "") Begin
            Move (Replace(FuncLib.sHelp, sComment, "")) to sComment
        End
        
        Move (StrSplitToArray(sComment, CS_CRLF)) to asComments
        Move (SizeOfArray(asComments)) to iSize 
        Decrement iSize
        
        For iCount from 0 to iSize
            Case Begin
                Case (IsMetaTag(asComments[iCount], eMethodType) = True)
                    Get ParseVariable asComments[iCount] to sFunctionType
                    Move sFunctionType to FuncLib.eFunctionType
                    Case Break 
                
                Case (IsMetaTag(asComments[iCount], eSummaryText) = True)
                    Get ParseVariable asComments[iCount] to sSummaryText
                    Move sSummaryText to FuncLib.sSummary
                    Case Break
                    
                Case (IsMetaTag(asComments[iCount], eEnumList) = True)
                    Get ParseEnumList asComments[iCount]             to FuncEnumList.asEnumList
                    Move (SizeOfArray(FuncEnumList.asEnumList) <> 0) to FuncLib.bFuncEnumList
                    Case Break
                    
                Case (IsMetaTag(asComments[iCount], eInitValue) = True)
                    Get ParseVariable asComments[iCount] to sInitialValue
                    Move sInitialValue to FuncEnumList.sInitialValue
                    Case Break
                    
                Case (IsMetaTag(asComments[iCount], eHelpTopic) = True)
                    Get ParseHelpTopic iCount asComments to FuncEnumList.sParamHelp 
                    Move iSize to iCount // We are out of the loop...
                    Case Break
            Case End
        Loop
                
        Move FuncEnumList to FuncLib.FuncEnumList
        Function_Return FuncLib
    End_Function 
    
    { Visibility = Private }
    { Description = "Helper function for the Procedure RegisterInterface." }
    Function ParseVariable String sVariableValue Returns String
        Integer iPos
        
        Move (Pos("=", sVariableValue)) to iPos
        Move (Mid(sVariableValue, Length(sVariableValue), (iPos +1))) to sVariableValue
        Move (Trim(Replace("}", sVariableValue, ""))) to sVariableValue
        
        Function_Return sVariableValue
    End_Function
    
    { Visibility = Private }
    { Description = "Helper function for the Procedure RegisterInterface." }
    Function IsMultiLineComment String sComment Returns Boolean
        Boolean bOK
        String sMetaTagMulti
        
        Move (sComment contains '{' and sComment contains '}') to bOK
        Function_Return bOK
    End_Function
    
    { Visibility = Private }
    { Description  = "Helper function for the Procedure RegisterInterface." }
    { Description += "This will make sure that no formatting is lost for the Help text." }
    { Description += "Else the StrSplitToArray would remove how the help text is written," }
    { Description += "for a { Description = meta-tag for a function." }
    Function ParseHelpText String sComment Returns String
        String sHelpText
        Integer iPos
        
        Move "" to sHelpText
        Move (Pos('{', sComment)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sComment, (iPos -1))) to sHelpText    
        End
        
        Function_Return sHelpText
    End_Function
    
    { Visibility = Private }
    { Description = "Helper function for the Procedure RegisterInterface." }
    Function ParseEnumList String sEnumList Returns String[]
        String[] asEnumList
        Integer iSize iCount iPos
        
        Move (Pos("=", sEnumList)) to iPos
        Move (Mid(sEnumList, Length(sEnumList), (iPos +1))) to sEnumList
        Move (Trim(Replace("}", sEnumList, ""))) to sEnumList
        Move (StrSplitToArray(sEnumList, ",")) to asEnumList
        Function_Return asEnumList
    End_Function
    
    { Visibility = Private }
    { Description = "Helper function for the Procedure RegisterInterface." }
    Function ParseHelpTopic Integer iStart String[] asComments Returns String
        String sParamHelp sText
        Integer iSize iCount iPos
        
        Move "" to sParamHelp
        Move (SizeOfArray(asComments)) to iSize
        Decrement iSize
        For iCount from iStart to iSize
            Move asComments[iCount] to sText
            Move (Pos("=", sText)) to iPos
            If (iPos <> 0) Begin
                Move (Mid(sText, Length(sText), (iPos +1))) to sText
                Move (Trim(Replace("}", sText, ""))) to sText
            End
            Append sParamHelp sText
        Loop 
        Move (Replaces("\n", sParamHelp, CS_CRLF)) to sParamHelp 
        Function_Return sParamHelp
    End_Function
    
    Procedure PUBLIC_MESSAGES // For the Studio's Code Explorer
    End_Procedure

    Procedure ClearFuncLibProperties
        tTokenizer TokenizerDataEmpty
        Send _ClearRefactoringProperties
        Send ClearProjectObjectStructureProperties
        Set pTokenizer to TokenizerDataEmpty
    End_Procedure
        
    Function ReplaceAllLegacyOperators String sOverStrikeLine Returns String
        Get _ReplaceLegacyOperators sOverStrikeLine "lt" "<"  to sOverStrikeLine
        Get _ReplaceLegacyOperators sOverStrikeLine "le" "<=" to sOverStrikeLine
        Get _ReplaceLegacyOperators sOverStrikeLine "eq" "="  to sOverStrikeLine
        Get _ReplaceLegacyOperators sOverStrikeLine "ne" "<>" to sOverStrikeLine
        Get _ReplaceLegacyOperators sOverStrikeLine "gt" ">"  to sOverStrikeLine
        Get _ReplaceLegacyOperators sOverStrikeLine "ge" ">=" to sOverStrikeLine  
        Function_Return sOverStrikeLine
    End_Function
        
    Procedure ClearProjectObjectStructureProperties
        String[] asObjectNames
        Set pbProjectObjectStructureStart to False
        Set pbProjectObjectStructureEnd   to False
        Set pbRegisterAllObjectsStart     to False
        Set pbRegisterAllObjectsEnd       to False
        Set pasObjectNames                to asObjectNames
    End_Procedure

    // Used by the SplitInlineIfElseLine function.
    Function IsLineEndSemiColonOrBegin String sLine Returns Boolean
        Boolean bFound

        Get _HasLineEndSemiColon sLine to bFound
        If (bFound = False) Begin
            Move (Trim(Lowercase(sLine))) to sLine
            If (Right(sLine, 5) = "begin") Begin
                Move True to bFound
            End
        End
        Function_Return bFound
    End_Function

    Function IsStudioGeneratedComment String sLine String sComment String sComt2 Returns Boolean
        String sText sComment2
        Boolean bFound
        
        If (num_arguments > 2) Begin
            Move sComt2 to sComment2
        End
        Move (Trim(Lowercase(sLine))) to sText

        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
            Function_Return True
        End
        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment)) and sComment2 = "") Begin
            Function_Return True
        End
        Else If (sComment2 <> "") Begin
            Move (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) to bFound
            If (bFound = True) Begin
                Move (sText contains (" " + Lowercase(sComment2))) to bFound
                Function_Return bFound
            End
        End

        Function_Return False
    End_Function

    // helper function for IsKeywordInLine, when a keyword is found in a string declaration
    Function RemoveStringsFromLine String sLine Returns String
        Integer iLength iPos
        Boolean bSep1 bSep2
        String  sChar sSep1 sSep2 sReturn

        Move False to bSep1
        Move False to bSep2
        Move "'" to sSep1
        Move '"' to sSep2
        Move ""  to sReturn
        Move (Length(sLine)) to iLength

        For iPos from 1 to iLength
            Move (Mid(sLine, 1, iPos)) to sChar
            If (bSep1 = False and bSep2 = False) Begin
                If (sChar = sSep1) Begin
                    Move True to bSep1
                End
                Else If (sChar = sSep2) Begin
                    Move True to bSep2
                End
                If (bSep1 = False and bSep2 = False) Begin
                    Move (sReturn + sChar) to sReturn
                End
            End
            Else Begin
                If (bSep1) Begin
                    If (sChar = sSep1) Begin
                        Move False to bSep1
                    End
                End
                Else If (bSep2) Begin
                    If (sChar = sSep2) Begin
                        Move False to bSep2
                    End
                End
            End
        Loop

        Function_Return sReturn
    End_Function

    // Helper function for the SplitInlineIfElseLine function.
    {Visibility = Private}
    Function BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
        Boolean bChanged
        Integer iPos
        String  sLineIndent sIndent sLine1 sLine2 sTest
        tTokenizer TokenizerData

        // We need to get fresh tokenizer data here.
        Get Tokenizer sLine to TokenizerData
                    
        Move False to bChanged
        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
        Move (Repeat(" ", iLineIndent)) to sLineIndent
        Move (Lowercase(TokenizerData.sOverstrikeLine)) to sTest
        Move (TokenizerData.sIndentation + String(sTest)) to sTest
        Get _TestCommands sTest to iPos 
        
        If (iPos <> 0) Begin
            Move True to bChanged
            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitBySemiColumn) Begin
                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitByBeginEnd) Begin
                Move (Insert(" Begin" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
            End

            // Remove any spaces before the point on which we break the line
            Move (Left(sLine, iPos - 1)) to sLine1
            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
            Move (RTrim(sLine1)) to sLine1
            Move (sLine1 + sLine2) to sLine
        End
        Function_Return bChanged
    End_Function

    Function RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
        Boolean bChanged
        String sText
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move (LTrim(sLine))     to sText
        Move (Left(sText, 9))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = "property ") Begin
            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
            If (iPos = 0) Begin // if there's a tab char instead of a space then..
                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
            End
            If (iPos > 0) Begin
                Get ReplaceLineToken TokenizerData sLine sPubPriv "" to sLine
                Move True to bChanged
            End
        End
        Move (Rtrim(sLine)) to sLine
        Function_Return bChanged
    End_Function

    Function IsRegisterAllObjectsEnd String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        String sFirstWord

        Move False to bFound
        Move (Lowercase(sLine)) to sLine
        Move (Trim(sLine)) to sLine
        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
            Move (Pos(" ", sLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sLine, (iPos -1))) to sFirstWord
                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
            End 
        End
        Function_Return bFound
    End_Function

    Function IsProjectObjectStructureLine String sOverstrikeLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine
        Integer iPos iSize
        String sLine sObjectName

        Move sOverstrikeLine to sLine
        Move (Trim(sLine)) to sLine
        Move True to bWriteLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Lowercase(sLine)) to sLine
            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
            If (bWriteLine = False) Begin
                Move (SizeOfArray(asObjectNames)) to iSize
                Move (Pos(" is a", sLine)) to iPos
                Move (Left(sLine, (iPos -1))) to sObjectName
                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
                Move (Trim(sObjectName)) to sObjectName
                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
                Set pasObjectNames            to asObjectNames
            End
        End
        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
            Move False to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    Function IsProjectObjectStructureStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterObjectInArray String sOverstrikeLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine bRegisterObjectStart
        Integer iPos

        Move False to bWriteLine
        Get IsRegisterAllObjectsStart sOverstrikeLine to bRegisterObjectStart
        If (bRegisterObjectStart = False) Begin
            Move (Lowercase(sOverstrikeLine)) to sOverstrikeLine
            Move (Replace(Trim(Lowercase(CS_RegisterObject)), sOverstrikeLine, "")) to sOverstrikeLine
            Move (Trim(sOverstrikeLine)) to sOverstrikeLine
            Move (SearchArray(sOverstrikeLine, asObjectNames)) to iPos
            Move (iPos = -1) to bWriteLine
        End

        Function_Return bWriteLine
    End_Function

    Function IsRegisterAllObjectsStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
        Function_Return bFound
    End_Function

    // Old DF syntax that used "pages", e.g. "/MyPage"
    Function IsImageStart String sLine Returns Boolean
        Boolean bIsImageStart
        Integer iPos
        String sChar

        Move False to bIsImageStart
        Move (Pos(CS_ImageNameStart, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Mid(sLine, 1, 2)) to sChar
            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsImageStart
        End

        Function_Return bIsImageStart
    End_Function

    // Old DF syntax that used "pages". To mark end of a page these two characters were used: "/*"
    Function IsImageEnd String sLine Returns Boolean
        Boolean bFound
        Move (Pos(CS_ImageNameEnd, sLine) = 1) to bFound
        Function_Return bFound
    End_Function

    // It is assumed that the sWord is neither blank or part of a comment or text constant.
    // Check if the "sWord" is a local variable declaraction *array* (exist in pasLocalVariableTypes)
    Function IsVariableArrayDeclaration String sOverstrikeLine Returns Boolean
        Boolean bFound
        String[] asLocalVariableArrayTypes
        Integer iItem iPos
        String sVariableType

        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
        Move (Trim(Lowercase(sOverstrikeLine))) to sOverstrikeLine

        Move (sOverstrikeLine = Lowercase(CS_Local)) to bFound
        If (bFound = False) Begin
            Move (sOverstrikeLine = "global_variable") to bFound
        End
        If (bFound = False) Begin
            Move (Pos(" ", sOverstrikeLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sOverstrikeLine, (iPos -1))) to sVariableType
            End
            Move (SearchArray(sVariableType, asLocalVariableArrayTypes)) to iItem
            Move (iItem <> -1) to bFound
        End
        Function_Return bFound
    End_Function

    Function IsVariableDeclarationLine String sOverstrikeLine Returns Boolean
        Boolean bVariableDeclaration
        String[] asLocalVariableTypes asLocalVariableArrayTypes
        Integer iRetval
        String sFirstWord

        Move False to bVariableDeclaration
        Get pasLocalVariableTypes      to asLocalVariableTypes
        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes

        Get _RetrieveFirstToken sOverstrikeLine to sFirstWord
        Move (Lowercase(sFirstWord)) to sFirstWord
        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
        If (iRetval <> -1) Begin
            Move True to bVariableDeclaration
        End
        Else Begin
            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
            If (iRetval <> -1) Begin
                Move True to bVariableDeclaration
            End
            Else Begin
                Move (sFirstWord = Lowercase(CS_Local)) to bVariableDeclaration
            End
        End

        Function_Return bVariableDeclaration
    End_Function

    Function IsValidRemoveEndCommentsLine String sLine Returns Boolean
        String sText
        Boolean bFound
        
        Move (Trim(Lowercase(sLine))) to sText
        Move (sText contains Lowercase(CS_EndClass)) to bFound
        If (bFound = False) Begin
            Move (sText contains Lowercase(CS_EndObject)) to bFound
        End
        If (bFound = False) Begin
            Move (sText contains "cd_end_object") to bFound
        End
        If (bFound = False) Begin
            Move (sText contains Lowercase(CS_EndFunction)) to bFound
        End
        If (bFound = False) Begin
            Move (sText contains Lowercase(CS_EndProcedure)) to bFound
        End
        
        Function_Return bFound    
    End_Function
    
    // Tests if the lowercase character passed in sLine on position iPos is
    // a valid character for a class name
    Function IsValidClassCharacter String sOverstrikeLine Integer iPos Returns Boolean
        Boolean bIsValid
        String  sChar
        Move False to bIsValid
        Move (Mid(sOverstrikeLine, 1, iPos)) to sChar
        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
            Move True to bIsValid
        End
        Function_Return bIsValid
    End_Function

    Function RemoveComments String ByRef sLine Returns Boolean
        Boolean bRemoved
        Integer iPos

        Move False to bRemoved
        Move sLine to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, iPos - 1)) to sLine
            Move (Rtrim(sLine)) to sLine
            Move True to bRemoved
        End
        Function_Return bRemoved
    End_Function

    // Takes an sOverstrikeLine line as parameter plus a tTokenizer struct.
    // Returns a string with all overstriked values replaced with the original content.
    Function RestoreOverstrikeLineValues String sOverstrikeLine tTokenizer TokenizerData Returns String
        Boolean bFound
        Integer iSize iCount iPos
        
        Move (SizeOfArray(TokenizerData.asStringConstant)) to iSize
        If (iSize = 0) Begin
            Function_Return sOverstrikeLine
        End                   
        
        Decrement iSize
        For iCount from 0 to iSize
            Move (Pos(TokenizerData.asStringConstant[iCount].sOverwrite, sOverstrikeLine)) to iPos
            If (iPos <> 0) Begin
                Move (Replace(TokenizerData.asStringConstant[iCount].sOverwrite, sOverstrikeLine, TokenizerData.asStringConstant[iCount].sContent)) to sOverstrikeLine
            End
        Loop
        Function_Return sOverstrikeLine
    End_Function 
    
    // The usage of legacy indicator variables, sometimes was combined with some
    // strange programming styles. Amongst them are to apply square bracket indicators,
    // before 'Loop' and 'Repeat'(!)
    // Returns: If 'Loop', returns just the 'Loop' command.
    //          If 'Repeat', changes 'Repeat' to 'While' and moves the expression to 
    //          the right of the command.
    Function FixIndicatorsLoopRepeatCommand String sOverstrikeLine Returns String
        Integer iPos
        String sExpression
        
        Move (Pos(Lowercase(CS_Loop), Lowercase(sOverstrikeLine))) to iPos
        If (iPos <> 0) Begin
            Move CS_Loop to sOverstrikeLine
        End
        Else Begin
            Move (Pos(Lowercase(CS_Repeat), Lowercase(sOverstrikeLine))) to iPos
            If (iPos <> 0) Begin
                Move (Left(sOverstrikeLine, (iPos -1))) to sExpression
                Move (CS_While * Trim(sExpression)) to sOverstrikeLine    
            End
        End
        
        Function_Return sOverstrikeLine
    End_Function
    
    // Samples:
    //   [FindErr], [Not Found], [~MyVar], [Found ~Found]
    // Returns:
    //   (FindErr), (not(Found)), (Not(MyVar)) (Found and Not(Found))  
    Function ConvertBracketIndicatorsToExpression Integer iLeftBracketNo tTokenizer TokenizerData Returns String
        String sToken sExpression
        Integer iPos iSize iCount iItem iLineTokensCount iItemTo iItemAs
        Boolean bHasBrackets bHasTo bHasAs
        
        Get _IsIndicatorStatement TokenizerData.sOverstrikeLine to bHasBrackets
        If (bHasBrackets = False) Begin
            Function_Return ""
        End
        Move (SearchArray("to", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItemTo
        Move (SearchArray("as", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItemAs
        
        Move 0 to iLineTokensCount
        // iLeftBracketNo is 1 based
        Decrement iLeftBracketNo
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move TokenizerData.asLineTokens[iCount] to sToken
            If (Left(sToken, 1) = "[" and iCount = iLeftBracketNo) Begin
                Move iCount to iLineTokensCount 
                Move iSize to iCount // We're out of here.
            End
        Loop
        Move (iItemTo <> -1 and iLineTokensCount >= iItemTo and iLineTokensCount <= iItemAs) to bHasTo
        Move (iItemAs <> -1 and iLineTokensCount >= iItemAs) to bHasAs
        
        Move "" to sExpression    
        If (bHasTo = False and bHasAs = False) Begin
            
            If (TokenizerData.BooleanIndicator.FirstBoolean.bHasBracket = True) Begin
                If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
                    Append sExpression CS_Not "("
                End
                Append sExpression TokenizerData.BooleanIndicator.FirstBoolean.sCode
                If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
                    Append sExpression ")"
                End
            End
    
            If (TokenizerData.BooleanIndicator.SecondBoolean.bHasBracket = True) Begin
                Append sExpression " and "
                If (TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True) Begin
                    Append sExpression CS_Not "("
                End
                Append sExpression TokenizerData.BooleanIndicator.SecondBoolean.sCode
                If (TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True) Begin
                    Append sExpression ")"
                End
            End 
        End
        Else If (bHasTo = True) Begin
            If (TokenizerData.BooleanIndicator.ToBoolean.bHasBracket = True) Begin
                If (TokenizerData.BooleanIndicator.ToBoolean.bHasNot = True) Begin
                    Append sExpression CS_Not "("
                End
                Append sExpression TokenizerData.BooleanIndicator.ToBoolean.sCode
                If (TokenizerData.BooleanIndicator.ToBoolean.bHasNot = True) Begin
                    Append sExpression ")"
                End
            End                    
        End
        Else If (bHasAs = True) Begin
            If (TokenizerData.BooleanIndicator.AsBoolean.bHasBracket = True) Begin
                If (TokenizerData.BooleanIndicator.AsBoolean.bHasNot = True) Begin
                    Append sExpression CS_Not "("
                End
                Append sExpression TokenizerData.BooleanIndicator.AsBoolean.sCode
                If (TokenizerData.BooleanIndicator.AsBoolean.bHasNot = True) Begin
                    Append sExpression ")"
                End
            End
        End
        
        If (sExpression <> "") Begin
            Move ("(" + sExpression + ")") to sExpression
        End
        
        Move (Trim(sExpression)) to sExpression
        Function_Return sExpression
    End_Function
    
    // Returns the end comment if one exists.
    // Else returns an empty string
    Function EndComment String sLine Returns String
        Integer iPos
        String sComment

        Move "" to sComment
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (Pos(CS_CommentSymbol, sLine)) to iPos
            Move (Mid(sLine, Length(sLine), iPos)) to sComment
        End
        Function_Return sComment
    End_Function

    // Sometimes a method has extra embedded spaces between its parameters.
    // We reduce consequitive spaces here to just one.
    // The Replaces function has a limit on how many occurances it can handle. 
    Function TrimInsideSpaces String sLine Returns String
        While (Pos("  ", sLine) <> 0)
            Move (Replaces("  ", sLine, " ")) to sLine  // as doc says you can't reduce 3+ spaces to 1 without running a loop
        Loop
        Function_Return sLine
    End_Function

    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
    Function HasLegacyOperator String sOverStrikeLine Returns Boolean
        Boolean bHas

        Get RemoveComments (&sOverStrikeLine) to bHas
        Move (Lowercase(sOverStrikeLine)) to sOverStrikeLine

        Case Begin
            Case (sOverStrikeLine contains " gt ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " ge ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " lt ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " le ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " eq ")
                Move True to bHas
                Case Break
            Case (sOverStrikeLine contains " ne ")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End

        Function_Return bHas
    End_Function

    Function ReplaceParanthesis String sToken Returns String
        Integer iPos
        Move (Replace("(", sToken, "")) to sToken
        Move (RightPos(")", sToken)) to iPos    
        If (iPos <> 0) Begin
            Move (Overstrike(" ", sToken, iPos)) to sToken
        End
        Function_Return (Trim(sToken))
    End_Function

    // Removes any "[", "]" or "tilde" characters
    Function ReplaceBrackets String sToken Returns String
        Move (Replaces("[", sToken, "")) to sToken
        Move (Replaces("]", sToken, "")) to sToken
        Move (Replaces(CS_Tilde, sToken, "")) to sToken
        Function_Return (Trim(sToken))
    End_Function

    Function HasBracket tBooleanIndicator BooleanIndicator Returns Boolean
        Boolean bTrue
        Move (BooleanIndicator.FirstBoolean.bHasBracket = True or ;
              BooleanIndicator.SecondBoolean.bHasBracket = True or ;
              BooleanIndicator.ToBoolean.bHasBracket = True) to bTrue
        Function_Return bTrue
    End_Function

    Function SingleCommandSyntaxToFunction String ByRef sLine String sKeyWord Returns Boolean
        Boolean bFound
        String sText sNose sVar1 sVar2 sVar3
        Integer iPos iItem iParam
        tTokenizer TokenizerData
        
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True) Begin
            Function_Return False
        End
        
        Get pTokenizer to TokenizerData
        Move (SearchArray(sKeyWord, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End
        
        Move "" to sNose  
        Move (Trim(sLine)) to sLine
        // Remove the keyword
        Move (Pos(Lowercase(sKeyWord), Lowercase(sLine))) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, (iPos -1))) to sNose
            Move (Replace(sNose, sLine, "")) to sLine
        End

        // Get the first variable
        Move TokenizerData.asLineTokens[iItem + 1] to sVar1
        // Check if this is a string constant, in case the array value contains underscores only.
        Get _IsStringArrayConstant sVar1 to bFound
        If (bFound = True) Begin
            Get _ExtractFirstStringConstant sLine to sVar1    
        End
        Move 0 to iParam
        
        Case Begin
            Case (Lowercase(sKeyWord) = Lowercase(CS_Length))
                Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar2
                    Get _IsStringArrayConstant sVar2 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase( sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar2    
                    End
                End
                Move ("(" + String(sKeyWord) + "(" + String(sVar1) + "))" * CS_To * String(sVar2)) to sLine
                Case Break  
                
            Case (Lowercase(sKeyWord) = Lowercase(CS_Left))   
                Move "" to sVar3
                Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar2
                    Get _IsStringArrayConstant sVar2 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase( sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar2
                    End
                    If (iItem + 2 <= SizeOfArray(TokenizerData.asLineTokens)) Begin
                        Move TokenizerData.asLineTokens[iItem +2] to sVar3
                    End
                End
                If (sVar3 <> "") Begin
                    Move ("(" + String(sKeyWord) + "(" + String(sVar1) + ", " + String(sVar3) + "))" * CS_To * String(sVar2)) to sLine
                End
                Else Begin
                    Move ("(" + String(sKeyWord) + "(" + String(sVar1) + "))" * CS_To * String(sVar2)) to sLine
                End
                Case Break  
                
            Case (Lowercase(sKeyWord) = Lowercase(CS_Right))
                Move "" to sVar3
                Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar2
                    Get _IsStringArrayConstant sVar2 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase( sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar2
                    End
                    If (iItem + 2 <= SizeOfArray(TokenizerData.asLineTokens)) Begin
                        Move TokenizerData.asLineTokens[iItem +2] to sVar3
                    End
                End
                If (sVar3 <> "") Begin
                    Move ("(" + String(sKeyWord) + "(" + String(sVar1) + ", " + String(sVar3) + "))" * CS_To * String(sVar2)) to sLine
                End
                Else Begin
                    Move ("(" + String(sKeyWord) + "(" + String(sVar1) + "))" * CS_To * String(sVar2)) to sLine
                End
                Case Break  
                
            Case (Lowercase(sKeyWord) = Lowercase(CS_Pos))
                Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar2
                    Get _IsStringArrayConstant sVar2 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_In) + " "), Lowercase(sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar2    
                    End
                End
                Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar3
                End
                Move ("(" + String(sKeyWord) + "(" + String(sVar1) + "," + String(sVar2) + "))" * CS_To * String(sVar3)) to sLine
                Case Break 
            Case (Lowercase(sKeyWord) = Lowercase(CS_Replace))
                Move (SearchArray(CS_Replace, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar1
                    Get _IsStringArrayConstant sVar1 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_Replace) + " "), Lowercase(sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar1
                    End
                End
                Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar2
                    Get _IsStringArrayConstant sVar2 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_In) + " "), Lowercase(sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar2
                    End 
                End
                Move (SearchArray(CS_With, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar3
                    Get _IsStringArrayConstant sVar3 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_With) + " "), Lowercase(sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar3
                    End 
                End
                Move ("(" + String(sKeyWord) + "(" + String(sVar1) + "," + String(sVar2) + "," + String(sVar3) + "))" * CS_To * String(sVar2)) to sLine
                Case Break 
                
            Case (Lowercase(sKeyWord) = Lowercase(CS_ZeroString))
                Move (SearchArray(CS_ZeroString, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar1
                End
                Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                If (iItem <> -1) Begin
                    Move TokenizerData.asLineTokens[iItem +1] to sVar2
                    Get _IsStringArrayConstant sVar2 to bFound
                    If (bFound = True) Begin
                        Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sLine))) to iPos
                        Move (Mid(sLine, Length(sLine), (iPos + 1))) to sText
                        Get _ExtractFirstStringConstant sText to sVar2
                    End 
                End
                Move ("(" + String(sKeyWord) + "(" + String(sVar1) + "))" * CS_To * String(sVar2)) to sLine
                Case Break 
            
            Case Else
                             
        Case End
                         
        If (sNose <> "") Begin
            Move (TokenizerData.sIndentation + String(sNose) * CS_Move * String(sLine)) to sLine
        End 
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * String(sLine)) to sLine
        End
        If (Length(TokenizerData.sEndComment)  > 0) Begin  
            Append sLine " " TokenizerData.sEndComment
        End

        Function_Return True
    End_Function

    // To be used by cRefactorFuncLib functions to replace one word with another,
    // regardless of lowercase/uppercase characters and spaces.
    // Returns the replaced result string.
    // Returns blank ("") if the "sFrom" parameter was not found in the "sLine" param
    Function ReplaceLineToken tTokenizer TokenizerData String sLine String sFrom String sTo Returns String
        String sFill sIndent sEndComment sText sLineLC sEndFill sToken
        Integer iPos iLength iCount iSize iStart iItem
        String[] asLine

        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return ""
        End
        
        // Split parameter sLine into a string array
        Move (StrSplitToArray(sLine, " ")) to asLine 
        Move (SearchArray(sFrom, asLine, Desktop, (RefFunc(DFSTRICMP)))) to iItem
        
        // If not found, we might have a "sFrom" token that is part of an expression, and
        // thus is not its own item in the string array.
        If (iItem = -1) Begin
            Move (SizeOfArray(asLine)) to iSize
            Decrement iSize
            For iCount from 0 to iSize
                Move -1 to iItem
                Move asLine[iCount] to sToken
                If (Lowercase(sToken) contains Lowercase(sFrom)) Begin
                    Move iCount to iItem
                End
                If (iItem <> -1) Begin
                    Move iSize to iCount // We're out of here.
                End
            Loop
            If (iItem = -1) Begin
                Function_Return ""
            End
            
            Move (Pos(Lowercase(sFrom), Lowercase(sToken))) to iPos
            Move iPos to iStart
            Move (iStart + Length(sFrom) - 1) to iSize
            // Overstrike "sFrom" token:
            For iCount from iStart to iSize
                Move (Overstrike("|", sToken, iCount)) to sToken
            Loop
            Move (Length(sFrom)) to iLength
            Move (FillString("|", iLength)) to sFill
            // Replace overstrike with ""
            Move (Replace(sFill, sToken, "")) to sToken
            // Insert the "sTo" token
            Move (Insert(sTo, sToken, iPos)) to sToken 
            Move sToken to sTo
        End
        
        // Move the "sTo" token back into string array and re-create the sLine string.
        Move sTo to asLine[iItem]
        Move (StrJoinFromArray(asLine, " ")) to sLine
        Function_Return (Rtrim(sLine))
    End_Function

    // Returns True if this is a comment line with "//" to the left,
    // or if the line is blank.
    Function IsCommentLineOrBlank String sLine Returns Boolean
        Boolean bIsComment bIsBlank

        Get _IsCommentLine sLine to bIsComment
        Get _IsBlankLine sLine to bIsBlank

        Function_Return (bIsComment = True or bIsBlank = True)
    End_Function

    // Returns true if the passed sKeyword exists in the asLineTokens array,
    // else returns False.
    // Note that the asLineTokens doesn't contain any string literals, and expressions are
    // kept together as one item in the array.
    // Note: The sKeywords string must be separated by "|".
    Function IsKeywordInLine String sKeywords String[] asLineTokens Returns Boolean
        String sKeyword
        String[] asKeywords
        Integer iSize iCount iItem

        Move (Lowercase(sKeywords)) to sKeywords
        Move (StrSplitToArray(sKeywords, "|")) to asKeywords
        Move (SizeOfArray(asKeywords)) to iSize
        Decrement iSize
        For iCount from 0 to iSize                                // This makes the search case insensitive.
            Move (SearchArray(asKeywords[iCount], asLineTokens, Desktop, (RefFunc(DFSTRICMP)))) to iItem
            If (iItem <> -1) Begin
                Function_Return True
            End
        Loop

        Function_Return False
    End_Function

    Procedure RestoreErrorState
        Get piLastErr to LastErr
        If (pbErr(Self)) Begin
            Move True to Err
        End
        Else Begin
            Move False to Err
        End
    End_Procedure

    Procedure SaveErrorState
        Set piLastErr to LastErr
        If (Err = True) Begin
            Set pbErr to True
        End
        Else Begin
            Set pbErr to False
        End
        Move False to Err
        Move 0 to LastErr
    End_Procedure

    // This *must* be called *once* per source line, *before* any of the refactor functions are called.
    // It calls the Tokenizer function and sets the class property pTokenizer that is used
    // by refactoring functions in this class!
    // The call is made automatically by the refactoring engine, but there are special cases were
    // this also needs to be done manually.
    Procedure InitializeTokenizer String sLine
        tTokenizer TokenizerData
        // Note: This function call also sets the pTokenizer class property.
        Get Tokenizer sLine to TokenizerData
    End_Procedure

End_Class
