Compiling Program: C:\Projects\DF18\DfRefactor\AppSrc\WriteDateTimeHeaderFile.src
Memory Available: 2147483646
1>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cApplication.pkg)
1>>>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\windows.pkd)
7602>>>
7602>>>Use LanguageText.pkg
7602>>>Use WinUser.pkg
7602>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinShell.pkg)
7602>>>>>Use DLL.pkg
7602>>>>>
7602>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7603>>>>>
7603>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7604>>>>>
7604>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;    Returns Integer // void
7605>>>>>
7605>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;    Returns Integer
7606>>>>>
7606>>>>>
7606>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
7606>>>>>Define URL_ESCAPE_SEGMENT_ONLY                 for |CI$00002000
7606>>>>>
7606>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;    Returns Integer // S_OK if succesfull
7607>>>>>
7607>>>>>External_Function UrlEscape "UrlEscapeA" shlwapi.dll;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord dwFlags;    Returns Integer
7608>>>>>
7608>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWorkspace.pkg)
7608>>>>>Use VdfBase.pkg
7608>>>>>Use tWinStructs.pkg
7608>>>>>Use LanguageText.pkg
7608>>>>>Use WinShell.pkg // Shell API functions
7608>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\seq_chnl.pkg)
7608>>>>>>>Use LanguageText.pkg
7608>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\DataFlex 19.1\Pkg\errornum.inc)
7608>>>>>>>>
7608>>>>>>>>//
7608>>>>>>>>// these will get defined in fmac
7608>>>>>>>>//
7608>>>>>>>>// already defined
7608>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
7608>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
7608>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
7608>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
7608>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
7608>>>>>>>>// new compiler errors used by fmac
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
7608>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
7608>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
7608>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>
7608>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
7608>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
7608>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
7608>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
7608>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
7608>>>>>>>// so that programs that use direct_input/output
7608>>>>>>>// w/o specifying a channel will work.
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Integer Seq$Channel$Error$Mode
7608>>>>>>>
7608>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
7610>>>>>>>    Move Mode to Seq$Channel$Error$Mode
7611>>>>>>>End_Procedure
7612>>>>>>>
7612>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
7614>>>>>>>    Function_Return Seq$Channel$Error$Mode
7615>>>>>>>End_Function
7616>>>>>>>
7616>>>>>>>Object Seq_Channel_List is an Array
7618>>>>>>>    Procedure Initialize
7621>>>>>>>        Integer Itm
7621>>>>>>>        
7621>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
7622>>>>>>>        
7622>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
7626>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
7627>>>>>>>            Increment Itm
7628>>>>>>>        Loop
7629>>>>>>>>
7629>>>>>>>    End_Procedure
7630>>>>>>>    
7630>>>>>>>    Send Initialize
7631>>>>>>>End_Object
7632>>>>>>>
7632>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
7633>>>>>>>
7633>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
7635>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
7636>>>>>>>End_Function
7637>>>>>>>
7637>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
7639>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
7640>>>>>>>End_Procedure
7641>>>>>>>
7641>>>>>>>Function Seq_New_Channel Global Returns Integer
7643>>>>>>>    Integer Obj Chnl
7643>>>>>>>    
7643>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
7644>>>>>>>    
7644>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
7648>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7650>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7651>>>>>>>            Function_Return Chnl
7652>>>>>>>        End
7652>>>>>>>>
7652>>>>>>>        
7652>>>>>>>        Increment Chnl
7653>>>>>>>    Loop
7654>>>>>>>>
7654>>>>>>>    
7654>>>>>>>    // wrap back to beginning
7654>>>>>>>    Move 0 to Chnl
7655>>>>>>>    
7655>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
7659>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7661>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7662>>>>>>>            Function_Return Chnl
7663>>>>>>>        End
7663>>>>>>>>
7663>>>>>>>        
7663>>>>>>>        Increment Chnl
7664>>>>>>>    Loop
7665>>>>>>>>
7665>>>>>>>    
7665>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
7666>>>>>>>End_Function
7667>>>>>>>
7667>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
7669>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
7672>>>>>>>End_Procedure
7673>>>>>>>
7673>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
7675>>>>>>>    Integer Chnl
7675>>>>>>>    
7675>>>>>>>    Move (Seq_New_Channel()) to Chnl
7676>>>>>>>    
7676>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7678>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
7681>>>>>>>        Function_Return Chnl
7682>>>>>>>    End
7682>>>>>>>>
7682>>>>>>>    
7682>>>>>>>    Move False to Err
7683>>>>>>>    Direct_Input channel Chnl Dvc
7685>>>>>>>    
7685>>>>>>>    If (Err) Begin
7687>>>>>>>        Send Seq_Release_Channel Chnl
7688>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7689>>>>>>>    End
7689>>>>>>>>
7689>>>>>>>    
7689>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
7690>>>>>>>    
7690>>>>>>>    Function_Return Chnl
7691>>>>>>>End_Function
7692>>>>>>>
7692>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
7694>>>>>>>    Integer Chnl
7694>>>>>>>    
7694>>>>>>>    Move (Seq_New_Channel()) to Chnl
7695>>>>>>>    
7695>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7697>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7699>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7700>>>>>>>>
7700>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7701>>>>>>>        End
7701>>>>>>>>
7701>>>>>>>        
7701>>>>>>>        Function_Return Chnl
7702>>>>>>>    End
7702>>>>>>>>
7702>>>>>>>    
7702>>>>>>>    Move False to Err
7703>>>>>>>    Direct_Output channel Chnl Dvc
7705>>>>>>>    
7705>>>>>>>    If (Err) Begin
7707>>>>>>>        Send Seq_Release_Channel Chnl
7708>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7709>>>>>>>    End
7709>>>>>>>>
7709>>>>>>>    
7709>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7710>>>>>>>    
7710>>>>>>>    Function_Return Chnl
7711>>>>>>>End_Function
7712>>>>>>>
7712>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
7714>>>>>>>    Integer Chnl
7714>>>>>>>    
7714>>>>>>>    Move (Seq_New_Channel()) to Chnl
7715>>>>>>>    
7715>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7717>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7719>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7720>>>>>>>>
7720>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7721>>>>>>>        End
7721>>>>>>>>
7721>>>>>>>        
7721>>>>>>>        Function_Return Chnl
7722>>>>>>>    End
7722>>>>>>>>
7722>>>>>>>    
7722>>>>>>>    Move False to Err
7723>>>>>>>    Append_Output channel Chnl Dvc
7725>>>>>>>    
7725>>>>>>>    If (Err) Begin
7727>>>>>>>        Send Seq_Release_Channel Chnl
7728>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7729>>>>>>>    End
7729>>>>>>>>
7729>>>>>>>    
7729>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7730>>>>>>>    
7730>>>>>>>    Function_Return Chnl
7731>>>>>>>End_Function
7732>>>>>>>
7732>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
7734>>>>>>>    Integer Mode
7734>>>>>>>    
7734>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
7736>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
7737>>>>>>>        
7737>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
7741>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
7746>>>>>>>        // If channel not open, release it! No (fatal) Error.
7746>>>>>>>        Send Seq_Release_Channel Chnl
7747>>>>>>>    End
7747>>>>>>>>
7747>>>>>>>End_Procedure
7748>>>>>>>
7748>>>>>Use GlobalFunctionsProcedures.pkg
7748>>>>>
7748>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7748>>>>>Register_Function VdfSystemDfPath   Returns String
7748>>>>>Register_Function VdfSystemMakePath Returns String
7748>>>>>
7748>>>>>Enum_List
7748>>>>>    Define wsWorkspaceOpened       // WS opened ok
7748>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7748>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7748>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7748>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7748>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7748>>>>>End_Enum_List
7748>>>>>
7748>>>>>Define INVALID_HANDLE_VALUE for -1
7748>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
7748>>>>>
7748>>>>>
7748>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7749>>>>>
7749>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7750>>>>>
7750>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7751>>>>>
7751>>>>>Function DoesFileExist Global String sFilename Returns Boolean
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    String sMask
7753>>>>>    Integer iVoid
7753>>>>>    Handle hFileFind
7753>>>>>    
7753>>>>>    Move (winFindFirstFile(ToAnsi(sFilename), AddressOf(Win32FindData))) to hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7754>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7756>>>>>        Move (winFindClose(hFileFind)) to iVoid
7757>>>>>    End
7757>>>>>>
7757>>>>>    
7757>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7758>>>>>End_Function
7759>>>>>
7759>>>>>
7759>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cIniFile.pkg)
7759>>>>>>>Use Dll.pkg
7759>>>>>>>Use errornum.inc
7759>>>>>>>Use LanguageText.pkg
7759>>>>>>>Use GlobalFunctionsProcedures.pkg
7759>>>>>>>
7759>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7759>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7759>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7760>>>>>>>
7760>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7761>>>>>>>
7761>>>>>>>Class cIniFile is a cObject
7762>>>>>>>    Procedure Construct_Object
7764>>>>>>>        Forward Send Construct_Object
7766>>>>>>>        
7766>>>>>>>        Property String psFileName
7767>>>>>>>    End_Procedure
7768>>>>>>>    
7768>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7770>>>>>>>        Boolean bSuccess
7770>>>>>>>        
7770>>>>>>>        If (trim(psFileName(Self))="") Begin
7772>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7773>>>>>>>>
7773>>>>>>>            Procedure_Return
7774>>>>>>>        End
7774>>>>>>>>
7774>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(Self)))) to bSuccess
7775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7778>>>>>>>    End_Procedure
7779>>>>>>>    
7779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7781>>>>>>>        Integer iNumChars iSizeValue
7781>>>>>>>        String sValue
7781>>>>>>>        
7781>>>>>>>        Move (ToAnsi(sSection)) to sSection
7782>>>>>>>        Move (ToAnsi(sKey))     to sKey
7783>>>>>>>        Move (ToAnsi(sDefault)) to sDefault
7784>>>>>>>        
7784>>>>>>>        Move 2047 to iSizeValue
7785>>>>>>>        
7785>>>>>>>        Move (Pad(" ",iSizeValue)) to sValue
7786>>>>>>>        
7786>>>>>>>        If (trim(psFileName(Self))="") Begin
7788>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7789>>>>>>>>
7789>>>>>>>            Function_Return ''
7790>>>>>>>        End
7790>>>>>>>>
7790>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, ToAnsi(psFilename(Self)))) to iNumChars
7791>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7792>>>>>>>    End_Function
7793>>>>>>>    
7793>>>>>>>    Function SectionExists String sSection Returns Boolean
7795>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7795>>>>>>>        Handle hoKeys
7795>>>>>>>        Integer icKey iKey
7795>>>>>>>        
7795>>>>>>>        Get Create U_ARRAY to hoKeys
7796>>>>>>>        Send ReadSection sSection hoKeys
7797>>>>>>>        Get Item_Count of hoKeys to icKey
7798>>>>>>>        Send Destroy of hoKeys
7799>>>>>>>        
7799>>>>>>>        Function_Return (icKey >0)
7800>>>>>>>    End_Function
7801>>>>>>>    
7801>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7803>>>>>>>        Integer iNumChars iSizeValue iPos
7803>>>>>>>        Pointer lpsKeys
7803>>>>>>>        String sKeys sKey
7803>>>>>>>        
7803>>>>>>>        Move 16384 to iSizeValue
7804>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sKeys
7805>>>>>>>        
7805>>>>>>>        Move (AddressOf(sKeys)) to lpsKeys
7806>>>>>>>        
7806>>>>>>>        Move (ToAnsi(sSection)) to sSection
7807>>>>>>>        
7807>>>>>>>        If (trim(psFileName(Self))="") Begin
7809>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7810>>>>>>>>
7810>>>>>>>            Procedure_Return
7811>>>>>>>        End
7811>>>>>>>>
7811>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(Self)))) to iNumChars
7812>>>>>>>        If (iNumChars >0) Begin
7814>>>>>>>            Repeat
7814>>>>>>>>
7814>>>>>>>                Move (Pos(Character(0),sKeys)) to iPos
7815>>>>>>>                If (iPos >1) Begin
7817>>>>>>>                    Move (Left(sKeys,iPos -1))  to sKey
7818>>>>>>>                    Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
7819>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sKey))
7820>>>>>>>                End
7820>>>>>>>>
7820>>>>>>>            Until (iPos <=1)
7822>>>>>>>        End
7822>>>>>>>>
7822>>>>>>>    End_Procedure
7823>>>>>>>    
7823>>>>>>>    Procedure ReadSections Handle hoArray
7825>>>>>>>        Integer iNumChars iSizeValue iPos
7825>>>>>>>        Pointer lpsSections
7825>>>>>>>        String sSections sSection
7825>>>>>>>        
7825>>>>>>>        Move 16384 to iSizeValue
7826>>>>>>>        
7826>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sSections
7827>>>>>>>        Move (AddressOf(sSections)) to lpsSections
7828>>>>>>>        
7828>>>>>>>        If (trim(psFileName(Self))="") Begin
7830>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7831>>>>>>>>
7831>>>>>>>            Procedure_Return
7832>>>>>>>        End
7832>>>>>>>>
7832>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(Self)))) to iNumChars
7833>>>>>>>        If (iNumChars >0) Begin
7835>>>>>>>            Repeat
7835>>>>>>>>
7835>>>>>>>                Move (Pos(Character(0),sSections)) to iPos
7836>>>>>>>                If (iPos >1) Begin
7838>>>>>>>                    Move (Left(sSections,iPos -1)) to sSection
7839>>>>>>>                    Move (Right(sSections, Length(sSections) - iPos)) to sSections
7840>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sSection))
7841>>>>>>>                End
7841>>>>>>>>
7841>>>>>>>            Until (iPos <=1)
7843>>>>>>>        End
7843>>>>>>>>
7843>>>>>>>        
7843>>>>>>>    End_Procedure
7844>>>>>>>    
7844>>>>>>>    Procedure DeleteSection String sSection
7846>>>>>>>        
7846>>>>>>>        If (trim(psFileName(Self))="") Begin
7848>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7849>>>>>>>>
7849>>>>>>>            Procedure_Return
7850>>>>>>>        End
7850>>>>>>>>
7850>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(Self))) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
7853>>>>>>>    End_Procedure
7854>>>>>>>    
7854>>>>>>>    Procedure DeleteKey String sSection String sKey
7856>>>>>>>        Integer iVoid
7856>>>>>>>        If (trim(psFileName(Self))="") Begin
7858>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7859>>>>>>>>
7859>>>>>>>            Procedure_Return
7860>>>>>>>        End
7860>>>>>>>>
7860>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(Self)))) to iVoid
7861>>>>>>>    End_Procedure
7862>>>>>>>    
7862>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7864>>>>>>>        Handle hoKeys
7864>>>>>>>        Integer iKey
7864>>>>>>>        Boolean bExists
7864>>>>>>>        
7864>>>>>>>        Move (False) to bExists
7865>>>>>>>        
7865>>>>>>>        Move (ToAnsi(Uppercase(sKey))) to sKey
7866>>>>>>>        
7866>>>>>>>        Get Create U_ARRAY to hoKeys
7867>>>>>>>        
7867>>>>>>>        Send ReadSection sSection hoKeys
7868>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
7874>>>>>>>>
7874>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7876>>>>>>>                Move (True) to bExists
7877>>>>>>>            End
7877>>>>>>>>
7877>>>>>>>        Loop
7878>>>>>>>>
7878>>>>>>>        
7878>>>>>>>        Send Destroy of hoKeys
7879>>>>>>>        
7879>>>>>>>        Function_Return bExists
7880>>>>>>>    End_Function
7881>>>>>>>    
7881>>>>>>>End_Class
7882>>>>>
7882>>>>>Class cWorkspace is a cObject
7883>>>>>    
7883>>>>>    Procedure Construct_Object
7885>>>>>        Forward Send Construct_Object
7887>>>>>        
7887>>>>>        
7887>>>>>        Property String psAppSrcPath
7888>>>>>        Property String psBitmapPath
7889>>>>>        Property String psDataPath
7890>>>>>        Property String psDdSrcPath
7891>>>>>        Property String psDescription
7892>>>>>        Property String psFileList
7893>>>>>        Property String psHelpPath
7894>>>>>        Property String psHome
7895>>>>>        Property String psIdeSrcPath
7896>>>>>        Property String psProgramPath
7897>>>>>        Property String psAppHtmlPath
7898>>>>>        Property String psWorkspaceName
7899>>>>>        Property String psWorkspaceWSFile
7900>>>>>        Property String psConnectionIni
7901>>>>>        
7901>>>>>        Property String psSystemDfPath // took from the Registry!
7902>>>>>        Property String psSystemMakePath // took from the Registry!
7903>>>>>        Property String psDfPath        // Calculated
7904>>>>>        
7904>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7905>>>>>        
7905>>>>>    End_Procedure
7906>>>>>    
7906>>>>>    Function FullPathNames String sShortPathNames Returns String
7908>>>>>        String sFileName
7908>>>>>        String sFullPathNames sFullPathName sShortPathName
7908>>>>>        Pointer lpsFilePart
7908>>>>>        Integer icChar // the number of characters returned
7908>>>>>        Integer iPos
7908>>>>>        
7908>>>>>        Move (Pos(";", sShortPathNames)) to iPos
7909>>>>>        While (length(sShortPathNames) >0)
7913>>>>>            If (iPos =0) Begin
7915>>>>>                Move sShortPathNames to sShortPathName
7916>>>>>                Move "" to sShortPathNames
7917>>>>>            End
7917>>>>>>
7917>>>>>            Else Begin // multiple paths
7918>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
7919>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
7920>>>>>            End
7920>>>>>>
7920>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
7921>>>>>            Move -1 to lpsFilePart
7922>>>>>            Move (GetFullPathName(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
7923>>>>>            Append sFullPathNames (CString(sFullPathName))
7924>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
7927>>>>>            Move (Pos(";", sShortPathNames)) to iPos
7928>>>>>        Loop
7929>>>>>>
7929>>>>>        
7929>>>>>        Function_Return sFullPathNames
7930>>>>>    End_Function
7931>>>>>    
7931>>>>>    Function GetApplicationPath Returns String
7933>>>>>        // Returns the path of the Application (no trailing "\")
7933>>>>>        String sApplicationFileName sPath
7933>>>>>        Boolean bRemoved
7933>>>>>        Integer iNumChars
7933>>>>>        String sFilename
7933>>>>>        
7933>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7934>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7935>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7936>>>>>        
7936>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7937>>>>>        Move (CString(sApplicationFileName)) to sPath
7938>>>>>        
7938>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
7941>>>>>        Function_Return sPath
7942>>>>>    End_Function
7943>>>>>    
7943>>>>>    Procedure DoClearPaths
7945>>>>>        // Call this prior to changing from one WorkspAce to another
7945>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7945>>>>>        Set psHome           to ""
7946>>>>>        Set psAppSrcPath     to ""
7947>>>>>        Set psBitmapPath     to ""
7948>>>>>        Set psDataPath       to ""
7949>>>>>        Set psDdSrcPath      to ""
7950>>>>>        Set psDescription    to ""
7951>>>>>        Set psFileList       to ""
7952>>>>>        Set psHelpPath       to ""
7953>>>>>        Set psIdeSrcPath     to ""
7954>>>>>        Set psAppHtmlPath    to ""
7955>>>>>        Set psProgramPath    to ""
7956>>>>>        Set psWorkspaceName  to ""
7957>>>>>        Set psSystemDfPath   to ""
7958>>>>>        Set psSystemMakePath to ""
7959>>>>>        Set psWorkspaceWSFile to ""
7960>>>>>        Set psConnectionIni to ""
7961>>>>>    End_Procedure
7962>>>>>    
7962>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7964>>>>>        String sApplicationStartPath
7964>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7964>>>>>        Boolean bRemoved
7964>>>>>        Handle hoIniFile
7964>>>>>        Boolean bSuccess // call succeeded?
7964>>>>>        String sOldDirectory
7964>>>>>        String sSystemDfPath sSystemMakePath
7964>>>>>        Boolean bExist // does the WS file exist?
7964>>>>>        Boolean bChangingWorkspace
7964>>>>>        
7964>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7964>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
7964>>>>>        
7964>>>>>        Set psWorkspaceWSFile to ""
7965>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
7968>>>>>        
7968>>>>>        // Append extension if not supplied...
7968>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7970>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
7971>>>>>        End
7971>>>>>>
7971>>>>>        
7971>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
7972>>>>>        
7972>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7974>>>>>            // Set the properties to the paths of the Workspace
7974>>>>>            // Find the WS file (with program)...
7974>>>>>            Get GetApplicationPath to sApplicationStartPath
7975>>>>>            
7975>>>>>            Move sWorkspaceFile to sWsName
7976>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
7977>>>>>        End
7977>>>>>>
7977>>>>>        Else Begin
7978>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
7979>>>>>            
7979>>>>>            Move sWorkspaceFile to sApplicationStartPath
7980>>>>>            Move (PathRemoveFileSpec(AddressOf(sApplicationStartPath))) to bRemoved
7981>>>>>        End
7981>>>>>>
7981>>>>>        
7981>>>>>        // Ensure that the file can be found...
7981>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7981>>>>>        // [JVH] Turn off support for
7981>>>>>        // Ansi extended characters in workspace until we can
7981>>>>>        // resolve all open issues
7981>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7982>>>>>        File_Exist sWorkspaceFile bExist
7983>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
7986>>>>>        
7986>>>>>        Get psHome           to sHome
7987>>>>>        Get psAppSrcPath     to sAppSrcPath
7988>>>>>        Get psAppHtmlPath    to sAppHtmlPath
7989>>>>>        Get psBitmapPath     to sBitmapPath
7990>>>>>        Get psDataPath       to sDataPath
7991>>>>>        Get psDdSrcPath      to sDdSrcPath
7992>>>>>        Get psDescription    to sDescription
7993>>>>>        Get psFileList       to sFileList
7994>>>>>        Get psHelpPath       to sHelpPath
7995>>>>>        Get psIdeSrcPath     to sIdeSrcPath
7996>>>>>        Get psProgramPath    to sProgramPath
7997>>>>>        Get psSystemDfPath   to sSystemDfPath
7998>>>>>        Get psSystemMakePath to sSystemMakePath
7999>>>>>        Get psWorkspaceName  to sWorkspaceName
8000>>>>>        Get psConnectionIni to sConnectionIni
8001>>>>>        
8001>>>>>        Get_Current_Directory to sOldDirectory
8002>>>>>        // Note- this conversion is temporarily rolled back
8002>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
8002>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) to bSuccess
8003>>>>>        
8003>>>>>        Get Create U_cIniFile to hoIniFile
8004>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
8005>>>>>        
8005>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
8008>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
8011>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
8014>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
8017>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
8020>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
8023>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
8026>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
8029>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
8032>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
8035>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
8038>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
8041>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
8044>>>>>        
8044>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
8047>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
8050>>>>>        
8050>>>>>        Set psHome          to (FullPathNames(Self, sHome))
8051>>>>>        
8051>>>>>        // Set CWD to Home...
8051>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
8052>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
8053>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
8054>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
8055>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
8056>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
8057>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
8058>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
8059>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
8060>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
8061>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
8062>>>>>        
8062>>>>>        Set psWorkspaceName to sWorkspaceName
8063>>>>>        Set psDescription   to sDescription
8064>>>>>        
8064>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
8065>>>>>        
8065>>>>>        // Restore CWD...
8065>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
8066>>>>>        
8066>>>>>        // Check for error conditions:
8066>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
8066>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
8069>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
8072>>>>>        
8072>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
8073>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
8076>>>>>        
8076>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
8079>>>>>        
8079>>>>>        Send DoAssignPaths // set psDfPath
8080>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
8081>>>>>        Set pbWorkspaceOpened to True
8082>>>>>        
8082>>>>>        Function_Return wsWorkspaceOpened
8083>>>>>    End_Function
8084>>>>>    
8084>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
8086>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
8086>>>>>        
8086>>>>>        Handle hoSections hoIniFile
8086>>>>>        Integer iWorkspace eOpened
8086>>>>>        String sWorkspaceName sPath
8086>>>>>        String sVdfRootDir
8086>>>>>        
8086>>>>>        Get Create U_Array    to hoSections
8087>>>>>        Get Create U_cIniFile to hoIniFile
8088>>>>>        
8088>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8091>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8094>>>>>        
8094>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8095>>>>>        
8095>>>>>        Send ReadSections of hoIniFile hoSections
8096>>>>>        
8096>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
8102>>>>>>
8102>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
8103>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
8105>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
8106>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
8109>>>>>                
8109>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
8110>>>>>                Send Destroy of hoSections
8111>>>>>                Send Destroy of hoIniFile
8112>>>>>                Function_Return eOpened
8113>>>>>            End
8113>>>>>>
8113>>>>>        Loop
8114>>>>>>
8114>>>>>        
8114>>>>>        Send Destroy of hoSections
8115>>>>>        Send Destroy of hoIniFile
8116>>>>>        Function_Return wsWorkspaceNotFound
8117>>>>>    End_Function
8118>>>>>    
8118>>>>>    Function IsRegistered String sWorkspace Returns Boolean
8120>>>>>        Boolean bRegistered
8120>>>>>        Handle hoIniFile
8120>>>>>        String sVdfRootDir
8120>>>>>        
8120>>>>>        Get Create U_cIniFile to hoIniFile
8121>>>>>        
8121>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8124>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8127>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8128>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
8129>>>>>        
8129>>>>>        Send Destroy of hoIniFile
8130>>>>>        
8130>>>>>        Function_Return bRegistered
8131>>>>>    End_Function
8132>>>>>    
8132>>>>>    Function VdfSystemDfPath Returns String
8134>>>>>        String sSystemDfPath
8134>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
8137>>>>>        
8137>>>>>        Function_Return sSystemDfPath
8138>>>>>    End_Function
8139>>>>>    
8139>>>>>    Function VdfSystemMakePath Returns String
8141>>>>>        String sSystemMakePath
8141>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
8144>>>>>        
8144>>>>>        Function_Return sSystemMakePath
8145>>>>>    End_Function
8146>>>>>    
8146>>>>>    Procedure DoAssignPaths
8148>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
8148>>>>>        
8148>>>>>        Get psDataPath     to sDataPath
8149>>>>>        Get psBitmapPath   to sBitmapPath
8150>>>>>        Get psHelpPath     to sHelpPath
8151>>>>>        Get psProgramPath  to sProgramPath
8152>>>>>        Get psSystemDfPath to sSystemDfPath
8153>>>>>        
8153>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
8154>>>>>        
8154>>>>>    End_Procedure
8155>>>>>    
8155>>>>>    Procedure DoSetPaths
8157>>>>>        // [JVH] must convert paths to Ansi before setting these values
8157>>>>>        // Note- this conversion is temporarily rolled back
8157>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
8157>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
8157>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
8160>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
8163>>>>>    End_Procedure
8164>>>>>    
8164>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
8166>>>>>        String sPath
8166>>>>>        
8166>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
8169>>>>>        Else Begin
8170>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
8171>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
8172>>>>>            Send hmGeneric to hoCallBack ""
8173>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
8174>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
8175>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
8176>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
8177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
8178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
8179>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
8180>>>>>        End
8180>>>>>>
8180>>>>>    End_Procedure
8181>>>>>    
8181>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
8183>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
8183>>>>>        // returns a corresponding message string.
8183>>>>>        String sError
8183>>>>>        
8183>>>>>        Case Begin
8183>>>>>            Case (eErrorCode = wsWorkspaceOpened)
8185>>>>>                Move C_$NoErrors to sError
8186>>>>>                Case Break
8187>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
8190>>>>>                Move C_$NoWsName to sError
8191>>>>>                Case Break
8192>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
8195>>>>>                Move C_$NoWsFileFound to sError
8196>>>>>                Case Break
8197>>>>>            Case (eErrorCode = wsDataPathEmpty)
8200>>>>>                Move C_$NoWsDataPath to sError
8201>>>>>                Case Break
8202>>>>>            Case (eErrorCode = wsFileListEmpty)
8205>>>>>                Move C_$NoWsFileList to sError
8206>>>>>                Case Break
8207>>>>>            Case (eErrorCode = wsFileListNotExist)
8210>>>>>                Move C_$NoFileListCfg to sError
8211>>>>>                Case Break
8212>>>>>            Case Else
8212>>>>>                Move C_$UnknownError to sError
8213>>>>>                Case Break
8214>>>>>        Case End
8214>>>>>        
8214>>>>>        Function_Return (sError-".")
8215>>>>>    End_Function
8216>>>>>    
8216>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
8218>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
8218>>>>>        String sVdfRootDir
8218>>>>>        Handle hoIniFile
8218>>>>>        String sPath
8218>>>>>        String sFileName
8218>>>>>        String sWorkspacePath
8218>>>>>        
8218>>>>>        Move "" to sFileName
8219>>>>>        
8219>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8222>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8225>>>>>        
8225>>>>>        Get Create U_cIniFile to hoIniFile
8226>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8227>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
8228>>>>>        If (sWorkspacePath <>"") Begin
8230>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
8233>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
8234>>>>>        End
8234>>>>>>
8234>>>>>        Send Destroy of hoIniFile
8235>>>>>        
8235>>>>>        Function_Return sFileName
8236>>>>>    End_Function
8237>>>>>    
8237>>>>>    Function CountOfPaths String sPaths Returns Integer
8239>>>>>        // Returns the number of paths defined in a string of paths
8239>>>>>        Integer iChar icChar icPath
8239>>>>>        
8239>>>>>        If (sPaths ="") ;            Function_Return 0
8242>>>>>        
8242>>>>>        Move (Length(sPaths) -1) to icChar
8243>>>>>        For iChar from 1 to icChar
8249>>>>>>
8249>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
8252>>>>>        Loop
8253>>>>>>
8253>>>>>        
8253>>>>>        Function_Return (icPath +1)
8254>>>>>    End_Function
8255>>>>>    
8255>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
8257>>>>>        // Returns the path at the 1-based index of passed paths.
8257>>>>>        // If the path contains a trailing "\", it will be removed
8257>>>>>        Integer iChar icPath iPath iPos
8257>>>>>        String sPath
8257>>>>>        
8257>>>>>        Move (sPaths +";") to sPaths
8258>>>>>        For iPath from 1 to iIndex
8264>>>>>>
8264>>>>>            Move (Pos(";", sPaths)) to iPos
8265>>>>>            If iPos Begin
8267>>>>>                Move (Left(sPaths, iPos -1)) to sPath
8268>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
8271>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
8272>>>>>            End
8272>>>>>>
8272>>>>>            Else ;                Function_Return "" // index past number of paths
8274>>>>>        Loop
8275>>>>>>
8275>>>>>        
8275>>>>>        Function_Return sPath
8276>>>>>    End_Function
8277>>>>>    
8277>>>>>End_Class
8278>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLine.pkg)
8278>>>>>Use VDFBase.pkg
8278>>>>>
8278>>>>>Class cCommandLine is a cObject
8279>>>>>    
8279>>>>>    Procedure Construct_Object
8281>>>>>        Forward Send Construct_Object
8283>>>>>        
8283>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
8284>>>>>    End_Procedure
8285>>>>>    
8285>>>>>    Procedure Private_DoCreateArgsArray
8287>>>>>        // creates the array for holding the arguments. Created upon demand only!
8287>>>>>        Integer icArg
8287>>>>>        String sArg
8287>>>>>        
8287>>>>>        Object oArgs is an Array
8289>>>>>            Delegate Set phoArgs to Self
8291>>>>>            Repeat
8291>>>>>>
8291>>>>>                CmdLine sArg
8292>>>>>>
8292>>>>>                If (sArg <> "") Begin
8294>>>>>                    Increment icArg
8295>>>>>                    Set Value  (icArg -1) to sArg
8296>>>>>                End
8296>>>>>>
8296>>>>>            Until (sArg = "")
8298>>>>>        End_Object
8299>>>>>    End_Procedure
8300>>>>>    
8300>>>>>    Function CountOfArgs Returns Integer
8302>>>>>        //Returns the number of arguments passed
8302>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8305>>>>>        Function_Return (Item_Count(phoArgs(Self)))
8306>>>>>    End_Function
8307>>>>>    
8307>>>>>    Function Argument Integer iIndex Returns String
8309>>>>>        //Returns the one-based argument string
8309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8312>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
8313>>>>>    End_Function
8314>>>>>    
8314>>>>>End_Class
8315>>>>>
8315>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRegistry.pkg)
8315>>>>>Use Dll.pkg
8315>>>>>Use RegistryAPI.pkg
8315>>>>>
8315>>>>>Enum_List // Registry Data types
8315>>>>>    Define rdString
8315>>>>>    Define rdDword
8315>>>>>    Define rdBinary
8315>>>>>    Define rdUnknown
8315>>>>>End_Enum_List
8315>>>>>
8315>>>>>//Prototypes
8315>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
8315>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
8315>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
8315>>>>>Register_Function pbLazyWrite    Returns Boolean // True
8315>>>>>
8315>>>>>Register_Function CountOfSubkeys      Returns Integer
8315>>>>>Register_Function CountOfValues       Returns Integer
8315>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
8315>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
8315>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
8315>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
8315>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
8315>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
8315>>>>>Register_Function LongestDataLength   Returns Integer
8315>>>>>Register_Function LongestSubkeyLength Returns Integer
8315>>>>>Register_Function LongestValueLength  Returns Integer
8315>>>>>Register_Function OpenKey             String sKeyName Returns Integer
8315>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
8315>>>>>Register_Function ReadDword           String sValueName Returns DWord
8315>>>>>Register_Function ReadString          String sValueName Returns String
8315>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
8315>>>>>Register_Function ValueLength         String sValueName Returns Integer
8315>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
8315>>>>>Register_Procedure CloseKey
8315>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
8315>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
8315>>>>>Register_Procedure WriteString        String sValue String sValueData
8315>>>>>
8315>>>>>
8315>>>>>Class cRegistry is a cObject
8316>>>>>    Procedure Construct_Object
8318>>>>>        Forward Send Construct_Object
8320>>>>>        
8320>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
8321>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
8322>>>>>        Property Handle phCurrentKey
8323>>>>>        Property Boolean pbLazyWrite True
8324>>>>>    End_Procedure
8325>>>>>    
8325>>>>>    Function CountOfSubkeys Returns Integer
8327>>>>>        DWord dwCountOfSubkeys
8327>>>>>        Integer iError
8327>>>>>        String sError
8327>>>>>        
8327>>>>>        Move 0 to dwCountOfSubkeys
8328>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
8329>>>>>        If iError Begin
8331>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8332>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8333>>>>>>
8333>>>>>        End
8333>>>>>>
8333>>>>>        Function_Return dwCountOfSubkeys
8334>>>>>    End_Function
8335>>>>>    
8335>>>>>    Function CountOfValues Returns Integer
8337>>>>>        DWord dwCountOfValues
8337>>>>>        Integer iError
8337>>>>>        String sError
8337>>>>>        
8337>>>>>        Move 0 to dwCountOfValues
8338>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
8339>>>>>        If iError Begin
8341>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8342>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8343>>>>>>
8343>>>>>        End
8343>>>>>>
8343>>>>>        
8343>>>>>        Function_Return dwCountOfValues
8344>>>>>    End_Function
8345>>>>>    
8345>>>>>    Function LongestSubkeyLength Returns Integer
8347>>>>>        DWord dwLongestSubkeyLength
8347>>>>>        Integer iError
8347>>>>>        String sError
8347>>>>>        
8347>>>>>        Move 0 to dwLongestSubkeyLength
8348>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
8349>>>>>        If iError Begin
8351>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8352>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8353>>>>>>
8353>>>>>        End
8353>>>>>>
8353>>>>>        
8353>>>>>        Function_Return dwLongestSubkeyLength
8354>>>>>    End_Function
8355>>>>>    
8355>>>>>    Function LongestValueLength Returns Integer
8357>>>>>        DWord dwLongestValueLength
8357>>>>>        Integer iError
8357>>>>>        String sError
8357>>>>>        
8357>>>>>        Move 0 to dwLongestValueLength
8358>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
8359>>>>>        If iError Begin
8361>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8362>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8363>>>>>>
8363>>>>>        End
8363>>>>>>
8363>>>>>        
8363>>>>>        Function_Return dwLongestValueLength
8364>>>>>    End_Function
8365>>>>>    
8365>>>>>    Function LongestDataLength Returns Integer
8367>>>>>        DWord dwLongestDataLength
8367>>>>>        Integer iError
8367>>>>>        String sError
8367>>>>>        
8367>>>>>        Move 0 to dwLongestDataLength
8368>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
8369>>>>>        If iError Begin
8371>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8372>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8373>>>>>>
8373>>>>>        End
8373>>>>>>
8373>>>>>        
8373>>>>>        Function_Return dwLongestDataLength
8374>>>>>    End_Function
8375>>>>>    
8375>>>>>    Function ValueType String sValueName Returns Integer
8377>>>>>        DWord dwType
8377>>>>>        Integer iError eType
8377>>>>>        String sError
8377>>>>>        
8377>>>>>        Move 0 to dwType
8378>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) to iError
8379>>>>>        If iError Begin
8381>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8382>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8383>>>>>>
8383>>>>>        End
8383>>>>>>
8383>>>>>        
8383>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
8386>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
8390>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
8394>>>>>        Else ;            Move rdUnknown to eType
8396>>>>>        
8396>>>>>        Function_Return eType
8397>>>>>    End_Function
8398>>>>>    
8398>>>>>    Function ValueLength String sValueName Returns Integer
8400>>>>>        DWord dwSize
8400>>>>>        Integer iError
8400>>>>>        String sError
8400>>>>>        
8400>>>>>        Move 0 to dwSize
8401>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) to iError
8402>>>>>        If iError Begin
8404>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8405>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8406>>>>>>
8406>>>>>        End
8406>>>>>>
8406>>>>>        
8406>>>>>        Function_Return dwSize
8407>>>>>    End_Function
8408>>>>>    
8408>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
8410>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
8410>>>>>        Handle hKey hKeyOpened
8410>>>>>        Integer iError
8410>>>>>        String sError
8410>>>>>        
8410>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8411>>>>>        
8411>>>>>        Get phRootKey to hKey
8412>>>>>        
8412>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
8413>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8416>>>>>        Else Begin
8417>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8418>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8419>>>>>>
8419>>>>>        End
8419>>>>>>
8419>>>>>        Function_Return iError
8420>>>>>    End_Function
8421>>>>>    
8421>>>>>    Procedure CloseKey
8423>>>>>        Integer iError
8423>>>>>        Handle hKey
8423>>>>>        
8423>>>>>        Get phCurrentKey to hKey
8424>>>>>        
8424>>>>>        If (hKey <>0) Begin
8426>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
8429>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
8431>>>>>            
8431>>>>>            Set phCurrentKey to 0
8432>>>>>        End
8432>>>>>>
8432>>>>>    End_Procedure
8433>>>>>    
8433>>>>>    Function OpenKey String sKeyName Returns Boolean
8435>>>>>        Handle hKey hKeyOpened
8435>>>>>        Integer iError
8435>>>>>        
8435>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8436>>>>>        
8436>>>>>        Get phRootKey to hKey
8437>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8438>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8441>>>>>        
8441>>>>>        Function_Return (iError=0)
8442>>>>>    End_Function
8443>>>>>    
8443>>>>>    Procedure WriteDword String sValue DWord dwValueData
8445>>>>>        Handle hKey
8445>>>>>        Integer iError
8445>>>>>        DWord dwData
8445>>>>>        String sError
8445>>>>>        
8445>>>>>        Move dwValueData to dwData
8446>>>>>        Get phCurrentKey to hKey
8447>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, AddressOf(dwData), SizeOfType(DWord))) to iError
8448>>>>>        If iError Begin
8450>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8451>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8452>>>>>>
8452>>>>>        End
8452>>>>>>
8452>>>>>    End_Procedure
8453>>>>>    
8453>>>>>    Procedure WriteString String sValue String sValueData
8455>>>>>        Handle hKey
8455>>>>>        Integer iError cbData
8455>>>>>        String sError
8455>>>>>        
8455>>>>>        If (sValueData = "") Begin
8457>>>>>            Move (Character(0)) to sValueData
8458>>>>>            Move 1 to cbData
8459>>>>>        End
8459>>>>>>
8459>>>>>        Else Begin
8460>>>>>            Move (Length(sValueData) +1) to cbData
8461>>>>>        End
8461>>>>>>
8461>>>>>        Move (ToAnsi(sValueData)) to sValueData
8462>>>>>        Get phCurrentKey to hKey
8463>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, AddressOf(sValueData), cbData)) to iError
8464>>>>>        If iError Begin
8466>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8467>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8468>>>>>>
8468>>>>>        End
8468>>>>>>
8468>>>>>    End_Procedure
8469>>>>>    
8469>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
8471>>>>>        Handle hKey
8471>>>>>        Integer iError
8471>>>>>        String sError
8471>>>>>        
8471>>>>>        Get phCurrentKey to hKey
8472>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) to iError
8473>>>>>        If iError Begin
8475>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8476>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8477>>>>>>
8477>>>>>        End
8477>>>>>>
8477>>>>>    End_Procedure
8478>>>>>    
8478>>>>>    Function ReadDword String sValueName Returns DWord
8480>>>>>        Handle hKey
8480>>>>>        Integer iError
8480>>>>>        DWord dwValueData dwValueDataLength
8480>>>>>        String sError
8480>>>>>        
8480>>>>>        Move 0           to dwValueData
8481>>>>>        Move (SizeOfType(DWord)) to dwValueDataLength
8482>>>>>        
8482>>>>>        Get phCurrentKey to hKey
8483>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) to iError
8484>>>>>        If iError Begin
8486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8488>>>>>>
8488>>>>>        End
8488>>>>>>
8488>>>>>        
8488>>>>>        Function_Return dwValueData
8489>>>>>    End_Function
8490>>>>>    
8490>>>>>    Function ReadString String sValueName Returns String
8492>>>>>        Handle hKey
8492>>>>>        Integer iError
8492>>>>>        String sValueData
8492>>>>>        DWord dwValueDataLength
8492>>>>>        Pointer lpsValueData
8492>>>>>        String sError
8492>>>>>        
8492>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to sValueData
8493>>>>>        Move (AddressOf(sValueData)) to lpsValueData
8494>>>>>        
8494>>>>>        Move (Length(sValueData)) to dwValueDataLength
8495>>>>>        
8495>>>>>        Get phCurrentKey to hKey
8496>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) to iError
8497>>>>>        If iError Begin
8499>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8500>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8501>>>>>>
8501>>>>>        End
8501>>>>>>
8501>>>>>        
8501>>>>>        Function_Return (ToOem(CString(sValueData)))
8502>>>>>    End_Function
8503>>>>>    
8503>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
8505>>>>>        Handle hKey
8505>>>>>        Integer iError
8505>>>>>        String sError
8505>>>>>        
8505>>>>>        Get phCurrentKey to hKey
8506>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) to iError
8507>>>>>        If iError Begin
8509>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8510>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8511>>>>>>
8511>>>>>        End
8511>>>>>>
8511>>>>>        
8511>>>>>        Function_Return (iDataLength >0)
8512>>>>>    End_Function
8513>>>>>    
8513>>>>>    
8513>>>>>    // Private....
8513>>>>>    Function GetBaseKey Returns Handle
8515>>>>>        Handle hBaseKey
8515>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
8518>>>>>        Else ;            Get phCurrentKey to hBaseKey
8520>>>>>        
8520>>>>>        Function_Return hBaseKey
8521>>>>>    End_Function
8522>>>>>    
8522>>>>>    Function GetKey String sKeyName Returns Handle
8524>>>>>        Handle hKeyOpened
8524>>>>>        Integer iError
8524>>>>>        
8524>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
8525>>>>>        
8525>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8526>>>>>        
8526>>>>>        If (iError =0) ;            Function_Return hKeyOpened
8529>>>>>        Else ;            Function_Return 0
8531>>>>>    End_Function
8532>>>>>    
8532>>>>>    // Public
8532>>>>>    Function KeyExists String sKeyName Returns Boolean
8534>>>>>        Handle hKey
8534>>>>>        Integer iVoid
8534>>>>>        
8534>>>>>        Get GetKey sKeyName to hKey
8535>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
8538>>>>>        Function_Return (hKey <>0)
8539>>>>>    End_Function
8540>>>>>    
8540>>>>>    Function ValueExists String sValueName Returns Boolean
8542>>>>>        // Determines whether a Value exists for the currently-opened Key.
8542>>>>>        Integer iError
8542>>>>>        DWord dwDataType
8542>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
8543>>>>>        
8543>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) to iError
8544>>>>>        
8544>>>>>        Function_Return (iError=0)
8545>>>>>    End_Function
8546>>>>>    
8546>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
8548>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), ToAnsi(sKeyName)) =0)
8549>>>>>    End_Function
8550>>>>>    
8550>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
8552>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), ToAnsi(sValueName)) =0)
8553>>>>>    End_Function
8554>>>>>    
8554>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
8556>>>>>        Integer iError
8556>>>>>        Integer icValue iLongestSubkey
8556>>>>>        Handle hKey
8556>>>>>        DWord dwSubkeyNameLength
8556>>>>>        String sSubkeyName
8556>>>>>        tWinFileTime FileTime
8556>>>>>        tWinFileTime FileTime
8556>>>>>        
8556>>>>>        Get LongestSubkeyLength to iLongestSubkey
8557>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
8558>>>>>        
8558>>>>>        Get phCurrentKey to hKey
8559>>>>>        Repeat
8559>>>>>>
8559>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
8560>>>>>            
8560>>>>>            Move (RegEnumKeyEx(hKey, icValue, AddressOf(sSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
8561>>>>>            If (iError =0) Begin
8563>>>>>                Increment icValue
8564>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sSubkeyName)))
8565>>>>>            End
8565>>>>>>
8565>>>>>        Until (iError)
8567>>>>>        Function_Return icValue
8568>>>>>        
8568>>>>>    End_Function
8569>>>>>    
8569>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
8571>>>>>        Integer iError
8571>>>>>        Integer icValue iLongestValue
8571>>>>>        Handle hKey
8571>>>>>        DWord dwValueNameLength
8571>>>>>        String sValueName sValueNameSize
8571>>>>>        Pointer lpsValueName
8571>>>>>        
8571>>>>>        Get LongestValueLength to iLongestValue
8572>>>>>        Move (Repeat(character(0), iLongestValue +1)) to sValueName
8573>>>>>        Move (AddressOf(sValueName)) to lpsValueName
8574>>>>>        
8574>>>>>        Get phCurrentKey to hKey
8575>>>>>        Repeat
8575>>>>>>
8575>>>>>            Move (iLongestValue +1) to dwValueNameLength
8576>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
8577>>>>>            If (iError =0) Begin
8579>>>>>                Increment icValue
8580>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sValueName)))
8581>>>>>            End
8581>>>>>>
8581>>>>>        Until (iError)
8583>>>>>        Function_Return icValue
8584>>>>>        
8584>>>>>    End_Function
8585>>>>>    
8585>>>>>End_Class
8586>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cVersionInfo.pkg)
8586>>>>>Use VdfBase.pkg
8586>>>>>Use DLL.pkg
8586>>>>>Use tWinStructs.pkg
8586>>>>>Use WinKern.pkg
8586>>>>>
8586>>>>>Define VS_FF_DEBUG         for |CI$00000001
8586>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
8586>>>>>Define VS_FF_PATCHED       for |CI$00000004
8586>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
8586>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
8586>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
8586>>>>>
8586>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
8587>>>>>
8587>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    DWord dwHandle ;    DWord dwLen ;    Address aData ;    Returns Integer
8588>>>>>
8588>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;    Returns Integer
8589>>>>>
8589>>>>>
8589>>>>>Class cVersionInfo is a cObject
8590>>>>>    Procedure Construct_Object
8592>>>>>        Forward Send Construct_Object
8594>>>>>        
8594>>>>>        
8594>>>>>        Property Integer piVersionMajor
8595>>>>>        Property Integer piVersionMinor
8596>>>>>        Property Integer piVersionRelease
8597>>>>>        Property Integer piVersionBuild
8598>>>>>        
8598>>>>>        Property Boolean pbIncluded
8599>>>>>        Property Boolean pbSpecialBuild
8600>>>>>        Property Boolean pbPrivateBuild
8601>>>>>        
8601>>>>>    End_Procedure
8602>>>>>    
8602>>>>>    Procedure DoCreate String sFileName
8604>>>>>        DWord dwHandle
8604>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
8604>>>>>        String sData
8604>>>>>        String sVersionBuffer
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        String sSubBlock
8604>>>>>        Address aVsFixedFileInfo
8604>>>>>        
8604>>>>>        Move 0 to aVsFixedFileInfo
8605>>>>>        Move 0 to dwHandle
8606>>>>>        Move 0 to iVerSize
8607>>>>>        
8607>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
8608>>>>>        Set pbIncluded to (iInfoSize <>0)
8609>>>>>        
8609>>>>>        If (pbIncluded(Self)) Begin
8611>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
8612>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
8613>>>>>            
8613>>>>>            If (iSuccess <>0) Begin
8615>>>>>                Move "\" to sSubBlock
8616>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
8618>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
8619>>>>>                    
8619>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
8620>>>>>                    Set piVersionMajor to (Hi(iVersion))
8621>>>>>                    Set piVersionMinor to (Low(iVersion))
8622>>>>>                    
8622>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
8623>>>>>                    Set piVersionRelease to (Hi(iVersion))
8624>>>>>                    Set piVersionBuild   to (Low(iVersion))
8625>>>>>                    
8625>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
8626>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
8627>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
8628>>>>>                End
8628>>>>>>
8628>>>>>            End
8628>>>>>>
8628>>>>>            
8628>>>>>        End
8628>>>>>>
8628>>>>>    End_Procedure
8629>>>>>    
8629>>>>>End_Class
8630>>>Use GlobalFunctionsProcedures.pkg
8630>>>Use tWinStructs.pkg
8630>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
8630>>>
8630>>>Register_Function phoWorkspace Returns Handle
8630>>>Register_Function phoCommandLine Returns Handle
8630>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8630>>>Register_Function GetApplicationName Returns String
8630>>>Register_Function GetApplicationFileName Returns String
8630>>>
8630>>>Register_Function Statusbar_State Returns Integer
8630>>>Register_Function Toolbar_State Returns Integer
8630>>>Register_Procedure Set Statusbar_State
8630>>>Register_Procedure Set Toolbar_State
8630>>>
8630>>>
8630>>>Class cApplication is a cObject
8631>>>    Procedure Construct_Object
8633>>>        Forward Send Construct_Object
8635>>>        
8635>>>        Move Self to ghoApplication
8636>>>        
8636>>>        Property Handle phoVersionInfo
8637>>>        Property Handle phoWorkspace
8638>>>        Property Handle phoCommandLine
8639>>>        Property Handle phoMainPanel       // main panel will set this for us.
8640>>>        Property String psHelpFile         // type of file is determined by peHelpType
8641>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8642>>>        
8642>>>        Property String psCompany "Data Access Worldwide"
8643>>>        Property String psProduct "DataFlex Applications"
8644>>>        Property String psVersion C_DFVersion
8645>>>        Property String psProgram (Module_Name(desktop))
8646>>>        
8646>>>        // set to '' to stop the auto open workspace behavior
8646>>>        Property String psAutoOpenWorkspace 'Config.ws'
8647>>>        
8647>>>        
8647>>>        Property Boolean pbPreserveEnvironment True
8648>>>        
8648>>>        Object oCommandLine is a cCommandLine
8650>>>            Delegate Set phoCommandLine to Self
8652>>>        End_Object
8653>>>        
8653>>>        Object oWorkspace is a cWorkspace
8655>>>            Delegate Set phoWorkspace to Self
8657>>>        End_Object
8658>>>        
8658>>>        Object oVersionInfo is a cVersionInfo
8660>>>            Delegate Set phoVersionInfo to Self
8662>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
8663>>>        End_Object
8664>>>        
8664>>>        Set pbUseWindowsFont to True
8665>>>        
8665>>>    End_Procedure
8666>>>    
8666>>>    Procedure Destroy_Object
8668>>>        If (ghoApplication=Self) Begin
8670>>>            Move 0 to ghoApplication
8671>>>        End
8671>>>>
8671>>>        Forward Send Destroy_Object
8673>>>    End_Procedure
8674>>>    
8674>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8674>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8674>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8676>>>        Move bNext to gbKEnterNext
8677>>>    End_Procedure
8678>>>    
8678>>>    Function pbEnterKeyAsTabKey Returns Boolean
8680>>>        Function_Return gbKEnterNext
8681>>>    End_Function
8682>>>    
8682>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8684>>>// not used with webapp
8684>>>        Handle hoRegistry hoCommandBars
8684>>>        Handle hMonitor
8684>>>        Integer iError cxy
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        String sKey
8684>>>        Boolean bSuccess
8684>>>        String sObjectName
8684>>>        
8684>>>        If (pbPreserveEnvironment(Self)) Begin
8686>>>            Get Create U_cRegistry to hoRegistry
8687>>>            Set pfAccessRights of hoRegistry to KEY_READ
8688>>>            
8688>>>            Get RegistryKeyString to sKey
8689>>>            
8689>>>            If (bProgram = False) Begin
8691>>>                Move (sKey +"\WINDOWS") to sKey
8692>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8693>>>                Move (sKey +"\" +sObjectName) to sKey
8694>>>            End
8694>>>>
8694>>>            Else ;                Move (sKey + "\Preferences") to sKey
8696>>>            
8696>>>            Get OpenKey of hoRegistry sKey to bSuccess
8697>>>            
8697>>>            If bSuccess Begin
8699>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8701>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8702>>>                    If bSuccess Begin
8704>>>                        // Do not restore size if the window is not resizable
8704>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8706>>>                            // restore always works with outer size
8706>>>                            Get GuiWindowSize     of hoContainer to cxy
8707>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
8708>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8709>>>                        End
8709>>>>
8709>>>                        
8709>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
8709>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
8709>>>                        If (bProgram) Begin
8711>>>                            // Test the top left point
8711>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
8712>>>                            
8712>>>                            If (hMonitor = 0) Begin
8714>>>                                // test the bottom right point
8714>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
8715>>>                            End
8715>>>>
8715>>>                            
8715>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
8715>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
8715>>>                            If (hMonitor = 0) Begin
8717>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
8718>>>                            End
8718>>>>
8718>>>                        End
8718>>>>
8718>>>                        
8718>>>                        // Set the placement
8718>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8719>>>                    End
8719>>>>
8719>>>                End
8719>>>>
8719>>>                If bProgram Begin
8721>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8722>>>                    If not hoCommandBars Begin
8724>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8727>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8730>>>                    End
8730>>>>
8730>>>                End
8730>>>>
8730>>>                
8730>>>                Send CloseKey of hoRegistry
8731>>>            End
8731>>>>
8731>>>            
8731>>>            Send Destroy of hoRegistry
8732>>>        End
8732>>>>
8732>>>    End_Procedure
8733>>>    
8733>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8735>>>// not used with webapp
8735>>>        Handle hoRegistry
8735>>>        Integer iError
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        String sKey
8735>>>        Boolean bSuccess
8735>>>        Integer eShowCmd
8735>>>        String sObjectName
8735>>>        
8735>>>        If (pbPreserveEnvironment(Self)) Begin
8737>>>            Get Create U_cRegistry to hoRegistry
8738>>>            Get RegistryKeyString to sKey
8739>>>            
8739>>>            If (bProgram = False) Begin
8741>>>                Move (sKey +"\WINDOWS") to sKey
8742>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8743>>>                Move (sKey +"\" +sObjectName) to sKey
8744>>>            End
8744>>>>
8744>>>            Else ;                Move (sKey +"\Preferences") to sKey
8746>>>            
8746>>>            Get CreateKey of hoRegistry sKey to iError
8747>>>            If (iError = 0) Begin
8749>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8750>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8751>>>                If bSuccess Begin
8753>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8753>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8755>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8756>>>                    End
8756>>>>
8756>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8757>>>                End
8757>>>>
8757>>>                
8757>>>                If bProgram Begin
8759>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8760>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8761>>>                End
8761>>>>
8761>>>                
8761>>>                
8761>>>                Send CloseKey of hoRegistry
8762>>>            End
8762>>>>
8762>>>            
8762>>>            Send Destroy of hoRegistry
8763>>>        End
8763>>>>
8763>>>    End_Procedure
8764>>>    
8764>>>    
8764>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
8766>>>        Integer ixySize ixSize iySize
8766>>>        Integer ixOffset iyOffset
8766>>>        
8766>>>        // first calculate the offset needed to move onto the main monitor at 0,0
8766>>>        Move (0 - WindowPos.left) to ixOffset
8767>>>        Move (0 - WindowPos.top) to iyOffset
8768>>>        
8768>>>        Move 0 to WindowPos.left
8769>>>        Move 0 to WindowPos.top
8770>>>        
8770>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
8771>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
8772>>>        
8772>>>        // also make sure that the size of the window is <= the size of the main monitor
8772>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
8773>>>        Move (low(ixySize))      to ixSize
8774>>>        Move (hi(ixySize))       to iySize
8775>>>        
8775>>>        Move (ixSize min WindowPos.right) to WindowPos.right
8776>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
8777>>>    End_Procedure
8778>>>    
8778>>>    
8778>>>    Function RegistryKeyString Returns String
8780>>>        String sCompany sProduct sVersion sProgram
8780>>>        
8780>>>        Get psCompany to sCompany
8781>>>        Get psProduct to sProduct
8782>>>        Get psVersion to sVersion
8783>>>        Get psProgram to sProgram
8784>>>        
8784>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
8787>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
8790>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
8793>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
8796>>>        
8796>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8797>>>    End_Function
8798>>>    
8798>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8800>>>        String sKey
8800>>>        Handle hoRegistry
8800>>>        Integer iError
8800>>>        
8800>>>        Get Create U_cRegistry to hoRegistry
8801>>>        Get RegistryKeyString to sKey
8802>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8805>>>        Get CreateKey of hoRegistry sKey to iError
8806>>>        If (iError = 0) Begin
8808>>>            Send WriteString of hoRegistry sValueName sValueData
8809>>>            Send CloseKey of hoRegistry
8810>>>        End
8810>>>>
8810>>>        
8810>>>        Send Destroy of hoRegistry
8811>>>    End_Procedure
8812>>>    Procedure WriteDword String sSubKey String sValueName DWord dwValueData
8814>>>        String sKey
8814>>>        Handle hoRegistry
8814>>>        Integer iError
8814>>>        
8814>>>        Get Create U_cRegistry to hoRegistry
8815>>>        Get RegistryKeyString to sKey
8816>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8819>>>        Get CreateKey of hoRegistry sKey to iError
8820>>>        If (iError = 0) Begin
8822>>>            Send WriteDword of hoRegistry sValueName dwValueData
8823>>>            Send CloseKey of hoRegistry
8824>>>        End
8824>>>>
8824>>>        
8824>>>        Send Destroy of hoRegistry
8825>>>    End_Procedure
8826>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
8828>>>        String sKey
8828>>>        Handle hoRegistry
8828>>>        Integer iError
8828>>>        
8828>>>        Get Create U_cRegistry to hoRegistry
8829>>>        Get RegistryKeyString to sKey
8830>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8833>>>        Get CreateKey of hoRegistry sKey to iError
8834>>>        If (iError = 0) Begin
8836>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
8837>>>            Send CloseKey of hoRegistry
8838>>>        End
8838>>>>
8838>>>        
8838>>>        Send Destroy of hoRegistry
8839>>>    End_Procedure
8840>>>    
8840>>>    // returns true if both sub-key and value exists.
8840>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
8842>>>        String sKey
8842>>>        Handle hoRegistry
8842>>>        Boolean bOK
8842>>>        Get Create U_cRegistry to hoRegistry
8843>>>        Get RegistryKeyString to sKey
8844>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8847>>>        Get OpenKey of hoRegistry sKey to bOk
8848>>>        If (bOK) Begin
8850>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
8851>>>            Send CloseKey of hoRegistry
8852>>>        End
8852>>>>
8852>>>        Send Destroy of hoRegistry
8853>>>        Function_Return bOk
8854>>>    End_Function
8855>>>    
8855>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
8857>>>        String sKey sData
8857>>>        Handle hoRegistry
8857>>>        Boolean bOK
8857>>>        
8857>>>        Move sDefault to sData
8858>>>        Get Create U_cRegistry to hoRegistry
8859>>>        Get RegistryKeyString to sKey
8860>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8863>>>        Get OpenKey of hoRegistry sKey to bOk
8864>>>        If (bOK) Begin
8866>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
8869>>>            Send CloseKey of hoRegistry
8870>>>        End
8870>>>>
8870>>>        
8870>>>        Send Destroy of hoRegistry
8871>>>        Function_Return sData
8872>>>    End_Function
8873>>>    
8873>>>    Function ReadDword String sSubKey String sValueName DWord dwDefault Returns DWord
8875>>>        String sKey
8875>>>        DWord dwData
8875>>>        Handle hoRegistry
8875>>>        Boolean bOK
8875>>>        
8875>>>        Move dwDefault to dwData
8876>>>        Get Create U_cRegistry to hoRegistry
8877>>>        Get RegistryKeyString to sKey
8878>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8881>>>        Get OpenKey of hoRegistry sKey to bOk
8882>>>        If bOK Begin
8884>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName to dwData
8887>>>            Send CloseKey of hoRegistry
8888>>>        End
8888>>>>
8888>>>        
8888>>>        Send Destroy of hoRegistry
8889>>>        Function_Return dwData
8890>>>    End_Function
8891>>>    
8891>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
8893>>>        String sKey
8893>>>        Handle hoRegistry
8893>>>        Boolean bOK bSuccess
8893>>>        
8893>>>        Get Create U_cRegistry to hoRegistry
8894>>>        Get RegistryKeyString to sKey
8895>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8898>>>        Get OpenKey of hoRegistry sKey to bOk
8899>>>        If bOK Begin
8901>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength to bSuccess
8902>>>            Send CloseKey of hoRegistry
8903>>>        End
8903>>>>
8903>>>        
8903>>>        Send Destroy of hoRegistry
8904>>>        Function_Return bSuccess
8905>>>    End_Function
8906>>>    
8906>>>    Procedure DoOpenWorkspace String sWorkspace
8908>>>        // Tries to open in this order:
8908>>>        // 1) if absolute path, use that; otherwise
8908>>>        // 2) try to open in the path of the EXE; otherwise
8908>>>        // 3) load it via the Registered list
8908>>>        
8908>>>        Integer eOpened
8908>>>        String sError sWSFile
8908>>>        Handle hoWorkspace
8908>>>        Boolean bChangingWorkspace
8908>>>        
8908>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
8908>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
8908>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
8908>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
8908>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
8908>>>        // that there should be no automatic opening of a worskpace.
8908>>>        Set psAutoOpenWorkspace to ""
8909>>>        
8909>>>        Get phoWorkspace to hoWorkspace
8910>>>        
8910>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
8911>>>        If (bChangingWorkspace and ghoConnection) Begin
8913>>>            Send AutoDisconnect
8914>>>        End
8914>>>>
8914>>>        
8914>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
8915>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
8917>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
8919>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
8920>>>            End
8920>>>>
8920>>>        End
8920>>>>
8920>>>        If (eOpened <> wsWorkspaceOpened) Begin
8922>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
8923>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
8924>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
8925>>>>
8925>>>            Abort
8926>>>>
8926>>>        End
8926>>>>
8926>>>        Else Begin
8927>>>            Send AutoConnect
8928>>>            Send OnWorkspaceOpened
8929>>>        End
8929>>>>
8929>>>    End_Procedure
8930>>>    
8930>>>    Procedure AutoConnect
8932>>>        If (ghoConnection) Begin
8934>>>            Send AutoConnect of ghoConnection
8935>>>        End
8935>>>>
8935>>>    End_Procedure
8936>>>    
8936>>>    Procedure AutoDisconnect
8938>>>        If (ghoConnection) Begin
8940>>>            Send AutoDisconnect of ghoConnection
8941>>>        End
8941>>>>
8941>>>    End_Procedure
8942>>>    
8942>>>    // send after a workspace is successfully opened and connected
8942>>>    Procedure OnWorkspaceOpened
8944>>>    End_Procedure
8945>>>    
8945>>>    Procedure OnCreate
8947>>>        // Event called when the Application object is ready to be used
8947>>>        // to open a Workspace, etc.
8947>>>    End_Procedure
8948>>>    
8948>>>    Procedure End_Construct_Object
8950>>>        String sName
8950>>>        Forward Send End_Construct_Object
8952>>>        Send OnCreate
8953>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
8953>>>        Get psAutoOpenWorkspace to sName
8954>>>        If (sName<>"") Begin
8956>>>            Send DoOpenWorkspace sName
8957>>>        End
8957>>>>
8957>>>    End_Procedure
8958>>>    
8958>>>    Function GetApplicationFileName Returns String
8960>>>        // Returns the filename from Windows
8960>>>        Integer iNumChars
8960>>>        String sFilename
8960>>>        
8960>>>        Move (Repeat(Character(0), 1024)) to sFileName
8961>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) to iNumChars
8962>>>        
8962>>>        Function_Return (CString(sFilename))
8963>>>    End_Function
8964>>>    
8964>>>    Function GetApplicationPath Returns String
8966>>>        // Returns the path of the Application (no trailing "\")
8966>>>        String sApplicationFileName sPath
8966>>>        Boolean bRemoved
8966>>>        
8966>>>        Get GetApplicationFileName  to sApplicationFileName
8967>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
8968>>>        Move (CString(sApplicationFileName)) to sPath
8969>>>        
8969>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8972>>>        Function_Return sPath
8973>>>    End_Function
8974>>>    
8974>>>    Function GetApplicationName Returns String
8976>>>        // Returns the name of the Application (without its Path or Extension)
8976>>>        String sApplicationFileName sApplicationName
8976>>>        Boolean bRemoved
8976>>>        Integer iVoid
8976>>>        
8976>>>        Get GetApplicationFileName to sApplicationFileName
8977>>>        Move (ExtractFileName(sApplicationFileName)) to sApplicationName
8978>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) to iVoid
8979>>>        Function_Return (CString(sApplicationName))
8980>>>    End_Function
8981>>>    
8981>>>    Function DFRootPath Returns String
8983>>>        String sRoot
8983>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
8986>>>        // Ensure it does not contain a trailing "\"
8986>>>        If (Right(sRoot,1) = "\") Begin
8988>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
8989>>>        End
8989>>>>
8989>>>        Function_Return sRoot
8990>>>    End_Function
8991>>>    
8991>>>    Function DFBinPath Returns String
8993>>>        String sRoot
8993>>>        Get DFRootPath to sRoot
8994>>>        If (sRoot<>"") Begin
8996>>>            Move (sRoot+"\bin") to sRoot
8997>>>        End
8997>>>>
8997>>>        Else Begin
8998>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
8998>>>            // bin path must be the same as the application path.
8998>>>            Get GetApplicationPath to sRoot
8999>>>        End
8999>>>>
8999>>>        Function_Return sRoot
9000>>>    End_Function
9001>>>    
9001>>>    // this just directs to the desktop property. If you are using an application object you are
9001>>>    // encouraged to set this here.
9001>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
9003>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
9004>>>    End_Procedure
9005>>>    
9005>>>    Function pbUseWindowsFont Returns Boolean
9007>>>        Boolean bUseWindowsFont
9007>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
9008>>>        Function_Return bUseWindowsFont
9009>>>    End_Function
9010>>>    
9010>>>    // this just directs to the desktop property. If you are using an application object you are
9010>>>    // encouraged to set this here.
9010>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
9012>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
9013>>>    End_Procedure
9014>>>    
9014>>>    Function pbLegacyDialogRatio Returns Boolean
9016>>>        Boolean bLegacy
9016>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
9017>>>        Function_Return bLegacy
9018>>>    End_Function
9019>>>End_Class
9020>>>
9020>>>
9020>Define CS_CompileTimeHeaderFile for "CompileHeader.h"
9020>
9020>Object oApplication is a cApplication
9022>
9022>    Procedure CreateCompileHeaderFile
9025>        DateTime dtCurrentDateTime
9025>        String sPath
9025>        
9025>        Move (psDataPath(phoWorkspace(Self))) to sPath
9026>        If (Right(sPath, 1) <> "\") Begin
9028>            Move (sPath +"\") to sPath
9029>        End
9029>        Move (CurrentDateTime()) to dtCurrentDateTime
9030>        
9030>        Direct_Output (sPath + CS_CompileTimeHeaderFile)
9031>            Writeln ("Define C$_CompileDateTime for" * '"' + String(dtCurrentDateTime) + '"')
9033>       Close_Output
9034>
9034>    End_Procedure
9035>
9035>    Procedure OnWorkspaceOpened
9038>        Send CreateCompileHeaderFile
9039>    End_Procedure
9040>    
9040>End_Object
9041>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 9956
Total Resources: 0
Total Commands : 9040
Total Windows  : 0
Total Pages    : 0
Static Data    : 93422
Message area   : 49985
Total Blocks   : 4986
