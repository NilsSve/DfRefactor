// Copyright (c) 2018 Nils Svedmyr, RDC Tools International
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to Do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in All
// copies or substantial portions of the Software.
//
// THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
// IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
// FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
// LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
// OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Functions to support export & import of defined functions from one amchine to another.
// It exports the data from the Functions.dat table to a fixed format. It then scans the cRefactorfunctionLibrar.pkg global refactoring repository for the corresponding code base,
// and makes a copy of the function code text.
// When imported to another machine the selected Functions.dat records will be added that does *not* already exist, with the same function name. It does *not* attempt to make an update of existing data.
// The code base will be appended at the end of the cRefactorfunctionLibrar class.
Use Windows.pkg
Use File_dlg.pkg
Use cJsonObject.pkg
Use WsGlobalFunctions.pkg
Use cRDCAutoCreateNewID.pkg
Use RefactorConstants.h.pkg

Use vWin32fh.pkg

Open FunctionsA
Open SysFile

// Global handle to the import/Export functions. Used for export/import.
Global_Variable Handle ghoImportExportFunctions
Move 0 to ghoImportExportFunctions

Class cImportExportFunctions is a cObject
    Procedure Construct_Object
        Forward Send Construct_Object
        
        Property Integer piNoOfFunctions
        Property String  psLineBreak ""
        Property String[] pasMissingUnitFunctions
    End_Procedure
    
    Procedure SEARCH_HELPER_FUNCTIONS
    End_Procedure
    //
    // Custom search functions for string arrays
    // Note that the compiler must have found these declarations before they can be used in code.
    Function _FindFunctionCode String sSourceLine String sSearchText Returns Integer  
        If (Lowercase(sSourceLine) contains Lowercase(sSearchText)) ;
            Function_Return (EQ)
        Function_Return (GT)
    End_Function
    
    Function _FindEndCode String sSourceLine String sSearchText Returns Integer  
        If (Trim(Lowercase(sSourceLine)) = Lowercase(sSearchText)) ;
            Function_Return (EQ)
        Function_Return (GT)
    End_Function
    
    Function GenerateJsonExportFile tExportImport ExportImport String sFileName Returns Boolean
        Handle hoJson 
        Boolean bOK
        
        Move False to Err
        Get Create (RefClass(cJsonObject)) to hoJson
        Send DataTypeToJson of hoJson ExportImport
        Move (Err = False) to bOK
        If (bOK = True) Begin
            Get WriteJsonToFile sFileName hoJson to bOK 
        End
        Send Destroy of hoJson
        
        Function_Return bOK
    End_Function  
    
    Procedure CREATE_JSON_EXPORT_FILE
    End_Procedure
    //
    Function WriteJsonToFile String sFileName Handle hoJson Returns Boolean
        UChar[] ucJson
        Boolean bExists
        Integer iCh
        
        Set peWhiteSpace  of hoJson to jpWhitespace_Pretty
        Get StringifyUtf8 of hoJson to ucJson
        If (Err = True) Begin
            Function_Return False
        End
        
        Get OpenOutput sFileName to iCh
        If (iCh < 0) Begin
            Function_Return False
        End    
        // Cannot write a BOM character! It will make the ParseUtf8 function to fail!
//        Write channel iCh C_BOM_UTF8
        Write channel iCh ucJson
        Send CloseOutput iCh
        File_Exist sFileName bExists
        
        Function_Return bExists
    End_Function
    
    Procedure READ_JSON_FILE
    End_Procedure
    //
    Function ReadJsonFile String sFileName Integer ByRef iErrors Returns UChar[]
        Integer iCh
        UChar[] uImportFileData
        
        Get OpenInput sFileName to iCh
        If (iCh < 0) Begin
            Move 1 to iErrors
            Function_Return uImportFileData
        End
        
        Set piNoOfFunctions to 0
        Read_Block channel iCh uImportFileData -1
        
        Send CloseInput iCh
        Function_Return uImportFileData
    End_Function
    
    // Parse Uchar array to tExportImport struct and save data.
    Function ParseJsonData UChar[] uImportFileData String ByRef sParseError Returns Boolean
        Handle hoJson
        Boolean bOK
        tExportImport ExportImport 
        
        Get Create (RefClass(cJsonObject)) to hoJson
        Set pbRequireAllMembers of hoJson to False
        Get ParseUtf8 of hoJson uImportFileData to bOK
        If (bOK = False) Begin 
            // The sParseError byref value will be shown in an info_box
            Get psParseError of hoJson to sParseError
            Send Destroy of hoJson
            Function_Return False
        End
        
        Get JsonToDataType of hoJson to ExportImport
        Get SaveImportData ExportImport to bOK
        
        Send Destroy of hoJson
        Function_Return bOK
    End_Function
    
    Function SaveImportData tExportImport ExportImport Returns Boolean
        Integer iCount iSize iRow iRows
        Boolean bOK bErr
        tFunctionData asData
        tFunctionCode asCode 
        tUnitTestCode asUnit
        String[] asFunctionLibraryFile asFunctionLibraryFileLC
        String[] asUnitTestsFile asUnitTestsFileLC
        
        Get ReadUnitTestsFile (&iSize) to asUnitTestsFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_UnitTestsFile) * "file")
            Function_Return False
        End
        Get LowercaseCodeLibrary asUnitTestsFile to asUnitTestsFileLC
        // Remove the last "End_Object" line, and the line after it in CS_UnitTestsFile
        Move (SizeOfArray(asUnitTestsFile)) to iSize
        Decrement iSize
        Move (ResizeArray(asUnitTestsFile, iSize)) to asUnitTestsFile
        Move (ResizeArray(asUnitTestsFileLC, iSize)) to asUnitTestsFileLC
        
        // Needs to be after we have read the Unit test file:
        Get ReadCodeLibraryFile False (&iSize) to asFunctionLibraryFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_FunctionLibraryFile) * "file")
            Function_Return False
        End
        
        Get LowercaseCodeLibrary asFunctionLibraryFile to asFunctionLibraryFileLC
        // Remove the two comment lines, the "End_Object" and any blank lines there after from function library file.
        Move (SearchArray(CS_EndObject, asFunctionLibraryFileLC, Self, RefFunc(_FindEndCode))) to iRow
        If (iRow <> -1) Begin
            If (asFunctionLibraryFile[iRow -2] = CS_Comment1) Begin
                Move (iRow - 3) to iRow
            End
            Move (SizeOfArray(asFunctionLibraryFile)) to iSize
            Move (iSize - (iSize - iRow)) to iRows
            Move (ResizeArray(asFunctionLibraryFile,   iRows)) to asFunctionLibraryFile
            Move (ResizeArray(asFunctionLibraryFileLC, iRows)) to asFunctionLibraryFileLC
        End
    
        Move ExportImport.iNoOfFunctions to iSize
        Decrement iSize
        Set piNoOfFunctions to iSize
        For iCount from 0 to iSize
            Move ExportImport.Data[iCount] to asData
            Get SaveDataToTable asData to bOK
            Move ExportImport.Code[iCount] to asCode
            Get RemoveEndOfLineCharacters asCode.CodeArray to asCode.CodeArray
            Move ExportImport.Unit[iCount] to asUnit  
            Get RemoveEndOfLineCharacters asUnit.UnitArray to asUnit.UnitArray
            // Update the two source file arrays, so we can
            // write them to disk when loop has finished.
            Get UpdateSourceCodeArray asCode asFunctionLibraryFile iCount (&bErr) to asFunctionLibraryFile   
            Get UpdateUnitCodeArray   asUnit asUnitTestsFile       iCount (&bErr) to asUnitTestsFile
        Loop
        
        // Write the updated source files back to disk:
        Get WriteCodeLibraryFile asFunctionLibraryFile to bOK
        If (bOK = True) Begin
            Get WriteUnitTestsFile asUnitTestsFile to bOK
        End
        Function_Return bOK
    End_Function  
    
    Function SaveDataToTable tFunctionData asData Returns Boolean
        Boolean bNew
        Integer iID  
        
        Move False to Err       
        Clear FunctionsA
        Move asData.Function_Name to FunctionsA.Function_Name
        Find eq FunctionsA.Function_Name
        Move (Found = False) to bNew    
        If (bNew = True) Begin
            Get AutoCreateNewID File_Field FunctionsA.ID True to iID
            Clear FunctionsA
            Move iID to FunctionsA.ID
            Move asData.Function_Name to FunctionsA.Function_Name
        End
        If (bNew = True) ;
            Lock
        Else ;
            Reread FunctionsA
                Move asData.Function_Help        to FunctionsA.Function_Help
                Move asData.SummaryText          to FunctionsA.SummaryText
                Move asData.Selected             to FunctionsA.Selected
                Move asData.Type                 to FunctionsA.Type
                Move asData.bHasParameter        to FunctionsA.bHasParameter
                Move asData.Parameter            to FunctionsA.Parameter
                Move asData.ParameterValidation  to FunctionsA.ParameterValidation 
                Move asData.ParameterHelp        to FunctionsA.ParameterHelp
                Move asData.bPrivate             to FunctionsA.bPrivate
                Move asData.bPublished           to FunctionsA.bPublished
                Move asData.Counter              to FunctionsA.Counter
                SaveRecord FunctionsA
            Unlock                   
            
        Function_Return (Err = False)
    End_Function 

    // The JsonObject class/StringifyUtf8 function outputs data with a LineFeed, but the Studio always 
    // saves source with CR+LF as the line delimiter because that is want the compiler wants.
    // So we strip from CR or LF characters so we can Add them later when writing the file. 
    Function RemoveEndOfLineCharacters String[] asCode Returns String[]
        Integer iSize iCount
        String sLine
        
        Move (SizeOfArray(asCode)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asCode[iCount] to sLine
            If (Right(sLine, 1) = CS_LF) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End                                               
            If (Right(sLine, 1) = CS_CR) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End                                               
            Move sLine to asCode[iCount]
        Loop
        Function_Return asCode        
    End_Function

    Procedure MAIN_EXPORT_FUNCTION
    End_Procedure
    //
    Function ExportFile String[] asFunctions String sFileName Returns Boolean
        Integer iSize iCount
        Boolean bOK
        String sUnitFunctions
        String[] asMissingUnitFunctions
        tExportImport ExportImport
        
        Move (SizeOfArray(asFunctions)) to iSize
        Decrement iSize
        If (iSize < 0) Begin
            Send Info_Box "Found no selected funtions to Export!"
            Function_Return False
        End
        
        Set pasMissingUnitFunctions to asMissingUnitFunctions
        Get FillExportImportStruct asFunctions to ExportImport
        Get GenerateJsonExportFile ExportImport sFileName to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        
        Get pasMissingUnitFunctions to asMissingUnitFunctions
        Move (SizeOfArray(asMissingUnitFunctions)) to iSize
        Decrement iSize
        If (iSize >= 0) Begin
            For iCount from 0 to iSize
                Append sUnitFunctions (Trim(asMissingUnitFunctions[iCount])) CS_CRLF
            Loop
            Send Info_Box ("Warning! Unit Tests are missing from the file:" * String(CS_UnitTestsFile) * "for some of the registered functions.\n\nYou should really consider to add 'Unit Tests' for them all:\n" + String(sUnitFunctions) +"\nHowever, dummy objects/procedures will be automatically created for them in" * String(CS_UnitTestsFile) * "when imported.\n\nPress Ctrl+C to copy this text.")
        End
        
        Function_Return bOK
    End_Function   
    
    Procedure MAIN_IMPORT_FUNCTION
    End_Procedure
    //
    Function ImportFile String sFileName Integer ByRef iFunctions Returns Integer 
        Integer iErrors iSize iCount
        UChar[] uImportFileData
        String sErrorText sUnitFunctions
        String[] asMissingUnitFunctions                                 
        Boolean bOK
        
        Move "" to sErrorText
        Set pasMissingUnitFunctions to asMissingUnitFunctions
        Get ReadJsonFile sFileName (&iErrors) to uImportFileData
        Get ParseJsonData uImportFileData (&sErrorText) to bOK
        If (bOK = False) Begin
            Send Info_Box ("Json parsing error:\n\n" + String(sErrorText))
            Function_Return 1
        End 

        Get pasMissingUnitFunctions to asMissingUnitFunctions
        Move (SizeOfArray(asMissingUnitFunctions)) to iSize
        Decrement iSize
        If (iSize >= 0) Begin
            For iCount from 0 to iSize
                Append sUnitFunctions (Trim(asMissingUnitFunctions[iCount])) CS_CRLF
            Loop
            Send Info_Box ("Warning! Unit Tests are missing from the file:" * String(CS_UnitTestsFile) * "for these functions.\n\nYou should really consider to add 'Unit Tests' for them all:\n" + String(sUnitFunctions) +"\n\nPress Ctrl+C to copy this text.")
        End
        
        Get piNoOfFunctions to iFunctions
        Function_Return 0
    End_Function
    
    Procedure STRUCTURE_FILL_FUNCTIONS
    End_Procedure
    //
    Function FillExportImportStruct String[] asFunctions Returns tExportImport
        tExportImport ExportImport
        tFunctionData[] FunctionDataArray
        tFunctionCode[] FunctionCodeArray
        
        Move (SizeOfArray(asFunctions)) to ExportImport.iNoOfFunctions
        Get FillFunctionDataArray asFunctions to ExportImport.Data
        Get FillFunctionCodeArray asFunctions to ExportImport.Code
        Get FillFunctionUnitArray asFunctions to ExportImport.Unit
        
        Function_Return ExportImport
    End_Function
    
    Function FillFunctionDataArray String[] asFunctionArray Returns tFunctionData[]
        tFunctionData[] FunctionDataArray
        Integer iSize iCount
        
        Move (SizeOfArray(asFunctionArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Clear FunctionsA
            Move asFunctionArray[iCount] to FunctionsA.Function_Name
            Find eq FunctionsA.Function_Name
            If (Found and FunctionsA.bPrivate = 0) Begin
                Move FunctionsA.ID                              to FunctionDataArray[iCount].ID
                Move (Trim(FunctionsA.Function_Name))           to FunctionDataArray[iCount].Function_Name
                Move (Trim(FunctionsA.Function_Help))           to FunctionDataArray[iCount].Function_Help
                Move (Trim(FunctionsA.SummaryText))             to FunctionDataArray[iCount].SummaryText
                Move FunctionsA.Selected                        to FunctionDataArray[iCount].Selected
                Move FunctionsA.Type                            to FunctionDataArray[iCount].Type
                Move FunctionsA.bHasParameter                   to FunctionDataArray[iCount].bHasParameter
                Move (Trim(FunctionsA.Parameter))               to FunctionDataArray[iCount].Parameter
                Move (Trim(FunctionsA.ParameterValidation))     to FunctionDataArray[iCount].ParameterValidation
                Move (Trim(FunctionsA.ParameterHelp))           to FunctionDataArray[iCount].ParameterHelp
                Move (Trim(FunctionsA.bPrivate))                to FunctionDataArray[iCount].bPrivate
                Move (Trim(FunctionsA.bPublished))              to FunctionDataArray[iCount].bPublished
                Move 0                                          to FunctionDataArray[iCount].Counter
            End
        Loop  
        
        Function_Return FunctionDataArray
    End_Function
    
    Function FillFunctionCodeArray String[] asFunctionArray Returns tFunctionCode[]
        tFunctionCode[] FunctionCodeArray
        String[] asCodeArray asFunctionLibraryFile asFunctionLibraryFileLC
        Integer iSize iCount
        
        Get ReadCodeLibraryFile False (&iSize) to asFunctionLibraryFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_FunctionLibraryFile) * "file")
            Function_Return FunctionCodeArray
        End
        Get LowercaseCodeLibrary asFunctionLibraryFile to asFunctionLibraryFileLC 
        Move (SizeOfArray(asFunctionArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Clear FunctionsA
            Move asFunctionArray[iCount] to FunctionsA.Function_Name
            Find eq FunctionsA.Function_Name
            If (Found and FunctionsA.bPrivate = 0) Begin
                Get CopyFunctionCode asFunctionLibraryFile asFunctionLibraryFileLC FunctionsA.Function_Name to asCodeArray
                Move (Trim(FunctionsA.Function_Name))   to FunctionCodeArray[iCount].sFunctionName
                Move (SizeOfArray(asCodeArray))         to FunctionCodeArray[iCount].iSourceLines
                Move asCodeArray                        to FunctionCodeArray[iCount].CodeArray
            End
        Loop
        
        Function_Return FunctionCodeArray
    End_Function
    
    Function FillFunctionUnitArray String[] asFunctionArray Returns tUnitTestCode[]
        tUnitTestCode[] UnitTestCodeArray
        String[] asUnitArray asUnitTestFile asUnitTestFileLC
        Integer iSize iCount
        
        Get ReadUnitTestsFile (&iSize) to asUnitTestFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_UnitTestsFile) * "file")
            Function_Return UnitTestCodeArray
        End
        Get LowercaseCodeLibrary asUnitTestFile to asUnitTestFileLC 
        Move (SizeOfArray(asFunctionArray)) to iSize
        Decrement iSize

        // We have a special case with the "Tokenizer" function of the cBaseFuncLib class. It isn't
        // registered (for obvious reasons) in the Functions data table, *but* we do want to have
        // unit tests for that function. Thus we add that info here outside of the Functions loop above:
        Get CopyUnitCode asUnitTestFile asUnitTestFileLC CS_UnitTestsTokenizerFunc to asUnitArray
        Move CS_UnitTestsTokenizerFunc  to UnitTestCodeArray[0].sFunctionName
        Move (SizeOfArray(asUnitArray)) to UnitTestCodeArray[0].iSourceLines
        Move asUnitArray                to UnitTestCodeArray[0].UnitArray
        
        For iCount from 0 to iSize
            Clear FunctionsA
            Move asFunctionArray[iCount] to FunctionsA.Function_Name
            Find eq FunctionsA.Function_Name
            If (Found) Begin
                Get CopyUnitCode asUnitTestFile asUnitTestFileLC FunctionsA.Function_Name to asUnitArray
                Move (Trim(FunctionsA.Function_Name))   to UnitTestCodeArray[iCount + 1].sFunctionName
                Move (SizeOfArray(asUnitArray))         to UnitTestCodeArray[iCount + 1].iSourceLines
                Move asUnitArray                        to UnitTestCodeArray[iCount + 1].UnitArray
            End
        Loop
        
        Function_Return UnitTestCodeArray
    End_Function
    
    // Make a backup-copy for the passed Filename.
    // Note: The filename must include the full path. 
    // If the CS_ImportBackupFolder folder doesn't exist,
    // it will be created.         
    // A timestamp (date & time) will be added to the file name.
    // Returns True if all went OK. 
    Function CreateBackupFile String sFileName Returns Boolean         
        Integer iRetVal
        String sPath sBackupFile sSourceFile 
        Boolean bExists
        
        Get ParseFolderName sFileName to sPath
        Get vFolderFormat sPath to sPath 
        Get vFolderExists (sPath + CS_ImportBackupFolder) to bExists
        If (bExists = False) Begin
            Get vCreateDirectory (sPath + CS_ImportBackupFolder) to iRetVal
            If (iRetVal <> 0) Begin
                Send Info_Box ("Could not create import backup folder:" * String(sPath + CS_ImportBackupFolder))
                Function_Return False
            End                                                                                                  
        End
        Get ParseFileName sFileName to sSourceFile
        Move (Replace(".pkg", sSourceFile, "")) to sBackupFile
        Move (sBackupFile + "." + String(CurrentDateTime()) + ".pkg") to sBackupFile 
        Move (Replaces(",", sBackupFile, "_")) to sBackupFile
        Move (Replaces(":", sBackupFile, "_")) to sBackupFile
        Move (Replaces("/", sBackupFile, "-")) to sBackupFile
        Get vCopyFile (sPath + sSourceFile) (sPath + CS_ImportBackupFolder + "\" + sBackupFile) to iRetVal
        
        Function_Return (iRetVal = 0)    
    End_Function

    Procedure CREFACTORFUNCLIB_SOURCE_CODE_FUNCTIONS
    End_Procedure
    //    
    // Returns -1 is the passed sFunctionName doesn't exist in the asFunctionLibraryFile string array.
    // Else it returns the array item where it was found.
    Function FunctionCodeExists String[] asFunctionLibraryFile String[] asFunctionLibraryFileLC String sFunctionName Returns Integer
        Integer iRow
        
        Move (Trim(sFunctionName)) to sFunctionName
        Move ("function" * Lowercase(sFunctionName)) to sFunctionName 
        Move (SearchArray(sFunctionName, asFunctionLibraryFileLC, Self, RefFunc(_FindFunctionCode))) to iRow 

        Function_Return iRow
    End_Function  
    
    // Copies the code text for the passed sFunctionName from the oRefactorFuncLib funcion library,
    // and returns a string array as the result. 
    // It also includes meta-data and comments that exists above/before the function declaration.
    // Note: For comments to be successfully "included" the comment lines must be immediately above
    //       the function declaration, without any "empty" line. A commend line must start with "//",
    //       or be part of the meta-tag data.
    // If sFunctionName was not found, the returned array will be empty.
    Function CopyFunctionCode String[] asFunctionLibraryFile String[] asFunctionLibraryFileLC String sFunctionName Returns String[]
        Integer iRow iCount iSize
        String[] asFunctionCode asComments
        String sEndFunctionLC sSourceLineLC
        Boolean bEnd
        
        Get FunctionCodeExists asFunctionLibraryFile asFunctionLibraryFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Function_Return asFunctionCode    
        End
        
        Get CopyFunctionMetaTags asFunctionLibraryFile iRow to asComments
        Move (iRow - SizeOfArray(asComments)) to iRow
        
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_EndFunction)) to sEndFunctionLC
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        Repeat
            Move asFunctionLibraryFile[iRow]   to asFunctionCode[iCount] 
            Move asFunctionLibraryFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndFunctionLC) to bEnd
            Increment iCount 
            Increment iRow
        Until (bEnd = True or iCount >= iSize)
        
        Function_Return asFunctionCode
    End_Function
    
    // Removes the code text for the passed "sFunctionName" from the oRefactorFuncLib function library,
    // and returns a string array excluding the code for the passed "sFunctionName".
    // If "sFunctionName" was not found, the returned array will be empty.
    Function RemoveFunctionCode String[] asFunctionLibraryFile String[] ByRef asFunctionLibraryFileLC String sFunctionName Boolean ByRef bErr Returns String[]
        Integer iRow iCount iSize
        String sEndFunctionLC sSourceLineLC
        String[] asComments
        Boolean bEnd
        
        Get FunctionCodeExists asFunctionLibraryFile asFunctionLibraryFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Move True to bErr
            Function_Return asFunctionLibraryFile    
        End
        
        // We also need to remove any comment lines above the "Function xxx" declaration line:
        Get CopyFunctionMetaTags asFunctionLibraryFile iRow to asComments
        Move (iRow - SizeOfArray(asComments)) to iRow
        
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_EndFunction)) to sEndFunctionLC
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        Repeat
            Move (RemoveFromArray(asFunctionLibraryFile, iRow))   to asFunctionLibraryFile 
            Move (RemoveFromArray(asFunctionLibraryFileLC, iRow)) to asFunctionLibraryFileLC 
            Move asFunctionLibraryFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndFunctionLC) to bEnd
            Increment iCount 
        Until (bEnd = True or iCount > iSize)
        
        // Remove the "Function_End" and the blank line after the function:
        Move (RemoveFromArray(asFunctionLibraryFile, iRow))       to asFunctionLibraryFile 
        Move (RemoveFromArray(asFunctionLibraryFileLC, iRow))     to asFunctionLibraryFileLC 
        Move (RemoveFromArray(asFunctionLibraryFile, iRow))       to asFunctionLibraryFile 
        Move (RemoveFromArray(asFunctionLibraryFileLC, iRow))     to asFunctionLibraryFileLC 
        Move False to bErr
        Function_Return asFunctionLibraryFile
    End_Function   

    // Adds the content of the asNewCode text array to the asFunctionLibraryFile array.
    // Note: Code for the passed sFunctionName value (in asFunctionLibraryFile), should have been 
    //       removed prior calling this message.
    Function AddFunctionCode tFunctionCode asCode String[] asFunctionLibraryFile String[] asFunctionLibraryFileLC Boolean ByRef bErr Returns String[]
        Integer iCount iSize
        
        Move asCode.iSourceLines to iSize
        Decrement iSize
        // Add new function code to the bottom of the source code array:
        For iCount from 0 to iSize
            Move asCode.CodeArray[iCount] to asFunctionLibraryFile[SizeOfArray(asFunctionLibraryFile)]
        Loop 
        
        // Add one empty row.
        Move "" to asFunctionLibraryFile[SizeOfArray(asFunctionLibraryFile)]
        Function_Return asFunctionLibraryFile
    End_Function

    Function IsMetaTagStart String sLine Returns Boolean
        Boolean bOK
        String sMetaTagStartTrue sMetaTagStartFalse
        
        Move False to bOK
        Move "{published=true}"  to sMetaTagStartTrue
        Move "{published=false}" to sMetaTagStartFalse
        Move (Trim(Lowercase(sLine))) to sLine
        Move (Replaces(" ", sLine, "")) to sLine
        Move (sLine = sMetaTagStartTrue or sLine = sMetaTagStartFalse) to bOK
        
        Function_Return bOK
    End_Function

    Function IsMetaTagEnd String sLine Returns Boolean
        Boolean bOK
        String sLineTrim    
        
        Move False to bOK
        Move (Trim(sLine)) to sLineTrim
        Move (Replaces(" ", sLineTrim, "")) to sLineTrim
        Move (Lowercase(sLine)) to sLine
        Move (sLineTrim = '"""}' or (sLine contains " function " and sLine contains " returns ")) to bOK
        
        Function_Return bOK
    End_Function
    
    // Reads meta-tags written on top of a declared function name (or comments like this very text)
    // Note that there may *not* be blank lines above a function, as this logic stops as soon as 
    // it finds a blank line. It is OK though to leave the rest of a line blank, after a "//"
    // The logic starts at the "Function xName String ByRef" line, and works upwards until it finds
    // a blank line.
    // Returns a string array with the found text lines, that would be *five* items for this text.
    //
    Function CopyFunctionMetaTags String[] asSourceFile Integer iRow Returns String[]
        String[] asComments
        String sLine sCommentTag
        Integer iCount iSize
        Boolean bComment bStart bEnd
        
        Move False to bStart
        Move False to bEnd
        Move (SizeOfArray(asSourceFile)) to iSize
        Move "//" to sCommentTag
        Move 1 to iCount
        Repeat
            If (iRow - iCount >= 0) Begin
                Move asSourceFile[iRow - iCount] to sLine
                If (bStart = False) Begin
                    Get IsMetaTagStart sLine to bStart
                End
                If (bEnd = False) Begin
                    Get IsMetaTagEnd sLine to bEnd
                End
                Move (bStart = True or bEnd = True) to bComment
                If (bComment = False) Begin
                    Move (Left(Trim(sLine), 2) = sCommentTag) to bComment
                End
                If (bComment = True) Begin
                    Move sLine to asComments[SizeOfArray(asComments)]
                End
            End
            Increment iCount
        Until (bStart = True or iCount >= iSize) // Last part is just for extra safety!
//        Until (sLine = "" or bStart = True or iCount >= iSize) // Last part is just for extra safety!

        Function_Return asComments
    End_Function

    // Reads meta-tags written on top of a declared function name (or comments like this very text)
    // Note that there may *not* be blank lines above a function, as this logic stops as soon as 
    // it finds a blank line. It is OK though to leave the rest of a line blank, after a "//"
    // The logic starts at the "Function xName String ByRef" line, and works upwards until it finds
    // a blank line.
    // Returns a string array with the found text lines, that would be *five* items for this text.
    //
//    Function CopyFunctionMetaTags String[] asFunctionLibraryFile Integer iRow Returns String[]
//        String[] asComments
//        String sLine sLineOrg sMetaTagStart1 sMetaTagStart2 sMetaTagEnd1 sMetaTagEnd2 sMetaTagEnd3 sCommentTag
//        Integer iCount iSize
//        Boolean bComment bStart bEnd
//        
//        Move False to bStart
//        Move False to bEnd
//        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
//        Move "{published = true}" to sMetaTagStart1
//        Move "{published=true}"   to sMetaTagStart2
//        Move '""" }'              to sMetaTagEnd1
//        Move " function "         to sMetaTagEnd2
//        Move " returns "          to sMetaTagEnd3
//        Move "//"                 to sCommentTag
//        Move 1 to iCount
//        Repeat
//            Move asFunctionLibraryFile[iRow - iCount] to sLine
//            Move sLine to sLineOrg
//            Move (Trim(sLine)) to sLine
//            If (bStart = False) Begin
//                Move (Lowercase(sLine) = sMetaTagStart1 or Lowercase(sLine) = sMetaTagStart2) to bStart
//            End
//            If (bEnd = False) Begin
//                Move (Lowercase(sLine) = sMetaTagEnd1 or (Lowercase(sLineOrg) contains sMetaTagEnd2 and Lowercase(sLineOrg) contains sMetaTagEnd3)) to bEnd
//            End
//            Move (bStart = True or bEnd = True) to bComment
//            If (bComment = False) Begin
//                Move (Left(sLine, 2) = sCommentTag) to bComment
//            End
//            If (bComment = True) Begin
//                Move sLine to asComments[SizeOfArray(asComments)]
//            End
//            Increment iCount
//        Until (sLine = "" or bStart = True or iCount >= iSize) // Last part is just for extra safety!
//        
//        Function_Return asComments
//    End_Function
    
    // Reads the top of - or - the full content of the CS_FunctionLibraryFile class, starting with the 
    // the class declaration line, including the "End_Class" line and returns the result as a string array.
    // Pass a bTopOnly = True, to only return the top part of the file (until the "Class xxx" start.
    Function ReadCodeLibraryFile Boolean bTopOnly Integer ByRef iSize Returns String[]
        String[] asSourceFile   
        String sPath sFileName 
        Boolean bExists

        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath   
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        // Make the filename fully qualified: (Full path)
        Move (sPath + CS_FunctionLibraryFile) to sFileName          

        File_Exist sFileName bExists
        If (bExists = False) Begin  
            Move -1 to iSize
            Send Info_Box ("Could not find the Code Library repository file:" * (String(sFileName)))
            Function_Return asSourceFile
        End  
        
        Get ReadSourceFile sFileName bTopOnly False (&iSize) to asSourceFile
        
        Function_Return asSourceFile
    End_Function  
    
    Function WriteCodeLibraryFile String[] asFunctionLibraryFile Returns Boolean    
        String sPath sFileName sLine sLineBreak
        String[] asFunctionLibraryTop
        Integer iCount iSize iCh
        Boolean bOK
        
        Get psLineBreak to sLineBreak
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath   
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_FunctionLibraryFile) to sFileName  
        
        Get CreateBackupFile sFileName to bOK
        If (bOk = False) Begin
            Send Info_Box ("Could not make a backup copy of the" * CS_FunctionLibraryFile * "function library. Process stopped.") 
            Function_Return False
        End
        
        // Note that this needs to be above the Direct_Output below, because that
        // will reset the size of the file to zero.
        Get ReadCodeLibraryFile True (&iSize) to asFunctionLibraryTop
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_FunctionLibraryFile) * "file")
            Function_Return False
        End
        
        Get OpenOutput sFileName to iCh
        If (iCh < 0) Begin
            Function_Return False
        End
        
        // 1. Write the top part of the cRefactorFuncLib.pkg file:
        Move (SizeOfArray(asFunctionLibraryTop)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Write channel iCh asFunctionLibraryTop[iCount] sLineBreak
        Loop
        
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        // 2. Write the function library code part from the oRefactorFuncLib.pkg file:
        For iCount from 0 to iSize
            Write channel iCh asFunctionLibraryFile[iCount] sLineBreak
        Loop

        // End by adding the two comments, the "Enc_Class" + one empty line:
        Writeln channel iCh CS_Comment1
        Writeln channel iCh CS_Comment2
        Writeln channel iCh CS_EndObject
    
        Send CloseOutput iCh
        Function_Return True
    End_Function
                                 
    Function UpdateSourceCodeArray tFunctionCode asCode String[] asFunctionLibraryFile Integer iFunction Boolean ByRef bErr Returns String[]
        String sFunctionName 
        String[] asFunctionLibraryFileLC
        Integer iRow iCount iSize
        
        // For the very first function code we add a blank item at the end,
        // so that we get a blank line before the imported functions, when
        // printed to file.
        If (iFunction = 0) Begin
            Move "" to asFunctionLibraryFile[SizeOfArray(asFunctionLibraryFile)
        End
        
        Get LowercaseCodeLibrary asFunctionLibraryFile to asFunctionLibraryFileLC
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        If (iSize = 0) Begin
            Move True to bErr
            Function_Return asFunctionLibraryFile
        End
        
        Move asCode.sFunctionName to sFunctionName
        // If the function code already exists, that old code will first be removed, then the new function code will be added to the end.
        Get FunctionCodeExists asFunctionLibraryFile asFunctionLibraryFileLC sFunctionName to iRow
        If (iRow <> -1) Begin
            Get RemoveFunctionCode asFunctionLibraryFile (&asFunctionLibraryFileLC) sFunctionName (&bErr) to asFunctionLibraryFile
            If (bErr = True) Begin
                Function_Return asFunctionLibraryFile
            End
        End
        
        // 2. Add code for the function to the cRefactorFuncLib class array:
        Move asCode.iSourceLines to iCount
        Get AddFunctionCode asCode asFunctionLibraryFile asFunctionLibraryFileLC (&bErr) to asFunctionLibraryFile
        If (bErr = True) Begin            
        // ToDo: This must be wrong. Should we return an empty array?
            Function_Return asFunctionLibraryFile
        End
    
        Function_Return asFunctionLibraryFile 
    End_Function
    
    Procedure UNIT_TESTING_SOURCE_CODE_FUNCTIONS
    End_Procedure
    //    
    // Returns -1 is the passed sFunctionName doesn't exist in the asUnitCodeFile string array.
    // Else it returns the array item where it was found.
    //
    // ToDo: This should be more granulare; It can happen that the object with the psFunctionName exists,
    //       but some procedure(s) in that object has been changed/added/removed.
    //       OR if the psFunctionName was found *always* replace the code. 
    Function UnitCodeExists String[] asUnitCodeFile String[] asUnitCodeFileLC String sFunctionName Returns Integer
        Integer iRow
        String[] asUnitCode
        
        Move (Trim(sFunctionName)) to sFunctionName
        Move ('set psfunctionname to "' + Lowercase(sFunctionName) + '"') to sFunctionName 
        Move (SearchArray(sFunctionName, asUnitCodeFileLC, Self, RefFunc(_FindFunctionCode))) to iRow 

        Function_Return iRow
    End_Function      
    
    // Add new dummy code for objects that does not yet exist (non-existing unit testing objects for existing functions).
    // Returns a string array with the new dummy code object.
    // This dummy code needs to be filled with unit testing code and its '{ Published = False }' must be changed to
    // '{ Published = True }', else it won't be executed.
    Function CreateDummyCode String[] asUnitCodeFile String[] asUnitCodeFileLC String sFunctionName Returns String[]
        String sTab1 sTab2 sTab3 sLine  
        String[] asNewCode
        
        Move (Trim(sFunctionName)) to sFunctionName
        Move "    " to sTab1
        Move "        " to sTab2
        Move "            " to sTab3
        
        // Object code:
        Move (sTab1 + String("Object o") + sFunctionName + " is a cTestFixture") to sLine 
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab2 + (String("Set psFunctionName to ")) + '"' + sFunctionName + '"') to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move "" to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        
        // Procedure code: 
        // Note that we set the Published=False, which means that the procedure will *not* get executed.
        Move (sTab2 + "{ Published = False }") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab2 + "// ToDo: Dummy procedure. You need to fill it with a meaningful test and change 'Published = False' to 'Published = True'") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab2 + "Procedure" * String(sFunctionName) + "_1") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab3 + "String sLine sExpected") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab3 + "Boolean bChanged") to sLine   
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab3 + "tTokenizer TokenizerData") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]   
        Move (sTab3 + "Move '' to sLine") to sLine 
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab3 + "Move ' ' to sExpected") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab3 + "Get Tokenizer of ghoRefactorFuncLib sLine to TokenizerData") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]   
        Move (sTab3 + "Get " + String(sFunctionName) * "of ghoRefactorFuncLib (&sLine) to bChanged") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab3 + "Send AssertSAreEqual sExpected sLine") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab2 + "End_Procedure") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        
        // End Object
        Move "" to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        Move (sTab1 + "End_Object") to sLine
        Move sLine to asNewCode[SizeOfArray(asNewCode)]
        
        Function_Return asNewCode
    End_Function  
    
    Function CopyUnitCode String[] asUnitCodeFile String[] asUnitCodeFileLC String sFunctionName Returns String[]
        Integer iRow iCount iSize
        String[] asUnitCode asMissingUnitFunctions
        String sEndObjectLC sSourceLineLC
        Boolean bEnd
        
        Get UnitCodeExists asUnitCodeFile asUnitCodeFileLC sFunctionName to iRow
        If (iRow = -1) Begin   
            Get CreateDummyCode asUnitCodeFile asUnitCodeFileLC sFunctionName to asUnitCode
            Get pasMissingUnitFunctions to asMissingUnitFunctions
            Move sFunctionName to asMissingUnitFunctions[SizeOfArray(asMissingUnitFunctions)]
            Set pasMissingUnitFunctions to asMissingUnitFunctions
            Function_Return asUnitCode    
        End
        
        // Note! We assume that the "Object oxxx is a cTestFixture" line is directly above the
        //      'Set psFunctionName to "xxx"' source code line! So substract by 1.
        Decrement iRow
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_EndObject)) to sEndObjectLC
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        Decrement iSize
        Repeat
            Move asUnitCodeFile[iRow]   to asUnitCode[iCount] 
            Move asUnitCodeFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndObjectLC) to bEnd
            Increment iCount 
            Increment iRow
        Until (bEnd = True or iCount >= iSize)
        
        Function_Return asUnitCode
    End_Function
         
    // Removes the code text for the passed "sFunctionName" from the CS_UnitTestsFile,
    // and returns a string array excluding the code for the passed "sFunctionName".
    // If "sFunctionName" was not found, the returned array will be empty.
    Function RemoveUnitCode String[] asUnitCodeFile String[] ByRef asUnitCodeFileLC String sFunctionName Boolean ByRef bErr Returns String[]
        Integer iRow iCount iSize
        String sEndObjectLC sSourceLineLC
        Boolean bEnd
        
        Get FunctionCodeExists asUnitCodeFile asUnitCodeFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Move True to bErr
            Function_Return asUnitCodeFile    
        End
        
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_EndObject)) to sEndObjectLC
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        Decrement iSize
        Repeat
            Move (RemoveFromArray(asUnitCodeFile, iRow))   to asUnitCodeFile
            Move (RemoveFromArray(asUnitCodeFileLC, iRow)) to asUnitCodeFileLC
            Move asUnitCodeFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndObjectLC) to bEnd
            Increment iCount 
        Until (bEnd = True or iCount >= iSize)
        
        // Remove the last "End_Object" line and next empty line:
        Move (RemoveFromArray(asUnitCodeFile, iRow))       to asUnitCodeFile
        Move (RemoveFromArray(asUnitCodeFileLC, iRow))     to asUnitCodeFileLC 
        Move (RemoveFromArray(asUnitCodeFile, iRow))       to asUnitCodeFile
        Move (RemoveFromArray(asUnitCodeFileLC, iRow))     to asUnitCodeFileLC 
        Move False to bErr

        Function_Return asUnitCodeFile
    End_Function   

    // Adds the content of the asNewCode text array to the asUnitCode array.
    // Note: Code for the passed sFunctionName value (in asUnitCode), should have been 
    //       removed prior calling this message.
    Function AddUnitCode tUnitTestCode asUnit String[] asUnitCodeFile String[] asUnitCodeFileLC Boolean ByRef bErr Returns String[]
        Integer iCount iSize
        
        Move asUnit.iSourceLines to iSize
        Decrement iSize
        // Add new function code to the bottom of the source code array:
        For iCount from 0 to iSize
            Move asUnit.UnitArray[iCount] to asUnitCodeFile[SizeOfArray(asUnitCodeFile)]
        Loop 
        
        // Add one empty row.
        Move "" to asUnitCodeFile[SizeOfArray(asUnitCodeFile)]
        Function_Return asUnitCodeFile
    End_Function

    // Reads the content of the Unit Testing source file: CS_UnitTestsFile,
    // and returns it as a string array.
    Function ReadUnitTestsFile Integer ByRef iSize Returns String[]
        String[] asSourceFile
        String sPath sFileName
        Boolean bExists
        
        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        // Make the filename fully qualified: (Full path)
        Move (sPath + CS_UnitTestsFile) to sFileName          

        File_Exist sFileName bExists
        If (bExists = False) Begin
            Send Info_Box ("Could not find the Unit testing source file:" * (String(sFileName)))
            Function_Return asSourceFile
        End  
        
        Get ReadSourceFile sFileName False True (&iSize) to asSourceFile
        
        Function_Return asSourceFile
    End_Function

    Function WriteUnitTestsFile String[] asUnitCodeFile Returns Boolean    
        String sPath sFileName sLine sLineBreak
        Integer iCount iSize iCh
        Boolean bOK
        
        Get psLineBreak     to sLineBreak
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath   
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_UnitTestsFile) to sFileName  
        
        Get CreateBackupFile sFileName to bOK
        If (bOk = False) Begin
            Send Info_Box ("Could not make a backup copy of the" * CS_UnitTestsFile * "file. Process stopped.") 
            Function_Return False
        End
        
        Get OpenOutput sFileName to iCh
        If (iCh < 0) Begin
            Function_Return False
        End
        
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        // Somewhere there was one to many lines added to the string array - remove last one.
        Decrement iSize
        Decrement iSize
        for iCount from 0 to iSize
            Write channel iCh asUnitCodeFile[iCount] sLineBreak
        Loop
        Writeln channel iCh ""
        Writeln channel iCh CS_EndObject
    
        Send CloseOutput iCh
        Function_Return True
    End_Function

    Function UpdateUnitCodeArray tUnitTestCode asUnit String[] asUnitCodeFile Integer iFunction Boolean ByRef bErr Returns String[]
        String sFunctionName 
        String[] asUnitCodeFileLC asNewCode
        Integer iRow iCount iSize
        
        Get LowercaseCodeLibrary asUnitCodeFile to asUnitCodeFileLC
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        If (iSize = 0) Begin
            Move True to bErr
            Function_Return asUnitCodeFile
        End
        
        Move asUnit.sFunctionName to sFunctionName
        Get UnitCodeExists asUnitCodeFile asUnitCodeFileLC sFunctionName to iRow
        // 1a. If the function code already exists, that old code will first be removed, then the new function code will be added to the end.
        If (iRow <> -1) Begin
            Get RemoveUnitCode asUnitCodeFile (&asUnitCodeFileLC) sFunctionName (&bErr) to asUnitCodeFile
            If (bErr = True) Begin
                Function_Return asUnitCodeFile
            End
        End 
        // 1b. If the object didn't exist in either the import file or current file; add dummy code
        Else Begin
            Move asUnit.iSourceLines to iCount
            If (iCount = 0) Begin
                Get CreateDummyCode asUnitCodeFile asUnitCodeFileLC sFunctionName to asNewCode
                Move (SizeOfArray(asNewCode)) to asUnit.iSourceLines
                Move sFunctionName            to asUnit.sFunctionName
                Move asNewCode                to asUnit.UnitArray
            End
        End
        
        // 2. Add code for the function to the oUnit_Tests object array:
        Move asUnit.iSourceLines to iCount
        If (iCount > 0) Begin
            Get AddUnitCode asUnit asUnitCodeFile asUnitCodeFileLC (&bErr) to asUnitCodeFile
            If (bErr = True) Begin
                Function_Return asUnitCodeFile
            End
        End
    
        Function_Return asUnitCodeFile
    End_Function
    
    Procedure HELPER_FUNCTIONS
    End_Procedure
    //
    // Lower cases the function library to make searches/compares easier:
    // String arrays using this method all ends with the "LC" suffix.
    Function LowercaseCodeLibrary String[] asFunctionLibraryFile Returns String[]
        String[] asFunctionLibraryFileLC
        Integer iSize iCount
        
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move (Lowercase(asFunctionLibraryFile[iCount])) to asFunctionLibraryFileLC[iCount]
        Loop
        
        Function_Return asFunctionLibraryFileLC   
    End_Function  

    // Reads the content of the passed sFileName source file and returns it as a string array.
    // The sFileName must contain the full path.
    // Line-ending characters like CR and LF are stripped for each line.
    // If bUnitTest = False, reading will stop after a CS_EndObject is found.
    // No checking is done if the file exists or not.
    // If something went wrong an empty string array will be returned.
    Function ReadSourceFile String sFileName Boolean bTopOnly Boolean bUnitTest Integer ByRef iSize Returns String[]
        Integer iCh iFileSize iCount
        String[] asSourceFile   
        String sLine sLastLine sLineBreak
        Boolean bStart bEnd bEndOfFile bLastLineBreak   

        Move False to bEndOfFile
        Move ""    to sLastLine
        Move False to bStart
        Move False to bEnd
        Move 0 to iCount

        // Need to use binary read mode as we want to use CR+LF as the line delimiter.
        // The filemode options don't seem to work as documented, not sure why.
        Get OpenInput ("binary:" + sFilename) to iCh
        If (iCh < 0) Begin                 
            Move -1 to iSize
            Function_Return asSourceFile
        End

        // By setting the size of the array before we start reading,
        // it makes the process much faster. A new ResizeArray is performed
        // after the file has been read.
        Get vWin32_APIFileSize sFilename to iFileSize
        Move (ResizeArray(asSourceFile, iFileSize)) to asSourceFile

        // Set the linebreak character to use for the file to CR + LF,
        // because that is what the Studio uses when saving a file. And it seems to be because
        // the compiler can get confused when there is only a LF.
        // The readline automatically reads until LF, but does not include it in the read string.
        Move CS_CRLF to sLineBreak
        Set psLineBreak to sLineBreak

        While (bEndOfFile = False)
            Readln channel iCh sLine    
            // Remove any trailing spaces:
            Move (Rtrim(sLine)) to sLine
            Move (SeqEof) to bEndOfFile

            If (bEndOfFile and Length(sLastLine) > 0) Begin
                If (Right(sLastLine, 1) = CS_CR) Begin
                    Move True to bLastLineBreak
                End
            End
            Move sLine to sLastLine
            
            // Remove any CR or LF at the end of line.
            // The Line_Feed character is already removed by the Readln command.
            // When the WriteCodeLibraryFile is called, it will add CR+LF for each array item.
            // All this hazzle because the Compiler is expecting each line to end with a CR+LF,
            // else it gets confused and generates errors on what seems to be a perfectly normal
            // source code line.
            If (Right(sLine, 1) = CS_CR) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End
            If (Right(sLine, 1) = CS_LF) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End

            If (bEndOfFile = False) Begin
                If (bTopOnly = True) Begin
                    Move (Trim(sLine) = CS_FunctionLibraryStart) to bEnd
                    If (bEnd = True) Begin 
                        Move True to bEndOfFile
                    End
                    Else Begin
                        Move sLine to asSourceFile[iCount]
                        Increment iCount
                    End
                End
                Else If (bUnitTest = False) Begin
                    If (bStart = False) Begin
                        Move (Trim(sLine) = CS_FunctionLibraryStart) to bStart
                    End
                    If (bStart = True and bEnd = False) Begin
                        Move sLine to asSourceFile[iCount]
                        Increment iCount
                    End
                    Move (Trim(sLine) = CS_EndObject) to bEnd
                    If (bStart = True and bEnd = True) Begin      
                        Move True to bEndOfFile
                    End
                End
                Else Begin
                    Move sLine to asSourceFile[iCount]
                    Increment iCount
                End
            End
        Loop
        
        Send CloseOutput iCh
        Move (ResizeArray(asSourceFile, iCount)) to asSourceFile
        Move iCount to iSize
        Function_Return asSourceFile
    End_Function  
    
End_Class
