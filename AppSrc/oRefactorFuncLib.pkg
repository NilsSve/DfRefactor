Use cRefactorFuncLib.pkg

// Use statement for YOUR USER DEFINED refactoring classes,
// that are used by the UserDefinedRefactorFunctions.pkg
// file is automatically included in the oRefactorFuncLib object below.
Use UserDefinedUseStatement.pkg

//
// *** Refactor Function Library ***
// The object below contains all refactoring functions.

/*  RULES FOR META-TAGS:

    There are four parameters accepted by the procdure RegisterInterface that is used to
    collect info about a function when the program starts. The first one
    is a handle that cannot be used for our purposes. The second one is the function name.
    The third contains the types and names of the parameters and return type for the function.
    That leaves only one more RegisterInterface param we can use, and that is the "sComment".
    The { Description } meta-tag content is what ends up in the sComment parameter.
    
    As we need to handle more than four parameters, the RegisterInterface has been made in
    such a way that other meta-tags embedded within the { Description } meta-tag, are
    parsed and moved to various struct members.
    
    Important Note: For the { Description... meta-tag text "Aligned Multiline Strings" are
                    used. That is strings that starts and ended with a """ (triple-quote character).
                    Embedded in that { Description... meta-tag, other meta-tags are used
                    to describe other characterestica for the function. Those are the parts
                    that are parsed in the RegisterInterface procedure.

    Studio Note:    The Studio does get confused how meta-tags are used here.
                    It is therefor advised to edit and test new refactoring
                    functions in another package, and then publish it here.
    
    The {Published} meta-tag must be True for a function to show up at all in function lists of the running program.
    Sample:
    {Published=True}

    The { Description } meta-tag is a compound tag, as it will contain other meta-tags, as described above,
    it always starts with a tripple quote, and ends with a tripple quote symbol.
    Sample:
    { Description = """
        Some text that could span
        several lines.
        
        The { MethodType } describes what type of function it belongs to, as this is vital for the
        refactoring engine when calling it. It must be any member from this predefined enumeration list;
            Define eStandard_Function     for 1   // One source line at a time will be passed for these functions.
            Define eRemove_Function       for 2   // One source line at a time will be passed for these functions.
            Define eEditor_Function       for 3   // A source file as a string array will be passed
            Define eReport_Function       for 4   // A source file as a string array. Makes no source changes.
            Define eReport_FunctionAll    for 5   // Makes no source changes.
            Define eOther_Function        for 6   // A source file as a string array will be passed.
            Define eOther_FunctionAll     for 7   // All selected files as a string array will be passed. 
        Sample:
        { MethodType = eStandard_Function }
        
          When a refactoring function uses parameters for the "sParameter" param, possible
          values are entered in an { EnumList } meta-tag.
          If an { EnumList } meta-tag is used, it needs to be followed by to other meta-tags;
          { InitialValue } that is the default value from the EnumList, and
          { HelpTopic } that will be the help text presented to the user when selecting on of the
                        values in the EnumList. This needs to be the last item.

        Sample:
        { EnumList = "CI_SplitBySpaceAndSemicolon, CI_SplitBySemicolon, CI_SplitToBeginEndBlock" }
        { InitialValue = CI_SplitToBeginEndBlock }
        { HelpTopic = "Valid Values; CI_SplitBySpaceAndSemicolon - 'Split line with space and semicolon',
            CI_SplitBySemicolon - 'Split line with semicolon', CI_SplitToBeginEndBlock - 'Use a Begin/End block'"}
        """ }
*/

Object oRefactorFuncLib is a cRefactorFuncLib
    Move Self to ghoRefactorFuncLib

    // *** User defined functions of type: eStandard_Function (line-by-line) are included here ***
    //     Use the file to add your own special refactoring function(s) that are particular to
    //     a special code base/project, and has no general interest.
    //     (Dummy method for the Code Explorer)
    #Include UserDefinedRefactorFunctions.pkg

    {Published=True} 
    { Description = """ 
        Changes legacy Calc/MoveInt/MoveStr/MoveNum commands with a 'Move' command.
        The legacy commands compiles but does not work with the Studio's Code Explorer.
        { MethodType = eStandard_Function }
        """ }
    Function ChangeCalcToMoveStatement String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sTest sStart sStop
        Integer iPos
        tTokenizer TokenizerData
        
        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady or TokenizerData.bIsInCommand or TokenizerData.bIsInImage or TokenizerData.bIsVariableDeclaration) Begin
            Function_Return False
        End

        // Check if line contains one of the keywords and that none of the keywords are within quotes.
        Get _IsKeywordInLine "calc|moveint|movenum|movereal|movestr" TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        Move (Lowercase(sLine)) to sTest
        Move False to bChanged

        Case Begin
            Case (Pos("calc ", sTest))
                Move (Pos("calc ", sTest))            to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("moveint ", sTest))
                Move (Pos("moveint ", sTest))         to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movenum ", sTest))
                Move (Pos("movenum ", sTest))         to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movereal ", sTest))
                Move (Pos("movereal ", sTest))        to iPos
                Move (Left(sLine, (iPos -1))) to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
                Move (sStart + CS_Move + sStop)       to sLine
                Move True                             to bChanged
                Case Break

            Case (Pos("movestr ", sTest))
                If (Lowercase(TokenizerData.FirstLeftCommand.sCode) <> Lowercase(CS_Move)) Begin
                    Move (Pos("movestr ", sTest))         to iPos
                    Move (Left(sLine, (iPos -1))) to sStart
                    Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                    Move (sStart + CS_Move + sStop)       to sLine
                    Move True                             to bChanged
                End
                Case Break
        Case End

        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Replaces legacy DfTrue and DFFalse with True or False
        { MethodType = eStandard_Function }
        """ }
    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sNewBoolean
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData

        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get _IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Trim(sLine)) to sLine
        Repeat
            Move CS_True to sNewBoolean
            Move (Pos(Lowercase(CS_DfTrue), Lowercase(TokenizerData.sOverstrikeLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos(Lowercase(CS_DfFalse), Lowercase(TokenizerData.sOverstrikeLine))) to iPos
                Move CS_False to sNewBoolean
            End
            If (iPos <> 0) Begin
                Move (Overstrike("||" + sNewBoolean, sLine, iPos)) to sLine
                Move (Replace("||", sLine, "")) to sLine
                Move (Overstrike("||" + sNewBoolean, TokenizerData.sOverstrikeLine, iPos)) to TokenizerData.sOverstrikeLine
                Move (Replace("||", TokenizerData.sOverstrikeLine, "")) to TokenizerData.sOverstrikeLine
            End
        Until (iPos = 0)

        Move (TokenizerData.sIndentation + String(sLine)) to sLine
        Function_Return True
    End_Function

    {Published=True} 
    { Description = """
        Changes legacy square brackets found indicators; [Found] {FindErr] to expressions; (Found) or (Not(Found))
        Changes: 
        - Indicate Found as True" --> Move True to Found
        - [Select] Indicate Select as Windowindex Eq Fieldindex --> Move (WindowInex = FieldIndex) to Select
        - [Found] and [FindErr] indicator statements.
        - [Found| Command -> e.g. If Found Command
        - While [Not Found]   -> e.g. While (Not(Found))
        - [Found|Not Found|FindErr|Not FindErr] While   -> e.g. While (Not(Found))
        - [Found] Indicate Found as Invoice.CustNum eq Customer.Number -> If (Found) Move (Invoice.CustNum eq Customer.Number) to Found
        - If [Not Found] Reread hTable -> If (Not(Found)) Reread hTable
        - [~Found] begin -> If (Not(Found)) Begin
        - [Found ~Found] Begin -> If (Found and Not(Found)) Begin
        Known limitations:
        - It can only handle max two booleans within the same square bracket. E.g. "[Found Select]"
        - It can't handle "GROUP" and/or "ALL" indicator directives. If any of those two are found,
          this function will leave the sLine as it is.
        { MethodType = eStandard_Function }
        """ }
    Function ChangeLegacyIndicators String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bStartBracket bHasBracket bIndicateStart bIfStart
        String sToken sOverstrikeLine sNot sTo sMove sIf sFirstCmd sSecondCmd sExpression
        Integer iItem iSize iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True or TokenizerData.bIsInImage = True) Begin
            Function_Return False
        End
        Get _HasBracket TokenizerData.BooleanIndicator to bHasBracket
        If (TokenizerData.BooleanIndicator.bHasIndicateCommand = False and bHasBracket = False) Begin
            Function_Return False
        End

        If (Lowercase(sLine) contains (Lowercase(CS_Find) + " ") or ;
            Lowercase(sLine) contains (Lowercase(CS_Send) + " ") or ;
            Lowercase(sLine) contains (Lowercase(CS_Constrain) + " ")) Begin
            Function_Return False
        End

        Move (SearchArray("GROUP", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray("ALL", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End

        // Has If-statement?
        Move (TokenizerData.bHasIfCommand = True) to bIfStart
        If (bIfStart = True) Begin
            Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Move TokenizerData.asLineTokens[iItem] to sIf
            End
        End
        Else Begin
            Move CS_If to sIf
        End

        // Has Move-statement?
        Move (SearchArray(CS_Move, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sMove
        End
        Else Begin
            Move CS_Move to sMove
        End
        Move TokenizerData.FirstLeftCommand.sCode  to sFirstCmd
        Move TokenizerData.SecondLeftCommand.sCode to sSecondCmd

        // Has To-statement?
        Move (SearchArray(CS_To, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sTo
        End
        Else Begin
            Move CS_To to sTo
        End

        Move 0 to iItem
        Move TokenizerData.asLineTokens[iItem] to sToken
        // Starts with a indicator bracket?
        Move (Left(sToken, 1) = "[") to bStartBracket
        Move CS_Not to sNot

        // Get the "Not" keyword:
        If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot  = True or ;
            TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True or ;
            TokenizerData.BooleanIndicator.ToBoolean.bHasNot     = True or ;
            TokenizerData.BooleanIndicator.AsBoolean.bHasNot     = True) Begin
            Move (SearchArray("[not", TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem = -1) Begin
                Move (Pos(("[" + CS_Tilde), TokenizerData.sLine)) to iItem
                If (iItem = 0) Begin
                    Move -1 to iItem
                End
                Else If (iItem > 0) Begin
                    Move -1 to iItem
                End
            End
            If (iItem <> -1) Begin
                Get _ReplaceBrackets TokenizerData.asLineTokens[iItem] to sNot
            End
        End

        // Has an "Indicate" command?
        Move (SearchArray(CS_Indicate, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        Move (iItem <> -1) to bIndicateStart

        // Add "Not" operator and add paranthesis to boolean expressions/variables;
        If (TokenizerData.BooleanIndicator.FirstBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + "))") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
        End
        Else If (TokenizerData.BooleanIndicator.FirstBoolean.sCode <> "" and Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) <> "(") Begin
            Move ("(" + TokenizerData.BooleanIndicator.FirstBoolean.sCode + ")") to TokenizerData.BooleanIndicator.FirstBoolean.sCode
        End
        If (TokenizerData.BooleanIndicator.SecondBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.SecondBoolean.sCode + "))") to TokenizerData.BooleanIndicator.SecondBoolean.sCode
        End
        Else If (Left(TokenizerData.BooleanIndicator.SecondBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.SecondBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.SecondBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.SecondBoolean.sCode + ")") to TokenizerData.BooleanIndicator.SecondBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.ToBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.ToBoolean.sCode + "))") to TokenizerData.BooleanIndicator.ToBoolean.sCode
        End
        If (Left(TokenizerData.BooleanIndicator.ToBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.ToBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.ToBoolean.sCode <> "" and not(TokenizerData.BooleanIndicator.ToBoolean.sCode contains " ")) Begin
                Move ("(" + TokenizerData.BooleanIndicator.ToBoolean.sCode + ")") to TokenizerData.BooleanIndicator.ToBoolean.sCode
            End
        End
        If (TokenizerData.BooleanIndicator.AsBoolean.bHasNot = True) Begin
            Move ("(" + sNot + "(" + TokenizerData.BooleanIndicator.AsBoolean.sCode + "))") to TokenizerData.BooleanIndicator.AsBoolean.sCode
        End
        If (Left(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> "(" and Right(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> ")") Begin
            If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                Move ("(" + TokenizerData.BooleanIndicator.AsBoolean.sCode + ")") to TokenizerData.BooleanIndicator.AsBoolean.sCode
            End
        End

        Case Begin
            // This was too much code, so it was broken out to a helper-function (sub):
            Case (bStartBracket = True)
                Get _ChangeLegacyIndicators_Sub TokenizerData TokenizerData.sOverstrikeLine (&bChanged) to sOverstrikeLine
                Case Break

            // 'If [False] Indicate Select as Windowindex Eq Fieldindex // Comment'
            // 'If [not found] Move (Windowindex Eq Fieldindex) to Select // Comment'
            // 'If dDate LE '01/01/1984' Indicate ERROR_DATE True'
            Case (bIfStart = True)
                Move sIf to sOverstrikeLine
                Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                Get _ReplaceParanthesis sToken to sToken
                Move (Pos(Lowercase(sToken), Lowercase(Trim(sLine)))) to iPos
                If (iPos < TokenizerData.SecondLeftCommand.iStartPos) Begin
                    Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                    Move (SearchArray(sToken, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                    If (iItem = -1) Begin
                        Get _ReplaceParanthesis sToken to sToken
                        Move (SearchArray(sToken, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                    End
                    If (iItem <> -1) Begin
                        Increment iItem
                        If (iItem <= SizeOfArray(TokenizerData.asLineTokens)) Begin
                            Move TokenizerData.asLineTokens[iItem] to sToken
                            If (Lowercase(sToken) = Lowercase(CS_As)) Begin
                                Increment iItem
                                Move TokenizerData.asLineTokens[iItem] to sToken
                            End
                        End
                        If (Lowercase(sToken) = Lowercase(CS_To)) Begin
                            Increment iItem
                            Move TokenizerData.asLineTokens[iItem] to sToken
                            Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode " " sMove
                            Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sExpression
                            Append sOverstrikeLine " " sExpression " " sTo " " sToken
                        End
                        Else Begin
                            Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode " " sMove
                            Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sExpression
                            Get _ReplaceParanthesis sExpression to sExpression
                            Append sOverstrikeLine " " sToken " " sTo " " sExpression
                        End
                    End
                End
                Else Begin
                    Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                    If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
                        Append sOverstrikeLine " " sMove " " TokenizerData.BooleanIndicator.AsBoolean.sCode
                        Move TokenizerData.BooleanIndicator.SecondBoolean.sCode to sToken
                        Append sOverstrikeLine " " sTo   " " sToken
                    End
                    Else Begin
                        Append sOverstrikeLine " " sMove " " TokenizerData.BooleanIndicator.SecondBoolean.sCode
                        Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
                        Get _ReplaceParanthesis sToken to sToken
                        Append sOverstrikeLine " " sTo   " " sToken
                    End
                End

                Case Break

            // 'Indicate Found as True'
            // 'Indicate [Found] as True'
            // 'Indicate Select as Windowindex Eq Fieldindex // Comment'
            Case (bIndicateStart = True)
                Move CS_Move to sOverstrikeLine
                If (Left(TokenizerData.BooleanIndicator.FirstBoolean.sCode, 1) = "(") Begin
                    Get _ReplaceParanthesis TokenizerData.BooleanIndicator.FirstBoolean.sCode to TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                // If AsBoolean.sCode = "" we have a missing "as" keyword on line, so we adjust for that here.
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode = "") Begin
                    Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
                    Move TokenizerData.asLineTokens[iSize -1] to TokenizerData.BooleanIndicator.AsBoolean.sCode
                End
                If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "" and Left(TokenizerData.BooleanIndicator.AsBoolean.sCode, 1) <> "(") Begin
                    Move ("(" + TokenizerData.BooleanIndicator.AsBoolean.sCode +")") to TokenizerData.BooleanIndicator.AsBoolean.sCode
                End
                Append sOverstrikeLine " " TokenizerData.BooleanIndicator.AsBoolean.sCode " " CS_To " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                Case Break

            // Starts with any other than: "If", "Indicate" or a square bracket indicator as e.g. "[Not Found]". I.e. another command.
            Case Else
                // Do we have a e.g. "While [Not Found]" construct?
                If (Pos(sFirstCmd, TokenizerData.sOverstrikeLine) < Pos("[", TokenizerData.sOverstrikeLine)) Begin
                    Move sFirstCmd to sOverstrikeLine
                    Append sOverstrikeLine " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                End
                Else Begin
                    Move TokenizerData.BooleanIndicator.ToBoolean.sCode to sToken
                    If (sToken = "") Begin
                        Move TokenizerData.BooleanIndicator.AsBoolean.sCode to sToken
                    End
                    Move (CS_Move * String(sToken)) to sOverstrikeLine
                    If (SearchArray(sTo, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP)) <> -1) Begin
                        Append sOverstrikeLine " " sTo " " TokenizerData.BooleanIndicator.FirstBoolean.sCode
                    End
                    Else Begin
                        Move TokenizerData.asLineTokens[(SizeOfArray(TokenizerData.asLineTokens) -1)] to sToken
                        Move (SearchArray(CS_As, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
                        If (iItem <> -1) Begin
                            Move TokenizerData.BooleanIndicator.FirstBoolean.sCode to sToken
                            Append sOverstrikeLine " " sTo " " sToken
                        End
                        Else Begin
                            Append sOverstrikeLine " " sToken
                        End
                    End
                End
        Case End

        Move (TokenizerData.sIndentation + sOverstrikeLine) to sOverstrikeLine
        If (TokenizerData.sEndComment <> "") Begin
            Append sOverstrikeLine " " TokenizerData.sEndComment
        End
        Move sOverstrikeLine to sLine
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """ 
        Replaces legacy GetAddress command with function AddressOf.
        Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
        For the function to do anything, the line needs to contain a "GetAddress" command.
        { MethodType = eStandard_Function }
        """ }
    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sText
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText

        If (TokenizerData.bLineIsReady or TokenizerData.bHasEndSemiColon or TokenizerData.bIsInFunction or ;
            TokenizerData.bIsInProcedure = True ) Begin
            Function_Return False
        End

        Get _IsKeywordInLine (CS_GetAddress + "|") TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.OfStatement.sCode + "))" * CS_To * String(TokenizerData.ToStatement.sCode)) to sLine
        End

        Function_Return True
    End_Function

    {Published=True} 
    { Description = """
        Changes legacy Insert command to use the function Insert.
        Example: 'Insert "," In sText At 2' --> 'Move (Insert(",", sText, 2)) to sText'
        ' If sOne Eq "A" Insert "B" in sOne at 2' --> ' If sOne Eq "A" Move (Insert("B", sOne, 2)) to sOne'
        { MethodType = eStandard_Function }
        """ }
    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sNose sLineLC sToken sVar1 sVar2 sText
        Integer iPos iItem iInPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True or TokenizerData.bIsInCommand = True) Begin
            Function_Return False
        End

        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End

        Move (Trim(sLine)) to sLine

        Move "" to sNose
        Move (Lowercase(sLine)) to sLineLC
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        // If anything left of the CS_Insert command, save it in "sNose" (start string)
        If (iItem > 0) Begin
            Move (Pos(Lowercase(CS_Insert), sLineLC)) to iPos
            Move (Left(sLine, (iPos -1))) to sNose
            Move (Replace(sNose, sLine, "")) to sLine
        End

        // Remove the CS_Insert command
        Move TokenizerData.asLineTokens[iItem] to sToken
        Move (Replace(sToken, sLine, "")) to sLine
        // Get the first variable
        Move TokenizerData.asLineTokens[iItem + 1] to sVar1

        // Find and remove the "IN" keyword.
        Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sToken
            Move (Replace(sToken, sLine, "")) to sLine
            Move TokenizerData.asLineTokens[iItem + 1] to sVar2
        End

        // Find and remove the "AT" keyword, and save the next parameter which is the position to insert at.
        Move (SearchArray(CS_At, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Move TokenizerData.asLineTokens[iItem] to sToken
            Move (Replace(sToken, sLine, "")) to sLine
            Move TokenizerData.asLineTokens[iItem + 1] to iInPos
        End

        Move "" to sText
        If (sNose <> "") Begin
            Move sNose to sText
            Move (Trim(sText) + " ") to sText
        End
        Append sText CS_Move " " "(" CS_Insert "(" sVar1 "," sVar2 "," iInPos "))" " " CS_To " " sVar2

        Move (TokenizerData.sIndentation + String(sText)) to sLine
        If (TokenizerData.sEndComment <> "") Begin
            Append sLine TokenizerData.sEndComment
        End
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Changes legacy Current_Object -> Self
        Replaces the legacy keyword 'Current_Object' with 'Self'
        { MethodType = eStandard_Function } 
        """ }
    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
        String sChar
        Boolean bFound
        Integer iPos iItem
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move (SearchArray(CS_Current_Object, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
            If (iPos <> 0) Begin
                Move (Mid(sLine, 1, (iPos -1))) to sChar
                If (sChar <> "(") Begin
                    Function_Return
                End
            End
            Else Begin
                Function_Return False
            End
        End

        Get _ReplaceLineToken TokenizerData sLine CS_Current_Object CS_Self to sLine
        // Note! We call ourself recursively if there are more than one "current_object".
        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos <> 0) Begin
            Get ChangeCurrent_ObjectToSelf (&sLine) "" to bFound
        End

        Function_Return True
    End_Function

    {Published=True} 
    { Description = """
        Replaces IN command with expression operator Contains.
        It also swap places for the two variables involved and adds paranthesis.
        { MethodType = eStandard_Function }
        """ }
    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
        String sOrg sPattern sMatched sRemain sHost sSub sText sAfter sBefore sItem sExpression
        Integer iSize iCount iItem
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End
        Move (SearchArray(CS_With, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Insert, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Pos, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Move (SearchArray(CS_In, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Function_Return False
        End

        Move sLine to sOrg
        Move sLine to sText
        Move TokenizerData.asLineTokens[iItem -1] to sAfter
        Move TokenizerData.asLineTokens[iItem +1] to sBefore
        Decrement iItem
        Move ("(" + sBefore * CS_Contains * String(sAfter) + ")") to sExpression
        // Set the "Before" array item to the expression
        Move sExpression            to TokenizerData.asLineTokens[iItem]
        // Add expression to the expression array:
        Move (SizeOfArray(TokenizerData.aExpressions)) to iSize
        Move sExpression            to TokenizerData.aExpressions[iSize].sExpression
        Move (Length(sExpression))  to TokenizerData.aExpressions[iSize].iLength
        Move (Pos(sAfter, sOrg))    to TokenizerData.aExpressions[iSize].iStartPos
        If (TokenizerData.BooleanIndicator.AsBoolean.sCode <> "") Begin
            Move sExpression to TokenizerData.BooleanIndicator.AsBoolean.sCode
        End
        Increment iItem
        // Remove the two items we have concatenated.
        Move (RemoveFromArray(TokenizerData.asLineTokens, iItem)) to TokenizerData.asLineTokens
        Move (RemoveFromArray(TokenizerData.asLineTokens, iItem)) to TokenizerData.asLineTokens
        Move (SizeOfArray(TokenizerData.asLineTokens)) to iSize
        Decrement iSize
        Move "" to sText
        For iCount from 0 to iSize
            Move TokenizerData.asLineTokens[iCount] to sItem
            Append sText sItem " "
        Loop

        If (sText <> sOrg) Begin
            Move (TokenizerData.sIndentation + Trim(sText)) to sLine
            If (TokenizerData.sEndComment <> "") Begin
                Append sLine " " TokenizerData.sEndComment
            End
            Set pTokenizer to TokenizerData
        End

        Function_Return (sLine <> sOrg)
    End_Function

    {Published=True} 
    { Description = """
        Changes legacy Left command with Left.
        Example: Left sVar 5 to sLeft -> Move (Left(sVar, 5)) to sLeft
        { MethodType = eStandard_Function }
        """ }
    Function ChangeLeftCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Left to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Changes legacy comparison operators to: <, <=, =, <>, >, >= 
        Replaces: gt, ge, lt, le, eq, ne with > >= < <= = <>
        It does not change operators in e.g. find operations.
        { MethodType = eStandard_Function }
        """ }
    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
        String sExpression sOrg sOrgNS sOverStrikeLine
        Boolean bFound
        Integer iItem iCount iSize iPos iLeftParanthesis iRightParanthesis
        tTokenizer TokenizerData
        tOperatorsInfo OperatorInfo

        Get pTokenizer to TokenizerData
        If (TokenizerData.OperatorsInfo.bIsLegacy = False) Begin
            Function_Return False
        End
        If (Lowercase(TokenizerData.FirstLeftCommand.sCode) = Lowercase(CS_Find) or Lowercase(TokenizerData.SecondLeftCommand.sCode) = Lowercase(CS_Find)) Begin
            Function_Return False
        End
        Move (SearchArray(CS_Constrain, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem <> -1) Begin
            Function_Return False
        End
        Get _HasLegacyOperator TokenizerData.sOverstrikeLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Ltrim(sLine)) to sOrg
        Get _TrimInsideSpaces sOrg to sOrgNS 
        Move TokenizerData.sOverstrikeLine to sOverStrikeLine

        Move (SizeOfArray(TokenizerData.aExpressions)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move TokenizerData.aExpressions[iCount].sExpression to sExpression
            Move (Pos(sExpression, sOrgNS)) to iPos
            If (iPos = 0) Begin
                Move TokenizerData.aExpressions[iCount].sExpressionNP to sExpression
                Move (Pos(sExpression, sOrgNS)) to iPos
            End      
            If (iPos <> 0) Begin
                Move (Replace(sExpression, sOrgNS, "")) to sOrgNS
                Move TokenizerData.aExpressions[iCount].sExpression to sExpression
                Move (Insert(sExpression, sOrgNS, iPos)) to sOrgNS
            End
            Else Begin
                Move (Pos(sExpression, sOverStrikeLine)) to iPos
                If (iPos <> 0) Begin                   
                    Move sOverStrikeLine to sOrgNS
                    Move (Replace(sExpression, sOrgNS, "")) to sOrgNS
                    Move TokenizerData.aExpressions[iCount].sExpression to sExpression
                    Get _TrimInsideSpaces sExpression to sExpression
                    Move (Insert(sExpression, sOrgNS, iPos)) to sOrgNS
                End
            End
        Loop

        Get _ReplaceAllLegacyOperators sOrgNS to sOrgNS

        Move (TokenizerData.sIndentation + String(sOrgNS)) to sOrgNS
        If (sOrg <> sOrgNS) Begin
            Move sOrgNS to sLine
        End
        Function_Return (sOrg <> sOrgNS)
    End_Function

    {Published=True} 
    { Description = """
        Changes Shadow_State and Object_Shadow_State to Enabled_State
        Example: Set Shadow_State [of oObject] to True -> Set Enabled_State [of oObject] to False
                 Set Object_Shadow_State [of oObject] to True -> Set Enabled_State [of oObject] to False
        { MethodType = eStandard_Function }
        """ }
    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
        String sToState sText sLineLC sEndComment sSpaces
        Boolean bFound bIsComment
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bIsComment
        If (bIsComment = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Object_Shadow_State TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Get _IsKeywordInLine CS_Shadow_State TokenizerData.asLineTokens to bFound
        End
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Get _EndComment sLine to sEndComment
            Move (Replace(sEndComment, sLine, "")) to sLine
            Move (Rtrim(sLine)) to sText
            Move (Replace(sText, sLine, "")) to sSpaces
            Move (sSpaces + String(sEndComment)) to sEndComment
            Move (Rtrim(sLine)) to sLine
        End

        Move (Lowercase(sLine)) to sLineLC
        Move (Pos(Lowercase(CS_Object_Shadow_State), sLineLC)) to iPos
        If (iPos <> 0) Begin
            Get _ReplaceLineToken TokenizerData sLine CS_Object_Shadow_State CS_Enabled_State to sLine
        End
        Else Begin
            Move (Pos(Lowercase(CS_Shadow_State), sLineLC)) to iPos
            If (iPos <> 0) Begin
                Get _ReplaceLineToken TokenizerData sLine CS_Shadow_State CS_Enabled_State to sLine
            End
        End
        Move (Lowercase(sLine)) to sLineLC

        // We also need to negate any "True" or "False" in the "to" part of the line
        Move TokenizerData.ToStatement.sCode to sToState
        If (Lowercase(sToState) = Lowercase(CS_True) or Lowercase(sToState) = Lowercase(CS_False)) Begin
            Get _IsKeywordInLine CS_True TokenizerData.asLineTokens to bFound
            If (bFound = True) Begin
                Move (Pos(Lowercase(CS_True), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_True CS_False to sLine
                End
            End
            Else Begin
                Get _IsKeywordInLine CS_False TokenizerData.asLineTokens to bFound
                Move (Pos(Lowercase(CS_False), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Get _ReplaceLineToken TokenizerData sLine CS_False CS_True to sLine
                End
            End
        End
        // Or any self defined boolean variable at end of line:
        Else Begin
            Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
            // Add "not" keyword
            If (iPos = 0) Begin
                Move (Replace(sToState, sLine, ("(" + CS_Not + "(" + sToState + "))"))) to sLine
            End
            // Remove "not" keyword and its parantheses. Note that it can contain spaces.
            Else Begin
                Move (Replace("(", sToState, "")) to sText
                Move (Replace(Lowercase(CS_Not), sText, "")) to sText
                Move (Pos(Lowercase(CS_Not), Lowercase(sToState))) to iPos
                Move (Overstrike("   ", sToState, iPos)) to sToState
                Move (Replaces("(", sToState, "")) to sToState
                Move (Replaces(")", sToState, "")) to sToState
                Move (Trim(sToState))              to sToState
                Move (Pos(Lowercase(" " + CS_To + " "), sLineLC)) to iPos
                If (iPos <> 0) Begin
                    Move (Left(sLine, (iPos -1))) to sLine
                    Append sLine " " CS_To " " sToState
                End
            End
        End   
        Move (Rtrim(sLine)) to sLine
        If (sEndComment <> "") Begin
            Append sLine sEndComment
        End
        Else If (TokenizerData.sEndComment <> "") Begin
            Append sLine " " TokenizerData.sEndComment
        End

        Function_Return True
    End_Function

    {Published=True} 
    { Description = """  
        Changes usage of the legacy Length command with function Length.
        Example: Length sVar to iLength -> Move (Length(sVar)) to iLength
        { MethodType = eStandard_Function }
        """ }
    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Changes usage of legacy Pos command with function Pos.
        Example: Pos "-"  in sIns to iPos --> Move (Pos("-",sIns)) to iPos
        { MethodType = eStandard_Function }
        """ }
    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """ 
        Changes legacy Replace command with function Replace.
        Example: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
        { MethodType = eStandard_Function }
        """ }
    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Replace to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """ 
        Changes legacy Replace command with function Replace.
        Example: Right sVar 5 to sLeft -> Move (Rigth(sVar, 5)) to sLeft
        { MethodType = eStandard_Function }
        """ }
    Function ChangeRightCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Right to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """ 
        Changes legacy Sysdate4 command to Sysdate command.
        Changes the command "Sysdate4" -> Sysdate, as the SysDate4 command is obsolete.
        { MethodType = eStandard_Function }
        """ }
    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        tTokenizer TokenizerData
        tToken Token

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move TokenizerData.FirstLeftCommand to Token
        Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
        If (bFound = False) Begin
            Move TokenizerData.SecondLeftCommand to Token
            Move (Lowercase(Token.sCode) = Lowercase(CS_Sysdate4)) to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End

        Move (Replace("4", sLine, "")) to sLine
        Function_Return True
    End_Function

    {Published=True} 
    { Description = """
        Changes lecacy Trim command with function Trim.
        Example: Trim sVal to sVal -> Move (Trim(sVal)) to sVal
        { MethodType = eStandard_Function }
        """ }
    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        Integer iItem iPos
        tTokenizer TokenizerData
        String sVarName sKeyword sKeywordLC sLineLC

        Get pTokenizer to TokenizerData
        Get _IsCommentLineOrBlank sLine to bFound
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Get _IsKeywordInLine CS_Trim TokenizerData.asLineTokens to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move CS_Trim              to sKeyword
        Move (Lowercase(CS_Trim)) to sKeywordLC
        Move (Lowercase(sLine))   to sLineLC
        Move (SearchArray(sKeywordLC, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        Move TokenizerData.asLineTokens[iItem + 1] to sVarName
        If (sVarName = "") Begin
            Function_Return False
        End
        Move (Pos(sKeywordLC, sLineLC)) to iPos
        If (iPos <> 0) Begin
            Move (Replace(sKeyword, sLine, "")) to sLine
            Move (Replace(" " + sVarName + " ", sLine, "")) to sLine
            Move (Insert(CS_Move + " (" + CS_Trim + "(" + String(sVarName) + ")) ", sLine, iPos)) to sLine
            Move True to bChanged
        End

        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Changes lecasy 'Get Create U_Class' with 'Get Create (RefClass(Class))'
        { MethodType = eStandard_Function }
        """ }
    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bValid bIgnore
        String sTest sClassName sOldStyle sNewStyle
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move "" to sClassName
        Move (Lowercase(sLine)) to sTest
        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
        Get _TrimInsideSpaces sTest to sTest
        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
        If (Pos(" create u_", sTest)) Begin
            Move (Lowercase(sLine)) to sTest
            Move (Pos("u_", sTest)) to iPos
            Get _IsValidClassCharacter sTest iPos to bValid
            While (bValid)
                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
                Increment iPos
                Get _IsValidClassCharacter sTest iPos to bValid
            Loop
        End
        If (sClassName <> "") Begin
            Move True to bChanged
            Move sClassName to sOldStyle
            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
            Move ("(RefClass(" + sClassName + "))") to sNewStyle
            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
        End
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """ 
        Changes legacy ZeroString command with function ZeroString.
        Example: ZeroString iLength to sParameter --> Move (ZeroString(iLength)) to sParameter
        { MethodType = eStandard_Function }
        """ }
    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """ 
        Adjusts the casing of all scopes and keywords to match the casing as defined in the 
        language configuration.
        This is a wrapper function for the cScintillaEdit editor.
        A visible instantiation of the cScintillaEdit class is needed for this function to
        operate properly.
        { MethodType = eEditor_Function }
        """ }
    Function EditorNormalizeCase String[] ByRef asCode String sParameter Returns Boolean
        Handle hoEditor
        Boolean bOK bChanged
        String[] asRefactoredCode
        tRefactorSettings RefactorSettings

        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Error "phoEditor = 0 (Function: EditorNormalizeCase)"
            Function_Return 0
        End

        Set Changed_State of hoEditor to False
        Send RefactorNormalizeCase of hoEditor
        Send PumpMsgQueue of Desktop
        Get Changed_State of hoEditor to bChanged

        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Reindents the source code with the number of spaces specified in the sParameter variable.
        { MethodType = eEditor_Function }
        { EnumList = 1,2,3,4,5,6}
        { InitialValue = 4}
        { HelpTopic = Select the indent size you want to use for spaces when indenting code 
                      and when breaking a line on rewriting a single line to multiple lines.
                      It is the same value that can be set on the Editor Settings dialog tab size.
        """ }
    Function EditorReIndent String[] ByRef asCode String sParameter Returns Boolean
        Handle hoEditor
        Boolean bOK bChanged
        String[] asRefactoredCode
        tRefactorSettings RefactorSettings

        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Error "phoEditor = 0 (Function: EditorReIndent)"
            Function_Return 0
        End
        // This is automatically set by the _InitTabSize message in cBaseFuncLib
        // when the program is started.
        If (num_arguments > 1) Begin
            Set piTabSize of hoEditor to sParameter
        End

        Set Changed_State of hoEditor to False
        Send RefactorReIndent of hoEditor
        Send GotoLine of hoEditor 0
        Send PumpMsgQueue of Desktop
        Get Changed_State of hoEditor to bChanged

        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure.
        { MethodType = eStandard_Function }
        """ }
    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
        Boolean bFound bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bIsBlank = True or TokenizerData.bIsComment = True or TokenizerData.sEndComment = "") Begin
            Function_Return False
        End
        Get _IsValidRemoveEndCommentsLine sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get _RemoveComments (&sLine) to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Removes 'Local' keyword if present from procedures and functions variable declaration lines.
        { MethodType = eStandard_Function }
        """ }
    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound bVariableDeclaration bLocalVariableArrayDeclaration
        String sText
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move sLine to sText
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get _IsVariableDeclarationLine  of ghoRefactorFuncLib TokenizerData.sOverstrikeLine  to bVariableDeclaration
        Get _IsVariableArrayDeclaration of ghoRefactorFuncLib TokenizerData.sOverstrikeLine to bLocalVariableArrayDeclaration
        If (bVariableDeclaration = False and bLocalVariableArrayDeclaration = False) Begin
            Function_Return False
        End

        Move False to bChanged
        Move (LTrim(sLine)) to sText
        Move (Left(sText, 6)) to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_Local) + " ")) Begin
            // local must be the first word on the line.
            // Now find the local statement and remove it.
            Move (Lowercase(sLine)) to sText
            Move (Pos((Lowercase(CS_Local) + " "), sText)) to iPos
            If (iPos > 0) Begin
                Move (Remove(sLine, iPos, 6)) to sLine
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Removes legacy IDE markers '//AB-Store' etc.
        Returns True if at least one legacy IDE (Studio) source code marker was found.
        { MethodType = eRemove_Function }
        """ }
    Function RemoveOldStudioMarkers String sLine Returns Boolean
        Boolean bFound
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bFound
        Move (Trim(sLine)) to sLine

        Case Begin
            Case (sLine = "//AB-IgnoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-IgnoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-PanelStoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreTopStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreTopEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ClientStoreEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-DDOStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-DDOEnd")
                Move True to bFound
                Case Break
            Case (Left(sLine, 6) = "//AB/ ")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-MenuPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-End")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ToolbarPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ViewStart")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-ViewEnd")
                Move True to bFound
                Case Break
            Case (sLine = "//AB-StatusBarPackage")
                Move True to bFound
                Case Break
            Case (sLine = "//IDE-FileType=ftApplication")
                Move True to bFound
                Case Break
        Case End

        Function_Return bFound
    End_Function

    {Published=True} 
    { Description = """ 
        Removes legacy Register_Object structures on top of e.g. view files.
        It removes old style Studio 'Project Object Structures"
        It does not do so for WebApp (*.wo) files.
        { MethodType = eRemove_Function }
        """ }
    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
        String[] asObjectNames
        tTokenizer TokenizerData

        Move True to bWriteLine
        Get pTokenizer to TokenizerData
        If (TokenizerData.bIsVariableDeclaration or TokenizerData.bIsInCommand or ;
            TokenizerData.bIsInClass or TokenizerData.bIsInImage or TokenizerData.bIsInFunction or ;
            TokenizerData.bIsInProcedure or TokenizerData.bIsInDF23MultiLineString) Begin
            Function_Return False
        End

        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd
        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
        Get pasObjectNames                to asObjectNames

        If (bRegisterAllObjectsEnd = False) Begin
            If (bRegisterAllObjectsStart = False) Begin
                Get _IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
                Set pbRegisterAllObjectsStart        to bRegisterAllObjectsStart
            End
            If (bRegisterAllObjectsStart = True) Begin
                Get _IsRegisterObjectInArray sLine asObjectNames to bWriteLine
                Move False to bProjectObjectStructureStart
                Set           pbProjectObjectStructureStart to False
            End
            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
                Get _IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
            End
            If (bProjectObjectStructureStart = True) Begin
                Get _IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
            End
            Get _IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
            If (bRegisterAllObjectsEnd = True) Begin
                Send _ResetProjectObjectStructureProperties
                // This means that we won't bother with the rest of the file.
                Set pbRegisterAllObjectsEnd to True
            End
        End
        If (bWriteLine = False) Begin
            Move "" to sLine
        End
        Function_Return (bWriteLine = False)
    End_Function

    {Published=True} 
    { Description = """
        Removes 'Private' keyword from Property declaration lines.
        { MethodType = eStandard_Function }
        """ }
    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Removes 'Public' property members from property declaration lines.
        { MethodType = eStandard_Function }
        """ }
    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Removes "MS Sans Serif" font source lines.
        { MethodType = eStandard_Function }
        """ }
    Function RemoveSansSerif String sLine Returns Boolean
        String sTest
        Boolean bWriteLine

        Move False to bWriteLine
        Move (Lowercase(Trim(sLine))) to sTest
        Move (Replaces(" ", sTest, ""))  to sTest
        Move (Replaces("'", sTest, "*")) to sTest
        Move (Replaces('"', sTest, "*")) to sTest
        If (sTest contains 'settypefaceto*mssansserif*') Begin
            Move True to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    {Published=True} 
    { Description = """
        Removes old Studio generated comments lines.
        Examples:
            // fires when the button is clicked
            //OnChange is called on every changed character
            // Visual DataFlex xx.x Client Size Adjuster
            // Visual DataFlex xx.x Migration Utility
            ...and so on
        { MethodType = eRemove_Function }
        """ }
    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
        String sText sComment sComment2
        Boolean bFound bChanged
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move False to bChanged
        Move (Trim(sLine)) to sText
        If (sText = "" or sText = CS_CommentSymbol or sText contains (CS_CommentSymbol + "AB") or TokenizerData.bIsComment = False) Begin
            Function_Return False
        End

        Move "fires when the button is clicked" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "onchange is called on every changed character" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex"      to sComment
        Move "client size adjuster" to sComment2
        Get _IsStudioGeneratedComment sLine sComment sComment2 to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex"    to sComment
        Move "migration utility," to sComment2
        Get _IsStudioGeneratedComment sLine sComment sComment2 to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "If you set Current_radio you must set this after the" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "radio objects have been created AND after Notify_select_State has been" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "created. i.e. Set in bottom-code at end!!" to sComment
        Get _IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Removes all spaces at the end of code lines (trailing spaces).
        { MethodType = eStandard_Function }
        """ }
    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
        Integer iBefore iAfter
        Boolean bChanged
        tTokenizer TokenizerData

        Move (Length(sLine))     to iBefore
        Move (RTrim(sLine))      to sLine
        Move (Length(sLine))     to iAfter
        Move (iBefore <> iAfter) to bChanged

        Function_Return bChanged
    End_Function

    {Published=True} 
    { Description = """
        Reports Only! Makes no changes to the source code.
        Check all files in the current workspace to see if they are used, else list them in a report.
        Pass an array with *all source files*
        Returns a list of unused files. See the DFRefactor programs: 'Other Log Files' toolbar button for results.
        { MethodType = eReport_Function }
        """ }
    Function ReportUnusedSourceFiles String[] ByRef asFiles String sParameter Returns Integer
        Handle ho
        Integer iRetval
        String sLogFile
        String[] asOtherLogFiles
        tRefactorSettings RefactorSettings

        Get Create (RefClass(cUnusedSourceFiles)) to ho
        If (ho = 0) Begin
            Error "Could not create cUnusedSourceFiles object."
            Function_Return 0
        End

        Get pRefactorSettings to RefactorSettings
        Get FindUnusedSourceFiles of ho RefactorSettings.FileData.asFullFileNames to iRetval

        If (iRetval <> 0) Begin
            Get pasOtherLogFiles to asOtherLogFiles
            Get psLogFile of ho to asOtherLogFiles[SizeOfArray(asOtherLogFiles)]
            Set pasOtherLogFiles to asOtherLogFiles
        End
        Send Destroy of ho
        Function_Return iRetval
    End_Function

    {Published=True} 
    { Description = """
        Pass all source files including path, as a string array.
        The naming style of datadictionaries over time has not been constant.
        The new style is:
            Object o<tablename>_DD is a c<TableName>Datadictionary
        They also have a switch so you can keep on using the legacy style name which is:
            Object o<tablename>_DD is a <tablename>_Datadictionary
      
        However before VDF12, this is how it looked:
            Object <tableName>_DD is a <tablename>_Datadictionary
      
        This caused tremendous headaches as due to the extra "o" we ended up with name clashes
        all over the place. Copying old code into new views/dialogs simply breaks and if your
        codebase has mixed styles then the compiler will not catch that.
        A code nightmare.
      
        This program allows you to switch between the following code styles:
        <TableName>_DD  == eDDOldStyle
        TO: o<TableName>_DD == eDDStudioStyle 
        { MethodType = eOther_FunctionAll }
        { EnumList = eDDUnknown, eDDOldStyle, eDDStudioStyle, eDDNewStyle}
        { InitialValue = eDDNewStyle}
        { HelpTopic = eDDNewStyle = o<tablename>_dd
                      eDDSutdioStyle = o<tablename>DD
                      oDDOldStyle = <tablename>_DD
                      eDDUnknown = style unknow or noet yet classified}
        """ }
    Function RestylelDDOs String[] ByRef asFiles String sParameter Returns Integer
        String sHomePath
        Handle ho
        Integer iRetval iSize iCount eDDOStyle
        tRefactorSettings RefactorSettings

        If (SizeOfArray(asFiles) <= 0) Begin
            Function_Return False
        End

        Get Create (RefClass(cDDOReStyler)) to ho
        If (ho = 0) Begin
            Error "Could not create cDDORestyler object (Function: RestyleDDOs)"
            Function_Return 0
        End

        If (num_arguments > 1) Begin
            Move sParameter to eDDOStyle
        End

        // Path for the workspace we are refactoring:

        // ToDo: Check e.g. this code on how to set a temp filelist path etc:
        //  Procedure LoadTablesList Integer iSortBy String sFilter
        // Or perhaps do that in a "Procedure Set psHomePath" of the class??
        Get psHomePath  of ghoApplication to sHomePath
        If (sHomePath = "") Begin
            Get psHome of (phoWorkspace(ghoApplication)) to sHomePath
        End
        Set psHomePath  of ho to sHomePath
        Set peDDOStyle  of ho to eDDOStyle
        Set pasAllFiles of ho to asFiles
        Get StartDDORestyler of ho to iRetval
        Send Destroy of ho

        Function_Return iRetval
    End_Function

    {Published=True} 
    { Description = """
        Removes variables from functions and procedures that aren't used.
        A limitation is that it does *not* remove unused struct variables.
        Pass a source file as a string array.
        Removes all unusad locally defined, in Procedures & Functions, for the
        passed string array. Returns number of removed unused local variables.
        { MethodType = eOther_Function }
        """ }
    Function RemoveUnusedLocals String[] ByRef asCode String sParameter Returns Integer
        Handle ho
        Integer iRetval

        Get Create (RefClass(cRemoveUnusedLocals)) to ho
        If (ho = 0) Begin
            Error "Could not create cRemoveUnusedLocals object."
            Function_Return 0
        End

        Set piNoOfUnusedLocalVariables of ho to 0
        Get RemoveUnusedLocals of ho (&asCode) to iRetval
        Send Destroy of ho

        Function_Return iRetval
    End_Function

    {Published=True} 
    { Description = """
        Removes blank lines if more than xx 'Max blank lines' 
        Removes consecutive empty blank lines if more than sParameter value.
        Pass a source file as a string array.
        Returns the passed string array but with removed duplicated empty lines.
        { MethodType = eOther_Function }
        { EnumList = 1,2,3,4,5,6}
        { InitialValue = 2 }
        { HelpTopic = Select max number of consecutive blank lines allowed in source files. }
        """ }
    Function RemoveMultipleBlankLines String[] ByRef asCode String sParameter Returns Integer
        String[] asCodeOut
        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines
        String sLine
        Boolean bImageStart bImageEnd bMakeImageTest

        Move False to bImageStart
        Move False to bImageEnd
        Move True  to bMakeImageTest
        Move 0 to iCurrentNoOfEmptyLines
        Move sParameter to iMaxNoOfEmptyLines

        Move (SizeOfArray(asCode)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (Trim(asCode[iCount])) to sLine

            If (bMakeImageTest = True) Begin
                If (bImageStart = False and bImageEnd = False) Begin
                    Get _IsImageStart sLine to bImageStart
                End
            End

            If (bImageStart = False and bImageEnd = False) Begin
                If (sLine = "") Begin
                    Increment iCurrentNoOfEmptyLines
                End
                Else Begin
                    Move 0 to iCurrentNoOfEmptyLines
                End
            End
            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
                Move asCode[iCount] to asCodeOut[SizeOfArray(asCodeOut)]
            End

            If (bMakeImageTest = True) Begin
                If (bImageStart = True) Begin
                    Get _IsImageEnd sLine to bImageEnd
                    If (bImageEnd = True) Begin
                        Move False to bImageStart
                        Move False to bImageEnd
                        Move False to bMakeImageTest
                    End
                End
            End
        Loop

        Move (SizeOfArray(asCode) - SizeOfArray(asCodeOut)) to iEmptyLines
        Move asCodeOut to asCode

        Function_Return iEmptyLines
    End_Function

    {Published=True} 
    { Description = """ 
        Splits If/Else single lines to If/Else - Begin constructs.
        This function accepts a parameter controlling the If/Else or Begin/End block constructs.
        Valid sParameters, See: EnumList;
        { MethodType = eStandard_Function }
        { EnumList = "CI_SplitBySpaceAndSemicolon, CI_SplitBySemicolon, CI_SplitToBeginEndBlock" }
        { InitialValue = CI_SplitToBeginEndBlock }
        { HelpTopic = "Valid Values; CI_SplitBySpaceAndSemicolon - 'Split line with space and semicolon',
        CI_SplitBySemicolon - 'Split line with semicolon', CI_SplitToBeginEndBlock - 'Use a Begin/End block'"}
        """ }
    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
        Boolean bStop bChanged bFound
        Integer iIndent eSplitBy iTabSize iItem
        String  sText
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        Move (SearchArray(CS_If, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
        If (iItem = -1) Begin
            Move (Trim(sLine)) to sText
            Move (Left(sText, 3)) to sText
            Move (Lowercase(sText) = Lowercase(CS_If)) to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End

        Move False to bChanged
        Move sParameter to eSplitBy
        Get piTabSize to iTabSize
        If (eSplitBy = CI_SplitToBeginEndBlock) Begin
            Move (SearchArray(CS_Begin, TokenizerData.asLineTokens, Desktop, RefFunc(DFSTRICMP))) to iItem
            If (iItem <> -1) Begin
                Function_Return False
            End
        End

        Move (LTrim(sLine))     to sText
        Move (Pos(sText,sLine) - 1) to iIndent
        Move (Left(sText, 3))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_If) + " ")) Begin
            Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
            If (bStop = False) Begin
                // It's one of those single line if statements, break it up
                Move (Lowercase(sLine)) to sText
                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
            End
        End
        Else Begin
            Move (LTrim(sLine))     to sText
            Move (Left(sText, 5))   to sText
            Move (Lowercase(sText)) to sText
            If (sText = (Lowercase(CS_Else) + " ")) Begin
                Get _IsLineEndSemiColonOrBegin TokenizerData.sOverstrikeLine to bStop
                If (bStop = False) Begin
                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
                End
            End
        End
        Function_Return bChanged
    End_Function
    
End_Object
