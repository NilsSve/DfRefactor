Compiling Program: C:\Projects\DF18\DfRefactor\AppSrc\DFRefactor.src
Memory Available: 2147483646
1>//****************************************************************************
1>// $Module type: Program
1>// $Module name: DFRefactor
1>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
1>// Web-site    : http://www.rdctools.com
1>// Created     : 2018-08-05 @ 09:50 (Military date format: YY-MM-DD)
1>//
1>// Description : Code Refactor functions for DataFlex.
1>//
1>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
1>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
1>// This is free software; you can redistribute it and/or modify it under the terms of the
1>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
1>// in the help folder for more details.
1>//
1>//****************************************************************************
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
67438>>>// these are all the packages used in a standard MDI menubar/toolbar system
67438>>>
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
67438>>>>>Use Dfpanel.pkg
67438>>>>>Use cCJCommandBarSystem.pkg
67438>>>>>Use LanguageText.pkg
67438>>>>>
67438>>>>>
67438>>>>>Class cCJUndoMenuItem is a cCJMenuItem
67439>>>>>    
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>        Set psCaption   to C_$CaptionUndo
67444>>>>>        Set psToolTip to C_$ToolTipUndo
67445>>>>>        Set psDescription to C_$DescUndo
67446>>>>>        Set psImage to "ActionUndo.ico"
67447>>>>>        Set pbActiveUpdate to True
67448>>>>>        Set psCategory to C_$CategoryEdit
67449>>>>>        Set psShortcut to C_$Key_Ctrl_Z
67450>>>>>    End_Procedure
67451>>>>>    
67451>>>>>    Procedure OnExecute Variant vCommandBarControl
67453>>>>>        Send Undo of (focus(Self))
67454>>>>>    End_Procedure
67455>>>>>    
67455>>>>>    Function IsEnabled Returns Boolean
67457>>>>>        Boolean bEnabled
67457>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
67458>>>>>        Function_Return bEnabled
67459>>>>>    End_Function
67460>>>>>    
67460>>>>>End_Class
67461>>>>>
67461>>>>>
67461>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
67462>>>>>    
67462>>>>>    Procedure Construct_Object
67464>>>>>        Forward Send Construct_Object
67466>>>>>        Set psCaption   to C_$CaptionDelete
67467>>>>>        Set psToolTip to C_$ToolTipDelete
67468>>>>>        Set psDescription to C_$DescDelete
67469>>>>>        Set psImage to "actionDelete.ico"
67470>>>>>        Set psShortcut to C_$Key_Delete
67471>>>>>        Set pbActiveUpdate to True
67472>>>>>        Set psCategory to C_$CategoryEdit
67473>>>>>    End_Procedure
67474>>>>>    
67474>>>>>    
67474>>>>>    Procedure OnExecute Variant vCommandBarControl
67476>>>>>        Send Delete of (focus(Self))
67477>>>>>    End_Procedure
67478>>>>>    
67478>>>>>    Function IsEnabled Returns Boolean
67480>>>>>        Boolean bEnabled
67480>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
67481>>>>>        Function_Return bEnabled
67482>>>>>    End_Function
67483>>>>>    
67483>>>>>End_Class
67484>>>>>
67484>>>>>
67484>>>>>Class cCJCutMenuItem is a cCJMenuItem
67485>>>>>    
67485>>>>>    Procedure Construct_Object
67487>>>>>        Forward Send Construct_Object
67489>>>>>        Set psCaption   to C_$CaptionCut
67490>>>>>        Set psToolTip to C_$TooltipCut
67491>>>>>        Set psDescription to C_$DescCut
67492>>>>>        Set psImage to "actionCut.ico"
67493>>>>>        Set psShortcut to C_$Key_Ctrl_X
67494>>>>>        Set pbActiveUpdate to True
67495>>>>>        Set psCategory to C_$CategoryEdit
67496>>>>>    End_Procedure
67497>>>>>    
67497>>>>>    
67497>>>>>    Procedure OnExecute Variant vCommandBarControl
67499>>>>>        Send Cut of (focus(Self))
67500>>>>>    End_Procedure
67501>>>>>    
67501>>>>>    Function IsEnabled Returns Boolean
67503>>>>>        Boolean bEnabled
67503>>>>>        Get CanCut of (Focus(Self)) to bEnabled
67504>>>>>        Function_Return bEnabled
67505>>>>>    End_Function
67506>>>>>    
67506>>>>>End_Class
67507>>>>>
67507>>>>>
67507>>>>>Class cCJCopyMenuItem is a cCJMenuItem
67508>>>>>    
67508>>>>>    Procedure Construct_Object
67510>>>>>        Forward Send Construct_Object
67512>>>>>        Set psCaption   to C_$CaptionCopy
67513>>>>>        Set psToolTip to C_$ToolTipCopy
67514>>>>>        Set psDescription to C_$DescCopy
67515>>>>>        Set psImage to "actionCopy.ico"
67516>>>>>        Set psShortcut to C_$Key_Ctrl_C
67517>>>>>        Set pbActiveUpdate to True
67518>>>>>        Set psCategory to C_$CategoryEdit
67519>>>>>    End_Procedure
67520>>>>>    
67520>>>>>    
67520>>>>>    Procedure OnExecute Variant vCommandBarControl
67522>>>>>        Send Copy of (focus(Self))
67523>>>>>    End_Procedure
67524>>>>>    
67524>>>>>    Function IsEnabled Returns Boolean
67526>>>>>        Boolean bEnabled
67526>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
67527>>>>>        Function_Return bEnabled
67528>>>>>    End_Function
67529>>>>>    
67529>>>>>End_Class
67530>>>>>
67530>>>>>
67530>>>>>Class cCJPasteMenuItem is a cCJMenuItem
67531>>>>>    
67531>>>>>    Procedure Construct_Object
67533>>>>>        Forward Send Construct_Object
67535>>>>>        Set psCaption   to C_$CaptionPaste
67536>>>>>        Set psToolTip to C_$ToolTipPaste
67537>>>>>        Set psDescription to C_$DescPaste
67538>>>>>        Set psImage to "actionPaste.ico"
67539>>>>>        Set pbActiveUpdate to True
67540>>>>>        Set psShortcut to C_$Key_Ctrl_V
67541>>>>>        Set psCategory to C_$CategoryEdit
67542>>>>>    End_Procedure
67543>>>>>    
67543>>>>>    
67543>>>>>    Procedure OnExecute Variant vCommandBarControl
67545>>>>>        Send Paste of (focus(Self))
67546>>>>>    End_Procedure
67547>>>>>    
67547>>>>>    Function IsEnabled Returns Boolean
67549>>>>>        Boolean bEnabled
67549>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
67550>>>>>        Function_Return bEnabled
67551>>>>>    End_Function
67552>>>>>    
67552>>>>>End_Class
67553>>>>>
67553>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
67554>>>>>    
67554>>>>>    Procedure Construct_Object
67556>>>>>        Forward Send Construct_Object
67558>>>>>        Set psCaption   to C_$CaptionSelectAll
67559>>>>>        Set psToolTip to C_$ToolTipSelectAll
67560>>>>>        Set psDescription to C_$DescSelectAll
67561>>>>>        Set pbActiveUpdate to True
67562>>>>>        Set psShortcut to C_$Key_Ctrl_A
67563>>>>>        Set psCategory to C_$CategoryEdit
67564>>>>>    End_Procedure
67565>>>>>    
67565>>>>>    
67565>>>>>    Procedure OnExecute Variant vCommandBarControl
67567>>>>>        Send Select_All of (focus(Self))
67568>>>>>    End_Procedure
67569>>>>>    
67569>>>>>    Function IsEnabled Returns Boolean
67571>>>>>        Boolean bEnabled
67571>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
67572>>>>>        Function_Return bEnabled
67573>>>>>    End_Function
67574>>>>>    
67574>>>>>End_Class
67575>>>>>
67575>>>>>
67575>>>>>Class cCJExitMenuItem is a cCJMenuItem
67576>>>>>    
67576>>>>>    Procedure Construct_Object
67578>>>>>        Forward Send Construct_Object
67580>>>>>        Set psCaption to C_$CaptionExit
67581>>>>>        Set psToolTip to C_$ToolTipExit
67582>>>>>        Set psDescription to C_$ToolTipExit
67583>>>>>        Set psShortcut to C_$Key_Alt_F4
67584>>>>>        Set psCategory to C_$CategoryFile
67585>>>>>    End_Procedure
67586>>>>>    
67586>>>>>    Procedure OnExecute Variant vCommandBarControl
67588>>>>>        Send Exit_Application of Desktop
67589>>>>>    End_Procedure
67590>>>>>    
67590>>>>>End_Class
67591>>>>>
67591>>>>>Class cCJHelpMenuItem is a cCJMenuItem
67592>>>>>    
67592>>>>>    Procedure Construct_Object
67594>>>>>        Forward Send Construct_Object
67596>>>>>        Set psCaption to C_$CaptionHelp
67597>>>>>        Set psDescription to C_$ToolTipHelp
67598>>>>>        Set psToolTip to C_$DescHelp
67599>>>>>        Set psImage to "ActionHelp.ico"
67600>>>>>        Set psShortcut to "F1"
67601>>>>>        Set psCategory to C_$CategoryHelp
67602>>>>>    End_Procedure
67603>>>>>    
67603>>>>>    Procedure OnExecute Variant vCommandBarControl
67605>>>>>        Send Help of (Focus(Self))
67606>>>>>    End_Procedure
67607>>>>>    
67607>>>>>End_Class
67608>>>>>
67608>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
67609>>>>>    
67609>>>>>    Procedure Construct_Object
67611>>>>>        Forward Send Construct_Object
67613>>>>>        Set psCaption to C_$CaptionAddStatusbar
67614>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
67615>>>>>        Set psDescription to  C_$DescAddStatusbar
67616>>>>>        Set psCategory to C_$CategoryWindow
67617>>>>>    End_Procedure
67618>>>>>    
67618>>>>>    Procedure OnExecute Variant vCommandBarControl
67620>>>>>        Handle hoCommandBars hoClientArea
67620>>>>>        Get CommandBarSystemObject to hoCommandBars
67621>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67622>>>>>        If hoClientArea Begin
67624>>>>>            // the clientarea's parent panel has message
67624>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
67625>>>>>        End
67625>>>>>>
67625>>>>>    End_Procedure
67626>>>>>    
67626>>>>>    Function IsChecked Returns Boolean
67628>>>>>        Boolean bOn
67628>>>>>        Handle hoCommandBars hoClientArea
67628>>>>>        Get CommandBarSystemObject to hoCommandBars
67629>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67630>>>>>        If hoClientArea Begin
67632>>>>>            // the clientarea's parent panel has message
67632>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
67633>>>>>        End
67633>>>>>>
67633>>>>>        Function_Return bOn
67634>>>>>    End_Function
67635>>>>>End_Class
67636>>>>>
67636>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
67637>>>>>    
67637>>>>>    Procedure Construct_Object
67639>>>>>        Forward Send Construct_Object
67641>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
67642>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
67643>>>>>        Set psDescription to C_$DescAutoArrangeIcons
67644>>>>>        Set psCategory to C_$CategoryWindow
67645>>>>>    End_Procedure
67646>>>>>    
67646>>>>>    Procedure OnExecute Variant vCommandBarControl
67648>>>>>        Handle hoCommandBars hoClientArea
67648>>>>>        Get CommandBarSystemObject to hoCommandBars
67649>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67650>>>>>        If hoClientArea Begin
67652>>>>>            // the clientarea's parent panel has message
67652>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
67653>>>>>        End
67653>>>>>>
67653>>>>>    End_Procedure
67654>>>>>    
67654>>>>>    Function IsChecked Returns Boolean
67656>>>>>        Boolean bOn
67656>>>>>        Handle hoCommandBars hoClientArea
67656>>>>>        Get CommandBarSystemObject to hoCommandBars
67657>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67658>>>>>        If hoClientArea Begin
67660>>>>>            // the clientarea's parent panel has message
67660>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
67661>>>>>        End
67661>>>>>>
67661>>>>>        Function_Return bOn
67662>>>>>    End_Function
67663>>>>>End_Class
67664>>>>>
67664>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
67665>>>>>    
67665>>>>>    Procedure Construct_Object
67667>>>>>        Forward Send Construct_Object
67669>>>>>        Set psCaption to C_$CaptionRestoreMenus
67670>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
67671>>>>>        Set psDescription to C_$DescRestoreMenus
67672>>>>>        Set psCategory to C_$CategoryWindow
67673>>>>>    End_Procedure
67674>>>>>    
67674>>>>>    Procedure OnExecute Variant vCommandBarControl
67676>>>>>        Handle hoCommandBars
67676>>>>>        Get CommandBarSystemObject to hoCommandBars
67677>>>>>        Send RestoreLayout of hoCommandBars
67678>>>>>    End_Procedure
67679>>>>>    
67679>>>>>End_Class
67680>>>>>
67680>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
67681>>>>>    
67681>>>>>    Procedure Construct_Object
67683>>>>>        Forward Send Construct_Object
67685>>>>>        Set psCaption to C_$CaptionCascade
67686>>>>>        Set psToolTip to C_$ToolTipCascade
67687>>>>>        Set psDescription to  C_$DescCascade
67688>>>>>        Set psImage to "ActionCascade.ico"
67689>>>>>        Set psCategory to C_$CategoryWindow
67690>>>>>    End_Procedure
67691>>>>>    
67691>>>>>    Procedure OnExecute Variant vCommandBarControl
67693>>>>>        Handle hoCommandBars hoClientArea
67693>>>>>        Get CommandBarSystemObject to hoCommandBars
67694>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67695>>>>>        If hoClientArea Begin
67697>>>>>            Send Cascade_Windows of hoClientArea
67698>>>>>        End
67698>>>>>>
67698>>>>>    End_Procedure
67699>>>>>End_Class
67700>>>>>
67700>>>>>Class cCJTileHorizontally is a cCJMenuItem
67701>>>>>    
67701>>>>>    Procedure Construct_Object
67703>>>>>        Forward Send Construct_Object
67705>>>>>        Set psCaption to C_$CaptionTileHorizontally
67706>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
67707>>>>>        Set psDescription to  C_$DescTileHorizontally
67708>>>>>        Set psImage to "ActionTileHorizontally.ico"
67709>>>>>        Set psCategory to C_$CategoryWindow
67710>>>>>    End_Procedure
67711>>>>>    
67711>>>>>    Procedure OnExecute Variant vCommandBarControl
67713>>>>>        Handle hoCommandBars hoClientArea
67713>>>>>        Get CommandBarSystemObject to hoCommandBars
67714>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67715>>>>>        If hoClientArea Begin
67717>>>>>            Send Tile_Windows_Horizontal of hoClientArea
67718>>>>>        End
67718>>>>>>
67718>>>>>    End_Procedure
67719>>>>>End_Class
67720>>>>>
67720>>>>>Class cCJTileVertically is a cCJMenuItem
67721>>>>>    
67721>>>>>    Procedure Construct_Object
67723>>>>>        Forward Send Construct_Object
67725>>>>>        Set psCaption to C_$CaptionTileVertically
67726>>>>>        Set psToolTip to C_$ToolTipTileVertically
67727>>>>>        Set psDescription to  C_$DescTileVertically
67728>>>>>        Set psImage to "ActionTileVertically.ico"
67729>>>>>        Set psCategory to C_$CategoryWindow
67730>>>>>    End_Procedure
67731>>>>>    
67731>>>>>    Procedure OnExecute Variant vCommandBarControl
67733>>>>>        Handle hoCommandBars hoClientArea
67733>>>>>        Get CommandBarSystemObject to hoCommandBars
67734>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67735>>>>>        If hoClientArea Begin
67737>>>>>            Send Tile_Windows_Vertical of hoClientArea
67738>>>>>        End
67738>>>>>>
67738>>>>>    End_Procedure
67739>>>>>End_Class
67740>>>>>
67740>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
67741>>>>>    
67741>>>>>    Procedure Construct_Object
67743>>>>>        Forward Send Construct_Object
67745>>>>>        Set psCaption to C_$CaptionMinimizeWindows
67746>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
67747>>>>>        Set psDescription to  C_$DescMinimizeWindows
67748>>>>>        Set psCategory to C_$CategoryWindow
67749>>>>>    End_Procedure
67750>>>>>    
67750>>>>>    Procedure OnExecute Variant vCommandBarControl
67752>>>>>        Handle hoCommandBars hoClientArea
67752>>>>>        Get CommandBarSystemObject to hoCommandBars
67753>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67754>>>>>        If hoClientArea Begin
67756>>>>>            // the clientarea's parent panel has message
67756>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
67757>>>>>        End
67757>>>>>>
67757>>>>>    End_Procedure
67758>>>>>End_Class
67759>>>>>
67759>>>>>
67759>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
67760>>>>>    
67760>>>>>    Procedure Construct_Object
67762>>>>>        Forward Send Construct_Object
67764>>>>>        Set psCaption to C_$CaptionRestoreWindows
67765>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
67766>>>>>        Set psDescription to  C_$DescRestoreWindows
67767>>>>>        Set psCategory to C_$CategoryWindow
67768>>>>>    End_Procedure
67769>>>>>    
67769>>>>>    Procedure OnExecute Variant vCommandBarControl
67771>>>>>        Handle hoCommandBars hoClientArea
67771>>>>>        Get CommandBarSystemObject to hoCommandBars
67772>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67773>>>>>        If hoClientArea Begin
67775>>>>>            // the clientarea's parent panel has message
67775>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
67776>>>>>        End
67776>>>>>>
67776>>>>>    End_Procedure
67777>>>>>End_Class
67778>>>>>
67778>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
67779>>>>>    
67779>>>>>    Procedure Construct_Object
67781>>>>>        Forward Send Construct_Object
67783>>>>>        Set psCaption to C_$CaptionArrangeIcons
67784>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
67785>>>>>        Set psDescription to  C_$DescArrangeIcons
67786>>>>>        Set psCategory to C_$CategoryWindow
67787>>>>>    End_Procedure
67788>>>>>    
67788>>>>>    Procedure OnExecute Variant vCommandBarControl
67790>>>>>        Handle hoCommandBars hoClientArea
67790>>>>>        Get CommandBarSystemObject to hoCommandBars
67791>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67792>>>>>        If hoClientArea Begin
67794>>>>>            Send Arrange_Icons of hoClientArea
67795>>>>>        End
67795>>>>>>
67795>>>>>    End_Procedure
67796>>>>>    
67796>>>>>End_Class
67797>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
67797>>>>>Use cCJCommandBarSystem.pkg
67797>>>>>Use LanguageText.pkg
67797>>>>>
67797>>>>>// It is expected that if you use this class that you provide an about object that is
67797>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
67797>>>>>// because you may wish to create your own custom about package.
67797>>>>>
67797>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
67798>>>>>
67798>>>>>    Procedure Construct_Object
67800>>>>>        Forward Send Construct_Object
67802>>>>>        Set psCaption to C_$CaptionAbout
67803>>>>>        Set psDescription to C_$ToolTipAbout
67804>>>>>        Set psToolTip to C_$DescAbout
67805>>>>>        Set psImage to "ActionAbout.ico"
67806>>>>>        Set psCategory to C_$CategoryHelp
67807>>>>>    End_Procedure
67808>>>>>    
67808>>>>>    Procedure OnExecute Variant vCommandBarControl
67810>>>>>        Handle hoCommandBars hoClientArea
67810>>>>>        Get CommandBarSystemObject to hoCommandBars
67811>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67812>>>>>        If hoClientArea Begin
67814>>>>>            Send Activate_About of hoClientArea
67815>>>>>        End
67815>>>>>>
67815>>>>>    End_Procedure
67816>>>>>
67816>>>>>End_Class
67817>>>>>
67817>>>>>
67817>>>Use cCJDeoMenuItemClasses.pkg
67817>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
67817>>>>>Use cCJCommandBarSystem.pkg
67817>>>>>
67817>>>>>Register_Function Client_ID Returns Integer
67817>>>>>
67817>>>>>// only used by cCJMDIWIndowsMenuItem
67817>>>>>Class cCJMDIWindowItem is a cCJMenuItem
67818>>>>>    
67818>>>>>    Procedure Construct_Object
67820>>>>>        Forward Send Construct_Object
67822>>>>>        Property Handle phWindow 0 // object id of view
67823>>>>>        Set pbControlFlagNoMovable to True
67824>>>>>        Set pbActiveUpdate to True
67825>>>>>    End_Procedure
67826>>>>>    
67826>>>>>    Procedure OnExecute Variant vCommandBarControl
67828>>>>>        Handle hWindow
67828>>>>>        Get phWindow to hWindow
67829>>>>>        Send Activate_View of hWindow
67830>>>>>    End_Procedure
67831>>>>>    
67831>>>>>End_Class
67832>>>>>
67832>>>>>
67832>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
67833>>>>>    
67833>>>>>    Procedure Construct_Object
67835>>>>>        Forward Send Construct_Object
67837>>>>>        Property Handle[] phArrayOfWindows
67838>>>>>        Set peControlType to xtpControlPopup
67839>>>>>        Set psCategory to C_$CategoryWindow
67840>>>>>    End_Procedure
67841>>>>>    
67841>>>>>    // This adds MDI windows to the existing menu items.
67841>>>>>    // This removes any existing windows menus and always adds a new set to the end
67841>>>>>    
67841>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
67843>>>>>        Handle  hClientArea hView
67843>>>>>        String  sLabel
67843>>>>>        Integer i iWindows
67843>>>>>        Handle[] hArrayOfWindows
67844>>>>>        Variant vItem
67844>>>>>        
67844>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
67844>>>>>        // also assume that destroying an action removes all menu instances of that action
67844>>>>>        Get phArrayOfWindows to hArrayOfWindows
67845>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
67846>>>>>        For i from 0 to (iWindows-1)
67852>>>>>>
67852>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
67853>>>>>        Loop
67854>>>>>>
67854>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
67855>>>>>        
67855>>>>>        // Add all views to this menu. Create the action and add the item
67855>>>>>        Move 0 to i
67856>>>>>        Get Client_Id to hClientArea // object id of client area
67857>>>>>        If (hClientArea > 0) Begin
67859>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
67860>>>>>            While (hView <> 0)
67864>>>>>                If (Active_State(hView)) Begin
67866>>>>>                    // create the action
67866>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
67867>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
67868>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
67869>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
67870>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
67872>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
67873>>>>>                    End
67873>>>>>>
67873>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
67874>>>>>                    If (i=0) Begin
67876>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
67877>>>>>                    End
67877>>>>>>
67877>>>>>                    // Create a menu item for this action
67877>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
67878>>>>>                    Increment i
67879>>>>>                End
67879>>>>>>
67879>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
67880>>>>>            Loop
67881>>>>>>
67881>>>>>        End
67881>>>>>>
67881>>>>>        
67881>>>>>        Set phArrayOfWindows to hArrayOfWindows
67882>>>>>        
67882>>>>>    End_Procedure
67883>>>>>    
67883>>>>>End_Class
67884>Use cCJCommandBarSystem.pkg
67884>Use File_dlg.pkg
67884>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
67884>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
67884>>>>>Use VDFBase.pkg
67884>>>>>
67884>>>>>Class cFormatter is an cObject
67885>>>>>    
67885>>>>>    Procedure Construct_object
67887>>>>>        Integer iCh
67887>>>>>        Forward Send construct_object
67889>>>>>        Property String  psCurrencySymbol
67890>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
67891>>>>>        
67891>>>>>        Property String  psLeft
67892>>>>>        Property String  psright
67893>>>>>        Property Integer pbThousandsSep
67894>>>>>        Property Integer piPoints
67895>>>>>        
67895>>>>>        Property String  psCurPosLeft
67896>>>>>        Property String  psCurPosright
67897>>>>>        Property Integer pbCurPosThousandsSep
67898>>>>>        Property Integer piCurPosPoints
67899>>>>>        
67899>>>>>        Property String  psCurNegLeft
67900>>>>>        Property String  psCurNegright
67901>>>>>        Property Integer pbCurNegThousandsSep
67902>>>>>        Property Integer piCurNegPoints
67903>>>>>        
67903>>>>>        Property String  psNumPosLeft
67904>>>>>        Property String  psNumPosright
67905>>>>>        Property Integer pbNumPosThousandsSep
67906>>>>>        Property Integer piNumPosPoints
67907>>>>>        
67907>>>>>        Property String  psNumNegLeft
67908>>>>>        Property String  psNumNegright
67909>>>>>        Property Integer pbNumNegThousandsSep
67910>>>>>        Property Integer piNumNegPoints
67911>>>>>        
67911>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
67912>>>>>        Send SetFormat  ",#.*"           False // numeric
67913>>>>>        
67913>>>>>    End_Procedure
67914>>>>>    
67914>>>>>    // internal
67914>>>>>    // parse passed format string and set temporary properties with result
67914>>>>>    Procedure ParseFormat String sFmt
67916>>>>>        
67916>>>>>        String sLeft sRight sDigit
67916>>>>>        Integer bSep iPos i iDigits
67916>>>>>        
67916>>>>>        // replace any literals. A "/" followed by anything.
67916>>>>>        // some literals are special. $ . , / #
67916>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
67917>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
67918>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
67919>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
67920>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
67921>>>>>        Move (Character(9)) to sDigit
67922>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
67923>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
67924>>>>>        
67924>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
67925>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
67928>>>>>        
67928>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
67929>>>>>        
67929>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
67930>>>>>        
67930>>>>>        // Move all the special literals back into place before parsing
67930>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
67931>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
67932>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
67933>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
67934>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
67935>>>>>        
67935>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
67937>>>>>            Move 1 to i                        // look for first non # to right and count the #s
67938>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
67940>>>>>                Move -2 to iDigits
67941>>>>>                Increment i
67942>>>>>            End
67942>>>>>>
67942>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
67946>>>>>                Increment i
67947>>>>>            Loop
67948>>>>>>
67948>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
67949>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
67952>>>>>            //
67952>>>>>            Move 1 to i                           // find the first non-# to the left of the point
67953>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
67957>>>>>                Increment i
67958>>>>>            Loop
67959>>>>>>
67959>>>>>            Move (left(sFmt,iPos-i)) to sLeft
67960>>>>>        End
67960>>>>>>
67960>>>>>        Else Begin                             // we have no decinal
67961>>>>>            Move 0 to iDigits                  // so points is none
67962>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
67963>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
67965>>>>>                Move sFmt to sLeft
67966>>>>>                Move ""   to sRight
67967>>>>>            End
67967>>>>>>
67967>>>>>            Else Begin
67968>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
67969>>>>>                Move 1 to i
67970>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
67974>>>>>                    Increment i
67975>>>>>                Loop
67976>>>>>>
67976>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
67977>>>>>            End
67977>>>>>>
67977>>>>>        End
67977>>>>>>
67977>>>>>        // set temporary format properties and exit
67977>>>>>        Set pbThousandsSep to bSep
67978>>>>>        Set psLeft         to sLeft
67979>>>>>        Set psRight        to sRight
67980>>>>>        Set piPoints       to iDigits
67981>>>>>    End_Procedure
67982>>>>>    
67982>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
67982>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
67982>>>>>    //
67982>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
67982>>>>>    Procedure SetFormat String sFmt Integer bCurrency
67984>>>>>        String sPos sNeg
67984>>>>>        Integer iPos
67984>>>>>        
67984>>>>>        Move (Pos(";",sFmt)) to iPos
67985>>>>>        If iPos Begin
67987>>>>>            Move (left(sFmt,iPos-1))    to sPos
67988>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
67989>>>>>        End
67989>>>>>>
67989>>>>>        Else Begin
67990>>>>>            Move sFmt         to sPos
67991>>>>>            Move ("-" + sFmt) to sNeg
67992>>>>>        End
67992>>>>>>
67992>>>>>        Send ParseFormat sPos
67993>>>>>        If bCurrency Begin
67995>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
67996>>>>>            Set psCurPosLeft         to (psLeft(Self))
67997>>>>>            Set psCurPosRight        to (psRight(Self))
67998>>>>>            Set piCurPosPoints       to (piPoints(Self))
67999>>>>>        End
67999>>>>>>
67999>>>>>        Else Begin
68000>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
68001>>>>>            Set psNumPosLeft         to (psLeft(Self))
68002>>>>>            Set psNumPosRight        to (psRight(Self))
68003>>>>>            Set piNumPosPoints       to (piPoints(Self))
68004>>>>>        End
68004>>>>>>
68004>>>>>        
68004>>>>>        Send ParseFormat sNeg
68005>>>>>        If bCurrency Begin
68007>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
68008>>>>>            Set psCurNegLeft         to (psLeft(Self))
68009>>>>>            Set psCurNegRight        to (psRight(Self))
68010>>>>>            Set piCurNegPoints       to (piPoints(Self))
68011>>>>>        End
68011>>>>>>
68011>>>>>        Else Begin
68012>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
68013>>>>>            Set psNumNegLeft         to (psLeft(Self))
68014>>>>>            Set psNumNegRight        to (psRight(Self))
68015>>>>>            Set piNumNegPoints       to (piPoints(Self))
68016>>>>>        End
68016>>>>>>
68016>>>>>    End_Procedure
68017>>>>>    
68017>>>>>    // low level formatting. Pass parameters
68017>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
68019>>>>>        String  sLeft sRight sNumber sSep sDec
68019>>>>>        Integer bIsNegative iDec iLen iCh
68019>>>>>        
68019>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
68022>>>>>        Move (Character(iCh)) to sDec
68023>>>>>        
68023>>>>>        Move (abs(nNumber)) to sNumber
68024>>>>>        Move (Pos(sDec,sNumber)) to iDec
68025>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
68026>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
68027>>>>>        // format for decimal separator
68027>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
68030>>>>>        
68030>>>>>        // format for thousand sep.
68030>>>>>        If bSep Begin
68032>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
68035>>>>>            Move (Character(iCh)) to sSep
68036>>>>>            Move (Length(sLeft)) to iLen
68037>>>>>            While (iLen>3)
68041>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
68042>>>>>                Move (iLen-3) to iLen
68043>>>>>            Loop
68044>>>>>>
68044>>>>>        End
68044>>>>>>
68044>>>>>        // if decimal points or -2 (allow anything) and there are points to show
68044>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
68047>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
68048>>>>>    End_Function
68049>>>>>    
68049>>>>>    // Public: Format for currency
68049>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
68051>>>>>        String  sLeft sRight
68051>>>>>        Integer bSep
68051>>>>>        If (nNumber<0) Begin
68053>>>>>            Get pbCurNegThousandsSep to bSep
68054>>>>>            Get psCurNegLeft         to sLeft
68055>>>>>            Get psCurNegRight        to sRight
68056>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
68059>>>>>        End
68059>>>>>>
68059>>>>>        Else Begin
68060>>>>>            Get pbCurPosThousandsSep to bSep
68061>>>>>            Get psCurPosLeft         to sLeft
68062>>>>>            Get psCurPosRight        to sRight
68063>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
68066>>>>>        End
68066>>>>>>
68066>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
68067>>>>>    End_Function
68068>>>>>    
68068>>>>>    // Public: Format for numeric
68068>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
68070>>>>>        String  sLeft sRight
68070>>>>>        Integer bSep
68070>>>>>        If (nNumber<0) Begin
68072>>>>>            Get pbNumNegThousandsSep to bSep
68073>>>>>            Get psNumNegLeft         to sLeft
68074>>>>>            Get psNumNegRight        to sRight
68075>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
68078>>>>>        End
68078>>>>>>
68078>>>>>        Else Begin
68079>>>>>            Get pbNumPosThousandsSep to bSep
68080>>>>>            Get psNumPosLeft         to sLeft
68081>>>>>            Get psNumPosRight        to sRight
68082>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
68085>>>>>        End
68085>>>>>>
68085>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
68086>>>>>    End_Function
68087>>>>>    
68087>>>>>    
68087>>>>>    // Public: Format passing format string
68087>>>>>    Function FormatVal Number nNumber String sFmt Returns String
68089>>>>>        Integer iPos bIsNeg
68089>>>>>        String  sLeft sRight
68089>>>>>        Integer iPoints bSep
68089>>>>>        Move (nNumber<0) to bIsNeg
68090>>>>>        Move (Pos(";",sFmt)) to iPos
68091>>>>>        Case Begin
68091>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
68094>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
68098>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
68102>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
68104>>>>>        Case End
68104>>>>>        Send ParseFormat sFmt
68105>>>>>        Get pbThousandsSep to bSep
68106>>>>>        Get psLeft         to sLeft
68107>>>>>        Get psRight        to sRight
68108>>>>>        Get piPoints       to iPoints
68109>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
68110>>>>>    End_Function
68111>>>>>    
68111>>>>>End_Class
68112>>>
68112>>>Global_Variable Handle ghoFormatter
68112>>>Get Create of desktop U_cFormatter to ghoFormatter
68113>>>
68113>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
68115>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
68116>>>End_Function
68117>>>
68117>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
68119>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
68120>>>End_Function
68121>>>
68121>>>Function FormatValue Global Number nNum String sFmt Returns String
68123>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
68124>>>End_Function
68125>>>
68125>>>Procedure SetCurrencyFormat Global String sFmt
68127>>>    Send SetFormat of ghoFormatter sFmt True
68128>>>End_Procedure
68129>>>
68129>>>Procedure SetNumberFormat Global String sFmt
68131>>>    Send SetFormat of ghoFormatter sFmt False
68132>>>End_Procedure
68133>>>
68133>>>
68133>Use cWorkspaceMenuItem.pkg
Including file: cWorkspaceMenuItem.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cWorkspaceMenuItem.pkg)
68133>>>Use cApplication.pkg
68133>>>Use cCJCommandBarSystem.pkg
68133>>>
68133>>>// Procedure that needs to exist in the ghoApplication object.
68133>>>Register_Procedure UpdateWorkspaceSelectorDisplay String sSWSFileName
68133>>>
68133>>>Class cWorkspaceMenuItem is a cCJMenuItem
68134>>>    Procedure OnExecute
68136>>>        String sFileName
68136>>>        Get psCaption to sFileName
68137>>>        Send UpdateWorkspaceSelectorDisplay of ghoApplication sFileName
68138>>>    End_Procedure
68139>>>End_Class
68140>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vWin32fh.pkg)
68140>>>// This code is part of VDF GUIdance
68140>>>// Visit us @ http://www.vdf-guidance.com
68140>>>// e-Mail us @ info@vdf-guidance.com
68140>>>// VDF GUIdance is a mutual project of
68140>>>// Frank Vandervelpen - Vandervelpen Systems and
68140>>>// Wil van Antwerpen  - Antwise Solutions
68140>>>// All software source code should be used <<AS IS>> without any warranty.
68140>>>//
68140>>>//
68140>>>// *** Windows 32bit file handling wrapper class ***
68140>>>//
68140>>>
68140>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
68140>>>//                   This may be painfull for some of you, but it was really needed as it was
68140>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
68140>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
68140>>>//
68140>>>// The used naming-convention is:
68140>>>//     - a prefix of "vWin32_" for every external function declaration
68140>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
68140>>>//
68140>>>// By using this we are guarding ourselves for conflicts with variable declarations
68140>>>// of DataAccess in the future.
68140>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
68140>>>//
68140>>>// mm-dd-yyyy Author Description
68140>>>//
68140>>>//                   vSHGetFolderPath added to retrieve the new shell folders
68140>>>//                   vGetWindowsDirectory
68140>>>//
68140>>>//                   vGetTempFileName
68140>>>//                   vGetTempPath
68140>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
68140>>>//                   This is an absolute need for WebApp. We expect you to handle the
68140>>>//                   error in your application anyways. Changed this for:
68140>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
68140>>>// 03-02-2002 **WvA: vRemoveDirectory added
68140>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
68140>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
68140>>>//                   It is renamed too avoid this.
68140>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
68140>>>//                   function vSelectedFileName is now just SelectedFileName
68140>>>//                   Removed the local keyword in the variable declarations
68140>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
68140>>>//                   created file-open dialog
68140>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
68140>>>//                   in that it didn't exactly return the correct filename of the file created.
68140>>>//                   This has now been taken care of.
68140>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
68140>>>//                   These declarations are now included from the vWin32fh header file.
68140>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
68140>>>//                   Before today one could always undo the operation, as of now you cannot as
68140>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
68140>>>//                   Since i don't really expect someone to use that feature it has been removed.
68140>>>//                   One can however restore to the old way of handling by simply calling the
68140>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
68140>>>//                   filehandling operations
68140>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
68140>>>//                   as well as the StringFromRightOfChar function.
68140>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
68140>>>//                   DISABLED now as testing shows that it does not work as advertised...
68140>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
68140>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
68140>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
68140>>>//                   extended characters are treated ok too.
68140>>>//                   Reported by Flemming from
68140>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
68140>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
68140>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
68140>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
68140>>>//                   Added vSelectSavefile function to create a file save dialog
68140>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
68140>>>//                   Added vParentPath function to retrieve the parent "node" of a path
68140>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
68140>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
68140>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
68140>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
68140>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
68140>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
68140>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
68140>>>
68140>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
68140>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\cvFileDialogs.pkg)
68140>>>>>//***************************************************************************
68140>>>>>//*
68140>>>>>//* Class:        cvSaveAsDialog
68140>>>>>//* Package Name: cvFileDialogs.pkg
68140>>>>>//*
68140>>>>>//***************************************************************************
68140>>>>>
68140>>>>>Use File_dlg.pkg
68140>>>>>
68140>>>>>// *WvA: 13-01-1999 Created
68140>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
68140>>>>>// This function opens the Windows standard file open dialog and returns the selected
68140>>>>>// file_name.
68140>>>>>Class cvSelectFile_Dialog is an OpenDialog
68141>>>>>
68141>>>>>    Procedure Construct_Object Integer iImage_Id
68143>>>>>        Forward Send Construct_Object iImage_Id
68145>>>>>        Set HideReadOnly_State to True
68146>>>>>    End_Procedure
68147>>>>>
68147>>>>>    Function SelectedFileName Returns String
68149>>>>>        String sFileName
68149>>>>>        Move "" to sFileName
68150>>>>>        If (Show_Dialog(Self)) Begin
68152>>>>>            Move (RTrim(File_Name(Self))) to sFileName
68153>>>>>        End
68153>>>>>>
68153>>>>>        Function_Return sFileName
68154>>>>>    End_Function
68155>>>>>End_Class
68156>>>>>
68156>>>>>// *WvA: 13-01-1999 Created
68156>>>>>// This function opens the Windows standard file open dialog and returns the selected
68156>>>>>// file_name. Returns '' if the user didn't make a selection.
68156>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
68156>>>>>//                   file-open dialog
68156>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
68158>>>>>    String sSelectedFile
68158>>>>>    Integer hoOpenFileDialog
68158>>>>>
68158>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
68160>>>>>
68160>>>>>        Set Dialog_Caption    to sCaptionText
68161>>>>>        Set Filter_String     to sSupportedFileTypes
68162>>>>>        Set Initial_Folder    to sInitialFolder
68163>>>>>
68163>>>>>        Move Self       to hoOpenFileDialog
68164>>>>>    End_Object
68165>>>>>
68165>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
68166>>>>>    Send Destroy_Object to hoOpenFileDialog
68167>>>>>    Function_Return sSelectedFile
68168>>>>>End_Function
68169>>>>>
68169>>>>>Class cvSaveAsDialog is a SaveAsDialog
68170>>>>>
68170>>>>>    Procedure Construct_Object
68172>>>>>        Forward Send Construct_Object
68174>>>>>        Set HideReadOnly_State to True
68175>>>>>    End_Procedure
68176>>>>>
68176>>>>>    Function SelectedFileName Returns String
68178>>>>>        String sFileName
68178>>>>>        Move "" to sFileName
68179>>>>>        If (Show_Dialog(Self)) Begin
68181>>>>>            Move (RTrim(File_Name(Self))) to sFileName
68182>>>>>        End
68182>>>>>>
68182>>>>>        Function_Return sFileName
68183>>>>>    End_Function
68184>>>>>
68184>>>>>End_Class
68185>>>>>
68185>>>>>// Added optional default filename as suggested by Nils
68185>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
68187>>>>>    String sSelectedFile
68187>>>>>    Integer hoDialog
68187>>>>>
68187>>>>>    Move "" to sSelectedFile
68188>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
68189>>>>>    If (hoDialog) Begin
68191>>>>>    //Set NoChangeDir_State Of hoDialog To True
68191>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
68192>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
68193>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
68194>>>>>        If (Num_Arguments = 4) Begin
68196>>>>>            Set File_Title        of hoDialog to sDefaultFileName
68197>>>>>        End
68197>>>>>>
68197>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
68198>>>>>        Send Destroy of hoDialog
68199>>>>>    End
68199>>>>>>
68199>>>>>    Function_Return sSelectedFile
68200>>>>>End_Function
68201>>>Use Seq_chnl.pkg
68201>>>
68201>>>Use windows.pkg
68201>>>Use Dll.pkg
68201>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vwin32fh.h)
68201>>>>>//TH-Header
68201>>>>>//*****************************************************************************************
68201>>>>>// Copyright (c)  2004 KURANT Project
68201>>>>>// All rights reserved.
68201>>>>>//
68201>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
68201>>>>>// $ProjectName : Windows 32 bits file handling
68201>>>>>// $Authors     : Wil van Antwerpen
68201>>>>>// $Created     : 19.02.2004  19:25
68201>>>>>// $Type        : BSD (as in do with it whatever you like)
68201>>>>>//
68201>>>>>// Contents:
68201>>>>>//  This file contains the Windows API external function call definitions and
68201>>>>>//  constants as they are used in the vWin32fh package.
68201>>>>>//*****************************************************************************************
68201>>>>>//TH-RevisionStart
68201>>>>>//TH-RevisionEnd
68201>>>>>
68201>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
68201>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
68201>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
68201>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
68201>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
68201>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
68201>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
68201>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
68201>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
68201>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
68201>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
68201>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
68201>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
68201>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
68201>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
68201>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
68201>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
68201>>>>>
68201>>>>>
68201>>>>>Define vMax_Path     For |CI260
68201>>>>>Define vMinChar      For |CI$80
68201>>>>>Define vMaxChar      For |CI$7F
68201>>>>>Define vMinShort     For |CI$8000
68201>>>>>Define vMaxShort     For |CI$7FFF
68201>>>>>Define vMinLong      For |CI$80000000
68201>>>>>Define vMaxLong      For |CI$7FFFFFFF
68201>>>>>Define vMaxByte      For |CI$FF
68201>>>>>Define vMaxWord      For |CI$FFFF
68201>>>>>Define vMaxDword     For |CI$FFFFFFFF
68201>>>>>
68201>>>>>
68201>>>>>
68201>>>>>// For FindFirstFile
68201>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
68201>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
68201>>>>>Define vERROR_NO_MORE_FILES    For |CI18
68201>>>>>
68201>>>>>// The defines below can be used to find out what kind of error has occurred if
68201>>>>>// the API-call ShellExecute is used.
68201>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
68201>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
68201>>>>>Define vERROR_BAD_FORMAT       For |CI0011
68201>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
68201>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
68201>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
68201>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
68201>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
68201>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
68201>>>>>Define vSE_ERR_FNF             For |CI0002
68201>>>>>Define vSE_ERR_NOASSOC         For |CI0031
68201>>>>>Define vSE_ERR_OOM             For |CI0008
68201>>>>>Define vSE_ERR_PNF             For |CI0003
68201>>>>>Define vSE_ERR_SHARE           For |CI0026
68201>>>>>
68201>>>>>
68201>>>>>// C-Structure
68201>>>>>//typedef struct _browseinfo {
68201>>>>>//    HWND hwndOwner;
68201>>>>>//    LPCITEMIDLIST pidlRoot;
68201>>>>>//    LPSTR pszDisplayName;
68201>>>>>//    LPCSTR lpszTitle;
68201>>>>>//    UINT ulFlags;
68201>>>>>//    BFFCALLBACK lpfn;
68201>>>>>//    LPARAM lParam;
68201>>>>>//    int iImage;
68201>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
68201>>>>>
68201>>>>>//declare C structure struct_browseinfo
68201>>>>>//as documented in MSDN under Windows Shell API
68201>>>>>Struct tvBrowseInfo
68201>>>>>  Handle    hWndOwner
68201>>>>>  Pointer   pIDLRoot
68201>>>>>  Pointer   pszDisplayName
68201>>>>>  Pointer   lpszTitle
68201>>>>>  dWord     ulFlags
68201>>>>>  Pointer   lpfnCallback
68201>>>>>  dWord     lParam
68201>>>>>  DWord     iImage
68201>>>>>End_Struct // tvBrowseInfo
68201>>>>>
68201>>>>>// Browsing for directory.
68201>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
68201>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
68201>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
68201>>>>>                                            // The callback function can set the status text by
68201>>>>>                                            // sending messages to the dialog box.
68201>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
68201>>>>>
68201>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
68201>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
68201>>>>>
68201>>>>>// message from browser
68201>>>>>//Define BFFM_INITIALIZED        1
68201>>>>>//Define BFFM_SELCHANGED         2
68201>>>>>
68201>>>>>// messages to browser
68201>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
68201>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
68201>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
68201>>>>>
68201>>>>>
68201>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
68202>>>>>
68202>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
68203>>>>>
68203>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
68204>>>>>
68204>>>>>
68204>>>>>
68204>>>>>
68204>>>>>Struct tvSecurity_attributes
68204>>>>>  DWord   nLength
68204>>>>>  Pointer lpDescriptor
68204>>>>>  Integer bInheritHandle
68204>>>>>End_Struct // tvSecurity_attributes
68204>>>>>
68204>>>>>//nLength:
68204>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
68204>>>>>// SECURITY_ATTRIBUTES structure.
68204>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
68204>>>>>// value of the nLength member. However, an application should still set it properly.
68204>>>>>// That ensures current, future, and cross-platform compatibility.
68204>>>>>//
68204>>>>>//lpSecurityDescriptor:
68204>>>>>// Points to a security descriptor for the object that controls the sharing of it.
68204>>>>>// If NULL is specified for this member, the object may be assigned the default security
68204>>>>>// descriptor of the calling process.
68204>>>>>//
68204>>>>>//bInheritHandle:
68204>>>>>// Specifies whether the returned handle is inherited when a new process is created.
68204>>>>>// If this member is TRUE, the new process inherits the handle.
68204>>>>>
68204>>>>>
68204>>>>>// BOOL CreateDirectory(
68204>>>>>//    LPCTSTR lpPathName,
68204>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
68204>>>>>//   );
68204>>>>>//
68204>>>>>// lpPathName
68204>>>>>//  Points to a null-terminated string that specifies the path of the directory
68204>>>>>//  to be created.
68204>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
68204>>>>>//  This limit is related to how the CreateDirectory function parses paths.
68204>>>>>// lpSecurityAttributes
68204>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
68204>>>>>//  determines whether the returned handle can be inherited by child processes.
68204>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
68204>>>>>// Returns:
68204>>>>>//  If the function succeeds, the return value is nonzero.
68204>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
68204>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
68205>>>>>
68205>>>>>
68205>>>>>// lpPathName
68205>>>>>//  Points to a null-terminated string that specifies the path of the directory
68205>>>>>//  to be removed.
68205>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
68205>>>>>// Returns:
68205>>>>>//  If the function succeeds, the return value is nonzero.
68205>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
68205>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
68206>>>>>
68206>>>>>
68206>>>>>
68206>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
68206>>>>>// executable file or a document file.
68206>>>>>//
68206>>>>>// Operation can be one of the following:
68206>>>>>//    "OPEN"  The function opens the file specified by lpFile.
68206>>>>>//            The file can be an executable file or a document file.
68206>>>>>//            The file can be a folder to open.
68206>>>>>//    "PRINT" The function prints the file specified by lpFile.
68206>>>>>//            The file should be a document file. If the file is an executable file,
68206>>>>>//            the function opens the file, as if "open" had been specified.
68206>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
68206>>>>>//
68206>>>>>// Return Values:
68206>>>>>//
68206>>>>>// If the function succeeds, the return value is the instance handle of the application that
68206>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
68206>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
68206>>>>>//
68206>>>>>// The following table lists these error values:
68206>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
68206>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
68206>>>>>// Public Const ERROR_BAD_FORMAT = 11&
68206>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
68206>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
68206>>>>>// Public Const SE_ERR_DDEBUSY = 30
68206>>>>>// Public Const SE_ERR_DDEFAIL = 29
68206>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
68206>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
68206>>>>>// Public Const SE_ERR_FNF = 2
68206>>>>>// Public Const SE_ERR_NOASSOC = 31
68206>>>>>// Public Const SE_ERR_OOM = 8
68206>>>>>// Public Const SE_ERR_PNF = 3
68206>>>>>// Public Const SE_ERR_SHARE = 26
68206>>>>>
68206>>>>>
68206>>>>>
68206>>>>>// Code to open the program that is associated with the selected file.
68206>>>>>//
68206>>>>>// External function call used in Procedure DoStartDocument
68206>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
68207>>>>>
68207>>>>>
68207>>>>>
68207>>>>>
68207>>>>>Define vFO_MOVE                For |CI$0001
68207>>>>>Define vFO_COPY                For |CI$0002
68207>>>>>Define vFO_DELETE              For |CI$0003
68207>>>>>Define vFO_RENAME              For |CI$0004
68207>>>>>
68207>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
68207>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
68207>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
68207>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
68207>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
68207>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
68207>>>>>                                          // Must be freed using SHFreeNameMappings
68207>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
68207>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
68207>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
68207>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
68207>>>>>
68207>>>>>Struct tvShFileOpStruct
68207>>>>>  Handle  hWnd
68207>>>>>  Integer wFunc
68207>>>>>  Pointer pFrom
68207>>>>>  Pointer pTo
68207>>>>>  Short   fFlags
68207>>>>>  Short   fAnyOperationsAborted
68207>>>>>  Pointer hNameMappings
68207>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
68207>>>>>End_Struct // tvShFileOpStruct
68207>>>>>
68207>>>>>// hwnd
68207>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
68207>>>>>
68207>>>>>// wFunc
68207>>>>>//   Operation to perform. This member can be one of the following values:
68207>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
68207>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
68207>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
68207>>>>>//     FO_RENAME   Renames the files specified by pFrom.
68207>>>>>
68207>>>>>// pFrom
68207>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
68207>>>>>//   be null-separated. The list of names must be double null-terminated.
68207>>>>>
68207>>>>>// pTo
68207>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
68207>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
68207>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
68207>>>>>//   double null-terminated.
68207>>>>>
68207>>>>>// fAnyOperationsAborted
68207>>>>>//   Value that receives TRUE if the user aborted any file operations before they
68207>>>>>//   were completed or FALSE otherwise.
68207>>>>>
68207>>>>>
68207>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
68207>>>>>// This can be a file or a folder.
68207>>>>>// With thanks to Andrew S Kaplan
68207>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
68208>>>>>
68208>>>>>
68208>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
68208>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
68209>>>>>
68209>>>>>
68209>>>>>
68209>>>>>// Courtesy Of Vincent Oorsprong
68209>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
68209>>>>>//   Pointer lpPathName ;
68209>>>>>//   Pointer lpPrefixString ;
68209>>>>>//   Integer uUnique ;
68209>>>>>//   Pointer lpTempFileName ;
68209>>>>>//   Returns Integer
68209>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
68209>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
68210>>>>>
68210>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
68211>>>>>
68211>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
68212>>>>>
68212>>>>>// from:
68212>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
68212>>>>>//
68212>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
68212>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
68212>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
68212>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
68212>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
68212>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
68212>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
68212>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
68212>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
68212>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
68212>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
68212>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
68212>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
68212>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
68212>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
68212>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
68212>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
68212>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
68212>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
68212>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
68212>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
68212>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
68212>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
68212>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
68212>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
68212>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
68212>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
68212>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
68212>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
68212>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
68212>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
68212>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
68212>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
68212>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
68212>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
68212>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
68212>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
68212>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
68212>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
68212>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
68212>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
68212>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
68212>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
68212>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
68212>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
68212>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
68212>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
68212>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
68212>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
68212>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
68212>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
68212>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
68212>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
68212>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
68212>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
68212>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
68212>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
68212>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
68212>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
68212>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
68212>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
68212>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
68212>>>>>
68212>>>>>
68212>>>>>//HRESULT SHGetFolderPath(
68212>>>>>//    HWND hwndOwner,
68212>>>>>//    int nFolder,
68212>>>>>//    HANDLE hToken,
68212>>>>>//    DWORD dwFlags,
68212>>>>>//    LPTSTR pszPath
68212>>>>>//);
68212>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
68212>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
68212>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
68212>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
68212>>>>>// If that fails, it will try to simulate the appropriate behavior.
68212>>>>>//
68212>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
68213>>>>>
68213>>>>>
68213>>>>>
68213>>>>>Struct tvWin32FindData
68213>>>>> Dword            dwFileAttributes
68213>>>>> Dword            ftCreationLowDateTime
68213>>>>> Dword            ftCreationHighDateTime
68213>>>>> dword            ftLastAccessLowDateTime
68213>>>>> Dword            ftLastAccessHighDateTime
68213>>>>> Dword            ftLastWriteLowDateTime
68213>>>>> Dword            ftLastWriteHighDateTime
68213>>>>> Dword            nFileSizeHigh
68213>>>>> Dword            nFileSizeLow
68213>>>>> Dword            dwReserved0
68213>>>>> Dword            dwReserved1
68213>>>>> UChar[vMax_Path] cFileName
68213>>>>> UChar[14]        cAlternateFileName
68213>>>>>End_Struct
68213>>>>>
68213>>>>>// Courtesy Of Vincent Oorsprong
68213>>>>>// lpFileName      : address of name of file to search for
68213>>>>>// lpFindFileData  : address of returned information
68213>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
68214>>>>>
68214>>>>>// Courtesy Of Vincent Oorsprong
68214>>>>>// hFindFile       : handle of search
68214>>>>>// lpFindFileData  : address of structure for data on found file
68214>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
68215>>>>>
68215>>>>>//
68215>>>>>// Unicode equivalents
68215>>>>>//
68215>>>>>// lpFileName      : address of name of file to search for
68215>>>>>// lpFindFileData  : address of returned information
68215>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
68216>>>>>
68216>>>>>// hFindFile       : handle of search
68216>>>>>// lpFindFileData  : address of structure for data on found file
68216>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
68217>>>>>
68217>>>>>
68217>>>>>// Courtesy Of Vincent Oorsprong
68217>>>>>//  hFindFile      : file search handle
68217>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
68218>>>>>
68218>>>>>
68218>>>>>
68218>>>>>Struct tvFileTime
68218>>>>>  DWord dwLowDateTime
68218>>>>>  DWord dwHighDateTime
68218>>>>>End_Struct
68218>>>>>
68218>>>>>
68218>>>>>Struct tvSystemTime
68218>>>>>  UShort wYear
68218>>>>>  UShort wMonth
68218>>>>>  UShort wDayOfWeek
68218>>>>>  UShort wDay
68218>>>>>  UShort wHour
68218>>>>>  UShort wMinute
68218>>>>>  UShort wSecond
68218>>>>>  UShort wMilliSeconds
68218>>>>>End_Struct
68218>>>>>
68218>>>>>
68218>>>>>// Courtesy Of Vincent Oorsprong
68218>>>>>//  lpFileTime     : pointer to file time to convert
68218>>>>>//  lpSystemTime   : pointer to structure to receive system time
68218>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
68219>>>>>
68219>>>>>// Courtesy Of Vincent Oorsprong
68219>>>>>// This function formats the time in a picture-string passed
68219>>>>>//
68219>>>>>// Picture      Meaning
68219>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
68219>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
68219>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
68219>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
68219>>>>>//    m         Minutes with no leading zero for single-digit minutes
68219>>>>>//    mm        Minutes with leading zero for single-digit minutes
68219>>>>>//    s         Seconds with no leading zero for single-digit seconds
68219>>>>>//    ss        Seconds with leading zero for single-digit seconds
68219>>>>>//    t         One character time marker string, such as A or P
68219>>>>>//    tt        Multicharacter time marker string, such as AM or PM
68219>>>>>//
68219>>>>>// For example, to get the time string  "11:29:40 PM"
68219>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
68219>>>>>
68219>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
68220>>>>>
68220>>>>>
68220>>>>>// Courtesy Of Vincent Oorsprong
68220>>>>>// This function formats the date in a picture-string passed
68220>>>>>//
68220>>>>>// Picture      Meaning
68220>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
68220>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
68220>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
68220>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
68220>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
68220>>>>>//              value associated with the specified locale.
68220>>>>>//    M         Month as digits with no leading zero for single-digit months.
68220>>>>>//    MM        Month as digits with leading zero for single-digit months.
68220>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
68220>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
68220>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
68220>>>>>//              associated with the specified locale.
68220>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
68220>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
68220>>>>>//    yyyy      Year represented hy full four digits.
68220>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
68220>>>>>//              with the specified locale. This element is ignored if the date to be formatted
68220>>>>>//              does not have an associated era or period string.
68220>>>>>// For example, to get the date string  "Wed, Aug 31 94"
68220>>>>>// use the following picture string:    "ddd","MMM dd yy"
68220>>>>>
68220>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
68221>>>>>
68221>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
68221>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
68221>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
68221>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
68221>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
68221>>>>>
68221>>>>>//  Date Flags for GetDateFormatW.
68221>>>>>//
68221>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
68221>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
68221>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
68221>>>>>
68221>>>>>
68221>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
68222>>>>>
68222>>>>>
68222>>>>>// **WvA: 20-02-2004
68222>>>>>// While i was testing the format capabilities i stumbled over a very
68222>>>>>// weird problem where it looks like that the integer value gets somehow translated
68222>>>>>// incorrectly into an unsigned integer.
68222>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
68222>>>>>// It does smell a bit fishy though
68222>>>>>// Tested it with the same results on both VDF7 and VDF9.1
68222>>>>>
68222>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
68222>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
68222>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
68222>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
68222>>>>>
68222>>>>>// Possible errors that can be returned by the shellformat function
68222>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
68222>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
68222>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
68222>>>>>
68222>>>>>
68222>>>>> // Courtesy Of Steve Walter,
68222>>>>> // USA Software, Inc
68222>>>>> // Format a disk
68222>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
68222>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
68223>>>>>
68223>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
68223>>>>>
68223>>>>>// SHCreateDirectoryEx
68223>>>>>
68223>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
68223>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
68223>>>>>//
68223>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
68223>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
68223>>>>>//    the files are visible. If they are not visible, expect one of the following:
68223>>>>>//
68223>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
68223>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
68223>>>>>//        ERROR_CANCELLED.
68223>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
68223>>>>>
68223>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
68223>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
68223>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
68223>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
68223>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
68223>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
68223>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
68223>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
68223>>>>>
68223>>>>>//        int SHCreateDirectoryEx(
68223>>>>>//            HWND hwnd,
68223>>>>>//            LPCTSTR pszPath,
68223>>>>>//            const SECURITY_ATTRIBUTES *psa
68223>>>>>//        );
68223>>>>>
68223>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
68224>>>>>
68224>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
68225>>>
68225>>>
68225>>>//
68225>>>// Gets the string from the right of the last sStopChar in sFrom
68225>>>// If sStopChar has no occurences in the string an empty string is
68225>>>// returned.
68225>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
68227>>>    String  sRetVal
68227>>>    String  sChar
68227>>>    Integer iLength
68227>>>    Integer iPos
68227>>>    Boolean bStopChar
68227>>>    Move "" to sRetval
68228>>>    Move (Length(sFrom)) to iLength
68229>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
68231>>>        Move iLength   to iPos
68232>>>        Move (False)   to bStopChar
68233>>>        While Not bStopChar
68237>>>            Move (Mid(sFrom,1,iPos)) to sChar
68238>>>            Decrement iPos
68239>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
68241>>>                Move (True) to bStopChar
68242>>>            End
68242>>>>
68242>>>            Else Begin
68243>>>                Move (sChar+sRetVal) to sRetVal
68244>>>            End
68244>>>>
68244>>>        Loop
68245>>>>
68245>>>    End
68245>>>>
68245>>>    Function_Return sRetVal
68246>>>End_Function
68247>>>
68247>>>// Pre:  sFileName contains the complete path of the file.
68247>>>// Post: returns the complete path of the file.
68247>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
68247>>>Function ParseFolderName Global String sFileName Returns String
68249>>>    String sFile
68249>>>    String sFolderName
68249>>>    String sDirSep // this is "\" for windows, or "/" for unix
68249>>>
68249>>>    Move "" to sFolderName
68250>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68251>>>    If sDirSep In sFileName Begin
68253>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
68254>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
68255>>>    End
68255>>>>
68255>>>    Else If ":" In sFileName Begin
68258>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
68259>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
68260>>>    End
68260>>>>
68260>>>    Function_Return sFolderName
68261>>>End_Function
68262>>>
68262>>>// Pre:  sFileName contains the complete path of the file.
68262>>>// post: The returned filename has it's path removed, but will have a extension
68262>>>Function ParseFileName Global String sFileName Returns String
68264>>>    String sFolderName
68264>>>    String sDirSep // this is "\" for windows, or "/" for unix
68264>>>
68264>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68265>>>    Get ParseFolderName sFileName to sFolderName
68266>>>    If (sFolderName <> "") Begin
68268>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
68269>>>    End
68269>>>>
68269>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
68270>>>    Function_Return sFilename
68271>>>End_Function
68272>>>
68272>>>// Pre:  sFileName may contain the complete path of the file.
68272>>>//       or contain multiple dots in the filename, so temp.gif.bak will
68272>>>//       return "bak" as the extension and not "gif"
68272>>>// Post: returns the extension only, this extension can be a valid unixlike extension
68272>>>//       such as "html" or "java"
68272>>>Function ParseFileExtension Global String sFileName Returns String
68274>>>    String  sFileExtension
68274>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
68275>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
68276>>>    Function_Return sFileExtension
68277>>>End_Function
68278>>>
68278>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
68278>>>
68278>>>Function DDE_Error_To_String Integer iErrorID Returns String
68280>>>    String sMessage
68280>>>    Case Begin
68280>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
68282>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
68283>>>            Case Break
68284>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
68287>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
68288>>>            Case Break
68289>>>        Case (iErrorID = vERROR_BAD_FORMAT)
68292>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
68293>>>            Case Break
68294>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
68297>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
68298>>>            Case Break
68299>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
68302>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
68303>>>            Case Break
68304>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
68307>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
68308>>>            Case Break
68309>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
68312>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
68313>>>            Case Break
68314>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
68317>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
68318>>>            Case Break
68319>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
68322>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
68323>>>            Case Break
68324>>>        Case (iErrorID = vSE_ERR_NOASSOC)
68327>>>            Move CS_DDE_ERR_NOASSOC to sMessage
68328>>>            Case Break
68329>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
68332>>>            Move CS_DDE_ERR_OOM to sMessage
68333>>>            Case Break
68334>>>        Case (iErrorID = vSE_ERR_PNF)
68337>>>            Move CS_DDE_ERR_PNF to sMessage
68338>>>            Case Break
68339>>>        Case (iErrorID = vSE_ERR_SHARE)
68342>>>            Move CS_DDE_ERR_SHARE to sMessage
68343>>>            Case Break
68344>>>        Case Else
68344>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
68345>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
68346>>>            Case Break
68347>>>    Case End
68347>>>    Function_Return sMessage
68348>>>End_Function
68349>>>
68349>>>Procedure vDDE_Error_Handler Integer iErrorID
68351>>>    String sMessage
68351>>>    Get DDE_Error_To_String iErrorID to sMessage
68352>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
68353>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
68354>>>End_Procedure
68355>>>
68355>>>// Does the directory exist? - No = false, Yes = True
68355>>>// This also works with UNC path encoding and wildcards
68355>>>Function vFolderExists Global String sFolderName Returns Boolean
68357>>>    Boolean bFolderExists
68357>>>    Boolean bStop
68357>>>    String  sFolder sTmp
68357>>>    Integer iCh
68357>>>
68357>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
68357>>>    Move (ToANSI(Trim(sFolderName))) to sFolderName
68358>>>    If (sFolderName = "") Begin
68360>>>        Function_Return False
68361>>>    End
68361>>>>
68361>>>
68361>>>    Move True  to bFolderExists
68362>>>    Move False to bStop
68363>>>    Move "dir:" to sFolder
68364>>>    Append sFolder sFolderName
68365>>>    Get Seq_New_Channel to iCh  // get free channel for input
68366>>>    Direct_Input channel iCh sFolder
68368>>>    Repeat
68368>>>>
68368>>>        Readln channel iCh sTmp
68370>>>        Move (SeqEof) to bStop
68371>>>        If (Trim(sTmp)="") Begin
68373>>>            Move False to bFolderExists
68374>>>        End
68374>>>>
68374>>>        Else Begin
68375>>>            Move True to bFolderExists
68376>>>            Move True to bStop
68377>>>        End
68377>>>>
68377>>>    Until (bStop)
68379>>>    Close_Input channel iCh
68381>>>    Send Seq_Release_Channel iCh
68382>>>    Function_Return bFolderExists
68383>>>End_Function
68384>>>
68384>>>// returns folder name if a folder was selected, otherwise returns ""
68384>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
68386>>>    String sFolder sTitle sPath
68386>>>    Pointer lpItemIdList
68386>>>    Integer iFolderSelected iRetval
68386>>>    tvBrowseInfo BrowseInfo
68386>>>    tvBrowseInfo BrowseInfo
68386>>>
68386>>>    Move "" to sPath
68387>>>    If (sDialogTitle<>"") Begin
68389>>>        Move sDialogTitle to sTitle
68390>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
68390>>>        // disables showing some commonly used ascii characters like ascii 137 ()
68390>>>        // These chars are correctly shown if no toansi is used.
68390>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
68390>>>        // selected it will always be valid.
68390>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
68391>>>    End
68391>>>>
68391>>>
68391>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
68392>>>
68392>>>    // Torben Lund added line below. Move handle of focus object to structure before
68392>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
68392>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
68393>>>
68393>>>    // null 128 chars into var (make space)
68393>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68394>>>
68394>>>    // select folder
68394>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
68395>>>    // get selected folder name
68395>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
68396>>>
68396>>>    // release memory resources that are used by the ItemIdList
68396>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
68397>>>
68397>>>    If (iFolderSelected<>0) Begin
68399>>>        Move (CString(sFolder)) to sPath
68400>>>    End
68400>>>>
68400>>>    Function_Return  sPath
68401>>>End_Function
68402>>>
68402>>>// returns 0 if the folder is created.
68402>>>//         1 if the API-call returned an error.
68402>>>Function vCreateDirectory Global String sNewFolder Returns Integer
68404>>>    String  sFolder
68404>>>    Integer iRetval bFolderCreated
68404>>>    tvSecurity_attributes SA
68404>>>    tvSecurity_attributes SA
68404>>>
68404>>>    Move False to bFolderCreated
68405>>>
68405>>>    // null MAX_PATH chars into var (make space)
68405>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68406>>>
68406>>>    If (sNewFolder <> "") Begin
68408>>>
68408>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
68409>>>        Move  0  to SA.lpDescriptor
68410>>>        Move  1  to SA.bInheritHandle
68411>>>
68411>>>        //
68411>>>        Move (sNewFolder+"") to sFolder
68412>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
68413>>>    End
68413>>>>
68413>>>
68413>>>    If (bFolderCreated=false) Begin
68415>>>        Move 1 to iRetVal
68416>>>    End
68416>>>>
68416>>>    Function_Return iRetVal
68417>>>End_Function
68418>>>
68418>>>// **WvA: 03-02-2002 Function created.
68418>>>// With this function one can remove a directory.
68418>>>// returns 0 if the folder is removed.
68418>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
68418>>>//         2 if the folder did not exist
68418>>>//         3 if the sFolder parameter passed is equal to ""
68418>>>Function vRemoveDirectory Global String sFolder Returns Integer
68420>>>    Boolean bRemoved
68420>>>    String  sPath
68420>>>    Integer iRetval
68420>>>
68420>>>    Move 0     to iRetVal
68421>>>    Move False to bRemoved
68422>>>    Move (Trim(sFolder)) to sFolder
68423>>>    If (sFolder="") Begin
68425>>>        Move 3 to iRetVal
68426>>>    End
68426>>>>
68426>>>    If (vFolderExists(sFolder)=False) Begin
68428>>>        Move 2 to iRetVal
68429>>>    End
68429>>>>
68429>>>    If (iRetVal=0) Begin
68431>>>    // null MAX_PATH chars into var (make space)
68431>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
68432>>>        //
68432>>>        Move (Insert(sFolder,sPath,1)) to sPath
68433>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
68434>>>    End
68434>>>>
68434>>>
68434>>>    If (iRetVal=0 And bRemoved=False) Begin
68436>>>        Move 1 to iRetVal
68437>>>    End
68437>>>>
68437>>>    Function_Return iRetVal
68438>>>End_Function
68439>>>
68439>>>// This function informs the user that he entered a yet unknown folder and
68439>>>// asks if he/she wants to create the folder (Yes/No)
68439>>>// Choice: "Yes" - this creates the folder
68439>>>//                 if successful, the function returns false
68439>>>//                 else it will be true.
68439>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
68439>>>//                 For example: to stop a save
68439>>>// Precondition: A foldername must be entered. We do not check for empty paths
68439>>>// This function returns a non-zero value if the folder isn't created afterwards
68439>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
68441>>>    Integer bIsNotValid
68441>>>    Integer iUsers_Choice
68441>>>    String  sMessage
68441>>>
68441>>>    If (vFolderExists(sFolderName) Eq 0) Begin
68443>>>        Move "The folder '" to sMessage
68444>>>        Append sMessage sFolderName
68445>>>        Append sMessage "' does not yet exist,\n"
68446>>>        Append sMessage "Do you want to create it now?"
68447>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
68448>>>        Case Begin
68448>>>            Case (iUsers_Choice = MBR_Yes)
68450>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
68451>>>                If bIsNotValid Begin
68453>>>                    Move "An error occurred while trying to create folder '" to sMessage
68454>>>                    Append sMessage sFolderName "'.\n\n"
68456>>>                    Send Info_Box sMessage "Info"
68457>>>                End
68457>>>>
68457>>>                Case Break
68458>>>            Case (iUsers_Choice = MBR_No)
68461>>>                Move dfTrue to bIsNotValid // Cancel the save
68462>>>                Case Break
68463>>>        Case End
68463>>>    End
68463>>>>
68463>>>    Function_Return bIsNotValid
68464>>>End_Function
68465>>>
68465>>>// This will perform an operation on a file (e.g. open) with the application
68465>>>// registered in the Windows Registry to open that type of file (via its extension)
68465>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
68465>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
68467>>>    Handle  hInstance hWnd
68467>>>    // remove any leading/trailing spaces in the string
68467>>>    Move (Trim(sDocument)) to sDocument
68468>>>    Move (Trim(sPath))     to sPath
68469>>>    // Make the strings readable for windows API, by converting them to null-terminated
68469>>>    Append sOperation   (Character(0))
68470>>>    Append sDocument    (Character(0))
68471>>>    Append sParameters  (Character(0))
68472>>>    Append sPath        (Character(0))
68473>>>
68473>>>    Get Window_Handle to hWnd
68474>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
68475>>>    If (hInstance <= 32) Begin
68477>>>        Send vDDE_Error_Handler hInstance
68478>>>    End
68478>>>>
68478>>>End_Procedure
68479>>>
68479>>>Class cShellFileOperations is a Array
68480>>>
68480>>>    Procedure Construct_Object
68482>>>        Forward Send Construct_Object
68484>>>        Property Integer piDeleteFlags        0
68485>>>        Property Integer piCopyFlags          0
68486>>>        Property Integer piMoveFlags          0
68487>>>        Property Integer piRenameFlags        0
68488>>>
68488>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
68489>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
68490>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
68491>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
68492>>>    End_Procedure
68493>>>
68493>>>    // This function uses the shell API to perform a file operation on the
68493>>>    // files supplied.
68493>>>    //
68493>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
68495>>>        Integer  iRetVal
68495>>>        Integer  iUserAbort
68495>>>        tvShFileOpStruct FOS
68495>>>        tvShFileOpStruct FOS
68495>>>
68495>>>        Move (ToAnsi(sSource)+Character(0)+Character(0))      to sSource
68496>>>        Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
68497>>>
68497>>>        If (eOperation <> vFO_DELETE) Begin
68499>>>            Move (AddressOf(sDestination)) to FOS.pTo
68500>>>        End
68500>>>>
68500>>>
68500>>>        Move eOperation           to FOS.wFunc
68501>>>        Move (AddressOf(sSource)) to FOS.pFrom
68502>>>        Move iFlags               to FOS.fFlags
68503>>>
68503>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
68504>>>        Move FOS.fAnyOperationsAborted to iUserAbort
68505>>>        If (iUserAbort <> 0) Begin
68507>>>            Move 80 to iRetVal  // file Operation Aborted by USER
68508>>>        End
68508>>>>
68508>>>        Function_Return (iRetVal)
68509>>>    End_Function
68510>>>
68510>>>    Function sfoDeleteFile String sFileName Returns Integer
68512>>>        Integer  iRetVal
68512>>>        Integer  iFlags
68512>>>
68512>>>        Get piDeleteFlags to iFlags
68513>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
68514>>>        Function_Return iRetVal
68515>>>    End_Function
68516>>>
68516>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
68518>>>        Integer  iRetVal
68518>>>        Integer  iFlags
68518>>>
68518>>>        Get piCopyFlags to iFlags
68519>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
68520>>>        Function_Return iRetVal
68521>>>    End_Function
68522>>>
68522>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
68524>>>        Integer  iRetVal
68524>>>        Integer  iFlags
68524>>>
68524>>>        Get piMoveFlags to iFlags
68525>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
68526>>>        Function_Return iRetVal
68527>>>    End_Function
68528>>>
68528>>>    // Rename a file or folder
68528>>>    // Returns a nonzero value if the operation failed.
68528>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
68530>>>        Integer  iRetVal
68530>>>        Integer  iFlags
68530>>>
68530>>>        Get piRenameFlags to iFlags
68531>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
68532>>>        Function_Return iRetVal
68533>>>    End_Function
68534>>>
68534>>>    // Courtesy Of Steve Walter
68534>>>    // Requires Windows 2000 and up according to msdn but it was
68534>>>    //  in fact available before that as an unpublished API call
68534>>>    //  a little google search shows that this was already available
68534>>>    //  in windows 95 and NT
68534>>>    //
68534>>>    // The format is controlled by the dialog interface.
68534>>>    // That is, the user must click the OK button To actually Begin the format
68534>>>    // the format cannot be started programmatically.
68534>>>    // An alternative to this functionality would be to use a controlpanel
68534>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
68534>>>    //
68534>>>    // hWnd = The windows handle of the object from which the format Function
68534>>>    //        is called.
68534>>>    // To Get this,
68534>>>    //          use:  Get Window_Handle Of <object>
68534>>>    //          For instance, in this app, we're going to use the Report_Panel:
68534>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
68534>>>    //
68534>>>    // sDrive = The drive letter. At this moment only A and B are valid
68534>>>    //
68534>>>    // iOptions = Format options.
68534>>>    //  SHFMT_OPT_DEFAULT = Quick format
68534>>>    //  SHFMT_OPT_FULL    = Full Format
68534>>>    //  SHFMT_OPT_SYSONLY = System only
68534>>>    //  3                 = Full format with system. (unsupported)
68534>>>    //
68534>>>    // Return Values:
68534>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
68534>>>    //  SHFMT_CANCEL   = Format cancelled by user.
68534>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
68534>>>    //
68534>>>    //
68534>>>    // *** ATTENTION: This function has been disabled as it doesn't
68534>>>    //                seem to work, i must have made a silly mistake
68534>>>    //                somewhere.
68534>>>    //
68534>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
68536>>>        Handle   hWnd
68536>>>        Integer  iObj
68536>>>        DWord    dwReturnVal
68536>>>        Integer iDrive
68536>>>
68536>>>        Function_Return 1 // STOP HERE
68537>>>
68537>>>        Move (Trim(sDrive)) to sDrive
68538>>>        If ( sDrive <> '' ) Begin
68540>>>            If ( sDrive Contains ':' ) Begin
68542>>>                Move (Replace(':',sDrive,'')) to sDrive
68543>>>            End
68543>>>>
68543>>>            If (Not( 'AB' Contains sDrive )) Begin
68545>>>                Function_Return (SHFMT_NOFORMAT)
68546>>>            End
68546>>>>
68546>>>            If ( sDrive = 'A' ) Begin
68548>>>                Move 0 to iDrive
68549>>>            End
68549>>>>
68549>>>            Else If ( sDrive = 'B' ) Begin
68552>>>                Move 1 to iDrive
68553>>>            End
68553>>>>
68553>>>            // Window_Handle Of Desktop equals to 0
68553>>>
68553>>>            Get focus of desktop to iObj
68554>>>            If (iObj>desktop) Begin
68556>>>                Get Container_Handle of iObj to hWnd
68557>>>            End
68557>>>>
68557>>>            While (hWnd=0 And iObj<>Desktop)
68561>>>                Get Parent of iObj to iObj
68562>>>                Get Container_Handle of iObj to hWnd
68563>>>            Loop
68564>>>>
68564>>>
68564>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
68564>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
68565>>>        End
68565>>>>
68565>>>        Else Begin
68566>>>            Move (SHFMT_ERROR) to dwReturnVal
68567>>>        End
68567>>>>
68567>>>        Function_Return dwReturnVal
68568>>>    End_Function
68569>>>
68569>>>    //Example:
68569>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
68569>>>    //                                          mode.
68569>>>
68569>>>End_Class
68570>>>
68570>>>Object oShellFileOperations is a cShellFileOperations
68572>>>End_Object
68573>>>
68573>>>// Restore to the old way of working with the shell file operations.
68573>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
68573>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
68573>>>Procedure vWin32fhCompatibilityMode
68575>>>    Integer hoSFO
68575>>>    Integer iFlags
68575>>>
68575>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
68576>>>    Move (oShellFileOperations(Self)) to hoSFO
68577>>>
68577>>>    Set piDeleteFlags of hoSFO to iFlags
68578>>>    Set piCopyFlags   of hoSFO to iFlags
68579>>>    Set piMoveFlags   of hoSFO to iFlags
68580>>>    Set piRenameFlags of hoSFO to iFlags
68581>>>End_Procedure
68582>>>
68582>>>// Delete a file or folder
68582>>>// Returns a nonzero value if the operation failed.
68582>>>Function vDeleteFile Global String sFileName Returns Integer
68584>>>    Integer  iRetVal
68584>>>
68584>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
68585>>>    Function_Return iRetVal
68586>>>End_Function
68587>>>
68587>>>// Copy a file or folder
68587>>>// Returns a nonzero value if the operation failed.
68587>>>Function vCopyFile Global String sSource String sDestination Returns Integer
68589>>>    Integer  iRetVal
68589>>>
68589>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68590>>>    Function_Return iRetVal
68591>>>End_Function
68592>>>
68592>>>// Move a file or folder
68592>>>// Returns a nonzero value if the operation failed.
68592>>>Function vMoveFile Global String sSource String sDestination Returns Integer
68594>>>    Integer  iRetVal
68594>>>
68594>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68595>>>    Function_Return iRetVal
68596>>>End_Function
68597>>>
68597>>>// Rename a file or folder
68597>>>// Returns a nonzero value if the operation failed.
68597>>>Function vRenameFile Global String sSource String sDestination Returns Integer
68599>>>    Integer  iRetVal
68599>>>
68599>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68600>>>    Function_Return iRetVal
68601>>>End_Function
68602>>>
68602>>>Function vGetWindowsDirectory Returns String
68604>>>    String  sDirectory
68604>>>    Integer iVoid
68604>>>
68604>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
68605>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
68606>>>    Function_Return (CString(sDirectory))
68607>>>End_Function
68608>>>
68608>>>Function vGetTempPath Returns String
68610>>>    Integer iRetval
68610>>>    String  sTempPath
68610>>>
68610>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
68611>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
68612>>>    Function_Return (Cstring(sTempPath))
68613>>>End_Function
68614>>>
68614>>>// Courtesy of Marco Kuipers
68614>>>Function vMakeTempFile Returns String
68616>>>    Integer iRetval
68616>>>    String  sTempPath
68616>>>    String  sTempFileName
68616>>>    String  sPrefixString
68616>>>
68616>>>    Get vGetTempPath to sTempPath
68617>>>    If (sTempPath = "") Begin
68619>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
68620>>>        If (sTempPath<>"") Begin
68622>>>            Move (sTempPath+"\Temp\") to sTempPath
68623>>>        End
68623>>>>
68623>>>    End
68623>>>>
68623>>>
68623>>>    If (sTempPath = "") Begin
68625>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
68625>>>    // makes little sense. Leaving this in as it was old behavior.
68625>>>        Get_Current_Directory to sTempPath
68626>>>    End
68626>>>>
68626>>>
68626>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
68627>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
68629>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
68630>>>>
68630>>>    End
68630>>>>
68630>>>
68630>>>    Move (ZeroString(vMax_Path)) to sTempFileName
68631>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
68632>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
68633>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
68635>>>    //Get ShowLastError to iRetval
68635>>>        Move "" to sTempFileName
68636>>>    End
68636>>>>
68636>>>
68636>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
68637>>>End_Function
68638>>>
68638>>>// This function creates a uniquely named temporary file in folder sPath
68638>>>// The file created will have a prefix based on the first 3 characters in sPrefix
68638>>>// Note that you will have to cleanup the tempfile yourself as the function
68638>>>// does not take care of that.
68638>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
68640>>>    Integer iRetVal
68640>>>    String sTempFileName
68640>>>
68640>>>    Move (ToAnsi(sPath)+Character(0))   to sPath
68641>>>    Move (ToAnsi(sPrefix)+Character(0)) to sPrefix
68642>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
68643>>>
68643>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
68644>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
68645>>>    Function_Return sTempFileName
68646>>>End_Function
68647>>>
68647>>>//
68647>>>// Get a specific shell folder for example to get the desktop folder
68647>>>// simply call this function and pass it vCSIDL_DESKTOP
68647>>>//
68647>>>Function vSHGetFolderPath Integer eFolder Returns String
68649>>>    String  sFolder
68649>>>    Integer iVoid
68649>>>    Handle  hWnd
68649>>>
68649>>>    Move (Window_Handle(focus(desktop))) to hWnd
68650>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68651>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
68652>>>    Function_Return (CString(sFolder))
68653>>>End_Function
68654>>>
68654>>>// Courtesy Of Vincent Oorsprong
68654>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
68656>>>    String  sFormattedTime sFormattedDate
68656>>>    String  sFileDateTime
68656>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
68656>>>    tvFileTime   FileTime
68656>>>    tvFileTime   FileTime
68656>>>    tvSystemTime SystemTime
68656>>>    tvSystemTime SystemTime
68656>>>
68656>>>    Move "" to sFileDateTime
68657>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
68658>>>    Move dwHighDateTime to FileTime.dwHighDateTime
68659>>>
68659>>>    Move 0 to SystemTime.wYear
68660>>>
68660>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
68661>>>    If (iSuccess = 1) Begin
68663>>>        Move (ZeroString(255))        to sFormattedTime
68664>>>        Move (Length(sFormattedTime)) to iLenCcTime
68665>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
68666>>>        Move (ZeroString(255))        to sFormattedDate
68667>>>        Move (Length(sFormattedDate)) to iLenCcDate
68668>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
68669>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
68670>>>    End
68670>>>>
68670>>>    Function_Return sFileDateTime
68671>>>End_Function
68672>>>
68672>>>// **WvA:
68672>>>// A windows replacement for the standard function FileExists.
68672>>>// This version will also return (true) for a file when it is open by an application.
68672>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
68672>>>// Example: Get vFilePathExists "C:\config.sy?"
68672>>>// This will return true if you have a file matching these conditions. (aka config.sys)
68672>>>Function vFilePathExists Global String sFilePathMask Returns Integer
68674>>>    String  sDirSep
68674>>>    Handle  hFindFile
68674>>>    Integer iVoid
68674>>>    tvWin32FindData FindData
68674>>>    tvWin32FindData FindData
68674>>>
68674>>>    Move vINVALID_HANDLE_VALUE to hFindFile
68675>>>    Move (ToANSI(Trim(sFilePathMask))) to sFilePathMask
68676>>>
68676>>>    If (Length(sFilePathMask)>0) Begin
68678>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
68678>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68679>>>        While (Right(sFilePathMask, 1) = sDirSep)
68683>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
68684>>>        Loop
68685>>>>
68685>>>
68685>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68686>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
68687>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
68688>>>    End
68688>>>>
68688>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
68689>>>End_Function
68690>>>
68690>>>//
68690>>>// WideChar version of the function, do not use, it's an experiment
68690>>>//
68690>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
68692>>>    Handle  hFindFile
68692>>>    Integer iVoid
68692>>>    tvWin32FindData FindData
68692>>>    tvWin32FindData FindData
68692>>>
68692>>>    Move vINVALID_HANDLE_VALUE to hFindFile
68693>>>
68693>>>    If (Length(sFilePathMask)>0) Begin
68695>>>
68695>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68696>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
68697>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
68698>>>    End
68698>>>>
68698>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
68699>>>End_Function
68700>>>
68700>>>// **WvA
68700>>>// Formats a foldername by first trimming it and after that by sticking a
68700>>>// directory separator (/\) to the end if it doesn't have one there already.
68700>>>// The folder may contain a drive letter or UNC encoding.
68700>>>Function vFolderFormat Global String sFolderName Returns String
68702>>>    String sDirSep
68702>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
68703>>>    Move (Trim(sFolderName)) to sFolderName
68704>>>    If (Right(sFolderName,1)<>sDirSep) Begin
68706>>>        Move (sFolderName+sDirSep) to sFolderName
68707>>>    End
68707>>>>
68707>>>    Function_Return sFolderName
68708>>>End_Function
68709>>>
68709>>>//
68709>>>// Returns the amount of files in the folder (if it exists)
68709>>>// Returns -1 if folder doesn't exist.
68709>>>// The files "." and ".." are not counted.
68709>>>//
68709>>>Function vFolderFileCount Global String sFolderName Returns Integer
68711>>>    Boolean bFound
68711>>>    Handle  hFindFile
68711>>>    Integer iCount  iVoid
68711>>>    Integer iSuccess
68711>>>    String  sFileName
68711>>>    tvWin32FindData FindData
68711>>>    tvWin32FindData FindData
68711>>>
68711>>>    Move -1 to iCount
68712>>>    Get vFolderFormat sFolderName to sFolderName
68713>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
68714>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68715>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
68716>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
68717>>>    If (bFound) Begin
68719>>>        Move 0 to iCount
68720>>>    End
68720>>>>
68720>>>    While (bFound)
68724>>>        Increment iCount
68725>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
68726>>>        If (sFileName="." or sFileName="..") Begin
68728>>>            Decrement iCount
68729>>>        End
68729>>>>
68729>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
68730>>>        Move (iSuccess<>0) to bFound
68731>>>    Loop
68732>>>>
68732>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
68733>>>    Function_Return iCount
68734>>>End_Function
68735>>>
68735>>>//
68735>>>// Gets the parent path of the currently supplied path
68735>>>// Returns "" when we are at the root folder.
68735>>>//
68735>>>Function vParentPath Global String sPath Returns String
68737>>>    String sStrip sDirSep
68737>>>
68737>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68738>>>    Move (Trim(sPath)) to sPath
68739>>>    If (Right(sPath,1) = sDirSep) Begin
68741>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
68742>>>    End
68742>>>>
68742>>>    If (Pos(sDirSep, sPath)) Begin
68744>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
68745>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
68746>>>    End
68746>>>>
68746>>>    Else Begin
68747>>>        Move "" to sPath
68748>>>    End
68748>>>>
68748>>>    Function_Return sPath
68749>>>End_Function
68750>>>
68750>>>// Create the folder, including intermediate directories.
68750>>>// Don't panic if the folder already exists.
68750>>>// Michael Mullan June 2009.
68750>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
68752>>>    String  sFolder
68752>>>    Integer iRetval iFolderCreated
68752>>>    tvSecurity_attributes SA
68752>>>    tvSecurity_attributes SA
68752>>>
68752>>>    Move 0 to iFolderCreated
68753>>>
68753>>>    // null MAX_PATH chars into var (make space)
68753>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68754>>>    If (sNewFolder <> "") Begin
68756>>>
68756>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
68757>>>        Move  0  to SA.lpDescriptor
68758>>>        Move  1  to SA.bInheritHandle
68759>>>
68759>>>        //
68759>>>        Move (sNewFolder+"") to sFolder
68760>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
68761>>>    End
68761>>>>
68761>>>
68761>>>    If (iFolderCreated <> 0) Begin
68763>>>        Move 1 to iRetVal
68764>>>        Case Begin
68764>>>            Case (iFolderCreated = 161)
68766>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
68767>>>>
68767>>>                Case Break
68768>>>            Case (iFolderCreated = 206)
68771>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
68772>>>>
68772>>>                Case Break
68773>>>            Case (iFolderCreated = 3)
68776>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
68777>>>>
68777>>>                Case Break
68778>>>            Case (iFolderCreated = 80)
68781>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
68782>>>                Case Break
68783>>>            Case (iFolderCreated = 183)
68786>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
68787>>>                Case Break
68788>>>            Case (iFolderCreated = 1223)
68791>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
68792>>>>
68792>>>                Case Break
68793>>>            Case Else
68793>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
68794>>>>
68794>>>        Case End
68794>>>    End
68794>>>>
68794>>>    Function_Return iRetVal
68795>>>End_Function
68796>>>
68796>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
68798>>>    DWord   dwFileSizeHigh dwFileSizeLow
68798>>>    Integer iFileSize iVoid
68798>>>    Handle  hFindFile
68798>>>    tvWin32FindData FindData
68798>>>    tvWin32FindData FindData
68798>>>
68798>>>    Move (sFileName+"") to sFileName
68799>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68800>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
68801>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
68803>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
68804>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
68805>>>    End
68805>>>>
68805>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
68806>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
68807>>>
68807>>>    Function_Return iFileSize
68808>>>End_Function
68809>>>
68809>>>//
68809>>>// Based on code in Peter Crook's Browse folder workspace
68809>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
68809>>>//
68809>>>//=============================================================================
68809>>>// Verifies that a path is a valid directory.
68809>>>//
68809>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
68809>>>//
68809>>>// Parameters:
68809>>>//      sPath - Address of the path to verify.
68809>>>//=============================================================================
68809>>>Function vPathIsDirectory Global String sPath Returns Boolean
68811>>>    Integer iResult
68811>>>    Boolean bRetVal
68811>>>
68811>>>    Move false to bRetVal
68812>>>    Move (ToAnsi(sPath) - Character (0)) to sPath
68813>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
68814>>>    If (iResult<>0) Begin
68816>>>        Move True to bRetVal
68817>>>    End
68817>>>>
68817>>>
68817>>>    Function_Return bRetVal
68818>>>End_Function
68819>>>
68819>Use RefactorFunctionConstants.inc
Including file: RefactorFunctionConstants.inc    (C:\Projects\DF18\DfRefactor\AppSrc\RefactorFunctionConstants.inc)
68819>>>Use Windows.pkg
68819>>>Use DFClient.pkg
68819>>>Use cFilesystem.pkg
Including file: cFilesystem.pkg    (C:\Projects\DF18\DfRefactor\Libraries\cFileSystem\AppSrc\cFilesystem.pkg)
68819>>>>>//************************************************************************
68819>>>>>//*** FileSystem - Binary file operations For VDF15+.
68819>>>>>//************************************************************************
68819>>>>>//*** Based on original package: akefs.pkg
68819>>>>>//*** Version: 4.0
68819>>>>>//*** (C) NordTeam Gruppen, NOVAX A/S
68819>>>>>//***
68819>>>>>//*** Author......: Allan Kim Eriksen
68819>>>>>//*** Created.....: 23/08 2001
68819>>>>>//***
68819>>>>>//*** Rev History.: 31/08 2018 Nils Svedmyr. Added Functions from Akefs.pkg
68819>>>>>//***               to get/set file date/time and procedure SetFileLastWriteTime.
68819>>>>>//***               Refactored functions FileSize & FileDate to only have one Function_Return,
68819>>>>>//***               and changed a couple of While loops to end with a "loop" word instead of "End".
68819>>>>>//***
68819>>>>>//************************************************************************
68819>>>>>// cFilesystem class with functions and procedures to access binary files.
68819>>>>>// Filenumbers are not limited to 10 but only to system resources.
68819>>>>>// Also windows API calls For file copy, file move ect.
68819>>>>>// This class is For vdf 15 and up.
68819>>>>>// This class is not limited to 2 GB but can handle filesizes up $7FFFFFFFFFFFFFFF (9 exabyte)
68819>>>>>
68819>>>>>//************************************************************************
68819>>>>>// Be aware that argument_size has to be larger
68819>>>>>// than the requested amount of bytes read in the buffer for
68819>>>>>// BytesFromBinaryFile.
68819>>>>>//************************************************************************
68819>>>>>
68819>>>>>//************************************************************************
68819>>>>>// Constants used For the external functions.
68819>>>>>//************************************************************************
68819>>>>>// fsCreatefile.
68819>>>>>    Define GENERIC_READ for            |CI$80000000
68819>>>>>    Define GENERIC_WRITE for           |CI$40000000
68819>>>>>    Define GENERIC_RANDOM for          (GENERIC_READ + GENERIC_WRITE)
68819>>>>>    Define CREATE_NEW for              |CI$00000001
68819>>>>>    Define CREATE_ALWAYS for           |CI$00000002
68819>>>>>    Define OPEN_EXISTING for           |CI$00000003
68819>>>>>    Define OPEN_ALWAYS for             |CI$00000004
68819>>>>>    Define TRUNCATE_EXISTING for       |CI$00000005
68819>>>>>
68819>>>>>
68819>>>>>    Define FILE_SHARE_READ for         |CI$1
68819>>>>>    Define FILE_SHARE_WRITE for        |CI$2
68819>>>>>    Define FILE_SHARE_RANDOM for       (FILE_SHARE_READ + FILE_SHARE_WRITE)
68819>>>>>
68819>>>>>// Generel.
68819>>>>>Define FNULL For                   |CI$0
68819>>>>>
68819>>>>>// FormatString.
68819>>>>>
68819>>>>>// SetFilePosition.
68819>>>>>Define FILE_BEGIN For     0
68819>>>>>Define FILE_CURRENT For  1
68819>>>>>Define FILE_END For      2
68819>>>>>Define INVALID_SET_FILE_POINTER For |CI$FFFFFFFF
68819>>>>>
68819>>>>>// FindFile.
68819>>>>>
68819>>>>>Define ERROR_NO_MORE_FILES    For |CI18
68819>>>>>Define ERROR_MOD_NOT_FOUND    For |CI126
68819>>>>>
68819>>>>>
68819>>>>>
68819>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileFlags.
68819>>>>>
68819>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileOS.
68819>>>>>Define VOS_DOS          For |CI$10000
68819>>>>>Define VOS_NT           For |CI$40000
68819>>>>>Define VOS_WINDOWS16    For |CI$00001
68819>>>>>Define VOS_WINDOWS32    For |CI$00004
68819>>>>>Define VOS_OS216        For |CI$20000
68819>>>>>Define VOS_OS232        For |CI$30000
68819>>>>>Define VOS_PM16         For |CI$00002
68819>>>>>Define VOS_PM32         For |CI$00003
68819>>>>>Define VOS_UNKNOWN      For |CI$00000
68819>>>>>
68819>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileType.
68819>>>>>Define VFT_APP          For |CI$01
68819>>>>>Define VFT_DLL          For |CI$02
68819>>>>>Define VFT_DRV          For |CI$03
68819>>>>>Define VFT_FONT         For |CI$04
68819>>>>>Define VFT_STATIC_LIB   For |CI$07
68819>>>>>Define VFT_UNKNOWN      For |CI$00
68819>>>>>Define VFT_VXD          For |CI$05
68819>>>>>
68819>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_DRV.
68819>>>>>Define VFT2_DRV_COMM                For |CI$0A
68819>>>>>Define VFT2_DRV_DISPLAY             For |CI$04
68819>>>>>Define VFT2_DRV_INSTALLABLE         For |CI$08
68819>>>>>Define VFT2_DRV_KEYBOARD            For |CI$02
68819>>>>>Define VFT2_DRV_LANGUAGE            For |CI$03
68819>>>>>Define VFT2_DRV_MOUSE               For |CI$05
68819>>>>>Define VFT2_DRV_NETWORK             For |CI$06
68819>>>>>Define VFT2_DRV_PRINTER             For |CI$01
68819>>>>>Define VFT2_DRV_SOUND               For |CI$09
68819>>>>>Define VFT2_DRV_SYSTEM              For |CI$07
68819>>>>>Define VFT2_DRV_VERSIONED_PRINTER   For |CI$0C
68819>>>>>
68819>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_FONT.
68819>>>>>Define VFT2_FONT_RASTER             For |CI$01
68819>>>>>Define VFT2_FONT_TRUETYPE           For |CI$03
68819>>>>>Define VFT2_FONT_VECTOR             For |CI$02
68819>>>>>
68819>>>>>Define VFT2_UNKNOWN                 For |CI$00
68819>>>>>
68819>>>>>Define FS_FILEHANDLEMISSING For "The filehandle does not exists For the current filenumber."
68819>>>>>
68819>>>>>// Filesearch
68819>>>>>Enum_List
68819>>>>>    Define DIRMODE_FILES_ONLY For 1
68819>>>>>    Define DIRMODE_DIRECTORIES_ONLY
68819>>>>>    Define DIRMODE_FILES_AND_DIRECTORIES
68819>>>>>End_Enum_List
68819>>>>>
68819>>>>>//************************************************************************
68819>>>>>// Declarations of external functions.
68819>>>>>// Functions that needs variables For output are made global stings or
68819>>>>>// integers, and can be found on top of the declaration.
68819>>>>>//************************************************************************
68819>>>>>External_Function fsCreatefile "CreateFileA" kernel32.dll ;String sFile ;        //filenameDWord dwDesAccess ;   // access modeDWord dwShare ;       // share modePointer lpSecAtt ;    // SDDWord dwCrDisp ;      // how to createDWord dwFlags ;       // file attributesHandle hTempFile ;    // handle to template filReturns Integer       //Returns handle that can be used to access the object
68820>>>>>
68820>>>>>External_Function fsGetLastError "GetLastError" kernel32.dll Returns Integer
68821>>>>>
68821>>>>>External_Function fsFormatMessage "FormatMessageA" kernel32.dll ;DWord dwFlags ;         // source and processing optionsPointer lpSrc ;         // message sourceDWord dwMsgId ;         // message identifierDWord dwLngId ;         // language identifierPointer lpBuf ;         // message bufferDWord nSize ;           // maximum size of message bufferPointer Arg ;           // array of message insertsReturns Integer
68822>>>>>
68822>>>>>External_Function fsLocalFree "LocalFree" kernel32.dll ;Handle hMem ;   // A handle to the local memory object.Returns Integer
68823>>>>>
68823>>>>>External_Function fsCloseHandle "CloseHandle" kernel32.dll ;Handle hObject ;        // handle to objectReturns Integer
68824>>>>>
68824>>>>>External_Function fsReadFile "ReadFile" kernel32.dll ;Handle hFile ;          // handle to filePointer lpBuffer ;      // data bufferDWord nBytesToRead ;    // number of bytes to readPointer lpBytesRead ;   // number of bytes readPointer lpOverlapped ;  // overlapped bufferReturns Integer
68825>>>>>
68825>>>>>External_Function fsWriteFile "WriteFile" kernel32.dll ;Handle hFile ;              // handle to filePointer lpBuf ;             // data bufferDWord nNumBytesWrt ;        // number of bytes to writePointer lpNumBytesWritten ; // number of bytes writtenPointer lpOverlapped ;      // overlapped bufferReturns Integer
68826>>>>>
68826>>>>>External_Function fsGetFileSizeEx "GetFileSizeEx" kernel32.dll ;Handle hFile ;           // handle to filePointer lpFileSizeHigh ; // A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.Returns Integer
68827>>>>>
68827>>>>>External_Function fsSetFilePointer "SetFilePointer" kernel32.dll ;Handle hFile ;              // handle to fileUInteger lDistanceToMove ;    // The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.Pointer lpDistanceToMoveHigh ;  // A pointer to the high order 32-bits of the signed 64-bit distance to move.DWord dwMoveMethod ;        // The starting point For the file pointer move.Returns UInteger
68828>>>>>
68828>>>>>External_Function fsSetEndOfFile "SetEndOfFile" kernel32.dll ;Handle hFile ;              // handle to the file to have its EOF position moved.Returns Integer             // nonzero if success
68829>>>>>
68829>>>>>External_Function fsDeleteFile "DeleteFileA" Kernel32.Dll ;String  sFileName ;             // Pointer to a null-terminated string that specifies the file to be deleted.Returns Integer
68830>>>>>
68830>>>>>External_Function fsMoveFile "MoveFileA" Kernel32.Dll ;String  sExistingFileName ;     // Pointer to a null-terminated string that names an existing file or directory.String  sNewFileName ;          // Pointer to a null-terminated string that specifies the new name of a file or directory.Returns Integer                 // The new name must Not already exist. A new File may be on A different File system Or drive. A new directory must be on the same drive.
68831>>>>>
68831>>>>>External_Function fsCopyFile "CopyFileA" Kernel32.Dll ;String  sExistingFileName ;     // Pointer to a null-terminated string that specifies the name of an existing file.String  sNewFileName ;          // Pointer to a null-terminated string that specifies the name of the new file.Boolean bFailIfExists ;         // If bFailIfExists is TRUE and the new file specified by lpNewFileName already exists, the function fails.Returns Integer                 // If bFailIfExists is FALSE and the new file already exists, the function overwrites the existing file and succeeds.
68832>>>>>
68832>>>>>External_Function fsFindFirstFile "FindFirstFileA" Kernel32.Dll ;String  sFileName ;             // Pointer to a null-terminated string that specifies a valid directory or path and file name, which can contain wildcard characters (* and ?).Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
68833>>>>>
68833>>>>>External_Function fsFindNextFile "FindNextFileA" Kernel32.Dll ;Handle hFindFile ;              // handle returned by a previous call to the FindFirstFile function.Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
68834>>>>>
68834>>>>>External_Function fsFindClose "FindClose" Kernel32.dll ;Handle hFindFile ;              // File search handle. This handle must have been previously opened by the FindFirstFile function.Returns Integer
68835>>>>>
68835>>>>>External_Function fsGetFileTime "GetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with read accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
68836>>>>>
68836>>>>>External_Function fsSetFileTime "SetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with write accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
68837>>>>>
68837>>>>>External_function fsGetSystemTimeAsFileTime "GetSystemTimeAsFileTime" Kernel32.dll ;Pointer lpSystemTimeAsFileTime ;   // Pointer to a FILETIME structure containing the current system time in filetimme formatReturns Integer
68838>>>>>
68838>>>>>External_Function fsFileTimeToSystemTime "FileTimeToSystemTime" Kernel32.dll ;Pointer lpFiletime ;            // Pointer to a FILETIME structure containing the file time to convert to system date and time format.Pointer lpSystemtime ;          // Pointer to a SYSTEMTIME structure to receive the converted file time.Returns Integer
68839>>>>>
68839>>>>>External_Function fsSystemTimeToTzSpecificLocalTime "SystemTimeToTzSpecificLocalTime" Kernel32.dll ;Pointer lpTimeZone ;            // A pointer to a TIME_ZONE_INFORMATION structure that specifies the time zone of interest.Pointer lpUniversalTime ;       // A pointer to a SYSTEMTIME structure that specifies a time, in UTC.Pointer lpLocalTime ;           // A pointer to a SYSTEMTIME structure that receives the local time.Returns Integer
68840>>>>>
68840>>>>>External_Function fsGetTempFileName "GetTempFileNameA" kernel32.dll ;String  sPathname ;String  sPrefixString ;Integer iUnique ;Pointer sTempFileName ;Returns Integer
68841>>>>>
68841>>>>>External_Function fsGetTempPath "GetTempPathA" Kernel32.Dll ;Integer nBufferLength ;Pointer lpBuffer ;Returns Integer
68842>>>>>
68842>>>>>External_Function fsCreateDirectory "CreateDirectoryA" Kernel32.dll ;String  sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be created.Pointer lpSecAttributes ;       // Pointer to a SECURITY_ATTRIBUTES structure.Returns Integer
68843>>>>>
68843>>>>>External_Function fsRemoveDirectory "RemoveDirectoryA" Kernel32.dll ;String  sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be removed.Returns Integer
68844>>>>>
68844>>>>>External_Function fsExtractAssociatedIcon "ExtractAssociatedIconA" shell32.dll ;Handle hInst ;Pointer lpIconPath ;Integer lpiIcon ;Returns Handle
68845>>>>>
68845>>>>>External_Function fsDestroyIcon "DestroyIcon" User32.dll ;Handle hIcon ;Returns Integer
68846>>>>>
68846>>>>>External_Function fsGetFileVersionInfoSize "GetFileVersionInfoSizeA" Version.dll ;String  sFilename ;             // The name of the file of interest. The function uses the search sequence specified by the LoadLibrary function.Pointer lpHandle ;              // A pointer to a variable that the function sets to zero.Returns UInteger
68847>>>>>
68847>>>>>External_Function fsGetFileVersionInfo "GetFileVersionInfoA" Version.dll ;String  sFilename ;             // The name of the file. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.DWord   dwHandle ;              // This parameter is ignored.DWord   dwLen ;                 // The size, in bytes, of the buffer pointed to by the lpData parameter.Pointer lpData ;                // Pointer to a buffer that receives the file-version information.Returns Boolean
68848>>>>>
68848>>>>>External_Function fsVerQueryValue "VerQueryValueA" Version.dll ;Pointer lpBlock ;               // The version-information resource returned by the GetFileVersionInfo function.String  sSubBlock ;             // The version-information value to be retrieved.Pointer lplpBuffer ;            // When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by lpBlock.Pointer lpLen ;                 // When this method returns, contains a pointer to the size of the requested data pointed to by lpBuffer.Returns Boolean
68849>>>>>
68849>>>>>//************************************************************************
68849>>>>>// Structures
68849>>>>>//************************************************************************
68849>>>>>
68849>>>>>// Nils 2018-08-30 Added For the SourceCodeTools project
68849>>>>>// so we don't need to use both Akefs.pkg and this package.
68849>>>>>// A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
68849>>>>>Struct tFileTime
68849>>>>>    DWord dwLowDateTime    // Low-order part of the file time.
68849>>>>>    DWord dwHighDateTime   // High-order part of the file time.
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct structWFD  // Used by FindFirstFile
68849>>>>>    DWord    dwFileAttributes
68849>>>>>    UBigInt  ftCreationDateTime
68849>>>>>    UBigInt  ftLastAccessDateTime
68849>>>>>    UBigInt  ftLastWriteDateTime
68849>>>>>    UInteger nFileSizeHigh
68849>>>>>    UInteger nFileSizeLow
68849>>>>>    DWord    dares
68849>>>>>    DWord    dbres
68849>>>>>    UChar[MAX_PATH] cFileName
68849>>>>>    UChar[14]       cAlternateFileName
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct structSystemTime
68849>>>>>    UShort wYear
68849>>>>>    UShort wMonth
68849>>>>>    UShort wDayOfWeek
68849>>>>>    UShort wDay
68849>>>>>    UShort wHour
68849>>>>>    UShort wMinute
68849>>>>>    UShort wSecond
68849>>>>>    UShort wMillieseconds
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct structFile
68849>>>>>    Handle hFilehandle
68849>>>>>    String sFilename    // Assigned filename in OEM format.
68849>>>>>    Boolean bEndOfFile  // True then the end of the binary file had been read.
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct structFileBufferPointer
68849>>>>>    Integer iBufferPointer
68849>>>>>    Integer iBufferSize
68849>>>>>    BigInt biFromFilePosition
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct tsSearchResult
68849>>>>>    String sFilename
68849>>>>>    String sAlternateFileName   // 8.3 format
68849>>>>>    DateTime dtCreationDateTime
68849>>>>>    DateTime dtLastAccessDateTime
68849>>>>>    DateTime dtLastWriteDateTime
68849>>>>>    BigInt biFileSize
68849>>>>>    Integer iFileAttributes
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct tsVS_FIXEDFILEINFO
68849>>>>>    DWord dwSignature
68849>>>>>    DWord dwStrucVersion
68849>>>>>    DWord dwFileVersionMS
68849>>>>>    DWord dwFileVersionLS
68849>>>>>    DWord dwProductVersionMS
68849>>>>>    DWord dwProductVersionLS
68849>>>>>    DWord dwFileFlagsMask
68849>>>>>    DWord dwFileFlags
68849>>>>>    DWord dwFileOS
68849>>>>>    DWord dwFileType
68849>>>>>    DWord dwFileSubtype
68849>>>>>    //    DWord dwFileDateMS
68849>>>>>    //    DWord dwFileDateLS
68849>>>>>    UBigInt ubiFileDate
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct tsFileVersionInfo
68849>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
68849>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
68849>>>>>    Short[] siFileVersion
68849>>>>>    Short[] siProductVersion
68849>>>>>    DateTime dtCreationDateTime
68849>>>>>    String sComments
68849>>>>>    String sCompanyName
68849>>>>>    String sFileDescription
68849>>>>>    String sFileVersion
68849>>>>>    String sInternalName
68849>>>>>    String sLegalCopyright
68849>>>>>    String sLegalTrademarks
68849>>>>>    String sOriginalFilename
68849>>>>>    String sProductName
68849>>>>>    String sProductVersion
68849>>>>>    String sPrivateBuild
68849>>>>>    String sSpecialBuild
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Struct tsLandAndCodePage
68849>>>>>    UShort wLanguage
68849>>>>>    UShort wCodePage
68849>>>>>End_Struct
68849>>>>>
68849>>>>>Register_Function FileErrorText Integer iFilenumber Returns String
68849>>>>>
68849>>>>>//************************************************************************
68849>>>>>// The filesystem class
68849>>>>>//************************************************************************
68849>>>>>Class cFilesystem is a cObject
68850>>>>>
68850>>>>>    Procedure Construct_Object
68852>>>>>        Forward Send Construct_Object
68854>>>>>
68854>>>>>        // True then the end of the binary file had been read - not when $1A (EOF) is met.
68854>>>>>        // Legacy property. Use the BinaryFileEndOfFile function instead.
68854>>>>>        Property Boolean pbEOF False
68855>>>>>
68855>>>>>        // True if any error has occured during fileoprerations.
68855>>>>>        Property Boolean pbError False
68856>>>>>
68856>>>>>        // If errormessages should be called with dataflex error command set this to true
68856>>>>>        Property Boolean pbErrorAsVDFError False
68857>>>>>
68857>>>>>        // Keeps assigned handles and filenames For each filenumber.
68857>>>>>        // private
68857>>>>>        Property structFile[] plsFile
68858>>>>>
68858>>>>>        // Keeps read cached buffers For each filenumer. Used For BinaryReadChcheu
68858>>>>>        // private
68858>>>>>        Property String[] psaCachedBuffer
68859>>>>>
68859>>>>>        // Pointers For cached buffers.
68859>>>>>        // private
68859>>>>>        Property structFileBufferPointer[] plsCachedPointer
68860>>>>>    End_Procedure
68861>>>>>
68861>>>>>    // Returns the next available filenumber For a binary file.
68861>>>>>    Function BinaryFileNextFilenumber Returns Integer
68863>>>>>        structFile[] lsFile
68863>>>>>        structFile[] lsFile
68864>>>>>        Integer iMaxFiles iCurrentFile iNextFileNumber
68864>>>>>        Get plsFile to lsFile
68865>>>>>        Move (SizeOfArray(lsFile)) to iMaxFiles
68866>>>>>        Move -1 to iNextFileNumber
68867>>>>>        Move 0 to iCurrentFile
68868>>>>>        While (iCurrentFile < iMaxFiles and iNextFileNumber = -1)
68872>>>>>            If (lsFile[iCurrentFile].hFilehandle = 0) Begin
68874>>>>>                Move iCurrentFile to iNextFileNumber
68875>>>>>            End
68875>>>>>>
68875>>>>>            Else Begin
68876>>>>>                Increment iCurrentFile
68877>>>>>            End
68877>>>>>>
68877>>>>>        Loop
68878>>>>>>
68878>>>>>        If (iNextFileNumber = -1) Begin
68880>>>>>            Move iMaxFiles to iNextFileNumber
68881>>>>>        End
68881>>>>>>
68881>>>>>        Function_Return iNextFileNumber
68882>>>>>    End_Function
68883>>>>>
68883>>>>>    // Opens a binary file.
68883>>>>>    // If bShared is false or not pharsed the file is opened in exclusive.
68883>>>>>    // If bShared is True the file is opened with both read and write shared mode
68883>>>>>    // If bCreate is True the file is created if it does not exist already.
68883>>>>>    // If bReadOnly is True the file is opened with only read access (and only read shared mode if bShared is also true).
68883>>>>>    // Returns true if the file was opened or created without error.
68883>>>>>    Function BinaryFileOpen Integer iFilenumber String sFilename Boolean bShared Boolean bCreate Boolean bReadOnly Returns Boolean
68885>>>>>        Integer iReturnValue iErrornumber
68885>>>>>        DWord dwSharedMode dwCreateMode dwAccessMode
68885>>>>>        structFile[] lsFile
68885>>>>>        structFile[] lsFile
68886>>>>>        String sFilenameANSI
68886>>>>>        Boolean bOk bFilehandleOK
68886>>>>>        Get plsFile to lsFile
68887>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
68889>>>>>            If (lsFile[iFilenumber].hFilehandle = 0) Begin
68891>>>>>                Move True to bFilehandleOK
68892>>>>>            End
68892>>>>>>
68892>>>>>        End
68892>>>>>>
68892>>>>>        Else Begin
68893>>>>>            Move True to bFilehandleOK
68894>>>>>        End
68894>>>>>>
68894>>>>>        If bFilehandleOK Begin
68896>>>>>            Move sFilename to lsFile[iFilenumber].sFilename
68897>>>>>            Move (ToAnsi(sFilename)) To sFilenameANSI
68898>>>>>            Set pbError to False
68899>>>>>            Move False to bOk
68900>>>>>            Move GENERIC_RANDOM to dwAccessMode
68901>>>>>            Move FNULL to dwSharedMode
68902>>>>>            If (num_arguments > 2) Begin
68904>>>>>                If (bShared = True) Begin
68906>>>>>                    Move FILE_SHARE_RANDOM to dwSharedMode
68907>>>>>                End
68907>>>>>>
68907>>>>>            End
68907>>>>>>
68907>>>>>            Move OPEN_EXISTING to dwCreateMode
68908>>>>>            If (num_arguments > 3) Begin
68910>>>>>                If (bCreate = True) Begin
68912>>>>>                    Move OPEN_ALWAYS to dwCreateMode
68913>>>>>                End
68913>>>>>>
68913>>>>>            End
68913>>>>>>
68913>>>>>            If (num_arguments > 4) Begin
68915>>>>>                If (bReadOnly = True) Begin
68917>>>>>                    Move GENERIC_READ to dwAccessMode
68918>>>>>                    If (bShared = True) Begin
68920>>>>>                        Move FILE_SHARE_READ to dwSharedMode
68921>>>>>                    End
68921>>>>>>
68921>>>>>                End
68921>>>>>>
68921>>>>>            End
68921>>>>>>
68921>>>>>            Append sFilenameANSI (Character(0)) (Character(0))
68923>>>>>            Move (fsCreatefile(sFilenameANSI, dwAccessMode, dwSharedMode, FNULL, dwCreateMode, FILE_ATTRIBUTE_NORMAL, FNULL)) to iReturnValue
68924>>>>>            If (iReturnValue = INVALID_HANDLE_VALUE) Begin
68926>>>>>                Move (fsGetLastError()) to iErrornumber
68927>>>>>                If iErrornumber Begin
68929>>>>>                    Send DoShowError iErrornumber ("File: "+ sFilename)
68930>>>>>                End
68930>>>>>>
68930>>>>>            End
68930>>>>>>
68930>>>>>            Else Begin
68931>>>>>                Move iReturnValue to lsFile[iFilenumber].hFilehandle
68932>>>>>                Move False to lsFile[iFilenumber].bEndOfFile
68933>>>>>                Set plsFile to lsFile
68934>>>>>                Set pbEOF to False
68935>>>>>                Move True to bOk
68936>>>>>            End
68936>>>>>>
68936>>>>>        End
68936>>>>>>
68936>>>>>        Else Begin
68937>>>>>            Send warning_box "The filenumber is already used."
68938>>>>>        End
68938>>>>>>
68938>>>>>        Function_Return bOk
68939>>>>>    End_Function
68940>>>>>
68940>>>>>    // Closing a binary file
68940>>>>>    // Returns true if the file could be closed.
68940>>>>>    Function BinaryFileClose Integer iFilenumber Returns Boolean
68942>>>>>        Integer iRetVal iErrorNumber
68942>>>>>        Handle hHandle
68942>>>>>        structFile[] lsFile
68942>>>>>        structFile[] lsFile
68943>>>>>        structFileBufferPointer[] lsFileBufferPointer
68943>>>>>        structFileBufferPointer[] lsFileBufferPointer
68944>>>>>        String[] saCachedBuffer
68945>>>>>        Boolean bOk
68945>>>>>        Get BinaryFileHandle iFilenumber to hHandle
68946>>>>>        Set pbError to False
68947>>>>>        Move False to bOk
68948>>>>>        If hHandle Begin
68950>>>>>            Move (fsCloseHandle(hHandle)) to iRetVal
68951>>>>>            If (iRetVal = 0) Begin           // Could not close
68953>>>>>                Move (fsGetLastError()) to iErrorNumber
68954>>>>>                If iErrorNumber Begin
68956>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68957>>>>>                End
68957>>>>>>
68957>>>>>            End
68957>>>>>>
68957>>>>>            Else Begin
68958>>>>>                Get plsFile to lsFile
68959>>>>>                Get plsCachedPointer to lsFileBufferPointer
68960>>>>>                Get psaCachedBuffer to saCachedBuffer
68961>>>>>                Move 0 to lsFile[iFilenumber].hFilehandle
68962>>>>>                Move "" to saCachedBuffer[iFilenumber]
68963>>>>>                Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
68964>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].iBufferSize
68965>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].biFromFilePosition
68966>>>>>                Set plsFile to lsFile
68967>>>>>                Set plsCachedPointer to lsFileBufferPointer
68968>>>>>                Set psaCachedBuffer to saCachedBuffer
68969>>>>>                Move True to bOk
68970>>>>>            End
68970>>>>>>
68970>>>>>        End
68970>>>>>>
68970>>>>>        Function_Return bOk
68971>>>>>    End_Function
68972>>>>>
68972>>>>>    // Reading from a binary file.
68972>>>>>    // The data read from the file is placed in sReadBuffer and the function returns the number of bytes read.
68972>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
68972>>>>>    // No errors occures if you try to read past end of file.
68972>>>>>    // To speed up reading process you should read in a block of data at a time (i.e. iNumberOfBytes = 2000) instead of
68972>>>>>    // reading one byte at a time. No errors occures if you try to read past end
68972>>>>>    // of file. Note that iNumberOfBytes must not exceed the argument size.
68972>>>>>    Function BinaryFileRead Integer iFilenumber Integer iNumberOfBytes String ByRef sReadBuffer Returns Integer
68974>>>>>        Handle hFileHandle
68974>>>>>        Integer iBytesRead iMaxBuffer iErrorNumber
68974>>>>>        Boolean bOk
68974>>>>>        structFile[] lsFile
68974>>>>>        structFile[] lsFile
68975>>>>>        Set pbError to False
68976>>>>>        Move 0 to iBytesRead
68977>>>>>        Get_Argument_Size to iMaxBuffer
68978>>>>>        If (iNumberOfBytes > iMaxBuffer) Begin
68980>>>>>            Send warning_box "Blocksize to read exceeds argument size!"
68981>>>>>            Function_Return iBytesRead
68982>>>>>        End
68982>>>>>>
68982>>>>>        If (iNumberOfBytes < 1) Begin
68984>>>>>            Send warning_box "Number of bytes to read can not be less than one."
68985>>>>>            Function_Return iBytesRead
68986>>>>>        End
68986>>>>>>
68986>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68987>>>>>        If hFileHandle Begin
68989>>>>>            Move (ZeroString(iNumberOfBytes)) to sReadBuffer
68990>>>>>            Move (fsReadFile(hFileHandle, AddressOf(sReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
68991>>>>>            If (bOk = False) Begin
68993>>>>>                Move (fsGetLastError()) to iErrorNumber
68994>>>>>                If iErrorNumber Begin
68996>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68997>>>>>                End
68997>>>>>>
68997>>>>>            End
68997>>>>>>
68997>>>>>            Else Begin
68998>>>>>                If (iBytesRead = 0 or iBytesRead <> iNumberOfBytes) Begin
69000>>>>>                    Get plsFile to lsFile
69001>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
69002>>>>>                    Set plsFile to lsFile
69003>>>>>                    Set pbEOF to True
69004>>>>>                    Move (Left(sReadBuffer, iBytesRead)) to sReadBuffer
69005>>>>>                End
69005>>>>>>
69005>>>>>            End
69005>>>>>>
69005>>>>>        End
69005>>>>>>
69005>>>>>        Else Begin
69006>>>>>            Send warning_box FS_FILEHANDLEMISSING
69007>>>>>        End
69007>>>>>>
69007>>>>>        Function_Return iBytesRead
69008>>>>>    End_Function
69009>>>>>
69009>>>>>    // Reading from a binary file until a string of bytes are matched.
69009>>>>>    // The data read from the file is placed in the sReturnBuffer and the function returns the number of bytes read until the match is read including the match.
69009>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
69009>>>>>    // The return string buffer would also be empty.
69009>>>>>    // No errors occures if you try to read past end of file.
69009>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
69009>>>>>    Function BinaryFileReadCachedUntilMatch Integer iFilenumber String sMatchString String ByRef sReturnBuffer Boolean ByRef bEndOfFile Returns Integer
69011>>>>>        Handle hFileHandle
69011>>>>>        Integer iBuffersize iMatchPos iLengthMatch
69011>>>>>        String sByte
69011>>>>>        structFile[] lsFile
69011>>>>>        structFile[] lsFile
69012>>>>>        structFileBufferPointer[] lsFileBufferPointer
69012>>>>>        structFileBufferPointer[] lsFileBufferPointer
69013>>>>>        String[] saCachedBuffer
69014>>>>>        Get plsFile to lsFile
69015>>>>>        Move "" to sReturnBuffer
69016>>>>>        Move 1 to iMatchPos
69017>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
69019>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
69020>>>>>            If (hFileHandle <> 0) Begin
69022>>>>>                Move (Length(sMatchString)) to iLengthMatch
69023>>>>>                Get plsCachedPointer to lsFileBufferPointer
69024>>>>>                Get psaCachedBuffer to saCachedBuffer
69025>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
69027>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
69028>>>>>                    Move "" to saCachedBuffer[iFilenumber]
69029>>>>>                End
69029>>>>>>
69029>>>>>                Repeat
69029>>>>>>
69029>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer > lsFileBufferPointer[iFilenumber].iBufferSize) Begin
69031>>>>>                        Get_Argument_Size to iBuffersize
69032>>>>>                        Get BinaryFilePosition iFilenumber to lsFileBufferPointer[iFilenumber].biFromFilePosition
69033>>>>>                        Get BinaryFileRead iFilenumber iBuffersize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer[iFilenumber].iBufferSize
69034>>>>>                        Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
69035>>>>>                        Set psaCachedBuffer to saCachedBuffer
69036>>>>>                    End
69036>>>>>>
69036>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer =< lsFileBufferPointer[iFilenumber].iBufferSize) Begin
69038>>>>>                        Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer[iFilenumber].iBufferPointer)) to sByte
69039>>>>>                        Increment lsFileBufferPointer[iFilenumber].iBufferPointer
69040>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
69041>>>>>                        If (sByte = Mid(sMatchString, 1, iMatchPos)) Begin
69043>>>>>                            Increment iMatchPos
69044>>>>>                        End
69044>>>>>>
69044>>>>>                        Else Begin
69045>>>>>                            Move 1 to iMatchPos
69046>>>>>                        End
69046>>>>>>
69046>>>>>                    End
69046>>>>>>
69046>>>>>                Until (iMatchPos > iLengthMatch or lsFileBufferPointer[iFilenumber].iBufferSize = 0)
69048>>>>>                Set plsCachedPointer to lsFileBufferPointer
69049>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
69051>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
69052>>>>>                End
69052>>>>>>
69052>>>>>            End
69052>>>>>>
69052>>>>>            Else Begin
69053>>>>>                Send warning_box FS_FILEHANDLEMISSING
69054>>>>>            End
69054>>>>>>
69054>>>>>        End
69054>>>>>>
69054>>>>>        Function_Return (Length(sReturnBuffer))
69055>>>>>    End_Function
69056>>>>>
69056>>>>>    // Reading from a binary file as CSV file For next text field.
69056>>>>>    // The data read from the file is placed in the sReturnBuffer excluding the separator and the function returns true.
69056>>>>>    // Then the function returns false the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
69056>>>>>    // When the end of row data has been read the bEndOfRow is set true.
69056>>>>>    // The end of row is indicated with sCharEOL. If that is not applied the charactersequence character(13) + character(10) is used.
69056>>>>>    // The return string buffer would also be empty.
69056>>>>>    // No errors occures if you try to read past end of file.
69056>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
69056>>>>>    Function BinaryFileReadCachedCSV Integer iFilenumber String sFieldseparator String sTextQualification String ByRef sReturnBuffer Boolean ByRef bEndOfRow Boolean ByRef bEndOfFile String sCharEOL Returns Integer
69058>>>>>        Handle hFileHandle
69058>>>>>        Integer iLengthSeparator iLengthTextQualification iEOLLength iTestLength
69058>>>>>        String sByte sEOL sTestBuffer
69058>>>>>        structFile[] lsFile
69058>>>>>        structFile[] lsFile
69059>>>>>        structFileBufferPointer[] lsFileBufferPointer
69059>>>>>        structFileBufferPointer[] lsFileBufferPointer
69060>>>>>        String[] saCachedBuffer
69061>>>>>        Boolean bInTextFieldMode bTextFieldReady bFieldSeparator bTextQualificator bEscapeTextQualificatorTest bByteOk
69061>>>>>        BigInt biAfterTextQualificator
69061>>>>>        Get plsFile to lsFile
69062>>>>>        If (num_arguments > 6) Begin
69064>>>>>            Move sCharEOL to sEOL
69065>>>>>        End
69065>>>>>>
69065>>>>>        Else Begin
69066>>>>>            Move ((Character(13))+(Character(10))) to sEOL
69067>>>>>        End
69067>>>>>>
69067>>>>>        Move (Length(sEOL)) to iEOLLength
69068>>>>>        Move "" to sReturnBuffer
69069>>>>>        Move "" to sByte
69070>>>>>        Move False to bInTextFieldMode
69071>>>>>        Move False to bTextFieldReady
69072>>>>>        Move False to bEndOfRow
69073>>>>>        Move False to bTextQualificator
69074>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
69076>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
69077>>>>>            If (hFileHandle <> 0) Begin
69079>>>>>                Move (Length(sFieldseparator)) to iLengthSeparator
69080>>>>>                Move (Length(sTextQualification)) to iLengthTextQualification
69081>>>>>                Get plsCachedPointer to lsFileBufferPointer
69082>>>>>                Get psaCachedBuffer to saCachedBuffer
69083>>>>>
69083>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
69085>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
69086>>>>>                    Move "" to saCachedBuffer[iFilenumber]
69087>>>>>                End
69087>>>>>>
69087>>>>>                Repeat
69087>>>>>>
69087>>>>>                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
69088>>>>>                    If bByteOk Begin
69090>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
69091>>>>>                        Move (Right(sReturnBuffer, iLengthSeparator) = sFieldseparator) to bFieldSeparator
69092>>>>>                        If bFieldSeparator Begin
69094>>>>>                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthSeparator))) to sReturnBuffer
69095>>>>>                            Move True to bTextFieldReady
69096>>>>>                            Move False to bEscapeTextQualificatorTest
69097>>>>>                        End
69097>>>>>>
69097>>>>>                        If (not(bTextFieldReady)) Begin
69099>>>>>                            Move (Right(sReturnBuffer, iEOLLength) = sEOL) to bEndOfRow
69100>>>>>                            If bEndOfRow Begin
69102>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iEOLLength))) to sReturnBuffer
69103>>>>>                                Move True to bTextFieldReady
69104>>>>>                            End
69104>>>>>>
69104>>>>>                        End
69104>>>>>>
69104>>>>>                        If (not(bTextFieldReady)) Begin
69106>>>>>                            Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
69107>>>>>                            If bTextQualificator Begin
69109>>>>>                            // Read until end of text field. Place filepointer after text field.
69109>>>>>                                Move True to bInTextFieldMode
69110>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
69111>>>>>                                Repeat
69111>>>>>>
69111>>>>>                                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
69112>>>>>                                    If bByteOk Begin
69114>>>>>                                        Move (sReturnBuffer + sByte) to sReturnBuffer
69115>>>>>                                        Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
69116>>>>>                                        If bTextQualificator Begin
69118>>>>>                                        // Either it is the end of the text field or the escape text qualificator has been read.
69118>>>>>                                        // Read ahead to a new buffer to see if the next bytes are the text qualificator.
69118>>>>>                                        // If it is, add the new buffer to the return buffer.
69118>>>>>                                        // If not, restore the filebuffer to this position and mark the text field ended.
69118>>>>>                                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
69119>>>>>                                            Set plsCachedPointer to lsFileBufferPointer
69120>>>>>                                            Get BinaryFileCachedPosition iFilenumber to biAfterTextQualificator
69121>>>>>                                            Move "" to sTestBuffer
69122>>>>>                                            Move 0 to iTestLength
69123>>>>>                                            Move True to bEscapeTextQualificatorTest
69124>>>>>                                            Repeat
69124>>>>>>
69124>>>>>                                                Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
69125>>>>>                                                If bByteOk Begin
69127>>>>>                                                    Move (sTestBuffer + sByte) to sTestBuffer
69128>>>>>                                                    Increment iTestLength
69129>>>>>                                                    If (Left(sTextQualification, iTestLength) = sTestBuffer) Begin
69131>>>>>                                                        If (iTestLength = iLengthTextQualification) Begin
69133>>>>>                                                            Move (sReturnBuffer + sTestBuffer) to sReturnBuffer
69134>>>>>                                                            Move False to bEscapeTextQualificatorTest
69135>>>>>                                                        End
69135>>>>>>
69135>>>>>                                                    End
69135>>>>>>
69135>>>>>                                                    Else Begin
69136>>>>>                                                        Set BinaryFileChachedPosition iFilenumber to biAfterTextQualificator
69137>>>>>                                                        Get plsCachedPointer to lsFileBufferPointer
69138>>>>>                                                        Move False to bEscapeTextQualificatorTest
69139>>>>>                                                        Move False to bInTextFieldMode
69140>>>>>                                                    End
69140>>>>>>
69140>>>>>                                                End
69140>>>>>>
69140>>>>>                                            Until (bEscapeTextQualificatorTest = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
69142>>>>>                                        End
69142>>>>>>
69142>>>>>                                    End
69142>>>>>>
69142>>>>>                                Until (bInTextFieldMode = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
69144>>>>>                            End
69144>>>>>>
69144>>>>>                        End
69144>>>>>>
69144>>>>>                    End
69144>>>>>>
69144>>>>>                Until (bTextFieldReady = True or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
69146>>>>>                Set plsCachedPointer to lsFileBufferPointer
69147>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
69149>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
69150>>>>>                    If (bEndOfFile = True) Begin
69152>>>>>                        Move True to bTextFieldReady
69153>>>>>                        Move True to bEndOfRow
69154>>>>>                    End
69154>>>>>>
69154>>>>>                End
69154>>>>>>
69154>>>>>            End
69154>>>>>>
69154>>>>>            Else Begin
69155>>>>>                Send warning_box FS_FILEHANDLEMISSING
69156>>>>>            End
69156>>>>>>
69156>>>>>        End
69156>>>>>>
69156>>>>>        Function_Return bTextFieldReady
69157>>>>>    End_Function
69158>>>>>
69158>>>>>    Function NextByteCSV Integer ByRef iFilenumber structFileBufferPointer ByRef lsFileBufferPointer String[] ByRef saCachedBuffer String ByRef sByte Returns String
69160>>>>>        Integer iBufferSize
69160>>>>>        Boolean bOk
69160>>>>>        If (lsFileBufferPointer.iBufferPointer > lsFileBufferPointer.iBufferSize) Begin
69162>>>>>            Get_Argument_Size to iBufferSize
69163>>>>>            Get BinaryFilePosition iFilenumber to lsFileBufferPointer.biFromFilePosition
69164>>>>>            Get BinaryFileRead iFilenumber iBufferSize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer.iBufferSize
69165>>>>>            Move 1 to lsFileBufferPointer.iBufferPointer
69166>>>>>            Set psaCachedBuffer to saCachedBuffer
69167>>>>>        End
69167>>>>>>
69167>>>>>        If (lsFileBufferPointer.iBufferPointer <= lsFileBufferPointer.iBufferSize) Begin
69169>>>>>            Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer.iBufferPointer)) to sByte
69170>>>>>            Increment lsFileBufferPointer.iBufferPointer
69171>>>>>            Move True to bOk
69172>>>>>        End
69172>>>>>>
69172>>>>>        Function_Return bOk
69173>>>>>    End_Function
69174>>>>>
69174>>>>>    // Shortcut to read a binary file as lines from a textfile.
69174>>>>>    // Reads from cached file until sCharEOL are recieved.
69174>>>>>    // Data is returned without the ending sCharEOL
69174>>>>>    // If sCharEOL is not applied the charactersequence character(13) + character(10) is used.
69174>>>>>    // Returns True when the line has been read.
69174>>>>>    Function BinaryFileReadCachedLN Integer iFilenumber String ByRef sLine Boolean ByRef bEndOfFile String sCharEOL Returns Boolean
69176>>>>>        Boolean bEndOfRow
69176>>>>>        Integer iBytesRead iEOLLength
69176>>>>>        String sEOL
69176>>>>>        If (num_arguments > 3) Begin
69178>>>>>            Move sCharEOL to sEOL
69179>>>>>        End
69179>>>>>>
69179>>>>>        Else Begin
69180>>>>>            Move ((Character(13))+(Character(10))) to sEOL
69181>>>>>        End
69181>>>>>>
69181>>>>>        Move (Length(sEOL)) to iEOLLength
69182>>>>>        Get BinaryFileReadCachedUntilMatch iFilenumber sEOL (&sLine) (&bEndOfFile) to iBytesRead
69183>>>>>        If (iBytesRead > 0) Begin
69185>>>>>            If (Right(sLine, iEOLLength) = sEOL) Begin
69187>>>>>                Move (Left(sLine, (Length(sLine) - iEOLLength))) to sLine
69188>>>>>                Move True to bEndOfRow
69189>>>>>            End
69189>>>>>>
69189>>>>>        End
69189>>>>>>
69189>>>>>        Function_Return bEndOfRow
69190>>>>>    End_Function
69191>>>>>
69191>>>>>    // Writing to a binary file.
69191>>>>>    // Returns true if the data was written to the file without error.
69191>>>>>    Function BinaryFileWrite Integer iFilenumber String ByRef sWriteData Returns Boolean
69193>>>>>        Integer iBytesWritten iBytesToWrite iErrorNumber
69193>>>>>        Handle hFileHandle
69193>>>>>        Boolean bOk
69193>>>>>        Set pbError to False
69194>>>>>        Move False to bOk
69195>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69196>>>>>        If hFileHandle Begin
69198>>>>>            Move 0 to iBytesWritten
69199>>>>>            Move (Length(sWriteData)) to iBytesToWrite
69200>>>>>            Move (fsWriteFile(hFileHandle, AddressOf(sWriteData), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
69201>>>>>            If (bOk = False) Begin
69203>>>>>                Move (fsGetLastError()) to iErrorNumber
69204>>>>>                If iErrorNumber Begin
69206>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
69207>>>>>                End
69207>>>>>>
69207>>>>>            End
69207>>>>>>
69207>>>>>            If (iBytesToWrite <> iBytesWritten) Begin
69209>>>>>                Send Warning_box "Not all data could be written!"
69210>>>>>                Move False to bOk
69211>>>>>            End
69211>>>>>>
69211>>>>>        End
69211>>>>>>
69211>>>>>        Else Begin
69212>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
69213>>>>>        End
69213>>>>>>
69213>>>>>        Function_Return bOk
69214>>>>>    End_Function
69215>>>>>
69215>>>>>    // Write HEX values to a binary file as bytes.
69215>>>>>    // HEX values in sWriteHEX are first coverted to bytes and then written
69215>>>>>    // to the binary file.
69215>>>>>    // Returns true if the HEX data was written to the file without error.
69215>>>>>    Function BinaryFileWriteHex Integer iFilenumer String ByRef sWriteHex Returns Boolean
69217>>>>>        String sData
69217>>>>>        Integer iLength iCount iByte
69217>>>>>        Boolean bOk
69217>>>>>        Move (Length(sWritehex)) to iLength
69218>>>>>        Move 1 to iCount
69219>>>>>        While (iCount < iLength)
69223>>>>>            Move ("$"+Mid(sWriteHex, 2, iCount)) to iByte
69224>>>>>            Move (iCount + 2) to iCount
69225>>>>>            Move (sData + Character(iByte)) to sData
69226>>>>>        Loop
69227>>>>>>
69227>>>>>        Get BinaryFileWrite iFilenumer (&sData) to bOk
69228>>>>>        Function_Return bOk
69229>>>>>    End_Function
69230>>>>>
69230>>>>>    // Retrives the file size from a binary file.
69230>>>>>    Function BinaryFileSize Integer iFilenumber Returns BigInt
69232>>>>>        BigInt biFilesize
69232>>>>>        Handle hFileHandle
69232>>>>>        Boolean bOk
69232>>>>>        Integer iErrorNumber
69232>>>>>        Set pbError to False
69233>>>>>        Move -1 to biFilesize
69234>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69235>>>>>        If hFileHandle Begin
69237>>>>>        // The LARGE_INTEGER structure has the same structure as a BigInt.
69237>>>>>            Move (fsGetFileSizeEx(hFileHandle, AddressOf(biFilesize))) to bOk
69238>>>>>            If (bOk = -False) Begin
69240>>>>>                Move (fsGetLastError()) to iErrorNumber
69241>>>>>                If iErrorNumber Begin
69243>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
69244>>>>>                End
69244>>>>>>
69244>>>>>            End
69244>>>>>>
69244>>>>>        End
69244>>>>>>
69244>>>>>        Else Begin
69245>>>>>            Send warning_box FS_FILEHANDLEMISSING
69246>>>>>        End
69246>>>>>>
69246>>>>>        Function_Return biFilesize
69247>>>>>    End_Function
69248>>>>>
69248>>>>>    // Retrives the file position from a binary file.
69248>>>>>    // Returns -1 if an error occured.
69248>>>>>    Function BinaryFilePosition Integer iFilenumber Returns BigInt
69250>>>>>        BigInt biFilePosition biBigHi
69250>>>>>        Handle hFileHandle
69250>>>>>        Boolean bOk
69250>>>>>        Integer iErrorNumber iLo iHi
69250>>>>>        UInteger iNewPos
69250>>>>>
69250>>>>>        Set pbError to False
69251>>>>>        Move -1 to biFilePosition
69252>>>>>        Move 0 to iHi
69253>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69254>>>>>        If hFileHandle Begin
69256>>>>>            Move (2^32) to biBigHi
69257>>>>>            Move (fsSetFilePointer(hFileHandle, ilo, AddressOf(iHi), FILE_CURRENT)) to iNewPos
69258>>>>>            If (iNewPos = (biBigHi - 1)) Begin
69260>>>>>                Move (fsGetLastError()) to iErrorNumber
69261>>>>>                If iErrorNumber Begin
69263>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
69264>>>>>                End
69264>>>>>>
69264>>>>>                Else Begin
69265>>>>>                    Move True to bOk
69266>>>>>                End
69266>>>>>>
69266>>>>>            End
69266>>>>>>
69266>>>>>            Else Begin
69267>>>>>                Move True to bOk
69268>>>>>            End
69268>>>>>>
69268>>>>>            If bOk Begin
69270>>>>>                Move ((iHi * biBigHi) + iNewPos) to biFilePosition
69271>>>>>            End
69271>>>>>>
69271>>>>>        End
69271>>>>>>
69271>>>>>        Else Begin
69272>>>>>            Send warning_box FS_FILEHANDLEMISSING
69273>>>>>        End
69273>>>>>>
69273>>>>>        Function_Return biFilePosition
69274>>>>>    End_Function
69275>>>>>
69275>>>>>    // Sets the file position from a binary file to a new position.
69275>>>>>    Procedure Set BinaryFilePosition Integer iFilenumber BigInt biPosition
69277>>>>>        Handle hFileHandle
69277>>>>>        Integer iHi iErrorNumber
69277>>>>>        UInteger iLo iNewPos
69277>>>>>        Boolean bOk
69277>>>>>        BigInt biFileSize biBigHi
69277>>>>>        structFile[] lsFile
69277>>>>>        structFile[] lsFile
69278>>>>>
69278>>>>>        Set pbError to False
69279>>>>>        Move False to bOk
69280>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69281>>>>>        If hFileHandle Begin
69283>>>>>            Move (2^32) to biBigHi
69284>>>>>            Move (biPosition / biBigHi) to iHi
69285>>>>>            Move (biPosition - (iHi * biBigHi)) to iLo
69286>>>>>            Move (fsSetFilePointer(hFileHandle, iLo, AddressOf(iHi), FILE_BEGIN)) to iNewPos
69287>>>>>            If (iNewPos = (biBigHi - 1)) Begin
69289>>>>>                Move (fsGetLastError()) to iErrorNumber
69290>>>>>                If iErrorNumber Begin
69292>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
69293>>>>>                End
69293>>>>>>
69293>>>>>                Else Begin
69294>>>>>                    Move True to bOk
69295>>>>>                End
69295>>>>>>
69295>>>>>            End
69295>>>>>>
69295>>>>>            Else Begin
69296>>>>>                Move True to bOk
69297>>>>>            End
69297>>>>>>
69297>>>>>            If bOk Begin
69299>>>>>                Get BinaryFileSize iFilenumber to biFileSize
69300>>>>>                Get plsFile to lsFile
69301>>>>>                If (biFileSize > biPosition) Begin
69303>>>>>                    Move False to lsFile[iFilenumber].bEndOfFile
69304>>>>>                    Set pbEOF to False
69305>>>>>                End
69305>>>>>>
69305>>>>>                Else Begin
69306>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
69307>>>>>                    Set pbEOF to True
69308>>>>>                End
69308>>>>>>
69308>>>>>                Set plsFile to lsFile
69309>>>>>            End
69309>>>>>>
69309>>>>>        End
69309>>>>>>
69309>>>>>        Else Begin
69310>>>>>            Send warning_box FS_FILEHANDLEMISSING
69311>>>>>        End
69311>>>>>>
69311>>>>>        Set pbError to (not(bOk))
69312>>>>>    End_Procedure
69313>>>>>
69313>>>>>    // Returns -1 if an error occured.
69313>>>>>    Function BinaryFileCachedPosition Integer iFileNumber Returns BigInt
69315>>>>>        BigInt biPosition
69315>>>>>        structFileBufferPointer[] lsFileBufferPointer
69315>>>>>        structFileBufferPointer[] lsFileBufferPointer
69316>>>>>        Handle hFileHandle
69316>>>>>        Move -1 to biPosition
69317>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69318>>>>>        If hFileHandle Begin
69320>>>>>            Get plsCachedPointer to lsFileBufferPointer
69321>>>>>            If (iFilenumber < SizeOfArray(lsFileBufferPointer)) Begin
69323>>>>>                If (lsFileBufferPointer[iFileNumber].iBufferSize > 0) Begin
69325>>>>>                    Move (lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferPointer - 1) to biPosition
69326>>>>>                End
69326>>>>>>
69326>>>>>                Else Begin
69327>>>>>                    Get BinaryFilePosition iFileNumber to biPosition
69328>>>>>                End
69328>>>>>>
69328>>>>>            End
69328>>>>>>
69328>>>>>            Else Begin
69329>>>>>                Get BinaryFilePosition iFileNumber to biPosition
69330>>>>>            End
69330>>>>>>
69330>>>>>        End
69330>>>>>>
69330>>>>>        Else Begin
69331>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
69332>>>>>        End
69332>>>>>>
69332>>>>>        Function_Return biPosition
69333>>>>>    End_Function
69334>>>>>
69334>>>>>    // Sets the pointer For the current file cache.
69334>>>>>    Procedure Set BinaryFileChachedPosition Integer iFileNumber BigInt biNewPosition
69336>>>>>        Handle hFileHandle
69336>>>>>        structFileBufferPointer[] lsFileBufferPointer
69336>>>>>        structFileBufferPointer[] lsFileBufferPointer
69337>>>>>        String[] saCachedBuffer
69338>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69339>>>>>        If hFileHandle Begin
69341>>>>>            Get plsCachedPointer to lsFileBufferPointer
69342>>>>>            If (lsFileBufferPointer[iFileNumber].biFromFilePosition > biNewPosition) Begin
69344>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
69345>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
69346>>>>>                Set plsCachedPointer to lsFileBufferPointer
69347>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
69348>>>>>                Get psaCachedBuffer to saCachedBuffer
69349>>>>>                Move "" to saCachedBuffer[iFileNumber]
69350>>>>>                Set psaCachedBuffer to saCachedBuffer
69351>>>>>            End
69351>>>>>>
69351>>>>>            Else If ((lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferSize) < biNewPosition) Begin
69354>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
69355>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
69356>>>>>                Set plsCachedPointer to lsFileBufferPointer
69357>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
69358>>>>>                Get psaCachedBuffer to saCachedBuffer
69359>>>>>                Move "" to saCachedBuffer[iFileNumber]
69360>>>>>                Set psaCachedBuffer to saCachedBuffer
69361>>>>>            End
69361>>>>>>
69361>>>>>            Else Begin
69362>>>>>                Move (biNewPosition - lsFileBufferPointer[iFileNumber].biFromFilePosition + 1) to lsFileBufferPointer[iFileNumber].iBufferPointer
69363>>>>>                Set plsCachedPointer to lsFileBufferPointer
69364>>>>>            End
69364>>>>>>
69364>>>>>        End
69364>>>>>>
69364>>>>>        Else Begin
69365>>>>>            Send warning_box FS_FILEHANDLEMISSING
69366>>>>>        End
69366>>>>>>
69366>>>>>    End_Procedure
69367>>>>>
69367>>>>>    // Truncate or extend a binary file to the specified file position
69367>>>>>    // by setting the binary file End Of File position.
69367>>>>>    // If biPosition is -1 the current file position is used as EOF position.
69367>>>>>    Procedure Set BinaryFileEndOfFile Integer iFilenumber BigInt biPosition
69369>>>>>        Handle hFileHandle
69369>>>>>        Boolean bError bOk
69369>>>>>        Integer iErrorNumber
69369>>>>>        structFile[] lsFile
69369>>>>>        structFile[] lsFile
69370>>>>>        Set pbError to False
69371>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69372>>>>>        If hFileHandle Begin
69374>>>>>            If (biPosition > -1) Begin
69376>>>>>                Set BinaryFilePosition iFilenumber to biPosition
69377>>>>>            End
69377>>>>>>
69377>>>>>            Get pbError to bError
69378>>>>>            If (bError = False) Begin
69380>>>>>                Move (fsSetEndOfFile(hFileHandle)) to bOk
69381>>>>>                If (bOk = False) Begin
69383>>>>>                    Move (fsGetLastError()) to iErrorNumber
69384>>>>>                    If iErrorNumber Begin
69386>>>>>                        Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
69387>>>>>                    End
69387>>>>>>
69387>>>>>                End
69387>>>>>>
69387>>>>>                Else Begin
69388>>>>>                    Get plsFile to lsFile
69389>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
69390>>>>>                    Set plsFile to lsFile
69391>>>>>                    Set pbEOF to True
69392>>>>>                End
69392>>>>>>
69392>>>>>            End
69392>>>>>>
69392>>>>>        End
69392>>>>>>
69392>>>>>        Else Begin
69393>>>>>            Send warning_box FS_FILEHANDLEMISSING
69394>>>>>        End
69394>>>>>>
69394>>>>>        Set pbError to (not(bOk))
69395>>>>>    End_Procedure
69396>>>>>
69396>>>>>    // Returns true if the last read from the binary file had reached the end.
69396>>>>>    Function BinaryFileEndOfFile Integer iFilenumber Returns Boolean
69398>>>>>        structFile[] lsFile
69398>>>>>        structFile[] lsFile
69399>>>>>        Handle hFileHandle
69399>>>>>        Boolean bEndOfFile
69399>>>>>        Move True to bEndOfFile
69400>>>>>        Set pbError to False
69401>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
69402>>>>>        If hFileHandle Begin
69404>>>>>            Get plsFile to lsFile
69405>>>>>            Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
69406>>>>>        End
69406>>>>>>
69406>>>>>        Else Begin
69407>>>>>            Send warning_box FS_FILEHANDLEMISSING
69408>>>>>        End
69408>>>>>>
69408>>>>>        Function_Return bEndOfFile
69409>>>>>    End_Function
69410>>>>>
69410>>>>>    // Returns the filehandle from the filenumber.
69410>>>>>    // Returns 0 if the filenumber is not used.
69410>>>>>    Function BinaryFileHandle Integer iFilenumber Returns Handle
69412>>>>>        Handle hFileHandle
69412>>>>>        structFile[] lsFile
69412>>>>>        structFile[] lsFile
69413>>>>>        Get plsFile to lsFile
69414>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
69416>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
69417>>>>>        End
69417>>>>>>
69417>>>>>        Function_Return hFileHandle
69418>>>>>    End_Function
69419>>>>>
69419>>>>>    // Searches For a file
69419>>>>>    // iMode = DIRMODE_FILES_ONLY (default)
69419>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
69419>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES
69419>>>>>    // Returns True if found
69419>>>>>    Function FileExists String sFilePathMask Integer iFileDirMode Returns Boolean
69421>>>>>        Integer iMode
69421>>>>>        Boolean bFound
69421>>>>>        tsSearchResult[] lsResult
69421>>>>>        tsSearchResult[] lsResult
69422>>>>>        Move False to bFound
69423>>>>>        Set pbError to False
69424>>>>>        If (num_arguments < 2) Begin
69426>>>>>            Move DIRMODE_FILES_ONLY to iMode
69427>>>>>        End
69427>>>>>>
69427>>>>>        Else Begin
69428>>>>>            Move iFileDirMode to iMode
69429>>>>>        End
69429>>>>>>
69429>>>>>        Get FileSearch sFilePathMask iMode True to lsResult
69430>>>>>        If (SizeOfArray(lsResult) > 0) Begin
69432>>>>>            Move True to bFound
69433>>>>>        End
69433>>>>>>
69433>>>>>        Function_Return bFound
69434>>>>>    End_Function
69435>>>>>
69435>>>>>    // Deletes a file.
69435>>>>>    // Returns True if succeeds.
69435>>>>>    Function FileDelete String sFilename Integer iRetryAttempts Returns Boolean
69437>>>>>        Boolean bFound bDeleted
69437>>>>>        Integer iErrorNumber iRetryLeft
69437>>>>>
69437>>>>>        Set pbError to False
69438>>>>>        If (num_arguments > 1) Begin
69440>>>>>            Move iRetryAttempts to iRetryLeft
69441>>>>>        End
69441>>>>>>
69441>>>>>        Else Begin
69442>>>>>            Move 0 to iRetryLeft
69443>>>>>        End
69443>>>>>>
69443>>>>>        Get FileExists sFilename to bFound
69444>>>>>        If bFound Begin
69446>>>>>            Repeat
69446>>>>>>
69446>>>>>                Move (ToAnsi(sFilename)) To sFilename
69447>>>>>                Move (sFilename+(Character(0))) to sFilename
69448>>>>>                Move (fsDeleteFile(sFilename)) to bDeleted
69449>>>>>                If (bDeleted = False) Begin
69451>>>>>                    Decrement iRetryLeft
69452>>>>>                    If (iRetryLeft <= 0) Begin
69454>>>>>                        Move (fsGetLastError()) to iErrorNumber
69455>>>>>                        If iErrorNumber Begin
69457>>>>>                            Send DoShowError iErrorNumber ("Tried to delete file: "+sFilename)
69458>>>>>                        End
69458>>>>>>
69458>>>>>                    End
69458>>>>>>
69458>>>>>                    Else Begin
69459>>>>>                        Sleep 1
69460>>>>>                    End
69460>>>>>>
69460>>>>>                End
69460>>>>>>
69460>>>>>            Until (bDeleted = True or iRetryLeft <= 0)
69462>>>>>        End
69462>>>>>>
69462>>>>>        Function_Return bDeleted
69463>>>>>    End_Function
69464>>>>>
69464>>>>>    // Moves a file or directory.
69464>>>>>    // Returns True if succeeds.
69464>>>>>    Function FileMove String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
69466>>>>>        Boolean bMoved
69466>>>>>        Integer iErrorNumber iRetryLeft
69466>>>>>
69466>>>>>        Set pbError to False
69467>>>>>        If (num_arguments > 2) Begin
69469>>>>>            Move iRetryAttempts to iRetryLeft
69470>>>>>        End
69470>>>>>>
69470>>>>>        Else Begin
69471>>>>>            Move 0 to iRetryLeft
69472>>>>>        End
69472>>>>>>
69472>>>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileName
69473>>>>>        Move (ToAnsi(sNewFileName))      to sNewFileName
69474>>>>>        Move (sExistingFilename+(Character(0))) to sExistingFilename
69475>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
69476>>>>>        Repeat
69476>>>>>>
69476>>>>>            Move (fsMoveFile(sExistingFilename, sNewFileName)) to bMoved
69477>>>>>            If (bMoved = False) Begin
69479>>>>>                Decrement iRetryLeft
69480>>>>>                If (iRetryLeft <= 0) Begin
69482>>>>>                    Move (fsGetLastError()) to iErrorNumber
69483>>>>>                    If iErrorNumber Begin
69485>>>>>                        Send DoShowError iErrorNumber ("Tried to move/rename file: "+sExistingFileName+" to "+sNewFileName)
69486>>>>>                    End
69486>>>>>>
69486>>>>>                End
69486>>>>>>
69486>>>>>                Else Begin
69487>>>>>                    Sleep 1
69488>>>>>                End
69488>>>>>>
69488>>>>>            End
69488>>>>>>
69488>>>>>        Until (bMoved = True or iRetryLeft <= 0)
69490>>>>>        Function_Return bMoved
69491>>>>>    End_Function
69492>>>>>
69492>>>>>    // Copies a file. Overwriting an existing file by default.
69492>>>>>    // Returns True if succeeds.
69492>>>>>    Function FileCopy String sExistingFileName String sNewFileName Boolean bFailIfExists Integer iRetryAttempts Returns Boolean
69494>>>>>        Boolean bCopied
69494>>>>>        Boolean bDoNotOverwrite
69494>>>>>        Integer iErrorNumber iRetryLeft
69494>>>>>        Set pbError to False
69495>>>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileName
69496>>>>>        Move (ToAnsi(sNewFileName))      to sNewFileName
69497>>>>>        Move (sExistingFileName+(Character(0))) to sExistingFileName
69498>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
69499>>>>>        If (Num_Arguments > 2) Begin
69501>>>>>            Move bFailIfExists to bDoNotOverwrite
69502>>>>>        End
69502>>>>>>
69502>>>>>        Else Begin
69503>>>>>            Move False to bDoNotOverwrite
69504>>>>>        End
69504>>>>>>
69504>>>>>        If (num_arguments > 3) Begin
69506>>>>>            Move iRetryAttempts to iRetryLeft
69507>>>>>        End
69507>>>>>>
69507>>>>>        Else Begin
69508>>>>>            Move 0 to iRetryLeft
69509>>>>>        End
69509>>>>>>
69509>>>>>        Repeat
69509>>>>>>
69509>>>>>            Move (fsCopyFile(sExistingFileName, sNewFileName, bDoNotOverwrite)) to bCopied
69510>>>>>            If (bCopied = False) Begin
69512>>>>>                Decrement iRetryLeft
69513>>>>>                If (iRetryLeft <= 0) Begin
69515>>>>>                    Move (fsGetLastError()) to iErrorNumber
69516>>>>>                    If iErrorNumber Begin
69518>>>>>                        Send DoShowError iErrorNumber ("Tried to copy file: "+sExistingFileName+" to "+sNewFileName)
69519>>>>>                    End
69519>>>>>>
69519>>>>>                End
69519>>>>>>
69519>>>>>                Else Begin
69520>>>>>                    Sleep 1
69521>>>>>                End
69521>>>>>>
69521>>>>>            End
69521>>>>>>
69521>>>>>        Until (bCopied = True or iRetryLeft <= 0)
69523>>>>>        Function_Return bCopied
69524>>>>>    End_Function
69525>>>>>
69525>>>>>    // Renames a file or directory.
69525>>>>>    // Returns True if succeeds.
69525>>>>>    Function FileRename String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
69527>>>>>        Boolean bRenamed
69527>>>>>        If (num_arguments > 2) Begin
69529>>>>>            Get FileMove sExistingFileName sNewFileName iRetryAttempts to bRenamed
69530>>>>>        End
69530>>>>>>
69530>>>>>        Else Begin
69531>>>>>            Get FileMove sExistingFileName sNewFileName to bRenamed
69532>>>>>        End
69532>>>>>>
69532>>>>>        Function_Return bRenamed
69533>>>>>    End_Function
69534>>>>>
69534>>>>>    // Returns the file size of a file.
69534>>>>>    // Returns -1 if an error occured.
69534>>>>>    Function FileSize String sFilename Returns BigInt
69536>>>>>        tsSearchResult[] lsSearchResult
69536>>>>>        tsSearchResult[] lsSearchResult
69537>>>>>        BigInt iRetval
69537>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
69538>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
69540>>>>>            Move lsSearchResult[0].biFileSize to iRetval
69541>>>>>        End
69541>>>>>>
69541>>>>>        Else Begin
69542>>>>>            Move -1 to iRetval
69543>>>>>        End
69543>>>>>>
69543>>>>>        Function_Return iRetval
69544>>>>>    End_Function
69545>>>>>
69545>>>>>    // Returns the last write date of a file.
69545>>>>>    // Returns 0 if an error occured.
69545>>>>>    Function FileDate String sFilename Returns Date
69547>>>>>        tsSearchResult[] lsSearchResult
69547>>>>>        tsSearchResult[] lsSearchResult
69548>>>>>        Date dDate
69548>>>>>        Move 0 to dDate
69549>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
69550>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
69552>>>>>            Move lsSearchResult[0].dtLastWriteDateTime to dDate
69553>>>>>        End
69553>>>>>>
69553>>>>>        Function_Return dDate
69554>>>>>    End_Function
69555>>>>>
69555>>>>>    // Returns the fileversion info.
69555>>>>>    // Returns false if an error occured.
69555>>>>>    Function FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Boolean
69557>>>>>        Boolean bOk
69557>>>>>        Integer iErrorNumber iStatus
69557>>>>>        Get _FileVersion sFilename (&lsFileVersionInfo) to iStatus
69558>>>>>        If (iStatus = -1) Begin
69560>>>>>            Move (fsGetLastError()) to iErrorNumber
69561>>>>>            If iErrorNumber Begin
69563>>>>>                Send DoShowError iErrorNumber ("Tried to get fileversion info from file: "+sFilename)
69564>>>>>            End
69564>>>>>>
69564>>>>>        End
69564>>>>>>
69564>>>>>        Move (iStatus = 0) to bOk
69565>>>>>        Function_Return bOk
69566>>>>>    End_Function
69567>>>>>
69567>>>>>    Function _FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Integer
69569>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
69569>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
69569>>>>>        UInteger iBytesNeeded
69569>>>>>        Address aBuffer
69569>>>>>        Boolean bOk
69569>>>>>        String sSubBlock
69569>>>>>        DWord dwBufferLen dwBufferPointer
69569>>>>>        tsLandAndCodePage lsLandAndCodePage
69569>>>>>        tsLandAndCodePage lsLandAndCodePage
69569>>>>>        Move (ToANSI(sFilename)) To sFilename
69570>>>>>        Move (sFilename + (Character(0))) to sFilename
69571>>>>>        Move 0 to iBytesNeeded
69572>>>>>        Move 0 to aBuffer
69573>>>>>        Move 0 to lsFIXEDFILEINFO.dwStrucVersion    // Initialize the variable.
69574>>>>>        Move 0 to lsLandAndCodePage.wCodePage
69575>>>>>        Move (fsGetFileVersionInfoSize(sFilename, 0)) to iBytesNeeded
69576>>>>>        If (iBytesNeeded = 0) Begin
69578>>>>>            Function_Return False
69579>>>>>        End
69579>>>>>>
69579>>>>>        Move False to bOk
69580>>>>>        Move (Alloc(iBytesNeeded)) to aBuffer
69581>>>>>        Move (MemSet(aBuffer, 0, iBytesNeeded)) to bOk
69582>>>>>        Move (fsGetFileVersionInfo(sFilename, 0, iBytesNeeded, aBuffer)) to bOk
69583>>>>>        If (not(bOk)) Begin
69585>>>>>            Move (Free(aBuffer)) to bOk
69586>>>>>            Function_Return -1
69587>>>>>        End
69587>>>>>>
69587>>>>>        Move "\" to sSubBlock
69588>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
69589>>>>>        Move 0 to dwBufferLen
69590>>>>>        Move 0 to dwBufferPointer
69591>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
69592>>>>>        If (not(bOk)) Begin
69594>>>>>            Move (Free(aBuffer)) to bOk
69595>>>>>            Function_Return -1
69596>>>>>        End
69596>>>>>>
69596>>>>>        If (dwBufferLen <> 52) Begin
69598>>>>>            Send warning_box (SFormat("Length of bufferdata For VS_FIXEDFILEINFO struct are not in the expected size.\nLength is %1 and should have been 52.", dwBufferLen))
69599>>>>>            Move (Free(aBuffer)) to bOk
69600>>>>>            Function_Return -2
69601>>>>>        End
69601>>>>>>
69601>>>>>        Move (MemCopy(AddressOf(lsFIXEDFILEINFO), dwBufferPointer, dwBufferLen)) to bOk
69602>>>>>        If (not(bOk)) Begin
69604>>>>>            Move (Free(aBuffer)) to bOk
69605>>>>>            Function_Return -1
69606>>>>>        End
69606>>>>>>
69606>>>>>        Move lsFIXEDFILEINFO to lsFileVersionInfo.lsFIXEDFILEINFO
69607>>>>>        Get ConvertFileTileToLocalDateTime lsFIXEDFILEINFO.ubiFileDate to lsFileVersionInfo.dtCreationDateTime
69608>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[0]
69609>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[1]
69610>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[2]
69611>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[3]
69612>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[0]
69613>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[1]
69614>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[2]
69615>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[3]
69616>>>>>        Move "\VarFileInfo\Translation" to sSubBlock
69617>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
69618>>>>>        Move 0 to dwBufferLen
69619>>>>>        Move 0 to dwBufferPointer
69620>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
69621>>>>>        If (not(bOk)) Begin
69623>>>>>            Move (Free(aBuffer)) to bOk
69624>>>>>            Function_Return -1
69625>>>>>        End
69625>>>>>>
69625>>>>>        If (dwBufferLen <> 4) Begin
69627>>>>>            Send warning_box (SFormat("Length of bufferdata For land and codepage numbers are not in the expected size.\nLength is %1 and should have been 4.", dwBufferLen))
69628>>>>>            Move (Free(aBuffer)) to bOk
69629>>>>>            Function_Return -2
69630>>>>>        End
69630>>>>>>
69630>>>>>        Move (MemCopy(AddressOf(lsLandAndCodePage), dwBufferPointer, dwBufferLen)) to bOk
69631>>>>>        Get VerQueryValueStringFileInfo aBuffer "Comments" lsLandAndCodePage to lsFileVersionInfo.sComments
69632>>>>>        Get VerQueryValueStringFileInfo aBuffer "CompanyName" lsLandAndCodePage to lsFileVersionInfo.sCompanyName
69633>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileDescription" lsLandAndCodePage to lsFileVersionInfo.sFileDescription
69634>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileVersion" lsLandAndCodePage to lsFileVersionInfo.sFileVersion
69635>>>>>        Get VerQueryValueStringFileInfo aBuffer "InternalName" lsLandAndCodePage to lsFileVersionInfo.sInternalName
69636>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalCopyright" lsLandAndCodePage to lsFileVersionInfo.sLegalCopyright
69637>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalTrademarks" lsLandAndCodePage to lsFileVersionInfo.sLegalTrademarks
69638>>>>>        Get VerQueryValueStringFileInfo aBuffer "OriginalFilename" lsLandAndCodePage to lsFileVersionInfo.sOriginalFilename
69639>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductName" lsLandAndCodePage to lsFileVersionInfo.sProductName
69640>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductVersion" lsLandAndCodePage to lsFileVersionInfo.sProductVersion
69641>>>>>        Get VerQueryValueStringFileInfo aBuffer "PrivateBuild" lsLandAndCodePage to lsFileVersionInfo.sPrivateBuild
69642>>>>>        Get VerQueryValueStringFileInfo aBuffer "SpecialBuild" lsLandAndCodePage to lsFileVersionInfo.sSpecialBuild
69643>>>>>        Move (Free(aBuffer)) to bOk
69644>>>>>        Function_Return 0
69645>>>>>    End_Function
69646>>>>>
69646>>>>>    // Convert an short integer to a 4-character hex string.
69646>>>>>    Function ShortToHex Short siValue Returns String
69648>>>>>        String sHex
69648>>>>>        Move "" to sHex
69649>>>>>        Repeat
69649>>>>>>
69649>>>>>            Move (Mid ("0123456789ABCDEF", 1, ((siValue iand |CI$0F) + 1)) + sHex) to sHex
69650>>>>>            Move (siValue / |CI$10) to siValue
69651>>>>>        Until (siValue = 0)
69653>>>>>        Move (Right("0000" + sHex, 4)) to sHex
69654>>>>>        Function_Return sHex
69655>>>>>    End_Function
69656>>>>>
69656>>>>>    Function VerQueryValueStringFileInfo Address aBuffer String sInfoName tsLandAndCodePage lsLandAndCodePage Returns String
69658>>>>>        String sSubBlock
69658>>>>>        String sValue
69658>>>>>        DWord dwBufferLen dwBufferPointer
69658>>>>>        Boolean bOk
69658>>>>>        Move (SFormat("\StringFileInfo\%1%2\%3", ShortToHex(Self, lsLandAndCodePage.wLanguage), ShortToHex(Self, lsLandAndCodePage.wCodePage), sInfoName)) to sSubBlock
69659>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
69660>>>>>        Move 0 to dwBufferLen
69661>>>>>        Move 0 to dwBufferPointer
69662>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
69663>>>>>        If (not(bOk)) Begin
69665>>>>>            Function_Return ""
69666>>>>>        End
69666>>>>>>
69666>>>>>        Move (ZeroString(dwBufferLen)) to sValue
69667>>>>>        Move (MemCopy(AddressOf(sValue), dwBufferPointer, dwBufferLen)) to bOk
69668>>>>>        Move (ToOEM(CString(sValue))) To sValue
69669>>>>>        Function_Return sValue
69670>>>>>    End_Function
69671>>>>>
69671>>>>>    // Returns the file extention without the leading "."
69671>>>>>    // Example sFile = "x:\text.txt". The function returns "txt".
69671>>>>>    Function FileExtention String sFilename Returns String
69673>>>>>        String sExtention
69673>>>>>        Integer iPos
69673>>>>>        Move (RightPos(".", sFilename)) to iPos
69674>>>>>        If (iPos > 0) Begin
69676>>>>>            Move (Right(sFilename, (Length(sFilename) - iPos))) to sExtention
69677>>>>>            If (sExtention contains "\" or sExtention contains " ") Begin
69679>>>>>                Move "" to sExtention
69680>>>>>            End
69680>>>>>>
69680>>>>>        End
69680>>>>>>
69680>>>>>        Function_Return sExtention
69681>>>>>    End_Function
69682>>>>>
69682>>>>>    // Gets a handle to an icon stored as a resource in a file or an icon
69682>>>>>    // stored in a file's associated executable file.
69682>>>>>    // When the icon handle is no longer needed, close it by using the DestroyFileIcon procedure.
69682>>>>>    Function FileIcon String sFilename Returns Handle
69684>>>>>        Handle hIcon
69684>>>>>        Integer iIcon
69684>>>>>        Address aFilename
69684>>>>>        Move (ToANSI(sFilename)) To sFilename
69685>>>>>        Move (Pad(sFilename, MAX_PATH)) to sFilename
69686>>>>>        Move (AddressOf(sFileName)) To aFileName
69687>>>>>        Move 0 to iIcon
69688>>>>>        Move (fsExtractAssociatedIcon(0, aFilename, AddressOf(iIcon))) to hIcon
69689>>>>>        Function_Return hIcon
69690>>>>>    End_Function
69691>>>>>
69691>>>>>    // Destroy hIcon, created from FileIcon.
69691>>>>>    Procedure DestroyFileIcon Handle hIcon
69693>>>>>        Integer iResult
69693>>>>>        If (hIcon <> 0) Begin
69695>>>>>            Move (fsDestroyIcon(hIcon)) to iResult
69696>>>>>        End
69696>>>>>>
69696>>>>>    End_Procedure
69697>>>>>
69697>>>>>    // Search a directory For the files with normal windows mask-signs
69697>>>>>    // Returns an array of matching files and directories
69697>>>>>    // iMode = DIRMODE_FILES_ONLY
69697>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
69697>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
69697>>>>>    // If bReturnOnlyOne is true only one search result item is returned.
69697>>>>>    // If bReturnOnlyOne is true and no items where found no error is shown.
69697>>>>>    Function FileSearch String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
69699>>>>>        tsSearchResult[] lsSearchResult
69699>>>>>        tsSearchResult[] lsSearchResult
69700>>>>>        Integer iSearchResultCount iMode iErrorNumber
69700>>>>>        structWFD lsFindData
69700>>>>>        structWFD lsFindData
69700>>>>>        Handle hFindFile
69700>>>>>        Boolean bError bStop bFound bOk bOnlyOne
69700>>>>>        BigInt biBigHi
69700>>>>>        Address aFileName
69700>>>>>
69700>>>>>        If (num_arguments < 2) Begin
69702>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
69703>>>>>        End
69703>>>>>>
69703>>>>>        Else Begin
69704>>>>>            Move iFileDirMode to iMode
69705>>>>>        End
69705>>>>>>
69705>>>>>        If (num_arguments < 3) Begin
69707>>>>>            Move False to bOnlyOne
69708>>>>>        End
69708>>>>>>
69708>>>>>        Else Begin
69709>>>>>            Move bReturnOnlyOne to bOnlyOne
69710>>>>>        End
69710>>>>>>
69710>>>>>        Move (ToAnsi(sFilePathMask)) To sFilePathMask
69711>>>>>        Move (sFilePathMask+Character(0)) To sFilePathMask
69712>>>>>        Move 0 To lsFindData.dwFileAttributes   // Initialize lsFindData
69713>>>>>        Move (fsFindFirstFile(sFilePathMask, AddressOf(lsFindData))) to hFindFile
69714>>>>>        If (hFindFile <> INVALID_HANDLE_VALUE) Begin
69716>>>>>            Move False to bError
69717>>>>>            Move False to bStop
69718>>>>>            Move (2^32) to biBigHi
69719>>>>>            Set pbError to bError
69720>>>>>            While (bError = False and bStop = False)
69724>>>>>                Move False to bFound
69725>>>>>                Case Begin
69725>>>>>                    Case (iMode = DIRMODE_FILES_ONLY)
69727>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = 0) Begin
69729>>>>>                            Move True to bFound
69730>>>>>                        End
69730>>>>>>
69730>>>>>                        Case Break
69731>>>>>                    Case (iMode = DIRMODE_DIRECTORIES_ONLY)
69734>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = FILE_ATTRIBUTE_DIRECTORY) Begin
69736>>>>>                            Move True to bFound
69737>>>>>                        End
69737>>>>>>
69737>>>>>                        Case Break
69738>>>>>                    Case Else
69738>>>>>                        Move True to bFound
69739>>>>>                        Case Break
69740>>>>>                Case End
69740>>>>>                If bFound Begin
69742>>>>>                    Move (AddressOf(lsFindData.cFileName)) to aFilename
69743>>>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sFilename
69744>>>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sFilename)) to lsSearchResult[iSearchResultCount].sFilename
69745>>>>>                    Move (AddressOf(lsFindData.cAlternateFileName)) to aFilename
69746>>>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sAlternateFileName
69747>>>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sAlternateFileName)) To lsSearchResult[iSearchResultCount].sAlternateFileName
69748>>>>>                    Move lsFindData.dwFileAttributes to lsSearchResult[iSearchResultCount].iFileAttributes
69749>>>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftCreationDateTime to lsSearchResult[iSearchResultCount].dtCreationDateTime
69750>>>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftLastAccessDateTime to lsSearchResult[iSearchResultCount].dtLastAccessDateTime
69751>>>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftLastWriteDateTime to lsSearchResult[iSearchResultCount].dtLastWriteDateTime
69752>>>>>                    Move ((lsFindData.nFileSizeHigh * biBigHi) + lsFindData.nFileSizeLow) to lsSearchResult[iSearchResultCount].biFileSize
69753>>>>>                    Increment iSearchResultCount
69754>>>>>                    If bOnlyOne Begin
69756>>>>>                        Move True to bStop
69757>>>>>                    End
69757>>>>>>
69757>>>>>                End
69757>>>>>>
69757>>>>>                If (bStop = False) Begin
69759>>>>>                    Move (fsFindNextFile(hFindFile, AddressOf(lsFindData))) to bOk
69760>>>>>                End
69760>>>>>>
69760>>>>>                If (bOk = False) Begin
69762>>>>>                    Move True to bStop
69763>>>>>                    If (bOnlyOne = False) Begin
69765>>>>>                        Move (fsGetLastError()) to iErrorNumber
69766>>>>>                        If (iErrorNumber <> ERROR_NO_MORE_FILES and iErrorNumber <> ERROR_MOD_NOT_FOUND and iErrorNumber <> 0) Begin
69768>>>>>                            Send DoShowError iErrorNumber ("Search path: "+sFilePathMask)
69769>>>>>                        End
69769>>>>>>
69769>>>>>                    End
69769>>>>>>
69769>>>>>                End
69769>>>>>>
69769>>>>>                Get pbError to bError
69770>>>>>            Loop
69771>>>>>>
69771>>>>>            Move (fsFindClose(hFindFile)) to bOk
69772>>>>>        End
69772>>>>>>
69772>>>>>        Function_Return lsSearchResult
69773>>>>>    End_Function
69774>>>>>
69774>>>>>    // Search a directory and all subdirectories For the files with normal windows mask-signs.
69774>>>>>    // lsResult[?].sFileName contains full path and filename.
69774>>>>>    // iMode = DIRMODE_FILES_ONLY
69774>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
69774>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
69774>>>>>    Function FileSearchRecursive String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
69776>>>>>        Integer iMode
69776>>>>>        Boolean bOnlyOne
69776>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
69776>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
69778>>>>>        If (num_arguments < 2) Begin
69780>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
69781>>>>>        End
69781>>>>>>
69781>>>>>        Else Begin
69782>>>>>            Move iFileDirMode to iMode
69783>>>>>        End
69783>>>>>>
69783>>>>>        If (num_arguments < 3) Begin
69785>>>>>            Move False to bOnlyOne
69786>>>>>        End
69786>>>>>>
69786>>>>>        Else Begin
69787>>>>>            Move bReturnOnlyOne to bOnlyOne
69788>>>>>        End
69788>>>>>>
69788>>>>>        Get FileSearchRecursivePriv sFilePathMask iMode bOnlyOne (&lsFinalResult) to lsSearchResult
69789>>>>>        Function_Return lsFinalResult
69790>>>>>    End_Function
69791>>>>>
69791>>>>>    // Private
69791>>>>>    Function FileSearchRecursivePriv String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne tsSearchResult[] ByRef lsFinalResult Returns tsSearchResult[]
69793>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
69793>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
69795>>>>>        Integer iMax iCnt iLast iFinalMax
69795>>>>>        String sSearchInDir sFileMask
69795>>>>>        Boolean bStop
69795>>>>>        
69795>>>>>        Move False to bStop
69796>>>>>        Move (RightPos("\", sFilePathMask)) to iLast
69797>>>>>        If (iLast > 0) Begin
69799>>>>>            Move (Left(sFilePathMask, iLast - 1)) to sSearchInDir
69800>>>>>            Move (Mid(sFilePathMask, Length(sFilePathMask), iLast + 1)) to sFileMask
69801>>>>>        End
69801>>>>>>
69801>>>>>        Get FileSearch (sSearchInDir + "\*.*") DIRMODE_DIRECTORIES_ONLY to lsSearchResultDir
69802>>>>>        Move (SizeOfArray(lsSearchResultDir)) to iMax
69803>>>>>        Move 0 to iCnt
69804>>>>>        While (iCnt < iMax and bStop = False)
69808>>>>>            If (lsSearchResultDir[iCnt].sFilename <> "." and lsSearchResultDir[iCnt].sFilename <> "..") Begin
69810>>>>>                Get FileSearchRecursivePriv (sSearchInDir + "\" + lsSearchResultDir[iCnt].sFilename + "\" + sFileMask) iFileDirMode bReturnOnlyOne (&lsFinalResult) to lsSearchResult
69811>>>>>            End
69811>>>>>>
69811>>>>>            Increment iCnt
69812>>>>>            If (bReturnOnlyOne = True) Begin
69814>>>>>                If (SizeOfArray(lsFinalResult) > 0) Begin
69816>>>>>                    Move True to bStop
69817>>>>>                End
69817>>>>>>
69817>>>>>            End
69817>>>>>>
69817>>>>>        Loop
69818>>>>>>
69818>>>>>        If (bStop = False) Begin
69820>>>>>            Get FileSearch sFilePathMask iFileDirMode to lsSearchResult
69821>>>>>            Move (SizeOfArray(lsSearchResult)) to iMax
69822>>>>>            Move (SizeOfArray(lsFinalResult)) to iFinalMax
69823>>>>>            Move 0 to iCnt
69824>>>>>            While (iCnt < iMax and bStop = False)
69828>>>>>                Move lsSearchResult[iCnt] to lsFinalResult[iFinalMax]
69829>>>>>                Move (sSearchInDir + "\" + lsSearchResult[iCnt].sFilename) to lsFinalResult[iFinalMax].sFilename
69830>>>>>                Increment iFinalMax
69831>>>>>                Increment iCnt
69832>>>>>                If (bReturnOnlyOne = True) Begin
69834>>>>>                    If (SizeOfArray(lsFinalResult) > 0) Begin
69836>>>>>                        Move True to bStop
69837>>>>>                    End
69837>>>>>>
69837>>>>>                End
69837>>>>>>
69837>>>>>            Loop
69838>>>>>>
69838>>>>>        End
69838>>>>>>
69838>>>>>        Function_Return lsSearchResult
69839>>>>>    End_Function
69840>>>>>
69840>>>>>    // Finds a list of files.
69840>>>>>    // sSearchFiles is a list of files to search For separated by semicolon (;).
69840>>>>>    // sSearchFiles may not contain paths but may contain wildcards.
69840>>>>>    // sSearchPaths may only contain paths.
69840>>>>>    // Returns a string array with the files
69840>>>>>    // Returns only files with full path.
69840>>>>>    // Use:
69840>>>>>    // Get ListOfFiles "path1;path2" "*.txt;*.asc"
69840>>>>>    // This will return all the .txt and .asc files with full path that exists in path1 and path2.
69840>>>>>    Function ListOfFiles String sSearchPaths String sSearchFiles Returns String[]
69842>>>>>        String[] saFileList
69843>>>>>        Integer iFilelistCount iSearchFilesCount iCurSearchFile
69843>>>>>        Integer iSearchPathsCount iCurSearchPath iFilesFound iCurFileFound
69843>>>>>        String sCurSearchFile sCurSearchPath
69843>>>>>        tsSearchResult[] lsSearchResult
69843>>>>>        tsSearchResult[] lsSearchResult
69844>>>>>        Get CountOfFields sSearchPaths to iSearchPathsCount
69845>>>>>        Get CountOfFields sSearchFiles to iSearchFilesCount
69846>>>>>        If (iSearchFilesCount > 0 and iSearchPathsCount > 0) Begin
69848>>>>>            For iCurSearchFile from 1 to iSearchFilesCount
69854>>>>>>
69854>>>>>                Get FieldAtIndex sSearchFiles iCurSearchFile to sCurSearchFile
69855>>>>>                Move (Trim(sCurSearchFile)) to sCurSearchFile
69856>>>>>                If (sCurSearchFile <> "") Begin
69858>>>>>                    For iCurSearchPath from 1 to iSearchPathsCount
69864>>>>>>
69864>>>>>                        Get FieldAtIndex sSearchPaths iCurSearchPath to sCurSearchPath
69865>>>>>                        If (Right(sCurSearchPath, 1) <> "\") Begin
69867>>>>>                            Move (sCurSearchPath + "\") to sCurSearchPath
69868>>>>>                        End
69868>>>>>>
69868>>>>>                        Get FileSearch (sCurSearchPath + sCurSearchFile) DIRMODE_FILES_ONLY to lsSearchResult
69869>>>>>                        Move (SizeOfArray(lsSearchResult)) to iFilesFound
69870>>>>>                        Decrement iFilesFound
69871>>>>>                        For iCurFileFound from 0 to iFilesFound
69877>>>>>>
69877>>>>>                            Move (sCurSearchPath + lsSearchResult[iCurFileFound].sFilename) to saFileList[iFilelistCount]
69878>>>>>                            Increment iFilelistCount
69879>>>>>                        Loop
69880>>>>>>
69880>>>>>                    Loop
69881>>>>>>
69881>>>>>                End
69881>>>>>>
69881>>>>>            Loop
69882>>>>>>
69882>>>>>        End
69882>>>>>>
69882>>>>>        Function_Return saFileList
69883>>>>>    End_Function
69884>>>>>
69884>>>>>    // Get Windows Temp path
69884>>>>>    Function FileTempPath Returns String
69886>>>>>        Integer iRetVal
69886>>>>>        String  sTempPath
69886>>>>>        Move (ZeroString(MAX_PATH)) to sTempPath
69887>>>>>        Move (fsGetTempPath(MAX_PATH, AddressOf(sTempPath))) to iRetVal
69888>>>>>        If (iRetVal > MAX_PATH) Begin
69890>>>>>            Move (ZeroString(iRetval)) to sTempPath
69891>>>>>            Move (fsGetTempPath(iRetVal, AddressOf(sTempPath))) to iRetVal
69892>>>>>        End
69892>>>>>>
69892>>>>>        Move (ToOEM(sTempPath)) To sTempPath
69893>>>>>        Move (CString(sTempPath)) to sTempPath
69894>>>>>        Function_Return sTempPath
69895>>>>>    End_Function
69896>>>>>
69896>>>>>    // Generates a temporary file.
69896>>>>>    // Returns full path and filename or blank if no file could be created.
69896>>>>>    // sPathName is the place where the temporary file is generated. If it is
69896>>>>>    // not argumented the TEMP enviroment variable is used. If that is also not
69896>>>>>    // available the current directory is used.
69896>>>>>    // You can prefix the first 3 letters of the filename with sPrefix.
69896>>>>>    Function FileTempFileName String sPathName String sPrefix Returns String
69898>>>>>        Address aTempFileName
69898>>>>>        String sPathNameTmp sPrefixTmp sTempFileName
69898>>>>>        Boolean bOk
69898>>>>>        Set pbError to False
69899>>>>>        If (num_arguments > 0) Begin
69901>>>>>            Move sPathName to sPathNameTmp
69902>>>>>        End
69902>>>>>>
69902>>>>>        Else Begin
69903>>>>>            Move "" to sPathNameTmp
69904>>>>>        End
69904>>>>>>
69904>>>>>        If (num_arguments > 1) Begin
69906>>>>>            Move sPrefix to sPrefixTmp
69907>>>>>        End
69907>>>>>>
69907>>>>>        Else Begin
69908>>>>>            Move "" to sPrefixTmp
69909>>>>>        End
69909>>>>>>
69909>>>>>        Move (Trim(sPathNameTmp)) to sPathNameTmp
69910>>>>>        If (sPathNameTmp = "") Begin
69912>>>>>            Get FileTempPath to sPathNameTmp
69913>>>>>            If (sPathNameTmp = "") Begin
69915>>>>>                Move "." to sPathNameTmp
69916>>>>>            End
69916>>>>>>
69916>>>>>        End
69916>>>>>>
69916>>>>>        Move (ZeroString(MAX_PATH))     To sTempFilename
69917>>>>>        Move (AddressOf(sTempFileName)) To aTempFileName
69918>>>>>        Move (ToANSI(sPathNameTmp))     to sPathNameTmp
69919>>>>>        Move (ToANSI(sPrefixTmp))       To sPrefixTmp
69920>>>>>        Move (fsGetTempFileName(sPathNameTmp, sPrefixTmp, 0, aTempFileName)) to bOk
69921>>>>>        If bOk Begin
69923>>>>>            Move (ToOEM(sTempFileName)) To sTempFileName
69924>>>>>            Move (CString(sTempFileName)) to sTempFileName
69925>>>>>        End
69925>>>>>>
69925>>>>>        Function_Return sTempFileName
69926>>>>>    End_Function
69927>>>>>
69927>>>>>    // Returns the file path without the filename. Does not return ending directory separator.
69927>>>>>    // Example sFilename = "x:\PathToFile\File.txt". The function returns "x:\PathToFile".
69927>>>>>    Function FilePath String sFilename Returns String
69929>>>>>        String sPathOnly sDirSep
69929>>>>>        Integer iPos
69929>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69930>>>>>        Move (RightPos(sDirSep, sFilename)) to iPos
69931>>>>>        If (iPos > 0) Begin
69933>>>>>            Move (Left(sFilename, iPos - 1)) to sPathOnly
69934>>>>>        End
69934>>>>>>
69934>>>>>        Function_Return sPathOnly
69935>>>>>    End_Function
69936>>>>>    
69936>>>>>    // Creates a new directory.
69936>>>>>    // Returns True if succeeds.
69936>>>>>    Function DirectoryCreate String sDirectoryName Returns Boolean
69938>>>>>        Boolean bFound bOk
69938>>>>>        Integer iErrorNumber
69938>>>>>        Move False to bOk
69939>>>>>        Set pbError to False
69940>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
69941>>>>>        If (not(bFound)) Begin
69943>>>>>            Move (toAnsi(sDirectoryName)) To sDirectoryname
69944>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
69945>>>>>            Move (fsCreateDirectory(sDirectoryname, FNULL)) to bOk
69946>>>>>            If (bOk = False) Begin           // Could not create
69948>>>>>                Move (fsGetLastError()) to iErrorNumber
69949>>>>>                If iErrorNumber Begin
69951>>>>>                    Send DoShowError iErrorNumber ("Tried to create directory: "+sDirectoryname)
69952>>>>>                End
69952>>>>>>
69952>>>>>            End
69952>>>>>>
69952>>>>>        End
69952>>>>>>
69952>>>>>        Function_Return bOk
69953>>>>>    End_Function
69954>>>>>
69954>>>>>    // Creates a new directory and all missing parent directories in the sPath.
69954>>>>>    // If the sPath contains a filename set bPathContainsFileName to true. This will create all the parent directories for the filename. The filename itself will not be created.
69954>>>>>    // If a parent directory already exists it will be skipped.
69954>>>>>    // Requires an absolute path.
69954>>>>>    // Returns true if all the directories could be created or was already created.
69954>>>>>    Function DirectoryCreateEx String sPath Boolean bPathContainsFileName Returns Boolean
69956>>>>>        Boolean bOk bExists bFilePath
69956>>>>>        Integer iPos iDirSepLength
69956>>>>>        String sCurrentPath sDirSep
69956>>>>>        If (num_arguments > 1) Begin
69958>>>>>            Move bPathContainsFileName to bFilePath
69959>>>>>        End
69959>>>>>>
69959>>>>>        If (bFilePath) Begin
69961>>>>>            Get FilePath sPath to sPath
69962>>>>>        End
69962>>>>>>
69962>>>>>        Get RemoveFolderSeperator sPath to sPath
69963>>>>>        Get FileExists sPath DIRMODE_DIRECTORIES_ONLY to bExists
69964>>>>>        If (bExists) Begin
69966>>>>>            Function_Return True
69967>>>>>        End
69967>>>>>>
69967>>>>>        Get AddFolderSeperator sPath to sPath
69968>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69969>>>>>        Move (Length(sDirSep)) to iDirSepLength
69970>>>>>        Move True to bOk
69971>>>>>        // Check for absolute path an skip device or volume.
69971>>>>>        Move (Pos((":" + sDirSep), sPath)) to iPos
69972>>>>>        If (iPos > 0) Begin
69974>>>>>            Increment iPos
69975>>>>>        End
69975>>>>>>
69975>>>>>        Else Begin
69976>>>>>            // UNC path
69976>>>>>            If (Left(sPath, 2) = "\\") Begin
69978>>>>>                // Host name
69978>>>>>                Move (Pos("\", sPath, 3)) to iPos
69979>>>>>                If (iPos > 0) Begin
69981>>>>>                    Increment iPos
69982>>>>>                    // Share name
69982>>>>>                    Move (Pos("\", sPath, iPos)) to iPos
69983>>>>>                    If (iPos > 0) Begin
69985>>>>>                        Increment iPos
69986>>>>>                    End
69986>>>>>>
69986>>>>>                End
69986>>>>>>
69986>>>>>            End
69986>>>>>>
69986>>>>>        End
69986>>>>>>
69986>>>>>        If (iPos = 0) Begin
69988>>>>>            Send warning_box (SFormat("The path %1 is not an absolute path.", sPath))
69989>>>>>            Function_Return False
69990>>>>>        End
69990>>>>>>
69990>>>>>        While (iPos > 0 and bOk)
69994>>>>>            Move (Pos(sDirSep, sPath, iPos + iDirSepLength)) to iPos
69995>>>>>            If (iPos > 0) Begin
69997>>>>>                Move (Left(sPath, (iPos - 1))) to sCurrentPath
69998>>>>>                Get FileExists sCurrentPath DIRMODE_DIRECTORIES_ONLY to bExists
69999>>>>>                If (not(bExists)) Begin
70001>>>>>                    Get DirectoryCreate sCurrentPath to bOk
70002>>>>>                End
70002>>>>>>
70002>>>>>            End
70002>>>>>>
70002>>>>>        Loop
70003>>>>>>
70003>>>>>        Function_Return bOk
70004>>>>>    End_Function
70005>>>>>
70005>>>>>    // Removes an existing empty directory.
70005>>>>>    // Returns True if succeeds.
70005>>>>>    Function DirectoryRemove String sDirectoryName Returns Boolean
70007>>>>>        Boolean bFound bOk
70007>>>>>        Integer iErrorNumber
70007>>>>>        Move False to bOk
70008>>>>>        Set pbError to False
70009>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
70010>>>>>        If bFound Begin
70012>>>>>            Move (toAnsi(sDirectoryName)) To sDirectoryname
70013>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
70014>>>>>            Move (fsRemoveDirectory(sDirectoryname)) to bOk
70015>>>>>            If (bOk = False) Begin           // Could not delete
70017>>>>>                Move (fsGetLastError()) to iErrorNumber
70018>>>>>                If iErrorNumber Begin
70020>>>>>                    Send DoShowError iErrorNumber ("Tried to remove directory: "+sDirectoryName)
70021>>>>>                End
70021>>>>>>
70021>>>>>            End
70021>>>>>>
70021>>>>>        End
70021>>>>>>
70021>>>>>        Function_Return bOk
70022>>>>>    End_Function
70023>>>>>
70023>>>>>    // Removes a directory and all its contents.
70023>>>>>    // Returns true on succes.
70023>>>>>    Function DirectoryRemoveRecursive String sDirectoryName Returns Boolean
70025>>>>>        tsSearchResult[] alsSearchResults
70025>>>>>        tsSearchResult[] alsSearchResults
70026>>>>>        Integer iIndex
70026>>>>>        Boolean bOk
70026>>>>>
70026>>>>>        If (Right(sDirectoryName, 1) = "\") Begin
70028>>>>>            Move (Left(sDirectoryName, Length(sDirectoryName) - 1)) to sDirectoryName
70029>>>>>        End
70029>>>>>>
70029>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_DIRECTORIES_ONLY to alsSearchResults
70030>>>>>        For iIndex from 2 to (SizeOfArray(alsSearchResults) - 1)
70036>>>>>>
70036>>>>>            Get DirectoryRemoveRecursive (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
70037>>>>>            If (not(bOk)) Begin
70039>>>>>                Function_Return False
70040>>>>>            End
70040>>>>>>
70040>>>>>        Loop
70041>>>>>>
70041>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_FILES_ONLY to alsSearchResults
70042>>>>>        For iIndex from 0 to (SizeOfArray(alsSearchResults) - 1)
70048>>>>>>
70048>>>>>            Get FileDelete (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
70049>>>>>            If (not(bOk)) Begin
70051>>>>>                Function_Return False
70052>>>>>            End
70052>>>>>>
70052>>>>>        Loop
70053>>>>>>
70053>>>>>        Get DirectoryRemove sDirectoryName to bOk
70054>>>>>        Function_Return bOk
70055>>>>>    End_Function
70056>>>>>
70056>>>>>    // Converts the filetime in UTC and returns a datetime in local time.
70056>>>>>    // private
70056>>>>>    Function ConvertFileTileToLocalDateTime UBigInt ubiFileTime Returns DateTime
70058>>>>>        Boolean bOk
70058>>>>>        UBigInt ubiZero
70058>>>>>        structSystemTime lsSystemTime lsLocalTime
70058>>>>>        structSystemTime lsSystemTime lsLocalTime
70058>>>>>        DateTime dtLocalTime
70058>>>>>        Move 0 to lsSystemTime.wDay
70059>>>>>        Move 0 to lsLocalTime.wDay
70060>>>>>        Move 0 to ubiZero
70061>>>>>        If (ubiFileTime <> ubiZero) Begin
70063>>>>>            Move (fsFileTimeToSystemTime(AddressOf(ubiFileTime), AddressOf(lsSystemTime))) to bOk
70064>>>>>            If bOk Begin
70066>>>>>                Move (fsSystemTimeToTzSpecificLocalTime(FNULL, AddressOf(lsSystemTime), AddressOf(lsLocalTime))) to bOk
70067>>>>>                If bOk Begin
70069>>>>>                    Move (DateSetYear(dtLocalTime, lsLocalTime.wYear)) to dtLocalTime
70070>>>>>                    Move (DateSetMonth(dtLocalTime, lsLocalTime.wMonth)) to dtLocalTime
70071>>>>>                    Move (DateSetDay(dtLocalTime, lsLocalTime.wDay)) to dtLocalTime
70072>>>>>                    Move (DateSetHour(dtLocalTime, lsLocalTime.wHour)) to dtLocalTime
70073>>>>>                    Move (DateSetMinute(dtLocalTime, lsLocalTime.wMinute)) to dtLocalTime
70074>>>>>                    Move (DateSetSecond(dtLocalTime, lsLocalTime.wSecond)) to dtLocalTime
70075>>>>>                    Move (DateSetMillisecond(dtLocalTime, lsLocalTime.wMillieseconds)) to dtLocalTime
70076>>>>>                End
70076>>>>>>
70076>>>>>            End
70076>>>>>>
70076>>>>>        End
70076>>>>>>
70076>>>>>        Function_Return dtLocalTime
70077>>>>>    End_Function
70078>>>>>
70078>>>>>    // Returns the filename with full path where the casing is preserved from windows.
70078>>>>>    Function FilePreservedFilename String sFilename Returns String
70080>>>>>        Integer iNumOfDirectories iCurrentDirectory
70080>>>>>        String sPreservedFilename sCurDir sSearchName
70080>>>>>        tsSearchResult[] lsSearchResult
70080>>>>>        tsSearchResult[] lsSearchResult
70081>>>>>
70081>>>>>        Get CountOfFields sFilename "\" to iNumOfDirectories
70082>>>>>        For iCurrentDirectory from 1 to (iNumOfDirectories - 1)
70088>>>>>>
70088>>>>>            Get FieldAtIndex sFilename iCurrentDirectory "\" to sCurDir
70089>>>>>            If (sCurDir <> "") Begin
70091>>>>>                If (Right(sCurDir, 1) <> ":") Begin
70093>>>>>                    Move (sPreservedFilename + sCurDir) to sSearchName
70094>>>>>                    Get FileSearch sSearchName DIRMODE_DIRECTORIES_ONLY to lsSearchResult
70095>>>>>                    If (SizeOfArray(lsSearchResult) > 0) Begin
70097>>>>>                        Move (sPreservedFilename + lsSearchResult[0].sFilename + "\") to sPreservedFilename
70098>>>>>                    End
70098>>>>>>
70098>>>>>                    Else Begin
70099>>>>>                        Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
70100>>>>>                    End
70100>>>>>>
70100>>>>>                End
70100>>>>>>
70100>>>>>                Else Begin
70101>>>>>                    Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
70102>>>>>                End
70102>>>>>>
70102>>>>>            End
70102>>>>>>
70102>>>>>            Else Begin
70103>>>>>                Move (sPreservedFilename + "\") to sPreservedFilename
70104>>>>>            End
70104>>>>>>
70104>>>>>        Loop
70105>>>>>>
70105>>>>>        Get FileSearch sFilename DIRMODE_FILES_AND_DIRECTORIES to lsSearchResult
70106>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
70108>>>>>            Move (sPreservedFilename + lsSearchResult[0].sFilename) to sPreservedFilename
70109>>>>>        End
70109>>>>>>
70109>>>>>        Else Begin
70110>>>>>            Function_Return ""
70111>>>>>        End
70111>>>>>>
70111>>>>>        Function_Return sPreservedFilename
70112>>>>>    End_Function
70113>>>>>
70113>>>>>    // Returns the number of fields present in a string of fields seperated by a delimiter.
70113>>>>>    // If sDelimiter is not applied the ";" will be used.
70113>>>>>    Function CountOfFields String sFields String sDelimiter Returns Integer
70115>>>>>        Integer iChar icChar iField
70115>>>>>        String sDlm
70115>>>>>        If (sFields ="") Begin
70117>>>>>            Function_Return 0
70118>>>>>        End
70118>>>>>>
70118>>>>>        If (num_arguments > 1) Begin
70120>>>>>            Move sDelimiter to sDlm
70121>>>>>        End
70121>>>>>>
70121>>>>>        Else Begin
70122>>>>>            Move ";" to sDlm
70123>>>>>        End
70123>>>>>>
70123>>>>>        Move (Length(sFields) -1) to icChar
70124>>>>>        For iChar from 1 to icChar
70130>>>>>>
70130>>>>>            If (Mid(sFields, 1, iChar) = sDlm) Begin
70132>>>>>                Increment iField
70133>>>>>            End
70133>>>>>>
70133>>>>>        Loop
70134>>>>>>
70134>>>>>        Function_Return (iField +1)
70135>>>>>    End_Function
70136>>>>>
70136>>>>>    // Returns a field from a string containing multiple delimited fields.
70136>>>>>    // Index is 1-based.
70136>>>>>    Function FieldAtIndex String sFields Integer iIndex String sDelimiter Returns String
70138>>>>>        Integer iField iPos
70138>>>>>        String sField sDlm
70138>>>>>        If (num_arguments > 2) Begin
70140>>>>>            Move sDelimiter to sDlm
70141>>>>>        End
70141>>>>>>
70141>>>>>        Else Begin
70142>>>>>            Move ";" to sDlm
70143>>>>>        End
70143>>>>>>
70143>>>>>        Move (sFields + sDlm) to sFields
70144>>>>>        For iField from 1 to iIndex
70150>>>>>>
70150>>>>>            Move (Pos(sDlm, sFields)) to iPos
70151>>>>>            If iPos Begin
70153>>>>>                Move (Left(sFields, iPos -1)) to sField
70154>>>>>                Move (Right(sFields, Length(sFields) -iPos)) to sFields
70155>>>>>            End
70155>>>>>>
70155>>>>>            Else Begin
70156>>>>>                Function_Return ""
70157>>>>>            End
70157>>>>>>
70157>>>>>        Loop
70158>>>>>>
70158>>>>>        Function_Return sField
70159>>>>>    End_Function
70160>>>>>
70160>>>>>    // Removes the file extention from the sFile string and returns the extention including "."
70160>>>>>    // Example sFile = "x:\text.txt". The function returns ".txt" and sFile = "x:\text".
70160>>>>>    Function RemoveExtention String ByRef sFilename Returns String
70162>>>>>        String sExtention
70162>>>>>        Integer iLengthExtention
70162>>>>>        Get FileExtention sFilename to sExtention
70163>>>>>        Move (Length(sExtention)) to iLengthExtention
70164>>>>>        If (iLengthExtention > 0) Begin
70166>>>>>            Move (Left(sFilename, (Length(sFilename) - iLengthExtention - 1))) to sFilename
70167>>>>>        End
70167>>>>>>
70167>>>>>        Function_Return sExtention
70168>>>>>    End_Function
70169>>>>>
70169>>>>>    // Add a directory separator if it is not present.
70169>>>>>    // Example sFoldername = "x:\FolderA". The function returns "x:\FolderA\"
70169>>>>>    Function AddFolderSeperator String sFolderName Returns String
70171>>>>>        String sDirSep
70171>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
70172>>>>>        Move (Trim(sFolderName)) to sFolderName
70173>>>>>        If (Right(sFolderName, 1) <> sDirSep) Begin
70175>>>>>            Move (sFolderName + sDirSep) to sFolderName
70176>>>>>        End
70176>>>>>>
70176>>>>>        Function_Return sFolderName
70177>>>>>    End_Function
70178>>>>>
70178>>>>>    // Removes a directory separator if it is present.
70178>>>>>    // Example sFoldername = "x:\FolderA\". The function returns "x:\FolderA"
70178>>>>>    Function RemoveFolderSeperator String sFolderName Returns String
70180>>>>>        String sDirSep
70180>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
70181>>>>>        Move (Trim(sFolderName)) to sFolderName
70182>>>>>        If (Right(sFolderName, 1) = sDirSep) Begin
70184>>>>>            Move (Left(sFolderName, Length(sFolderName) - 1)) to sFolderName
70185>>>>>        End
70185>>>>>>
70185>>>>>        Function_Return sFolderName
70186>>>>>    End_Function
70187>>>>>
70187>>>>>    Function FileLastWriteTime String sFileName Returns tFileTime
70189>>>>>        DWord dwAccess
70189>>>>>        DWord dwShared
70189>>>>>        DWord dwCreate
70189>>>>>        Handle hFile
70189>>>>>        Integer iRetval iErrorNumber
70189>>>>>        tFileTime ftLastWrite
70189>>>>>        tFileTime ftLastWrite
70189>>>>>        //
70189>>>>>        Append sFilename (Character(0)) (Character(0))
70191>>>>>        Move (GENERIC_READ iOr GENERIC_WRITE) To dwAccess
70192>>>>>        Move FILE_SHARE_RANDOM   To dwShared
70193>>>>>        Move OPEN_EXISTING       To dwCreate
70194>>>>>
70194>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) To hFile
70195>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
70197>>>>>            Move (fsGetLastError()) To iErrorNumber
70198>>>>>            If iErrorNumber Begin
70200>>>>>                Send DoShowError iErrorNumber sFileName
70201>>>>>            End
70201>>>>>>
70201>>>>>            Procedure_Return
70202>>>>>        End
70202>>>>>>
70202>>>>>        Else Begin
70203>>>>>            Move 0 To ftLastWrite.dwLowDateTime
70204>>>>>            Move (fsGetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) To iRetval
70205>>>>>            If (iRetVal = 0) Begin           //Could not close
70207>>>>>                Move (fsGetLastError()) To iErrorNumber
70208>>>>>                If iErrorNumber Begin
70210>>>>>                    Send DoShowError iErrorNumber sFileName
70211>>>>>                End
70211>>>>>>
70211>>>>>            End
70211>>>>>>
70211>>>>>            Move (fsCloseHandle(hFile)) To iRetVal
70212>>>>>            If (iRetVal = 0) Begin           //Could not close
70214>>>>>                Move (fsGetLastError()) To iErrorNumber
70215>>>>>                If iErrorNumber Begin
70217>>>>>                    Send DoShowError iErrorNumber sFileName
70218>>>>>                End
70218>>>>>>
70218>>>>>            End
70218>>>>>>
70218>>>>>        End
70218>>>>>>
70218>>>>>        Function_Return ftLastWrite
70219>>>>>    End_Function
70220>>>>>
70220>>>>>    Function CurrentSystemTimeAsFileTime Returns tFileTime
70222>>>>>        Integer iRetVal
70222>>>>>        Integer iErrorNumber
70222>>>>>        String  sFileName
70222>>>>>        tFileTime ftCurrentTime
70222>>>>>        tFileTime ftCurrentTime
70222>>>>>
70222>>>>>        Move 0 to ftCurrentTime.dwLowDateTime
70223>>>>>        Move (fsGetSystemTimeAsFileTime(AddressOf(ftCurrentTime))) to iRetVal
70224>>>>>        If (iRetVal = 0) Begin
70226>>>>>            Move (fsGetLastError()) to iErrorNumber
70227>>>>>            If iErrorNumber Begin
70229>>>>>                Send DoShowError iErrorNumber sFileName
70230>>>>>            End
70230>>>>>>
70230>>>>>        End
70230>>>>>>
70230>>>>>        Function_Return ftCurrentTime
70231>>>>>    End_Function
70232>>>>>
70232>>>>>    // Nils 2018-08-30 Added this message from Akefs.pkg as we need it For the
70232>>>>>    // SourceCodeTools project
70232>>>>>    Procedure Set FileLastWriteTime String sFileName tFileTime ftLastWrite
70234>>>>>        DWord dwAccess dwShared dwCreate
70234>>>>>        Handle hFile
70234>>>>>        Integer iRetval iErrorNumber
70234>>>>>
70234>>>>>        Append sFilename (Character(0)) (Character(0))
70236>>>>>        Move (GENERIC_READ ior GENERIC_WRITE) to dwAccess
70237>>>>>        Move FILE_SHARE_RANDOM   to dwShared
70238>>>>>        Move OPEN_EXISTING       to dwCreate
70239>>>>>
70239>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) to hFile
70240>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
70242>>>>>            Move (fsGetLastError()) to iErrorNumber
70243>>>>>            If (iErrorNumber <> 0) Begin
70245>>>>>                Send DoShowError iErrorNumber sFileName
70246>>>>>            End
70246>>>>>>
70246>>>>>            Procedure_Return
70247>>>>>        End
70247>>>>>>
70247>>>>>        Else Begin
70248>>>>>            Move (fsSetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) to iRetval
70249>>>>>            If (iRetVal = 0) Begin           //Could not close
70251>>>>>                Move (fsGetLastError()) to iErrorNumber
70252>>>>>                If (iErrorNumber <> 0) Begin
70254>>>>>                    Send DoShowError iErrorNumber sFileName
70255>>>>>                End
70255>>>>>>
70255>>>>>            End
70255>>>>>>
70255>>>>>            Move (fsCloseHandle(hFile)) to iRetVal
70256>>>>>            If (iRetVal = 0) Begin           //Could not close
70258>>>>>                Move (fsGetLastError()) to iErrorNumber
70259>>>>>                If (iErrorNumber <> 0) Begin
70261>>>>>                    Send DoShowError iErrorNumber sFileName
70262>>>>>                End
70262>>>>>>
70262>>>>>            End
70262>>>>>>
70262>>>>>        End
70262>>>>>>
70262>>>>>    End_Procedure
70263>>>>>
70263>>>>>    // Fetch the error message from the system message table using the default language.
70263>>>>>    // If not in unicode then the variable sAppendErrorText is in ANSI
70263>>>>>    Procedure DoShowError Integer iErrorNumber String sAppendErrorText
70265>>>>>        Pointer lpOut
70265>>>>>        Integer iRetChars iRetVal
70265>>>>>        String sMsg
70265>>>>>        Boolean bOk
70265>>>>>
70265>>>>>        Move 0 to lpOut
70266>>>>>        Move (fsFormatMessage((FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS+FORMAT_MESSAGE_ALLOCATE_BUFFER), FNULL, iErrorNumber, FNULL, AddressOf(lpOut), 0, FNULL)) to iRetChars
70267>>>>>        If (iRetChars > 0) Begin
70269>>>>>            Move (ZeroString(iRetChars)) to sMsg
70270>>>>>            Move (MemCopy(AddressOf(sMsg), lpOut, iRetChars)) to bOk
70271>>>>>            Move (fsLocalFree(lpOut)) to iRetVal
70272>>>>>            Move (ToOEM(sMsg)) To sMsg
70273>>>>>            Move (ToOEM(sAppendErrorText)) To sAppendErrorText
70274>>>>>            If (num_arguments > 0) Begin
70276>>>>>                Move (Trim(sAppendErrorText)) to sAppendErrorText
70277>>>>>                If (sAppendErrorText <> "") Begin
70279>>>>>                    Append sMsg "\n" sAppendErrorText
70281>>>>>                End
70281>>>>>>
70281>>>>>            End
70281>>>>>>
70281>>>>>            Send warning_box sMsg
70282>>>>>        End
70282>>>>>>
70282>>>>>    End_Procedure
70283>>>>>
70283>>>>>    // Shows a warning message to user with OK button and a exclamation icon.
70283>>>>>    // private
70283>>>>>    Procedure Warning_Box String sWngMsg
70285>>>>>        Integer iVoid
70285>>>>>        Boolean bSendVdfError
70285>>>>>        Set pbError to True
70286>>>>>        Get pbErrorAsVDFError to bSendVdfError
70287>>>>>        If (bSendVdfError = False) Begin
70289>>>>>            Get Message_Box sWngMsg "Filesystem Error" MB_OK MB_ICONEXCLAMATION to iVoid
70290>>>>>        End
70290>>>>>>
70290>>>>>        Else Begin
70291>>>>>            Error DFERR_PROGRAM sWngMsg
70292>>>>>>
70292>>>>>        End
70292>>>>>>
70292>>>>>    End_Procedure
70293>>>>>
70293>>>>>    // Fetch the filename from the list of filenames associated with a filenumber.
70293>>>>>    // This function is used For reporting filenames during an error.
70293>>>>>    // private
70293>>>>>    Function FileErrorText Integer iFilenumber Returns String
70295>>>>>        String sErrorText
70295>>>>>        structFile[] lsFile
70295>>>>>        structFile[] lsFile
70296>>>>>        Get plsFile to lsFile
70297>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
70299>>>>>            Move ("File: "+lsFile[iFilenumber].sFilename) to sErrorText
70300>>>>>        End
70300>>>>>>
70300>>>>>        Function_Return sErrorText
70301>>>>>    End_Function
70302>>>>>
70302>>>>>End_Class
70303>>>
70303>>>Enum_List
70303>>>    Define cx_RegKeyAlreadyExist
70303>>>    Define cx_RegKeyCreated
70303>>>    Define cx_RegkeyFailed
70303>>>    Define cx_RegKeyDFKeyDoesNotExist
70303>>>    Define cx_InstalledOkDFUnder16
70303>>>End_Enum_List
70303>>>
70303>>>Enum_List
70303>>>    Define CI_LeftExpression
70303>>>    Define CI_CommandExpression
70303>>>    Define CI_OfExpression
70303>>>    Define CI_ToTexpression
70303>>>End_Enum_List
70303>>>
70303>>>Struct tWorkspace
70303>>>    String sWorkspace
70303>>>    String sWorkspaceFull    
70303>>>End_Struct
70303>>>
70303>>>Struct tRefactorCheckbox
70303>>>    Handle hObject
70303>>>    Boolean bChecked
70303>>>    Boolean bReportFunction
70303>>>    Integer iRefactorFunction
70303>>>End_Struct
70303>>>
70303>>>Struct tRefactorSettings
70303>>>    Integer iSelectedStandardFunctions  // Are called for each source line.
70303>>>    Integer iSelectedRemoveFunctions    // Are called for each source line. May remove the source line. Returns True if line should be removed
70303>>>    Integer iSelectedEditorFunctions    // Using the Scintilla Editor. A Full source file is passed.
70303>>>    Integer iSelectedReportFunctions    // Makes no source changes. A full source file is passed.
70303>>>    Integer iSelectedReportAllFunctions // Makes no source changes. All selected files are passed as a string array (including path).
70303>>>    Integer iSelectedOtherFunctions     // A full source file is passed to functions as a string array.
70303>>>    Integer iSelectedOtherAllFunctions  // All selected files are passed as a string array (including path).
70303>>>    //
70303>>>    Integer iSelectedLineByLineFunctions  // Sum of all line-by-line action functions (not full file or report functions).
70303>>>    Integer iSelectedFullFileFunctions  // Sum of all functions that should be feed with a string array of _one_ source file.
70303>>>    Integer iSelectedAllFilesFunctions  // All functions that should be feed with a string array with all selected files (including path).
70303>>>    //
70303>>>    Boolean bCountSourceLines           // If we should only count source lines (all other functions will be ignored).
70303>>>    Boolean bEditorDropSelf             // Scintilla Editor special function that pops up a dialog before each change(!).
70303>>>    //
70303>>>    String  sFileFilter                 // File selection filter.
70303>>>    String[] asFolderNames              // String array with full path to all selected folders.
70303>>>End_Struct                   
70303>>>
70303>>>Struct tParseObject
70303>>>    String sObject
70303>>>    String sObjectLabel  // short name
70303>>>    String sClass
70303>>>    Handle pElement
70303>>>End_Struct
70303>>>
70303>>>Struct tCJComboBoxContent
70303>>>    String sText
70303>>>    Integer eTheme
70303>>>End_Struct
70303>>>
70303>>>Struct tBackupFiles
70303>>>    String sFileName
70303>>>    String sPath
70303>>>    DateTime dtFileDate
70303>>>End_Struct
70303>>>
70303>>>Struct tCodeComponents
70303>>>    String sIndentation
70303>>>    String sLineStartIndicator
70303>>>    String sLineEndIndicator
70303>>>    Boolean bHasIndicateCommand
70303>>>    String sLeftCommand
70303>>>    String sCode   
70303>>>    String sOfStatement   
70303>>>    String sToStatement
70303>>>    String sRightComment 
70303>>>    Boolean bHasEndSemiColon   
70303>>>End_Struct 
70303>>>
70303>>>Struct tBooleanIndicator
70303>>>    Boolean bHasBracket  
70303>>>    Boolean bHasNot
70303>>>    String sExpression
70303>>>    String sCode
70303>>>End_Struct        
70303>>>
70303>>>Struct tOperatorsInfo
70303>>>    Boolean bIsOperator
70303>>>    Boolean bIsLegacy
70303>>>    Integer iPos
70303>>>    String  sOperator
70303>>>End_Struct
70303>>>
70303>>>    Define clGreenGrey              for (RGB(64, 84, 93))
70303>>>    Define clGreenGreyLight         for (RGB(7, 117, 104))
70303>>>Define clDarkGreen                  for (RGB(49, 60, 83))
70303>>>
70303>>>Define CPC_OpenFile                 for 1 // perfcounter on open file
70303>>>Define CS_Settings                  for "Settings"
70303>>>Define CS_GridFontSize              for "GridFontSize"
70303>>>Define CS_StarZenSourceExplorer     for "StarZenSourceExplorer"
70303>>>Define CS_FileCompareProgram        for "FileCompareProgram"
70303>>>Define CS_ToolbarIconSize           for "ToolbarIconSize"
70303>>>Define CS_GridRowBackgroundColor    for "GridRowBackgroundColor"
70303>>>Define CS_MaxBlankLineSize          for "MaxBlankLineSize"
70303>>>Define CS_SplitByPreference         for "SplitByPreference"
70303>>>Define CS_DataFlexVersionText       for "DataFlex Version:"
70303>>>Define CS_SelectWorkspaceText       for "Select Workspace:"
70303>>>Define CS_CurrentWorkspaceText      for "Current Workspace:"
70303>>>Define CS_WorkspacesKey             for "Workspaces"
70303>>>Define CS_WorkspacePaths            for "WorkspacePaths"
70303>>>Define CS_ConfigFile                for "ConfigFile"
70303>>>Define CS_WorkspaceRecentKey        for "Recent"
70303>>>Define CS_PropertiesKeyWord         for "Properties"
70303>>>Define CS_ThemeKeyWord              for "Theme"
70303>>>Define CS_VersionKeyWord            for "Version"
70303>>>Define CS_OpenWorkspace             for "Select &Workspace"
70303>>>//Define CS_OpenWorkspace             for "Open &Workspace"
70303>>>Define CS_CurrentWorkspace          for "Current &Workspace:"
70303>>>Define CS_NoActiveWorkspaceText     for ""
70303>>>Define CS_SelectWorkspaceFile       for "Select a DataFlex workspace project file (*.sws)"
70303>>>Define CS_BrowseSourceFileTxt       for "Select File:"
70303>>>Define CS_CurrentSourceFileTxt      for "Current File:"
70303>>>Define CS_NoActiveSourceFileText    for "" 
70303>>>Define CS_NoWorkspaceSelected       for "- None"
70303>>>Define CS_WorkspaceFilterString     for "DataFlex Workspace Files (*.sws)|*.sws|Any file (*.*)|*.*"
70303>>>Define CS_OpenFileStdFilter         for "All files *.*|*.*|Programs *.src|*.src|Views *.vw|*.vw|Report Views *.rv|*.rv|Selection Lists *.sl|*.sl|Packages *.pkg|*.pkg"
70303>>>Define CS_SourceCodeFilters         for "DataFlex Source *.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu|*.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu"
70303>>>Define CS_SourceFileFilters         for "Programs|*.src|Views|*.vw|Dialogs|*.dg|Data Dictionaries|*.dd|Include files|*.inc|Report Views|*.rv|Selection Lists|*.sl|Packages|*.pkg|Business Processes|*.bp|Menus|*.mn|Header Files|*.h|Sture's Files|*.nui;*.utl|Any file|*.*"
70303>>>Define CS_CreateBackupFiles         for "CreateBackupFiles"
70303>>>Define CS_SummaryLogfileName        for "DFRefactoringLogFile.txt"
70303>>>
70303>>>Define CS_VarTypes                  for "STRING;INTEGER;NUMBER;DATE;DATETIME;BOOLEAN;HANDLE;REAL;VARIANT;TIMESPAN;ROWID;DECIMAL;BIGINT;REAL;UCHAR;ADDRESS;CHAR;CURRENCY;DWORD;FLOAT;POINTER;SHORT;TIME;UBIGINT;USHORT" // careful, cannot end on a semicolumn as you will introduce variable type equal to ""
70303>>>Define CS_VarArrayTypes             for "STRING[];INTEGER[];NUMBER[];DATE[];DATETIME[];BOOLEAN[];HANDLE[];REAL[];VARIANT[];TIMESPAN[];ROWID[];DECIMAL[];BIGINT[];REAL[];UCHAR[];ADDRESS[];CHAR[];CURRENCY[];DWORD[];FLOAT[];POINTER[];SHORT[];TIME[];UBIGINT[];USHORT[];STRING[][];INTEGER[][];NUMBER[][];DATE[][];DATETIME[][];BOOLEAN[][];HANDLE[][];REAL[][];VARIANT[][];TIMESPAN[][];ROWID[][];DECIMAL[][];BIGINT[][];REAL[][];UCHAR[][];ADDRESS[][];CHAR[][];CURRENCY[][];DWORD[][];FLOAT[][];POINTER[][];SHORT[][];TIME[][];UBIGINT[][];USHORT[][]"
70303>>>Define CS_ValidLeftCharacters       for ("()[];,&+-*<>= " + Character(9)) // Character 9=tab char //"()[];,.&+-*<>= "
70303>>>
70303>>>Define CS_UnusedSourceLogFile       for "UnusedSourceFiles.txt"
70303>>>Define CS_CommentSymbol             for ("/"+"/")
70303>>>Define CS_ImageNameStart            for "/"
70303>>>Define CS_ImageNameEnd              for "/*"
70303>>>Define CS_StudioToolsPathStart      for "Software\Data Access Worldwide\DataFlex Tools\"
70303>>>Define CS_StudioToolsPathEnd        for "\Studio\Preferences\File Extensions"
70303>>>Define CS_StudioCodeEditorPath      for "\Studio\Code-Editor"
70303>>>Define CS_StudioFontName            for "FontName"
70303>>>Define CS_StudioFontSize            for "FontSize"
70303>>>Define CS_StudioExpandTabs          for "ExpandTabs"
70303>>>Define CS_StudioIndentStyle         for "IndentStyle"
70303>>>Define CS_StudioTabSize             for "TabSize"
70303>>>Define CS_StudioEditorSettingsStart for "DataFlex Studio"
70303>>>Define CS_StudioEditorSettingsEnd   for "Code Editor Settings"
70303>>>Define CS_StudioEditorSettingsExtra for "(Will be applied when indenting code)"
70303>>>Define CS_IdleText                  for "Idle..."
70303>>>Define CS_WorkingText               for "Working..."
70303>>>Define CS_ReadyText                 for "Ready!"
70303>>>
70303>>>Define CS_Default_Dialog_Caption    for "Select a source file"
70303>>>Define CS_Folder_Dialog_Caption     for "Select a Filename - Only the foldername will be returned"
70303>>>Define CS_Default_Filter_String     for "All Files *.*|*.*|Programs *.src|*.src|Views *.vw|*.vw|Report Views *.rv|*.rv|Selection Lists *.sl|*.sl|Packages *.pkg|*.pkg"
70303>>>Define CS_Folder_Filter_String      for "All files|*.*"
70303>>>
70303>>>Define CS_BackupFolder              for "DFRefactor Backup"
70303>>>Define CS_NoFolderList              for (".|..|.svn|.git|.hg|apphtml|data|bitmaps|help|idesrc|programs|.cab|install")
70303>>>//Define CS_NoFolderList              for (".|..|.svn|.git|.hg|apphtml|data|bitmaps|help|idesrc|programs|.cab|install" + "|" + CS_BackupFolder)
70303>>>Define CS_DefaultSourceFolders      for "appsrc|ddsrc|libraries|pkg"
70303>>>Define CS_LF                        for (Character(10))
70303>>>Define CS_CR                        for (Character(13))
70303>>>Define CS_CRLF                      for (Character(13) + Character(10))
70303>>>Define CS_DirSeparator              for (SysConf(SYSCONF_DIR_SEPARATOR))
70303>>>Define CI_EOL                       for 2048
70303>>>
70303>>>
70303>>>// Note: the "Visual" will automatically be replace if a more recent DF version is used.
70303>>>Define CS_StudioPath                for "Software\Data Access Worldwide\Visual DataFlex Tools\"
70303>>>Define CS_StudioPathEnd             for  "\Studio\Preferences\File Extensions"
70303>>>Define CS_WebFileExtensions         for ".wo;.html;.asa;.asp;.css;.js"
70303>>>Define CS_StdExtensions             for "*.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu"
70303>>>Define CS_DFAndTemplExt             for "*.src;*.vw;*.sl;*.dg;*.rv;*.bp;*.pkg;*.wo;*.dd;*.inc;*.dfo;*.tpl"
70303>>>Define CS_DDDEFExt                  for "*.dd"
70303>>>Define CS_PkgIncExt                 for "*.pkg;*.inc;*.mac"
70303>>>Define CS_SrcPkgExt                 for "*.src;*.pkg"
70303>>>Define CS_AllExt                    for "*.*"
70303>>>Define CS_DFExtensionsKey           for "DFExtension"
70303>>>
70303>>>Define CS_DFCOMProxyClasses         for "DataFlex COM proxy classes generated from"
70303>>>Define CS_ProjectObjectStructure    for "Project Object Structure"
70303>>>Define CS_RegisterAllObjects        for "Register all objects"
70303>>>Define CS_RegisterObject            for "Register_Object "
70303>>>
70303>>>// Special function names:
70303>>>Define CS_CountSourceLines              for "CountSourceLines"
70303>>>Define CS_EditorReIndent                for "EditorReIndent"
70303>>>Define CS_EditorDropSelf                for "EditorDropSelf"
70303>>>Define CS_RemoveProjectObjectStructure  for "RemoveProjectObjectStructure"
70303>>>//Define CS_RemoveBlankLines              for "RemoveBlankLines"
70303>>>Define CS_UnusedSourceFiles             for "ReportUnusedSourceFiles"
70303>>>
70303>>>// Refactor Testing program:
70303>>>Define CS_Compiler       for "DFComp.exe"
70303>>>Define CS_TestProgram    for "CompiledRefactoredCode.src"
70303>>>Define CS_TestErrFile    for "CompiledRefactoredCode.err"
70303>>>Define CS_CompOptions    for "-e3fv2i0"     
70303>>>Define CS_SWSFile        for "DFRefactor19.1.sws"
70303>>>Define CS_DFUnitTest     for "DFUnit_TestRunner"
70303>>>Define CS_DFRefactor     for "DFRefactor"
70303>>>Define CS_LegacyCode     for "LegacyCode.pkg"
70303>>>Define CS_RefactoredCode for "RefactoredCode.pkg"
70303>>>
70303>>>// Refactor Testing program:
70303>>>Define CS_Trim           for "Trim"    
70303>>>Define CS_Length         for "Length"  
70303>>>Define CS_Pos            for "Pos"   
70303>>>Define CS_Replace        for "Replace"
70303>>>Define CS_In             for "In" 
70303>>>Define CS_If             for "If"   
70303>>>Define CS_Else           for "Else"
70303>>>Define CS_Begin          for "Begin"
70303>>>Define CS_With           for "With" 
70303>>>Define CS_At             for "At"   
70303>>>Define CS_As             for "As"  
70303>>>Define CS_To             for "to"
70303>>>Define CS_Of             for "of"
70303>>>Define CS_ZeroString     for "ZeroString"  
70303>>>Define CS_Insert         for "Insert" 
70303>>>Define CS_Repeat         for "Repeat"
70303>>>Define CS_While          for "While" 
70303>>>Define CS_Loop           for "Loop"
70303>>>Define CS_Current_Object for "Current_Object"
70303>>>Define CS_Self           for "Self"
70303>>>Define CS_Move           for "Move"
70303>>>Define CS_Indicate       for "Indicate"  
70303>>>Define CS_Not            for "Not"
70303>>>Define CS_True           for "True"   
70303>>>Define CS_False          for "False"
70303>>>Define CS_DfTrue         for "DfTrue"
70303>>>Define CS_DfFalse        for "DfFalse"
70303>>>Define CS_Set            for "Set"
70303>>>Define CS_Get            for "Get"
70303>>>Define CS_Enabled_State  for "Enabled_State" 
70303>>>Define CS_Find           for "Find"   
70303>>>Define CS_Send           for "Send"
70303>>>Define CS_Found          for "Found"
70303>>>Define CS_Finderr        for "Finderr"
70303>>>Define CS_Sysdate4       for "Sysdate4"
70303>>>Define CS_Constrain      for "Constrain"
70303>>>Define CS_Until          for "Until"
70303>>>Define CS_Local          for "Local"
70303>>>Define CS_GetAddress     for "GetAddress" 
70303>>>Define CS_AddressOf      for "AddressOf"
70303>>>Define CS_Function       for "Function"
70303>>>Define CS_Contains       for "contains"
70303>>>Define CS_Select         for "[Select]"
70303>>>
70303>>>// cRegex Expression Constants:
70303>>>//
70303>
70303>Object oHtmlHelp is a cHtmlHelp
70305>    Set pbAlwaysOnTop to False
70306>End_Object
70307>
70307>// Dummy messages that are called from the toolbars; in case they
70307>// doesn't exist in a view. This avoids runtime errors.
70307>Function pbShouldSave Desktop Returns Boolean
70309>    Function_Return False
70310>End_Function
70311>
70311>Function BackupFile Desktop Returns String
70313>    Function_Return ""
70314>End_Function
70315>
70315>Procedure OpenSourceFile Desktop
70317>End_Procedure
70318>
70318>Procedure Compare Desktop String sCompareApp
70320>End_Procedure
70321>
70321>Procedure OnWorkspaceLoaded Desktop
70323>End_Procedure
70324>
70324>Procedure LoadFile Desktop String sFileName
70326>End_Procedure
70327>
70327>External_Function GetACP "GetACP" kernel32.dll Returns Integer
70328>Register_Procedure DoChangeFontSize
70328>
70328>Enum_List
70328>    Define CI_CleanupSource
70328>    Define CI_CodeIndenter
70328>End_Enum_List
70328>
70328>// Needs to be _before_ the cApplication object as we refer to it there.
70328>// However, the package itself must be Used _after_ the ghoApplication object,
70328>// as it contains references to the phoWorkspace property. (Kind of catch 22).
70328>Global_Variable Integer ghoEditorProperties
70328>
70328>Use cRefactorApplication.pkg
Including file: cRefactorApplication.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorApplication.pkg)
70328>>>Use cApplication.pkg
70328>>>Use cIniFile.pkg
70328>>>Use cCJCommandBarSystem.pkg
70328>>>Use gFormatNumbers.pkg
70328>>>Use vwin32fh.pkg          
70328>>>Use cFilesystem.pkg
70328>>>Use RefactorFunctionConstants.inc
70328>>>Use DeleteWorkspaceHistory.dg
Including file: DeleteWorkspaceHistory.dg    (C:\Projects\DF18\DfRefactor\AppSrc\DeleteWorkspaceHistory.dg)
70328>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\cRDCModalPanel.pkg)
70328>>>>>>>//****************************************************************************
70328>>>>>>>// $Module type: Class
70328>>>>>>>// $Module name: cRDCModalPanel
70328>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
70328>>>>>>>// Created     : 2014-03-17 @ 12:33
70328>>>>>>>//
70328>>>>>>>// Description :
70328>>>>>>>//
70328>>>>>>>// $Rev History:
70328>>>>>>>//    2014-03-17  Module header created
70328>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70328>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70328>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70328>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70328>>>>>>>// in the help folder for more details.
70328>>>>>>>//
70328>>>>>>>//****************************************************************************
70328>>>>>>>Use Windows.pkg
70328>>>>>>>Use cCJCommandBarSystem.pkg   
70328>>>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJSkinFramework.pkg)
70328>>>>>>>>>Use windows.pkg
70328>>>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJComSkinFramework.pkg)
70328>>>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.SkinFramework.v18.3.0.ocx
70328>>>>>>>>>>>Use FlexCom20.pkg
70328>>>>>>>>>>>
70328>>>>>>>>>>>// Changes to Imported package
70328>>>>>>>>>>>//     OLEXTPxx to XTPxx
70328>>>>>>>>>>>//     OLExtpxx to xtpxx
70328>>>>>>>>>>>//     OLESkinFramework to SkinFramework
70328>>>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
70328>>>>>>>>>>>//     cCom classes to cCJ
70328>>>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
70328>>>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
70328>>>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
70328>>>>>>>>>>>//     Use statements as noted below (classes moved to these files)
70328>>>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
70328>>>>>>>>>>>
70328>>>>>>>>>>>// These have been extracted from this class and moved into seperate packages
70328>>>>>>>>>>>// because other Codejock classes use these.
70328>>>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
70328>>>>>>>>>>>
70328>>>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
70328>>>>>>>>>>>    Define xtpSkinApplyMetrics for 1
70328>>>>>>>>>>>    Define xtpSkinApplyFrame for 2
70328>>>>>>>>>>>    Define xtpSkinApplyColors for 4
70328>>>>>>>>>>>    Define xtpSkinApplyMenus for 8
70328>>>>>>>>>>>
70328>>>>>>>>>>>// CLSID: {C0DE1830-28D7-4F2C-87A7-7266367B4655}
70328>>>>>>>>>>>// Dispatch interface for SkinFramework Control
70328>>>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
70329>>>>>>>>>>>
70329>>>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
70331>>>>>>>>>>>        SkinFrameworkApplyOptions retVal
70331>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
70332>>>>>>>>>>>        Function_Return retVal
70333>>>>>>>>>>>    End_Function
70334>>>>>>>>>>>
70334>>>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
70336>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
70337>>>>>>>>>>>    End_Procedure
70338>>>>>>>>>>>
70338>>>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
70340>>>>>>>>>>>        Boolean retVal
70340>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
70341>>>>>>>>>>>        Function_Return retVal
70342>>>>>>>>>>>    End_Function
70343>>>>>>>>>>>
70343>>>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
70345>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
70346>>>>>>>>>>>    End_Procedure
70347>>>>>>>>>>>
70347>>>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
70349>>>>>>>>>>>        Boolean retVal
70349>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
70350>>>>>>>>>>>        Function_Return retVal
70351>>>>>>>>>>>    End_Function
70352>>>>>>>>>>>
70352>>>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
70354>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
70355>>>>>>>>>>>    End_Procedure
70356>>>>>>>>>>>
70356>>>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
70358>>>>>>>>>>>        Handle hDispatchDriver
70358>>>>>>>>>>>        Boolean retVal
70358>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70359>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
70360>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
70361>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
70362>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
70363>>>>>>>>>>>        Function_Return retVal
70364>>>>>>>>>>>    End_Function
70365>>>>>>>>>>>
70365>>>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
70367>>>>>>>>>>>        Handle hDispatchDriver
70367>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70368>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70369>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
70370>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
70371>>>>>>>>>>>    End_Procedure
70372>>>>>>>>>>>
70372>>>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
70374>>>>>>>>>>>        Handle hDispatchDriver
70374>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70375>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
70376>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
70377>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
70378>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
70379>>>>>>>>>>>    End_Procedure
70380>>>>>>>>>>>
70380>>>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
70382>>>>>>>>>>>        Handle hDispatchDriver
70382>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70383>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70384>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
70385>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
70386>>>>>>>>>>>    End_Procedure
70387>>>>>>>>>>>
70387>>>>>>>>>>>    Procedure ComRemoveAllWindows
70389>>>>>>>>>>>        Handle hDispatchDriver
70389>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70390>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
70391>>>>>>>>>>>    End_Procedure
70392>>>>>>>>>>>
70392>>>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
70394>>>>>>>>>>>        Handle hDispatchDriver
70394>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70395>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
70396>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
70397>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
70398>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
70399>>>>>>>>>>>    End_Procedure
70400>>>>>>>>>>>
70400>>>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
70402>>>>>>>>>>>        Handle hDispatchDriver
70402>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70403>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70404>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
70405>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
70406>>>>>>>>>>>    End_Procedure
70407>>>>>>>>>>>
70407>>>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
70409>>>>>>>>>>>        Handle hDispatchDriver
70409>>>>>>>>>>>        Variant retVal
70409>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70410>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
70411>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
70412>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
70413>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
70414>>>>>>>>>>>        Function_Return retVal
70415>>>>>>>>>>>    End_Function
70416>>>>>>>>>>>
70416>>>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
70418>>>>>>>>>>>        Handle hDispatchDriver
70418>>>>>>>>>>>        Variant retVal
70418>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70419>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70420>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
70421>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
70422>>>>>>>>>>>        Function_Return retVal
70423>>>>>>>>>>>    End_Function
70424>>>>>>>>>>>
70424>>>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
70426>>>>>>>>>>>        Handle hDispatchDriver
70426>>>>>>>>>>>        OLE_COLOR retVal
70426>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70427>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70428>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70429>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
70430>>>>>>>>>>>        Function_Return retVal
70431>>>>>>>>>>>    End_Function
70432>>>>>>>>>>>
70432>>>>>>>>>>>    Procedure ComExcludeModule String llModuleName
70434>>>>>>>>>>>        Handle hDispatchDriver
70434>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70435>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70436>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
70437>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
70438>>>>>>>>>>>    End_Procedure
70439>>>>>>>>>>>
70439>>>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
70441>>>>>>>>>>>        Handle hDispatchDriver
70441>>>>>>>>>>>        Variant retVal
70441>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70442>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
70443>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
70444>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
70445>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
70446>>>>>>>>>>>        Function_Return retVal
70447>>>>>>>>>>>    End_Function
70448>>>>>>>>>>>
70448>>>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
70450>>>>>>>>>>>        Handle hDispatchDriver
70450>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70451>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
70452>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
70453>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
70454>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
70455>>>>>>>>>>>    End_Procedure
70456>>>>>>>>>>>
70456>>>>>>>>>>>    Procedure ComAboutBox
70458>>>>>>>>>>>        Handle hDispatchDriver
70458>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70459>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
70460>>>>>>>>>>>    End_Procedure
70461>>>>>>>>>>>End_Class
70462>>>>>>>>>>>
70462>>>>>>>>>>>// CLSID: {C0DE1830-4463-4030-B324-AC6A8075FEC8}
70462>>>>>>>>>>>// Event interface for SkinFramework Control
70462>>>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
70463>>>>>>>>>>>
70463>>>>>>>>>>>    Procedure RegisterComEvents
70465>>>>>>>>>>>    End_Procedure
70466>>>>>>>>>>>End_Class
70467>>>>>>>>>>>
70467>>>>>>>>>>>// CoClass
70467>>>>>>>>>>>// ProgID: Codejock.SkinFramework.18.3.0
70467>>>>>>>>>>>// CLSID: {C0DE1830-2217-42EE-B1B0-82C890431F17}
70467>>>>>>>>>>>// SkinFramework Control
70467>>>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
70468>>>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
70469>>>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
70470>>>>>>>>>>>
70470>>>>>>>>>>>    Procedure Construct_Object
70472>>>>>>>>>>>        Forward Send Construct_Object
70474>>>>>>>>>>>        Set psProgID to "{C0DE1830-2217-42EE-B1B0-82C890431F17}"
70475>>>>>>>>>>>        Set psEventId to "{C0DE1830-4463-4030-B324-AC6A8075FEC8}"
70476>>>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2018 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v18.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
70477>>>>>>>>>>>        Set peAutoCreate to acAutoCreate
70478>>>>>>>>>>>    End_Procedure
70479>>>>>>>>>>>End_Class
70480>>>>>>>>>>>
70480>>>>>>>>>>>// CLSID: {C0DE1830-CA9A-4AA9-8601-0AB7F551AA3D}
70480>>>>>>>>>>>// SkinFramework Global Settings
70480>>>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
70481>>>>>>>>>>>
70481>>>>>>>>>>>    Function ComLicense Returns String
70483>>>>>>>>>>>        String retVal
70483>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
70484>>>>>>>>>>>        Function_Return retVal
70485>>>>>>>>>>>    End_Function
70486>>>>>>>>>>>
70486>>>>>>>>>>>    Procedure Set ComLicense String value
70488>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
70489>>>>>>>>>>>    End_Procedure
70490>>>>>>>>>>>
70490>>>>>>>>>>>    Function ComTitle Returns String
70492>>>>>>>>>>>        String retVal
70492>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
70493>>>>>>>>>>>        Function_Return retVal
70494>>>>>>>>>>>    End_Function
70495>>>>>>>>>>>
70495>>>>>>>>>>>    Procedure Set ComTitle String value
70497>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
70498>>>>>>>>>>>    End_Procedure
70499>>>>>>>>>>>
70499>>>>>>>>>>>    Function ComVersion Returns String
70501>>>>>>>>>>>        Handle hDispatchDriver
70501>>>>>>>>>>>        String retVal
70501>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70502>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
70503>>>>>>>>>>>        Function_Return retVal
70504>>>>>>>>>>>    End_Function
70505>>>>>>>>>>>
70505>>>>>>>>>>>    Function ComUnicode Returns Boolean
70507>>>>>>>>>>>        Handle hDispatchDriver
70507>>>>>>>>>>>        Boolean retVal
70507>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70508>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
70509>>>>>>>>>>>        Function_Return retVal
70510>>>>>>>>>>>    End_Function
70511>>>>>>>>>>>
70511>>>>>>>>>>>    Function ComOcxPath Returns String
70513>>>>>>>>>>>        Handle hDispatchDriver
70513>>>>>>>>>>>        String retVal
70513>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70514>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
70515>>>>>>>>>>>        Function_Return retVal
70516>>>>>>>>>>>    End_Function
70517>>>>>>>>>>>End_Class
70518>>>>>>>>>>>
70518>>>>>>>>>>>// CoClass
70518>>>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.18.3.0
70518>>>>>>>>>>>// CLSID: {C0DE1830-F744-4373-B38D-29CE83EF0EE5}
70518>>>>>>>>>>>// SkinFramework Global Settings
70518>>>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
70519>>>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
70520>>>>>>>>>>>
70520>>>>>>>>>>>    Procedure Construct_Object
70522>>>>>>>>>>>        Forward Send Construct_Object
70524>>>>>>>>>>>        Set psProgID to "{C0DE1830-F744-4373-B38D-29CE83EF0EE5}"
70525>>>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
70526>>>>>>>>>>>    End_Procedure
70527>>>>>>>>>>>End_Class
70528>>>>>>>>>>>
70528>>>>>>>>>>>// CLSID: {C0DE1830-1038-498E-A936-361F08B4C4AA}
70528>>>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
70529>>>>>>>>>>>
70529>>>>>>>>>>>    Function ComColorScheme Returns String
70531>>>>>>>>>>>        String retVal
70531>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
70532>>>>>>>>>>>        Function_Return retVal
70533>>>>>>>>>>>    End_Function
70534>>>>>>>>>>>
70534>>>>>>>>>>>    Procedure Set ComColorScheme String value
70536>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
70537>>>>>>>>>>>    End_Procedure
70538>>>>>>>>>>>
70538>>>>>>>>>>>    Function ComFontSize Returns String
70540>>>>>>>>>>>        String retVal
70540>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
70541>>>>>>>>>>>        Function_Return retVal
70542>>>>>>>>>>>    End_Function
70543>>>>>>>>>>>
70543>>>>>>>>>>>    Procedure Set ComFontSize String value
70545>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
70546>>>>>>>>>>>    End_Procedure
70547>>>>>>>>>>>
70547>>>>>>>>>>>    Function ComIniFileName Returns String
70549>>>>>>>>>>>        String retVal
70549>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
70550>>>>>>>>>>>        Function_Return retVal
70551>>>>>>>>>>>    End_Function
70552>>>>>>>>>>>
70552>>>>>>>>>>>    Procedure Set ComIniFileName String value
70554>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
70555>>>>>>>>>>>    End_Procedure
70556>>>>>>>>>>>End_Class
70557>>>>>>>>>>>
70557>>>>>>>>>>>// CLSID: {C0DE1830-4834-499E-95B4-30E0C3F43A10}
70557>>>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
70558>>>>>>>>>>>
70558>>>>>>>>>>>    Function ComName Returns String
70560>>>>>>>>>>>        String retVal
70560>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
70561>>>>>>>>>>>        Function_Return retVal
70562>>>>>>>>>>>    End_Function
70563>>>>>>>>>>>
70563>>>>>>>>>>>    Procedure Set ComName String value
70565>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
70566>>>>>>>>>>>    End_Procedure
70567>>>>>>>>>>>
70567>>>>>>>>>>>    Function ComPath Returns String
70569>>>>>>>>>>>        String retVal
70569>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
70570>>>>>>>>>>>        Function_Return retVal
70571>>>>>>>>>>>    End_Function
70572>>>>>>>>>>>
70572>>>>>>>>>>>    Procedure Set ComPath String value
70574>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
70575>>>>>>>>>>>    End_Procedure
70576>>>>>>>>>>>
70576>>>>>>>>>>>    Function ComCount Returns Integer
70578>>>>>>>>>>>        Handle hDispatchDriver
70578>>>>>>>>>>>        Integer retVal
70578>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70579>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
70580>>>>>>>>>>>        Function_Return retVal
70581>>>>>>>>>>>    End_Function
70582>>>>>>>>>>>
70582>>>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
70584>>>>>>>>>>>        Handle hDispatchDriver
70584>>>>>>>>>>>        Variant retVal
70584>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70585>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70586>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70587>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
70588>>>>>>>>>>>        Function_Return retVal
70589>>>>>>>>>>>    End_Function
70590>>>>>>>>>>>
70590>>>>>>>>>>>    Function Com_NewEnum Returns Variant
70592>>>>>>>>>>>        Handle hDispatchDriver
70592>>>>>>>>>>>        Variant retVal
70592>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70593>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
70594>>>>>>>>>>>        Function_Return retVal
70595>>>>>>>>>>>    End_Function
70596>>>>>>>>>>>End_Class
70597>>>>>>>>>>>
70597>>>>>>>>>>>// CLSID: {C0DE1830-FB37-4B08-A2B9-F6F8B253D697}
70597>>>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
70598>>>>>>>>>>>
70598>>>>>>>>>>>    Function ComCount Returns Integer
70600>>>>>>>>>>>        Handle hDispatchDriver
70600>>>>>>>>>>>        Integer retVal
70600>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70601>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
70602>>>>>>>>>>>        Function_Return retVal
70603>>>>>>>>>>>    End_Function
70604>>>>>>>>>>>
70604>>>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
70606>>>>>>>>>>>        Handle hDispatchDriver
70606>>>>>>>>>>>        Variant retVal
70606>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70607>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70608>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70609>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
70610>>>>>>>>>>>        Function_Return retVal
70611>>>>>>>>>>>    End_Function
70612>>>>>>>>>>>
70612>>>>>>>>>>>    Function Com_NewEnum Returns Variant
70614>>>>>>>>>>>        Handle hDispatchDriver
70614>>>>>>>>>>>        Variant retVal
70614>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70615>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
70616>>>>>>>>>>>        Function_Return retVal
70617>>>>>>>>>>>    End_Function
70618>>>>>>>>>>>End_Class
70619>>>>>>>>>>>
70619>>>>>>>>>>>// CLSID: {C0DE1830-C56F-43C0-BCF1-8193B35FE4C4}
70619>>>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
70620>>>>>>>>>>>
70620>>>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
70622>>>>>>>>>>>        Handle hDispatchDriver
70622>>>>>>>>>>>        OLE_COLOR retVal
70622>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70623>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70624>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70625>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
70626>>>>>>>>>>>        Function_Return retVal
70627>>>>>>>>>>>    End_Function
70628>>>>>>>>>>>End_Class
70629>>>>>>>>>Use cApplication.pkg
70629>>>>>>>>>
70629>>>>>>>>>Struct tSkinInformation
70629>>>>>>>>>    String sName     // description of the skin
70629>>>>>>>>>    String sSkinfile // file path. Can be relative or full
70629>>>>>>>>>    String sSkinIni  // section name
70629>>>>>>>>>End_Struct
70629>>>>>>>>>
70629>>>>>>>>>
70629>>>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
70630>>>>>>>>>    
70630>>>>>>>>>    Procedure Construct_Object
70632>>>>>>>>>        Forward Send Construct_Object
70634>>>>>>>>>        
70634>>>>>>>>>        Property String psSkinFile ""
70635>>>>>>>>>        Property String psSkinIni ""
70636>>>>>>>>>        Property Boolean pbLoadPreference False
70637>>>>>>>>>        
70637>>>>>>>>>        Set peAutoCreate to acAutoCreate
70638>>>>>>>>>        
70638>>>>>>>>>        Move Self to ghoSkinFramework
70639>>>>>>>>>    End_Procedure
70640>>>>>>>>>    
70640>>>>>>>>>    // return the default skin path, which is the programs directory.
70640>>>>>>>>>    // This requires an application object.
70640>>>>>>>>>    // If you want to different skin path, override this.
70640>>>>>>>>>    Function SkinPath Returns String
70642>>>>>>>>>        String sPath sPaths
70642>>>>>>>>>        Handle hoWorkspace
70642>>>>>>>>>        If ghoApplication Begin
70644>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
70645>>>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
70646>>>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
70647>>>>>>>>>        End
70647>>>>>>>>>>
70647>>>>>>>>>        Else Begin
70648>>>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
70649>>>>>>>>>>
70649>>>>>>>>>        End
70649>>>>>>>>>>
70649>>>>>>>>>        Function_Return sPath
70650>>>>>>>>>    End_Function
70651>>>>>>>>>    
70651>>>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
70651>>>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
70651>>>>>>>>>    Function SkinQFile Returns String
70653>>>>>>>>>        String sFile sPath sSep
70653>>>>>>>>>        Boolean bQualified
70653>>>>>>>>>        Get psSkinFile to sFile
70654>>>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
70656>>>>>>>>>            Get SkinPath to sPath
70657>>>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
70658>>>>>>>>>            Move (sPath - sSep - sFile) to sFile
70659>>>>>>>>>        End
70659>>>>>>>>>>
70659>>>>>>>>>        Function_Return sFile
70660>>>>>>>>>    End_Function
70661>>>>>>>>>    
70661>>>>>>>>>    // defines the default VDF window class mapping.
70661>>>>>>>>>    Procedure OnAddVDFWindowClasses
70663>>>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
70664>>>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
70665>>>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
70666>>>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
70667>>>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
70668>>>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
70669>>>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
70670>>>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
70671>>>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
70672>>>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
70673>>>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
70674>>>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
70675>>>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
70676>>>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
70677>>>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
70678>>>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
70679>>>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
70680>>>>>>>>>        // External class
70680>>>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
70681>>>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
70682>>>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
70683>>>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
70684>>>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
70685>>>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
70686>>>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
70687>>>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
70688>>>>>>>>>    End_Procedure
70689>>>>>>>>>    
70689>>>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
70689>>>>>>>>>    Procedure OnAddCustomWindowClasses
70691>>>>>>>>>    End_Procedure
70692>>>>>>>>>    
70692>>>>>>>>>    // called when object is created during end_construct_object.
70692>>>>>>>>>    Procedure OnCreate
70694>>>>>>>>>        Integer iOpts
70694>>>>>>>>>        Boolean bUseWindowsFont
70694>>>>>>>>>        Forward Send OnCreate
70696>>>>>>>>>        
70696>>>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
70696>>>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
70696>>>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
70697>>>>>>>>>        If bUseWindowsFont Begin
70699>>>>>>>>>            Get ComApplyOptions to iOpts
70700>>>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
70701>>>>>>>>>        End
70701>>>>>>>>>>
70701>>>>>>>>>        
70701>>>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
70701>>>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
70701>>>>>>>>>        // and this was the suggested workaround.
70701>>>>>>>>>        Set ComAutoApplyNewThreads to False
70702>>>>>>>>>        
70702>>>>>>>>>        Send OnAddVDFWindowClasses
70703>>>>>>>>>        Send OnAddCustomWindowClasses
70704>>>>>>>>>        
70704>>>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
70704>>>>>>>>>        If (pbLoadPreference(Self)) Begin
70706>>>>>>>>>            Send LoadSkinPreference
70707>>>>>>>>>        End
70707>>>>>>>>>>
70707>>>>>>>>>        // if a skin file name exists, we apply the skin.
70707>>>>>>>>>        If (psSkinFile(Self)<>"") Begin
70709>>>>>>>>>            Send ApplySkin
70710>>>>>>>>>        End
70710>>>>>>>>>>
70710>>>>>>>>>    End_Procedure
70711>>>>>>>>>    
70711>>>>>>>>>    // called by framework as part of application exit.
70711>>>>>>>>>    Procedure Broadcast_Notify_Exit_Application
70713>>>>>>>>>        Send Notify_Exit_Application
70714>>>>>>>>>    End_Procedure
70715>>>>>>>>>    
70715>>>>>>>>>    Procedure Notify_Exit_Application
70717>>>>>>>>>        If (pbLoadPreference(Self)) Begin
70719>>>>>>>>>            Send SaveSkinPreference
70720>>>>>>>>>        End
70720>>>>>>>>>>
70720>>>>>>>>>    End_Procedure
70721>>>>>>>>>    
70721>>>>>>>>>    Procedure NotifyPreApplySkin
70723>>>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
70725>>>>>>>>>    End_Procedure
70726>>>>>>>>>    
70726>>>>>>>>>    Procedure NotifyPostApplySkin
70728>>>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
70730>>>>>>>>>    End_Procedure
70731>>>>>>>>>    
70731>>>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
70731>>>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
70731>>>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
70733>>>>>>>>>        tSkinInformation[] Skins
70733>>>>>>>>>        tSkinInformation[] Skins
70734>>>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
70734>>>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
70734>>>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
70734>>>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
70734>>>>>>>>>        Integer iPos iDfltLen
70734>>>>>>>>>        Boolean bUseRelativePath
70734>>>>>>>>>        
70734>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
70735>>>>>>>>>        
70735>>>>>>>>>        Get SkinPath to sDefaultPath
70736>>>>>>>>>        If (sPath="") Begin
70738>>>>>>>>>            Move sDefaultPath to sPath
70739>>>>>>>>>        End
70739>>>>>>>>>>
70739>>>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
70740>>>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
70741>>>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
70742>>>>>>>>>        
70742>>>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
70743>>>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
70745>>>>>>>>>            
70745>>>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
70746>>>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
70747>>>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
70748>>>>>>>>>            
70748>>>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
70749>>>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
70750>>>>>>>>>            
70750>>>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
70756>>>>>>>>>>
70756>>>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
70757>>>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
70758>>>>>>>>>                
70758>>>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
70759>>>>>>>>>                
70759>>>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
70765>>>>>>>>>>
70765>>>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
70766>>>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
70767>>>>>>>>>                    
70767>>>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
70768>>>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
70769>>>>>>>>>                    If bUseRelativePath Begin
70771>>>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
70772>>>>>>>>>                        If iPos Begin
70774>>>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
70775>>>>>>>>>                            While (Left(sSkinFile,1)=sSep)
70779>>>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
70780>>>>>>>>>                            Loop
70781>>>>>>>>>>
70781>>>>>>>>>                        End
70781>>>>>>>>>>
70781>>>>>>>>>                    End
70781>>>>>>>>>>
70781>>>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
70782>>>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
70783>>>>>>>>>                    
70783>>>>>>>>>                    Increment iArrayItem
70784>>>>>>>>>                Loop
70785>>>>>>>>>>
70785>>>>>>>>>            Loop
70786>>>>>>>>>>
70786>>>>>>>>>            
70786>>>>>>>>>            Send Destroy of hSkinDescriptions
70787>>>>>>>>>            Send Destroy of hSkinDescription
70788>>>>>>>>>            Send Destroy of hSkinIniFile
70789>>>>>>>>>            
70789>>>>>>>>>        End
70789>>>>>>>>>>
70789>>>>>>>>>        Function_Return Skins
70790>>>>>>>>>    End_Function
70791>>>>>>>>>    
70791>>>>>>>>>    // Save the skin preference. This requires an application object.
70791>>>>>>>>>    // Only do this if the application object allows it.
70791>>>>>>>>>    // This is called during startup if pbLoadPreference is True
70791>>>>>>>>>    // Suitable for override
70791>>>>>>>>>    Procedure SaveSkinPreference
70793>>>>>>>>>        String sSkin sIni
70793>>>>>>>>>        If ghoApplication Begin
70795>>>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
70797>>>>>>>>>                Get psSkinFile to sSkin
70798>>>>>>>>>                Get psSkinIni to sIni
70799>>>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
70800>>>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
70801>>>>>>>>>            End
70801>>>>>>>>>>
70801>>>>>>>>>        End
70801>>>>>>>>>>
70801>>>>>>>>>        Else Begin
70802>>>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
70803>>>>>>>>>>
70803>>>>>>>>>        End
70803>>>>>>>>>>
70803>>>>>>>>>    End_Procedure
70804>>>>>>>>>    
70804>>>>>>>>>    // Load the skin preference. This requires an application object.
70804>>>>>>>>>    // Only do this if the application object allows it.
70804>>>>>>>>>    // This is called during startup if pbLoadPreference is True
70804>>>>>>>>>    // Suitable for override
70804>>>>>>>>>    Procedure LoadSkinPreference
70806>>>>>>>>>        String sSkin sIni
70806>>>>>>>>>        Boolean bExists
70806>>>>>>>>>        If ghoApplication Begin
70808>>>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
70810>>>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
70811>>>>>>>>>                If bExists Begin
70813>>>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
70814>>>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
70815>>>>>>>>>                    Set psSkinFile to sSkin
70816>>>>>>>>>                    Set psSkinIni to sIni
70817>>>>>>>>>                End
70817>>>>>>>>>>
70817>>>>>>>>>            End
70817>>>>>>>>>>
70817>>>>>>>>>        End
70817>>>>>>>>>>
70817>>>>>>>>>        Else Begin
70818>>>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
70819>>>>>>>>>>
70819>>>>>>>>>        End
70819>>>>>>>>>>
70819>>>>>>>>>    End_Procedure
70820>>>>>>>>>    
70820>>>>>>>>>    // Can be called to apply the current skin.
70820>>>>>>>>>    Procedure ApplySkin
70822>>>>>>>>>        Boolean bOk
70822>>>>>>>>>        String sSkin sIni
70822>>>>>>>>>        If (IsComObjectCreated(Self)) Begin
70824>>>>>>>>>            Get SkinQFile to sSkin
70825>>>>>>>>>            Get psSkinIni to sIni
70826>>>>>>>>>            
70826>>>>>>>>>            Send NotifyPreApplySkin
70827>>>>>>>>>            // when skins are used we don't want to use built in Visual Styles
70827>>>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
70828>>>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
70829>>>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
70831>>>>>>>>>                // if not ok, no skin was appied. Enable visual styles
70831>>>>>>>>>                Send EnableVisualStyles of Desktop True
70832>>>>>>>>>            End
70832>>>>>>>>>>
70832>>>>>>>>>            Send NotifyPostApplySkin
70833>>>>>>>>>        End
70833>>>>>>>>>>
70833>>>>>>>>>    End_Procedure
70834>>>>>>>>>    
70834>>>>>>>>>    
70834>>>>>>>>>End_Class
70835>>>>>>>
70835>>>>>>>Class cRDCModalPanel is a ModalPanel
70836>>>>>>>
70836>>>>>>>    Procedure Construct_Object
70838>>>>>>>        Forward Send Construct_Object
70840>>>>>>>
70840>>>>>>>        Set Maximize_Icon to True
70841>>>>>>>        Set Minimize_Icon to False
70842>>>>>>>        Set Border_Style to Border_Thick
70843>>>>>>>        Set Locate_Mode to Center_On_Parent
70844>>>>>>>
70844>>>>>>>        Property String Private_Icon
70845>>>>>>>        Property Handle phoDialogCommandbar
70846>>>>>>>    End_Procedure
70847>>>>>>>
70847>>>>>>>    Procedure Set Icon String sIcon
70849>>>>>>>        Forward Set Icon to sIcon
70851>>>>>>>        Set Private_Icon to sIcon
70852>>>>>>>    End_Procedure
70853>>>>>>>
70853>>>>>>>    Function Icon Returns String
70855>>>>>>>        String sIcon
70855>>>>>>>        Get Private_Icon to sIcon
70856>>>>>>>        Function_Return sIcon
70857>>>>>>>    End_Function
70858>>>>>>>
70858>>>>>>>    Procedure Page Integer iPageObject
70860>>>>>>>        String sIcon
70860>>>>>>>        Integer hWnd
70860>>>>>>>        
70860>>>>>>>        Forward Send Page iPageObject
70862>>>>>>>        Get Private_Icon to sIcon
70863>>>>>>>        If (sIcon <> "") Begin
70865>>>>>>>            Set Icon to sIcon
70866>>>>>>>        End
70866>>>>>>>>
70866>>>>>>>
70866>>>>>>>        Get Window_Handle to hWnd
70867>>>>>>>
70867>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
70869>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
70870>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
70871>>>>>>>        End
70871>>>>>>>>
70871>>>>>>>    End_Procedure
70872>>>>>>>
70872>>>>>>>    // Put a status bar at the bottom of the panel, which makes
70872>>>>>>>    // status_help work and puts a gripper in the lower right corner.
70872>>>>>>>    Procedure End_Construct_Object
70874>>>>>>>        Integer iStyle iSize iOffset
70874>>>>>>>
70874>>>>>>>        Forward Send End_Construct_Object
70876>>>>>>>
70876>>>>>>>        Get Border_Style to iStyle
70877>>>>>>>        Move 8 to iOffset
70878>>>>>>>        If (iStyle = Border_Thick) Begin
70880>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
70882>>>>>>>                Object oStatusBar is a cCJStatusBar
70884>>>>>>>                    Set phoDialogCommandbar to Self
70885>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
70887>>>>>>>                        Set piId to sbpIDIdlePane
70888>>>>>>>                        Set pbStyleStretch to True
70889>>>>>>>                    End_Object
70890>>>>>>>                End_Object
70891>>>>>>>            End_Object
70892>>>>>>>            Get Size to iSize
70893>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
70894>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
70895>>>>>>>        End
70895>>>>>>>>
70895>>>>>>>
70895>>>>>>>    End_Procedure
70896>>>>>>>
70896>>>>>>>    Procedure Popup
70898>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
70899>>>>>>>        Forward Send Popup
70901>>>>>>>    End_Procedure
70902>>>>>>>
70902>>>>>>>End_Class
70903>>>>>Use cRDCCJSelectionGrid.pkg
Including file: cRDCCJSelectionGrid.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCCJSelectionGrid.pkg)
70903>>>>>>>//****************************************************************************
70903>>>>>>>// $Module type: Package
70903>>>>>>>// $Module name: cRDCCJSelectionGrid.pkg
70903>>>>>>>//
70903>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
70903>>>>>>>// Copyright (c) 2018 RDC Tools International
70903>>>>>>>// E-mail      : support@rdctools.com
70903>>>>>>>// Web-site    : http://www.rdctools.com
70903>>>>>>>//
70903>>>>>>>// Created     : 2018-12-17 @ 08:04 (Military date format - Year-Month-Day)
70903>>>>>>>//
70903>>>>>>>// Note        : Grid class that uses a checkbox column for selecting items.
70903>>>>>>>//
70903>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70903>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70903>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70903>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70903>>>>>>>// in the help folder for more details.
70903>>>>>>>//
70903>>>>>>>//****************************************************************************
70903>>>>>>>Use cCJGrid.pkg
70903>>>>>>>Use cCJGridColumn.pkg
70903>>>>>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridColumnRowIndicator.pkg)
70903>>>>>>>>>Use cCJGridColumn.pkg
70903>>>>>>>>>
70903>>>>>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
70904>>>>>>>>>    
70904>>>>>>>>>    Procedure Construct_Object
70906>>>>>>>>>        Forward Send Construct_Object
70908>>>>>>>>>        
70908>>>>>>>>>        Property Integer piImage 0
70909>>>>>>>>>        
70909>>>>>>>>>        Set psCaption to ""
70910>>>>>>>>>        Set piWidth to 20
70911>>>>>>>>>        Set pbResizable to False
70912>>>>>>>>>        Set pbEditable to False
70913>>>>>>>>>        Set pbFocusable to False
70914>>>>>>>>>        Set pbAllowDrag to False
70915>>>>>>>>>        Set psToolTip to "Row Indicator"
70916>>>>>>>>>    End_Procedure
70917>>>>>>>>>    
70917>>>>>>>>>    Procedure OnCreateColumn
70919>>>>>>>>>        Integer iImage
70919>>>>>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
70921>>>>>>>>>        Set piImage to iImage
70922>>>>>>>>>    End_Procedure
70923>>>>>>>>>    
70923>>>>>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
70925>>>>>>>>>        Integer iImage iFocusedRow
70925>>>>>>>>>        Handle hoDataSource
70925>>>>>>>>>        
70925>>>>>>>>>        Get phoDataSource to hoDataSource
70926>>>>>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
70927>>>>>>>>>        Move -1 to iImage
70928>>>>>>>>>        If (iRow = iFocusedRow) Begin
70930>>>>>>>>>            Get piImage to iImage
70931>>>>>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
70932>>>>>>>>>        End
70932>>>>>>>>>>
70932>>>>>>>>>    End_Procedure
70933>>>>>>>>>    
70933>>>>>>>>>End_Class
70934>>>>>>>Use Cursor.pkg
70934>>>>>>>Use vWin32fh.pkg
70934>>>>>>>
70934>>>>>>>
70934>>>>>>>
70934>>>>>>>Enum_List
70934>>>>>>>    Define cx_Select_All
70934>>>>>>>    Define cx_Select_None
70934>>>>>>>    Define cx_Select_Invert
70934>>>>>>>End_Enum_List
70934>>>>>>>
70934>>>>>>>// Classes used by the cRDCCJSelectionGrid
70934>>>>>>>Class cRDCCJToggleSelectMenuItem is a cCJMenuItem
70935>>>>>>>
70935>>>>>>>    Procedure Construct_Object
70937>>>>>>>        Forward Send Construct_Object
70939>>>>>>>        Set psCaption to "Toggle Current Item"
70940>>>>>>>        Set psImage to "ToggleOn.ico"
70941>>>>>>>        Set psShortcut to "Space-Bar"
70942>>>>>>>    End_Procedure
70943>>>>>>>
70943>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70945>>>>>>>        Forward Send OnExecute vCommandBarControl
70947>>>>>>>        Send ToggleCurrentItem
70948>>>>>>>    End_Procedure
70949>>>>>>>
70949>>>>>>>End_Class
70950>>>>>>>
70950>>>>>>>Class cRDCCJSelectAllMenuItem is a cCJMenuItem
70951>>>>>>>
70951>>>>>>>    Procedure Construct_Object
70953>>>>>>>        Forward Send Construct_Object
70955>>>>>>>        Set pbControlBeginGroup to True
70956>>>>>>>        Set psCaption to "Select All"
70957>>>>>>>        Set psImage to "SelectAll.ico"
70958>>>>>>>        Set psShortcut to "Ctrl+A"
70959>>>>>>>    End_Procedure
70960>>>>>>>
70960>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70962>>>>>>>        Forward Send OnExecute vCommandBarControl
70964>>>>>>>        Set SelectItems to cx_Select_All
70965>>>>>>>    End_Procedure
70966>>>>>>>
70966>>>>>>>End_Class
70967>>>>>>>
70967>>>>>>>Class cRDCCJDeSelectAllMenuItem is a cCJMenuItem
70968>>>>>>>
70968>>>>>>>    Procedure Construct_Object
70970>>>>>>>        Forward Send Construct_Object
70972>>>>>>>        Set psCaption to "Select None"
70973>>>>>>>        Set psImage to "SelectNone.ico"
70974>>>>>>>        Set psShortcut to "Ctrl+N"
70975>>>>>>>    End_Procedure
70976>>>>>>>
70976>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70978>>>>>>>        Forward Send OnExecute vCommandBarControl
70980>>>>>>>        Set SelectItems to cx_Select_None
70981>>>>>>>    End_Procedure
70982>>>>>>>
70982>>>>>>>End_Class
70983>>>>>>>
70983>>>>>>>Class cRDCCJInvertSelectionsMenuItem is a cCJMenuItem
70984>>>>>>>
70984>>>>>>>    Procedure Construct_Object
70986>>>>>>>        Forward Send Construct_Object
70988>>>>>>>        Set psCaption to "Invert Selection"
70989>>>>>>>        Set psImage to "SelectInvert.ico"
70990>>>>>>>        Set psShortcut to "Ctrl+I"
70991>>>>>>>    End_Procedure
70992>>>>>>>
70992>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70994>>>>>>>        Forward Send OnExecute vCommandBarControl
70996>>>>>>>        Set SelectItems to cx_Select_Invert
70997>>>>>>>    End_Procedure
70998>>>>>>>
70998>>>>>>>End_Class
70999>>>>>>>
70999>>>>>>>Class cRDCCJAddFolderMenuItem is a cCJMenuItem
71000>>>>>>>
71000>>>>>>>    Procedure Construct_Object
71002>>>>>>>        Forward Send Construct_Object
71004>>>>>>>        Set psCaption to "Add Folder"
71005>>>>>>>        Set psImage to "AddFolder.ico"
71006>>>>>>>        Set psShortcut to "Ins"
71007>>>>>>>    End_Procedure
71008>>>>>>>
71008>>>>>>>    Procedure OnExecute Variant vCommandBarControl
71010>>>>>>>        Forward Send OnExecute vCommandBarControl
71012>>>>>>>        Send BrowseForFolder
71013>>>>>>>    End_Procedure
71014>>>>>>>
71014>>>>>>>End_Class
71015>>>>>>>
71015>>>>>>>Class cRDCCJRemoveItemMenuItem is a cCJMenuItem
71016>>>>>>>
71016>>>>>>>    Procedure Construct_Object
71018>>>>>>>        Forward Send Construct_Object
71020>>>>>>>        Set psCaption to "Remove From Grid"
71021>>>>>>>        Set psImage to "ActionDelete.ico"
71022>>>>>>>        Set psShortcut to "Del"
71023>>>>>>>    End_Procedure
71024>>>>>>>
71024>>>>>>>    Procedure OnExecute Variant vCommandBarControl
71026>>>>>>>        Forward Send OnExecute vCommandBarControl
71028>>>>>>>        Send Request_Delete
71029>>>>>>>    End_Procedure
71030>>>>>>>
71030>>>>>>>End_Class
71031>>>>>>>
71031>>>>>>>Register_Function pbShowAddFolderMenuItem Returns Boolean
71031>>>>>>>Register_Function pbShowRemoveFolderMenuItem Returns Boolean
71031>>>>>>>Register_Function pbShowInvertSelectionsMenuItem Returns Boolean
71031>>>>>>>
71031>>>>>>>Class cGridContext_mnu is a cCJContextMenu
71032>>>>>>>    Procedure Construct_Object
71034>>>>>>>        Handle hoMenuItem
71034>>>>>>>        Forward Send Construct_Object
71036>>>>>>>
71036>>>>>>>        Get Create (RefClass(cRDCCJToggleSelectMenuItem))      to hoMenuItem
71037>>>>>>>        Get Create (RefClass(cRDCCJSelectAllMenuItem))         to hoMenuItem
71038>>>>>>>        Get Create (RefClass(cRDCCJDeSelectAllMenuItem))       to hoMenuItem
71039>>>>>>>        If (pbShowInvertSelectionsMenuItem(Self) = True) Begin
71041>>>>>>>            Get Create (RefClass(cRDCCJInvertSelectionsMenuItem))  to hoMenuItem
71042>>>>>>>        End
71042>>>>>>>>
71042>>>>>>>        If (pbShowAddFolderMenuItem(Self) = True) Begin
71044>>>>>>>            Get Create (RefClass(cRDCCJAddFolderMenuItem))  to hoMenuItem
71045>>>>>>>            Set pbControlBeginGroup of hoMenuItem to True
71046>>>>>>>        End
71046>>>>>>>>
71046>>>>>>>        If (pbShowRemoveFolderMenuItem(Self) = True) Begin
71048>>>>>>>            Get Create (RefClass(cRDCCJRemoveItemMenuItem))  to hoMenuItem
71049>>>>>>>            If (pbShowAddFolderMenuItem(Self) = False) Begin
71051>>>>>>>                Set pbControlBeginGroup of hoMenuItem to True
71052>>>>>>>            End
71052>>>>>>>>
71052>>>>>>>        End
71052>>>>>>>>
71052>>>>>>>    End_Procedure
71053>>>>>>>
71053>>>>>>>End_Class
71054>>>>>>>
71054>>>>>>>Class cRDCCJSelectionGrid is a cCJGrid
71055>>>>>>>
71055>>>>>>>    Procedure Construct_Object
71057>>>>>>>        Forward Send Construct_Object
71059>>>>>>>
71059>>>>>>>        // This must be set manually in the grid column object for the 'data' column (or one of them):
71059>>>>>>>        Property Handle phoData_Col 0
71060>>>>>>>        Property Handle phoCheckbox_Col 0
71061>>>>>>>
71061>>>>>>>        Property Boolean pbShowAddFolderMenuItem False
71062>>>>>>>        Property Boolean pbShowRemoveFolderMenuItem False   
71063>>>>>>>        Property Boolean pbShowInvertSelectionsMenuItem True
71064>>>>>>>        Property Boolean pbEnableMoveKeys False
71065>>>>>>>
71065>>>>>>>        Set pbRestoreLayout to True
71066>>>>>>>        Set psLayoutSection to (Name(Self) + "_grid")
71067>>>>>>>        Set psNoItemsText to "No data found..."
71068>>>>>>>        Set pbHeaderReorders to True
71069>>>>>>>        Set pbHeaderPrompts to False
71070>>>>>>>        Set pbHeaderTogglesDirection to True
71071>>>>>>>        Set pbSelectionEnable to True
71072>>>>>>>        Set pbAllowInsertRow to False
71073>>>>>>>        Set pbAllowAppendRow to False
71074>>>>>>>        Set pbShowRowFocus to True
71075>>>>>>>        Set pbShowFooter to True
71076>>>>>>>        Set pbMultipleSelection to True
71077>>>>>>>        Set pbHotTracking to True
71078>>>>>>>        Set pbEditOnClick to True
71079>>>>>>>        Set piLayoutBuild to 4
71080>>>>>>>        Set Status_Help to "Select with the spacebar"
71081>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
71082>>>>>>>        Set peAnchors to anAll
71083>>>>>>>        // This makes the ticked checkboxes to appear as bold.
71083>>>>>>>        Set peVisualTheme to xtpReportThemeVisualStudio2012Light
71084>>>>>>>
71084>>>>>>>        On_Key Key_Space      Send ToggleCurrentItem
71085>>>>>>>        On_Key Key_Delete     Send Request_Delete
71086>>>>>>>        On_Key Key_Insert     Send BrowseForFolder
71087>>>>>>>        On_Key Key_Ctrl+Key_A Send SelectAll
71088>>>>>>>        On_Key Key_Ctrl+Key_N Send SelectNone
71089>>>>>>>        On_Key Key_Ctrl+Key_I Send SelectInvert
71090>>>>>>>        On_Key kCancel        Send CancelIfPopupObject
71091>>>>>>>        On_Key Key_Alt+Key_Down_Arrow Send MoveDown
71092>>>>>>>        On_Key Key_Alt+Key_Up_Arrow   Send MoveUp
71093>>>>>>>    End_Procedure
71094>>>>>>>
71094>>>>>>>    Procedure MoveUp
71096>>>>>>>        tDataSourceRow[] TheData
71096>>>>>>>        tDataSourceRow[] TheData
71097>>>>>>>        tDataSourceRow TheRow
71097>>>>>>>        tDataSourceRow TheRow
71097>>>>>>>        Handle hDataSource
71097>>>>>>>        Integer iCurrentRow
71097>>>>>>>
71097>>>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
71099>>>>>>>            Procedure_Return
71100>>>>>>>        End
71100>>>>>>>>
71100>>>>>>>        Get phoDataSource to hDataSource
71101>>>>>>>        Get DataSource of hDataSource to TheData
71102>>>>>>>        Get SelectedRow of hDataSource to iCurrentRow
71103>>>>>>>        If (iCurrentRow > 0) Begin
71105>>>>>>>            Move TheData[iCurrentRow - 1] to TheRow
71106>>>>>>>            Move TheData[iCurrentRow] to TheData[iCurrentRow - 1]
71107>>>>>>>            Move TheRow to TheData[iCurrentRow]
71108>>>>>>>            Send ReInitializeData TheData True
71109>>>>>>>            Send MoveToRow (iCurrentRow - 1)
71110>>>>>>>        End
71110>>>>>>>>
71110>>>>>>>    End_Procedure
71111>>>>>>>
71111>>>>>>>    Procedure MoveDown
71113>>>>>>>        tDataSourceRow[] TheData
71113>>>>>>>        tDataSourceRow[] TheData
71114>>>>>>>        tDataSourceRow TheRow
71114>>>>>>>        tDataSourceRow TheRow
71114>>>>>>>        Handle hDataSource
71114>>>>>>>        Integer iCurrentRow
71114>>>>>>>
71114>>>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
71116>>>>>>>            Procedure_Return
71117>>>>>>>        End
71117>>>>>>>>
71117>>>>>>>        Get phoDataSource to hDataSource
71118>>>>>>>        Get DataSource of hDataSource to TheData
71119>>>>>>>        Get SelectedRow of hDataSource to iCurrentRow
71120>>>>>>>        If ((iCurrentRow + 1) < SizeOfArray(TheData)) Begin
71122>>>>>>>            Move TheData[iCurrentRow] to TheRow
71123>>>>>>>            Move TheData[iCurrentRow + 1] to TheData[iCurrentRow]
71124>>>>>>>            Move TheRow to TheData[iCurrentRow + 1]
71125>>>>>>>            Send ReInitializeData TheData True
71126>>>>>>>            Send MoveToRow (iCurrentRow + 1)
71127>>>>>>>        End
71127>>>>>>>>
71127>>>>>>>    End_Procedure
71128>>>>>>>
71128>>>>>>>    Procedure RefreshSelectionUpdate
71130>>>>>>>    End_Procedure                   
71131>>>>>>>    
71131>>>>>>>    Procedure CancelIfPopupObject
71133>>>>>>>        Boolean bIsInPopupObject
71133>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
71135>>>>>>>        If (bIsInPopupObject = True) Begin
71137>>>>>>>            Send Close_Panel
71138>>>>>>>        End
71138>>>>>>>>
71138>>>>>>>    End_Procedure
71139>>>>>>>
71139>>>>>>>    Procedure End_Construct_Object
71141>>>>>>>        String sColor
71141>>>>>>>        Handle hoContextMenu
71141>>>>>>>        Forward Send End_Construct_Object
71143>>>>>>>
71143>>>>>>>        Object oCheckbox_col is a cCJGridColumn
71145>>>>>>>            Set phoCheckbox_Col to Self
71146>>>>>>>            Set piWidth to 60
71147>>>>>>>            Set pbResizable to False
71148>>>>>>>            Set psCaption to "Select"
71149>>>>>>>            Set psToolTip to "Select an item by using the space bar or click with the mouse."
71150>>>>>>>            Set pbCheckbox to True
71151>>>>>>>            Set peHeaderAlignment to xtpAlignmentCenter
71152>>>>>>>            Set peFooterAlignment to xtpAlignmentCenter
71153>>>>>>>            Set peDataType to Mask_Numeric_Window
71154>>>>>>>        End_Object
71155>>>>>>>
71155>>>>>>>        If (ghoApplication <> 0) Begin
71157>>>>>>>            Get ReadString of ghoApplication CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
71158>>>>>>>        End
71158>>>>>>>>
71158>>>>>>>        If (sColor = "clBlueGreyLight") Begin
71160>>>>>>>            Move "clGreenGrey" to sColor
71161>>>>>>>        End
71161>>>>>>>>
71161>>>>>>>        Set piSelectedRowBackColor to sColor
71162>>>>>>>        Set piHighlightBackColor   to sColor
71163>>>>>>>
71163>>>>>>>        Get Create (RefClass(cGridContext_mnu)) to hoContextMenu
71164>>>>>>>        Set phoContextMenu to hoContextMenu
71165>>>>>>>    End_Procedure
71166>>>>>>>
71166>>>>>>>    Procedure OnCreateGridControl
71168>>>>>>>        Handle hoObject
71168>>>>>>>        Integer iToolTipStyle
71168>>>>>>>        Boolean bIsBalloonStyleSupported
71168>>>>>>>
71168>>>>>>>        Forward Send OnCreateGridControl
71170>>>>>>>
71170>>>>>>>        Get phoToolTipContext to hoObject
71171>>>>>>>        If (hoObject <> 0) Begin
71173>>>>>>>            Move xtpToolTipStandard to iToolTipStyle
71174>>>>>>>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
71174>>>>>>>            // The ComShowTitleAndDescription also requires IE 5.0.
71174>>>>>>>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
71175>>>>>>>            If (bIsBalloonStyleSupported = True) Begin
71177>>>>>>>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
71178>>>>>>>            End
71178>>>>>>>>
71178>>>>>>>            Set ComStyle             of hoObject to iToolTipStyle
71179>>>>>>>            Set ComShowOfficeBorder  of hoObject to True
71180>>>>>>>            Set ComShowShadow        of hoObject to True
71181>>>>>>>            // Set the max width for a tooltip. 250 just seems to be a good
71181>>>>>>>            // compromise. After 250 pixels the text will wrap to the next line automatically.
71181>>>>>>>            Set ComMaxTipWidth       of hoObject to 250 // In pixels
71182>>>>>>>        End
71182>>>>>>>>
71182>>>>>>>        Send DoChangeFontSize
71183>>>>>>>    End_Procedure
71184>>>>>>>
71184>>>>>>>    Procedure AddItem String sDataValue
71186>>>>>>>        Handle hoDataSource
71186>>>>>>>        tDataSourceRow[] TheData
71186>>>>>>>        tDataSourceRow[] TheData
71187>>>>>>>        tsSearchResult[] asFolderArray
71187>>>>>>>        tsSearchResult[] asFolderArray
71188>>>>>>>        Integer iSize iData_Col iCheckbox_Col
71188>>>>>>>
71188>>>>>>>        If (not(IsComObjectCreated(Self))) Begin
71190>>>>>>>            Procedure_Return
71191>>>>>>>        End
71191>>>>>>>>
71191>>>>>>>
71191>>>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
71192>>>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
71193>>>>>>>        Get phoDataSource to hoDataSource
71194>>>>>>>        Get DataSource of hoDataSource to TheData
71195>>>>>>>        Move (SizeOfArray(TheData)) to iSize
71196>>>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
71197>>>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
71198>>>>>>>
71198>>>>>>>        Send ReInitializeData TheData False
71199>>>>>>>        Send MoveToLastRow
71200>>>>>>>    End_Procedure
71201>>>>>>>
71201>>>>>>>    Procedure BrowseForFolder
71203>>>>>>>        String sFolderName
71203>>>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
71204>>>>>>>        If (sFolderName <> "") Begin
71206>>>>>>>            Send AddItem sFolderName
71207>>>>>>>        End
71207>>>>>>>>
71207>>>>>>>    End_Procedure
71208>>>>>>>
71208>>>>>>>    // We don't want columns to be editable. But setting
71208>>>>>>>    // pbEditable = False or pbReadOnly makes it very hard to read,
71208>>>>>>>    // and makes it impossible to select the checkbox column with the mouse.
71208>>>>>>>    // So we disable those columns instead.
71208>>>>>>>    Function CanEditColumn Integer iCol Returns Boolean
71210>>>>>>>        Handle hoCol
71210>>>>>>>        Boolean bRetval
71210>>>>>>>
71210>>>>>>>        Forward Get CanEditColumn iCol to bRetval
71212>>>>>>>
71212>>>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to hoCol
71213>>>>>>>        If (iCol <> hoCol) Begin
71215>>>>>>>            Move False to bRetval
71216>>>>>>>        End
71216>>>>>>>>
71216>>>>>>>        Else Begin
71217>>>>>>>            Move True to bRetval
71218>>>>>>>        End
71218>>>>>>>>
71218>>>>>>>
71218>>>>>>>        Function_Return bRetval
71219>>>>>>>    End_Function
71220>>>>>>>
71220>>>>>>>    Procedure Request_Clear_All
71222>>>>>>>        tDataSourceRow[] EmptyData
71222>>>>>>>        tDataSourceRow[] EmptyData
71223>>>>>>>        Handle hoGrid hoDataSource
71223>>>>>>>
71223>>>>>>>        Move Self  to hoGrid
71224>>>>>>>        If (IsComObjectCreated(hoGrid)) Begin
71226>>>>>>>            Get phoDataSource of hoGrid to hoDataSource
71227>>>>>>>            Send InitializeData of hoGrid EmptyData
71228>>>>>>>            Send DoSetCheckboxFooterText
71229>>>>>>>        End
71229>>>>>>>>
71229>>>>>>>    End_Procedure
71230>>>>>>>
71230>>>>>>>    // Set checkboxes of the first column as selected.
71230>>>>>>>    // iState can be one of the following:
71230>>>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
71230>>>>>>>    Procedure Set SelectItems Integer iState
71232>>>>>>>        Integer iCount iSize iCheckbox_Col
71232>>>>>>>        Boolean bChecked
71232>>>>>>>        Handle hoDataSource hoCheckBox_Col
71232>>>>>>>        tDataSourceRow[] TheData
71232>>>>>>>        tDataSourceRow[] TheData
71233>>>>>>>        
71233>>>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
71234>>>>>>>        If (hoCheckBox_Col = 0) Begin
71236>>>>>>>            Procedure_Return
71237>>>>>>>        End                 
71237>>>>>>>>
71237>>>>>>>        
71237>>>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
71238>>>>>>>        Get phoDataSource               to hoDataSource
71239>>>>>>>        Get DataSource of hoDataSource  to TheData
71240>>>>>>>        Move (SizeOfArray(TheData))     to iSize
71241>>>>>>>        Decrement iSize
71242>>>>>>>        For iCount from 0 to iSize
71248>>>>>>>>
71248>>>>>>>            Case Begin
71248>>>>>>>                Case (iState = cx_Select_All)
71250>>>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
71251>>>>>>>                    Case Break
71252>>>>>>>                Case (iState = cx_Select_None)
71255>>>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
71256>>>>>>>                    Case Break
71257>>>>>>>                Case (iState = cx_Select_Invert)
71260>>>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
71261>>>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
71262>>>>>>>                    Case Break
71263>>>>>>>            Case End
71263>>>>>>>        Loop
71264>>>>>>>>
71264>>>>>>>
71264>>>>>>>        Send ReInitializeData TheData False
71265>>>>>>>        Send DoSetCheckboxFooterText
71266>>>>>>>    End_Procedure
71267>>>>>>>
71267>>>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
71267>>>>>>>    Function SelectedItems Returns String[]
71269>>>>>>>        Integer i iItems iSize iCheckbox_Col iData_Col
71269>>>>>>>        String[] sDataArray
71270>>>>>>>        Handle hoDataSource
71270>>>>>>>        tDataSourceRow[] TheData
71270>>>>>>>        tDataSourceRow[] TheData
71271>>>>>>>        Boolean bChecked
71271>>>>>>>
71271>>>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
71272>>>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
71273>>>>>>>
71273>>>>>>>        Get phoDataSource to hoDataSource
71274>>>>>>>        Get DataSource of hoDataSource to TheData
71275>>>>>>>        Move (SizeOfArray(TheData)) to iItems
71276>>>>>>>        Decrement iItems
71277>>>>>>>
71277>>>>>>>        For i from 0 to iItems
71283>>>>>>>>
71283>>>>>>>            Move TheData[i].sValue[iCheckbox_Col] to bChecked
71284>>>>>>>            If (bChecked = True) Begin
71286>>>>>>>                Move (SizeOfArray(sDataArray)) to iSize
71287>>>>>>>                Move TheData[i].sValue[iData_Col] to sDataArray[iSize]
71288>>>>>>>            End
71288>>>>>>>>
71288>>>>>>>        Loop
71289>>>>>>>>
71289>>>>>>>
71289>>>>>>>        Function_Return sDataArray
71290>>>>>>>    End_Function
71291>>>>>>>
71291>>>>>>>    Procedure SelectAll
71293>>>>>>>        Set SelectItems to cx_Select_All
71294>>>>>>>    End_Procedure
71295>>>>>>>
71295>>>>>>>    Procedure SelectNone
71297>>>>>>>        Set SelectItems to cx_Select_None
71298>>>>>>>    End_Procedure
71299>>>>>>>
71299>>>>>>>    Procedure SelectInvert
71301>>>>>>>        Set SelectItems to cx_Select_Invert
71302>>>>>>>    End_Procedure
71303>>>>>>>
71303>>>>>>>    // Returns number of items.
71303>>>>>>>    Function ItemCount Returns Integer
71305>>>>>>>        Integer iItems
71305>>>>>>>        Handle hoDataSource
71305>>>>>>>        tDataSourceRow[] TheData
71305>>>>>>>        tDataSourceRow[] TheData
71306>>>>>>>
71306>>>>>>>        Get phoDataSource to hoDataSource
71307>>>>>>>        Get DataSource of hoDataSource to TheData
71308>>>>>>>        Move (SizeOfArray(TheData)) to iItems
71309>>>>>>>
71309>>>>>>>        Function_Return iItems
71310>>>>>>>    End_Function
71311>>>>>>>
71311>>>>>>>    // Returns number of checked items.
71311>>>>>>>    Function CheckedItems Returns Integer
71313>>>>>>>        Integer iCount iItems iCheckbox_Col iRetval
71313>>>>>>>        Handle hoDataSource hoCheckbox_Col
71313>>>>>>>        tDataSourceRow[] TheData
71313>>>>>>>        tDataSourceRow[] TheData
71314>>>>>>>        Boolean bChecked
71314>>>>>>>
71314>>>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
71315>>>>>>>        If (hoCheckbox_Col = 0) Begin
71317>>>>>>>            Procedure_Return
71318>>>>>>>        End
71318>>>>>>>>
71318>>>>>>>        Get piColumnId of hoCheckbox_Col to iCheckbox_Col
71319>>>>>>>        Get phoDataSource to hoDataSource
71320>>>>>>>        Get DataSource of hoDataSource to TheData
71321>>>>>>>        Move (SizeOfArray(TheData)) to iItems
71322>>>>>>>        Decrement iItems
71323>>>>>>>
71323>>>>>>>        For iCount from 0 to iItems
71329>>>>>>>>
71329>>>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
71330>>>>>>>            If (bChecked = True) Begin
71332>>>>>>>                Increment iRetval
71333>>>>>>>            End
71333>>>>>>>>
71333>>>>>>>        Loop
71334>>>>>>>>
71334>>>>>>>
71334>>>>>>>        Function_Return iRetval
71335>>>>>>>    End_Function
71336>>>>>>>
71336>>>>>>>    // Toggles the current row on/off (the checkbox)
71336>>>>>>>    Procedure ToggleCurrentItem
71338>>>>>>>        Boolean bChecked
71338>>>>>>>        Integer iCol
71338>>>>>>>        Handle hoCol hoCheckbox_Col
71338>>>>>>>
71338>>>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
71339>>>>>>>        If (hoCheckbox_Col = 0) Begin
71341>>>>>>>            Procedure_Return
71342>>>>>>>        End
71342>>>>>>>>
71342>>>>>>>        Get piColumnId of hoCheckbox_Col to iCol
71343>>>>>>>        Get ColumnObject iCol   to hoCol
71344>>>>>>>        Get SelectedRowValue    of hoCol to bChecked
71345>>>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
71346>>>>>>>        Send Request_Save
71347>>>>>>>        Send DoSetCheckboxFooterText
71348>>>>>>>    End_Procedure
71349>>>>>>>
71349>>>>>>>    Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
71351>>>>>>>        Forward Send OnComMouseUp llButton llShift llx lly
71353>>>>>>>        Send Request_Save
71354>>>>>>>        Send DoSetCheckboxFooterText
71355>>>>>>>    End_Procedure
71356>>>>>>>
71356>>>>>>>    Procedure DoSetCheckboxFooterText
71358>>>>>>>        Integer iCol iSelected iItems
71358>>>>>>>        Handle hoCol hoCheckbox_Col
71358>>>>>>>
71358>>>>>>>        If ((phoData_Col(Self) = 0)) Begin
71360>>>>>>>            Move 1 to iCol
71361>>>>>>>        End
71361>>>>>>>>
71361>>>>>>>        Else Begin
71362>>>>>>>            Get piColumnId of (phoData_Col(Self)) to iCol
71363>>>>>>>        End
71363>>>>>>>>
71363>>>>>>>        Get ItemCount to iItems
71364>>>>>>>        Get ColumnObject iCol to hoCol
71365>>>>>>>        Get CheckedItems to iSelected
71366>>>>>>>        Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))
71367>>>>>>>    End_Procedure
71368>>>>>>>
71368>>>>>>>    Procedure DoChangeFontSize
71370>>>>>>>        Handle hoFont hoPaintManager
71370>>>>>>>        Variant vFont
71370>>>>>>>        String sFont sFontSize
71370>>>>>>>        Boolean bCreated
71370>>>>>>>        Integer iVal
71370>>>>>>>
71370>>>>>>>        Get IsComObjectCreated to bCreated  // When program is started, grid object isn't created yet.
71371>>>>>>>        If (bCreated = False) Begin
71373>>>>>>>            Procedure_Return
71374>>>>>>>        End
71374>>>>>>>>
71374>>>>>>>
71374>>>>>>>        Get phoReportPaintManager to hoPaintManager
71375>>>>>>>        Get Create (RefClass(cComStdFont)) to hoFont  // Create a font object
71376>>>>>>>        Get ComTextFont of hoPaintManager to vFont    // Bind the font object to the Grid's text font
71377>>>>>>>        Set pvComObject of hoFont to vFont            // Connect DataFlex object with com object
71378>>>>>>>
71378>>>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iVal
71379>>>>>>>        Set ComSize of hoFont to iVal
71380>>>>>>>        Send ComRedraw
71381>>>>>>>        Send Destroy to hoFont                        // Destroy the font object (releases memory)
71382>>>>>>>    End_Procedure
71383>>>>>>>
71383>>>>>>>    // Augment to load data to the grid. Is called automatically
71383>>>>>>>    // from procedure Activating
71383>>>>>>>    Procedure LoadData
71385>>>>>>>    End_Procedure
71386>>>>>>>
71386>>>>>>>    // Automatically load data into the grid when activating.
71386>>>>>>>    Procedure Activating
71388>>>>>>>        Send Cursor_Wait of Cursor_Control
71389>>>>>>>        Send LoadData                       
71390>>>>>>>        Send DoChangeFontSize      
71391>>>>>>>        Send Cursor_Ready of Cursor_Control
71392>>>>>>>    End_Procedure
71393>>>>>>>
71393>>>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
71395>>>>>>>        Integer iSize jSize kSize iSup iInf iDef
71395>>>>>>>        Handle hoPaintManager hoFont
71395>>>>>>>        Variant vFont
71395>>>>>>>        
71395>>>>>>>        Move 3 to iInf      //max size
71396>>>>>>>        Move 18 to iSup     //min size
71397>>>>>>>        Move 8 to iDef      //default
71398>>>>>>>        Boolean blimite
71398>>>>>>>        Get phoReportPaintManager to hoPaintManager
71399>>>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
71401>>>>>>>            Procedure_Return
71402>>>>>>>        End
71402>>>>>>>>
71402>>>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
71403>>>>>>>        Get ComTextFont of hoPaintManager to vFont
71404>>>>>>>        Set pvComObject of hoFont to vFont
71405>>>>>>>        If (iDirection = 0) Begin
71407>>>>>>>            Set ComSize of hoFont to iDef
71408>>>>>>>        End
71408>>>>>>>>
71408>>>>>>>        Else Begin
71409>>>>>>>           Get ComSize of hoFont to iSize
71410>>>>>>>           Move iSize to jSize
71411>>>>>>>           Repeat
71411>>>>>>>>
71411>>>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
71412>>>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
71413>>>>>>>                If (not(blimite)) Begin       
71415>>>>>>>                   Set ComSize of hoFont to jSize
71416>>>>>>>                   Get ComSize of hoFont to kSize
71417>>>>>>>                End
71417>>>>>>>>
71417>>>>>>>            Until (iSize <> kSize or blimite)
71419>>>>>>>        End
71419>>>>>>>>
71419>>>>>>>        Send Destroy to hoFont 
71420>>>>>>>        Send ComRedraw  
71421>>>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
71422>>>>>>>    End_Procedure 
71423>>>>>>>
71423>>>>>>>End_Class
71424>>>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
71424>>>>>>>//****************************************************************************
71424>>>>>>>// $Module type: Package
71424>>>>>>>// $Module name: cRDCButtonDPI.pkg
71424>>>>>>>//
71424>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
71424>>>>>>>// Copyright (c) 2013 RDC Tools International
71424>>>>>>>// E-mail      : support@rdctools.com
71424>>>>>>>// Web-site    : http://www.rdctools.com
71424>>>>>>>//
71424>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
71424>>>>>>>//
71424>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
71424>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
71424>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
71424>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
71424>>>>>>>// in the help folder for more details.
71424>>>>>>>//
71424>>>>>>>//****************************************************************************
71424>>>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
71424>>>>>>>>>//****************************************************************************
71424>>>>>>>>>// $Module type: Package
71424>>>>>>>>>// $Module name: cRDCButton.pkg
71424>>>>>>>>>//
71424>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
71424>>>>>>>>>// Copyright (c) 2013 RDC Tools International
71424>>>>>>>>>// E-mail      : support@rdctools.com
71424>>>>>>>>>// Web-site    : http://www.rdctools.com
71424>>>>>>>>>//
71424>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
71424>>>>>>>>>//
71424>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
71424>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
71424>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
71424>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
71424>>>>>>>>>// in the help folder for more details.
71424>>>>>>>>>//
71424>>>>>>>>>//****************************************************************************
71424>>>>>>>>>Use Windows.pkg
71424>>>>>>>>>Use Enclient.pkg
71424>>>>>>>>>Use errornum.inc
71424>>>>>>>>>
71424>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
71425>>>>>>>>>    Procedure Construct_Object
71427>>>>>>>>>        Forward Send Construct_Object
71429>>>>>>>>>
71429>>>>>>>>>    End_Procedure
71430>>>>>>>>>
71430>>>>>>>>>    Procedure OnIdle
71432>>>>>>>>>        Delegate Send DoUpdate
71434>>>>>>>>>    End_Procedure
71435>>>>>>>>>
71435>>>>>>>>>End_Class
71436>>>>>>>>>
71436>>>>>>>>>Class cRDCButton is a Button
71437>>>>>>>>>
71437>>>>>>>>>    Procedure Construct_Object
71439>>>>>>>>>        Forward Send Construct_Object
71441>>>>>>>>>
71441>>>>>>>>>        Property Boolean pbAutoEnable True
71442>>>>>>>>>
71442>>>>>>>>>        Property Boolean pbEnabled True
71443>>>>>>>>>
71443>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
71444>>>>>>>>>
71444>>>>>>>>>        On_Key kCancel Send CancelIfPopupObject
71445>>>>>>>>>    End_Procedure
71446>>>>>>>>>
71446>>>>>>>>>    Procedure CancelIfPopupObject
71448>>>>>>>>>        Boolean bIsInPopupObject
71448>>>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
71450>>>>>>>>>        If (bIsInPopupObject = True) Begin
71452>>>>>>>>>            Send Close_Panel
71453>>>>>>>>>        End
71453>>>>>>>>>>
71453>>>>>>>>>    End_Procedure
71454>>>>>>>>>
71454>>>>>>>>>    Procedure End_Construct_Object
71456>>>>>>>>>        String sTooltip sStatus_Help
71456>>>>>>>>>
71456>>>>>>>>>        Forward Send End_Construct_Object
71458>>>>>>>>>
71458>>>>>>>>>        Get psToolTip   to sTooltip
71459>>>>>>>>>        Get Status_Help to sStatus_Help
71460>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
71462>>>>>>>>>            Set psToolTip to sStatus_Help
71463>>>>>>>>>        End
71463>>>>>>>>>>
71463>>>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
71465>>>>>>>>>            Set Status_Help to sToolTip
71466>>>>>>>>>        End
71466>>>>>>>>>>
71466>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
71467>>>>>>>>>    End_Procedure
71468>>>>>>>>>
71468>>>>>>>>>    Procedure DoUpdate
71470>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
71472>>>>>>>>>            Procedure_Return
71473>>>>>>>>>        End
71473>>>>>>>>>>
71473>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
71474>>>>>>>>>    End_Procedure
71475>>>>>>>>>
71475>>>>>>>>>    Function IsEnabled Returns Boolean
71477>>>>>>>>>        Boolean bEnabled
71477>>>>>>>>>        Get pbEnabled to bEnabled
71478>>>>>>>>>        Function_Return bEnabled
71479>>>>>>>>>    End_Function
71480>>>>>>>>>
71480>>>>>>>>>    // Enable the idle handler timer when the button is activated
71480>>>>>>>>>    Procedure Activating
71482>>>>>>>>>        Forward Send Activating
71484>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
71485>>>>>>>>>    End_Procedure
71486>>>>>>>>>
71486>>>>>>>>>    // Disable the idle handler when the button is deactivated
71486>>>>>>>>>    Procedure Deactivating
71488>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
71489>>>>>>>>>        Forward Send Deactivating
71491>>>>>>>>>    End_Procedure
71492>>>>>>>>>
71492>>>>>>>>>End_Class
71493>>>>>>>
71493>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
71493>>>>>>>Class cRDCButtonDPI is a cRDCButton
71494>>>>>>>    Procedure Construct_Object
71496>>>>>>>        Integer iIconSize
71496>>>>>>>        Forward Send Construct_Object
71498>>>>>>>        Set piImageMarginLeft to 10
71499>>>>>>>    End_Procedure
71500>>>>>>>
71500>>>>>>>    // Returns: DPI setting as an integer.
71500>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
71500>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
71500>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
71500>>>>>>>    Function GetCurrentDPI Returns Integer
71502>>>>>>>        Handle hDC
71502>>>>>>>        Integer iPixelsX
71502>>>>>>>        Move (GetDC(0)) to hDC
71503>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
71504>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
71505>>>>>>>        Function_Return iPixelsX
71506>>>>>>>    End_Function
71507>>>>>>>
71507>>>>>>>    Function GetCorrectIconSize Returns Integer
71509>>>>>>>        Integer iPixelsX iIndex iSize
71509>>>>>>>        Integer[] iaSizes
71510>>>>>>>
71510>>>>>>>        Move 16 to iaSizes[0]
71511>>>>>>>        Move 24 to iaSizes[1]
71512>>>>>>>        Move 32 to iaSizes[2]
71513>>>>>>>        Move 48 to iaSizes[3]
71514>>>>>>>        Move 64 to iaSizes[4]
71515>>>>>>>
71515>>>>>>>        Get piImageSize to iSize  // the "100%" size
71516>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
71517>>>>>>>        Move (0 max iIndex) to iIndex
71518>>>>>>>        Get GetCurrentDPI to iPixelsX
71519>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
71519>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
71519>>>>>>>        // will increment iIndex as many times as we need here.
71519>>>>>>>        Case Begin
71519>>>>>>>            Case (iPixelsX > 144)
71521>>>>>>>                Increment iIndex
71522>>>>>>>            Case (iPixelsX = 144)
71525>>>>>>>                Increment iIndex
71526>>>>>>>            Case (iPixelsX = 120)
71529>>>>>>>                Increment iIndex
71530>>>>>>>        Case End
71530>>>>>>>        Move (iIndex min 4) to iIndex
71531>>>>>>>        Function_Return iaSizes[iIndex]
71532>>>>>>>    End_Function
71533>>>>>>>
71533>>>>>>>    Procedure Set psToolTip String sToolTip
71535>>>>>>>        String sStatusHelp
71535>>>>>>>
71535>>>>>>>        Get Status_Help to sStatusHelp
71536>>>>>>>        If (sStatusHelp = "") Begin
71538>>>>>>>            Set Status_Help to sToolTip
71539>>>>>>>        End
71539>>>>>>>>
71539>>>>>>>
71539>>>>>>>        Forward Set psToolTip to sToolTip
71541>>>>>>>    End_Procedure
71542>>>>>>>
71542>>>>>>>End_Class
71543>>>>>
71543>>>>>Object oDeleteWorkspaceHistory_dg is a cRDCModalPanel
71545>>>>>    Set Label to "Delete Workspace History Items"
71546>>>>>    Set Size to 158 374
71547>>>>>    Set Location to 2 2
71548>>>>>    Set piMinSize to 158 345
71549>>>>>    Set Icon to "RemoveWorkspaceHistory.ico"
71550>>>>>
71550>>>>>    Property String[] pasWorkspaces
71552>>>>>
71552>>>>>    Object oInfo_tb is a TextBox
71554>>>>>        Set Size to 10 100
71555>>>>>        Set Location to 10 29
71556>>>>>        Set Label to "Use the spacebar to select items"
71557>>>>>    End_Object
71558>>>>>
71558>>>>>    Object oWorkspaceHistory_grd is a cRDCCJSelectionGrid
71560>>>>>        Set Size to 109 346
71561>>>>>        Set Location to 22 14
71562>>>>>        Set psNoItemsText to "No Workspace selected yet..."
71563>>>>>
71563>>>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
71565>>>>>            Set piWidth to 25
71566>>>>>        End_Object
71567>>>>>
71567>>>>>        Object oWorkspaceName_col is a cCJGridColumn
71569>>>>>            // This must be here:
71569>>>>>            Set phoData_Col to Self
71570>>>>>
71570>>>>>            Set piWidth to 602
71571>>>>>            Set psCaption to "Workspace Name"
71572>>>>>            Set psToolTip to "Workspace history name"
71573>>>>>            Set pbEditable to False
71574>>>>>        End_Object
71575>>>>>
71575>>>>>        Procedure LoadData
71578>>>>>            String sFolderName
71578>>>>>            Handle hoDataSource
71578>>>>>            tDataSourceRow[] TheData TheDataEmpty
71578>>>>>            tDataSourceRow[] TheData TheDataEmpty
71580>>>>>            tsSearchResult[] asFolderArray
71580>>>>>            tsSearchResult[] asFolderArray
71581>>>>>            Integer iSize iRow iCount iFolderCol iCheckBoxCol
71581>>>>>            String[] asWorkspaces
71582>>>>>
71582>>>>>            If (not(IsComObjectCreated(Self))) Begin
71584>>>>>                Procedure_Return
71585>>>>>            End
71585>>>>>>
71585>>>>>
71585>>>>>            Get pasWorkspaces to asWorkspaces
71586>>>>>            Move (SizeOfArray(asWorkspaces)) to iSize
71587>>>>>            If (iSize = 0) Begin
71589>>>>>                Procedure_Return
71590>>>>>            End
71590>>>>>>
71590>>>>>
71590>>>>>            Move 0 to iCount
71591>>>>>            Decrement iSize
71592>>>>>            Get phoDataSource to hoDataSource
71593>>>>>            Get DataSource of hoDataSource to TheData
71594>>>>>            Move TheDataEmpty to TheData
71595>>>>>            Get piColumnId of (phoData_Col(Self))     to iFolderCol
71596>>>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
71597>>>>>
71597>>>>>            Move 0 to iRow
71598>>>>>            For iCount From 0 to iSize
71604>>>>>>
71604>>>>>                Move asWorkspaces[iCount] to sFolderName
71605>>>>>                Move sFolderName to TheData[iRow].sValue[iFolderCol]
71606>>>>>                Move False to TheData[iRow].sValue[iCheckBoxCol]
71607>>>>>                Increment iRow
71608>>>>>            Loop
71609>>>>>>
71609>>>>>
71609>>>>>            If (iRow <> 0) Begin
71611>>>>>                Send ReInitializeData TheData False
71612>>>>>                Send MoveToFirstRow
71613>>>>>            End
71613>>>>>>
71613>>>>>            Else Begin
71614>>>>>                Send InitializeData TheDataEmpty
71615>>>>>            End
71615>>>>>>
71615>>>>>            Get CheckedItems to iCount
71616>>>>>            Set psFooterText of oWorkspaceName_col  to ("Selected Items:" * String(iCount))
71617>>>>>        End_Procedure
71618>>>>>
71618>>>>>        // We delete selected item(s) in three steps.
71618>>>>>        // 1. Check for selected items and delete them from the grid
71618>>>>>        // 2. Get the remainder of items from the grid to an array string
71618>>>>>        // 3. Delete all current items from the registry and write the new array string.
71618>>>>>        Function DeleteSelectedItems Returns Boolean
71621>>>>>            String[] asWorkspaces
71622>>>>>            Integer iCount iSize iRegistryItems iItem iWorkspaceName_col iCheckbox_Col
71622>>>>>            Handle hoDataSource
71622>>>>>            tDataSourceRow[] TheData NewData
71622>>>>>            tDataSourceRow[] TheData NewData
71624>>>>>            Boolean bChecked
71624>>>>>
71624>>>>>            Move False to Err
71625>>>>>            Get piColumnId of oWorkspaceName_col to iWorkspaceName_col
71626>>>>>            Get piColumnId of oCheckbox_col      to iCheckbox_Col
71627>>>>>            Get phoDataSource to hoDataSource
71628>>>>>            Get DataSource    of hoDataSource to TheData
71629>>>>>            Move (SizeOfArray(TheData)) to iSize
71630>>>>>            Decrement iSize
71631>>>>>            Move 0 to iItem
71632>>>>>
71632>>>>>            // 1. Delete selected grid items
71632>>>>>            For iCount From 0 to iSize
71638>>>>>>
71638>>>>>                Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
71639>>>>>                If (bChecked = False) Begin
71641>>>>>                    Move TheData[iCount] to NewData[iItem]
71642>>>>>                    Increment iItem
71643>>>>>                End
71643>>>>>>
71643>>>>>            Loop
71644>>>>>>
71644>>>>>            Send ReInitializeData NewData False
71645>>>>>            Send MoveToFirstRow
71646>>>>>
71646>>>>>            // 2. Get the grid data again and move items to string array
71646>>>>>            Get DataSource of hoDataSource to TheData
71647>>>>>            Move (SizeOfArray(TheData)) to iSize
71648>>>>>            Decrement iSize
71649>>>>>            Move 0 to iItem
71650>>>>>            For iCount From 0 to iSize
71656>>>>>>
71656>>>>>                Move TheData[iCount].sValue[iWorkspaceName_col] to asWorkspaces[iItem]
71657>>>>>                Increment iItem
71658>>>>>            Loop
71659>>>>>>
71659>>>>>
71659>>>>>            // Get max number of workspaces that can be saved to the registry.
71659>>>>>            Get piWorkspaceItems of ghoApplication to iRegistryItems
71660>>>>>
71660>>>>>            // 3. Delete all current items from the registry and write the new array string, then write the new ones.
71660>>>>>            For iCount From 0 to iRegistryItems
71666>>>>>>
71666>>>>>                Send WriteString of ghoApplication CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) ""
71667>>>>>            Loop
71668>>>>>>
71668>>>>>
71668>>>>>            Move (SizeOfArray(asWorkspaces)) to iSize
71669>>>>>            Decrement iSize
71670>>>>>            For iCount From 0 to iSize
71676>>>>>>
71676>>>>>                Send WriteString of ghoApplication CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) asWorkspaces[iCount]
71677>>>>>            Loop
71678>>>>>>
71678>>>>>
71678>>>>>            Send DoSetCheckboxFooterText
71679>>>>>            Function_Return (Err = False)
71680>>>>>        End_Function
71681>>>>>
71681>>>>>        On_Key Key_Space Send ToggleCurrentItem
71682>>>>>    End_Object
71683>>>>>
71683>>>>>    Object oOK_Btn is a cRDCButtonDPI
71685>>>>>        Set Label to "Delete"
71686>>>>>        Set Location to 137 255
71687>>>>>        Set peAnchors to anBottomRight
71688>>>>>        Set psImage to "ActionDelete.ico"
71689>>>>>
71689>>>>>        Procedure OnClick
71692>>>>>            Integer iCount iRetval
71692>>>>>            Boolean bOK
71692>>>>>
71692>>>>>            Get CheckedItems of oWorkspaceHistory_grd to iCount
71693>>>>>            If (iCount = 0) Begin
71695>>>>>                Send Info_Box "You need to select at least one workspace history item to delete. Please adjust and try again."
71696>>>>>                Procedure_Return
71697>>>>>            End
71697>>>>>>
71697>>>>>
71697>>>>>            Get YesNo_Box ("Are you sure you want to delete" * String(iCount) * "history workspaces from the registry?") to iRetval
71698>>>>>            If (iRetval <> MBR_Yes) Begin
71700>>>>>                Procedure_Return
71701>>>>>            End
71701>>>>>>
71701>>>>>
71701>>>>>            Get DeleteSelectedItems of oWorkspaceHistory_grd to bOK
71702>>>>>            If (bOK = True) Begin
71704>>>>>                Send Info_Box "Selected item(s) successfully deleted from the registry"
71705>>>>>            End
71705>>>>>>
71705>>>>>            Else Begin
71706>>>>>                Send Info_Box "Nope, that didn't work. It did not work to delete the selected item(s)."
71707>>>>>            End
71707>>>>>>
71707>>>>>
71707>>>>>        End_Procedure
71708>>>>>
71708>>>>>        On_Key kCancel Send KeyAction of oCancel_Btn
71709>>>>>    End_Object
71710>>>>>
71710>>>>>    Object oCancel_Btn is a Button
71712>>>>>        Set Label to "Close"
71713>>>>>        Set Location to 137 310
71714>>>>>        Set peAnchors to anBottomRight
71715>>>>>
71715>>>>>        Procedure OnClick
71718>>>>>            Send Close_Panel
71719>>>>>        End_Procedure
71720>>>>>
71720>>>>>        On_Key kCancel Send KeyAction of oCancel_Btn
71721>>>>>    End_Object
71722>>>>>
71722>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
71723>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
71724>>>>>End_Object
71725>>>>>
71725>>>>>Procedure ActivateDeleteWorkspaceHistoryDialog String[] asWorkspaces
71727>>>>>    Handle ho
71727>>>>>    Move (oDeleteWorkspaceHistory_dg(Self)) to ho
71728>>>>>    Set pasWorkspaces of ho to asWorkspaces
71729>>>>>    Send Popup of ho
71730>>>>>End_Procedure
71731>>>
71731>>>Global_Variable Integer ghoFileSystem
71731>>>
71731>>>Class cRefactorApplication is a cApplication
71732>>>    
71732>>>    Procedure Construct_Object
71734>>>        Forward Send Construct_Object
71736>>>
71736>>>        Property String private.psFileCompareApp
71737>>>        Property String private.psStarZenSourceExplorer
71738>>>        Property Integer private.piToolbarIconSize 0
71739>>>        Property String private.psGridRowBackgroundColor 0
71740>>>        Property String private.psSWSFile       ""
71741>>>        Property Boolean private.pbWorkspaceMode True
71742>>>        Property Boolean private.pbShouldBackupFile True
71743>>>        Property Integer private.piActiveView -1
71744>>>        Property Handle private.phoActiveView -1 
71745>>>        
71745>>>        // Used by the DfAbout object to display the compile date & time.
71745>>>        // See also: End_Construct_Object in this class.
71745>>>        Property String psCompileDateAndTime ""
71746>>>        
71746>>>        Property Handle phoEditorView 0
71747>>>        Property Handle phoRefactorView 0
71748>>>        Property Handle phoEditor 0
71749>>>    
71749>>>        Property String psHomePath  ""
71750>>>        Property String psCurrentSourceFileName ""
71751>>>        Property Integer piWorkspaceItems 9 // Zero based
71752>>>    
71752>>>        // For the Scintilla editor
71752>>>        Property String psStartupProgramPath ""
71753>>>        Property String psStartupBitmapPath  ""
71754>>>
71754>>>        Get Create (RefClass(cFilesystem)) to ghoFileSystem
71755>>>                                      
71755>>>        Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_BINARY
71755>>>    End_Procedure
71756>>>
71756>>>    // Note; This logic uses the Include_Resource info above to set the
71756>>>    // ghoApplication property; psCompileDateAndTime that is used by the DfAbout object
71756>>>    // to show the compiled date & time.
71756>>>    // The includeded file CompileHeader.h is generated by the "Before Compilation Process",
71756>>>    // setup in the project properties "Compiler" tab-page. 
71756>>>    Procedure End_Construct_Object
71758>>>        String sCompileTime  
71758>>>        Integer iPos
71758>>>        
71758>>>        Forward Send End_Construct_Object
71760>>>        Direct_Input "resource: res_CompileHeader"
71761>>>        Readln sCompileTime
71762>>>        Move (Pos('"', sCompileTime)) to iPos
71763>>>        If (iPos <> 0) Begin
71765>>>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
71766>>>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
71767>>>            Set psCompileDateAndTime to sCompileTime
71768>>>        End
71768>>>>
71768>>>        Close_Input
71769>>>        
71769>>>        Open SysFile
Including file: SysFile.fd    (C:\Projects\DF18\DfRefactor\DDSrc\SysFile.fd)
71771>>>        Set private.psStarZenSourceExplorer to (Trim(SysFile.PathStarZen)) 
71772>>>    End_Procedure
71773>>>
71773>>>    Function SourceFilePath Returns String
71775>>>        String sFileName sPath
71775>>>
71775>>>        Get psHomePath to sPath
71776>>>        Get psCurrentSourceFileName to sFileName
71777>>>        If (sFileName <> "") Begin
71779>>>            Get ParseFolderName sFileName to sPath
71780>>>        End
71780>>>>
71780>>>        Function_Return sPath
71781>>>    End_Function
71782>>>
71782>>>    Procedure Set piToolbarIconSize Integer iSize
71784>>>        Send WriteDword CS_Settings CS_ToolbarIconSize iSize
71785>>>        Set private.piToolbarIconSize to iSize
71786>>>        Set piToolbarIconSize of ghoCommandBars to iSize
71787>>>    End_Procedure
71788>>>
71788>>>    Function piToolbarIconSize Returns Integer
71790>>>        Integer iSize
71790>>>        Get private.piToolbarIconSize to iSize
71791>>>        If (iSize = 0) Begin
71793>>>            Get ReadDword CS_Settings CS_ToolbarIconSize 24 to iSize
71794>>>            Set private.piToolbarIconSize to iSize
71795>>>        End
71795>>>>
71795>>>        Function_Return iSize
71796>>>    End_Function
71797>>>
71797>>>    Procedure Set psGridRowBackgroundColor String sColor
71799>>>        Set private.psGridRowBackgroundColor to sColor
71800>>>        Send WriteString CS_Settings CS_GridRowBackgroundColor sColor
71801>>>        Broadcast Recursive Set piSelectedRowBackColor of (Client_Id(phoMainPanel(ghoApplication))) to sColor
71803>>>        Broadcast Recursive Set piHighlightBackColor   of (Client_Id(phoMainPanel(ghoApplication))) to sColor
71805>>>    End_Procedure
71806>>>
71806>>>    Function psGridRowBackgroundColor Returns String
71808>>>        String sColor
71808>>>        Get private.psGridRowBackgroundColor to sColor
71809>>>        If (sColor = 0) Begin
71811>>>            Get ReadString CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
71812>>>            If (sColor contains "clBlueGrey") Begin
71814>>>                Move (Replace("clBlueGrey", sColor, "clGreenGrey")) to sColor
71815>>>            End
71815>>>>
71815>>>            Set private.psGridRowBackgroundColor to sColor
71816>>>        End
71816>>>>
71816>>>        Function_Return sColor
71817>>>    End_Function
71818>>>
71818>>>    Procedure Set psFileCompareApp String sProgramName
71820>>>        Send WriteString CS_Settings CS_FileCompareProgram sProgramName
71821>>>        Set private.psFileCompareApp to sProgramName
71822>>>    End_Procedure
71823>>>
71823>>>    Function psFileCompareApp Returns String
71825>>>        String sProgramName
71825>>>        Get private.psFileCompareApp to sProgramName
71826>>>        If (sProgramName = "") Begin
71828>>>            Get ReadString CS_Settings CS_FileCompareProgram "" to sProgramName
71829>>>            Set private.psFileCompareApp to sProgramName
71830>>>        End
71830>>>>
71830>>>        Function_Return sProgramName
71831>>>    End_Function
71832>>>
71832>>>    Procedure Set psStarZenSourceExplorer String sProgramName
71834>>>        Send WriteString CS_Settings CS_StarZenSourceExplorer sProgramName
71835>>>        Set private.psStarZenSourceExplorer to sProgramName
71836>>>    End_Procedure
71837>>>
71837>>>    Function psStarZenSourceExplorer Returns String
71839>>>        String sProgramName
71839>>>        Get private.psStarZenSourceExplorer to sProgramName
71840>>>        If (sProgramName = "") Begin
71842>>>            Get ReadString CS_Settings CS_StarZenSourceExplorer "" to sProgramName
71843>>>            Set private.psStarZenSourceExplorer to sProgramName
71844>>>        End
71844>>>>
71844>>>        Function_Return sProgramName
71845>>>    End_Function
71846>>>
71846>>>    Procedure DisplayPerfCounters
71848>>>    End_Procedure
71849>>>
71849>>>    Function StartPerfCounter Integer eOperation String sComment Returns Integer
71851>>>        Function_Return 0
71852>>>    End_Function
71853>>>
71853>>>    Procedure StopPerfCounter Integer iCounter
71855>>>    End_Procedure
71856>>>
71856>>>    Procedure Set piActiveView Integer iActiveViewID Handle hoActiveView
71858>>>        Set Private.piActiveView  to iActiveViewID
71859>>>        Set Private.phoActiveView to hoActiveView
71860>>>    End_Procedure
71861>>>
71861>>>    Function piActiveView Returns Integer
71863>>>        Function_Return (Private.piActiveView(Self))
71864>>>    End_Function
71865>>>
71865>>>    Function phoActiveView Returns Integer
71867>>>        Function_Return (Private.phoActiveView(Self))
71868>>>    End_Function
71869>>>
71869>>>    Procedure AddWorkSpaceFileToRegistry String sFileName
71871>>>        Integer iCount iSize
71871>>>        String[] sWorkspaces
71872>>>        Boolean bFound
71872>>>
71872>>>        Get piWorkspaceItems to iSize
71873>>>        // Is the selected .sws file new?
71873>>>        For iCount from 0 to iSize
71879>>>>
71879>>>            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) "" to sWorkspaces[iCount]
71880>>>            If (Uppercase(sWorkspaces[iCount]) = Uppercase(sFilename)) Begin
71882>>>                Move True to bFound
71883>>>            End
71883>>>>
71883>>>        Loop
71884>>>>
71884>>>
71884>>>        // If new, save it to the registry. Push it to the top of the stack (LiFo).
71884>>>        If (bFound = False) Begin
71886>>>            Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + "0") sFilename
71887>>>            Decrement iSize
71888>>>            For iCount from 0 to iSize
71894>>>>
71894>>>                If (sWorkspaces[iCount] <> "") Begin
71896>>>                    Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount + 1)) sWorkspaces[iCount]
71897>>>                End
71897>>>>
71897>>>            Loop
71898>>>>
71898>>>        End
71898>>>>
71898>>>    End_Procedure
71899>>>
71899>>>    Function ReadWorkspaceKeysFromRegistry Returns String[]
71901>>>        Integer iCount iSize iItem
71901>>>        String[] asWorkspaces
71902>>>        String sWorkspace
71902>>>
71902>>>        Move 0 to iItem
71903>>>        Get piWorkspaceItems to iSize
71904>>>        For iCount from 0 to iSize
71910>>>>
71910>>>            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) '' to sWorkspace
71911>>>            If (sWorkspace <> "") Begin
71913>>>                Move sWorkspace to asWorkspaces[iItem]
71914>>>                Increment iItem
71915>>>            End
71915>>>>
71915>>>        Loop
71916>>>>
71916>>>        Function_Return asWorkspaces
71917>>>    End_Function
71918>>>
71918>>>    Procedure DeleteWorkSpaceHistoryFromRegistry
71920>>>        String[] asWorkspaces
71921>>>
71921>>>        Get ReadWorkspaceKeysFromRegistry to asWorkspaces
71922>>>        Send ActivateDeleteWorkspaceHistoryDialog of (Client_Id(phoMainPanel(ghoApplication))) asWorkspaces
71923>>>    End_Procedure
71924>>>
71924>>>    // Pass an SWS file with full path.
71924>>>    // Returns the .ws file name of the Programs folder.
71924>>>    Function WsFileNameFromSWSFileName String sSWSFilename Returns String
71926>>>        Handle hoIni
71926>>>        String sWs sWorkspaceFileName
71926>>>
71926>>>        Get Create (RefClass(cIniFile)) to hoIni
71927>>>        Set psFilename of hoIni  to sSWSFilename
71928>>>        Get ReadString of hoIni CS_WorkspacePaths CS_ConfigFile "" to sWs
71929>>>        Send Destroy   of hoIni
71930>>>        Move (Replace(".\", sWs, ExtractFilePath(sSWSFilename))) to sWorkspaceFileName
71931>>>
71931>>>        Function_Return sWorkspaceFileName
71932>>>    End_Function
71933>>>
71933>>>    Procedure ToggleWorkspaceAndFileMode
71935>>>    End_Procedure
71936>>>
71936>>>    Procedure Set pbWorkspaceMode Boolean bState
71938>>>        Set private.pbWorkspaceMode to bState
71939>>>        Send ToggleWorkspaceAndFileMode
71940>>>    End_Procedure
71941>>>
71941>>>    Function pbWorkspaceMode Returns Boolean
71943>>>        Function_Return (private.pbWorkspaceMode(Self))
71944>>>    End_Function
71945>>>
71945>>>    Procedure Set pbShouldBackupFile Boolean bState
71947>>>        Send WriteDword CS_Settings CS_CreateBackupFiles bState
71948>>>        Set private.pbShouldBackupFile to bState
71949>>>    End_Procedure
71950>>>
71950>>>    Function pbShouldBackupFile Returns Boolean
71952>>>        Boolean bState
71952>>>        Get private.pbShouldBackupFile to bState
71953>>>        Function_Return bState
71954>>>    End_Function
71955>>>
71955>>>    // Will create a backup-folder for the passed file, if-and-only-if it doesn't exists.
71955>>>    // Returns the full path to the backup folder.
71955>>>    Function CreateBackupFolder String sFile Returns String
71957>>>        String sPath sHomePath sBackupFolder
71957>>>        Boolean bFolderExists bSuccess
71957>>>        Integer iRetval iPos
71957>>>
71957>>>        Move "" to sPath
71958>>>        Get psHomePath            to sHomePath
71959>>>        If (sFile <> "") Begin
71961>>>        Get ParseFolderName sFile to sPath
71962>>>        Move (Replace(Lowercase(sHomePath), Lowercase(sPath), "")) to sPath // Only want the subfolder structure
71963>>>        Move (Pos(":", sPath)) to iPos
71964>>>        If (iPos > 0) Begin
71966>>>            Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
71967>>>            Move (Pos(CS_DirSeparator, sPath)) to iPos
71968>>>            If (iPos > 0) Begin
71970>>>                Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
71971>>>            End
71971>>>>
71971>>>        End
71971>>>>
71971>>>        End
71971>>>>
71971>>>
71971>>>        Move (sHomePath + CS_BackupFolder + CS_DirSeparator + sPath) to sBackupFolder
71972>>>        Get RemoveFolderSeperator of ghoFileSystem sBackupFolder to sBackupFolder
71973>>>        Get vFolderExists sBackupFolder to bFolderExists
71974>>>        If (bFolderExists = False) Begin
71976>>>            Get DirectoryCreateEx of ghoFileSystem sBackupFolder False to bSuccess
71977>>>            If (bSuccess = False) Begin
71979>>>                Get YesNo_Box ("Warning! The" * String(sHomePath) + "\DFRefactor Backup folder could not be created. You should abort the program now, fix the cause and restart. Abort the program?") to iRetval
71980>>>                If (iRetval = MBR_Yes) Begin
71982>>>                    Send Exit_Application
71983>>>                End
71983>>>>
71983>>>            End
71983>>>>
71983>>>        End
71983>>>>
71983>>>        Get vFolderFormat sBackupFolder to sBackupFolder
71984>>>        Function_Return sBackupFolder
71985>>>    End_Function
71986>>>
71986>>>    Function IsBackupFolder Returns Boolean
71988>>>        String sHomePath sBackupFolder
71988>>>        Boolean bExists
71988>>>
71988>>>        Get psHomePath to sHomePath
71989>>>        Get vFolderFormat sHomePath to sHomePath
71990>>>        Move (sHomePath + CS_BackupFolder) to sBackupFolder
71991>>>        Get vFolderExists sBackupFolder to bExists
71992>>>
71992>>>        Function_Return bExists
71993>>>    End_Function
71994>>>
71994>>>    // Takes a source file name with full path as parameter.
71994>>>    // Returns a name with full path for it's backup file counterpart.
71994>>>    // If the backup folder doesn't exist, it will be created, aka
71994>>>    // the BackupFolder function is used.
71994>>>    Function BackupFileName String sPathFileName Returns String
71996>>>        String sBackupFolder sFileName sBackupFile
71996>>>        Integer iPos
71996>>>
71996>>>        Get CreateBackupFolder sPathFileName   to sBackupFolder
71997>>>        Get vFolderFormat sBackupFolder  to sBackupFolder
71998>>>        Get ParseFileName sPathFileName  to sFileName
71999>>>        Move (Pos(":", sFileName))       to iPos
72000>>>        If (iPos > 0) Begin
72002>>>            Move (Mid(sFileName, CI_EOL, iPos)) to sFileName
72003>>>        End
72003>>>>
72003>>>        Move (sBackupFolder + sFileName) to sBackupFile
72004>>>
72004>>>        Function_Return sBackupFile
72005>>>    End_Function
72006>>>
72006>>>    Function HomeBackupFilePath Returns String
72008>>>        Boolean bExist
72008>>>        String sPath sPathBackup
72008>>>
72008>>>        Get psHomePath to sPath
72009>>>        If (sPath <> "") Begin
72011>>>            Get vFolderFormat sPath to sPath
72012>>>            Move (sPath + CS_BackupFolder) to sPathBackup
72013>>>            Get FileExists of ghoFileSystem sPathBackup DIRMODE_DIRECTORIES_ONLY to bExist
72014>>>            If (bExist) Begin
72016>>>                Move sPathBackup to sPath
72017>>>            End
72017>>>>
72017>>>            Else Begin
72018>>>                Move "" to sPath
72019>>>            End
72019>>>>
72019>>>        End
72019>>>>
72019>>>        Function_Return sPath
72020>>>    End_Function
72021>>>
72021>>>    Function SaveBackupFile String sSourceFile Returns Boolean
72023>>>        Boolean bOK bExists bShouldBackup
72023>>>        String sBackupFile
72023>>>        Date dWriteSource dWriteBackup
72023>>>//        tFileTime ftCurrentTime  
72023>>>        structSystemTime ftCurrentTime
72023>>>        structSystemTime ftCurrentTime
72023>>>
72023>>>        Move True to bShouldBackup
72024>>>        Get BackupFileName sSourceFile to sBackupFile
72025>>>        Get FileExists of ghoFileSystem sBackupFile to bExists
72026>>>        If (bExists = True) Begin
72028>>>            Get FileDate of ghoFileSystem sSourceFile to dWriteSource
72029>>>            Get FileDate of ghoFileSystem sBackupFile to dWriteBackup
72030>>>            Move ((dWriteSource - dWriteBackup) > 2 or (dWriteBackup - dWriteSource) > 2) to bShouldBackup
72031>>>        End
72031>>>>
72031>>>
72031>>>        // If we make a backup copy of the file we change the date & time,
72031>>>        // to present time. This is so we later - if the 'Start Process' button is
72031>>>        // pressed again - decide to _not_ backup the file again iif it has todays,
72031>>>        // or yesterday's date. That way the user can press the "Start Process"
72031>>>        // button several times without the backup file gets overwritten by a
72031>>>        // file that has been changed all ready - keeping the original source file
72031>>>        // intact.
72031>>>        If (bShouldBackup = True) Begin
72033>>>            Get FileCopy of ghoFileSystem sSourceFile sBackupFile False to bOK
72034>>>            Get CurrentSystemTimeAsFileTime of ghoFileSystem to ftCurrentTime
72035>>>            Set FileLastWriteTime of ghoFileSystem to sBackupFile ftCurrentTime
72036>>>            Get FileExists of ghoFileSystem sBackupFile to bExists
72037>>>        End
72037>>>>
72037>>>
72037>>>        Function_Return bExists
72038>>>    End_Function
72039>>>
72039>>>    // Does a backup copy of the current source file exist?
72039>>>    Function IsBackupFile String sCurrentFileName Returns String
72041>>>        String sPath sFile sHomePath sBackupFolder sBackupFile sExt
72041>>>        Boolean bExists
72041>>>        tsSearchResult[] SearchResultArray
72041>>>        tsSearchResult[] SearchResultArray
72042>>>
72042>>>        If (sCurrentFileName = "") Begin
72044>>>            Function_Return ""
72045>>>        End
72045>>>>
72045>>>
72045>>>        Get psHomePath to sHomePath
72046>>>        Get ParseFolderName sCurrentFileName to sPath
72047>>>        Move (sHomePath + CS_BackupFolder) to sBackupFolder
72048>>>        Get vFolderExists sBackupFolder to bExists
72049>>>        If (bExists = False) Begin
72051>>>            Function_Return ""
72052>>>        End
72052>>>>
72052>>>
72052>>>        Move "" to sBackupFile
72053>>>        Get ParseFileName sCurrentFileName to sFile
72054>>>        Get ParseFileExtension sFile to sExt
72055>>>        Move (Replace(sExt, sFile, "")) to sFile
72056>>>        Get vFolderFormat sBackupFolder to sBackupFolder
72057>>>        Move (sBackupFolder + sFile + String("*")) to sFile
72058>>>        Get FileSearchRecursive of ghoFileSystem sFile DIRMODE_FILES_ONLY True to SearchResultArray
72059>>>        If (SizeOfArray(SearchResultArray)) Begin
72061>>>            Move SearchResultArray[0].sFilename to sBackupFile
72062>>>        End
72062>>>>
72062>>>
72062>>>        Function_Return sBackupFile
72063>>>    End_Function
72064>>>
72064>>>    Function AllBackupFolderFiles Returns tsSearchResult[]
72066>>>        Boolean bExists
72066>>>        String sBackupHomeFolder sBackupFolder sHomePath sFileMask sFileName
72066>>>        String[] asNoFolderSearch asBackupFolders
72068>>>        tsSearchResult[] asBackupFilesEmpty asBackupFiles asBackupFilesTotal
72068>>>        tsSearchResult[] asBackupFilesEmpty asBackupFiles asBackupFilesTotal
72071>>>        Integer iFolder iFolders iFile iFiles
72071>>>
72071>>>        Get psHomePath to sHomePath
72072>>>        Get vFolderFormat sHomePath to sHomePath
72073>>>        Move (sHomePath + CS_BackupFolder) to sBackupHomeFolder
72074>>>        Get vFolderExists sBackupHomeFolder to bExists
72075>>>        If (bExists = False) Begin
72077>>>            Function_Return asBackupFilesEmpty
72078>>>        End
72078>>>>
72078>>>
72078>>>        Get NoFolderListAsArray True to asNoFolderSearch
72079>>>        Get RecursiveSearchFolders sBackupHomeFolder asNoFolderSearch to asBackupFolders
72080>>>        Move (SizeOfArray(asBackupFolders)) to iFolders
72081>>>        Decrement iFolders
72082>>>        For iFolder from 0 to iFolders
72088>>>>
72088>>>            Move asBackupFolders[iFolder] to sBackupFolder
72089>>>            Get vFolderFormat sBackupFolder to sBackupFolder
72090>>>            Move (sBackupFolder + "*.*") to sFileMask
72091>>>
72091>>>            // File loop:
72091>>>            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asBackupFiles
72092>>>            // Remove report files created by the DFRefactor tool.
72092>>>            If (SizeOfArray(asBackupFiles)) Begin
72094>>>                If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_SummaryLogfileName) Begin
72096>>>                    Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
72097>>>                    If (SizeOfArray(asBackupFiles)) Begin
72099>>>                        If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_UnusedSourceLogFile) Begin
72101>>>                            Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
72102>>>                        End
72102>>>>
72102>>>                    End
72102>>>>
72102>>>                End
72102>>>>
72102>>>            End
72102>>>>
72102>>>            Move (SizeOfArray(asBackupFiles)) to iFiles
72103>>>            Decrement iFiles
72104>>>            For iFile from 0 to iFiles
72110>>>>
72110>>>                Move asBackupFiles[iFile].sFilename to sFileName
72111>>>                // Store the path in the sAlternateFileName struct item
72111>>>                Move sBackupFolder to asBackupFiles[iFile].sAlternateFileName
72112>>>            Loop
72113>>>>
72113>>>            Move (AppendArray(asBackupFilesTotal, asBackupFiles)) to asBackupFilesTotal
72114>>>        Loop
72115>>>>
72115>>>
72115>>>        Function_Return asBackupFilesTotal
72116>>>    End_Function
72117>>>
72117>>>    Function AllSourceFolders String[] asSelectedFolders Returns String[]
72119>>>        String sHomePath
72119>>>        String[] asNoFolderSearch asSourceFolders asAllSourceFolders
72122>>>        Integer iSize iCount
72122>>>
72122>>>        Get psHomePath to sHomePath
72123>>>        Get vFolderFormat sHomePath to sHomePath
72124>>>
72124>>>        Get NoFolderListAsArray False to asNoFolderSearch
72125>>>        Move (SizeOfArray(asSelectedFolders)) to iSize
72126>>>        Decrement iSize
72127>>>        For iCount from 0 to iSize
72133>>>>
72133>>>            Get RecursiveSearchFolders asSelectedFolders[iCount] asNoFolderSearch to asSourceFolders
72134>>>            Move (AppendArray(asAllSourceFolders, asSourceFolders)) to asAllSourceFolders
72135>>>        Loop
72136>>>>
72136>>>
72136>>>        Function_Return asAllSourceFolders
72137>>>    End_Function
72138>>>
72138>>>    Function AllSourceFiles String[] asSelectedFolders String sFileFilter Returns tsSearchResult[]
72140>>>        Boolean bIsFileInFilter
72140>>>        String sSourceFolder sFileMask sFileName
72140>>>        String[] asAllSourceFolders
72141>>>        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
72141>>>        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
72144>>>        Integer iFolder iFolders iFile iFiles
72144>>>
72144>>>        Move asSelectedFolders to asAllSourceFolders
72145>>>        Move (SizeOfArray(asAllSourceFolders)) to iFolders
72146>>>        Decrement iFolders
72147>>>
72147>>>        // Folder loop:
72147>>>        For iFolder from 0 to iFolders
72153>>>>
72153>>>            Move asAllSourceFolders[iFolder] to sSourceFolder
72154>>>            Get vFolderFormat sSourceFolder to sSourceFolder
72155>>>            Move (sSourceFolder + "*.*") to sFileMask
72156>>>
72156>>>            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asSourceFiles
72157>>>            Move (SizeOfArray(asSourceFiles)) to iFiles
72158>>>            Decrement iFiles
72159>>>
72159>>>            // File loop:
72159>>>            For iFile from 0 to iFiles
72165>>>>
72165>>>                Move asSourceFiles[iFile].sFilename to sFileName
72166>>>                Get IsFileInFilter sFileName sFileFilter to bIsFileInFilter
72167>>>                If (bIsFileInFilter = True) Begin
72169>>>                    // Store the path in the sAlternateFileName struct item
72169>>>                    Move sSourceFolder to asSourceFiles[iFile].sAlternateFileName
72170>>>                End
72170>>>>
72170>>>                Else Begin
72171>>>                    Move (RemoveFromArray(asSourceFiles, iFile)) to asSourceFiles
72172>>>                    Decrement iFile
72173>>>                    Decrement iFiles
72174>>>                End
72174>>>>
72174>>>            Loop
72175>>>>
72175>>>            Move (AppendArray(asSourceFilesTotal, asSourceFiles)) to asSourceFilesTotal
72176>>>        Loop
72177>>>>
72177>>>
72177>>>        Function_Return asSourceFilesTotal
72178>>>    End_Function
72179>>>
72179>>>    Function IsFileInFilter String sFileName String sFileFilter Returns Boolean
72181>>>        Integer iSearchIndex
72181>>>        String sExtension sChar
72181>>>        String[] asFileFilter
72182>>>
72182>>>        Move (Lowercase(sFileName))      to sFileName
72183>>>        Get ParseFileExtension sFileName to sExtension
72184>>>        Move (Left(sExtension, 1))       to sChar
72185>>>        If (sChar <> ".") Begin
72187>>>            Move ("." + String(sExtension)) to sExtension
72188>>>        End
72188>>>>
72188>>>        Move (Lowercase(sFileFilter))         to sFileFilter
72189>>>        Move (Replaces("*", sFileFilter, "")) to sFileFilter
72190>>>        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilter
72191>>>        Move (SearchArray(sExtension, asFileFilter)) to iSearchIndex
72192>>>        Function_Return (iSearchIndex <> -1)
72193>>>    End_Function
72194>>>
72194>>>    Function RecursiveSearchFolders String sSourceFolder String[] asNoFolderList Returns String[]
72196>>>        Boolean bFound
72196>>>        Integer iCount iSize iItem
72196>>>        String sMask sFileName sPrevFolderName sHomePath
72196>>>        tsSearchResult[] asSearchResult
72196>>>        tsSearchResult[] asSearchResult
72197>>>        String[] saSearchFolders
72198>>>
72198>>>        If (not(sSourceFolder contains ":")) Begin
72200>>>            Get psHomePath to sHomePath
72201>>>            Get vFolderFormat sHomePath to sHomePath
72202>>>            Move (sHomePath + sSourceFolder) to sSourceFolder
72203>>>        End
72203>>>>
72203>>>        Get vFolderFormat sSourceFolder to sSourceFolder
72204>>>        Move (sSourceFolder + "*") to sMask
72205>>>
72205>>>        Move 0 to iItem
72206>>>
72206>>>        // Recursive folder search
72206>>>        Get FileSearchRecursive of ghoFileSystem sMask DIRMODE_DIRECTORIES_ONLY False to asSearchResult
72207>>>        Move (SizeOfArray(asSearchResult)) to iSize
72208>>>        Decrement iSize
72209>>>
72209>>>        // Remove folder names from array where we should not search for source files
72209>>>        Move "" to sPrevFolderName
72210>>>        For iCount from 0 to iSize
72216>>>>
72216>>>            Get IsFolderInNoFolderList of ghoApplication asNoFolderList asSearchResult[iCount].sFilename to bFound
72217>>>            If (bFound = False) Begin
72219>>>                If (asSearchResult[iCount].sFilename <> sPrevFolderName) Begin
72221>>>                    Move asSearchResult[iCount].sFilename to saSearchFolders[iItem]
72222>>>                    Increment iItem
72223>>>                End
72223>>>>
72223>>>            End
72223>>>>
72223>>>            Move asSearchResult[iCount].sFilename to sPrevFolderName
72224>>>        Loop
72225>>>>
72225>>>
72225>>>        Move sSourceFolder to saSearchFolders[SizeOfArray(saSearchFolders)]
72226>>>        // Sort the folder array to get the top one first.
72226>>>        Move (SortArray(saSearchFolders)) to saSearchFolders
72227>>>
72227>>>        Function_Return saSearchFolders
72228>>>    End_Function
72229>>>
72229>>>    Procedure ComparePaths String sCompareApp
72231>>>        String sPath sPathBackup
72231>>>
72231>>>        Get psHomePath to sPath
72232>>>        Get HomeBackupFilePath to sPathBackup
72233>>>        If (sPath <> "" and sPathBackup <> "") Begin
72235>>>            Runprogram Background ('"' + sCompareApp + '"') ('"' + sPath + '" "' + sPathBackup + '"')
72236>>>        End
72236>>>>
72236>>>    End_Procedure
72237>>>
72237>>>    Procedure CompareFiles String sCompareApp
72239>>>        Boolean bExist
72239>>>        String sFileName sFile sFileBackup sCurrentFileName
72239>>>
72239>>>        Get psCurrentSourceFileName to sFileName
72240>>>        If (sFileName <> "") Begin
72242>>>            Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bExist
72243>>>            If (bExist) Begin
72245>>>                Get psCurrentSourceFileName to sCurrentFileName
72246>>>                Get IsBackupFile sCurrentFileName to sFileBackup
72247>>>                If (sFileBackup <> "") Begin
72249>>>                    Runprogram Background ('"' + sCompareApp + '"') ('"' + sFileName + '" "' + sFileBackup + '"')
72250>>>                End
72250>>>>
72250>>>                Else Begin
72251>>>                    Send Info_Box ("Cannot find the backup file file" * sFileBackup)
72252>>>                End
72252>>>>
72252>>>            End
72252>>>>
72252>>>            Else Begin
72253>>>                Send Info_Box ("The file in the source file" * sFileName * "\nDoes not exist.")
72254>>>            End
72254>>>>
72254>>>        End
72254>>>>
72254>>>        Else Begin
72255>>>            Send Info_Box "You have to select a file first."
72256>>>        End
72256>>>>
72256>>>    End_Procedure
72257>>>
72257>>>    // Returns the current Studio "File mask" setting as a string. See
72257>>>    Function StudioFileMaskSettings Returns String
72259>>>        Handle hoReg
72259>>>        String sStudioRegPath sRetval sDFVersion
72259>>>        Boolean bExists bOk
72259>>>        Integer iMajorVersion iMinorVersion
72259>>>
72259>>>        Move FMAC_VERSION  to iMajorVersion
72260>>>        Move FMAC_REVISION to iMinorVersion
72261>>>        Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sDFVersion
72262>>>
72262>>>        Get Create (RefClass(cRegistry)) to hoReg
72263>>>        Set pfAccessRights of hoReg to Key_Read
72264>>>
72264>>>        Move CS_StudioToolsPathStart to sStudioRegPath
72265>>>        Move (sStudioRegPath + sDFVersion + CS_StudioToolsPathEnd) to sStudioRegPath
72266>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
72267>>>
72267>>>        // First check if the DF version is installed
72267>>>        Get KeyExists of hoReg sStudioRegPath to bExists
72268>>>        If (bExists = False) Begin
72270>>>            Send Destroy of hoReg
72271>>>            Function_Return cx_RegKeyDFKeyDoesNotExist
72272>>>        End
72272>>>>
72272>>>
72272>>>        Get OpenKey of hoReg sStudioRegPath to bOk
72273>>>        If (bOk = True) Begin
72275>>>            Set pfAccessRights of hoReg to KEY_READ
72276>>>            Get ReadString of hoReg CS_DFExtensionsKey to sRetval
72277>>>        End
72277>>>>
72277>>>
72277>>>        Send CloseKey of hoReg
72278>>>        Send Destroy of hoReg
72279>>>        Function_Return sRetval
72280>>>    End_Function
72281>>>
72281>>>    Function StudioFileExtensions String sDFVersion Returns String
72283>>>        Handle hoReg
72283>>>        String sStudioRegPath  sRetval
72283>>>        Boolean bExists bOk
72283>>>
72283>>>        Get Create (RefClass(cRegistry)) to hoReg
72284>>>        Move CS_StudioPath to sStudioRegPath
72285>>>        If (sDFVersion > "17.1") Begin
72287>>>            Move (Replace("Visual ", sStudioRegPath, "")) to sStudioRegPath
72288>>>        End
72288>>>>
72288>>>        Move (sStudioRegPath + sDFVersion + CS_StudioPathEnd) to sStudioRegPath
72289>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
72290>>>
72290>>>        // First check if the DF version is installed
72290>>>        Get KeyExists of hoReg sStudioRegPath to bExists
72291>>>        If (bExists = False) Begin
72293>>>            Send Destroy of hoReg
72294>>>            Function_Return cx_RegKeyDFKeyDoesNotExist
72295>>>        End
72295>>>>
72295>>>
72295>>>        Get OpenKey of hoReg sStudioRegPath to bOk
72296>>>        If (bOk = True) Begin
72298>>>            Set pfAccessRights of hoReg to KEY_READ
72299>>>            // In the Studio this key is still call "VDF".
72299>>>            Get ReadString of hoReg "VdfExtensions" to sRetval
72300>>>        End
72300>>>>
72300>>>
72300>>>        Send CloseKey of hoReg
72301>>>        Send Destroy of hoReg
72302>>>        Function_Return (Trim(sRetval))
72303>>>    End_Function
72304>>>
72304>>>    Function NoFolderListAsArray Boolean bNoBackupFolder Returns String[]
72306>>>        String sNoFolderList
72306>>>        String[] saNoFolderList
72307>>>
72307>>>        Move CS_NoFolderList to sNoFolderList
72308>>>        If (bNoBackupFolder = False) Begin
72310>>>            Move (sNoFolderList + "|" + CS_BackupFolder) to sNoFolderList
72311>>>        End
72311>>>>
72311>>>        Move (Lowercase(sNoFolderList)) to sNoFolderList
72312>>>        Move (StrSplitToArray(sNoFolderList, "|")) to saNoFolderList
72313>>>        Function_Return saNoFolderList
72314>>>    End_Function
72315>>>
72315>>>    // Returns True if the passed sFolderName exists in the passed string array.
72315>>>    Function IsFolderInNoFolderList String[] saNoFolderList String sFolderName Returns Boolean
72317>>>        Integer iSize iCount iIndex iCurrentFolder
72317>>>        Boolean bOK bFound
72317>>>        String sNoFolder sFolderNameShort
72317>>>        String[] saFolderList
72318>>>
72318>>>        Move False to bOK
72319>>>        Move (SearchArray(".",  saNoFolderList)) to iCurrentFolder
72320>>>        Move (iCurrentFolder <> -1) to bFound
72321>>>        If (bFound = True) Begin
72323>>>            // We need to remove "." from the array to avoid problems with folders containing a "."
72323>>>            Move (RemoveFromArray(saNoFolderList, iCurrentFolder)) to saNoFolderList
72324>>>            // The rightmost folder name:
72324>>>            Get ParseFileName sFolderName to sFolderNameShort
72325>>>            Move (sFolderNameShort = ".." or sFolderNameShort = ".") to bOK // Then we're done
72326>>>        End
72326>>>>
72326>>>
72326>>>        If (bOK = False) Begin
72328>>>            Move (Lowercase(sFolderName)) to sFolderName
72329>>>            Move (StrSplitToArray(sFolderName, CS_DirSeparator)) to saFolderList
72330>>>            Move (Lowercase(sFolderName)) to sFolderName
72331>>>            Move (SizeOfArray(saNoFolderList)) to iSize
72332>>>            Decrement iSize
72333>>>            For iCount from 0 to iSize
72339>>>>
72339>>>                Move (Lowercase(saNoFolderList[iCount])) to sNoFolder
72340>>>                Move (SearchArray(sNoFolder, saFolderList)) to iIndex
72341>>>                If (iIndex <> -1) Begin
72343>>>                    Move True to bOK
72344>>>                End
72344>>>>
72344>>>                If (bOK = True) Break
72347>>>            Loop
72348>>>>
72348>>>        End
72348>>>>
72348>>>
72348>>>        Function_Return bOK
72349>>>    End_Function
72350>>>
72350>>>    Function IsFolderInDefaultsFolderList String sFolderName Returns Boolean
72352>>>        Integer iSize iCount iIndex
72352>>>        Boolean bOK
72352>>>        String sDefaultFolders
72352>>>        String[] saDefaultFolderList saFolderList
72354>>>
72354>>>        Move False to bOK
72355>>>        Move -1 to iIndex
72356>>>
72356>>>        Move CS_DefaultSourceFolders to sDefaultFolders
72357>>>        Move (Lowercase(sDefaultFolders)) to sDefaultFolders
72358>>>        Move (StrSplitToArray(sDefaultFolders, "|")) to saDefaultFolderList
72359>>>
72359>>>        Move (Lowercase(sFolderName)) to sFolderName
72360>>>        Move (StrSplitToArray(sFolderName, "\")) to saFolderList
72361>>>
72361>>>        Move (SizeOfArray(saFolderList)) to iSize
72362>>>        Decrement iSize
72363>>>        For iCount from 0 to iSize
72369>>>>
72369>>>            Move saFolderList[iCount] to sFolderName
72370>>>            Move (SearchArray(sFolderName, saDefaultFolderList)) to iIndex
72371>>>            If (iIndex <> -1) Begin
72373>>>                Move True to bOK
72374>>>            End
72374>>>>
72374>>>            If (bOK = True) Break
72377>>>        Loop
72378>>>>
72378>>>
72378>>>        Function_Return bOK
72379>>>    End_Function
72380>>>
72380>>>End_Class
72381>
72381>Object oApplication is a cRefactorApplication
72383>    Set psProduct to "DFRefactor - Refactoring for DataFlex"
72384>    Set psCompany to "RDC Tools International"
72385>    Set peHelpType to htHtmlHelp
72386>    Set psHelpFile to "DFRefactor.chm"
72387>
72387>    Object oSwsOpenDialog is an OpenDialog
72389>        Set Dialog_Caption to CS_SelectWorkspaceFile
72390>        Set Filter_String  to CS_WorkspaceFilterString
72391>    End_Object
72392>
72392>    Function SelectWorkspaceFile Returns String
72395>        Boolean bOpen
72395>        String sFileName
72395>
72395>        Move "" to sFileName
72396>        Get Show_Dialog of oSwsOpenDialog to bOpen
72397>        If (bOpen = True) Begin
72399>            Get File_Name of oSwsOpenDialog to sFileName
72400>            Send AddWorkSpaceFileToRegistry sFileName
72401>        End
72401>        Function_Return sFileName
72402>    End_Function
72403>
72403>    Procedure Set psSWSFile String sSWSFile
72406>        String sPath sListItem   
72406>        Handle hoCombo 
72406>        Integer iItem iCount
72406>        
72406>        Get ParseFoldername sSWSFile to sPath
72407>        If (sPath <> "") Begin
72409>            Get vFolderFormat sPath to sPath
72410>        End
72410>        Set psHomePath to sPath
72411>        Set private.psSWSFile to sSWSFile 
72412>
72412>        If (ghoCommandBars > 0) Begin         
72414>            Send DisplayWorkspaceItem of (oWorkspaceSelector_Menuitem(ghoCommandBars)) sSWSFile
72415>            If (hoCombo > 0) Begin
72417>                Get ComListCount of hoCombo to iCount
72418>                For iItem from 0 to iCount
72424>                    Get ComList of hoCombo iItem to sListItem
72425>                    If (sListItem = "Select Workspace:") Begin
72427>                        Set ComListIndex of hoCombo to iItem
72428>                    End
72428>                Loop
72429>                Send Destroy of hoCombo
72430>            End
72430>        End
72430>    End_Procedure
72431>
72431>    Function psSWSFile Returns String
72434>        Function_Return (private.psSWSFile(Self))
72435>    End_Function
72436>
72436>    Function psWorkspaceHomePath Returns String
72439>        String sPath sSWSFile
72439>        Get psSWSFile to sSWSFile
72440>        Get ParseFolderName sSWSFile to sPath
72441>        Function_Return sPath
72442>    End_Function
72443>
72443>    Procedure UpdateWorkspaceSelectorDisplay String sFileName
72446>        String sText sVersion sWorkspaceText
72446>        Handle hoIniFile
72446>        Integer iPos
72446>        Boolean bExists
72446>
72446>        If (sFileName <> "") Begin
72448>            Move (RightPos(". ", sFileName)) to iPos
72449>            If (iPos <> 0) Begin
72451>                Move (Mid(sFileName, CI_EOL, 4)) to sFileName
72452>                Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bExists
72453>                If (bExists = False) Begin
72455>                    Send Info_Box "The .sws file doesn't exist! Please select another."
72456>                    Procedure_Return
72457>                End
72457>            End
72457>            Move CS_CurrentWorkspace to sWorkspaceText
72458>            Get Create (RefClass(cIniFile)) to hoIniFile
72459>            Set psFilename of hoIniFile to sFileName
72460>            Get ReadString of hoIniFile CS_PropertiesKeyWord CS_VersionKeyWord "" to sVersion
72461>            Send Destroy of hoIniFile
72462>
72462>            // Remove any number pre-facing the .sws file path & name
72462>            Move (Pos(":", sFileName)) to iPos
72463>            If (iPos <> 2) Begin
72465>                Move (Mid(sFileName, CI_EOL, 4)) to sFileName
72466>            End
72466>            Get ParseFileName sFileName to sText
72467>        End
72467>        Else Begin
72468>            Move CS_OpenWorkspace to sWorkspaceText
72469>            Move CS_NoActiveWorkspaceText to sText            
72470>            If ((oWorkspaceSelector_Menuitem(ghoCommandBars))) Begin
72472>                If (IsComObjectCreated(oWorkspaceSelector_Menuitem(ghoCommandBars))) Begin
72474>                    Send ResetComboForm of (oWorkspaceSelector_Menuitem(ghoCommandBars))
72475>                End
72475>            End
72475>        End
72475>        
72475>        // It is probably safest to clear all views when switching workspace.
72475>        If (phoMainPanel(Self) <> 0) Begin
72477>            Broadcast Send Request_Clear_All of (Client_Id(phoMainPanel(ghoApplication)))
72479>            Set psCaption of (oWorkspaceSelector_Menuitem(ghoCommandBars)) to sWorkspaceText
72480>        End
72480>        Set psSWSFile to sFileName
72481>        If (phoMainPanel(Self) <> 0) Begin  
72483>            // Send to all views
72483>            Broadcast Send OnWorkspaceLoaded of (Client_Id(phoMainPanel(ghoApplication)))
72485>        End
72485>        Send UpdateSourceFileNameDisplay ""
72486>    End_Procedure
72487>
72487>    Procedure UpdateSourceFileNameDisplay String sFileName
72490>        String sText sFileBrowseText sFileNameOnly
72490>
72490>        If (sFileName <> "") Begin
72492>            Move sFileName to sText
72493>            Get ParseFileName sFileName to sFileNameOnly
72494>            Move CS_CurrentSourceFileTxt to sFileBrowseText
72495>        End
72495>        Else Begin
72496>            Move CS_BrowseSourceFileTxt to sFileBrowseText
72497>            Move CS_NoActiveSourceFileText to sText
72498>        End
72498>
72498>        Set psCurrentSourceFileName to sFileName
72499>        If (phoMainPanel(Self) <> 0) Begin
72501>            Set psCaption of (oOpenFolderMenuItem(ghoCommandBars))      to sFileBrowseText
72502>            Set psCaption of (oSourceFileText_MenuItem(ghoCommandBars)) to sFileNameOnly
72503>            Set psToolTip of (oSourceFileText_MenuItem(ghoCommandBars)) to sText
72504>            Set pbChecked of (oSourceFileText_MenuItem(ghoCommandBars)) to (sText <> "")
72505>        End
72505>    End_Procedure
72506>
72506>    Procedure ToggleWorkspaceAndFileMode
72509>        Boolean bState
72509>        Get pbWorkspaceMode to bState
72510>        If (oWorkspaceRadio_MenuItem(ghoCommandBars) <> 0) Begin
72512>            Set pbChecked of (oWorkspaceRadio_MenuItem(ghoCommandBars)) to bState
72513>        End
72513>        If (oFileRadioMenuItem(ghoCommandBars) <> 0) Begin
72515>            Set pbChecked of (oFileRadioMenuItem(ghoCommandBars)) to (not(bState))
72516>        End
72516>    End_Procedure
72517>
72517>    Object oOpenSourceFileDialog is a OpenDialog
72519>        Set Dialog_Caption to "Select a source file"
72520>
72520>        // Nils: I find these filters to restricted and cumbersome to work with.
72520>        // Wil: Me too
72520>        //Set Filter_String to CS_SourceFileFilters
72520>        Set Filter_String to (CS_SourceCodeFilters+"|All Files (*.*)|*.*")
72521>    End_Object
72522>
72522>    Procedure SelectSourceFile
72525>        Boolean bOpen bReadOnly bExists
72525>        String  sFileName sHomePath sAppSrcPath sInitialFolder
72525>        Handle ho
72525>
72525>        Move (oOpenSourceFileDialog(Self)) to ho
72526>        Get Initial_Folder of ho to sInitialFolder
72527>        If (sInitialFolder = "") Begin
72529>            Get psHomePath to sHomePath
72530>            // If an "AppSrc" folder exists we want to display those source files.
72530>            Get vFolderFormat sHomePath to sAppSrcPath
72531>            Move (sAppSrcPath + "AppSrc") to sAppSrcPath
72532>            Get vFolderExists sAppSrcPath to bExists
72533>            If (bExists = True) Begin
72535>                Move sAppSrcPath to sHomePath
72536>            End
72536>
72536>            Set Initial_Folder of ho to sHomePath
72537>        End
72537>        Get Show_Dialog of ho to bOpen
72538>        If (bOpen = True) Begin
72540>            Get File_Name of ho to sFileName
72541>            // Check if user is opening file as read_only
72541>            Get TickReadOnly_State of ho to bReadOnly
72542>            If (bReadOnly = True) Begin
72544>                Send Info_Box ("Files should not be opened as ReadOnly.") "Warning!"
72545>            End
72545>            Else Begin
72546>                Set pbWorkspaceMode to False
72547>                Send UpdateSourceFileNameDisplay sFileName
72548>                Send LoadFile of (phoEditor(Self)) sFileName
72549>                Send Activate_oEditorView_vw of (Client_Id(phoMainPanel(Self)))
72550>            End
72550>        End
72550>    End_Procedure
72551>
72551>    Procedure OpenContainingFolder String sFName
72554>        String sPath sFileName
72554>
72554>        If (num_arguments = 0 or sFName = "") Begin
72556>            Get psHomePath to sPath
72557>        End
72557>
72557>        Else Begin
72558>            Move sFName to sFileName
72559>            Get ParseFolderName sFileName to sPath
72560>        End
72560>
72560>        RunProgram Shell Background sPath
72561>    End_Procedure
72562>
72562>    Function ScintillaEditorSettings String sKey Returns String
72565>        String sRetval sFontSize sFont
72565>
72565>        Get psFontFace of ghoEditorProperties to sFont
72566>        Move (Left(sFont, Pos(';', sFont))) to sFontSize
72567>        Move (Trim(Replace(sFontSize, sFont, ""))) to sFont
72568>        Move (Replace("PT;", Uppercase(sFontSize), "")) to sFontSize
72569>        Move (Trim(Right(sFont, Length(sFont)-Pos(';', sFont)))) to sFont
72570>        If (sKey = CS_StudioFontName) Begin
72572>            Move sFont to sRetval
72573>        End
72573>        If (sKey = CS_StudioFontSize) Begin
72575>            Move sFontSize to sRetval
72576>        End
72576>        Function_Return sRetval
72577>    End_Function
72578>
72578>    // Command Line Interface:
72578>    //
72578>    // Enable to pass a path to an folder or filename on the command line,
72578>    // and add something like this to the Studio's Tools menu:
72578>    // Label:                Command:                                                 Parameters:
72578>    // "DFRefactor" "C:\Projects\DFRefactor\Programs\DFRefactor.exe" "<project>"
72578>    // Note: This Studio setup can be done from the ProgramSetup.dg dialog.
72578>    Procedure OnCreate
72581>        Handle hoCommandLine
72581>        String sSourceFile sSWSFile
72581>        Boolean bChecked   
72581>        Integer iWin10BetaSetting
72581>
72581>        Forward Send OnCreate
72583>
72583>        // Test for serious Windows 10 "bug": "https://support.dataaccess.com/Forums/showthread.php?64797-Recent-Microsoft-Changes-to-Windows-10-May-Impact-Functionality-and-or-Data-Integrity"
72583>        Move (GetACP()) to iWin10BetaSetting
72584>        If (iWin10BetaSetting = 65001) Begin
72586>            Send Info_Box ("Windows 10 ouch! This workstation has its BETA option set to TRUE. This means that the normal codepage that DataFlex relies on does not work. This also means that some refactoring functions will fail. Program will now exit!")
72587>            Send vShellExecute "Open" "https://support.dataaccess.com/Forums/showthread.php?64797-Recent-Microsoft-Changes-to-Windows-10-May-Impact-Functionality-and-or-Data-Integrity" "" ""
72588>            Send Exit_Application
72589>        End
72589>        
72589>        Set psStartupProgramPath to (psProgramPath(phoWorkspace(Self)))
72590>        Set psStartupBitmapPath  to (psBitmapPath(phoWorkspace(Self)))
72591>
72591>        Get phoCommandLine to hoCommandLine
72592>        If (hoCommandLine > 0) Begin
72594>            Get Argument of hoCommandLine 1 to sSWSFile
72595>            Get Argument of hoCommandLine 2 to sSourceFile
72596>            //            Showln sSWSFile
72596>            //            Showln sSourceFile
72596>            Move (Trim(sSourceFile)) to sSourceFile
72597>            If (Right(sSourceFile, 1) = CS_DirSeparator) Begin
72599>                Move (Left(sSourceFile, (Length(sSourceFile) -1))) to sSourceFile
72600>            End
72600>            // We need to send these messages in this order: 
72600>            //Showln sSWSFile
72600>            //Showln sSourceFile            
72600>            Send UpdateWorkspaceSelectorDisplay sSWSFile
72601>            Send UpdateSourceFileNameDisplay sSourceFile
72602>        End
72602>
72602>        Get ReadDword CS_Settings CS_CreateBackupFiles True to bChecked
72603>        Set private.pbShouldBackupFile to bChecked
72604>    End_Procedure
72605>
72605>End_Object
72606>
72606>Use cToolTipController.pkg
72606>Object oToolTipController is a cToolTipController
72608>    Move Self to ghoToolTipController
72609>    Set piIcon to TTI_INFO
72610>    Set psTitle to "Info"
72611>    Set piMaxWidth to 250
72612>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
72613>    Set pbUsePrefix to True
72614>End_Object
72615>
72615>Open SysFile
72617>Register_Object oSysfile_DD
72617>// Need this here for the menu system.
72617>Use cUnusedSourceFiles.pkg
Including file: cUnusedSourceFiles.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cUnusedSourceFiles.pkg)
72617>>>// Original work by Sean Bamforth, APG.
72617>>>// Adapted to this project by Nils Svedmyr, RDC Tools International
72617>>>//
72617>>>Use Batchdd.pkg
72617>>>Use cApplication.pkg
72617>>>Use vWin32fh.pkg
72617>>>
72617>>>Struct tUnusedSourceFiles
72617>>>    String sUsedPackageName
72617>>>    String sFileName
72617>>>    String sPath
72617>>>    Integer iRow
72617>>>End_Struct
72617>>>
72617>>>Use RefactorFunctionConstants.inc
72617>>>//Use UnusedSourceFiles.dg
72617>>>
72617>>>
72617>>>Class cUnusedSourceFiles is a BusinessProcess
72618>>>
72618>>>    Procedure Construct_Object
72620>>>        Forward Send Construct_Object
72622>>>        
72622>>>        // The path and psFileFilter needs to be set to the current workspace before using this class
72622>>>        Property String psHomePath (psHome(phoWorkspace(ghoApplication)))
72623>>>        Property String psFileFilter "*.src;*.vw;*.sl;*.dg;*.rv;*.bp;*.pkg;*.wo;*.dd;*.inc"
72624>>>        
72624>>>        Property String[] pasAllFolders
72625>>>        Property Integer piNoOfUnusedSourceFiles 0
72626>>>        Property Boolean pbOK True
72627>>>        //
72627>>>        // Return array:
72627>>>        Property String[] pasUnusedSource
72628>>>    End_Procedure
72629>>>
72629>>>    Function AllSourceFiles String[] asFolders String sFileFilter Returns tUnusedSourceFiles[]
72631>>>        String[] asFileFilters
72632>>>        String[] asSearch
72633>>>        tUnusedSourceFiles[] asAllSource asSource asEmpty
72633>>>        tUnusedSourceFiles[] asAllSource asSource asEmpty
72636>>>        Integer iFilterCount iFilterSize iFolderCount iFolderSize iSize iCount iSearchCount iSearchSize iItem
72636>>>        String sFolder sFilename
72636>>>        tsSearchResult[] SearchResult
72636>>>        tsSearchResult[] SearchResult
72637>>>
72637>>>        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilters
72638>>>
72638>>>        Move (SizeOfArray(asFolders)) to iFolderSize
72639>>>        Decrement iFolderSize
72640>>>        Move (SizeOfArray(asFileFilters)) to iFilterSize
72641>>>        Decrement iFilterSize
72642>>>
72642>>>        For iFolderCount From 0 to iFolderSize
72648>>>>
72648>>>            For iFilterCount From 0 to iFilterSize
72654>>>>
72654>>>                Move asFolders[iFolderCount] to sFolder
72655>>>                Get vFolderFormat sFolder to sFolder
72656>>>                Move (Lowercase(sFolder) + asFileFilters[iFilterCount]) to asSearch[SizeOfArray(asSearch)]
72657>>>            Loop
72658>>>>
72658>>>        Loop
72659>>>>
72659>>>
72659>>>        Move (SizeOfArray(asSearch)) to iSize
72660>>>        Decrement iSize
72661>>>        For iCount From 0 to iSize
72667>>>>
72667>>>            Move asSearch[iCount]  to sFolder
72668>>>            Get ParseFolderName sFolder to sFolder
72669>>>            Get vFolderFormat   sFolder to sFolder
72670>>>
72670>>>            Move 0 to iItem
72671>>>            Move asEmpty to asSource
72672>>>            Get FileSearch of ghoFileSystem asSearch[iCount] DIRMODE_FILES_ONLY False to SearchResult
72673>>>            Move (SizeOfArray(SearchResult)) to iSearchSize
72674>>>            Decrement iSearchSize
72675>>>            For iSearchCount from 0 to iSearchSize
72681>>>>
72681>>>                Move sFolder                                to asSource[iItem].sPath
72682>>>                Move (SearchResult[iSearchCount].sFilename) to asSource[iItem].sFileName
72683>>>                Increment iItem
72684>>>            Loop
72685>>>>
72685>>>
72685>>>            Move (AppendArray(asSource, asAllSource)) to asAllSource
72686>>>        Loop
72687>>>>
72687>>>
72687>>>        Function_Return asAllSource
72688>>>    End_Function
72689>>>
72689>>>    Function IsUseOrIncludeLine String sInp Returns Boolean
72691>>>        Boolean bOK
72691>>>
72691>>>        Move False to bOK
72692>>>        Move (Lowercase(sInp)) to sInp
72693>>>        Get StripComment sInp  to sInp
72694>>>        Move (Trim(sInp)) to sInp
72695>>>
72695>>>        If ((Pos("use ", sInp)) = 1) Begin
72697>>>            Move True to bOK
72698>>>        End
72698>>>>
72698>>>        If ((Pos("#include ", sInp)) = 1) Begin
72700>>>            Move True to bOK
72701>>>        End                   
72701>>>>
72701>>>        // Hardcoded exception for the LoginEncryption.pkg file(!). It should never be removed.
72701>>>        If (lowercase(sInp) contains "loginencryption.pkg") Begin
72703>>>            Move False to bOK
72704>>>        End
72704>>>>
72704>>>        Function_Return bOK
72705>>>    End_Function
72706>>>
72706>>>    Function StripComment String sLine Returns String
72708>>>        Integer iPos
72708>>>
72708>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
72709>>>        If (iPos > 0) Begin
72711>>>            Move (Left(sLine, iPos - 1)) to sLine
72712>>>        End
72712>>>>
72712>>>        Function_Return sLine
72713>>>    End_Function
72714>>>
72714>>>    // Note: The function adds a ".pkg" to the package name if no extension has been specifieds in the source code.
72714>>>    Function ExtractPackageName String sLine Returns String
72716>>>        Integer iPos
72716>>>
72716>>>        Move (Trim(Lowercase(sLine))) to sLine
72717>>>        Get StripComment sLine to sLine
72718>>>        Move (Pos("#include ", sLine)) to iPos
72719>>>        If (iPos = 1) Begin
72721>>>            Move (Mid(sLine, CI_EOL, (iPos + 8))) to sLine
72722>>>        End
72722>>>>
72722>>>        Move (Pos("use ", sLine)) to iPos
72723>>>        If (iPos = 1) Begin
72725>>>            Move (Mid(sLine, CI_EOL, (iPos + 3))) to sLine
72726>>>        End
72726>>>>
72726>>>        Move (Trim(sLine)) to sLine
72727>>>        If (not(sLine contains ".")) Begin
72729>>>            Move (sLine + ".pkg") to sLine
72730>>>        End
72730>>>>
72730>>>
72730>>>        Move (Pos(CS_DirSeparator, sLine)) to iPos
72731>>>        If (iPos <> 0) Begin
72733>>>            Get ParseFileName sLine to sLine
72734>>>        End
72734>>>>
72734>>>
72734>>>        Function_Return sLine
72735>>>    End_Function
72736>>>
72736>>>    Function ReadSourceFile String sFilename Returns String[]
72738>>>        Integer iCh iFileSize iCount
72738>>>        String[] asFile
72739>>>
72739>>>        Get Seq_New_Channel to iCh
72740>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin 
72742>>>            Error "No Channel Available for Process: Procedure 'ReadSourceFile (cUnusedSourceFiles)'"            
72743>>>>
72743>>>            Function_Return asFile
72744>>>        End
72744>>>>
72744>>>
72744>>>        Move 0 to iCount
72745>>>        Get vWin32_APIFileSize sFilename to iFileSize
72746>>>        Move (ResizeArray(asFile, iFileSize)) to asFile
72747>>>
72747>>>        Direct_Input channel iCh ("binary:" + sFilename)
72749>>>        While (SeqEof = False)
72753>>>            Readln channel iCh asFile[iCount]
72755>>>            Increment iCount
72756>>>        Loop
72757>>>>
72757>>>        Close_Input channel iCh
72759>>>        Send Seq_Release_Channel iCh
72760>>>        Move (ResizeArray(asFile, iCount)) to asFile
72761>>>
72761>>>        Function_Return asFile
72762>>>    End_Function
72763>>>
72763>>>    Function SingleFileUsedPackages String sFullFilename Returns tUnusedSourceFiles[]
72765>>>        tUnusedSourceFiles[] asRetVal
72765>>>        tUnusedSourceFiles[] asRetVal
72766>>>        String[] asFile
72767>>>        String sLine sPath sFilename sPackageName sSourceLine
72767>>>        Integer iItem iCount iSize
72767>>>        Boolean bOK
72767>>>
72767>>>        Move 0 to iItem
72768>>>        Get ReadSourceFile sFullFilename to asFile
72769>>>        Move (SizeOfArray(asFile)) to iSize
72770>>>        If (iSize = 0) Begin
72772>>>            Function_Return asRetVal
72773>>>        End
72773>>>>
72773>>>
72773>>>        Get ParseFolderName sFullFilename  to sPath
72774>>>        Get ParseFileName   sFullFilename  to sFilename
72775>>>        Set Title_Text of ghoStatusPanel   to ("Scanning for 'Use':" * String(sPath))
72776>>>        Set Message_Text of ghoStatusPanel to ("in file:" * String(sFilename))
72777>>>        Decrement iSize
72778>>>        For iCount from 0 to iSize
72784>>>>
72784>>>            Move asFile[iCount] to sLine
72785>>>            Move (Lowercase(sLine)) to sLine
72786>>>            Move (Trim(sLine)) to sSourceLine
72787>>>            If (sSourceLine <> "") Begin
72789>>>                Get IsUseOrIncludeLine sLine to bOK
72790>>>                If (bOK = True) Begin
72792>>>                    Get ExtractPackageName sLine to sPackageName
72793>>>                    Move sPackageName to asRetVal[iItem].sUsedPackageName
72794>>>                    Move sPath        to asRetVal[iItem].sPath
72795>>>                    Move sFilename    to asRetVal[iItem].sFileName
72796>>>                    Move iCount       to asRetVal[iItem].iRow
72797>>>                    Increment iItem
72798>>>                End
72798>>>>
72798>>>            End
72798>>>>
72798>>>        Loop
72799>>>>
72799>>>
72799>>>        Set Title_Text   of ghoStatusPanel to ""
72800>>>        Set Message_Text of ghoStatusPanel to ""
72801>>>
72801>>>        Function_Return asRetVal
72802>>>    End_Function
72803>>>
72803>>>    Function IncludeOrUseFile String sLine Returns String
72805>>>        Integer iPos
72805>>>
72805>>>        Move (lowercase(sLine)) to sLine
72806>>>        Move (Replace("#include ", sLine, "use ")) to sLine
72807>>>
72807>>>        Move (Pos("use ",sLine)) to iPos
72808>>>        If (iPos = 0) Begin
72810>>>            Function_Return ""
72811>>>        End
72811>>>>
72811>>>
72811>>>        Move (Mid(sLine, CI_EOL, (iPos + 4))) to sLine
72812>>>        Move (Trim(sLine)) to sLine
72813>>>        If ((Pos(".", sLine)) = 0) Begin
72815>>>            Append sLine ".pkg"
72816>>>        End
72816>>>>
72816>>>
72816>>>        Function_Return sLine
72817>>>    End_Function
72818>>>
72818>>>    //    Function RemoveStructArrayDuplicates tUnusedSourceFiles[] asUsedSourceFiles Returns tUnusedSourceFiles[]
72818>>>    //        tUnusedSourceFiles[] asNoDuplicates
72818>>>    //        Integer iSize iCount iItem
72818>>>    //        String sUsedPackageName sUsedPackageNameCompare
72818>>>    //
72818>>>    //        Move 0 to iItem
72818>>>    //        Move (SortArray(asUsedSourceFiles))   to asUsedSourceFiles
72818>>>    //        Move (SizeOfArray(asUsedSourceFiles)) to iSize
72818>>>    //        Decrement iSize
72818>>>    //        For iCount from 0 to iSize
72818>>>    //            Move asUsedSourceFiles[iCount].sUsedPackageName to sUsedPackageName
72818>>>    //            Move asNoDuplicates[iItem].sUsedPackageName     to sUsedPackageNameCompare
72818>>>    //            If (Lowercase(sUsedPackageName) <> Lowercase(sUsedPackageNameCompare)) Begin
72818>>>    //                Move asUsedSourceFiles[iCount].iRow         to asNoDuplicates[iItem].iRow
72818>>>    //                Move asUsedSourceFiles[iCount].sFileName    to asNoDuplicates[iItem].sFileName
72818>>>    //                Move asUsedSourceFiles[iCount].sPath        to asNoDuplicates[iItem].sPath
72818>>>    //                Move sUsedPackageName                       to asNoDuplicates[iItem].sUsedPackageName
72818>>>    //                Increment iItem
72818>>>    //            End
72818>>>    //        Loop
72818>>>    //
72818>>>    //        Function_Return asNoDuplicates
72818>>>    //    End_Function
72818>>>
72818>>>    // Note: Only uniqely identifed package files are returned in the struct array.
72818>>>    // All duplicates have been removed.
72818>>>    Function UsedPackageFiles tUnusedSourceFiles[] asSourceAllFiles Returns tUnusedSourceFiles[]
72820>>>        tUnusedSourceFiles[] asSingleFile asUsedSourceFiles
72820>>>        tUnusedSourceFiles[] asSingleFile asUsedSourceFiles
72822>>>        Integer iCount iSize
72822>>>
72822>>>        Move (SizeOfArray(asSourceAllFiles)) to iSize
72823>>>        Decrement iSize
72824>>>        For iCount From 0 to iSize
72830>>>>
72830>>>            Get SingleFileUsedPackages (asSourceAllFiles[iCount].sPath + String(asSourceAllFiles[iCount].sFileName)) to asSingleFile
72831>>>            If (SizeOfArray(asSingleFile) <> 0) Begin
72833>>>                Move (AppendArray(asUsedSourceFiles, asSingleFile)) to asUsedSourceFiles
72834>>>            End
72834>>>>
72834>>>        Loop
72835>>>>
72835>>>
72835>>>        // It doesn't make any time difference if duplicates are removed or not.
72835>>>        //        Get RemoveStructArrayDuplicates asUsedSourceFiles to asUsedSourceFiles
72835>>>
72835>>>        Function_Return asUsedSourceFiles
72836>>>    End_Function
72837>>>
72837>>>    Function UnusedPackages tUnusedSourceFiles[] asUsedFiles tUnusedSourceFiles[] asAllFiles Returns tUnusedSourceFiles[]
72839>>>        Integer iCount iSize iIndex iItem
72839>>>        String sFilename sExt
72839>>>        tUnusedSourceFiles[] aUnusedSource
72839>>>        tUnusedSourceFiles[] aUnusedSource
72840>>>        tUnusedSourceFiles UsedFile
72840>>>        tUnusedSourceFiles UsedFile
72840>>>
72840>>>        Move 0 to iItem
72841>>>        Move (SortArray(asUsedFiles))  to asUsedFiles
72842>>>        Move (SizeOfArray(asAllFiles)) to iSize
72843>>>        Decrement iSize
72844>>>
72844>>>        For iCount From 0 to iSize
72850>>>>
72850>>>            Move asAllFiles[iCount].sFileName to sFilename
72851>>>            Move (Lowercase(sFilename))       to sFilename
72852>>>            Move sFilename                    to UsedFile.sUsedPackageName
72853>>>            Get ParseFileExtension sFilename  to sExt
72854>>>
72854>>>            If (sExt <> "src") Begin
72856>>>                Move (SearchArray(UsedFile, asUsedFiles)) to iIndex
72857>>>                If (iIndex = -1) Begin                                      
72859>>>                    // Fix for Bug #182 "LoginEncryptionKey.inc" should never be listed as an unused source file.
72859>>>                    If (Lowercase(asAllFiles[iCount].sFileName) <> "loginencryptionkey.inc") Begin
72861>>>                        Move asAllFiles[iCount].sFileName to aUnusedSource[iItem].sFileName
72862>>>                        Move asAllFiles[iCount].sPath     to aUnusedSource[iItem].sPath
72863>>>                        Increment iItem
72864>>>                    End
72864>>>>
72864>>>                End
72864>>>>
72864>>>            End
72864>>>>
72864>>>        Loop
72865>>>>
72865>>>
72865>>>        Function_Return aUnusedSource
72866>>>    End_Function
72867>>>
72867>>>    Procedure OnProcess
72869>>>        String sFileFilter sHomePath
72869>>>        String[] asAllFolders
72870>>>        tUnusedSourceFiles[] asAllSourceFiles asUsedSourceFiles asUsedFiles asUnusedSource
72870>>>        tUnusedSourceFiles[] asAllSourceFiles asUsedSourceFiles asUsedFiles asUnusedSource
72874>>>        Integer iCh iSize iCount
72874>>>
72874>>>        Get psFileFilter                                      to sFileFilter
72875>>>        Get pasAllFolders                                     to asAllFolders
72876>>>        Get AllSourceFiles asAllFolders sFileFilter           to asAllSourceFiles
72877>>>        Get UsedPackageFiles asAllSourceFiles                 to asUsedSourceFiles
72878>>>        Get UnusedPackages asUsedSourceFiles asAllSourceFiles to asUnusedSource
72879>>>        Set piNoOfUnusedSourceFiles to (SizeOfArray(asUnusedSource))
72880>>>
72880>>>        Get Seq_New_Channel to iCh
72881>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
72883>>>            Set pbOK to False
72884>>>            Error "No channel available for writing Unused Source Code. Procedure: 'OnProcess' (cUnusedSourceFiles)"
72885>>>>
72885>>>            Procedure_Return
72886>>>        End
72886>>>>
72886>>>
72886>>>        Move (SizeOfArray(asUnusedSource)) to iSize
72887>>>        If (iSize <> 0) Begin
72889>>>            Decrement iSize
72890>>>            Get psHomePath to sHomePath
72891>>>            Get vFolderFormat sHomePath to sHomePath
72892>>>
72892>>>            Direct_Output channel iCh (sHomePath + CS_BackupFolder + CS_DirSeparator + CS_UnusedSourceLogFile)
72894>>>            For iCount from 0 to iSize
72900>>>>
72900>>>                Writeln channel iCh (asUnusedSource[iCount].sPath + String(asUnusedSource[iCount].sFileName))
72903>>>            Loop
72904>>>>
72904>>>
72904>>>            // For testing purposes:
72904>>>            //            Writeln channel iCh ""
72904>>>            //            Writeln channel iCh "asUsedFiles"
72904>>>            //            Move (SizeOfArray(asUsedFiles)) to iSize
72904>>>            //            Decrement iSize
72904>>>            //            For iCount from 0 to iSize
72904>>>            //                Writeln channel iCh asUsedFiles[iCount]
72904>>>            //            Loop
72904>>>            //
72904>>>            //            Writeln channel iCh ""
72904>>>            //            Writeln channel iCh "asAllSourceFiles"
72904>>>            //            Move (SizeOfArray(asAllSourceFiles)) to iSize
72904>>>            //            Decrement iSize
72904>>>            //            For iCount from 0 to iSize
72904>>>            //                Writeln channel iCh asAllSourceFiles[iCount]
72904>>>            //            Loop
72904>>>            //
72904>>>            //            Writeln channel iCh ""
72904>>>            //            Writeln channel iCh "asUsedSourceFiles"
72904>>>            //            Move (SizeOfArray(asUsedSourceFiles)) to iSize
72904>>>            //            Decrement iSize
72904>>>            //            For iCount from 0 to iSize
72904>>>            //                Writeln channel iCh asUsedSourceFiles[iCount]
72904>>>            //            Loop
72904>>>
72904>>>            Close_Output channel iCh
72906>>>            Send Seq_Release_Channel iCh
72907>>>        End
72907>>>>
72907>>>        Set pbOK to True   
72908>>>        
72908>>>        Set pasUnusedSource to asUnusedSource
72909>>>
72909>>>    End_Procedure
72910>>>    
72910>>>End_Class
72911>
72911>Use oEditorProperties.pkg
Including file: oEditorProperties.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\oEditorProperties.pkg)
72911>>>//*****************************************************************************************
72911>>>// Copyright (c) 2000 Michael Kurz
72911>>>// All rights reserved.
72911>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
72911>>>//
72911>>>// $FileName    : cEditorEdit.Pkg
72911>>>// $ProjectName : CODEMAX EDITOR
72911>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
72911>>>// $Created     : 01-25-2001 @ 19:00
72911>>>//
72911>>>// Contents:
72911>>>//      Properties for Editor, stored in an INI file, based on cEditorProperties.
72911>>>//      If you want to use a different config file then have your own version of this
72911>>>//      file with a different filename.
72911>>>// $Rev History
72911>>>//
72911>>>//*****************************************************************************************
72911>>>
72911>>>    // The out of this class created object is stored in this global Var.
72911>>>Use cEditorProperties.pkg
Including file: cEditorProperties.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cEditorProperties.pkg)
72911>>>>>//*****************************************************************************************
72911>>>>>// Copyright (c) 2000 Michael Kurz
72911>>>>>// All rights reserved.
72911>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
72911>>>>>//
72911>>>>>// $FileName    : cEditorEdit.Pkg
72911>>>>>// $ProjectName : CODEMAX EDITOR
72911>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
72911>>>>>// $Created     : 01-25-2001 @ 19:00
72911>>>>>//
72911>>>>>// Contents:
72911>>>>>//      Properties for Editor, stored in an INI file, based on cIniHandler.
72911>>>>>//
72911>>>>>// $Rev History
72911>>>>>//
72911>>>>>//*****************************************************************************************
72911>>>>>
72911>>>>>Use cIniManager.pkg                 // Class cIniManager
Including file: cIniManager.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cIniManager.pkg)
72911>>>>>>>//*****************************************************************************************
72911>>>>>>>// Copyright (c) 2000 Michael Kurz
72911>>>>>>>// All rights reserved.
72911>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
72911>>>>>>>//
72911>>>>>>>// $FileName    : cIniManager.pkg
72911>>>>>>>// $ProjectName : General shared classes
72911>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
72911>>>>>>>// $Created     : 12-31-2000 @ 09:00
72911>>>>>>>//
72911>>>>>>>// Contents:
72911>>>>>>>//      Abilities to load and save values to an inifile.
72911>>>>>>>//      This Class (cIniProperties) is not just a class it is a solution for a problem I
72911>>>>>>>//      had for years.
72911>>>>>>>//
72911>>>>>>>//      What's the idea?
72911>>>>>>>//          Very often if you develop a class you need want it to save properties to
72911>>>>>>>//          disk. Then you also need to build a kind of property page to edit these
72911>>>>>>>//          Properties ans save if to disk again.
72911>>>>>>>//
72911>>>>>>>//          With cIniProperties and a set of commands its possible to create a set of
72911>>>>>>>//          properties which are save with one call into an inifile to disk.
72911>>>>>>>//
72911>>>>>>>// $Rev History
72911>>>>>>>//
72911>>>>>>>//*****************************************************************************************
72911>>>>>>>//
72911>>>>>>>//
72911>>>>>>>//     // Stores the infos which TAPI lines should been monitored.
72911>>>>>>>//  Class cTapiHandler_Properties is a cIniProperties
72911>>>>>>>//      INI_Begin_Properties "FILENAME.INI"  [INI_COMPUTER | INI_COMPUTER | INI_GLOBAL]
72911>>>>>>>//
72911>>>>>>>//              // Normal Properties (Single Item)
72911>>>>>>>//          INI_Property        piTestInteger                         Public 0
72911>>>>>>>//          INI_Property        pnTestNumber                          Public 0
72911>>>>>>>//          INI_Property        psTestString                          Public ""
72911>>>>>>>//
72911>>>>>>>//              // Multi Item Properties
72911>>>>>>>//          INI_Property        integer Line                          Public 0  MULTI
72911>>>>>>>//          INI_Property.Sub    string  Name                          Public ""
72911>>>>>>>//          INI_Property.Sub    string  Monitor                       Public ""
72911>>>>>>>//          INI_Property.Sub    string  Standard                      Public ""
72911>>>>>>>//      INI_End_Properties
72911>>>>>>>//
72911>>>>>>>//          // Accessing Single Item Properties (as usual with set and get)
72911>>>>>>>//      set piTestInteger           to 10
72911>>>>>>>//      set psTestString            to ""
72911>>>>>>>//      get piTestString            to sTmp
72911>>>>>>>//      move (piTestInteger(Self))  to iTmp
72911>>>>>>>//
72911>>>>>>>//          // Accessing Multi Item Properties
72911>>>>>>>//      set Line        item iNr    to iWert
72911>>>>>>>//      set Line.Name   item iNr    to sWert
72911>>>>>>>//
72911>>>>>>>//          // Number of Items present
72911>>>>>>>//      move (Line.Count(Self))     to iCount
72911>>>>>>>//          // Deletes a specified Item
72911>>>>>>>//      send Line.DeleteItem iNr
72911>>>>>>>//
72911>>>>>>>//          // Deletes all Line Items.
72911>>>>>>>//      send Line.DeleteAllItems
72911>>>>>>>//  End_Class
72911>>>>>>>
72911>>>>>>>// Dependencies:
72911>>>>>>>Use Windows.Pkg                 // For external function use.
72911>>>>>>>Use DLL.Pkg                     // ...
72911>>>>>>>Use cLineParser.Pkg             // Class: cLineParser, for seperating a String in its parts.
Including file: cLinePARSER.PKG    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cLinePARSER.PKG)
72911>>>>>>>>>//*****************************************************************************************
72911>>>>>>>>>// Copyright (c) 2000 Michael Kurz
72911>>>>>>>>>// All rights reserved.
72911>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
72911>>>>>>>>>//
72911>>>>>>>>>// $FileName    : cLineParser.pkg
72911>>>>>>>>>// $ProjectName : General shared classes
72911>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
72911>>>>>>>>>// $Created     : 12-31-2000 @ 09:00
72911>>>>>>>>>//
72911>>>>>>>>>// Contents:
72911>>>>>>>>>//      Separates a string to its parts which need to be seperated by a special character.
72911>>>>>>>>>//
72911>>>>>>>>>// $Rev History
72911>>>>>>>>>// 11/09/2005 **WvA Added the possibility to skip parts in the parsing. This allows
72911>>>>>>>>>//            us to parse UNC paths correctly while the sep character is set to "\"
72911>>>>>>>>>//
72911>>>>>>>>>//*****************************************************************************************
72911>>>>>>>>>
72911>>>>>>>>>// This Class separates a string into his parts. Which need to be
72911>>>>>>>>>// seperated by a seperating character (psSepCharacter)
72911>>>>>>>>>// As the class is based on an array the parts can be retrieved by
72911>>>>>>>>>// "get value item iItem to sPart" and the number of items with a call
72911>>>>>>>>>// of "get Item_Count to iCount".
72911>>>>>>>>>
72911>>>>>>>>>Define CLINEPARSER_COMMAND      For 0
72911>>>>>>>>>Define CLINEPARSER_KEYWORD      For 1
72911>>>>>>>>>Define CLINEPARSER_COMMENT      For 2
72911>>>>>>>>>Define CLINEPARSER_STRING       For 3
72911>>>>>>>>>Define CLINEPARSER_EXPRESSION   For 4
72911>>>>>>>>>Define CLINEPARSER_INDICATOR    For 5
72911>>>>>>>>>
72911>>>>>>>>>Class cLineParser is a Array
72912>>>>>>>>>
72912>>>>>>>>>  // Adding properties and setting default values
72912>>>>>>>>>  Procedure Construct_Object
72914>>>>>>>>>    Forward Send Construct_Object
72916>>>>>>>>>
72916>>>>>>>>>    Property String  psSepCharacter                        ","  // Seperating character
72917>>>>>>>>>    Property String  psSkipSequence                        ""   // Sometimes we want the parser to skip parsing parts, eg. the unc prefix "\\" when the character is set to "\"
72918>>>>>>>>>    Property String  psSwapOutSequence                     "$x$" // (Private) This is used along with psSkipSequence to temporarily swap out parts you want to skip parsing, you would normally not need to change this.
72919>>>>>>>>>    Property String  psInputLine                           ""   // Stores the whole last given string. (only for convenience)
72920>>>>>>>>>    Property Integer piSkipEmptyParts                      0    // Skips empty parts
72921>>>>>>>>>    // Follow the language tokens, ie (Expr), comments, strings etc. recognize as token,
72921>>>>>>>>>    Property Integer piLanguageTokens                      False
72922>>>>>>>>>    Object oType is an Array
72924>>>>>>>>>    End_Object
72925>>>>>>>>>  End_Procedure
72926>>>>>>>>>
72926>>>>>>>>>  // Parses a line in its parts which are seperated by "psSepCharacter".
72926>>>>>>>>>  Procedure ParseLine String sLine
72928>>>>>>>>>    If (piLanguageTokens(Self)) Begin
72930>>>>>>>>>      Set psSepCharacter  To " "
72931>>>>>>>>>      Send ParseLineTkn   sLine
72932>>>>>>>>>    End
72932>>>>>>>>>>
72932>>>>>>>>>    Else Begin
72933>>>>>>>>>      Send ParseLineStd sLine
72934>>>>>>>>>    End
72934>>>>>>>>>>
72934>>>>>>>>>  End_Procedure
72935>>>>>>>>>
72935>>>>>>>>>  Procedure Add_Token Integer iType String sToken
72937>>>>>>>>>    Set Value Item (Item_Count(Self)) To (Trim(sToken))
72938>>>>>>>>>    If ((Item_Count(Self)=1)And(iType<>CLINEPARSER_COMMENT)And(iType<>CLINEPARSER_INDICATOR)) Begin
72940>>>>>>>>>      Set Value Of oType Item (Item_Count(Self)-1) To CLINEPARSER_COMMAND
72941>>>>>>>>>    End
72941>>>>>>>>>>
72941>>>>>>>>>    Else Begin
72942>>>>>>>>>      Set Value Of oType Item (Item_Count(Self)-1) To iType
72943>>>>>>>>>    End
72943>>>>>>>>>>
72943>>>>>>>>>  End_Procedure
72944>>>>>>>>>
72944>>>>>>>>>  Function ProcessStrToken String sChar String sLine Integer iCount Returns Integer
72946>>>>>>>>>    String sToken sChr
72946>>>>>>>>>    Move "" To sToken
72947>>>>>>>>>    Move sChar To sChr
72948>>>>>>>>>    Move (sToken+sChr) To sToken
72949>>>>>>>>>    Move "" To sChr
72950>>>>>>>>>    While ((sChr<>sChar)And(iCount<=(Length(sLine))))
72954>>>>>>>>>      Increment iCount
72955>>>>>>>>>      Move (Mid(sLine,1,iCount)) To sChr
72956>>>>>>>>>      Move (sToken+sChr) To sToken
72957>>>>>>>>>    Loop
72958>>>>>>>>>>
72958>>>>>>>>>    If (Trim(sToken)<>"") Begin
72960>>>>>>>>>      Send Add_Token CLINEPARSER_STRING (Trim(sToken))
72961>>>>>>>>>    End
72961>>>>>>>>>>
72961>>>>>>>>>    Function_Return iCount
72962>>>>>>>>>  End_Function
72963>>>>>>>>>
72963>>>>>>>>>  Function ProcessBrToken String sCharSt String sCharEn String sLine Integer iCount Returns Integer
72965>>>>>>>>>    Integer iBr iStr iChr
72965>>>>>>>>>    String sToken sChr
72965>>>>>>>>>    Increment iBr // Start
72966>>>>>>>>>    Move sCharSt To sToken
72967>>>>>>>>>    While ((iBr<>0)And(iCount<=(Length(sLine))))
72971>>>>>>>>>      Increment iCount
72972>>>>>>>>>      Move (Mid(sLine,1,iCount)) To sChr
72973>>>>>>>>>      If (sChr='"') Begin
72975>>>>>>>>>        If (iStr) ;          Decrement iStr
72978>>>>>>>>>        Else Begin
72979>>>>>>>>>          If (Not(iChr)) ;            Increment iStr
72982>>>>>>>>>        End
72982>>>>>>>>>>
72982>>>>>>>>>      End
72982>>>>>>>>>>
72982>>>>>>>>>      If (sChr="'") Begin
72984>>>>>>>>>        If (iChr) ;          Decrement iChr
72987>>>>>>>>>        Else Begin
72988>>>>>>>>>          If (Not(iStr)) ;            Increment iChr
72991>>>>>>>>>        End
72991>>>>>>>>>>
72991>>>>>>>>>      End
72991>>>>>>>>>>
72991>>>>>>>>>      If ((Not(iStr))And(Not(iChr))) Begin
72993>>>>>>>>>        If (sChr=sCharSt) ;          Increment iBr
72996>>>>>>>>>        If (sChr=sCharEn) ;          Decrement iBr
72999>>>>>>>>>      End
72999>>>>>>>>>>
72999>>>>>>>>>      Move (sToken+sChr)  To sToken
73000>>>>>>>>>    Loop
73001>>>>>>>>>>
73001>>>>>>>>>    If (Trim(sToken)<>"") Begin
73003>>>>>>>>>      If (sCharSt="[") ;        Send Add_Token CLINEPARSER_INDICATOR  (Trim(sToken))
73006>>>>>>>>>      Else ;        Send Add_Token CLINEPARSER_EXPRESSION (Trim(sToken))
73008>>>>>>>>>    End
73008>>>>>>>>>>
73008>>>>>>>>>    Function_Return iCount
73009>>>>>>>>>  End_Function
73010>>>>>>>>>
73010>>>>>>>>>  Procedure ParseLineTkn String sLine
73012>>>>>>>>>    Integer iC iBlank iSepL iCount
73012>>>>>>>>>    String  sToken sChar sSep sCom sNext sComLine
73012>>>>>>>>>    Move ('/'+'/') To sCom
73013>>>>>>>>>    Move (psSepCharacter(Self)) To sSep
73014>>>>>>>>>    Move (Length(sSep))         To iSepL
73015>>>>>>>>>    Send Delete_Data
73016>>>>>>>>>    If (sSep=" ") Begin
73018>>>>>>>>>      Move 1     To iBlank
73019>>>>>>>>>    End
73019>>>>>>>>>>
73019>>>>>>>>>
73019>>>>>>>>>    If (Left(sLine,2)=sCom) Begin
73021>>>>>>>>>      Send Add_Token CLINEPARSER_COMMENT (Trim(sLine))
73022>>>>>>>>>      Procedure_Return
73023>>>>>>>>>    End
73023>>>>>>>>>>
73023>>>>>>>>>
73023>>>>>>>>>    If sCom In sLine Begin
73025>>>>>>>>>      Move (Left(sLine, (Pos(sCom, sLine)-1))) To sToken
73026>>>>>>>>>      Move (Replace(sToken, sLine, "")) To sLine
73027>>>>>>>>>      Move (Trim(sLine))  To sComLine
73028>>>>>>>>>      Move sToken         To sLine
73029>>>>>>>>>      Move ""             To sToken
73030>>>>>>>>>    End
73030>>>>>>>>>>
73030>>>>>>>>>
73030>>>>>>>>>    While (iCount<=(Length(sLine)))
73034>>>>>>>>>      Increment iCount
73035>>>>>>>>>      Move (Mid(sLine,1,iCount)) To sChar
73036>>>>>>>>>      If (sChar='"' Or sChar="'") Begin
73038>>>>>>>>>        Get ProcessStrToken sChar sLine iCount To iCount
73039>>>>>>>>>        Move "" To sChar
73040>>>>>>>>>      End
73040>>>>>>>>>>
73040>>>>>>>>>      Else If (sChar="(") Begin
73043>>>>>>>>>        Get ProcessBrToken  sChar ")" sLine iCount To iCount
73044>>>>>>>>>        Move "" To sChar
73045>>>>>>>>>      End
73045>>>>>>>>>>
73045>>>>>>>>>      Else If (sChar="[") Begin
73048>>>>>>>>>        Get ProcessBrToken  sChar "]" sLine iCount To iCount
73049>>>>>>>>>        Move "" To sChar
73050>>>>>>>>>      End
73050>>>>>>>>>>
73050>>>>>>>>>      Else If (sChar="/") Begin
73053>>>>>>>>>        Increment iCount
73054>>>>>>>>>        Move (Mid(sLine,1,iCount)) To sNext
73055>>>>>>>>>        If (sNext="/") Begin
73057>>>>>>>>>          Move (sChar+sNext+Right(sLine, iCount+1)) To sToken
73058>>>>>>>>>          If (Trim(sToken)<>"") ;            Send Add_Token CLINEPARSER_COMMENT (Trim(sToken))
73061>>>>>>>>>          Move (Length(sLine)+100) To iCount // Cancels parsing
73062>>>>>>>>>        End
73062>>>>>>>>>>
73062>>>>>>>>>        Move "" To sChar
73063>>>>>>>>>      End
73063>>>>>>>>>>
73063>>>>>>>>>      If (sChar=sSep) Begin
73065>>>>>>>>>        If (Trim(sToken)<>"") ;          Send Add_Token CLINEPARSER_KEYWORD (Trim(sToken))
73068>>>>>>>>>        Move "" To sToken
73069>>>>>>>>>      End
73069>>>>>>>>>>
73069>>>>>>>>>      If (sChar<>"") ;        Move (sToken+sChar) To sToken
73072>>>>>>>>>    Loop
73073>>>>>>>>>>
73073>>>>>>>>>    If (sComLine<>"") ;      Send Add_Token CLINEPARSER_COMMENT (Trim(sComLine))
73076>>>>>>>>>  End_Procedure
73077>>>>>>>>>
73077>>>>>>>>>  Procedure ParseLineStd String sLine
73079>>>>>>>>>    Integer iPos iC iBlank iSepL iCount
73079>>>>>>>>>    String  sPart sSkip sSwap sOld
73079>>>>>>>>>    Boolean bSwapped
73079>>>>>>>>>    Move (Length(psSepCharacter(Self)))         To iSepL
73080>>>>>>>>>    Send Delete_Data
73081>>>>>>>>>    // *WvA: 11/09/2005 Added logic to skip parsing of specific parts.
73081>>>>>>>>>    Move (false) To bSwapped
73082>>>>>>>>>    Get psSkipSequence    To sSkip
73083>>>>>>>>>    Get psSwapOutSequence To sSwap
73084>>>>>>>>>    If (sSkip<>"") Begin
73086>>>>>>>>>      // temporarily replace our skip sequence with the swapvalue
73086>>>>>>>>>      Move sLine To sOld
73087>>>>>>>>>      Move (Replaces(sSkip,sLine,sSwap)) To sLine
73088>>>>>>>>>      Move (sOld<>sLine) To bSwapped
73089>>>>>>>>>    End
73089>>>>>>>>>>
73089>>>>>>>>>    If (psSepCharacter(Self)) Eq " " ;      Move 1     To iBlank
73092>>>>>>>>>    Repeat
73092>>>>>>>>>>
73092>>>>>>>>>      Increment iCount
73093>>>>>>>>>      Move (Pos(psSepCharacter(Self),sLine))  To iPos
73094>>>>>>>>>      If iPos Eq 0 ;        Move (Length(sLine))       To iPos
73097>>>>>>>>>
73097>>>>>>>>>      Move (Left(sLine,iPos+iSepL-1))         To sPart
73098>>>>>>>>>      Move (Replace(sPart,sLine,""))          To sLine
73099>>>>>>>>>      If (Right(sPart,iSepL)) Eq (psSepCharacter(Self)) ;        Move (Left(sPart,Length(sPart)-iSepL))  To sPart
73102>>>>>>>>>      If iBlank ;        Move (LTrim(sLine))               To sLine
73105>>>>>>>>>
73105>>>>>>>>>      // *WvA: 11/09/2005 Added logic to skip parsing of specific parts.
73105>>>>>>>>>      If ((bSwapped) And (Pos(sSwap,sPart)>0)) Begin
73107>>>>>>>>>        // Move our skip sequence back in the part just before storing it.
73107>>>>>>>>>        Move (Replaces(sSwap,sPart,sSkip)) To sPart
73108>>>>>>>>>      End
73108>>>>>>>>>>
73108>>>>>>>>>      If (Not(piSkipEmptyParts(Self))) ;        Set Value Item (Item_Count(Self)) To sPart
73111>>>>>>>>>      Else If (Trim(sPart)) Ne "" ;        Set Value Item (Item_Count(Self)) To sPart
73115>>>>>>>>>      If iCount Gt 500 Begin
73117>>>>>>>>>        //                Send Info_Box "Failure!"
73117>>>>>>>>>        Procedure_Return
73118>>>>>>>>>      End
73118>>>>>>>>>>
73118>>>>>>>>>    Until (sLine Eq "")
73120>>>>>>>>>  End_Procedure
73121>>>>>>>>>
73121>>>>>>>>>  // An easy procedure to init the LineParser.
73121>>>>>>>>>  Procedure Init String sSepCharacter Integer iSkipEmptyParts
73123>>>>>>>>>    Set psSepCharacter      To sSepCharacter
73124>>>>>>>>>    Set piSkipEmptyParts    To iSkipEmptyParts
73125>>>>>>>>>  End_Procedure
73126>>>>>>>>>End_Class
73127>>>>>>>>>
73127>>>>>>>>>
73127>>>>>>>Use Set.Pkg                     // Class: Set
73127>>>>>>>Use mUserAndComputerName.pkg    // Functions to get the User and the ComputerName.
Including file: mUserAndComputerName.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mUserAndComputerName.pkg)
73127>>>>>>>>>//*****************************************************************************************
73127>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73127>>>>>>>>>// All rights reserved.
73127>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73127>>>>>>>>>//
73127>>>>>>>>>// $FileName    : mUserAndComputerName.pkg
73127>>>>>>>>>// $ProjectName : General shared classes
73127>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73127>>>>>>>>>// $Created     : 12-31-2000 @ 09:00
73127>>>>>>>>>//
73127>>>>>>>>>// Contents:
73127>>>>>>>>>//
73127>>>>>>>>>// $Rev History
73127>>>>>>>>>//
73127>>>>>>>>>//*****************************************************************************************
73127>>>>>>>>>Use mPointer.pkg
Including file: mPointer.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mPointer.pkg)
73127>>>>>>>>>>>//TH-Header
73127>>>>>>>>>>>//*****************************************************************************************
73127>>>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73127>>>>>>>>>>>// All rights reserved.
73127>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73127>>>>>>>>>>>//
73127>>>>>>>>>>>// $FileName    : mPoiner.Pkg
73127>>>>>>>>>>>// $ProjectName : Shared Methods and Commands.
73127>>>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73127>>>>>>>>>>>// $Created     : 02-01-2001 @ 19:00
73127>>>>>>>>>>>//
73127>>>>>>>>>>>// Contents:
73127>>>>>>>>>>>//      Some useful commands and function when you use WinAPI Stuff or other
73127>>>>>>>>>>>//      DLL's which will ver often need pointers.
73127>>>>>>>>>>>//
73127>>>>>>>>>>>// $Rev History
73127>>>>>>>>>>>//
73127>>>>>>>>>>>//*****************************************************************************************
73127>>>>>>>>>>>
73127>>>>>>>>>>>// Implements a C++ Makro.
73127>>>>>>>>>>>Function MAKEWPARAM Global Integer iLow Integer iHi Returns Integer
73129>>>>>>>>>>>  Function_Return (iLow+(65536*iHI))
73130>>>>>>>>>>>End_Function
73131>>>>>>>>>>>
73131>>>>>>>>>>>// Defines a Variable only if not defined.
73131>>>>>>>>>>>// Checks if a string var isnt defined and defines it!
73131>>>>>>>>>>>// The same is done for the 2nd Para as a Pointer var.
73131>>>>>>>>>>>// Two usages:
73131>>>>>>>>>>>//  1.You have a string variable and want to create a pointer which contains its Addres.
73131>>>>>>>>>>>//  2.You'd like to String Buffer Init it to a length and Create and fille the Address Pointer
73131>>>>>>>>>>>// To avoid compilation errors when already declared. (VDF7+!)
73131>>>>>>>>>>>// Is a command that allows to put a string as pointer into a structure
73131>>>>>>>>>>>// Usage: PUT_POINTER sName  pName  "String..."  to sBuff at TYPE.FIELD
73131>>>>>>>>>
73131>>>>>>>>>
73131>>>>>>>>>Global_Variable String gsComputerName
73131>>>>>>>>>Global_Variable String gsUserName
73131>>>>>>>>>
73131>>>>>>>>>External_Function GetComputerName "GetComputerNameA" kernel32.dll Pointer lpszName Pointer lpdwcBuffer Returns Integer
73132>>>>>>>>>External_Function WNetGetUser1 "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUserName Pointer lpLength Returns Dword
73133>>>>>>>>>Function ComputerName For desktop Returns String
73135>>>>>>>>>    String  sName sLength sEnv
73135>>>>>>>>>    Integer iRetval
73135>>>>>>>>>    
73135>>>>>>>>>    Move (Repeat (Character (0), 25))                    To sName
73136>>>>>>>>>    Move (DwordToBytes (25))                             To sLength
73137>>>>>>>>>    Move (GetComputerName(AddressOf(sName), AddressOf(sLength)))   To iRetval
73138>>>>>>>>>    Move (cstring(sName))                                To sName
73139>>>>>>>>>    If sName Eq "" Move "DEFAULT"                        To sName
73142>>>>>>>>>    Move (cstring(sname))                                To gsComputerName
73143>>>>>>>>>    Function_Return gsComputerName
73144>>>>>>>>>End_Function
73145>>>>>>>>>
73145>>>>>>>>>Function NetzwerkBenutzer For desktop Returns String
73147>>>>>>>>>    String sName sLength
73147>>>>>>>>>    Integer iRetval
73147>>>>>>>>>
73147>>>>>>>>>    Move (Repeat (Character (0), 255))                   To sName
73148>>>>>>>>>    Move (DwordToBytes (255))                            To sLength
73149>>>>>>>>>    Move (WNetGetUser1 (0, AddressOf(sName), AddressOf(sLength)))   To iRetval
73150>>>>>>>>>    If iRetval Eq 0 Move (cstring(sName))                   To sName
73153>>>>>>>>>    Else Move "DEFAULT"                                     To sName
73155>>>>>>>>>    If sName Eq "" Move "DEFAULT"                           To sName
73158>>>>>>>>>    Move sName  To gsUserName
73159>>>>>>>>>    Function_Return sName
73160>>>>>>>>>End_Function
73161>>>>>>>>>
73161>>>>>>>>>
73161>>>>>>>>>
73161>>>>>>>>>Move (NetzwerkBenutzer(Desktop))    To gsUserName
73162>>>>>>>>>Move (ComputerName(Desktop))        To gsComputerName
73163>>>>>>>>>
73163>>>>>>>>>
73163>>>>>>>>>// Only for testing purposes...
73163>>>>>>>>>
73163>>>>>>>>>External_Function GetUserNameEx "GetUserNameExA" Secur32.DLL dword iFormat Pointer pName Integer iSize Returns Integer
73164>>>>>>>>>Function DFGetUserNameEx Global Integer iFormat Returns String
73166>>>>>>>>>    String  sName
73166>>>>>>>>>    String  sDW
73166>>>>>>>>>    Integer iRet
73166>>>>>>>>>    
73166>>>>>>>>>    Move (Repeat(Character(0),1024))            To sName
73167>>>>>>>>>    Move (DWordToBytes(1024))                   To sDW
73168>>>>>>>>>    Move (GetUserNameEx(iFormat,AddressOf(sName),AddressOf(sDW)))     To iRet
73169>>>>>>>>>    Function_Return (CString(sName))
73170>>>>>>>>>End_Function
73171>>>>>>>>>
73171>>>>>>>>>External_Function GetUserName "GetUserNameA" AdvApi32.DLL Pointer pName Integer iSize Returns Integer
73172>>>>>>>>>Function DFGetUserName Global Returns String
73174>>>>>>>>>    String  sName
73174>>>>>>>>>    String  sDW   
73174>>>>>>>>>    Integer iRet
73174>>>>>>>>>    
73174>>>>>>>>>    Move (Repeat(Character(0),1024))            To sName
73175>>>>>>>>>    Move (DWordToBytes(1024))                   To sDW
73176>>>>>>>>>    Move (GetUserName(AddressOf(sName),AddressOf(sDW))) To iRet
73177>>>>>>>>>    Function_Return (CString(sName))
73178>>>>>>>>>End_Function
73179>>>>>>>
73179>>>>>>>// Possible Ini modes:
73179>>>>>>>Define Ini_Global           For 0   // IniFilename is used as it is.        -> Global Settings.
73179>>>>>>>Define Ini_Computer         For 1   // The Computername is added at the End -> Settings for a special computer on a Networkdrive.
73179>>>>>>>Define Ini_User             For 2   // The UserName is added at the End     -> Settings for a special user on a Networkdrive.
73179>>>>>>>
73179>>>>>>>External_Function GetFocus "GetFocus" user32.dll Returns Integer
73180>>>>>>>
73180>>>>>>>// #COMMAND: SendEx
73180>>>>>>>// Creates Send Commands for all procedures which exist
73180>>>>>>>// If you give the command a procedure name "TestProc"
73180>>>>>>>// it will create send Test_Proc_1
73180>>>>>>>//                send Test_Proc_2
73180>>>>>>>//                ...
73180>>>>>>>//                send Test_Proc_X
73180>>>>>>>// as long as the procedures exist.
73180>>>>>>>
73180>>>>>>>// #COMMAND: ProcedureEx
73180>>>>>>>// Creates a Procedure with an addtional _X if the procedure doesnt exist.
73180>>>>>>>
73180>>>>>>>
73180>>>>>>>
73180>>>>>>>  // Has the ability to read an write from and to an IniFile.
73180>>>>>>>  // The main advantage of this class is that it stores all lines
73180>>>>>>>  // which are not known, so that they arent lost during a save.
73180>>>>>>>
73180>>>>>>>
73180>>>>>>>  Class cIniProperties is a Message
73181>>>>>>>    // Sets all Tag values.
73181>>>>>>>    Procedure onInit
73183>>>>>>>    End_Procedure
73184>>>>>>>    // For termination
73184>>>>>>>    Procedure INI_AddTagValues
73186>>>>>>>    End_Procedure
73187>>>>>>>
73187>>>>>>>
73187>>>>>>>    // Adding properties and setting default values
73187>>>>>>>    Procedure Construct_Object
73189>>>>>>>      Forward Send Construct_Object
73191>>>>>>>      Send Define_cIniProperties
73192>>>>>>>    End_Procedure
73193>>>>>>>
73193>>>>>>>    Procedure Define_cIniProperties
73195>>>>>>>
73195>>>>>>>      Property String  psSourceFile                   "cConfigManager.Ini" // Name of the inifile.
73196>>>>>>>      Property String  psSepCharacter                 ","                  // Seperating character.
73197>>>>>>>      Property Boolean pbUseDataPath                  True
73198>>>>>>>
73198>>>>>>>      // Data can be stored either global, user specific or
73198>>>>>>>      // computer specific.
73198>>>>>>>      // This is reached by adding ComputerName or UserName
73198>>>>>>>      // to the FileName.
73198>>>>>>>      Property Integer piLoadSaveMode                        Ini_Global           //[ Ini_User | Ini_Computer | Ini_Global ]
73199>>>>>>>
73199>>>>>>>      Object oUnusedLines is an Array                 // Storage for all unused (unknown) lines.
73201>>>>>>>      End_Object
73202>>>>>>>      Object oLineParser is a cLineParser             // Seperates a String into his parts.
73204>>>>>>>      End_Object
73205>>>>>>>
73205>>>>>>>      Object oTags is a Set                           // Known Tags
73207>>>>>>>      End_Object
73208>>>>>>>      Object oTagTypes is an Array                    // Type of the Tags
73210>>>>>>>      End_Object
73211>>>>>>>      Object oTagValues is an Array                   // Values for the Tags.
73213>>>>>>>      End_Object
73214>>>>>>>      Object oTagConnectedObjects is an Array         // ObjectIDs of the connected Obj.
73216>>>>>>>      End_Object
73217>>>>>>>
73217>>>>>>>      Send INI_AddTagValues
73218>>>>>>>      Send onInit
73219>>>>>>>    End_Procedure
73220>>>>>>>
73220>>>>>>>    // Connects an Object to a tag.
73220>>>>>>>    Procedure ConnectObjectToTag String sTag Integer hoID
73222>>>>>>>      Integer iC
73222>>>>>>>      Move (Uppercase(sTag))  To sTag
73223>>>>>>>      Get Find_Element Of (oTags(Self)) sTag  To iC
73224>>>>>>>      If iC Ge 0 Begin
73226>>>>>>>        Set Value Of (oTagConnectedObjects(Self)) Item iC   To hoID
73227>>>>>>>      End
73227>>>>>>>>
73227>>>>>>>    End_Procedure
73228>>>>>>>
73228>>>>>>>    Procedure Set ConnectObjectValue Integer hoDest String sValue
73230>>>>>>>      If hoDest Begin
73232>>>>>>>        If (checkbox_item_state(hoDest,0)) Eq 0 ;          Set Value        Of hoDest Item 0 To sValue
73235>>>>>>>        Else ;          Set Select_State Of hoDest Item 0 To sValue
73237>>>>>>>      End
73237>>>>>>>>
73237>>>>>>>    End_Procedure
73238>>>>>>>    Function ConnectObjectValue Integer hoDest Returns String
73240>>>>>>>      String sRet
73240>>>>>>>      If hoDest Begin
73242>>>>>>>        If (checkbox_item_state(hoDest,0)) Eq 0 ;          Move (Value(hoDest,0)) To sRet
73245>>>>>>>        Else ;          Move (Select_State(hoDest,0)) To sRet
73247>>>>>>>      End
73247>>>>>>>>
73247>>>>>>>      Function_Return sRet
73248>>>>>>>    End_Function
73249>>>>>>>
73249>>>>>>>
73249>>>>>>>
73249>>>>>>>    // Creates extended source files.
73249>>>>>>>    Function SourceFile Integer iMode Returns String
73251>>>>>>>      Integer iPos
73251>>>>>>>      String  sFile sExt
73251>>>>>>>      String  sPath
73251>>>>>>>      Get psSourceFile                                           To sFile
73252>>>>>>>      If iMode Eq Ini_User     ;        Get NetzwerkBenutzer To sExt
73255>>>>>>>      If iMode Eq Ini_Computer ;        Get ComputerName     To sExt
73258>>>>>>>
73258>>>>>>>      If (Left(Right(sFile,2),1)) Eq "." ;        Move 1                           To iPos
73261>>>>>>>      If (Left(Right(sFile,3),1)) Eq "." ;        Move 2                           To iPos
73264>>>>>>>      If (Left(Right(sFile,4),1)) Eq "." ;        Move 3                           To iPos
73267>>>>>>>      If iPos Gt 0 ;        Move (Insert(sExt,sFile,Length(sFile)-iPos))           To sFile
73270>>>>>>>      If (sFile<>"" and pbUseDataPath(Self)) Begin
73272>>>>>>>        Get psDataPath Of (phoWorkspace(ghoApplication)) To sPath
73273>>>>>>>        Get vFolderFormat sPath To sPath
73274>>>>>>>        Move (sPath+sFile) To sFile
73275>>>>>>>      End
73275>>>>>>>>
73275>>>>>>>      Function_Return sFile
73276>>>>>>>    End_Function
73277>>>>>>>
73277>>>>>>>    // Checks if a file exists.
73277>>>>>>>    Function INI_DoesFileExist String sFile Returns Integer
73279>>>>>>>      Integer iExist
73279>>>>>>>      If sFile Eq "" Begin
73281>>>>>>>        Function_Return 0
73282>>>>>>>      End
73282>>>>>>>>
73282>>>>>>>      Direct_Input sFile
73283>>>>>>>      If (Not(seqeof)) Move 1 To iExist
73286>>>>>>>      Close_Input
73287>>>>>>>      Function_Return iExist
73288>>>>>>>    End_Function
73289>>>>>>>
73289>>>>>>>    // Tries to find the best ini file.
73289>>>>>>>    Function SourceFileForRead Returns String
73291>>>>>>>      If (INI_DoesFileExist(Self, SourceFile(Self, piLoadSaveMode(Self)) )) Begin
73293>>>>>>>        Function_Return (SourceFile(Self, piLoadSaveMode(Self)))
73294>>>>>>>      End
73294>>>>>>>>
73294>>>>>>>      Function_Return (psSourceFile(Self))
73295>>>>>>>    End_Function
73296>>>>>>>
73296>>>>>>>    // Delivers the file for writing.
73296>>>>>>>    Function SourceFileForWrite Returns String
73298>>>>>>>      Function_Return (SourceFile(Self, piLoadSaveMode(Self)))
73299>>>>>>>    End_Function
73300>>>>>>>
73300>>>>>>>    // Deletes all items of a Tag, if it is multi!
73300>>>>>>>    Procedure DeleteAllItems String sTag
73302>>>>>>>      Integer iC iType hoID iC2 hoTmp
73302>>>>>>>      Get Find_Element Of (oTags(Self)) sTag      To iC
73303>>>>>>>      Get Value Of (oTagTypes(Self)) Item iC      To iType
73304>>>>>>>      Get Value Of (oTagValues(Self)) Item iC     To hoID
73305>>>>>>>      If iType If hoID Begin
73309>>>>>>>        For iC2 From 0 To (Item_Count(hoID)-1)
73315>>>>>>>>
73315>>>>>>>          Get Value Of hoID Item iC2              To hoTmp
73316>>>>>>>          If hoTmp ;            Send Destroy_Object                     To hoTmp
73319>>>>>>>        End
73320>>>>>>>>
73320>>>>>>>        Send Delete_Data                        To hoID
73321>>>>>>>      End
73321>>>>>>>>
73321>>>>>>>    End_Procedure
73322>>>>>>>
73322>>>>>>>    // Deletes one Item of a Tag if it is multi.
73322>>>>>>>    Procedure DeleteItem String sTag Integer iNr
73324>>>>>>>      Integer iC iType hoID hoTmp
73324>>>>>>>      Get Find_Element Of (oTags(Self)) sTag      To iC
73325>>>>>>>      Get Value Of (oTagTypes(Self)) Item iC      To iType
73326>>>>>>>      Get Value Of (oTagValues(Self)) Item iC     To hoID
73327>>>>>>>      If iType If hoID Begin
73331>>>>>>>        Get Value Of hoID Item iNr              To hoTmp
73332>>>>>>>        If hoTmp ;          Send Destroy_Object            To hoTmp
73335>>>>>>>        Send Delete_Item                        To hoID  iNr
73336>>>>>>>      End
73336>>>>>>>>
73336>>>>>>>    End_Procedure
73337>>>>>>>
73337>>>>>>>
73337>>>>>>>
73337>>>>>>>    // Deletes all values, not the defined tags (with "AddTag").
73337>>>>>>>    // Is sent before the data is loaded.
73337>>>>>>>    Procedure DoInit
73339>>>>>>>      Integer iC iType hoID iC2 hoTmp
73339>>>>>>>      For iC From 0 To (Item_Count(oTags(Self))-1)
73345>>>>>>>>
73345>>>>>>>        Get Value Of (oTagTypes(Self)) Item iC      To iType
73346>>>>>>>        Get Value Of (oTagValues(Self)) Item iC     To hoID
73347>>>>>>>        If iType Begin
73349>>>>>>>          For iC2 From 0 To (Item_Count(hoID)-1)
73355>>>>>>>>
73355>>>>>>>            Get Value Of hoID Item iC2              To hoTmp
73356>>>>>>>            If hoTmp ;              Send Destroy_Object                     To hoTmp
73359>>>>>>>          End
73360>>>>>>>>
73360>>>>>>>          Send Delete_Data                        To hoID
73361>>>>>>>        End
73361>>>>>>>>
73361>>>>>>>        Else ;          Send Delete_Data                       To hoID
73363>>>>>>>      End
73364>>>>>>>>
73364>>>>>>>    End_Procedure
73365>>>>>>>
73365>>>>>>>    // Adds a iniTag.
73365>>>>>>>    // The type can be multi of not. If it is a multi tag
73365>>>>>>>    // there can be more than one value with the same tag.
73365>>>>>>>    Procedure AddTag String sTag Integer iMulti
73367>>>>>>>      Integer iC hoID
73367>>>>>>>
73367>>>>>>>      Get Find_Element Of (oTags(Self)) sTag  To iC
73368>>>>>>>      If iC Lt 0 Begin
73370>>>>>>>        Object oIniTag is an Array
73372>>>>>>>          Move Self       To hoID
73373>>>>>>>        End_Object
73374>>>>>>>        Get Item_Count  Of (oTags(Self))                To iC
73375>>>>>>>        Set Value       Of (oTags(Self))        Item iC To sTag
73376>>>>>>>        Set Value       Of (oTagTypes(Self))    Item iC To iMulti
73377>>>>>>>        Set Value       Of (oTagValues(Self))   Item iC To hoID
73378>>>>>>>      End
73378>>>>>>>>
73378>>>>>>>    End_Procedure
73379>>>>>>>
73379>>>>>>>
73379>>>>>>>    // Sets the value of a Tag (and a SubTag)
73379>>>>>>>    Procedure SetIniValue String sTag Integer iMultiNr Integer iSubTagNr String sValue
73381>>>>>>>      Integer iC iType hoID hoID2 hoDest
73381>>>>>>>
73381>>>>>>>      Get Find_Element Of (oTags(Self)) sTag              To iC
73382>>>>>>>      If iC Ge 0 Begin
73384>>>>>>>        Get Value Of (oTagTypes(Self))              Item iC         To iType
73385>>>>>>>        Get Value Of (oTagValues(Self))             Item iC         To hoID
73386>>>>>>>        Get Value Of (oTagConnectedObjects(Self))   Item iC         To hoDest
73387>>>>>>>        If iType Begin
73389>>>>>>>          If iMultiNr Lt 0 Begin
73391>>>>>>>            Move (Item_Count(hoID))    To iMultiNr // To add new values
73392>>>>>>>          End
73392>>>>>>>>
73392>>>>>>>          Get Value Of hoID Item iMultiNr             To hoID2
73393>>>>>>>          If Not hoID2 Begin
73395>>>>>>>            Object oSubs is an Array
73397>>>>>>>              Move Self   To hoID2
73398>>>>>>>            End_Object
73399>>>>>>>            Set Value Of hoID Item iMultiNr         To hoID2
73400>>>>>>>          End
73400>>>>>>>>
73400>>>>>>>          Set Value Of hoID2 Item iSubTagNr           To sValue
73401>>>>>>>        End
73401>>>>>>>>
73401>>>>>>>        Else Begin
73402>>>>>>>          If hoDest Begin
73404>>>>>>>            Set ConnectObjectValue hoDest     To sValue
73405>>>>>>>          End
73405>>>>>>>>
73405>>>>>>>          Set Value Of hoID Item iSubTagNr            To sValue
73406>>>>>>>        End
73406>>>>>>>>
73406>>>>>>>      End
73406>>>>>>>>
73406>>>>>>>    End_Procedure
73407>>>>>>>
73407>>>>>>>
73407>>>>>>>    // Adds a value to a tag. If it is a mulit tag
73407>>>>>>>    // numerous values are possible, if not only one is stored and
73407>>>>>>>    // every call of AddTagValue for the same tag overwrites the existing
73407>>>>>>>    // value.
73407>>>>>>>    Procedure AddTagValue String sTag String sValue
73409>>>>>>>      Send SetIniValue sTag -1 0 sValue
73410>>>>>>>    End_Procedure
73411>>>>>>>
73411>>>>>>>
73411>>>>>>>    // Runs a line and returns true if the tag was known and false if not.
73411>>>>>>>    // This is called during the loading procedure and if it returns false
73411>>>>>>>    // the line is stored in "oUnusedLines".
73411>>>>>>>    // Given is the whole read line and an ObjectID of an array which contains
73411>>>>>>>    // all parts of the line.
73411>>>>>>>    Function DoLine String sLine Integer hoPartsID Returns Integer
73413>>>>>>>      Integer iC iC2 iMultiItemNr hoID
73413>>>>>>>      Get Find_Element Of (oTags(Self)) (Value(hoPartsID,0))  To iC
73414>>>>>>>      Get Value Of (oTagValues(Self)) Item iC                 To hoID
73415>>>>>>>      If hoID Begin
73417>>>>>>>        Get Item_Count Of hoID                          To iMultiItemNr
73418>>>>>>>      End
73418>>>>>>>>
73418>>>>>>>      If iC Ge 0 Begin
73420>>>>>>>        For iC2 From 1 To (Item_Count(hoPartsID)-1)
73426>>>>>>>>
73426>>>>>>>          Send SetIniValue (Value(hoPartsID,0)) iMultiItemNr (iC2-1) (Value(hoPartsID,iC2))
73427>>>>>>>        End
73428>>>>>>>>
73428>>>>>>>        If (Item_Count(hoPartsID)) Le 1 Begin
73430>>>>>>>          Send SetIniValue (Value(hoPartsID,0)) iMultiItemNr 1 ""
73431>>>>>>>        End
73431>>>>>>>>
73431>>>>>>>        Function_Return 1
73432>>>>>>>      End
73432>>>>>>>>
73432>>>>>>>      Function_Return 0
73433>>>>>>>    End_Function
73434>>>>>>>
73434>>>>>>>    // Reads the data out of the inifile.
73434>>>>>>>    Procedure LoadIni
73436>>>>>>>      String sLine
73436>>>>>>>      String sFile
73436>>>>>>>      Integer hoParser hoUnused
73436>>>>>>>
73436>>>>>>>      Move (oUnusedLines(Self))   To hoUnused
73437>>>>>>>      Move (oLineParser(Self))    To hoParser
73438>>>>>>>
73438>>>>>>>      Send DoInit                                 // Clears all values
73439>>>>>>>      Send Delete_Data            To hoUnused     // also the unusedlines.
73440>>>>>>>
73440>>>>>>>      Set psSepCharacter Of hoParser To (psSepCharacter(Self))
73441>>>>>>>        
73441>>>>>>>      Get SourceFileForRead To sFile
73442>>>>>>>
73442>>>>>>>      Direct_Input sFile
73443>>>>>>>      Repeat
73443>>>>>>>>
73443>>>>>>>        Readln sLine
73444>>>>>>>        If (Not(SeqEof)) Begin
73446>>>>>>>          Send ParseLine  To hoParser sLine
73447>>>>>>>          If (Not(DoLine(Self,sLine,hoParser))) Begin
73449>>>>>>>            Set Value Of hoUnused Item (Item_Count(hoUnused)) To sLine
73450>>>>>>>          End
73450>>>>>>>>
73450>>>>>>>        End
73450>>>>>>>>
73450>>>>>>>      Until (SeqEof)
73452>>>>>>>      Close_Input
73453>>>>>>>    End_Procedure
73454>>>>>>>
73454>>>>>>>    // Saves the data to the inifile.
73454>>>>>>>    Procedure SaveIni
73456>>>>>>>      Integer iC iC2 iC3 hoID iType hoUnused iCount hoID2 hoDest
73456>>>>>>>      String  sTag sSep
73456>>>>>>>      String  sFileName
73456>>>>>>>      Get psSepCharacter              To sSep
73457>>>>>>>      Get Item_Count Of (oTags(Self)) To iCount
73458>>>>>>>      Move (oUnusedLines(Self))       To hoUnused
73459>>>>>>>
73459>>>>>>>      Get SourceFileForWrite To sFileName
73460>>>>>>>      Direct_Output sFileName
73461>>>>>>>
73461>>>>>>>      For iC From 0 To (iCount-1)
73467>>>>>>>>
73467>>>>>>>        Get Value Of (oTags(Self))                  Item iC To sTag
73468>>>>>>>        Get Value Of (oTagTypes(Self))              Item iC To iType
73469>>>>>>>        Get Value Of (oTagValues(Self))             Item iC To hoID
73470>>>>>>>        Get Value Of (oTagConnectedObjects(Self))   Item iC To hoDest
73471>>>>>>>        If iType Begin
73473>>>>>>>          For iC2 From 0 To (Item_Count(hoID)-1)
73479>>>>>>>>
73479>>>>>>>            Get Value Of hoID   Item iC2        To hoID2
73480>>>>>>>            If hoID2 Begin
73482>>>>>>>              Write sTag
73483>>>>>>>              For iC3 From 0 To (Item_Count(hoID2)-1)
73489>>>>>>>>
73489>>>>>>>                Write sSep (Value(hoID2,iC3))
73491>>>>>>>              End
73492>>>>>>>>
73492>>>>>>>              Writeln
73493>>>>>>>            End
73493>>>>>>>>
73493>>>>>>>            Else Begin
73494>>>>>>>              Writeln sTag
73496>>>>>>>            End
73496>>>>>>>>
73496>>>>>>>          End
73497>>>>>>>>
73497>>>>>>>        End
73497>>>>>>>>
73497>>>>>>>        Else Begin
73498>>>>>>>          If hoDest Begin
73500>>>>>>>            Set Value Of hoID Item 0    To (ConnectObjectValue(Self,hoDest))
73501>>>>>>>          End
73501>>>>>>>>
73501>>>>>>>          Write sTag
73502>>>>>>>          For iC2 From 0 To (Item_Count(hoID)-1)
73508>>>>>>>>
73508>>>>>>>            Write sSep (Value(hoID,iC2))
73510>>>>>>>          End
73511>>>>>>>>
73511>>>>>>>          Writeln
73512>>>>>>>        End
73512>>>>>>>>
73512>>>>>>>      End
73513>>>>>>>>
73513>>>>>>>
73513>>>>>>>      For iC From 0 To (Item_Count(hoUnused)-1)
73519>>>>>>>>
73519>>>>>>>        Writeln (Value(hoUnused,iC))
73521>>>>>>>      End
73522>>>>>>>>
73522>>>>>>>
73522>>>>>>>      Close_Output
73523>>>>>>>    End_Procedure
73524>>>>>>>
73524>>>>>>>
73524>>>>>>>    // Delivers the value of a given tag.
73524>>>>>>>    Function IniValueEx String sTag Integer iMultiNr Integer iSubNr Returns String
73526>>>>>>>      Integer iC iType hoID hoDest
73526>>>>>>>      String sRetVal
73526>>>>>>>      Get Find_Element Of (oTags(Self)) sTag   To iC
73527>>>>>>>      Get Value Of (oTagTypes(Self))  Item iC  To iType
73528>>>>>>>      Get Value Of (oTagValues(Self)) Item iC  To hoID
73529>>>>>>>      Get Value Of (oTagConnectedObjects(Self))   Item iC         To hoDest
73530>>>>>>>      If iType Begin
73532>>>>>>>        If iMultiNr Ge (Item_Count(hoID)) Begin
73534>>>>>>>          Move (Item_Count(hoID)-1)  To iMultiNr
73535>>>>>>>        End  
73535>>>>>>>>
73535>>>>>>>        If hoID ;          Get Value Of hoID Item iMultiNr                              To hoID
73538>>>>>>>      End
73538>>>>>>>>
73538>>>>>>>      Else If hoDest If hoID Begin
73543>>>>>>>        Set Value Of hoID Item 0 To (ConnectObjectValue(Self,hoDest))
73544>>>>>>>      End
73544>>>>>>>>
73544>>>>>>>
73544>>>>>>>      If hoID ;        Move (Value(hoID,iSubNr)) to sRetVal
73547>>>>>>>      Else ;        Move "" To sRetVal      
73549>>>>>>>      Function_Return sRetVal
73550>>>>>>>    End_Function
73551>>>>>>>
73551>>>>>>>
73551>>>>>>>    // Delivers the value of a given tag.
73551>>>>>>>    Function IniValue String sTag Integer iNr Returns String
73553>>>>>>>      Function_Return (IniValueEx(Self,sTag,iNr,0))
73554>>>>>>>    End_Function
73555>>>>>>>
73555>>>>>>>    // Delivers the number of values of a given tag.
73555>>>>>>>    // If it isn't a multi tag 1 is returned.
73555>>>>>>>    Function IniValueCount String sTag Returns Integer
73557>>>>>>>      Integer iC iType hoID iRetval
73557>>>>>>>      Get Find_Element Of (oTags(Self)) sTag  To iC
73558>>>>>>>      Get Value Of (oTagTypes(Self)) Item iC  To iType
73559>>>>>>>      If iType Begin
73561>>>>>>>        Get Value Of (oTagValues(Self)) Item iC To hoID
73562>>>>>>>        Move (Item_Count(hoID)) To iRetval
73563>>>>>>>      End
73563>>>>>>>>
73563>>>>>>>      Else Begin
73564>>>>>>>        Move 1 To iRetval
73565>>>>>>>      End
73565>>>>>>>>
73565>>>>>>>      Function_Return iRetval
73566>>>>>>>    End_Function
73567>>>>>>>  End_Class
73568>>>>>>>
73568>>>>>>>
73568>>>>>>>  // Only for compatibility with earlier versions.
73568>>>>>>>  // Which I only used myself. :-)
73568>>>>>>>  Class cIniManager is a cIniProperties
73569>>>>>>>  End_Class
73570>>>>>>>
73570>>>>>>>  // Need to put this into a seperate command becouse the orginal Procedure and
73570>>>>>>>  // Function commands require the !$ to be set to the class name of the current class
73570>>>>>>>  // Can be used as the std commands eccexpt that the 1st argument must always be the
73570>>>>>>>  // the name of the last global Property = !$
73570>>>>>>>
73570>>>>>>>  // The top value of the Stack is the ClassName!!
73570>>>>>>>  // And every Stack Manipulation is done in a way that this is always the case!
73570>>>>>>>
73570>>>>>>>
73570>>>>>>>
73570>>>>>>>
73570>>>>>>>  // The top value of the Stack is the ClassName!!
73570>>>>>>>
73570>>>>>>>  // Saves two values to the Stack: String TagName and Numeric: MultiLine
73570>>>>>>>  // The 1st parameter need to be !$ becouse stack has to stay valid!
73570>>>>>>>
73570>>>>>>>
73570>>>>>>>  // Defines a MultiItem Property!
73570>>>>>>>
73570>>>>>>>  // Defines a Single Item Propery
73570>>>>>>>
73570>>>>>>>  // Defines a Ini Property whether MULTI Item or Single.
73570>>>>>>>
73570>>>>>>>  // Defines a sub-property for a multi item property.
73570>>>>>>>
73570>>>>>>>  // Defines a sub-property for a single item property.
73570>>>>>>>
73570>>>>>>>  // Defines a subproprty neither to a multi or a single (parent) property.
73570>>>>>>>
73570>>>>>>>
73570>>>>>>>  // For an easier writing of the Class Import.
73570>>>>>Use mPointer.pkg
73570>>>>>Use mAssignFilesToExecuteable.Pkg   // To Assign extention to this program.
Including file: mAssignFilesToExecuteAble.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mAssignFilesToExecuteAble.pkg)
73570>>>>>>>//TH-Header
73570>>>>>>>//*****************************************************************************************
73570>>>>>>>// Copyright (c) 2001 Michael Kurz
73570>>>>>>>// All rights reserved.
73570>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73570>>>>>>>//
73570>>>>>>>// $FileName    : mAssignFilesToExecuteAble.pkg
73570>>>>>>>// $ProjectName : Shared Methods
73570>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73570>>>>>>>// $Created     : 04-25-2001 @ 19:00
73570>>>>>>>//
73570>>>>>>>// Contents:
73570>>>>>>>//      Assigns Files (by their extentions) to an executeable
73570>>>>>>>//
73570>>>>>>>//      -AssignExecutAbleToTAG
73570>>>>>>>//      -AssignExecutAbleToTAG_OPEN
73570>>>>>>>//      -AssignExecutAbleToTAG_PRINT
73570>>>>>>>//      -AssignExtentionToTAG
73570>>>>>>>//
73570>>>>>>>// $Rev History
73570>>>>>>>//
73570>>>>>>>//*****************************************************************************************
73570>>>>>>>// Usage:
73570>>>>>>>//
73570>>>>>>>// -1st you have to create a Tag which stands for your executeable and what it is able to do
73570>>>>>>>//
73570>>>>>>>//      send AssignExecutAbleToTAG_OPEN "MyProgramName" "X:\PathOfMyProgram\...." "X:\TheIcontoShow\IconName.Ico" "Description" ShowExtentions(true|false)
73570>>>>>>>//
73570>>>>>>>// -Then you need to Assign the file extentions you want to the created TAG:
73570>>>>>>>//      send AssignExtentionToTAG ".TXT" "MyProgramName"
73570>>>>>>>//
73570>>>>>>>// -At least after some Associations for FileTypes have been changed, you need to send:
73570>>>>>>>//      send NofityShell_AssocChanged   // Informs the Shell that something has changed in that area.
73570>>>>>>>//
73570>>>>>>>//
73570>>>>>>>// Ready now all files with the Extention .TXT are opened with the program X:\PathofMy...
73570>>>>>>>
73570>>>>>>>Define SHCNE_RENAMEITEM          For |CI$00000001
73570>>>>>>>Define SHCNE_CREATE              For |CI$00000002
73570>>>>>>>Define SHCNE_DELETE              For |CI$00000004
73570>>>>>>>Define SHCNE_MKDIR               For |CI$00000008
73570>>>>>>>Define SHCNE_RMDIR               For |CI$00000010
73570>>>>>>>Define SHCNE_MEDIAINSERTED       For |CI$00000020
73570>>>>>>>Define SHCNE_MEDIAREMOVED        For |CI$00000040
73570>>>>>>>Define SHCNE_DRIVEREMOVED        For |CI$00000080
73570>>>>>>>Define SHCNE_DRIVEADD            For |CI$00000100
73570>>>>>>>Define SHCNE_NETSHARE            For |CI$00000200
73570>>>>>>>Define SHCNE_NETUNSHARE          For |CI$00000400
73570>>>>>>>Define SHCNE_ATTRIBUTES          For |CI$00000800
73570>>>>>>>Define SHCNE_UPDATEDIR           For |CI$00001000
73570>>>>>>>Define SHCNE_UPDATEITEM          For |CI$00002000
73570>>>>>>>Define SHCNE_SERVERDISCONNECT    For |CI$00004000
73570>>>>>>>Define SHCNE_UPDATEIMAGE         For |CI$00008000
73570>>>>>>>Define SHCNE_DRIVEADDGUI         For |CI$00010000
73570>>>>>>>Define SHCNE_RENAMEFOLDER        For |CI$00020000
73570>>>>>>>Define SHCNE_FREESPACE           For |CI$00040000
73570>>>>>>>Define SHCNE_EXTENDED_EVENT      For |CI$04000000
73570>>>>>>>Define SHCNE_ASSOCCHANGED        For |CI$08000000
73570>>>>>>>Define SHCNE_DISKEVENTS          For |CI$0002381F
73570>>>>>>>Define SHCNE_GLOBALEVENTS        For |CI$0C0581E0
73570>>>>>>>Define SHCNE_ALLEVENTS           For |CI$7FFFFFFF
73570>>>>>>>Define SHCNE_INTERRUPT           For |CI$80000000
73570>>>>>>>Define SHCNEE_ORDERCHANGED       For |CI$00000002
73570>>>>>>>Define SHCNE_RENAMEITEM          For |CI$00000001
73570>>>>>>>Define SHCNE_CREATE              For |CI$00000002
73570>>>>>>>Define SHCNE_DELETE              For |CI$00000004
73570>>>>>>>Define SHCNE_MKDIR               For |CI$00000008
73570>>>>>>>Define SHCNE_RMDIR               For |CI$00000010
73570>>>>>>>Define SHCNE_MEDIAINSERTED       For |CI$00000020
73570>>>>>>>Define SHCNE_MEDIAREMOVED        For |CI$00000040
73570>>>>>>>Define SHCNE_DRIVEREMOVED        For |CI$00000080
73570>>>>>>>Define SHCNE_DRIVEADD            For |CI$00000100
73570>>>>>>>Define SHCNE_NETSHARE            For |CI$00000200
73570>>>>>>>Define SHCNE_NETUNSHARE          For |CI$00000400
73570>>>>>>>Define SHCNE_ATTRIBUTES          For |CI$00000800
73570>>>>>>>Define SHCNE_UPDATEDIR           For |CI$00001000
73570>>>>>>>Define SHCNE_UPDATEITEM          For |CI$00002000
73570>>>>>>>Define SHCNE_SERVERDISCONNECT    For |CI$00004000
73570>>>>>>>Define SHCNE_UPDATEIMAGE         For |CI$00008000
73570>>>>>>>Define SHCNE_DRIVEADDGUI         For |CI$00010000
73570>>>>>>>Define SHCNE_RENAMEFOLDER        For |CI$00020000
73570>>>>>>>Define SHCNE_FREESPACE           For |CI$00040000
73570>>>>>>>Define SHCNE_EXTENDED_EVENT      For |CI$04000000
73570>>>>>>>Define SHCNE_ASSOCCHANGED        For |CI$08000000
73570>>>>>>>Define SHCNE_DISKEVENTS          For |CI$0002381F
73570>>>>>>>Define SHCNE_GLOBALEVENTS        For |CI$0C0581E0
73570>>>>>>>Define SHCNE_ALLEVENTS           For |CI$7FFFFFFF
73570>>>>>>>Define SHCNE_INTERRUPT           For |CI$80000000
73570>>>>>>>Define SHCNEE_ORDERCHANGED       For |CI$00000002
73570>>>>>>>
73570>>>>>>>
73570>>>>>>>// Flags
73570>>>>>>>// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
73570>>>>>>>Define SHCNF_IDLIST      For |CI$0000        // LPITEMIDLIST
73570>>>>>>>Define SHCNF_PATHA       For |CI$0001        // path name
73570>>>>>>>Define SHCNF_PRINTERA    For |CI$0002        // printer friendly name
73570>>>>>>>Define SHCNF_DWORD       For |CI$0003        // DWORD
73570>>>>>>>Define SHCNF_PATHW       For |CI$0005        // path name
73570>>>>>>>Define SHCNF_PRINTERW    For |CI$0006        // printer friendly name
73570>>>>>>>Define SHCNF_TYPE        For |CI$00FF
73570>>>>>>>Define SHCNF_FLUSH       For |CI$1000
73570>>>>>>>Define SHCNF_FLUSHNOWAIT For |CI$2000
73570>>>>>>>  Define SHCNF_PATH        For SHCNF_PATHA
73570>>>>>>>  Define SHCNF_PRINTER     For SHCNF_PRINTERA
73570>>>>>>>
73570>>>>>>>External_Function SHChangeNotify "SHChangeNotify" Shell32.DLL Integer wEventID Integer uFlags Pointer pItem1 Pointer pItem2 Returns Integer
73571>>>>>>>
73571>>>>>>>
73571>>>>>>>
73571>>>>>>>// Creates a ProgrammTag with the commandline to start for the given action.
73571>>>>>>>// Open, Print
73571>>>>>>>// Also an Icon for Displaying can be assigned.
73571>>>>>>>Procedure AssignExecutAbleToTAG Global String sTag String sAction String sPath String sIconPath String sDescription Integer iShowExtention
73573>>>>>>>//  Integer iRoot
73573>>>>>>>//  String  sBranch c34
73573>>>>>>>//  Move (Character(34))                                                        To c34
73573>>>>>>>//  get_Registry_Root                                                           To iRoot sBranch
73573>>>>>>>//  set_Registry_Root                                                           To HKEY_CLASSES_ROOT sTag
73573>>>>>>>//  Set_Foreign_Profile_String (Append("Shell\",sAction))"Command" ""           To (sPath+ " "+c34+"%1"+c34)
73573>>>>>>>//  If (sIconPath <> "") Begin
73573>>>>>>>//    Set_Foreign_Profile_String "DefaultIcon" "\" ""                             To sIconPath
73573>>>>>>>//  End
73573>>>>>>>//  If (sDescription <> "") Begin
73573>>>>>>>//    Set_Foreign_Profile_String "\" "\" ""                 To sDescription
73573>>>>>>>//  End
73573>>>>>>>//  If iShowExtention Begin
73573>>>>>>>//    Set_Foreign_Profile_String "\" "\" "AlwaysShowExt"    To ""
73573>>>>>>>//  End
73573>>>>>>>//  Set_Registry_Root                                                   To iRoot sBranch
73573>>>>>>>End_Procedure
73574>>>>>>>// For creating an Open Tag.
73574>>>>>>>Procedure AssignExecutAbleToTAG_OPEN Global String sTag String sPath String sIconPath String sDescription Integer iShowExtention
73576>>>>>>>//  Send AssignExecutAbleToTAG sTag "Open" sPath sIconPath sDescription iShowExtention
73576>>>>>>>End_Procedure
73577>>>>>>>// For creating a Print Tag.
73577>>>>>>>Procedure AssignExecutAbleToTAG_PRINT Global String sTag String sPath String sIconPath String sDescription Integer iShowExtention
73579>>>>>>>//  Send AssignExecutAbleToTAG sTag "Print" sPath sIconPath sDescription  iShowExtention
73579>>>>>>>End_Procedure
73580>>>>>>>// Assigns an Exention to a created TAG
73580>>>>>>>Procedure AssignExtentionToTAG Global String sExt String sTag
73582>>>>>>>//  Integer iRoot
73582>>>>>>>//  String  sBranch
73582>>>>>>>//  get_Registry_Root                                           To iRoot sBranch
73582>>>>>>>//  set_Registry_Root                                           To HKEY_CLASSES_ROOT sExt
73582>>>>>>>//  Set_Foreign_Profile_String "\" "\" ""                       To sTag
73582>>>>>>>//  set_Registry_Root       To  iRoot sBranch
73582>>>>>>>End_Procedure
73583>>>>>>>
73583>>>>>>>// Need to be sent to inform the System that these things have changed.
73583>>>>>>>Procedure NofityShell_AssocChanged Global
73585>>>>>>>//  Integer iRet
73585>>>>>>>//  Move (SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,0,0))  To iRet
73585>>>>>>>End_Procedure
73586>>>>>Use mEditorMacros.pkg               // Save and Load Macros.
Including file: mEditorMacros.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mEditorMacros.pkg)
73586>>>>>>>//TH-Header
73586>>>>>>>//*****************************************************************************************
73586>>>>>>>// Copyright (c)  2001 Michael Kurz
73586>>>>>>>// All rights reserved.
73586>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73586>>>>>>>//
73586>>>>>>>// $FileName    : D:\Entwicklung\Codemax\mEditorMacros.pkg
73586>>>>>>>// $ProjectName : Codemax
73586>>>>>>>// $Author      : Michael Kurz
73586>>>>>>>// $Created     : 17.05.2001  10:41
73586>>>>>>>//
73586>>>>>>>// Contents:
73586>>>>>>>//  Loading and saving Macros to Editor.Dat.
73586>>>>>>>//
73586>>>>>>>//*****************************************************************************************
73586>>>>>>>//TH-RevisionStart
73586>>>>>>>//TH-RevisionEnd
73586>>>>>>>
73586>>>>>>>Use vWin32fh.pkg
73586>>>>>>>Use mUserAndComputerName.pkg
73586>>>>>>>
73586>>>>>>>// EDITOR(20) file should not be used anymore (see Tools\TH3Workspace.pkg)
73586>>>>>>>//Open Editor
73586>>>>>>>
73586>>>>>>>// Deletes all Entries in Editor.Dat from a specific user an typ.
73586>>>>>>>Procedure Editor_DeleteAll String sUser String sTyp
73588>>>>>>>//    Clear Editor
73588>>>>>>>//    Move sUser      To Editor.User
73588>>>>>>>//    Move sTyp       To Editor.Type
73588>>>>>>>//    Repeat
73588>>>>>>>//        Find Gt Editor by Index.1
73588>>>>>>>//        If Editor.User Ne sUser Indicate found False
73588>>>>>>>//        If Editor.Type Ne sTyp  Indicate found False
73588>>>>>>>//        [found] Begin
73588>>>>>>>//            Lock
73588>>>>>>>//                Delete Editor
73588>>>>>>>//            Unlock
73588>>>>>>>//        End
73588>>>>>>>//    Until [Not found]
73588>>>>>>>End_Procedure
73589>>>>>>>
73589>>>>>>>// Saves one Macro to the editor DataBase.
73589>>>>>>>Procedure Editor_SaveMacro String sUser Integer iMacro
73591>>>>>>>//    Integer iSize
73591>>>>>>>//    Move (CMGetMacro(iMacro,0))     To iSize
73591>>>>>>>//    If iSize Eq 0 Procedure_Return
73591>>>>>>>//    Local_Buffer sBuff pBuff iSize
73591>>>>>>>//    Move (CMGetMacro(iMacro,pBuff)) To iSize
73591>>>>>>>//    Clear Editor
73591>>>>>>>//    Move sUser              To Editor.User
73591>>>>>>>//    Move "MACRO"            To Editor.Type
73591>>>>>>>//    Move iMacro             To Editor.File
73591>>>>>>>//    Lock
73591>>>>>>>//        Find Eq Editor by Index.1
73591>>>>>>>//        Move iSize          To Editor.Count
73591>>>>>>>//        Move sBuff          To Editor.Data
73591>>>>>>>//        Saverecord Editor
73591>>>>>>>//    Unlock
73591>>>>>>>End_Procedure
73592>>>>>>>// SAves all 10 possible macros with CodeMax.
73592>>>>>>>Procedure Editor_SaveAllMacros String sUser
73594>>>>>>>//    Integer iC
73594>>>>>>>//    Send Editor_DeleteAll sUser "MACRO"     // Delete all old macros.
73594>>>>>>>//    For iC From 0 To 9
73594>>>>>>>//        Send Editor_SaveMacro sUser iC
73594>>>>>>>//    End
73594>>>>>>>End_Procedure
73595>>>>>>>
73595>>>>>>>Procedure FloatDeleteAllMacros
73597>>>>>>>//    Send Editor_DeleteAll gsUserName "MACRO"
73597>>>>>>>End_Procedure
73598>>>>>>>
73598>>>>>>>// Saves one Macro to the editor DataBase.
73598>>>>>>>Procedure Editor_LoadMacro String sUser Integer iMacro
73600>>>>>>>//    Integer iRet
73600>>>>>>>//    Local_Buffer sBuff pBuff
73600>>>>>>>//    Clear Editor
73600>>>>>>>//    Move sUser              To Editor.User
73600>>>>>>>//    Move "MACRO"            To Editor.Type
73600>>>>>>>//    Move iMacro             To Editor.File
73600>>>>>>>//    Find Eq Editor by Index.1
73600>>>>>>>//    [found] Begin
73600>>>>>>>//        Move (Left(Editor.Data,Editor.Count))   To sBuff
73600>>>>>>>//        GetAddress Of sBuff                     To pBuff
73600>>>>>>>//        Move (CMSetMacro(iMacro,pBuff))         To iRet
73600>>>>>>>//    End
73600>>>>>>>End_Procedure
73601>>>>>>>// Tries to load all 10 Macros possible in Codemax.
73601>>>>>>>Procedure Editor_LoadAllMacros String sUser
73603>>>>>>>//    Integer iC
73603>>>>>>>//    For iC From 0 To 9
73603>>>>>>>//        Send Editor_LoadMacro sUser iC
73603>>>>>>>//    End
73603>>>>>>>End_Procedure
73604>>>>>>>
73604>>>>>Use mFiles.pkg
Including file: MFILES.PKG    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MFILES.PKG)
73604>>>>>>>//*****************************************************************************************
73604>>>>>>>// Copyright (c) 2000 Michael Kurz
73604>>>>>>>// All rights reserved.
73604>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73604>>>>>>>//
73604>>>>>>>// $FileName    : mFiles.pkg
73604>>>>>>>// $ProjectName : Shared Methods
73604>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73604>>>>>>>// $Created     : 01-25-2001 @ 19:00
73604>>>>>>>//
73604>>>>>>>// Contents:
73604>>>>>>>//      Some useful functions for filehandling.
73604>>>>>>>//      -RTrimBackSlah      // Removes all "\" at the end of a path. (String)
73604>>>>>>>//      -FileFromPath       // FileName without path from a complete path
73604>>>>>>>//      -PathFromPath       // PathName form a complete path without FileName
73604>>>>>>>//
73604>>>>>>>//
73604>>>>>>>// $Rev History
73604>>>>>>>//
73604>>>>>>>//*****************************************************************************************
73604>>>>>>>
73604>>>>>>>Use GlobalFunctionsProcedures.pkg
73604>>>>>>>External_function DLLCopyFile   "CopyFileA"    kernel32.dll Pointer pQuelle Pointer pZiel Integer bFailIfExists Returns Integer
73605>>>>>>>External_Function DLLDeleteFile "DeleteFileA"  kernel32.dll Pointer szSrc Returns Integer
73606>>>>>>>External_Function MoveFile      "MoveFileA"    kernel32.dll Pointer pOrig Pointer pRenamed Returns Integer
73607>>>>>>>External_Function GetTempPathEf "GetTempPathA" kernel32.dll Integer dwBufferLen Pointer lpBuffer Returns Integer
73608>>>>>>>
73608>>>>>>>// Removes all "\" characters from the right side of a string...
73608>>>>>>>Function RTrimBackSlash Global String sDir Returns String
73610>>>>>>>  Move (Trim(sDir))   To sDir
73611>>>>>>>  While ((Right(sDir,1)) Eq "\")  // Removes all "\" from the end...
73615>>>>>>>    Move (Left(sDir,Length(sDir)-1)) To sDir
73616>>>>>>>  End
73617>>>>>>>>
73617>>>>>>>  Function_Return sDir
73618>>>>>>>End_Function
73619>>>>>>>
73619>>>>>>>// Gives the part of the string that is found after the right most "\"
73619>>>>>>>// character.
73619>>>>>>>Function FileFromPath Global String sDir Returns String
73621>>>>>>>  Move (RTrimBackSlash(sDir)) To sDir // Removes all "\" from the right hand side!
73622>>>>>>>  While ((Pos("\",sDir)) Ne 0)        // Remove all path parts...
73626>>>>>>>    Move (Right(sDir, Length(sDir)-Pos("\",sDir)))  To sDir
73627>>>>>>>  End
73628>>>>>>>>
73628>>>>>>>  Function_Return sDir
73629>>>>>>>End_Function
73630>>>>>>>
73630>>>>>>>// Complement to FileFromPath: Returns everything except the string that
73630>>>>>>>// is found after the right most "\" character.
73630>>>>>>>Function PathFromPath Global String sDir Returns String
73632>>>>>>>  String sPath sTmp
73632>>>>>>>  Move (RTrimBackSlash(sDir)) To sDir // Removes all "\" from the right hand side!
73633>>>>>>>  While ((Pos("\",sDir)) Ne 0)        // Removes the file part (must be here or a directory part will be removed!)
73637>>>>>>>    Move (Left(sDir,Pos("\",sDir))) To sTmp
73638>>>>>>>    Move (Replace(sTmp,sDir,""))    To sDir
73639>>>>>>>    Append sPath sTmp
73640>>>>>>>  End
73641>>>>>>>>
73641>>>>>>>  If (Right(sPath,1)) Eq "\" ;    Move (Left(sPath,Length(sPath)-1))   To sPath    // No "\" at the right hand
73644>>>>>>>  Function_Return sPath
73645>>>>>>>End_Function
73646>>>>>>>
73646>>>>>>>
73646>>>>>>>//***********************************
73646>>>>>>>// A few casual string functions
73646>>>>>>>//
73646>>>>>>>//
73646>>>>>>>// Returns the position of a substring in a host string
73646>>>>>>>// but not from left but from right!
73646>>>>>>>Function PosR Global String sChar String sStr Returns Integer
73648>>>>>>>  String sTmp sSubst
73648>>>>>>>  Integer iPos
73648>>>>>>>  Move (Repeat("@",Length(sChar)))                        To sSubst
73649>>>>>>>  If sSubst Eq sChar ;    Move (Repeat(" ",Length(sChar)))     To sSubst
73652>>>>>>>  Move sStr                                               To sTmp
73653>>>>>>>  While (sTmp Contains sChar)
73657>>>>>>>    Move (Pos(sChar,sTmp))                              To iPos
73658>>>>>>>    Move (Replace(sChar,sTmp,sSubst))                   To sTmp
73659>>>>>>>  End
73660>>>>>>>>
73660>>>>>>>  If iPos Le 0 ;    Move 0                                     To iPos
73663>>>>>>>  Else ;    Move (Length(sStr)-iPos+1)                 To iPos
73665>>>>>>>  Function_Return iPos
73666>>>>>>>End_Function
73667>>>>>>>
73667>>>>>>>// Liefert den linken Teil eines Strings der von eine Substring
73667>>>>>>>// begrenzt wird! (wenn der String gar nicht enthalten ist wird
73667>>>>>>>// der Gesamte String geliefert!
73667>>>>>>>Function PartL Global String sChar String sStr Returns String
73669>>>>>>>  String sPart
73669>>>>>>>
73669>>>>>>>  If sChar In sStr ;    Move (Left(sStr,Pos(sChar,sStr)-1)) To sPart
73672>>>>>>>  Else ;    Move sStr To sPart
73674>>>>>>>  Function_Return sPart
73675>>>>>>>End_Function
73676>>>>>>>
73676>>>>>>>
73676>>>>>>>// Liefert den rechten Teil eines Strings der von eine Substring
73676>>>>>>>// begrenzt wird! (wenn der String gar nicht enthalten ist wird
73676>>>>>>>// der Gesamte String geliefert!
73676>>>>>>>Function PartR Global String sChar String sStr Returns String
73678>>>>>>>  If sChar In sStr ;    Function_Return (Right(sStr,PosR(sChar,sStr)-1))
73681>>>>>>>  Else ;    Function_Return sStr
73683>>>>>>>End_Function
73684>>>>>>>
73684>>>>>>>// Liefert den X-Ten Teil aus einem durch Trennzeichen geteilten String!
73684>>>>>>>Function PartX Global Integer iNr String sChar String sStr Returns String
73686>>>>>>>  Integer iC
73686>>>>>>>  String  sPart
73686>>>>>>>  For iC From 1 To iNr
73692>>>>>>>>
73692>>>>>>>    Move (PartL(sChar,sStr))        To sPart    // Den Linkenteil des Strings holen
73693>>>>>>>    Move (Replace(sPart,sStr,""))   To sStr     // Diesen Teil aus dem String entfernen
73694>>>>>>>    Move (Replace(sChar,sStr,""))   To sStr     // das Trennzeichen entfernen
73695>>>>>>>  Loop
73696>>>>>>>>
73696>>>>>>>  Function_Return sPart
73697>>>>>>>End_Function
73698>>>>>>>
73698>>>>>>>// CopyFileEx: Copy FirstFile to SecondFile and (optional) gives a MsgBox if copy failed
73698>>>>>>>// Added 18.05.01 Bernhard
73698>>>>>>>
73698>>>>>>>Function CopyFileEx Global String sQuell String sZiel Integer iMeldung Returns Integer
73700>>>>>>>  Boolean bOk
73700>>>>>>>  Integer iRet
73700>>>>>>>  String  sMeldung sDatei
73700>>>>>>>  String  sQuellFile sZielFile
73700>>>>>>>
73700>>>>>>>  Move (Trim(sZiel)) To sZiel
73701>>>>>>>  If (Right(sZiel,1)) In "\:" Begin
73703>>>>>>>    Move sQuell To sDatei
73704>>>>>>>    Repeat
73704>>>>>>>>
73704>>>>>>>      Move (Replace((Left(sDatei,Pos("\",sDatei))),sDatei,"")) To sDatei
73705>>>>>>>    Until (Not(sDatei Contains "\"))
73707>>>>>>>    Append sZiel sDatei
73708>>>>>>>  End
73708>>>>>>>>
73708>>>>>>>
73708>>>>>>>  Move sQuell To sQuellFile
73709>>>>>>>  Move sZiel To sZielFile
73710>>>>>>>  Append sQuellFile (Character(0))
73711>>>>>>>  Append sZielFile (Character(0))
73712>>>>>>>  Move (ToAnsi(sQuellFile)) To sQuellFile
73713>>>>>>>  Move (ToAnsi(sZielFile))  To sZielFile
73714>>>>>>>
73714>>>>>>>  Move (DLLCopyFile(AddressOf(sQuellFile),AddressOf(sZielFile),FALSE)) To iRet
73715>>>>>>>  If iRet Eq 0 If iMeldung Begin
73719>>>>>>>    Move ("Could not copy File "+sQuell+" to "+ sZiel+".") To sMeldung
73720>>>>>>>    Send Info_Box sMeldung
73721>>>>>>>    Move FALSE To bOk
73722>>>>>>>  End
73722>>>>>>>>
73722>>>>>>>  Else ;    Move TRUE To bOk
73724>>>>>>>  Function_Return bOk
73725>>>>>>>End_Function
73726>>>>>>>
73726>>>>>>>Function DoDeleteFile Global String sFile Returns Integer
73728>>>>>>>  Integer iRet
73728>>>>>>>  String  sS1
73728>>>>>>>  Move sFile         To sS1
73729>>>>>>>  Move (ToAnsi(sS1)) To sS1
73730>>>>>>>  Move (DLLDeleteFile(AddressOf(sS1)))   To iRet
73731>>>>>>>  Function_Return iRet
73732>>>>>>>End_Function
73733>>>>>>>
73733>>>>>>>
73733>>>>>>>// Fixed a bug if renaming a file that is not in the current directory
73733>>>>>>>// 19.2.02 Bernhard
73733>>>>>>>
73733>>>>>>>Procedure RenameFileEx Global String sQuell String sZiel Integer iMeldung
73735>>>>>>>  Integer iRet
73735>>>>>>>  String  sMeldung sQuellPath
73735>>>>>>>  String  sQuellFile sZielFile
73735>>>>>>>
73735>>>>>>>  Move sQuell To sQuellFile
73736>>>>>>>  Move sZiel  To sZielFile
73737>>>>>>>  If (Pos("\",sZielFile)) Eq 0 Begin
73739>>>>>>>    Move (PathFromPath(sQuellFile)) To sQuellPath
73740>>>>>>>    Move (sQuellPath + "\" + sZielFile) To sZielFile
73741>>>>>>>  End
73741>>>>>>>>
73741>>>>>>>
73741>>>>>>>  Get DoDeleteFile sZielFile To iRet
73742>>>>>>>
73742>>>>>>>  Append sQuellFile (Character(0))
73743>>>>>>>  Append sZielFile (Character(0))
73744>>>>>>>  Move (ToAnsi(sQuellFile)) To sQuellFile
73745>>>>>>>  Move (ToAnsi(sZielFile))  To sZielFile
73746>>>>>>>
73746>>>>>>>  Move (MoveFile(AddressOf(sQuellFile),AddressOf(sZielFile))) To iRet
73747>>>>>>>  If iRet Eq 0 If iMeldung Begin
73751>>>>>>>    Move ("Could not rename File "+sQuell+" to "+ sZiel+".") To sMeldung
73752>>>>>>>    Send Info_Box sMeldung
73753>>>>>>>  End
73753>>>>>>>>
73753>>>>>>>End_Procedure
73754>>>>>>>
73754>>>>>>>// TempDirectory: Returns the Temp-Directory of Windows. If the API-Call fails, the current-directory "." is returned
73754>>>>>>>// Added 19.02.02 Bernhard
73754>>>>>>>
73754>>>>>>>Function TempDirectory Global Returns String
73756>>>>>>>  Integer iRet
73756>>>>>>>  String  sDir
73756>>>>>>>  String  sTempDir
73756>>>>>>>
73756>>>>>>>  Move "." To sDir
73757>>>>>>>  Move (Repeat(Character(0),120)) To sTempDir
73758>>>>>>>  Move (GetTempPathEf(120,AddressOf(sTempDir))) To iRet
73759>>>>>>>  If iRet Ne 0 Begin
73761>>>>>>>    Move (ToOem(sTempDir)) To sTempDir
73762>>>>>>>    Move (cString(sTempDir)) To sTempDir
73763>>>>>>>    If (Right(sTempDir,1)) Eq "\" ;      Move (Left(sTempDir, ( (Length(sTempDir)) -1 ))) To sTempDir
73766>>>>>>>    Move sTempDir To sDir
73767>>>>>>>  End
73767>>>>>>>>
73767>>>>>>>  Function_Return sDir
73768>>>>>>>End_Function
73769>>>>>>>
73769>>>>>Use vWin32fh.pkg
73769>>>>>Use cSciCommandHotKeySupport.pkg
Including file: cSciCommandHotKeySupport.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciCommandHotKeySupport.pkg)
73769>>>>>>>Use cSciLexer.h
Including file: cSciLexer.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexer.h)
73769>>>>>>>>>Use DFAllent.pkg
73769>>>>>>>>>Use mStrConv.pkg
Including file: mStrConv.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mStrConv.pkg)
73769>>>>>>>>>>>//*****************************************************************************************
73769>>>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73769>>>>>>>>>>>// All rights reserved.
73769>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73769>>>>>>>>>>>//
73769>>>>>>>>>>>// $FileName    : mStrConv.Pkg
73769>>>>>>>>>>>// $ProjectName : Sahred Methods and Functions
73769>>>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73769>>>>>>>>>>>// $Created     : 01-25-2001 @ 19:00
73769>>>>>>>>>>>//
73769>>>>>>>>>>>// Contents:
73769>>>>>>>>>>>//      Functions for converting strings to a string with its ASCII values and back.
73769>>>>>>>>>>>//
73769>>>>>>>>>>>//
73769>>>>>>>>>>>// $Rev History
73769>>>>>>>>>>>//
73769>>>>>>>>>>>//*****************************************************************************************
73769>>>>>>>>>>>
73769>>>>>>>>>>>// Flips a string Left-Right
73769>>>>>>>>>>>Function FlipStrLR Global String sStr Returns String
73771>>>>>>>>>>>  Integer iC iL
73771>>>>>>>>>>>  String  sRet
73771>>>>>>>>>>>  Move (Length(sStr)) To iL
73772>>>>>>>>>>>  For iC From 1 To iL
73778>>>>>>>>>>>>
73778>>>>>>>>>>>    Move (Append(Mid(sStr,1,iC),sRet))  To sRet
73779>>>>>>>>>>>  Loop
73780>>>>>>>>>>>>
73780>>>>>>>>>>>  Function_Return sRet
73781>>>>>>>>>>>End_Function
73782>>>>>>>>>>>
73782>>>>>>>>>>>// Converts a String to Ascii Code
73782>>>>>>>>>>>Function ConvertBuffToAscii Global String sBuff Returns String
73784>>>>>>>>>>>  String  sCh sRet
73784>>>>>>>>>>>  Integer iC iLength
73784>>>>>>>>>>>  Move (Length(sBuff))    To iLength
73785>>>>>>>>>>>  For iC From 1 To iLength
73791>>>>>>>>>>>>
73791>>>>>>>>>>>    Move (Mid(sBuff,1,iC))              To sCh
73792>>>>>>>>>>>    Move (Ascii(sCh))                   To sCh
73793>>>>>>>>>>>    Move (Right(Append("000",sCh),3))   To sCh
73794>>>>>>>>>>>    Append sRet sCh
73795>>>>>>>>>>>  Loop
73796>>>>>>>>>>>>
73796>>>>>>>>>>>  Function_Return sRet
73797>>>>>>>>>>>End_Function
73798>>>>>>>>>>>// Converts a String from Ascii back to str.
73798>>>>>>>>>>>Function ConvertAsciiToBuff Global String sBuff Returns String
73800>>>>>>>>>>>  String  sRet
73800>>>>>>>>>>>  Integer iCh iC iLength
73800>>>>>>>>>>>  Move (Length(sBuff))    To iLength
73801>>>>>>>>>>>  For iC From 1 To iLength
73807>>>>>>>>>>>>
73807>>>>>>>>>>>    Move (Mid(sBuff,3,iC))              To iCh
73808>>>>>>>>>>>    Append sRet (Character(iCh))
73809>>>>>>>>>>>    Move (iC+2)                         To iC   // 1+2=3
73810>>>>>>>>>>>  Loop
73811>>>>>>>>>>>>
73811>>>>>>>>>>>  Function_Return sRet
73812>>>>>>>>>>>End_Function
73813>>>>>>>>>>>
73813>>>>>>>>>>>Function ConvertIntegerArrayToAscii Integer[] Data Returns String
73815>>>>>>>>>>>  String  sCh sResult
73815>>>>>>>>>>>  Integer iC iLength
73815>>>>>>>>>>>  Integer iValue
73815>>>>>>>>>>>  Integer iLSB iMSB
73815>>>>>>>>>>>  UShort  usLSB usMSB
73815>>>>>>>>>>>
73815>>>>>>>>>>>  Move "" To sResult
73816>>>>>>>>>>>  Move (SizeOfArray(Data))    To iLength
73817>>>>>>>>>>>  If (iLength>0) Begin
73819>>>>>>>>>>>    For iC From 0 To (iLength-1)
73825>>>>>>>>>>>>
73825>>>>>>>>>>>      Move 0 To usLSB
73826>>>>>>>>>>>      Move 0 To usMSB
73827>>>>>>>>>>>      Move 0 To iLSB
73828>>>>>>>>>>>      Move 0 To iMSB
73829>>>>>>>>>>>      Move Data[iC] To iValue
73830>>>>>>>>>>>      Move (Low(iValue)) To iLSB
73831>>>>>>>>>>>      Move (Hi(iValue))  To iMSB
73832>>>>>>>>>>>      // Write out Low data part of integer
73832>>>>>>>>>>>      Move (Mod(iLSB,256))    To usLSB
73833>>>>>>>>>>>      Move ((iLSB-usLSB)/256) To usMSB
73834>>>>>>>>>>>      Move (Right(Append("000",String(usLSB)),3))   To sCh
73835>>>>>>>>>>>      Append sResult sCh
73836>>>>>>>>>>>      Move (Right(Append("000",String(usMSB)),3))   To sCh
73837>>>>>>>>>>>      Append sResult sCh
73838>>>>>>>>>>>      // Write out High data part of integer
73838>>>>>>>>>>>      Move (Mod(iMSB,256))    To usLSB
73839>>>>>>>>>>>      Move ((iMSB-usLSB)/256) To usMSB
73840>>>>>>>>>>>      Move (Right(Append("000",String(usLSB)),3))   To sCh
73841>>>>>>>>>>>      Append sResult sCh
73842>>>>>>>>>>>      Move (Right(Append("000",String(usMSB)),3))   To sCh
73843>>>>>>>>>>>      Append sResult sCh
73844>>>>>>>>>>>    Loop
73845>>>>>>>>>>>>
73845>>>>>>>>>>>  End
73845>>>>>>>>>>>>
73845>>>>>>>>>>>  Function_Return sResult
73846>>>>>>>>>>>End_Function
73847>>>>>>>>>>>
73847>>>>>>>>>>>// The Hammer string format is LSB/MSB in string with 3 characters per digit
73847>>>>>>>>>>>// Total is 4 characters per integer value.
73847>>>>>>>>>>>// There can be a bogus "000" at the end with which we do nothing.
73847>>>>>>>>>>>Function ConvertAsciiToIntegerArray Global String sBuff Returns Integer[]
73849>>>>>>>>>>>  Integer iCh iC iLength
73849>>>>>>>>>>>  Integer iValue
73849>>>>>>>>>>>  Integer iByte
73849>>>>>>>>>>>  Integer[] Results
73850>>>>>>>>>>>
73850>>>>>>>>>>>  Move (ResizeArray(Results,0)) To Results
73851>>>>>>>>>>>  Move (Length(sBuff))    To iLength
73852>>>>>>>>>>>  Move 0 To iByte
73853>>>>>>>>>>>  Move 0 To iValue
73854>>>>>>>>>>>  For iC From 1 To iLength
73860>>>>>>>>>>>>
73860>>>>>>>>>>>    Move (Mid(sBuff,3,iC))              To iCh
73861>>>>>>>>>>>    Move (iValue+(iCh*(256^iByte))) To iValue
73862>>>>>>>>>>>    Increment iByte
73863>>>>>>>>>>>    If (iByte=4) Begin
73865>>>>>>>>>>>      Move iValue To Results[SizeOfArray(Results)]
73866>>>>>>>>>>>      Move 0 To iByte
73867>>>>>>>>>>>      Move 0 To iValue
73868>>>>>>>>>>>    End
73868>>>>>>>>>>>>
73868>>>>>>>>>>>    Move (iC+2)                         To iC   // 1+2=3
73869>>>>>>>>>>>  Loop
73870>>>>>>>>>>>>
73870>>>>>>>>>>>  Function_Return Results
73871>>>>>>>>>>>End_Function
73872>>>>>>>>>>>
73872>>>>>>>>>>>
73872>>>>>>>>>>>// Converts one Digit from Decimal to Hex.
73872>>>>>>>>>>>Function IntToHexDigit Global Integer iInt Returns String
73874>>>>>>>>>>>  If iInt Lt 0 ;    Function_Return 0
73877>>>>>>>>>>>  If iInt Lt 10 ;    Function_Return iInt
73880>>>>>>>>>>>  If iInt Eq 10 ;    Function_Return "A"
73883>>>>>>>>>>>  If iInt Eq 11 ;    Function_Return "B"
73886>>>>>>>>>>>  If iInt Eq 12 ;    Function_Return "C"
73889>>>>>>>>>>>  If iInt Eq 13 ;    Function_Return "D"
73892>>>>>>>>>>>  If iInt Eq 14 ;    Function_Return "E"
73895>>>>>>>>>>>  If iInt Eq 15 ;    Function_Return "F"
73898>>>>>>>>>>>  Function_Return ""
73899>>>>>>>>>>>End_Function
73900>>>>>>>>>>>
73900>>>>>>>>>>>// Converts one Digit from Decimal to Hex.
73900>>>>>>>>>>>Function HexToIntDigit Global String sHEX Returns Integer
73902>>>>>>>>>>>  If sHex Eq "F" ;    Function_Return 15
73905>>>>>>>>>>>  If sHex Eq "E" ;    Function_Return 14
73908>>>>>>>>>>>  If sHex Eq "D" ;    Function_Return 13
73911>>>>>>>>>>>  If sHex Eq "C" ;    Function_Return 12
73914>>>>>>>>>>>  If sHex Eq "B" ;    Function_Return 11
73917>>>>>>>>>>>  If sHex Eq "A" ;    Function_Return 10
73920>>>>>>>>>>>  Function_Return sHex
73921>>>>>>>>>>>End_Function
73922>>>>>>>>>>>
73922>>>>>>>>>>>
73922>>>>>>>>>>>// Converts a decimal value (0-255)
73922>>>>>>>>>>>Function IntToHex Global Integer iInt Returns String
73924>>>>>>>>>>>  Integer iL iH
73924>>>>>>>>>>>  String  sRet
73924>>>>>>>>>>>  Move (iInt/16)      To iH
73925>>>>>>>>>>>  Move (Mod(iInt,16)) To iL
73926>>>>>>>>>>>  Append sRet (IntToHexDigit(iH)) (IntToHexDigit(iL))
73928>>>>>>>>>>>  Function_Return sRet
73929>>>>>>>>>>>End_Function
73930>>>>>>>>>>>
73930>>>>>>>>>>>// Converts a hex value to decimal (0-255)
73930>>>>>>>>>>>Function HexToInt Global String sHex Returns Integer
73932>>>>>>>>>>>  Function_Return ((HexToIntDigit(Left(sHex,1))*16)+(HexToIntDigit(Right(sHex,1))))
73933>>>>>>>>>>>End_Function
73934>>>>>>>>>>>
73934>>>>>>>>>>>// Converts a character to an Ascii value in Hex
73934>>>>>>>>>>>Function AsciiHex Global String sCH Returns String
73936>>>>>>>>>>>  Function_Return (IntToHex(Ascii(sCH)))
73937>>>>>>>>>>>End_Function
73938>>>>>>>>>>>// Converts a ascii hex value to a character.
73938>>>>>>>>>>>Function CharacterHex Global String sHex Returns String
73940>>>>>>>>>>>  Function_Return (Character(HexToInt(sHex)))
73941>>>>>>>>>>>End_Function
73942>>>>>>>>>>>
73942>>>>>>>>>>>
73942>>>>>>>>>>>// Converts a String to Ascii Code
73942>>>>>>>>>>>Function ConvertBuffToAsciiHex Global String sBuff Returns String
73944>>>>>>>>>>>  String  sCh sRet
73944>>>>>>>>>>>  Integer iC iLength
73944>>>>>>>>>>>  Move (Length(sBuff))    To iLength
73945>>>>>>>>>>>  For iC From 1 To iLength
73951>>>>>>>>>>>>
73951>>>>>>>>>>>    Move (Mid(sBuff,1,iC))              To sCh
73952>>>>>>>>>>>    Move (AsciiHex(sCh))                To sCh
73953>>>>>>>>>>>    Append sRet sCh
73954>>>>>>>>>>>  Loop
73955>>>>>>>>>>>>
73955>>>>>>>>>>>  Function_Return sRet
73956>>>>>>>>>>>End_Function
73957>>>>>>>>>>>// Converts a String from Ascii back to str.
73957>>>>>>>>>>>Function ConvertAsciiToBuffHex Global String sBuff Returns String
73959>>>>>>>>>>>  String  sCh sRet
73959>>>>>>>>>>>  Integer iC iLength
73959>>>>>>>>>>>  Move (Length(sBuff))    To iLength
73960>>>>>>>>>>>  For iC From 1 To iLength
73966>>>>>>>>>>>>
73966>>>>>>>>>>>    Move (Mid(sBuff,2,iC))              To sCh
73967>>>>>>>>>>>    Append sRet (CharacterHex(sCh))
73968>>>>>>>>>>>    Move (iC+1)                         To iC   // 1+1=2
73969>>>>>>>>>>>  Loop
73970>>>>>>>>>>>>
73970>>>>>>>>>>>  Function_Return sRet
73971>>>>>>>>>>>End_Function
73972>>>>>>>>>>>
73972>>>>>>>>>>>// Converts some special characters in a string.
73972>>>>>>>>>>>Function fsConvertString Global String sStr Returns String
73974>>>>>>>>>>>  String sCR
73974>>>>>>>>>>>  Append sCR (Character(13)) (Character(10))
73976>>>>>>>>>>>  Move (Replaces("\n",sStr,sCR))              To sStr
73977>>>>>>>>>>>  Move (Replaces("\t",sStr,Character(9)))     To sStr
73978>>>>>>>>>>>  Move (Replaces("\C34",sStr,Character(34)))  To sStr
73979>>>>>>>>>>>  Function_Return sStr
73980>>>>>>>>>>>End_Function
73981>>>>>>>>>Use mPointer.pkg
73981>>>>>>>>>Use tWinStructs.pkg
73981>>>>>>>>>Use cScintilla.h
Including file: cScintilla.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cScintilla.h)
73981>>>>>>>>>>>//TH-Header
73981>>>>>>>>>>>//*****************************************************************************************
73981>>>>>>>>>>>// Copyright (c)  2019 Antwise Solutions
73981>>>>>>>>>>>// All rights reserved.
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// $FileName    : \Pkg\cScintilla.h
73981>>>>>>>>>>>// $ProjectName : TheHammer4
73981>>>>>>>>>>>// $Authors     : Wil van Antwerpen
73981>>>>>>>>>>>// $Created     : 12.06.2019  22:31
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// Contents:
73981>>>>>>>>>>>//   Contains the defines that match the C declarations for the scintilla control that can
73981>>>>>>>>>>>//   be found at the scintilla project file scintilla.h
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// This header is licensed under the 2 clause BSD license as to make it as easy as possible to re-use if needed.
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// BSD License content start
73981>>>>>>>>>>>// *********************************************************************************************************
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// Copyright (c) 2019, Wil van Antwerpen
73981>>>>>>>>>>>// All rights reserved.
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// Redistribution and use in source and binary forms, with or without
73981>>>>>>>>>>>// modification, are permitted provided that the following conditions are met:
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// 1. Redistributions of source code must retain the above copyright notice, this
73981>>>>>>>>>>>//    list of conditions and the following disclaimer.
73981>>>>>>>>>>>// 2. Redistributions in binary form must reproduce the above copyright notice,
73981>>>>>>>>>>>//    this list of conditions and the following disclaimer in the documentation
73981>>>>>>>>>>>//    and/or other materials provided with the distribution.
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
73981>>>>>>>>>>>// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
73981>>>>>>>>>>>// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
73981>>>>>>>>>>>// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
73981>>>>>>>>>>>// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
73981>>>>>>>>>>>// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
73981>>>>>>>>>>>// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
73981>>>>>>>>>>>// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
73981>>>>>>>>>>>// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
73981>>>>>>>>>>>// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
73981>>>>>>>>>>>//
73981>>>>>>>>>>>// The views and conclusions contained in the software and documentation are those
73981>>>>>>>>>>>// of the authors and should not be interpreted as representing official policies,
73981>>>>>>>>>>>// either expressed or implied, of the VDF-Guidance / Hammer Project.
73981>>>>>>>>>>>// *********************************************************************************************************
73981>>>>>>>>>>>//
73981>>>>>>>>>>>//*****************************************************************************************
73981>>>>>>>>>>>//TH-RevisionStart
73981>>>>>>>>>>>// ********************
73981>>>>>>>>>>>// MODIFICATION SUMMARY
73981>>>>>>>>>>>// ********************
73981>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
73981>>>>>>>>>>>//TH-RevisionEnd
73981>>>>>>>>>>>
73981>>>>>>>>>>>
73981>>>>>>>>>>>
73981>>>>>>>>>>>
73981>>>>>>>>>>>// Note that the following defines come from the Scintilla.h file in the scintilla project
73981>>>>>>>>>>>// These files are generated from the Scintilla.iface file, so we will have to compare that
73981>>>>>>>>>>>// file every time!
73981>>>>>>>>>>>Define INVALID_POSITION                        For -1
73981>>>>>>>>>>>Define SCI_START                               For 2000
73981>>>>>>>>>>>Define SCI_OPTIONAL_START                      For 3000
73981>>>>>>>>>>>Define SCI_LEXER_START                         For 4000
73981>>>>>>>>>>>Define SCI_ADDTEXT                             For 2001
73981>>>>>>>>>>>Define SCI_ADDSTYLEDTEXT                       For 2002
73981>>>>>>>>>>>Define SCI_INSERTTEXT                          For 2003
73981>>>>>>>>>>>Define SCI_CHANGEINSERTION                     For 2672
73981>>>>>>>>>>>Define SCI_CLEARALL                            For 2004
73981>>>>>>>>>>>Define SCI_DELETERANGE                         For 2645
73981>>>>>>>>>>>Define SCI_CLEARDOCUMENTSTYLE                  For 2005
73981>>>>>>>>>>>Define SCI_GETLENGTH                           For 2006
73981>>>>>>>>>>>Define SCI_GETCHARAT                           For 2007
73981>>>>>>>>>>>Define SCI_GETCURRENTPOS                       For 2008
73981>>>>>>>>>>>Define SCI_GETANCHOR                           For 2009
73981>>>>>>>>>>>Define SCI_GETSTYLEAT                          For 2010
73981>>>>>>>>>>>Define SCI_REDO                                For 2011
73981>>>>>>>>>>>Define SCI_SETUNDOCOLLECTION                   For 2012
73981>>>>>>>>>>>Define SCI_SELECTALL                           For 2013
73981>>>>>>>>>>>Define SCI_SETSAVEPOINT                        For 2014
73981>>>>>>>>>>>Define SCI_GETSTYLEDTEXT                       For 2015
73981>>>>>>>>>>>Define SCI_CANREDO                             For 2016
73981>>>>>>>>>>>Define SCI_MARKERLINEFROMHANDLE                For 2017
73981>>>>>>>>>>>Define SCI_MARKERDELETEHANDLE                  For 2018
73981>>>>>>>>>>>Define SCI_GETUNDOCOLLECTION                   For 2019
73981>>>>>>>>>>>Define SCWS_INVISIBLE                          For 0
73981>>>>>>>>>>>Define SCWS_VISIBLEALWAYS                      For 1
73981>>>>>>>>>>>Define SCWS_VISIBLEAFTERINDENT                 For 2
73981>>>>>>>>>>>Define SCWS_VISIBLEONLYININDENT                For 3
73981>>>>>>>>>>>Define SCI_GETVIEWWS                           For 2020
73981>>>>>>>>>>>Define SCI_SETVIEWWS                           For 2021
73981>>>>>>>>>>>Define SCTD_LONGARROW                          For 0
73981>>>>>>>>>>>Define SCTD_STRIKEOUT                          For 1
73981>>>>>>>>>>>Define SCI_GETTABDRAWMODE                      For 2698
73981>>>>>>>>>>>Define SCI_SETTABDRAWMODE                      For 2699
73981>>>>>>>>>>>Define SCI_POSITIONFROMPOINT                   For 2022
73981>>>>>>>>>>>Define SCI_POSITIONFROMPOINTCLOSE              For 2023
73981>>>>>>>>>>>Define SCI_GOTOLINE                            For 2024
73981>>>>>>>>>>>Define SCI_GOTOPOS                             For 2025
73981>>>>>>>>>>>Define SCI_SETANCHOR                           For 2026
73981>>>>>>>>>>>Define SCI_GETCURLINE                          For 2027
73981>>>>>>>>>>>Define SCI_GETENDSTYLED                        For 2028
73981>>>>>>>>>>>Define SC_EOL_CRLF                             For 0
73981>>>>>>>>>>>Define SC_EOL_CR                               For 1
73981>>>>>>>>>>>Define SC_EOL_LF                               For 2
73981>>>>>>>>>>>Define SCI_CONVERTEOLS                         For 2029
73981>>>>>>>>>>>Define SCI_GETEOLMODE                          For 2030
73981>>>>>>>>>>>Define SCI_SETEOLMODE                          For 2031
73981>>>>>>>>>>>Define SCI_STARTSTYLING                        For 2032
73981>>>>>>>>>>>Define SCI_SETSTYLING                          For 2033
73981>>>>>>>>>>>Define SCI_GETBUFFEREDDRAW                     For 2034
73981>>>>>>>>>>>Define SCI_SETBUFFEREDDRAW                     For 2035
73981>>>>>>>>>>>Define SCI_SETTABWIDTH                         For 2036
73981>>>>>>>>>>>Define SCI_GETTABWIDTH                         For 2121
73981>>>>>>>>>>>Define SCI_CLEARTABSTOPS                       For 2675
73981>>>>>>>>>>>Define SCI_ADDTABSTOP                          For 2676
73981>>>>>>>>>>>Define SCI_GETNEXTTABSTOP                      For 2677
73981>>>>>>>>>>>Define SC_CP_UTF8                              For 65001
73981>>>>>>>>>>>Define SCI_SETCODEPAGE                         For 2037
73981>>>>>>>>>>>Define SC_IME_WINDOWED                         For 0
73981>>>>>>>>>>>Define SC_IME_INLINE                           For 1
73981>>>>>>>>>>>Define SCI_GETIMEINTERACTION                   For 2678
73981>>>>>>>>>>>Define SCI_SETIMEINTERACTION                   For 2679
73981>>>>>>>>>>>Define MARKER_MAX                              For 31
73981>>>>>>>>>>>Define SC_MARK_CIRCLE                          For 0
73981>>>>>>>>>>>Define SC_MARK_ROUNDRECT                       For 1
73981>>>>>>>>>>>Define SC_MARK_ARROW                           For 2
73981>>>>>>>>>>>Define SC_MARK_SMALLRECT                       For 3
73981>>>>>>>>>>>Define SC_MARK_SHORTARROW                      For 4
73981>>>>>>>>>>>Define SC_MARK_EMPTY                           For 5
73981>>>>>>>>>>>Define SC_MARK_ARROWDOWN                       For 6
73981>>>>>>>>>>>Define SC_MARK_MINUS                           For 7
73981>>>>>>>>>>>Define SC_MARK_PLUS                            For 8
73981>>>>>>>>>>>Define SC_MARK_VLINE                           For 9
73981>>>>>>>>>>>Define SC_MARK_LCORNER                         For 10
73981>>>>>>>>>>>Define SC_MARK_TCORNER                         For 11
73981>>>>>>>>>>>Define SC_MARK_BOXPLUS                         For 12
73981>>>>>>>>>>>Define SC_MARK_BOXPLUSCONNECTED                For 13
73981>>>>>>>>>>>Define SC_MARK_BOXMINUS                        For 14
73981>>>>>>>>>>>Define SC_MARK_BOXMINUSCONNECTED               For 15
73981>>>>>>>>>>>Define SC_MARK_LCORNERCURVE                    For 16
73981>>>>>>>>>>>Define SC_MARK_TCORNERCURVE                    For 17
73981>>>>>>>>>>>Define SC_MARK_CIRCLEPLUS                      For 18
73981>>>>>>>>>>>Define SC_MARK_CIRCLEPLUSCONNECTED             For 19
73981>>>>>>>>>>>Define SC_MARK_CIRCLEMINUS                     For 20
73981>>>>>>>>>>>Define SC_MARK_CIRCLEMINUSCONNECTED            For 21
73981>>>>>>>>>>>Define SC_MARK_BACKGROUND                      For 22
73981>>>>>>>>>>>Define SC_MARK_DOTDOTDOT                       For 23
73981>>>>>>>>>>>Define SC_MARK_ARROWS                          For 24
73981>>>>>>>>>>>Define SC_MARK_PIXMAP                          For 25
73981>>>>>>>>>>>Define SC_MARK_FULLRECT                        For 26
73981>>>>>>>>>>>Define SC_MARK_LEFTRECT                        For 27
73981>>>>>>>>>>>Define SC_MARK_AVAILABLE                       For 28
73981>>>>>>>>>>>Define SC_MARK_UNDERLINE                       For 29
73981>>>>>>>>>>>Define SC_MARK_RGBAIMAGE                       For 30
73981>>>>>>>>>>>Define SC_MARK_BOOKMARK                        For 31
73981>>>>>>>>>>>Define SC_MARK_VERTICALBOOKMARK                For 32
73981>>>>>>>>>>>Define SC_MARK_CHARACTER                       For 10000
73981>>>>>>>>>>>// Hammer Custom
73981>>>>>>>>>>>Define SC_MARKNUM_LINEHIGHLIGHT                For 10
73981>>>>>>>>>>>Define SC_MARKNUM_BOOKMARK                     For 11
73981>>>>>>>>>>>Define SC_MARKNUM_CHANGEDLINE                  For 12
73981>>>>>>>>>>>Define SC_MARKNUM_CHANGEDLINESAVED             For 13
73981>>>>>>>>>>>Define SC_MARKNUM_DEBUGBREAKPOINT              For 14
73981>>>>>>>>>>>Define SC_MARKNUM_DEBUGCURRENTPOSITION         For 15
73981>>>>>>>>>>>// Hammer Custom ends
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDEREND                    For 25
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDEROPENMID                For 26
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDERMIDTAIL                For 27
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDERTAIL                   For 28
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDERSUB                    For 29
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDER                       For 30
73981>>>>>>>>>>>Define SC_MARKNUM_FOLDEROPEN                   For 31
73981>>>>>>>>>>>Define SC_MASK_FOLDERS                         For |CI$FE000000 // 0xFE000000
73981>>>>>>>>>>>// Hammer Custom
73981>>>>>>>>>>>Define SC_MASK_MARGIN                          For |CI$01000000 // 0x01000000 - allow symbol 24
73981>>>>>>>>>>>Define SC_MASK_BOOKMARK                        For |CI$00000800 // 0x00000800 - allow symbol 11, start counting from right, each bit is 1, starting from symbol 0
73981>>>>>>>>>>>Define SC_MASK_CHANGEDLINEUNSAVED              For |CI$00001000 // 0x00001000 - allow symbol 12 only
73981>>>>>>>>>>>Define SC_MASK_CHANGEDLINE                     For |CI$00003000 // 0x00003000 - allow symbol 12 and 13
73981>>>>>>>>>>>Define SC_MASK_DEBUGBREAKPOINT                 For |CI$00004000 // 0x00008000 - allow symbol 14
73981>>>>>>>>>>>Define SC_MASK_DEBUGCURRENTPOSITION            For |CI$00008000 // 0x00004000 - allow symbol 15
73981>>>>>>>>>>>Define SC_MASK_STATUS                          For |CI$0000C800 // 0x00000800 - allow symbol 11, 14 and 15
73981>>>>>>>>>>>// Hammer Custom ends
73981>>>>>>>>>>>Define SCI_MARKERDEFINE                        For 2040
73981>>>>>>>>>>>Define SCI_MARKERSETFORE                       For 2041
73981>>>>>>>>>>>Define SCI_MARKERSETBACK                       For 2042
73981>>>>>>>>>>>Define SCI_MARKERSETBACKSELECTED               For 2292
73981>>>>>>>>>>>Define SCI_MARKERENABLEHIGHLIGHT               For 2293
73981>>>>>>>>>>>Define SCI_MARKERADD                           For 2043
73981>>>>>>>>>>>Define SCI_MARKERDELETE                        For 2044
73981>>>>>>>>>>>Define SCI_MARKERDELETEALL                     For 2045
73981>>>>>>>>>>>Define SCI_MARKERGET                           For 2046
73981>>>>>>>>>>>Define SCI_MARKERNEXT                          For 2047
73981>>>>>>>>>>>Define SCI_MARKERPREVIOUS                      For 2048
73981>>>>>>>>>>>Define SCI_MARKERDEFINEPIXMAP                  For 2049
73981>>>>>>>>>>>Define SCI_MARKERADDSET                        For 2466
73981>>>>>>>>>>>Define SCI_MARKERSETALPHA                      For 2476
73981>>>>>>>>>>>Define SC_MAX_MARGIN                           For 4
73981>>>>>>>>>>>Define SC_MARGIN_SYMBOL                        For 0
73981>>>>>>>>>>>Define SC_MARGIN_NUMBER                        For 1
73981>>>>>>>>>>>Define SC_MARGIN_BACK                          For 2
73981>>>>>>>>>>>Define SC_MARGIN_FORE                          For 3
73981>>>>>>>>>>>Define SC_MARGIN_TEXT                          For 4
73981>>>>>>>>>>>Define SC_MARGIN_RTEXT                         For 5
73981>>>>>>>>>>>Define SC_MARGIN_COLOUR                        For 6
73981>>>>>>>>>>>Define SCI_SETMARGINTYPEN                      For 2240
73981>>>>>>>>>>>Define SCI_GETMARGINTYPEN                      For 2241
73981>>>>>>>>>>>Define SCI_SETMARGINWIDTHN                     For 2242
73981>>>>>>>>>>>Define SCI_GETMARGINWIDTHN                     For 2243
73981>>>>>>>>>>>Define SCI_SETMARGINMASKN                      For 2244
73981>>>>>>>>>>>Define SCI_GETMARGINMASKN                      For 2245
73981>>>>>>>>>>>Define SCI_SETMARGINSENSITIVEN                 For 2246
73981>>>>>>>>>>>Define SCI_GETMARGINSENSITIVEN                 For 2247
73981>>>>>>>>>>>Define SCI_SETMARGINCURSORN                    For 2248
73981>>>>>>>>>>>Define SCI_GETMARGINCURSORN                    For 2249
73981>>>>>>>>>>>Define SCI_SETMARGINBACKN                      For 2250
73981>>>>>>>>>>>Define SCI_GETMARGINBACKN                      For 2251
73981>>>>>>>>>>>Define SCI_SETMARGINS                          For 2252
73981>>>>>>>>>>>Define SCI_GETMARGINS                          For 2253
73981>>>>>>>>>>>Define STYLE_DEFAULT                           For 32
73981>>>>>>>>>>>Define STYLE_LINENUMBER                        For 33
73981>>>>>>>>>>>Define STYLE_BRACELIGHT                        For 34
73981>>>>>>>>>>>Define STYLE_BRACEBAD                          For 35
73981>>>>>>>>>>>Define STYLE_CONTROLCHAR                       For 36
73981>>>>>>>>>>>Define STYLE_INDENTGUIDE                       For 37
73981>>>>>>>>>>>Define STYLE_CALLTIP                           For 38
73981>>>>>>>>>>>Define STYLE_FOLDDISPLAYTEXT                   For 39
73981>>>>>>>>>>>// Hammer Custom
73981>>>>>>>>>>>Define STYLE_AUTOCOMPLETE                      For 40
73981>>>>>>>>>>>// Hammer Custom ends
73981>>>>>>>>>>>Define STYLE_LASTPREDEFINED                    For 40
73981>>>>>>>>>>>Define STYLE_MAX                               For 255
73981>>>>>>>>>>>Define SC_CHARSET_ANSI                         For 0
73981>>>>>>>>>>>Define SC_CHARSET_DEFAULT                      For 1
73981>>>>>>>>>>>Define SC_CHARSET_BALTIC                       For 186
73981>>>>>>>>>>>Define SC_CHARSET_CHINESEBIG5                  For 136
73981>>>>>>>>>>>Define SC_CHARSET_EASTEUROPE                   For 238
73981>>>>>>>>>>>Define SC_CHARSET_GB2312                       For 134
73981>>>>>>>>>>>Define SC_CHARSET_GREEK                        For 161
73981>>>>>>>>>>>Define SC_CHARSET_HANGUL                       For 129
73981>>>>>>>>>>>Define SC_CHARSET_MAC                          For 77
73981>>>>>>>>>>>Define SC_CHARSET_OEM                          For 255
73981>>>>>>>>>>>Define SC_CHARSET_RUSSIAN                      For 204
73981>>>>>>>>>>>Define SC_CHARSET_OEM866                       For 866
73981>>>>>>>>>>>Define SC_CHARSET_CYRILLIC                     For 1251
73981>>>>>>>>>>>Define SC_CHARSET_SHIFTJIS                     For 128
73981>>>>>>>>>>>Define SC_CHARSET_SYMBOL                       For 2
73981>>>>>>>>>>>Define SC_CHARSET_TURKISH                      For 162
73981>>>>>>>>>>>Define SC_CHARSET_JOHAB                        For 130
73981>>>>>>>>>>>Define SC_CHARSET_HEBREW                       For 177
73981>>>>>>>>>>>Define SC_CHARSET_ARABIC                       For 178
73981>>>>>>>>>>>Define SC_CHARSET_VIETNAMESE                   For 163
73981>>>>>>>>>>>Define SC_CHARSET_THAI                         For 222
73981>>>>>>>>>>>Define SC_CHARSET_8859_15                      For 1000
73981>>>>>>>>>>>Define SCI_STYLECLEARALL                       For 2050
73981>>>>>>>>>>>Define SCI_STYLESETFORE                        For 2051
73981>>>>>>>>>>>Define SCI_STYLESETBACK                        For 2052
73981>>>>>>>>>>>Define SCI_STYLESETBOLD                        For 2053
73981>>>>>>>>>>>Define SCI_STYLESETITALIC                      For 2054
73981>>>>>>>>>>>Define SCI_STYLESETSIZE                        For 2055
73981>>>>>>>>>>>Define SCI_STYLESETFONT                        For 2056
73981>>>>>>>>>>>Define SCI_STYLESETEOLFILLED                   For 2057
73981>>>>>>>>>>>Define SCI_STYLERESETDEFAULT                   For 2058
73981>>>>>>>>>>>Define SCI_STYLESETUNDERLINE                   For 2059
73981>>>>>>>>>>>Define SC_CASE_MIXED                           For 0
73981>>>>>>>>>>>Define SC_CASE_UPPER                           For 1
73981>>>>>>>>>>>Define SC_CASE_LOWER                           For 2
73981>>>>>>>>>>>Define SC_CASE_CAMEL                           For 3
73981>>>>>>>>>>>Define SCI_STYLEGETFORE                        For 2481
73981>>>>>>>>>>>Define SCI_STYLEGETBACK                        For 2482
73981>>>>>>>>>>>Define SCI_STYLEGETBOLD                        For 2483
73981>>>>>>>>>>>Define SCI_STYLEGETITALIC                      For 2484
73981>>>>>>>>>>>Define SCI_STYLEGETSIZE                        For 2485
73981>>>>>>>>>>>Define SCI_STYLEGETFONT                        For 2486
73981>>>>>>>>>>>Define SCI_STYLEGETEOLFILLED                   For 2487
73981>>>>>>>>>>>Define SCI_STYLEGETUNDERLINE                   For 2488
73981>>>>>>>>>>>Define SCI_STYLEGETCASE                        For 2489
73981>>>>>>>>>>>Define SCI_STYLEGETCHARACTERSET                For 2490
73981>>>>>>>>>>>Define SCI_STYLEGETVISIBLE                     For 2491
73981>>>>>>>>>>>Define SCI_STYLEGETCHANGEABLE                  For 2492
73981>>>>>>>>>>>Define SCI_STYLEGETHOTSPOT                     For 2493
73981>>>>>>>>>>>Define SCI_STYLESETCASE                        For 2060
73981>>>>>>>>>>>Define SC_FONT_SIZE_MULTIPLIER                 For 100
73981>>>>>>>>>>>Define SCI_STYLESETSIZEFRACTIONAL              For 2061
73981>>>>>>>>>>>Define SCI_STYLEGETSIZEFRACTIONAL              For 2062
73981>>>>>>>>>>>Define SC_WEIGHT_NORMAL                        For 400
73981>>>>>>>>>>>Define SC_WEIGHT_SEMIBOLD                      For 600
73981>>>>>>>>>>>Define SC_WEIGHT_BOLD                          For 700
73981>>>>>>>>>>>Define SCI_STYLESETWEIGHT                      For 2063
73981>>>>>>>>>>>Define SCI_STYLEGETWEIGHT                      For 2064
73981>>>>>>>>>>>Define SCI_STYLESETCHARACTERSET                For 2066
73981>>>>>>>>>>>Define SCI_STYLESETHOTSPOT                     For 2409
73981>>>>>>>>>>>Define SCI_SETSELFORE                          For 2067
73981>>>>>>>>>>>Define SCI_SETSELBACK                          For 2068
73981>>>>>>>>>>>Define SCI_GETSELALPHA                         For 2477
73981>>>>>>>>>>>Define SCI_SETSELALPHA                         For 2478
73981>>>>>>>>>>>Define SCI_GETSELEOLFILLED                     For 2479
73981>>>>>>>>>>>Define SCI_SETSELEOLFILLED                     For 2480
73981>>>>>>>>>>>Define SCI_SETCARETFORE                        For 2069
73981>>>>>>>>>>>Define SCI_ASSIGNCMDKEY                        For 2070
73981>>>>>>>>>>>Define SCI_CLEARCMDKEY                         For 2071
73981>>>>>>>>>>>Define SCI_CLEARALLCMDKEYS                     For 2072
73981>>>>>>>>>>>Define SCI_SETSTYLINGEX                        For 2073
73981>>>>>>>>>>>Define SCI_STYLESETVISIBLE                     For 2074
73981>>>>>>>>>>>Define SCI_GETCARETPERIOD                      For 2075
73981>>>>>>>>>>>Define SCI_SETCARETPERIOD                      For 2076
73981>>>>>>>>>>>Define SCI_SETWORDCHARS                        For 2077
73981>>>>>>>>>>>Define SCI_GETWORDCHARS                        For 2646
73981>>>>>>>>>>>Define SCI_SETCHARACTERCATEGORYOPTIMIZATION    For 2720
73981>>>>>>>>>>>Define SCI_GETCHARACTERCATEGORYOPTIMIZATION    For 2721
73981>>>>>>>>>>>Define SCI_BEGINUNDOACTION                     For 2078
73981>>>>>>>>>>>Define SCI_ENDUNDOACTION                       For 2079
73981>>>>>>>>>>>Define INDIC_PLAIN                             For 0
73981>>>>>>>>>>>Define INDIC_SQUIGGLE                          For 1
73981>>>>>>>>>>>Define INDIC_TT                                For 2
73981>>>>>>>>>>>Define INDIC_DIAGONAL                          For 3
73981>>>>>>>>>>>Define INDIC_STRIKE                            For 4
73981>>>>>>>>>>>Define INDIC_HIDDEN                            For 5
73981>>>>>>>>>>>Define INDIC_BOX                               For 6
73981>>>>>>>>>>>Define INDIC_ROUNDBOX                          For 7
73981>>>>>>>>>>>Define INDIC_STRAIGHTBOX                       For 8
73981>>>>>>>>>>>Define INDIC_DASH                              For 9
73981>>>>>>>>>>>Define INDIC_DOTS                              For 10
73981>>>>>>>>>>>Define INDIC_SQUIGGLELOW                       For 11
73981>>>>>>>>>>>Define INDIC_DOTBOX                            For 12
73981>>>>>>>>>>>Define INDIC_SQUIGGLEPIXMAP                    For 13
73981>>>>>>>>>>>Define INDIC_COMPOSITIONTHICK                  For 14
73981>>>>>>>>>>>Define INDIC_COMPOSITIONTHIN                   For 15
73981>>>>>>>>>>>Define INDIC_FULLBOX                           For 16
73981>>>>>>>>>>>Define INDIC_TEXTFORE                          For 17
73981>>>>>>>>>>>Define INDIC_POINT                             For 18
73981>>>>>>>>>>>Define INDIC_POINTCHARACTER                    For 19
73981>>>>>>>>>>>Define INDIC_GRADIENT                          For 20
73981>>>>>>>>>>>Define INDIC_GRADIENTCENTRE                    For 21
73981>>>>>>>>>>>Define INDIC_IME                               For 32
73981>>>>>>>>>>>Define INDIC_IME_MAX                           For 35
73981>>>>>>>>>>>Define INDIC_MAX                               For 35
73981>>>>>>>>>>>Define INDIC_CONTAINER                         For 8
73981>>>>>>>>>>>Define INDIC0_MASK                             For |CI$20  // 0x20
73981>>>>>>>>>>>Define INDIC1_MASK                             For |CI$40  // 0x40
73981>>>>>>>>>>>Define INDIC2_MASK                             For |CI$80  // 0x80
73981>>>>>>>>>>>Define INDICS_MASK                             For |CI$E0  // 0xE0
73981>>>>>>>>>>>Define SCI_INDICSETSTYLE                       For 2080
73981>>>>>>>>>>>Define SCI_INDICGETSTYLE                       For 2081
73981>>>>>>>>>>>Define SCI_INDICSETFORE                        For 2082
73981>>>>>>>>>>>Define SCI_INDICGETFORE                        For 2083
73981>>>>>>>>>>>Define SCI_INDICSETUNDER                       For 2510
73981>>>>>>>>>>>Define SCI_INDICGETUNDER                       For 2511
73981>>>>>>>>>>>Define SCI_INDICSETHOVERSTYLE                  For 2680
73981>>>>>>>>>>>Define SCI_INDICGETHOVERSTYLE                  For 2681
73981>>>>>>>>>>>Define SCI_INDICSETHOVERFORE                   For 2682
73981>>>>>>>>>>>Define SCI_INDICGETHOVERFORE                   For 2683
73981>>>>>>>>>>>Define SC_INDICVALUEBIT                        For |CI$1000000  // 0x1000000
73981>>>>>>>>>>>Define SC_INDICVALUEMASK                       For |CI$FFFFFF   // 0xFFFFFF
73981>>>>>>>>>>>Define SC_INDICFLAG_VALUEFORE                  For 1
73981>>>>>>>>>>>Define SCI_INDICSETFLAGS                       For 2684
73981>>>>>>>>>>>Define SCI_INDICGETFLAGS                       For 2685
73981>>>>>>>>>>>Define SCI_SETWHITESPACEFORE                   For 2084
73981>>>>>>>>>>>Define SCI_SETWHITESPACEBACK                   For 2085
73981>>>>>>>>>>>Define SCI_SETWHITESPACESIZE                   For 2086
73981>>>>>>>>>>>Define SCI_GETWHITESPACESIZE                   For 2087
73981>>>>>>>>>>>Define SCI_SETLINESTATE                        For 2092
73981>>>>>>>>>>>Define SCI_GETLINESTATE                        For 2093
73981>>>>>>>>>>>Define SCI_GETMAXLINESTATE                     For 2094
73981>>>>>>>>>>>Define SCI_GETCARETLINEVISIBLE                 For 2095
73981>>>>>>>>>>>Define SCI_SETCARETLINEVISIBLE                 For 2096
73981>>>>>>>>>>>Define SCI_GETCARETLINEBACK                    For 2097
73981>>>>>>>>>>>Define SCI_SETCARETLINEBACK                    For 2098
73981>>>>>>>>>>>Define SCI_GETCARETLINEFRAME                   For 2704
73981>>>>>>>>>>>Define SCI_SETCARETLINEFRAME                   For 2705
73981>>>>>>>>>>>Define SCI_STYLESETCHANGEABLE                  For 2099
73981>>>>>>>>>>>Define SCI_AUTOCSHOW                           For 2100
73981>>>>>>>>>>>Define SCI_AUTOCCANCEL                         For 2101
73981>>>>>>>>>>>Define SCI_AUTOCACTIVE                         For 2102
73981>>>>>>>>>>>Define SCI_AUTOCPOSSTART                       For 2103
73981>>>>>>>>>>>Define SCI_AUTOCCOMPLETE                       For 2104
73981>>>>>>>>>>>Define SCI_AUTOCSTOPS                          For 2105
73981>>>>>>>>>>>Define SCI_AUTOCSETSEPARATOR                   For 2106
73981>>>>>>>>>>>Define SCI_AUTOCGETSEPARATOR                   For 2107
73981>>>>>>>>>>>Define SCI_AUTOCSELECT                         For 2108
73981>>>>>>>>>>>Define SCI_AUTOCSETCANCELATSTART               For 2110
73981>>>>>>>>>>>Define SCI_AUTOCGETCANCELATSTART               For 2111
73981>>>>>>>>>>>Define SCI_AUTOCSETFILLUPS                     For 2112
73981>>>>>>>>>>>Define SCI_AUTOCSETCHOOSESINGLE                For 2113
73981>>>>>>>>>>>Define SCI_AUTOCGETCHOOSESINGLE                For 2114
73981>>>>>>>>>>>Define SCI_AUTOCSETIGNORECASE                  For 2115
73981>>>>>>>>>>>Define SCI_AUTOCGETIGNORECASE                  For 2116
73981>>>>>>>>>>>Define SCI_USERLISTSHOW                        For 2117
73981>>>>>>>>>>>Define SCI_AUTOCSETAUTOHIDE                    For 2118
73981>>>>>>>>>>>Define SCI_AUTOCGETAUTOHIDE                    For 2119
73981>>>>>>>>>>>// Hammer Custom
73981>>>>>>>>>>>Define SCI_AUTOCUSESTYLE                       For 2120
73981>>>>>>>>>>>// Hammer Custom Ends
73981>>>>>>>>>>>Define SCI_AUTOCSETDROPRESTOFWORD              For 2270
73981>>>>>>>>>>>Define SCI_AUTOCGETDROPRESTOFWORD              For 2271
73981>>>>>>>>>>>Define SCI_REGISTERIMAGE                       For 2405
73981>>>>>>>>>>>Define SCI_CLEARREGISTEREDIMAGES               For 2408
73981>>>>>>>>>>>Define SCI_AUTOCGETTYPESEPARATOR               For 2285
73981>>>>>>>>>>>Define SCI_AUTOCSETTYPESEPARATOR               For 2286
73981>>>>>>>>>>>Define SCI_AUTOCSETMAXWIDTH                    For 2208
73981>>>>>>>>>>>Define SCI_AUTOCGETMAXWIDTH                    For 2209
73981>>>>>>>>>>>Define SCI_AUTOCSETMAXHEIGHT                   For 2210
73981>>>>>>>>>>>Define SCI_AUTOCGETMAXHEIGHT                   For 2211
73981>>>>>>>>>>>Define SCI_SETINDENT                           For 2122
73981>>>>>>>>>>>Define SCI_GETINDENT                           For 2123
73981>>>>>>>>>>>Define SCI_SETUSETABS                          For 2124
73981>>>>>>>>>>>Define SCI_GETUSETABS                          For 2125
73981>>>>>>>>>>>Define SCI_SETLINEINDENTATION                  For 2126
73981>>>>>>>>>>>Define SCI_GETLINEINDENTATION                  For 2127
73981>>>>>>>>>>>Define SCI_GETLINEINDENTPOSITION               For 2128
73981>>>>>>>>>>>Define SCI_GETCOLUMN                           For 2129
73981>>>>>>>>>>>Define SCI_COUNTCHARACTERS                     For 2633
73981>>>>>>>>>>>Define SCI_COUNTCODEUNITS                      For 2715
73981>>>>>>>>>>>Define SCI_SETHSCROLLBAR                       For 2130
73981>>>>>>>>>>>Define SCI_GETHSCROLLBAR                       For 2131
73981>>>>>>>>>>>Define SC_IV_NONE                              For 0
73981>>>>>>>>>>>Define SC_IV_REAL                              For 1
73981>>>>>>>>>>>Define SC_IV_LOOKFORWARD                       For 2
73981>>>>>>>>>>>Define SC_IV_LOOKBOTH                          For 3
73981>>>>>>>>>>>Define SCI_SETINDENTATIONGUIDES                For 2132
73981>>>>>>>>>>>Define SCI_GETINDENTATIONGUIDES                For 2133
73981>>>>>>>>>>>Define SCI_SETHIGHLIGHTGUIDE                   For 2134
73981>>>>>>>>>>>Define SCI_GETHIGHLIGHTGUIDE                   For 2135
73981>>>>>>>>>>>Define SCI_GETLINEENDPOSITION                  For 2136
73981>>>>>>>>>>>Define SCI_GETCODEPAGE                         For 2137
73981>>>>>>>>>>>Define SCI_GETCARETFORE                        For 2138
73981>>>>>>>>>>>Define SCI_GETREADONLY                         For 2140
73981>>>>>>>>>>>Define SCI_SETCURRENTPOS                       For 2141
73981>>>>>>>>>>>Define SCI_SETSELECTIONSTART                   For 2142
73981>>>>>>>>>>>Define SCI_GETSELECTIONSTART                   For 2143
73981>>>>>>>>>>>Define SCI_SETSELECTIONEND                     For 2144
73981>>>>>>>>>>>Define SCI_GETSELECTIONEND                     For 2145
73981>>>>>>>>>>>Define SCI_SETEMPTYSELECTION                   For 2556
73981>>>>>>>>>>>Define SCI_SETPRINTMAGNIFICATION               For 2146
73981>>>>>>>>>>>Define SCI_GETPRINTMAGNIFICATION               For 2147
73981>>>>>>>>>>>Define SC_PRINT_NORMAL                         For 0
73981>>>>>>>>>>>Define SC_PRINT_INVERTLIGHT                    For 1
73981>>>>>>>>>>>Define SC_PRINT_BLACKONWHITE                   For 2
73981>>>>>>>>>>>Define SC_PRINT_COLOURONWHITE                  For 3
73981>>>>>>>>>>>Define SC_PRINT_COLOURONWHITEDEFAULTBG         For 4
73981>>>>>>>>>>>Define SC_PRINT_SCREENCOLOURS                  For 5
73981>>>>>>>>>>>Define SCI_SETPRINTCOLOURMODE                  For 2148
73981>>>>>>>>>>>Define SCI_GETPRINTCOLOURMODE                  For 2149
73981>>>>>>>>>>>Define SCFIND_WHOLEWORD                        For |CI$02    // 0x2
73981>>>>>>>>>>>Define SCFIND_MATCHCASE                        For |CI$04    // 0x4
73981>>>>>>>>>>>Define SCFIND_WORDSTART                        For |CI$00100000 // 0x00100000
73981>>>>>>>>>>>Define SCFIND_REGEXP                           For |CI$00200000 // 0x00200000
73981>>>>>>>>>>>Define SCFIND_POSIX                            For |CI$00400000 // 0x00400000
73981>>>>>>>>>>>Define SCFIND_CXX11REGEX                       For |CI$00800000 // 0x00800000
73981>>>>>>>>>>>Define SCI_FINDTEXT                            For 2150
73981>>>>>>>>>>>Define SCI_FORMATRANGE                         For 2151
73981>>>>>>>>>>>Define SCI_GETFIRSTVISIBLELINE                 For 2152
73981>>>>>>>>>>>Define SCI_GETLINE                             For 2153
73981>>>>>>>>>>>Define SCI_GETLINECOUNT                        For 2154
73981>>>>>>>>>>>Define SCI_SETMARGINLEFT                       For 2155
73981>>>>>>>>>>>Define SCI_GETMARGINLEFT                       For 2156
73981>>>>>>>>>>>Define SCI_SETMARGINRIGHT                      For 2157
73981>>>>>>>>>>>Define SCI_GETMARGINRIGHT                      For 2158
73981>>>>>>>>>>>Define SCI_GETMODIFY                           For 2159
73981>>>>>>>>>>>Define SCI_SETSEL                              For 2160
73981>>>>>>>>>>>Define SCI_GETSELTEXT                          For 2161
73981>>>>>>>>>>>Define SCI_GETTEXTRANGE                        For 2162
73981>>>>>>>>>>>Define SCI_HIDESELECTION                       For 2163
73981>>>>>>>>>>>Define SCI_POINTXFROMPOSITION                  For 2164
73981>>>>>>>>>>>Define SCI_POINTYFROMPOSITION                  For 2165
73981>>>>>>>>>>>Define SCI_LINEFROMPOSITION                    For 2166
73981>>>>>>>>>>>Define SCI_POSITIONFROMLINE                    For 2167
73981>>>>>>>>>>>Define SCI_LINESCROLL                          For 2168
73981>>>>>>>>>>>Define SCI_SCROLLCARET                         For 2169
73981>>>>>>>>>>>Define SCI_SCROLLRANGE                         For 2569
73981>>>>>>>>>>>Define SCI_REPLACESEL                          For 2170
73981>>>>>>>>>>>Define SCI_SETREADONLY                         For 2171
73981>>>>>>>>>>>Define SCI_NULL                                For 2172
73981>>>>>>>>>>>Define SCI_CANPASTE                            For 2173
73981>>>>>>>>>>>Define SCI_CANUNDO                             For 2174
73981>>>>>>>>>>>Define SCI_EMPTYUNDOBUFFER                     For 2175
73981>>>>>>>>>>>Define SCI_UNDO                                For 2176
73981>>>>>>>>>>>Define SCI_CUT                                 For 2177
73981>>>>>>>>>>>Define SCI_COPY                                For 2178
73981>>>>>>>>>>>Define SCI_PASTE                               For 2179
73981>>>>>>>>>>>Define SCI_CLEAR                               For 2180
73981>>>>>>>>>>>Define SCI_SETTEXT                             For 2181
73981>>>>>>>>>>>Define SCI_GETTEXT                             For 2182
73981>>>>>>>>>>>Define SCI_GETTEXTLENGTH                       For 2183
73981>>>>>>>>>>>Define SCI_GETDIRECTFUNCTION                   For 2184
73981>>>>>>>>>>>Define SCI_GETDIRECTPOINTER                    For 2185
73981>>>>>>>>>>>Define SCI_SETOVERTYPE                         For 2186
73981>>>>>>>>>>>Define SCI_GETOVERTYPE                         For 2187
73981>>>>>>>>>>>Define SCI_SETCARETWIDTH                       For 2188
73981>>>>>>>>>>>Define SCI_GETCARETWIDTH                       For 2189
73981>>>>>>>>>>>Define SCI_SETTARGETSTART                      For 2190
73981>>>>>>>>>>>Define SCI_GETTARGETSTART                      For 2191
73981>>>>>>>>>>>Define SCI_SETTARGETEND                        For 2192
73981>>>>>>>>>>>Define SCI_GETTARGETEND                        For 2193
73981>>>>>>>>>>>Define SCI_SETTARGETRANGE                      For 2686
73981>>>>>>>>>>>Define SCI_GETTARGETTEXT                       For 2687
73981>>>>>>>>>>>Define SCI_TARGETFROMSELECTION                 For 2287
73981>>>>>>>>>>>Define SCI_TARGETWHOLEDOCUMENT                 For 2690
73981>>>>>>>>>>>Define SCI_REPLACETARGET                       For 2194
73981>>>>>>>>>>>Define SCI_REPLACETARGETRE                     For 2195
73981>>>>>>>>>>>Define SCI_SEARCHINTARGET                      For 2197
73981>>>>>>>>>>>Define SCI_SETSEARCHFLAGS                      For 2198
73981>>>>>>>>>>>Define SCI_GETSEARCHFLAGS                      For 2199
73981>>>>>>>>>>>Define SCI_CALLTIPSHOW                         For 2200
73981>>>>>>>>>>>Define SCI_CALLTIPCANCEL                       For 2201
73981>>>>>>>>>>>Define SCI_CALLTIPACTIVE                       For 2202
73981>>>>>>>>>>>Define SCI_CALLTIPPOSSTART                     For 2203
73981>>>>>>>>>>>Define SCI_CALLTIPSETPOSSTART                  For 2214
73981>>>>>>>>>>>Define SCI_CALLTIPSETHLT                       For 2204
73981>>>>>>>>>>>Define SCI_CALLTIPSETBACK                      For 2205
73981>>>>>>>>>>>Define SCI_CALLTIPSETFORE                      For 2206
73981>>>>>>>>>>>Define SCI_CALLTIPSETFOREHLT                   For 2207
73981>>>>>>>>>>>Define SCI_CALLTIPUSESTYLE                     For 2212
73981>>>>>>>>>>>Define SCI_CALLTIPSETPOSITION                  For 2213
73981>>>>>>>>>>>Define SCI_VISIBLEFROMDOCLINE                  For 2220
73981>>>>>>>>>>>Define SCI_DOCLINEFROMVISIBLE                  For 2221
73981>>>>>>>>>>>Define SCI_WRAPCOUNT                           For 2235
73981>>>>>>>>>>>Define SC_FOLDLEVELBASE                        For |CI$000400  // $0x400
73981>>>>>>>>>>>Define SC_FOLDLEVELWHITEFLAG                   For |CI$001000  // $0x1000
73981>>>>>>>>>>>Define SC_FOLDLEVELHEADERFLAG                  For |CI$002000  // $0x2000
73981>>>>>>>>>>>Define SC_FOLDLEVELNUMBERMASK                  For |CI$000FFF  // $0x0FFF
73981>>>>>>>>>>>Define SCI_SETFOLDLEVEL                        For 2222
73981>>>>>>>>>>>Define SCI_GETFOLDLEVEL                        For 2223
73981>>>>>>>>>>>Define SCI_GETLASTCHILD                        For 2224
73981>>>>>>>>>>>Define SCI_GETFOLDPARENT                       For 2225
73981>>>>>>>>>>>Define SCI_SHOWLINES                           For 2226
73981>>>>>>>>>>>Define SCI_HIDELINES                           For 2227
73981>>>>>>>>>>>Define SCI_GETLINEVISIBLE                      For 2228
73981>>>>>>>>>>>Define SCI_GETALLLINESVISIBLE                  For 2236
73981>>>>>>>>>>>Define SCI_SETFOLDEXPANDED                     For 2229
73981>>>>>>>>>>>Define SCI_GETFOLDEXPANDED                     For 2230
73981>>>>>>>>>>>Define SCI_TOGGLEFOLD                          For 2231
73981>>>>>>>>>>>Define SCI_TOGGLEFOLDSHOWTEXT                  For 2700
73981>>>>>>>>>>>Define SC_FOLDDISPLAYTEXT_HIDDEN               For 0
73981>>>>>>>>>>>Define SC_FOLDDISPLAYTEXT_STANDARD             For 1
73981>>>>>>>>>>>Define SC_FOLDDISPLAYTEXT_BOXED                For 2
73981>>>>>>>>>>>Define SCI_FOLDDISPLAYTEXTSETSTYLE             For 2701
73981>>>>>>>>>>>Define SCI_FOLDDISPLAYTEXTGETSTYLE             For 2707
73981>>>>>>>>>>>Define SCI_SETDEFAULTFOLDDISPLAYTEXT           For 2722
73981>>>>>>>>>>>Define SCI_GETDEFAULTFOLDDISPLAYTEXT           For 2723
73981>>>>>>>>>>>Define SC_FOLDACTION_CONTRACT                  For 0
73981>>>>>>>>>>>Define SC_FOLDACTION_EXPAND                    For 1
73981>>>>>>>>>>>Define SC_FOLDACTION_TOGGLE                    For 2
73981>>>>>>>>>>>Define SCI_FOLDLINE                            For 2237
73981>>>>>>>>>>>Define SCI_FOLDCHILDREN                        For 2238
73981>>>>>>>>>>>Define SCI_EXPANDCHILDREN                      For 2239
73981>>>>>>>>>>>Define SCI_FOLDALL                             For 2662
73981>>>>>>>>>>>Define SCI_ENSUREVISIBLE                       For 2232
73981>>>>>>>>>>>Define SC_AUTOMATICFOLD_SHOW                   For |CI$0001  // $0x0001
73981>>>>>>>>>>>Define SC_AUTOMATICFOLD_CLICK                  For |CI$0002  // $0x0002
73981>>>>>>>>>>>Define SC_AUTOMATICFOLD_CHANGE                 For |CI$0004  // $0x0004
73981>>>>>>>>>>>Define SCI_SETAUTOMATICFOLD                    For 2663
73981>>>>>>>>>>>Define SCI_GETAUTOMATICFOLD                    For 2664
73981>>>>>>>>>>>Define SC_FOLDFLAG_LINEBEFORE_EXPANDED         For |CI$0002  // $0x0002
73981>>>>>>>>>>>Define SC_FOLDFLAG_LINEBEFORE_CONTRACTED       For |CI$0004 // $0x0004
73981>>>>>>>>>>>Define SC_FOLDFLAG_LINEAFTER_EXPANDED          For |CI$0008  // $0x0008
73981>>>>>>>>>>>Define SC_FOLDFLAG_LINEAFTER_CONTRACTED        For |CI$0010  // $0x0010
73981>>>>>>>>>>>Define SC_FOLDFLAG_LEVELNUMBERS                For |CI$0040  // $0x0040
73981>>>>>>>>>>>Define SC_FOLDFLAG_LINESTATE                   For |CI$0080  // $0x0080
73981>>>>>>>>>>>Define SCI_SETFOLDFLAGS                        For 2233
73981>>>>>>>>>>>Define SCI_ENSUREVISIBLEENFORCEPOLICY          For 2234
73981>>>>>>>>>>>Define SCI_SETTABINDENTS                       For 2260
73981>>>>>>>>>>>Define SCI_GETTABINDENTS                       For 2261
73981>>>>>>>>>>>Define SCI_SETBACKSPACEUNINDENTS               For 2262
73981>>>>>>>>>>>Define SCI_GETBACKSPACEUNINDENTS               For 2263
73981>>>>>>>>>>>Define SC_TIME_FOREVER                         For 10000000
73981>>>>>>>>>>>Define SCI_SETMOUSEDWELLTIME                   For 2264
73981>>>>>>>>>>>Define SCI_GETMOUSEDWELLTIME                   For 2265
73981>>>>>>>>>>>Define SCI_WORDSTARTPOSITION                   For 2266
73981>>>>>>>>>>>Define SCI_WORDENDPOSITION                     For 2267
73981>>>>>>>>>>>Define SCI_ISRANGEWORD                         For 2691
73981>>>>>>>>>>>Define SC_IDLESTYLING_NONE                     For 0
73981>>>>>>>>>>>Define SC_IDLESTYLING_TOVISIBLE                For 1
73981>>>>>>>>>>>Define SC_IDLESTYLING_AFTERVISIBLE             For 2
73981>>>>>>>>>>>Define SC_IDLESTYLING_ALL                      For 3
73981>>>>>>>>>>>Define SCI_SETIDLESTYLING                      For 2692
73981>>>>>>>>>>>Define SCI_GETIDLESTYLING                      For 2693
73981>>>>>>>>>>>Define SC_WRAP_NONE                            For 0
73981>>>>>>>>>>>Define SC_WRAP_WORD                            For 1
73981>>>>>>>>>>>Define SC_WRAP_CHAR                            For 2
73981>>>>>>>>>>>Define SC_WRAP_WHITESPACE                      For 3
73981>>>>>>>>>>>Define SCI_SETWRAPMODE                         For 2268
73981>>>>>>>>>>>Define SCI_GETWRAPMODE                         For 2269
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAG_NONE                  For |CI$0000  // $0x0000
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAG_END                   For |CI$0001  // $0x0001
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAG_START                 For |CI$0002  // $0x0002
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAG_MARGIN                For |CI$0004  // $0x0004
73981>>>>>>>>>>>Define SCI_SETWRAPVISUALFLAGS                  For 2460
73981>>>>>>>>>>>Define SCI_GETWRAPVISUALFLAGS                  For 2461
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAGLOC_DEFAULT            For |CI$0000  // $0x0000
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAGLOC_END_BY_TEXT        For |CI$0001  // $0x0001
73981>>>>>>>>>>>Define SC_WRAPVISUALFLAGLOC_START_BY_TEXT      For |CI$0002  // $0x0002
73981>>>>>>>>>>>Define SCI_SETWRAPVISUALFLAGSLOCATION          For 2462
73981>>>>>>>>>>>Define SCI_GETWRAPVISUALFLAGSLOCATION          For 2463
73981>>>>>>>>>>>Define SCI_SETWRAPSTARTINDENT                  For 2464
73981>>>>>>>>>>>Define SCI_GETWRAPSTARTINDENT                  For 2465
73981>>>>>>>>>>>Define SC_WRAPINDENT_FIXED                     For 0
73981>>>>>>>>>>>Define SC_WRAPINDENT_SAME                      For 1
73981>>>>>>>>>>>Define SC_WRAPINDENT_INDENT                    For 2
73981>>>>>>>>>>>Define SC_WRAPINDENT_DEEPINDENT                For 3
73981>>>>>>>>>>>Define SCI_SETWRAPINDENTMODE                   For 2472
73981>>>>>>>>>>>Define SCI_GETWRAPINDENTMODE                   For 2473
73981>>>>>>>>>>>Define SC_CACHE_NONE                           For 0
73981>>>>>>>>>>>Define SC_CACHE_CARET                          For 1
73981>>>>>>>>>>>Define SC_CACHE_PAGE                           For 2
73981>>>>>>>>>>>Define SC_CACHE_DOCUMENT                       For 3
73981>>>>>>>>>>>Define SCI_SETLAYOUTCACHE                      For 2272
73981>>>>>>>>>>>Define SCI_GETLAYOUTCACHE                      For 2273
73981>>>>>>>>>>>Define SCI_SETSCROLLWIDTH                      For 2274
73981>>>>>>>>>>>Define SCI_GETSCROLLWIDTH                      For 2275
73981>>>>>>>>>>>Define SCI_SETSCROLLWIDTHTRACKING              For 2516
73981>>>>>>>>>>>Define SCI_GETSCROLLWIDTHTRACKING              For 2517
73981>>>>>>>>>>>Define SCI_TEXTWIDTH                           For 2276
73981>>>>>>>>>>>Define SCI_SETENDATLASTLINE                    For 2277
73981>>>>>>>>>>>Define SCI_GETENDATLASTLINE                    For 2278
73981>>>>>>>>>>>Define SCI_TEXTHEIGHT                          For 2279
73981>>>>>>>>>>>Define SCI_SETVSCROLLBAR                       For 2280
73981>>>>>>>>>>>Define SCI_GETVSCROLLBAR                       For 2281
73981>>>>>>>>>>>Define SCI_APPENDTEXT                          For 2282
73981>>>>>>>>>>>Define SC_PHASES_ONE                           For 0
73981>>>>>>>>>>>Define SC_PHASES_TWO                           For 1
73981>>>>>>>>>>>Define SC_PHASES_MULTIPLE                      For 2
73981>>>>>>>>>>>Define SCI_GETPHASESDRAW                       For 2673
73981>>>>>>>>>>>Define SCI_SETPHASESDRAW                       For 2674
73981>>>>>>>>>>>Define SC_EFF_QUALITY_MASK                     For |CI$0F  // $0xF
73981>>>>>>>>>>>Define SC_EFF_QUALITY_DEFAULT                  For 0
73981>>>>>>>>>>>Define SC_EFF_QUALITY_NON_ANTIALIASED          For 1
73981>>>>>>>>>>>Define SC_EFF_QUALITY_ANTIALIASED              For 2
73981>>>>>>>>>>>Define SC_EFF_QUALITY_LCD_OPTIMIZED            For 3
73981>>>>>>>>>>>Define SCI_SETFONTQUALITY                      For 2611
73981>>>>>>>>>>>Define SCI_GETFONTQUALITY                      For 2612
73981>>>>>>>>>>>Define SCI_SETFIRSTVISIBLELINE                 For 2613
73981>>>>>>>>>>>Define SC_MULTIPASTE_ONCE                      For 0
73981>>>>>>>>>>>Define SC_MULTIPASTE_EACH                      For 1
73981>>>>>>>>>>>Define SCI_SETMULTIPASTE                       For 2614
73981>>>>>>>>>>>Define SCI_GETMULTIPASTE                       For 2615
73981>>>>>>>>>>>Define SCI_GETTAG                              For 2616
73981>>>>>>>>>>>Define SCI_LINESJOIN                           For 2288
73981>>>>>>>>>>>Define SCI_LINESSPLIT                          For 2289
73981>>>>>>>>>>>Define SCI_SETFOLDMARGINCOLOUR                 For 2290
73981>>>>>>>>>>>Define SCI_SETFOLDMARGINHICOLOUR               For 2291
73981>>>>>>>>>>>Define SC_ACCESSIBILITY_DISABLED               For 0
73981>>>>>>>>>>>Define SC_ACCESSIBILITY_ENABLED                For 1
73981>>>>>>>>>>>Define SCI_SETACCESSIBILITY                    For 2702
73981>>>>>>>>>>>Define SCI_GETACCESSIBILITY                    For 2703
73981>>>>>>>>>>>Define SCI_LINEDOWN                            For 2300
73981>>>>>>>>>>>Define SCI_LINEDOWNEXTEND                      For 2301
73981>>>>>>>>>>>Define SCI_LINEUP                              For 2302
73981>>>>>>>>>>>Define SCI_LINEUPEXTEND                        For 2303
73981>>>>>>>>>>>Define SCI_CHARLEFT                            For 2304
73981>>>>>>>>>>>Define SCI_CHARLEFTEXTEND                      For 2305
73981>>>>>>>>>>>Define SCI_CHARRIGHT                           For 2306
73981>>>>>>>>>>>Define SCI_CHARRIGHTEXTEND                     For 2307
73981>>>>>>>>>>>Define SCI_WORDLEFT                            For 2308
73981>>>>>>>>>>>Define SCI_WORDLEFTEXTEND                      For 2309
73981>>>>>>>>>>>Define SCI_WORDRIGHT                           For 2310
73981>>>>>>>>>>>Define SCI_WORDRIGHTEXTEND                     For 2311
73981>>>>>>>>>>>Define SCI_HOME                                For 2312
73981>>>>>>>>>>>Define SCI_HOMEEXTEND                          For 2313
73981>>>>>>>>>>>Define SCI_LINEEND                             For 2314
73981>>>>>>>>>>>Define SCI_LINEENDEXTEND                       For 2315
73981>>>>>>>>>>>Define SCI_DOCUMENTSTART                       For 2316
73981>>>>>>>>>>>Define SCI_DOCUMENTSTARTEXTEND                 For 2317
73981>>>>>>>>>>>Define SCI_DOCUMENTEND                         For 2318
73981>>>>>>>>>>>Define SCI_DOCUMENTENDEXTEND                   For 2319
73981>>>>>>>>>>>Define SCI_PAGEUP                              For 2320
73981>>>>>>>>>>>Define SCI_PAGEUPEXTEND                        For 2321
73981>>>>>>>>>>>Define SCI_PAGEDOWN                            For 2322
73981>>>>>>>>>>>Define SCI_PAGEDOWNEXTEND                      For 2323
73981>>>>>>>>>>>Define SCI_EDITTOGGLEOVERTYPE                  For 2324
73981>>>>>>>>>>>Define SCI_CANCEL                              For 2325
73981>>>>>>>>>>>Define SCI_DELETEBACK                          For 2326
73981>>>>>>>>>>>Define SCI_TAB                                 For 2327
73981>>>>>>>>>>>Define SCI_BACKTAB                             For 2328
73981>>>>>>>>>>>Define SCI_NEWLINE                             For 2329
73981>>>>>>>>>>>Define SCI_FORMFEED                            For 2330
73981>>>>>>>>>>>Define SCI_VCHOME                              For 2331
73981>>>>>>>>>>>Define SCI_VCHOMEEXTEND                        For 2332
73981>>>>>>>>>>>Define SCI_ZOOMIN                              For 2333
73981>>>>>>>>>>>Define SCI_ZOOMOUT                             For 2334
73981>>>>>>>>>>>Define SCI_DELWORDLEFT                         For 2335
73981>>>>>>>>>>>Define SCI_DELWORDRIGHT                        For 2336
73981>>>>>>>>>>>Define SCI_DELWORDRIGHTEND                     For 2518
73981>>>>>>>>>>>Define SCI_LINECUT                             For 2337
73981>>>>>>>>>>>Define SCI_LINEDELETE                          For 2338
73981>>>>>>>>>>>Define SCI_LINETRANSPOSE                       For 2339
73981>>>>>>>>>>>Define SCI_LINEREVERSE                         For 2354
73981>>>>>>>>>>>Define SCI_LINEDUPLICATE                       For 2404
73981>>>>>>>>>>>Define SCI_LOWERCASE                           For 2340
73981>>>>>>>>>>>Define SCI_UPPERCASE                           For 2341
73981>>>>>>>>>>>Define SCI_LINESCROLLDOWN                      For 2342
73981>>>>>>>>>>>Define SCI_LINESCROLLUP                        For 2343
73981>>>>>>>>>>>Define SCI_DELETEBACKNOTLINE                   For 2344
73981>>>>>>>>>>>Define SCI_HOMEDISPLAY                         For 2345
73981>>>>>>>>>>>Define SCI_HOMEDISPLAYEXTEND                   For 2346
73981>>>>>>>>>>>Define SCI_LINEENDDISPLAY                      For 2347
73981>>>>>>>>>>>Define SCI_LINEENDDISPLAYEXTEND                For 2348
73981>>>>>>>>>>>Define SCI_HOMEWRAP                            For 2349
73981>>>>>>>>>>>Define SCI_HOMEWRAPEXTEND                      For 2450
73981>>>>>>>>>>>Define SCI_LINEENDWRAP                         For 2451
73981>>>>>>>>>>>Define SCI_LINEENDWRAPEXTEND                   For 2452
73981>>>>>>>>>>>Define SCI_VCHOMEWRAP                          For 2453
73981>>>>>>>>>>>Define SCI_VCHOMEWRAPEXTEND                    For 2454
73981>>>>>>>>>>>Define SCI_LINECOPY                            For 2455
73981>>>>>>>>>>>Define SCI_MOVECARETINSIDEVIEW                 For 2401
73981>>>>>>>>>>>Define SCI_LINELENGTH                          For 2350
73981>>>>>>>>>>>Define SCI_BRACEHIGHLIGHT                      For 2351
73981>>>>>>>>>>>Define SCI_BRACEHIGHLIGHTINDICATOR             For 2498
73981>>>>>>>>>>>Define SCI_BRACEBADLIGHT                       For 2352
73981>>>>>>>>>>>Define SCI_BRACEBADLIGHTINDICATOR              For 2499
73981>>>>>>>>>>>Define SCI_BRACEMATCH                          For 2353
73981>>>>>>>>>>>Define SCI_GETVIEWEOL                          For 2355
73981>>>>>>>>>>>Define SCI_SETVIEWEOL                          For 2356
73981>>>>>>>>>>>Define SCI_GETDOCPOINTER                       For 2357
73981>>>>>>>>>>>Define SCI_SETDOCPOINTER                       For 2358
73981>>>>>>>>>>>Define SCI_SETMODEVENTMASK                     For 2359
73981>>>>>>>>>>>Define EDGE_NONE                               For 0
73981>>>>>>>>>>>Define EDGE_LINE                               For 1
73981>>>>>>>>>>>Define EDGE_BACKGROUND                         For 2
73981>>>>>>>>>>>Define EDGE_MULTILINE                          For 3
73981>>>>>>>>>>>Define SCI_GETEDGECOLUMN                       For 2360
73981>>>>>>>>>>>Define SCI_SETEDGECOLUMN                       For 2361
73981>>>>>>>>>>>Define SCI_GETEDGEMODE                         For 2362
73981>>>>>>>>>>>Define SCI_SETEDGEMODE                         For 2363
73981>>>>>>>>>>>Define SCI_GETEDGECOLOUR                       For 2364
73981>>>>>>>>>>>Define SCI_SETEDGECOLOUR                       For 2365
73981>>>>>>>>>>>Define SCI_MULTIEDGEADDLINE                    For 2694
73981>>>>>>>>>>>Define SCI_MULTIEDGECLEARALL                   For 2695
73981>>>>>>>>>>>Define SCI_SEARCHANCHOR                        For 2366
73981>>>>>>>>>>>Define SCI_SEARCHNEXT                          For 2367
73981>>>>>>>>>>>Define SCI_SEARCHPREV                          For 2368
73981>>>>>>>>>>>Define SCI_LINESONSCREEN                       For 2370
73981>>>>>>>>>>>Define SC_POPUP_NEVER                          For 0
73981>>>>>>>>>>>Define SC_POPUP_ALL                            For 1
73981>>>>>>>>>>>Define SC_POPUP_TEXT                           For 2
73981>>>>>>>>>>>Define SCI_USEPOPUP                            For 2371
73981>>>>>>>>>>>Define SCI_SELECTIONISRECTANGLE                For 2372
73981>>>>>>>>>>>Define SCI_SETZOOM                             For 2373
73981>>>>>>>>>>>Define SCI_GETZOOM                             For 2374
73981>>>>>>>>>>>Define SC_DOCUMENTOPTION_DEFAULT               For 0
73981>>>>>>>>>>>Define SC_DOCUMENTOPTION_STYLES_NONE           For |CI$0001  // 0x1
73981>>>>>>>>>>>Define SC_DOCUMENTOPTION_TEXT_LARGE            For |CI$0100  // 0x100
73981>>>>>>>>>>>Define SCI_CREATEDOCUMENT                      For 2375
73981>>>>>>>>>>>Define SCI_ADDREFDOCUMENT                      For 2376
73981>>>>>>>>>>>Define SCI_RELEASEDOCUMENT                     For 2377
73981>>>>>>>>>>>Define SCI_GETDOCUMENTOPTIONS                  For 2379
73981>>>>>>>>>>>Define SCI_GETMODEVENTMASK                     For 2378
73981>>>>>>>>>>>Define SCI_SETCOMMANDEVENTS                    For 2717
73981>>>>>>>>>>>Define SCI_GETCOMMANDEVENTS                    For 2718
73981>>>>>>>>>>>Define SCI_SETFOCUS                            For 2380
73981>>>>>>>>>>>Define SCI_GETFOCUS                            For 2381
73981>>>>>>>>>>>Define SC_STATUS_OK                            For 0
73981>>>>>>>>>>>Define SC_STATUS_FAILURE                       For 1
73981>>>>>>>>>>>Define SC_STATUS_BADALLOC                      For 2
73981>>>>>>>>>>>Define SC_STATUS_WARN_START                    For 1000
73981>>>>>>>>>>>Define SC_STATUS_WARN_REGEX                    For 1001
73981>>>>>>>>>>>Define SCI_SETSTATUS                           For 2382
73981>>>>>>>>>>>Define SCI_GETSTATUS                           For 2383
73981>>>>>>>>>>>Define SCI_SETMOUSEDOWNCAPTURES                For 2384
73981>>>>>>>>>>>Define SCI_GETMOUSEDOWNCAPTURES                For 2385
73981>>>>>>>>>>>Define SCI_SETMOUSEWHEELCAPTURES               For 2696
73981>>>>>>>>>>>Define SCI_GETMOUSEWHEELCAPTURES               For 2697
73981>>>>>>>>>>>Define SC_CURSORNORMAL                         For 1
73981>>>>>>>>>>>Define SC_CURSORARROW                          For 2
73981>>>>>>>>>>>Define SC_CURSORWAIT                           For 4
73981>>>>>>>>>>>Define SC_CURSORREVERSEARROW                   For 7
73981>>>>>>>>>>>Define SCI_SETCURSOR                           For 2386
73981>>>>>>>>>>>Define SCI_GETCURSOR                           For 2387
73981>>>>>>>>>>>Define SCI_SETCONTROLCHARSYMBOL                For 2388
73981>>>>>>>>>>>Define SCI_GETCONTROLCHARSYMBOL                For 2389
73981>>>>>>>>>>>Define SCI_WORDPARTLEFT                        For 2390
73981>>>>>>>>>>>Define SCI_WORDPARTLEFTEXTEND                  For 2391
73981>>>>>>>>>>>Define SCI_WORDPARTRIGHT                       For 2392
73981>>>>>>>>>>>Define SCI_WORDPARTRIGHTEXTEND                 For 2393
73981>>>>>>>>>>>Define VISIBLE_SLOP                            For |CI$01  // $0x01
73981>>>>>>>>>>>Define VISIBLE_STRICT                          For |CI$04  // $0x04
73981>>>>>>>>>>>Define SCI_SETVISIBLEPOLICY                    For 2394
73981>>>>>>>>>>>Define SCI_DELLINELEFT                         For 2395
73981>>>>>>>>>>>Define SCI_DELLINERIGHT                        For 2396
73981>>>>>>>>>>>Define SCI_SETXOFFSET                          For 2397
73981>>>>>>>>>>>Define SCI_GETXOFFSET                          For 2398
73981>>>>>>>>>>>Define SCI_CHOOSECARETX                        For 2399
73981>>>>>>>>>>>Define SCI_GRABFOCUS                           For 2400
73981>>>>>>>>>>>Define CARET_SLOP                              For |CI$01  // $0x01
73981>>>>>>>>>>>Define CARET_STRICT                            For |CI$04  // $0x04
73981>>>>>>>>>>>Define CARET_JUMPS                             For |CI$10  // $0x10
73981>>>>>>>>>>>Define CARET_EVEN                              For |CI$08  // $0x08
73981>>>>>>>>>>>Define SCI_SETXCARETPOLICY                     For 2402
73981>>>>>>>>>>>Define SCI_SETYCARETPOLICY                     For 2403
73981>>>>>>>>>>>Define SCI_SETPRINTWRAPMODE                    For 2406
73981>>>>>>>>>>>Define SCI_GETPRINTWRAPMODE                    For 2407
73981>>>>>>>>>>>Define SCI_SETHOTSPOTACTIVEFORE                For 2410
73981>>>>>>>>>>>Define SCI_GETHOTSPOTACTIVEFORE                For 2494
73981>>>>>>>>>>>Define SCI_SETHOTSPOTACTIVEBACK                For 2411
73981>>>>>>>>>>>Define SCI_GETHOTSPOTACTIVEBACK                For 2495
73981>>>>>>>>>>>Define SCI_SETHOTSPOTACTIVEUNDERLINE           For 2412
73981>>>>>>>>>>>Define SCI_GETHOTSPOTACTIVEUNDERLINE           For 2496
73981>>>>>>>>>>>Define SCI_SETHOTSPOTSINGLELINE                For 2421
73981>>>>>>>>>>>Define SCI_GETHOTSPOTSINGLELINE                For 2497
73981>>>>>>>>>>>Define SCI_PARADOWN                            For 2413
73981>>>>>>>>>>>Define SCI_PARADOWNEXTEND                      For 2414
73981>>>>>>>>>>>Define SCI_PARAUP                              For 2415
73981>>>>>>>>>>>Define SCI_PARAUPEXTEND                        For 2416
73981>>>>>>>>>>>Define SCI_POSITIONBEFORE                      For 2417
73981>>>>>>>>>>>Define SCI_POSITIONAFTER                       For 2418
73981>>>>>>>>>>>Define SCI_POSITIONRELATIVE                    For 2670
73981>>>>>>>>>>>Define SCI_POSITIONRELATIVECODEUNITS           For 2716
73981>>>>>>>>>>>Define SCI_COPYRANGE                           For 2419
73981>>>>>>>>>>>Define SCI_COPYTEXT                            For 2420
73981>>>>>>>>>>>Define SC_SEL_STREAM                           For 0
73981>>>>>>>>>>>Define SC_SEL_RECTANGLE                        For 1
73981>>>>>>>>>>>Define SC_SEL_LINES                            For 2
73981>>>>>>>>>>>Define SC_SEL_THIN                             For 3
73981>>>>>>>>>>>Define SCI_SETSELECTIONMODE                    For 2422
73981>>>>>>>>>>>Define SCI_GETSELECTIONMODE                    For 2423
73981>>>>>>>>>>>Define SCI_GETMOVEEXTENDSSELECTION             For 2706
73981>>>>>>>>>>>Define SCI_GETLINESELSTARTPOSITION             For 2424
73981>>>>>>>>>>>Define SCI_GETLINESELENDPOSITION               For 2425
73981>>>>>>>>>>>Define SCI_LINEDOWNRECTEXTEND                  For 2426
73981>>>>>>>>>>>Define SCI_LINEUPRECTEXTEND                    For 2427
73981>>>>>>>>>>>Define SCI_CHARLEFTRECTEXTEND                  For 2428
73981>>>>>>>>>>>Define SCI_CHARRIGHTRECTEXTEND                 For 2429
73981>>>>>>>>>>>Define SCI_HOMERECTEXTEND                      For 2430
73981>>>>>>>>>>>Define SCI_VCHOMERECTEXTEND                    For 2431
73981>>>>>>>>>>>Define SCI_LINEENDRECTEXTEND                   For 2432
73981>>>>>>>>>>>Define SCI_PAGEUPRECTEXTEND                    For 2433
73981>>>>>>>>>>>Define SCI_PAGEDOWNRECTEXTEND                  For 2434
73981>>>>>>>>>>>Define SCI_STUTTEREDPAGEUP                     For 2435
73981>>>>>>>>>>>Define SCI_STUTTEREDPAGEUPEXTEND               For 2436
73981>>>>>>>>>>>Define SCI_STUTTEREDPAGEDOWN                   For 2437
73981>>>>>>>>>>>Define SCI_STUTTEREDPAGEDOWNEXTEND             For 2438
73981>>>>>>>>>>>Define SCI_WORDLEFTEND                         For 2439
73981>>>>>>>>>>>Define SCI_WORDLEFTENDEXTEND                   For 2440
73981>>>>>>>>>>>Define SCI_WORDRIGHTEND                        For 2441
73981>>>>>>>>>>>Define SCI_WORDRIGHTENDEXTEND                  For 2442
73981>>>>>>>>>>>Define SCI_SETWHITESPACECHARS                  For 2443
73981>>>>>>>>>>>Define SCI_GETWHITESPACECHARS                  For 2647
73981>>>>>>>>>>>Define SCI_SETPUNCTUATIONCHARS                 For 2648
73981>>>>>>>>>>>Define SCI_GETPUNCTUATIONCHARS                 For 2649
73981>>>>>>>>>>>Define SCI_SETCHARSDEFAULT                     For 2444
73981>>>>>>>>>>>Define SCI_AUTOCGETCURRENT                     For 2445
73981>>>>>>>>>>>Define SCI_AUTOCGETCURRENTTEXT                 For 2610
73981>>>>>>>>>>>Define SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE For 0
73981>>>>>>>>>>>Define SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE  For 1
73981>>>>>>>>>>>Define SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR    For 2634
73981>>>>>>>>>>>Define SCI_AUTOCGETCASEINSENSITIVEBEHAVIOUR    For 2635
73981>>>>>>>>>>>Define SC_MULTIAUTOC_ONCE                      For 0
73981>>>>>>>>>>>Define SC_MULTIAUTOC_EACH                      For 1
73981>>>>>>>>>>>Define SCI_AUTOCSETMULTI                       For 2636
73981>>>>>>>>>>>Define SCI_AUTOCGETMULTI                       For 2637
73981>>>>>>>>>>>Define SC_ORDER_PRESORTED                      For 0
73981>>>>>>>>>>>Define SC_ORDER_PERFORMSORT                    For 1
73981>>>>>>>>>>>Define SC_ORDER_CUSTOM                         For 2
73981>>>>>>>>>>>Define SCI_AUTOCSETORDER                       For 2660
73981>>>>>>>>>>>Define SCI_AUTOCGETORDER                       For 2661
73981>>>>>>>>>>>Define SCI_ALLOCATE                            For 2446
73981>>>>>>>>>>>Define SCI_TARGETASUTF8                        For 2447
73981>>>>>>>>>>>Define SCI_SETLENGTHFORENCODE                  For 2448
73981>>>>>>>>>>>Define SCI_ENCODEDFROMUTF8                     For 2449
73981>>>>>>>>>>>Define SCI_FINDCOLUMN                          For 2456
73981>>>>>>>>>>>Define SCI_GETCARETSTICKY                      For 2457
73981>>>>>>>>>>>Define SCI_SETCARETSTICKY                      For 2458
73981>>>>>>>>>>>Define SC_CARETSTICKY_OFF                      For 0
73981>>>>>>>>>>>Define SC_CARETSTICKY_ON                       For 1
73981>>>>>>>>>>>Define SC_CARETSTICKY_WHITESPACE               For 2
73981>>>>>>>>>>>Define SCI_TOGGLECARETSTICKY                   For 2459
73981>>>>>>>>>>>Define SCI_SETPASTECONVERTENDINGS              For 2467
73981>>>>>>>>>>>Define SCI_GETPASTECONVERTENDINGS              For 2468
73981>>>>>>>>>>>Define SCI_SELECTIONDUPLICATE                  For 2469
73981>>>>>>>>>>>Define SC_ALPHA_TRANSPARENT                    For 0
73981>>>>>>>>>>>Define SC_ALPHA_OPAQUE                         For 255
73981>>>>>>>>>>>Define SC_ALPHA_NOALPHA                        For 256
73981>>>>>>>>>>>Define SCI_SETCARETLINEBACKALPHA               For 2470
73981>>>>>>>>>>>Define SCI_GETCARETLINEBACKALPHA               For 2471
73981>>>>>>>>>>>Define CARETSTYLE_INVISIBLE                    For 0
73981>>>>>>>>>>>Define CARETSTYLE_LINE                         For 1
73981>>>>>>>>>>>Define CARETSTYLE_BLOCK                        For 2
73981>>>>>>>>>>>Define CARETSTYLE_OVERSTRIKE_BAR               For 0
73981>>>>>>>>>>>Define CARETSTYLE_OVERSTRIKE_BLOCK             For 16
73981>>>>>>>>>>>Define CARETSTYLE_INS_MASK                     For |CI$0F   // 0xF
73981>>>>>>>>>>>Define SCI_SETCARETSTYLE                       For 2512
73981>>>>>>>>>>>Define SCI_GETCARETSTYLE                       For 2513
73981>>>>>>>>>>>Define SCI_SETINDICATORCURRENT                 For 2500
73981>>>>>>>>>>>Define SCI_GETINDICATORCURRENT                 For 2501
73981>>>>>>>>>>>Define SCI_SETINDICATORVALUE                   For 2502
73981>>>>>>>>>>>Define SCI_GETINDICATORVALUE                   For 2503
73981>>>>>>>>>>>Define SCI_INDICATORFILLRANGE                  For 2504
73981>>>>>>>>>>>Define SCI_INDICATORCLEARRANGE                 For 2505
73981>>>>>>>>>>>Define SCI_INDICATORALLONFOR                   For 2506
73981>>>>>>>>>>>Define SCI_INDICATORVALUEAT                    For 2507
73981>>>>>>>>>>>Define SCI_INDICATORSTART                      For 2508
73981>>>>>>>>>>>Define SCI_INDICATOREND                        For 2509
73981>>>>>>>>>>>Define SCI_SETPOSITIONCACHE                    For 2514
73981>>>>>>>>>>>Define SCI_GETPOSITIONCACHE                    For 2515
73981>>>>>>>>>>>Define SCI_COPYALLOWLINE                       For 2519
73981>>>>>>>>>>>Define SCI_GETCHARACTERPOINTER                 For 2520
73981>>>>>>>>>>>Define SCI_GETRANGEPOINTER                     For 2643
73981>>>>>>>>>>>Define SCI_GETGAPPOSITION                      For 2644
73981>>>>>>>>>>>Define SCI_INDICSETALPHA                       For 2523
73981>>>>>>>>>>>Define SCI_INDICGETALPHA                       For 2524
73981>>>>>>>>>>>Define SCI_INDICSETOUTLINEALPHA                For 2558
73981>>>>>>>>>>>Define SCI_INDICGETOUTLINEALPHA                For 2559
73981>>>>>>>>>>>Define SCI_SETEXTRAASCENT                      For 2525
73981>>>>>>>>>>>Define SCI_GETEXTRAASCENT                      For 2526
73981>>>>>>>>>>>Define SCI_SETEXTRADESCENT                     For 2527
73981>>>>>>>>>>>Define SCI_GETEXTRADESCENT                     For 2528
73981>>>>>>>>>>>Define SCI_MARKERSYMBOLDEFINED                 For 2529
73981>>>>>>>>>>>Define SCI_MARGINSETTEXT                       For 2530
73981>>>>>>>>>>>Define SCI_MARGINGETTEXT                       For 2531
73981>>>>>>>>>>>Define SCI_MARGINSETSTYLE                      For 2532
73981>>>>>>>>>>>Define SCI_MARGINGETSTYLE                      For 2533
73981>>>>>>>>>>>Define SCI_MARGINSETSTYLES                     For 2534
73981>>>>>>>>>>>Define SCI_MARGINGETSTYLES                     For 2535
73981>>>>>>>>>>>Define SCI_MARGINTEXTCLEARALL                  For 2536
73981>>>>>>>>>>>Define SCI_MARGINSETSTYLEOFFSET                For 2537
73981>>>>>>>>>>>Define SCI_MARGINGETSTYLEOFFSET                For 2538
73981>>>>>>>>>>>Define SC_MARGINOPTION_NONE                    For 0
73981>>>>>>>>>>>Define SC_MARGINOPTION_SUBLINESELECT           For 1
73981>>>>>>>>>>>Define SCI_SETMARGINOPTIONS                    For 2539
73981>>>>>>>>>>>Define SCI_GETMARGINOPTIONS                    For 2557
73981>>>>>>>>>>>Define SCI_ANNOTATIONSETTEXT                   For 2540
73981>>>>>>>>>>>Define SCI_ANNOTATIONGETTEXT                   For 2541
73981>>>>>>>>>>>Define SCI_ANNOTATIONSETSTYLE                  For 2542
73981>>>>>>>>>>>Define SCI_ANNOTATIONGETSTYLE                  For 2543
73981>>>>>>>>>>>Define SCI_ANNOTATIONSETSTYLES                 For 2544
73981>>>>>>>>>>>Define SCI_ANNOTATIONGETSTYLES                 For 2545
73981>>>>>>>>>>>Define SCI_ANNOTATIONGETLINES                  For 2546
73981>>>>>>>>>>>Define SCI_ANNOTATIONCLEARALL                  For 2547
73981>>>>>>>>>>>Define ANNOTATION_HIDDEN                       For 0
73981>>>>>>>>>>>Define ANNOTATION_STANDARD                     For 1
73981>>>>>>>>>>>Define ANNOTATION_BOXED                        For 2
73981>>>>>>>>>>>Define ANNOTATION_INDENTED                     For 3
73981>>>>>>>>>>>Define SCI_ANNOTATIONSETVISIBLE                For 2548
73981>>>>>>>>>>>Define SCI_ANNOTATIONGETVISIBLE                For 2549
73981>>>>>>>>>>>Define SCI_ANNOTATIONSETSTYLEOFFSET            For 2550
73981>>>>>>>>>>>Define SCI_ANNOTATIONGETSTYLEOFFSET            For 2551
73981>>>>>>>>>>>Define SCI_RELEASEALLEXTENDEDSTYLES            For 2552
73981>>>>>>>>>>>Define SCI_ALLOCATEEXTENDEDSTYLES              For 2553
73981>>>>>>>>>>>Define UNDO_MAY_COALESCE                       For 1
73981>>>>>>>>>>>Define SCI_ADDUNDOACTION                       For 2560
73981>>>>>>>>>>>Define SCI_CHARPOSITIONFROMPOINT               For 2561
73981>>>>>>>>>>>Define SCI_CHARPOSITIONFROMPOINTCLOSE          For 2562
73981>>>>>>>>>>>Define SCI_SETMOUSESELECTIONRECTANGULARSWITCH  For 2668
73981>>>>>>>>>>>Define SCI_GETMOUSESELECTIONRECTANGULARSWITCH  For 2669
73981>>>>>>>>>>>Define SCI_SETMULTIPLESELECTION                For 2563
73981>>>>>>>>>>>Define SCI_GETMULTIPLESELECTION                For 2564
73981>>>>>>>>>>>Define SCI_SETADDITIONALSELECTIONTYPING        For 2565
73981>>>>>>>>>>>Define SCI_GETADDITIONALSELECTIONTYPING        For 2566
73981>>>>>>>>>>>Define SCI_SETADDITIONALCARETSBLINK            For 2567
73981>>>>>>>>>>>Define SCI_GETADDITIONALCARETSBLINK            For 2568
73981>>>>>>>>>>>Define SCI_SETADDITIONALCARETSVISIBLE          For 2608
73981>>>>>>>>>>>Define SCI_GETADDITIONALCARETSVISIBLE          For 2609
73981>>>>>>>>>>>Define SCI_GETSELECTIONS                       For 2570
73981>>>>>>>>>>>Define SCI_GETSELECTIONEMPTY                   For 2650
73981>>>>>>>>>>>Define SCI_CLEARSELECTIONS                     For 2571
73981>>>>>>>>>>>Define SCI_SETSELECTION                        For 2572
73981>>>>>>>>>>>Define SCI_ADDSELECTION                        For 2573
73981>>>>>>>>>>>Define SCI_DROPSELECTIONN                      For 2671
73981>>>>>>>>>>>Define SCI_SETMAINSELECTION                    For 2574
73981>>>>>>>>>>>Define SCI_GETMAINSELECTION                    For 2575
73981>>>>>>>>>>>Define SCI_SETSELECTIONNCARET                  For 2576
73981>>>>>>>>>>>Define SCI_GETSELECTIONNCARET                  For 2577
73981>>>>>>>>>>>Define SCI_SETSELECTIONNANCHOR                 For 2578
73981>>>>>>>>>>>Define SCI_GETSELECTIONNANCHOR                 For 2579
73981>>>>>>>>>>>Define SCI_SETSELECTIONNCARETVIRTUALSPACE      For 2580
73981>>>>>>>>>>>Define SCI_GETSELECTIONNCARETVIRTUALSPACE      For 2581
73981>>>>>>>>>>>Define SCI_SETSELECTIONNANCHORVIRTUALSPACE     For 2582
73981>>>>>>>>>>>Define SCI_GETSELECTIONNANCHORVIRTUALSPACE     For 2583
73981>>>>>>>>>>>Define SCI_SETSELECTIONNSTART                  For 2584
73981>>>>>>>>>>>Define SCI_GETSELECTIONNSTART                  For 2585
73981>>>>>>>>>>>Define SCI_SETSELECTIONNEND                    For 2586
73981>>>>>>>>>>>Define SCI_GETSELECTIONNEND                    For 2587
73981>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONCARET        For 2588
73981>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONCARET        For 2589
73981>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONANCHOR       For 2590
73981>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONANCHOR       For 2591
73981>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONCARETVIRTUALSPACE  For 2592
73981>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE  For 2593
73981>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONANCHORVIRTUALSPACE For 2594
73981>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE For 2595
73981>>>>>>>>>>>Define SCVS_NONE                               For 0
73981>>>>>>>>>>>Define SCVS_RECTANGULARSELECTION               For 1
73981>>>>>>>>>>>Define SCVS_USERACCESSIBLE                     For 2
73981>>>>>>>>>>>Define SCVS_NOWRAPLINESTART                    For 4
73981>>>>>>>>>>>Define SCI_SETVIRTUALSPACEOPTIONS              For 2596
73981>>>>>>>>>>>Define SCI_GETVIRTUALSPACEOPTIONS              For 2597
73981>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONMODIFIER     For 2598
73981>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONMODIFIER     For 2599
73981>>>>>>>>>>>Define SCI_SETADDITIONALSELFORE                For 2600
73981>>>>>>>>>>>Define SCI_SETADDITIONALSELBACK                For 2601
73981>>>>>>>>>>>Define SCI_SETADDITIONALSELALPHA               For 2602
73981>>>>>>>>>>>Define SCI_GETADDITIONALSELALPHA               For 2603
73981>>>>>>>>>>>Define SCI_SETADDITIONALCARETFORE              For 2604
73981>>>>>>>>>>>Define SCI_GETADDITIONALCARETFORE              For 2605
73981>>>>>>>>>>>Define SCI_ROTATESELECTION                     For 2606
73981>>>>>>>>>>>Define SCI_SWAPMAINANCHORCARET                 For 2607
73981>>>>>>>>>>>Define SCI_MULTIPLESELECTADDNEXT               For 2688
73981>>>>>>>>>>>Define SCI_MULTIPLESELECTADDEACH               For 2689
73981>>>>>>>>>>>Define SCI_CHANGELEXERSTATE                    For 2617
73981>>>>>>>>>>>Define SCI_CONTRACTEDFOLDNEXT                  For 2618
73981>>>>>>>>>>>Define SCI_VERTICALCENTRECARET                 For 2619
73981>>>>>>>>>>>Define SCI_MOVESELECTEDLINESUP                 For 2620
73981>>>>>>>>>>>Define SCI_MOVESELECTEDLINESDOWN               For 2621
73981>>>>>>>>>>>Define SCI_SETIDENTIFIER                       For 2622
73981>>>>>>>>>>>Define SCI_GETIDENTIFIER                       For 2623
73981>>>>>>>>>>>Define SCI_RGBAIMAGESETWIDTH                   For 2624
73981>>>>>>>>>>>Define SCI_RGBAIMAGESETHEIGHT                  For 2625
73981>>>>>>>>>>>Define SCI_RGBAIMAGESETSCALE                   For 2651
73981>>>>>>>>>>>Define SCI_MARKERDEFINERGBAIMAGE               For 2626
73981>>>>>>>>>>>Define SCI_REGISTERRGBAIMAGE                   For 2627
73981>>>>>>>>>>>Define SCI_SCROLLTOSTART                       For 2628
73981>>>>>>>>>>>Define SCI_SCROLLTOEND                         For 2629
73981>>>>>>>>>>>Define SC_TECHNOLOGY_DEFAULT                   For 0
73981>>>>>>>>>>>Define SC_TECHNOLOGY_DIRECTWRITE               For 1
73981>>>>>>>>>>>Define SC_TECHNOLOGY_DIRECTWRITERETAIN         For 2
73981>>>>>>>>>>>Define SC_TECHNOLOGY_DIRECTWRITEDC             For 3
73981>>>>>>>>>>>Define SCI_SETTECHNOLOGY                       For 2630
73981>>>>>>>>>>>Define SCI_GETTECHNOLOGY                       For 2631
73981>>>>>>>>>>>Define SCI_CREATELOADER                        For 2632
73981>>>>>>>>>>>Define SCI_FINDINDICATORSHOW                   For 2640
73981>>>>>>>>>>>Define SCI_FINDINDICATORFLASH                  For 2641
73981>>>>>>>>>>>Define SCI_FINDINDICATORHIDE                   For 2642
73981>>>>>>>>>>>Define SCI_VCHOMEDISPLAY                       For 2652
73981>>>>>>>>>>>Define SCI_VCHOMEDISPLAYEXTEND                 For 2653
73981>>>>>>>>>>>Define SCI_GETCARETLINEVISIBLEALWAYS           For 2654
73981>>>>>>>>>>>Define SCI_SETCARETLINEVISIBLEALWAYS           For 2655
73981>>>>>>>>>>>Define SC_LINE_END_TYPE_DEFAULT                For 0
73981>>>>>>>>>>>Define SC_LINE_END_TYPE_UNICODE                For 1
73981>>>>>>>>>>>Define SCI_SETLINEENDTYPESALLOWED              For 2656
73981>>>>>>>>>>>Define SCI_GETLINEENDTYPESALLOWED              For 2657
73981>>>>>>>>>>>Define SCI_GETLINEENDTYPESACTIVE               For 2658
73981>>>>>>>>>>>Define SCI_SETREPRESENTATION                   For 2665
73981>>>>>>>>>>>Define SCI_GETREPRESENTATION                   For 2666
73981>>>>>>>>>>>Define SCI_CLEARREPRESENTATION                 For 2667
73981>>>>>>>>>>>Define SCI_STARTRECORD                         For 3001
73981>>>>>>>>>>>Define SCI_STOPRECORD                          For 3002
73981>>>>>>>>>>>Define SCI_SETLEXER                            For 4001
73981>>>>>>>>>>>Define SCI_GETLEXER                            For 4002
73981>>>>>>>>>>>Define SCI_COLOURISE                           For 4003
73981>>>>>>>>>>>Define SCI_SETPROPERTY                         For 4004
73981>>>>>>>>>>>Define KEYWORDSET_MAX                          For 8
73981>>>>>>>>>>>Define SCI_SETKEYWORDS                         For 4005
73981>>>>>>>>>>>Define SCI_SETLEXERLANGUAGE                    For 4006
73981>>>>>>>>>>>Define SCI_LOADLEXERLIBRARY                    For 4007
73981>>>>>>>>>>>Define SCI_GETPROPERTY                         For 4008
73981>>>>>>>>>>>Define SCI_GETPROPERTYEXPANDED                 For 4009
73981>>>>>>>>>>>Define SCI_GETPROPERTYINT                      For 4010
73981>>>>>>>>>>>Define SCI_GETLEXERLANGUAGE                    For 4012
73981>>>>>>>>>>>Define SCI_PRIVATELEXERCALL                    For 4013
73981>>>>>>>>>>>Define SCI_PROPERTYNAMES                       For 4014
73981>>>>>>>>>>>Define SC_TYPE_BOOLEAN                         For 0
73981>>>>>>>>>>>Define SC_TYPE_INTEGER                         For 1
73981>>>>>>>>>>>Define SC_TYPE_STRING                          For 2
73981>>>>>>>>>>>Define SCI_PROPERTYTYPE                        For 4015
73981>>>>>>>>>>>Define SCI_DESCRIBEPROPERTY                    For 4016
73981>>>>>>>>>>>Define SCI_DESCRIBEKEYWORDSETS                 For 4017
73981>>>>>>>>>>>Define SCI_GETLINEENDTYPESSUPPORTED            For 4018
73981>>>>>>>>>>>Define SCI_ALLOCATESUBSTYLES                   For 4020
73981>>>>>>>>>>>Define SCI_GETSUBSTYLESSTART                   For 4021
73981>>>>>>>>>>>Define SCI_GETSUBSTYLESLENGTH                  For 4022
73981>>>>>>>>>>>Define SCI_GETSTYLEFROMSUBSTYLE                For 4027
73981>>>>>>>>>>>Define SCI_GETPRIMARYSTYLEFROMSTYLE            For 4028
73981>>>>>>>>>>>Define SCI_FREESUBSTYLES                       For 4023
73981>>>>>>>>>>>Define SCI_SETIDENTIFIERS                      For 4024
73981>>>>>>>>>>>Define SCI_DISTANCETOSECONDARYSTYLES           For 4025
73981>>>>>>>>>>>Define SCI_GETSUBSTYLEBASES                    For 4026
73981>>>>>>>>>>>Define SCI_GETNAMEDSTYLES                      For 4029
73981>>>>>>>>>>>Define SCI_NAMEOFSTYLE                         For 4030
73981>>>>>>>>>>>Define SCI_TAGSOFSTYLE                         For 4031
73981>>>>>>>>>>>Define SCI_DESCRIPTIONOFSTYLE                  For 4032
73981>>>>>>>>>>>Define SC_MOD_INSERTTEXT                       For |CI$01  // $0x1
73981>>>>>>>>>>>Define SC_MOD_DELETETEXT                       For |CI$02  // $0x2
73981>>>>>>>>>>>Define SC_MOD_CHANGESTYLE                      For |CI$04  // $0x4
73981>>>>>>>>>>>Define SC_MOD_CHANGEFOLD                       For |CI$08  // $0x8
73981>>>>>>>>>>>Define SC_PERFORMED_USER                       For |CI$010  // $0x10
73981>>>>>>>>>>>Define SC_PERFORMED_UNDO                       For |CI$020  // $0x20
73981>>>>>>>>>>>Define SC_PERFORMED_REDO                       For |CI$040  // $0x40
73981>>>>>>>>>>>Define SC_MULTISTEPUNDOREDO                    For |CI$080  // $0x80
73981>>>>>>>>>>>Define SC_LASTSTEPINUNDOREDO                   For |CI$0100  // $0x100
73981>>>>>>>>>>>Define SC_MOD_CHANGEMARKER                     For |CI$0200  // $0x200
73981>>>>>>>>>>>Define SC_MOD_BEFOREINSERT                     For |CI$0400  // $0x400
73981>>>>>>>>>>>Define SC_MOD_BEFOREDELETE                     For |CI$0800  // $0x800
73981>>>>>>>>>>>Define SC_MULTILINEUNDOREDO                    For |CI$01000  // $0x1000
73981>>>>>>>>>>>Define SC_STARTACTION                          For |CI$2000  // $0x2000
73981>>>>>>>>>>>Define SC_MOD_CHANGEINDICATOR                  For |CI$4000  // $0x4000
73981>>>>>>>>>>>Define SC_MOD_CHANGELINESTATE                  For |CI$8000  // $0x8000
73981>>>>>>>>>>>Define SC_MOD_CHANGEMARGIN                     For |CI$10000  // $0x10000
73981>>>>>>>>>>>Define SC_MOD_CHANGEANNOTATION                 For |CI$20000  //$0x20000
73981>>>>>>>>>>>Define SC_MOD_CONTAINER                        For |CI$40000  // $0x40000
73981>>>>>>>>>>>Define SC_MOD_LEXERSTATE                       For |CI$80000  // $0x80000
73981>>>>>>>>>>>Define SC_MOD_INSERTCHECK                      For |CI$100000  // $0x100000
73981>>>>>>>>>>>Define SC_MOD_CHANGETABSTOPS                   For |CI$200000  // $0x200000
73981>>>>>>>>>>>Define SC_MODEVENTMASKALL                      For |CI$3FFFFF  // $0x3FFFFF
73981>>>>>>>>>>>Define SC_UPDATE_CONTENT                       For |CI$01  // $0x1
73981>>>>>>>>>>>Define SC_UPDATE_SELECTION                     For |CI$02  // $0x2
73981>>>>>>>>>>>Define SC_UPDATE_V_SCROLL                      For |CI$04  // $0x4
73981>>>>>>>>>>>Define SC_UPDATE_H_SCROLL                      For |CI$08  // $0x8
73981>>>>>>>>>>>Define SCEN_CHANGE                             For 768
73981>>>>>>>>>>>Define SCEN_SETFOCUS                           For 512
73981>>>>>>>>>>>Define SCEN_KILLFOCUS                          For 256
73981>>>>>>>>>>>Define SCK_DOWN                                For 300
73981>>>>>>>>>>>Define SCK_UP                                  For 301
73981>>>>>>>>>>>Define SCK_LEFT                                For 302
73981>>>>>>>>>>>Define SCK_RIGHT                               For 303
73981>>>>>>>>>>>Define SCK_HOME                                For 304
73981>>>>>>>>>>>Define SCK_END                                 For 305
73981>>>>>>>>>>>Define SCK_PRIOR                               For 306
73981>>>>>>>>>>>Define SCK_NEXT                                For 307
73981>>>>>>>>>>>Define SCK_DELETE                              For 308
73981>>>>>>>>>>>Define SCK_INSERT                              For 309
73981>>>>>>>>>>>Define SCK_ESCAPE                              For 7
73981>>>>>>>>>>>Define SCK_BACK                                For 8
73981>>>>>>>>>>>Define SCK_TAB                                 For 9
73981>>>>>>>>>>>Define SCK_RETURN                              For 13
73981>>>>>>>>>>>Define SCK_ADD                                 For 310
73981>>>>>>>>>>>Define SCK_SUBTRACT                            For 311
73981>>>>>>>>>>>Define SCK_DIVIDE                              For 312
73981>>>>>>>>>>>Define SCK_WIN                                 For 313
73981>>>>>>>>>>>Define SCK_RWIN                                For 314
73981>>>>>>>>>>>Define SCK_MENU                                For 315
73981>>>>>>>>>>>Define SCMOD_NORM                              For 0
73981>>>>>>>>>>>Define SCMOD_SHIFT                             For 1
73981>>>>>>>>>>>Define SCMOD_CTRL                              For 2
73981>>>>>>>>>>>Define SCMOD_ALT                               For 4
73981>>>>>>>>>>>Define SCMOD_SUPER                             For 8
73981>>>>>>>>>>>Define SCMOD_META                              For 16
73981>>>>>>>>>>>Define SC_AC_FILLUP                            For 1
73981>>>>>>>>>>>Define SC_AC_DOUBLECLICK                       For 2
73981>>>>>>>>>>>Define SC_AC_TAB                               For 3
73981>>>>>>>>>>>Define SC_AC_NEWLINE                           For 4
73981>>>>>>>>>>>Define SC_AC_COMMAND                           For 5
73981>>>>>>>>>>>Define SCN_STYLENEEDED                         For 2000   // SCN - Notifications
73981>>>>>>>>>>>Define SCN_CHARADDED                           For 2001
73981>>>>>>>>>>>Define SCN_SAVEPOINTREACHED                    For 2002
73981>>>>>>>>>>>Define SCN_SAVEPOINTLEFT                       For 2003
73981>>>>>>>>>>>Define SCN_MODIFYATTEMPTRO                     For 2004
73981>>>>>>>>>>>Define SCN_KEY                                 For 2005
73981>>>>>>>>>>>Define SCN_DOUBLECLICK                         For 2006
73981>>>>>>>>>>>Define SCN_UPDATEUI                            For 2007
73981>>>>>>>>>>>Define SCN_MODIFIED                            For 2008
73981>>>>>>>>>>>Define SCN_MACRORECORD                         For 2009
73981>>>>>>>>>>>Define SCN_MARGINCLICK                         For 2010
73981>>>>>>>>>>>Define SCN_NEEDSHOWN                           For 2011
73981>>>>>>>>>>>Define SCN_PAINTED                             For 2013
73981>>>>>>>>>>>Define SCN_USERLISTSELECTION                   For 2014
73981>>>>>>>>>>>Define SCN_URIDROPPED                          For 2015
73981>>>>>>>>>>>Define SCN_DWELLSTART                          For 2016
73981>>>>>>>>>>>Define SCN_DWELLEND                            For 2017
73981>>>>>>>>>>>Define SCN_ZOOM                                For 2018
73981>>>>>>>>>>>Define SCN_HOTSPOTCLICK                        For 2019
73981>>>>>>>>>>>Define SCN_HOTSPOTDOUBLECLICK                  For 2020
73981>>>>>>>>>>>Define SCN_CALLTIPCLICK                        For 2021
73981>>>>>>>>>>>Define SCN_AUTOCSELECTION                      For 2022
73981>>>>>>>>>>>Define SCN_INDICATORCLICK                      For 2023
73981>>>>>>>>>>>Define SCN_INDICATORRELEASE                    For 2024
73981>>>>>>>>>>>Define SCN_AUTOCCANCELLED                      For 2025
73981>>>>>>>>>>>Define SCN_AUTOCCHARDELETED                    For 2026
73981>>>>>>>>>>>Define SCN_HOTSPOTRELEASECLICK                 For 2027
73981>>>>>>>>>>>Define SCN_FOCUSIN                             For 2028
73981>>>>>>>>>>>Define SCN_FOCUSOUT                            For 2029
73981>>>>>>>>>>>Define SCN_AUTOCCOMPLETED                      For 2030
73981>>>>>>>>>>>Define SCN_MARGINRIGHTCLICK                    For 2031
73981>>>>>>>>>>>Define SCN_AUTOCSELECTIONCHANGE                For 2032
73981>>>>>>>>>>>Define SC_BIDIRECTIONAL_DISABLED               For 0
73981>>>>>>>>>>>Define SC_BIDIRECTIONAL_L2R                    For 1
73981>>>>>>>>>>>Define SC_BIDIRECTIONAL_R2L                    For 2
73981>>>>>>>>>>>Define SCI_GETBIDIRECTIONAL                    For 2708
73981>>>>>>>>>>>Define SCI_SETBIDIRECTIONAL                    For 2709
73981>>>>>>>>>>>Define SC_LINECHARACTERINDEX_NONE              For 0
73981>>>>>>>>>>>Define SC_LINECHARACTERINDEX_UTF32             For 1
73981>>>>>>>>>>>Define SC_LINECHARACTERINDEX_UTF16             For 2
73981>>>>>>>>>>>Define SCI_GETLINECHARACTERINDEX               For 2710
73981>>>>>>>>>>>Define SCI_ALLOCATELINECHARACTERINDEX          For 2711
73981>>>>>>>>>>>Define SCI_RELEASELINECHARACTERINDEX           For 2712
73981>>>>>>>>>>>Define SCI_LINEFROMINDEXPOSITION               For 2713
73981>>>>>>>>>>>Define SCI_INDEXPOSITIONFROMLINE               For 2714
73981>>>>>>>>>>>
73981>>>>>>>>>>>
73981>>>>>>>>>>>// Basic signed type used throughout interface (see scintilla source Sci_Position.h)
73981>>>>>>>>>>>// typedef ptrdiff_t Sci_Position;
73981>>>>>>>>>>>Define Sci_Position For Longptr
73981>>>>>>>>>>>
73981>>>>>>>>>>>// Unsigned variant used for ILexer::Lex and ILexer::Fold
73981>>>>>>>>>>>// typedef size_t Sci_PositionU;
73981>>>>>>>>>>>Define Sci_PositionU For ULongptr
73981>>>>>>>>>>>
73981>>>>>>>>>>>// For Sci_CharacterRange  which is defined as long to be compatible with Win32 CHARRANGE
73981>>>>>>>>>>>// typedef long Sci_PositionCR;
73981>>>>>>>>>>>Define Sci_PositionCR For integer
73981>>>>>>>>>>>
73981>>>>>>>>>>>
73981>>>>>>>>>>>//struct Sci_CharacterRange {
73981>>>>>>>>>>>//    Sci_PositionCR cpMin;
73981>>>>>>>>>>>//    Sci_PositionCR cpMax;
73981>>>>>>>>>>>//};
73981>>>>>>>>>>>Struct tSci_CharacterRange
73981>>>>>>>>>>>  Sci_PositionCR cpMin
73981>>>>>>>>>>>  Sci_PositionCR cpMax
73981>>>>>>>>>>>End_Struct
73981>>>>>>>>>>>
73981>>>>>>>>>>>//struct Sci_TextRange {
73981>>>>>>>>>>>//    struct Sci_CharacterRange chrg;
73981>>>>>>>>>>>//    char *lpstrText;
73981>>>>>>>>>>>//};
73981>>>>>>>>>>>Struct tSci_TextRange
73981>>>>>>>>>>>  tSci_CharacterRange chrg
73981>>>>>>>>>>>  tSci_CharacterRange chrg
73981>>>>>>>>>>>  Pointer lpstrText
73981>>>>>>>>>>>End_Struct
73981>>>>>>>>>>>
73981>>>>>>>>>>>//struct Sci_TextToFind {
73981>>>>>>>>>>>//    struct Sci_CharacterRange chrg;     // range to search
73981>>>>>>>>>>>//    const char *lpstrText;              // the search pattern (zero terminated)
73981>>>>>>>>>>>//    struct Sci_CharacterRange chrgText; // returned as position of matching text
73981>>>>>>>>>>>//};
73981>>>>>>>>>>>Struct tSci_TextToFind
73981>>>>>>>>>>>  tSci_CharacterRange chrg
73981>>>>>>>>>>>  tSci_CharacterRange chrg
73981>>>>>>>>>>>  Pointer            pszText
73981>>>>>>>>>>>  tSci_CharacterRange chrgText
73981>>>>>>>>>>>  tSci_CharacterRange chrgText
73981>>>>>>>>>>>End_Struct
73981>>>>>>>>>>>
73981>>>>>>>>>>>//struct Sci_Rectangle {
73981>>>>>>>>>>>//      int left;
73981>>>>>>>>>>>//      int top;
73981>>>>>>>>>>>//      int right;
73981>>>>>>>>>>>//      int bottom;
73981>>>>>>>>>>>//};
73981>>>>>>>>>>>Struct tSci_Rectangle
73981>>>>>>>>>>>  Integer left
73981>>>>>>>>>>>  Integer top
73981>>>>>>>>>>>  Integer right
73981>>>>>>>>>>>  Integer bottom
73981>>>>>>>>>>>End_Struct
73981>>>>>>>>>>>
73981>>>>>>>>>>>
73981>>>>>>>>>>>//
73981>>>>>>>>>>>//  Struct Sci_NotifyHeader {
73981>>>>>>>>>>>//      /* Compatible with Windows NMHDR.
73981>>>>>>>>>>>//       * hwndFrom is really an environment specific window handle or pointer
73981>>>>>>>>>>>//       * but most clients of Scintilla.h do not have this type visible. */
73981>>>>>>>>>>>//      void *hwndFrom;
73981>>>>>>>>>>>//      uptr_t idFrom;
73981>>>>>>>>>>>//      unsigned int code;
73981>>>>>>>>>>>//  };
73981>>>>>>>>>>>Struct tSci_NotifyHeader
73981>>>>>>>>>>>  Handle   hwndFrom
73981>>>>>>>>>>>  ULongptr idFrom
73981>>>>>>>>>>>  UInteger uCode
73981>>>>>>>>>>>End_Struct
73981>>>>>>>>>>>//
73981>>>>>>>>>>>//  Struct SCNotification {
73981>>>>>>>>>>>//      Sci_NotifyHeader nmhdr;
73981>>>>>>>>>>>//      Sci_Position position;
73981>>>>>>>>>>>//      /* SCN_STYLENEEDED, SCN_DOUBLECLICK, SCN_MODIFIED, SCN_MARGINCLICK, */
73981>>>>>>>>>>>//      /* SCN_NEEDSHOWN, SCN_DWELLSTART, SCN_DWELLEND, SCN_CALLTIPCLICK, */
73981>>>>>>>>>>>//      /* SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK, SCN_HOTSPOTRELEASECLICK, */
73981>>>>>>>>>>>//      /* SCN_INDICATORCLICK, SCN_INDICATORRELEASE, */
73981>>>>>>>>>>>//      /* SCN_USERLISTSELECTION, SCN_AUTOCSELECTION */
73981>>>>>>>>>>>//
73981>>>>>>>>>>>//      int ch;
73981>>>>>>>>>>>//      /* SCN_CHARADDED, SCN_KEY, SCN_AUTOCCOMPLETED, SCN_AUTOCSELECTION, */
73981>>>>>>>>>>>//      /* SCN_USERLISTSELECTION */
73981>>>>>>>>>>>//      int modifiers;
73981>>>>>>>>>>>//      /* SCN_KEY, SCN_DOUBLECLICK, SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK, */
73981>>>>>>>>>>>//      /* SCN_HOTSPOTRELEASECLICK, SCN_INDICATORCLICK, SCN_INDICATORRELEASE, */
73981>>>>>>>>>>>//
73981>>>>>>>>>>>//      int modificationType;   /* SCN_MODIFIED */
73981>>>>>>>>>>>//      const Char *text;
73981>>>>>>>>>>>//      /* SCN_MODIFIED, SCN_USERLISTSELECTION, SCN_AUTOCSELECTION, SCN_URIDROPPED */
73981>>>>>>>>>>>//
73981>>>>>>>>>>>//      Sci_Position length;            /* SCN_MODIFIED */
73981>>>>>>>>>>>//      Sci_Position linesAdded;        /* SCN_MODIFIED */
73981>>>>>>>>>>>//      int message;    /* SCN_MACRORECORD */
73981>>>>>>>>>>>//      uptr_t wParam;  /* SCN_MACRORECORD */
73981>>>>>>>>>>>//      sptr_t lParam;  /* SCN_MACRORECORD */
73981>>>>>>>>>>>//      Sci_Position line;              /* SCN_MODIFIED */
73981>>>>>>>>>>>//      int foldLevelNow;       /* SCN_MODIFIED */
73981>>>>>>>>>>>//      int foldLevelPrev;      /* SCN_MODIFIED */
73981>>>>>>>>>>>//      int margin;             /* SCN_MARGINCLICK */
73981>>>>>>>>>>>//      int listType;   /* SCN_USERLISTSELECTION */
73981>>>>>>>>>>>//      int x;                  /* SCN_DWELLSTART, SCN_DWELLEND */
73981>>>>>>>>>>>//      int y;          /* SCN_DWELLSTART, SCN_DWELLEND */
73981>>>>>>>>>>>//      int token;              /* SCN_MODIFIED with SC_MOD_CONTAINER */
73981>>>>>>>>>>>//      Sci_Position annotationLinesAdded;      /* SCN_MODIFIED with SC_MOD_CHANGEANNOTATION */
73981>>>>>>>>>>>//      int updated;    /* SCN_UPDATEUI */
73981>>>>>>>>>>>//      int listCompletionMethod;
73981>>>>>>>>>>>//      /* SCN_AUTOCSELECTION, SCN_AUTOCCOMPLETED, SCN_USERLISTSELECTION, */
73981>>>>>>>>>>>//  };
73981>>>>>>>>>>>Struct tSCNotification
73981>>>>>>>>>>>  tSci_NotifyHeader nmhdr
73981>>>>>>>>>>>  tSci_NotifyHeader nmhdr
73981>>>>>>>>>>>  Sci_Position      position
73981>>>>>>>>>>>  Integer           ch
73981>>>>>>>>>>>  Integer           modifiers
73981>>>>>>>>>>>  Integer           modificationType
73981>>>>>>>>>>>  Address           Text
73981>>>>>>>>>>>  Sci_Position      length
73981>>>>>>>>>>>  Sci_Position      linesAdded
73981>>>>>>>>>>>  Integer           message
73981>>>>>>>>>>>  ULongptr          wParam
73981>>>>>>>>>>>  Longptr           lParam
73981>>>>>>>>>>>  Sci_Position      line
73981>>>>>>>>>>>  Integer           foldLevelNow
73981>>>>>>>>>>>  Integer           foldLevelPrev
73981>>>>>>>>>>>  Integer           margin
73981>>>>>>>>>>>  Integer           listType
73981>>>>>>>>>>>  Integer           x
73981>>>>>>>>>>>  Integer           y
73981>>>>>>>>>>>  Integer           token
73981>>>>>>>>>>>  Sci_Position      annotationLinesAdded
73981>>>>>>>>>>>  Integer           updated
73981>>>>>>>>>>>  Integer           listCompletionMethod
73981>>>>>>>>>>>  //Integer           characterSource  // not in the current scintilla YET
73981>>>>>>>>>>>End_Struct
73981>>>>>>>>>
73981>>>>>>>>>
73981>>>>>>>>>Define CS_CR   For (Character(13))
73981>>>>>>>>>Define CS_CRLF For (Character(13)+Character(10))
73981>>>>>>>>>Define CS_LF   For (Character(10))
73981>>>>>>>>>
73981>>>>>>>>>
73981>>>>>>>>>Define CMAX_DLL_NAME For SCILEXER32.DLL
73981>>>>>>>>>
73981>>>>>>>>>
73981>>>>>>>>>Define NM_SETFOCUS              For -7
73981>>>>>>>>>Define NM_KILLFOCUS             For -8
73981>>>>>>>>>
73981>>>>>>>>>Define WM_CONTEXTMENU           For |CI$007B // 0x007B
73981>>>>>>>>>Define WM_RBUTTONUP             For |CI$0205 // 0x0205
73981>>>>>>>>>
73981>>>>>>>>>External_Function GetObject          'GetObjectA'           Gdi32.dll   Handle hGdi Integer iSize Pointer pBuff Returns Integer
73982>>>>>>>>>External_Function LockWindowUpdate   'LockWindowUpdate'     USer32.dll  Handle hwnd Returns Integer
73983>>>>>>>>>External_Function ReplyMessage       'ReplyMessage'         User32.dll  Integer iResult Returns Integer
73984>>>>>>>>>
73984>>>>>>>>>// File Dropping from e.g WindowsExplorer.
73984>>>>>>>>>Define WM_DROPFILES              For |CI$0233
73984>>>>>>>>>External_Function DragAcceptFiles    'DragAcceptFiles'      Shell32.dll Handle hwnd Integer iFlag Returns Integer
73985>>>>>>>>>External_Function DragQueryFile      'DragQueryFile'        Shell32.dll Handle hDrop Integer iFileIndex Pointer pFileBuff Integer iBuffSize Returns Integer
73986>>>>>>>>>External_Function DragFinish         'DragFinish'           Shell32.dll Handle hDrop Returns Integer
73987>>>>>>>>>
73987>>>>>>>>>// CodeTip Support external Function
73987>>>>>>>>>External_Function CT_DestroyWindow   'DestroyWindow'        User32.dll  Handle hWnd Returns Integer
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>Define RDW_INVALIDATE          For |CI$0001
73988>>>>>>>>>Define RDW_INTERNALPAINT       For |CI$0002
73988>>>>>>>>>Define RDW_ERASE               For |CI$0004
73988>>>>>>>>>
73988>>>>>>>>>Define RDW_VALIDATE            For |CI$0008
73988>>>>>>>>>Define RDW_NOINTERNALPAINT     For |CI$0010
73988>>>>>>>>>Define RDW_NOERASE             For |CI$0020
73988>>>>>>>>>
73988>>>>>>>>>Define RDW_NOCHILDREN          For |CI$0040
73988>>>>>>>>>Define RDW_ALLCHILDREN         For |CI$0080
73988>>>>>>>>>
73988>>>>>>>>>Define RDW_UPDATENOW           For |CI$0100
73988>>>>>>>>>Define RDW_ERASENOW            For |CI$0200
73988>>>>>>>>>
73988>>>>>>>>>Define RDW_FRAME               For |CI$0400
73988>>>>>>>>>Define RDW_NOFRAME             For |CI$0800
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>Define COLORREF For DWord
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>// Is a command that allows to put a string into a structure
73988>>>>>>>>>// Usage: PUT_POINTER sName  pName  "String..."  to sBuff at TYPE.FIELD
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>Define LF_FACESIZE          For 32
73988>>>>>>>>>Define CODEMAXWNDCLASS      For "Scintilla" //"CodeSense" //"CodeMax"
73988>>>>>>>>>
73988>>>>>>>>>/////////////////////////////////////////////////////////////
73988>>>>>>>>>//
73988>>>>>>>>>// Constants
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>
73988>>>>>>>>>// maximum size (TCHARs) of text to find or replace
73988>>>>>>>>>Define CM_MAX_FINDREPL_TEXT          For 100
73988>>>>>>>>>// maximum MRU size in find and find/replace dialogs
73988>>>>>>>>>Define CM_FIND_REPLACE_MRU_MAX       For 10
73988>>>>>>>>>// required buffer size for pszMRUList argument CMSetFindReplaceMRUList() and CMGetFindReplaceMRUList()
73988>>>>>>>>>Define CM_FIND_REPLACE_MRU_BUFF_SIZE For ( ( CM_MAX_FINDREPL_TEXT + 1 ) * CM_FIND_REPLACE_MRU_MAX )
73988>>>>>>>>>// maximum number of keystroke macros supported by CodeMax
73988>>>>>>>>>Define CM_MAX_MACROS                 For 10
73988>>>>>>>>>// maximum size of command string returned in pszBuff param of CMGetCommandString() if bDescription is FALSE
73988>>>>>>>>>Define CM_MAX_CMD_STRING             For 50
73988>>>>>>>>>// maximum size of command string returned in pszBuff param of CMGetCommandString() if bDescription is TRUE
73988>>>>>>>>>Define CM_MAX_CMD_DESCRIPTION        For 100
73988>>>>>>>>>// maximum size of a language name set with CMRegisterLanguage
73988>>>>>>>>>Define CM_MAX_LANGUAGE_NAME          For 30
73988>>>>>>>>>// maximum tab size (characters)
73988>>>>>>>>>Define CM_MAX_TABSIZE                For 100
73988>>>>>>>>>// minimum tab size (characters)
73988>>>>>>>>>Define CM_MIN_TABSIZE                For 2
73988>>>>>>>>>// left margin width (pixels)
73988>>>>>>>>>Define CM_CXLEFTMARGIN               For 24
73988>>>>>>>>>// SVN // maximum CodeList tooltip text length
73988>>>>>>>>>Define CM_MAX_CODELIST_TIP                       For 128
73988>>>>>>>>>
73988>>>>>>>>>/////////////////////////////////////////////////////////////
73988>>>>>>>>>//
73988>>>>>>>>>// CMM_SETLINESTYLE style bits
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>Define CML_OWNERDRAW      For |CI$1      // Parent window should receive CMN_DRAWLINE notifications
73988>>>>>>>>>Define CML_NOTIFY_DEL     For |CI$2      // Parent window should receive CMN_DELETELINE notifications
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>/////////////////////////////////////////////////////////////
73988>>>>>>>>>//
73988>>>>>>>>>// Messages - CMM_xxxxxx
73988>>>>>>>>>// As long as they are listed then they have not yet been migrated to scintilla
73988>>>>>>>>>// If commented out then it means not in scintilla or it simply works so much different that I have not
73988>>>>>>>>>// made up my mind on how-to implement or migrate.
73988>>>>>>>>>//
73988>>>>>>>>>Define CMM_SETLANGUAGE                For ( WM_USER + 1600 )
73988>>>>>>>>>Define CMM_GETLANGUAGE                For ( WM_USER + 1601 )
73988>>>>>>>>>//Define CMM_ENABLECOLORSYNTAX          FOR ( WM_USER + 1610 )
73988>>>>>>>>>//Define CMM_ISCOLORSYNTAXENABLED       FOR ( WM_USER + 1620 )
73988>>>>>>>>>//Define CMM_SETCOLORS                  FOR ( WM_USER + 1630 )
73988>>>>>>>>>//Define CMM_GETCOLORS                  FOR ( WM_USER + 1640 )
73988>>>>>>>>>Define CMM_ENABLEWHITESPACEDISPLAY    For ( WM_USER + 1800 )
73988>>>>>>>>>Define CMM_ISWHITESPACEDISPLAYENABLED For ( WM_USER + 1810 )
73988>>>>>>>>>Define CMM_ENABLETABEXPAND            For ( WM_USER + 1811 )
73988>>>>>>>>>Define CMM_ISTABEXPANDENABLED         For ( WM_USER + 1812 )
73988>>>>>>>>>//Define CMM_ENABLESMOOTHSCROLLING      FOR ( WM_USER + 1820 )
73988>>>>>>>>>//Define CMM_ISSMOOTHSCROLLINGENABLED   FOR ( WM_USER + 1830 )
73988>>>>>>>>>//Define CMM_ENABLELINETOOLTIPS         FOR ( WM_USER + 1860 )
73988>>>>>>>>>//Define CMM_ISLINETOOLTIPSENABLED      FOR ( WM_USER + 1870 )
73988>>>>>>>>>Define CMM_ENABLELEFTMARGIN           For ( WM_USER + 1880 )
73988>>>>>>>>>Define CMM_ISLEFTMARGINENABLED        For ( WM_USER + 1890 )
73988>>>>>>>>>Define CMM_ENABLECOLUMNSEL            For ( WM_USER + 1891 )
73988>>>>>>>>>Define CMM_ISCOLUMNSELENABLED         For ( WM_USER + 1892 )
73988>>>>>>>>>Define CMM_ENABLEDRAGDROP             For ( WM_USER + 1893 )
73988>>>>>>>>>Define CMM_ISDRAGDROPENABLED          For ( WM_USER + 1894 )
73988>>>>>>>>>//Define CMM_SETTOPINDEX                FOR ( WM_USER + 1960 )
73988>>>>>>>>>//Define CMM_GETTOPINDEX                FOR ( WM_USER + 1970 )
73988>>>>>>>>>Define CMM_GETVISIBLELINECOUNT        For ( WM_USER + 1980 )
73988>>>>>>>>>Define CMM_HITTEST                    For ( WM_USER + 1990 )
73988>>>>>>>>>Define CMM_INSERTFILE                 For ( WM_USER + 2320 )
73988>>>>>>>>>Define CMM_INSERTTEXT                 For ( WM_USER + 2330 )
73988>>>>>>>>>Define CMM_REPLACETEXT                For ( WM_USER + 2340 )
73988>>>>>>>>>Define CMM_GETWORDLENGTH              For ( WM_USER + 2382 )
73988>>>>>>>>>Define CMM_GETSEL                     For ( WM_USER + 2420 )
73988>>>>>>>>>Define CMM_GETSELFROMPOINT            For ( WM_USER + 2425 )
73988>>>>>>>>>Define CMM_SETSEL                     For ( WM_USER + 2430 )
73988>>>>>>>>>Define CMM_DELETESEL                  For ( WM_USER + 2440 )
73988>>>>>>>>>Define CMM_REPLACESEL                 For ( WM_USER + 2450 )
73988>>>>>>>>>Define CMM_SETMODIFIED                For ( WM_USER + 2461 )
73988>>>>>>>>>Define CMM_ENABLECRLF                 For ( WM_USER + 2470 )
73988>>>>>>>>>Define CMM_ISCRLFENABLED              For ( WM_USER + 2480 )
73988>>>>>>>>>//Define CMM_SETFONTOWNERSHIP           FOR ( WM_USER + 2485 )
73988>>>>>>>>>//Define CMM_GETFONTOWNERSHIP           FOR ( WM_USER + 2486 )
73988>>>>>>>>>Define CMM_EXECUTECMD                 For ( WM_USER + 2700 )
73988>>>>>>>>>//Define CMM_SETSPLITTERPOS             FOR ( WM_USER + 2900 )
73988>>>>>>>>>//Define CMM_GETSPLITTERPOS             FOR ( WM_USER + 2901 )
73988>>>>>>>>>Define CMM_GETVIEWCOUNT               For ( WM_USER + 3600 )
73988>>>>>>>>>Define CMM_GETCURRENTVIEW             For ( WM_USER + 3610 )
73988>>>>>>>>>//Define CMM_ENABLESPLITTER             FOR ( WM_USER + 3720 )
73988>>>>>>>>>//Define CMM_ISSPLITTERENABLED          FOR ( WM_USER + 3730 )
73988>>>>>>>>>Define CMM_ISRECORDINGMACRO           For ( WM_USER + 3731 )
73988>>>>>>>>>Define CMM_ISPLAYINGMACRO             For ( WM_USER + 3732 )
73988>>>>>>>>>Define CMM_ENABLEGLOBALPROPS          For ( WM_USER + 3740 )
73988>>>>>>>>>Define CMM_ISGLOBALPROPSENABLED       For ( WM_USER + 3741 )
73988>>>>>>>>>Define CMM_SETDLGPARENT               For ( WM_USER + 3750 )
73988>>>>>>>>>
73988>>>>>>>>>// 2.0
73988>>>>>>>>>Define CMM_ENABLESELBOUNDS            For ( WM_USER + 3760 )
73988>>>>>>>>>Define CMM_ISSELBOUNDSENABLED         For ( WM_USER + 3770 )
73988>>>>>>>>>//Define CMM_SETFONTSTYLES              FOR ( WM_USER + 3780 )
73988>>>>>>>>>//Define CMM_GETFONTSTYLES              FOR ( WM_USER + 3790 )
73988>>>>>>>>>Define CMM_ENABLEREGEXP               For ( WM_USER + 3800 )
73988>>>>>>>>>Define CMM_ISREGEXPENABLED            For ( WM_USER + 3810 )
73988>>>>>>>>>Define CMM_SETITEMDATA                For ( WM_USER + 3820 )
73988>>>>>>>>>Define CMM_GETITEMDATA                For ( WM_USER + 3830 )
73988>>>>>>>>>Define CMM_SETLINESTYLE               For ( WM_USER + 3840 )
73988>>>>>>>>>Define CMM_GETLINESTYLE               For ( WM_USER + 3850 )
73988>>>>>>>>>Define CMM_SETBOOKMARK                For ( WM_USER + 3860 )
73988>>>>>>>>>Define CMM_GETBOOKMARK                For ( WM_USER + 3870 )
73988>>>>>>>>>Define CMM_SETALLBOOKMARKS            For ( WM_USER + 3880 )
73988>>>>>>>>>Define CMM_GETALLBOOKMARKS            For ( WM_USER + 3890 )
73988>>>>>>>>>Define CMM_POSFROMCHAR                For ( WM_USER + 3920 )
73988>>>>>>>>>Define CMM_ENABLEHIDESEL              For ( WM_USER + 3930 )
73988>>>>>>>>>Define CMM_ISHIDESELENABLED           For ( WM_USER + 3940 )
73988>>>>>>>>>Define CMM_ENABLENORMALIZECASE        For ( WM_USER + 3970 )
73988>>>>>>>>>Define CMM_ISNORMALIZECASEENABLED     For ( WM_USER + 3980 )
73988>>>>>>>>>Define CMM_SETDIVIDER                 For ( WM_USER + 3990 )
73988>>>>>>>>>Define CMM_GETDIVIDER                 For ( WM_USER + 4000 )
73988>>>>>>>>>Define CMM_SETFINDTEXT                For ( WM_USER + 4030 )
73988>>>>>>>>>Define CMM_GETFINDTEXT                For ( WM_USER + 4040 )
73988>>>>>>>>>Define CMM_SETREPLACETEXT             For ( WM_USER + 4050 )
73988>>>>>>>>>Define CMM_GETREPLACETEXT             For ( WM_USER + 4060 )
73988>>>>>>>>>Define CMM_SETIMAGELIST               For ( WM_USER + 4070 )
73988>>>>>>>>>Define CMM_GETIMAGELIST               For ( WM_USER + 4080 )
73988>>>>>>>>>Define CMM_SETMARGINIMAGES            For ( WM_USER + 4090 )
73988>>>>>>>>>Define CMM_GETMARGINIMAGES            For ( WM_USER + 4100 )
73988>>>>>>>>>Define CMM_ABOUTBOX                   For ( WM_USER + 4110 )
73988>>>>>>>>>Define CMM_PRINT                      For ( WM_USER + 4120 )
73988>>>>>>>>>Define CMM_SETCARETPOS                For ( WM_USER + 4130 )
73988>>>>>>>>>Define CMM_VIEWCOLTOBUFFERCOL         For ( WM_USER + 4140 )
73988>>>>>>>>>Define CMM_BUFFERCOLTOVIEWCOL         For ( WM_USER + 4150 )
73988>>>>>>>>>
73988>>>>>>>>>// 2.1
73988>>>>>>>>>Define CMM_SETBORDERSTYLE             For ( WM_USER + 4160 )
73988>>>>>>>>>Define CMM_GETBORDERSTYLE             For ( WM_USER + 4170 )
73988>>>>>>>>>// SVN
73988>>>>>>>>>Define CMM_SETCURRENTVIEW             For ( WM_USER + 4180 )
73988>>>>>>>>>
73988>>>>>>>>>Define CMM_GETCURRENTTOKEN            For ( WM_USER + 5000 )
73988>>>>>>>>>Define CMM_UPDATECONTROLPOSITIONS     For ( WM_USER + 5010 )
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>// Extensions for Oem/Ansi support
73988>>>>>>>>>Define CMM_ENABLEOEMCODE              For ( WM_USER + 4300 )
73988>>>>>>>>>Define CMM_ISOEMCODEENABLED           For ( WM_USER + 4301 )
73988>>>>>>>>>
73988>>>>>>>>>/////////////////////////////////////////////////////////////
73988>>>>>>>>>//
73988>>>>>>>>>// Edit commands
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>
73988>>>>>>>>>Define CMD_FIRST                       For 100
73988>>>>>>>>>Define CMD_WORDUPPERCASE               For ( CMD_FIRST + 0 )
73988>>>>>>>>>Define CMD_WORDTRANSPOSE               For ( CMD_FIRST + 1 )
73988>>>>>>>>>Define CMD_WORDRIGHTEXTEND             For ( CMD_FIRST + 2 )
73988>>>>>>>>>Define CMD_WORDRIGHT                   For ( CMD_FIRST + 3 )
73988>>>>>>>>>Define CMD_WORDENDRIGHT                For ( CMD_FIRST + 4 )
73988>>>>>>>>>Define CMD_WORDENDRIGHTEXTEND          For ( CMD_FIRST + 5 )
73988>>>>>>>>>Define CMD_WORDLOWERCASE               For ( CMD_FIRST + 6 )
73988>>>>>>>>>Define CMD_WORDLEFTEXTEND              For ( CMD_FIRST + 7 )
73988>>>>>>>>>Define CMD_WORDLEFT                    For ( CMD_FIRST + 8 )
73988>>>>>>>>>Define CMD_WORDENDLEFT                 For ( CMD_FIRST + 9 )
73988>>>>>>>>>Define CMD_WORDENDLEFTEXTEND           For ( CMD_FIRST + 10 )
73988>>>>>>>>>Define CMD_WORDDELETETOSTART           For ( CMD_FIRST + 11 )
73988>>>>>>>>>Define CMD_WORDDELETETOEND             For ( CMD_FIRST + 12 )
73988>>>>>>>>>Define CMD_WORDCAPITALIZE              For ( CMD_FIRST + 13 )
73988>>>>>>>>>Define CMD_WINDOWSTART                 For ( CMD_FIRST + 14 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLUP              For ( CMD_FIRST + 15 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLTOTOP           For ( CMD_FIRST + 16 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLTOCENTER        For ( CMD_FIRST + 17 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLTOBOTTOM        For ( CMD_FIRST + 18 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLRIGHT           For ( CMD_FIRST + 19 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLLEFT            For ( CMD_FIRST + 20 )
73988>>>>>>>>>Define CMD_WINDOWSCROLLDOWN            For ( CMD_FIRST + 21 )
73988>>>>>>>>>Define CMD_WINDOWRIGHTEDGE             For ( CMD_FIRST + 22 )
73988>>>>>>>>>Define CMD_WINDOWLEFTEDGE              For ( CMD_FIRST + 23 )
73988>>>>>>>>>Define CMD_WINDOWEND                   For ( CMD_FIRST + 24 )
73988>>>>>>>>>Define CMD_UPPERCASESELECTION          For ( CMD_FIRST + 25 )
73988>>>>>>>>>Define CMD_UNTABIFYSELECTION           For ( CMD_FIRST + 26 )
73988>>>>>>>>>Define CMD_UNINDENTSELECTION           For ( CMD_FIRST + 27 )
73988>>>>>>>>>Define CMD_UNDOCHANGES                 For ( CMD_FIRST + 28 )
73988>>>>>>>>>Define CMD_UNDO                        For ( CMD_FIRST + 29 )
73988>>>>>>>>>Define CMD_TABIFYSELECTION             For ( CMD_FIRST + 30 )
73988>>>>>>>>>Define CMD_SENTENCERIGHT               For ( CMD_FIRST + 31 )
73988>>>>>>>>>Define CMD_SENTENCELEFT                For ( CMD_FIRST + 32 )
73988>>>>>>>>>Define CMD_SENTENCECUT                 For ( CMD_FIRST + 33 )
73988>>>>>>>>>Define CMD_SELECTSWAPANCHOR            For ( CMD_FIRST + 34 )
73988>>>>>>>>>Define CMD_SELECTPARA                  For ( CMD_FIRST + 35 )
73988>>>>>>>>>Define CMD_SELECTLINE                  For ( CMD_FIRST + 36 )
73988>>>>>>>>>Define CMD_SELECTALL                   For ( CMD_FIRST + 37 )
73988>>>>>>>>>Define CMD_REDOCHANGES                 For ( CMD_FIRST + 38 )
73988>>>>>>>>>Define CMD_REDO                        For ( CMD_FIRST + 39 )
73988>>>>>>>>>Define CMD_PASTE                       For ( CMD_FIRST + 40 )
73988>>>>>>>>>Define CMD_PARAUP                      For ( CMD_FIRST + 41 )
73988>>>>>>>>>Define CMD_PARADOWN                    For ( CMD_FIRST + 42 )
73988>>>>>>>>>Define CMD_PAGEUPEXTEND                For ( CMD_FIRST + 43 )
73988>>>>>>>>>Define CMD_PAGEUP                      For ( CMD_FIRST + 44 )
73988>>>>>>>>>Define CMD_PAGEDOWNEXTEND              For ( CMD_FIRST + 45 )
73988>>>>>>>>>Define CMD_PAGEDOWN                    For ( CMD_FIRST + 46 )
73988>>>>>>>>>Define CMD_LOWERCASESELECTION          For ( CMD_FIRST + 47 )
73988>>>>>>>>>Define CMD_LINEUPEXTEND                For ( CMD_FIRST + 48 )
73988>>>>>>>>>Define CMD_LINEUP                      For ( CMD_FIRST + 49 )
73988>>>>>>>>>Define CMD_LINETRANSPOSE               For ( CMD_FIRST + 50 )
73988>>>>>>>>>Define CMD_LINESTART                   For ( CMD_FIRST + 51 )
73988>>>>>>>>>Define CMD_LINEOPENBELOW               For ( CMD_FIRST + 52 )
73988>>>>>>>>>Define CMD_LINEOPENABOVE               For ( CMD_FIRST + 53 )
73988>>>>>>>>>Define CMD_LINEENDEXTEND               For ( CMD_FIRST + 54 )
73988>>>>>>>>>Define CMD_LINEEND                     For ( CMD_FIRST + 55 )
73988>>>>>>>>>Define CMD_LINEDOWNEXTEND              For ( CMD_FIRST + 56 )
73988>>>>>>>>>Define CMD_LINEDOWN                    For ( CMD_FIRST + 57 )
73988>>>>>>>>>Define CMD_LINEDELETETOSTART           For ( CMD_FIRST + 58 )
73988>>>>>>>>>Define CMD_LINEDELETETOEND             For ( CMD_FIRST + 59 )
73988>>>>>>>>>Define CMD_LINEDELETE                  For ( CMD_FIRST + 60 )
73988>>>>>>>>>Define CMD_LINECUT                     For ( CMD_FIRST + 61 )
73988>>>>>>>>>Define CMD_INDENTTOPREV                For ( CMD_FIRST + 62 )
73988>>>>>>>>>Define CMD_INDENTSELECTION             For ( CMD_FIRST + 63 )
73988>>>>>>>>>Define CMD_HOMEEXTEND                  For ( CMD_FIRST + 64 )
73988>>>>>>>>>Define CMD_HOME                        For ( CMD_FIRST + 65 )
73988>>>>>>>>>Define CMD_GOTOMATCHBRACE              For ( CMD_FIRST + 66 )
73988>>>>>>>>>Define CMD_GOTOINDENTATION             For ( CMD_FIRST + 67 )
73988>>>>>>>>>Define CMD_GOTOLINE                    For ( CMD_FIRST + 68 )
73988>>>>>>>>>Define CMD_FINDREPLACE                 For ( CMD_FIRST + 69 )
73988>>>>>>>>>Define CMD_REPLACE                     For ( CMD_FIRST + 70 )
73988>>>>>>>>>Define CMD_REPLACEALLINBUFFER          For ( CMD_FIRST + 71 )
73988>>>>>>>>>Define CMD_REPLACEALLINSELECTION       For ( CMD_FIRST + 72 )
73988>>>>>>>>>Define CMD_FINDPREVWORD                For ( CMD_FIRST + 73 )
73988>>>>>>>>>Define CMD_FINDPREV                    For ( CMD_FIRST + 74 )
73988>>>>>>>>>Define CMD_FINDNEXTWORD                For ( CMD_FIRST + 75 )
73988>>>>>>>>>Define CMD_FINDNEXT                    For ( CMD_FIRST + 76 )
73988>>>>>>>>>Define CMD_FINDMARKALL                 For ( CMD_FIRST + 77 )
73988>>>>>>>>>Define CMD_FIND                        For ( CMD_FIRST + 78 )
73988>>>>>>>>>Define CMD_SETFINDTEXT                 For ( CMD_FIRST + 79 )
73988>>>>>>>>>Define CMD_SETREPLACETEXT              For ( CMD_FIRST + 80 )
73988>>>>>>>>>Define CMD_TOGGLEPRESERVECASE          For ( CMD_FIRST + 81 )
73988>>>>>>>>>Define CMD_TOGGLEWHOLEWORD             For ( CMD_FIRST + 82 )
73988>>>>>>>>>Define CMD_TOGGLECASESENSITIVE         For ( CMD_FIRST + 83 )
73988>>>>>>>>>Define CMD_END                         For ( CMD_FIRST + 84 )
73988>>>>>>>>>Define CMD_TOGGLEWHITESPACEDISPLAY     For ( CMD_FIRST + 85 )
73988>>>>>>>>>Define CMD_TOGGLEOVERTYPE              For ( CMD_FIRST + 86 )
73988>>>>>>>>>Define CMD_SETREPEATCOUNT              For ( CMD_FIRST + 87 )
73988>>>>>>>>>Define CMD_DOCUMENTSTARTEXTEND         For ( CMD_FIRST + 88 )
73988>>>>>>>>>Define CMD_DOCUMENTSTART               For ( CMD_FIRST + 89 )
73988>>>>>>>>>Define CMD_DOCUMENTENDEXTEND           For ( CMD_FIRST + 90 )
73988>>>>>>>>>Define CMD_DOCUMENTEND                 For ( CMD_FIRST + 91 )
73988>>>>>>>>>Define CMD_DELETEHORIZONTALSPACE       For ( CMD_FIRST + 92 )
73988>>>>>>>>>Define CMD_DELETEBLANKLINES            For ( CMD_FIRST + 93 )
73988>>>>>>>>>Define CMD_DELETEBACK                  For ( CMD_FIRST + 94 )
73988>>>>>>>>>Define CMD_DELETE                      For ( CMD_FIRST + 95 )
73988>>>>>>>>>Define CMD_CUTSELECTION                For ( CMD_FIRST + 96 )
73988>>>>>>>>>Define CMD_CUT                         For ( CMD_FIRST + 97 )
73988>>>>>>>>>Define CMD_COPY                        For ( CMD_FIRST + 98 )
73988>>>>>>>>>Define CMD_CHARTRANSPOSE               For ( CMD_FIRST + 99 )
73988>>>>>>>>>Define CMD_CHARRIGHTEXTEND             For ( CMD_FIRST + 100 )
73988>>>>>>>>>Define CMD_CHARRIGHT                   For ( CMD_FIRST + 101 )
73988>>>>>>>>>Define CMD_CHARLEFTEXTEND              For ( CMD_FIRST + 102 )
73988>>>>>>>>>Define CMD_CHARLEFT                    For ( CMD_FIRST + 103 )
73988>>>>>>>>>Define CMD_BOOKMARKTOGGLE              For ( CMD_FIRST + 104 )
73988>>>>>>>>>Define CMD_BOOKMARKPREV                For ( CMD_FIRST + 105 )
73988>>>>>>>>>Define CMD_BOOKMARKNEXT                For ( CMD_FIRST + 106 )
73988>>>>>>>>>Define CMD_BOOKMARKCLEARALL            For ( CMD_FIRST + 107 )
73988>>>>>>>>>Define CMD_BOOKMARKJUMPTOFIRST         For ( CMD_FIRST + 108 )
73988>>>>>>>>>Define CMD_BOOKMARKJUMPTOLAST          For ( CMD_FIRST + 109 )
73988>>>>>>>>>Define CMD_APPENDNEXTCUT               For ( CMD_FIRST + 110 )
73988>>>>>>>>>Define CMD_INSERTCHAR                  For ( CMD_FIRST + 111 )
73988>>>>>>>>>Define CMD_NEWLINE                     For ( CMD_FIRST + 112 )
73988>>>>>>>>>Define CMD_RECORDMACRO                 For ( CMD_FIRST + 113 )
73988>>>>>>>>>Define CMD_PLAYMACRO1                  For ( CMD_FIRST + 114 )
73988>>>>>>>>>Define CMD_PLAYMACRO2                  For ( CMD_FIRST + 115 )
73988>>>>>>>>>Define CMD_PLAYMACRO3                  For ( CMD_FIRST + 116 )
73988>>>>>>>>>Define CMD_PLAYMACRO4                  For ( CMD_FIRST + 117 )
73988>>>>>>>>>Define CMD_PLAYMACRO5                  For ( CMD_FIRST + 118 )
73988>>>>>>>>>Define CMD_PLAYMACRO6                  For ( CMD_FIRST + 119 )
73988>>>>>>>>>Define CMD_PLAYMACRO7                  For ( CMD_FIRST + 120 )
73988>>>>>>>>>Define CMD_PLAYMACRO8                  For ( CMD_FIRST + 121 )
73988>>>>>>>>>Define CMD_PLAYMACRO9                  For ( CMD_FIRST + 122 )
73988>>>>>>>>>Define CMD_PLAYMACRO10                 For ( CMD_FIRST + 123 )
73988>>>>>>>>>Define CMD_PROPERTIES                  For ( CMD_FIRST + 124 )
73988>>>>>>>>>Define CMD_BEGINUNDO                   For ( CMD_FIRST + 125 )
73988>>>>>>>>>Define CMD_ENDUNDO                     For ( CMD_FIRST + 126 )
73988>>>>>>>>>Define CMD_RESERVED3                   For ( CMD_FIRST + 127 )  // internal use only
73988>>>>>>>>>// 2.0
73988>>>>>>>>>Define CMD_TOGGLEREGEXP                For ( CMD_FIRST + 128 )
73988>>>>>>>>>Define CMD_CLEARSELECTION              For ( CMD_FIRST + 129 )
73988>>>>>>>>>Define CMD_REGEXPON                    For ( CMD_FIRST + 130 )
73988>>>>>>>>>Define CMD_REGEXPOFF                   For ( CMD_FIRST + 131 )
73988>>>>>>>>>Define CMD_WHOLEWORDON                 For ( CMD_FIRST + 132 )
73988>>>>>>>>>Define CMD_WHOLEWORDOFF                For ( CMD_FIRST + 133 )
73988>>>>>>>>>Define CMD_PRESERVECASEON              For ( CMD_FIRST + 134 )
73988>>>>>>>>>Define CMD_PRESERVECASEOFF             For ( CMD_FIRST + 135 )
73988>>>>>>>>>Define CMD_CASESENSITIVEON             For ( CMD_FIRST + 136 )
73988>>>>>>>>>Define CMD_CASESENSITIVEOFF            For ( CMD_FIRST + 137 )
73988>>>>>>>>>Define CMD_WHITESPACEDISPLAYON         For ( CMD_FIRST + 138 )
73988>>>>>>>>>Define CMD_WHITESPACEDISPLAYOFF        For ( CMD_FIRST + 139 )
73988>>>>>>>>>Define CMD_OVERTYPEON                  For ( CMD_FIRST + 140 )
73988>>>>>>>>>Define CMD_OVERTYPEOFF                 For ( CMD_FIRST + 141 )
73988>>>>>>>>>// SVN
73988>>>>>>>>>//Define CMD_LAST                        For ( CMD_FIRST + 141 )
73988>>>>>>>>>// 2.1
73988>>>>>>>>>Define CMD_CODELIST                    For ( CMD_FIRST + 142 )
73988>>>>>>>>>Define CMD_CODETIP                     For ( CMD_FIRST + 143 )
73988>>>>>>>>>Define CMD_LAST                        For ( CMD_FIRST + 143 )
73988>>>>>>>>>
73988>>>>>>>>>// all register commands must be at or higher than CMD_USER_BASE
73988>>>>>>>>>Define CMD_USER_BASE                   For ( CMD_FIRST + 900 )
73988>>>>>>>>>
73988>>>>>>>>>Define CMDERR_FAILURE     For 1     // general failure
73988>>>>>>>>>Define CMDERR_INPUT       For 2     // bad input
73988>>>>>>>>>Define CMDERR_SELECTION   For 3     // bad selection
73988>>>>>>>>>Define CMDERR_NOTFOUND    For 4     // data not found
73988>>>>>>>>>Define CMDERR_EMPTYBUF    For 5     // buffer is empty
73988>>>>>>>>>Define CMDERR_READONLY    For 6     // buffer is read-only
73988>>>>>>>>>
73988>>>>>>>>>////////////////////////////////////////////////////////////////////////////////////////
73988>>>>>>>>>//
73988>>>>>>>>>// Language Support for CMM_SETLANGUAGE, RegisterLanguage(), and UnregisterLanguage()
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>
73988>>>>>>>>>// stock languages
73988>>>>>>>>>Define CMLANG_CPP         For "C/C++"
73988>>>>>>>>>Define CMLANG_PASCAL      For "Pascal"
73988>>>>>>>>>Define CMLANG_BASIC       For "Basic"
73988>>>>>>>>>Define CMLANG_SQL         For "SQL"
73988>>>>>>>>>Define CMLANG_JAVA        For "Java"
73988>>>>>>>>>Define CMLANG_HTML        For "HTML"
73988>>>>>>>>>Define CMLANG_XML         For "XML"
73988>>>>>>>>>
73988>>>>>>>>>//// language styles
73988>>>>>>>>>//Define CMLS_PROCEDURAL    FOR 0
73988>>>>>>>>>//Define CMLS_SGML          FOR 1
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>//TYPE CM_LANGUAGE
73988>>>>>>>>>//    Field CM_LANGUAGE.dwStyle                             as Dword    // One of the CMLS_ values DWORD
73988>>>>>>>>>//    Field CM_LANGUAGE.bIsCaseSensitive                    as Integer  // TRUE if keywords are case sensitive BOOL
73988>>>>>>>>>//    Field CM_LANGUAGE.pszKeywords                         as Pointer  // The keywords delimited by '\n' LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszOperators                        as Pointer  // The operators delimited by '\n' LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszSingleLineComments               as Pointer  // The single line comment tokens (e.g. "//") LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszMultiLineComments1               as Pointer  // The multiline comment start tokens (e.g. "/*\n{\n(*") LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszMultiLineComments2               as Pointer  // The multiline comment end tokens (e.g. "*/\n}\n*)") LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszScopeKeywords1                   as Pointer  // The scoping start tokens (e.g. "{\nbegin") LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszScopeKeywords2                   as Pointer  // The multiline comment end tokens (e.g. "}\nend") LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszStringDelims                     as Pointer  // The string literal delimiters (e.g. "\"\n'") -- also includes character literals LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.chEscape                            as Char 1   // The escape character TCHAR
73988>>>>>>>>>//    Field CM_LANGUAGE.chTerminator                        as Char 1   // The statement terminator char (usually ';') TCHAR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszTagElementNames                  as Pointer  // Tag-based element names delimited by '\n' LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszTagAttributeNames                as Pointer  // Tag-based attribute names delimited by '\n' LPCTSTR
73988>>>>>>>>>//    Field CM_LANGUAGE.pszTagEntities                      as Pointer  // Tag-based entities delimited by '\n' LPCTSTR
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>//
73988>>>>>>>>>//// Color settings for CMM_GETCOLORS and CMM_SETCOLORS
73988>>>>>>>>>////
73988>>>>>>>>>//// Note:  Use CLR_INVALID on background colors to specify transparent
73988>>>>>>>>>////        (text) or appropriate control panel setting
73988>>>>>>>>>//TYPE CM_COLORS
73988>>>>>>>>>//    Field CM_COLORS.crWindow                            as COLORREF // window background color
73988>>>>>>>>>//    Field CM_COLORS.crLeftMargin                        as COLORREF // left margin background color
73988>>>>>>>>>//    Field CM_COLORS.crBookmark                          as COLORREF // bookmark foreground color
73988>>>>>>>>>//    Field CM_COLORS.crBookmarkBk                        as COLORREF // bookmark background color
73988>>>>>>>>>//    Field CM_COLORS.crText                              as COLORREF // plain text foreground color
73988>>>>>>>>>//    Field CM_COLORS.crTextBk                            as COLORREF // plain text background color
73988>>>>>>>>>//    Field CM_COLORS.crNumber                            as COLORREF // numeric literal foreground color
73988>>>>>>>>>//    Field CM_COLORS.crNumberBk                          as COLORREF // numeric literal background color
73988>>>>>>>>>//    Field CM_COLORS.crKeyword                           as COLORREF // keyword foreground color
73988>>>>>>>>>//    Field CM_COLORS.crKeywordBk                         as COLORREF // keyword background color
73988>>>>>>>>>//    Field CM_COLORS.crOperator                          as COLORREF // operator foreground color
73988>>>>>>>>>//    Field CM_COLORS.crOperatorBk                        as COLORREF // operator background color
73988>>>>>>>>>//    Field CM_COLORS.crScopeKeyword                      as COLORREF // scope keyword foreground color
73988>>>>>>>>>//    Field CM_COLORS.crScopeKeywordBk                    as COLORREF // scope keyword background color
73988>>>>>>>>>//    Field CM_COLORS.crComment                           as COLORREF // comment foreground color
73988>>>>>>>>>//    Field CM_COLORS.crCommentBk                         as COLORREF // comment background color
73988>>>>>>>>>//    Field CM_COLORS.crString                            as COLORREF // string foreground color
73988>>>>>>>>>//    Field CM_COLORS.crStringBk                          as COLORREF // string background color
73988>>>>>>>>>//    Field CM_COLORS.crTagText                           as COLORREF // plain tag text foreground color
73988>>>>>>>>>//    Field CM_COLORS.crTagTextBk                         as COLORREF // plain tag text background color
73988>>>>>>>>>//    Field CM_COLORS.crTagEntity                         as COLORREF // tag entity foreground color
73988>>>>>>>>>//    Field CM_COLORS.crTagEntityBk                       as COLORREF // tag entity background color
73988>>>>>>>>>//    Field CM_COLORS.crTagElementName                    as COLORREF // tag element name foreground color
73988>>>>>>>>>//    Field CM_COLORS.crTagElementNameBk                  as COLORREF // tag element name background color
73988>>>>>>>>>//    Field CM_COLORS.crTagAttributeName                  as COLORREF // tag attribute name foreground color
73988>>>>>>>>>//    Field CM_COLORS.crTagAttributeNameBk                as COLORREF // tag attribute name background color
73988>>>>>>>>>//    Field CM_COLORS.crLineNumber                        as COLORREF // line number foreground color
73988>>>>>>>>>//    Field CM_COLORS.crLineNumberBk                      as COLORREF // line number background color
73988>>>>>>>>>//    Field CM_COLORS.crHDividerLines                     as COLORREF // line number separate line color
73988>>>>>>>>>//    Field CM_COLORS.crVDividerLines                     as COLORREF // left margin separate line color
73988>>>>>>>>>//    Field CM_COLORS.crHighlightedLine                   as COLORREF // highlighted line color
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// Font style settings for CMM_GETFONTSTYLES and CMM_SETFONTSTYLES
73988>>>>>>>>>//// each byte value is one of the CM_FONT_XXX values listed below
73988>>>>>>>>>//// this declaration
73988>>>>>>>>>////
73988>>>>>>>>>//TYPE CM_FONTSTYLES
73988>>>>>>>>>//    Field CM_FONTSTYLES.byText                              as Char 1   // plain text font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byNumber                            as Char 1   // numeric literal font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byKeyword                           as Char 1   // keyword font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byOperator                          as Char 1   // operator font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byScopeKeyword                      as Char 1   // scope keyword font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byComment                           as Char 1   // comment font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byString                            as Char 1   // string font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byTagText                           as Char 1   // plain tag text font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byTagEntity                         as Char 1   // tag entity font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byTagElementName                    as Char 1   // tag element name font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byTagAttributeName                  as Char 1   // tag attribute name font style BYTE
73988>>>>>>>>>//    Field CM_FONTSTYLES.byLineNumber                        as Char 1   // line number font style BYTE
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// Font style options used in CM_FONTSTYLES
73988>>>>>>>>>////
73988>>>>>>>>>////
73988>>>>>>>>>//Define CM_FONT_NORMAL     For 0   // normal weight
73988>>>>>>>>>//Define CM_FONT_BOLD       For 1   // bold weight
73988>>>>>>>>>//Define CM_FONT_ITALIC     For 2   // normal weight, italic
73988>>>>>>>>>//Define CM_FONT_BOLDITALIC For 3   // bold weight, italic
73988>>>>>>>>>//Define CM_FONT_UNDERLINE  For 4   // normal weight, underline
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>// AutoIndent options
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>Define CM_INDENT_OFF        For  0    // auto-indent off -- new line begins at column 0
73988>>>>>>>>>Define CM_INDENT_SCOPE      For  1    // NOT SUPPORTED
73988>>>>>>>>>Define CM_INDENT_PREVLINE   For  2    // new line has identical indentation of previous line
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// Print option flags used with CMM_PRINT
73988>>>>>>>>>////
73988>>>>>>>>>////
73988>>>>>>>>>//Define CM_PRINT_PROMPTDLG    For |CI$000   // display the print common dialog
73988>>>>>>>>>//Define CM_PRINT_DEFAULTPRN   For |CI$001   // use default printer (no print dialog displayed)
73988>>>>>>>>>//Define CM_PRINT_HDC          For |CI$002   // use HDC provided
73988>>>>>>>>>//Define CM_PRINT_RICHFONTS    For |CI$004   // use bold, italics, underline, etc. when appropriate
73988>>>>>>>>>//Define CM_PRINT_COLOR        For |CI$008   // print in color
73988>>>>>>>>>//Define CM_PRINT_PAGENUMS     For |CI$010   // print 'page # of #' at the bottom of the page
73988>>>>>>>>>//Define CM_PRINT_DATETIME     For |CI$020   // print date and time at top of the page
73988>>>>>>>>>//Define CM_PRINT_BORDERTHIN   For |CI$040   // surround text with a thin border
73988>>>>>>>>>//Define CM_PRINT_BORDERTHICK  For |CI$080   // surround text with a thick border
73988>>>>>>>>>//Define CM_PRINT_BORDERDOUBLE For |CI$100   // surround text with two thin borders
73988>>>>>>>>>//Define CM_PRINT_SELECTION    For |CI$200   // print the selection rather than entire edit contents
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// Border option flags used with CMM_GETBORDERSTYLE and CMM_SETBORDERSTYLE.
73988>>>>>>>>>//// Note: this values may be or'd together to achieve different effects.
73988>>>>>>>>>////
73988>>>>>>>>>//Define CM_BORDER_NONE        For |CI$0  // no border
73988>>>>>>>>>//Define CM_BORDER_THIN        For |CI$1  // 1-pixel border
73988>>>>>>>>>//Define CM_BORDER_CLIENT      For |CI$2  // client edge (WS_EX_CLIENTEDGE)
73988>>>>>>>>>//Define CM_BORDER_STATIC      For |CI$4  // static edge (WS_EX_STATICEDGE)
73988>>>>>>>>>//Define CM_BORDER_MODAL       For |CI$8  // modal edge (WS_EX_DLGMODALFRAME)
73988>>>>>>>>>//Define CM_BORDER_CORRAL      For (CM_BORDER_MODAL Ior CM_BORDER_CLIENT)
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// Text position indicators
73988>>>>>>>>>////
73988>>>>>>>>>////
73988>>>>>>>>>//
73988>>>>>>>>>//Type CM_POSITION
73988>>>>>>>>>//  Field CM_POSITION.nLine                as Integer  // zero-based line number int
73988>>>>>>>>>//  Field CM_POSITION.nCol                 as Integer  // zero-based *buffer* column number int
73988>>>>>>>>>//End_Type
73988>>>>>>>>>//
73988>>>>>>>>>//// Erzeugt einen String und eine Pointer variable, wenn diese noch nicht definiert sind!
73988>>>>>>>>>//// Fueltt mit Line und Col und holt die Addresse in the Pointer
73988>>>>>>>>>//#COMMAND Local_CM_POSITION R R "LINE=" R "COL=" R
73988>>>>>>>>>//    DEFINE_STR_PTR !1 !2
73988>>>>>>>>>//    ZeroType CM_POSITION  To !1         // as a little insurance
73988>>>>>>>>>//    Put !4 To !1 At CM_POSITION.nLine   // Set Line
73988>>>>>>>>>//    Put !6 To !1 At CM_POSITION.nCol    // Set Column
73988>>>>>>>>>//    GetAddress Of !1 To !2
73988>>>>>>>>>//#ENDCOMMAND
73988>>>>>>>>>//
73988>>>>>>>>>//
73988>>>>>>>>>//    // Erzeugt einen String und eine Pointer variable, wenn diese noch nicht definiert sind!
73988>>>>>>>>>//    // Fueltt mit Line und Col und holt die Addresse in the Pointer
73988>>>>>>>>>//
73988>>>>>>>>>//TYPE CM_RANGE
73988>>>>>>>>>//    Field CM_RANGE.posStart             as Char CM_POSITION_SIZE    // the anchor CM_POSITION
73988>>>>>>>>>//    Field CM_RANGE.posEnd               as Char CM_POSITION_SIZE    // the extension (if same as anchor, selection is empty) CM_POSITION
73988>>>>>>>>>//    Field CM_RANGE.bColumnSel           as Integer                  // TRUE if is a column selection, FALSE if paragragh selection BOOL
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>//
73988>>>>>>>>>//#COMMAND Local_CM_RANGE R R "START=" R  R "END=" R R
73988>>>>>>>>>//    DEFINE_STR_PTR !1 !2
73988>>>>>>>>>//    Zerotype CM_RANGE   to !1
73988>>>>>>>>>//
73988>>>>>>>>>//    Local_CM_POSITION sPosStart psPosStart LINE= !4 COL= !5   // Create a String with the StartPosition
73988>>>>>>>>>//    Local_CM_POSITION sPosEnd   psPosEnd   LINE= !7 COL= !8   // Create a String with the EndPosition
73988>>>>>>>>>//
73988>>>>>>>>>//    PUT_STRING sPosStart to !1 AT CM_RANGE.posStart           // Set Start Position
73988>>>>>>>>>//    PUT_STRING sPosEnd   to !1 AT CM_RANGE.posEnd             // Set End Position
73988>>>>>>>>>//
73988>>>>>>>>>//    GetAddress Of !1     to !2                                // Get the Address of the created Structure
73988>>>>>>>>>//#ENDCOMMAND
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// Hot key descriptor
73988>>>>>>>>>////
73988>>>>>>>>>////
73988>>>>>>>>>//TYPE CM_HOTKEY
73988>>>>>>>>>//    Field CM_HOTKEY.byModifiers1         as Integer //Char 1   // 1st keystroke's modifiers (combination of HOTKEYF_ALT, HOTKEYF_SHIFT, HOTKEYF_CONTROL) BYTE
73988>>>>>>>>>//    Field CM_HOTKEY.nVirtKey1            as Integer  // 1st keystroke's virtkey (e.g. Ctrl + 'A') UINT
73988>>>>>>>>>//    Field CM_HOTKEY.byModifiers2         as Integer //Char 1   // 2nd keystroke's modifiers (combination of HOTKEYF_ALT, HOTKEYF_SHIFT, HOTKEYF_CONTROL) BYTE
73988>>>>>>>>>//    Field CM_HOTKEY.nVirtKey2            as Integer  // 2nd keystroke's virtkey (e.g. Ctrl + 'A') UINT
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>
73988>>>>>>>>>//
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// CMN_CMDFAILURE notification data passed to parent window
73988>>>>>>>>>////
73988>>>>>>>>>////
73988>>>>>>>>>//TYPE CM_CMDFAILUREDATA
73988>>>>>>>>>//    Field CM_CMDFAILUREDATA.hdr                  as Char NMHDR_SIZE // standard notification data NMHDR
73988>>>>>>>>>//    Field CM_CMDFAILUREDATA.wCmd                 as WORD            // CMD_XXX command that failed WORD
73988>>>>>>>>>//    Field CM_CMDFAILUREDATA.dwErr                as Dword           // CMDERR_XXX failure code DWORD
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>
73988>>>>>>>>>
73988>>>>>>>>>///////////////////////////////////////////////////////////////
73988>>>>>>>>>////
73988>>>>>>>>>//// CMN_KEYDOWN, CMN_KEYUP, CMN_KEYPRESS notification
73988>>>>>>>>>//// data passed to parent window
73988>>>>>>>>>////
73988>>>>>>>>>////
73988>>>>>>>>>Define CM_KEY_NOEXT      For |CI$0
73988>>>>>>>>>Define CM_KEY_SHIFT      For |CI$1
73988>>>>>>>>>Define CM_KEY_CTRL       For |CI$2
73988>>>>>>>>>Define CM_KEY_ALT        For |CI$4
73988>>>>>>>>>//TYPE CM_KEYDATA
73988>>>>>>>>>//    Field CM_KEYDATA.hdr                  as Char NMHDR_SIZE    // standard notification data NMHDR
73988>>>>>>>>>//    Field CM_KEYDATA.nKeyCode             as Integer            // virtkey if CMN_KEYUP or CMN_KEYDOWN.  Ascii code if CMN_KEYPRESS int
73988>>>>>>>>>//    Field CM_KEYDATA.nKeyModifier         as Integer            // bitfield of: CM_KEY_SHIFT, CM_KEY_CTRL, and/or CM_KEY_ALT int
73988>>>>>>>>>//END_TYPE
73988>>>>>>>>>
73988>>>>>>>>>// Just converts the ID to the name.
73988>>>>>>>>>Function CMKeymodifierIDToName Global Integer iModifier Returns String
73990>>>>>>>>>  String sRet
73990>>>>>>>>>  If (iModifier Iand CM_KEY_SHIFT) ;    Append sRet (If(sRet Eq "","","+")) "Shift"
73994>>>>>>>>>  If (iModifier Iand CM_KEY_CTRL) ;    Append sRet (If(sRet Eq "","","+")) "Ctrl"
73998>>>>>>>>>  If (iModifier Iand CM_KEY_ALT) ;    Append sRet (If(sRet Eq "","","+")) "Alt"
74002>>>>>>>>>  Function_Return sRet
74003>>>>>>>>>End_Function
74004>>>>>>>>>
74004>>>>>>>>>///////////////////////////////////////////////////////////////
74004>>>>>>>>>////
74004>>>>>>>>>//// CMN_MOUSEDOWN, CMN_MOUSEUP, CMN_MOUSEPRESS notification
74004>>>>>>>>>//// data passed to parent window
74004>>>>>>>>>////
74004>>>>>>>>>////
74004>>>>>>>>>//Define CM_BTN_LEFT      For |CI$1
74004>>>>>>>>>//Define CM_BTN_RIGHT     For |CI$2
74004>>>>>>>>>//Define CM_BTN_MIDDLE    For |CI$4
74004>>>>>>>>>//
74004>>>>>>>>>//TYPE CM_MOUSEDATA
74004>>>>>>>>>//    Field CM_MOUSEDATA.hdr                  as Char NMHDR_SIZE  // standard notification data NMHDR
74004>>>>>>>>>//    Field CM_MOUSEDATA.pt                   as Char tPOINT_SIZE // position of mouse (client coordinates) POINT
74004>>>>>>>>>//    Field CM_MOUSEDATA.nButton              as Integer  // bitfield of: CM_BTN_LEFT, CM_BTN_RIGHT, and/or CM_BTN_MIDDLE int
74004>>>>>>>>>//    Field CM_MOUSEDATA.nKeyModifier         as Integer  // bitfield of: CM_KEY_SHIFT, CM_KEY_CTRL, and/or CM_KEY_ALT int
74004>>>>>>>>>//END_TYPE
74004>>>>>>>>>//
74004>>>>>>>>>///////////////////////////////////////////////////////////////
74004>>>>>>>>>////
74004>>>>>>>>>//// CMN_FINDWRAPPED notification data passed to parent window
74004>>>>>>>>>////
74004>>>>>>>>>////
74004>>>>>>>>>//TYPE CM_FINDWRAPPEDDATA
74004>>>>>>>>>//    Field CM_FINDWRAPPEDDATA.hdr                  as Char NMHDR_SIZE // standard notification data NMHDR
74004>>>>>>>>>//    Field CM_FINDWRAPPEDDATA.wCmd                 as WORD     // the command being executed WORD
74004>>>>>>>>>//    Field CM_FINDWRAPPEDDATA.bForward             as Integer  // TRUE if wrapped while searching forward, FALSE if searching backward BOOL
74004>>>>>>>>>//END_TYPE
74004>>>>>>>>>
74004>>>>>>>>>///////////////////////////////////////////////////////////////
74004>>>>>>>>>////
74004>>>>>>>>>//// Tooltip window styles specified as return value from
74004>>>>>>>>>//// CMN_CODETIP notifications
74004>>>>>>>>>////
74004>>>>>>>>>//Define CM_TIPSTYLE_NONE                                   For 0       // don't display a tooltip
74004>>>>>>>>>//Define CM_TIPSTYLE_NORMAL                               For 1 // standard tooltip window
74004>>>>>>>>>//Define CM_TIPSTYLE_HIGHLIGHT                  for 2   // tooltip with text highlighting
74004>>>>>>>>>//Define CM_TIPSTYLE_FUNCHIGHLIGHT      for 3   // tooltip with function highlighting
74004>>>>>>>>>//Define CM_TIPSTYLE_MULTIFUNC                  for 4   // highlighting for multiple functions
74004>>>>>>>>>
74004>>>>>>>>>Define C_TIPTYPE_UNDEFINED        For 0
74004>>>>>>>>>Define C_TIPTYPE_EXPRESSION       For 1
74004>>>>>>>>>Define C_TIPTYPE_FUNCTION         For 2
74004>>>>>>>>>Define C_TIPTYPE_PROCEDURE        For 3
74004>>>>>>>>>//
74004>>>>>>>>>//
74004>>>>>>>>>//// -----------------------------------------------------------------------------------------
74004>>>>>>>>>//// END - SVN
74004>>>>>>>>>//
74004>>>>>>>>>
74004>>>>>>>>>/////////////////////////////////////////////////////////////
74004>>>>>>>>>//
74004>>>>>>>>>// data passed to CMM_SETLINENUMBERING
74004>>>>>>>>>//
74004>>>>>>>>>//
74004>>>>>>>>>Define CM_BINARY            For 2  // not supported
74004>>>>>>>>>Define CM_OCTAL             For 8  // not supported
74004>>>>>>>>>Define CM_DECIMAL           For 10
74004>>>>>>>>>Define CM_HEXADECIMAL       For 16 // not supported
74004>>>>>>>>>
74004>>>>>>>>>
74004>>>>>>>>>/////////////////////////////////////////////////////////////
74004>>>>>>>>>//
74004>>>>>>>>>// Error codes
74004>>>>>>>>>//
74004>>>>>>>>>//
74004>>>>>>>>>//typedef LRESULT CME_CODE;
74004>>>>>>>>>
74004>>>>>>>>>Define CME_SUCCESS        For 1        // function or method completed successfully
74004>>>>>>>>>Define CME_FAILURE        For 0        // function or method did not complete because of an error
74004>>>>>>>>>Define CME_BADARGUMENT    For -1       // function or method did not complete because an invalid argument was passed in
74004>>>>>>>>>
74004>>>>>>>>>/////////////////////////////////////////////////////////////
74004>>>>>>>>>//
74004>>>>>>>>>// CMM_HITTEST return codes
74004>>>>>>>>>//
74004>>>>>>>>>//
74004>>>>>>>>>
74004>>>>>>>>>Define CM_NOWHERE        For 0        // Not over the CodeMax control
74004>>>>>>>>>Define CM_HSPLITTER      For 1        // Over the horizontal splitter bar
74004>>>>>>>>>Define CM_VSPLITTER      For 2        // Over the vertical splitter bar
74004>>>>>>>>>Define CM_HVSPLITTER     For 3        // Over the intersection of the horizontal and vertical splitter bar
74004>>>>>>>>>Define CM_EDITSPACE      For 4        // Over the buffer contents (code)
74004>>>>>>>>>Define CM_HSCROLLBAR     For 5        // Over the horizontal scrollbar
74004>>>>>>>>>Define CM_VSCROLLBAR     For 6        // Over the vertical scrollbar
74004>>>>>>>>>Define CM_SIZEBOX        For 7        // Over the sizebox visible when both scrollbars are visible
74004>>>>>>>>>Define CM_LEFTMARGIN     For 8        // Over the left margin area
74004>>>>>>>>>
74004>>>>>>>>>
74004>>>>>>>>>/////////////////////////////////////////////////////////////
74004>>>>>>>>>//
74004>>>>>>>>>// CMM_GETCURRENTTOKEN return codes
74004>>>>>>>>>//
74004>>>>>>>>>//
74004>>>>>>>>>
74004>>>>>>>>>Define CM_TOKENTYPE_KEYWORD                                     For |CI$1 // 0x01
74004>>>>>>>>>Define CM_TOKENTYPE_OPERATOR                            For |CI$2 //0x02
74004>>>>>>>>>Define CM_TOKENTYPE_STRING                                      For |CI$3 //0x03
74004>>>>>>>>>Define CM_TOKENTYPE_SINGLELINECOMMENT           For |CI$4 //0x04
74004>>>>>>>>>Define CM_TOKENTYPE_MULTILINECOMMENT            For |CI$5 //0x05
74004>>>>>>>>>Define CM_TOKENTYPE_NUMBER                                      For |CI$6 //0x06
74004>>>>>>>>>Define CM_TOKENTYPE_SCOPEBEGIN                          For |CI$7 //0x07
74004>>>>>>>>>Define CM_TOKENTYPE_SCOPEEND                            For |CI$8 //0x08
74004>>>>>>>>>Define CM_TOKENTYPE_TEXT                                        For |CI$FF //0xff
74004>>>>>>>>>Define CM_TOKENTYPE_LAST                    For |CI$FFFFFFFF
74004>>>>>>>>>Define CM_TOKENTYPE_UNKNOWN                                     For (CM_TOKENTYPE_LAST-1) //(DWORD)-1
74004>>>>>>>>>
74004>>>>>>>>>
74004>>>>>>>>>/////////////////////////////////////////////////////////////
74004>>>>>>>>>//
74004>>>>>>>>>// Exported functions
74004>>>>>>>>>//
74004>>>>>>>>>//
74004>>>>>>>>>
74004>>>>>>>>>Define SCLEX_NULL                       For 1
74004>>>>>>>>>Define SCLEX_PYTHON                     For 2
74004>>>>>>>>>Define SCLEX_CPP                        For 3
74004>>>>>>>>>Define SCLEX_HTML                       For 4
74004>>>>>>>>>Define SCLEX_XML                        For 5
74004>>>>>>>>>Define SCLEX_PERL                       For 6
74004>>>>>>>>>Define SCLEX_SQL                        For 7
74004>>>>>>>>>Define SCLEX_VB                         For 8
74004>>>>>>>>>Define SCLEX_PROPERTIES                 For 9
74004>>>>>>>>>Define SCLEX_PASCAL                     For 18
74004>>>>>>>>>Define SCLEX_PHPSCRIPT                  For 69
74004>>>>>>>>>Define SCLEX_DATAFLEX                   For 129
74004>>>>>>>>>
74004>>>>>>>>>Define SCE_NOTUSED                      For -1
74004>>>>>>>>>
74004>>>>>>>>>// Text
74004>>>>>>>>>Define SCE_TEXT_DEFAULT                 For 0
74004>>>>>>>>>
74004>>>>>>>>>// DataFlex
74004>>>>>>>>>Define SCE_DF_DEFAULT                   For 0
74004>>>>>>>>>Define SCE_DF_IDENTIFIER                For 1
74004>>>>>>>>>Define SCE_DF_METATAG                   For 2
74004>>>>>>>>>Define SCE_DF_IMAGE                     For 3
74004>>>>>>>>>Define SCE_DF_COMMENTLINE               For 4
74004>>>>>>>>>Define SCE_DF_PREPROCESSOR              For 5
74004>>>>>>>>>Define SCE_DF_PREPROCESSOR2             For 6
74004>>>>>>>>>Define SCE_DF_NUMBER                    For 7
74004>>>>>>>>>Define SCE_DF_HEXNUMBER                 For 8
74004>>>>>>>>>Define SCE_DF_WORD                      For 9
74004>>>>>>>>>Define SCE_DF_STRING                    For 10
74004>>>>>>>>>Define SCE_DF_STRINGEOL                 For 11
74004>>>>>>>>>Define SCE_DF_SCOPEWORD                 For 12
74004>>>>>>>>>Define SCE_DF_OPERATOR                  For 13
74004>>>>>>>>>Define SCE_DF_ICODE                     For 14
74004>>>>>>>>>
74004>>>>>>>>>// C/C++
74004>>>>>>>>>Define SCE_C_DEFAULT                    For 0
74004>>>>>>>>>Define SCE_C_COMMENT                    For 1
74004>>>>>>>>>Define SCE_C_COMMENTLINE                For 2
74004>>>>>>>>>Define SCE_C_COMMENTDOC                 For 3
74004>>>>>>>>>Define SCE_C_NUMBER                     For 4
74004>>>>>>>>>Define SCE_C_WORD                       For 5
74004>>>>>>>>>Define SCE_C_STRING                     For 6
74004>>>>>>>>>Define SCE_C_CHARACTER                  For 7
74004>>>>>>>>>Define SCE_C_UUID                       For 8
74004>>>>>>>>>Define SCE_C_PREPROCESSOR               For 9
74004>>>>>>>>>Define SCE_C_OPERATOR                   For 10
74004>>>>>>>>>Define SCE_C_IDENTIFIER                 For 11
74004>>>>>>>>>Define SCE_C_STRINGEOL                  For 12
74004>>>>>>>>>Define SCE_C_VERBATIM                   For 13
74004>>>>>>>>>Define SCE_C_REGEX                      For 14
74004>>>>>>>>>Define SCE_C_COMMENTLINEDOC             For 15
74004>>>>>>>>>Define SCE_C_WORD2                      For 16
74004>>>>>>>>>Define SCE_C_COMMENTDOCKEYWORD          For 17
74004>>>>>>>>>Define SCE_C_COMMENTDOCKEYWORDERROR     For 18
74004>>>>>>>>>Define SCE_C_GLOBALCLASS                For 19
74004>>>>>>>>>Define SCE_C_STRINGRAW                  For 20
74004>>>>>>>>>Define SCE_C_TRIPLEVERBATIM             For 21
74004>>>>>>>>>Define SCE_C_HASHQUOTEDSTRING           For 22
74004>>>>>>>>>Define SCE_C_PREPROCESSORCOMMENT        For 23
74004>>>>>>>>>Define SCE_C_PREPROCESSORCOMMENTDOC     For 24
74004>>>>>>>>>Define SCE_C_USERLITERAL                For 25
74004>>>>>>>>>Define SCE_C_TASKMARKER                 For 26
74004>>>>>>>>>Define SCE_C_ESCAPESEQUENCE             For 27
74004>>>>>>>>>
74004>>>>>>>>>// Pascal
74004>>>>>>>>>Define SCE_PAS_DEFAULT                  For 0
74004>>>>>>>>>Define SCE_PAS_IDENTIFIER               For 1
74004>>>>>>>>>Define SCE_PAS_COMMENT                  For 2
74004>>>>>>>>>Define SCE_PAS_COMMENT2                 For 3
74004>>>>>>>>>Define SCE_PAS_COMMENTLINE              For 4
74004>>>>>>>>>Define SCE_PAS_PREPROCESSOR             For 5
74004>>>>>>>>>Define SCE_PAS_PREPROCESSOR2            For 6
74004>>>>>>>>>Define SCE_PAS_NUMBER                   For 7
74004>>>>>>>>>Define SCE_PAS_HEXNUMBER                For 8
74004>>>>>>>>>Define SCE_PAS_WORD                     For 9
74004>>>>>>>>>Define SCE_PAS_STRING                   For 10
74004>>>>>>>>>Define SCE_PAS_STRINGEOL                For 11
74004>>>>>>>>>Define SCE_PAS_CHARACTER                For 12
74004>>>>>>>>>Define SCE_PAS_OPERATOR                 For 13
74004>>>>>>>>>Define SCE_PAS_ASM                      For 14
74004>>>>>>>>>
74004>>>>>>>>>// Html/XML/PHP
74004>>>>>>>>>Define SCE_H_DEFAULT                    For 0
74004>>>>>>>>>Define SCE_H_TAG                        For 1
74004>>>>>>>>>Define SCE_H_TAGUNKNOWN                 For 2
74004>>>>>>>>>Define SCE_H_ATTRIBUTE                  For 3
74004>>>>>>>>>Define SCE_H_ATTRIBUTEUNKNOWN           For 4
74004>>>>>>>>>Define SCE_H_NUMBER                     For 5
74004>>>>>>>>>Define SCE_H_DOUBLESTRING               For 6
74004>>>>>>>>>Define SCE_H_SINGLESTRING               For 7
74004>>>>>>>>>Define SCE_H_OTHER                      For 8
74004>>>>>>>>>Define SCE_H_COMMENT                    For 9
74004>>>>>>>>>Define SCE_H_ENTITY                     For 10
74004>>>>>>>>>Define SCE_H_TAGEND                     For 11
74004>>>>>>>>>Define SCE_H_XMLSTART                   For 12
74004>>>>>>>>>Define SCE_H_XMLEND                     For 13
74004>>>>>>>>>Define SCE_H_SCRIPT                     For 14
74004>>>>>>>>>Define SCE_H_ASP                        For 15
74004>>>>>>>>>Define SCE_H_ASPAT                      For 16
74004>>>>>>>>>Define SCE_H_CDATA                      For 17
74004>>>>>>>>>Define SCE_H_QUESTION                   For 18
74004>>>>>>>>>Define SCE_H_VALUE                      For 19
74004>>>>>>>>>Define SCE_H_XCCOMMENT                  For 20
74004>>>>>>>>>Define SCE_H_SGML_DEFAULT               For 21
74004>>>>>>>>>Define SCE_H_SGML_COMMAND               For 22
74004>>>>>>>>>Define SCE_H_SGML_1ST_PARAM             For 23
74004>>>>>>>>>Define SCE_H_SGML_DOUBLESTRING          For 24
74004>>>>>>>>>Define SCE_H_SGML_SIMPLESTRING          For 25
74004>>>>>>>>>Define SCE_H_SGML_ERROR                 For 26
74004>>>>>>>>>Define SCE_H_SGML_SPECIAL               For 27
74004>>>>>>>>>Define SCE_H_SGML_ENTITY                For 28
74004>>>>>>>>>Define SCE_H_SGML_COMMENT               For 29
74004>>>>>>>>>Define SCE_H_SGML_1ST_PARAM_COMMENT     For 30
74004>>>>>>>>>Define SCE_H_SGML_BLOCK_DEFAULT         For 31
74004>>>>>>>>>Define SCE_HJ_START                     For 40
74004>>>>>>>>>Define SCE_HJ_DEFAULT                   For 41
74004>>>>>>>>>Define SCE_HJ_COMMENT                   For 42
74004>>>>>>>>>Define SCE_HJ_COMMENTLINE               For 43
74004>>>>>>>>>Define SCE_HJ_COMMENTDOC                For 44
74004>>>>>>>>>Define SCE_HJ_NUMBER                    For 45
74004>>>>>>>>>Define SCE_HJ_WORD                      For 46
74004>>>>>>>>>Define SCE_HJ_KEYWORD                   For 47
74004>>>>>>>>>Define SCE_HJ_DOUBLESTRING              For 48
74004>>>>>>>>>Define SCE_HJ_SINGLESTRING              For 49
74004>>>>>>>>>Define SCE_HJ_SYMBOLS                   For 50
74004>>>>>>>>>Define SCE_HJ_STRINGEOL                 For 51
74004>>>>>>>>>Define SCE_HJ_REGEX                     For 52
74004>>>>>>>>>Define SCE_HJA_START                    For 55
74004>>>>>>>>>Define SCE_HJA_DEFAULT                  For 56
74004>>>>>>>>>Define SCE_HJA_COMMENT                  For 57
74004>>>>>>>>>Define SCE_HJA_COMMENTLINE              For 58
74004>>>>>>>>>Define SCE_HJA_COMMENTDOC               For 59
74004>>>>>>>>>Define SCE_HJA_NUMBER                   For 60
74004>>>>>>>>>Define SCE_HJA_WORD                     For 61
74004>>>>>>>>>Define SCE_HJA_KEYWORD                  For 62
74004>>>>>>>>>Define SCE_HJA_DOUBLESTRING             For 63
74004>>>>>>>>>Define SCE_HJA_SINGLESTRING             For 64
74004>>>>>>>>>Define SCE_HJA_SYMBOLS                  For 65
74004>>>>>>>>>Define SCE_HJA_STRINGEOL                For 66
74004>>>>>>>>>Define SCE_HJA_REGEX                    For 67
74004>>>>>>>>>Define SCE_HB_START                     For 70
74004>>>>>>>>>Define SCE_HB_DEFAULT                   For 71
74004>>>>>>>>>Define SCE_HB_COMMENTLINE               For 72
74004>>>>>>>>>Define SCE_HB_NUMBER                    For 73
74004>>>>>>>>>Define SCE_HB_WORD                      For 74
74004>>>>>>>>>Define SCE_HB_STRING                    For 75
74004>>>>>>>>>Define SCE_HB_IDENTIFIER                For 76
74004>>>>>>>>>Define SCE_HB_STRINGEOL                 For 77
74004>>>>>>>>>Define SCE_HBA_START                    For 80
74004>>>>>>>>>Define SCE_HBA_DEFAULT                  For 81
74004>>>>>>>>>Define SCE_HBA_COMMENTLINE              For 82
74004>>>>>>>>>Define SCE_HBA_NUMBER                   For 83
74004>>>>>>>>>Define SCE_HBA_WORD                     For 84
74004>>>>>>>>>Define SCE_HBA_STRING                   For 85
74004>>>>>>>>>Define SCE_HBA_IDENTIFIER               For 86
74004>>>>>>>>>Define SCE_HBA_STRINGEOL                For 87
74004>>>>>>>>>Define SCE_HP_START                     For 90
74004>>>>>>>>>Define SCE_HP_DEFAULT                   For 91
74004>>>>>>>>>Define SCE_HP_COMMENTLINE               For 92
74004>>>>>>>>>Define SCE_HP_NUMBER                    For 93
74004>>>>>>>>>Define SCE_HP_STRING                    For 94
74004>>>>>>>>>Define SCE_HP_CHARACTER                 For 95
74004>>>>>>>>>Define SCE_HP_WORD                      For 96
74004>>>>>>>>>Define SCE_HP_TRIPLE                    For 97
74004>>>>>>>>>Define SCE_HP_TRIPLEDOUBLE              For 98
74004>>>>>>>>>Define SCE_HP_CLASSNAME                 For 99
74004>>>>>>>>>Define SCE_HP_DEFNAME                   For 100
74004>>>>>>>>>Define SCE_HP_OPERATOR                  For 101
74004>>>>>>>>>Define SCE_HP_IDENTIFIER                For 102
74004>>>>>>>>>Define SCE_HPHP_COMPLEX_VARIABLE        For 104
74004>>>>>>>>>Define SCE_HPA_START                    For 105
74004>>>>>>>>>Define SCE_HPA_DEFAULT                  For 106
74004>>>>>>>>>Define SCE_HPA_COMMENTLINE              For 107
74004>>>>>>>>>Define SCE_HPA_NUMBER                   For 108
74004>>>>>>>>>Define SCE_HPA_STRING                   For 109
74004>>>>>>>>>Define SCE_HPA_CHARACTER                For 110
74004>>>>>>>>>Define SCE_HPA_WORD                     For 111
74004>>>>>>>>>Define SCE_HPA_TRIPLE                   For 112
74004>>>>>>>>>Define SCE_HPA_TRIPLEDOUBLE             For 113
74004>>>>>>>>>Define SCE_HPA_CLASSNAME                For 114
74004>>>>>>>>>Define SCE_HPA_DEFNAME                  For 115
74004>>>>>>>>>Define SCE_HPA_OPERATOR                 For 116
74004>>>>>>>>>Define SCE_HPA_IDENTIFIER               For 117
74004>>>>>>>>>Define SCE_HPHP_DEFAULT                 For 118
74004>>>>>>>>>Define SCE_HPHP_HSTRING                 For 119
74004>>>>>>>>>Define SCE_HPHP_SIMPLESTRING            For 120
74004>>>>>>>>>Define SCE_HPHP_WORD                    For 121
74004>>>>>>>>>Define SCE_HPHP_NUMBER                  For 122
74004>>>>>>>>>Define SCE_HPHP_VARIABLE                For 123
74004>>>>>>>>>Define SCE_HPHP_COMMENT                 For 124
74004>>>>>>>>>Define SCE_HPHP_COMMENTLINE             For 125
74004>>>>>>>>>Define SCE_HPHP_HSTRING_VARIABLE        For 126
74004>>>>>>>>>Define SCE_HPHP_OPERATOR                For 127
74004>>>>>>>>>
74004>>>>>>>>>// SQL
74004>>>>>>>>>Define SCE_SQL_DEFAULT                  For 0
74004>>>>>>>>>Define SCE_SQL_COMMENT                  For 1
74004>>>>>>>>>Define SCE_SQL_COMMENTLINE              For 2
74004>>>>>>>>>Define SCE_SQL_COMMENTDOC               For 3
74004>>>>>>>>>Define SCE_SQL_NUMBER                   For 4
74004>>>>>>>>>Define SCE_SQL_WORD                     For 5
74004>>>>>>>>>Define SCE_SQL_STRING                   For 6
74004>>>>>>>>>Define SCE_SQL_CHARACTER                For 7
74004>>>>>>>>>Define SCE_SQL_SQLPLUS                  For 8
74004>>>>>>>>>Define SCE_SQL_SQLPLUS_PROMPT           For 9
74004>>>>>>>>>Define SCE_SQL_OPERATOR                 For 10
74004>>>>>>>>>Define SCE_SQL_IDENTIFIER               For 11
74004>>>>>>>>>Define SCE_SQL_SQLPLUS_COMMENT          For 13
74004>>>>>>>>>Define SCE_SQL_COMMENTLINEDOC           For 15
74004>>>>>>>>>Define SCE_SQL_WORD2                    For 16
74004>>>>>>>>>Define SCE_SQL_COMMENTDOCKEYWORD        For 17
74004>>>>>>>>>Define SCE_SQL_COMMENTDOCKEYWORDERROR   For 18
74004>>>>>>>>>Define SCE_SQL_USER1                    For 19
74004>>>>>>>>>Define SCE_SQL_USER2                    For 20
74004>>>>>>>>>Define SCE_SQL_USER3                    For 21
74004>>>>>>>>>Define SCE_SQL_USER4                    For 22
74004>>>>>>>>>Define SCE_SQL_QUOTEDIDENTIFIER         For 23
74004>>>>>>>>>Define SCE_SQL_QOPERATOR                For 24
74004>>>>>>>>>
74004>>>>>>>>>// Properties
74004>>>>>>>>>Define SCE_PROPS_DEFAULT                For 0
74004>>>>>>>>>Define SCE_PROPS_COMMENT                For 1
74004>>>>>>>>>Define SCE_PROPS_SECTION                For 2
74004>>>>>>>>>Define SCE_PROPS_ASSIGNMENT             For 3
74004>>>>>>>>>Define SCE_PROPS_DEFVAL                 For 4
74004>>>>>>>>>Define SCE_PROPS_KEY                    For 5
74004>>>>>>>>>
74004>>>>>>>>>
74004>>>>>>>>>//Define MARGIN_SCRIPT_FOLD_INDEX For 1 // don't use this strange code word for "code folder margin" use below constants
74004>>>>>>>>>Define MARGIN_STATUS       For 0  // bookmarks, breakpoints, debug line pointer
74004>>>>>>>>>Define MARGIN_CHANGED_LINE For 1
74004>>>>>>>>>Define MARGIN_LINE_NUMBERS For 2
74004>>>>>>>>>Define MARGIN_CODE_FOLDING For 3
74004>>>>>>>>>
74004>>>>>>>>>
74004>>>>>>>>>Procedure DevTest String sMethod
74006>>>>>>>>>  //Send Info_box sMethod "DevTest"
74006>>>>>>>>>End_Procedure
74007>>>>>>>>>
74007>>>>>>>>>Function CMSetFindReplaceMRUList Global Pointer pszMRUList Integer bFind Returns Integer
74009>>>>>>>>>  Send DevTest "CMSetFindReplaceMRUList"
74010>>>>>>>>>  Function_Return 0
74011>>>>>>>>>End_Function
74012>>>>>>>>>Function CMGetFindReplaceMRUList Global Pointer pszMRUList Integer bFind Returns Integer
74014>>>>>>>>>  Send DevTest "CMGetFindReplaceMRUList"
74015>>>>>>>>>  Function_Return 0
74016>>>>>>>>>End_Function
74017>>>>>>>>>Function CMRegisterLanguage Global Pointer pszName Pointer pLang Returns Integer
74019>>>>>>>>>  Send DevTest "CMRegisterLanguage"
74020>>>>>>>>>  Function_Return 0
74021>>>>>>>>>End_Function
74022>>>>>>>>>Function CMUnregisterLanguage Global Pointer pszName Returns Integer
74024>>>>>>>>>  Send DevTest "CMUnregisterLanguage"
74025>>>>>>>>>  Function_Return 0
74026>>>>>>>>>End_Function
74027>>>>>>>>>Function CMGetMacro Global Integer nMacro Pointer pMacroBuff   Returns Integer
74029>>>>>>>>>  Send DevTest "CMGetMacro"
74030>>>>>>>>>  Function_Return 0
74031>>>>>>>>>End_Function
74032>>>>>>>>>Function CMSetMacro Global Integer nMacro Pointer pMacroBuff  Returns Integer
74034>>>>>>>>>  Send DevTest "CMSetMacro"
74035>>>>>>>>>  Function_Return 0
74036>>>>>>>>>End_Function
74037>>>>>>>>>
74037>>>>>>>>>// 2.0
74037>>>>>>>>>Function CMUnregisterAllLanguages Global  Returns Integer
74039>>>>>>>>>  Send DevTest "CMUnregisterAllLanguages"
74040>>>>>>>>>  Function_Return 0
74041>>>>>>>>>End_Function
74042>>>>>>>>>Function CMGetLanguageDef Global Pointer pszName Pointer pLang   Returns Integer
74044>>>>>>>>>  Send DevTest "CMGetLanguageDef"
74045>>>>>>>>>  Function_Return 0
74046>>>>>>>>>End_Function
74047>>>>>>>>>
74047>>>>>>>>>
74047>>>>>>>>>// Possible values for piFindWrapMode
74047>>>>>>>>>Define FindWrapMode_NoWrap      For 1
74047>>>>>>>>>Define FindWrapMode_NoWrapMsg   For 2
74047>>>>>>>>>Define FindWrapMode_WrapSilent  For 3
74047>>>>>>>>>Define FindWrapMode_WrapAsk     For 4
74047>>>>>>>>>
74047>>>>>>>>>
74047>>>>>>>Use mWinAPIGetKeyNameText.pkg   // Get a name for a virual keycode.
Including file: mWinAPIGetKeyNameText.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mWinAPIGetKeyNameText.pkg)
74047>>>>>>>>>//TH-Header
74047>>>>>>>>>//*****************************************************************************************
74047>>>>>>>>>// Copyright (c)  2001 Michael Kurz
74047>>>>>>>>>// All rights reserved.
74047>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
74047>>>>>>>>>//
74047>>>>>>>>>// $FileName    : mWinAPIGetKeyNameText.pkg
74047>>>>>>>>>// $ProjectName : Shared Methods
74047>>>>>>>>>// $Author      : Michael Kurz
74047>>>>>>>>>// $Created     : 01.05.2001  20:02
74047>>>>>>>>>//
74047>>>>>>>>>// Contents:
74047>>>>>>>>>//  -WinAPIGetKeyNameText integer iVirtualKeyCode returns string
74047>>>>>>>>>//
74047>>>>>>>>>//  Gets the name of a VK key code.
74047>>>>>>>>>//*****************************************************************************************
74047>>>>>>>>>//TH-RevisionStart
74047>>>>>>>>>//TH-RevisionEnd
74047>>>>>>>>>
74047>>>>>>>>>
74047>>>>>>>>>  External_Function GetKeyNameText "GetKeyNameTextA" User32.dll UInteger iKey Pointer pBuff Integer iSize Returns Integer
74048>>>>>>>>>
74048>>>>>>>>>// Retrieves the name of a key. (Virtual KeyCode)
74048>>>>>>>>>Function WinAPIGetKeyNameText Global Integer iKey Returns String
74050>>>>>>>>>  Integer iRet
74050>>>>>>>>>  String  sBuff
74050>>>>>>>>>  
74050>>>>>>>>>  Move (Repeat(Character(0),1024))  To sBuff
74051>>>>>>>>>  Move (MapVirtualKey(iKey,0))      To iKey
74052>>>>>>>>>  Move (iKey*65536)                 To iKey
74053>>>>>>>>>  Move (GetKeyNameText(iKey,AddressOf(sBuff),1024))  To iRet
74054>>>>>>>>>  If iRet Eq 0 ;    Move "" To sBuff
74057>>>>>>>>>  Else ;    Move (Cstring(sBuff)) To sBuff
74059>>>>>>>>>  Function_Return sBuff
74060>>>>>>>>>End_Function
74061>>>>>>>>>
74061>>>>>>>>>
74061>>>>>>>Use cSciLexerSupport.pkg
Including file: cSciLexerSupport.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexerSupport.pkg)
74061>>>>>>>>>//TH-Header
74061>>>>>>>>>//*****************************************************************************************
74061>>>>>>>>>// Copyright (c)  2018 Your Company Name
74061>>>>>>>>>// All rights reserved.
74061>>>>>>>>>//
74061>>>>>>>>>// $FileName    : SourceCodeTools\AppSrc\cSciLexerSupport.pkg
74061>>>>>>>>>// $ProjectName : DFRefactor
74061>>>>>>>>>// $Authors     :
74061>>>>>>>>>// $Created     : 28.07.2018  23:59
74061>>>>>>>>>//
74061>>>>>>>>>// Contents:
74061>>>>>>>>>//  Support module for the sciLexer control to use the sciLexer control outside of
74061>>>>>>>>>//  The Hammer project.
74061>>>>>>>>>//
74061>>>>>>>>>//*****************************************************************************************
74061>>>>>>>>>//TH-RevisionStart
74061>>>>>>>>>// ********************
74061>>>>>>>>>// MODIFICATION SUMMARY
74061>>>>>>>>>// ********************
74061>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
74061>>>>>>>>>//TH-RevisionEnd
74061>>>>>>>>>
74061>>>>>>>>>// No Code here for the Hammer itself
74061>>>>>>>Use TH3Workspace.pkg
Including file: TH3Workspace.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\TH3Workspace.pkg)
74061>>>>>>>>>// TH3Workspace.pkg
74061>>>>>>>>>// By Sergey V. Natarov
74061>>>>>>>>>// Created: 11/03/2017
74061>>>>>>>>>// This file defines TH3 Workspace (HWS extension)
74061>>>>>>>>>// HWS includes information about The Hammer Workspace
74061>>>>>>>>>// It is based on the Project workspace, but can be amended
74061>>>>>>>>>// by Developer
74061>>>>>>>>>
74061>>>>>>>>>Use TH3Workspace.h
Including file: TH3Workspace.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\TH3Workspace.h)
74061>>>>>>>>>>>// TH3Workspace.h
74061>>>>>>>>>>>// on 12/03/2017 by Sergey V. Natarov
74061>>>>>>>>>>>
74061>>>>>>>>>>>Use RegistryAPI.pkg
74061>>>>>>>>>>>
74061>>>>>>>>>>>Global_Variable Integer ghoToolsPane
74061>>>>>>>>>>>Global_Variable Integer ghoOutputPane
74061>>>>>>>>>>>Global_Variable Integer ghoOutputDialog
74061>>>>>>>>>>>Global_Variable Integer ghoEditorPopupMenu
74061>>>>>>>>>>>Global_Variable Integer ghoCurrentFileTab
74061>>>>>>>>>>>Global_Variable Integer ghoWorkspaceFilesTree
74061>>>>>>>>>>>  Global_Variable Integer ghoWorkSpaceHandlerEx
74061>>>>>>>>>>>
74061>>>>>>>>>>>Global_Variable Integer ghoCompilerInfo
74061>>>>>>>>>>>Global_Variable Integer ghoBuildMenu
74061>>>>>>>>>>>Global_Variable String gsTransferWSFile
74061>>>>>>>>>>>Global_Variable String gsTransferDDFile
74061>>>>>>>>>>>Global_Variable String[] gILanguage
74061>>>>>>>>>>>
74061>>>>>>>>>>>// The Hammer File Types
74061>>>>>>>>>>>Define KPH_FILE_EDITABLE For 0
74061>>>>>>>>>>>Define KPH_FILE_MENU     For 1
74061>>>>>>>>>>>Define KPH_FILE_FOLDER   For 2
74061>>>>>>>>>>>
74061>>>>>>>>>>>Struct tTHSource
74061>>>>>>>>>>>    String  sFile
74061>>>>>>>>>>>    String  sBookmarks
74061>>>>>>>>>>>    Integer iBookmarkCount
74061>>>>>>>>>>>    Integer iCursorLine
74061>>>>>>>>>>>    Integer iCursorColumn
74061>>>>>>>>>>>End_Struct
74061>>>>>>>>>>>
74061>>>>>>>>>>>Struct tTHWorkspace
74061>>>>>>>>>>>    String   sName
74061>>>>>>>>>>>    String   sSchema
74061>>>>>>>>>>>    Integer  iShowPaths
74061>>>>>>>>>>>    String   sFullName
74061>>>>>>>>>>>    String   sStudio
74061>>>>>>>>>>>    String   sCompiler
74061>>>>>>>>>>>    String   sDBEditor
74061>>>>>>>>>>>    String   sDBViewer
74061>>>>>>>>>>>    String   sFFText
74061>>>>>>>>>>>    String   sFFTypes
74061>>>>>>>>>>>    String   sFFPath
74061>>>>>>>>>>>    Integer  iFFMatchWord
74061>>>>>>>>>>>    Integer  iFFMatchCase
74061>>>>>>>>>>>    Integer  iFFSubFolders
74061>>>>>>>>>>>    Integer  iFFShowAll
74061>>>>>>>>>>>    Integer  iFFExcludeComments
74061>>>>>>>>>>>    Integer  iFFRegExp
74061>>>>>>>>>>>    String[] saFiles
74061>>>>>>>>>>>    String[] saFileDesc
74061>>>>>>>>>>>    String[] saFolders
74061>>>>>>>>>>>    String[] saExclude
74061>>>>>>>>>>>    String[] saOpened
74061>>>>>>>>>>>    tTHSource[] taSources
74061>>>>>>>>>>>    tTHSource[] taSources
74061>>>>>>>>>>>End_Struct
74061>>>>>>>>>>>
74061>>>>>>>>>>>Struct tTHCompiler
74061>>>>>>>>>>>    String sVersion
74061>>>>>>>>>>>    String sProgID
74061>>>>>>>>>>>    String sEventId
74061>>>>>>>>>>>    Handle hoCompiler
74061>>>>>>>>>>>End_Struct
74061>>>>>>>>>>>
74061>>>>>>>>>>>
74061>>>>>>>>>>>// Language Definition
74061>>>>>>>>>>>Struct tTHLanguage
74061>>>>>>>>>>>    String      sName
74061>>>>>>>>>>>    Integer     iProcedural
74061>>>>>>>>>>>    Integer     iCaseSensitive
74061>>>>>>>>>>>    String      sLineComments
74061>>>>>>>>>>>    String      sStringDelimiter
74061>>>>>>>>>>>    String      sMultiLineCommentStart
74061>>>>>>>>>>>    String      sMultiLineCommentStop
74061>>>>>>>>>>>    String      sEscapeChar
74061>>>>>>>>>>>    String      sLineTerminationChar
74061>>>>>>>>>>>    String      sMetaStart
74061>>>>>>>>>>>    String      sMetaStop
74061>>>>>>>>>>>    String[]    saScopeStart
74061>>>>>>>>>>>    String[]    saScopeStop
74061>>>>>>>>>>>    String[]    saKeywords
74061>>>>>>>>>>>    String[]    saOperators
74061>>>>>>>>>>>    String[]    saTags
74061>>>>>>>>>>>    String[]    saEntities
74061>>>>>>>>>>>    String[]    saAttributes
74061>>>>>>>>>>>End_Struct
74061>>>>>>>>>>>
74061>>>>>>>>>>>Struct tDFDefaultClasses
74061>>>>>>>>>>>    String sCategory
74061>>>>>>>>>>>    String sClass
74061>>>>>>>>>>>    String sFile
74061>>>>>>>>>>>End_Struct
74061>>>>>>>>>>>
74061>>>>>>>>>>>Define TH_SCHEMA_DATAFLEX   for "DataFlex"
74061>>>>>>>>>>>Define TH_SCHEMA_DELPHI     for "Delphi"
74061>>>>>>>>>>>Define TH_SCHEMA_CCPP       for "C/C++"
74061>>>>>>>>>>>Define TH_SCHEMA_PYTHON     for "Python"
74061>>>>>>>>>>>Define TH_SCHEMA_WEB        for "Web"
74061>>>>>>>>>>>Define TH_SCHEMA_OTHER      for "Other"
74061>>>>>>>>>>>
74061>>>>>>>>>>>
74061>>>>>>>>>>>Function UCharToSHORT Global UChar[] Buffer Returns Integer
74063>>>>>>>>>>>    Integer in1 in2
74063>>>>>>>>>>>    
74063>>>>>>>>>>>    Move 0 To in1
74064>>>>>>>>>>>    If (SizeOfArray(Buffer)=2) Begin
74066>>>>>>>>>>>      Move Buffer[0] To in1
74067>>>>>>>>>>>      Move Buffer[1] To in2
74068>>>>>>>>>>>      Move ( in1 + (in2*256) ) to in1
74069>>>>>>>>>>>      If (in2 > 127) ;          Move (in1 - 65536) to in1
74072>>>>>>>>>>>    End
74072>>>>>>>>>>>>
74072>>>>>>>>>>>    Function_Return in1
74073>>>>>>>>>>>End_Function
74074>>>>>>>>>>>
74074>>>>>>>>>>>
74074>>>>>>>>>>>Function UCharToDWORD Global UChar[] Buffer Returns Integer
74076>>>>>>>>>>>    Integer in1 in2 in3 in4
74076>>>>>>>>>>>    
74076>>>>>>>>>>>    Move 0 To in1
74077>>>>>>>>>>>    If (SizeOfArray(Buffer)=4) Begin
74079>>>>>>>>>>>      Move Buffer[0] To in1
74080>>>>>>>>>>>      Move Buffer[1] To in2
74081>>>>>>>>>>>      Move Buffer[2] To in3
74082>>>>>>>>>>>      Move Buffer[3] To in4
74083>>>>>>>>>>>      Move (in1 + (in2*256) + (in3*65536) + (in4*16777216)) to in1
74084>>>>>>>>>>>    End
74084>>>>>>>>>>>>
74084>>>>>>>>>>>    Function_Return in1
74085>>>>>>>>>>>End_Function
74086>>>>>>>>>>>
74086>>>>>>>>>>>Function DWORDtoUChar Global Integer aDWORD Returns UChar[]
74088>>>>>>>>>>>    UChar[] data
74089>>>>>>>>>>>    Move (low(aDWORD) iand 255) To data[0]
74090>>>>>>>>>>>    Move (low(aDWORD) / 256)    To data[1]
74091>>>>>>>>>>>    Move (hi(aDWORD) iand 255)  To data[2]
74092>>>>>>>>>>>    Move (hi(aDWORD) / 256)     To data[3]
74093>>>>>>>>>>>    Function_Return data
74094>>>>>>>>>>>End_Function
74095>>>>>>>>>>>
74095>>>>>>>>>>>Function SHORTtoUChar Global Integer aSHORT Returns UChar[]
74097>>>>>>>>>>>    UChar[] data
74098>>>>>>>>>>>    Move ( aSHORT iand 255) To data[0]
74099>>>>>>>>>>>    Move ( aSHORT / 256)    To data[1]
74100>>>>>>>>>>>    Function_Return data
74101>>>>>>>>>>>End_Function
74102>>>>>>>>>>>
74102>>>>>>>>>>>// Upto 256 chars
74102>>>>>>>>>>>Function WSReadStr1 Returns String
74104>>>>>>>>>>>    String  sValue
74104>>>>>>>>>>>    UChar   ucSize
74104>>>>>>>>>>>    Integer iSize
74104>>>>>>>>>>>    Read_Block ucSize 1
74105>>>>>>>>>>>    Move ucSize to iSize
74106>>>>>>>>>>>    If iSize ;        Read_Block sValue iSize
74109>>>>>>>>>>>    Function_Return sValue
74110>>>>>>>>>>>End_Function
74111>>>>>>>>>>>
74111>>>>>>>>>>>// Upto 65356 chars
74111>>>>>>>>>>>Function WSReadStr2 Returns String
74113>>>>>>>>>>>    String  sValue
74113>>>>>>>>>>>    UChar[] ucaSize
74114>>>>>>>>>>>    Integer iSize
74114>>>>>>>>>>>    Read_Block ucaSize 2
74115>>>>>>>>>>>    Move (UCharToSHORT(ucaSize)) to iSize
74116>>>>>>>>>>>    If iSize ;        Read_Block sValue iSize
74119>>>>>>>>>>>    Function_Return sValue
74120>>>>>>>>>>>End_Function
74121>>>>>>>>>>>
74121>>>>>>>>>>>// Upto 2G chars
74121>>>>>>>>>>>Function WSReadStr4 Returns String
74123>>>>>>>>>>>    String  sValue
74123>>>>>>>>>>>    UChar[] ucaSize
74124>>>>>>>>>>>    Integer iSize
74124>>>>>>>>>>>    Read_Block ucaSize 4
74125>>>>>>>>>>>    Move (UCharToDWORD(ucaSize)) to iSize
74126>>>>>>>>>>>    If iSize ;        Read_Block sValue iSize
74129>>>>>>>>>>>    Function_Return sValue
74130>>>>>>>>>>>End_Function
74131>>>>>>>>>>>
74131>>>>>>>>>>>// 0..256
74131>>>>>>>>>>>Function WSReadInt1 Returns Integer
74133>>>>>>>>>>>    UChar      ucValue
74133>>>>>>>>>>>    Read_Block  ucValue 1
74134>>>>>>>>>>>    Function_Return ucValue
74135>>>>>>>>>>>End_Function
74136>>>>>>>>>>>
74136>>>>>>>>>>>// 0..65536
74136>>>>>>>>>>>Function WSReadInt2 Returns Integer
74138>>>>>>>>>>>    UChar[]     ucaValue
74139>>>>>>>>>>>    Read_Block  ucaValue 2
74140>>>>>>>>>>>    Function_Return (UCharToSHORT(ucaValue))
74141>>>>>>>>>>>End_Function
74142>>>>>>>>>>>
74142>>>>>>>>>>>// 0..2G
74142>>>>>>>>>>>Function WSReadInt4 Returns Integer
74144>>>>>>>>>>>    UChar[]     ucaValue
74145>>>>>>>>>>>    Read_Block  ucaValue 4
74146>>>>>>>>>>>    Function_Return (UCharToDWORD(ucaValue))
74147>>>>>>>>>>>End_Function
74148>>>>>>>>>>>
74148>>>>>>>>>>>Procedure WSWriteStr1 String sValue
74150>>>>>>>>>>>    UChar ucLen
74150>>>>>>>>>>>    Move (Length(sValue)) To ucLen
74151>>>>>>>>>>>    Write ucLen
74152>>>>>>>>>>>    Write sValue
74153>>>>>>>>>>>End_Procedure
74154>>>>>>>>>>>
74154>>>>>>>>>>>Procedure WSWriteStr2 String sValue
74156>>>>>>>>>>>    Write (SHORTtoUChar(Length(sValue)))
74157>>>>>>>>>>>    Write sValue
74158>>>>>>>>>>>End_Procedure
74159>>>>>>>>>>>
74159>>>>>>>>>>>Procedure WSWriteStr4 String sValue
74161>>>>>>>>>>>    Write (DWordtoUChar(Length(sValue)))
74162>>>>>>>>>>>    Write sValue
74163>>>>>>>>>>>End_Procedure
74164>>>>>>>>>>>
74164>>>>>>>>>>>Function CheckType String sFile Returns Integer
74166>>>>>>>>>>>    String sTemp sTmp
74166>>>>>>>>>>>    Integer iPos
74166>>>>>>>>>>>    Integer iType
74166>>>>>>>>>>>
74166>>>>>>>>>>>    Move KPH_FILE_EDITABLE To iType
74167>>>>>>>>>>>    Move sFile To sTemp
74168>>>>>>>>>>>    While (Pos("\",sTemp)<>0)
74172>>>>>>>>>>>        Move (Pos("\",sTemp)) To iPos
74173>>>>>>>>>>>        Move (Left(sTemp,iPos)) To sTmp
74174>>>>>>>>>>>        Move (Replace(sTmp,sTemp,"")) To sTemp
74175>>>>>>>>>>>    Loop
74176>>>>>>>>>>>>
74176>>>>>>>>>>>    Move (Pos(".",sTemp)) To iPos
74177>>>>>>>>>>>    If (iPos=0) Begin
74179>>>>>>>>>>>        Move KPH_FILE_FOLDER To iType
74180>>>>>>>>>>>    End  
74180>>>>>>>>>>>>
74180>>>>>>>>>>>    Function_Return iType
74181>>>>>>>>>>>End_Function
74182>>>>>>>>>>>
74182>>>>>>>>>Use THColorer.h
Including file: THColorer.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\THColorer.h)
74182>>>>>>>>>>>// THColorer.pkg
74182>>>>>>>>>>>// This is header package for TheHammer 3.0 Code Colorer
74182>>>>>>>>>>>// by Sergey V. Natarov
74182>>>>>>>>>>>
74182>>>>>>>>>>>Use Font_dlg.pkg
Including file: Font_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Font_dlg.pkg)
74182>>>>>>>>>>>>>Use VDFBase.pkg
74182>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
74182>>>>>>>>>>>>>Use tWinStructs.pkg
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Flags
74182>>>>>>>>>>>>>// The following flags are for Windows '95 only.
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Orginal FontTypes constants
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Character sets
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Output precision
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Clipping precision
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Output quality
74182>>>>>>>>>>>>>// The following output quality's are for Windows '95 only
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Pitch
74182>>>>>>>>>>>>>// The following pitch is for Window '95 only
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Font family
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>// Font type
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>
74182>>>>>>>>>>>>>External_Function ChooseFont "ChooseFontA" COMDLG32.DLL ;    Pointer lpChooseFont Returns Integer
74183>>>>>>>>>>>>>
74183>>>>>>>>>>>>>Class FontDialog is a cObject
74184>>>>>>>>>>>>>    Procedure Construct_Object
74186>>>>>>>>>>>>>        Forward Send Construct_Object
74188>>>>>>>>>>>>>        
74188>>>>>>>>>>>>>        // Old interface property's
74188>>>>>>>>>>>>>        Property Integer FontTypes 0
74189>>>>>>>>>>>>>        // ChooseFont property's
74189>>>>>>>>>>>>>        Property Integer FontPointSize 0
74190>>>>>>>>>>>>>        Property Integer ScreenFonts_State True // False
74191>>>>>>>>>>>>>        Property Integer ShowHelp_State False
74192>>>>>>>>>>>>>        Property Integer Effects_State True // False
74193>>>>>>>>>>>>>        Property Integer NoVectorFonts_State False
74194>>>>>>>>>>>>>        Property Integer NoOEMFonts_State False
74195>>>>>>>>>>>>>        Property Integer NoSimulations_State False
74196>>>>>>>>>>>>>        Property Integer FixedPitchOnly_State False
74197>>>>>>>>>>>>>        Property Integer ForceFontExist_State True // False
74198>>>>>>>>>>>>>        Property Integer ScalableOnly_State False
74199>>>>>>>>>>>>>        Property Integer TTOnly_State False
74200>>>>>>>>>>>>>        Property Integer NoFaceSel_State False
74201>>>>>>>>>>>>>        Property Integer NoStyleSel_State False
74202>>>>>>>>>>>>>        Property Integer NoSizeSel_State False
74203>>>>>>>>>>>>>        Property Integer SelectScript_State False
74204>>>>>>>>>>>>>        Property Integer NoScriptSel_State False
74205>>>>>>>>>>>>>        Property Integer NoVertFonts_State False
74206>>>>>>>>>>>>>        Property Integer ScriptsOnly_State False
74207>>>>>>>>>>>>>        Property Integer ANSIOnly_State False
74208>>>>>>>>>>>>>        Property Integer FontRGBColors 0
74209>>>>>>>>>>>>>        Property Integer FontType 0
74210>>>>>>>>>>>>>        Property Integer FontSizeMin 1
74211>>>>>>>>>>>>>        Property Integer FontSizeMax 9999
74212>>>>>>>>>>>>>        // LogFont property's
74212>>>>>>>>>>>>>        Property Integer FontHeight -1    // see comments below
74213>>>>>>>>>>>>>        Property Integer FontWidth -1     // see comments below
74214>>>>>>>>>>>>>        Property Integer FontEscapement 0
74215>>>>>>>>>>>>>        Property Integer FontOrientation 0
74216>>>>>>>>>>>>>        Property Integer FontWeight -1    // see comments below
74217>>>>>>>>>>>>>        Property Integer FontItalic -1    // see comments below
74218>>>>>>>>>>>>>        Property Integer FontUnderline -1 // see comments below
74219>>>>>>>>>>>>>        Property Integer FontStrikeOut 0
74220>>>>>>>>>>>>>        Property Integer FontCharSet 0
74221>>>>>>>>>>>>>        Property Integer FontOutPrecision 0
74222>>>>>>>>>>>>>        Property Integer FontClipPrecision 0
74223>>>>>>>>>>>>>        Property Integer FontQuality 0
74224>>>>>>>>>>>>>        Property Integer FontPitch 0
74225>>>>>>>>>>>>>        Property Integer FontFamily 0
74226>>>>>>>>>>>>>        Property String  FaceName "EMPTY"  // see comments below
74227>>>>>>>>>>>>>        
74227>>>>>>>>>>>>>        // Set Focus_Mode To NonFocusable
74227>>>>>>>>>>>>>    End_Procedure
74228>>>>>>>>>>>>>    
74228>>>>>>>>>>>>>    Function OwnerHandle Returns Handle
74230>>>>>>>>>>>>>        Handle hWnd
74230>>>>>>>>>>>>>        Handle hoObj
74230>>>>>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
74231>>>>>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
74232>>>>>>>>>>>>>        Function_Return hWnd
74233>>>>>>>>>>>>>    End_Function
74234>>>>>>>>>>>>>    
74234>>>>>>>>>>>>>    Function FontDialog Returns Integer
74236>>>>>>>>>>>>>        Integer iResult iPitchAndFamily iFlags
74236>>>>>>>>>>>>>        String sResult
74236>>>>>>>>>>>>>        String sFaceName
74236>>>>>>>>>>>>>        Handle hOwner
74236>>>>>>>>>>>>>        tWinChooseFont ChseFont
74236>>>>>>>>>>>>>        tWinChooseFont ChseFont
74236>>>>>>>>>>>>>        tWinLogFont LogicalFont
74236>>>>>>>>>>>>>        tWinLogFont LogicalFont
74236>>>>>>>>>>>>>        
74236>>>>>>>>>>>>>        //Delegate Get Container_Handle To hOwner
74236>>>>>>>>>>>>>        Get OwnerHandle to hOwner
74237>>>>>>>>>>>>>        // Some property's default to -1 because we want to determine if the user
74237>>>>>>>>>>>>>        // changed these properties. If he changed the property's we will take their
74237>>>>>>>>>>>>>        // value and pass it on to the function. If the user didn't change the
74237>>>>>>>>>>>>>        // properties we will retrieve them from the DFWindow class.
74237>>>>>>>>>>>>>        // DF19.1: Changed TYPE into STRUCT, which means that -1 cannot be assigned to a UChar member.
74237>>>>>>>>>>>>>        Integer iVal
74237>>>>>>>>>>>>>        If (FontItalic(Self) = -1) Begin
74239>>>>>>>>>>>>>            Move (FontItalics(Self)) to iVal
74240>>>>>>>>>>>>>            If (iVal = -1) ;                Set FontItalic to 255
74243>>>>>>>>>>>>>            Else ;                Set FontItalic to iVal
74245>>>>>>>>>>>>>        End
74245>>>>>>>>>>>>>>
74245>>>>>>>>>>>>>        If (FontUnderline(Self) = -1) ;            Set FontUnderline to 255
74248>>>>>>>>>>>>>        If (FontWeight(Self) = -1) ;            Set FontWeight to 255
74251>>>>>>>>>>>>>        If (FontHeight(Self) = -1) Begin
74253>>>>>>>>>>>>>            Move (Hi(FontSize(Self))) to iVal
74254>>>>>>>>>>>>>            If (iVal = -1) ;                Set FontHeight to 255
74257>>>>>>>>>>>>>            Else ;                Set FontHeight to iVal
74259>>>>>>>>>>>>>        End
74259>>>>>>>>>>>>>>
74259>>>>>>>>>>>>>        If (FontWidth(Self) = -1) Begin
74261>>>>>>>>>>>>>            Move (Low(FontSize(Self))) to iVal
74262>>>>>>>>>>>>>            If (iVal = -1) ;                Set FontWidth to 255
74265>>>>>>>>>>>>>            Else ;                Set FontWidth to iVal
74267>>>>>>>>>>>>>        End
74267>>>>>>>>>>>>>>
74267>>>>>>>>>>>>>        If (FaceName(Self) = "EMPTY") ;            Set FaceName to (TypeFace(Self))
74270>>>>>>>>>>>>>        
74270>>>>>>>>>>>>>        Move (FontHeight(Self)) to LogicalFont.lfHeight
74271>>>>>>>>>>>>>        Move (FontWidth(Self)) to LogicalFont.lfWidth
74272>>>>>>>>>>>>>        Move (FontEscapement(Self)) to LogicalFont.lfEscapement
74273>>>>>>>>>>>>>        Move (FontOrientation(Self)) to LogicalFont.lfOrientation
74274>>>>>>>>>>>>>        Move (FontWeight(Self))    to LogicalFont.lfWeight
74275>>>>>>>>>>>>>        Move (FontItalic(Self))    to LogicalFont.lfItalic
74276>>>>>>>>>>>>>        Move (FontUnderline(Self)) to LogicalFont.lfUnderline
74277>>>>>>>>>>>>>        Move (FontStrikeOut(Self)) to LogicalFont.lfStrikeOut
74278>>>>>>>>>>>>>        Move (FontCharSet(Self))   to LogicalFont.lfCharSet
74279>>>>>>>>>>>>>        Move (FontOutPrecision(Self)) to LogicalFont.lfOutPrecision
74280>>>>>>>>>>>>>        Move (FontClipPrecision(Self)) to LogicalFont.lfClipPrecision
74281>>>>>>>>>>>>>        Move (FontQuality(Self)) to LogicalFont.lfQuality
74282>>>>>>>>>>>>>
74282>>>>>>>>>>>>>        // Family is an integer using bits 5-7 (has values 0,16,32,48,64 and 80), 
74282>>>>>>>>>>>>>        // and Pitch uses bits 1-4 (values 0,1,2,8). They can be simply added using IOR to get the PitchAndFamily.
74282>>>>>>>>>>>>>        Move (FontFamily(Self) ior FontPitch(Self)) to LogicalFont.lfPitchAndFamily
74283>>>>>>>>>>>>>
74283>>>>>>>>>>>>>        Get FaceName to sFaceName
74284>>>>>>>>>>>>>        Move (Left(sFaceName,LF_FACESIZE)) to sFaceName
74285>>>>>>>>>>>>>        Move (MemCopy(AddressOf(LogicalFont.lfFaceName), AddressOf(sfaceName), Length(sfaceName))) to iResult
74286>>>>>>>>>>>>>        
74286>>>>>>>>>>>>>        Move (SizeOfType(tWinChooseFont)) to ChseFont.lStructSize
74287>>>>>>>>>>>>>        Move hOwner to ChseFont.hwndOwner
74288>>>>>>>>>>>>>        Move (AddressOf(LogicalFont)) to ChseFont.lpLogFont
74289>>>>>>>>>>>>>        // The original FONT_DLG.PKG (by Stuart) always sets the CF_LIMITSIZE, CF_SCREENFONT and
74289>>>>>>>>>>>>>        // CF_INITTOLOGFONTSTRUCT flags. We will do the same...
74289>>>>>>>>>>>>>        // This defeats the use of CF_SCREENFONTS and CF_LIMITSIZE !
74289>>>>>>>>>>>>>        Move (CF_LIMITSIZE+CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+FontTypes(Self)) to iFlags
74290>>>>>>>>>>>>>        If (ShowHelp_State(Self)) ;            Move (iFlags+CF_SHOWHELP) to iFlags
74293>>>>>>>>>>>>>        If (Effects_State(Self)) ;            Move (iFlags+CF_EFFECTS) to iFlags
74296>>>>>>>>>>>>>        If (NoOEMFonts_State(Self)) ;            Move (iFlags+CF_NOOEMFONTS) to iFlags
74299>>>>>>>>>>>>>        If (ForceFontExist_State(Self)) ;            Move (iFlags+CF_FORCEFONTEXIST) to iFlags
74302>>>>>>>>>>>>>        If (NoFaceSel_State(Self)) ;            Move (iFlags+CF_NOFACESEL) to iFlags
74305>>>>>>>>>>>>>        If (NoStyleSel_State(Self)) ;            Move (iFlags+CF_NOSTYLESEL) to iFlags
74308>>>>>>>>>>>>>        If (NoSizeSel_State(Self)) ;            Move (iFlags+CF_NOSIZESEL) to iFlags
74311>>>>>>>>>>>>>        If (SelectScript_State(Self)) ;            Move (iFlags+CF_SELECTSCRIPT) to iFlags
74314>>>>>>>>>>>>>        If (NoScriptSel_State(Self)) ;            Move (iFlags+CF_NOSCRIPTSEL) to iFlags
74317>>>>>>>>>>>>>        If (NoVertFonts_State(Self)) ;            Move (iFlags+CF_NOVERTFONTS) to iFlags
74320>>>>>>>>>>>>>        If (ScriptsOnly_State(Self)) ;            Move (iFlags+CF_SCRIPTSONLY) to iFlags
74323>>>>>>>>>>>>>        If (not(FontTypes(Self))) Begin
74325>>>>>>>>>>>>>            If (ANSIOnly_State(Self)) ;                Move (iFlags+CF_ANSIONLY) to iFlags
74328>>>>>>>>>>>>>            If (NoVectorFonts_State(Self)) ;                Move (iFlags+CF_NOVECTORFONTS) to iFlags
74331>>>>>>>>>>>>>            If (NoSimulations_State(Self)) ;                Move (iFlags+CF_NOSIMULATIONS) to iFlags
74334>>>>>>>>>>>>>            If (FixedPitchOnly_State(Self)) ;                Move (iFlags+CF_FIXEDPITCHONLY) to iFlags
74337>>>>>>>>>>>>>            If (ScalableOnly_State(Self)) ;                Move (iFlags+CF_SCALABLEONLY) to iFlags
74340>>>>>>>>>>>>>            If (TTOnly_State(Self)) ;                Move (iFlags+CF_TTONLY) to iFlags
74343>>>>>>>>>>>>>        End
74343>>>>>>>>>>>>>>
74343>>>>>>>>>>>>>        Move iFlags to ChseFont.Flags
74344>>>>>>>>>>>>>        Move (FontPointSize(Self)) to ChseFont.iPointSize
74345>>>>>>>>>>>>>        Move (FontRGBColors(Self)) to ChseFont.rgbColors
74346>>>>>>>>>>>>>        Move (FontType(Self)) to ChseFont.nFontType
74347>>>>>>>>>>>>>        Move (FontSizeMin(Self)) to ChseFont.nSizeMin
74348>>>>>>>>>>>>>        Move (FontSizeMax(Self)) to ChseFont.nSizeMax
74349>>>>>>>>>>>>>        
74349>>>>>>>>>>>>>        Move (ChooseFont(AddressOf(ChseFont))) to iResult
74350>>>>>>>>>>>>>        If not iResult ;            Function_Return iResult
74353>>>>>>>>>>>>>        Move LogicalFont.lfHeight to iResult
74354>>>>>>>>>>>>>        Set FontHeight to iResult
74355>>>>>>>>>>>>>        Move LogicalFont.lfWidth to iResult
74356>>>>>>>>>>>>>        Set FontWidth to iResult
74357>>>>>>>>>>>>>        Move LogicalFont.lfEscapement to iResult
74358>>>>>>>>>>>>>        Set FontEscapement to iResult
74359>>>>>>>>>>>>>        Move LogicalFont.lfOrientation to iResult
74360>>>>>>>>>>>>>        Set FontOrientation to iResult
74361>>>>>>>>>>>>>        Move LogicalFont.lfWeight to iResult
74362>>>>>>>>>>>>>        Set FontWeight to iResult
74363>>>>>>>>>>>>>        Move LogicalFont.lfItalic to iResult
74364>>>>>>>>>>>>>        Set FontItalic to iResult
74365>>>>>>>>>>>>>        Move LogicalFont.lfUnderline to iResult
74366>>>>>>>>>>>>>        Set FontUnderline to iResult
74367>>>>>>>>>>>>>        Move LogicalFont.lfStrikeOut to iResult
74368>>>>>>>>>>>>>        Set FontStrikeOut to iResult
74369>>>>>>>>>>>>>        Move LogicalFont.lfCharSet to iResult
74370>>>>>>>>>>>>>        Set FontCharSet to iResult
74371>>>>>>>>>>>>>        Move LogicalFont.lfOutPrecision to iResult
74372>>>>>>>>>>>>>        Set FontOutPrecision to iResult
74373>>>>>>>>>>>>>        Move LogicalFont.lfClipPrecision to iResult
74374>>>>>>>>>>>>>        Set FontClipPrecision to iResult
74375>>>>>>>>>>>>>        Move LogicalFont.lfQuality to iResult
74376>>>>>>>>>>>>>        Set FontQuality to iResult
74377>>>>>>>>>>>>>        Move LogicalFont.lfPitchAndFamily to iPitchAndFamily
74378>>>>>>>>>>>>>
74378>>>>>>>>>>>>>        Move (ZeroString(LF_FACESIZE)) to sResult
74379>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sResult), AddressOf(LogicalFont.lfFaceName), LF_FACESIZE)) to iResult
74380>>>>>>>>>>>>>        Set FaceName to sResult
74381>>>>>>>>>>>>>
74381>>>>>>>>>>>>>        // https://docs.microsoft.com/en-us/previous-versions/windows/desktop/bb322837(v=vs.85)
74381>>>>>>>>>>>>>        // Pitch is the lower 4 bits and can have values 0,1,2, and 8. 
74381>>>>>>>>>>>>>        // Family is the higher 4 bits and can have values: 0,16,32,48,64 and 80.
74381>>>>>>>>>>>>>        // The correct function for getting them is IAND
74381>>>>>>>>>>>>>        Set FontPitch to (Integer (iPitchAndFamily iand |CI$0F))
74382>>>>>>>>>>>>>        Set FontFamily to (Integer (iPitchAndFamily iand |CI$F0))
74383>>>>>>>>>>>>>
74383>>>>>>>>>>>>>        Move ChseFont.iPointSize to iResult
74384>>>>>>>>>>>>>        Set FontPointSize to iResult
74385>>>>>>>>>>>>>        Move ChseFont.rgbColors to iResult
74386>>>>>>>>>>>>>        Set FontRGBColors to iResult
74387>>>>>>>>>>>>>        Move ChseFont.nFontType to iResult
74388>>>>>>>>>>>>>        Set FontType to iResult
74389>>>>>>>>>>>>>        Move ChseFont.nSizeMin to iResult
74390>>>>>>>>>>>>>        Set FontSizeMin to iResult
74391>>>>>>>>>>>>>        Move ChseFont.nSizeMax to iResult
74392>>>>>>>>>>>>>        Set FontSizeMax to iResult
74393>>>>>>>>>>>>>        Function_Return True
74394>>>>>>>>>>>>>    End_Function
74395>>>>>>>>>>>>>    
74395>>>>>>>>>>>>>    
74395>>>>>>>>>>>>>    Procedure Set ShowEffects_State Integer iState
74397>>>>>>>>>>>>>        Set Effects_State to iState
74398>>>>>>>>>>>>>    End_Procedure
74399>>>>>>>>>>>>>    
74399>>>>>>>>>>>>>    Function ShowEffects Returns Integer
74401>>>>>>>>>>>>>        Function_Return (Effects_State(Self))
74402>>>>>>>>>>>>>    End_Function
74403>>>>>>>>>>>>>    
74403>>>>>>>>>>>>>    Procedure Set InitialFont_State Integer iState
74405>>>>>>>>>>>>>        Set NoFaceSel_State to (not(iState))
74406>>>>>>>>>>>>>    End_Procedure
74407>>>>>>>>>>>>>    
74407>>>>>>>>>>>>>    Function InitialFontState Returns Integer
74409>>>>>>>>>>>>>        Function_Return (not(NoFaceSel_State(Self)))
74410>>>>>>>>>>>>>    End_Function
74411>>>>>>>>>>>>>    
74411>>>>>>>>>>>>>    Procedure Set InitialSize_State Integer iState
74413>>>>>>>>>>>>>        Set NoSizeSel_State to (not(iState))
74414>>>>>>>>>>>>>    End_Procedure
74415>>>>>>>>>>>>>    
74415>>>>>>>>>>>>>    Function InitialSize_State Returns Integer
74417>>>>>>>>>>>>>        Function_Return (not(NoSizeSel_State(Self)))
74418>>>>>>>>>>>>>    End_Function
74419>>>>>>>>>>>>>    
74419>>>>>>>>>>>>>    Procedure Set InitialStyle_State Integer iState
74421>>>>>>>>>>>>>        Set NoStyleSel_State to (not(iState))
74422>>>>>>>>>>>>>    End_Procedure
74423>>>>>>>>>>>>>    
74423>>>>>>>>>>>>>    Function InitialStyle_State Returns Integer
74425>>>>>>>>>>>>>        Function_Return (not(NoStyleSel_State(Self)))
74426>>>>>>>>>>>>>    End_Function
74427>>>>>>>>>>>>>    
74427>>>>>>>>>>>>>    Procedure Set FontExists_State Integer iState
74429>>>>>>>>>>>>>        Set ForceFontExist_State to iState
74430>>>>>>>>>>>>>    End_Procedure
74431>>>>>>>>>>>>>    
74431>>>>>>>>>>>>>    Function FontExists_State Returns Integer
74433>>>>>>>>>>>>>        Function_Return (ForceFontExist_State(Self))
74434>>>>>>>>>>>>>    End_Function
74435>>>>>>>>>>>>>    
74435>>>>>>>>>>>>>    Procedure Set FontMinSize Integer iSize
74437>>>>>>>>>>>>>        Set FontSizeMin to iSize
74438>>>>>>>>>>>>>    End_Procedure
74439>>>>>>>>>>>>>    
74439>>>>>>>>>>>>>    Function FontMinSize Returns Integer
74441>>>>>>>>>>>>>        Function_Return (FontSizeMin(Self))
74442>>>>>>>>>>>>>    End_Function
74443>>>>>>>>>>>>>    
74443>>>>>>>>>>>>>    Procedure Set FontMaxSize Integer iSize
74445>>>>>>>>>>>>>        Set FontSizeMax to iSize
74446>>>>>>>>>>>>>    End_Procedure
74447>>>>>>>>>>>>>    
74447>>>>>>>>>>>>>    Function FontMaxSize Returns Integer
74449>>>>>>>>>>>>>        Function_Return (FontSizeMax(Self))
74450>>>>>>>>>>>>>    End_Function
74451>>>>>>>>>>>>>    
74451>>>>>>>>>>>>>    Procedure Set FontColor Integer iColor
74453>>>>>>>>>>>>>        Set FontRGBColors to iColor
74454>>>>>>>>>>>>>    End_Procedure
74455>>>>>>>>>>>>>    
74455>>>>>>>>>>>>>    Function FontColor Returns Integer
74457>>>>>>>>>>>>>        Function_Return (FontRGBColors(Self))
74458>>>>>>>>>>>>>    End_Function
74459>>>>>>>>>>>>>    
74459>>>>>>>>>>>>>    Function Show_Dialog Returns Integer
74461>>>>>>>>>>>>>        Function_Return (FontDialog(Self))
74462>>>>>>>>>>>>>    End_Function
74463>>>>>>>>>>>>>    
74463>>>>>>>>>>>>>End_Class
74464>>>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>// *** COLORS ***
74464>>>>>>>>>>>// _WindowColr_ _LftMrgnClr_ _BookmarkCl_ _BookmarkBg_ _TextColorX_ _TextBackgr_ _NumberColr_ _NumberBkGr_ _KeywordsCl_ _KeywordsBg_ _OperatorCl_ _OperatorBg_ _ScopeKwClr_ _ScopeKwBkg_ _CommentClr_ _CommentBkg_ _StringColr_ _StringBkgr_ _TagTextClr_ _TagTextBkg_ _TagEntyClr_ _TagEntyBkg_ _TagElemClr_ _TagElemBkg_ _TagAttrClr_ _TagAttrBkg_ _LineNrColr_ _LineNrBkgr_ _HrDivLinCl_ _VrDivLinCl_ _HiLtLineCl_
74464>>>>>>>>>>>// 255255255000 192192192000 255255255255 255255255255 000000000000 255255255000 255000255000 255255255000 000000255000 255255255000 255000000000 255255255000 000000255000 255255255000 000128000000 255255255000 128128128000 255255255000 000128128000 255255255255 255000000000 255255255255 000000255000 255255255255 128000000000 255255255255 255255255000 128128128000 255255255255 192192192000 192192192000 000
74464>>>>>>>>>>>//      1            2             3           4             5           6             7            8            9           10            11          12            13          14           15           16            17          18           19          20            21            22           23         24            25           26           27           28          29            30          31
74464>>>>>>>>>>>
74464>>>>>>>>>>>// *** FONTS *** (PSFONTSTYLES)
74464>>>>>>>>>>>//      Nr       Sc Ct    TT En    At
74464>>>>>>>>>>>//   _  _  _  _  _  _  _  _  _  _  _  _
74464>>>>>>>>>>>// 000000000000000002000001000001000000000
74464>>>>>>>>>>>//   _     -  -        -        -     -
74464>>>>>>>>>>>//   Tx    Kw Op       St       El    Ln
74464>>>>>>>>>>>//   1  2  3  4  5  6  7  8  9 10 11 12
74464>>>>>>>>>>>//          1         2         3
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Normal           = 0
74464>>>>>>>>>>>// Bold             = 1
74464>>>>>>>>>>>// Italics          = 2
74464>>>>>>>>>>>// Bold + Italics   = 3
74464>>>>>>>>>>>// Underline        = 4
74464>>>>>>>>>>>// B+U              = 5
74464>>>>>>>>>>>// I+U              = 6
74464>>>>>>>>>>>// B+I+U            = 7
74464>>>>>>>>>>>
74464>>>>>>>>>>>// CodeMax: 31 elements as 3sRGBA + 3 zeroes
74464>>>>>>>>>>>Define CM_COLORS_STRSIZE for (31*12 + 3)
74464>>>>>>>>>>>// Scintilla: 37 elements as 3sRGBA + 3 zeroes
74464>>>>>>>>>>>Define SC_COLORS_STRSIZE for (42*12 + 3)
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Define Default white schema:
74464>>>>>>>>>>>Define TH_DEFSCHEMA_WHITE_STR   for "Default (White)"
74464>>>>>>>>>>>Define TH_DEFSCHEMA_BLACK_STR   for "Default (Black)"
74464>>>>>>>>>>>Define TH_DEFSCHEMA_BLUE_STR    for "Default (Blue)"
74464>>>>>>>>>>>Define TH_DEFSCHEMA_LIME_STR    for "Default (Lime)"
74464>>>>>>>>>>>Define TH_DEFSCHEMA_SERENE_STR  for "Default (Serene)"
74464>>>>>>>>>>>Define TH_DEFSCHEMA_SAHARA_STR  for "Default (Sahara)"
74464>>>>>>>>>>>Define TH_COLORSCHEMA_WHITE     for "255255255255220225240000255255255255255255255255000000000000255255255000255000255000255255255000000000255000255255255000255000000000255255255000000000255000255255255000000128000000255255255000128128128000255255255000000128128000255255255255255000000000255255255255000000255000255255255255128000000000255255255255105105105000190200225000255255255255192192192000220225240000128128128000255215215000000000000000200225255000255255000000255035035000000128128000255255255000170195240000215107000000255255255000000"
74464>>>>>>>>>>>Define TH_COLORSCHEMA_BLACK     for "025025025000120120120000255255255255255255255255255255255000025025025000255185255000025025025000140215240000025025025000255108108000025025025000140215240000025025025000187255187000025025025000192192192000025025025000045255255000255255255255255000000000255255255255128128255000255255255255255147147000255255255255192192192000080080080000255255255255192192192000105105105000090090090000255215215000000000000000200225255000255255000000255000000000202255255000025025025000000000170000255190120000025025025000000"
74464>>>>>>>>>>>Define TH_COLORSCHEMA_BLUE      for "000000128000000000128000255255255255255255255255255255255000000000128000255070255000000000128000115205235000000000128000255066066000000000128000115205235000000000128000147255147000000000128000190190190000000000128000000164164000255255255255255000000000255255255255166166255000255255255255255176176000255255255255255255255000000000128000255255255255192192192000000128128000090090090000255215215000000000000000200225255000255255000000255035035000179179000000000000128000000128128000255190120000000000128000000"
74464>>>>>>>>>>>Define TH_COLORSCHEMA_LIME      for "049060083000069082104000255255255255255255255255255255255000049060083000255138021000049060083000156255000000049060083000249255013000049060083000156255000000049060083000255098255000049060083000180180180000049060083000000189095000255255255255255000000000255255255255171087255000255255255255255072164000255255255255096114145000028038060000255255255255192192192000028038060000070070070000253193220000255026026000049060083000255255000000255035035000000240240000049060083000001001001000255194034000049060083000000"
74464>>>>>>>>>>>Define TH_COLORSCHEMA_SERENE    for "025025025000120120120000255255255255255255255255255255255000025025025000255185255000025025025000140215240000025025025000255108108000025025025000140215240000025025025000187255187000025025025000255255000000025025025000000174174000255255255255255000000000255255255255180104255000255255255255128128255000255255255255192192192000080080080000255255255255192192192000105105105000090090090000255215215000000000000000200225255000255255000000255000000000202255255000025025025000000000170000255190120000025025025000000,000000000000001000000001000001000000000000000000000000"
74464>>>>>>>>>>>Define TH_COLORSCHEMA_SAHARA    for "255255187000220225240000255255255255255255187000000000000000255255187000255000255000255255187000000000255000255255187000255000000000255255187000000000255000255255187000000128000000255255187000255000128000255255187000000128128000255255187000255000000000255255187000000000255000255255187000128000000000255255187000105105105000190200225000255255255255192192192000220225240000128128128000255215215000000000000000200225255000255255000000255035035000000128128000255255187000170195240000215107000000255255187000000,000000000000000000000000000000000000000000000001000000"
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Font Styles
74464>>>>>>>>>>>Define THFS_NORMAL      for 0
74464>>>>>>>>>>>Define THFS_BOLD        for 1
74464>>>>>>>>>>>Define THFS_ITALICS     for 2
74464>>>>>>>>>>>Define THFS_UNDERLINE   for 4
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Editor Colors
74464>>>>>>>>>>>Enum_List
74464>>>>>>>>>>>    Define EC_WINDOW            // 00
74464>>>>>>>>>>>    Define EC_LEFTMARGIN        // 01
74464>>>>>>>>>>>    Define EC_BOOKMARK          // 02
74464>>>>>>>>>>>    Define EC_TEXT              // 03
74464>>>>>>>>>>>    Define EC_NUMBERS           // 04
74464>>>>>>>>>>>    Define EC_KEYWORDS          // 05
74464>>>>>>>>>>>    Define EC_OPERATORS         // 06
74464>>>>>>>>>>>    Define EC_SCOPEKWORDS       // 07
74464>>>>>>>>>>>    Define EC_COMMENTS          // 08
74464>>>>>>>>>>>    Define EC_STRINGS           // 09
74464>>>>>>>>>>>    Define EC_TAGTEXT           // 10
74464>>>>>>>>>>>    Define EC_TAGENTITIES       // 11
74464>>>>>>>>>>>    Define EC_TAGELEMENT        // 12
74464>>>>>>>>>>>    Define EC_TAGATTRIBUTE      // 13
74464>>>>>>>>>>>    Define EC_LINENUMBERS       // 14
74464>>>>>>>>>>>    Define EC_HDIVLINES         // 15
74464>>>>>>>>>>>    Define EC_VDIVLINES         // 16
74464>>>>>>>>>>>    Define EC_HLIGHTEDLINE      // 17
74464>>>>>>>>>>>    // Scintilla Only
74464>>>>>>>>>>>    Define EC_STRINGTYPING      // 18
74464>>>>>>>>>>>    Define EC_BRACEHLIGHT       // 19
74464>>>>>>>>>>>    Define EC_UNMATCHEDBRACE    // 20
74464>>>>>>>>>>>    Define EC_METATAGS          // 21
74464>>>>>>>>>>>    Define EC_SELECTION         // 22
74464>>>>>>>>>>>    Define EC_PREPROCESSOR      // 23
74464>>>>>>>>>>>End_Enum_List
74464>>>>>>>>>>>
74464>>>>>>>>>>>Struct tColorer
74464>>>>>>>>>>>    String  sName       // Color element
74464>>>>>>>>>>>    Integer iForeOff    // Front Color Required
74464>>>>>>>>>>>    Integer iBackOff    // Back Color Required
74464>>>>>>>>>>>    Integer iFont       // Font Allowed
74464>>>>>>>>>>>    Integer iStyle      // Font Style
74464>>>>>>>>>>>    Integer iCM         // CodeMax Support
74464>>>>>>>>>>>    Integer iForeC      // Actual Text Color
74464>>>>>>>>>>>    Integer iBackC      // Actual Background Color
74464>>>>>>>>>>>    Integer iBold       // Font Bold
74464>>>>>>>>>>>    Integer iItalics    // Font Italics
74464>>>>>>>>>>>    Integer iUnderline  // Font Underline
74464>>>>>>>>>>>End_Struct
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Charset
74464>>>>>>>>>>>// Commented out defines are already defined in Font_dlg package
74464>>>>>>>>>>>//Define ANSI_CHARSET             for 0
74464>>>>>>>>>>>//Define DEFAULT_CHARSET          for 1
74464>>>>>>>>>>>//Define SYMBOL_CHARSET           for 2
74464>>>>>>>>>>>//Define SHIFTJIS_CHARSET         for 128
74464>>>>>>>>>>>Define HANGEUL_CHARSET          for 129
74464>>>>>>>>>>>//Define HANGUL_CHARSET           for 129
74464>>>>>>>>>>>//Define GB2312_CHARSET           for 134
74464>>>>>>>>>>>//Define CHINESEBIG5_CHARSET      for 136
74464>>>>>>>>>>>//Define OEM_CHARSET              for 255
74464>>>>>>>>>>>Define JOHAB_CHARSET            for 130
74464>>>>>>>>>>>Define HEBREW_CHARSET           for 177
74464>>>>>>>>>>>Define ARABIC_CHARSET           for 178
74464>>>>>>>>>>>Define GREEK_CHARSET            for 161
74464>>>>>>>>>>>Define TURKISH_CHARSET          for 162
74464>>>>>>>>>>>Define VIETNAMESE_CHARSET       for 163
74464>>>>>>>>>>>Define THAI_CHARSET             for 222
74464>>>>>>>>>>>Define EASTEUROPE_CHARSET       for 238
74464>>>>>>>>>>>Define RUSSIAN_CHARSET          for 204
74464>>>>>>>>>>>
74464>>>>>>>>>>>Define MAC_CHARSET              for 77
74464>>>>>>>>>>>Define BALTIC_CHARSET           for 186
74464>>>>>>>>>>>
74464>>>>>>>>>>>tColorer[] gtColorer
74464>>>>>>>>>>>tColorer[] gtColorer
74464>>>>>>>>>Use Flexml.pkg
Including file: Flexml.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Flexml.pkg)
74464>>>>>>>>>>>Use VdfBase.pkg
74464>>>>>>>>>>>Use LanguageText.pkg
74464>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Used to designate that a handle is a handle to an Xml Dom object. This
74464>>>>>>>>>>>// is used/required by server web-services but could be used elsewhere .
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Types of Nodes
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>// classes and methods defined in fmac
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function transformNode Handle infcXSLNode Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>// XML function & procedure registration
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Procedure Set XmlInterface Handle iHandle
74464>>>>>>>>>>>Register_Function XmlInterface Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>// NODE Properties
74464>>>>>>>>>>>Register_Function phAttributes Returns Handle
74464>>>>>>>>>>>Register_Function psBaseName Returns String
74464>>>>>>>>>>>Register_Function phChildNodes Returns Handle
74464>>>>>>>>>>>Register_Function phDefinition Returns Handle
74464>>>>>>>>>>>Register_Function phFirstChild Returns Handle
74464>>>>>>>>>>>Register_Function phLastChild Returns Handle
74464>>>>>>>>>>>Register_Function phNextSibling Returns Handle
74464>>>>>>>>>>>Register_Function psNameSpaceURI Returns String
74464>>>>>>>>>>>Register_Function psNodeName Returns String
74464>>>>>>>>>>>Register_Function piNodeType Returns Integer
74464>>>>>>>>>>>Register_Function psNodeTypeString Returns String
74464>>>>>>>>>>>Register_Function phOwnerDocument Returns Handle
74464>>>>>>>>>>>Register_Function phParentNode Returns Handle
74464>>>>>>>>>>>Register_Function pbParsed Returns Integer
74464>>>>>>>>>>>Register_Function psPrefix Returns String
74464>>>>>>>>>>>Register_Function phPreviousSibling Returns Handle
74464>>>>>>>>>>>Register_Function pbSpecified Returns Integer
74464>>>>>>>>>>>Register_Function psText Returns String
74464>>>>>>>>>>>Register_Procedure Set psText String sText
74464>>>>>>>>>>>Register_Function psXML Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Node Read write properties
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Procedure Set psDataType String sTypeName
74464>>>>>>>>>>>Register_Function psDataType Returns String
74464>>>>>>>>>>>Register_Procedure Set pvNodeTypedValue Integer iType Integer iAddress
74464>>>>>>>>>>>Register_Function pvNodeTypedValue Integer iType Returns Integer  // address of data
74464>>>>>>>>>>>Register_Procedure Set psNodeValue String sValue
74464>>>>>>>>>>>Register_Function psNodeValue Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Node Methods
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function AppendChild Handle iChildInfc Returns Handle
74464>>>>>>>>>>>Register_Function CloneInfcNode Handle bRecurse Returns Handle
74464>>>>>>>>>>>Register_Function HasChildNodes Returns Integer
74464>>>>>>>>>>>Register_Function InsertBefore Handle infcNodeToInsert Handle iWhere Returns Handle
74464>>>>>>>>>>>Register_Function RemoveChild Handle iChildToRemove Returns Handle
74464>>>>>>>>>>>Register_Function ReplaceChild Handle iNewChild Handle iChildToReplace Returns Handle
74464>>>>>>>>>>>Register_Function SelectNodes String selectstring Returns Handle
74464>>>>>>>>>>>Register_Function SelectSingleNode String selectstring Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Node Collections
74464>>>>>>>>>>>// READONLY PROPERTIES
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function phItem Integer iItem Returns Handle
74464>>>>>>>>>>>Register_Function phElementItem Integer iItem Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function piLength Returns Integer
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function NamedItem String sName Returns Handle
74464>>>>>>>>>>>Register_Function QualifiedItem String sBaseName String sNameSpace Returns Handle
74464>>>>>>>>>>>Register_Function RemoveNamedItem String sName Returns Handle
74464>>>>>>>>>>>Register_Function RemoveQualifiedItem String sBaseName String sNameSpace Returns Handle
74464>>>>>>>>>>>Register_Function SetNamedItem Handle iInterface Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>// XML DOM Document
74464>>>>>>>>>>>// Read only properties
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function phDocType Returns Handle
74464>>>>>>>>>>>Register_Function phImplementation Returns Handle
74464>>>>>>>>>>>Register_Function phParseError Returns Handle
74464>>>>>>>>>>>Register_Function piReadyState Returns Integer
74464>>>>>>>>>>>Register_Function psURL Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Read Write Properties
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Procedure Set pbAsync Integer bValue
74464>>>>>>>>>>>Register_Function pbAsync Returns Integer
74464>>>>>>>>>>>Register_Procedure Set phDocumentElement Handle iElement
74464>>>>>>>>>>>Register_Function phDocumentElement Returns Handle
74464>>>>>>>>>>>Register_Procedure Set pbPreserveWhiteSpace Integer bValue
74464>>>>>>>>>>>Register_Function pbPreserveWhiteSpace Returns Integer
74464>>>>>>>>>>>Register_Procedure Set pbResolveExternals Integer bValue
74464>>>>>>>>>>>Register_Function pbResolveExternals Returns Integer
74464>>>>>>>>>>>Register_Procedure Set pbValidateOnParse Integer bValue
74464>>>>>>>>>>>Register_Function pbValidateOnParse Returns Integer
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Events
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Methods
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function Abort Returns Integer
74464>>>>>>>>>>>Register_Function ElementsByTagName String sTagName Returns Handle
74464>>>>>>>>>>>Register_Function LoadDocument String sURLName Returns Integer
74464>>>>>>>>>>>Register_Function LoadXML String sXMLText Returns Integer
74464>>>>>>>>>>>Register_Function NodeFromID String sNodeName Returns Handle
74464>>>>>>>>>>>Register_Function SaveDocument String sURLName Returns Integer
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Parse Error
74464>>>>>>>>>>>// Read Only Properties
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function piErrorCode Returns Integer
74464>>>>>>>>>>>Register_Function piFilePos Returns Integer
74464>>>>>>>>>>>Register_Function piLine Returns Integer
74464>>>>>>>>>>>Register_Function piLinePos Returns Integer
74464>>>>>>>>>>>Register_Function psReason Returns String
74464>>>>>>>>>>>Register_Function psSrcText Returns String
74464>>>>>>>>>>>Register_Function psURL Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// DOM Implementation
74464>>>>>>>>>>>// Method
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function HasFeature String sSystem String sFeature Returns Integer
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Methods
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function substringData Integer iOffset Integer iCount Returns String
74464>>>>>>>>>>>Register_Function appendData String sData Returns Handle
74464>>>>>>>>>>>Register_Function insertData Integer iOffset String sData Returns Handle
74464>>>>>>>>>>>Register_Function deleteData Integer iOffset Integer iCount Returns Handle
74464>>>>>>>>>>>Register_Function replaceData Integer iOffset Integer iCount String sData Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Attributes
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function psName Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Elements
74464>>>>>>>>>>>// Read Only properties
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function psTagName Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// Methods
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Procedure Set attributeValue String sName String sValue
74464>>>>>>>>>>>Register_Function attributeValue String sName Returns String
74464>>>>>>>>>>>Register_Function removeAttribute String sName Returns Handle
74464>>>>>>>>>>>Register_Function attributeNode String sName Returns Handle
74464>>>>>>>>>>>Register_Procedure Set attributeNode Handle iNode Returns Handle
74464>>>>>>>>>>>Register_Function removeAttributeNode Handle iNode Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>// DOM Text
74464>>>>>>>>>>>// Methods
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function splitText Integer iOffset Returns Integer
74464>>>>>>>>>>>
74464>>>>>>>>>>>// DOM Processing Instruction
74464>>>>>>>>>>>// Read Only Properties
74464>>>>>>>>>>>Register_Function psTarget Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// DOM Document Type
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function phEntities Returns Handle
74464>>>>>>>>>>>Register_Function phNotations Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>// DOM Notations
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function psPublicID Returns String
74464>>>>>>>>>>>Register_Function psSystemID Returns String
74464>>>>>>>>>>>Register_Function psNotationName Returns String
74464>>>>>>>>>>>
74464>>>>>>>>>>>// create nodes
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function createAttribute String sName Returns Handle
74464>>>>>>>>>>>Register_Function createCDataSection String sValue Returns Handle
74464>>>>>>>>>>>Register_Function createComment String sValue Returns Handle
74464>>>>>>>>>>>Register_Function createDocumentFragment Returns Handle
74464>>>>>>>>>>>Register_Function createElement String sTagName Returns Handle
74464>>>>>>>>>>>Register_Function createEntityReference String sEntityName Returns Handle
74464>>>>>>>>>>>Register_Function createNode Integer iNodeType String sName String sNameSpace Returns Handle
74464>>>>>>>>>>>Register_Function createProcessingInstruction String sTarget String sData Returns Handle
74464>>>>>>>>>>>Register_Function createTextNode String sData Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>Register_Function ChangeNodeType Integer iTypeOfNode Integer bSetInterface Returns Handle
74464>>>>>>>>>>>
74464>>>>>>>>>>>
74464>>>>>>>>>>>//          Part 1:  Base Document Logic Specialized For Templates
74464>>>>>>>>>>>
74464>>>>>>>>>>>//
74464>>>>>>>>>>>//  XML Collections
74464>>>>>>>>>>>//
74464>>>>>>>>>>>//  Collection mixin has common functions to both node lists and named node maps
74464>>>>>>>>>>>//
74464>>>>>>>>>>>
74464>>>>>>>>>>>// This provides functions required of all XMLDOM objects.
74464>>>>>>>>>>>//
74464>>>>>>>>>>>Class cXMLDOMMixin is a Mixin
74465>>>>>>>>>>>    
74465>>>>>>>>>>>    // Create an XML object of passed class Id and bind passed interface. returns
74465>>>>>>>>>>>    // the object handle. All dynamic XML object can be created using this syntax
74465>>>>>>>>>>>    
74465>>>>>>>>>>>    Function CreateXMLObject Integer iClassId Handle hinfXMLInterface Returns Handle
74467>>>>>>>>>>>        Handle hoId hoDocument
74467>>>>>>>>>>>        // We will always create objects at the DOMDocument level.
74467>>>>>>>>>>>        Get DocumentObject to hoDocument
74468>>>>>>>>>>>        If (hoDocument=0) Begin  // this should never happen.
74470>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR C_$XmlFailedNoDocObject
74471>>>>>>>>>>>>
74471>>>>>>>>>>>            Function_Return 0
74472>>>>>>>>>>>        End
74472>>>>>>>>>>>>
74472>>>>>>>>>>>        If hinfXMLInterface Begin
74474>>>>>>>>>>>            Get Create of hoDocument iClassId to hoID
74475>>>>>>>>>>>            Set XMLInterface of hoID to hinfXMLInterface
74476>>>>>>>>>>>        End
74476>>>>>>>>>>>>
74476>>>>>>>>>>>        Function_Return hoID
74477>>>>>>>>>>>    End_Function
74478>>>>>>>>>>>    
74478>>>>>>>>>>>    // create an XML Node object based on the interface type.
74478>>>>>>>>>>>    // this will convert the interface to the proper type and will create
74478>>>>>>>>>>>    // an appropriate DF object.
74478>>>>>>>>>>>    // This requires that a DocumentObject exists
74478>>>>>>>>>>>    
74478>>>>>>>>>>>    Function CreateXMLNode Handle hinfc Returns Handle
74480>>>>>>>>>>>        Integer iType iClassId
74480>>>>>>>>>>>        Handle  hoDocument hoNode
74480>>>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
74480>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
74481>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
74482>>>>>>>>>>>        If (hinfc=0) Begin
74484>>>>>>>>>>>            // this should not happen and we would need to know about this.
74484>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
74485>>>>>>>>>>>>
74485>>>>>>>>>>>            Function_Return 0
74486>>>>>>>>>>>        End
74486>>>>>>>>>>>>
74486>>>>>>>>>>>        Get DocumentObject to hoDocument
74487>>>>>>>>>>>        // you can augment your class IDs in a single place.
74487>>>>>>>>>>>        Get NodeClassId of hoDocument iType to iClassId
74488>>>>>>>>>>>        Get CreateXMLObject of hoDocument iClassId hinfc to hoNode
74489>>>>>>>>>>>        
74489>>>>>>>>>>>        Function_Return hoNode
74490>>>>>>>>>>>    End_Function
74491>>>>>>>>>>>    
74491>>>>>>>>>>>    
74491>>>>>>>>>>>    // Change object's class. This let's you change the class id of an object
74491>>>>>>>>>>>    // on an object by object basis. This would let you create nodes (e.g. elements)
74491>>>>>>>>>>>    // that have a custom interface for each node type. Normally, this would be sent
74491>>>>>>>>>>>    // after a node has been created using one of the default classes
74491>>>>>>>>>>>    Function ChangeNodeClass Handle hoNode Integer iClassID Returns Handle
74493>>>>>>>>>>>        Integer iType
74493>>>>>>>>>>>        Handle  hinfcNew
74493>>>>>>>>>>>        Get piNodeType of hoNode to iType
74494>>>>>>>>>>>        Get ChangeNodeType of hoNode iType False to hInfcNew
74495>>>>>>>>>>>        Send Destroy to hoNode // destroy object and old infc handle.
74496>>>>>>>>>>>        Get CreateXMLObject iClassId hinfcNew to hoNode
74497>>>>>>>>>>>        Function_Return hoNode
74498>>>>>>>>>>>    End_Function
74499>>>>>>>>>>>    
74499>>>>>>>>>>>End_Class
74500>>>>>>>>>>>
74500>>>>>>>>>>>
74500>>>>>>>>>>>Class cXMLDOMCollectionMixin is a Mixin
74501>>>>>>>>>>>    
74501>>>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
74502>>>>>>>>>>>    
74502>>>>>>>>>>>    //  Returns number of items in the collection
74502>>>>>>>>>>>    //
74502>>>>>>>>>>>    Function NodeListLength Returns Integer
74504>>>>>>>>>>>        Integer iLength
74504>>>>>>>>>>>        Get piLength to iLength
74505>>>>>>>>>>>        Function_Return iLength
74506>>>>>>>>>>>    End_Function
74507>>>>>>>>>>>    
74507>>>>>>>>>>>    // Returns an XML node object for pass item
74507>>>>>>>>>>>    //
74507>>>>>>>>>>>    Function CollectionNode Integer I Returns Handle
74509>>>>>>>>>>>        Handle hoNewNode
74509>>>>>>>>>>>        Handle infcItem
74509>>>>>>>>>>>        Get phItem i to infcItem
74510>>>>>>>>>>>        If (infcItem) ;            Get CreateXMLNode infcItem to hoNewNode
74513>>>>>>>>>>>        Function_Return hoNewNode
74514>>>>>>>>>>>    End_Function
74515>>>>>>>>>>>    
74515>>>>>>>>>>>    
74515>>>>>>>>>>>End_Class
74516>>>>>>>>>>>
74516>>>>>>>>>>>// Simple declarations of collections.
74516>>>>>>>>>>>
74516>>>>>>>>>>>Class cXMLDOMNodeList is a BaseXmlDomNodeList
74517>>>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
74518>>>>>>>>>>>End_Class
74519>>>>>>>>>>>
74519>>>>>>>>>>>Class cXMLDOMNamedNodeMap is a BaseXmlDomNamedNodeMap
74520>>>>>>>>>>>    
74520>>>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
74521>>>>>>>>>>>    
74521>>>>>>>>>>>    // returns a node attribute that matches passed name, zero if none
74521>>>>>>>>>>>    Function NamedNode String sName Returns Handle
74523>>>>>>>>>>>        Handle hoNewNode
74523>>>>>>>>>>>        Handle infcItem
74523>>>>>>>>>>>        Get NamedItem sName to infcItem
74524>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74527>>>>>>>>>>>        Function_Return hoNewNode
74528>>>>>>>>>>>    End_Function
74529>>>>>>>>>>>    
74529>>>>>>>>>>>    // Adds or changes a node attribute
74529>>>>>>>>>>>    // This should return the passed object Id which is now bound to the attribute. If an error, returns 0
74529>>>>>>>>>>>    Function SetNamedNode Handle hoNode Returns Handle
74531>>>>>>>>>>>        Handle hinfcNode hinfcItem
74531>>>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode // node of passed attribute
74532>>>>>>>>>>>        Get SetNamedItem hinfcNode to hinfcItem
74533>>>>>>>>>>>        If hinfcItem ;            Set XMLInterface of hoNode to hinfcItem
74536>>>>>>>>>>>        Else ;            Move 0 to hoNode // zero indicates error
74538>>>>>>>>>>>        Function_Return hoNode
74539>>>>>>>>>>>    End_Function
74540>>>>>>>>>>>    
74540>>>>>>>>>>>    // removes named attribute, Returns handle of removed node or zero if not found.
74540>>>>>>>>>>>    // Note that returned object must be disposed of or moved somewhere else.
74540>>>>>>>>>>>    Function RemoveNamedNode String sName Returns Handle
74542>>>>>>>>>>>        Handle hoNewNode
74542>>>>>>>>>>>        Handle infcItem
74542>>>>>>>>>>>        Get RemoveNamedItem sName to infcItem
74543>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74546>>>>>>>>>>>        Function_Return hoNewNode
74547>>>>>>>>>>>    End_Function
74548>>>>>>>>>>>    
74548>>>>>>>>>>>    Function QualifiedNode String sNameSpace String sBaseName Returns Handle
74550>>>>>>>>>>>        Handle hoNewNode
74550>>>>>>>>>>>        Handle infcItem
74550>>>>>>>>>>>        Get QualifiedItem  sBaseName sNameSpace  to infcItem
74551>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74554>>>>>>>>>>>        Function_Return hoNewNode
74555>>>>>>>>>>>    End_Function
74556>>>>>>>>>>>    
74556>>>>>>>>>>>    Function RemoveQualifiedNode String sNameSpace String sBaseName Returns Handle
74558>>>>>>>>>>>        Handle hoNewNode
74558>>>>>>>>>>>        Handle infcItem
74558>>>>>>>>>>>        Get RemoveQualifiedItem sBaseName sNameSpace to infcItem
74559>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74562>>>>>>>>>>>        Function_Return hoNewNode
74563>>>>>>>>>>>    End_Function
74564>>>>>>>>>>>    
74564>>>>>>>>>>>End_Class
74565>>>>>>>>>>>
74565>>>>>>>>>>>
74565>>>>>>>>>>>
74565>>>>>>>>>>>// Mixin for nodes.
74565>>>>>>>>>>>//
74565>>>>>>>>>>>//  First the declaration of functions that have no object references.
74565>>>>>>>>>>>//
74565>>>>>>>>>>>
74565>>>>>>>>>>>
74565>>>>>>>>>>>Class cXMLDOMNodeMixin is a Mixin
74566>>>>>>>>>>>    
74566>>>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
74567>>>>>>>>>>>    
74567>>>>>>>>>>>    //  Append Node to the end of list. Returns passed Object handle if Ok, 0 if error
74567>>>>>>>>>>>    
74567>>>>>>>>>>>    Function AppendNode Handle hoNode Returns Handle
74569>>>>>>>>>>>        Handle hinfcNode
74569>>>>>>>>>>>        Handle infcReturned
74569>>>>>>>>>>>        // Get COM Interface to call Append child.
74569>>>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode
74570>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74573>>>>>>>>>>>        Get AppendChild hinfcNode to infcReturned
74574>>>>>>>>>>>        // Interface returned is stored in DataFlex object.
74574>>>>>>>>>>>        If (infcReturned=0) ;            Function_Return 0
74577>>>>>>>>>>>        Set XMLInterface of hoNode to infcReturned
74578>>>>>>>>>>>        Function_Return hoNode
74579>>>>>>>>>>>    End_Function
74580>>>>>>>>>>>    
74580>>>>>>>>>>>    //  Insert NewNode before Node. Returns passed newnode Object handle if Ok, 0 if error
74580>>>>>>>>>>>    
74580>>>>>>>>>>>    Function InsertBeforeNode Handle hoNewNode Handle hoNode Returns Handle
74582>>>>>>>>>>>        Handle hinfcNewNode hinfcNode hoRefNode infcReturned
74582>>>>>>>>>>>        Integer iType
74582>>>>>>>>>>>        // DOM says if no refnode argument passed or it is 0, append to end
74582>>>>>>>>>>>        If (Num_Arguments=1) ;            Move 0 to hoRefNode
74585>>>>>>>>>>>        Else ;            Move hoNode to hoRefNode
74587>>>>>>>>>>>        Get XMLInterface of hoNewNode to hinfcNewNode
74588>>>>>>>>>>>        If (hinfcNewNode=0) ;            Function_Return 0
74591>>>>>>>>>>>        If hoRefNode Begin
74593>>>>>>>>>>>            Get XMLInterface of hoRefNode to hinfcNode
74594>>>>>>>>>>>            If (hinfcNode=0) ;                Function_Return 0
74597>>>>>>>>>>>        End
74597>>>>>>>>>>>>
74597>>>>>>>>>>>        Get InsertBefore hinfcNewNode hinfcNode to infcReturned
74598>>>>>>>>>>>        If (infcReturned=0) ;            Function_Return 0
74601>>>>>>>>>>>        // Interface returned is stored in DataFlex object.
74601>>>>>>>>>>>        Set XMLInterface of hoNewNode to infcReturned
74602>>>>>>>>>>>        Function_Return hoNewNode
74603>>>>>>>>>>>    End_Function
74604>>>>>>>>>>>    
74604>>>>>>>>>>>    //  Remove Node. Returns object Id of removed node, zero if error
74604>>>>>>>>>>>    //  Important: The node is not destroyed! This lets you move it elsewhere if you want
74604>>>>>>>>>>>    
74604>>>>>>>>>>>    Function RemoveNode Handle hoNode Returns Handle
74606>>>>>>>>>>>        Handle hInfcNode
74606>>>>>>>>>>>        Get XMLInterface of hoNode to hInfcNode
74607>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74610>>>>>>>>>>>        Get RemoveChild hInfcNode to hinfcNode
74611>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74614>>>>>>>>>>>        Set XMLInterface of hoNode to hinfcNode
74615>>>>>>>>>>>        Function_Return hoNode
74616>>>>>>>>>>>    End_Function
74617>>>>>>>>>>>    
74617>>>>>>>>>>>    //  Replace Node. Returns object Id of replaced node, zero if error
74617>>>>>>>>>>>    //  Important: The replaced node is not destroyed! This lets you move it elsewhere if you want
74617>>>>>>>>>>>    
74617>>>>>>>>>>>    Function ReplaceNode Handle hoNewNode Handle hoNodeToReplace Returns Handle
74619>>>>>>>>>>>        Handle hInfcNewNode hinfcNodetoReplace hinfcNode
74619>>>>>>>>>>>        Get XMLInterface of hoNewNode       to hInfcNewNode
74620>>>>>>>>>>>        Get XMLInterface of hoNodetoReplace to hInfcNodetoreplace
74621>>>>>>>>>>>        If (hinfcNewNode=0 or hInfcNodeToReplace=0) ;            Function_Return 0
74624>>>>>>>>>>>        Get ReplaceChild hInfcNewNode hinfcNodeToReplace to hinfcNode
74625>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74628>>>>>>>>>>>        Set XMLInterface of hoNodetoReplace to hinfcNode
74629>>>>>>>>>>>        Function_Return hoNodetoReplace
74630>>>>>>>>>>>    End_Function
74631>>>>>>>>>>>    
74631>>>>>>>>>>>    // Remove the named node. Returns handle to removed node. You must destroy
74631>>>>>>>>>>>    // or move this removed object as needed
74631>>>>>>>>>>>    
74631>>>>>>>>>>>    Function RemoveNamedNode String sQueryString Returns Handle
74633>>>>>>>>>>>        Handle hoNode
74633>>>>>>>>>>>        Handle hInfcTemplate hinfcNode
74633>>>>>>>>>>>        Integer iRet
74633>>>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcTemplate
74634>>>>>>>>>>>        If (hinfcTemplate) Begin
74636>>>>>>>>>>>            // Remove child returns an interface to the disassociated node.
74636>>>>>>>>>>>            // It should be disposed by setting it to an object and then calling destroy
74636>>>>>>>>>>>            Get RemoveChild hInfcTemplate to hInfcNode
74637>>>>>>>>>>>            // Even if hInfcTemplate and hInfcNode are the same their reference count will be incremented.
74637>>>>>>>>>>>            // Therefore we must destroy one the interfaces which will decrement the reference count thus
74637>>>>>>>>>>>            // avoding a memory leak
74637>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, DESTROY_XML_INTERFACE, hInfcTemplate, 0, 0, 0, 0)) to iRet
74638>>>>>>>>>>>            If hInfcNode ;                Get CreateXMLNode hinfcNode to hoNode
74641>>>>>>>>>>>        End
74641>>>>>>>>>>>>
74641>>>>>>>>>>>        Function_Return hoNode
74642>>>>>>>>>>>    End_Function
74643>>>>>>>>>>>    
74643>>>>>>>>>>>    // This function creates a clone of the passed Node. if bRecurse all child nodes are also
74643>>>>>>>>>>>    // cloned. The object Id of the new clone object is returned.
74643>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
74643>>>>>>>>>>>    // the node to the XML Document.
74643>>>>>>>>>>>    
74643>>>>>>>>>>>    Function CloneNode Integer bRecurse Returns Handle
74645>>>>>>>>>>>        Handle hoNewNode
74645>>>>>>>>>>>        Handle hinfcNewNode
74645>>>>>>>>>>>        Get CloneInfcNode (If(bRecurse,-1,0)) to hinfcNewNode
74646>>>>>>>>>>>        If hinfcNewNode ;            Get CreateXMLNode hinfcNewNode to hoNewNode
74649>>>>>>>>>>>        Function_Return hoNewNode
74650>>>>>>>>>>>    End_Function
74651>>>>>>>>>>>    
74651>>>>>>>>>>>    //  Create a collection of all nodes. returns handle of a cXMLDomNodeList
74651>>>>>>>>>>>    
74651>>>>>>>>>>>    Function ChildNodes Returns Handle
74653>>>>>>>>>>>        Handle infcNodeList
74653>>>>>>>>>>>        Handle hoNodeList
74653>>>>>>>>>>>        Get phChildNodes to infcNodeList
74654>>>>>>>>>>>        If (infcNodeList) ;            Get CreateXMLObject U_cXMLDOMNodeList infcNodeList to hoNodeList
74657>>>>>>>>>>>        Function_Return hoNodeList
74658>>>>>>>>>>>    End_Function
74659>>>>>>>>>>>    
74659>>>>>>>>>>>    //  Create a collection of all attributes. returns handle of a cXMLDomNodeMapList
74659>>>>>>>>>>>    
74659>>>>>>>>>>>    Function AttributeNodes Returns Handle
74661>>>>>>>>>>>        Handle hoCollectionId   // Object to hold collection
74661>>>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
74661>>>>>>>>>>>        Get phAttributes to hinfcAttributes
74662>>>>>>>>>>>        If (hinfcAttributes) ;            Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcAttributes to hoCollectionId
74665>>>>>>>>>>>        Function_Return hoCollectionId
74666>>>>>>>>>>>    End_Function
74667>>>>>>>>>>>    
74667>>>>>>>>>>>    //  Create a collection of all attributes for the temporary attribute node object.
74667>>>>>>>>>>>    //  Using this saves a small amount of time creating and destroying this object but
74667>>>>>>>>>>>    //  it must be used with care. This binding is temporary!
74667>>>>>>>>>>>    Function TempAttributeNodes Returns Handle
74669>>>>>>>>>>>        Handle hoCollectionId hoDocument
74669>>>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
74669>>>>>>>>>>>        Get phAttributes to hinfcAttributes
74670>>>>>>>>>>>        If (hinfcAttributes) Begin
74672>>>>>>>>>>>            Get DocumentObject to hoDocument
74673>>>>>>>>>>>            Get phoTempDomNodeMap of hoDocument to hoCollectionId
74674>>>>>>>>>>>            Set XMLInterface of hoCollectionId to hinfcAttributes
74675>>>>>>>>>>>        End
74675>>>>>>>>>>>>
74675>>>>>>>>>>>        Function_Return hoCollectionId
74676>>>>>>>>>>>    End_Function
74677>>>>>>>>>>>    
74677>>>>>>>>>>>    
74677>>>>>>>>>>>    // Returns a collection of just elements
74677>>>>>>>>>>>    
74677>>>>>>>>>>>    Function ElementNodes String sQueryString Returns Handle
74679>>>>>>>>>>>        Handle hoNodeList
74679>>>>>>>>>>>        Handle hinfcNodeList
74679>>>>>>>>>>>        Get ElementsByTagName sQueryString to hinfcNodeList
74680>>>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
74683>>>>>>>>>>>        Function_Return hoNodeList
74684>>>>>>>>>>>    End_Function
74685>>>>>>>>>>>    
74685>>>>>>>>>>>    
74685>>>>>>>>>>>    
74685>>>>>>>>>>>    // Return object handle for query.
74685>>>>>>>>>>>    
74685>>>>>>>>>>>    Function FindNode String sQueryString Returns Handle
74687>>>>>>>>>>>        Handle hoNode
74687>>>>>>>>>>>        Handle hinfcNode
74687>>>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcNode
74688>>>>>>>>>>>        If (hinfcNode <> 0) ;            Get CreateXMLNode hInfcNode to hoNode
74691>>>>>>>>>>>        Function_Return hoNode
74692>>>>>>>>>>>    End_Function
74693>>>>>>>>>>>    
74693>>>>>>>>>>>    // Return object handle for a collection node.
74693>>>>>>>>>>>    
74693>>>>>>>>>>>    
74693>>>>>>>>>>>    Function FindNodeList String sQueryString Returns Handle
74695>>>>>>>>>>>        Handle hoNodeList
74695>>>>>>>>>>>        Handle hinfcNodeList
74695>>>>>>>>>>>        Get SelectNodes sQueryString to hinfcNodeList
74696>>>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
74699>>>>>>>>>>>        Function_Return hoNodeList
74700>>>>>>>>>>>    End_Function
74701>>>>>>>>>>>    
74701>>>>>>>>>>>    // The CreatexxxxxNode messages creates an node object for the type specified. Both
74701>>>>>>>>>>>    // the interface and the object or of the correct type (i.e. element, comment)
74701>>>>>>>>>>>    // These all return an object handle which can be used to place the object via
74701>>>>>>>>>>>    // appendNode or InsertBeforeNode
74701>>>>>>>>>>>    
74701>>>>>>>>>>>    // This function creates a child element, returning a dataflex object.
74701>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
74701>>>>>>>>>>>    // the element to the XML Document.
74701>>>>>>>>>>>    
74701>>>>>>>>>>>    Function CreateElementNode String sTagName String sValue Returns Handle
74703>>>>>>>>>>>        Handle hoNewElement
74703>>>>>>>>>>>        Handle hoDocumentObject
74703>>>>>>>>>>>        Handle infcNewElement
74703>>>>>>>>>>>        Integer iClassId
74703>>>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
74703>>>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
74703>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74704>>>>>>>>>>>        Get createElement of hoDocumentObject sTagName to infcNewElement
74705>>>>>>>>>>>        If infcNewElement Begin // if there was an error, no infc handle would be returned
74707>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ELEMENT to iClassId
74708>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewElement to hoNewElement
74709>>>>>>>>>>>            If hoNewElement ; // very unlikely this will be zero                Set psText of hoNewElement to sValue
74712>>>>>>>>>>>        End
74712>>>>>>>>>>>>
74712>>>>>>>>>>>        Function_Return hoNewElement
74713>>>>>>>>>>>    End_Function
74714>>>>>>>>>>>    
74714>>>>>>>>>>>    // This function creates an attribute in a document. Attributes are _NOT_ children of an element.
74714>>>>>>>>>>>    // A DataFlex object is returned. An attribute can be added to an xml document using
74714>>>>>>>>>>>    // get AddAttributeNode.
74714>>>>>>>>>>>    
74714>>>>>>>>>>>    Function CreateAttributeNode String sName String sValue Returns Handle
74716>>>>>>>>>>>        Handle hoNewAttribute
74716>>>>>>>>>>>        Handle hoDocumentObject
74716>>>>>>>>>>>        Handle infcNewAttribute
74716>>>>>>>>>>>        Integer iClassId
74716>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74717>>>>>>>>>>>        // Create an Attribute in the document and assign its interface to the new DF object.
74717>>>>>>>>>>>        Get createAttribute of hoDocumentObject sName to infcNewAttribute
74718>>>>>>>>>>>        If infcNewAttribute Begin // if there was an error, no infc handle would be returned
74720>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ATTRIBUTE to iClassId
74721>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewAttribute to hoNewAttribute
74722>>>>>>>>>>>            // Set the value of the attribute.
74722>>>>>>>>>>>            If hoNewAttribute ; // very unlikely this will be 0                Set psText of hoNewAttribute to sValue
74725>>>>>>>>>>>        End
74725>>>>>>>>>>>>
74725>>>>>>>>>>>        Function_Return hoNewAttribute
74726>>>>>>>>>>>    End_Function
74727>>>>>>>>>>>    
74727>>>>>>>>>>>    // This function creates a child comment, returning a dataflex object.
74727>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
74727>>>>>>>>>>>    // the comment to the XML Document.
74727>>>>>>>>>>>    
74727>>>>>>>>>>>    Function CreateChildComment String sValue Returns Handle
74729>>>>>>>>>>>        Handle hoNewComment
74729>>>>>>>>>>>        Handle hoDocumentObject
74729>>>>>>>>>>>        Handle infcNewComment
74729>>>>>>>>>>>        Integer iClassID
74729>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74730>>>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
74730>>>>>>>>>>>        Get createComment of hoDocumentObject sValue to infcNewComment
74731>>>>>>>>>>>        If infcNewComment Begin // if there was an error, no infc handle would be returned
74733>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_COMMENT to iClassId
74734>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewComment to hoNewComment
74735>>>>>>>>>>>            If hoNewComment ; // very unlikely this will be 0                Set psText of hoNewComment to sValue
74738>>>>>>>>>>>        End
74738>>>>>>>>>>>>
74738>>>>>>>>>>>        Function_Return hoNewComment
74739>>>>>>>>>>>    End_Function
74740>>>>>>>>>>>    
74740>>>>>>>>>>>    // This function creates a child processing instruction, returning a dataflex object.
74740>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
74740>>>>>>>>>>>    // the processing instruction to the XML Document.
74740>>>>>>>>>>>    
74740>>>>>>>>>>>    Function CreateChildProcessingInstruction String sTarget String sValue Returns Handle
74742>>>>>>>>>>>        Handle hoNewProcessingInstruction
74742>>>>>>>>>>>        Handle hoDocumentObject
74742>>>>>>>>>>>        Handle infcNewProcessingInstruction
74742>>>>>>>>>>>        Integer iClassID
74742>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74743>>>>>>>>>>>        // Create an ProcessingInstruction in the document and assign its interface to the new DF object.
74743>>>>>>>>>>>        Get createProcessingInstruction of hoDocumentObject sTarget sValue to infcNewProcessingInstruction
74744>>>>>>>>>>>        If infcNewProcessingInstruction  Begin // if there was an error, no infc handle would be returned
74746>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_PROCESSING_INSTRUCTION to iClassId
74747>>>>>>>>>>>            Get CreateXMLObject iClassID infcNewProcessingInstruction to hoNewProcessingInstruction
74748>>>>>>>>>>>        End
74748>>>>>>>>>>>>
74748>>>>>>>>>>>        Function_Return hoNewProcessingInstruction
74749>>>>>>>>>>>    End_Function
74750>>>>>>>>>>>    
74750>>>>>>>>>>>    // This function creates a child text node, returning a dataflex object.
74750>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
74750>>>>>>>>>>>    // the text node to the XML Document.
74750>>>>>>>>>>>    
74750>>>>>>>>>>>    Function CreateChildTextNode String sValue Returns Handle
74752>>>>>>>>>>>        Handle hoNewTextNode
74752>>>>>>>>>>>        Handle hoDocumentObject
74752>>>>>>>>>>>        Handle infcNewTextNode
74752>>>>>>>>>>>        Integer iClassID
74752>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74753>>>>>>>>>>>        // Create an TextNode in the document and assign its interface to the new DF object.
74753>>>>>>>>>>>        Get createTextNode of hoDocumentObject sValue to infcNewTextNode
74754>>>>>>>>>>>        If infcNewTextNode Begin // if there was an error, no infc handle would be returned
74756>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_TEXT to iClassId
74757>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewTextNode to hoNewTextNode
74758>>>>>>>>>>>        End
74758>>>>>>>>>>>>
74758>>>>>>>>>>>        Function_Return hoNewTextNode
74759>>>>>>>>>>>    End_Function
74760>>>>>>>>>>>    
74760>>>>>>>>>>>    // This function creates a cdata text node, returning a dataflex object.
74760>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
74760>>>>>>>>>>>    // the cdata node to the XML Document.
74760>>>>>>>>>>>    
74760>>>>>>>>>>>    Function CreateCDATASectionNode String sValue Returns Handle
74762>>>>>>>>>>>        Handle hoNewNode
74762>>>>>>>>>>>        Handle hoDocumentObject
74762>>>>>>>>>>>        Handle infcNewNode
74762>>>>>>>>>>>        Integer iClassId
74762>>>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
74762>>>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
74762>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74763>>>>>>>>>>>        Get createCDATASection of hoDocumentObject sValue to infcNewNode
74764>>>>>>>>>>>        If infcNewNode Begin
74766>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_CDATA_SECTION to iClassId
74767>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewNode to hoNewNode
74768>>>>>>>>>>>        End
74768>>>>>>>>>>>>
74768>>>>>>>>>>>        Function_Return hoNewNode
74769>>>>>>>>>>>    End_Function
74770>>>>>>>>>>>    
74770>>>>>>>>>>>    // Create a document fragment.  Document fragments can be used to house nodes temporarily. When
74770>>>>>>>>>>>    // You append or insert a document fragment (appendNode InsertBeforeNode) child nodes are appended
74770>>>>>>>>>>>    // to the destination object and not the fragment node itself. This is useful!
74770>>>>>>>>>>>    
74770>>>>>>>>>>>    Function CreateDocumentFragmentNode Returns Handle
74772>>>>>>>>>>>        Handle hoNew
74772>>>>>>>>>>>        Handle hoDocumentObject
74772>>>>>>>>>>>        Handle infcNew
74772>>>>>>>>>>>        Integer iClassID
74772>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74773>>>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
74773>>>>>>>>>>>        Get createDocumentFragment of hoDocumentObject to infcNew
74774>>>>>>>>>>>        If infcNew Begin // if there was an error, no infc handle would be returned
74776>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_DOCUMENT_FRAGMENT to iClassId
74777>>>>>>>>>>>            Get CreateXMLObject iClassId infcNew to hoNew
74778>>>>>>>>>>>        End
74778>>>>>>>>>>>>
74778>>>>>>>>>>>        Function_Return hoNew
74779>>>>>>>>>>>    End_Function
74780>>>>>>>>>>>    
74780>>>>>>>>>>>    //  Create a Node of any passed Type (e.g. Node_element). Normally you don't need this as there are
74780>>>>>>>>>>>    //  specific messages to do this for each node type. Node that this lets you pass namespaces as a separate
74780>>>>>>>>>>>    //  parameter. With all of the other messages (e.g. createElementNode) you pass namespaces as prefixed to
74780>>>>>>>>>>>    // the tagname (e.g. Get CreateElementNode "MyNameSpace:MyTag" "MyValue" to hoEle)
74780>>>>>>>>>>>    
74780>>>>>>>>>>>    Function CreateChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
74782>>>>>>>>>>>        Handle hoNewNode hoDocumentObject
74782>>>>>>>>>>>        Handle infcNewNode
74782>>>>>>>>>>>        Integer iClassid iType
74782>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74783>>>>>>>>>>>        Get NodeClassId iNodeType to iClassId
74784>>>>>>>>>>>        If (iClassId<>0) Begin
74786>>>>>>>>>>>            // Create a node in the document and assign its interface to the new DF object.
74786>>>>>>>>>>>            Get createNode of hoDocumentObject iNodeType sTagName sNameSpace to infcNewNode
74787>>>>>>>>>>>            // this is required to force the interface type to be correct.
74787>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, infcNewNode, 0, 0, 0, 0)) to iType
74788>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, infcNewNode, iType, 1, 0, 0)) to infcNewNode
74789>>>>>>>>>>>            
74789>>>>>>>>>>>            If infcNewNode ;                Get CreateXMLObject iClassId infcNewNode to hoNewNode
74792>>>>>>>>>>>        End
74792>>>>>>>>>>>>
74792>>>>>>>>>>>        Function_Return hoNewNode
74793>>>>>>>>>>>    End_Function
74794>>>>>>>>>>>    
74794>>>>>>>>>>>    
74794>>>>>>>>>>>    
74794>>>>>>>>>>>    // The Addxxxxx messages create a new node and appends it to the list. When used as a function,
74794>>>>>>>>>>>    // the object handle is returned and must be disposed of later by the programmer.
74794>>>>>>>>>>>    // When used as a procedure, the object is destroyed--it just does it and is done.
74794>>>>>>>>>>>    
74794>>>>>>>>>>>    Function AddElement String sTagName String sValue Returns Handle
74796>>>>>>>>>>>        Handle hoNewElement
74796>>>>>>>>>>>        Get CreateElementNode sTagName sValue to hoNewElement
74797>>>>>>>>>>>        If hoNewElement ;            Get AppendNode hoNewElement to hoNewElement
74800>>>>>>>>>>>        Function_Return hoNewElement
74801>>>>>>>>>>>    End_Function
74802>>>>>>>>>>>    
74802>>>>>>>>>>>    Procedure AddElement String sTagName String sValue
74804>>>>>>>>>>>        Handle hoNewElement
74804>>>>>>>>>>>        Get AddElement sTagName sValue to hoNewElement
74805>>>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
74808>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElement"))
74810>>>>>>>>>>>    End_Procedure
74811>>>>>>>>>>>    
74811>>>>>>>>>>>    // this returns the object, This is often needed
74811>>>>>>>>>>>    Function CreateElementNodeNS String sNameSpace String sTagName String sValue Returns Handle
74813>>>>>>>>>>>        Handle hoNewElement
74813>>>>>>>>>>>        Get CreateChildNode NODE_ELEMENT sTagName sNameSpace to hoNewElement
74814>>>>>>>>>>>        If (hoNewElement and sValue<>"") ;            Set psText of hoNewElement to sValue
74817>>>>>>>>>>>        Function_Return hoNewElement
74818>>>>>>>>>>>    End_Function
74819>>>>>>>>>>>    
74819>>>>>>>>>>>    
74819>>>>>>>>>>>    // this returns the object, This is often needed
74819>>>>>>>>>>>    Function AddElementNS String sNameSpace String sTagName String sValue Returns Handle
74821>>>>>>>>>>>        Handle hoNewElement
74821>>>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName sValue to hoNewElement
74822>>>>>>>>>>>        If hoNewElement Begin
74824>>>>>>>>>>>            Get AppendNode hoNewElement to hoNewElement
74825>>>>>>>>>>>        End
74825>>>>>>>>>>>>
74825>>>>>>>>>>>        Function_Return hoNewElement
74826>>>>>>>>>>>    End_Function
74827>>>>>>>>>>>    
74827>>>>>>>>>>>    Procedure AddElementNS String sNameSpace String sTagName String sValue
74829>>>>>>>>>>>        Handle hoNewElement
74829>>>>>>>>>>>        Get AddElementNS sNameSpace sTagName sValue to hoNewElement
74830>>>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
74833>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElementNS"))
74835>>>>>>>>>>>    End_Procedure
74836>>>>>>>>>>>    
74836>>>>>>>>>>>    Function AddAttributeNode Handle hoNode Returns Handle
74838>>>>>>>>>>>        Handle hInfc
74838>>>>>>>>>>>        Get Set_AttributeNode (XmlInterface(hoNode)) to hInfc
74839>>>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Set XmlInterface of hoNode to hInfc
74842>>>>>>>>>>>        Function_Return hoNode
74843>>>>>>>>>>>    End_Function
74844>>>>>>>>>>>    
74844>>>>>>>>>>>    Function AttributeValueNode String sName Returns Handle
74846>>>>>>>>>>>        Handle hInfc
74846>>>>>>>>>>>        Handle hoNode
74846>>>>>>>>>>>        Get AttributeNode sName to hInfc
74847>>>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Get CreateXMLNode hInfc to hoNode
74850>>>>>>>>>>>        Function_Return hoNode
74851>>>>>>>>>>>    End_Function
74852>>>>>>>>>>>    
74852>>>>>>>>>>>    Function AttributeValueNodeNS String sNameSpace String sBaseName Returns Handle
74854>>>>>>>>>>>        Handle hoAttrs hoAttr
74854>>>>>>>>>>>        String sValue
74854>>>>>>>>>>>        Get TempAttributeNodes to hoAttrs
74855>>>>>>>>>>>        If hoAttrs Begin
74857>>>>>>>>>>>            Get QualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
74858>>>>>>>>>>>            Set XMLInterface of hoAttrs to 0
74859>>>>>>>>>>>        End
74859>>>>>>>>>>>>
74859>>>>>>>>>>>        Function_Return hoAttr
74860>>>>>>>>>>>    End_Function
74861>>>>>>>>>>>    
74861>>>>>>>>>>>    
74861>>>>>>>>>>>    Function CreateAttributeNodeNS String sNameSpace String sName String sValue Returns Handle
74863>>>>>>>>>>>        Handle hoNewAttribute
74863>>>>>>>>>>>        Get CreateChildNode NODE_ATTRIBUTE sName sNameSpace to hoNewAttribute
74864>>>>>>>>>>>        If hoNewAttribute ;            Set psText of hoNewAttribute to sValue
74867>>>>>>>>>>>        Function_Return hoNewAttribute
74868>>>>>>>>>>>    End_Function
74869>>>>>>>>>>>    
74869>>>>>>>>>>>    Procedure AddAttributeNS String sNameSpace String sName String sValue
74871>>>>>>>>>>>        Handle hoNode
74871>>>>>>>>>>>        Get CreateAttributeNodeNS sNameSpace sName sValue to hoNode
74872>>>>>>>>>>>        If hoNode Begin
74874>>>>>>>>>>>            Get AddAttributeNode hoNode to hoNode
74875>>>>>>>>>>>            If hoNode ;                Send Destroy of hoNode
74878>>>>>>>>>>>        End
74878>>>>>>>>>>>>
74878>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddAttributeNS"))
74880>>>>>>>>>>>    End_Procedure
74881>>>>>>>>>>>    
74881>>>>>>>>>>>    
74881>>>>>>>>>>>    // This function encapsulates creation and addition of attributes to a node.
74881>>>>>>>>>>>    // should only work with element class
74881>>>>>>>>>>>    Procedure AddAttribute String sName String sValue
74883>>>>>>>>>>>        Set AttributeValue sName to sValue
74884>>>>>>>>>>>    End_Procedure
74885>>>>>>>>>>>    
74885>>>>>>>>>>>    // This function encapsulates creation and addition of comments to a node.
74885>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
74885>>>>>>>>>>>    
74885>>>>>>>>>>>    Procedure AddChildComment String sValue
74887>>>>>>>>>>>        Handle hoNewNode
74887>>>>>>>>>>>        Get createChildComment sValue to hoNewNode
74888>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildComment"))
74891>>>>>>>>>>>        Else Begin
74892>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
74893>>>>>>>>>>>            Send Destroy to hoNewNode
74894>>>>>>>>>>>        End
74894>>>>>>>>>>>>
74894>>>>>>>>>>>    End_Procedure
74895>>>>>>>>>>>    
74895>>>>>>>>>>>    // This function encapsulates creation and addition of processing instructions to a node.
74895>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
74895>>>>>>>>>>>    
74895>>>>>>>>>>>    Procedure AddChildProcessingInstruction String sTarget String sValue
74897>>>>>>>>>>>        Handle hoNewNode
74897>>>>>>>>>>>        Get createChildProcessingInstruction sTarget sValue to hoNewNode
74898>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildProcessingInstruction"))
74901>>>>>>>>>>>        Else Begin
74902>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
74903>>>>>>>>>>>            Send Destroy to hoNewNode
74904>>>>>>>>>>>        End
74904>>>>>>>>>>>>
74904>>>>>>>>>>>    End_Procedure
74905>>>>>>>>>>>    
74905>>>>>>>>>>>    
74905>>>>>>>>>>>    // This function encapsulates creation and addition of text nodes to a node.
74905>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
74905>>>>>>>>>>>    
74905>>>>>>>>>>>    Procedure AddChildTextNode String sValue
74907>>>>>>>>>>>        Handle hoNewNode
74907>>>>>>>>>>>        Get createChildTextNode sValue to hoNewNode
74908>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildTextNode"))
74911>>>>>>>>>>>        Else Begin
74912>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
74913>>>>>>>>>>>            Send Destroy to hoNewNode
74914>>>>>>>>>>>        End
74914>>>>>>>>>>>>
74914>>>>>>>>>>>    End_Procedure
74915>>>>>>>>>>>    
74915>>>>>>>>>>>    // This procedure encapsulates creation and addition of cdata text nodes to a node.
74915>>>>>>>>>>>    Procedure AddCDataSection String sValue
74917>>>>>>>>>>>        Handle hoNewNode
74917>>>>>>>>>>>        Get CreateCDATASectionNode sValue to hoNewNode
74918>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddCDataSection"))
74921>>>>>>>>>>>        Else Begin
74922>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
74923>>>>>>>>>>>            Send Destroy to hoNewNode
74924>>>>>>>>>>>        End
74924>>>>>>>>>>>>
74924>>>>>>>>>>>    End_Procedure
74925>>>>>>>>>>>    
74925>>>>>>>>>>>    
74925>>>>>>>>>>>    Function AddChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
74927>>>>>>>>>>>        Handle hoNewNode
74927>>>>>>>>>>>        Handle hoDocumentObject
74927>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
74928>>>>>>>>>>>        Get createChildNode of hoDocumentObject iNodeType sTagName sNamespace to hoNewNode
74929>>>>>>>>>>>        If hoNewNode ;            Get AppendNode hoNewNode to hoNewNode
74932>>>>>>>>>>>        Function_Return hoNewNode
74933>>>>>>>>>>>    End_Function
74934>>>>>>>>>>>    
74934>>>>>>>>>>>    // don't use the runtime/msxml version of this. Instead just return the
74934>>>>>>>>>>>    // first text from the first child node. This is much faster
74934>>>>>>>>>>>    Function psText Returns String
74936>>>>>>>>>>>        Handle hText
74936>>>>>>>>>>>        String sValue
74936>>>>>>>>>>>        Get phFirstChild to hText
74937>>>>>>>>>>>        Get InfcNodeValue hText to sValue
74938>>>>>>>>>>>        Function_Return sValue
74939>>>>>>>>>>>    End_Function
74940>>>>>>>>>>>    
74940>>>>>>>>>>>    // Use this to call the internal Text property. This returns all text for all child
74940>>>>>>>>>>>    // node. You rarely would want to do this. The is uses the msxml psText which can
74940>>>>>>>>>>>    // get slow with very large files. If for some reason you need all of the child node's
74940>>>>>>>>>>>    // text and the file is large, you might want to consider doing this process manually.
74940>>>>>>>>>>>    Function AllChildNodesText Returns String
74942>>>>>>>>>>>        String sValue
74942>>>>>>>>>>>        Forward Get psText to sValue
74944>>>>>>>>>>>        Function_Return sValue
74945>>>>>>>>>>>    End_Function
74946>>>>>>>>>>>    
74946>>>>>>>>>>>    // return the interface NodeValue without having to create a
74946>>>>>>>>>>>    // new object. This also disposes the hInfc interface
74946>>>>>>>>>>>    Function InfcNodeValue Handle hInfc Returns String
74948>>>>>>>>>>>        Handle hoDocument hoTempNode
74948>>>>>>>>>>>        String sValue
74948>>>>>>>>>>>        If (hinfc) Begin
74950>>>>>>>>>>>            Get DocumentObject to hoDocument
74951>>>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
74952>>>>>>>>>>>            Set XMLInterface of hoTempNode to hInfc
74953>>>>>>>>>>>            Get psNodeValue of hoTempNode to sValue
74954>>>>>>>>>>>            // This disposes of hInfc which was passed in. After
74954>>>>>>>>>>>            // calling this you can no longer use it (which is good).
74954>>>>>>>>>>>            Set XMLInterface of hoTempNode to 0
74955>>>>>>>>>>>        End
74955>>>>>>>>>>>>
74955>>>>>>>>>>>        Function_Return sValue
74956>>>>>>>>>>>    End_Function
74957>>>>>>>>>>>    
74957>>>>>>>>>>>    // ChildNodeValue is used to get the "value" of an element. This is useful when the element
74957>>>>>>>>>>>    // only has a single value (similar to an attribute).
74957>>>>>>>>>>>    
74957>>>>>>>>>>>    Function ChildNodeValue String sTagName Returns String
74959>>>>>>>>>>>        Handle hoTempNode hoDocument
74959>>>>>>>>>>>        Handle hinfcTempNode
74959>>>>>>>>>>>        String sRetVal
74959>>>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
74960>>>>>>>>>>>        If (hinfcTempNode <> 0) Begin
74962>>>>>>>>>>>            Get DocumentObject to hoDocument
74963>>>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
74964>>>>>>>>>>>            Set XMLInterface of hoTempNode to hinfcTempNode
74965>>>>>>>>>>>            Get phFirstChild of hoTempNode to hinfcTempNode
74966>>>>>>>>>>>            Set XMLInterface of hoTempNode to 0
74967>>>>>>>>>>>            If hinfcTempNode Begin
74969>>>>>>>>>>>                Get InfcNodeValue hinfcTempNode to sRetVal
74970>>>>>>>>>>>            End
74970>>>>>>>>>>>>
74970>>>>>>>>>>>        End
74970>>>>>>>>>>>>
74970>>>>>>>>>>>        Function_Return sRetVal
74971>>>>>>>>>>>    End_Function
74972>>>>>>>>>>>    
74972>>>>>>>>>>>    // This simple function allows a parent to change the text of one of its elements.
74972>>>>>>>>>>>    // This actually occurs quite a bit, because (as stated above) lowest level
74972>>>>>>>>>>>    // elements are frequently used as properties.
74972>>>>>>>>>>>    //
74972>>>>>>>>>>>    Procedure SetChildNodeValue String sTagName String sValue
74974>>>>>>>>>>>        Handle hoTempNode
74974>>>>>>>>>>>        Handle hinfcTempNode
74974>>>>>>>>>>>        // Search for the node that matches.
74974>>>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
74975>>>>>>>>>>>        // If no match is found, add a new element with the tag.
74975>>>>>>>>>>>        If (hinfcTempNode = 0) ;            Send AddElement sTagName sValue
74978>>>>>>>>>>>        Else Begin
74979>>>>>>>>>>>            Get CreateXMLObject U_BaseXMLDOMNode hinfcTempNode to hoTempNode
74980>>>>>>>>>>>            If hoTempNode Begin
74982>>>>>>>>>>>                // Set the text of the element.
74982>>>>>>>>>>>                Set psText of hoTempNode to sValue
74983>>>>>>>>>>>                Send Destroy to hoTempNode
74984>>>>>>>>>>>            End
74984>>>>>>>>>>>>
74984>>>>>>>>>>>            Else ;                Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_SetChildNodeValue"))
74986>>>>>>>>>>>        End
74986>>>>>>>>>>>>
74986>>>>>>>>>>>    End_Procedure
74987>>>>>>>>>>>    
74987>>>>>>>>>>>    // These messages are used to allow you to travese through a nodes.
74987>>>>>>>>>>>    
74987>>>>>>>>>>>    Function FirstChild Returns Handle
74989>>>>>>>>>>>        Handle hoChild
74989>>>>>>>>>>>        Handle hinfcChild
74989>>>>>>>>>>>        Get phFirstChild  to hinfcChild
74990>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
74993>>>>>>>>>>>        Function_Return hoChild
74994>>>>>>>>>>>    End_Function
74995>>>>>>>>>>>    
74995>>>>>>>>>>>    Function NextSibling Returns Handle
74997>>>>>>>>>>>        Handle hoChild
74997>>>>>>>>>>>        Handle hinfcChild
74997>>>>>>>>>>>        Get phNextSibling  to hinfcChild
74998>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75001>>>>>>>>>>>        Function_Return hoChild
75002>>>>>>>>>>>    End_Function
75003>>>>>>>>>>>    
75003>>>>>>>>>>>    Function PreviousSibling Returns Handle
75005>>>>>>>>>>>        Handle hoChild
75005>>>>>>>>>>>        Handle hinfcChild
75005>>>>>>>>>>>        Get phPreviousSibling  to hinfcChild
75006>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75009>>>>>>>>>>>        Function_Return hoChild
75010>>>>>>>>>>>    End_Function
75011>>>>>>>>>>>    
75011>>>>>>>>>>>    Function LastChild Returns Handle
75013>>>>>>>>>>>        Handle hoChild
75013>>>>>>>>>>>        Handle hinfcChild
75013>>>>>>>>>>>        Get phLastChild  to hinfcChild
75014>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75017>>>>>>>>>>>        Function_Return hoChild
75018>>>>>>>>>>>    End_Function
75019>>>>>>>>>>>    
75019>>>>>>>>>>>    // return an object that is the parent of the current node
75019>>>>>>>>>>>    Function ParentNode Returns Handle
75021>>>>>>>>>>>        Handle hoId
75021>>>>>>>>>>>        Handle hinfcXMLInterface
75021>>>>>>>>>>>        Get phParentNode to hinfcXMLInterface
75022>>>>>>>>>>>        If (hinfcXMLInterface) ;            Get CreateXmlNode hinfcXMLInterface to hoID
75025>>>>>>>>>>>        Function_Return hoID
75026>>>>>>>>>>>    End_Function
75027>>>>>>>>>>>    
75027>>>>>>>>>>>    // Same as NextSibling except it uses or destroys the current node
75027>>>>>>>>>>>    //
75027>>>>>>>>>>>    // optimized version does not destroy/create object unless it needs to.
75027>>>>>>>>>>>    // if the next node is the same node type we will resuse this object
75027>>>>>>>>>>>    // else this object is destroyed
75027>>>>>>>>>>>    Function NextNode Returns Handle
75029>>>>>>>>>>>        Handle hoNode hoDocument
75029>>>>>>>>>>>        Handle hInfc
75029>>>>>>>>>>>        Get phNextSibling to hInfc
75030>>>>>>>>>>>        If hInfc Begin
75032>>>>>>>>>>>            Get DocumentObject to hoDocument
75033>>>>>>>>>>>            Move Self to hoNode
75034>>>>>>>>>>>            Send BindXMLInfc of hoDocument hInfc (&hoNode)
75035>>>>>>>>>>>        End
75035>>>>>>>>>>>>
75035>>>>>>>>>>>        Else Begin
75036>>>>>>>>>>>            Send Destroy
75037>>>>>>>>>>>            Move 0 to hoNode
75038>>>>>>>>>>>        End
75038>>>>>>>>>>>>
75038>>>>>>>>>>>        Function_Return hoNode
75039>>>>>>>>>>>    End_Function
75040>>>>>>>>>>>    
75040>>>>>>>>>>>    
75040>>>>>>>>>>>    // Enumerate through all nodes.
75040>>>>>>>>>>>    
75040>>>>>>>>>>>    Procedure EnumerateNodes Integer iMsg Handle hoReceiver String sVal1 String sVal2
75042>>>>>>>>>>>        Integer i iLen
75042>>>>>>>>>>>        Handle hoNode
75042>>>>>>>>>>>        Handle hoNodeCollection
75042>>>>>>>>>>>        Get ChildNodes to hoNodeCollection
75043>>>>>>>>>>>        If (hoNodeCollection <> 0) Begin
75045>>>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
75046>>>>>>>>>>>            Decrement iLen
75047>>>>>>>>>>>            For i from 0 to iLen
75053>>>>>>>>>>>>
75053>>>>>>>>>>>                // For each record, process its fields.
75053>>>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
75054>>>>>>>>>>>                Send iMsg of hoReceiver hoNode sVal1 sVal2
75055>>>>>>>>>>>                Send Destroy of hoNode
75056>>>>>>>>>>>            Loop
75057>>>>>>>>>>>>
75057>>>>>>>>>>>            Send Destroy of hoNodeCollection
75058>>>>>>>>>>>        End
75058>>>>>>>>>>>>
75058>>>>>>>>>>>    End_Procedure
75059>>>>>>>>>>>    
75059>>>>>>>>>>>    // Enumerate through all elements.
75059>>>>>>>>>>>    
75059>>>>>>>>>>>    Procedure EnumerateElements Integer iMsg Handle hoReceiver String sVal1 String sVal2
75061>>>>>>>>>>>        Integer i iLen
75061>>>>>>>>>>>        Handle hoNode
75061>>>>>>>>>>>        Handle hoNodeCollection
75061>>>>>>>>>>>        Get ChildNodes to hoNodeCollection
75062>>>>>>>>>>>        If (hoNodeCollection <> 0) Begin
75064>>>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
75065>>>>>>>>>>>            Decrement iLen
75066>>>>>>>>>>>            For i from 0 to iLen
75072>>>>>>>>>>>>
75072>>>>>>>>>>>                // For each record, process its fields.
75072>>>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
75073>>>>>>>>>>>                If (piNodeType(hoNode)=NODE_ELEMENT) ;                    Send iMsg of hoReceiver hoNode sVal1 sVal2
75076>>>>>>>>>>>                Send Destroy of hoNode
75077>>>>>>>>>>>            Loop
75078>>>>>>>>>>>>
75078>>>>>>>>>>>            Send Destroy of hoNodeCollection
75079>>>>>>>>>>>        End
75079>>>>>>>>>>>>
75079>>>>>>>>>>>    End_Procedure
75080>>>>>>>>>>>    
75080>>>>>>>>>>>    
75080>>>>>>>>>>>    // enumerate through all attributes. There is no recurse here because attributes will not
75080>>>>>>>>>>>    // contain attributes.
75080>>>>>>>>>>>    
75080>>>>>>>>>>>    Procedure EnumerateAttributes Integer iMsg Handle hoReceiver String sSomeValue
75082>>>>>>>>>>>        Integer i iLen
75082>>>>>>>>>>>        Handle hoNode
75082>>>>>>>>>>>        Handle hoNodeMapCollection
75082>>>>>>>>>>>        // we don't use tempattributenodes because we don't know what the enum message will do.
75082>>>>>>>>>>>        Get AttributeNodes to hoNodeMapCollection
75083>>>>>>>>>>>        If (hoNodeMapCollection <> 0) Begin
75085>>>>>>>>>>>            Get NodeListLength of hoNodeMapCollection to iLen
75086>>>>>>>>>>>            Decrement iLen
75087>>>>>>>>>>>            For i from 0 to iLen
75093>>>>>>>>>>>>
75093>>>>>>>>>>>                // For each record, process its fields.
75093>>>>>>>>>>>                Get CollectionNode of hoNodeMapCollection i to hoNode
75094>>>>>>>>>>>                Send iMsg of hoReceiver hoNode sSomeValue
75095>>>>>>>>>>>                Send Destroy of hoNode
75096>>>>>>>>>>>            Loop
75097>>>>>>>>>>>>
75097>>>>>>>>>>>            Send Destroy of hoNodeMapCollection
75098>>>>>>>>>>>        End
75098>>>>>>>>>>>>
75098>>>>>>>>>>>    End_Procedure
75099>>>>>>>>>>>    
75099>>>>>>>>>>>    
75099>>>>>>>>>>>    Function XSLTransformation Handle hoXSLDocument Returns String
75101>>>>>>>>>>>        Handle infcXSLStartAt
75101>>>>>>>>>>>        String sBuffer
75101>>>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
75101>>>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
75102>>>>>>>>>>>        Get TransformNode infcXSLStartAt to sBuffer
75103>>>>>>>>>>>        Function_Return sBuffer
75104>>>>>>>>>>>    End_Function
75105>>>>>>>>>>>    
75105>>>>>>>>>>>    // This allows for transformations not limited to the size of the string buffer
75105>>>>>>>>>>>    //
75105>>>>>>>>>>>    // Note that it is up to the programmer to dispose of the memory allocated at pBuffer
75105>>>>>>>>>>>    // by using the free(pBuffer) function
75105>>>>>>>>>>>    //
75105>>>>>>>>>>>    Function XSLTransformationToAddress Handle hoXSLDocument Returns Address
75107>>>>>>>>>>>        Handle infcXSLStartAt
75107>>>>>>>>>>>        Address pBuffer
75107>>>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
75107>>>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
75108>>>>>>>>>>>        Get TransformNodeToAddress infcXSLStartAt to pBuffer
75109>>>>>>>>>>>        Function_Return pBuffer
75110>>>>>>>>>>>    End_Function
75111>>>>>>>>>>>    
75111>>>>>>>>>>>    
75111>>>>>>>>>>>    // extract base name from string. e.g.: ns:name --> name
75111>>>>>>>>>>>    //
75111>>>>>>>>>>>    Function BaseNameFromQName String sName Returns String
75113>>>>>>>>>>>        Integer iPos
75113>>>>>>>>>>>        Move (Pos(":",sName)) to iPos
75114>>>>>>>>>>>        If iPos Begin
75116>>>>>>>>>>>            Move (remove(sName,1,iPos)) to sName
75117>>>>>>>>>>>        End
75117>>>>>>>>>>>>
75117>>>>>>>>>>>        Function_Return sName
75118>>>>>>>>>>>    End_Function
75119>>>>>>>>>>>    
75119>>>>>>>>>>>    // extract prefix name from string. e.g.: ns:name --> ns
75119>>>>>>>>>>>    //
75119>>>>>>>>>>>    Function PrefixNameFromQName String sName Returns String
75121>>>>>>>>>>>        String sPreFix
75121>>>>>>>>>>>        Integer iPos
75121>>>>>>>>>>>        Move (Pos(":",sName)) to iPos
75122>>>>>>>>>>>        If iPos Begin
75124>>>>>>>>>>>            Move (Left(sName,iPos-1)) to sPreFix
75125>>>>>>>>>>>        End
75125>>>>>>>>>>>>
75125>>>>>>>>>>>        Function_Return sPreFix
75126>>>>>>>>>>>    End_Function
75127>>>>>>>>>>>    
75127>>>>>>>>>>>    
75127>>>>>>>>>>>    // Returns true if node is element and namespace and base name match
75127>>>>>>>>>>>    //
75127>>>>>>>>>>>    Function IsElementNS String sNamespaceURI String sBaseName Returns Boolean
75129>>>>>>>>>>>        Function_Return (piNodeType(Self)=NODE_ELEMENT and ;            psNameSpaceURI(Self)=sNamespaceURI and ;            psBaseName(Self)=sBaseName )
75130>>>>>>>>>>>    End_Function
75131>>>>>>>>>>>    
75131>>>>>>>>>>>    // Returns node of first occurence of child node matching namespace and base name
75131>>>>>>>>>>>    //
75131>>>>>>>>>>>    Function ChildElementNS String sNameSpaceURI String sBaseName Returns Handle
75133>>>>>>>>>>>        Handle hoNode
75133>>>>>>>>>>>        Get FirstChild to hoNode
75134>>>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
75138>>>>>>>>>>>            Get NextNode of hoNode to hoNode
75139>>>>>>>>>>>        Loop
75140>>>>>>>>>>>>
75140>>>>>>>>>>>        Function_Return hoNode
75141>>>>>>>>>>>    End_Function
75142>>>>>>>>>>>    
75142>>>>>>>>>>>    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
75144>>>>>>>>>>>        Handle hoNode
75144>>>>>>>>>>>        // NextNode may return the same object or it may destroy the object and
75144>>>>>>>>>>>        // return nothing or a different object
75144>>>>>>>>>>>        Get NextNode to hoNode
75145>>>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
75149>>>>>>>>>>>            // use of hoNode is required. This can be different than self
75149>>>>>>>>>>>            Get NextNode of hoNode to hoNode
75150>>>>>>>>>>>        Loop
75151>>>>>>>>>>>>
75151>>>>>>>>>>>        
75151>>>>>>>>>>>        Function_Return hoNode
75152>>>>>>>>>>>    End_Function
75153>>>>>>>>>>>    
75153>>>>>>>>>>>    
75153>>>>>>>>>>>    // Returns value (string) first occurence of child node matching namespace and base name
75153>>>>>>>>>>>    //
75153>>>>>>>>>>>    Function ChildElementValueNS String sNameSpaceURI String sBaseName Returns String
75155>>>>>>>>>>>        Handle hoNext
75155>>>>>>>>>>>        String sText
75155>>>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNext
75156>>>>>>>>>>>        If hoNext Begin
75158>>>>>>>>>>>            Get psText of hoNext to sText
75159>>>>>>>>>>>            Send destroy of hoNext
75160>>>>>>>>>>>        End
75160>>>>>>>>>>>>
75160>>>>>>>>>>>        Function_Return sText
75161>>>>>>>>>>>    End_Function
75162>>>>>>>>>>>    
75162>>>>>>>>>>>    Procedure SetChildElementValueNS String sNameSpaceURI String sBaseName String sValue
75164>>>>>>>>>>>        Handle hoNode
75164>>>>>>>>>>>        Handle hinfcTempNode
75164>>>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNode
75165>>>>>>>>>>>        If (hoNode=0) Begin
75167>>>>>>>>>>>            Send AddElementNS sNameSpaceURI sBaseName sValue
75168>>>>>>>>>>>        End
75168>>>>>>>>>>>>
75168>>>>>>>>>>>        Else Begin
75169>>>>>>>>>>>            Set psText of hoNode to sValue
75170>>>>>>>>>>>            Send destroy of hoNode
75171>>>>>>>>>>>        End
75171>>>>>>>>>>>>
75171>>>>>>>>>>>    End_Procedure
75172>>>>>>>>>>>    
75172>>>>>>>>>>>    // pass a prefix and try to finds its NameSpaceURI. Start at current node and work up to parent.
75172>>>>>>>>>>>    // This can be useful when a qualified name is found in an attribute value
75172>>>>>>>>>>>    //
75172>>>>>>>>>>>    Function PrefixToNamespaceURI String sPrefix Returns String
75174>>>>>>>>>>>        Handle hoNode
75174>>>>>>>>>>>        Integer i iNodes
75174>>>>>>>>>>>        Handle hoNodes hoParentNode hoAttNode
75174>>>>>>>>>>>        Boolean bDone bParent
75174>>>>>>>>>>>        String sAttPrefix sName sNameSpace
75174>>>>>>>>>>>        
75174>>>>>>>>>>>        Move Self to hoNode
75175>>>>>>>>>>>        While not bDone
75179>>>>>>>>>>>            Get TempAttributeNodes of hoNode to hoNodes
75180>>>>>>>>>>>            If (hoNodes <> 0) Begin
75182>>>>>>>>>>>                Get NodeListLength of hoNodes to iNodes
75183>>>>>>>>>>>                For i from 0 to (iNodes-1)
75189>>>>>>>>>>>>
75189>>>>>>>>>>>                    // For each record, process its fields.
75189>>>>>>>>>>>                    Get CollectionNode of hoNodes i to hoAttNode
75190>>>>>>>>>>>                    Get psPrefix of hoAttNode to sAttPrefix
75191>>>>>>>>>>>                    Get psBaseName of hoAttNode to sName
75192>>>>>>>>>>>                    // with legacy msxml, xmlns="foo" returns psPrefix="xmlns" and pbBaseName=""
75192>>>>>>>>>>>                    // with newer msxml, xmlns="foo" returns psPrefix="" and pbBaseName="xmlns"
75192>>>>>>>>>>>                    // We handle both cases here.
75192>>>>>>>>>>>                    
75192>>>>>>>>>>>                    If ( (sAttPrefix="xmlns" and sName=sPrefix) or ; // if a normal xmlns:xx="foo" match (sPrefix="xx") or a legacy xmlns="foo" match (sPrefix="")                        (sPrefix="" and sAttPrefix="" and sName="xmlns") ) Begin // special test for newer msxml xmlns="foo" match (sPrefix="")
75194>>>>>>>>>>>                        
75194>>>>>>>>>>>                        Get Value of hoAttNode to sNameSpace
75195>>>>>>>>>>>                        Move True to bDone
75196>>>>>>>>>>>                        Move (iNodes-1) to i
75197>>>>>>>>>>>                        
75197>>>>>>>>>>>                    End
75197>>>>>>>>>>>>
75197>>>>>>>>>>>                    
75197>>>>>>>>>>>                    Send Destroy of hoAttNode
75198>>>>>>>>>>>                Loop
75199>>>>>>>>>>>>
75199>>>>>>>>>>>                Set XMLInterface of hoNodes to 0
75200>>>>>>>>>>>            End
75200>>>>>>>>>>>>
75200>>>>>>>>>>>            
75200>>>>>>>>>>>            Get ParentNode of hoNode to hoParentNode
75201>>>>>>>>>>>            If bParent ;                Send destroy of hoNode
75204>>>>>>>>>>>            If not bDone Begin
75206>>>>>>>>>>>                If not hoParentNode ;                    Move True to bDone
75209>>>>>>>>>>>                Else Begin
75210>>>>>>>>>>>                    Move True to bParent
75211>>>>>>>>>>>                    Move hoParentNode to hoNode
75212>>>>>>>>>>>                End
75212>>>>>>>>>>>>
75212>>>>>>>>>>>            End
75212>>>>>>>>>>>>
75212>>>>>>>>>>>        Loop
75213>>>>>>>>>>>>
75213>>>>>>>>>>>        Function_Return sNameSpace
75214>>>>>>>>>>>    End_Function
75215>>>>>>>>>>>    
75215>>>>>>>>>>>    
75215>>>>>>>>>>>    
75215>>>>>>>>>>>End_Class
75216>>>>>>>>>>>
75216>>>>>>>>>>>// Set up basic inheritance for specialized forms of XML classes.
75216>>>>>>>>>>>// This needs to be done so we can make objects of these types.
75216>>>>>>>>>>>
75216>>>>>>>>>>>Class cXMLDOMElement is a BaseXmlDomElement
75217>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75218>>>>>>>>>>>    
75218>>>>>>>>>>>    // Should use AddAttributeValue...does same thing
75218>>>>>>>>>>>    Procedure SetAttributeValue String sName String sValue
75220>>>>>>>>>>>        Send AddAttribute sName sValue
75221>>>>>>>>>>>    End_Procedure
75222>>>>>>>>>>>    
75222>>>>>>>>>>>    // Note: Get_AttributeValue already there
75222>>>>>>>>>>>    
75222>>>>>>>>>>>    Procedure RemoveAttribute String sName
75224>>>>>>>>>>>        Integer iVal
75224>>>>>>>>>>>        Get RemoveAttribute sName to iVal
75225>>>>>>>>>>>    End_Procedure
75226>>>>>>>>>>>    
75226>>>>>>>>>>>    Function AttributeValueNS String sNameSpace String sBaseName Returns String
75228>>>>>>>>>>>        String sValue
75228>>>>>>>>>>>        Handle hinfcItem
75228>>>>>>>>>>>        Handle hoDoc hoTempAttributeNodes hoNode
75228>>>>>>>>>>>        Integer hinfcAttributes
75228>>>>>>>>>>>        
75228>>>>>>>>>>>        Get TempAttributeNodes to hoTempAttributeNodes
75229>>>>>>>>>>>        Get QualifiedItem of hoTempAttributeNodes sBaseName sNameSpace  to hinfcItem
75230>>>>>>>>>>>        Set XMLInterface of hoTempAttributeNodes to 0
75231>>>>>>>>>>>        If hinfcItem Begin
75233>>>>>>>>>>>            Get DocumentObject to hoDoc
75234>>>>>>>>>>>            Get phoTempDomNode of hoDoc to hoNode
75235>>>>>>>>>>>            Set XMLInterface of hoNode to hinfcItem
75236>>>>>>>>>>>            Get psNodeValue of hoNode to sValue
75237>>>>>>>>>>>            Set XMLInterface of hoNode to 0
75238>>>>>>>>>>>        End
75238>>>>>>>>>>>>
75238>>>>>>>>>>>        Function_Return sValue
75239>>>>>>>>>>>    End_Function
75240>>>>>>>>>>>    
75240>>>>>>>>>>>    Procedure RemoveAttributeNS String sNameSpace String sBaseName
75242>>>>>>>>>>>        Handle hoAttrs hoAttr
75242>>>>>>>>>>>        String sValue
75242>>>>>>>>>>>        Get TempAttributeNodes to hoAttrs
75243>>>>>>>>>>>        If hoAttrs Begin
75245>>>>>>>>>>>            Get RemoveQualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
75246>>>>>>>>>>>            Set XMLInterface of hoAttrs to 0
75247>>>>>>>>>>>            If hoAttr ;                Send destroy of hoAttr
75250>>>>>>>>>>>        End
75250>>>>>>>>>>>>
75250>>>>>>>>>>>    End_Procedure
75251>>>>>>>>>>>    
75251>>>>>>>>>>>End_Class
75252>>>>>>>>>>>
75252>>>>>>>>>>>Class cXMLDOMNode is a BaseXmlDomNode
75253>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75254>>>>>>>>>>>End_Class
75255>>>>>>>>>>>
75255>>>>>>>>>>>Class cXMLDOMAttribute is a BaseXmlDomAttribute
75256>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75257>>>>>>>>>>>End_Class
75258>>>>>>>>>>>
75258>>>>>>>>>>>Class cXMLDOMComment is a BaseXmlDomComment
75259>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75260>>>>>>>>>>>End_Class
75261>>>>>>>>>>>
75261>>>>>>>>>>>Class cXMLDOMProcessingInstruction is a BaseXmlDomProcessingInstruction
75262>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75263>>>>>>>>>>>End_Class
75264>>>>>>>>>>>
75264>>>>>>>>>>>Class cXMLDOMTextNode is a BaseXmlDomTextNode
75265>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75266>>>>>>>>>>>End_Class
75267>>>>>>>>>>>
75267>>>>>>>>>>>Class cXMLDOMCDATASection is a BaseXmlDomCDATASection
75268>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75269>>>>>>>>>>>End_Class
75270>>>>>>>>>>>
75270>>>>>>>>>>>Class cXMLDOMDocumentType is a BaseXmlDomDocumentType
75271>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75272>>>>>>>>>>>    
75272>>>>>>>>>>>End_Class
75273>>>>>>>>>>>
75273>>>>>>>>>>>Class cXMLDOMNotation is a BaseXmlDomNotation
75274>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75275>>>>>>>>>>>End_Class
75276>>>>>>>>>>>
75276>>>>>>>>>>>Class cXMLDOMEntity is a BaseXmlDomEntity
75277>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75278>>>>>>>>>>>End_Class
75279>>>>>>>>>>>
75279>>>>>>>>>>>Class cXMLDOMEntityReference is a BaseXmlDomEntityReference
75280>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75281>>>>>>>>>>>End_Class
75282>>>>>>>>>>>
75282>>>>>>>>>>>Class cXMLDOMDocumentFragment is a BaseXmlDomDocumentFragment
75283>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75284>>>>>>>>>>>End_Class
75285>>>>>>>>>>>
75285>>>>>>>>>>>
75285>>>>>>>>>>>Class cXMLDOMParseError is a BaseXMLDomParseError
75286>>>>>>>>>>>    // returns an error sub-object as a sibling of this error object
75286>>>>>>>>>>>    Function ErrorItemNode Integer iItem Returns Handle
75288>>>>>>>>>>>        Handle hoParseErrorNode hoParent
75288>>>>>>>>>>>        Handle hParseErrorIntf
75288>>>>>>>>>>>        Get ErrorItem iItem to hParseErrorIntf
75289>>>>>>>>>>>        If (hParseErrorIntf) Begin
75291>>>>>>>>>>>            // add to parent in case developer destroys the current object
75291>>>>>>>>>>>            Get Parent to hoParent
75292>>>>>>>>>>>            Get Create of hoParent U_cXMLDOMParseError to hoParseErrorNode
75293>>>>>>>>>>>            Set XmlInterface of hoParseErrorNode to hParseErrorIntf
75294>>>>>>>>>>>        End
75294>>>>>>>>>>>>
75294>>>>>>>>>>>        Function_Return hoParseErrorNode
75295>>>>>>>>>>>    End_Function
75296>>>>>>>>>>>End_Class
75297>>>>>>>>>>>
75297>>>>>>>>>>>// Base document class with Base functions.
75297>>>>>>>>>>>
75297>>>>>>>>>>>Class cXMLDOMDocument is an BaseXmlDomDocument
75298>>>>>>>>>>>    
75298>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75299>>>>>>>>>>>    
75299>>>>>>>>>>>    Procedure Construct_Object
75301>>>>>>>>>>>        Handle hInfc
75301>>>>>>>>>>>        Forward Send Construct_Object
75303>>>>>>>>>>>        Property String psDocumentName ""
75304>>>>>>>>>>>        Property Integer phPrivateDocumentElement 0
75305>>>>>>>>>>>        Property Handle phoTempDomNode (Create(Self,U_cXMLDomNode))
75306>>>>>>>>>>>        Property Handle phoTempDomNodeMap (Create(Self,U_cXMLDOMNamedNodeMap))
75307>>>>>>>>>>>        
75307>>>>>>>>>>>        // added in 15.1. If no COM pointer, msxml6 is most likely not installed. This will
75307>>>>>>>>>>>        // raise an unhandled error, which could be augmented to do something else.
75307>>>>>>>>>>>        Get XmlInterface to hInfc
75308>>>>>>>>>>>        If (hInfc=0) Begin
75310>>>>>>>>>>>            Send ErrorCreatingXMLObject
75311>>>>>>>>>>>        End
75311>>>>>>>>>>>>
75311>>>>>>>>>>>        
75311>>>>>>>>>>>        // as of 18.0 pbAsync now defaults to False. In most cases, this is what you want
75311>>>>>>>>>>>        Set pbAsync to False
75312>>>>>>>>>>>    End_Procedure
75313>>>>>>>>>>>    
75313>>>>>>>>>>>    // returns the classId for the passed NodeType. This is a good augmentation point. All nodes
75313>>>>>>>>>>>    // within an xml document come here to get a class. So, if you want to augment and return a
75313>>>>>>>>>>>    // different class, just check the node type and return whatever -- else forward
75313>>>>>>>>>>>    
75313>>>>>>>>>>>    Function NodeClassId Integer iType Returns Integer
75315>>>>>>>>>>>        Integer iClassId
75315>>>>>>>>>>>        Case Begin
75315>>>>>>>>>>>            Case (iType=NODE_ELEMENT) ;                Move U_cXMLDOMElement      to iClassId
75318>>>>>>>>>>>            Case (iType=NODE_ATTRIBUTE) ;                Move U_cXMLDOMAttribute    to iClassId
75322>>>>>>>>>>>            Case (iType=NODE_TEXT) ;                Move U_cXMLDOMTextNode     to iClassId
75326>>>>>>>>>>>            Case (iType=NODE_CDATA_SECTION) ;                Move U_cXMLDOMCDATASection to iClassId
75330>>>>>>>>>>>            Case (iType=NODE_ENTITY_REFERENCE) ;                Move U_cXMLDOMEntityReference to iClassId
75334>>>>>>>>>>>            Case (iType=NODE_ENTITY) ;                Move U_cXMLDOMEntity       to iClassId
75338>>>>>>>>>>>            Case (iType=NODE_PROCESSING_INSTRUCTION) ;                Move U_cXMLDOMProcessingInstruction to iClassId
75342>>>>>>>>>>>            Case (iType=NODE_COMMENT) ;                Move U_cXMLDOMComment      to iClassId
75346>>>>>>>>>>>            Case (iType=NODE_DOCUMENT) ;                Move U_cXMLDOMDocument     to iClassId
75350>>>>>>>>>>>            Case (iType=NODE_DOCUMENT_TYPE) ;                Move U_cXMLDOMDocumentType to iClassId
75354>>>>>>>>>>>            Case (iType=NODE_DOCUMENT_FRAGMENT) ;                Move U_cXMLDOMDocumentFragment to iClassId
75358>>>>>>>>>>>            Case (iType=NODE_NOTATION) ;                Move U_cXMLDOMNotation     to iClassId
75362>>>>>>>>>>>            Case (iType=0) ;                Move 0                     to iClassId // this is an error!!
75366>>>>>>>>>>>            Case Else ;                Move U_cXMLDOMNode         to iClassId
75368>>>>>>>>>>>        Case End
75368>>>>>>>>>>>        Function_Return iClassId
75369>>>>>>>>>>>    End_Function
75370>>>>>>>>>>>    
75370>>>>>>>>>>>    // Load an XML Document. The name of the document is stored in a property
75370>>>>>>>>>>>    // that must be set for this function to work correctly.
75370>>>>>>>>>>>    
75370>>>>>>>>>>>    Function LoadXMLDocument Returns Integer
75372>>>>>>>>>>>        String sDocumentName
75372>>>>>>>>>>>        Integer bRetVal
75372>>>>>>>>>>>        Get psDocumentName to sDocumentName
75373>>>>>>>>>>>        Get LoadDocument sDocumentName to bRetVal
75374>>>>>>>>>>>        If (bRetVal = 0);            Function_Return True
75377>>>>>>>>>>>        Else;            Function_Return False
75379>>>>>>>>>>>    End_Function
75380>>>>>>>>>>>    
75380>>>>>>>>>>>    Function SaveXMLDocument Returns Integer
75382>>>>>>>>>>>        String sDocumentName
75382>>>>>>>>>>>        Integer bRetVal
75382>>>>>>>>>>>        Get psDocumentName to sDocumentName
75383>>>>>>>>>>>        Get SaveDocument sDocumentName to bRetVal
75384>>>>>>>>>>>        Function_Return bRetVal
75385>>>>>>>>>>>    End_Function
75386>>>>>>>>>>>    
75386>>>>>>>>>>>    // Load an XML from a string. This aguments the C message to ret 1 if Ok and 0 if error.
75386>>>>>>>>>>>    //
75386>>>>>>>>>>>    Function LoadXML String sXML Returns Integer
75388>>>>>>>>>>>        Integer bRetVal
75388>>>>>>>>>>>        // for some reason the parser will not work properly with embedded double quotes.
75388>>>>>>>>>>>        // Change all " to ' in document.
75388>>>>>>>>>>>        //Move (replaces('"',sXML,"'")) to sXML  // removed this. Bad Idea.
75388>>>>>>>>>>>        Forward Get LoadXml sXML to bRetVal
75390>>>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
75393>>>>>>>>>>>        Else;            Function_Return False
75395>>>>>>>>>>>    End_Function
75396>>>>>>>>>>>    
75396>>>>>>>>>>>    // Load an XML string from an address. This aguments the C message to ret 1 if Ok and 0 if error.
75396>>>>>>>>>>>    //
75396>>>>>>>>>>>    Function LoadXMLFromAddress Address pXML Returns Integer
75398>>>>>>>>>>>        Integer bRetVal
75398>>>>>>>>>>>        Forward Get LoadXmlFromAddress pXML to bRetVal
75400>>>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
75403>>>>>>>>>>>        Else;            Function_Return False
75405>>>>>>>>>>>    End_Function
75406>>>>>>>>>>>    
75406>>>>>>>>>>>    
75406>>>>>>>>>>>    // Allow Nodes and Node node lists to get the parent document.
75406>>>>>>>>>>>    
75406>>>>>>>>>>>    Function DocumentObject Returns Handle
75408>>>>>>>>>>>        Function_Return Self
75409>>>>>>>>>>>    End_Function
75410>>>>>>>>>>>    
75410>>>>>>>>>>>    // Access to the root node allows for searches and iterations.
75410>>>>>>>>>>>    // The root node is a cNode.
75410>>>>>>>>>>>    
75410>>>>>>>>>>>    Function DocumentElement Returns Handle
75412>>>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
75412>>>>>>>>>>>        Handle infcNode   // XML Element Interface
75412>>>>>>>>>>>        Get phDocumentElement to infcNode
75413>>>>>>>>>>>        If infcNode Begin
75415>>>>>>>>>>>            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
75416>>>>>>>>>>>            Set phPrivateDocumentElement to hNewNode // we no longer use this at all
75417>>>>>>>>>>>        End
75417>>>>>>>>>>>>
75417>>>>>>>>>>>        Function_Return hNewNode
75418>>>>>>>>>>>    End_Function
75419>>>>>>>>>>>    
75419>>>>>>>>>>>    //  CreateRootNode is used to set up the first element in a document.
75419>>>>>>>>>>>    //  It should only be used when creating new files.
75419>>>>>>>>>>>    
75419>>>>>>>>>>>    Function CreateDocumentElement String sTagName Returns Handle
75421>>>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
75421>>>>>>>>>>>        Handle infcNode   // XML Element Interface
75421>>>>>>>>>>>        // Call XML to create an element in the document.
75421>>>>>>>>>>>        Get CreateElement sTagName to infcNode
75422>>>>>>>>>>>        // Tie the element interface to the DataFlex object.
75422>>>>>>>>>>>        If infcNode ;            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
75425>>>>>>>>>>>        // Call XML to set the root element of the document.
75425>>>>>>>>>>>        Set phDocumentElement to infcNode
75426>>>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
75427>>>>>>>>>>>        Function_Return hNewNode
75428>>>>>>>>>>>    End_Function
75429>>>>>>>>>>>    
75429>>>>>>>>>>>    Function CreateDocumentElementNS String sNamespace String sTagName Returns Handle
75431>>>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
75431>>>>>>>>>>>        Handle infcNode iType  // XML Element Interface
75431>>>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName "" to hNewNode
75432>>>>>>>>>>>        Get XmlInterface of hNewNode to infcNode
75433>>>>>>>>>>>        Set phDocumentElement to infcNode
75434>>>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
75435>>>>>>>>>>>        Function_Return hNewNode
75436>>>>>>>>>>>    End_Function
75437>>>>>>>>>>>    
75437>>>>>>>>>>>    
75437>>>>>>>>>>>    
75437>>>>>>>>>>>    // return the DocType as a document-type object. Returns 0 if no dtd
75437>>>>>>>>>>>    // Access to information from the doc type object is limited. Use get psXML
75437>>>>>>>>>>>    Function DocTypeNode Returns Handle
75439>>>>>>>>>>>        Handle hinfcDocType hoDocType
75439>>>>>>>>>>>        Get phDocType to hinfcDocType
75440>>>>>>>>>>>        If hinfcDocType ;            Get CreateXMLObject U_cXMLDOMDocumentType hinfcDocType to hoDocType
75443>>>>>>>>>>>        Function_Return hoDocType
75444>>>>>>>>>>>    End_Function
75445>>>>>>>>>>>    
75445>>>>>>>>>>>    Function phXMLErrorObject Returns Handle
75447>>>>>>>>>>>        Handle hoParseErrorObject
75447>>>>>>>>>>>        Handle hInfcParseError
75447>>>>>>>>>>>        Get phParseError to hInfcParseError
75448>>>>>>>>>>>        If hInfcParseError ;            Get CreateXMLObject U_cXMLDOMParseError hinfcParseError to hoParseErrorObject
75451>>>>>>>>>>>        Function_Return hoParseErrorObject
75452>>>>>>>>>>>    End_Function
75453>>>>>>>>>>>    
75453>>>>>>>>>>>    //  The following procedure is meant to be overridden by one provided by the developer.
75453>>>>>>>>>>>    
75453>>>>>>>>>>>    Procedure BasicParseErrorReport
75455>>>>>>>>>>>        String sProblem
75455>>>>>>>>>>>        String sLinePosition
75455>>>>>>>>>>>        String sDescr
75455>>>>>>>>>>>        String sReason
75455>>>>>>>>>>>        String sSource
75455>>>>>>>>>>>        Handle hoParseErrorObject
75455>>>>>>>>>>>        Get phXMLErrorObject to hoParseErrorObject
75456>>>>>>>>>>>        If hoParseErrorObject Begin
75458>>>>>>>>>>>            Move (SFormat(C_$CannotLoad, psDocumentName(Self)) + "."+character(13)+character(10)) to sProblem
75459>>>>>>>>>>>            Move (SFormat(C_$ParsingError, piLine(hoParseErrorObject), piLinePos(hoParseErrorObject))) to sLinePosition
75460>>>>>>>>>>>            Move (sLinePosition +character(13)+character(10)) to sLinePosition
75461>>>>>>>>>>>            
75461>>>>>>>>>>>            Move (C_$Reason + ":" * (psReason(hoParseErrorObject))  +character(13)+character(10)) to sReason
75462>>>>>>>>>>>            Move (C_$Source + ":" * (psSrcText(hoParseErrorObject))) to sSource
75463>>>>>>>>>>>            Move (sProblem + sLinePosition + sReason + sSource) to sDescr
75464>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR sDescr
75465>>>>>>>>>>>>
75465>>>>>>>>>>>            Send Destroy of hoParseErrorObject
75466>>>>>>>>>>>        End
75466>>>>>>>>>>>>
75466>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR C_$NotCreatedParseObject
75468>>>>>>>>>>>    End_Procedure
75469>>>>>>>>>>>    
75469>>>>>>>>>>>    // bind an xml interface node to the passed XML object. If the
75469>>>>>>>>>>>    // object type is of the wrong type, we will destroy it and recreate it
75469>>>>>>>>>>>    // which is why hoNode is passed byRef.
75469>>>>>>>>>>>    // to use this you'd have to use the lower level private messages to get the
75469>>>>>>>>>>>    // xml interface handles and then bind them to an object. Just like in COM you could
75469>>>>>>>>>>>    // bind these to the same object, which might save some parsing time. This is made private
75469>>>>>>>>>>>    // because the time savings would probably be small and would not justify the extra
75469>>>>>>>>>>>    // complexity.
75469>>>>>>>>>>>    // It is a programming error to pass this a zero handle.
75469>>>>>>>>>>>    Procedure BindXMLInfc Handle hInfc Handle ByRef hoNode
75471>>>>>>>>>>>        Integer iType iClassId iType2
75471>>>>>>>>>>>        Get piNodeType of hoNode to iType2 // type of the DF XML object
75472>>>>>>>>>>>        
75472>>>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
75472>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
75473>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
75474>>>>>>>>>>>        If (hinfc=0) Begin
75476>>>>>>>>>>>            // this should not happen and we would need to know about this.
75476>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
75477>>>>>>>>>>>>
75477>>>>>>>>>>>            Procedure_Return 0
75478>>>>>>>>>>>        End
75478>>>>>>>>>>>>
75478>>>>>>>>>>>        // if the type is the same we can reuse the current object and binding it to the interface pointer
75478>>>>>>>>>>>        If (iType=iType2) Begin
75480>>>>>>>>>>>            // resuse Self and return
75480>>>>>>>>>>>            Set XMLInterface of hoNode to hInfc
75481>>>>>>>>>>>        End
75481>>>>>>>>>>>>
75481>>>>>>>>>>>        // if diffrent type, destroy the existing object and recreate it
75481>>>>>>>>>>>        Else Begin
75482>>>>>>>>>>>            Send Destroy of hoNode
75483>>>>>>>>>>>            Get NodeClassId iType to iClassId
75484>>>>>>>>>>>            Get CreateXMLObject iClassId hInfc to hoNode
75485>>>>>>>>>>>        End
75485>>>>>>>>>>>>
75485>>>>>>>>>>>    End_Procedure
75486>>>>>>>>>>>    
75486>>>>>>>>>>>    Function ValidateDocument Returns Handle
75488>>>>>>>>>>>        Handle hParseErrorIntf hoParseError
75488>>>>>>>>>>>        Forward Get ValidateDocument to hParseErrorIntf
75490>>>>>>>>>>>        If hParseErrorIntf Begin
75492>>>>>>>>>>>            Get CreateXMLObject U_cXMLDOMParseError hParseErrorIntf to hoParseError
75493>>>>>>>>>>>        End
75493>>>>>>>>>>>>
75493>>>>>>>>>>>        Function_Return hoParseError
75494>>>>>>>>>>>    End_Function
75495>>>>>>>>>>>    
75495>>>>>>>>>>>    Function AddExternalSchemaDocument String sSchema Handle hoSchema Returns Boolean
75497>>>>>>>>>>>        Handle hInfc
75497>>>>>>>>>>>        Boolean bOk
75497>>>>>>>>>>>        Get XmlInterface of hoSchema to hInfc
75498>>>>>>>>>>>        Forward Get AddExternalSchemaDocument sSchema hInfc to bOk
75500>>>>>>>>>>>        Function_Return (not(bOk))
75501>>>>>>>>>>>    End_Function
75502>>>>>>>>>>>    
75502>>>>>>>>>>>    Function AddExternalSchemaFile String sSchema String sFile Returns Boolean
75504>>>>>>>>>>>        Boolean bOk
75504>>>>>>>>>>>        Forward Get AddExternalSchemaFile sSchema sFile to bOk
75506>>>>>>>>>>>        Function_Return (not(bOk))
75507>>>>>>>>>>>    End_Function
75508>>>>>>>>>>>    
75508>>>>>>>>>>>    Procedure Set psSelectionNamespaces String sNamespaces
75510>>>>>>>>>>>        Set psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
75511>>>>>>>>>>>    End_Procedure
75512>>>>>>>>>>>    
75512>>>>>>>>>>>    Function psSelectionNamespaces Returns String
75514>>>>>>>>>>>        String  sNamespaces
75514>>>>>>>>>>>        Get psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
75515>>>>>>>>>>>        Function_Return sNamespaces
75516>>>>>>>>>>>    End_Function
75517>>>>>>>>>>>    
75517>>>>>>>>>>>    Procedure Set pbMultipleErrorMessages Boolean bMultipleErrors
75519>>>>>>>>>>>        Set pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
75520>>>>>>>>>>>    End_Procedure
75521>>>>>>>>>>>    
75521>>>>>>>>>>>    Function pbMultipleErrorMessages Returns Boolean
75523>>>>>>>>>>>        Boolean bMultipleErrors
75523>>>>>>>>>>>        Get pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
75524>>>>>>>>>>>        Function_Return bMultipleErrors
75525>>>>>>>>>>>    End_Function
75526>>>>>>>>>>>    
75526>>>>>>>>>>>    Procedure ErrorCreatingXMLObject
75528>>>>>>>>>>>        Error DFERR_XML_INTERNAL_ERROR "Could not create XML COM object. MSXML6 may not be properly installed and registered."
75529>>>>>>>>>>>>
75529>>>>>>>>>>>    End_Procedure
75530>>>>>>>>>>>    
75530>>>>>>>>>>>    // returns the last parse error. If 0, you know everything parsed. This can be
75530>>>>>>>>>>>    // used along wit pbReadyState to load XML documents in async mode.
75530>>>>>>>>>>>    Function LastParseError Returns Integer
75532>>>>>>>>>>>        Integer iErr
75532>>>>>>>>>>>        Handle hoParseErrorReport
75532>>>>>>>>>>>        Get phXMLErrorObject to hoParseErrorReport
75533>>>>>>>>>>>        Get piErrorCode of hoParseErrorReport to iErr
75534>>>>>>>>>>>        Send Destroy of hoParseErrorReport
75535>>>>>>>>>>>        Function_Return iErr
75536>>>>>>>>>>>    End_Function
75537>>>>>>>>>>>    
75537>>>>>>>>>>>    
75537>>>>>>>>>>>End_Class
75538>>>>>>>>>
75538>>>>>>>>>//Declare_Datafile ASDB
75538>>>>>>>>>//Declare_Datafile SYSFILE
75538>>>>>>>>>//Declare_Datafile VDFCLS
75538>>>>>>>>>//Declare_Datafile VDFPRNT
75538>>>>>>>>>//Declare_Datafile VDFPROP
75538>>>>>>>>>
75538>>>>>>>>>
75538>>>>>>>>>// 2001-01-09 -RvdW
75538>>>>>>>>>//#Replace CURRENT$WORKSPACE   "Hammer"
75538>>>>>>>>>
75538>>>>>>>>>// 2001-01-09 -RvdW
75538>>>>>>>>>//Use cApplicationEx.pkg
75538>>>>>>>>>//Use Startup.pkg
75538>>>>>>>>>//Object Splash_Screen is a SplashScreenPanel
75538>>>>>>>>>//    Set Bitmap to "LOGO.BMP"
75538>>>>>>>>>//    Send Activate
75538>>>>>>>>>//End_Object
75538>>>>>>>>>//
75538>>>>>>>>>//Object oApplication is a cApplicationEx
75538>>>>>>>>>//    Property Integer piWrkSpcNewFile                False
75538>>>>>>>>>//    Property Integer piWrkSpcSetVersion             False
75538>>>>>>>>>//    Property Integer piWrkSpcRegister               False
75538>>>>>>>>>//    Property String  psWrkSpcOpenFileName           ""
75538>>>>>>>>>//
75538>>>>>>>>>//    Set piCmdLineSupport    to True                 // Use it for CommandLine Parameters.
75538>>>>>>>>>//    Set psCompany           to CTH_Project_Name
75538>>>>>>>>>//    Set psProduct           to CTH_Programm_Name
75538>>>>>>>>>//    Set psVersion           to CTH_Version_No
75538>>>>>>>>>//    Set peHelpType          to htHtmlHelp
75538>>>>>>>>>//
75538>>>>>>>>>//    //@ RRS: Addded DF19 cConnection support
75538>>>>>>>>>//    Object oConnectionManager is a cConnectionManager
75538>>>>>>>>>//      // Set pbAutoConnect to False
75538>>>>>>>>>//    End_Object
75538>>>>>>>>>//
75538>>>>>>>>>//        // Propeties to store some global flags.
75538>>>>>>>>>//    Object oWrkSpcOpenFileNames is an Array
75538>>>>>>>>>//    End_Object
75538>>>>>>>>>//        // Sends the given Message to the given Object with all given
75538>>>>>>>>>//        // Parameters.
75538>>>>>>>>>//    Procedure WrkSpcDoForAllFiles Integer iMsg Integer hoDest
75538>>>>>>>>>//        Integer hoID iC
75538>>>>>>>>>//        String  sFile
75538>>>>>>>>>//        Move (oWrkSpcOpenFileNames(Self)) to hoID
75538>>>>>>>>>//        For iC from 0 to (Item_Count(hoID)-1)
75538>>>>>>>>>//            Get value of hoID item iC   to sFile
75538>>>>>>>>>//            If sFile Ne "" If iMsg If hoDest Begin
75538>>>>>>>>>//                Send iMsg to hoDest sFile
75538>>>>>>>>>//            End
75538>>>>>>>>>//        Loop
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//        // Procedure which are called when the CommandLineParameters are received.
75538>>>>>>>>>//    Procedure WrkSpcRegister
75538>>>>>>>>>//      Set piWrkSpcRegister    to True
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//    Procedure WrkSpcOpenFile String sFile
75538>>>>>>>>>//        Integer iArg
75538>>>>>>>>>//        String  sArg
75538>>>>>>>>>//        Set psWrkSpcOpenFileName    to sFile
75538>>>>>>>>>//        Send Delete_Data            to (oWrkSpcOpenFileNames(Self))
75538>>>>>>>>>//        For iArg from 1 to NUM_Arguments
75538>>>>>>>>>//            Move iArg&   to sArg
75538>>>>>>>>>//            If (Trim(sArg)) Ne "" Begin
75538>>>>>>>>>//                Set value of (oWrkSpcOpenFileNames(Self)) item (Item_Count(oWrkSpcOpenFileNames(Self))) to sArg
75538>>>>>>>>>//            End
75538>>>>>>>>>//        Loop
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//    Procedure WrkSpcNewFile
75538>>>>>>>>>//        Set piWrkSpcNewFile         to True
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//    Procedure WrkSpcSetVersion
75538>>>>>>>>>//        Set piWrkSpcSetVersion      to True
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//        // Commands which should been handled from the CmdLine:
75538>>>>>>>>>//    Send RegisterCommand "-REGISTER"    Msg_WrkSpcRegister      0 "Associates all VDF Filetypes to the Hammer."
75538>>>>>>>>>//    Send RegisterCommand "-OPEN"        Msg_WrkSpcOpenFile      0 "Opens the given file."
75538>>>>>>>>>//    Send SetDefaultCommand              // -OPEN is the default Command.
75538>>>>>>>>>//    Send RegisterCommand "-NEW"         Msg_WrkSpcNewFile       0 "Opens a empty file view."
75538>>>>>>>>>//    Send RegisterCommand "-SETVERSION"  Msg_WrkSpcSetVersion    0 "Opens the Version/ Workspace dialog on startup"
75538>>>>>>>>>//
75538>>>>>>>>>//    Procedure OnCreate
75538>>>>>>>>>//        Send DoOpenWorkspace (CURRENT$WORKSPACE)
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//    Procedure OpenTH3DB Integer iFileNum
75538>>>>>>>>>////      Boolean bOpened
75538>>>>>>>>>////      String  sFileName
75538>>>>>>>>>////      String  sTH3DataPath
75538>>>>>>>>>////      tTH3DB[] TH3DB
75538>>>>>>>>>////
75538>>>>>>>>>////      Get pTH3DB to TH3DB
75538>>>>>>>>>////      Get psDataPath of (phoWorkspace(Self)) to sTH3DataPath
75538>>>>>>>>>////      Get vFolderFormat sTH3DataPath to sTH3DataPath
75538>>>>>>>>>////      Get_Attribute DF_FILE_OPENED of iFileNum to bOpened
75538>>>>>>>>>////      If (bOpened) Begin
75538>>>>>>>>>////        Get_Attribute DF_FILE_PHYSICAL_NAME of iFileNum to sFileName
75538>>>>>>>>>////        Get ParseFileName sFileName to sFileName // we want no path
75538>>>>>>>>>////      End
75538>>>>>>>>>////      Case Begin
75538>>>>>>>>>////        Case (iFileNum=ASDB.File_Number)
75538>>>>>>>>>////          If (Uppercase(sFileName)<>"ASDB") Begin
75538>>>>>>>>>////            If (bOpened) Close iFileNum
75538>>>>>>>>>////            Open (sTH3DataPath+"ASDB") as ASDB
75538>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////          Else Begin
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////        Case Break
75538>>>>>>>>>////        Case (iFileNum=SYSFILE.File_Number)
75538>>>>>>>>>////          If (Uppercase(sFileName)<>"SYSFILE") Begin
75538>>>>>>>>>////            If (bOpened) Close iFileNum
75538>>>>>>>>>////            Open (sTH3DataPath+"SYSFILE") as SYSFILE
75538>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////          Else Begin
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////        Case Break
75538>>>>>>>>>////        Case (iFileNum=VDFCLS.File_Number)
75538>>>>>>>>>////          If (Uppercase(sFileName)<>"VDFCLS") Begin
75538>>>>>>>>>////            If (bOpened) Close iFileNum
75538>>>>>>>>>////            Open (sTH3DataPath+"VDFCLS") as VDFCLS
75538>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////          Else Begin
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////        Case Break
75538>>>>>>>>>////        Case (iFileNum=VDFPRNT.File_Number)
75538>>>>>>>>>////          If (Uppercase(sFileName)<>"VDFCLS") Begin
75538>>>>>>>>>////            If (bOpened) Close iFileNum
75538>>>>>>>>>////            Open (sTH3DataPath+"VDFCLS") as VDFPRNT
75538>>>>>>>>>////            Set_Attribute DF_FILE_ALIAS Of VDFPRNT.File_number To DF_FILE_IS_ALIAS
75538>>>>>>>>>////            Set_Attribute DF_FILE_ALIAS Of VDFCLS.File_number  To DF_FILE_IS_MASTER
75538>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////          Else Begin
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////        Case Break
75538>>>>>>>>>////        Case (iFileNum=VDFPROP.File_Number)
75538>>>>>>>>>////          If (Uppercase(sFileName)<>"VDFPROP") Begin
75538>>>>>>>>>////            If (bOpened) Close iFileNum
75538>>>>>>>>>////            Open (sTH3DataPath+"VDFPROP") as VDFPROP
75538>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////          Else Begin
75538>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75538>>>>>>>>>////          End
75538>>>>>>>>>////        Case Break
75538>>>>>>>>>////      Case End
75538>>>>>>>>>////      Set pTH3DB to TH3DB
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//    Procedure CloseTH3DB Integer iFileNum
75538>>>>>>>>>//      Integer iSize
75538>>>>>>>>>//      tTH3DB[] TH3DB
75538>>>>>>>>>//
75538>>>>>>>>>//      Get pTH3DB to TH3DB
75538>>>>>>>>>//      Move (SizeOfArray(TH3DB)-1) To iSize
75538>>>>>>>>>//      If (iFileNum>=iSize) Begin
75538>>>>>>>>>//        If (TH3DB[iFileNum].bIsOpen) Begin
75538>>>>>>>>>//          Close iFileNum
75538>>>>>>>>>//          Move False To TH3DB[iFileNum].bIsOpen
75538>>>>>>>>>//        End
75538>>>>>>>>>//        If (TH3DB[iFileNum].bReOpen) Begin
75538>>>>>>>>>//          Open iFileNum // reopens file that current filelist points to.
75538>>>>>>>>>//        End
75538>>>>>>>>>//        Set pTH3DB to TH3DB
75538>>>>>>>>>//      End
75538>>>>>>>>>//    End_Procedure
75538>>>>>>>>>//
75538>>>>>>>>>//End_Object // oApplication
75538>>>>>>>>>
75538>>>>>>>>>Function THWinRegClassesRootValue String sBranch String sKey Returns String
75540>>>>>>>>>//    Handle hCurrentRoot
75540>>>>>>>>>//    String sCurrentPath
75540>>>>>>>>>//    String sRetVal sValue
75540>>>>>>>>>//    UInteger hKey
75540>>>>>>>>>//    Integer iSize iError hRootKey
75540>>>>>>>>>//
75540>>>>>>>>>//#IF (!@ >= 200)
75540>>>>>>>>>//    WString wsBranch
75540>>>>>>>>>//    WString wsValue
75540>>>>>>>>>//    
75540>>>>>>>>>//    Move (sBranch+Character(0)) To wsBranch
75540>>>>>>>>>//    Get_Registry_Root To hCurrentRoot sCurrentPath
75540>>>>>>>>>//    Move 0 To hKey
75540>>>>>>>>>//    Move (RegOpenKeyEx(HKEY_CLASSES_ROOT, wsBranch, 0, KEY_READ, AddressOf(hKey))) to iError
75540>>>>>>>>>//    If (hKey<>0) Begin
75540>>>>>>>>>//        Move 200 to iSize
75540>>>>>>>>>//        Move (ZeroString(iSize)) to wsValue
75540>>>>>>>>>//        Move (RegQueryValueEx(hKey, sKey, 0, 0, AddressOf(wsValue), AddressOf(iSize))) To iError
75540>>>>>>>>>//        Move (CString(wsValue)) to sRetVal
75540>>>>>>>>>//        Move (RegCloseKey(hKey)) to iError
75540>>>>>>>>>//    End
75540>>>>>>>>>//    Set_Registry_Root to hCurrentRoot sCurrentPath
75540>>>>>>>>>//#ELSE
75540>>>>>>>>>//    Get_Registry_Root To hCurrentRoot sCurrentPath
75540>>>>>>>>>//    Move 0 To hKey
75540>>>>>>>>>//    Move (RegOpenKeyEx(HKEY_CLASSES_ROOT, ToAnsi(sBranch), 0, KEY_READ, AddressOf(hKey))) to iError
75540>>>>>>>>>//    If (hKey<>0) Begin
75540>>>>>>>>>//        Move 100 to iSize
75540>>>>>>>>>//        Move (ZeroString(iSize)) to sValue
75540>>>>>>>>>//        Move (RegQueryValueEx(hKey, sKey, 0, 0, AddressOf(sValue), AddressOf(iSize))) to iError
75540>>>>>>>>>//        Move (CString(sValue)) to sRetVal
75540>>>>>>>>>//        Move (RegCloseKey(hKey)) to iError
75540>>>>>>>>>//    End
75540>>>>>>>>>//    Set_Registry_Root to hCurrentRoot sCurrentPath
75540>>>>>>>>>//#ENDIF
75540>>>>>>>>>//
75540>>>>>>>>>//    Function_Return sRetVal
75540>>>>>>>>>End_Function
75541>>>>>>>>>
75541>>>>>>>>>// Provided as a list of Event IDs (but seems like not required)
75541>>>>>>>>>Function THCompilerEventID String sVersion Returns String
75543>>>>>>>>>    If (sVersion="12.0") Function_Return "{E4C3F246-8F3B-49C6-88E9-3BE282B6990A}"
75546>>>>>>>>>    If (sVersion="12.1") Function_Return "{6621490D-0725-44D0-ACF5-86B42A4718F9}"
75549>>>>>>>>>    If (sVersion="14.0") Function_Return "{72F51D9A-D76E-474F-8ACE-3276FD7E9D61}"
75552>>>>>>>>>    If (sVersion="14.1") Function_Return "{B4F4CE77-4CCB-4B64-9297-7A83484EAD0F}"
75555>>>>>>>>>    If (sVersion="15.0") Function_Return "{2C4E9D67-AB48-4F73-8BF2-A837723F150B}"
75558>>>>>>>>>    If (sVersion="15.1") Function_Return "{01367077-9E13-458E-B393-936C8DBF6BD2}"
75561>>>>>>>>>    If (sVersion="16.0") Function_Return "{765949AB-411F-47B6-9DC8-CC2934DD6C93}"
75564>>>>>>>>>    If (sVersion="16.1") Function_Return "{7EF7BDFC-193D-4852-BD42-8F29D8E13558}"
75567>>>>>>>>>    If (sVersion="17.0") Function_Return "{DAA0B8DD-A193-4B44-89A4-0FD195158897}"
75570>>>>>>>>>    If (sVersion="17.1") Function_Return "{05A055A7-F12E-4B10-A878-0CB4B1B91AF4}"
75573>>>>>>>>>    If (sVersion="18.0") Function_Return "{D2508C70-B95A-4B3A-86C5-C043DE93A1CD}"
75576>>>>>>>>>    If (sVersion="18.1") Function_Return "{A218E494-0D49-4FBC-B883-54C8312AB504}"
75579>>>>>>>>>    If (sVersion="18.2") Function_Return "{3788BA01-C926-4B82-A3BD-936E67E00C54}"
75582>>>>>>>>>    If (sVersion="19.0") Function_Return "{2C22F54E-164C-4B28-A089-5357B54A2371}"
75585>>>>>>>>>    If (sVersion="19.1") Function_Return ""
75588>>>>>>>>>    Function_Return ""
75589>>>>>>>>>End_Function
75590>>>>>>>>>
75590>>>>>>>>>Procedure THEnumerateBuiltInCompilers
75592>>>>>>>>>//    Integer iVersion iVersionStart iVersionStop iSubVersion iSubVersions iCompiler
75592>>>>>>>>>//    String  sCompiler sVersion sResult sProgID sEventID
75592>>>>>>>>>//    tTHCompiler[] THCompilers
75592>>>>>>>>>//
75592>>>>>>>>>//    Move 12 to iVersionStart
75592>>>>>>>>>//    Move 25 to iVersionStop
75592>>>>>>>>>//    Move  3 to iSubVersions
75592>>>>>>>>>//    Get pTHCompilers of ghoApplication To THCompilers
75592>>>>>>>>>//    For iVersion from iVersionStart to iVersionStop
75592>>>>>>>>>//        For iSubVersion from 0 to iSubVersions
75592>>>>>>>>>//            Move (String(iVersion)+"."+String(iSubVersion)) to sVersion
75592>>>>>>>>>//            Move ("vdfcompctl.VDFCompiler."+sVersion) to sCompiler
75592>>>>>>>>>//            Move (THWinRegClassesRootValue(Self, sCompiler, "")) to sResult
75592>>>>>>>>>//            If (Uppercase(sResult)="VDFCOMPILER OBJECT") Begin
75592>>>>>>>>>//                // Looks like it works perfectly without Event ID
75592>>>>>>>>>////                Get  THCompilerEventID sVersion     to sEventID
75592>>>>>>>>>////                If (sEventID<>"") Begin
75592>>>>>>>>>//                    Move (SizeOfArray(THCompilers))                         to iCompiler
75592>>>>>>>>>//                    Move sVersion                                           to THCompilers[iCompiler].sVersion
75592>>>>>>>>>//                    Get  THWinRegClassesRootValue (sCompiler+"\CLSID") ""   to sProgID
75592>>>>>>>>>//                    Move sProgID                                            to THCompilers[iCompiler].sProgID
75592>>>>>>>>>//                    Move sEventID                                           to THCompilers[iCompiler].sEventId
75592>>>>>>>>>////                End // EventID
75592>>>>>>>>>//            End // Compiler Object
75592>>>>>>>>>//        Loop
75592>>>>>>>>>//    Loop
75592>>>>>>>>>//    Set pTHCompilers of ghoApplication To THCompilers
75592>>>>>>>>>End_Procedure
75593>>>>>>>>>//Send THEnumerateBuiltInCompilers
75593>>>>>>>>>
75593>>>>>>>>>Function THFindBuiltInCompiler String sVersion Returns Integer
75595>>>>>>>>>//    tTHCompiler ltTHCompiler
75595>>>>>>>>>//    tTHCompiler[] THCompilers
75595>>>>>>>>>//    Move sVersion To ltTHCompiler.sVersion
75595>>>>>>>>>//    Get pTHCompilers of ghoApplication To THCompilers
75595>>>>>>>>>//    Function_Return (SearchArray(ltTHCompiler, THCompilers))
75595>>>>>>>>>End_Function
75596>>>>>>>>>
75596>>>>>>>>>Function THFindWorkspaceFile String sPath String sType Returns String
75598>>>>>>>>>//    String sWSFile
75598>>>>>>>>>//    Direct_Input ("DIR:"+sPath+"*."+sType)
75598>>>>>>>>>//    While (not(SeqEof))
75598>>>>>>>>>//        Readln sWSFile
75598>>>>>>>>>//        If (sWSFile<>"") Break
75598>>>>>>>>>//    Loop
75598>>>>>>>>>//    Close_Input
75598>>>>>>>>>//    Function_Return sWSFile
75598>>>>>>>>>End_Function
75599>>>>>>>>>
75599>>>>>>>>>Function THNewWorkspaceName String sPath Returns String
75601>>>>>>>>>//    String sWSFile
75601>>>>>>>>>//    Number nVersion
75601>>>>>>>>>//    // Try to find DataFlex Workspace
75601>>>>>>>>>//    Get THFindWorkspaceFile sPath "SWS" to sWSFile
75601>>>>>>>>>//    If (sWSFile<>"") Move (Left(sWSFile, Length(sWSFile)-3)) to sWSFile
75601>>>>>>>>>//    Else Begin
75601>>>>>>>>>//      Get fnCurrentVdfVersion of ghoWorkspaceHandlerEx to nVersion
75601>>>>>>>>>//      If (nVersion<80) Begin  // VDF7 and earlier didn't use SWS files
75601>>>>>>>>>//        Get CurrentWorkspaceTag of ghoWorkSpaceHandlerEx to sWSFile
75601>>>>>>>>>//        If (sWSFile<>"") Move (sWSFile+".") To sWSFile
75601>>>>>>>>>//      End
75601>>>>>>>>>//      Else Move "Project." to sWSFile
75601>>>>>>>>>//    End
75601>>>>>>>>>//    //
75601>>>>>>>>>//    If (sWSFile<>"") Move (sWSFile+"hws") To sWSFile
75601>>>>>>>>>//    Function_Return sWSFile
75601>>>>>>>>>End_Function
75602>>>>>>>>>
75602>>>>>>>>>Function THWorkspaceName String sPath Integer ByRef bNew Integer ByRef iType Returns String
75604>>>>>>>>>//    String sWSFile
75604>>>>>>>>>//    Direct_Input ("DIR:"+sPath+'*.hws')
75604>>>>>>>>>//    While (not(SeqEof))
75604>>>>>>>>>//        Readln sWSFile
75604>>>>>>>>>//        If (sWSFile<>"") Break
75604>>>>>>>>>//    Loop
75604>>>>>>>>>//    Close_Input
75604>>>>>>>>>//    If (sWSFile="") Begin
75604>>>>>>>>>//        Get THNewWorkspaceName sPath to sWSFile
75604>>>>>>>>>//        If (sWSFile="") Move "Project.hws" to sWSFile
75604>>>>>>>>>//        Else Move 1 to iType // DataFlex Workspace
75604>>>>>>>>>//        Move 1 to bNew
75604>>>>>>>>>//    End
75604>>>>>>>>>//    Function_Return sWSFile
75604>>>>>>>>>End_Function
75605>>>>>>>>>
75605>>>>>>>>>// *** Load Language from Studio 12+ (Used by THParameters Dialog)
75605>>>>>>>>>// Loading from the Current Workspace Version
75605>>>>>>>>>Procedure LoadLanguageTokens String sLanguage String sElement Handle hoTokens Integer iList tTHLanguage ByRef ltTHLanguage
75607>>>>>>>>>    Handle hoToken
75607>>>>>>>>>    String sToken sStrings
75607>>>>>>>>>    Integer iScopeStart iScopeStop iKeyword iOperator
75607>>>>>>>>>    Move (Uppercase(sLanguage)) to sLanguage
75608>>>>>>>>>    Get FirstChild of hoTokens to hoToken
75609>>>>>>>>>    While (hoToken <> 0)
75613>>>>>>>>>        Get psText of hoToken "" "" to sToken
75614>>>>>>>>>        //
75614>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saKeywords))     to iKeyword
75615>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saScopeStart))   to iScopeStart
75616>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saScopeStop))    to iScopeStop
75617>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saOperators))    to iOperator
75618>>>>>>>>>        //
75618>>>>>>>>>        If ((sElement="BLOCKCOMMENTS")and(iList=0)) Move sToken to ltTHLanguage.sMultiLineCommentStart
75621>>>>>>>>>        If ((sElement="BLOCKCOMMENTS")and(iList=1)) Move sToken to ltTHLanguage.sMultiLineCommentStop
75624>>>>>>>>>        If ((sElement="1001")and(iList=0)) Move sToken to ltTHLanguage.sMetaStart
75627>>>>>>>>>        If ((sElement="1001")and(iList=1)) Move sToken to ltTHLanguage.sMetaStop
75630>>>>>>>>>        If (sElement="LINECOMMENTS") Move sToken to ltTHLanguage.sLineComments
75633>>>>>>>>>        If (sElement="1002") Move sToken to ltTHLanguage.saKeywords[iKeyword] // Use|#Include
75636>>>>>>>>>        If ((sElement="DEFINITIONBLOCKS")and(iList=0)) Move sToken to ltTHLanguage.saScopeStart[iScopeStart]
75639>>>>>>>>>        If ((sElement="DEFINITIONBLOCKS")and(iList=1)) Move sToken to ltTHLanguage.saScopeStop[iScopeStop]
75642>>>>>>>>>        If ((sElement="SCOPEKEYWORDS")and(iList=0)) Move sToken to ltTHLanguage.saScopeStart[iScopeStart]
75645>>>>>>>>>        If ((sElement="SCOPEKEYWORDS")and(iList=1)) Move sToken to ltTHLanguage.saScopeStop[iScopeStop]
75648>>>>>>>>>        If (sElement="KEYWORDS") Move sToken to ltTHLanguage.saKeywords[iKeyword]
75651>>>>>>>>>        If (sElement="OPERATORS") Begin
75653>>>>>>>>>            Move (Replace("&lt;&gt;", sToken, "<>")) to sToken
75654>>>>>>>>>            Move (Replace("&lt;", sToken, "<")) to sToken
75655>>>>>>>>>            Move (Replace("&gt;", sToken, ">")) to sToken
75656>>>>>>>>>            Move (Replace("&amp;", sToken, "&")) to sToken
75657>>>>>>>>>            Move sToken to ltTHLanguage.saOperators[iOperator]
75658>>>>>>>>>        End
75658>>>>>>>>>>
75658>>>>>>>>>        If ((sElement="RESOURCEBLOCK")and(iList=0)) Move sToken to ltTHLanguage.saScopeStart[iScopeStart]
75661>>>>>>>>>        If ((sElement="RESOURCEBLOCK")and(iList=1)) Move sToken to ltTHLanguage.saScopeStop[iScopeStop]
75664>>>>>>>>>        If ((sElement="STRINGS")and(iList=0)) Begin
75666>>>>>>>>>            Move ltTHLanguage.sStringDelimiter to sStrings
75667>>>>>>>>>            If (sStrings="") Move sToken to sStrings
75670>>>>>>>>>            Else Move (sStrings+"\n"+sToken) to sStrings
75672>>>>>>>>>            Move sStrings to ltTHLanguage.sStringDelimiter
75673>>>>>>>>>        End
75673>>>>>>>>>>
75673>>>>>>>>>        //
75673>>>>>>>>>        Get NextNode of hoToken to hoToken
75674>>>>>>>>>    Loop
75675>>>>>>>>>>
75675>>>>>>>>>    Send Destroy to hoTokens
75676>>>>>>>>>End_Procedure
75677>>>>>>>>>Function LoadLanguage String sLanguage Returns tTHLanguage
75679>>>>>>>>>//    tTHLanguage ltTHLanguage
75679>>>>>>>>>//    String      sVdfConfig
75679>>>>>>>>>//    String      sPath
75679>>>>>>>>>//    String      sFile
75679>>>>>>>>>//    String      sValue
75679>>>>>>>>>//    Integer     bOK
75679>>>>>>>>>//    Handle      hoXML
75679>>>>>>>>>//    Handle      hoRoot
75679>>>>>>>>>//    Handle      hoTokenSet
75679>>>>>>>>>//    Handle      hoTokens
75679>>>>>>>>>//    If ((Uppercase(sLanguage)="VDF")or(sLanguage=""))   Move "DataFlex" to sLanguage
75679>>>>>>>>>//    If (Uppercase(sLanguage) contains "SQL")            Move "SQL" to sLanguage
75679>>>>>>>>>//    Get psVdfRootDir    of ghoWorkSpaceHandlerEx to sVdfConfig
75679>>>>>>>>>//    Get PathAtIndex     of (phoWorkspace(ghoApplication)) sVdfConfig 1 to sPath
75679>>>>>>>>>//    Move (sPath+"\Lib\"+sLanguage+".lng") to sFile
75679>>>>>>>>>//    Get Create (RefClass(cXMLDOMDocument)) to hoXML
75679>>>>>>>>>//    If (hoXML) Begin
75679>>>>>>>>>//        Set psDocumentName  of hoXML to sFile
75679>>>>>>>>>//        Get LoadXMLDocument of hoXML to bOK
75679>>>>>>>>>//        If (bOK) Begin
75679>>>>>>>>>//            Get DocumentElement of hoXML to hoRoot // Language
75679>>>>>>>>>//            If (hoRoot) Begin
75679>>>>>>>>>//                Move 1 to ltTHLanguage.iProcedural
75679>>>>>>>>>//                Get AttributeValueNS of hoRoot "" "name" to ltTHLanguage.sName
75679>>>>>>>>>//                Get AttributeValueNS of hoRoot "" "casesensitive" to sValue
75679>>>>>>>>>//                If (Uppercase(sValue)<>"NO") Move 1 to ltTHLanguage.iCaseSensitive
75679>>>>>>>>>//                Get FirstChild of hoRoot to hoTokenSet
75679>>>>>>>>>//                If hoTokenSet Begin
75679>>>>>>>>>//                    While (hoTokenSet<>0)
75679>>>>>>>>>//                        Get AttributeValueNS of hoTokenSet "" "id" to sValue
75679>>>>>>>>>//                        Move (Uppercase(sValue)) to sValue
75679>>>>>>>>>//                        // Token List 1
75679>>>>>>>>>//                        Get ChildElementNS of hoTokenSet "" "tokens"   to hoTokens
75679>>>>>>>>>//                        If hoTokens ;
75679>>>>>>>>>//                            Send LoadLanguageTokens sLanguage sValue hoTokens 0 (&ltTHLanguage)
75679>>>>>>>>>//                        // Token List 2
75679>>>>>>>>>//                        Get ChildElementNS of hoTokenSet "" "tokens2"  to hoTokens
75679>>>>>>>>>//                        If hoTokens ;
75679>>>>>>>>>//                            Send LoadLanguageTokens sLanguage sValue hoTokens 1 (&ltTHLanguage)
75679>>>>>>>>>//                        //
75679>>>>>>>>>//                        Get NextNode of hoTokenSet to hoTokenSet
75679>>>>>>>>>//                    Loop // hoTokenSet
75679>>>>>>>>>//                End
75679>>>>>>>>>//                Send Destroy to hoRoot
75679>>>>>>>>>//            End // hoRoot
75679>>>>>>>>>//        End // LoadXMLDocument OK
75679>>>>>>>>>//        Send Destroy of hoXML
75679>>>>>>>>>//    End // hoXML
75679>>>>>>>>>//    Function_Return ltTHLanguage
75679>>>>>>>>>End_Function
75680>>>>>>>>>
75680>>>>>>>>>Procedure THWorkspaceDataFlexDefaults String sHome
75682>>>>>>>>>//    Integer iExt
75682>>>>>>>>>//    tTHWorkspace THWorkspace
75682>>>>>>>>>//    // General
75682>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
75682>>>>>>>>>//    Move "DataFlex"                     to THWorkspace.sSchema
75682>>>>>>>>>//    Get CurrentWorkSpaceDescription ;
75682>>>>>>>>>//        of ghoWorkSpaceHandlerEx        to THWorkspace.sName
75682>>>>>>>>>//    // Folders
75682>>>>>>>>>//    Move sHome                          to THWorkspace.saFolders[0]
75682>>>>>>>>>//    // Files
75682>>>>>>>>>//    Move "SRC"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Project (Program)"   to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "PKG"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Package"             to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "INC"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Include File"                 to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "DD"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Data Dictionary"              to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "MN"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Menu (obsolete)"     to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "H"                            to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Header"                       to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "BP"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Business Process"    to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "UTL"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Sture's Utility"              to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "DG"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Dialog"              to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "SL"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Selection List"      to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "VW"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex View"                to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "RV"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Report View"         to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "WO"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Web Object"          to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "HTM"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "HyperText Markup Language"    to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "HTML"                         to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "HyperText Markup Language"    to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "ASP"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Active Server Page"           to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "JS"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "JavaScript"                   to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "WS"                           to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Workspace"           to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "SWS"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "DataFlex Studio Workspace"    to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "INI"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Configuration File"           to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "CSS"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Cascading Style Sheet"        to THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Increment iExt
75682>>>>>>>>>//    Move "INT"                          to THWorkspace.saFiles[iExt]
75682>>>>>>>>>//    Move "Database Intermediate File"   To THWorkspace.saFileDesc[iExt]
75682>>>>>>>>>//    Set pTHWorkspace of ghoApplication To THWorkspace
75682>>>>>>>>>End_Procedure
75683>>>>>>>>>
75683>>>>>>>>>Function THWorkspaceHome Returns String
75685>>>>>>>>>//    String sHome sPath
75685>>>>>>>>>//    String sWsFile sWSHome
75685>>>>>>>>>//    Number nVersion
75685>>>>>>>>>//    Get fnCurrentVdfVersion  of ghoWorkSpaceHandlerEx to nVersion
75685>>>>>>>>>//    If (nVersion>=120) Begin
75685>>>>>>>>>//      Get CurrentHomePath of ghoWorkSpaceHandlerEx to sWSHome // usually a relative path such as "." or "..\"
75685>>>>>>>>>//      Get CurrentWSFile   of ghoWorkSpaceHandlerEx to sWsFile
75685>>>>>>>>>//      Get ParseFolderName sWsFile to sPath
75685>>>>>>>>>//      Get ConvertRelativePath of ghoWorkSpaceHandlerEx sWSHome "."  sPath To sHome
75685>>>>>>>>>//    End
75685>>>>>>>>>//    Else Begin
75685>>>>>>>>>//      Get PrimaryProgramPath   of ghoWorkSpaceHandlerEx   to sPath
75685>>>>>>>>>//      Get vParentPath sPath To sHome
75685>>>>>>>>>//    End
75685>>>>>>>>>//    Function_Return sHome
75685>>>>>>>>>End_Function
75686>>>>>>>>>
75686>>>>>>>>>Procedure THDoReadWorkspace String sWSFile
75688>>>>>>>>>//    Boolean  bExists
75688>>>>>>>>>//    Integer  bNew iType
75688>>>>>>>>>//    Integer  iFFOptions
75688>>>>>>>>>//    String   sFile sHome sDescription sFolder
75688>>>>>>>>>//    Handle   hoWorkspace
75688>>>>>>>>>//    //
75688>>>>>>>>>//    String sVersion sSize sTmp
75688>>>>>>>>>//    Integer iFolder iFolders iFile iFiles iExclude iExcludes
75688>>>>>>>>>//    Integer iSize
75688>>>>>>>>>//    tTHWorkspace THWorkspace  EmptyTHWorkspace
75688>>>>>>>>>//    //
75688>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
75688>>>>>>>>>//    If (num_arguments>0) Move sWSFile to sFile
75688>>>>>>>>>//    If (sFile="") Begin
75688>>>>>>>>>//        // Assume it is DataFlex Project by Default
75688>>>>>>>>>//        Get THWorkspaceHome to sHome
75688>>>>>>>>>//    End
75688>>>>>>>>>//    Get vFolderFormat sHome To sHome
75688>>>>>>>>>//    Get THWorkspaceName sHome (&bNew) (&iType) to sFile
75688>>>>>>>>>//    // 1. Clear Repository
75688>>>>>>>>>//    Move EmptyTHWorkspace to THWorkspace
75688>>>>>>>>>//    // 2. Set Workspace (HWS) File
75688>>>>>>>>>//    Move (sHome+sFile) to THWorkspace.sFullName
75688>>>>>>>>>//    // 3. Read Options or Create HWS Template (if New)
75688>>>>>>>>>//    If (bNew) Begin
75688>>>>>>>>>//        Move 1 to THWorkspace.iShowPaths
75688>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
75688>>>>>>>>>//        If (iType=1) Begin
75688>>>>>>>>>//            // DataFlex Defaults
75688>>>>>>>>>//            Send THWorkspaceDataFlexDefaults sHome
75688>>>>>>>>>//        End
75688>>>>>>>>>//        Send THDoWriteWorkspace
75688>>>>>>>>>//    End
75688>>>>>>>>>//    Else Begin
75688>>>>>>>>>//        // Read HWS file if found
75688>>>>>>>>>//        Direct_Input ("Binary:"*sHome+sFile)
75688>>>>>>>>>//        // Header
75688>>>>>>>>>//        Readln sVersion
75688>>>>>>>>>//        Move (Left(sVersion, 7)) to sVersion
75688>>>>>>>>>//        If (Left(sVersion, 3)<>"HWS") Begin
75688>>>>>>>>>//            Close_Input
75688>>>>>>>>>//            Send UserError ("File"*sHome+sFile*"is not a valid Hammer .hws file. Falling back to defaults.")
75688>>>>>>>>>//            Move 1 to THWorkspace.iShowPaths
75688>>>>>>>>>//            Set pTHWorkspace of ghoApplication To THWorkspace
75688>>>>>>>>>//            If (iType=1) Begin
75688>>>>>>>>>//                // DataFlex Defaults
75688>>>>>>>>>//                Send THWorkspaceDataFlexDefaults sHome
75688>>>>>>>>>//            End
75688>>>>>>>>>//            Procedure_Return // Not a HWS file
75688>>>>>>>>>//        End
75688>>>>>>>>>//        // General
75688>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sName
75688>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sSchema
75688>>>>>>>>>//        Get WSReadInt1      to THWorkspace.iShowPaths
75688>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sStudio
75688>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sCompiler
75688>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sDBEditor
75688>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sDBViewer
75688>>>>>>>>>//        // Folders
75688>>>>>>>>>//        Get WSReadInt2      to iFolders
75688>>>>>>>>>//        For iFolder from 0  to (iFolders-1)
75688>>>>>>>>>//            Get WSReadStr2  to sFolder
75688>>>>>>>>>//            If (iFolder=0) Begin // Check that our home folder hasn't changed
75688>>>>>>>>>//              //Get vFolderExists sFolder to bExists  <-- Can't use this one as it depends on DIR: and thus opens its own channel and mucks this up completely
75688>>>>>>>>>//              Get vFilePathExists (sFolder+"*") to bExists
75688>>>>>>>>>//              If (bExists=false) Begin
75688>>>>>>>>>//                Move "" To sFolder
75688>>>>>>>>>//              End
75688>>>>>>>>>//            End
75688>>>>>>>>>//            Move sFolder To THWorkspace.saFolders[iFolder]
75688>>>>>>>>>//        Loop
75688>>>>>>>>>//        If (SizeOfArray(THWorkspace.saFolders)=0 Or THWorkspace.saFolders[0]="") Begin
75688>>>>>>>>>//                                                  // if the user renames the folder then the logic can no longer find our home path
75688>>>>>>>>>//          Move sHome To THWorkspace.saFolders[0]  // Put the home path of our workspace in there
75688>>>>>>>>>//        End
75688>>>>>>>>>//        // Files
75688>>>>>>>>>//        Get WSReadInt2      to iFiles
75688>>>>>>>>>//        For iFile from 0    to (iFiles-1)
75688>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saFiles[iFile]
75688>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saFileDesc[iFile]
75688>>>>>>>>>//        Loop
75688>>>>>>>>>//        // Excludes
75688>>>>>>>>>//        Get WSReadInt2      to iExcludes
75688>>>>>>>>>//        For iExclude from 0 to (iExcludes-1)
75688>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saExclude[iExclude]
75688>>>>>>>>>//        Loop
75688>>>>>>>>>//        // Sources
75688>>>>>>>>>//        Get WSReadInt2      to iFiles
75688>>>>>>>>>//        For iFile from 0    to (iFiles-1)
75688>>>>>>>>>//            Get WSReadStr2  to THWorkspace.taSources[iFile].sFile
75688>>>>>>>>>//            Get WSReadStr4  to THWorkspace.taSources[iFile].sBookmarks
75688>>>>>>>>>//            Get WSReadInt2  to THWorkspace.taSources[iFile].iBookmarkCount
75688>>>>>>>>>//            Get WSReadInt2  to THWorkspace.taSources[iFile].iCursorColumn
75688>>>>>>>>>//            Get WSReadInt2  to THWorkspace.taSources[iFile].iCursorLine
75688>>>>>>>>>//        Loop
75688>>>>>>>>>//        // Find in Files
75688>>>>>>>>>//        Get WSReadStr2  to THWorkspace.sFFText
75688>>>>>>>>>//        Get WSReadStr2  to THWorkspace.sFFTypes
75688>>>>>>>>>//        Get WSReadStr2  to THWorkspace.sFFPath
75688>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFMatchWord
75688>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFMatchCase
75688>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFSubFolders
75688>>>>>>>>>//        Get WSReadInt1  To iFFOptions  // encoding the iFFShowAll and iFFExcludeComments into the same byte so
75688>>>>>>>>>//                                       // that I do not have to handle the versioning nightmare it will create otherwise.
75688>>>>>>>>>//        If (iFFOptions iAnd 1) Move 1 To THWorkspace.iFFShowAll
75688>>>>>>>>>//        If (iFFOptions iAnd 2) Move 1 To THWorkspace.iFFExcludeComments
75688>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFRegExp
75688>>>>>>>>>//        // Opened Files
75688>>>>>>>>>//        Get WSReadInt2      to iFiles
75688>>>>>>>>>//        For iFile from 0    to (iFiles-1)
75688>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saOpened[iFile]
75688>>>>>>>>>//        Loop
75688>>>>>>>>>//        Close_Input
75688>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
75688>>>>>>>>>//    End
75688>>>>>>>>>End_Procedure
75689>>>>>>>>>
75689>>>>>>>>>//
75689>>>>>>>>>// During debugging I see bookmark/cursor position items in the taSources
75689>>>>>>>>>// arrays without a filename. Not sure why that can happen, but we don't want
75689>>>>>>>>>// to keep those as at has no value then.
75689>>>>>>>>>//
75689>>>>>>>>>Procedure RemoveEmptyBookmarkSources tTHSource[] ByRef taSources
75691>>>>>>>>>//  Integer iFile
75691>>>>>>>>>//  Integer iFiles
75691>>>>>>>>>//  String  sFile
75691>>>>>>>>>//  
75691>>>>>>>>>//  Move (SizeOfArray(taSources)) to iFiles
75691>>>>>>>>>//  Move (iFiles-1) To iFile
75691>>>>>>>>>//  While (iFile>0)
75691>>>>>>>>>//    Move (trim(taSources[iFile].sFile)) to sFile
75691>>>>>>>>>//    If (sFile="") Begin
75691>>>>>>>>>//      Move (RemoveFromArray(taSources,iFile)) To taSources
75691>>>>>>>>>//    End
75691>>>>>>>>>//    Decrement iFile
75691>>>>>>>>>//  Loop
75691>>>>>>>>>End_Procedure
75692>>>>>>>>>
75692>>>>>>>>>Procedure THDoWriteWorkspace
75694>>>>>>>>>//    Integer iFolder iFolders iFile iFiles iExclude iExcludes
75694>>>>>>>>>//    Integer iFFOptions
75694>>>>>>>>>//    String  sFile
75694>>>>>>>>>//    tTHWorkspace THWorkspace
75694>>>>>>>>>//    Get pTHWorkspace of ghoApplication To  THWorkspace
75694>>>>>>>>>//    Send RemoveEmptyBookmarkSources (&THWorkspace.taSources)
75694>>>>>>>>>//    Move THWorkspace.sFullName To sFile
75694>>>>>>>>>//    Direct_Output sFile
75694>>>>>>>>>//        // Header
75694>>>>>>>>>//        Writeln "HWS0301, (C) 2018, KURANT Project"
75694>>>>>>>>>//        //
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sName
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sSchema
75694>>>>>>>>>//        Write (Character(THWorkspace.iShowPaths))
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sStudio
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sCompiler
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sDBEditor
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sDBViewer
75694>>>>>>>>>//        // Folders
75694>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saFolders)) to iFolders
75694>>>>>>>>>//        Write (SHORTtoUChar(iFolders))
75694>>>>>>>>>//        For iFolder from 0 to (iFolders-1)
75694>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saFolders[iFolder]
75694>>>>>>>>>//        Loop
75694>>>>>>>>>//        // Files
75694>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saFiles)) to iFiles
75694>>>>>>>>>//        Write (SHORTtoUChar(iFiles))
75694>>>>>>>>>//        For iFile from 0 to (iFiles-1)
75694>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saFiles[iFile]
75694>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saFileDesc[iFile]
75694>>>>>>>>>//        Loop
75694>>>>>>>>>//        // Excludes
75694>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saExclude)) to iExcludes
75694>>>>>>>>>//        Write (SHORTtoUChar(iExcludes))
75694>>>>>>>>>//        For iExclude from 0 to (iExcludes-1)
75694>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saExclude[iExclude]
75694>>>>>>>>>//        Loop
75694>>>>>>>>>//        // File Information
75694>>>>>>>>>//        Move (SizeOfArray(THWorkspace.taSources)) to iFiles
75694>>>>>>>>>//        Write (SHORTtoUChar(iFiles))
75694>>>>>>>>>//        For iFile from 0 to (iFiles-1)
75694>>>>>>>>>//            Send WSWriteStr2 THWorkspace.taSources[iFile].sFile
75694>>>>>>>>>//            Send WSWriteStr4 THWorkspace.taSources[iFile].sBookmarks
75694>>>>>>>>>//            Write (SHORTtoUChar(THWorkspace.taSources[iFile].iBookmarkCount))
75694>>>>>>>>>//            Write (SHORTtoUChar(THWorkspace.taSources[iFile].iCursorColumn))
75694>>>>>>>>>//            Write (SHORTtoUChar(THWorkspace.taSources[iFile].iCursorLine))
75694>>>>>>>>>//        Loop
75694>>>>>>>>>//        // Find in Files
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sFFText
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sFFTypes
75694>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sFFPath
75694>>>>>>>>>//        Write (Character(THWorkspace.iFFMatchWord)) // 0|1
75694>>>>>>>>>//        Write (Character(THWorkspace.iFFMatchCase))
75694>>>>>>>>>//        Write (Character(THWorkspace.iFFSubFolders))
75694>>>>>>>>>//        Move 0 To iFFOptions
75694>>>>>>>>>//        If (THWorkspace.iFFShowAll)         Move 1 To iFFOptions
75694>>>>>>>>>//        If (THWorkspace.iFFExcludeComments) Move (iFFOptions iOr 2) To iFFOptions
75694>>>>>>>>>//        Write (Character(iFFOptions))
75694>>>>>>>>>//        Write (Character(THWorkspace.iFFRegExp))
75694>>>>>>>>>//        // Opened Files
75694>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saOpened)) to iFiles
75694>>>>>>>>>//        Write (SHORTtoUChar(iFiles))
75694>>>>>>>>>//        For iFile from 0 to (iFiles-1)
75694>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saOpened[iFile]
75694>>>>>>>>>//        Loop
75694>>>>>>>>>//    Close_Output
75694>>>>>>>>>End_Procedure
75695>>>>>>>>>
75695>>>>>>>>>// This Procedure should no longer be neccessary.
75695>>>>>>>>>// MK 27.06.2001 21:41
75695>>>>>>>>>// This Procedure still required as TH3 loses standard DF packages visibility
75695>>>>>>>>>// SN 29.03.2017 13:12
75695>>>>>>>>>Procedure AddToOpenPath String ByRef sOpenPath String ByRef sPath
75697>>>>>>>>>    String sTmp
75697>>>>>>>>>    If (sPath="") Procedure_Return
75700>>>>>>>>>    If ((Pos(';', sPath)=0) and (Uppercase(sOpenPath) contains Uppercase(sPath))) Procedure_Return
75703>>>>>>>>>    If (Pos(';', sPath)=0) Begin
75705>>>>>>>>>        Move (sOpenPath+";"+sPath) to sOpenPath
75706>>>>>>>>>        Procedure_Return
75707>>>>>>>>>    End
75707>>>>>>>>>>
75707>>>>>>>>>    While (Pos(';', sPath))
75711>>>>>>>>>        Move (Left(sPath, Pos(';', sPath))) to sTmp
75712>>>>>>>>>        Move (Replace(sTmp, sPath, "")) to sPath
75713>>>>>>>>>        If (sTmp<>".;") ;            Move (Replace(';', sTmp, "")) to sTmp
75716>>>>>>>>>        If (not(Uppercase(sOpenPath) contains Uppercase(sTmp))) Begin
75718>>>>>>>>>            If (sTmp=".;") ;                Move (Replace(';', sTmp, "")) to sTmp
75721>>>>>>>>>            Move (sOpenPath +';'+sTmp) to sOpenPath
75722>>>>>>>>>        End
75722>>>>>>>>>>
75722>>>>>>>>>    Loop
75723>>>>>>>>>>
75723>>>>>>>>>    If (sPath<>"") Begin
75725>>>>>>>>>        If (not(Uppercase(sOpenPath) contains Uppercase(sPath))) ;            Move (sOpenPath + ";" + sPath) to sOpenPath
75728>>>>>>>>>    End
75728>>>>>>>>>>
75728>>>>>>>>>End_Procedure
75729>>>>>>>>>
75729>>>>>>>>>Procedure IncludeMakePath
75731>>>>>>>>>    String sMake sMake2 sOpenPath
75731>>>>>>>>>    Get_Attribute DF_OPEN_PATH          to sOpenPath
75734>>>>>>>>>    Get_Profile_String "DFCOMP" ;                       "MakePath"       to sMake
75737>>>>>>>>>    Send AddToOpenPath (&sOpenPath) (&sMake)
75738>>>>>>>>>    Get_Profile_String "WorkSpaces" ;                       "SystemMakePath" to sMake2
75741>>>>>>>>>    Send AddToOpenPath (&sOpenPath) (&sMake2)
75742>>>>>>>>>    Set_Attribute DF_OPEN_PATH          to sOpenPath
75745>>>>>>>>>End_Procedure
75746>>>>>>>>>Send IncludeMakePath
75747>>>>>>>>>
75747>>>>>>>>>Procedure THRegisterDFClass tDFDefaultClasses[] ByRef ltDFClasses String sCategory String sClass String sPackage
75749>>>>>>>>>    Integer iCount
75749>>>>>>>>>    Move (SizeOfArray(ltDFClasses)) to iCount
75750>>>>>>>>>    Move sCategory  to ltDFClasses[iCount].sCategory
75751>>>>>>>>>    Move sClass     to ltDFClasses[iCount].sClass
75752>>>>>>>>>    Move sPackage   to ltDFClasses[iCount].sFile
75753>>>>>>>>>End_Procedure
75754>>>>>>>>>Procedure LoadDefaultClasses tDFDefaultClasses[] ByRef ltDFClasses
75756>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "DataDictionary"          "DataDictionary"        "DataDict.pkg"
75757>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbForm"                  "dbForm"                "DFEntry.pkg"
75758>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbEdit"                  "cDbTextEdit"           "cDbTextEdit.pkg"
75759>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbCombo"                 "dbComboForm"           "DfCEntry.pkg"
75760>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbCheckBox"              "dbCheckBox"            "DFEnChk.pkg"
75761>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbSpinForm"              "dbSpinForm"            "DFSpnEnt.pkg"
75762>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbGrid"                  "dbGrid"                "DfTable.pkg"
75763>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbList"                  "dbList"                "DFSelLst.pkg"
75764>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbTabDialog"             "dbTabDialog"           "DfTabDlg.pkg"
75765>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbTabPage"               "dbTabPage"             "DfTabDlg.pkg"
75766>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbView"                  "dbView"                "DFClient.pkg"
75767>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbModalPanel"            "dbModalPanel"          "DFClient.pkg"
75768>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "ReportView"              "ReportView"            "DFRptVw.pkg"
75769>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWinReport2"             "cWinReport2"           "cWinReport2.pkg"
75770>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Button"                  "Button"                "Windows.pkg"
75771>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Radio"                   "Radio"                 "Windows.pkg"
75772>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Form"                    "Form"                  "Windows.pkg"
75773>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Group"                   "Group"                 "Windows.pkg"
75774>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "RadioGroup"              "RadioGroup"            "Windows.pkg"
75775>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Menubar/toolbar System"  "cCJCommandBarSystem"   "cCJStandardCommandBarSystem.pkg"
75776>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "MenuItem"                "cCJMenuItem"           "cCJCommandBarSystem.pkg"
75777>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cDbCJGrid"               "cDbCJGrid"             "cDbCJGrid.pkg"
75778>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cDbCJGridColumn"         "cDbCJGridColumn"       "cDbCJGridColumn.pkg"
75779>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cDbCJGridPromptList"     "cDbCJGridPromptList"   "cDbCJGridPromptList.pkg"
75780>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebButton"              "cWebButton"            "cWebButton.pkg"
75781>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebCheckBox"            "cWebCheckBox"          "cWebCheckBox.pkg"
75782>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebCombo"               "cWebCombo"             "cWebCombo.pkg"
75783>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebEdit"                "cWebEdit"              "cWebEdit.pkg"
75784>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebForm"                "cWebForm"              "cWebForm.pkg"
75785>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebGrid"                "cWebGrid"              "cWebGrid.pkg"
75786>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebColumn"              "cWebColumn"            "cWebColumn.pkg"
75787>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebColumnCheckBox"      "cWebColumnCheckBox"    "cWebColumnCheckBox.pkg"
75788>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebColumnCombo"         "cWebColumnCombo"       "cWebColumnCombo.pkg"
75789>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebMenuItem"            "cWebMenuItem"          "cWebMenuItem.pkg"
75790>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebMenuItemLoadView"    "cWebMenuItemLoadView"  "cWebMenuItemLoadView.pkg"
75791>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebModalDialog"         "cWebModalDialog"       "cWebModalDialog.pkg"
75792>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebPanel"               "cWebPanel"             "cWebPanel.pkg"
75793>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebPromptList"          "cWebPromptList"        "cWebPromptList.pkg"
75794>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebTabContainer"        "cWebTabContainer"      "cWebTabContainer.pkg"
75795>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebTabPage"             "cWebTabPage"           "cWebTabPage.pkg"
75796>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebView"                "cWebView"              "cWebView.pkg"
75797>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "WebBusinessProcess"      "cWebBusinessProcess"   "cWebBusinessProcess.pkg"
75798>>>>>>>>>End_Procedure
75799>>>>>>>>>
75799>>>>>>>>>// Source File
75799>>>>>>>>>Function THWS_FindFile String sFile Returns Integer
75801>>>>>>>>>//    tTHSource ltaSource
75801>>>>>>>>>//    tTHWorkspace THWorkspace
75801>>>>>>>>>//    Move (Uppercase(sFile)) To ltaSource.sFile
75801>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
75801>>>>>>>>>//    Function_Return (SearchArray(ltaSource, THWorkspace.taSources))
75801>>>>>>>>>End_Function
75802>>>>>>>>>Function THWS_FileIndex String sFile Returns Integer
75804>>>>>>>>>//    tTHSource ltaSource
75804>>>>>>>>>//    tTHWorkspace THWorkspace
75804>>>>>>>>>//    Integer iFile
75804>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
75804>>>>>>>>>//    Move sFile                                                to ltaSource.sFile
75804>>>>>>>>>//    Move (SearchArray(ltaSource, THWorkspace.taSources))      to iFile
75804>>>>>>>>>//    If (iFile=-1) Move (SizeOfArray(THWorkspace.taSources))   to iFile
75804>>>>>>>>>//    Function_Return iFile
75804>>>>>>>>>End_Function
75805>>>>>>>>>Procedure THWS_SaveBookmarks String sFile String sBookmarks Integer iCount
75807>>>>>>>>>//    Integer iFile
75807>>>>>>>>>//    tTHWorkspace THWorkspace
75807>>>>>>>>>//    If ((iCount=0) and (sBookmarks<>"")) ;
75807>>>>>>>>>//        Move (Length(sBookmarks)/12)    to iCount
75807>>>>>>>>>//    Move (Uppercase(Trim(sFile)))       to sFile
75807>>>>>>>>>//    Get THWS_FileIndex sFile            To iFile
75807>>>>>>>>>//    Get pTHWorkspace  of ghoApplication To THWorkspace
75807>>>>>>>>>//    Move sFile                          to THWorkspace.taSources[iFile].sFile
75807>>>>>>>>>//    Move sBookmarks                     to THWorkspace.taSources[iFile].sBookmarks
75807>>>>>>>>>//    Move iCount                         To THWorkspace.taSources[iFile].iBookmarkCount
75807>>>>>>>>>//    Set pTHWorkspace  of ghoApplication To THWorkspace
75807>>>>>>>>>End_Procedure
75808>>>>>>>>>Procedure THWS_SaveCursorPosition String sFile Integer iLine Integer iColumn
75810>>>>>>>>>//    Integer iFile
75810>>>>>>>>>//    tTHWorkspace THWorkspace
75810>>>>>>>>>//    Move (Uppercase(Trim(sFile)))       to sFile
75810>>>>>>>>>//    Get THWS_FileIndex sFile            To iFile
75810>>>>>>>>>//    Get pTHWorkspace  of ghoApplication To THWorkspace
75810>>>>>>>>>//    Move sFile                          to THWorkspace.taSources[iFile].sFile
75810>>>>>>>>>//    Move iLine                          to THWorkspace.taSources[iFile].iCursorLine
75810>>>>>>>>>//    Move iColumn                        To THWorkspace.taSources[iFile].iCursorColumn
75810>>>>>>>>>//    Set pTHWorkspace  of ghoApplication To THWorkspace
75810>>>>>>>>>End_Procedure
75811>>>>>>>>>
75811>>>>>>>>>// Opened files
75811>>>>>>>>>Procedure THWS_SaveOpened String sFile Handle hoEditor
75813>>>>>>>>>//    tTHWorkspace THWorkspace
75813>>>>>>>>>//    If (hoEditor<>0) Begin
75813>>>>>>>>>//      // also save bookmarks and CursorPositions
75813>>>>>>>>>//      Send SaveBookMarks  of hoEditor sFile
75813>>>>>>>>>//      Send SaveCurrentPos of hoEditor sFile
75813>>>>>>>>>//    End
75813>>>>>>>>>//    Get pTHWorkspace Of ghoApplication To THWorkspace
75813>>>>>>>>>//    If (SearchArray(sFile, THWorkspace.saOpened)<0) Begin
75813>>>>>>>>>//        Move sFile   To THWorkspace.saOpened[SizeOfArray(THWorkspace.saOpened)]
75813>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
75813>>>>>>>>>//        Send THDoWriteWorkspace
75813>>>>>>>>>//    End
75813>>>>>>>>>End_Procedure
75814>>>>>>>>>Procedure THWS_DeleteOpened String sFile
75816>>>>>>>>>//    Integer iFile
75816>>>>>>>>>//    tTHWorkspace THWorkspace
75816>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
75816>>>>>>>>>//    Move (SearchArray(sFile, THWorkspace.saOpened)) to iFile
75816>>>>>>>>>//    If (iFile>=0) Begin
75816>>>>>>>>>//        Move (RemoveFromArray(THWorkspace.saOpened, iFile)) To THWorkspace.saOpened
75816>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
75816>>>>>>>>>//        Send THDoWriteWorkspace
75816>>>>>>>>>//    End
75816>>>>>>>>>End_Procedure
75817>>>>>>>>>
75817>>>>>>>>>Function _T Global String sText Integer iIndex Returns String
75819>>>>>>>>>    Function_Return sText
75820>>>>>>>>>End_Function
75821>>>>>>>>>
75821>>>>>>>
75821>>>>>>>// Already declared in winuser
75821>>>>>>>//// BOOL WINAPI GetKeyboardState(
75821>>>>>>>////  _Out_ PBYTE lpKeyState
75821>>>>>>>//// );
75821>>>>>>>//External_Function GetKeyboardState "GetKeyBoardState" User32.dll Pointer lpKeyState Returns Integer
75821>>>>>>>
75821>>>>>>>Define KS_KeyDown For |CI$80
75821>>>>>>>
75821>>>>>>>//
75821>>>>>>>// A shortcut is defined as both a dataflex code that can be used in an On_Key as well as the windows
75821>>>>>>>// virtual Key code which is stored per key and thus has to be in an array.
75821>>>>>>>// eg. ctrl+F3 = dataflex integer 5138, but also VK_Ctrl+VK_F3
75821>>>>>>>// where 5138 is the integer representation of Key_Ctrl+Key_F3 which is equivalent to 5138 in our example.
75821>>>>>>>//
75821>>>>>>>Struct tShortCut
75821>>>>>>>  Integer   iDFKey
75821>>>>>>>  Integer[] VKcode
75821>>>>>>>End_Struct
75821>>>>>>>
75821>>>>>>>
75821>>>>>>>Struct tSciCommandHotKey
75821>>>>>>>  Integer iCmd
75821>>>>>>>  String  sName
75821>>>>>>>  String  sDescription
75821>>>>>>>  tShortCut HotKey
75821>>>>>>>  tShortCut HotKey
75821>>>>>>>  tShortCut HotKey2
75821>>>>>>>  tShortCut HotKey2
75821>>>>>>>End_Struct
75821>>>>>>>
75821>>>>>>>Class cSciCommandHotKeys is a cObject
75822>>>>>>>  Procedure Construct_Object
75824>>>>>>>    Property tSciCommandHotKey[] pCommands
75825>>>>>>>  End_Procedure
75826>>>>>>>
75826>>>>>>>  Procedure RegisterCommand Integer iCmd String sName String sDesc
75828>>>>>>>    tSciCommandHotKey Command
75828>>>>>>>    tSciCommandHotKey Command
75828>>>>>>>    tSciCommandHotKey[] Commands
75828>>>>>>>    tSciCommandHotKey[] Commands
75829>>>>>>>    Get pCommands To Commands
75830>>>>>>>    Move iCmd  To Command.iCmd
75831>>>>>>>    Move sName To Command.sName
75832>>>>>>>    Move sDesc To Command.sDescription
75833>>>>>>>    Move Command To Commands[SizeOfArray(Commands)]
75834>>>>>>>    Set pCommands To Commands
75835>>>>>>>  End_Procedure
75836>>>>>>>
75836>>>>>>>  Function FindCommand Integer iCmd Returns tSciCommandHotKey
75838>>>>>>>    Integer iItem
75838>>>>>>>    Integer iCount
75838>>>>>>>    tSciCommandHotKey Command
75838>>>>>>>    tSciCommandHotKey Command
75838>>>>>>>    tSciCommandHotKey[] Commands
75838>>>>>>>    tSciCommandHotKey[] Commands
75839>>>>>>>
75839>>>>>>>    Move -1 To Command.iCmd
75840>>>>>>>    Get pCommands To Commands
75841>>>>>>>    Move (SizeOfArray(Commands)) To iCount
75842>>>>>>>    For iItem From 0 To (iCount-1)
75848>>>>>>>>
75848>>>>>>>      If (iCmd=Commands[iItem].iCmd) Begin
75850>>>>>>>        Move Commands[iItem] To Command
75851>>>>>>>        Move iCount To iItem
75852>>>>>>>      End
75852>>>>>>>>
75852>>>>>>>    Loop
75853>>>>>>>>
75853>>>>>>>    Function_Return Command
75854>>>>>>>  End_Function
75855>>>>>>>
75855>>>>>>>
75855>>>>>>>  Function FindCommandIndex Integer iCmd Returns Integer
75857>>>>>>>    Integer iItem
75857>>>>>>>    Integer iIndex
75857>>>>>>>    Integer iCount
75857>>>>>>>    tSciCommandHotKey[] Commands
75857>>>>>>>    tSciCommandHotKey[] Commands
75858>>>>>>>
75858>>>>>>>    Move -1 To iIndex
75859>>>>>>>    Get pCommands To Commands
75860>>>>>>>    Move (SizeOfArray(Commands)) To iCount
75861>>>>>>>    For iItem From 0 To (iCount-1)
75867>>>>>>>>
75867>>>>>>>      If (iCmd=Commands[iItem].iCmd) Begin
75869>>>>>>>        Move iItem To iIndex
75870>>>>>>>        Move iCount To iItem
75871>>>>>>>      End
75871>>>>>>>>
75871>>>>>>>    Loop
75872>>>>>>>>
75872>>>>>>>    Function_Return iIndex
75873>>>>>>>  End_Function
75874>>>>>>>
75874>>>>>>>  Function CommandHasHotKey tSciCommandHotKey Command Returns Boolean
75876>>>>>>>    Boolean bHasHotKey
75876>>>>>>>
75876>>>>>>>    Move False To bHasHotKey
75877>>>>>>>    If (SizeOfArray(Command.HotKey.VKcode)>0 or SizeOfArray(Command.HotKey2.VKcode)>0) Begin
75879>>>>>>>      Move True To bHasHotKey
75880>>>>>>>    End
75880>>>>>>>>
75880>>>>>>>    Function_Return bHasHotKey
75881>>>>>>>  End_Function
75882>>>>>>>
75882>>>>>>>  //
75882>>>>>>>  // Searches the current command to see if a shortcut has already been assigned elsewhere
75882>>>>>>>  // Returns the command if it has or Command.iCmd with -1 if it hasn't
75882>>>>>>>  //
75882>>>>>>>  Function ShortCutIsAssignedTo tShortCut ShortCut Returns tSciCommandHotKey
75884>>>>>>>    Integer iItem
75884>>>>>>>    Integer iCount
75884>>>>>>>    tSciCommandHotKey Command
75884>>>>>>>    tSciCommandHotKey Command
75884>>>>>>>    tSciCommandHotKey[] Commands
75884>>>>>>>    tSciCommandHotKey[] Commands
75885>>>>>>>
75885>>>>>>>    Move -1 To Command.iCmd
75886>>>>>>>    Get pCommands To Commands
75887>>>>>>>    Move (SizeOfArray(Commands)) To iCount
75888>>>>>>>    For iItem From 0 To (iCount-1)
75894>>>>>>>>
75894>>>>>>>      If (ShortCut.iDFKey=Commands[iItem].HotKey.iDFKey or ShortCut.iDFKey=Commands[iItem].HotKey2.iDFKey) Begin
75896>>>>>>>        Move Commands[iItem] To Command
75897>>>>>>>        Move iCount To iItem
75898>>>>>>>      End
75898>>>>>>>>
75898>>>>>>>    Loop
75899>>>>>>>>
75899>>>>>>>    Function_Return Command
75900>>>>>>>  End_Function
75901>>>>>>>
75901>>>>>>>  //
75901>>>>>>>  // Assigns a keyboard shortcut to the selected command. If a shortcut already exists
75901>>>>>>>  // then it will assign a 2nd shortcut. We can never have more as 2 shortcuts for one command.
75901>>>>>>>  //
75901>>>>>>>  Procedure AssignShortCutToCmd Integer iCmd tShortCut ShortCut
75903>>>>>>>    Boolean bHasHotKey
75903>>>>>>>    Integer iItem
75903>>>>>>>    String  sMsg
75903>>>>>>>    tSciCommandHotKey  Assigned
75903>>>>>>>    tSciCommandHotKey  Assigned
75903>>>>>>>    tSciCommandHotKey[] Commands
75903>>>>>>>    tSciCommandHotKey[] Commands
75904>>>>>>>
75904>>>>>>>    Get FindCommandIndex iCmd To iItem
75905>>>>>>>    If (iItem>-1) Begin
75907>>>>>>>      Get ShortCutIsAssignedTo ShortCut To Assigned
75908>>>>>>>      If (Assigned.iCmd=-1) Begin
75910>>>>>>>        Get pCommands To Commands
75911>>>>>>>        Get CommandHasHotKey Commands[iItem] To bHasHotKey
75912>>>>>>>        If (bHasHotKey=False) Begin
75914>>>>>>>          Move ShortCut To Commands[iItem].HotKey
75915>>>>>>>        End
75915>>>>>>>>
75915>>>>>>>        Else Begin
75916>>>>>>>          Move ShortCut To Commands[iItem].HotKey2
75917>>>>>>>        End
75917>>>>>>>>
75917>>>>>>>        Set pCommands To Commands
75918>>>>>>>      End
75918>>>>>>>>
75918>>>>>>>      Else Begin
75919>>>>>>>        Send Info_Box ("Already assigned to "+Assigned.sName+"\nYou have to remove it there first.")
75920>>>>>>>      End
75920>>>>>>>>
75920>>>>>>>    End
75920>>>>>>>>
75920>>>>>>>  End_Procedure
75921>>>>>>>
75921>>>>>>>  //
75921>>>>>>>  // Removes all associated keyboard shortcuts from the command
75921>>>>>>>  //
75921>>>>>>>  Procedure RemoveShortCutFromCmd Integer iCmd
75923>>>>>>>    Integer iItem
75923>>>>>>>    tShortCut EmptyShortCut
75923>>>>>>>    tShortCut EmptyShortCut
75923>>>>>>>    tSciCommandHotKey[] Commands
75923>>>>>>>    tSciCommandHotKey[] Commands
75924>>>>>>>
75924>>>>>>>    Get FindCommandIndex iCmd To iItem
75925>>>>>>>    If (iItem>-1) Begin
75927>>>>>>>      Get pCommands To Commands
75928>>>>>>>      Move EmptyShortCut To Commands[iItem].HotKey
75929>>>>>>>      Move EmptyShortCut To Commands[iItem].HotKey2
75930>>>>>>>      Set pCommands To Commands
75931>>>>>>>    End
75931>>>>>>>>
75931>>>>>>>  End_Procedure
75932>>>>>>>
75932>>>>>>>  //
75932>>>>>>>  // For sorting on the cmd.Name part in the structure
75932>>>>>>>  //
75932>>>>>>>  Function CompareCommands tSciCommandHotKey Cmd1 tSciCommandHotKey Cmd2 Returns Integer
75934>>>>>>>    String sName1
75934>>>>>>>    String sName2
75934>>>>>>>
75934>>>>>>>    Move (uppercase(Cmd1.sName)) To sName1
75935>>>>>>>    Move (Uppercase(Cmd2.sName)) To sName2
75936>>>>>>>    If (sName1 > sName2) ;      Function_Return (GT)
75939>>>>>>>    Else If (sName1 < sName2) ;      Function_Return (LT)
75943>>>>>>>    Function_Return (EQ)
75944>>>>>>>  End_Function
75945>>>>>>>
75945>>>>>>>  Procedure SortByCommandName
75947>>>>>>>    tSciCommandHotKey[] Commands
75947>>>>>>>    tSciCommandHotKey[] Commands
75948>>>>>>>    tSciCommandHotKey[] SortedCommands
75948>>>>>>>    tSciCommandHotKey[] SortedCommands
75949>>>>>>>
75949>>>>>>>    Get pCommands To Commands
75950>>>>>>>    Move (SortArray(Commands, Self, RefFunc(CompareCommands))) To SortedCommands
75951>>>>>>>    Set pCommands To SortedCommands
75952>>>>>>>  End_Procedure
75953>>>>>>>
75953>>>>>>>
75953>>>>>>>  Function MapVKtoString Integer iVK Returns String
75955>>>>>>>    String  sKey
75955>>>>>>>
75955>>>>>>>    If (iVK>=48 and iVK<=57) Begin
75957>>>>>>>      // VK_0 thru VK_9 are the same as ASCII '0' thru '9'
75957>>>>>>>      Move (Character(iVK)) To sKey
75958>>>>>>>    End
75958>>>>>>>>
75958>>>>>>>    Else If (iVK>=65 and iVK<=90) Begin
75961>>>>>>>      // VK_A thru VK_Z are the same as ASCII 'A' thru 'Z'
75961>>>>>>>      Move (Character(iVK)) To sKey
75962>>>>>>>    End
75962>>>>>>>>
75962>>>>>>>    Else Begin
75963>>>>>>>      Case Begin
75963>>>>>>>        Case (iVK=VK_LBUTTON)
75965>>>>>>>          Move "LBUTTON" To sKey
75966>>>>>>>          Case Break
75967>>>>>>>        Case (iVK=VK_RBUTTON)
75970>>>>>>>          Move "RBUTTON" To sKey
75971>>>>>>>          Case Break
75972>>>>>>>        Case (iVK=VK_CANCEL)
75975>>>>>>>          Move "CANCEL" To sKey
75976>>>>>>>          Case Break
75977>>>>>>>        Case (iVK=VK_MBUTTON)
75980>>>>>>>          Move "MBUTTON" To sKey
75981>>>>>>>          Case Break
75982>>>>>>>        Case (iVK=VK_BACK)
75985>>>>>>>          Move "Backspace" To sKey
75986>>>>>>>          Case Break
75987>>>>>>>        Case (iVK=VK_TAB)
75990>>>>>>>          Move "Tab" To sKey
75991>>>>>>>          Case Break
75992>>>>>>>        Case (iVK=VK_CLEAR)
75995>>>>>>>          Move "CLEAR" To sKey
75996>>>>>>>          Case Break
75997>>>>>>>        Case (iVK=VK_RETURN)
76000>>>>>>>          Move "Enter" To sKey
76001>>>>>>>          Case Break
76002>>>>>>>        Case (iVK=VK_SHIFT)
76005>>>>>>>          Move "Shift" To sKey
76006>>>>>>>          Case Break
76007>>>>>>>        Case (iVK=VK_CONTROL)
76010>>>>>>>          Move "Ctrl" To sKey
76011>>>>>>>          Case Break
76012>>>>>>>        Case (iVK=VK_MENU)
76015>>>>>>>          Move "Alt" To sKey
76016>>>>>>>          Case Break
76017>>>>>>>        Case (iVK=VK_PAUSE)
76020>>>>>>>          Move "PAUSE" To sKey
76021>>>>>>>          Case Break
76022>>>>>>>        Case (iVK=VK_CAPITAL)
76025>>>>>>>          Move "CAPITAL" To sKey
76026>>>>>>>          Case Break
76027>>>>>>>        Case (iVK=VK_ESCAPE)
76030>>>>>>>          Move "Escape" To sKey
76031>>>>>>>          Case Break
76032>>>>>>>        Case (iVK=VK_SPACE)
76035>>>>>>>          Move "Space" To sKey
76036>>>>>>>          Case Break
76037>>>>>>>        Case (iVK=VK_PRIOR)
76040>>>>>>>          Move "Page Up" To sKey
76041>>>>>>>          Case Break
76042>>>>>>>        Case (iVK=VK_NEXT)
76045>>>>>>>          Move "Page Down" To sKey
76046>>>>>>>          Case Break
76047>>>>>>>        Case (iVK=VK_END)
76050>>>>>>>          Move "End" To sKey
76051>>>>>>>          Case Break
76052>>>>>>>        Case (iVK=VK_HOME)
76055>>>>>>>          Move "Home" To sKey
76056>>>>>>>          Case Break
76057>>>>>>>        Case (iVK=VK_LEFT)
76060>>>>>>>          Move "Left" To sKey
76061>>>>>>>          Case Break
76062>>>>>>>        Case (iVK=VK_UP)
76065>>>>>>>          Move "Up" To sKey
76066>>>>>>>          Case Break
76067>>>>>>>        Case (iVK=VK_RIGHT)
76070>>>>>>>          Move "Right" To sKey
76071>>>>>>>          Case Break
76072>>>>>>>        Case (iVK=VK_DOWN)
76075>>>>>>>          Move "Down" To sKey
76076>>>>>>>          Case Break
76077>>>>>>>        Case (iVK=VK_SELECT)
76080>>>>>>>          Move "SELECT" To sKey
76081>>>>>>>          Case Break
76082>>>>>>>        Case (iVK=VK_PRINT)
76085>>>>>>>          Move "PRINT" To sKey
76086>>>>>>>          Case Break
76087>>>>>>>        Case (iVK=VK_EXECUTE)
76090>>>>>>>          Move "EXECUTE" To sKey
76091>>>>>>>          Case Break
76092>>>>>>>        Case (iVK=VK_SNAPSHOT)
76095>>>>>>>          Move "SNAPSHOT" To sKey
76096>>>>>>>          Case Break
76097>>>>>>>        Case (iVK=VK_INSERT)
76100>>>>>>>          Move "Insert" To sKey
76101>>>>>>>          Case Break
76102>>>>>>>        Case (iVK=VK_DELETE)
76105>>>>>>>          Move "Delete" To sKey
76106>>>>>>>          Case Break
76107>>>>>>>        Case (iVK=VK_HELP)
76110>>>>>>>          Move "Help" To sKey
76111>>>>>>>          Case Break
76112>>>>>>>        Case (iVK=VK_LWIN)
76115>>>>>>>          Move "LWIN" To sKey
76116>>>>>>>          Case Break
76117>>>>>>>        Case (iVK=VK_RWIN)
76120>>>>>>>          Move "RWIN" To sKey
76121>>>>>>>          Case Break
76122>>>>>>>        Case (iVK=VK_APPS)
76125>>>>>>>          Move "APPS" To sKey
76126>>>>>>>          Case Break
76127>>>>>>>        Case (iVK=VK_NUMPAD0)
76130>>>>>>>          Move "NUMPAD0" To sKey
76131>>>>>>>          Case Break
76132>>>>>>>        Case (iVK=VK_NUMPAD1)
76135>>>>>>>          Move "NUMPAD1" To sKey
76136>>>>>>>          Case Break
76137>>>>>>>        Case (iVK=VK_NUMPAD2)
76140>>>>>>>          Move "NUMPAD2" To sKey
76141>>>>>>>          Case Break
76142>>>>>>>        Case (iVK=VK_NUMPAD3)
76145>>>>>>>          Move "NUMPAD3" To sKey
76146>>>>>>>          Case Break
76147>>>>>>>        Case (iVK=VK_NUMPAD4)
76150>>>>>>>          Move "NUMPAD4" To sKey
76151>>>>>>>          Case Break
76152>>>>>>>        Case (iVK=VK_NUMPAD5)
76155>>>>>>>          Move "NUMPAD5" To sKey
76156>>>>>>>          Case Break
76157>>>>>>>        Case (iVK=VK_NUMPAD6)
76160>>>>>>>          Move "NUMPAD6" To sKey
76161>>>>>>>          Case Break
76162>>>>>>>        Case (iVK=VK_NUMPAD7)
76165>>>>>>>          Move "NUMPAD7" To sKey
76166>>>>>>>          Case Break
76167>>>>>>>        Case (iVK=VK_NUMPAD8)
76170>>>>>>>          Move "NUMPAD8" To sKey
76171>>>>>>>          Case Break
76172>>>>>>>        Case (iVK=VK_NUMPAD9)
76175>>>>>>>          Move "NUMPAD9" To sKey
76176>>>>>>>          Case Break
76177>>>>>>>        Case (iVK=VK_MULTIPLY)
76180>>>>>>>          Move "MULTIPLY" To sKey
76181>>>>>>>          Case Break
76182>>>>>>>        Case (iVK=VK_ADD)
76185>>>>>>>          Move "ADD" To sKey
76186>>>>>>>          Case Break
76187>>>>>>>        Case (iVK=VK_SEPARATOR)
76190>>>>>>>          Move "SEPARATOR" To sKey
76191>>>>>>>          Case Break
76192>>>>>>>        Case (iVK=VK_SUBTRACT)
76195>>>>>>>          Move "SUBTRACT" To sKey
76196>>>>>>>          Case Break
76197>>>>>>>        Case (iVK=VK_DECIMAL)
76200>>>>>>>          Move "DECIMAL" To sKey
76201>>>>>>>          Case Break
76202>>>>>>>        Case (iVK=VK_DIVIDE)
76205>>>>>>>          Move "DIVIDE" To sKey
76206>>>>>>>          Case Break
76207>>>>>>>        Case (iVK=VK_F1)
76210>>>>>>>          Move "F1" To sKey
76211>>>>>>>          Case Break
76212>>>>>>>        Case (iVK=VK_F2)
76215>>>>>>>          Move "F2" To sKey
76216>>>>>>>          Case Break
76217>>>>>>>        Case (iVK=VK_F3)
76220>>>>>>>          Move "F3" To sKey
76221>>>>>>>          Case Break
76222>>>>>>>        Case (iVK=VK_F4)
76225>>>>>>>          Move "F4" To sKey
76226>>>>>>>          Case Break
76227>>>>>>>        Case (iVK=VK_F5)
76230>>>>>>>          Move "F5" To sKey
76231>>>>>>>          Case Break
76232>>>>>>>        Case (iVK=VK_F6)
76235>>>>>>>          Move "F6" To sKey
76236>>>>>>>          Case Break
76237>>>>>>>        Case (iVK=VK_F7)
76240>>>>>>>          Move "F7" To sKey
76241>>>>>>>          Case Break
76242>>>>>>>        Case (iVK=VK_F8)
76245>>>>>>>          Move "F8" To sKey
76246>>>>>>>          Case Break
76247>>>>>>>        Case (iVK=VK_F9)
76250>>>>>>>          Move "F9" To sKey
76251>>>>>>>          Case Break
76252>>>>>>>        Case (iVK=VK_F10)
76255>>>>>>>          Move "F10" To sKey
76256>>>>>>>          Case Break
76257>>>>>>>        Case (iVK=VK_F11)
76260>>>>>>>          Move "F11" To sKey
76261>>>>>>>          Case Break
76262>>>>>>>        Case (iVK=VK_F12)
76265>>>>>>>          Move "F12" To sKey
76266>>>>>>>          Case Break
76267>>>>>>>        Case (iVK=VK_F13)
76270>>>>>>>          Move "F13" To sKey
76271>>>>>>>          Case Break
76272>>>>>>>        Case (iVK=VK_F14)
76275>>>>>>>          Move "F14" To sKey
76276>>>>>>>          Case Break
76277>>>>>>>        Case (iVK=VK_F15)
76280>>>>>>>          Move "F15" To sKey
76281>>>>>>>          Case Break
76282>>>>>>>        Case (iVK=VK_F16)
76285>>>>>>>          Move "F16" To sKey
76286>>>>>>>          Case Break
76287>>>>>>>        Case (iVK=VK_F17)
76290>>>>>>>          Move "F17" To sKey
76291>>>>>>>          Case Break
76292>>>>>>>        Case (iVK=VK_F18)
76295>>>>>>>          Move "F18" To sKey
76296>>>>>>>          Case Break
76297>>>>>>>        Case (iVK=VK_F19)
76300>>>>>>>          Move "F19" To sKey
76301>>>>>>>          Case Break
76302>>>>>>>        Case (iVK=VK_F20)
76305>>>>>>>          Move "F20" To sKey
76306>>>>>>>          Case Break
76307>>>>>>>        Case (iVK=VK_F21)
76310>>>>>>>          Move "F21" To sKey
76311>>>>>>>          Case Break
76312>>>>>>>        Case (iVK=VK_F22)
76315>>>>>>>          Move "F22" To sKey
76316>>>>>>>          Case Break
76317>>>>>>>        Case (iVK=VK_F23)
76320>>>>>>>          Move "F23" To sKey
76321>>>>>>>          Case Break
76322>>>>>>>        Case (iVK=VK_F24)
76325>>>>>>>          Move "F24" To sKey
76326>>>>>>>          Case Break
76327>>>>>>>        Case (iVK=VK_NUMLOCK)
76330>>>>>>>          Move "NUMLOCK" To sKey
76331>>>>>>>          Case Break
76332>>>>>>>        Case (iVK=VK_SCROLL)
76335>>>>>>>          Move "SCROLL" To sKey
76336>>>>>>>          Case Break
76337>>>>>>>        Case (iVK=VK_LSHIFT)
76340>>>>>>>          Move "LSHIFT" To sKey
76341>>>>>>>          Case Break
76342>>>>>>>        Case (iVK=VK_RSHIFT)
76345>>>>>>>          Move "RSHIFT" To sKey
76346>>>>>>>          Case Break
76347>>>>>>>        Case (iVK=VK_LCONTROL)
76350>>>>>>>          Move "LCONTROL" To sKey
76351>>>>>>>          Case Break
76352>>>>>>>        Case (iVK=VK_RCONTROL)
76355>>>>>>>          Move "RCONTROL" To sKey
76356>>>>>>>          Case Break
76357>>>>>>>        Case (iVK=VK_LMENU)
76360>>>>>>>          Move "LMENU" To sKey
76361>>>>>>>          Case Break
76362>>>>>>>        Case (iVK=VK_RMENU)
76365>>>>>>>          Move "RMENU" To sKey
76366>>>>>>>          Case Break
76367>>>>>>>        Case (iVK=VK_PROCESSKEY)
76370>>>>>>>          Move "PROCESSKEY" To sKey
76371>>>>>>>          Case Break
76372>>>>>>>        Case (iVK=VK_ATTN)
76375>>>>>>>          Move "ATTN" To sKey
76376>>>>>>>          Case Break
76377>>>>>>>        Case (iVK=VK_CRSEL)
76380>>>>>>>          Move "CRSEL" To sKey
76381>>>>>>>          Case Break
76382>>>>>>>        Case (iVK=VK_EXSEL)
76385>>>>>>>          Move "EXSEL" To sKey
76386>>>>>>>          Case Break
76387>>>>>>>        Case (iVK=VK_EREOF)
76390>>>>>>>          Move "EREOF" To sKey
76391>>>>>>>          Case Break
76392>>>>>>>        Case (iVK=VK_PLAY)
76395>>>>>>>          Move "PLAY" To sKey
76396>>>>>>>          Case Break
76397>>>>>>>        Case (iVK=VK_ZOOM)
76400>>>>>>>          Move "ZOOM" To sKey
76401>>>>>>>          Case Break
76402>>>>>>>        Case (iVK=VK_NONAME)
76405>>>>>>>          Move "NONAME" To sKey
76406>>>>>>>          Case Break
76407>>>>>>>        Case (iVK=VK_PA1)
76410>>>>>>>          Move "PA1" To sKey
76411>>>>>>>          Case Break
76412>>>>>>>        Case (iVK=VK_OEM_CLEAR)
76415>>>>>>>          Move "OEM_CLEAR" To sKey
76416>>>>>>>          Case Break
76417>>>>>>>        Case Else
76417>>>>>>>          // Hello undocumented DF command, welcome to the pleasure dome
76417>>>>>>>          //MAP_VK_TO_UNSHIFTED_CHAR iVK to iKey
76417>>>>>>>          //Move (Character(iKey)) To sKey
76417>>>>>>>          // The above works, but perhaps it is better to rely on something we can support
76417>>>>>>>          Move (WinAPIGetKeyNameText(iVK))  To sKey
76418>>>>>>>      Case End
76418>>>>>>>    End
76418>>>>>>>>
76418>>>>>>>    Function_Return sKey
76419>>>>>>>  End_Function
76420>>>>>>>
76420>>>>>>>  //
76420>>>>>>>  // Juggles the order of the keys in the array a bit so that they end up looking more natural
76420>>>>>>>  // to the end user. Eg. Ctrl+Alt+Enter looks a lot better as Enter+Alt+Ctrl
76420>>>>>>>  // After this the order is left to right Ctrl+Alt+Shift ->> everything else
76420>>>>>>>  Function NaturalOrderKeys Integer[] Keys Returns Integer[]
76422>>>>>>>    Integer iKey
76422>>>>>>>
76422>>>>>>>    // Move Shift in front position
76422>>>>>>>    Move (SearchArray(VK_SHIFT,Keys)) To iKey
76423>>>>>>>    If (iKey>-1) Begin
76425>>>>>>>      Move (RemoveFromArray(Keys,iKey)) To Keys
76426>>>>>>>      Move (InsertInArray(Keys,0,VK_SHIFT)) To Keys
76427>>>>>>>    End
76427>>>>>>>>
76427>>>>>>>    // Move Alt in front position
76427>>>>>>>    Move (SearchArray(VK_MENU,Keys)) To iKey
76428>>>>>>>    If (iKey>-1) Begin
76430>>>>>>>      Move (RemoveFromArray(Keys,iKey)) To Keys
76431>>>>>>>      Move (InsertInArray(Keys,0,VK_MENU)) To Keys
76432>>>>>>>    End
76432>>>>>>>>
76432>>>>>>>    // Move Ctrl in front position if it exists as "Ctrl+Enter" looks better as "Enter+Ctrl"
76432>>>>>>>    Move (SearchArray(VK_CONTROL,Keys)) To iKey
76433>>>>>>>    If (iKey>-1) Begin
76435>>>>>>>      Move (RemoveFromArray(Keys,iKey)) To Keys
76436>>>>>>>      Move (InsertInArray(Keys,0,VK_CONTROL)) To Keys
76437>>>>>>>    End
76437>>>>>>>>
76437>>>>>>>    Function_Return Keys
76438>>>>>>>  End_Function
76439>>>>>>>
76439>>>>>>>
76439>>>>>>>  Function ReadKeyboardState Returns Integer[]
76441>>>>>>>    Boolean   bFiltered // filter left/right alt/ctrl/shift keys as we don't want to see those
76441>>>>>>>    Integer   iSuccess
76441>>>>>>>    Integer   iKey
76441>>>>>>>    Integer[] Keys
76442>>>>>>>    UChar[256] KeyState
76443>>>>>>>
76443>>>>>>>    Move True To bFiltered
76444>>>>>>>    Move (ResizeArray(Keys,0)) To Keys
76445>>>>>>>    Move (GetKeyboardState(AddressOf(KeyState))) To iSuccess
76446>>>>>>>    If (iSuccess) Begin
76448>>>>>>>      For iKey From 0 To 255
76454>>>>>>>>
76454>>>>>>>        If ((KeyState[iKey] iAnd KS_KeyDown) = KS_KeyDown) Begin
76456>>>>>>>          If (bFiltered) Begin
76458>>>>>>>            If (iKey <> VK_LSHIFT and iKey <> VK_LCONTROL and iKey <> VK_LMENU and iKey <> VK_RSHIFT and iKey <> VK_RCONTROL and iKey <> VK_RMENU ) Begin
76460>>>>>>>              Move iKey To Keys[SizeOfArray(Keys)]
76461>>>>>>>            End
76461>>>>>>>>
76461>>>>>>>          End
76461>>>>>>>>
76461>>>>>>>          Else Begin
76462>>>>>>>            Move iKey To Keys[SizeOfArray(Keys)]
76463>>>>>>>          End
76463>>>>>>>>
76463>>>>>>>        End
76463>>>>>>>>
76463>>>>>>>      Loop
76464>>>>>>>>
76464>>>>>>>    End
76464>>>>>>>>
76464>>>>>>>    Function_Return Keys
76465>>>>>>>  End_Function
76466>>>>>>>
76466>>>>>>>  Function KeysToString Integer[] Keys Returns String
76468>>>>>>>    Integer iKey
76468>>>>>>>    Integer iCount
76468>>>>>>>    String  sKey
76468>>>>>>>    String  sShortCut
76468>>>>>>>
76468>>>>>>>    Move "" To sShortCut
76469>>>>>>>    Move (SizeOfArray(Keys)) To iCount
76470>>>>>>>    If (iCount>0) Begin
76472>>>>>>>      Get NaturalOrderKeys Keys To Keys
76473>>>>>>>      For iKey From 0 To (iCount-1)
76479>>>>>>>>
76479>>>>>>>        Get MapVKtoString Keys[iKey] To sKey
76480>>>>>>>        If (iKey=0) ;          Move sKey To sShortCut
76483>>>>>>>        Else ;          Move (sShortCut * "+" * sKey) To sShortCut
76485>>>>>>>      Loop
76486>>>>>>>>
76486>>>>>>>    End
76486>>>>>>>>
76486>>>>>>>    Function_Return sShortCut
76487>>>>>>>  End_Function
76488>>>>>>>
76488>>>>>>>  Function CommandHotKeyString tSciCommandHotKey Command Returns String
76490>>>>>>>    String sShortCut
76490>>>>>>>    String sShortCut2
76490>>>>>>>
76490>>>>>>>    Get KeysToString Command.HotKey.VKcode  To sShortCut
76491>>>>>>>    Get KeysToString Command.HotKey2.VKcode To sShortCut2
76492>>>>>>>    If (sShortCut2<>"") Begin
76494>>>>>>>      Move (sShortCut + ", " + sShortCut2) To sShortCut
76495>>>>>>>    End
76495>>>>>>>>
76495>>>>>>>    Function_Return sShortCut
76496>>>>>>>  End_Function
76497>>>>>>>
76497>>>>>>>  Procedure ClearAllShortCutKeyDefinitions
76499>>>>>>>    Integer iItem
76499>>>>>>>    Integer iCmdCount
76499>>>>>>>    tShortCut EmptyHotKey
76499>>>>>>>    tShortCut EmptyHotKey
76499>>>>>>>    tSciCommandHotKey Command
76499>>>>>>>    tSciCommandHotKey Command
76499>>>>>>>    tSciCommandHotKey[] Commands
76499>>>>>>>    tSciCommandHotKey[] Commands
76500>>>>>>>
76500>>>>>>>    Get pCommands To Commands
76501>>>>>>>    Move (SizeOfArray(Commands)) To iCmdCount
76502>>>>>>>    For iItem From 0 To (iCmdCount-1)
76508>>>>>>>>
76508>>>>>>>      Move Commands[iItem] To Command
76509>>>>>>>      Move EmptyHotKey To Command.HotKey
76510>>>>>>>      Move EmptyHotKey To Command.HotKey2
76511>>>>>>>      Move Command To Commands[iItem]
76512>>>>>>>    Loop
76513>>>>>>>>
76513>>>>>>>    Set pCommands To Commands
76514>>>>>>>  End_Procedure
76515>>>>>>>
76515>>>>>>>  //
76515>>>>>>>  // Returns a serialized version of all the current shortcut definitions for the available commands
76515>>>>>>>  // format is <CmdShortcut1>,<CmdShortcut2>,<CmdShortcut3>,..
76515>>>>>>>  // Where <CmdShortcut1> = <iCmd,iDfKeyCode1,VKCode(s):iDfKeyCode2,VKCode2(s)>
76515>>>>>>>  //
76515>>>>>>>  // If a command has no defined shortcut, then the command is not in the list
76515>>>>>>>  Function ShortCutKeyDefinitions Returns String
76517>>>>>>>    Boolean bHasHotKey
76517>>>>>>>    Integer iItem
76517>>>>>>>    Integer iKey
76517>>>>>>>    Integer iKeyCount
76517>>>>>>>    Integer iCmdCount
76517>>>>>>>    String  sHotKey
76517>>>>>>>    String  sDefinitions
76517>>>>>>>    tShortCut HotKey
76517>>>>>>>    tShortCut HotKey
76517>>>>>>>    tSciCommandHotKey Command
76517>>>>>>>    tSciCommandHotKey Command
76517>>>>>>>    tSciCommandHotKey[] Commands
76517>>>>>>>    tSciCommandHotKey[] Commands
76518>>>>>>>
76518>>>>>>>    Move "" To sDefinitions
76519>>>>>>>    Get pCommands To Commands
76520>>>>>>>    Move (SizeOfArray(Commands)) To iCmdCount
76521>>>>>>>    For iItem From 0 To (iCmdCount-1)
76527>>>>>>>>
76527>>>>>>>      Move Commands[iItem] To Command
76528>>>>>>>      Get CommandHasHotKey Command To bHasHotKey
76529>>>>>>>      If (bHasHotKey) Begin
76531>>>>>>>        Move Command.HotKey To HotKey
76532>>>>>>>        Move ("<"+Trim(Command.iCmd)+"|"+Trim(HotKey.iDFKey)) To sHotKey
76533>>>>>>>        Move (SizeOfArray(HotKey.VKcode)) To iKeyCount
76534>>>>>>>        For iKey From 0 To (iKeyCount-1)
76540>>>>>>>>
76540>>>>>>>          Move (sHotKey+'|'+Trim(HotKey.VKcode[iKey])) To sHotKey
76541>>>>>>>        Loop
76542>>>>>>>>
76542>>>>>>>        Move Command.HotKey2 To HotKey
76543>>>>>>>        If (SizeOfArray(HotKey.VKcode)>0) Begin
76545>>>>>>>          // there's a second hotkey defined
76545>>>>>>>          Move (sHotKey+":"+Trim(HotKey.iDFKey)) To sHotKey
76546>>>>>>>          Move (SizeOfArray(HotKey.VKcode)) To iKeyCount
76547>>>>>>>          For iKey From 0 To (iKeyCount-1)
76553>>>>>>>>
76553>>>>>>>            Move (sHotKey+'|'+Trim(HotKey.VKcode[iKey])) To sHotKey
76554>>>>>>>          Loop
76555>>>>>>>>
76555>>>>>>>        End
76555>>>>>>>>
76555>>>>>>>        Move (sHotKey+">") To sHotKey
76556>>>>>>>        If (sDefinitions="") ;          Move sHotKey To sDefinitions
76559>>>>>>>        Else ;          Move (sDefinitions+sHotKey) To sDefinitions
76561>>>>>>>      End
76561>>>>>>>>
76561>>>>>>>    Loop
76562>>>>>>>>
76562>>>>>>>    Function_Return sDefinitions
76563>>>>>>>  End_Function
76564>>>>>>>
76564>>>>>>>  //
76564>>>>>>>  // Deserialize vkKeys passed in a string as "nnn|nnn|nnn" to an integer array with vkKey items
76564>>>>>>>  //
76564>>>>>>>  Function DeserializeVkKeys String sVkKeys Returns Integer[]
76566>>>>>>>    Integer iPos
76566>>>>>>>    String  sVkKey
76566>>>>>>>    Integer[] vkKeys
76567>>>>>>>
76567>>>>>>>    Move "" To sVkKey
76568>>>>>>>    Move (ResizeArray(vkKeys,0))  To vkKeys
76569>>>>>>>    While (Pos("|",sVkKeys))
76573>>>>>>>      Move (Pos("|",sVkKeys)) To iPos
76574>>>>>>>      Move (Left(sVkKeys,iPos-1)) To sVkKey
76575>>>>>>>      Move (Replace(sVkKey+"|",sVkKeys,"")) To sVkKeys
76576>>>>>>>      Move (Cast(sVkKey,Integer)) To vkKeys[SizeOfArray(vkKeys)]
76577>>>>>>>    Loop
76578>>>>>>>>
76578>>>>>>>    If (sVkKeys<>"") Begin
76580>>>>>>>      Move (Cast(sVkKeys,Integer)) To vkKeys[SizeOfArray(vkKeys)]
76581>>>>>>>    End
76581>>>>>>>>
76581>>>>>>>    Function_Return vkKeys
76582>>>>>>>  End_Function
76583>>>>>>>
76583>>>>>>>  //
76583>>>>>>>  // Reads the above defined shortcut serialization format from sDefinitions and assigns it to our command list.
76583>>>>>>>  //
76583>>>>>>>  Procedure Set ShortCutKeyDefinitions String sDefinitions
76585>>>>>>>    Integer iItem
76585>>>>>>>    Integer iPos
76585>>>>>>>    Integer iCmd
76585>>>>>>>    Integer iDfkey iDfKey2
76585>>>>>>>    Integer[] vkKeys vkKeys2
76587>>>>>>>    String  sHotKey
76587>>>>>>>    String  sCmd
76587>>>>>>>    String  sDfKey sDfKey2
76587>>>>>>>    String  sVkKeys sVkKey
76587>>>>>>>    tSciCommandHotKey Command
76587>>>>>>>    tSciCommandHotKey Command
76587>>>>>>>    tSciCommandHotKey[] Commands
76587>>>>>>>    tSciCommandHotKey[] Commands
76588>>>>>>>
76588>>>>>>>    Send ClearAllShortCutKeyDefinitions
76589>>>>>>>    Get pCommands To Commands
76590>>>>>>>    While (Pos("<",sDefinitions)>0)
76594>>>>>>>      Move "" To sHotKey
76595>>>>>>>      Move (Pos(">",sDefinitions)) To iPos
76596>>>>>>>      If (iPos>0) Begin
76598>>>>>>>        Move (Left(sDefinitions,iPos)) To sHotKey // HotKey definition for 1 command
76599>>>>>>>        Move (Replace(sHotKey,sDefinitions,"")) To sDefinitions
76600>>>>>>>      End
76600>>>>>>>>
76600>>>>>>>      Else ;        Move "" To sDefinitions
76602>>>>>>>
76602>>>>>>>      Move (Replace("<",sHotKey,"")) To sHotKey
76603>>>>>>>      Move (Replace(">",sHotKey,"")) To sHotKey
76604>>>>>>>      If (sHotKey<>"") Begin
76606>>>>>>>        Move "" To sCmd            // first initialize all variables we use for parsing
76607>>>>>>>        Move "" To sDfKey
76608>>>>>>>        Move "" To sDfKey2
76609>>>>>>>        Move "" To sVkKeys
76610>>>>>>>        Move 0  To iCmd
76611>>>>>>>        Move 0  To iDfkey
76612>>>>>>>        Move 0  To iDfKey2
76613>>>>>>>        Move (ResizeArray(vkKeys,0))  To vkKeys
76614>>>>>>>        Move (ResizeArray(vkKeys2,0)) To vkKeys2
76615>>>>>>>
76615>>>>>>>        Move (Pos("|",sHotKey)) To iPos
76616>>>>>>>        If (iPos>0) Begin
76618>>>>>>>          Move (Left(sHotKey,iPos-1)) To sCmd
76619>>>>>>>          Move (Replace(sCmd+"|",sHotKey,"")) To sHotKey
76620>>>>>>>          Move (Pos("|",sHotKey)) To iPos
76621>>>>>>>          If (iPos>0) Begin
76623>>>>>>>            Move (Left(sHotKey,iPos-1)) To sDfkey
76624>>>>>>>            Move (Replace(sDfKey+"|",sHotKey,"")) To sHotKey
76625>>>>>>>            Move (Pos(":",sHotKey)) To iPos
76626>>>>>>>            If (iPos>0) Begin
76628>>>>>>>              Move (Left(sHotKey,iPos-1)) To sVkKeys
76629>>>>>>>              Move (Replace(sVkKeys+":",sHotKey,"")) To sHotKey
76630>>>>>>>            End
76630>>>>>>>>
76630>>>>>>>            Else Begin
76631>>>>>>>              Move sHotKey To sVkKeys
76632>>>>>>>              Move "" To sHotKey
76633>>>>>>>            End
76633>>>>>>>>
76633>>>>>>>          End
76633>>>>>>>>
76633>>>>>>>          Else ;            Move "" To sHotKey
76635>>>>>>>        End
76635>>>>>>>>
76635>>>>>>>        Else ;          Move "" To sHotKey
76637>>>>>>>        If (sVkKeys<>"") Begin
76639>>>>>>>          Get DeserializeVkKeys sVkKeys To vkKeys
76640>>>>>>>        End
76640>>>>>>>>
76640>>>>>>>        If (sHotKey<>"") Begin
76642>>>>>>>          // there's a 2nd hotkey in here
76642>>>>>>>          Move (Pos("|",sHotKey)) To iPos
76643>>>>>>>          If (iPos>0) Begin
76645>>>>>>>            Move (Left(sHotKey,iPos-1)) To sDfkey2
76646>>>>>>>            Move (Replace(sDfKey2+"|",sHotKey,"")) To sHotKey
76647>>>>>>>            Move sHotKey To sVkKeys
76648>>>>>>>            Get DeserializeVkKeys sVkKeys To vkKeys2
76649>>>>>>>          End
76649>>>>>>>>
76649>>>>>>>        End
76649>>>>>>>>
76649>>>>>>>        Move (Cast(sCmd,Integer))    To iCmd
76650>>>>>>>        Move 0 To iItem
76651>>>>>>>        If (iCmd<>0) Begin
76653>>>>>>>          Get FindCommandIndex iCmd To iItem
76654>>>>>>>        End
76654>>>>>>>>
76654>>>>>>>        If (iItem>-1) Begin
76656>>>>>>>          Move Commands[iItem] To Command
76657>>>>>>>          Move (Cast(sDfKey,Integer))  To iDfkey
76658>>>>>>>
76658>>>>>>>          Move iDfkey To Command.HotKey.iDFKey
76659>>>>>>>          Move vkKeys To Command.HotKey.VKcode
76660>>>>>>>          If (sDfKey2<>"") Begin
76662>>>>>>>            Move (Cast(sDfKey2,Integer)) To iDfKey2
76663>>>>>>>            Move iDfkey2 To Command.HotKey2.iDFKey
76664>>>>>>>            Move vkKeys2 To Command.HotKey2.VKcode
76665>>>>>>>          End
76665>>>>>>>>
76665>>>>>>>          Move Command To Commands[iItem]
76666>>>>>>>        End
76666>>>>>>>>
76666>>>>>>>      End
76666>>>>>>>>
76666>>>>>>>    Loop
76667>>>>>>>>
76667>>>>>>>
76667>>>>>>>    Set pCommands To Commands
76668>>>>>>>  End_Procedure
76669>>>>>>>
76669>>>>>>>  // If no definition has been found then we need to set some defaults
76669>>>>>>>  // Below are our defaults (You can create defaults by copy&paste from the config ini file)
76669>>>>>>>  Function DefaultDefinitions Returns String
76671>>>>>>>    String sShortCuts
76671>>>>>>>
76671>>>>>>>    Move "<206|299|17|40><205|298|17|38><204|279|13|17><1025|270|118><1024|269|116><203|260|37><202|5127|16|37><201|261|39><200|5128|16|39><242|7174|16|17|40><243|2080|17|32><198|2147|17|67><197|2168|17|88><196|2679|17|18|87>" To sShortCuts
76672>>>>>>>    Move (sShortCuts+"<195|277|46><194|278|8:5123|8|16><191|301|17|35><190|7178|16|17|35><189|300|17|36><188|7177|16|17|36><1005|312|17|115><1007|2158|17|78><1001|2159|17|79><1004|2163|17|83><1002|265|113><1003|6161|17|113><178|2150|17|70>") To sShortCuts
76673>>>>>>>    Move (sShortCuts+"<1010|3142|16|17|70><176|281|114><175|6162|17|114><174|5138|16|114><173|7186|16|17|114><169|6674|17|18|114><168|2151|17|71><166|2141|17|221><165|294|36><164|5129|16|36><163|296|9>") To sShortCuts
76674>>>>>>>    Move (sShortCuts+"<1064|2664|17|18|72><161|2169|17|89><157|273|40><156|5126|16|40><155|295|35><154|5130|16|35><153|3150|16|17|78><149|272|38><148|5125|16|38><1050|4615|18|37><1057|559|18|191><1051|4614|18|40><1052|4616|18|39>") To sShortCuts
76675>>>>>>>    Move (sShortCuts+"<147|2156|17|76><146|291|34><145|5132|16|34><144|290|33><143|5131|16|33><140|2166|17|86><224|4609|13|18><213|3154|16|17|82><1079|3155|16|17|83><137|2145|17|65><136|6679|17|18|119><134|3160|16|17|88>") To sShortCuts
76676>>>>>>>    Move (sShortCuts+"<1011|2167|17|87><133|2667|17|18|75><132|6663|17|18|37><131|6664|17|18|39><187|2162|17|82><130|3156|16|17|84><1060|609|18|65><186|276|45><185|2676|17|18|84><1062|2152|17|72><129|2170|17|90><127|262|9|16>") To sShortCuts
76677>>>>>>>    Move (sShortCuts+"<126|3104|16|17|32><125|2165|17|85><1043|6146|9|17><1044|7170|9|16|17><120|292|17|33><119|293|17|34><1040|268|18|112><1042|6166|17|118><112|6158|17|46><111|297|8|17><108|302|17|37><107|7175|16|17|37><103|303|17|39>") To sShortCuts
76678>>>>>>>    Move (sShortCuts+"<102|7176|16|17|39>") To sShortCuts
76679>>>>>>>    Function_Return sShortCuts
76680>>>>>>>  End_Function
76681>>>>>>>
76681>>>>>>>  Function HasVkKey Integer[] VKcode Integer vk Returns Boolean
76683>>>>>>>    Boolean bHasKey
76683>>>>>>>    Integer iKey
76683>>>>>>>    Integer iCount
76683>>>>>>>
76683>>>>>>>    Move False To bHasKey
76684>>>>>>>    Move (SizeOfArray(VKcode)) To iCount
76685>>>>>>>    For iKey From 0 To (iCount-1)
76691>>>>>>>>
76691>>>>>>>      If (VKcode[iKey]=vk) Begin
76693>>>>>>>        Move True To bHasKey
76694>>>>>>>        Move iCount To iKey
76695>>>>>>>      End
76695>>>>>>>>
76695>>>>>>>    Loop
76696>>>>>>>>
76696>>>>>>>    Function_Return bHasKey
76697>>>>>>>  End_Function
76698>>>>>>>
76698>>>>>>>  //
76698>>>>>>>  // If a hotkey has alt then it has that annoying bell sound unless you handle it.
76698>>>>>>>  // Here's the code to detect that.
76698>>>>>>>  // Pre: only call this if the command actually has a hotkey assigned.
76698>>>>>>>  //
76698>>>>>>>  Function HotKeyHasAlt Integer iCmd Returns Boolean
76700>>>>>>>    Boolean bAlt
76700>>>>>>>    tSciCommandHotKey Command
76700>>>>>>>    tSciCommandHotKey Command
76700>>>>>>>
76700>>>>>>>    Move False To bAlt
76701>>>>>>>    Get FindCommand Of oSciCommandHotKeys iCmd To Command
76702>>>>>>>    If (Command.iCmd=iCmd) Begin
76704>>>>>>>      Get HasVkKey Of oSciCommandHotKeys Command.HotKey.VKcode VK_MENU To bAlt
76705>>>>>>>      If (bAlt=False) Begin
76707>>>>>>>        Get HasVkKey Of oSciCommandHotKeys Command.HotKey2.VKcode VK_MENU To bAlt
76708>>>>>>>      End
76708>>>>>>>>
76708>>>>>>>    End
76708>>>>>>>>
76708>>>>>>>    Function_Return bAlt
76709>>>>>>>  End_Function
76710>>>>>>>
76710>>>>>>>
76710>>>>>>>  //
76710>>>>>>>  // On_Key shortcut definitions are so much fun. You can't just pass them the DataFlex value as retrieved from procedure Key
76710>>>>>>>  // You'll have to do some math on them to return back the correct integer value that the On_Key wants in order
76710>>>>>>>  // to have it work correctly.
76710>>>>>>>  // You also cannot use expressions (see forum: https://support.dataaccess.com/Forums/showthread.php?60684-Dynamic-Keyboard-shortcut-brain-teaser )
76710>>>>>>>  // In this function we will try to figure out what it takes.
76710>>>>>>>  //
76710>>>>>>>  // For the moment it is still pretty much a riddle, here's what testing shows:
76710>>>>>>>  //
76710>>>>>>>  //  iDfKey < 605       ==> iOnKey = iDfKey
76710>>>>>>>  //  iDfKey 2139..2141  ==> iOnKey = iDfKey (ctrl+[ and ctrl+])
76710>>>>>>>  //  iDfKey 605..3141   ==> iOnKey = iDfKey-32
76710>>>>>>>  //  iDfKey 3142..4609  ==> iOnKey = iDfKey
76710>>>>>>>  //  iDfKey > 4609 ==> if ctrl/alt/shift subtract $1000 then subtract value for each modifier key
76710>>>>>>>  //                    add back new value for each modifier key and add offset
76710>>>>>>>  //  iDfKey >= 6672 ==> iOnKey = iDfKey
76710>>>>>>>  //
76710>>>>>>>  Function DataFlexOnKey tShortCut HotKey Returns Integer
76712>>>>>>>    Boolean bAlt bShift bCtrl
76712>>>>>>>    Integer iOnKey
76712>>>>>>>    Integer iDfKey
76712>>>>>>>    Integer iDfOffset
76712>>>>>>>
76712>>>>>>>    Move HotKey.iDFKey To iDfKey
76713>>>>>>>    //
76713>>>>>>>    Move iDFKey To iOnKey
76714>>>>>>>    Move 32     To iDfOffset
76715>>>>>>>    If (iDfKey>2138 and iDfKey<2142) ;      Move 0 To iDfOffset
76718>>>>>>>    If (iDfkey>605 and iDfKey<3142) ;      Move (iDfKey-iDfOffset) To iOnkey
76721>>>>>>>    Else If (iDfkey>4609 and iDfkey<6672) Begin
76724>>>>>>>      Get HasVkKey HotKey.VKcode VK_MENU    To bAlt
76725>>>>>>>      Get HasVkKey HotKey.VKcode VK_SHIFT   To bShift
76726>>>>>>>      Get HasVkKey HotKey.VKcode VK_CONTROL To bCtrl
76727>>>>>>>
76727>>>>>>>      If (bAlt or bShift or bCtrl) Begin
76729>>>>>>>        Move |CI$1000 To iDfOffset
76730>>>>>>>        If (bAlt) ;          Move (iDfOffset+|CI$0200) To iDfOffset
76733>>>>>>>        If (bShift) ;          Move (iDfOffset+|CI$0400) To iDfOffset
76736>>>>>>>        If (bCtrl) ;          Move (iDfOffset+|CI$0800) To iDfOffset
76739>>>>>>>        If (iDfOffset=|CI$1200 or iDfOffset=|CI$1400 or iDfOffset=|CI$1800) Begin
76741>>>>>>>          // only 1 modifier key was pressed, offset goes back to 0, iDfKey=iOnKey
76741>>>>>>>          Move 0 To iDfOffset
76742>>>>>>>        End
76742>>>>>>>>
76742>>>>>>>        If (iDfOffset<>0) Begin
76744>>>>>>>          Move |CI$EF8 To iDfOffset
76745>>>>>>>          Move (iDfKey-iDfOffset) To iOnKey
76746>>>>>>>        End
76746>>>>>>>>
76746>>>>>>>      End
76746>>>>>>>>
76746>>>>>>>
76746>>>>>>>    End
76746>>>>>>>>
76746>>>>>>>
76746>>>>>>>    Function_Return iOnKey
76747>>>>>>>  End_Function
76748>>>>>>>
76748>>>>>>>End_Class
76749>>>>>>>
76749>>>>>>>Object oSciCommandHotKeys is a cSciCommandHotKeys
76751>>>>>>>End_Object
76752>>>>>>>
76752>>>>>>>Procedure CMRegisterCommand Global Integer iCmd String sName String sDesc
76754>>>>>>>  Send RegisterCommand Of oSciCommandHotKeys iCmd sName sDesc
76755>>>>>>>End_Procedure
76756>>>>>>>
76756>>>>>>>// Used for declaring a Userdefined Command which can be accesed from within
76756>>>>>>>// our editing control.
76756>>>>>>>
76756>>>>>>>Procedure RegisterInternalCommand Global Integer iCmd String sName String sDesc
76758>>>>>>>  Send RegisterCommand Of oSciCommandHotKeys iCmd sName sDesc
76759>>>>>>>End_Procedure
76760>>>>>>>
76760>>>>>>>//
76760>>>>>>>// Need to register all our internal commands so that we have a similar set as with
76760>>>>>>>// codemax. The below text is pretty much a copy of what codemax has.
76760>>>>>>>//
76760>>>>>>>Procedure RegisterAllInternalCommands
76762>>>>>>>  tSciCommandHotKey[] ltCommands
76762>>>>>>>  tSciCommandHotKey[] ltCommands
76763>>>>>>>  Set pCommands Of oSciCommandHotKeys To ltCommands
76764>>>>>>>  Send RegisterInternalCommand  CMD_WORDUPPERCASE               "WordUpperCase"             (_T("Makes the current word uppercase", 1100))
76765>>>>>>>  Send RegisterInternalCommand  CMD_WORDTRANSPOSE               "WordTranspose"             (_T("Swaps the current and previous words", 1101))
76766>>>>>>>  Send RegisterInternalCommand  CMD_WORDRIGHTEXTEND             "WordRightExtend"           (_T("Extends the selection forward to the start of the next word", 1102))
76767>>>>>>>  Send RegisterInternalCommand  CMD_WORDRIGHT                   "WordRight"                 (_T("Moves forward to the start of the next word", 1103))
76768>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDRIGHT                "WordEndRight"              (_T("Moves forward to the end of the next word", 1104))
76769>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDRIGHTEXTEND          "WordEndRightExtend"        (_T("Extends the selection forward to the end of the next word", 1105))
76770>>>>>>>  Send RegisterInternalCommand  CMD_WORDLOWERCASE               "WordLowerCase"             (_T("Makes the current word lowercase", 1106))
76771>>>>>>>  Send RegisterInternalCommand  CMD_WORDLEFTEXTEND              "WordLeftExtend"            (_T("Extends the selection backward to the start of the previous word", 1107))
76772>>>>>>>  Send RegisterInternalCommand  CMD_WORDLEFT                    "WordLeft"                  (_T("Moves backward to the start of the previous word", 1108))
76773>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDLEFT                 "WordEndLeft"               (_T("Moves backward to the end of the previous word", 1109))
76774>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDLEFTEXTEND           "WordEndLeftExtend"         (_T("Extends the selection backward to the end of the previous word", 1110))
76775>>>>>>>  Send RegisterInternalCommand  CMD_WORDDELETETOSTART           "WordDeleteToStart"         (_T("Deletes a word to the left", 1111))
76776>>>>>>>  Send RegisterInternalCommand  CMD_WORDDELETETOEND             "WordDeleteToEnd"           (_T("Deletes a word to the right", 1112))
76777>>>>>>>  Send RegisterInternalCommand  CMD_WORDCAPITALIZE              "WordCapitalize"            (_T("Makes the first character uppercase", 1113))
76778>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSTART                 "WindowStart"               (_T("Moves to the top of the text window", 1114))
76779>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLUP              "WindowScrollUp"            (_T("Scrolls the file contents up one line", 1115))
76780>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLTOTOP           "WindowScrollToTop"         (_T("Scrolls the line to the top of the window", 1116))
76781>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLTOCENTER        "WindowScrollToCenter"      (_T("Scrolls the line to the center of the window", 1117))
76782>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLTOBOTTOM        "WindowScrollToBottom"      (_T("Scrolls the line to the bottom of the window", 1118))
76783>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLRIGHT           "WindowScrollRight"         (_T("Scrolls the window to the right", 1119))
76784>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLLEFT            "WindowScrollLeft"          (_T("Scrolls the window to the left", 1120))
76785>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLDOWN            "WindowScrollDown"          (_T("Scrolls the file contents down one line", 1121))
76786>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWRIGHTEDGE             "WindowRightEdge"           (_T("Moves to the right edge of the text window", 1122))
76787>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWLEFTEDGE              "WindowLeftEdge"            (_T("Moves to the left edge of the text window", 1123))
76788>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWEND                   "WindowEnd"                 (_T("Moves to the bottom of the text window", 1124))
76789>>>>>>>  Send RegisterInternalCommand  CMD_UPPERCASESELECTION          "UpperCaseSelection"        (_T("Makes the selection all uppercase", 1125))
76790>>>>>>>  Send RegisterInternalCommand  CMD_UNTABIFYSELECTION           "UntabifySelection"         (_T("Replaces tabs with spaces in the selection", 1126))
76791>>>>>>>  Send RegisterInternalCommand  CMD_UNINDENTSELECTION           "UnindentSelection"         (_T("Indents the selected text left one stop", 1127))
76792>>>>>>>  Send RegisterInternalCommand  CMD_UNDOCHANGES                 "UndoChanges"               (_T("Undo's the last action, ignoring movement commands", 1128))
76793>>>>>>>  Send RegisterInternalCommand  CMD_UNDO                        "Undo"                      (_T("Undo the last action", 1129))
76794>>>>>>>  Send RegisterInternalCommand  CMD_TABIFYSELECTION             "TabifySelection"           (_T("Replaces spaces with tabs in the selection", 1130))
76795>>>>>>>  Send RegisterInternalCommand  CMD_SENTENCERIGHT               "SentenceRight"             (_T("Moves to the beginning of the next sentence", 1131))
76796>>>>>>>  Send RegisterInternalCommand  CMD_SENTENCELEFT                "SentenceLeft"              (_T("Moves to the beginning of the previous sentence", 1132))
76797>>>>>>>  Send RegisterInternalCommand  CMD_SENTENCECUT                 "SentenceCut"               (_T("Deletes the remainder of the sentence", 1133))
76798>>>>>>>  Send RegisterInternalCommand  CMD_SELECTSWAPANCHOR            "SelectSwapAnchor"          (_T("Swaps the anchor and the cursor in a selection", 1134))
76799>>>>>>>  Send RegisterInternalCommand  CMD_SELECTPARA                  "SelectPara"                (_T("Selects the current paragraph", 1135))
76800>>>>>>>  Send RegisterInternalCommand  CMD_SELECTLINE                  "SelectLine"                (_T("Selects lines of text", 1136))
76801>>>>>>>  Send RegisterInternalCommand  CMD_SELECTALL                   "SelectAll"                 (_T("Selects the entire document", 1137))
76802>>>>>>>  Send RegisterInternalCommand  CMD_REDOCHANGES                 "RedoChanges"               (_T("Redoes the last action, ignoring movement commands", 1138))
76803>>>>>>>  Send RegisterInternalCommand  CMD_REDO                        "Redo"                      (_T("Redoes the previously undone action", 1139))
76804>>>>>>>  Send RegisterInternalCommand  CMD_PASTE                       "Paste"                     (_T("Inserts the clipboard contents at the insertion point", 1140))
76805>>>>>>>  Send RegisterInternalCommand  CMD_PARAUP                      "ParaUp"                    (_T("Moves to the beginning of the previous paragraph", 1141))
76806>>>>>>>  Send RegisterInternalCommand  CMD_PARADOWN                    "ParaDown"                  (_T("Moves to the beginning of the next paragraph", 1142))
76807>>>>>>>  Send RegisterInternalCommand  CMD_PAGEUPEXTEND                "PageUpExtend"              (_T("Extends the selection up one page", 1143))
76808>>>>>>>  Send RegisterInternalCommand  CMD_PAGEUP                      "PageUp"                    (_T("Moves the cursor up one page", 1144))
76809>>>>>>>  Send RegisterInternalCommand  CMD_PAGEDOWNEXTEND              "PageDownExtend"            (_T("Extends the selection down one page", 1145))
76810>>>>>>>  Send RegisterInternalCommand  CMD_PAGEDOWN                    "PageDown"                  (_T("Moves the cursor down one page", 1146))
76811>>>>>>>  Send RegisterInternalCommand  CMD_LOWERCASESELECTION          "LowerCaseSelection"        (_T("Makes the selection all lowercase", 1147))
76812>>>>>>>  Send RegisterInternalCommand  CMD_LINEUPEXTEND                "LineUpExtend"              (_T("Extends the selection up one line", 1148))
76813>>>>>>>  Send RegisterInternalCommand  CMD_LINEUP                      "LineUp"                    (_T("Moves the cursor up one line", 1149))
76814>>>>>>>  Send RegisterInternalCommand  CMD_LINETRANSPOSE               "LineTranspose"             (_T("Swaps current and previous lines", 1150))
76815>>>>>>>  Send RegisterInternalCommand  CMD_LINESTART                   "LineStart"                 (_T("Moves to the start of the current line", 1151))
76816>>>>>>>  Send RegisterInternalCommand  CMD_LINEOPENBELOW               "LineOpenBelow"             (_T("Opens a new line below the cursor", 1152))
76817>>>>>>>  Send RegisterInternalCommand  CMD_LINEOPENABOVE               "LineOpenAbove"             (_T("Opens a new line above the cursor", 1153))
76818>>>>>>>  Send RegisterInternalCommand  CMD_LINEENDEXTEND               "LineEndExtend"             (_T("Extends the selection to the end of the current line", 1154))
76819>>>>>>>  Send RegisterInternalCommand  CMD_LINEEND                     "LineEnd"                   (_T("Moves the cursor to the end of the current line", 1155))
76820>>>>>>>  Send RegisterInternalCommand  CMD_LINEDOWNEXTEND              "LineDownExtend"            (_T("Extends the selection down one line", 1156))
76821>>>>>>>  Send RegisterInternalCommand  CMD_LINEDOWN                    "LineDown"                  (_T("Moves the cursor down one line", 1157))
76822>>>>>>>  Send RegisterInternalCommand  CMD_LINEDELETETOSTART           "LineDeleteToStart"         (_T("Deletes to the beginning of the current line", 1158))
76823>>>>>>>  Send RegisterInternalCommand  CMD_LINEDELETETOEND             "LineDeleteToEnd"           (_T("Deletes to the end of the current line", 1159))
76824>>>>>>>  Send RegisterInternalCommand  CMD_LINEDELETE                  "LineDelete"                (_T("Deletes the selected line", 1160))
76825>>>>>>>  Send RegisterInternalCommand  CMD_LINECUT                     "LineCut"                   (_T("Deletes the selected line and places the text on the clipboard", 1161))
76826>>>>>>>  Send RegisterInternalCommand  CMD_INDENTTOPREV                "IndentToPrev"              (_T("Indents to the position of the next text on the previous line", 1162))
76827>>>>>>>  Send RegisterInternalCommand  CMD_INDENTSELECTION             "IndentSelection"           (_T("Indents to the selected text right one stop", 1163))
76828>>>>>>>  Send RegisterInternalCommand  CMD_HOMEEXTEND                  "HomeExtend"                (_T("Extends the selection to either the start of the current line or the start of the text on that line", 1164))
76829>>>>>>>  Send RegisterInternalCommand  CMD_HOME                        "Home"                      (_T("Moves to either the start of the current line or the start of the text on that line", 1165))
76830>>>>>>>  Send RegisterInternalCommand  CMD_GOTOMATCHBRACE              "GoToMatchBrace"            (_T("Finds the matching brace", 1166))
76831>>>>>>>  Send RegisterInternalCommand  CMD_GOTOINDENTATION             "GoToIndentation"           (_T("Moves to the end of the indentation", 1167))
76832>>>>>>>  Send RegisterInternalCommand  CMD_GOTOLINE                    "GoToLine"                  (_T("Moves to a user-specified line", 1168))
76833>>>>>>>  Send RegisterInternalCommand  CMD_FINDREPLACE                 "FindReplace"               (_T("Displays the Find & Replace dialog box", 1169))
76834>>>>>>>  Send RegisterInternalCommand  CMD_REPLACE                     "Replace"                   (_T("Replaces the first occurrence of the find text after the current position with the replace text", 1170))
76835>>>>>>>  Send RegisterInternalCommand  CMD_REPLACEALLINBUFFER          "ReplaceAllInBuffer"        (_T("Replaces the find text with the replace text in the entire buffer", 1171))
76836>>>>>>>  Send RegisterInternalCommand  CMD_REPLACEALLINSELECTION       "ReplaceAllInSelection"     (_T("Replaces the find text with the replace text in the selection", 1172))
76837>>>>>>>  Send RegisterInternalCommand  CMD_FINDPREVWORD                "FindPrevWord"              (_T("Finds the previous occurrence of the selected word", 1173))
76838>>>>>>>  Send RegisterInternalCommand  CMD_FINDPREV                    "FindPrev"                  (_T("Finds the previous occurrence of the specified text", 1174))
76839>>>>>>>  Send RegisterInternalCommand  CMD_FINDNEXTWORD                "FindNextWord"              (_T("Finds the next occurrence of the selected word", 1175))
76840>>>>>>>  Send RegisterInternalCommand  CMD_FINDNEXT                    "FindNext"                  (_T("Finds the next occurrence of the specified text", 1176))
76841>>>>>>>  Send RegisterInternalCommand  CMD_FINDMARKALL                 "FindMarkAll"               (_T("Finds the specified text and sets a bookmark at the specified locations", 1177))
76842>>>>>>>  Send RegisterInternalCommand  CMD_FIND                        "Find"                      (_T("Finds the specified text", 1178))
76843>>>>>>>  Send RegisterInternalCommand  CMD_SETFINDTEXT                 "SetFindKeyWord"            (_T("Sets the text to search for in subsequent find commands", 1179))
76844>>>>>>>  Send RegisterInternalCommand  CMD_SETREPLACETEXT              "SetReplaceKeyWord"         (_T("Sets the text to substitute for the find text in subsequent find & replace commands", 1180))
76845>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEPRESERVECASE          "TogglePreserveCase"        (_T("Toggles intelligent case preservation when replacing text", 1181))
76846>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEWHOLEWORD             "ToggleWholeWord"           (_T("Toggles whole word searching on and off", 1182))
76847>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLECASESENSITIVE         "ToggleCaseSensitive"       (_T("Toggles case sensitive searching on and off", 1183))
76848>>>>>>>  Send RegisterInternalCommand  CMD_END                         "End"                       (_T("Moves to the end of the current line, bottom of the text window, or end of the file", 1184))
76849>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEWHITESPACEDISPLAY     "ToggleWhiteSpaceDisplay"   (_T("Shows or hides whitespace indicators", 1185))
76850>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEOVERTYPE              "ToggleOvertype"            (_T("Toggles between inserting and replacing text", 1186))
76851>>>>>>>  Send RegisterInternalCommand  CMD_SETREPEATCOUNT              "SetRepeatCount"            (_T("Sets the repeat count for the next command", 1187))
76852>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTSTARTEXTEND         "DocumentStartExtend"       (_T("Extends the selection to the beginning of the file", 1188))
76853>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTSTART               "DocumentStart"             (_T("Moves to the beginning of the file", 1189))
76854>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTENDEXTEND           "DocumentEndExtend"         (_T("Extends the selection to the end of the file", 1190))
76855>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTEND                 "DocumentEnd"               (_T("Moves to the end of the file", 1191))
76856>>>>>>>  Send RegisterInternalCommand  CMD_DELETEHORIZONTALSPACE       "DeleteHorizontalSpace"     (_T("Deletes the spaces and the tabs around the cursor", 1192))
76857>>>>>>>  Send RegisterInternalCommand  CMD_DELETEBLANKLINES            "DeleteBlankLines"          (_T("Delete the blank lines adjacent to the cursor", 1193))
76858>>>>>>>  Send RegisterInternalCommand  CMD_DELETEBACK                  "DeleteBack"                (_T("Deletes the selection or, if there is no selection, the character to the left of the cursor", 1194))
76859>>>>>>>  Send RegisterInternalCommand  CMD_DELETE                      "Delete"                    (_T("Deletes the selection", 1195))
76860>>>>>>>  Send RegisterInternalCommand  CMD_CUTSELECTION                "CutSelection"              (_T("Cuts the selection and puts it on the clipboard", 1196))
76861>>>>>>>  Send RegisterInternalCommand  CMD_CUT                         "Cut"                       (_T("Cuts the selection and puts it on the clipboard", 1197))
76862>>>>>>>  Send RegisterInternalCommand  CMD_COPY                        "Copy"                      (_T("Copies the selection to the clipboard", 1198))
76863>>>>>>>  Send RegisterInternalCommand  CMD_CHARTRANSPOSE               "CharTranspose"             (_T("Swap characters around the insertion point", 1199))
76864>>>>>>>  Send RegisterInternalCommand  CMD_CHARRIGHTEXTEND             "CharRightExtend"           (_T("Extends the selection one character to the right", 1200))
76865>>>>>>>  Send RegisterInternalCommand  CMD_CHARRIGHT                   "CharRight"                 (_T("Moves the cursor one character to the right", 1201))
76866>>>>>>>  Send RegisterInternalCommand  CMD_CHARLEFTEXTEND              "CharLeftExtend"            (_T("Extends the selection one character to the left", 1202))
76867>>>>>>>  Send RegisterInternalCommand  CMD_CHARLEFT                    "CharLeft"                  (_T("Moves the cursor one character to the left", 1203))
76868>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKTOGGLE              "BookmarkToggle"            (_T("Toggles a bookmark for the current line on and off", 1204))
76869>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKPREV                "BookmarkPrev"              (_T("Moves to the line containing the previous bookmark", 1205))
76870>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKNEXT                "BookmarkNext"              (_T("Moves to the line containing the next bookmark", 1206))
76871>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKCLEARALL            "BookmarkClearAll"          (_T("Clears all bookmarks in the window", 1207))
76872>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKJUMPTOFIRST         "BookmarkJumpToFirst"       (_T("Moves to the first line containing a bookmark", 1208))
76873>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKJUMPTOLAST          "BookmarkJumpToLast"        (_T("Moves to the last line containing a bookmark", 1209))
76874>>>>>>>  Send RegisterInternalCommand  CMD_APPENDNEXTCUT               "AppendNextCut"             (_T("Appends the next cut text to end of clipboard", 1210))
76875>>>>>>>  Send RegisterInternalCommand  CMD_INSERTCHAR                  "InsertChar"                (_T("Inserts a character at the current location", 1211))
76876>>>>>>>  Send RegisterInternalCommand  CMD_NEWLINE                     "NewLine"                   (_T("Inserts a new-line character at the current location", 1212))
76877>>>>>>>  Send RegisterInternalCommand  CMD_RECORDMACRO                 "RecordMacro"               (_T("Begins/ends keystroke macro recording", 1213))
76878>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO1                  "PlayMacro1"                (_T("Plays keystroke macro 1", 1214))
76879>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO2                  "PlayMacro2"                (_T("Plays keystroke macro 2", 1215))
76880>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO3                  "PlayMacro3"                (_T("Plays keystroke macro 3", 1216))
76881>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO4                  "PlayMacro4"                (_T("Plays keystroke macro 4", 1217))
76882>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO5                  "Playmacro5"                (_T("Plays keystroke macro 5", 1218))
76883>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO6                  "Playmacro6"                (_T("Plays keystroke macro 6", 1219))
76884>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO7                  "Playmacro7"                (_T("Plays keystroke macro 7", 1220))
76885>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO8                  "Playmacro8"                (_T("Plays keystroke macro 8", 1221))
76886>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO9                  "Playmacro9"                (_T("Plays keystroke macro 9", 1222))
76887>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO10                 "Playmacro10"               (_T("Plays keystroke macro 10", 1223))
76888>>>>>>>  Send RegisterInternalCommand  CMD_PROPERTIES                  "Properties"                (_T("Displays the properties dialog", 1224))
76889>>>>>>>  Send RegisterInternalCommand  CMD_BEGINUNDO                   "BeginUndo"                 (_T("Starts an undo transaction", 1225))
76890>>>>>>>  Send RegisterInternalCommand  CMD_ENDUNDO                     "EndUndo"                   (_T("Ends an undo transaction", 1226))
76891>>>>>>>  //Send RegisterInternalCommand  CMD_RESERVED3                   "" ""  // internal use only (1227)
76891>>>>>>>
76891>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEREGEXP                "ToggleRegExp"              (_T("Toggles regular expression searching on and off", 1228))
76892>>>>>>>  Send RegisterInternalCommand  CMD_CLEARSELECTION              "ClearSelection"            (_T("Empties the selection", 1229))
76893>>>>>>>  Send RegisterInternalCommand  CMD_REGEXPON                    "RegExpOn"                  (_T("Turns on regular expression searching", 1230))
76894>>>>>>>  Send RegisterInternalCommand  CMD_REGEXPOFF                   "RegExpOff"                 (_T("Turns off regular expression searching", 1231))
76895>>>>>>>  Send RegisterInternalCommand  CMD_WHOLEWORDON                 "WholeWordOn"               (_T("Turns on whole word searching", 1232))
76896>>>>>>>  Send RegisterInternalCommand  CMD_WHOLEWORDOFF                "WholeWordOff"              (_T("Turns off whole word searching", 1233))
76897>>>>>>>  Send RegisterInternalCommand  CMD_PRESERVECASEON              "PreserveCaseOn"            (_T("Turns on case preservation when replacing text", 1234))
76898>>>>>>>  Send RegisterInternalCommand  CMD_PRESERVECASEOFF             "PreserveCaseOff"           (_T("Turns off case preservation when replacing text", 1235))
76899>>>>>>>  Send RegisterInternalCommand  CMD_CASESENSITIVEON             "CaseSensitiveOn"           (_T("Turns on case sensitive searching", 1236))
76900>>>>>>>  Send RegisterInternalCommand  CMD_CASESENSITIVEOFF            "CaseSensitiveOff"          (_T("Turns off case sensitive searching", 1237))
76901>>>>>>>  Send RegisterInternalCommand  CMD_WHITESPACEDISPLAYON         "WhiteSpaceDisplayOn"       (_T("Turns on white space display", 1238))
76902>>>>>>>  Send RegisterInternalCommand  CMD_WHITESPACEDISPLAYOFF        "WhiteSpaceDisplayOff"      (_T("Turns off white space display", 1239))
76903>>>>>>>  Send RegisterInternalCommand  CMD_OVERTYPEON                  "OvertypeOn"                (_T("Turns on overtype mode", 1240))
76904>>>>>>>  Send RegisterInternalCommand  CMD_OVERTYPEOFF                 "OvertypeOff"               (_T("Turns off overtype mode", 1241))
76905>>>>>>>  Send RegisterInternalCommand  CMD_CODELIST                    "CodeList"                  (_T("Activates the code list control", 1242))
76906>>>>>>>  Send RegisterInternalCommand  CMD_CODETIP                     "CodeTip"                   (_T("Activates the code tip control", 1243))
76907>>>>>>>  //Send RegisterInternalCommand  CMD_LAST                        "" ""
76907>>>>>>>End_Procedure
76908>>>>>>>
76908>>>>>>>// Registers commands for CodeMax so that these function can be accessed in macros and keyAssignments
76908>>>>>>>// This does only the registration! Connecting these commands to the actual code needs to be
76908>>>>>>>// done in the DefinePredefinedHotkeys of cEditorHotKey_Mixin
76908>>>>>>>Procedure RegisterExtraCommands
76910>>>>>>>
76910>>>>>>>  // File Menu. 1-9
76910>>>>>>>  CMDeclareCommand CMD_FileOpenFile               1 "FileOpenFile"            "Opens a file"
76911>>>>>>>  CMDeclareCommand CMD_FileSaveFile               2 "FileSaveFile"            "Saves the file"
76912>>>>>>>  CMDeclareCommand CMD_FileSaveFileAs             3 "FileSaveFileAs"          "Save file as..."
76913>>>>>>>  CMDeclareCommand CMD_FileSaveAll                4 "FileSaveAll"             "Saves all opened files"
76914>>>>>>>  CMDeclareCommand CMD_FileCloseFile              5 "FileCloseFile"           "Closes the file"
76915>>>>>>>  CMDeclareCommand CMD_FileCloseAllFiles          6 "FileCloseAllFiles"       "Closes all files"
76916>>>>>>>  CMDeclareCommand CMD_FileNewFile                7 "FileNewFile"             "Create a new file"
76917>>>>>>>
76917>>>>>>>  // Options Menu 10-19
76917>>>>>>>  CMDeclareCommand CMD_FindInFiles                10 "FindInFiles"            "Search the text in multiple files"
76918>>>>>>>  CMDeclareCommand CMD_SelectWorkSpace            11 "SelectWorkSpace"       "Select another workspace to work in"
76919>>>>>>>
76919>>>>>>>  // Build Menu 20-29
76919>>>>>>>  CMDeclareCommand CMD_BuildRun                   20 "BuildRun"                "Compiles and runs the main program (or current file if is '.SRC')"
76920>>>>>>>  CMDeclareCommand CMD_BuildRunCurrent            21 "BuildRunCurrent"         "Compiles and runs the current file"
76921>>>>>>>  CMDeclareCommand CMD_BuildCompileCurrent        22 "BuildCompile"            "Compiles the current file"
76922>>>>>>>  CMDeclareCommand CMD_BuildPreCompile            23 "BuildPrecompile"         "PreCompiles the current file"
76923>>>>>>>  CMDeclareCommand CMD_BuildExecute               24 "BuildExecute"            "Starts the main program (or current file if it is '.SRC') without compiling"
76924>>>>>>>  CMDeclareCommand CMD_BuildDebugRun              25 "BuildDebugRun"           "ReCompiles with debug info and starts the main program"
76925>>>>>>>  CMDeclareCommand CMD_BuildDebugRunCurrent       26 "BuildDebugRunCurrent"    "ReCompiles with debug info and starts the current program"
76926>>>>>>>
76926>>>>>>>  // Window Menu. 40-49
76926>>>>>>>  CMDeclareCommand CMD_WindowSwitchToCodeView     40 "WindowSwitchToCodeView"   "Activates the codeview window"
76927>>>>>>>  CMDeclareCommand CMD_WindowSwitchToErrorView    41 "WindowSwitchToErrorView"  "Activates the error window"
76928>>>>>>>  CMDeclareCommand CMD_WindowSyncCodeView         42 "WindowSyncCodeView"       "Synchronizes the CodeView with cursorposition"
76929>>>>>>>  CMDeclareCommand CMD_WindowNextView             43 "WindowNextView"           "Activates the next view"
76930>>>>>>>  CMDeclareCommand CMD_WindowPreviousView         44 "WindowPreviousView"       "Activates the privious view"
76931>>>>>>>
76931>>>>>>>  // Lists 50-59
76931>>>>>>>  CMDeclareCommand CMD_ListCreator                50 "ListCreator"              "Activates the Creator list"
76932>>>>>>>  CMDeclareCommand CMD_ListObjects                51 "ListObjects"              "Activates the Object List"
76933>>>>>>>  CMDeclareCommand CMD_ListVars                   52 "ListVariables"            "Activates the Variables List"
76934>>>>>>>  CMDeclareCommand CMD_ListKeys                   53 "ListKeys"                 "Activates the Keys List"
76935>>>>>>>  CMDeclareCommand CMD_ListProcedures             54 "ListProcedures"           "Activates the Procedures List (Overwriting)"
76936>>>>>>>  CMDeclareCommand CMD_ListFunctions              55 "ListFunctions"            "Activates the Functions List (Overwriting)"
76937>>>>>>>  CMDeclareCommand CMD_ListClasses                56 "ListClasses"              "Activates the Classes List"
76938>>>>>>>  CMDeclareCommand CMD_ListIDETags                57 "ListIDETags"              "Activates the List with IDE tags"
76939>>>>>>>
76939>>>>>>>
76939>>>>>>>  // Mixed. 60-69
76939>>>>>>>  CMDeclareCommand CMD_ToggleComment              60 "ToggleComment"              "Toggled the current line comment"
76940>>>>>>>  CMDeclareCommand CMD_ToolsInsertHeaderGlobal    61 "ToolsInsertHeaderGlobal"    "Inserts a header into the current file (global)"
76941>>>>>>>  CMDeclareCommand CMD_ToolsInsertHeaderUser      62 "ToolsInsertHeaderUser"      "Inserts a header into the current file (userspecific)"
76942>>>>>>>  CMDeclareCommand CMD_OpenFileUnderCursor        63 "OpenFileUnderCursor"        "Tries to open the file under the current cursorposition"
76943>>>>>>>  CMDeclareCommand CMD_InsertRevisionMark         64 "InsertRevisionMark"         "Inserts a Revisionmark"
76944>>>>>>>  CMDeclareCommand CMD_InsertColor                65 "InsertColor"                "Inserts a RGB Color value"
76945>>>>>>>
76945>>>>>>>  // Convertion 70-79
76945>>>>>>>  CMDeclareCommand CMD_ConvertOnItemToAddItem   70 "ConvertOnItemToAddItem"       "Converts On_Item block to send Add_Item and back"
76946>>>>>>>  CMDeclareCommand CMD_ConvertCStructToVDF      71 "ConvertCStructToVDF"          "Converts a C structure to VDF syntax"
76947>>>>>>>  CMDeclareCommand CMD_ConvertCDllCallToVDF     72 "ConvertCDllCallToVDF"         "Converts a C Dll call to VDF syntax"
76948>>>>>>>  CMDeclareCommand CMD_ConvertVDFTypeToHandler  73 "ConvertVDFTypeToHandler"      "Converts a VDF TYPE structure to a Handler class"
76949>>>>>>>
76949>>>>>>>  CMDeclareCommand CMD_MarkScopeBlock           74 "MarkScopeBlock"               "Marks the current Scope Begin/End block for the current Line"
76950>>>>>>>
76950>>>>>>>  // v3.0 by SVN
76950>>>>>>>  CMDeclareCommand CMD_MOVELINEUP               75 "MoveLineUp"                   "Moves selected editor's code line up"
76951>>>>>>>  CMDeclareCommand CMD_MOVELINEDOWN             76 "MoveLineDown"                 "Moves selected editor's code line down"
76952>>>>>>>  CMDeclareCommand CMD_DUPLICATESELECTION       77 "DuplicateSelection"           "Duplicates selection or code line"
76953>>>>>>>
76953>>>>>>>  // by WvA
76953>>>>>>>  CMDeclareCommand CMD_DEBUGPERFCOUNTERS        78 "Performance counters"         "Displays some statistics using performance counters (used for debugging purposes)"
76954>>>>>>>  CMDeclareCommand CMD_REFACTORDROPSELF         79 "Refactor Drop Self"           "Refactor option to clean up Self references that are not required in recent code"
76955>>>>>>>  CMDeclareCommand CMD_REFACTOROBJECTNEIGHBORHOOD 80 "Refactor Object Neighborhood" "Refactor option to clean up nested object references that are not required anymore due to object neighborhood logic"
76956>>>>>>>  CMDeclareCommand CMD_REFACTORREINDENT         81 "Refactor Re-Indent"           "Refactor option to remove all existing indentation in the current file and replace it with your preferred indentation settings"
76957>>>>>>>  CMDeclareCommand CMD_GOTOFIRSTINDENTMISMATCH  82 "GoTo First Indent Mismatch"   "Will try to locate the first line that mismatches the current indentation rules."
76958>>>>>>>  CMDeclareCommand CMD_REFACTORMETHODEXTRACT    83 "Method extract"               "Extract the selected lines of code for method extraction"
76959>>>>>>>End_Procedure
76960>>>>>>>
76960>>>>>>>Send RegisterAllInternalCommands
76961>>>>>>>Send RegisterExtraCommands
76962>>>>>>>
76962>>>>>>>// CMGetHotKeys is replaced by function ShortCutKeyDefinitions
76962>>>>>>>Function CMGetHotkeys Global Returns String
76964>>>>>>>  String sHotKeys
76964>>>>>>>
76964>>>>>>>  Get ShortCutKeyDefinitions Of oSciCommandHotKeys To sHotKeys
76965>>>>>>>  Function_Return sHotKeys
76966>>>>>>>End_Function
76967>>>>>>>
76967>>>>>>>Function CMSetHotkeys Global String sHotKeys Returns Integer
76969>>>>>>>  If (sHotKeys="") Begin
76971>>>>>>>    Get DefaultDefinitions Of oSciCommandHotKeys To sHotKeys
76972>>>>>>>  End
76972>>>>>>>>
76972>>>>>>>  Set ShortCutKeyDefinitions Of oSciCommandHotKeys To sHotKeys
76973>>>>>>>  Function_Return 1
76974>>>>>>>End_Function
76975>>>>>>>
76975>>>>>>>// Not used in The Hammer
76975>>>>>>>//Function CMResetDefaultHotKeys global  Returns Integer
76975>>>>>>>//  send DevTest "CMResetDefaultHotKeys"
76975>>>>>>>//  function_return 0
76975>>>>>>>//End_Function
76975>>>>>>>Function CMGetHotKeysForCmd Global Integer wCmd Pointer pHotKeys  Returns Integer
76977>>>>>>>  Send DevTest "CMGetHotKeysForCmd"
76978>>>>>>>  Function_Return 0
76979>>>>>>>End_Function
76980>>>>>>>
76980>>>>>>>//
76980>>>>>>>// Is there a hotkey defined for the following command? If so then return
76980>>>>>>>// the hotkey as a string
76980>>>>>>>//
76980>>>>>>>Function CMCommandToHotKeyStr Integer iCmd Returns String
76982>>>>>>>  String sRet
76982>>>>>>>  tSciCommandHotKey Command
76982>>>>>>>  tSciCommandHotKey Command
76982>>>>>>>
76982>>>>>>>  Move "" To sRet
76983>>>>>>>  Get FindCommand Of oSciCommandHotKeys iCmd To Command
76984>>>>>>>  If (Command.iCmd>-1 and Command.iCmd=iCmd) Begin
76986>>>>>>>    Get CommandHotKeyString Of oSciCommandHotKeys Command To sRet
76987>>>>>>>  End
76987>>>>>>>>
76987>>>>>>>  Move (ToOem(sRet)) to sRet
76988>>>>>>>  Function_Return sRet
76989>>>>>>>End_Function
76990>>>>>>>
76990>>>>>>>// ToDo:
76990>>>>>>>// Gets the keys assigned to a value.
76990>>>>>>>// LOW: Virt key
76990>>>>>>>//  HI: Modifier (Combination of CM_KEY_ALT,CM_KEY_CONTROL,CM_KEY_SHIFT)
76990>>>>>>>Function CMGetKeyForCommand Integer iCmd Integer iNr Returns Integer
76992>>>>>>>  //String  sHotkey
76992>>>>>>>  //Integer iRet iModifier1 iVirtKey1 iKeys
76992>>>>>>>  //Move (CMGetHotKeysForCmd(iCmd,0))   to iKeys                 // Get the Number of hotkeys assigned!
76992>>>>>>>  //If iNr Lt 0 Function_Return iKeys                            // If item lt 0 returns the number of keys.
76992>>>>>>>  //If iKeys Eq 0 Function_Return 0                              // If not keys are assigned break.
76992>>>>>>>  //    // Get the keyvalues...
76992>>>>>>>  //Local_Buffer sHotKeys pHotKeys (CM_HOTKEY_SIZE*iKeys+10)                        // Reserver the necc. amount of memory to get all Hotkeys assigned to the cmd.
76992>>>>>>>  //Move (CMGetHotKeysForCmd(iCmd,pHotKeys))                    to iRet         // Gets the assigned hotkeys.
76992>>>>>>>  //Move (Mid(sHotkeys,CM_HOTKEY_SIZE,(CM_HOTKEY_SIZE*iNr)+1))  to sHotkey      // Get the selected key.
76992>>>>>>>  //Getbuff From sHotKey at CM_HOTKEY.byModifiers1              to iModifier1   // Get the Ext key.
76992>>>>>>>  //Getbuff From sHotKey at CM_HOTKEY.nVirtKey1                 to iVirtKey1    // Get the VK key.
76992>>>>>>>  //Function_Return (MAKEWPARAM(iModifier1,iVirtkey1))
76992>>>>>>>End_Function
76993>>>>>>>
76993>>>>>>>
76993>>>>>>>// The following functions are Not used in the hammer
76993>>>>>>>//Function CMRegisterHotKey global Pointer pHotKey Integer wCmd   Returns Integer
76993>>>>>>>//  send DevTest "CMRegisterHotKey"
76993>>>>>>>//  function_return 0
76993>>>>>>>//End_Function
76993>>>>>>>//Function CMUnregisterHotKey global Pointer pHotKey   Returns Integer
76993>>>>>>>//  send DevTest "CMUnregisterHotKey"
76993>>>>>>>//  function_return 0
76993>>>>>>>//End_Function
76993>>>>>>>//Function CMGetCommandString global Integer wCmd Integer bDescription Pointer pszBuff Integer nBuffLen   Returns Integer
76993>>>>>>>//  send DevTest "CMGetCommandString"
76993>>>>>>>//  function_return 0
76993>>>>>>>//End_Function
76993>>>>>
76993>>>>>
76993>>>>>
76993>>>>>    // Stores all Parameter which should been saved to disk.
76993>>>>>
76993>>>>>    // Added Property piSaveLocal to speed-up the saving of a file on a network drive
76993>>>>>    // 19.02.02 Bernhard
76993>>>>>    // INI_GLOBAL
76993>>>>>Class cEditorProperties Is a cIniProperties
76994>>>>>    INI_Begin_Properties "CODEMAXEDIT.INI" INI_USER
76999>>>>>        INI_Property        String  psFileTypes                 Public ""
77007>>>>>        INI_Property        Integer piLineNumbering             Public False
77015>>>>>        INI_Property        Integer pbLeftMargin                Public False
77023>>>>>        INI_Property        String  psColors                    Public ""
77031>>>>>        INI_Property        String  psReadOnlyColors            Public ""
77039>>>>>        // By WvA 20170417 - Scintilla hot keys
77039>>>>>        INI_Property        String  psEditorHotKeys             Public ""
77047>>>>>        INI_Property        Integer piRecentFilesLimit          Public 0
77055>>>>>        INI_Property        String  psRecentFiles               Public "" MULTI
77075>>>>>        // By SVN 22-03-2017
77075>>>>>        INI_Property        Integer piRecentWSLimit             Public 15
77083>>>>>        INI_Property        String  psRecentWorkspaces          Public "" MULTI
77103>>>>>        INI_Property.Sub    String  sDescription                Public ""
77111>>>>>        INI_Property.Sub    String  sVersion                    Public ""
77119>>>>>        //
77119>>>>>        INI_Property        Integer piViewMode                  Public 0
77127>>>>>        INI_Property        Integer piViewSize.Y                Public 0
77135>>>>>        INI_Property        Integer piViewSize.X                Public 0
77143>>>>>        INI_Property        Integer pbColorSyntax               Public 0
77151>>>>>        INI_Property        String  psLanguage                  Public ""
77159>>>>>        INI_Property        Integer pbScrollBarH                Public 0
77167>>>>>        INI_Property        Integer pbScrollBarV                Public 0
77175>>>>>        INI_Property        Integer pbSplitterH                 Public 0
77183>>>>>        INI_Property        Integer pbSplitterV                 Public 0
77191>>>>>        INI_Property        Integer pbSmoothScrolling           Public 0
77199>>>>>        INI_Property        Integer pbLineToolTips              Public 0
77207>>>>>        INI_Property        Integer pbDragDrop                  Public 0
77215>>>>>        INI_Property        Integer pbColumnSel                 Public 0
77223>>>>>        INI_Property        Integer piUndoLimit                 Public 0
77231>>>>>        INI_Property        Integer piAutoIndentMode            Public 0
77239>>>>>        INI_Property        Integer piTabSize                   Public 0
77247>>>>>        INI_Property        Integer pbTabExpand                 Public 0
77255>>>>>        INI_Property        Integer pbNormalizeCase             Public 0
77263>>>>>        INI_Property        Integer pbCloseOutputPaneOnEscape   Public 0 // close output pane when pressing Escape key
77271>>>>>        INI_Property        Integer pbTrimEOLOnSave             Public 0 // trim line endings on save
77279>>>>>        INI_Property        Integer pbFileSaveBackup            Public True // create a .bak file on save
77287>>>>>        INI_Property        Integer pbOemToAnsi                 Public True // do an OEM to ANSI conversion on load and save
77295>>>>>        INI_Property        Integer pbUtf8Support               Public False // support Utf8 load/save
77303>>>>>        INI_Property        Integer pbMethodSuffixComment       Public False // automatically add a comment behind the method end
77311>>>>>        INI_Property        Integer pbPreserveCase              Public 0
77319>>>>>        INI_Property        Integer pbSelBounds                 Public 0
77327>>>>>        INI_Property        Integer pbWholeWord                 Public 0
77335>>>>>        INI_Property        Integer pbCaseSensitive             Public 0
77343>>>>>        INI_Property        String  psFont                      Public ""
77351>>>>>        INI_Property        String  psLanguages                 Public "" MULTI
77371>>>>>        INI_Property.Sub    Integer dwStyle                     Public 0
77379>>>>>        INI_Property.Sub    Integer bIsCaseSensitive            Public 0
77387>>>>>        INI_Property.Sub    String  szKeywords                  Public ""
77395>>>>>        INI_Property.Sub    String  szOperators                 Public ""
77403>>>>>        INI_Property.Sub    String  szSingleLineComments        Public ""
77411>>>>>        INI_Property.Sub    String  szMultiLineComments1        Public ""
77419>>>>>        INI_Property.Sub    String  szMultiLineComments2        Public ""
77427>>>>>        INI_Property.Sub    String  szScopeKeywords1            Public ""
77435>>>>>        INI_Property.Sub    String  szScopeKeywords2            Public ""
77443>>>>>        INI_Property.Sub    String  szStringDelims              Public ""
77451>>>>>        INI_Property.Sub    String  chEscape                    Public ""
77459>>>>>        INI_Property.Sub    String  chTerminator                Public ""
77467>>>>>        INI_Property.Sub    String  pszTagElementNames          Public ""
77475>>>>>        INI_Property.Sub    String  pszTagAttributeNames        Public ""
77483>>>>>        INI_Property.Sub    String  pszTagEntities              Public ""
77491>>>>>        INI_Property        String  psFontStyles                Public ""
77499>>>>>        INI_Property        Integer piUseWorkSpace              Public 0
77507>>>>>        INI_Property        Integer pbCompileAutoSave           Public 0
77515>>>>>        INI_Property        String  psCompiler                  Public ""
77523>>>>>        INI_Property        String  psCompiler.CompOptions      Public ""
77531>>>>>        INI_Property        String  psCompiler.PreCompOptions   Public ""
77539>>>>>        INI_Property        String  psDebugger                  Public ""
77547>>>>>        INI_Property        Integer piCompiler4Debug            Public ""
77555>>>>>        INI_Property        String  psDebugCompiler             Public ""
77563>>>>>        INI_Property        Integer piCompileShowErrorMsg       Public 0
77571>>>>>        INI_Property        String  psStartUpPath               Public ""
77579>>>>>        INI_Property        Integer piSaveLocal                 Public False
77587>>>>>        INI_Property        Integer piErrorListHeight           Public 0
77595>>>>>        INI_Property        Integer pbErrorListVisible          Public 0
77603>>>>>        INI_Property        Integer piCodeViewWidth             Public 0
77611>>>>>        INI_Property        Integer pbCodeViewVisible           Public 0
77619>>>>>        INI_Property        String  psVDFRegistryVersion        Public ""
77627>>>>>        // SVN 21-03-2017
77627>>>>>        INI_Property        Integer pbToolsPaneVisible          Public True
77635>>>>>        INI_Property        Integer pbOutputPaneVisible         Public False
77643>>>>>        //
77643>>>>>        // ** SVN 07/04-2017 -- TH3 New Tokens INI file
77643>>>>>        INI_Property        String  psTokensIniFile             Public "tokens.ini"
77651>>>>>        INI_Property        String  psCodeTipIniFile            Public ""
77659>>>>>        INI_Property        Integer pbUseCodeTips               Public True
77667>>>>>        INI_Property        Integer pbCodeTipAutoPopup          Public True
77675>>>>>        INI_Property        String  pbCodeListUseBitmaps        Public True
77683>>>>>        INI_Property        Integer pbShowClasses               Public True
77691>>>>>        INI_Property        Integer pbShowObjects               Public True
77699>>>>>        INI_Property        Integer pbShowMethods               Public True
77707>>>>>        INI_Property        Integer pbShowKeys                  Public True
77715>>>>>        INI_Property        Integer pbShowFields                Public True
77723>>>>>        INI_Property        Integer pbShowIndexes               Public True
77731>>>>>        INI_Property        Integer pbShowVariables             Public True
77739>>>>>        INI_Property        Integer pbShowIDETags               Public True
77747>>>>>        // ** SVN 07/04-2017 -- TH3 New CodeLists Auto Popup
77747>>>>>        INI_Property        Integer pbShowStructures            Public True
77755>>>>>        INI_Property        Integer pbShowCommands              Public True
77763>>>>>        INI_Property        Integer pbShowTypes                 Public True
77771>>>>>        INI_Property        Integer pbShowAttributes            Public True
77779>>>>>        INI_Property        Integer pbShowSourceFiles           Public True
77787>>>>>        INI_Property        String  psIDEPath                   Public ""
77795>>>>>        INI_Property        String  psDBBPath                   Public ""
77803>>>>>        INI_Property        String  psDBEPath                   Public ""
77811>>>>>        INI_Property        String  psMergePath                 Public ""
77819>>>>>        INI_Property        String  psVCSPath                   Public ""
77827>>>>>        INI_Property        String  psRptPath                   Public ""
77835>>>>>        INI_Property        String  psDbcPath                   Public ""
77843>>>>>        INI_Property        String  psDbuPath                   Public ""
77851>>>>>        INI_Property        String  psCodeArtPath               Public ""
77859>>>>>        INI_Property        String  psCodeSpyPath               Public ""
77867>>>>>        INI_Property        String  psCodePubPath               Public ""
77875>>>>>        INI_Property        String  psMenuPath                  Public ""
77883>>>>>        // ** SVN -- CodeArt
77883>>>>>        INI_Property        Integer pbCodeArtInsertErrors       Public False
77891>>>>>        INI_Property        Integer pbCodeArtInsertDateTime     Public False
77899>>>>>        INI_Property        Integer pbCodeArtInsertComments     Public True
77907>>>>>        // ** SVN -- CodePub
77907>>>>>        INI_Property        String  psCodePubHeaderFile         Public ""
77915>>>>>        INI_Property        String  psCodePubFooterFile         Public ""
77923>>>>>        //
77923>>>>>        //
77923>>>>>        INI_Property        String  psDfrun                     Public ""
77931>>>>>        INI_Property        String  psLangAssign                Public "" MULTI
77951>>>>>        INI_Property.Sub    String  Ext                         Public ""
77959>>>>>        INI_Property.Sub    String  Language                    Public ""
77967>>>>>
77967>>>>>        // BP -- Character translation
77967>>>>>        INI_Property        String  psCharTranslation           Public ""
77975>>>>>
77975>>>>>        // BP -- Watch Compiler Messages during Compile
77975>>>>>        INI_Property        Integer piWatchCompiler             Public 0
77983>>>>>        INI_Property        Integer piDisplayWatchAutomatic     Public 0
77991>>>>>        INI_Property        Integer piDebugAlways               Public 0
77999>>>>>        // By SVN -- 14-04-2017 Window
77999>>>>>        // By SVN -- 14-04-2017 Skinning
77999>>>>>        INI_Property        Integer piUseSkins                  Public 0
78007>>>>>        INI_Property        String  psCurrentSkinFile           Public ""
78015>>>>>        INI_Property        String  psCurrentSkinIni            Public ""
78023>>>>>        // Tabs
78023>>>>>        INI_Property        String  psFileTabsLocation          Public "Bottom"
78031>>>>>        INI_Property        String  psFileTabsAppearance        Public ""
78039>>>>>        INI_Property        String  psFileTabsColor             Public ""
78047>>>>>        INI_Property        Integer pbFileTabsMultiRow          Public False
78055>>>>>        // Color Schemas (By SVN)
78055>>>>>        INI_Property        String  psColorSchema               Public ""
78063>>>>>        INI_Property        String  psColorSchemas              Public "" MULTI
78083>>>>>        INI_Property.Sub    Integer psSchemaColors              Public ""
78091>>>>>        INI_Property.Sub    Integer psSchemaFontStyles          Public ""
78099>>>>>        INI_Property        String  psFontFace                  Public ""
78107>>>>>        // Custom Utility (By SVN on 27-04-2017)
78107>>>>>        INI_Property        String  psCustomMenuUtilities       Public "" MULTI // Code Maintenance...
78127>>>>>        INI_Property.Sub    Integer psUtilityType               Public "" // DATABASE, SOURCE, TOOLS
78135>>>>>        INI_Property.Sub    Integer psUtilityOrder              Public "" // 0, 1, 2, ...
78143>>>>>        INI_Property.Sub    Integer psUtilityCommand            Public "" // C:\...\Bin\... .exe %1 etc
78151>>>>>        //
78151>>>>>        INI_Property        String  psSignAppPath               Public ""
78159>>>>>        INI_Property        Integer pbExtCompilerOnly           Public 0
78167>>>>>        INI_Property        Integer pbShowMatchingBraces        Public True
78175>>>>>        INI_Property        Integer pbShowIndentGuides          Public True
78183>>>>>        INI_Property        Integer pbSelectWholeLine           Public True
78191>>>>>        INI_Property        String  psLastEditedFile            Public ""
78199>>>>>        // Interface Language
78199>>>>>        INI_Property        String  psInterfaceLanguage         Public ""
78207>>>>>        //
78207>>>>>    INI_End_Properties
78332>>>>>
78332>>>>>        // Delivers the language for
78332>>>>>    Function LanguageForFile String sFile Returns String
78334>>>>>        Integer iCount iItem
78334>>>>>        String  sExt sLangExt sLang
78334>>>>>
78334>>>>>        Move (CString(sFile)) To sFile // Not sure if we need to do this?
78335>>>>>        Get ParseFileExtension sFile To sExt
78336>>>>>        Get psLangAssign.Count  To iCount
78337>>>>>        For iItem From 0 To (iCount-1)
78343>>>>>>
78343>>>>>            Get psLangAssign.Ext item iItem    To sLangExt
78344>>>>>            Move (CString(sLangExt))           To sLangExt
78345>>>>>            Move (Replaces("*",sLangExt,""))   To sLangExt // If user enters "*.html" in language detection than it will never match the actual file extension
78346>>>>>            Move (Replaces(".",sLangExt,""))   To sLangExt // same for .html
78347>>>>>            Move (Trim(Uppercase(sExt)))       To sExt
78348>>>>>            Move (Trim(Uppercase(sLangExt)))   To sLangExt
78349>>>>>            If (sExt = sLangExt) Begin
78351>>>>>                Get psLangAssign.Language Item iItem    To sLang
78352>>>>>                Function_Return sLang
78353>>>>>            End
78353>>>>>>
78353>>>>>        End
78354>>>>>>
78354>>>>>        Function_Return (psLanguage(Self))
78355>>>>>    End_Function
78356>>>>>
78356>>>>>
78356>>>>>    // Adds a Entry to the RecentFiles List, previous it tests
78356>>>>>    // if the same file is already in the list and removes it.
78356>>>>>    // By SVN on 22-03-2017
78356>>>>>    Procedure AddRecentWorkspace String sWorkspace String sName String sVersion
78358>>>>>        Integer iCount iC iLimit
78358>>>>>        Move (Trim(sWorkspace))                 to sWorkspace
78359>>>>>        Move (psRecentWorkspaces.Count(Self))   to iCount
78360>>>>>        For iC from 0 to (iCount-1)
78366>>>>>>
78366>>>>>            If (Uppercase(psRecentWorkspaces(Self,iC)) = Uppercase(sWorkspace)) Begin
78368>>>>>                Send psRecentWorkspaces.DeleteItem iC
78369>>>>>                Move iCount to iC
78370>>>>>            End
78370>>>>>>
78370>>>>>        End
78371>>>>>>
78371>>>>>        Move (psRecentWorkspaces.Count(Self))           to iCount
78372>>>>>        Set psRecentWorkspaces              item iCount to sWorkspace
78373>>>>>        Set psRecentWorkspaces.sDescription item iCount to sName
78374>>>>>        Set psRecentWorkspaces.sVersion     item iCount to sVersion
78375>>>>>
78375>>>>>        // Limit to the max RecentFileList length
78375>>>>>        Move (psRecentWorkspaces.Count(Self))    to iCount
78376>>>>>        Move (piRecentWSLimit(Self))     to iLimit
78377>>>>>        For iC from 0 to (iCount-1-iLimit)
78383>>>>>>
78383>>>>>            Send psRecentWorkspaces.DeleteItem iC
78384>>>>>        End
78385>>>>>>
78385>>>>>    End_Procedure
78386>>>>>
78386>>>>>    // Adds a Entry to the RecentFiles List, previous it tests
78386>>>>>    // if the same file is already in the list and removes it.
78386>>>>>    Procedure AddRecentFile String sFile
78388>>>>>        Integer iCount iC iLimit
78388>>>>>        Move (Trim(sFile))                  to sFile
78389>>>>>        Move (psRecentFiles.Count(Self))    to iCount
78390>>>>>        For iC from 0 to (iCount-1)
78396>>>>>>
78396>>>>>            If (Uppercase(psRecentFiles(Self,iC))) Eq (Uppercase(sFile)) Begin
78398>>>>>                Send psRecentFiles.DeleteItem iC
78399>>>>>                Move iCount to iC
78400>>>>>            End
78400>>>>>>
78400>>>>>        End
78401>>>>>>
78401>>>>>        Move (psRecentFiles.Count(Self))    to iCount
78402>>>>>        Set psRecentFiles item iCount       to sFile
78403>>>>>
78403>>>>>        // Limit to the max RecentFileList length
78403>>>>>        Move (psRecentFiles.Count(Self))    to iCount
78404>>>>>        Move (piRecentFilesLimit(Self))     to iLimit
78405>>>>>        For iC from 0 to (iCount-1-iLimit)
78411>>>>>>
78411>>>>>            Send psRecentFiles.DeleteItem iC
78412>>>>>        Loop
78413>>>>>>
78413>>>>>    End_Procedure
78414>>>>>
78414>>>>>        // Finds a language by Name...
78414>>>>>    Function FindLanguage String sName Returns Integer
78416>>>>>        Integer iC iCount
78416>>>>>        String  sStr
78416>>>>>        Move (Trim(sName))          to sName
78417>>>>>        Get psLanguages.Count       to iCount
78418>>>>>        For iC from 0 to (iCount-1)
78424>>>>>>
78424>>>>>            Get psLanguages item iC  to sStr
78425>>>>>            If (sStr = sName) Begin
78427>>>>>                Function_Return iC
78428>>>>>            End
78428>>>>>>
78428>>>>>        End
78429>>>>>>
78429>>>>>        Function_Return -1
78430>>>>>    End_Function
78431>>>>>
78431>>>>>    Procedure DeleteLanguage String sName
78433>>>>>        Integer iCount iC
78433>>>>>        Move (Uppercase(Trim(sName)))       to sName
78434>>>>>        Move (psLanguages.Count(Self))   to iCount
78435>>>>>        For iC from 0 to (iCount-1)
78441>>>>>>
78441>>>>>            If (Uppercase(psLanguages(Self,iC))=sName) Begin
78443>>>>>                Send psLanguages.DeleteItem iC
78444>>>>>                Move iCount to iC
78445>>>>>            End
78445>>>>>>
78445>>>>>        Loop
78446>>>>>>
78446>>>>>    End_Procedure
78447>>>>>
78447>>>>>    // Finds a color schema by Name...
78447>>>>>    Function FindColorSchema String sName Returns Integer
78449>>>>>        Integer iC iCount
78449>>>>>        String  sStr
78449>>>>>        Move (Trim(sName))          to sName
78450>>>>>        Get psColorSchemas.Count       to iCount
78451>>>>>        For iC from 0 to (iCount-1)
78457>>>>>>
78457>>>>>            Get psColorSchemas item iC  to sStr
78458>>>>>            If (sStr = sName) Begin
78460>>>>>                Function_Return iC
78461>>>>>            End
78461>>>>>>
78461>>>>>        Loop
78462>>>>>>
78462>>>>>        Function_Return -1
78463>>>>>    End_Function
78464>>>>>
78464>>>>>    Procedure DeleteColorSchema String sName
78466>>>>>        Integer iCount iC
78466>>>>>        Move (Uppercase(Trim(sName)))       to sName
78467>>>>>        Move (psColorSchemas.Count(Self))   to iCount
78468>>>>>        For iC from 0 to (iCount-1)
78474>>>>>>
78474>>>>>            If (Uppercase(psColorSchemas(Self,iC))=sName) Begin
78476>>>>>                Send psColorSchemas.DeleteItem iC
78477>>>>>                Move iCount to iC
78478>>>>>            End
78478>>>>>>
78478>>>>>        Loop
78479>>>>>>
78479>>>>>    End_Procedure
78480>>>>>
78480>>>>>        // Registers the language with the given item nr.
78480>>>>>        // (for Highlighting)
78480>>>>>    Procedure RegisterLanguage Integer iC
78482>>>>>      // codemax only!
78482>>>>>    End_Procedure
78483>>>>>        // Does a RegisterLanguage for every language.
78483>>>>>        // (so all Languages are registerd <g>)
78483>>>>>    Procedure RegisterAllLanguages
78485>>>>>        Integer iC iCount
78485>>>>>        Get psLanguages.Count To iCount
78486>>>>>        For iC From 0 To (iCount-1)
78492>>>>>>
78492>>>>>            Send RegisterLanguage iC
78493>>>>>        End
78494>>>>>>
78494>>>>>    End_Procedure
78495>>>>>
78495>>>>>        // Overwritten to
78495>>>>>    Procedure LoadIni
78497>>>>>        Integer iRet
78497>>>>>        String  sStartupPath
78497>>>>>        Forward Send LoadIni
78499>>>>>
78499>>>>>        Get CMSetHotkeys (psEditorHotKeys(Self))  To iRet       // Sets the Hotkeys.
78500>>>>>        Send RegisterAllLanguages                               // Registers all Languages for Highlighting
78501>>>>>        // **WvA: 05-03-03, Changed to eliminate a "RAW file Error"
78501>>>>>        Get psStartUpPath To sStartUpPath
78502>>>>>
78502>>>>>        If sStartUpPath Ne "" Begin
78504>>>>>          Send DoChangeCurrentFolder sStartUpPath
78505>>>>>        End
78505>>>>>>
78505>>>>>
78505>>>>>        Send Editor_LoadAllMacros gsUserName
78506>>>>>    End_Procedure
78507>>>>>
78507>>>>>    Procedure SaveIni
78509>>>>>        Forward Send SaveIni
78511>>>>>        Send Editor_SaveAllMacros gsUserName
78512>>>>>    End_Procedure
78513>>>>>End_Class
78514>>>>>
78514>>>>>// This method will change the current windowsfolder for a given directory
78514>>>>>//
78514>>>>>// Just blindly checking the current folder using the Set_Directory command
78514>>>>>// evokes a cryptic "RAW-file error"
78514>>>>>//
78514>>>>>Procedure DoChangeCurrentFolder Global String sFolder
78516>>>>>  String sMessage
78516>>>>>  String sHome
78516>>>>>  If (vFolderExists(sFolder)) Begin
78518>>>>>    Set_Directory sFolder       // Sets the current workfolder
78519>>>>>  End
78519>>>>>>
78519>>>>>  Else Begin
78520>>>>>    Get psHome of (phoWorkspace(ghoApplication)) to sHome
78521>>>>>    If (sFolder<>"<undefined>") Begin // don't tell anything on first startup, just change the startup folder
78523>>>>>      // Cannot have a translation here as this is before the array gets populated, so you'll get error 4509.
78523>>>>>      //#IFDEF TH_TRANSLATION
78523>>>>>      //Move gILanguage[1592] to sMessage
78523>>>>>      //#ELSE
78523>>>>>      Move ("The program tried to set the following folder as your current directory.\n\n") to sMessage
78524>>>>>      Move (sMessage+"Folder: '%1'\n\n") to sMessage
78525>>>>>      Move (sMessage+"This folder does not appear to exist on your system.\n\n") to sMessage
78526>>>>>      Move (sMessage+"Changing current directory to '%2' instead.") to sMessage
78527>>>>>      //#ENDIF
78527>>>>>      Move (Replace("%1", sMessage, sFolder)) to sMessage
78528>>>>>      Move (Replace("%2", sMessage, sHome))   to sMessage
78529>>>>>      Send Info_Box sMessage (_T("Problem", 1593))
78530>>>>>    End
78530>>>>>>
78530>>>>>    Set_Directory sHome
78531>>>>>  End
78531>>>>>>
78531>>>>>End_Procedure
78532>>>Object oEditorProperties Is a cEditorProperties
78534>>>    Move Self to ghoEditorProperties
78535>>>    Set piLoadSaveMode to Ini_Global
78536>>>    Set psSourceFile to "ScintillaEdit.ini"
78537>>>End_Object
78538>>>
78538>>>Send LoadIni to ghoEditorProperties      // Loads the IniDate
78539>>>//Send Register_Color_Elements //of ghoEditorProperties
78539>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
78539>>>Use cCJStandardMenuItemClasses.pkg
78539>>>
78539>>>Object oEditContextMenu is a cCJContextMenu
78541>>>    
78541>>>    Move Self to Default_Form_Floating_Menu_ID
78542>>>    
78542>>>    Object oUndoMenuItem is a cCJUndoMenuItem
78544>>>    End_Object
78545>>>    
78545>>>    Object oCutMenuItem is a cCJCutMenuItem
78547>>>        Set pbControlBeginGroup to True
78548>>>    End_Object
78549>>>    
78549>>>    Object oCopyMenuItem is a cCJCopyMenuItem
78551>>>    End_Object
78552>>>
78552>>>    Object oPasteMenuItem is a cCJPasteMenuItem
78554>>>    End_Object
78555>>>
78555>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
78557>>>    End_Object
78558>>>
78558>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
78560>>>        Set pbControlBeginGroup to True
78561>>>    End_Object
78562>>>
78562>>>End_Object
78563>>>
78563>Use oDEOEditContextMenu.pkg
Including file: oDEOEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu.pkg)
78563>>>Use Windows.pkg
78563>>>Use cCJStandardMenuItemClasses.pkg
78563>>>Use cCJDeoMenuItemClasses.pkg
78563>>>
78563>>>
78563>>>Object oDEOEditContextMenu is a cCJContextMenu
78565>>>    
78565>>>    Move Self to Default_dbFloating_Menu_ID
78566>>>    
78566>>>    Object oUndoMenuItem is a cCJUndoMenuItem
78568>>>    End_Object
78569>>>    
78569>>>    Object oCutMenuItem is a cCJCutMenuItem
78571>>>        Set pbControlBeginGroup to True
78572>>>    End_Object
78573>>>    
78573>>>    Object oCopyMenuItem is a cCJCopyMenuItem
78575>>>    End_Object
78576>>>
78576>>>    Object oPasteMenuItem is a cCJPasteMenuItem
78578>>>    End_Object
78579>>>
78579>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
78581>>>    End_Object
78582>>>
78582>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
78584>>>        Set pbControlBeginGroup to True
78585>>>    End_Object
78586>>>
78586>>>    Object oPromptMenuItem is a cCJPromptMenuItem
78588>>>        Set pbControlBeginGroup to True
78589>>>    End_Object
78590>>>
78590>>>    Object oFindNextMenu is a cCJFindNextMenuItem
78592>>>        Set pbControlBeginGroup to True
78593>>>    End_Object
78594>>>
78594>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
78596>>>    End_Object
78597>>>
78597>>>    Object oClearMenuItem is a cCJClearMenuItem
78599>>>        Set pbControlBeginGroup to True
78600>>>    End_Object
78601>>>
78601>>>    Object oClearAllMenu is a cCJClearAllMenuItem
78603>>>    End_Object
78604>>>
78604>>>    Object oSaveMenu is a cCJSaveMenuItem
78606>>>    End_Object
78607>>>    
78607>>>    Object oDeleteMenu is a cCJDeleteMenuItem
78609>>>    End_Object
78610>>>
78610>>>
78610>>>End_Object
78611>Use cSCTabWorkspace.pkg
Including file: cSCTabWorkspace.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cSCTabWorkspace.pkg)
78611>>>Use cApplication.pkg
78611>>>Use cCJCommandBars.pkg
78611>>>
78611>>>Define CS_CurrentSourceFileToolTipStart  For "Current Source File:"
78611>>>Register_Function psCurrentSourceFileName Returns String
78611>>>
78611>>>Class cSCTabWorkspace is a cCJTabWorkspace
78612>>>
78612>>>    Procedure Construct_Object
78614>>>        Forward Send Construct_Object
78616>>>
78616>>>    End_Procedure
78617>>>
78617>>>    Procedure End_Construct_Object
78619>>>        Forward Send End_Construct_Object
78621>>>
78621>>>    End_Procedure
78622>>>
78622>>>    Procedure OnComSelectedChanged Variant llItem
78624>>>        Handle hoTab
78624>>>        String sSourceFileName
78624>>>
78624>>>        Get Create (RefClass(cCJTabControlItem)) to hoTab
78625>>>        If (hoTab) Begin
78627>>>            Set pvComObject of hoTab to llItem
78628>>>
78628>>>            If (ghoApplication <> 0) Begin
78630>>>                Get psCurrentSourceFileName of ghoApplication to sSourceFileName
78631>>>                If (sSourceFileName <> "") Begin
78633>>>                    Move (CS_CurrentSourceFileToolTipStart * sSourceFileName) to sSourceFileName
78634>>>                End
78634>>>>
78634>>>
78634>>>                Set ComToolTip of hoTab to sSourceFileName
78635>>>                Send Destroy of hoTab
78636>>>            End
78636>>>>
78636>>>        End
78636>>>>
78636>>>    End_Procedure
78637>>>End_Class
78638>//Use CaptureWindow.pkg
78638>
78638>
78638>Object oMain is a Panel
78640>    Set Label to (psProduct(ghoApplication))
78641>    Set Size to 310 550
78642>    Set piMinSize to 294 550
78643>
78643>    Object oCJCommandBarSystem is a cCJCommandBarSystem
78645>        Set pbTimerUpdate to True
78646>        Set piLayoutBuild to 8
78647>        Set pbToolBarAccelTips to True
78648>        Set pbAutoResizeIcons  to True
78649>        Set pbTabbedWorkspaces to True
78650>        Set pbLargeIcons to True
78651>
78651>        Property Handle phoTabWorkspace
78653>        Property Handle phoTabPaintManager
78655>
78655>        Procedure OnCreateCommandBars
78658>            Integer eTheme
78658>            Forward Send OnCreateCommandBars
78660>
78660>            Send DoChangeToolTipFormat
78661>
78661>            Get ReadDword of ghoApplication CS_Settings CS_ThemeKeyWord xtpThemeOffice2013Publisher to eTheme
78662>            Send SetTheTheme eTheme
78663>        End_Procedure
78664>
78664>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
78667>            Set phoTabWorkspace     to hoTabWorkspace
78668>            Set phoTabPaintManager  to hoTabPaintManager
78669>            Send DisplayTabWorkspace
78670>        End_Procedure
78671>
78671>        Procedure DisplayTabWorkspace
78674>            Variant vTab vPaintManager
78674>            Handle hoTab hoPaintManager hoOptions
78674>            Integer iSize
78674>
78674>            If (not(IsComObjectCreated(Self))) Begin
78676>                Procedure_Return
78677>            End
78677>
78677>            Get OptionsObject to hoOptions
78678>
78678>            // Create the tab workspace object. It will get created for the Client_Area so
78678>            // each view will be displayd on a separate tab-page (instead of the standard DF MDI-interface)
78678>            Get phoTabWorkspace    to hoTab
78679>            Get phoTabPaintManager to hoPaintManager
78680>
78680>            // Don't show the tab-pages "close" and next/prev buttons.
78680>            Set ComFlags of hoTab to xtpWorkspaceHideAll
78681>
78681>            Move 16 to iSize
78682>            Send ComSetIconSize of hoPaintManager iSize iSize   // Set icon size for Tab-workspace.
78683>            Send ComSetPopupIconSize of hoOptions 24 24
78684>            // To show or not to show tab-page icons...
78684>            Set ComShowIcons    of hoPaintManager to True
78685>
78685>            // Sets the tab-pages to display on the left side, instead of at the top:
78685>            Set ComPosition     of hoPaintManager to xtpTabPositionLeft
78686>
78686>            // This will truncate the middle part of long items
78686>            //Set ComDrawTextPathEllipsis of hoPaintManager to True
78686>
78686>            Get piToolbarIconSize of ghoApplication to iSize
78687>            Set piToolbarIconSize to iSize
78688>            Set ComToolTipBehaviour of hoPaintManager to xtpTabToolTipAlways // We _must_ have this for tooltips to show on tab-pages (views)
78689>
78689>            // Send Destroy of hoTab // Nope, we can't destroy this - else the tab-page settings won't work.
78689>            //#IF (!@ < 190)
78689>            //            Send Destroy of hoPaintManager
78689>            //#ENDIF
78689>        End_Procedure
78690>
78690>        Procedure DoChangeToolTipFormat
78693>            Variant vToolTip
78693>            Handle  hoObject
78693>            Integer eTheme iToolTipStyle
78693>            Boolean bIsBalloonStyleSupported
78693>
78693>            Get ComToolTipContext to vTooltip
78694>            Get Create (RefClass(cCJToolTipContext)) to hoObject
78695>            Set pvComObject of hoObject to vTooltip
78696>            Move xtpToolTipStandard to iToolTipStyle
78697>            
78697>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
78697>            // The ComShowTitleAndDescription also requires IE 5.0.
78697>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
78698>            If (bIsBalloonStyleSupported = False) Begin
78700>                // If not supported we cannot show baloon tooltip; use standard style instead.
78700>                If (iToolTipStyle = xtpToolTipBalloon) Begin
78702>                    Move xtpToolTipStandard to iToolTipStyle
78703>                End
78703>            End
78703>            If (bIsBalloonStyleSupported = True) Begin
78705>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
78706>            End
78706>            
78706>            Set ComStyle            of hoObject to iToolTipStyle
78707>            Set ComShowOfficeBorder of hoObject to True
78708>            Set ComShowShadow       of hoObject to True
78709>            // Set the max width for a tooltip. 250 just seems to be a good
78709>            // compromise. After 250 pixels the text will wrap to the next line automatically.
78709>            Set  ComMaxTipWidth     of hoObject to 250 // In pixels
78710>            Send Destroy            of hoObject
78711>            
78711>            If (phoStatusBar(ghoCommandBars)) Begin
78713>                Send DoChangeToolTipFormat of (phoStatusBar(Self))
78714>            End
78714>        End_Procedure
78715>
78715>        Procedure Set piToolbarIconSize Integer iSize
78718>            Handle hoOptions
78718>
78718>            If (not(IsComObjectCreated(Self))) Begin
78720>                Procedure_Return
78721>            End
78721>
78721>            Get OptionsObject to hoOptions
78722>            Send ComSetIconSize of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
78723>            Send ComRecalcLayout
78724>        End_Procedure
78725>
78725>        Procedure SetTheTheme Integer eTheme
78728>//            Integer iColor
78728>            Set peVisualTheme to eTheme
78729>            // If the color is changed it messes with the grid alternate background color.
78729>//            Get ComGetSpecialColor XPCOLOR_TOOLBAR_FACE to iColor    
78729>//            Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
78729>//            Send ComRecalcLayout of ghoCommandBars
78729>        End_Procedure
78730>
78730>        Object oWorkspace_Toolbar is a cCJToolbar
78732>            Set pbDockNextTo to False
78733>            Set peStretched to stStretchShared
78734>            Set pbCloseable to False
78735>            Set pbCustomizable to False
78736>
78736>            Object oWorkspaceSelectorText_Menuitem is a cCJMenuItem
78738>                Set psCaption to CS_SelectWorkspaceText
78739>                Set psToolTip to "Select Workspace"
78740>                Set psDescription to "Select a Workspace .sws File"
78741>                Set psImage to "ActionOpenWorkspace.ico"
78742>                Set peControlType to xtpControlCustom
78743>                Set peControlStyle to xtpButtonIconAndCaption
78744>                Procedure OnExecute Variant vCommandBarControl
78747>                    Send Execute of (oWorkspaceOpen_Menuitem(ghoCommandBars))
78748>                End_Procedure
78749>            End_Object
78750>                           
78750>            Object oWorkspaceSelector_Menuitem is a cCJMenuItem
78752>                Set psToolTip to "Recent Workspacess"
78753>                Set psImage to "ActionOpenWorkspace.ico"
78754>                Set peControlType to xtpControlComboBox 
78755>                
78755>                Property Handle[] phoMenuItems
78757>                Property tWorkspace[] pWorkspaces
78759>
78759>                // Event for when an item is selected from the comboform
78759>                Procedure OnExecute Variant vCommandBarControl
78762>                    Handle hoCombo
78762>                    Integer iSelection iSize
78762>                    tWorkspace[] Workspaces  
78762>                    tWorkspace[] Workspaces  
78763>                    String sWorkspace sWorkspaceShort
78763>            
78763>                    // Create and bind proxy control
78763>                    Get CreateProxyControl vCommandBarControl to hoCombo  
78764>                    // Get the current selection
78764>                    Get ComListIndex of hoCombo to iSelection
78765>                    Decrement iSelection 
78766>                    If (iSelection = 0) Begin
78768>                        Send Execute of (oResetWorkspace_MenuItem(ghoCommandBars))
78769>                        Procedure_Return
78770>                    End
78770>                    
78770>                    Get pWorkspaces to Workspaces
78771>                    Move Workspaces[iSelection].sWorkspaceFull to sWorkspace
78772>                    If (sWorkspace <> CS_NoWorkspaceSelected) Begin
78774>                        Send UpdateWorkspaceSelectorDisplay of ghoApplication sWorkspace
78775>                        Set psToolTip     to CS_CurrentWorkspaceText
78776>                        Set psDescription to sWorkspace   
78777>                        Set psCaption     of (oWorkspaceSelectorText_Menuitem(ghoCommandBars)) to CS_CurrentWorkspaceText
78778>                        Set psDescription of (oWorkspaceSelectorText_Menuitem(ghoCommandBars)) to sWorkspace
78779>                        Move Workspaces[iSelection].sWorkspace to sWorkspaceShort  
78780>                        Get ComListCount of hoCombo to iSelection 
78781>                        Increment iSelection
78782>                        Send ComAddItem  of hoCombo sWorkspaceShort iSelection
78783>                        Set ComListIndex of hoCombo to iSelection
78784>                    End                             
78784>
78784>                    // Dispose of the proxy control
78784>                    Send Destroy of hoCombo
78785>                End_Procedure
78786>
78786>                Procedure OnCreateControl Handle hoCombo
78789>                    Forward Send OnCreateControl hoCombo
78791>            
78791>                    Send ComAddItem of hoCombo CS_NoWorkspaceSelected 1
78792>                    Set ComListIndex of hoCombo to 1
78793>                End_Procedure   
78794>                
78794>                Procedure FillComboList Handle hoCombo
78797>                    Integer iCount iSize iLength iCurrent iTxtEntentSize iLengthShort iTxtEntentSizeShort
78797>                    String[] asWorkspaces
78798>                    tWorkspace[] Workspaces
78798>                    tWorkspace[] Workspaces
78799>                    String sWorkspace
78799>
78799>                    Get ReadWorkspaceKeysFromRegistry of ghoApplication to asWorkspaces  
78800>                    Move (InsertInArray(asWorkspaces, 0, CS_NoWorkspaceSelected)) to asWorkspaces
78801>                    Move (SizeOfArray(asWorkspaces)) to iSize
78802>                    Decrement iSize
78803>                    Send ComClear of hoCombo
78804>            
78804>                    for iCount from 0 to iSize
78810>                        Move asWorkspaces[iCount] to sWorkspace  
78811>                        Move sWorkspace to Workspaces[iCount].sWorkspaceFull
78812>                        Get ParseFileName sWorkspace to sWorkspace
78813>                        Move sWorkspace to Workspaces[iCount].sWorkspace
78814>                        Send ComAddItem of hoCombo Workspaces[iCount].sWorkspaceFull (iCount + 1)
78815>                        Get Text_Extent Workspaces[iCount].sWorkspaceFull to iLength
78816>                        If (iLength > iTxtEntentSize) Begin
78818>                            Move iLength to iTxtEntentSize
78819>                        End
78819>                        Get Text_Extent Workspaces[iCount].sWorkspace to iLengthShort
78820>                        If (iLengthShort > iTxtEntentSizeShort) Begin
78822>                            Move iLengthShort to iTxtEntentSizeShort
78823>                        End
78823>                    Loop
78824>                    
78824>                    Set pWorkspaces to Workspaces
78825>                    Move (Low(iTxtEntentSize) + 40) to iSize
78826>                    Set ComDropDownWidth of hoCombo to iSize  
78827>                    Set ComWidth         of hoCombo to (Low(iTxtEntentSizeShort) + 40)  
78828>                    Set ComListIndex     of hoCombo to 1
78829>                End_Procedure
78830>
78830>                Procedure DisplayWorkspaceItem String sWorkspace
78833>                    Handle hoCombo
78833>                    tWorkspace[] Workspaces   
78833>                    tWorkspace[] Workspaces   
78834>                    String sWorkspaceShort
78834>                    Integer iCount iSize iSelection
78834>                    Boolean bFound
78834>
78834>                    // Create and bind proxy control 
78834>                    If (IsComObjectCreated(Self)) Begin
78836>                        Get CreateFirstProxyControl to hoCombo   
78837>                        // Start by filling the combo with previously saved workspaces (if any),
78837>                        // in case the combo hasn't been activated before and a new workspace
78837>                        // is opened.    
78837>                        If (hoCombo > 0) Begin
78839>                            Send FillComboList hoCombo
78840>                            
78840>                            Get pWorkspaces to Workspaces  
78841>                            Move (SizeOfArray(Workspaces)) to iSize
78842>                            Decrement iSize    
78843>                            Move 0 to iSelection  
78844>                            Move "" to sWorkspaceShort
78845>                            
78845>                            for iCount from 0 to iSize
78851>                                Move (Lowercase(sWorkspace) = Lowercase(Workspaces[iCount].sWorkspace)   or ;                                Lowercase(sWorkspace) = Lowercase(Workspaces[iCount].sWorkspaceFull)) ;                                to bFound
78852>                                If (bFound = True) Begin
78854>                                    Move Workspaces[iCount].sWorkspace to sWorkspaceShort
78855>                                    Move iCount to iSelection 
78856>                                    Move iSize to iCount // We're done
78857>                                End
78857>                            Loop               
78858>                            
78858>                            // If found; add a new combo item at the end with the short version of the workspace (no path),
78858>                            // and point the combo to that item.
78858>                            If (iSelection <> 0) Begin
78860>                                Set psToolTip     to CS_CurrentWorkspaceText
78861>                                Set psDescription to sWorkspaceShort   
78862>                                Set psCaption     of (oWorkspaceSelectorText_Menuitem(ghoCommandBars)) to CS_CurrentWorkspaceText
78863>                                Set psDescription of (oWorkspaceSelectorText_Menuitem(ghoCommandBars)) to sWorkspace
78864>                                Set psDescription to sWorkspace
78865>                                Get ComListCount of hoCombo to iSelection 
78866>                                Increment iSelection
78867>                                Send ComAddItem  of hoCombo sWorkspaceShort iSelection
78868>                                Set ComListIndex of hoCombo to iSelection
78869>                            End
78869>                            Send Destroy of hoCombo    
78870>                        End
78870>                    End
78870>                
78870>                End_Procedure
78871>                
78871>                Procedure ResetComboForm
78874>                    Handle hoCombo
78874>                    // Create and bind proxy control 
78874>                    If (IsComObjectCreated(Self)) Begin
78876>                        Get CreateFirstProxyControl to hoCombo
78877>                        If (hoCombo <> 0) Begin
78879>                            Send ComClear of hoCombo
78880>                            Send ComAddItem of hoCombo CS_NoWorkspaceSelected 1
78881>                            Set ComListIndex of hoCombo to 1
78882>                            Set psCaption of (oWorkspaceSelectorText_Menuitem(ghoCommandBars)) to CS_SelectWorkspaceText
78883>                            Send Destroy of hoCombo
78884>                        End
78884>                    End
78884>                End_Procedure
78885>
78885>                Procedure OnCreateAction
78888>                    String sSWSFile sSourceFile
78888>
78888>                    Forward Send OnCreateAction
78890>                    Get psSWSFile of ghoApplication to sSWSFile
78891>                    Get psCurrentSourceFileName         of ghoApplication to sSourceFile
78892>                    Send UpdateWorkspaceSelectorDisplay of ghoApplication sSWSFile
78893>                    Send UpdateSourceFileNameDisplay    of ghoApplication sSourceFile
78894>                End_Procedure
78895>
78895>                // Note: We re-fill the combo each time it gets "clicked".
78895>                Procedure OnPopupInit Variant vCommandBarControl Handle hoCommandBarControls
78898>                    Handle hoCombo
78898>                    Forward Send OnPopupInit vCommandBarControl hoCommandBarControls
78900>                    Get CreateProxyControl vCommandBarControl to hoCombo
78901>                    Send FillComboList hoCombo
78902>                    Send Destroy of hoCombo
78903>                End_Procedure
78904>
78904>            End_Object
78905>
78905>            Object oWorkspaceOpen_Menuitem is a cCJMenuItem
78907>                Set psToolTip to "Open Workspace File"
78908>                Set psDescription to "Open a Workspace .sws File (Alt+W)"
78909>                Set psShortcut to "Alt+W"
78910>                Set pbControlCloseSubMenu to False
78911>                Set pbControlFlagNoMovable to True
78912>                Set psImage to "ActionOpen.ico"
78913>                Set peControlStyle to xtpButtonIcon
78914>
78914>                Procedure OnExecute Variant vCommandBarControl
78917>                    String sFileName
78917>                    Get SelectWorkspaceFile of ghoApplication to sFileName
78918>                    If (sFileName <> "") Begin
78920>                        Send UpdateWorkspaceSelectorDisplay of ghoApplication sFileName
78921>                        Send DisplayWorkspaceItem of (oWorkspaceSelector_Menuitem(ghoCommandBars)) sFileName
78922>                    End
78922>                End_Procedure
78923>                
78923>            End_Object
78924>            
78924>            Object oResetWorkspace_MenuItem is a cCJMenuItem
78926>                Set pbControlBeginGroup to True
78927>                Set pbActiveUpdate to True
78928>                Set psCaption to "Clear Workspace"
78929>                Set psToolTip to "Clear Workspace"
78930>                Set psDescription to "Clears the currently selected workspace, and everything else (Ctrl+F5)"
78931>                Set psImage to "ActionClear.ico"
78932>                Set peControlStyle to xtpButtonIconAndCaption
78933>
78933>                Procedure OnExecute Variant vCommandBarControl
78936>                    Boolean bChanged
78936>                    Integer iRetval
78936>
78936>                    Broadcast Recursive Get pbShouldSave of (Client_Id(phoMainPanel(ghoApplication))) to bChanged
78938>                    If (bChanged = True) Begin
78940>                        Get YesNo_Box ("Changes exists! If you answer 'Yes' your changes will be lost. Are you sure?") "" MB_DEFBUTTON2 to iRetval
78941>                        If (iRetval <> MBR_Yes) Begin
78943>                            Procedure_Return
78944>                        End
78944>                    End
78944>                    Send UpdateWorkspaceSelectorDisplay of ghoApplication ""
78945>                End_Procedure
78946>
78946>                Function IsEnabled Returns Boolean
78949>                    String sSWSFile
78949>                    Get psSWSFile of ghoApplication to sSWSFile
78950>                    Function_Return (sSWSFile <> "")
78951>                End_Function
78952>
78952>            End_Object
78953>
78953>            Object oRemoveWorkspaceHistory_Menuitem is a cCJMenuItem
78955>                Set psCaption to "Remove History "
78956>                Set psToolTip to "Remove History"
78957>                Set psDescription to "Dialog for removing Workspace history items from the registry (Alt+H)"
78958>                Set peControlStyle to xtpButtonIcon
78959>                Set psImage to "RemoveWorkspaceHistory.ico"
78960>                Set pbControlBeginGroup to True
78961>
78961>                Procedure OnExecute Variant vCommandBarControl
78964>                    Forward Send OnExecute vCommandBarControl
78966>                    Send DeleteWorkSpaceHistoryFromRegistry of ghoApplication
78967>                End_Procedure
78968>            End_Object
78969>
78969>        End_Object
78970>
78970>        Object oSourceFile_Toolbar is a cCJToolbar
78972>            Set pbEnableDocking to False
78973>            Set pbCloseable to False
78974>            Set pbCustomizable to False
78975>            Set pbShowExpandButton to False
78976>            Set peStretched to stStretchShared
78977>
78977>            Object oOpenFolderMenuItem is a cCJMenuItem
78979>                Set psCaption to CS_BrowseSourceFileTxt
78980>                Set psToolTip to "Select source file"
78981>                Set psDescription to "Displays an Open File dialog to select a source file from (Ctrl+O)"
78982>                Set psImage to "ActionOpen.ico"
78983>                Set peControlStyle to xtpButtonIconAndCaption
78984>                Set pbActiveUpdate to True
78985>
78985>                Procedure OnExecute Variant vCommandBarControl
78988>                    Forward Send OnExecute vCommandBarControl
78990>                    Send SelectSourceFile of ghoApplication
78991>                End_Procedure
78992>
78992>                Function IsEnabled Returns Boolean
78995>                    Boolean bState
78995>                    String sSWSFile
78995>
78995>                    Move False to bState
78996>                    Get psSWSFile of ghoApplication to sSWSFile
78997>                    Move (sSWSFile <> "") to bState
78998>
78998>                    Function_Return bState
78999>                End_Function
79000>
79000>            End_Object
79001>
79001>            Object oSourceFileText_MenuItem is a cCJMenuItem
79003>                Set peControlType to xtpControlCustom   
79004>
79004>                Procedure OnExecute Variant vCommandBarControl
79007>                    Forward Send OnExecute vCommandBarControl
79009>                    Send Execute of oOpenFolderMenuItem
79010>                End_Procedure
79011>            End_Object
79012>
79012>            Object oResetSourceFile_MenuItem is a cCJMenuItem
79014>                Set psCaption to "Clear File"
79015>                Set pbControlBeginGroup to True
79016>                Set psToolTip to "Clear source"
79017>                Set psDescription to "Clears (closes) the currently opened source file without saving changes. (F5)"
79018>                Set pbActiveUpdate to True
79019>                Set psImage to "ActionClear.ico"
79020>                Set peControlStyle to xtpButtonIconAndCaption
79021>
79021>                Procedure OnExecute Variant vCommandBarControl
79024>                    Boolean bChanged
79024>                    Integer iRetval
79024>                    Handle hoEditor
79024>
79024>                    Broadcast Recursive Get pbShouldSave of (Client_Id(phoMainPanel(ghoApplication))) to bChanged
79026>                    If (bChanged = True) Begin
79028>                        Get YesNo_Box "Changes exists! If you answer 'Yes' your changes will be lost. Are you sure?" to iRetval
79029>                        If (iRetval <> MBR_Yes) Begin
79031>                            Procedure_Return
79032>                        End
79032>                    End
79032>                    Send UpdateSourceFileNameDisplay of ghoApplication ""
79033>                    Get phoEditor of ghoApplication to hoEditor
79034>                    Send Request_Clear of hoEditor
79035>                    Set pbWorkspaceMode of ghoApplication to True                            
79036>                    Send Activate_oRefactorView of (Client_Id(phoMainPanel(ghoApplication))) 
79037>                    Send Activate of (phoRefactorView(ghoApplication))
79038>                End_Procedure
79039>
79039>                Function IsEnabled Returns Boolean
79042>                    String sFileName
79042>                    Get psCurrentSourceFileName of ghoApplication to sFileName
79043>                    Function_Return (sFileName <> "")
79044>                End_Function
79045>
79045>            End_Object
79046>
79046>            Object oOpenContainingFolder_MenuItem is a cCJMenuItem
79048>                Set psImage to "ActionOpenContainingFolder.ico"
79049>                Set psCaption to "Containing Folder"
79050>                Set psToolTip to "Open Folder"
79051>                Set psDescription to "Open Containing Folder"
79052>                Set pbActiveUpdate to True
79053>                Set pbControlBeginGroup to True
79054>
79054>                Procedure OnExecute Variant vCommandBarControl
79057>                    String sPath sFile
79057>                    Get psWorkspaceHomePath of ghoApplication to sPath
79058>                    Get psCurrentSourceFileName of ghoApplication to sFile
79059>                    
79059>                    // We want to have that file to be selected in Windows Explorer
79059>                    If (sFile <> "") Begin
79061>                        Move ("/select," * String(sFile)) to sPath
79062>                    End 
79062>                    Send vShellExecute "open" "explorer.exe" sPath ""
79063>                End_Procedure
79064>
79064>                Function IsEnabled Returns Boolean
79067>                    String sPath
79067>                    Get psWorkspaceHomePath of ghoApplication to sPath
79068>                    Function_Return (sPath <> "")
79069>                End_Function
79070>
79070>            End_Object
79071>
79071>        End_Object
79072>
79072>        Object oFileToolBar is a cCJToolbar
79074>            Set psTitle to "Process Toolbar"
79075>            Set peStretched to stStretchShared
79076>            Set pbCloseable to False
79077>            Set pbDockNextTo to False
79078>            Set pbCustomizable to False
79079>
79079>            Object oRadioSelectorText_Menuitem is a cCJMenuItem
79081>                Set psCaption to "Refactoring Mode:"
79082>                Set psToolTip to "Refactoring Mode"
79083>                Set psDescription to "Select if the Process should run on all source files that matches the 'File extensions' combo for selected workspace, or only on one selected file. (Toggle with Alt+F)"
79084>                Set pbControlBeginGroup to True
79085>                Set pbActiveUpdate to True
79086>                Set psImage to "Mode.ico"
79087>                Set peControlStyle to xtpButtonIconAndCaption
79088>
79088>                Procedure OnExecute Variant vCommandBarControl
79091>
79091>                    Forward Send OnExecute vCommandBarControl
79093>                    Send Execute of oWorkspaceRadio_MenuItem
79094>                End_Procedure
79095>
79095>                Function IsEnabled Returns Boolean
79098>                    String sSWSFile
79098>                    Get psSWSFile of ghoApplication to sSWSFile
79099>                    Function_Return (sSWSFile <> "")
79100>                End_Function
79101>
79101>            End_Object
79102>
79102>            Object oWorkspaceRadio_MenuItem is a cCJMenuItem
79104>                Set peControlType to xtpControlRadioButton
79105>                Set psCaption to "Full Workspace"
79106>                Set psToolTip to "Mode"
79107>                Set psDescription to "Select if the Process should run on all source files that matches the 'File extensions' combo for selected workspace. (Toggle with Alt+F)"
79108>                Set pbChecked to True
79109>                Set pbActiveUpdate to True
79110>
79110>                Procedure OnExecute Variant vCommandBarControl
79113>                    Boolean bState
79113>                    Get pbChecked to bState
79114>                    Set pbChecked to (not(bState))
79115>                    Set pbWorkspaceMode of ghoApplication to (not(bState))
79116>                End_Procedure
79117>
79117>                Function IsEnabled Returns Boolean
79120>                    String sSWSFile
79120>                    Get psSWSFile of ghoApplication to sSWSFile
79121>                    Function_Return (sSWSFile <> "")
79122>                End_Function
79123>
79123>                Procedure OnCreateControl Handle hoObj
79126>                    String sSWSFile
79126>                    Get psSWSFile of ghoApplication to sSWSFile
79127>                    Set pbChecked to (sSWSFile <> "")
79128>                    Set ComDefaultItem of hoObj to True
79129>                End_Procedure
79130>
79130>            End_Object
79131>
79131>            Object oFileRadioMenuItem is a cCJMenuItem
79133>                Set peControlType to xtpControlRadioButton
79134>                Set psCaption to "One &File"
79135>                Set psToolTip to "Mode"
79136>                Set psDescription to "Select if the Process should be run on one selected source file only (use the 'Open Source File:' to select) Toggles with Alt+F"
79137>                Set psShortcut to "Alt+F"
79138>                Set pbActiveUpdate to True
79139>                
79139>                Procedure OnExecute Variant vCommandBarControl
79142>                    Boolean bState
79142>                    Get pbChecked to bState
79143>                    Set pbChecked to (not(bState))
79144>                    Set pbWorkspaceMode of ghoApplication to bState
79145>                End_Procedure
79146>
79146>                Function IsEnabled Returns Boolean
79149>                    String sSWSFile
79149>
79149>                    Get psSWSFile of ghoApplication to sSWSFile
79150>                    Function_Return (sSWSFile <> "")
79151>                End_Function
79152>
79152>                Procedure OnCreateControl Handle hoObj
79155>                    String sSWSFile sSourceFile
79155>                    Forward Send OnCreateControl hoObj
79157>                    Get psSWSFile of ghoApplication to sSWSFile
79158>                    Get psCurrentSourceFileName of ghoApplication to sSourceFile
79159>                    Set pbChecked to (sSWSFile <> "")
79160>                    Set pbWorkspaceMode of ghoApplication to (sSourceFile = "")
79161>                    Set ComDefaultItem of hoObj to True
79162>                End_Procedure
79163>
79163>            End_Object
79164>
79164>            Object oSave_ToolItem is a cCJSaveMenuItem
79166>                Set peControlStyle to xtpButtonIcon
79167>                Set pbControlBeginGroup to True
79168>                Set psCaption to "&Save"
79169>                Set psToolTip to "Save"
79170>                Set psDescription to "Save editor changes (Alt+S)"
79171>                Set psShortcut to "Alt+S"
79172>
79172>                Function IsEnabled Returns Boolean
79175>                    Boolean bChanged
79175>
79175>                    Move False to bChanged   
79176>                    Get Should_Save of (oSysfile_DD(phoRefactorView(ghoApplication))) to bChanged
79177>                    If (bChanged = False) Begin
79179>                        Get pbShouldSave of (phoEditorView(ghoApplication)) to bChanged
79180>                    End     
79180>                    Function_Return bChanged
79181>                End_Function
79182>
79182>                Procedure OnExecute Variant vCommandBarControl
79185>                    Send Request_Save of (Focus(Self))
79186>                End_Procedure
79187>
79187>            End_Object
79188>
79188>            Object oEditorUndo_MenuItem is a cCJMenuItem
79190>                Set psToolTip to "Undo"
79191>                Set psDescription to "Undo last editor action (Ctrl+Z)"
79192>                Set psImage to "ActionUndo.ico"
79193>                Set pbActiveUpdate to True
79194>
79194>                Procedure OnExecute Variant vCommandBarControl
79197>                    Handle hoEditor
79197>                    Forward Send OnExecute vCommandBarControl
79199>
79199>                    Get phoEditor of ghoApplication to hoEditor
79200>                    Send CME_UndoAction of hoEditor
79201>                End_Procedure
79202>
79202>                Function IsEnabled Returns Boolean
79205>                    Boolean bOK bCanUndo
79205>                    Handle hoEditor
79205>
79205>                    Get phoEditor of ghoApplication to hoEditor
79206>                    Get Can_UndoAction of hoEditor  to bCanUndo
79207>
79207>                    Function_Return bCanUndo
79208>                End_Function
79209>
79209>            End_Object
79210>
79210>        End_Object
79211>
79211>        Object oTools_toolbar is a cCJToolbar
79213>            Set peStretched to stStretchShared
79214>            Set pbCloseable to False
79215>            Set pbCustomizable to False
79216>
79216>            Object oOpenLogFile_MenuItem is a cCJMenuItem
79218>                Set psToolTip to "View logfile"
79219>                Set psDescription to "View the logfile that is added to for each run (Alt+L)"
79220>                Set psImage to "OpenLogFile.ico"
79221>                Set peControlStyle to xtpButtonIcon
79222>                Set pbActiveUpdate to True
79223>
79223>                Procedure OnExecute Variant vCommandBarControl
79226>                    String sPath sLogFile
79226>                    Boolean bLogFileExists
79226>
79226>                    Forward Send OnExecute vCommandBarControl
79228>
79228>                    Get psHomePath of ghoApplication to sPath
79229>                    Get vFolderFormat sPath to sPath
79230>                    Move (sPath + CS_BackupFolder + CS_DirSeparator + CS_SummaryLogfileName) to sLogFile
79231>                    Get vFilePathExists sLogFile to bLogFileExists
79232>                    If (bLogFileExists = False) Begin
79234>                        Send Info_Box "Can't find the log file"
79235>                        Procedure_Return
79236>                    End
79236>
79236>                    Send ActivateLogFileDialog of (Client_Id(ghoCommandBars)) sLogFile
79237>                End_Procedure
79238>
79238>                Function IsEnabled Returns Boolean
79241>                    String sPath sLogFile
79241>                    Boolean bLogFileExists
79241>
79241>                    Get psHomePath of ghoApplication to sPath
79242>                    Get vFolderFormat sPath to sPath
79243>                    Move (sPath + CS_BackupFolder + CS_DirSeparator + CS_SummaryLogfileName) to sLogFile
79244>                    Get vFilePathExists sLogFile to bLogFileExists
79245>
79245>                    Function_Return (bLogFileExists = True)
79246>                End_Function
79247>
79247>            End_Object
79248>
79248>            Object oShowErrorLog_MenuItem is a cCJMenuItem
79250>                Set psToolTip to "View Error Log"
79251>                Set psDescription to "View the error log"
79252>                Set psImage to "ErrorLog.ico"
79253>                Set peControlStyle to xtpButtonIcon
79254>                Set pbActiveUpdate to True
79255>
79255>                Procedure OnExecute Variant vCommandBarControl
79258>                    Send Popup of (oStatusLog_dg(Client_Id(ghoCommandBars)))
79259>                End_Procedure
79260>
79260>            End_Object
79261>
79261>            Object oUnusedSourceFiles_MenuItem is a cCJMenuItem
79263>                Set psCaption to "Unused Source"
79264>                Set psDescription to "Show Unused Source Files dialog (Alt+I)"
79265>                Set psToolTip to "Unused Source Files"
79266>                Set psImage to "UnusedSourceFiles.ico"
79267>                Set peControlStyle to xtpButtonIcon
79268>                Set pbActiveUpdate to True
79269>
79269>                Procedure OnExecute Variant vCommandBarControl
79272>                    String sPath sFileName sLine sHomePath
79272>                    tUnusedSourceFiles[] asUnusedSource
79272>                    tUnusedSourceFiles[] asUnusedSource
79273>                    Boolean bLogFileExists bExists
79273>                    Integer iCh iCount
79273>
79273>                    Forward Send OnExecute vCommandBarControl
79275>
79275>                    Get psHomePath of ghoApplication to sHomePath
79276>                    Get vFolderFormat sHomePath to sHomePath
79277>                    Move (sHomePath + CS_BackupFolder + CS_DirSeparator + CS_UnusedSourceLogFile) to sFileName
79278>                    Get vFilePathExists sFileName to bLogFileExists
79279>                    If (bLogFileExists = False) Begin
79281>                        Send Info_Box "Can't find the log file"
79282>                        Procedure_Return
79283>                    End
79283>
79283>                    Send Cursor_Wait of Cursor_Control
79284>                    Direct_Input channel iCh sFileName
79286>                    While (SeqEof = False)
79290>                        Readln channel iCh sLine
79292>                        Get vFilePathExists sLine to bExists
79293>                        If (bExists = True) Begin
79295>                            Get ParseFolderName sLine to asUnusedSource[iCount].sPath
79296>                            Get ParseFileName   sLine to asUnusedSource[iCount].sFileName
79297>                            Increment iCount
79298>                        End
79298>                    Loop
79299>
79299>                    Send FillUnusedSourceFilesDialog of (Client_Id(ghoCommandBars)) asUnusedSource
79300>                    Send Cursor_Ready of Cursor_Control
79301>                    Send DisplayUnusedSourceFilesDialog of (Client_Id(ghoCommandBars))
79302>                End_Procedure
79303>
79303>                Function IsEnabled Returns Boolean
79306>                    String sPath sLogFile
79306>                    Boolean bLogFileExists
79306>
79306>                    Get psHomePath of ghoApplication to sPath
79307>                    Get vFolderFormat sPath to sPath
79308>                    Move (sPath + CS_BackupFolder + CS_DirSeparator + CS_UnusedSourceLogFile) to sLogFile
79309>                    Get vFilePathExists sLogFile to bLogFileExists
79310>
79310>                    Function_Return (bLogFileExists = True)
79311>                End_Function
79312>
79312>            End_Object
79313>
79313>            Object oUndoRefactoring_MenuItem is a cCJMenuItem
79315>                Set psToolTip to "Undo Backup Files"
79316>                Set psDescription to "Undo process of refactoring actions. Dialog that moves files from the 'DFRefactor Backup' subfolder structure to their original folders. (Alt+U)"
79317>                Set psImage to "UndoRefactoring.ico"
79318>                Set pbActiveUpdate to True
79319>                Set pbControlBeginGroup to True
79320>
79320>                Procedure OnExecute Variant vCommandBarControl
79323>                    tsSearchResult[] BackpupFileArray
79323>                    tsSearchResult[] BackpupFileArray
79324>                    Forward Send OnExecute vCommandBarControl
79326>                    Send Cursor_Wait of Cursor_Control
79327>                    Get AllBackupFolderFiles of ghoApplication to BackpupFileArray
79328>                    Send Cursor_Ready of Cursor_Control
79329>                    Send FillBackupFilesDialog of (Client_Id(ghoCommandBars)) BackpupFileArray
79330>                End_Procedure
79331>
79331>                Function IsEnabled Returns Boolean
79334>                    String sSourcePath sBackupPath
79334>                    String sBackupName sSourceFilename
79334>                    Boolean bWorkspaceMode bOK
79334>
79334>                    Move False to bOK
79335>                    Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
79336>                    Get psCurrentSourceFileName of ghoApplication to sSourceFilename
79337>                    Get IsBackupFile of ghoApplication sSourceFilename to sBackupName
79338>                    If (bWorkspaceMode = True) Begin
79340>                        Get SourceFilePath of ghoApplication to sSourcePath
79341>                        Get HomeBackupFilePath of ghoApplication to sBackupPath
79342>                        Move (sSourcePath <> "" and sBackupPath <> "") to bOK
79343>                    End
79343>                    Else Begin
79344>                        Move (sSourceFilename <> "" and sBackupName <> "") to bOK
79345>                    End
79345>
79345>                    Function_Return bOK
79346>                End_Function
79347>
79347>            End_Object
79348>
79348>            Object oCompare_MenuItem is a cCJMenuItem
79350>                Set psCaption to "Co&mpare"
79351>                Set psToolTip to "Compare"
79352>                Set psDescription to "Compare file changes after running refactoring function(s) (Alt+M)"
79353>                Set psImage to "Compare.ico"
79354>                Set peControlStyle to xtpButtonIcon
79355>                Set pbActiveUpdate to True
79356>                Set pbControlBeginGroup to True
79357>
79357>                Procedure OnExecute Variant vCommandBarControl
79360>                    String sCompareApp
79360>                    Boolean bWorkspaceMode
79360>
79360>                    Forward Send OnExecute vCommandBarControl
79362>
79362>                    Get psFileCompareApp of ghoApplication to sCompareApp
79363>                    Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
79364>                    If (bWorkspaceMode = True) Begin
79366>                        Send ComparePaths of ghoApplication sCompareApp
79367>                    End
79367>                    Else Begin
79368>                        Send CompareFiles of ghoApplication sCompareApp
79369>                    End
79369>                End_Procedure
79370>
79370>                Function IsEnabled Returns Boolean
79373>                    String sSourcePath sBackupPath
79373>                    String sBackupName sSourceFilename sCompareApp
79373>                    Boolean bWorkspaceMode bOK
79373>
79373>                    Move False to bOK
79374>                    Get psFileCompareApp of ghoApplication to sCompareApp
79375>                    If (sCompareApp <> "") Begin
79377>                        Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
79378>                        Get psCurrentSourceFileName of ghoApplication to sSourceFilename
79379>                        Get IsBackupFile of ghoApplication sSourceFilename to sBackupName
79380>                        If (bWorkspaceMode = True) Begin
79382>                            Get SourceFilePath of ghoApplication to sSourcePath
79383>                            Get HomeBackupFilePath of ghoApplication to sBackupPath
79384>                            Move (sSourcePath <> "" and sBackupPath <> "") to bOK
79385>                        End
79385>                        Else Begin
79386>                            Move (sSourceFilename <> "" and sBackupName <> "") to bOK
79387>                        End
79387>                    End
79387>
79387>                    Function_Return bOK
79388>                End_Function
79389>
79389>            End_Object
79390>
79390>            Object oCodeExplorer_ToolbarButton is a cCJMenuItem
79392>                Set psCaption to "DataFlex Source &Explorer"
79393>                Set psToolTip to "DataFlex Source Explorer"
79394>                Set psDescription to "Run Starzen's DataFlex Source Explorer (Alt+E)"
79395>                Set psImage to "DataFlexSourceExplorer.ico"
79396>                Set psShortcut to "Alt+E"
79397>                Set peControlStyle to xtpButtonIcon
79398>                Set pbActiveUpdate to True
79399>
79399>                Procedure OnExecute Variant vCommandBarControl
79402>                    String sProgram sSWSPath
79402>                    Forward Send OnExecute vCommandBarControl
79404>                    
79404>                    Get private.psStarZenSourceExplorer of ghoApplication to sProgram
79405>//                    Get ReadString of ghoApplication "Settings" "StarZenSourceExplorer" "" to sProgram
79405>                    If (sProgram = "") Begin
79407>                        Send Info_Box "You first need to setup the path to StarZen's Source Code Explorer program with 'Program Settings'"
79408>                        Procedure_Return
79409>                    End
79409>                    Get psSWSFile of ghoApplication to sSWSPath
79410>                    If (sSWSPath <> "") Begin
79412>                        Move ("-ws" * '"' + sSWSPath + '"') to sSWSPath
79413>                    End
79413>                    RunProgram Background sProgram sSWSPath
79414>                End_Procedure
79415>
79415>                Function IsEnabled Returns Boolean
79418>                    String sProgram
79418>                    Get psStarZenSourceExplorer of ghoApplication to sProgram
79419>                    Function_Return (sProgram <> "")
79420>                End_Function
79421>
79421>            End_Object
79422>
79422>        End_Object
79423>
79423>        Object oSettings_toolbar is a cCJToolbar
79425>            Set peStretched to stStretchShared
79426>            Set pbCloseable to False
79427>            Set pbCustomizable to False
79428>
79428>            Object oSettings_Toolbarbutton is a cCJMenuItem
79430>                Set psToolTip to "Program Settings"
79431>                Set psCaption to "Se&ttings"
79432>                Set psDescription to "Program Settings (Alt+T)"
79433>                Set psImage to "Settings.ico"
79434>                Set peControlStyle to xtpButtonIcon
79435>                Set pbControlBeginGroup to True
79436>                Set psShortcut to "Alt+T"
79437>
79437>                Procedure OnExecute Variant vCommandBarControl
79440>                    Forward Send OnExecute vCommandBarControl
79442>                    Send Popup of (oProgramSetup_dg(Client_Id(ghoCommandBars)))
79443>                    Broadcast Recursive Send DoChangeFontSize of (Client_Id(ghoCommandBars))
79445>                End_Procedure
79446>
79446>            End_Object
79447>
79447>            Object oScintillaEditorSettings_Mentuitem is a cCJMenuItem
79449>                Set psToolTip to "Editor Settings"
79450>                Set psCaption to "E&ditor Settings"
79451>                Set psDescription to "Configure the editor (Alt+D)"
79452>                Set psImage to "EditorSettings.ico"
79453>                Set peControlStyle to xtpButtonIcon
79454>                Set psShortcut to "Alt+D"
79455>
79455>                Procedure OnExecute Variant vCommandBarControl
79458>                    Forward Send OnExecute vCommandBarControl
79460>                    Send Popup of (oScintillaParameters_dg(Client_Id(ghoCommandBars)))
79461>                End_Procedure
79462>
79462>            End_Object
79463>
79463>            Object oThemeItem is a cCJMenuItem
79465>                Set peControlType to xtpControlComboBox
79466>                Set psCaption to "Theme:"
79467>                Set pbControlBeginGroup to True
79468>                Set psToolTip to "Theme"
79469>                Set psDescription to "Select a theme from the drop down list"
79470>                Set peControlStyle to xtpButtonIconAndCaption
79471>//                Set pbVisible to False
79471>
79471>                Property tCJComboBoxContent[] pCJComboBoxContentArray
79473>
79473>                Procedure OnCreateControl Handle hoObj
79476>                    Integer iItem eTheme
79476>                    Set ComWidth of hoObj to 235
79477>                    Send FillComboList hoObj
79478>                    Get peVisualTheme to eTheme
79479>                    Get FindDataItem hoObj eTheme to iItem
79480>                    Set ComListIndex of hoObj to (If(iItem, iItem, 1))
79481>                    Set ComAutoComplete of hoObj to True
79482>                End_Procedure
79483>
79483>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
79486>                    Integer iCount i eTheme
79486>                    Get ComListCount of hoCombo to iCount
79487>                    For i From 1 to iCount
79493>                        Get ComItemData  of hoCombo i to eTheme
79494>                        If (eTheme = eVal) Begin
79496>                            Function_Return i
79497>                        End
79497>                    Loop
79498>                    Function_Return 0
79499>                End_Function
79500>
79500>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
79503>                    tCJComboBoxContent[] CJComboBoxContentArray
79503>                    tCJComboBoxContent[] CJComboBoxContentArray
79504>                    Integer iCount    
79504>                    Get pCJComboBoxContentArray to CJComboBoxContentArray
79505>                    Move (SizeOfArray(CJComboBoxContentArray)) to iCount
79506>                    Move (" " + String(sText)) to CJComboBoxContentArray[iCount].sText
79507>                    Move eTheme to CJComboBoxContentArray[iCount].eTheme
79508>                    Set pCJComboBoxContentArray to CJComboBoxContentArray
79509>                End_Procedure
79510>
79510>                // First sorts the array alphabetically, then adds items
79510>                // to the CodeJock combo.
79510>                Procedure AddAllThemesToControl Handle hoCombo
79513>                    tCJComboBoxContent[] CJComboBoxContentArray
79513>                    tCJComboBoxContent[] CJComboBoxContentArray
79514>                    Integer iSize iCount iItems
79514>
79514>                    Get pCJComboBoxContentArray to CJComboBoxContentArray
79515>                    Move (SortArray(CJComboBoxContentArray)) to CJComboBoxContentArray
79516>                    Move (SizeOfArray(CJComboBoxContentArray)) to iSize
79517>                    Decrement iSize
79518>                    For iCount from 0 to iSize
79524>                        Get ComListCount of hoCombo to iItems
79525>                        Increment iItems
79526>                        Send ComAddItem of hoCombo CJComboBoxContentArray[iCount].sText iItems
79527>                        Set ComItemData of hoCombo iItems to CJComboBoxContentArray[iCount].eTheme
79528>                    Loop
79529>
79529>                    Set pCJComboBoxContentArray to CJComboBoxContentArray
79530>                End_Procedure
79531>
79531>                Procedure FillComboList Handle hoCombo
79534>                    Send ComClear     of hoCombo
79535>
79535>                    Send AddTheme hoCombo "xtpThemeOffice2016Access"        xtpThemeOffice2016Access
79536>                    Send AddTheme hoCombo "xtpThemeOffice2016Excel"         xtpThemeOffice2016Excel
79537>                    Send AddTheme hoCombo "xtpThemeOffice2016OneNote"       xtpThemeOffice2016OneNote
79538>                    Send AddTheme hoCombo "xtpThemeOffice2016Outlook"       xtpThemeOffice2016Outlook
79539>                    Send AddTheme hoCombo "xtpThemeOffice2016PowerPoint"    xtpThemeOffice2016PowerPoint
79540>                    Send AddTheme hoCombo "xtpThemeOffice2016Publisher"     xtpThemeOffice2016Publisher
79541>                    Send AddTheme hoCombo "xtpThemeOffice2016Word"          xtpThemeOffice2016Word
79542>
79542>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light"   xtpThemeVisualStudio2015Light
79543>                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua"          xtpThemeOffice2007Aqua
79544>                    Send AddTheme hoCombo "xtpThemeOffice2007Blue"          xtpThemeOffice2007Blue
79545>                    Send AddTheme hoCombo "xtpThemeOffice2007Black"         xtpThemeOffice2007Black
79546>                    Send AddTheme hoCombo "xtpThemeOffice2007Silver"        xtpThemeOffice2007Silver
79547>
79547>                    Send AddTheme hoCombo "xtpThemeOffice2010"              xtpThemeOffice2010
79548>                    Send AddTheme hoCombo "xtpThemeOffice2010Blue"          xtpThemeOffice2010Blue
79549>                    Send AddTheme hoCombo "xtpThemeOffice2010Black"         xtpThemeOffice2010Black
79550>                    Send AddTheme hoCombo "xtpThemeOffice2010Silver"        xtpThemeOffice2010Silver
79551>
79551>                    Send AddTheme hoCombo "xtpThemeOffice2013Word"          xtpThemeOffice2013Word
79552>                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook"       xtpThemeOffice2013Outlook
79553>                    Send AddTheme hoCombo "xtpThemeOffice2013Excel"         xtpThemeOffice2013Excel
79554>                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint"    xtpThemeOffice2013PowerPoint
79555>                    Send AddTheme hoCombo "xtpThemeOffice2013Access"        xtpThemeOffice2013Access
79556>                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher"     xtpThemeOffice2013Publisher
79557>                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote"       xtpThemeOffice2013OneNote
79558>
79558>                    Send AddTheme hoCombo "xtpThemeWindows7"                xtpThemeWindows7
79559>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue"    xtpThemeVisualStudio2015Blue
79560>
79560>                    Send AddTheme hoCombo "xtpThemeOffice2003"              xtpThemeOffice2003
79561>                    Send AddTheme hoCombo "xtpThemeWhidbey"                 xtpThemeWhidbey
79562>                    Send AddTheme hoCombo "xtpThemeResource"                xtpThemeResource
79563>                    Send AddTheme hoCombo "xtpThemeVisualStudio2008"        xtpThemeVisualStudio2008
79564>                    Send AddTheme hoCombo "xtpThemeVisualStudio6"           xtpThemeVisualStudio6
79565>                    Send AddTheme hoCombo "xtpThemeVisualStudio2010"        xtpThemeVisualStudio2010
79566>                    Send AddTheme hoCombo "xtpThemeOffice2013"              xtpThemeOffice2013
79567>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012"        xtpThemeVisualStudio2012
79568>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light"   xtpThemeVisualStudio2012Light
79569>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark"    xtpThemeVisualStudio2012Dark
79570>
79570>                    Send AddAllThemesToControl hoCombo
79571>                End_Procedure
79572>
79572>                Function CurrentTheme Handle vCommandBarControl Returns Integer
79575>                    Handle hMessage hoCombo
79575>                    Integer iIndex
79575>
79575>                    Move 0 to hMessage
79576>                    Get CreateProxyControl vCommandBarControl to hoCombo
79577>                    Get ComListIndex of hoCombo to iIndex
79578>                    If (iIndex > 0) Begin
79580>                        // Get the ItemData for the selected item and send that message
79580>                        Get ComItemData of hoCombo iIndex to hMessage
79581>                    End
79581>                    Send Destroy of hoCombo
79582>                    Function_Return hMessage
79583>                End_Function
79584>
79584>                Procedure OnExecute Variant vCommandBarControl
79587>                    Integer eTheme
79587>//                    Integer iColor
79587>
79587>                    Get CurrentTheme vCommandBarControl to eTheme
79588>                    Set peVisualTheme of ghoCommandBars to eTheme
79589>                    Send WriteDword of ghoApplication CS_Settings CS_ThemeKeyWord eTheme
79590>                    Send ComRecalcLayout of ghoCommandBars
79591>
79591>                    // Sets the background color for all application objects to the selected theme color:
79591>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
79591>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
79591>                End_Procedure 
79592>                
79592>            End_Object
79593>
79593>        End_Object
79594>
79594>        Object oExit_toolbar is a cCJToolbar
79596>            Set peStretched to stStretchShared
79597>            Set pbCloseable to False
79598>            Set pbCustomizable to False
79599>
79599>            //            Object oCaptureViewMenuItem is a cCJMenuItem
79599>            //                Set psCaption to "Take shapshot"
79599>            //                Set psToolTip to "Take shapshot"
79599>            //                Set psDescription to "Take a snapshot image of the current view/panel. (F10)"
79599>            //                Set psImage to "Camera.ico"
79599>            //
79599>            //                Procedure OnExecute Variant vCommandBarControl
79599>            //                    Send TakeSnapshot False
79599>            //                End_Procedure
79599>            //
79599>            ////                Function IsEnabled Returns Boolean
79599>            ////                    Function_Return
79599>            ////                End_Function
79599>            //            End_Object
79599>            //
79599>            Object oAbout_MenuItem is a cCJMenuItem
79601>                Set psCaption to "About"
79602>                Set psToolTip to "About"
79603>                Set psDescription to "About the program"
79604>                Set psImage to "ActionAbout.ico"
79605>                Set pbControlBeginGroup to True
79606>                Procedure OnExecute Variant vCommandBarControl
79609>                    Forward Send OnExecute vCommandBarControl
79611>                    Send Activate_About of (Client_Id(ghoCommandBars))
79612>                End_Procedure
79613>            End_Object
79614>
79614>            Object oHelpMenuItem is a cCJHelpMenuItem
79616>                Set peControlType to xtpControlSplitButtonPopup
79617>                Set psToolTip to "Help"
79618>                Set psDescription to "Help about the program (F1)"
79619>
79619>                Object oHelpMenuItemLocal is a cCJHelpMenuItem
79621>                    Set psCaption to "Local HTML Help"
79622>                End_Object
79623>
79623>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
79625>                    Set psCaption to "Online HTML Help"
79626>                    Set psImage to "ActionHelpInternet.ico"
79627>                    Procedure OnExecute Variant vCommandBarControl
79630>                        Runprogram Shell Background "https://www.rdctools.com/HTMLHelpDFRefactor/DFRefactor - Automated Code Refactoring for DataFlex.html"
79631>                    End_Procedure
79632>
79632>                End_Object
79633>
79633>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
79635>                    Set psCaption to "Check for Updates"
79636>                    Set psDescription to "Check for Updates..."
79637>                    Set psImage to "InternetUpdate.ico"
79638>                    Set pbControlBeginGroup to True
79639>                    
79639>                    Procedure OnExecute Variant vCommandBarControl
79642>                        String sPath sUpdateProgram sParam sFolder
79642>                        
79642>                        // The updater.exe program is located in the home folder:
79642>                        Get psHome of (phoWorkspace(ghoApplication)) to sPath
79643>                        Get vFolderFormat sPath to sPath
79644>                        Move "updater.exe" to sUpdateProgram
79645>                        Move "/checknow"   to sParam
79646>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
79647>                    End_Procedure
79648>
79648>                    Function RemoveFolderDelimiter String sPath Returns String
79651>                        String sDirSep
79651>                        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79652>                        Move (Trim(sPath)) to sPath
79653>                        If (Right(sPath, 1) = sDirSep) Begin
79655>                            Move (Left(sPath, (Length(sPath) -1))) to sPath
79656>                        End
79656>                        Function_Return sPath
79657>                    End_Function
79658>
79658>                End_Object
79659>                
79659>            End_Object
79660>
79660>            Object oExitMenuItem is a cCJExitMenuItem
79662>                Set psImage to "ActionExit.ico"
79663>                Set psToolTip to "Exit"
79664>                Set psDescription to "Exit the program (Alt+F4)"
79665>                Set pbControlBeginGroup to True
79666>            End_Object
79667>
79667>        End_Object
79668>
79668>        Object oStatusBar is a cCJStatusBar
79670>            Set StatusBar_Id to Self
79671>
79671>            Object oStatusPane1 is a cCJStatusBarPane
79673>                Set piID to sbpIDIdlePane
79674>                Set pbStyleStretch to True
79675>            End_Object
79676>
79676>            Object oStatusPane2 is a cCJStatusBarPane
79678>                Set phoViewPane to Self
79679>                Set pbStyleStretch to True
79680>            End_Object
79681>
79681>            Object oStatusPane3 is a cCJStatusBarPane
79683>                Set psText to "Current Action:"
79684>            End_Object
79685>
79685>            Object oNumberOfLines_StatusbarPane is a cCJStatusBarPane
79687>                Set psText to "No of Lines:"
79688>            End_Object
79689>
79689>            Object oNumberOfCharacters_StatusbarPane is a cCJStatusBarPane
79691>                Set psText to "Characters:"
79692>            End_Object
79693>
79693>            Procedure Set NumberOfEditorLines String sText
79696>                Move (FormatValue(sText, ",###")) to sText
79697>                Set psText of oNumberOfLines_StatusbarPane to ("No of Lines:" * String(sText))
79698>            End_Procedure
79699>
79699>            Procedure Set NumberOfEditorCharacters String sText
79702>                Move (FormatValue(sText, ",###")) to sText
79703>                Set psText of oNumberOfCharacters_StatusbarPane to ("Characters:" * String(sText))
79704>            End_Procedure
79705>
79705>            Procedure Set ActionText String sText
79708>                Handle hoViewPane
79708>                Get phoViewPane to hoViewPane
79709>                Set psText of hoViewPane to sText
79710>            End_Procedure
79711>
79711>        End_Object
79712>
79712>    End_Object
79713>
79713>    Object oClientArea is a ClientArea
79715>        Use Dd_debug.dg
Including file: Dd_debug.dg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dd_debug.dg)
79715>>>// By adding this to any Windows view or application (with a "use DD_Debug.dg") you can
79715>>>// inspect your DDOs and make sure they are doing what you think. To invoke this panel you
79715>>>// need to press ctrl/d (or send DebugDDs).
79715>>>//
79715>>>// As of 9.1, this also tests for sending reentrant messages to the DDO when the DDO is busy.
79715>>>// Normally, these messages are ignored - now you get an error message (so you can fix it).
79715>>>// Also, you can set a limit for number of filtered records so you can see if you are using
79715>>>// optimized and non-optimized indexes the way you think you are.
79715>>>//
79715>>>// NOTE: This package should NEVER appear in a deployed application. It is just for your
79715>>>//       own development and testing.
79715>>>
79715>>>Define CR_LF for (Character(13)+Character(10))
79715>>>
79715>>>// This provides support for DDO Rentancy checking and for testing for
79715>>>// non-optimal finding.
79715>>>Use DD_OperationChecker.pkg
Including file: dd_OperationChecker.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dd_OperationChecker.pkg)
79715>>>>>// One of the harder DDO errors to see is the issue of reentrancy. A number of the DDO operations are not
79715>>>>>// reentrant. When a message such as Request_Save, Request_find or Clear is sent to a DDO all DDOs are considered
79715>>>>>// to be "busy" until the operationis complete. While DDOs are busy you can not send messages to ANY other DDO in
79715>>>>>// ANY other part of your application. The file structure of DDOs and the the C structure of DDOs do not allow this.
79715>>>>>// If you do send a reentrant message while the DDOs are busy the reentrant message is ignored. Here lies the problem.
79715>>>>>// You are trying to perform some kind of DDO customization and some of these customized behaviors are ignored without
79715>>>>>// any kind of warning or error.
79715>>>>>//
79715>>>>>// The following DDO messages are non re-entrant. While any of these methods are being processed you cannot send any of these
79715>>>>>// messages to any DDOs.
79715>>>>>//
79715>>>>>//     Clear
79715>>>>>//     Clear_All
79715>>>>>//     Request_save
79715>>>>>//     Request_delete
79715>>>>>//     Request_assign
79715>>>>>//     Request_find
79715>>>>>//     Request_Superfind
79715>>>>>//     Find_by_recnum
79715>>>>>//
79715>>>>>//
79715>>>>>// This package provides diagnostic code that checks these messages and makes sure that are not trying to call them in a busy state.
79715>>>>>// Instead of the busy operation being ignored, an error will be reported. Once you see the error, you can fix it.
79715>>>>>//
79715>>>>>// In addition, there is a check built in here for non-optimal finding operations. You can set the value of giNonOptimalFindCount
79715>>>>>// to a non zero value and when a find operation filters that many recods, you will get an error.
79715>>>>>//
79715>>>>>// IMPORTANT: This is a debug package and should never be used in deployed applications. It should be used by the developer
79715>>>>>// to test their application. Once tested, the code should be removed.
79715>>>>>//
79715>>>>>// To Use
79715>>>>>//
79715>>>>>// This is used as part of DD_Debug.dg. While this could be used stand-alone you really don't want to do this.
79715>>>>>//
79715>>>>>// NOTE: This can only be used with VDF9.1 or above. If you try to use this with older packages this will not compile!
79715>>>>>
79715>>>>>Use Data_set.pkg
79715>>>>>
79715>>>>>// This variable determines of the rentrancy tests should be performed. dd_debug will use and set this
79715>>>>>Global_Variable Integer gbTestRentrancy
79715>>>>>Move 1 to gbTestRentrancy
79716>>>>>
79716>>>>>// This determines how many failed finds is considered to be non-optimal. When 0, there is no check.
79716>>>>>Global_Variable Integer giNonOptimalFindCount
79716>>>>>Move 0 to giNonOptimalFindCount
79717>>>>>
79717>>>>>Procedure CheckRentrancy for DataSet Handle hoDD String sMessage
79719>>>>>    String sMess sVal
79719>>>>>    
79719>>>>>    If (gbTestRentrancy=0 or operation_mode=mode_waiting) ;        Procedure_Return
79722>>>>>    
79722>>>>>    If (OPERATION_MODE=MODE_VALIDATING and Lowercase(sMessage)<>"request_save") Begin
79724>>>>>        // mode_validating is not really a non-reentrant DD function from the runtime's point of view. The DDs
79724>>>>>        // keep track of this mode. Therefore, we will let a re-entrant DD message pass through for all cases, except
79724>>>>>        // request_save because trying to perform a save while inside of a validate is most likely wrong.
79724>>>>>        Procedure_Return
79725>>>>>    End
79725>>>>>>
79725>>>>>    
79725>>>>>    Move ("DDO re-entrant operation attempted.\n\n"+;        "Message = " - sMessage - ".  Object =" - name(hoDD) -".\n"+ ;        "\nCurrent Operation_mode is " + String(operation_mode) +;        "\nCurrent Operation_origin is " + String(operation_origin) * name(operation_origin) ) to sMess
79726>>>>>    Error DFERR_PROGRAM sMess
79727>>>>>>
79727>>>>>End_Procedure
79728>>>>>
79728>>>>>Procedure NonOptimalTest for DataSet  Handle hoDD String sMessage Integer iOldDif Integer iFile Integer iIndex
79730>>>>>    String sMess
79730>>>>>    Integer iNewDif
79730>>>>>    
79730>>>>>    Move (constrain_tests_count - Constrain_found_count) to iNewDif
79731>>>>>    If (iNewDif-iOldDif>giNonOptimalFindCount) Begin
79733>>>>>        Move ("Constrained Find may not be Optimized.\n\n"+;            "Message =" - sMessage - ".  Object = " - name(hoDD) -".\n"+ ;            "Test finds exceeds the limit of" * String(giNonOptimalFindCount) * "filtered records.\n" +;            "Number of records searched = " + String(iNewDif-iOldDif) + ".") to sMess
79734>>>>>        If (iFile>0) Begin
79736>>>>>            // if iFile is zero we don't don't which file is being found (i.e. Locate_next)
79736>>>>>            Move (sMess + "\nFile = " + String(iFile) + ". Index = "+ String(iIndex) + ".") to sMess
79737>>>>>        End
79737>>>>>>
79737>>>>>        Error DFERR_PROGRAM sMess
79738>>>>>>
79738>>>>>    End
79738>>>>>>
79738>>>>>End_Procedure
79739>>>>>
79739>>>>>
79739>>>>>Procedure Clear for DataSet
79741>>>>>    Send CheckRentrancy Self "clear"
79742>>>>>    Forward Send Clear
79744>>>>>End_Procedure
79745>>>>>
79745>>>>>Procedure Clear_All for DataSet
79747>>>>>    Send CheckRentrancy Self "clear_all"
79748>>>>>    Forward Send clear_all
79750>>>>>End_Procedure
79751>>>>>
79751>>>>>Procedure Request_Save for DataSet
79753>>>>>    Send CheckRentrancy Self "request_save"
79754>>>>>    Forward Send request_save
79756>>>>>End_Procedure
79757>>>>>
79757>>>>>Procedure Request_Delete for DataSet
79759>>>>>    Send CheckRentrancy Self "request_delete"
79760>>>>>    Forward Send request_delete
79762>>>>>End_Procedure
79763>>>>>
79763>>>>>Procedure Request_Assign for DataSet Integer iFile
79765>>>>>    Send CheckRentrancy Self "request_assign"
79766>>>>>    If (num_arguments=0) ;        Forward Send request_assign
79770>>>>>    Else ;        Forward Send request_assign iFile
79773>>>>>End_Procedure
79774>>>>>
79774>>>>>Procedure Find_By_Recnum for DataSet Integer iFile Integer iRecord
79776>>>>>    Send CheckRentrancy Self "Find_by_recnum"
79777>>>>>    Forward Send Find_by_recnum iFile iRecord
79779>>>>>End_Procedure
79780>>>>>
79780>>>>>Procedure Request_Find for DataSet Integer iMode Integer iFile Integer iIndex
79782>>>>>    Integer iOldDif
79782>>>>>    Send CheckRentrancy Self "request_find"
79783>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
79784>>>>>    Forward Send request_find iMode iFile iIndex
79786>>>>>    If (giNonOptimalFindCount>0) Begin
79788>>>>>        Send NonOptimalTest Self "request_find" iOldDif iFile iIndex
79789>>>>>    End
79789>>>>>>
79789>>>>>End_Procedure
79790>>>>>
79790>>>>>Procedure Request_Read for DataSet Integer iMode Integer iFile Integer iIndex
79792>>>>>    Integer iOldDif
79792>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
79793>>>>>    Forward Send request_Read iMode iFile iIndex
79795>>>>>    If (giNonOptimalFindCount>0) Begin
79797>>>>>        Send NonOptimalTest  Self "request_read" iOldDif iFile iIndex
79798>>>>>    End
79798>>>>>>
79798>>>>>End_Procedure
79799>>>>>
79799>>>>>
79799>>>>>Procedure Request_Superfind for DataSet Integer iMode Integer iFile Integer iField
79801>>>>>    Integer iOldDif
79801>>>>>    Send CheckRentrancy Self "request_Superfind"
79802>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
79803>>>>>    Forward Send Request_Superfind iMode iFile iField
79805>>>>>    If (giNonOptimalFindCount>0) Begin
79807>>>>>        Send NonOptimalTest  Self "request_Superfind" iOldDif 0 0 // we don't have a file or an index
79808>>>>>    End
79808>>>>>>
79808>>>>>End_Procedure
79809>>>
79809>>>Procedure EnumerateDDs for DataDictionary Integer iMsg Handle hId
79811>>>    Send iMsg of hID Self
79812>>>End_Procedure
79813>>>
79813>>>Use Windows.pkg
79813>>>Use DataDict.pkg
79813>>>Use cTextEdit.pkg
79813>>>
79813>>>Class cDDDebugResults is a cTextEdit
79814>>>    Procedure Construct_Object
79816>>>        Forward Send Construct_Object
79818>>>        
79818>>>        Set peAnchors to anAll
79819>>>        Set pbWrap to False
79820>>>        Set Read_Only_State to True
79821>>>        Set psTypeface to "Courier New"
79822>>>        Set FontPointHeight to 9
79823>>>        
79823>>>        Property String psEditValue ''
79824>>>    End_Procedure
79825>>>    
79825>>>    Procedure Delete_Data
79827>>>        Forward Send Delete_Data
79829>>>        
79829>>>        Set psEditValue to ''
79830>>>    End_Procedure
79831>>>    
79831>>>    Procedure Page Integer iPageObject
79833>>>        String sEditValue
79833>>>        
79833>>>        Forward Send Page iPageObject
79835>>>        If (iPageObject > 0) Begin
79837>>>            Get psEditValue to sEditValue
79838>>>            Set Value to sEditValue
79839>>>        End
79839>>>>
79839>>>    End_Procedure
79840>>>    
79840>>>    Procedure Insert String sVal
79842>>>        Handle hWnd
79842>>>        String sEditValue
79842>>>        
79842>>>        Get Window_Handle to hWnd
79843>>>        If (hWnd <> 0) Begin
79845>>>            Send AppendText sVal
79846>>>        End
79846>>>>
79846>>>        Else Begin
79847>>>            Get psEditValue to sEditValue
79848>>>            Move (sEditValue + sVal) to sEditValue
79849>>>            Set psEditValue to sEditValue
79850>>>        End
79850>>>>
79850>>>    End_Procedure
79851>>>End_Class
79852>>>
79852>>>Object oDD_Debug is a ModalPanel
79854>>>    
79854>>>    Property Handle phoInvokingView    0
79856>>>    Property Handle phoCurrentDD       0
79858>>>    Property Handle phoFieldsEditId    0
79860>>>    Property Handle phoMiscEditId      0
79862>>>    Property Handle phoConstraintsEditId      0
79864>>>    
79864>>>    Set Locate_mode to Center_on_screen
79865>>>    Set Border_Style to Border_Thick
79866>>>    
79866>>>    On_Key kCancel Send Close_Panel
79867>>>    
79867>>>    Function IsRecnumTable Integer iFile Returns Boolean
79870>>>        Boolean bRecnumTable
79870>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFIle to bRecnumTable
79873>>>        Function_Return bRecnumTable
79874>>>    End_Function
79875>>>    
79875>>>    Set Minimize_Icon to False
79876>>>    Set Label to "Data Dictionary Inspector"
79877>>>    Set Location to 4 3
79878>>>    Set Size to 263 410
79879>>>    
79879>>>    Object oDDCombo is a ComboForm
79881>>>        
79881>>>        Set Label to "DD:"
79882>>>        Set Size to 12 103
79883>>>        Set Location to 6 19
79884>>>        Set Form_Border to 0
79885>>>        Set Label_Col_Offset to 2
79886>>>        Set Label_Justification_Mode to jMode_Right
79887>>>        
79887>>>        Set entry_state 0 to False
79888>>>        Set combo_sort_state to False
79889>>>        Set peAnchors to anNone
79890>>>        
79890>>>        Procedure AddDDs Handle hDD
79893>>>            Integer iCnt
79893>>>            String sName
79893>>>            Get Combo_Item_Count to iCnt
79894>>>            Get Object_label of hDD to sName
79895>>>            Send Combo_Add_Item sName
79896>>>            Set Aux_Value of (combo_data_object(Self)) iCnt to hDD
79897>>>            If (hDD=phoCurrentDD(Self)) ;                Set Value 0 to sName
79900>>>        End_Procedure
79901>>>        
79901>>>        Procedure Fill_List
79904>>>            Handle hVw
79904>>>            Get phoInvokingView to hVw
79905>>>            Send Combo_Delete_Data
79906>>>            Broadcast Send EnumerateDDs to hVw msg_AddDDs Self
79908>>>            //Set Value 0 to (Combo_value(self,0))
79908>>>            Send onChange
79909>>>        End_Procedure
79910>>>        
79910>>>        
79910>>>        Procedure onChange
79913>>>            Integer iItem hDD
79913>>>            Get combo_item_matching (value(Self,0)) to iItem
79914>>>            If (iItem>=0) Begin
79916>>>                Get Aux_Value of (combo_data_object(Self)) iItem to hDD
79917>>>                Delegate Set phoCurrentDD to hDD
79919>>>                Delegate Send RefreshNewDD
79921>>>            End
79921>>>>
79921>>>        End_Procedure
79922>>>        
79922>>>    End_Object
79923>>>    
79923>>>    Object oCurRec is a Form
79925>>>        
79925>>>        Set Label to "Current Rec"
79926>>>        Set Size to 12 37
79927>>>        Set Location to 6 165
79928>>>        Set Label_Col_Offset to 2
79929>>>        Set Label_Justification_Mode to jMode_Right
79930>>>        
79930>>>        Set numeric_mask 0 to 8 0
79931>>>        Set peAnchors to anNone
79932>>>        
79932>>>        Procedure NewRec // note that this is never used.
79935>>>            Integer iRec iFile hDD
79935>>>            Get phoCurrentDD to hDD
79936>>>            If hDD Begin
79938>>>                Get value 0 to iRec
79939>>>                Get Main_file of hDD to iFile
79940>>>                Set_Field_Value iFile 0 to iRec  // compatibility w/ recnum
79943>>>                Send Find of hDD EQ 0
79944>>>                Send refreshAll
79945>>>            End
79945>>>>
79945>>>        End_Procedure
79946>>>        
79946>>>    End_Object
79947>>>    
79947>>>    Object oFindCurRec is a Button
79949>>>        
79949>>>        Set Label to "Find"
79950>>>        Set Size to 12 20
79951>>>        Set Location to 6 205
79952>>>        Set peAnchors to anNone
79953>>>        
79953>>>        Procedure OnClick
79956>>>            Integer iRec iFile hDD
79956>>>            Get phoCurrentDD to hDD
79957>>>            If hDD Begin
79959>>>                Get Main_file of hDD to iFile
79960>>>                If (IsRecnumTable(Self,iFile)) Begin
79962>>>                    Get value of oCurRec 0 to iRec
79963>>>                    Set_Field_Value iFile 0 to iRec // compatibility w/ recnum
79966>>>                    Send Find of hDD EQ 0
79967>>>                    Send refreshAll
79968>>>                End
79968>>>>
79968>>>            End
79968>>>>
79968>>>        End_Procedure
79969>>>        
79969>>>    End_Object
79970>>>    
79970>>>    Object oDDRelatesTo is a ComboForm
79972>>>        
79972>>>        
79972>>>        Set Label to "Related To File:"
79973>>>        Set Size to 12 117
79974>>>        Set Location to 6 281
79975>>>        Set Form_Border to 0
79976>>>        Set Label_Col_Offset to 2
79977>>>        Set Label_Justification_Mode to jMode_Right
79978>>>        
79978>>>        Set entry_state 0 to False
79979>>>        Set combo_sort_state to False
79980>>>        Set peAnchors to anNone
79981>>>        
79981>>>        Procedure Fill_List
79984>>>            Integer iCnt iLmt iFile hCDO iCFile
79984>>>            Handle hDD
79984>>>            String sName
79984>>>            Send Combo_Delete_Data
79985>>>            Get phoCurrentDD to hDD
79986>>>            If (hDD = 0) ;                Procedure_Return
79989>>>            Get Constrain_file of hDD to iCFile
79990>>>            Get Combo_data_object to hCDO
79991>>>            Move (server_file_count(hDD)-1) to iLmt
79992>>>            Send Combo_add_item "None"
79993>>>            Set Aux_Value of hCDO 0 to iFile
79994>>>            If (iCFile = 0) ;                Set Value 0 to "None"
79997>>>            For iCnt from 0 to iLmt
80003>>>>
80003>>>                Get Server_File of hDD iCnt to iFile
80004>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
80007>>>                Send Combo_add_item sName
80008>>>                Set Aux_Value of hCDO (iCnt+1) to iFile
80009>>>                If (iFile = iCFile) ;                    Set Value 0 to sName
80012>>>            Loop
80013>>>>
80013>>>            
80013>>>        End_Procedure
80014>>>        
80014>>>        
80014>>>        Procedure onChange
80017>>>            Integer iItem iFile hDD
80017>>>            Get phoCurrentDD to hDD
80018>>>            If (hDD=0) ;                Procedure_Return
80021>>>            Get combo_item_matching (value(Self,0)) to iItem
80022>>>            If (iItem>=0) Begin
80024>>>                Get Aux_Value of (combo_data_object(Self)) iItem to iFile
80025>>>                Set constrain_file of hDD to iFile
80026>>>                Send RebuildAllConstraints of hDD
80027>>>                Delegate Send RefreshAll
80029>>>            End
80029>>>>
80029>>>        End_Procedure
80030>>>        
80030>>>    End_Object
80031>>>    
80031>>>    Object oShouldSave is a CheckBox
80033>>>        
80033>>>        Set enabled_state to False
80034>>>        
80034>>>        
80034>>>        Set Label to "Should Save"
80035>>>        Set Size to 10 55
80036>>>        Set Location to 22 5
80037>>>        Set peAnchors to anNone
80038>>>        
80038>>>        
80038>>>        
80038>>>    End_Object
80039>>>    
80039>>>    Object oChangedState is a CheckBox
80041>>>        
80041>>>        Set enabled_state to False
80042>>>        
80042>>>        
80042>>>        Set Label to "Changed State"
80043>>>        Set Size to 10 60
80044>>>        Set Location to 22 64
80045>>>        Set peAnchors to anNone
80046>>>        
80046>>>        
80046>>>        
80046>>>    End_Object
80047>>>    
80047>>>    Object oAutoFill is a CheckBox
80049>>>        Set Label to "Auto-Fill"
80050>>>        Set Size to 10 41
80051>>>        Set Location to 22 128
80052>>>        Set peAnchors to anNone
80053>>>        
80053>>>        Procedure Select_Toggling Integer iItm Integer bState
80056>>>            Forward Send select_toggling iItm bState
80058>>>            Set auto_fill_state of (phoCurrentDD(Self)) to (checked_state(Self))
80059>>>        End_Procedure
80060>>>        
80060>>>    End_Object
80061>>>    
80061>>>    Object oFillFromTop is a CheckBox
80063>>>        Set Label to "First-Rec Auto-fill"
80064>>>        Set Size to 10 71
80065>>>        Set Location to 22 172
80066>>>        Set peAnchors to anNone
80067>>>        
80067>>>        Procedure Select_Toggling Integer iItm Integer bState
80070>>>            Forward Send select_toggling iItm bState
80072>>>            Set pbAutoFillFromFirst of (phoCurrentDD(Self)) to (checked_state(Self))
80073>>>        End_Procedure
80074>>>        
80074>>>    End_Object
80075>>>    
80075>>>    Object oDDOrdering is a ComboForm
80077>>>        Set Label to "Ordering"
80078>>>        Set Size to 12 117
80079>>>        Set Location to 20 281
80080>>>        Set Form_Border to 0
80081>>>        Set Label_Col_Offset to 2
80082>>>        Set Label_Justification_Mode to jMode_Right
80083>>>        
80083>>>        Set entry_state 0 to False
80084>>>        Set combo_sort_state to False
80085>>>        Set peAnchors to anNone
80086>>>        
80086>>>        Procedure RefreshNewDD
80089>>>            Handle hDD
80089>>>            Integer iFile iSegs iNdxs i
80089>>>            Send Combo_Delete_Data
80090>>>            Get phoCurrentDD to hDD
80091>>>            If hDD Begin
80093>>>                Send Combo_Add_Item "Best.-1"
80094>>>                Send Combo_Add_Item "Index.0"
80095>>>                Get Main_file of hDD to iFile
80096>>>                Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
80099>>>                For i from 1 to iNdxs
80105>>>>
80105>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
80108>>>                    If iSegs ;                        Send Combo_Add_Item ("Index."-String(i))
80111>>>                Loop
80112>>>>
80112>>>            End
80112>>>>
80112>>>        End_Procedure
80113>>>        
80113>>>        Procedure Set Ordering Integer iOrdr
80116>>>            If (iOrdr = -1) ;                Set Value 0 to "Best.-1"
80119>>>            Else ;                Set Value 0 to ("Index."-String(iOrdr))
80121>>>        End_Procedure
80122>>>        
80122>>>        Procedure OnChange
80125>>>            Handle hDD
80125>>>            String sVal
80125>>>            Get value 0 to sVal
80126>>>            Get phoCurrentDD to hDD
80127>>>            If hDD ;                Set Ordering of hDD to (mid(sVal, 10, pos(".",sVal)+1))
80130>>>        End_Procedure
80131>>>        
80131>>>    End_Object
80132>>>    
80132>>>    
80132>>>    Object oTD is a TabDialog
80134>>>        Set Size to 149 389
80135>>>        Set Location to 33 11
80136>>>        Set Rotate_Mode to RM_Rotate
80137>>>        Set peAnchors to anAll
80138>>>        
80138>>>        Object oTP_Constraints is a TabPage
80140>>>            Set Label to "Constraints"
80141>>>            Set Tab_ToolTip_Value to "DD Constraints and Filters"
80142>>>            Delegate Set phoConstraintsEditId to Self
80144>>>            
80144>>>            Object oConstraintsEdit is a cDDDebugResults
80146>>>                Function FormatFileFieldName Integer iFile Integer iField Returns String
80149>>>                    String sFile sField sRet
80149>>>                    Boolean bOpen
80149>>>                    Get_Attribute DF_FILE_OPENED of iFile to bOpen
80152>>>                    If (bOpen) Begin
80154>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sFile
80157>>>                        Get_Attribute DF_FIELD_NAME of iFile iField to sField
80160>>>                        Function_Return (sFile+"."+sField)
80161>>>                    End
80161>>>>
80161>>>                    Else Begin
80162>>>                        Function_Return "file not open"
80163>>>                    End
80163>>>>
80163>>>                End_Function
80164>>>                
80164>>>                Procedure ShowDDOConstraints Handle hoDD
80167>>>                    Integer i j iMain iCurrentDDFile
80167>>>                    tConstraintDef[] Constraints
80167>>>                    tConstraintDef[] Constraints
80168>>>                    String sFilter
80168>>>                    Handle hoDDOther
80168>>>                    
80168>>>                    Get Main_File of hoDD to iMain
80169>>>                    Get DDOConstraints of  hoDD to Constraints
80170>>>                    
80170>>>                    Send Insert "Current DDO Constraints"
80171>>>                    Send Insert CR_LF
80172>>>                    Send Insert ("  Number of Constraints = " + String(SizeOfArray(Constraints)))
80173>>>                    Send Insert CR_LF
80174>>>                    
80174>>>                    For i from 0 to (SizeOfArray(Constraints)-1)
80180>>>>
80180>>>                        If (iCurrentDDFile<>Constraints[i].iFile) Begin
80182>>>                            Send Insert CR_LF
80183>>>                            Move Constraints[i].iFile to iCurrentDDFile
80184>>>                            If (Constraints[i].iFile<>iMain) Begin
80186>>>                                Get Which_Data_Set of hoDD Constraints[i].iFile to hoDDOther
80187>>>                            End
80187>>>>
80187>>>                            Else Begin
80188>>>                                Move hoDD to hoDDOther
80189>>>                            End
80189>>>>
80189>>>                            Send Insert  ("Constraints from ")
80190>>>                            
80190>>>                            If (hoDDOther) Begin
80192>>>                                Send Insert  (Object_Label(hoDDOther))
80193>>>                            End
80193>>>>
80193>>>                            Else Begin
80194>>>                                // not sure this could ever happen
80194>>>                                Send Insert  ("unknown. No DDO for file "+String(Constraints[i].iFile))
80195>>>                            End
80195>>>>
80195>>>                            
80195>>>                            If (hoDD<>hoDDOther) Begin
80197>>>                                Send Insert " (inherited)"
80198>>>                            End
80198>>>>
80198>>>                            
80198>>>                            Send Insert CR_LF
80199>>>                        End
80199>>>>
80199>>>                        
80199>>>                        
80199>>>                        Send Insert ("  " +String(i+1) + " Type=")
80200>>>                        Case Begin
80200>>>                            Case (Constraints[i].eType=CONST_VALUE) ;                                    Send Insert "CONST_VALUE"
80203>>>                            Case (Constraints[i].eType=CONST_CHILD) ;                                    Send Insert "CONST_CHILD"
80207>>>                            Case (Constraints[i].eType=CONST_FIELD) ;                                    Send Insert "CONST_FIELD"
80211>>>                            Case (Constraints[i].eType=CONST_EXP) ;                                    Send Insert "CONST_EXP"
80215>>>                            Case (Constraints[i].eType=CONST_RELATES) ;                                    Send Insert "CONST_RELATES"
80219>>>                        Case End
80219>>>                        
80219>>>                        If (Constraints[i].eType=CONST_VALUE or Constraints[i].eType=CONST_FIELD) Begin
80221>>>                            Send Insert " mode="
80222>>>                            Case Begin
80222>>>                                Case (Constraints[i].eMODE=CONST_LT) ;                                        Send Insert "LT"
80225>>>                                Case (Constraints[i].eMODE=CONST_LE) ;                                        Send Insert "LE"
80229>>>                                Case (Constraints[i].eMODE=CONST_EQ) ;                                        Send Insert "EQ"
80233>>>                                Case (Constraints[i].eMODE=CONST_GE) ;                                        Send Insert "GE"
80237>>>                                Case (Constraints[i].eMODE=CONST_GT) ;                                        Send Insert "GT"
80241>>>                                Case (Constraints[i].eMODE=CONST_NE) ;                                        Send Insert "NE"
80245>>>                                Case (Constraints[i].eMODE=CONST_Matches) ;                                        Send Insert "matches"
80249>>>                            Case End
80249>>>                        End
80249>>>>
80249>>>                        If (Constraints[i].eType<>CONST_EXP) Begin
80251>>>                            Send Insert (" File.Field=" + String(Constraints[i].iFile))
80252>>>                            Send Insert ("."  + String(Constraints[i].iField))
80253>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iFile,Constraints[i].iField)+")")
80254>>>                        End
80254>>>>
80254>>>                        If (Constraints[i].eType=CONST_CHILD or Constraints[i].eType=CONST_FIELD) Begin
80256>>>                            Send Insert (" Other File.Field="  + String(Constraints[i].iOtherFile))
80257>>>                            Send Insert ("."  + String(Constraints[i].iOtherField))
80258>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iOtherFile,Constraints[i].iOtherField)+")")
80259>>>                        End
80259>>>>
80259>>>                        Else If (Constraints[i].eType=CONST_VALUE) Begin
80262>>>                            Send Insert  (" Value=" + String(Constraints[i].sValue))
80263>>>                        End
80263>>>>
80263>>>                        Send Insert CR_LF
80264>>>                    Loop
80265>>>>
80265>>>                    
80265>>>                    Send Insert CR_LF
80266>>>                    
80266>>>                    Send ShowIndices hoDD
80267>>>                    
80267>>>                    
80267>>>                End_Procedure
80268>>>                
80268>>>                Procedure ShowIndices Handle hoDD
80271>>>                    
80271>>>                    Integer iLastIndex
80271>>>                    Integer iIndex i
80271>>>                    Integer iNumSegments
80271>>>                    Handle  hTable
80271>>>                    tDDOConstraintFindMeta FindMeta
80271>>>                    tDDOConstraintFindMeta FindMeta
80271>>>                    Get Main_File of hoDD to hTable
80272>>>                    
80272>>>                    Send Insert CR_LF
80273>>>                    Send Insert "Indexes and Constraints"
80274>>>                    Send Insert CR_LF
80275>>>                    
80275>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
80278>>>                    For iIndex from 1 to iLastIndex
80284>>>>
80284>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
80287>>>                        If (iNumSegments > 0) Begin
80289>>>                            
80289>>>                            Get DDOConstraintFindMeta of hoDD (GE) iIndex to FindMeta
80290>>>                            
80290>>>                            Send Insert ("    Index " + String(iIndex)+": ")
80291>>>                            If (FindMeta.iJumpInSegments>0 or FindMeta.bJumpOut or FindMeta.bPreRelate or FindMeta.bPostRelate) Begin
80293>>>                                Send Insert ( "Jumpin "+String(FindMeta.iJumpInSegments)+" of "+String(iNumSegments)+". " )
80294>>>                                Send Insert ( (If(FindMeta.bJumpOut,"JumpOut. ", "")) + (If(FindMeta.bPreRelate,"Pre-Relate. ", "")) + (If(FindMeta.bPostRelate,"Post-Relate. ", "")) )
80295>>>                            End
80295>>>>
80295>>>                            Else Begin
80296>>>                                Send Insert "No Constraints"
80297>>>                            End
80297>>>>
80297>>>                            Send Insert CR_LF
80298>>>                        End
80298>>>>
80298>>>                    Loop
80299>>>>
80299>>>                End_Procedure
80300>>>                
80300>>>                Procedure RefreshAll
80303>>>                    Handle hDD
80303>>>                    Get phoCurrentDD to hDD
80304>>>                    Set Dynamic_update_state to False
80305>>>                    Send Delete_Data
80306>>>                    If (hDD) Begin
80308>>>                        Send ShowDDOConstraints hDD
80309>>>                    End
80309>>>>
80309>>>                    Send Beginning_Of_Data
80310>>>                    Set Dynamic_update_state to True
80311>>>                End_Procedure
80312>>>                
80312>>>                
80312>>>                
80312>>>                Set Size to 100 375
80313>>>                Set Location to 4 4
80314>>>                
80314>>>                
80314>>>                
80314>>>            End_Object
80315>>>            
80315>>>            Object oSQLFilterCkBox is a CheckBox
80317>>>                Set Size to 10 50
80318>>>                Set Location to 122 4
80319>>>                Set Label to "Use SQL Filter"
80320>>>                Set peAnchors to anBottom
80321>>>                
80321>>>                Procedure Select_Toggling Integer iItm Integer bState
80324>>>                    Handle hoDDO
80324>>>                    Boolean bFilter
80324>>>                    Get phoCurrentDD to hoDDO
80325>>>                    Forward Send select_toggling iItm bState
80327>>>                    Get Checked_State to bFilter
80328>>>                    Set pbUseDDSQLFilters of hoDDO to bFilter
80329>>>                    Send ApplySQLFilterInfo
80330>>>                End_Procedure
80331>>>                
80331>>>            End_Object
80332>>>            
80332>>>            Object oInherit is a CheckBox
80334>>>                Set Label to "Inherit Constraints"
80335>>>                Set Size to 10 69
80336>>>                Set Location to 107 4
80337>>>                Set peAnchors to anBottomLeft
80338>>>                
80338>>>                Procedure Select_Toggling Integer iItm Integer bState
80341>>>                    Handle hDD
80341>>>                    Get phoCurrentDD to hDD
80342>>>                    Forward Send select_toggling iItm bState
80344>>>                    Set pbInheritConstraints of hDD to (checked_state(Self))
80345>>>                    If (hDD>0) Begin
80347>>>                        Send RebuildAllConstraints of hDD
80348>>>                        Send RefreshAll
80349>>>                    End
80349>>>>
80349>>>                End_Procedure
80350>>>                
80350>>>            End_Object
80351>>>            
80351>>>            Object oSQLFilter is a Form
80353>>>                Set Size to 12 316
80354>>>                Set Location to 120 63
80355>>>                Set peAnchors to anBottomLeftRight
80356>>>                Procedure OnChange
80359>>>                    Handle hoDDO
80359>>>                    String sValue
80359>>>                    Get phoCurrentDD to hoDDO
80360>>>                    Get Value to sValue
80361>>>                    Set psSQLFilter of hoDDO to sValue
80362>>>                End_Procedure
80363>>>            End_Object
80364>>>            
80364>>>            Procedure ApplySQLFilterInfo
80367>>>                Integer iValue
80367>>>                Boolean bFilter bAllowed
80367>>>                Handle hoDDO
80367>>>                String sFilter
80367>>>                
80367>>>                Get phoCurrentDD to hoDDO
80368>>>                Get SupportsSQLFilters of hoDDO to bAllowed
80369>>>                Set Enabled_state of oSQLFilterCkBox to bAllowed
80370>>>                Get pbUseDDSQLFilters of hoDDO to bFilter
80371>>>                Get psSQLFilter of hoDDO to sFilter
80372>>>                Set Checked_State of oSQLFilterCkBox to bFilter
80373>>>                Set Enabled_state of oSQLFilter to bFilter
80374>>>                Set Value of oSQLFilter to sFilter
80375>>>            End_Procedure
80376>>>            
80376>>>            Procedure RefreshAll
80379>>>                Send RefreshAll of oConstraintsEdit
80380>>>                Send ApplySQLFilterInfo
80381>>>            End_Procedure
80382>>>        End_Object
80383>>>        Object oTP_Field_Values is a TabPage
80385>>>            Set Label to "Field Values"
80386>>>            Set Tab_ToolTip_Value to "DD Field Values"
80387>>>            Object oFieldsEdit is a cDDDebugResults
80389>>>                Delegate Set phoFieldsEditId to Self
80391>>>                
80391>>>                Set Size to 127 375
80392>>>                Set Location to 4 4
80393>>>                
80393>>>                Procedure RefreshAll
80396>>>                    Handle hDD hRB
80396>>>                    Integer iMax iItem iFile
80396>>>                    Integer iOldErrorReport hOldErr
80396>>>                    String sLine sFieldName sChanged sVld sFrnVld sVal
80396>>>                    
80396>>>                    Get phoCurrentDD to hDD
80397>>>                    Get Record_Buffer of hDD to hRB
80398>>>                    Get main_file of hDD to iFile
80399>>>                    Set Dynamic_update_state to False
80400>>>                    Send Delete_Data
80401>>>                    
80401>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
80402>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
80403>>>                    Move Error_Object_id to hOldErr
80404>>>                    Move hDD to Error_Object_id
80405>>>                    
80405>>>                    // Write the Header
80405>>>                    Send Insert "Field                           Chg Vld FrnVld Value"
80406>>>                    Send Insert CR_LF
80407>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
80408>>>                    Send Insert CR_LF
80409>>>                    
80409>>>                    // Write the bodies for the fields
80409>>>                    Get Item_Count of hRB to iMax
80410>>>                    Decrement iMax
80411>>>                    For iItem from 0 to iMax
80417>>>>
80417>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
80420>>>                        Move (Pad(sFieldName,32)) to sFieldName
80421>>>                        Move (String(Item_Changed_State(hRB, iItem))) to sChanged
80422>>>                        // this will test it as a standard validation
80422>>>                        Move hDD to Operation_Origin
80423>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sVld
80424>>>                        // this will test it as a foreign validation
80424>>>                        Move 0 to Operation_Origin
80425>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sFrnVld
80426>>>                        Move (Field_Current_Value(hDD, iItem)) to sVal
80427>>>                        Move (sFormat("%1 %2   %3   %4     %5", sFieldName, sChanged, sVld, sFrnVld, sVal)) to sLine
80428>>>                        Send Insert sLine
80429>>>                        Send Insert CR_LF
80430>>>                    Loop
80431>>>>
80431>>>                    Send Insert CR_LF
80432>>>                    Send Insert "Existing_Key_Value = "
80433>>>                    Send Insert (Existing_Key_Value(hDD))
80434>>>                    Send Insert CR_LF
80435>>>                    
80435>>>                    Send Beginning_of_Data
80436>>>                    Set Dynamic_update_state to True
80437>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
80438>>>                    Move hOldErr to Error_Object_id
80439>>>                End_Procedure
80440>>>                
80440>>>                
80440>>>            End_Object
80441>>>            
80441>>>        End_Object
80442>>>        
80442>>>        
80442>>>        Object oTP_Misc is a TabPage
80444>>>            Set Label to "Misc"
80445>>>            Set Tab_ToolTip_Value to "Other DD static values"
80446>>>            Object oMiscEdit is a cDDDebugResults
80448>>>                Delegate Set phoMiscEditId to Self
80450>>>                
80450>>>                Procedure RefreshAll
80453>>>                    Handle hDD hRB
80453>>>                    Integer iMax iItem iFile iFIl iObj iOldSt
80453>>>                    Integer iCnt hVw iBase iType iFAObj iOldErrorReport hOldErr iMaster
80453>>>                    String sDummy sView sName sDummy2 sFieldName sType sLine
80453>>>                    Handle hoMaster
80453>>>                    Boolean bSwitched
80453>>>                    
80453>>>                    Get phoInvokingView to hVw
80454>>>                    Get Name of hVw to sView
80455>>>                    
80455>>>                    Get phoCurrentDD to hDD
80456>>>                    Get Record_Buffer    of hDD to hRB
80457>>>                    Get Field_Attributes of hDD to iFAObj
80458>>>                    Get main_file of hDD to iFile
80459>>>                    Set Dynamic_update_state to False
80460>>>                    Send Delete_Data
80461>>>                    
80461>>>                    Send Insert "Current DDO = "
80462>>>                    Send Insert (String(hDD) * "-" * Object_Label(hDD))
80463>>>                    Send Insert CR_LF
80464>>>                    
80464>>>                    Send Insert "Main File = "
80465>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
80468>>>                    Send Insert (String(iFile) * "-" * sName)
80469>>>                    Send Insert CR_LF
80470>>>                    
80470>>>                    
80470>>>                    
80470>>>                    Send Insert "Driver File = "
80471>>>                    Get_Attribute DF_FILE_DRIVER of iFile to sName
80474>>>                    Send Insert sName
80475>>>                    Send Insert CR_LF
80476>>>                    Send Insert CR_LF
80477>>>                    
80477>>>                    // see if this has a master table (i.e., if this DDO is an alias)
80477>>>                    Get MasterForAlias of hDD to iMaster
80478>>>                    If (iMaster<>0) Begin
80480>>>                        Get Data_Set of hDD iMaster to hoMaster
80481>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iMaster to sName
80484>>>                        Send Insert "Alias Table Information"
80485>>>                        Send Insert CR_LF
80486>>>                        Send Insert ("    Master Table: " + String(iMaster) * "-" * sName)
80487>>>                        Send Insert CR_LF
80488>>>                        // it is possible the master is not in this DDO structure. If so
80488>>>                        // this will be treated as a regular table.
80488>>>                        If (hoMaster) Begin
80490>>>                            Send Insert "    Master DDO = "
80491>>>                            Send Insert (String(hoMaster) * "-" * Object_Label(hoMaster))
80492>>>                        End
80492>>>>
80492>>>                        Else Begin
80493>>>                            Send Insert "    ** The master table is not part of the DDO structure"
80494>>>                            Send Insert CR_LF
80495>>>                            Send Insert "       therefore this DDO will be locked as a regular non-alias table."
80496>>>                        End
80496>>>>
80496>>>                        Send Insert CR_LF
80497>>>                        Send Insert CR_LF
80498>>>                    End
80498>>>>
80498>>>                    
80498>>>                    
80498>>>                    
80498>>>                    Send Insert "Current DDO Container = "
80499>>>                    Send Insert (String(hVw) * "-" * Object_Label(hVw) * "(" - sView - ")")
80500>>>                    Send Insert CR_LF
80501>>>                    Send Insert CR_LF
80502>>>                    
80502>>>                    Send Insert "Protect_Key_State = "
80503>>>                    Send Insert (If(Protect_Key_State(hDD),"True","False"))
80504>>>                    Send Insert CR_LF
80505>>>                    
80505>>>                    Send Insert "Cascade_Delete_State = "
80506>>>                    Send Insert (If(Cascade_Delete_State(hDD),"True","False"))
80507>>>                    Send Insert CR_LF
80508>>>                    Send Insert CR_LF
80509>>>                    
80509>>>                    Send Insert "Required Server Files = "
80510>>>                    Send Insert (Server_File_Count(hDD))
80511>>>                    Send Insert CR_LF
80512>>>                    For iCnt from 0 to (Server_File_Count(hDD)-1)
80518>>>>
80518>>>                        Get Server_File of hDD iCnt to iFil
80519>>>                        Send Insert ("     " +String(iFil)+" - ")
80520>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
80523>>>                        Send Insert sDummy
80524>>>                        Send Insert CR_LF
80525>>>                    Loop
80526>>>>
80526>>>                    Send Insert  CR_LF
80527>>>                    
80527>>>                    Send Insert "Required Client Files = "
80528>>>                    Send Insert (Client_File_Count(hDD))
80529>>>                    Send Insert CR_LF
80530>>>                    For iCnt from 0 to (Client_File_Count(hDD)-1)
80536>>>>
80536>>>                        Get Client_File of hDD iCnt to iFil
80537>>>                        Send Insert ("     " +String(iFil)+" - ")
80538>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
80541>>>                        Send Insert sDummy
80542>>>                        Send Insert CR_LF
80543>>>                    Loop
80544>>>>
80544>>>                    Send Insert  CR_LF
80545>>>                    
80545>>>                    Send Insert "Required Other Files = "
80546>>>                    Send Insert (System_File_Count(hDD))
80547>>>                    Send Insert CR_LF
80548>>>                    For iCnt from 0 to (System_File_Count(hDD)-1)
80554>>>>
80554>>>                        Get System_File_Number of hDD iCnt to iFil
80555>>>                        Send Insert ("     " +String(iFil)+" - ")
80556>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
80559>>>                        Send Insert sDummy
80560>>>                        Get System_File_Lock_Mode of hDD iCnt to iFil
80561>>>                        Case Begin
80561>>>                            Case (iFil=DD_Lock_on_All) ;                                    Move " - Lock on all" to sDummy
80564>>>                            Case (iFil=DD_Lock_on_Delete) ;                                    Move " - Lock on Delete" to sDummy
80568>>>                            Case (iFil=DD_Lock_on_new_Save_delete) ;                                    Move " - Lock on new save/delete" to sDummy
80572>>>                            Case (iFil=DD_Lock_on_Save) ;                                    Move " - Lock on save" to sDummy
80576>>>                            Case (iFil=DD_Lock_on_new_Save) ;                                    Move " - Lock on new save" to sDummy
80580>>>                            Case Else ;                                    Move " - No Lock" to sDummy
80582>>>                        Case End
80582>>>                        Send Insert sDummy
80583>>>                        Send Insert CR_LF
80584>>>                    Loop
80585>>>>
80585>>>                    Send Insert  CR_LF
80586>>>                    
80586>>>                    Send Insert "Attached DDO Server DDO = "
80587>>>                    Send Insert (Data_set_server_Count(hDD))
80588>>>                    Send Insert CR_LF
80589>>>                    For iCnt from 0 to (Data_set_server_Count(hDD)-1)
80595>>>>
80595>>>                        Get Data_Set_Server of hDD iCnt to iObj
80596>>>                        Get Main_file of iObj to iFil
80597>>>                        Get ParentDDOSwitched of hDD iFil to bSwitched
80598>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
80599>>>                        Send Insert ("     " +String(iObj)+" - "+sname)
80600>>>                        Send Insert ("     " +String(iFil)+" - ")
80601>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
80604>>>                        Send Insert sDummy
80605>>>                        Send Insert ("     (Switched: " + If(bSwitched, "True", "False") + ")")
80606>>>                        Send Insert CR_LF
80607>>>                    Loop
80608>>>>
80608>>>                    Send Insert  CR_LF
80609>>>                    
80609>>>                    Send Insert "Attached DDO CLient DDOs = "
80610>>>                    Send Insert  (Data_set_Client_Count(hDD))
80611>>>                    Send Insert  CR_LF
80612>>>                    For iCnt from 0 to (Data_set_Client_Count(hDD)-1)
80618>>>>
80618>>>                        Get Data_Set_Client of hDD iCnt to iObj
80619>>>                        Get Main_file of iObj to iFil
80620>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
80621>>>                        Send Insert ("     " +String(iObj)+" - "+sname)
80622>>>                        Send Insert ("     " +String(iFil)+" - ")
80623>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
80626>>>                        Send Insert sDummy
80627>>>                        Send Insert CR_LF
80628>>>                    Loop
80629>>>>
80629>>>                    Send Insert CR_LF
80630>>>                    
80630>>>                    Send Insert  "Valid Save Structure = "
80631>>>                    Send Insert  (If(Validate_Save_Structure(hDD,1),"No","Yes"))
80632>>>                    Send Insert  CR_LF
80633>>>                    
80633>>>                    Get Cascade_delete_State of hDD to ioldst
80634>>>                    Set Cascade_delete_State of hDD to True
80635>>>                    Send Insert  "Valid Cascade Delete Structure = "
80636>>>                    Send Insert  (If(Validate_Delete_Structure(hDD,1),"No","Yes"))
80637>>>                    Send Insert  CR_LF
80638>>>                    
80638>>>                    Set Cascade_delete_State of hDD to False
80639>>>                    Send Insert  "Valid No Cascade Delete Structure = "
80640>>>                    Send Insert  (If(Validate_Delete_Structure(hDD,1),"No","Yes"))
80641>>>                    Send Insert  CR_LF
80642>>>                    Set Cascade_delete_State of hDD to ioldst
80643>>>                    
80643>>>                    Send Insert  CR_LF
80644>>>                    Send Insert  "Attached DEOs = "
80645>>>                    Send Insert  (Data_set_user_Interface_Count(hDD))
80646>>>                    Send Insert  CR_LF
80647>>>                    For iCnt from 0 to (Data_set_User_Interface_Count(hDD)-1)
80653>>>>
80653>>>                        Get Data_Set_User_Interface of hDD iCnt to iObj
80654>>>                        Move (replace(sView+".",Object_Label(iObj),"")) to sName
80655>>>                        Send Insert ("     " +String(iObj)+" - "+sname)
80656>>>                        If not (Extended_deo_State(iObj)) ;                            Send Insert  ("  (**Not XDEO)")
80659>>>                        Else If (Data_File(iObj,0)<>iFile) ;                            Send Insert  ("    (foreign)")
80663>>>                        
80663>>>                        Send Insert  CR_LF
80664>>>                    Loop
80665>>>>
80665>>>                    Send Insert  CR_LF
80666>>>                    
80666>>>                    // Write the bodies for the fields
80666>>>                    // Write the Header
80666>>>                    Send Insert "              Extended Field Attributes"
80667>>>                    Send Insert CR_LF
80668>>>                    Send Insert "Field                            Type             Valid Values"
80669>>>                    Send Insert CR_LF
80670>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
80671>>>                    Send Insert CR_LF
80672>>>                    
80672>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
80673>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
80674>>>                    Move Error_Object_id to hOldErr
80675>>>                    Move hDD to Error_Object_id
80676>>>                    Get Item_Count of hRB to iMax
80677>>>                    Decrement iMax
80678>>>                    For iItem from 0 to iMax
80684>>>>
80684>>>                        Move (iItem * FA_COUNT) to iBase
80685>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
80688>>>                        Move (pad(sFieldName,32)) to sFieldName
80689>>>                        Get Field_Validation_Type of hDD iItem to iType
80690>>>                        Case Begin
80690>>>                            Case (iType=FA_VALIDATION_TYPE_RANGE)
80692>>>                                Move "Range" to sDummy
80693>>>                                Move ("Min="+Value(iFAObj,iBase+FA_MIN_VALUE) * ;                                    "Max="+Value(iFAObj,iBase+FA_MAX_VALUE)) ;                                    to sDummy2
80694>>>                                Case Break
80695>>>                            Case (iType=FA_VALIDATION_TYPE_CHECK)
80698>>>                                Move "Check" to sDummy
80699>>>                                Move ("Values =" * Value(iFAObj,iBase+FA_CHECK_VALUE)) to sDummy2
80700>>>                                Case Break
80701>>>                            Case (iType=FA_VALIDATION_TYPE_CHECKBOX)
80704>>>                                Move "CheckBox" to sDummy
80705>>>                                Move ("True="+ Value(iFAObj,iBase+FA_CHECKBOX_TRUE) * ;                                    "False="+ Value(iFAObj,iBase+FA_CHECKBOX_FALSE)) ;                                    to sDummy2
80706>>>                                Case Break
80707>>>                            Case (iType=FA_VALIDATION_TYPE_TABLE)
80710>>>                                Move "Table" to sDummy
80711>>>                                Move ("Id="+ Value(iFAObj,iBase+FA_TABLE_OBJECT) * ;                                    Name( Value(iFAObj,iBase+FA_TABLE_OBJECT) )) ;                                    to sDummy2
80712>>>                                Case Break
80713>>>                            Case Else
80713>>>                                Move "None" to sDummy
80714>>>                                Move "" to sDummy2
80715>>>                        Case End
80715>>>                        Move (Pad(sDummy,14)) to sDummy
80716>>>                        Move (SFormat("%1 %2 %3 %4", sFieldName, sType, sDummy, sDummy2)) to sLine
80717>>>                        Send Insert sLine
80718>>>                        Send Insert  CR_LF
80719>>>                    Loop
80720>>>>
80720>>>                    
80720>>>                    Send Beginning_Of_Data
80721>>>                    Set Dynamic_update_state to True
80722>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
80723>>>                    Move hOldErr to Error_Object_id
80724>>>                End_Procedure
80725>>>                
80725>>>                
80725>>>                
80725>>>                Set Size to 127 375
80726>>>                Set Location to 4 4
80727>>>                
80727>>>                
80727>>>                
80727>>>            End_Object
80728>>>            
80728>>>        End_Object
80729>>>        
80729>>>    End_Object
80730>>>    
80730>>>    Object oFindCounts is a Group
80732>>>        Set Size to 40 390
80733>>>        Set Location to 182 10
80734>>>        Set Label to "Constraint Find Counts"
80735>>>        Set peAnchors to anBottomLeft
80736>>>        Object oTestsCount is a Form
80738>>>            
80738>>>            Set enabled_state to False
80739>>>            
80739>>>            Set Label to "Tests_Count"
80740>>>            Set Size to 12 37
80741>>>            Set Location to 10 47
80742>>>            Set Label_Col_Offset to 2
80743>>>            Set Label_Justification_Mode to jMode_Right
80744>>>            
80744>>>            Set Numeric_mask 0 to 8 0
80745>>>            
80745>>>        End_Object
80746>>>        
80746>>>        Object oFoundCount is a Form
80748>>>            
80748>>>            Set enabled_state to False
80749>>>            
80749>>>            Set Label to "Found_Count"
80750>>>            Set Size to 12 37
80751>>>            Set Location to 10 137
80752>>>            Set Label_Col_Offset to 2
80753>>>            Set Label_Justification_Mode to jMode_Right
80754>>>            
80754>>>            Set Numeric_mask 0 to 8 0
80755>>>            
80755>>>        End_Object
80756>>>        
80756>>>        Object oDifference is a Form
80758>>>            
80758>>>            Set enabled_state to False
80759>>>            
80759>>>            Set Label to "Difference"
80760>>>            Set Size to 12 37
80761>>>            Set Location to 10 213
80762>>>            Set Label_Col_Offset to 2
80763>>>            Set Label_Justification_Mode to jMode_Right
80764>>>            
80764>>>            Set Numeric_mask 0 to 8 0
80765>>>            
80765>>>        End_Object
80766>>>        
80766>>>        Object oClearCounts is a Button
80768>>>            
80768>>>            
80768>>>            
80768>>>            Set Label to "Clear Count"
80769>>>            Set Size to 12 50
80770>>>            Set Location to 10 260
80771>>>            
80771>>>            Procedure OnClick
80774>>>                Send ClearCounts
80775>>>            End_Procedure
80776>>>            
80776>>>            
80776>>>        End_Object
80777>>>        
80777>>>        Object oNonOptimalWarnings is a CheckBox
80779>>>            Set Label to "Report errors if more than"
80780>>>            Set Size to 10 93
80781>>>            Set Location to 24 6
80782>>>            
80782>>>            Procedure OnChange
80785>>>                Delegate Send SetNonOptimalWarnings
80787>>>            End_Procedure
80788>>>            
80788>>>        End_Object
80789>>>        
80789>>>        Object oNonOptFinds is a Form
80791>>>            
80791>>>            Set Numeric_mask 0 to 6 0
80792>>>            
80792>>>            Set Size to 12 25
80793>>>            Set Location to 24 104
80794>>>            
80794>>>            
80794>>>            Set Value 0 to 50
80795>>>            
80795>>>            Procedure OnChange
80798>>>                Delegate Send SetNonOptimalWarnings
80800>>>            End_Procedure
80801>>>            
80801>>>        End_Object
80802>>>        
80802>>>        Object oNonOptTb is a Textbox
80804>>>            Set Label to "records are filtered."
80805>>>            Set Location to 25 132
80806>>>            Set Size to 10 61
80807>>>        End_Object
80808>>>        
80808>>>        
80808>>>        Procedure ClearCounts
80811>>>            Move 0 to Constrain_tests_count
80812>>>            Move 0 to Constrain_found_Count
80813>>>            Send RefreshCounts
80814>>>        End_Procedure
80815>>>        
80815>>>        Procedure RefreshCounts
80818>>>            Set Value of oTestsCount to constrain_tests_count
80819>>>            Set Value of oFoundCount to constrain_Found_count
80820>>>            Set Value of oDifference to (constrain_tests_count - Constrain_found_count)
80821>>>        End_Procedure
80822>>>        
80822>>>        
80822>>>    End_Object
80823>>>    
80823>>>    Object oFindGp is a Group
80825>>>        
80825>>>        
80825>>>        
80825>>>        Set Size to 30 185
80826>>>        Set Location to 225 10
80827>>>        Set Label to "Find Record"
80828>>>        Set peAnchors to anBottomLeft
80829>>>        Object oFindBgn is a Button
80831>>>            Set Size to 14 18
80832>>>            Set Location to 10 9
80833>>>            Set peImageAlign to Button_ImageList_Align_Center
80834>>>            Set psImage to "ActionFirst.ico"
80835>>>            
80835>>>            Procedure OnClick
80838>>>                Delegate Send FindRec FIRST_RECORD
80840>>>            End_Procedure
80841>>>            
80841>>>            
80841>>>        End_Object
80842>>>        
80842>>>        Object oFindPrev is a Button
80844>>>            Set Size to 14 18
80845>>>            Set Location to 10 31
80846>>>            Set peImageAlign to Button_ImageList_Align_Center
80847>>>            Set psImage to "ActionPrevious.ico"
80848>>>            
80848>>>            Procedure OnClick
80851>>>                Delegate Send FindRec LT
80853>>>            End_Procedure
80854>>>            
80854>>>            
80854>>>        End_Object
80855>>>        
80855>>>        Object oFindNext is a Button
80857>>>            
80857>>>            Set Size to 14 18
80858>>>            Set Location to 10 53
80859>>>            Set peImageAlign to Button_ImageList_Align_Center
80860>>>            Set psImage to "ActionNext.ico"
80861>>>            
80861>>>            Procedure OnClick
80864>>>                Delegate Send FindRec Gt
80866>>>            End_Procedure
80867>>>            
80867>>>            
80867>>>        End_Object
80868>>>        
80868>>>        Object oFindEnd is a Button
80870>>>            
80870>>>            Set Size to 14 18
80871>>>            Set Location to 10 75
80872>>>            Set peImageAlign to Button_ImageList_Align_Center
80873>>>            Set psImage to "ActionLast.ico"
80874>>>            
80874>>>            Procedure OnClick
80877>>>                Delegate Send FindRec LAST_RECORD
80879>>>            End_Procedure
80880>>>            
80880>>>            
80880>>>        End_Object
80881>>>        
80881>>>        Object oFindIndex is a ComboForm
80883>>>            
80883>>>            
80883>>>            
80883>>>            Set Size to 12 85
80884>>>            Set Location to 11 97
80885>>>            Set Form_Border to 0
80886>>>            Set Label_Col_Offset to 2
80887>>>            Set Label_Justification_Mode to jMode_Right
80888>>>            
80888>>>            Procedure Fill_list
80891>>>                Handle hDD
80891>>>                Integer iFile iSegs iNdxs i
80891>>>                Send Combo_Delete_Data
80892>>>                Get phoCurrentDD to hDD
80893>>>                If hDD Begin
80895>>>                    Send Combo_Add_Item "Index.0"
80896>>>                    Get Main_file of hDD to iFile
80897>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
80900>>>                    For i from 1 to iNdxs
80906>>>>
80906>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
80909>>>                        If iSegs ;                            Send Combo_Add_Item ("Index."-String(i))
80912>>>                    Loop
80913>>>>
80913>>>                End
80913>>>>
80913>>>                Set Value 0 to (combo_value(Self,0))
80914>>>            End_Procedure
80915>>>            
80915>>>            Function Ordering Returns Integer
80918>>>                String sVal
80918>>>                Get Value 0 to sVal
80919>>>                Function_Return (Integer(mid(sVal, 10, pos(".",sVal)+1)))
80920>>>            End_Function
80921>>>            
80921>>>        End_Object
80922>>>        
80922>>>        
80922>>>        Procedure FindRec Integer iMode
80925>>>            Handle hDD
80925>>>            Integer iNdx
80925>>>            Get Ordering of oFindIndex to iNdx
80926>>>            Get phoCurrentDD to hDD
80927>>>            If hDD Begin
80929>>>                Send Find of hDD iMode iNdx
80930>>>                Send RefreshAll
80931>>>            End
80931>>>>
80931>>>        End_Procedure
80932>>>        
80932>>>        Procedure RefreshNewDD
80935>>>            Send Fill_List of oFindIndex
80936>>>        End_Procedure
80937>>>        
80937>>>    End_Object
80938>>>    
80938>>>    Object oCheckRentrancy is a CheckBox
80940>>>        Set Label to "Report DD Rentrancy Errors"
80941>>>        Set Size to 10 105
80942>>>        Set Location to 224 294
80943>>>        Set peAnchors to anBottomLeft
80944>>>        
80944>>>        Procedure OnChange
80947>>>            Get Checked_State to gbTestRentrancy
80948>>>        End_Procedure
80949>>>        
80949>>>    End_Object
80950>>>    
80950>>>    Object oClearAll_bn is a Button
80952>>>        
80952>>>        
80952>>>        
80952>>>        Set Label to "Clear& All"
80953>>>        Set Location to 241 242
80954>>>        Set peAnchors to anBottomLeft
80955>>>        
80955>>>        Procedure OnClick
80958>>>            Handle hDD
80958>>>            Get phoCurrentDD to hDD
80959>>>            If hDD ;                Send clear_all to hdd
80962>>>            Send RefreshALL
80963>>>        End_Procedure
80964>>>        
80964>>>    End_Object
80965>>>    
80965>>>    Object oClear_bn is a Button
80967>>>        
80967>>>        
80967>>>        
80967>>>        Set Label to "&Clear"
80968>>>        Set Location to 241 295
80969>>>        Set peAnchors to anBottomLeft
80970>>>        
80970>>>        Procedure OnClick
80973>>>            Handle hDD
80973>>>            Get phoCurrentDD to hDD
80974>>>            If hDD ;                Send Clear to hdd
80977>>>            Send RefreshALL
80978>>>        End_Procedure
80979>>>        
80979>>>        
80979>>>    End_Object
80980>>>    
80980>>>    Object oClose_bn is a Button
80982>>>        
80982>>>        
80982>>>        
80982>>>        Set Label to "&Close"
80983>>>        Set Location to 241 350
80984>>>        Set peAnchors to anBottomLeft
80985>>>        
80985>>>        Procedure OnClick
80988>>>            Send Close_Panel
80989>>>        End_Procedure
80990>>>        
80990>>>        
80990>>>    End_Object
80991>>>    
80991>>>    Procedure RefreshAll
80994>>>        Handle hDD
80994>>>        Boolean bIsRecnumTable
80994>>>        Get phoCurrentDD to hDD
80995>>>        Get IsRecnumTable (main_file(hDD)) to bIsRecnumTable
80996>>>        Set Value          of oCurRec 0 to (If(bIsRecnumTable, current_record(hDD), 0))
80997>>>        Set checked_state  of oChangedState to (Changed_State(hDD))
80998>>>        Set checked_state  of oShouldSave   to (Should_save(hDD))
80999>>>        Send RefreshAll    of (phoFieldsEditId(Self))
81000>>>        Send RefreshCounts of oFindCounts
81001>>>    End_Procedure
81002>>>    
81002>>>    Procedure SetNonOptimalWarnings
81005>>>        Integer iValue
81005>>>        Boolean bChecked
81005>>>        Get Checked_State of oNonOptimalWarnings to bChecked
81006>>>        Get Value of oNonOptFinds to iValue
81007>>>        Move (If(bChecked,iValue,0)) to giNonOptimalFindCount
81008>>>        Set Enabled_state of oNonOptFinds to bChecked
81009>>>    End_Procedure
81010>>>    
81010>>>    Procedure RefreshNewDD
81013>>>        Handle hDD
81013>>>        Get phoCurrentDD to hDD
81014>>>        Send Fill_list of oDDRelatesTo
81015>>>        Set checked_state of oAutoFill to (Auto_Fill_State(hDD)<>0)
81016>>>        Set checked_state of oInherit  to (pbInheritConstraints(hDD))
81017>>>        Set checked_state of oFillFromTop to (pbAutoFillFromFirst(hDD))
81018>>>        Send RefreshAll   to (phoMiscEditId(Self))
81019>>>        Send RefreshAll   to (phoConstraintsEditId(Self))
81020>>>        Send RefreshAll
81021>>>        
81021>>>        Send RefreshNewDD of oDDOrdering
81022>>>        Send RefreshNewDD of oFindGP
81023>>>        Set  Ordering     of oDDOrdering to (ordering(hDD))
81024>>>    End_Procedure
81025>>>    
81025>>>    
81025>>>    Procedure refresh
81028>>>        Send Fill_list of oDDCombo
81029>>>        Send SetNonOptimalWarnings
81030>>>        Set checked_state of oCheckRentrancy to gbTestRentrancy
81031>>>    End_Procedure
81032>>>    
81032>>>    Procedure ShowDDs Handle hoDD
81035>>>        Handle hoVw
81035>>>        Get parent of hoDD  to hoVw
81036>>>        Set phoCurrentDD    to hoDD
81037>>>        Set phoInvokingView to hoVw
81038>>>        Send Refresh
81039>>>        Send Popup
81040>>>    End_Procedure
81041>>>    
81041>>>    
81041>>>    
81041>>>End_Object
81042>>>
81042>>>
81042>>>
81042>>>Procedure DebugDDs for cObject
81044>>>    Handle hDD
81044>>>    Get Server to hDD
81045>>>    If hDD ;        Send ShowDDs of oDD_Debug hDD
81048>>>End_Procedure
81049>>>
81049>>>On_Key key_Ctrl+Key_D Send DebugDDs
81050>>>
81050>        Use DeleteWorkspaceHistory.dg
81050>        
81050>        Use RefactorView.vw
Including file: RefactorView.vw    (C:\Projects\DF18\DfRefactor\AppSrc\RefactorView.vw)
81050>>>Use cRefactorDbView.pkg
Including file: cRefactorDbView.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorDbView.pkg)
81050>>>>>// Nils 2018-08-21
81050>>>>>// Various source code refactoring functions/procedures
81050>>>>>// for the DFRefactor project.
81050>>>>>// Was lifted from the CleanMarkers.vw  business process object (oBPO)
81050>>>>>// to here to make it easier to replace/add to this logic.
81050>>>>>// Wil 2018-09-03
81050>>>>>// Moved code into a dbView subclass instead.
81050>>>>>//
81050>>>>>Use Dfclient.pkg
81050>>>>>Use StatFLog.pkg
Including file: StatFLog.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\StatFLog.pkg)
81050>>>>>>>// This is a prototype status log file that can be used for adding status
81050>>>>>>>// log entries. If you are going to use this you MUST create a database
81050>>>>>>>// file named StatLog with, at least,  the following fields:
81050>>>>>>>//      Statlog.Date        date        date of status log entry
81050>>>>>>>//      Statlog.Time        String (5)  Time of entry in HH:MM format
81050>>>>>>>//      StatLog.Description String (??) Log text. We suggest length of
81050>>>>>>>//                                      at least 40.
81050>>>>>>>// You may add your own fields to this to store other types of information
81050>>>>>>>// such as user-id, status type, etc.
81050>>>>>>>//
81050>>>>>>>// Public Interface:
81050>>>>>>>//      Send Log_Status String sText
81050>>>>>>>//              Creates a log entry. Passes string Text.
81050>>>>>>>//      Send Log_Clear
81050>>>>>>>//              Clears the status log datafile.
81050>>>>>>>//
81050>>>>>>>//      Procedure OnNewRecord
81050>>>>>>>//              This is called each time a new record is ready to be
81050>>>>>>>//              written. All data is in the buffer (date, time, text).
81050>>>>>>>//              You can make any additional changes to the buffer. This is
81050>>>>>>>//              handy if you have additional fields.
81050>>>>>>>//
81050>>>>>>>// IMPORTANT NOTE: This is not meant to be a complete solution. Developers
81050>>>>>>>// are encouraged to create their own class (or sub-class) and data file
81050>>>>>>>// for logging information. The only public interface that must be adhered to
81050>>>>>>>// is send Log_Status and send Log_Clear. If you augment log_status you may
81050>>>>>>>// even choose to change the number of parameters and type of information
81050>>>>>>>// passed to the object.
81050>>>>>>>Use VDFBase.pkg
81050>>>>>>>
81050>>>>>>>Class StatusDbLog is a cObject
81051>>>>>>>    
81051>>>>>>>    Procedure Construct_Object
81053>>>>>>>        Forward Send Construct_Object
81055>>>>>>>        Open StatLog // Open the data-file. This MUST exist or error
Including file: StatLog.fd    (C:\Projects\DF18\DfRefactor\DDSrc\StatLog.fd)
81057>>>>>>>    End_Procedure
81058>>>>>>>    
81058>>>>>>>    // Clear the log file - Public message
81058>>>>>>>    Procedure Log_Clear
81060>>>>>>>        ZeroFile StatLog
81061>>>>>>>    End_Procedure
81062>>>>>>>    
81062>>>>>>>    // Private: converts integers Hour and Minutes into "HH:MM" string
81062>>>>>>>    Function TimeString Integer iHr Integer iMn Returns String
81064>>>>>>>        Function_Return (right("0"+String(iHr),2) + ":" + right("0"+String(iMn),2))
81065>>>>>>>    End_Function
81066>>>>>>>    
81066>>>>>>>    // write a log status record. Pass Text to write
81066>>>>>>>    Procedure Log_Status String Txt
81068>>>>>>>        Integer Hr Mn
81068>>>>>>>        Date    Dt
81068>>>>>>>        Integer OldError                 // we must trap errors that occur
81068>>>>>>>        Move Error_Object_ID to OldError       // within this object, often errors
81069>>>>>>>        Move Self to Error_Object_Id // are logged - causing recursion
81070>>>>>>>        Sysdate Dt Hr Mn
81073>>>>>>>        Clear StatLog
81074>>>>>>>        Move Dt to StatLog.Date
81075>>>>>>>        Move (TimeString(Self,hr,Mn)) to StatLog.Time
81076>>>>>>>        Move Txt to StatLog.Description
81077>>>>>>>        Send OnNewRecord // User hook to customize
81078>>>>>>>        SaveRecord StatLog
81079>>>>>>>        Move OldError to Error_Object_Id
81080>>>>>>>    End_Procedure
81081>>>>>>>    
81081>>>>>>>    // For Augmentation Only. This is called when a new record is about
81081>>>>>>>    // to be saved. You can make any changes, set new field values, etc.
81081>>>>>>>    Procedure OnNewRecord
81083>>>>>>>    End_Procedure
81084>>>>>>>    
81084>>>>>>>    // When errors occur within object, they are directed here.
81084>>>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String ErrMsg
81086>>>>>>>        //Forward send Error_Report iErrNum iErrLine ErrMsg
81086>>>>>>>        Send Error_report of desktop iErrNum iErrLine ErrMsg
81087>>>>>>>    End_Procedure
81088>>>>>>>    
81088>>>>>>>End_Class
81089>>>>>>>
81089>>>>>>>// expected usage
81089>>>>>>>//Object Status_Log is a StatusdbLog
81089>>>>>>>//End_Object
81089>>>>>Use RefactorFunctionConstants.inc
81089>>>>>Use cRegex.pkg
Including file: cRegex.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRegex.pkg)
81089>>>>>>>// cRegex class v1.03:
81089>>>>>>>// By Erik Svensson, posted on eriksven.com in March 2013
81089>>>>>>>// License: LGPLv3 - GNU LESSER GENERAL PUBLIC LICENSE Version 3 - http://www.gnu.org/licenses/lgpl.txt
81089>>>>>>>
81089>>>>>>>Define cREGEX_INCLUDED for 1
81089>>>>>>>
81089>>>>>>>// Visual DataFlex COM proxy classes generated from C:\Windows\system32\vbscript.dll\2
81089>>>>>>>Use FlexCom20.pkg
81089>>>>>>>
81089>>>>>>>Struct tRegexMatch
81089>>>>>>>    String Val
81089>>>>>>>    Integer FirstIndex
81089>>>>>>>    Integer Length
81089>>>>>>>End_Struct
81089>>>>>>>
81089>>>>>>>// CLSID: {3F4DACA0-160D-11D2-A8E9-00104B365C9F}
81089>>>>>>>Class cComIRegularExpressions is a Mixin
81090>>>>>>>
81090>>>>>>>    Function ComPattern Returns String
81092>>>>>>>        Handle hDispatchDriver
81092>>>>>>>        String retVal
81092>>>>>>>        Get phDispatchDriver to hDispatchDriver
81093>>>>>>>        Get InvokeComMethod of hDispatchDriver 10001 OLE_VT_BSTR to retVal
81094>>>>>>>        Function_Return retVal
81095>>>>>>>    End_Function
81096>>>>>>>
81096>>>>>>>    Procedure Set ComPattern String value
81098>>>>>>>        Handle hDispatchDriver
81098>>>>>>>        Get phDispatchDriver to hDispatchDriver
81099>>>>>>>        Send PrepareParams to hDispatchDriver 1
81100>>>>>>>        Set ComProperty of hDispatchDriver 10001 OLE_VT_BSTR to value
81101>>>>>>>    End_Procedure
81102>>>>>>>
81102>>>>>>>    Function ComIgnoreCase Returns Boolean
81104>>>>>>>        Handle hDispatchDriver
81104>>>>>>>        Boolean retVal
81104>>>>>>>        Get phDispatchDriver to hDispatchDriver
81105>>>>>>>        Get InvokeComMethod of hDispatchDriver 10002 OLE_VT_BOOL to retVal
81106>>>>>>>        Function_Return retVal
81107>>>>>>>    End_Function
81108>>>>>>>
81108>>>>>>>    Procedure Set ComIgnoreCase Boolean value
81110>>>>>>>        Handle hDispatchDriver
81110>>>>>>>        Get phDispatchDriver to hDispatchDriver
81111>>>>>>>        Send PrepareParams to hDispatchDriver 1
81112>>>>>>>        Set ComProperty of hDispatchDriver 10002 OLE_VT_BOOL to value
81113>>>>>>>    End_Procedure
81114>>>>>>>
81114>>>>>>>    Function ComGlobal Returns Boolean
81116>>>>>>>        Handle hDispatchDriver
81116>>>>>>>        Boolean retVal
81116>>>>>>>        Get phDispatchDriver to hDispatchDriver
81117>>>>>>>        Get InvokeComMethod of hDispatchDriver 10003 OLE_VT_BOOL to retVal
81118>>>>>>>        Function_Return retVal
81119>>>>>>>    End_Function
81120>>>>>>>
81120>>>>>>>    Procedure Set ComGlobal Boolean value
81122>>>>>>>        Handle hDispatchDriver
81122>>>>>>>        Get phDispatchDriver to hDispatchDriver
81123>>>>>>>        Send PrepareParams to hDispatchDriver 1
81124>>>>>>>        Set ComProperty of hDispatchDriver 10003 OLE_VT_BOOL to value
81125>>>>>>>    End_Procedure
81126>>>>>>>
81126>>>>>>>    Function ComExecute String llsourceString Returns Variant
81128>>>>>>>        Handle hDispatchDriver
81128>>>>>>>        Variant retVal
81128>>>>>>>        Get phDispatchDriver to hDispatchDriver
81129>>>>>>>        Send PrepareParams to hDispatchDriver 1
81130>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llsourceString
81131>>>>>>>        Get InvokeComMethod of hDispatchDriver 10004 OLE_VT_DISPATCH to retVal
81132>>>>>>>        Function_Return retVal
81133>>>>>>>    End_Function
81134>>>>>>>
81134>>>>>>>    Function ComTest String llsourceString Returns Boolean
81136>>>>>>>        Handle hDispatchDriver
81136>>>>>>>        Boolean retVal
81136>>>>>>>        Get phDispatchDriver to hDispatchDriver
81137>>>>>>>        Send PrepareParams to hDispatchDriver 1
81138>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llsourceString
81139>>>>>>>        Get InvokeComMethod of hDispatchDriver 10005 OLE_VT_BOOL to retVal
81140>>>>>>>        Function_Return retVal
81141>>>>>>>    End_Function
81142>>>>>>>
81142>>>>>>>    Function ComReplace String llsourceString String llreplaceString Returns String
81144>>>>>>>        Handle hDispatchDriver
81144>>>>>>>        String retVal
81144>>>>>>>        Get phDispatchDriver to hDispatchDriver
81145>>>>>>>        Send PrepareParams to hDispatchDriver 2
81146>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llsourceString
81147>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llreplaceString
81148>>>>>>>        Get InvokeComMethod of hDispatchDriver 10006 OLE_VT_BSTR to retVal
81149>>>>>>>        Function_Return retVal
81150>>>>>>>    End_Function
81151>>>>>>>End_Class
81152>>>>>>>
81152>>>>>>>// CoClass
81152>>>>>>>// ProgID: VBScript.RegExp
81152>>>>>>>// CLSID: {3F4DACA4-160D-11D2-A8E9-00104B365C9F}
81152>>>>>>>Class cComRegularExpressions is a cComAutomationObject
81153>>>>>>>    Import_Class_Protocol cComIRegularExpressions
81154>>>>>>>
81154>>>>>>>    Procedure Construct_Object
81156>>>>>>>        Forward Send Construct_Object
81158>>>>>>>        Set psProgID to "{3F4DACA4-160D-11D2-A8E9-00104B365C9F}"
81159>>>>>>>        Set peAutoCreate to acNoAutoCreate
81160>>>>>>>    End_Procedure
81161>>>>>>>End_Class
81162>>>>>>>
81162>>>>>>>// CLSID: {3F4DACA1-160D-11D2-A8E9-00104B365C9F}
81162>>>>>>>Class cComIRegExMatch is a Mixin
81163>>>>>>>
81163>>>>>>>    Function ComValue Returns String
81165>>>>>>>        Handle hDispatchDriver
81165>>>>>>>        String retVal
81165>>>>>>>        Get phDispatchDriver to hDispatchDriver
81166>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_BSTR to retVal
81167>>>>>>>        Function_Return retVal
81168>>>>>>>    End_Function
81169>>>>>>>
81169>>>>>>>    Function ComFirstIndex Returns Integer
81171>>>>>>>        Handle hDispatchDriver
81171>>>>>>>        Integer retVal
81171>>>>>>>        Get phDispatchDriver to hDispatchDriver
81172>>>>>>>        Get InvokeComMethod of hDispatchDriver 10001 OLE_VT_I4 to retVal
81173>>>>>>>        Function_Return retVal
81174>>>>>>>    End_Function
81175>>>>>>>
81175>>>>>>>    Function ComLength Returns Integer
81177>>>>>>>        Handle hDispatchDriver
81177>>>>>>>        Integer retVal
81177>>>>>>>        Get phDispatchDriver to hDispatchDriver
81178>>>>>>>        Get InvokeComMethod of hDispatchDriver 10002 OLE_VT_I4 to retVal
81179>>>>>>>        Function_Return retVal
81180>>>>>>>    End_Function
81181>>>>>>>End_Class
81182>>>>>>>
81182>>>>>>>// CoClass
81182>>>>>>>// CLSID: {3F4DACA5-160D-11D2-A8E9-00104B365C9F}
81182>>>>>>>Class cComRegExMatch is a cComAutomationObject
81183>>>>>>>    Import_Class_Protocol cComIRegExMatch
81184>>>>>>>
81184>>>>>>>    Procedure Construct_Object
81186>>>>>>>        Forward Send Construct_Object
81188>>>>>>>        Set peAutoCreate to acNoAutoCreate
81189>>>>>>>    End_Procedure
81190>>>>>>>End_Class
81191>>>>>>>
81191>>>>>>>// CLSID: {3F4DACA2-160D-11D2-A8E9-00104B365C9F}
81191>>>>>>>Class cComIRegExMatchCollection is a Mixin
81192>>>>>>>
81192>>>>>>>    Function ComItem Integer llindex Returns Variant
81194>>>>>>>        Handle hDispatchDriver
81194>>>>>>>        Variant retVal
81194>>>>>>>        Get phDispatchDriver to hDispatchDriver
81195>>>>>>>        Send PrepareParams to hDispatchDriver 1
81196>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llindex
81197>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
81198>>>>>>>        Function_Return retVal
81199>>>>>>>    End_Function
81200>>>>>>>
81200>>>>>>>    Function ComCount Returns Integer
81202>>>>>>>        Handle hDispatchDriver
81202>>>>>>>        Integer retVal
81202>>>>>>>        Get phDispatchDriver to hDispatchDriver
81203>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
81204>>>>>>>        Function_Return retVal
81205>>>>>>>    End_Function
81206>>>>>>>
81206>>>>>>>    Function Com_NewEnum Returns Variant
81208>>>>>>>        Handle hDispatchDriver
81208>>>>>>>        Variant retVal
81208>>>>>>>        Get phDispatchDriver to hDispatchDriver
81209>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
81210>>>>>>>        Function_Return retVal
81211>>>>>>>    End_Function
81212>>>>>>>End_Class
81213>>>>>>>
81213>>>>>>>// CoClass
81213>>>>>>>// CLSID: {3F4DACA6-160D-11D2-A8E9-00104B365C9F}
81213>>>>>>>Class cComRegExMatchCollection is a cComAutomationObject
81214>>>>>>>    Import_Class_Protocol cComIRegExMatchCollection
81215>>>>>>>
81215>>>>>>>    Procedure Construct_Object
81217>>>>>>>        Forward Send Construct_Object
81219>>>>>>>        Set peAutoCreate to acNoAutoCreate
81220>>>>>>>    End_Procedure
81221>>>>>>>End_Class
81222>>>>>>>
81222>>>>>>>//Wrapper
81222>>>>>>>Class cRegularExpressions is a cObject
81223>>>>>>>
81223>>>>>>>    Procedure Construct_Object
81225>>>>>>>        Handle hoRegExp
81225>>>>>>>
81225>>>>>>>        Forward Send Construct_Object
81227>>>>>>>
81227>>>>>>>        Property String  psPattern ""
81228>>>>>>>        Property Boolean pbIgnoreCase False
81229>>>>>>>        Property Handle  phRegex 0
81230>>>>>>>        Property Boolean pbGlobalFind False
81231>>>>>>>
81231>>>>>>>        Get Create (RefClass(cComRegularExpressions)) to hoRegExp
81232>>>>>>>        Send CreateComObject of hoRegExp
81233>>>>>>>
81233>>>>>>>        Set phRegex to hoRegExp
81234>>>>>>>
81234>>>>>>>    End_Procedure
81235>>>>>>>
81235>>>>>>>    Procedure Set Pattern String sPattern
81237>>>>>>>        Set psPattern to sPattern
81238>>>>>>>        Set ComPattern of (phRegex(Self)) to sPattern
81239>>>>>>>    End_Procedure
81240>>>>>>>
81240>>>>>>>    Procedure Set IgnoreCase Boolean bVal
81242>>>>>>>        Set ComIgnoreCase of (phRegex(Self)) to bVal
81243>>>>>>>    End_Procedure
81244>>>>>>>
81244>>>>>>>    Procedure Set GlobalFind Boolean bVal
81246>>>>>>>        Set ComGlobal of (phRegex(Self)) to bVal
81247>>>>>>>    End_Procedure
81248>>>>>>>
81248>>>>>>>    Function Test String sSource Returns Boolean
81250>>>>>>>        Function_Return (ComTest(phRegex(Self),sSource))
81251>>>>>>>    End_Function
81252>>>>>>>
81252>>>>>>>    Function StringReplace String sSource String sWith Returns String
81254>>>>>>>        Function_Return (ComReplace(phRegex(Self),sSource,sWith))
81255>>>>>>>    End_Function
81256>>>>>>>
81256>>>>>>>End_Class
81257>>>>>>>
81257>>>>>>>// Global functions
81257>>>>>>>Function Regex_Replace Global String sSource String sReplaceWith String sPattern Boolean bIgnoreCase Returns String
81259>>>>>>>    Handle hRegEx
81259>>>>>>>    String sRetVal
81259>>>>>>>
81259>>>>>>>    Get Create (RefClass(cRegularExpressions)) to hRegEx
81260>>>>>>>    If (hRegEx > 0) Begin
81262>>>>>>>        If (num_arguments = 4) Begin
81264>>>>>>>            Set IgnoreCase of hRegEx to bIgnoreCase
81265>>>>>>>        End
81265>>>>>>>>
81265>>>>>>>        Set Pattern of hRegEx to sPattern
81266>>>>>>>        Set GlobalFind of hRegEx to True
81267>>>>>>>        Get StringReplace of hRegEx sSource sReplaceWith to sRetVal
81268>>>>>>>        Send Destroy of hRegEx
81269>>>>>>>    End
81269>>>>>>>>
81269>>>>>>>    Else Begin
81270>>>>>>>        Error DFERR_PROGRAM "Cound not instantiate cRegex class"
81271>>>>>>>>
81271>>>>>>>    End
81271>>>>>>>>
81271>>>>>>>
81271>>>>>>>    Function_Return sRetVal
81272>>>>>>>
81272>>>>>>>End_Function
81273>>>>>>>
81273>>>>>>>Function Regex_IsMatch Global String sInput String sPattern Boolean bIgnoreCase Returns Boolean
81275>>>>>>>    Handle hRegEx
81275>>>>>>>    Boolean bIsMatch
81275>>>>>>>
81275>>>>>>>    Get Create (RefClass(cRegularExpressions)) to hRegEx
81276>>>>>>>    If (hRegEx > 0) Begin
81278>>>>>>>        If (num_arguments = 3) Begin
81280>>>>>>>            Set IgnoreCase of hRegEx to bIgnoreCase
81281>>>>>>>        End
81281>>>>>>>>
81281>>>>>>>        Set Pattern of hRegEx to sPattern
81282>>>>>>>        Set GlobalFind of hRegEx to True
81283>>>>>>>        Get Test of hRegEx (Trim(sInput)) to bIsMatch
81284>>>>>>>        Send Destroy of hRegEx
81285>>>>>>>    End
81285>>>>>>>>
81285>>>>>>>    Else Begin
81286>>>>>>>        Error DFERR_PROGRAM "Cound not instantiate cRegex class"
81287>>>>>>>>
81287>>>>>>>    End
81287>>>>>>>>
81287>>>>>>>
81287>>>>>>>    Function_Return bIsMatch
81288>>>>>>>
81288>>>>>>>End_Function
81289>>>>>>>
81289>>>>>>>Function Regex_Match Global String sInput String sPattern Boolean bIgnoreCase Returns tRegexMatch[]
81291>>>>>>>    Variant vMatchCollection vMatch
81291>>>>>>>    Integer iItems iItem
81291>>>>>>>    Handle hMatchCollection hRegEx hMatch
81291>>>>>>>    tRegexMatch match null
81291>>>>>>>    tRegexMatch match null
81291>>>>>>>    tRegexMatch[] matchArr
81291>>>>>>>    tRegexMatch[] matchArr
81292>>>>>>>
81292>>>>>>>    Get Create (RefClass(cRegularExpressions)) to hRegEx
81293>>>>>>>
81293>>>>>>>    If (hRegEx > 0) Begin
81295>>>>>>>        If (num_arguments = 3) Begin
81297>>>>>>>            Set IgnoreCase of hRegEx to bIgnoreCase
81298>>>>>>>        End
81298>>>>>>>>
81298>>>>>>>        Set Pattern of hRegEx to sPattern
81299>>>>>>>        Set GlobalFind of hRegEx to True
81300>>>>>>>        Get Create (RefClass(cComRegExMatchCollection)) to hMatchCollection
81301>>>>>>>        Get ComExecute of (phRegex(hRegEx)) sInput to vMatchCollection
81302>>>>>>>        If (not(IsNullComObject(vMatchCollection))) Begin
81304>>>>>>>            Set pvComObject of hMatchCollection to vMatchCollection
81305>>>>>>>            Get ComCount of hMatchCollection to iItems
81306>>>>>>>            For iItem from 1 to iItems
81312>>>>>>>>
81312>>>>>>>                Get Create (RefClass(cComRegExMatch)) to hMatch
81313>>>>>>>                Get ComItem of hMatchCollection (iItem-1) to vMatch
81314>>>>>>>                Set pvComObject of hMatch to vMatch
81315>>>>>>>                Get ComValue of hMatch to match.Val
81316>>>>>>>                Get ComFirstIndex of hMatch to match.FirstIndex
81317>>>>>>>                Get ComLength of hMatch to match.Length
81318>>>>>>>                Move match to matchArr[SizeOfArray(matchArr)]
81319>>>>>>>                Send Destroy of hMatch
81320>>>>>>>            Loop
81321>>>>>>>>
81321>>>>>>>        End
81321>>>>>>>>
81321>>>>>>>        Else Begin
81322>>>>>>>            Error DFERR_COM_OBJECT_METHOD_INVOCATION_ERROR "Invalid regex pattern"
81323>>>>>>>>
81323>>>>>>>        End
81323>>>>>>>>
81323>>>>>>>        Send Destroy of hMatchCollection
81324>>>>>>>        Send Destroy of hRegEx
81325>>>>>>>    End
81325>>>>>>>>
81325>>>>>>>    Else Begin
81326>>>>>>>        Error DFERR_PROGRAM "Cound not instantiate cRegex class"
81327>>>>>>>>
81327>>>>>>>    End
81327>>>>>>>>
81327>>>>>>>
81327>>>>>>>    Function_Return matchArr
81328>>>>>>>
81328>>>>>>>End_Function
81329>>>>>Use cRemoveUnusedLocals.pkg                  
Including file: cRemoveUnusedLocals.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRemoveUnusedLocals.pkg)
81329>>>>>>>//------------------------------------------------------------->
81329>>>>>>>// ReportUnusedLocals.pkg
81329>>>>>>>//      R.Worsley 3/09/2008
81329>>>>>>>//      Locate any unused local variables
81329>>>>>>>//      Conditions:
81329>>>>>>>//          Variables declared in the method line are not checked
81329>>>>>>>//          Read notes below on StringTokenizer
81329>>>>>>>//          Will work with the old "Local" as a descriptor
81329>>>>>>>//          Variables can be declared anywhere in the method
81329>>>>>>>//
81329>>>>>>>//      If used as a class in an another application, there are
81329>>>>>>>//      a couple of properties that can be set to automate the
81329>>>>>>>//      input and output file names.  See the property descriptions
81329>>>>>>>//      in class cReportUnusedLocals
81329>>>>>>>//
81329>>>>>>>//------------------------------------------------------------>
81329>>>>>>>//  04/08/2008 RLW  - Make into a class so the process can be
81329>>>>>>>//                   incorporated into other applications
81329>>>>>>>//  04/12/2008 RLW  - Change read/write registry process
81329>>>>>>>//  04/12/2008 RLW  - Fix so that wrapped variables on the function
81329>>>>>>>//                   or procedure line won't show odd results
81329>>>>>>>//  06/22/2008 RLW  - Add missing Seq_Release_Channel calls
81329>>>>>>>//  06/30/2018 Nils - Changed to use registry functions of the cApplication class.
81329>>>>>>>//  10/26/2018 Nils - Rewrote to use a struct instead of multi-dimensional array,
81329>>>>>>>//                    and to actually remove unused local variables (!), not just create a report.
81329>>>>>>>//  11/03/2018 Nils - Rewrote most of the logic to make it more robust. Removed the StringTokenizer
81329>>>>>>>//                    code to instead use the build in StrSplitToArray function.
81329>>>>>>>//  09/09/2021 Nils - Merged all generalized functions with the cRefactorFunctionLibrary class.
81329>>>>>>>//                    Also moved most constant declarations to SourceCode.inc
81329>>>>>>>//------------------------------------------------------------->
81329>>>>>>>Use cApplication.pkg
81329>>>>>>>Use Batchdd.pkg
81329>>>>>>>
81329>>>>>>>Global_Variable Handle ghoRefactorFunctionLibrary
81329>>>>>>>
81329>>>>>>>Use cRefactorFunctionLibrary.pkg
Including file: cRefactorFunctionLibrary.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorFunctionLibrary.pkg)
81329>>>>>>>>>Use UI
81329>>>>>>>>>Use RefactorFunctionConstants.inc
81329>>>>>>>>>Use cScintillaRefactorEditor.pkg
Including file: cScintillaRefactorEditor.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cScintillaRefactorEditor.pkg)
81329>>>>>>>>>>>Use cScintillaEdit.pkg
Including file: cScintillaEdit.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cScintillaEdit.pkg)
81329>>>>>>>>>>>>>Use cSciLexerSupport.pkg
81329>>>>>>>>>>>>>Use cSciLexerRefactor.pkg
Including file: cSciLexerRefactor.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexerRefactor.pkg)
81329>>>>>>>>>>>>>>>//TH-Header
81329>>>>>>>>>>>>>>>//*****************************************************************************************
81329>>>>>>>>>>>>>>>// Copyright (c)  2018 VDF-Guidance
81329>>>>>>>>>>>>>>>// All rights reserved.
81329>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>// $FileName    : cSciLexerRefactor.pkg
81329>>>>>>>>>>>>>>>// $ProjectName : TheHammer3
81329>>>>>>>>>>>>>>>// $Authors     :
81329>>>>>>>>>>>>>>>// $Created     : 02.09.2018  00:16
81329>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>// Contents:
81329>>>>>>>>>>>>>>>//  Additional class to move the refactoring logic into a subclass
81329>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>//*****************************************************************************************
81329>>>>>>>>>>>>>>>//TH-RevisionStart
81329>>>>>>>>>>>>>>>// ********************
81329>>>>>>>>>>>>>>>// MODIFICATION SUMMARY
81329>>>>>>>>>>>>>>>// ********************
81329>>>>>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
81329>>>>>>>>>>>>>>>//TH-RevisionEnd
81329>>>>>>>>>>>>>>>
81329>>>>>>>>>>>>>>>Use cSciLexer.pkg
Including file: cSciLexer.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexer.pkg)
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// File: cSciLexer.pkg
81329>>>>>>>>>>>>>>>>>// Author: Wil van Antwerpen
81329>>>>>>>>>>>>>>>>>// Date: March 2017
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// The scintilla control is made accessible here via the cSciLexer class and it's implementation has been designed to
81329>>>>>>>>>>>>>>>>>// be almost a drop-in replacement for the codemax control that was previously the control used for editing by the Hammer.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// As development on codemax has ceased years ago and we need to go forward, scintilla ended up being the best match.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// Note that the intention is to phase out codemax and that the backwards compatibility is likely to fade over time as
81329>>>>>>>>>>>>>>>>>// new scintilla only feature(s) will make it into the product.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// This is only designed this way to make the transition period from codemax to scintilla as smooth as can be.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// Codemax compatible methods are prefixed by CM_
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// Documentation for the scintilla control can be found here:
81329>>>>>>>>>>>>>>>>>// http://www.scintilla.org/ScintillaDoc.html
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// This wrapper is licensed under the 2 clause BSD license as to make it as easy as possible to re-use if needed.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// BSD License content start
81329>>>>>>>>>>>>>>>>>// *********************************************************************************************************
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// Copyright (c) 2017, Wil van Antwerpen
81329>>>>>>>>>>>>>>>>>// All rights reserved.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// Redistribution and use in source and binary forms, with or without
81329>>>>>>>>>>>>>>>>>// modification, are permitted provided that the following conditions are met:
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// 1. Redistributions of source code must retain the above copyright notice, this
81329>>>>>>>>>>>>>>>>>//    list of conditions and the following disclaimer.
81329>>>>>>>>>>>>>>>>>// 2. Redistributions in binary form must reproduce the above copyright notice,
81329>>>>>>>>>>>>>>>>>//    this list of conditions and the following disclaimer in the documentation
81329>>>>>>>>>>>>>>>>>//    and/or other materials provided with the distribution.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
81329>>>>>>>>>>>>>>>>>// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
81329>>>>>>>>>>>>>>>>>// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
81329>>>>>>>>>>>>>>>>>// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
81329>>>>>>>>>>>>>>>>>// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
81329>>>>>>>>>>>>>>>>>// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
81329>>>>>>>>>>>>>>>>>// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
81329>>>>>>>>>>>>>>>>>// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
81329>>>>>>>>>>>>>>>>>// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
81329>>>>>>>>>>>>>>>>>// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
81329>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>// The views and conclusions contained in the software and documentation are those
81329>>>>>>>>>>>>>>>>>// of the authors and should not be interpreted as representing official policies,
81329>>>>>>>>>>>>>>>>>// either expressed or implied, of the VDF-Guidance / Hammer Project.
81329>>>>>>>>>>>>>>>>>// *********************************************************************************************************
81329>>>>>>>>>>>>>>>>>
81329>>>>>>>>>>>>>>>>>
81329>>>>>>>>>>>>>>>>>Use cWinFunc.pkg
Including file: cWinFunc.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cWinFunc.pkg)
81329>>>>>>>>>>>>>>>>>>>//***************************************************************************
81329>>>>>>>>>>>>>>>>>>>// binary.pkg
81329>>>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>>>// Copyright (c) 1999-2001 Out of the Box Consulting, Inc.
81329>>>>>>>>>>>>>>>>>>>// All rights reserved.
81329>>>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>>>//***************************************************************************
81329>>>>>>>>>>>>>>>>>>>//  Description:
81329>>>>>>>>>>>>>>>>>>>//      This is a collection of functions/procedures to aid in binary
81329>>>>>>>>>>>>>>>>>>>//      operations.
81329>>>>>>>>>>>>>>>>>>>//
81329>>>>>>>>>>>>>>>>>>>//  Author: Oliver T. Nelson, Sture Anderson
81329>>>>>>>>>>>>>>>>>>>//***************************************************************************
81329>>>>>>>>>>>>>>>>>>>
81329>>>>>>>>>>>>>>>>>>>Function lshift Global Integer iVal Integer iPositions Returns Integer
81331>>>>>>>>>>>>>>>>>>>    Integer i
81331>>>>>>>>>>>>>>>>>>>    BigInt bVal
81331>>>>>>>>>>>>>>>>>>>    For i From 1 To iPositions
81337>>>>>>>>>>>>>>>>>>>>
81337>>>>>>>>>>>>>>>>>>>        Move (iVal * 2) To bVal
81338>>>>>>>>>>>>>>>>>>>        If (bVal >= 2147483648) ;            Move (bVal - 2147483648) To iVal
81341>>>>>>>>>>>>>>>>>>>        Else ;            Move bVal To iVal
81343>>>>>>>>>>>>>>>>>>>    Loop
81344>>>>>>>>>>>>>>>>>>>>
81344>>>>>>>>>>>>>>>>>>>    Function_Return iVal
81345>>>>>>>>>>>>>>>>>>>End_Function
81346>>>>>>>>>>>>>>>>>>>
81346>>>>>>>>>>>>>>>>>>>Function rshift Global Integer iVal Integer iPositions Returns Integer
81348>>>>>>>>>>>>>>>>>>>    Function_Return (iVal / (2^iPositions))
81349>>>>>>>>>>>>>>>>>>>End_Function
81350>>>>>>>>>>>>>>>>>>>
81350>>>>>>>>>>>>>>>>>>>Function rshiftabs Global Integer iVal Integer iPositions Returns Integer
81352>>>>>>>>>>>>>>>>>>>    UInteger iCnt
81352>>>>>>>>>>>>>>>>>>>    Number nVal
81352>>>>>>>>>>>>>>>>>>>
81352>>>>>>>>>>>>>>>>>>>    If (iVal < 0) Begin
81354>>>>>>>>>>>>>>>>>>>        Move (Number(iVal) + Number(4294967296)) To nVal
81355>>>>>>>>>>>>>>>>>>>        Move (nVal / (2^iPositions)) To iVal
81356>>>>>>>>>>>>>>>>>>>    End
81356>>>>>>>>>>>>>>>>>>>>
81356>>>>>>>>>>>>>>>>>>>    Else Begin
81357>>>>>>>>>>>>>>>>>>>        Move (iVal / (2^iPositions)) To iVal
81358>>>>>>>>>>>>>>>>>>>    End
81358>>>>>>>>>>>>>>>>>>>>
81358>>>>>>>>>>>>>>>>>>>    Function_Return iVal
81359>>>>>>>>>>>>>>>>>>>End_Function
81360>>>>>>>>>>>>>>>>>>>
81360>>>>>>>>>>>>>>>>>>>Function rol Global Integer iVal Integer iCnt Returns Integer
81362>>>>>>>>>>>>>>>>>>>    Function_Return (lshift(iVal, iCnt) Ior rshiftabs(iVal, (32 - iCnt)))
81363>>>>>>>>>>>>>>>>>>>End_Function
81364>>>>>>>>>>>>>>>>>>>
81364>>>>>>>>>>>>>>>>>>>Function inot Global Integer iValue Returns Integer
81366>>>>>>>>>>>>>>>>>>>    Function_Return ( (iValue * -1) - 1)
81367>>>>>>>>>>>>>>>>>>>End_Function
81368>>>>>>>>>>>>>>>>>>>
81368>>>>>>>>>>>>>>>>>>>Function xor Global Integer i1 Integer i2 Returns Integer
81370>>>>>>>>>>>>>>>>>>>    Function_Return ( (i1 Ior i2) - (i1 Iand i2) )
81371>>>>>>>>>>>>>>>>>>>End_Function
81372>>>>>>>>>>>>>>>>>>>
81372>>>>>>>>>>>>>>>>>>>// **WvA: 27-07-2004 Check added is already declared in VDFQuery strings.nui
81372>>>>>>>>>>>>>>>>>>>Function ByteToHex Global Integer byte# Returns String
81374>>>>>>>>>>>>>>>>>>>    Function_Return (Mid("0123456789ABCDEF",1,byte#/16+1)+Mid("0123456789ABCDEF",1,(byte# Iand 15)+1))
81375>>>>>>>>>>>>>>>>>>>End_Function
81376>>>>>>>>>>>>>>>>>>>
81376>>>>>>>>>>>>>>>>>>>Function WordToByte Global Integer wI  Returns String
81378>>>>>>>>>>>>>>>>>>>    Function_Return (Character(wI Iand 255)+Character(wI/256))
81379>>>>>>>>>>>>>>>>>>>End_Function
81380>>>>>>>>>>>>>>>>>>>
81380>>>>>>>>>>>>>>>>>>>Function WordToHex Global Integer wI  Returns String
81382>>>>>>>>>>>>>>>>>>>    Function_Return (ByteToHex(Character(wI Iand 255))+ByteToHex(Character(wI/256)))
81383>>>>>>>>>>>>>>>>>>>End_Function
81384>>>>>>>>>>>>>>>>>>>
81384>>>>>>>>>>>>>>>>>>>Function DwordToHex Global Integer aDWord Returns String
81386>>>>>>>>>>>>>>>>>>>    Function_Return ( ByteToHex(hi(aDWORD)/256)  +  ByteToHex(hi(aDWORD) Iand 255)  +  ByteToHex(low(aDWORD)/256)  +  ByteToHex(low(aDWORD) Iand 255)  )
81387>>>>>>>>>>>>>>>>>>>End_Function
81388>>>>>>>>>>>>>>>>>>>
81388>>>>>>>>>>>>>>>>>>>
81388>>>>>>>>>>>>>>>>>>>// Do NOT use, use UCharArrayToString instead
81388>>>>>>>>>>>>>>>>>>>Function Ptr2Str Pointer lpsDataPointer Returns String
81391>>>>>>>>>>>>>>>>>>>    String sResult sCharacter
81391>>>>>>>>>>>>>>>>>>>    Integer iVoid
81391>>>>>>>>>>>>>>>>>>>
81391>>>>>>>>>>>>>>>>>>>    If (lpsDataPointer <> 0) Begin
81393>>>>>>>>>>>>>>>>>>>        Move (ZeroString(1)) To sCharacter
81394>>>>>>>>>>>>>>>>>>>        Move (CopyMemory (AddressOf(sCharacter), lpsDataPointer, 1)) To iVoid
81395>>>>>>>>>>>>>>>>>>>        While (Ascii (sCharacter) <> 0)
81399>>>>>>>>>>>>>>>>>>>            Move (sResult + sCharacter) To sResult
81400>>>>>>>>>>>>>>>>>>>            Increment lpsDataPointer
81401>>>>>>>>>>>>>>>>>>>            Move (CopyMemory (AddressOf(sCharacter), lpsDataPointer, 1)) To iVoid
81402>>>>>>>>>>>>>>>>>>>        Loop
81403>>>>>>>>>>>>>>>>>>>>
81403>>>>>>>>>>>>>>>>>>>    End
81403>>>>>>>>>>>>>>>>>>>>
81403>>>>>>>>>>>>>>>>>>>    Function_Return sResult
81404>>>>>>>>>>>>>>>>>>>End_Function
81405>>>>>>>>>>>>>>>>>>>
81405>>>>>>>>>>>>>>>>>Use seq_chnl.pkg
81405>>>>>>>>>>>>>>>>>Use cSciLexer.h
81405>>>>>>>>>>>>>>>>>Use cSciCommandHotKeySupport.pkg
81405>>>>>>>>>>>>>>>>>Use cNormalizeCase.pkg
Including file: cNormalizeCase.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cNormalizeCase.pkg)
81405>>>>>>>>>>>>>>>>>>>//TH-Header
81405>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
81405>>>>>>>>>>>>>>>>>>>// Copyright (c)  2017 The Kurant project
81405>>>>>>>>>>>>>>>>>>>// All rights reserved.
81405>>>>>>>>>>>>>>>>>>>//
81405>>>>>>>>>>>>>>>>>>>// $FileName    : .\Hammer\Pkg\cNormalizeCase.pkg
81405>>>>>>>>>>>>>>>>>>>// $ProjectName : TheHammer3
81405>>>>>>>>>>>>>>>>>>>// $Authors     : Wil van Antwerpen
81405>>>>>>>>>>>>>>>>>>>// $Created     : 07.06.2017  13:30
81405>>>>>>>>>>>>>>>>>>>//
81405>>>>>>>>>>>>>>>>>>>// Contents:
81405>>>>>>>>>>>>>>>>>>>//  Contains the logic to be able to store the keywords and scopewords of a language so
81405>>>>>>>>>>>>>>>>>>>//  that this can be used to adjust the casing to the preferred casing as is defined in
81405>>>>>>>>>>>>>>>>>>>//  the language configuration.
81405>>>>>>>>>>>>>>>>>>>//
81405>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
81405>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
81405>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
81405>>>>>>>>>>>>>>>>>>>
81405>>>>>>>>>>>>>>>>>>>
81405>>>>>>>>>>>>>>>>>>>Struct tWordCaseAdjust
81405>>>>>>>>>>>>>>>>>>>  Integer  iLanguage
81405>>>>>>>>>>>>>>>>>>>  String[] KeyWords
81405>>>>>>>>>>>>>>>>>>>  String[] ScopeWords
81405>>>>>>>>>>>>>>>>>>>End_Struct
81405>>>>>>>>>>>>>>>>>>>
81405>>>>>>>>>>>>>>>>>>>Class cNormalizeCase is a cObject
81406>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
81408>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
81410>>>>>>>>>>>>>>>>>>>    Property tWordCaseAdjust[] pTextAdjust
81411>>>>>>>>>>>>>>>>>>>  End_Procedure
81412>>>>>>>>>>>>>>>>>>>
81412>>>>>>>>>>>>>>>>>>>  Function WordsToArray String sWords Returns String[]
81414>>>>>>>>>>>>>>>>>>>    Integer iPos
81414>>>>>>>>>>>>>>>>>>>    String  sNewWord
81414>>>>>>>>>>>>>>>>>>>    String[] Words
81415>>>>>>>>>>>>>>>>>>>
81415>>>>>>>>>>>>>>>>>>>    While (sWords<>"")
81419>>>>>>>>>>>>>>>>>>>      Move (Pos(" ",sWords)) To iPos
81420>>>>>>>>>>>>>>>>>>>      If (iPos>0) Begin
81422>>>>>>>>>>>>>>>>>>>        Move (Left(sWords,iPos-1)) To sNewWord
81423>>>>>>>>>>>>>>>>>>>        Move sNewWord To Words[SizeOfArray(Words)]
81424>>>>>>>>>>>>>>>>>>>        Move (Replace(sNewWord+" ",sWords,"")) To sWords
81425>>>>>>>>>>>>>>>>>>>      End
81425>>>>>>>>>>>>>>>>>>>>
81425>>>>>>>>>>>>>>>>>>>      Else Begin
81426>>>>>>>>>>>>>>>>>>>        Move sWords To Words[SizeOfArray(Words)]
81427>>>>>>>>>>>>>>>>>>>        Move "" To sWords
81428>>>>>>>>>>>>>>>>>>>      End
81428>>>>>>>>>>>>>>>>>>>>
81428>>>>>>>>>>>>>>>>>>>    Loop
81429>>>>>>>>>>>>>>>>>>>>
81429>>>>>>>>>>>>>>>>>>>    Function_Return Words
81430>>>>>>>>>>>>>>>>>>>  End_Function
81431>>>>>>>>>>>>>>>>>>>
81431>>>>>>>>>>>>>>>>>>>  Procedure AddKeywords Integer iLanguage String sKeyWords
81433>>>>>>>>>>>>>>>>>>>    Boolean bInitialized
81433>>>>>>>>>>>>>>>>>>>    Integer iItem
81433>>>>>>>>>>>>>>>>>>>    String[] Words
81434>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81434>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81435>>>>>>>>>>>>>>>>>>>
81435>>>>>>>>>>>>>>>>>>>    Move False To bInitialized
81436>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
81437>>>>>>>>>>>>>>>>>>>    Get WordsToArray sKeyWords To Words
81438>>>>>>>>>>>>>>>>>>>    Get InitializedLanguage iLanguage To bInitialized
81439>>>>>>>>>>>>>>>>>>>    If (bInitialized=False) Begin
81441>>>>>>>>>>>>>>>>>>>      Move (SizeOfArray(TextAdjusts)) To iItem
81442>>>>>>>>>>>>>>>>>>>      Move iLanguage To TextAdjusts[iItem].iLanguage
81443>>>>>>>>>>>>>>>>>>>      Move Words To TextAdjusts[iItem].KeyWords
81444>>>>>>>>>>>>>>>>>>>    End
81444>>>>>>>>>>>>>>>>>>>>
81444>>>>>>>>>>>>>>>>>>>    Else Begin
81445>>>>>>>>>>>>>>>>>>>      Get LanguageItem iLanguage To iItem
81446>>>>>>>>>>>>>>>>>>>      Move (AppendArray(Words,TextAdjusts[iItem].KeyWords)) To TextAdjusts[iItem].KeyWords
81447>>>>>>>>>>>>>>>>>>>    End
81447>>>>>>>>>>>>>>>>>>>>
81447>>>>>>>>>>>>>>>>>>>    Move (SortArray(TextAdjusts[iItem].KeyWords, Desktop, (RefFunc(DFSTRICMP)))) To TextAdjusts[iItem].KeyWords
81448>>>>>>>>>>>>>>>>>>>    Set pTextAdjust To TextAdjusts
81449>>>>>>>>>>>>>>>>>>>  End_Procedure
81450>>>>>>>>>>>>>>>>>>>
81450>>>>>>>>>>>>>>>>>>>  Procedure AddScopewords Integer iLanguage String sScopeWords
81452>>>>>>>>>>>>>>>>>>>    Boolean bInitialized
81452>>>>>>>>>>>>>>>>>>>    Integer iItem
81452>>>>>>>>>>>>>>>>>>>    String[] Words
81453>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81453>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81454>>>>>>>>>>>>>>>>>>>
81454>>>>>>>>>>>>>>>>>>>    Move False To bInitialized
81455>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
81456>>>>>>>>>>>>>>>>>>>    Get WordsToArray sScopeWords To Words
81457>>>>>>>>>>>>>>>>>>>    Get InitializedLanguage iLanguage To bInitialized
81458>>>>>>>>>>>>>>>>>>>    If (bInitialized=False) Begin
81460>>>>>>>>>>>>>>>>>>>      Move (SizeOfArray(TextAdjusts)) To iItem
81461>>>>>>>>>>>>>>>>>>>      Move iLanguage To TextAdjusts[iItem].iLanguage
81462>>>>>>>>>>>>>>>>>>>      Move Words To TextAdjusts[iItem].ScopeWords
81463>>>>>>>>>>>>>>>>>>>    End
81463>>>>>>>>>>>>>>>>>>>>
81463>>>>>>>>>>>>>>>>>>>    Else Begin
81464>>>>>>>>>>>>>>>>>>>      Get LanguageItem iLanguage To iItem
81465>>>>>>>>>>>>>>>>>>>      Move (AppendArray(Words,TextAdjusts[iItem].ScopeWords)) To TextAdjusts[iItem].ScopeWords
81466>>>>>>>>>>>>>>>>>>>    End
81466>>>>>>>>>>>>>>>>>>>>
81466>>>>>>>>>>>>>>>>>>>    Move (SortArray(TextAdjusts[iItem].ScopeWords, Desktop, (RefFunc(DFSTRICMP)))) To TextAdjusts[iItem].ScopeWords
81467>>>>>>>>>>>>>>>>>>>    Set pTextAdjust To TextAdjusts
81468>>>>>>>>>>>>>>>>>>>  End_Procedure
81469>>>>>>>>>>>>>>>>>>>
81469>>>>>>>>>>>>>>>>>>>  Function FindKeyWord Integer iLanguage String sKeyWord Returns String
81471>>>>>>>>>>>>>>>>>>>    Integer iItem
81471>>>>>>>>>>>>>>>>>>>    Integer iSearchIndex
81471>>>>>>>>>>>>>>>>>>>    String  sWord
81471>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81471>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81472>>>>>>>>>>>>>>>>>>>
81472>>>>>>>>>>>>>>>>>>>    Get LanguageItem iLanguage To iItem
81473>>>>>>>>>>>>>>>>>>>    If (iItem>-1) Begin
81475>>>>>>>>>>>>>>>>>>>      Get pTextAdjust To TextAdjusts
81476>>>>>>>>>>>>>>>>>>>      Move (BinarySearchArray(sKeyWord, TextAdjusts[iItem].KeyWords, Desktop, (RefFunc(DFSTRICMP)))) To iSearchIndex
81477>>>>>>>>>>>>>>>>>>>      If (iSearchIndex>-1) Begin
81479>>>>>>>>>>>>>>>>>>>        Move TextAdjusts[iItem].KeyWords[iSearchIndex] To sWord
81480>>>>>>>>>>>>>>>>>>>      End
81480>>>>>>>>>>>>>>>>>>>>
81480>>>>>>>>>>>>>>>>>>>      Else ;        Move sKeyWord To sWord
81482>>>>>>>>>>>>>>>>>>>    End
81482>>>>>>>>>>>>>>>>>>>>
81482>>>>>>>>>>>>>>>>>>>    Else ;      Move sKeyWord To sWord // not found, return word unchanged
81484>>>>>>>>>>>>>>>>>>>    Function_Return sWord
81485>>>>>>>>>>>>>>>>>>>  End_Function
81486>>>>>>>>>>>>>>>>>>>
81486>>>>>>>>>>>>>>>>>>>  Function FindScopeWord Integer iLanguage String sScopeWord Returns String
81488>>>>>>>>>>>>>>>>>>>    Integer iItem
81488>>>>>>>>>>>>>>>>>>>    Integer iSearchIndex
81488>>>>>>>>>>>>>>>>>>>    String  sWord
81488>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81488>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81489>>>>>>>>>>>>>>>>>>>
81489>>>>>>>>>>>>>>>>>>>    Get LanguageItem iLanguage To iItem
81490>>>>>>>>>>>>>>>>>>>    If (iItem>-1) Begin
81492>>>>>>>>>>>>>>>>>>>      Get pTextAdjust To TextAdjusts
81493>>>>>>>>>>>>>>>>>>>      Move (BinarySearchArray(sScopeWord, TextAdjusts[iItem].ScopeWords, Desktop, (RefFunc(DFSTRICMP)))) To iSearchIndex
81494>>>>>>>>>>>>>>>>>>>      If (iSearchIndex>-1) Begin
81496>>>>>>>>>>>>>>>>>>>        Move TextAdjusts[iItem].ScopeWords[iSearchIndex] To sWord
81497>>>>>>>>>>>>>>>>>>>      End
81497>>>>>>>>>>>>>>>>>>>>
81497>>>>>>>>>>>>>>>>>>>      Else ;        Move sScopeWord To sWord
81499>>>>>>>>>>>>>>>>>>>    End
81499>>>>>>>>>>>>>>>>>>>>
81499>>>>>>>>>>>>>>>>>>>    Else ;      Move sScopeWord To sWord // not found, return word unchanged
81501>>>>>>>>>>>>>>>>>>>    Function_Return sWord
81502>>>>>>>>>>>>>>>>>>>  End_Function
81503>>>>>>>>>>>>>>>>>>>
81503>>>>>>>>>>>>>>>>>>>  Function LanguageItem Integer iLanguage Returns Integer
81505>>>>>>>>>>>>>>>>>>>    Integer iItem iCount iFound
81505>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81505>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81506>>>>>>>>>>>>>>>>>>>
81506>>>>>>>>>>>>>>>>>>>    Move -1 To iFound
81507>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
81508>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(TextAdjusts)) To iCount
81509>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
81511>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
81517>>>>>>>>>>>>>>>>>>>>
81517>>>>>>>>>>>>>>>>>>>        If (TextAdjusts[iItem].iLanguage=iLanguage) Begin
81519>>>>>>>>>>>>>>>>>>>          Move iItem To iFound
81520>>>>>>>>>>>>>>>>>>>          Move iCount To iItem
81521>>>>>>>>>>>>>>>>>>>        End
81521>>>>>>>>>>>>>>>>>>>>
81521>>>>>>>>>>>>>>>>>>>      Loop
81522>>>>>>>>>>>>>>>>>>>>
81522>>>>>>>>>>>>>>>>>>>    End
81522>>>>>>>>>>>>>>>>>>>>
81522>>>>>>>>>>>>>>>>>>>    Function_Return iFound
81523>>>>>>>>>>>>>>>>>>>  End_Function
81524>>>>>>>>>>>>>>>>>>>
81524>>>>>>>>>>>>>>>>>>>  Function InitializedLanguage Integer iLanguage Returns Boolean
81526>>>>>>>>>>>>>>>>>>>    Boolean bInitialized
81526>>>>>>>>>>>>>>>>>>>    Integer iItem iCount
81526>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81526>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
81527>>>>>>>>>>>>>>>>>>>
81527>>>>>>>>>>>>>>>>>>>    Move False To bInitialized
81528>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
81529>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(TextAdjusts)) To iCount
81530>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
81532>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
81538>>>>>>>>>>>>>>>>>>>>
81538>>>>>>>>>>>>>>>>>>>        If (TextAdjusts[iItem].iLanguage=iLanguage) Begin
81540>>>>>>>>>>>>>>>>>>>          Move True To bInitialized
81541>>>>>>>>>>>>>>>>>>>          Move iCount To iItem
81542>>>>>>>>>>>>>>>>>>>        End
81542>>>>>>>>>>>>>>>>>>>>
81542>>>>>>>>>>>>>>>>>>>      Loop
81543>>>>>>>>>>>>>>>>>>>>
81543>>>>>>>>>>>>>>>>>>>    End
81543>>>>>>>>>>>>>>>>>>>>
81543>>>>>>>>>>>>>>>>>>>    Function_Return bInitialized
81544>>>>>>>>>>>>>>>>>>>  End_Function
81545>>>>>>>>>>>>>>>>>>>End_Class
81546>>>>>>>>>>>>>>>>>>>
81546>>>>>>>>>>>>>>>>>>>Object oNormalizeCase is a cNormalizeCase
81548>>>>>>>>>>>>>>>>>>>End_Object
81549>>>>>>>>>>>>>>>>>>>
81549>>>>>>>>>>>>>>>>>Use cSciLexerLanguageMixin.pkg
Including file: cSciLexerLanguageMixin.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexerLanguageMixin.pkg)
81549>>>>>>>>>>>>>>>>>>>//TH-Header
81549>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
81549>>>>>>>>>>>>>>>>>>>// Copyright (c)  2017 The Kurant project
81549>>>>>>>>>>>>>>>>>>>// All rights reserved.
81549>>>>>>>>>>>>>>>>>>>//
81549>>>>>>>>>>>>>>>>>>>// $FileName    : Pkg\cSciLexerLanguageMixin.pkg
81549>>>>>>>>>>>>>>>>>>>// $ProjectName : TheHammer3
81549>>>>>>>>>>>>>>>>>>>// $Authors     : wil
81549>>>>>>>>>>>>>>>>>>>// $Created     : 07.16.2017  01:11
81549>>>>>>>>>>>>>>>>>>>//
81549>>>>>>>>>>>>>>>>>>>// Contents:
81549>>>>>>>>>>>>>>>>>>>// A mixin class to help support multiple languages from within the hammer 3.
81549>>>>>>>>>>>>>>>>>>>// Not all of the languages that are in this mixin class are already supported, the supported ones
81549>>>>>>>>>>>>>>>>>>>// can be found in the LexerColorStyles function.
81549>>>>>>>>>>>>>>>>>>>//
81549>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
81549>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
81549>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
81549>>>>>>>>>>>>>>>>>>>Use cSciLexer.h
81549>>>>>>>>>>>>>>>>>>>
81549>>>>>>>>>>>>>>>>>>>Class cSciLexerLanguageMixin is a Mixin
81550>>>>>>>>>>>>>>>>>>>
81550>>>>>>>>>>>>>>>>>>>  Procedure Define_cSciLexerLanguageMixin
81552>>>>>>>>>>>>>>>>>>>  End_Procedure
81553>>>>>>>>>>>>>>>>>>>
81553>>>>>>>>>>>>>>>>>>>  Function SCKeywords String sKeyWords Returns String
81555>>>>>>>>>>>>>>>>>>>    Function_Return (Trim(Replaces("\n", sKeywords, " ")))
81556>>>>>>>>>>>>>>>>>>>  End_Function
81557>>>>>>>>>>>>>>>>>>>
81557>>>>>>>>>>>>>>>>>>>  Function ScintillaLexerForLanguage String sLanguage Returns String
81559>>>>>>>>>>>>>>>>>>>    String sLexer
81559>>>>>>>>>>>>>>>>>>>    Move (Lowercase(Trim(sLanguage))) To sLanguage
81560>>>>>>>>>>>>>>>>>>>    Case Begin
81560>>>>>>>>>>>>>>>>>>>      Case (sLanguage="vdf")
81562>>>>>>>>>>>>>>>>>>>        Move "dataflex" To sLexer
81563>>>>>>>>>>>>>>>>>>>        Case Break
81564>>>>>>>>>>>>>>>>>>>      Case (sLanguage="assembler a68k")
81567>>>>>>>>>>>>>>>>>>>        Move "a68k" To sLexer
81568>>>>>>>>>>>>>>>>>>>        Case Break
81569>>>>>>>>>>>>>>>>>>>      Case (sLanguage="abaqus") // ABAQUX
81572>>>>>>>>>>>>>>>>>>>        Move "abaqus" To sLexer
81573>>>>>>>>>>>>>>>>>>>        Case Break
81574>>>>>>>>>>>>>>>>>>>      Case (sLanguage="ada 95") // ada 95
81577>>>>>>>>>>>>>>>>>>>        Move "ada" To sLexer
81578>>>>>>>>>>>>>>>>>>>        Case Break
81579>>>>>>>>>>>>>>>>>>>      Case (sLanguage="apdl") // APDL
81582>>>>>>>>>>>>>>>>>>>        Move "apdl" To sLexer
81583>>>>>>>>>>>>>>>>>>>        Case Break
81584>>>>>>>>>>>>>>>>>>>      Case (sLanguage="assembler masm") // assembler MASM
81587>>>>>>>>>>>>>>>>>>>        Move "asm" To sLexer            // has a 2nd lexer?
81588>>>>>>>>>>>>>>>>>>>        Case Break
81589>>>>>>>>>>>>>>>>>>>      Case (sLanguage="asn.1")  // Lexer for ASN.1
81592>>>>>>>>>>>>>>>>>>>        Move "asn1" To sLexer
81593>>>>>>>>>>>>>>>>>>>        Case Break
81594>>>>>>>>>>>>>>>>>>>      Case (sLanguage="autoit3") // Lexer for AutoIt3
81597>>>>>>>>>>>>>>>>>>>        Move "au3" To sLexer
81598>>>>>>>>>>>>>>>>>>>        Case Break
81599>>>>>>>>>>>>>>>>>>>      Case (sLanguage="avenue") // Lexer for Avenue
81602>>>>>>>>>>>>>>>>>>>        Move "ave" To sLexer
81603>>>>>>>>>>>>>>>>>>>        Case Break
81604>>>>>>>>>>>>>>>>>>>      Case (sLanguage="avisynth") // Lexer for AviSynth.
81607>>>>>>>>>>>>>>>>>>>        Move "avs" To sLexer
81608>>>>>>>>>>>>>>>>>>>        Case Break
81609>>>>>>>>>>>>>>>>>>>      Case (sLanguage="baan") // Lexer for Baan.
81612>>>>>>>>>>>>>>>>>>>        Move "baan" To sLexer
81613>>>>>>>>>>>>>>>>>>>        Case Break
81614>>>>>>>>>>>>>>>>>>>      Case (sLanguage="bash") // Lexer for Bash.
81617>>>>>>>>>>>>>>>>>>>        Move "bash" To sLexer
81618>>>>>>>>>>>>>>>>>>>        Case Break
81619>>>>>>>>>>>>>>>>>>>      Case (sLanguage="blitz basic")  // Lexer for BlitzBasic and PureBasic.
81622>>>>>>>>>>>>>>>>>>>        Move "blitzbasic" To sLexer
81623>>>>>>>>>>>>>>>>>>>        Case Break
81624>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pure basic")
81627>>>>>>>>>>>>>>>>>>>        Move "purebasic" To sLexer
81628>>>>>>>>>>>>>>>>>>>        Case Break
81629>>>>>>>>>>>>>>>>>>>      Case (sLanguage="free basic")
81632>>>>>>>>>>>>>>>>>>>        Move "freebasic" To sLexer
81633>>>>>>>>>>>>>>>>>>>        Case Break
81634>>>>>>>>>>>>>>>>>>>      Case (sLanguage="batch files")  // Lexer for batch files.
81637>>>>>>>>>>>>>>>>>>>        Move "batch" To sLexer
81638>>>>>>>>>>>>>>>>>>>        Case Break
81639>>>>>>>>>>>>>>>>>>>      Case (sLanguage="bibtex")  // General BibTeX coloring scheme.
81642>>>>>>>>>>>>>>>>>>>        Move "bib" To sLexer
81643>>>>>>>>>>>>>>>>>>>        Case Break
81644>>>>>>>>>>>>>>>>>>>      Case (sLanguage="bullant") // lexer for Bullant
81647>>>>>>>>>>>>>>>>>>>        Move "bullant" To sLexer
81648>>>>>>>>>>>>>>>>>>>        Case Break
81649>>>>>>>>>>>>>>>>>>>      Case (sLanguage="objective caml") // Lexer for Objective Caml
81652>>>>>>>>>>>>>>>>>>>        Move "caml" To sLexer
81653>>>>>>>>>>>>>>>>>>>        Case Break
81654>>>>>>>>>>>>>>>>>>>      Case (sLanguage="clarion") // Case Sensitive Clarion Language Lexer
81657>>>>>>>>>>>>>>>>>>>        Move "clarion" To sLexer
81658>>>>>>>>>>>>>>>>>>>        Case Break
81659>>>>>>>>>>>>>>>>>>>      Case (sLanguage="clarion case insensitive") // Case Insensitive Clarion Language Lexer
81662>>>>>>>>>>>>>>>>>>>        Move "clarionnocase" To sLexer
81663>>>>>>>>>>>>>>>>>>>        Case Break
81664>>>>>>>>>>>>>>>>>>>      Case (sLanguage="cmake") // Lexer for Cmake
81667>>>>>>>>>>>>>>>>>>>        Move "cmake" To sLexer
81668>>>>>>>>>>>>>>>>>>>        Case Break
81669>>>>>>>>>>>>>>>>>>>      Case (sLanguage="cobol") // Lexer for COBOL
81672>>>>>>>>>>>>>>>>>>>        Move "COBOL" To sLexer
81673>>>>>>>>>>>>>>>>>>>        Case Break
81674>>>>>>>>>>>>>>>>>>>      Case (sLanguage="coffeescript") // Lexer for CoffeeScript.
81677>>>>>>>>>>>>>>>>>>>        Move "coffeescript" To sLexer
81678>>>>>>>>>>>>>>>>>>>        Case Break
81679>>>>>>>>>>>>>>>>>>>      Case (sLanguage="apache configuration files") // Lexer for Apache Configuration Files.
81682>>>>>>>>>>>>>>>>>>>        Move "conf" To sLexer
81683>>>>>>>>>>>>>>>>>>>        Case Break
81684>>>>>>>>>>>>>>>>>>>      Case (sLanguage="c/c++") // Lexer for C++, C, Java, and JavaScript.
81687>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
81688>>>>>>>>>>>>>>>>>>>        Case Break
81689>>>>>>>>>>>>>>>>>>>      Case (sLanguage="java") // Lexer for C++, C, Java, and JavaScript.
81692>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
81693>>>>>>>>>>>>>>>>>>>        Case Break
81694>>>>>>>>>>>>>>>>>>>      Case (sLanguage="javascript") // Lexer for C++, C, Java, and JavaScript.
81697>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
81698>>>>>>>>>>>>>>>>>>>        Case Break
81699>>>>>>>>>>>>>>>>>>>      Case (sLanguage="csharp") // Lexer for C++, C, Java, and JavaScript.
81702>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
81703>>>>>>>>>>>>>>>>>>>        Case Break
81704>>>>>>>>>>>>>>>>>>>      Case (sLanguage="go") // Lexer for C++, C, Java, and JavaScript.
81707>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
81708>>>>>>>>>>>>>>>>>>>        Case Break
81709>>>>>>>>>>>>>>>>>>>      Case (sLanguage="swift") // Lexer for C++, C, Java, and JavaScript.
81712>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
81713>>>>>>>>>>>>>>>>>>>        Case Break
81714>>>>>>>>>>>>>>>>>>>      Case (sLanguage="c/c++ case insensitive") // Lexer for C++, C, Java, and JavaScript case insensitive
81717>>>>>>>>>>>>>>>>>>>        Move "cppnocase" To sLexer
81718>>>>>>>>>>>>>>>>>>>        Case Break
81719>>>>>>>>>>>>>>>>>>>      Case (sLanguage="nncron files") //Lexer to use with extended crontab files used by Windows scheduler/event monitor/automation manager nnCron.
81722>>>>>>>>>>>>>>>>>>>        Move "nncrontab" To sLexer
81723>>>>>>>>>>>>>>>>>>>        Case Break
81724>>>>>>>>>>>>>>>>>>>      Case (sLanguage="csound") //Lexer for Csound (Orchestra & Score)
81727>>>>>>>>>>>>>>>>>>>        Move "csound" To sLexer
81728>>>>>>>>>>>>>>>>>>>        Case Break
81729>>>>>>>>>>>>>>>>>>>      Case (sLanguage="css") // Lexer for Cascading Style Sheets
81732>>>>>>>>>>>>>>>>>>>        Move "css" To sLexer
81733>>>>>>>>>>>>>>>>>>>        Case Break
81734>>>>>>>>>>>>>>>>>>>      Case (sLanguage="d") // Lexer for D.
81737>>>>>>>>>>>>>>>>>>>        Move "d" To sLexer
81738>>>>>>>>>>>>>>>>>>>        Case Break
81739>>>>>>>>>>>>>>>>>>>      Case (sLanguage="diff results")  // Lexer for diff results.
81742>>>>>>>>>>>>>>>>>>>        Move "diff" To sLexer
81743>>>>>>>>>>>>>>>>>>>        Case Break
81744>>>>>>>>>>>>>>>>>>>      Case (sLanguage="msc nastran dmap") // Lexer for MSC Nastran DMAP.
81747>>>>>>>>>>>>>>>>>>>        Move "DMAP" To sLexer
81748>>>>>>>>>>>>>>>>>>>        Case Break
81749>>>>>>>>>>>>>>>>>>>      Case (sLanguage="dmis") // Lexer for DMIS.
81752>>>>>>>>>>>>>>>>>>>        Move "DMIS" To sLexer
81753>>>>>>>>>>>>>>>>>>>        Case Break
81754>>>>>>>>>>>>>>>>>>>      Case (sLanguage="ecl") // Lexer for ECL.
81757>>>>>>>>>>>>>>>>>>>        Move "ecl" To sLexer
81758>>>>>>>>>>>>>>>>>>>        Case Break
81759>>>>>>>>>>>>>>>>>>>      Case (sLanguage="edifact") // EDIFACT
81762>>>>>>>>>>>>>>>>>>>        Move "edifact" To sLexer
81763>>>>>>>>>>>>>>>>>>>        Case Break
81764>>>>>>>>>>>>>>>>>>>      Case (sLanguage="eiffel") // Lexer for Eiffel.
81767>>>>>>>>>>>>>>>>>>>        Move "eiffel" To sLexer
81768>>>>>>>>>>>>>>>>>>>        Case Break
81769>>>>>>>>>>>>>>>>>>>      Case (sLanguage="erlang") // Lexer for Erlang.
81772>>>>>>>>>>>>>>>>>>>        Move "erlang" To sLexer
81773>>>>>>>>>>>>>>>>>>>        Case Break
81774>>>>>>>>>>>>>>>>>>>      Case (sLanguage="error lists") //Lexer for error lists. Used for the output pane in SciTE.
81777>>>>>>>>>>>>>>>>>>>        Move "errorlist" To sLexer
81778>>>>>>>>>>>>>>>>>>>        Case Break
81779>>>>>>>>>>>>>>>>>>>      Case (sLanguage="escript") // Lexer for ESCRIPT
81782>>>>>>>>>>>>>>>>>>>        Move "escript" To sLexer
81783>>>>>>>>>>>>>>>>>>>        Case Break
81784>>>>>>>>>>>>>>>>>>>      Case (sLanguage="harbour and flagship") // Lexer for Harbour and FlagShip.
81787>>>>>>>>>>>>>>>>>>>        Move "flagship" To sLexer             // (Syntactically compatible to other xBase dialects, like Clipper, dBase, Clip, FoxPro etc.)
81788>>>>>>>>>>>>>>>>>>>        Case Break
81789>>>>>>>>>>>>>>>>>>>      Case (sLanguage="forth") // Lexer for FORTH
81792>>>>>>>>>>>>>>>>>>>        Move "forth" To sLexer
81793>>>>>>>>>>>>>>>>>>>        Case Break
81794>>>>>>>>>>>>>>>>>>>      Case (sLanguage="fortran") // Lexer for Fortran.
81797>>>>>>>>>>>>>>>>>>>        Move "fortran" To sLexer
81798>>>>>>>>>>>>>>>>>>>        Case Break
81799>>>>>>>>>>>>>>>>>>>      Case (sLanguage="fortran 77")
81802>>>>>>>>>>>>>>>>>>>        Move "f77" To sLexer
81803>>>>>>>>>>>>>>>>>>>        Case Break
81804>>>>>>>>>>>>>>>>>>>      Case (sLanguage="gap") // Lexer for the GAP language. (The GAP System for Computational Discrete Algebra)
81807>>>>>>>>>>>>>>>>>>>        Move "gap" To sLexer
81808>>>>>>>>>>>>>>>>>>>        Case Break
81809>>>>>>>>>>>>>>>>>>>      Case (sLanguage="gui4cli") // This is the Lexer for Gui4Cli
81812>>>>>>>>>>>>>>>>>>>        Move "gui4cli" To sLexer
81813>>>>>>>>>>>>>>>>>>>        Case Break
81814>>>>>>>>>>>>>>>>>>>      Case (sLanguage="haskell") //A haskell lexer for the scintilla code control.
81817>>>>>>>>>>>>>>>>>>>        Move "haskell" To sLexer
81818>>>>>>>>>>>>>>>>>>>        Case Break
81819>>>>>>>>>>>>>>>>>>>      Case (sLanguage="literate haskell")
81822>>>>>>>>>>>>>>>>>>>        Move "literatehaskell" To sLexer
81823>>>>>>>>>>>>>>>>>>>        Case Break
81824>>>>>>>>>>>>>>>>>>>      Case (sLanguage="hex s-record") //Lexers for Motorola S-Record, Intel HEX and Tektronix extended HEX.
81827>>>>>>>>>>>>>>>>>>>        Move "srec" To sLexer
81828>>>>>>>>>>>>>>>>>>>        Case Break
81829>>>>>>>>>>>>>>>>>>>      Case (sLanguage="hex intel")
81832>>>>>>>>>>>>>>>>>>>        Move "ihex" To sLexer
81833>>>>>>>>>>>>>>>>>>>        Case Break
81834>>>>>>>>>>>>>>>>>>>      Case (sLanguage="hex tektronix")
81837>>>>>>>>>>>>>>>>>>>        Move "tehex" To sLexer
81838>>>>>>>>>>>>>>>>>>>        Case Break
81839>>>>>>>>>>>>>>>>>>>      Case (sLanguage="html") // Lexer for HTML.
81842>>>>>>>>>>>>>>>>>>>        Move "hypertext" To sLexer
81843>>>>>>>>>>>>>>>>>>>        Case Break
81844>>>>>>>>>>>>>>>>>>>      Case (sLanguage="xml")
81847>>>>>>>>>>>>>>>>>>>        Move "xml" To sLexer
81848>>>>>>>>>>>>>>>>>>>        Case Break
81849>>>>>>>>>>>>>>>>>>>      Case (sLanguage="php")
81852>>>>>>>>>>>>>>>>>>>        Move "phpscript" To sLexer
81853>>>>>>>>>>>>>>>>>>>        Case Break
81854>>>>>>>>>>>>>>>>>>>      Case (sLanguage="inno setup script") // Lexer for Inno Setup scripts.
81857>>>>>>>>>>>>>>>>>>>        Move "inno" To sLexer
81858>>>>>>>>>>>>>>>>>>>        Case Break
81859>>>>>>>>>>>>>>>>>>>      Case (sLanguage="json") //brief Lexer for JSON and JSON-LD formats
81862>>>>>>>>>>>>>>>>>>>        Move "json" To sLexer
81863>>>>>>>>>>>>>>>>>>>        Case Break
81864>>>>>>>>>>>>>>>>>>>      Case (sLanguage="kix script")  // Lexer for KIX-Scripts.
81867>>>>>>>>>>>>>>>>>>>        Move "kix" To sLexer
81868>>>>>>>>>>>>>>>>>>>        Case Break
81869>>>>>>>>>>>>>>>>>>>      Case (sLanguage="kvirc script") // Lexer for KVIrc script.
81872>>>>>>>>>>>>>>>>>>>        Move "kvirc" To sLexer
81873>>>>>>>>>>>>>>>>>>>        Case Break
81874>>>>>>>>>>>>>>>>>>>      Case (sLanguage="latex") // Lexer for LaTeX2e.
81877>>>>>>>>>>>>>>>>>>>        Move "latex" To sLexer
81878>>>>>>>>>>>>>>>>>>>        Case Break
81879>>>>>>>>>>>>>>>>>>>      Case (sLanguage="lisp") // Lexer for Lisp.
81882>>>>>>>>>>>>>>>>>>>        Move "lisp" To sLexer
81883>>>>>>>>>>>>>>>>>>>        Case Break
81884>>>>>>>>>>>>>>>>>>>      Case (sLanguage="basser lout") // Lexer for the Basser Lout (>= version 3) typesetting language
81887>>>>>>>>>>>>>>>>>>>        Move "lout" To sLexer
81888>>>>>>>>>>>>>>>>>>>        Case Break
81889>>>>>>>>>>>>>>>>>>>      Case (sLanguage="lua") // Lexer for Lua language.
81892>>>>>>>>>>>>>>>>>>>        Move "lua" To sLexer
81893>>>>>>>>>>>>>>>>>>>        Case Break
81894>>>>>>>>>>>>>>>>>>>      Case (sLanguage="magiksf") // Lexer for GE(r) Smallworld(tm) MagikSF
81897>>>>>>>>>>>>>>>>>>>        Move "magiksf" To sLexer
81898>>>>>>>>>>>>>>>>>>>        Case Break
81899>>>>>>>>>>>>>>>>>>>      Case (sLanguage="make file") // Lexer for make files.
81902>>>>>>>>>>>>>>>>>>>        Move "makefile" To sLexer
81903>>>>>>>>>>>>>>>>>>>        Case Break
81904>>>>>>>>>>>>>>>>>>>      Case (sLanguage="markdown") // A simple Markdown lexer for scintilla.
81907>>>>>>>>>>>>>>>>>>>        Move "markdown" To sLexer
81908>>>>>>>>>>>>>>>>>>>        Case Break
81909>>>>>>>>>>>>>>>>>>>      Case (sLanguage="matlab") // Lexer for Matlab.
81912>>>>>>>>>>>>>>>>>>>        Move "matlab" To sLexer
81913>>>>>>>>>>>>>>>>>>>        Case Break
81914>>>>>>>>>>>>>>>>>>>      Case (sLanguage="octave")
81917>>>>>>>>>>>>>>>>>>>        Move "octave" To sLexer
81918>>>>>>>>>>>>>>>>>>>        Case Break
81919>>>>>>>>>>>>>>>>>>>      Case (sLanguage="metapost") // general context conformant metapost coloring scheme
81922>>>>>>>>>>>>>>>>>>>        Move "metapost" To sLexer
81923>>>>>>>>>>>>>>>>>>>        Case Break
81924>>>>>>>>>>>>>>>>>>>      Case (sLanguage="mmix assembler") // Lexer for MMIX Assembler Language.
81927>>>>>>>>>>>>>>>>>>>        Move "mmixal" To sLexer
81928>>>>>>>>>>>>>>>>>>>        Case Break
81929>>>>>>>>>>>>>>>>>>>      Case (sLanguage="modula") // brief Lexer for Modula-2/3 documents.
81932>>>>>>>>>>>>>>>>>>>        Move "modula" To sLexer
81933>>>>>>>>>>>>>>>>>>>        Case Break
81934>>>>>>>>>>>>>>>>>>>      Case (sLanguage="lot") // Lexer for MPT specific files. Based on LexOthers.cxx
81937>>>>>>>>>>>>>>>>>>>        Move "lot" To sLexer //LOT = the text log file created by the MPT application while running a test program
81938>>>>>>>>>>>>>>>>>>>        Case Break
81939>>>>>>>>>>>>>>>>>>>      Case (sLanguage="mssql") // Lexer for MSSQL.
81942>>>>>>>>>>>>>>>>>>>        Move "mssql" To sLexer
81943>>>>>>>>>>>>>>>>>>>        Case Break
81944>>>>>>>>>>>>>>>>>>>      Case (sLanguage="mysql") // Lexer for MySQL
81947>>>>>>>>>>>>>>>>>>>        Move "mysql" To sLexer
81948>>>>>>>>>>>>>>>>>>>        Case Break
81949>>>>>>>>>>>>>>>>>>>      Case (sLanguage="nimrod") // Lexer for Nimrod.
81952>>>>>>>>>>>>>>>>>>>        Move "nimrod" To sLexer
81953>>>>>>>>>>>>>>>>>>>        Case Break
81954>>>>>>>>>>>>>>>>>>>      Case (sLanguage="nsis") // Lexer for NSIS
81957>>>>>>>>>>>>>>>>>>>        Move "nsis" To sLexer
81958>>>>>>>>>>>>>>>>>>>        Case Break
81959>>>>>>>>>>>>>>>>>>>      Case (sLanguage="text") // Lexer for no language. Used for plain text and unrecognized files.
81962>>>>>>>>>>>>>>>>>>>        Move "null" To sLexer
81963>>>>>>>>>>>>>>>>>>>        Case Break
81964>>>>>>>>>>>>>>>>>>>      Case (sLanguage="opal") // Lexer for OPAL (functional language similar to Haskell)
81967>>>>>>>>>>>>>>>>>>>        Move "opal" To sLexer
81968>>>>>>>>>>>>>>>>>>>        Case Break
81969>>>>>>>>>>>>>>>>>>>      Case (sLanguage="oscript") // Lexer for OScript sources; ocx files and/or OSpace dumps.
81972>>>>>>>>>>>>>>>>>>>        Move "oscript" To sLexer
81973>>>>>>>>>>>>>>>>>>>        Case Break
81974>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pascal") // Lexer for Pascal.
81977>>>>>>>>>>>>>>>>>>>        Move "pascal" To sLexer
81978>>>>>>>>>>>>>>>>>>>        Case Break
81979>>>>>>>>>>>>>>>>>>>      Case (sLanguage="powerbasic") // Lexer for PowerBasic
81982>>>>>>>>>>>>>>>>>>>        Move "powerbasic" To sLexer
81983>>>>>>>>>>>>>>>>>>>        Case Break
81984>>>>>>>>>>>>>>>>>>>      Case (sLanguage="perl") // Lexer for Perl
81987>>>>>>>>>>>>>>>>>>>        Move "perl" To sLexer
81988>>>>>>>>>>>>>>>>>>>        Case Break
81989>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pl/m") //
81992>>>>>>>>>>>>>>>>>>>        Move "PL/M" To sLexer
81993>>>>>>>>>>>>>>>>>>>        Case Break
81994>>>>>>>>>>>>>>>>>>>      Case (sLanguage="po files") // Lexer for GetText Translation (PO) files.
81997>>>>>>>>>>>>>>>>>>>        Move "po" To sLexer
81998>>>>>>>>>>>>>>>>>>>        Case Break
81999>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pov-ray sdl") // Lexer for POV-Ray SDL (Persistance of Vision Raytracer, Scene Description Language).
82002>>>>>>>>>>>>>>>>>>>        Move "pov" To sLexer
82003>>>>>>>>>>>>>>>>>>>        Case Break
82004>>>>>>>>>>>>>>>>>>>      Case (sLanguage="powerpro") // PowerPro lexer
82007>>>>>>>>>>>>>>>>>>>        Move "powerpro" To sLexer
82008>>>>>>>>>>>>>>>>>>>        Case Break
82009>>>>>>>>>>>>>>>>>>>      Case (sLanguage="powershell") // Lexer for PowerShell scripts.
82012>>>>>>>>>>>>>>>>>>>        Move "powershell" To sLexer
82013>>>>>>>>>>>>>>>>>>>        Case Break
82014>>>>>>>>>>>>>>>>>>>      Case (sLanguage="progress") //Lexer for Progress 4GL.
82017>>>>>>>>>>>>>>>>>>>        Move "abl" To sLexer
82018>>>>>>>>>>>>>>>>>>>        Case Break
82019>>>>>>>>>>>>>>>>>>>      Case (sLanguage="properties file" or sLanguage="ini") // Lexer for properties files.
82022>>>>>>>>>>>>>>>>>>>        Move "props" To sLexer
82023>>>>>>>>>>>>>>>>>>>        Case Break
82024>>>>>>>>>>>>>>>>>>>      Case (sLanguage="postscript") // Lexer for PostScript
82027>>>>>>>>>>>>>>>>>>>        Move "ps" To sLexer
82028>>>>>>>>>>>>>>>>>>>        Case Break
82029>>>>>>>>>>>>>>>>>>>      Case (sLanguage="python") // Lexer for Python.
82032>>>>>>>>>>>>>>>>>>>        Move "python" To sLexer
82033>>>>>>>>>>>>>>>>>>>        Case Break
82034>>>>>>>>>>>>>>>>>>>      Case (sLanguage="r") // Lexer for R, S, SPlus Statistics Program (Heavily derived from CPP Lexer).
82037>>>>>>>>>>>>>>>>>>>        Move "r" To sLexer
82038>>>>>>>>>>>>>>>>>>>        Case Break
82039>>>>>>>>>>>>>>>>>>>      Case (sLanguage="rebol") // Lexer for REBOL.
82042>>>>>>>>>>>>>>>>>>>        Move "rebol" To sLexer
82043>>>>>>>>>>>>>>>>>>>        Case Break
82044>>>>>>>>>>>>>>>>>>>      Case (sLanguage="windows registry") // brief Lexer for Windows registration files(.reg)
82047>>>>>>>>>>>>>>>>>>>        Move "registry" To sLexer
82048>>>>>>>>>>>>>>>>>>>        Case Break
82049>>>>>>>>>>>>>>>>>>>      Case (sLanguage="ruby") // Lexer for Ruby.
82052>>>>>>>>>>>>>>>>>>>        Move "ruby" To sLexer
82053>>>>>>>>>>>>>>>>>>>        Case Break
82054>>>>>>>>>>>>>>>>>>>      Case (sLanguage="rust") // Lexer for Rust.
82057>>>>>>>>>>>>>>>>>>>        Move "rust" To sLexer
82058>>>>>>>>>>>>>>>>>>>        Case Break
82059>>>>>>>>>>>>>>>>>>>      Case (sLanguage="scriptol") // Lexer for Scriptol.
82062>>>>>>>>>>>>>>>>>>>        Move "scriptol" To sLexer
82063>>>>>>>>>>>>>>>>>>>        Case Break
82064>>>>>>>>>>>>>>>>>>>      Case (sLanguage="smalltalk") // Lexer for Smalltalk language.
82067>>>>>>>>>>>>>>>>>>>        Move "smalltalk" To sLexer
82068>>>>>>>>>>>>>>>>>>>        Case Break
82069>>>>>>>>>>>>>>>>>>>      Case (sLanguage="sml") // Lexer for SML.
82072>>>>>>>>>>>>>>>>>>>        Move "SML" To sLexer
82073>>>>>>>>>>>>>>>>>>>        Case Break
82074>>>>>>>>>>>>>>>>>>>      Case (sLanguage="sorcus installation file") // Lexer for SORCUS installation files
82077>>>>>>>>>>>>>>>>>>>        Move "sorcins" To sLexer
82078>>>>>>>>>>>>>>>>>>>        Case Break
82079>>>>>>>>>>>>>>>>>>>      Case (sLanguage="specman") // Lexer for Specman E language.
82082>>>>>>>>>>>>>>>>>>>        Move "specman" To sLexer
82083>>>>>>>>>>>>>>>>>>>        Case Break
82084>>>>>>>>>>>>>>>>>>>      Case (sLanguage="spice") // Lexer for Spice
82087>>>>>>>>>>>>>>>>>>>        Move "spice" To sLexer
82088>>>>>>>>>>>>>>>>>>>        Case Break
82089>>>>>>>>>>>>>>>>>>>      Case (sLanguage="sql") // Lexer for SQL, including PL/SQL and SQL*Plus.
82092>>>>>>>>>>>>>>>>>>>        Move "sql" To sLexer
82093>>>>>>>>>>>>>>>>>>>        Case Break
82094>>>>>>>>>>>>>>>>>>>      Case (sLanguage="structured text") // Lexer for Structured Text language.
82097>>>>>>>>>>>>>>>>>>>        Move "fcST" To sLexer
82098>>>>>>>>>>>>>>>>>>>        Case Break
82099>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tacl") // Lexer for TAL
82102>>>>>>>>>>>>>>>>>>>        Move "TACL" To sLexer
82103>>>>>>>>>>>>>>>>>>>        Case Break
82104>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tads3") // Lexer for TADS3.
82107>>>>>>>>>>>>>>>>>>>        Move "tads3" To sLexer
82108>>>>>>>>>>>>>>>>>>>        Case Break
82109>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tal") // Lexer for TAL
82112>>>>>>>>>>>>>>>>>>>        Move "TAL" To sLexer
82113>>>>>>>>>>>>>>>>>>>        Case Break
82114>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tcl") // Lexer for TCL language.
82117>>>>>>>>>>>>>>>>>>>        Move "tcl" To sLexer
82118>>>>>>>>>>>>>>>>>>>        Case Break
82119>>>>>>>>>>>>>>>>>>>      Case (sLanguage="take command") // Lexer for Take Command / TCC batch scripts (.bat, .btm, .cmd).
82122>>>>>>>>>>>>>>>>>>>        Move "tcmd" To sLexer
82123>>>>>>>>>>>>>>>>>>>        Case Break
82124>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tex coloring scheme") // File: LexTeX.cxx - general context conformant tex coloring scheme
82127>>>>>>>>>>>>>>>>>>>        Move "tex" To sLexer
82128>>>>>>>>>>>>>>>>>>>        Case Break
82129>>>>>>>>>>>>>>>>>>>      Case (sLanguage="txt2tags") // A simple Txt2tags lexer for scintilla.
82132>>>>>>>>>>>>>>>>>>>        Move "txt2tags" To sLexer
82133>>>>>>>>>>>>>>>>>>>        Case Break
82134>>>>>>>>>>>>>>>>>>>      Case (sLanguage="visual basic") // Lexer for Visual Basic and VBScript.
82137>>>>>>>>>>>>>>>>>>>        Move "vb" To sLexer
82138>>>>>>>>>>>>>>>>>>>        Case Break
82139>>>>>>>>>>>>>>>>>>>      Case (sLanguage="basic") // using vb as a default for just "basic"
82142>>>>>>>>>>>>>>>>>>>        Move "vb" To sLexer
82143>>>>>>>>>>>>>>>>>>>        Case Break
82144>>>>>>>>>>>>>>>>>>>      Case (sLanguage="vbscript")
82147>>>>>>>>>>>>>>>>>>>        Move "vbscript" To sLexer
82148>>>>>>>>>>>>>>>>>>>        Case Break
82149>>>>>>>>>>>>>>>>>>>      Case (sLanguage="verilog") // Lexer for Verilog.
82152>>>>>>>>>>>>>>>>>>>        Move "verilog" To sLexer
82153>>>>>>>>>>>>>>>>>>>        Case Break
82154>>>>>>>>>>>>>>>>>>>      Case (sLanguage="vhdl") // Lexer for VHDL
82157>>>>>>>>>>>>>>>>>>>        Move "vhdl" To sLexer
82158>>>>>>>>>>>>>>>>>>>        Case Break
82159>>>>>>>>>>>>>>>>>>>      Case (sLanguage="visual prolog") // Lexer for Visual Prolog.
82162>>>>>>>>>>>>>>>>>>>        Move "visualprolog" To sLexer
82163>>>>>>>>>>>>>>>>>>>        Case Break
82164>>>>>>>>>>>>>>>>>>>      Case (sLanguage="yaml") // Lexer for YAML.
82167>>>>>>>>>>>>>>>>>>>        Move "yaml" To sLexer
82168>>>>>>>>>>>>>>>>>>>        Case Break
82169>>>>>>>>>>>>>>>>>>>      Case Else
82169>>>>>>>>>>>>>>>>>>>        Move "dataflex" To sLexer
82170>>>>>>>>>>>>>>>>>>>    Case End
82170>>>>>>>>>>>>>>>>>>>
82170>>>>>>>>>>>>>>>>>>>    Function_Return sLexer
82171>>>>>>>>>>>>>>>>>>>  End_Function
82172>>>>>>>>>>>>>>>>>>>
82172>>>>>>>>>>>>>>>>>>>
82172>>>>>>>>>>>>>>>>>>>  Function LanguageForScintillaLexer String sLexer Returns String
82174>>>>>>>>>>>>>>>>>>>    String sLanguage
82174>>>>>>>>>>>>>>>>>>>    Move (Lowercase(Trim(sLexer))) To sLexer
82175>>>>>>>>>>>>>>>>>>>    Case Begin
82175>>>>>>>>>>>>>>>>>>>      Case (sLexer="dataflex")
82177>>>>>>>>>>>>>>>>>>>        Move "VDF" To sLanguage
82178>>>>>>>>>>>>>>>>>>>        Case Break
82179>>>>>>>>>>>>>>>>>>>        //Case (sLexer="assembler a68k")
82179>>>>>>>>>>>>>>>>>>>        //  Move "a68k" to sLexer
82179>>>>>>>>>>>>>>>>>>>        //  Case Break
82179>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="abaqus") // ABAQUS
82179>>>>>>>>>>>>>>>>>>>        //  Move "abaqus" to sLexer
82179>>>>>>>>>>>>>>>>>>>        //  Case Break
82179>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="ada 95") // ada 95
82179>>>>>>>>>>>>>>>>>>>        //  Move "ada" to sLexer
82179>>>>>>>>>>>>>>>>>>>        //  Case Break
82179>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="apdl") // APDL
82179>>>>>>>>>>>>>>>>>>>        //  Move "apdl" to sLexer
82179>>>>>>>>>>>>>>>>>>>        //  Case Break
82179>>>>>>>>>>>>>>>>>>>      Case (sLexer="asm") //
82182>>>>>>>>>>>>>>>>>>>        Move "assembler MASM" To sLanguage
82183>>>>>>>>>>>>>>>>>>>        Case Break
82184>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="asn.1")  // Lexer for ASN.1
82184>>>>>>>>>>>>>>>>>>>        //  Move "asn1" to sLexer
82184>>>>>>>>>>>>>>>>>>>        //  Case Break
82184>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="autoit3") // Lexer for AutoIt3
82184>>>>>>>>>>>>>>>>>>>        //  Move "au3" to sLexer
82184>>>>>>>>>>>>>>>>>>>        //  Case Break
82184>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="avenue") // Lexer for Avenue
82184>>>>>>>>>>>>>>>>>>>        //  Move "ave" to sLexer
82184>>>>>>>>>>>>>>>>>>>        //  Case Break
82184>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="avisynth") // Lexer for AviSynth.
82184>>>>>>>>>>>>>>>>>>>        //  Move "avs" to sLexer
82184>>>>>>>>>>>>>>>>>>>        //  Case Break
82184>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="baan") // Lexer for Baan.
82184>>>>>>>>>>>>>>>>>>>        //  Move "baan" to sLexer
82184>>>>>>>>>>>>>>>>>>>        //  Case Break
82184>>>>>>>>>>>>>>>>>>>      Case (sLexer="bash") // Lexer for Bash.
82187>>>>>>>>>>>>>>>>>>>        Move "Bash" To sLanguage
82188>>>>>>>>>>>>>>>>>>>        Case Break
82189>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="blitz basic")  // Lexer for BlitzBasic and PureBasic.
82189>>>>>>>>>>>>>>>>>>>        //  Move "blitzbasic" to sLexer
82189>>>>>>>>>>>>>>>>>>>        //  Case Break
82189>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="pure basic")
82189>>>>>>>>>>>>>>>>>>>        //  Move "purebasic" to sLexer
82189>>>>>>>>>>>>>>>>>>>        //  Case Break
82189>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="free basic")
82189>>>>>>>>>>>>>>>>>>>        //  Move "freebasic" to sLexer
82189>>>>>>>>>>>>>>>>>>>        //  Case Break
82189>>>>>>>>>>>>>>>>>>>      Case (sLexer="batch")  // Lexer for batch files.
82192>>>>>>>>>>>>>>>>>>>        Move "Batch files" To sLanguage
82193>>>>>>>>>>>>>>>>>>>        Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="bibtex")  // General BibTeX coloring scheme.
82194>>>>>>>>>>>>>>>>>>>        //  Move "bib" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="bullant") // lexer for Bullant
82194>>>>>>>>>>>>>>>>>>>        //  Move "bullant" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="objective caml") // Lexer for Objective Caml
82194>>>>>>>>>>>>>>>>>>>        //  Move "caml" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="clarion") // Case Sensitive Clarion Language Lexer
82194>>>>>>>>>>>>>>>>>>>        //  Move "clarion" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="clarion case insensitive") // Case Insensitive Clarion Language Lexer
82194>>>>>>>>>>>>>>>>>>>        //  Move "clarionnocase" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="cmake") // Lexer for Cmake
82194>>>>>>>>>>>>>>>>>>>        //  Move "cmake" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="cobol") // Lexer for COBOL
82194>>>>>>>>>>>>>>>>>>>        //  Move "COBOL" to sLexer
82194>>>>>>>>>>>>>>>>>>>        //  Case Break
82194>>>>>>>>>>>>>>>>>>>      Case (sLexer="coffeescript") // Lexer for CoffeeScript.
82197>>>>>>>>>>>>>>>>>>>        Move "CoffeeScript" To sLanguage
82198>>>>>>>>>>>>>>>>>>>        Case Break
82199>>>>>>>>>>>>>>>>>>>      Case (sLexer="conf") // Lexer for Apache Configuration Files.
82202>>>>>>>>>>>>>>>>>>>        Move "Apache Configuration Files" To sLanguage
82203>>>>>>>>>>>>>>>>>>>        Case Break
82204>>>>>>>>>>>>>>>>>>>      Case (sLexer="cpp") // Lexer for C++, C, Java, and JavaScript.
82207>>>>>>>>>>>>>>>>>>>        Move "C/C++" To sLanguage
82208>>>>>>>>>>>>>>>>>>>        Case Break
82209>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="java") // Lexer for C++, C, Java, and JavaScript.
82209>>>>>>>>>>>>>>>>>>>        //  Move "cpp" to sLexer
82209>>>>>>>>>>>>>>>>>>>        //  Case Break
82209>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="javascript") // Lexer for C++, C, Java, and JavaScript.
82209>>>>>>>>>>>>>>>>>>>        //  Move "cpp" to sLexer
82209>>>>>>>>>>>>>>>>>>>        //  Case Break
82209>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="c/c++ case insensitive") // Lexer for C++, C, Java, and JavaScript case insensitive
82209>>>>>>>>>>>>>>>>>>>        //  Move "cppnocase" to sLexer
82209>>>>>>>>>>>>>>>>>>>        //  Case Break
82209>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="nncron files") //Lexer to use with extended crontab files used by Windows scheduler/event monitor/automation manager nnCron.
82209>>>>>>>>>>>>>>>>>>>        //  Move "nncrontab" to sLexer
82209>>>>>>>>>>>>>>>>>>>        //  Case Break
82209>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="csound") //Lexer for Csound (Orchestra & Score)
82209>>>>>>>>>>>>>>>>>>>        //  Move "csound" to sLexer
82209>>>>>>>>>>>>>>>>>>>        //  Case Break
82209>>>>>>>>>>>>>>>>>>>      Case (sLexer="css") // Lexer for Cascading Style Sheets
82212>>>>>>>>>>>>>>>>>>>        Move "CSS" To sLanguage
82213>>>>>>>>>>>>>>>>>>>        Case Break
82214>>>>>>>>>>>>>>>>>>>      Case (sLexer="d") // Lexer for D.
82217>>>>>>>>>>>>>>>>>>>        Move "D" To sLanguage
82218>>>>>>>>>>>>>>>>>>>        Case Break
82219>>>>>>>>>>>>>>>>>>>      Case (sLexer="diff")  // Lexer for diff results.
82222>>>>>>>>>>>>>>>>>>>        Move "diff results" To sLanguage
82223>>>>>>>>>>>>>>>>>>>        Case Break
82224>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="msc nastran dmap") // Lexer for MSC Nastran DMAP.
82224>>>>>>>>>>>>>>>>>>>        //  Move "DMAP" to sLexer
82224>>>>>>>>>>>>>>>>>>>        //  Case Break
82224>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="dmis") // Lexer for DMIS.
82224>>>>>>>>>>>>>>>>>>>        //  Move "DMIS" to sLexer
82224>>>>>>>>>>>>>>>>>>>        //  Case Break
82224>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="ecl") // Lexer for ECL.
82224>>>>>>>>>>>>>>>>>>>        //  Move "ecl" to sLexer
82224>>>>>>>>>>>>>>>>>>>        //  Case Break
82224>>>>>>>>>>>>>>>>>>>      Case (sLexer="edifact") // EDIFACT
82227>>>>>>>>>>>>>>>>>>>        Move "EDIFACT" To sLanguage
82228>>>>>>>>>>>>>>>>>>>        Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="eiffel") // Lexer for Eiffel.
82229>>>>>>>>>>>>>>>>>>>        //  Move "eiffel" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="erlang") // Lexer for Erlang.
82229>>>>>>>>>>>>>>>>>>>        //  Move "erlang" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="error lists") //Lexer for error lists. Used for the output pane in SciTE.
82229>>>>>>>>>>>>>>>>>>>        //  Move "errorlist" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="escript") // Lexer for ESCRIPT
82229>>>>>>>>>>>>>>>>>>>        //  Move "escript" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="harbour and flagship") // Lexer for Harbour and FlagShip.
82229>>>>>>>>>>>>>>>>>>>        //  Move "flagship" to sLexer             // (Syntactically compatible to other xBase dialects, like Clipper, dBase, Clip, FoxPro etc.)
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="forth") // Lexer for FORTH
82229>>>>>>>>>>>>>>>>>>>        //  Move "forth" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="fortran") // Lexer for Fortran.
82229>>>>>>>>>>>>>>>>>>>        //  Move "fortran" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="fortran 77")
82229>>>>>>>>>>>>>>>>>>>        //  Move "f77" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="gap") // Lexer for the GAP language. (The GAP System for Computational Discrete Algebra)
82229>>>>>>>>>>>>>>>>>>>        //  Move "gap" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="gui4cli") // This is the Lexer for Gui4Cli
82229>>>>>>>>>>>>>>>>>>>        //  Move "gui4cli" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="haskell") //A haskell lexer for the scintilla code control.
82229>>>>>>>>>>>>>>>>>>>        //  Move "haskell" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="literate haskell")
82229>>>>>>>>>>>>>>>>>>>        //  Move "literatehaskell" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="hex s-record") //Lexers for Motorola S-Record, Intel HEX and Tektronix extended HEX.
82229>>>>>>>>>>>>>>>>>>>        //  Move "srec" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="hex intel")
82229>>>>>>>>>>>>>>>>>>>        //  Move "ihex" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="hex tektronix")
82229>>>>>>>>>>>>>>>>>>>        //  Move "tehex" to sLexer
82229>>>>>>>>>>>>>>>>>>>        //  Case Break
82229>>>>>>>>>>>>>>>>>>>      Case (sLexer="hypertext") // Lexer for HTML.
82232>>>>>>>>>>>>>>>>>>>        Move "HTML" To sLanguage
82233>>>>>>>>>>>>>>>>>>>        Case Break
82234>>>>>>>>>>>>>>>>>>>      Case (sLexer="xml")
82237>>>>>>>>>>>>>>>>>>>        Move "XML" To sLanguage
82238>>>>>>>>>>>>>>>>>>>        Case Break
82239>>>>>>>>>>>>>>>>>>>      Case (sLexer="phpscript")
82242>>>>>>>>>>>>>>>>>>>        Move "PHP" To sLanguage
82243>>>>>>>>>>>>>>>>>>>        Case Break
82244>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="inno setup script") // Lexer for Inno Setup scripts.
82244>>>>>>>>>>>>>>>>>>>        //  Move "inno" to sLexer
82244>>>>>>>>>>>>>>>>>>>        //  Case Break
82244>>>>>>>>>>>>>>>>>>>      Case (sLexer="json") //brief Lexer for JSON and JSON-LD formats
82247>>>>>>>>>>>>>>>>>>>        Move "JSON" To sLanguage
82248>>>>>>>>>>>>>>>>>>>        Case Break
82249>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="kix script")  // Lexer for KIX-Scripts.
82249>>>>>>>>>>>>>>>>>>>        //  Move "kix" to sLexer
82249>>>>>>>>>>>>>>>>>>>        //  Case Break
82249>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="kvirc script") // Lexer for KVIrc script.
82249>>>>>>>>>>>>>>>>>>>        //  Move "kvirc" to sLexer
82249>>>>>>>>>>>>>>>>>>>        //  Case Break
82249>>>>>>>>>>>>>>>>>>>      Case (sLexer="latex") // Lexer for LaTeX2e.
82252>>>>>>>>>>>>>>>>>>>        Move "LaTeX" To sLanguage
82253>>>>>>>>>>>>>>>>>>>        Case Break
82254>>>>>>>>>>>>>>>>>>>      Case (sLexer="lisp") // Lexer for Lisp.
82257>>>>>>>>>>>>>>>>>>>        Move "Lisp" To sLanguage
82258>>>>>>>>>>>>>>>>>>>        Case Break
82259>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="basser lout") // Lexer for the Basser Lout (>= version 3) typesetting language
82259>>>>>>>>>>>>>>>>>>>        //  Move "lout" to sLexer
82259>>>>>>>>>>>>>>>>>>>        //  Case Break
82259>>>>>>>>>>>>>>>>>>>      Case (sLexer="lua") // Lexer for Lua language.
82262>>>>>>>>>>>>>>>>>>>        Move "Lua" To sLanguage
82263>>>>>>>>>>>>>>>>>>>        Case Break
82264>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="magiksf") // Lexer for GE(r) Smallworld(tm) MagikSF
82264>>>>>>>>>>>>>>>>>>>        //  Move "magiksf" to sLexer
82264>>>>>>>>>>>>>>>>>>>        //  Case Break
82264>>>>>>>>>>>>>>>>>>>      Case (sLexer="makefile") // Lexer for make files.
82267>>>>>>>>>>>>>>>>>>>        Move "make file" To sLanguage
82268>>>>>>>>>>>>>>>>>>>        Case Break
82269>>>>>>>>>>>>>>>>>>>      Case (sLexer="markdown") // A simple Markdown lexer for scintilla.
82272>>>>>>>>>>>>>>>>>>>        Move "Markdown" To sLanguage
82273>>>>>>>>>>>>>>>>>>>        Case Break
82274>>>>>>>>>>>>>>>>>>>      Case (sLexer="matlab") // Lexer for Matlab.
82277>>>>>>>>>>>>>>>>>>>        Move "Matlab" To sLanguage
82278>>>>>>>>>>>>>>>>>>>        Case Break
82279>>>>>>>>>>>>>>>>>>>      Case (sLexer="octave")
82282>>>>>>>>>>>>>>>>>>>        Move "Octave" To sLanguage
82283>>>>>>>>>>>>>>>>>>>        Case Break
82284>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="metapost") // general context conformant metapost coloring scheme
82284>>>>>>>>>>>>>>>>>>>        //  Move "metapost" to sLexer
82284>>>>>>>>>>>>>>>>>>>        //  Case Break
82284>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="mmix assembler") // Lexer for MMIX Assembler Language.
82284>>>>>>>>>>>>>>>>>>>        //  Move "mmixal" to sLexer
82284>>>>>>>>>>>>>>>>>>>        //  Case Break
82284>>>>>>>>>>>>>>>>>>>      Case (sLexer="modula") // brief Lexer for Modula-2/3 documents.
82287>>>>>>>>>>>>>>>>>>>        Move "Modula" To sLanguage
82288>>>>>>>>>>>>>>>>>>>        Case Break
82289>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="lot") // Lexer for MPT specific files. Based on LexOthers.cxx
82289>>>>>>>>>>>>>>>>>>>        //  Move "lot" to sLexer //LOT = the text log file created by the MPT application while running a test program
82289>>>>>>>>>>>>>>>>>>>        //  Case Break
82289>>>>>>>>>>>>>>>>>>>      Case (sLexer="mssql") // Lexer for MSSQL.
82292>>>>>>>>>>>>>>>>>>>        Move "MSSQL" To sLanguage
82293>>>>>>>>>>>>>>>>>>>        Case Break
82294>>>>>>>>>>>>>>>>>>>      Case (sLexer="mysql") // Lexer for MySQL
82297>>>>>>>>>>>>>>>>>>>        Move "MySQL" To sLanguage
82298>>>>>>>>>>>>>>>>>>>        Case Break
82299>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="nimrod") // Lexer for Nimrod.
82299>>>>>>>>>>>>>>>>>>>        //  Move "nimrod" to sLexer
82299>>>>>>>>>>>>>>>>>>>        //  Case Break
82299>>>>>>>>>>>>>>>>>>>      Case (sLexer="nsis") // Lexer for NSIS
82302>>>>>>>>>>>>>>>>>>>        Move "NSIS" To sLanguage
82303>>>>>>>>>>>>>>>>>>>        Case Break
82304>>>>>>>>>>>>>>>>>>>      Case (sLexer="null") // Lexer for no language. Used for plain text and unrecognized files.
82307>>>>>>>>>>>>>>>>>>>        Move "Text" To sLanguage
82308>>>>>>>>>>>>>>>>>>>        Case Break
82309>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="opal") // Lexer for OPAL (functional language similar to Haskell)
82309>>>>>>>>>>>>>>>>>>>        //  Move "opal" to sLexer
82309>>>>>>>>>>>>>>>>>>>        //  Case Break
82309>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="oscript") // Lexer for OScript sources; ocx files and/or OSpace dumps.
82309>>>>>>>>>>>>>>>>>>>        //  Move "oscript" to sLexer
82309>>>>>>>>>>>>>>>>>>>        //  Case Break
82309>>>>>>>>>>>>>>>>>>>      Case (sLexer="pascal") // Lexer for Pascal.
82312>>>>>>>>>>>>>>>>>>>        Move "Pascal" To sLanguage
82313>>>>>>>>>>>>>>>>>>>        Case Break
82314>>>>>>>>>>>>>>>>>>>      Case (sLexer="powerbasic") // Lexer for PowerBasic
82317>>>>>>>>>>>>>>>>>>>        Move "PowerBasic" To sLanguage
82318>>>>>>>>>>>>>>>>>>>        Case Break
82319>>>>>>>>>>>>>>>>>>>      Case (sLexer="perl") // Lexer for Perl
82322>>>>>>>>>>>>>>>>>>>        Move "Perl" To sLanguage
82323>>>>>>>>>>>>>>>>>>>        Case Break
82324>>>>>>>>>>>>>>>>>>>      Case (sLexer="pl/m") //
82327>>>>>>>>>>>>>>>>>>>        Move "PL/M" To sLanguage
82328>>>>>>>>>>>>>>>>>>>        Case Break
82329>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="po files") // Lexer for GetText Translation (PO) files.
82329>>>>>>>>>>>>>>>>>>>        //  Move "po" to sLexer
82329>>>>>>>>>>>>>>>>>>>        //  Case Break
82329>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="pov-ray sdl") // Lexer for POV-Ray SDL (Persistance of Vision Raytracer, Scene Description Language).
82329>>>>>>>>>>>>>>>>>>>        //  Move "pov" to sLexer
82329>>>>>>>>>>>>>>>>>>>        //  Case Break
82329>>>>>>>>>>>>>>>>>>>      Case (sLexer="powerpro") // PowerPro lexer
82332>>>>>>>>>>>>>>>>>>>        Move "PowerPro" To sLanguage
82333>>>>>>>>>>>>>>>>>>>        Case Break
82334>>>>>>>>>>>>>>>>>>>      Case (sLexer="powershell") // Lexer for PowerShell scripts.
82337>>>>>>>>>>>>>>>>>>>        Move "PowerShell" To sLanguage
82338>>>>>>>>>>>>>>>>>>>        Case Break
82339>>>>>>>>>>>>>>>>>>>      Case (sLexer="abl") //Lexer for Progress 4GL.
82342>>>>>>>>>>>>>>>>>>>        Move "Progress" To sLanguage
82343>>>>>>>>>>>>>>>>>>>        Case Break
82344>>>>>>>>>>>>>>>>>>>      Case (sLexer="props") // Lexer for properties files.
82347>>>>>>>>>>>>>>>>>>>        Move "properties file" To sLanguage
82348>>>>>>>>>>>>>>>>>>>        Case Break
82349>>>>>>>>>>>>>>>>>>>      Case (sLexer="ps") // Lexer for PostScript
82352>>>>>>>>>>>>>>>>>>>        Move "PostScript" To sLanguage
82353>>>>>>>>>>>>>>>>>>>        Case Break
82354>>>>>>>>>>>>>>>>>>>      Case (sLexer="python") // Lexer for Python.
82357>>>>>>>>>>>>>>>>>>>        Move "Python" To sLanguage
82358>>>>>>>>>>>>>>>>>>>        Case Break
82359>>>>>>>>>>>>>>>>>>>      Case (sLexer="r") // Lexer for R, S, SPlus Statistics Program (Heavily derived from CPP Lexer).
82362>>>>>>>>>>>>>>>>>>>        Move "R" To sLanguage
82363>>>>>>>>>>>>>>>>>>>        Case Break
82364>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="rebol") // Lexer for REBOL.
82364>>>>>>>>>>>>>>>>>>>        //  Move "rebol" to sLexer
82364>>>>>>>>>>>>>>>>>>>        //  Case Break
82364>>>>>>>>>>>>>>>>>>>      Case (sLexer="registry") // brief Lexer for Windows registration files(.reg)
82367>>>>>>>>>>>>>>>>>>>        Move "Windows Registry" To sLanguage
82368>>>>>>>>>>>>>>>>>>>        Case Break
82369>>>>>>>>>>>>>>>>>>>      Case (sLexer="ruby") // Lexer for Ruby.
82372>>>>>>>>>>>>>>>>>>>        Move "Ruby" To sLanguage
82373>>>>>>>>>>>>>>>>>>>        Case Break
82374>>>>>>>>>>>>>>>>>>>      Case (sLexer="rust") // Lexer for Rust.
82377>>>>>>>>>>>>>>>>>>>        Move "Rust" To sLanguage
82378>>>>>>>>>>>>>>>>>>>        Case Break
82379>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="scriptol") // Lexer for Scriptol.
82379>>>>>>>>>>>>>>>>>>>        //  Move "scriptol" to sLexer
82379>>>>>>>>>>>>>>>>>>>        //  Case Break
82379>>>>>>>>>>>>>>>>>>>      Case (sLexer="smalltalk") // Lexer for Smalltalk language.
82382>>>>>>>>>>>>>>>>>>>        Move "Smalltalk" To sLanguage
82383>>>>>>>>>>>>>>>>>>>        Case Break
82384>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="sml") // Lexer for SML.
82384>>>>>>>>>>>>>>>>>>>        //  Move "SML" to sLexer
82384>>>>>>>>>>>>>>>>>>>        //  Case Break
82384>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="sorcus installation file") // Lexer for SORCUS installation files
82384>>>>>>>>>>>>>>>>>>>        //  Move "sorcins" to sLexer
82384>>>>>>>>>>>>>>>>>>>        //  Case Break
82384>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="specman") // Lexer for Specman E language.
82384>>>>>>>>>>>>>>>>>>>        //  Move "specman" to sLexer
82384>>>>>>>>>>>>>>>>>>>        //  Case Break
82384>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="spice") // Lexer for Spice
82384>>>>>>>>>>>>>>>>>>>        //  Move "spice" to sLexer
82384>>>>>>>>>>>>>>>>>>>        //  Case Break
82384>>>>>>>>>>>>>>>>>>>      Case (sLexer="sql") // Lexer for SQL, including PL/SQL and SQL*Plus.
82387>>>>>>>>>>>>>>>>>>>        Move "SQL" To sLanguage
82388>>>>>>>>>>>>>>>>>>>        Case Break
82389>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="structured text") // Lexer for Structured Text language.
82389>>>>>>>>>>>>>>>>>>>        //  Move "fcST" to sLexer
82389>>>>>>>>>>>>>>>>>>>        //  Case Break
82389>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tacl") // Lexer for TAL
82389>>>>>>>>>>>>>>>>>>>        //  Move "TACL" to sLexer
82389>>>>>>>>>>>>>>>>>>>        //  Case Break
82389>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tads3") // Lexer for TADS3.
82389>>>>>>>>>>>>>>>>>>>        //  Move "tads3" to sLexer
82389>>>>>>>>>>>>>>>>>>>        //  Case Break
82389>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tal") // Lexer for TAL
82389>>>>>>>>>>>>>>>>>>>        //  Move "TAL" to sLexer
82389>>>>>>>>>>>>>>>>>>>        //  Case Break
82389>>>>>>>>>>>>>>>>>>>      Case (sLexer="tcl") // Lexer for TCL language.
82392>>>>>>>>>>>>>>>>>>>        Move "TCL" To sLanguage
82393>>>>>>>>>>>>>>>>>>>        Case Break
82394>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="take command") // Lexer for Take Command / TCC batch scripts (.bat, .btm, .cmd).
82394>>>>>>>>>>>>>>>>>>>        //  Move "tcmd" to sLexer
82394>>>>>>>>>>>>>>>>>>>        //  Case Break
82394>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tex coloring scheme") // File: LexTeX.cxx - general context conformant tex coloring scheme
82394>>>>>>>>>>>>>>>>>>>        //  Move "tex" to sLexer
82394>>>>>>>>>>>>>>>>>>>        //  Case Break
82394>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="txt2tags") // A simple Txt2tags lexer for scintilla.
82394>>>>>>>>>>>>>>>>>>>        //  Move "txt2tags" to sLexer
82394>>>>>>>>>>>>>>>>>>>        //  Case Break
82394>>>>>>>>>>>>>>>>>>>      Case (sLexer="vb") // Lexer for Visual Basic and VBScript.
82397>>>>>>>>>>>>>>>>>>>        Move "Visual Basic" To sLanguage
82398>>>>>>>>>>>>>>>>>>>        Case Break
82399>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="basic") // using vb as a default for just "basic"
82399>>>>>>>>>>>>>>>>>>>        //  Move "vb" to sLexer
82399>>>>>>>>>>>>>>>>>>>        //  Case Break
82399>>>>>>>>>>>>>>>>>>>      Case (sLexer="vbscript")
82402>>>>>>>>>>>>>>>>>>>        Move "VBScript" To sLanguage
82403>>>>>>>>>>>>>>>>>>>        Case Break
82404>>>>>>>>>>>>>>>>>>>      Case (sLexer="verilog") // Lexer for Verilog.
82407>>>>>>>>>>>>>>>>>>>        Move "Verilog" To sLanguage
82408>>>>>>>>>>>>>>>>>>>        Case Break
82409>>>>>>>>>>>>>>>>>>>      Case (sLexer="vhdl") // Lexer for VHDL
82412>>>>>>>>>>>>>>>>>>>        Move "VHDL" To sLanguage
82413>>>>>>>>>>>>>>>>>>>        Case Break
82414>>>>>>>>>>>>>>>>>>>      Case (sLexer="visualprolog") // Lexer for Visual Prolog.
82417>>>>>>>>>>>>>>>>>>>        Move "Visual Prolog" To sLanguage
82418>>>>>>>>>>>>>>>>>>>        Case Break
82419>>>>>>>>>>>>>>>>>>>      Case (sLexer="yaml") // Lexer for YAML.
82422>>>>>>>>>>>>>>>>>>>        Move "YAML" To sLanguage
82423>>>>>>>>>>>>>>>>>>>        Case Break
82424>>>>>>>>>>>>>>>>>>>      Case Else
82424>>>>>>>>>>>>>>>>>>>        Move "DataFlex" To sLanguage
82425>>>>>>>>>>>>>>>>>>>    Case End
82425>>>>>>>>>>>>>>>>>>>
82425>>>>>>>>>>>>>>>>>>>    Function_Return sLanguage
82426>>>>>>>>>>>>>>>>>>>  End_Function // LanguageForScintillaLexer
82427>>>>>>>>>>>>>>>>>>>
82427>>>>>>>>>>>>>>>>>>>
82427>>>>>>>>>>>>>>>>>>>  //
82427>>>>>>>>>>>>>>>>>>>  //
82427>>>>>>>>>>>>>>>>>>>  Procedure SetAppearance Integer iStyle Integer iColorIndex
82429>>>>>>>>>>>>>>>>>>>    Integer iBackColor
82429>>>>>>>>>>>>>>>>>>>
82429>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFORE   iStyle gtColorer[iColorIndex].iForeC
82430>>>>>>>>>>>>>>>>>>>    Move gtColorer[iColorIndex].iBackC To iBackColor
82431>>>>>>>>>>>>>>>>>>>    If (iBackColor=-1) Begin // use background color of window
82433>>>>>>>>>>>>>>>>>>>      Get piWindowColor To iBackColor
82434>>>>>>>>>>>>>>>>>>>      If (iBackColor<0) Begin
82436>>>>>>>>>>>>>>>>>>>        Move clWhite To iBackColor
82437>>>>>>>>>>>>>>>>>>>      End
82437>>>>>>>>>>>>>>>>>>>>
82437>>>>>>>>>>>>>>>>>>>    End
82437>>>>>>>>>>>>>>>>>>>>
82437>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK   iStyle iBackColor
82438>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBOLD   iStyle gtColorer[iColorIndex].iBold
82439>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETITALIC iStyle gtColorer[iColorIndex].iItalics
82440>>>>>>>>>>>>>>>>>>>  End_Procedure
82441>>>>>>>>>>>>>>>>>>>
82441>>>>>>>>>>>>>>>>>>>
82441>>>>>>>>>>>>>>>>>>>  //
82441>>>>>>>>>>>>>>>>>>>  // Map the color style per defined language
82441>>>>>>>>>>>>>>>>>>>  //
82441>>>>>>>>>>>>>>>>>>>  Procedure SetAppearanceForLanguage Integer iLexer
82443>>>>>>>>>>>>>>>>>>>
82443>>>>>>>>>>>>>>>>>>>    If (iLexer=SCLEX_NULL) Begin
82445>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_TEXT_DEFAULT       EC_TEXT
82446>>>>>>>>>>>>>>>>>>>    End
82446>>>>>>>>>>>>>>>>>>>>
82446>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_DATAFLEX) Begin
82449>>>>>>>>>>>>>>>>>>>      //
82449>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_DEFAULT       EC_TEXT
82450>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_IDENTIFIER    EC_TEXT             // // # Identifiers (style.dataflex.1=)
82451>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_METATAG       EC_METATAGS         // # Comment: { ... } (style.dataflex.2=$(colour.code.comment.box),$(font.code.comment.box))
82452>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_IMAGE         EC_COMMENTS         // # Comment: (* ... *) (style.dataflex.3=$(colour.code.comment.box),$(font.code.comment.box))
82453>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_COMMENTLINE   EC_COMMENTS         // # Line Comment: // ... (style.dataflex.4=$(colour.code.comment.line),$(font.code.comment.line))
82454>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_PREPROCESSOR  EC_PREPROCESSOR     // # Preprocessor (Macro/Commands): #MACRO/#ENDMACRO
82455>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_PREPROCESSOR2 EC_PREPROCESSOR     // # Preprocessor: (*$ ... *) (style.dataflex.6=$(colour.preproc))
82456>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_NUMBER        EC_NUMBERS          // # Number (style.dataflex.7=$(colour.Number))
82457>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_HEXNUMBER     EC_NUMBERS          // # Hex Number (style.dataflex.8=$(colour.Number))
82458>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_WORD          EC_KEYWORDS         // # Keyword (style.dataflex.9=$(colour.keyword) // Basic keywords)
82459>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_STRING        EC_STRINGS          // # String (style.dataflex.10=$(colour.String))
82460>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_STRINGEOL     EC_STRINGTYPING     // # End of line where String is not closed (style.dataflex.11=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled)
82461>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_SCOPEWORD     EC_SCOPEKWORDS      // # Scope keyword (style.dataflex.12=$(colour.keyword),bold)
82462>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_OPERATOR      EC_OPERATORS        // # Operators (style.dataflex.13=$(colour.operator),bold)
82463>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_ICODE         EC_NUMBERS          // # ICode (style.dataflex.14=$(colour.Number))
82464>>>>>>>>>>>>>>>>>>>    End
82464>>>>>>>>>>>>>>>>>>>>
82464>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_CPP) Begin
82467>>>>>>>>>>>>>>>>>>>      //
82467>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_DEFAULT                EC_TEXT
82468>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_IDENTIFIER             EC_TEXT
82469>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTDOC             EC_METATAGS
82470>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENT                EC_COMMENTS
82471>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTLINE            EC_COMMENTS
82472>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_PREPROCESSOR           EC_PREPROCESSOR
82473>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_GLOBALCLASS            EC_PREPROCESSOR
82474>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_NUMBER                 EC_NUMBERS
82475>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_CHARACTER              EC_NUMBERS
82476>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_WORD                   EC_KEYWORDS
82477>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_STRING                 EC_STRINGS
82478>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_STRINGEOL              EC_STRINGTYPING
82479>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_WORD2                  EC_SCOPEKWORDS
82480>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_OPERATOR               EC_OPERATORS
82481>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_UUID                   EC_STRINGS
82482>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_VERBATIM               EC_TEXT
82483>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_REGEX                  EC_OPERATORS
82484>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTLINEDOC         EC_METATAGS
82485>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTDOCKEYWORD      EC_METATAGS
82486>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTDOCKEYWORDERROR EC_STRINGTYPING
82487>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_STRINGRAW              EC_STRINGS
82488>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_TRIPLEVERBATIM         EC_COMMENTS
82489>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_HASHQUOTEDSTRING       EC_STRINGS
82490>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_PREPROCESSORCOMMENT    EC_METATAGS
82491>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_PREPROCESSORCOMMENTDOC EC_METATAGS
82492>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_USERLITERAL            EC_STRINGS
82493>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_TASKMARKER             EC_BRACEHLIGHT
82494>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_ESCAPESEQUENCE         EC_STRINGS
82495>>>>>>>>>>>>>>>>>>>
82495>>>>>>>>>>>>>>>>>>>    End
82495>>>>>>>>>>>>>>>>>>>>
82495>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_PASCAL) Begin
82498>>>>>>>>>>>>>>>>>>>      //
82498>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_DEFAULT        EC_TEXT
82499>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_IDENTIFIER     EC_TEXT
82500>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_COMMENT2       EC_METATAGS
82501>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_COMMENT        EC_COMMENTS
82502>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_COMMENTLINE    EC_COMMENTS
82503>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_PREPROCESSOR   EC_PREPROCESSOR
82504>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_PREPROCESSOR2  EC_PREPROCESSOR
82505>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_NUMBER         EC_NUMBERS
82506>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_HEXNUMBER      EC_NUMBERS
82507>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_WORD           EC_KEYWORDS
82508>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_STRING         EC_STRINGS
82509>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_STRINGEOL      EC_STRINGTYPING
82510>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_OPERATOR       EC_OPERATORS
82511>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_CHARACTER      EC_STRINGS
82512>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_ASM            EC_BOOKMARK
82513>>>>>>>>>>>>>>>>>>>    End
82513>>>>>>>>>>>>>>>>>>>>
82513>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_HTML or iLexer=SCLEX_XML or iLexer=SCLEX_PHPSCRIPT) Begin
82516>>>>>>>>>>>>>>>>>>>      //
82516>>>>>>>>>>>>>>>>>>>      Set LexerProperty "fold.html" To "1"
82517>>>>>>>>>>>>>>>>>>>      //
82517>>>>>>>>>>>>>>>>>>>      // Has over 100 styles as it supports markup for embedded scripting etc..
82517>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_DEFAULT           EC_TEXT
82518>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_TAG               EC_TAGELEMENT
82519>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_TAGUNKNOWN        EC_KEYWORDS
82520>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ATTRIBUTE         EC_TAGATTRIBUTE
82521>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ATTRIBUTEUNKNOWN  EC_OPERATORS
82522>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_NUMBER            EC_NUMBERS
82523>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_DOUBLESTRING      EC_STRINGS
82524>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SINGLESTRING      EC_STRINGS
82525>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_OTHER             EC_TEXT
82526>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_COMMENT           EC_COMMENTS
82527>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ENTITY            EC_TAGENTITIES
82528>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_TAGEND            EC_TAGELEMENT    // XML style tag ends '/>'
82529>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_XMLSTART          EC_SCOPEKWORDS   // XML identifier start '<?'
82530>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_XMLEND            EC_SCOPEKWORDS   // XML identifier end '?>'
82531>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SCRIPT            EC_METATAGS      // SCRIPT
82532>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ASP               EC_KEYWORDS      // ASP <% ... %>
82533>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ASPAT             EC_KEYWORDS      // ASP <% ... %>
82534>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_CDATA             EC_STRINGS       // CDATA
82535>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_QUESTION          EC_STRINGTYPING  // PHP
82536>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_VALUE             EC_NUMBERS       // Unquoted values
82537>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_XCCOMMENT         EC_COMMENTS      // JSP Comment <%-- ... --%>
82538>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_DEFAULT      EC_TEXT          // SGML tags <! ... >
82539>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_COMMAND      EC_PREPROCESSOR
82540>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_1ST_PARAM    EC_SCOPEKWORDS
82541>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_DOUBLESTRING EC_STRINGS
82542>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_SIMPLESTRING EC_STRINGS
82543>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_ERROR        EC_STRINGTYPING
82544>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_SPECIAL      EC_UNMATCHEDBRACE
82545>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_ENTITY       EC_TAGENTITIES
82546>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_COMMENT      EC_COMMENTS
82547>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_1ST_PARAM_COMMENT EC_METATAGS
82548>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_BLOCK_DEFAULT EC_TEXT
82549>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_START            EC_TEXT          // Embedded Javascript, JS Start - allows eol filled background to not start on same line as SCRIPT tag
82550>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_DEFAULT          EC_TEXT          //
82551>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_COMMENT          EC_COMMENTS
82552>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_COMMENTLINE      EC_COMMENTS
82553>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_COMMENTDOC       EC_METATAGS
82554>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_NUMBER           EC_NUMBERS
82555>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_WORD             EC_SCOPEKWORDS
82556>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_KEYWORD          EC_KEYWORDS
82557>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_DOUBLESTRING     EC_STRINGS
82558>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_SINGLESTRING     EC_STRINGS
82559>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_SYMBOLS          EC_PREPROCESSOR
82560>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_STRINGEOL        EC_STRINGTYPING
82561>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_REGEX            EC_OPERATORS
82562>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_START           EC_TEXT          // ASP Javascript
82563>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_DEFAULT         EC_TEXT
82564>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_COMMENT         EC_COMMENTS
82565>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_COMMENTLINE     EC_COMMENTS
82566>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_COMMENTDOC      EC_METATAGS
82567>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_NUMBER          EC_NUMBERS
82568>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_WORD            EC_SCOPEKWORDS
82569>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_KEYWORD         EC_KEYWORDS
82570>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_DOUBLESTRING    EC_STRINGS
82571>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_SINGLESTRING    EC_STRINGS
82572>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_SYMBOLS         EC_PREPROCESSOR
82573>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_STRINGEOL       EC_STRINGTYPING
82574>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_REGEX           EC_OPERATORS
82575>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_START            EC_TEXT          // Embedded VBS
82576>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_DEFAULT          EC_TEXT
82577>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_COMMENTLINE      EC_COMMENTS
82578>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_NUMBER           EC_NUMBERS
82579>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_WORD             EC_SCOPEKWORDS
82580>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_STRING           EC_STRINGS
82581>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_IDENTIFIER       EC_KEYWORDS
82582>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_STRINGEOL        EC_STRINGTYPING
82583>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_START           EC_TEXT          // ASP VBS
82584>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_DEFAULT         EC_TEXT
82585>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_COMMENTLINE     EC_COMMENTS
82586>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_NUMBER          EC_NUMBERS
82587>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_WORD            EC_SCOPEKWORDS
82588>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_STRING          EC_STRINGS
82589>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_IDENTIFIER      EC_KEYWORDS
82590>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_STRINGEOL       EC_STRINGTYPING
82591>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_START            EC_TEXT          // Embedded Python
82592>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_DEFAULT          EC_TEXT
82593>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_COMMENTLINE      EC_COMMENTS
82594>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_NUMBER           EC_NUMBERS
82595>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_STRING           EC_STRINGS
82596>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_CHARACTER        EC_STRINGS
82597>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_WORD             EC_SCOPEKWORDS
82598>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_TRIPLE           EC_PREPROCESSOR
82599>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_TRIPLEDOUBLE     EC_PREPROCESSOR
82600>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_CLASSNAME        EC_METATAGS
82601>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_DEFNAME          EC_METATAGS
82602>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_OPERATOR         EC_OPERATORS
82603>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_IDENTIFIER       EC_KEYWORDS
82604>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_COMPLEX_VARIABLE   EC_TAGENTITIES // PHP complex variable
82605>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_START           EC_TEXT          // ASP Python
82606>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_DEFAULT         EC_TEXT
82607>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_COMMENTLINE     EC_COMMENTS
82608>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_NUMBER          EC_NUMBERS
82609>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_STRING          EC_STRINGS
82610>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_CHARACTER       EC_STRINGS
82611>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_WORD            EC_SCOPEKWORDS
82612>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_TRIPLE          EC_PREPROCESSOR
82613>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_TRIPLEDOUBLE    EC_PREPROCESSOR
82614>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_CLASSNAME       EC_METATAGS
82615>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_DEFNAME         EC_METATAGS
82616>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_OPERATOR        EC_OPERATORS
82617>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_IDENTIFIER      EC_KEYWORDS
82618>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_DEFAULT        EC_TEXT          // PHP
82619>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_HSTRING        EC_STRINGS
82620>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_SIMPLESTRING   EC_STRINGS
82621>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_WORD           EC_SCOPEKWORDS
82622>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_NUMBER         EC_NUMBERS
82623>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_VARIABLE       EC_TAGENTITIES
82624>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_COMMENT        EC_COMMENTS
82625>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_COMMENTLINE    EC_COMMENTS
82626>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_HSTRING_VARIABLE  EC_TAGELEMENT
82627>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_OPERATOR       EC_OPERATORS
82628>>>>>>>>>>>>>>>>>>>    End
82628>>>>>>>>>>>>>>>>>>>>
82628>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_SQL) Begin
82631>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_DEFAULT         EC_TEXT
82632>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENT         EC_COMMENTS
82633>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTLINE     EC_COMMENTS
82634>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTDOC      EC_METATAGS
82635>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_NUMBER          EC_NUMBERS
82636>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_WORD            EC_KEYWORDS
82637>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_STRING          EC_STRINGS
82638>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_CHARACTER       EC_STRINGS
82639>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_SQLPLUS         EC_TAGTEXT
82640>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_SQLPLUS_PROMPT  EC_TAGENTITIES
82641>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_OPERATOR        EC_OPERATORS
82642>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_IDENTIFIER      EC_TEXT
82643>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_SQLPLUS_COMMENT EC_COMMENTS
82644>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTLINEDOC  EC_METATAGS
82645>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_WORD2           EC_SCOPEKWORDS
82646>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTDOCKEYWORD  EC_METATAGS
82647>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTDOCKEYWORDERROR   EC_STRINGTYPING
82648>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER1           EC_TAGENTITIES
82649>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER2           EC_TAGELEMENT
82650>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER3           EC_TAGATTRIBUTE
82651>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER4           EC_TAGTEXT
82652>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_QUOTEDIDENTIFIER  EC_TEXT
82653>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_QOPERATOR       EC_TEXT
82654>>>>>>>>>>>>>>>>>>>    End
82654>>>>>>>>>>>>>>>>>>>>
82654>>>>>>>>>>>>>>>>>>>
82654>>>>>>>>>>>>>>>>>>>    If (iLexer=SCLEX_PROPERTIES) Begin
82656>>>>>>>>>>>>>>>>>>>      //
82656>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_DEFAULT    EC_TEXT
82657>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_SECTION    EC_METATAGS
82658>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_COMMENT    EC_COMMENTS
82659>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_KEY        EC_KEYWORDS
82660>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_DEFVAL     EC_STRINGS
82661>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_ASSIGNMENT EC_OPERATORS
82662>>>>>>>>>>>>>>>>>>>    End
82662>>>>>>>>>>>>>>>>>>>>
82662>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_VB) Begin
82665>>>>>>>>>>>>>>>>>>>
82665>>>>>>>>>>>>>>>>>>>    End
82665>>>>>>>>>>>>>>>>>>>>
82665>>>>>>>>>>>>>>>>>>>
82665>>>>>>>>>>>>>>>>>>>  End_Procedure
82666>>>>>>>>>>>>>>>>>>>
82666>>>>>>>>>>>>>>>>>>>End_Class
82667>>>>>>>>>>>>>>>>>>>
82667>>>>>>>>>>>>>>>>>Use cSciCodelist.pkg
Including file: cSciCodelist.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciCodelist.pkg)
82667>>>>>>>>>>>>>>>>>>>//TH-Header
82667>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
82667>>>>>>>>>>>>>>>>>>>// Copyright (c)  2003 Bernhard Ponemayr
82667>>>>>>>>>>>>>>>>>>>// All rights reserved.
82667>>>>>>>>>>>>>>>>>>>//
82667>>>>>>>>>>>>>>>>>>>// $FileName    : .\hammer\Pkg\cSciCodelist.pkg
82667>>>>>>>>>>>>>>>>>>>// $ProjectName : Listview API
82667>>>>>>>>>>>>>>>>>>>// $Author      : Bernhard Ponemayr
82667>>>>>>>>>>>>>>>>>>>// $Created     : 20.01.2003  16:07
82667>>>>>>>>>>>>>>>>>>>//
82667>>>>>>>>>>>>>>>>>>>// Contents: Abstraction class for the Autocomplete functionality in scintilla control to
82667>>>>>>>>>>>>>>>>>>>// work similar as the codemax codesense control that is to be found in cCodelist.pkg
82667>>>>>>>>>>>>>>>>>>>//
82667>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
82667>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
82667>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
82667>>>>>>>>>>>>>>>>>>>
82667>>>>>>>>>>>>>>>>>>>Define LVS_SORTASCENDING       For |CI$0010
82667>>>>>>>>>>>>>>>>>>>Define LVS_EX_TRACKSELECT      For |CI$00000008
82667>>>>>>>>>>>>>>>>>>>Define LVS_EX_ONECLICKACTIVATE For |CI$00000040
82667>>>>>>>>>>>>>>>>>>>
82667>>>>>>>>>>>>>>>>>>>Struct tCodeList
82667>>>>>>>>>>>>>>>>>>>  String  sSortValue  // used for sorting/searching the case insensitive variant that DF claims works, doesn't work
82667>>>>>>>>>>>>>>>>>>>  String  sValue
82667>>>>>>>>>>>>>>>>>>>  Integer iRef
82667>>>>>>>>>>>>>>>>>>>  String  sBitmap
82667>>>>>>>>>>>>>>>>>>>  Integer iInsertOrder   // Set as item number in the original inserting order before sorting!
82667>>>>>>>>>>>>>>>>>>>End_Struct // tCodeList
82667>>>>>>>>>>>>>>>>>>>
82667>>>>>>>>>>>>>>>>>>>
82667>>>>>>>>>>>>>>>>>>>Class cSciCodelist is a Array
82668>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
82670>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
82672>>>>>>>>>>>>>>>>>>>    Property Handle  phoCodelist    0    // not used
82673>>>>>>>>>>>>>>>>>>>    Property Integer pbUseBitmaps   TRUE // not used (need xpm images)
82674>>>>>>>>>>>>>>>>>>>    Property Integer piRefValue     0    // The ref value contains additional info such as a record id or status about a variable
82675>>>>>>>>>>>>>>>>>>>    Property Handle  phLastUsedFont 0    // not used
82676>>>>>>>>>>>>>>>>>>>    Property Integer piCurrent      -1   // The current item (aka, the one just selected)
82677>>>>>>>>>>>>>>>>>>>    Property tCodeList[] pCodeList
82678>>>>>>>>>>>>>>>>>>>
82678>>>>>>>>>>>>>>>>>>>  End_Procedure
82679>>>>>>>>>>>>>>>>>>>
82679>>>>>>>>>>>>>>>>>>>  Procedure Codelist_Connect Handle hCodelist Integer bUseBitmaps
82681>>>>>>>>>>>>>>>>>>>    Set phoCodelist To hCodelist // not used
82682>>>>>>>>>>>>>>>>>>>    Set piCurrent   To -1
82683>>>>>>>>>>>>>>>>>>>    If ( bUseBitmaps ) Begin
82685>>>>>>>>>>>>>>>>>>>      Set pbUseBitmaps To TRUE
82686>>>>>>>>>>>>>>>>>>>    End
82686>>>>>>>>>>>>>>>>>>>>
82686>>>>>>>>>>>>>>>>>>>    Else Begin
82687>>>>>>>>>>>>>>>>>>>      Set pbUseBitmaps To FALSE
82688>>>>>>>>>>>>>>>>>>>    End
82688>>>>>>>>>>>>>>>>>>>>
82688>>>>>>>>>>>>>>>>>>>  End_Procedure
82689>>>>>>>>>>>>>>>>>>>
82689>>>>>>>>>>>>>>>>>>>  Procedure Codelist_Disconnect
82691>>>>>>>>>>>>>>>>>>>    Send Codelist_delete_data               // Remove all Items from list
82692>>>>>>>>>>>>>>>>>>>    Set phoCodelist To 0
82693>>>>>>>>>>>>>>>>>>>  End_Procedure
82694>>>>>>>>>>>>>>>>>>>
82694>>>>>>>>>>>>>>>>>>>  //
82694>>>>>>>>>>>>>>>>>>>  // While it is called "add_item" in the original code it is actually inserting the data
82694>>>>>>>>>>>>>>>>>>>  // at the bottom. As that's slow, we will reverse the array before sorting.
82694>>>>>>>>>>>>>>>>>>>  //
82694>>>>>>>>>>>>>>>>>>>  Function Codelist_Add_Item String sText String sBitmap Integer iRefValue Returns Integer
82696>>>>>>>>>>>>>>>>>>>    Integer   iCount
82696>>>>>>>>>>>>>>>>>>>    Integer   iRet
82696>>>>>>>>>>>>>>>>>>>    tCodeList CodeItem
82696>>>>>>>>>>>>>>>>>>>    tCodeList CodeItem
82696>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82696>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82697>>>>>>>>>>>>>>>>>>>
82697>>>>>>>>>>>>>>>>>>>    Move 0 To iRet
82698>>>>>>>>>>>>>>>>>>>    If (sText<>"") Begin
82700>>>>>>>>>>>>>>>>>>>      Get pCodeList To CodeList
82701>>>>>>>>>>>>>>>>>>>      Move (SizeOfArray(CodeList)) To iCount
82702>>>>>>>>>>>>>>>>>>>      Move (lowercase(sText)) To CodeItem.sSortValue
82703>>>>>>>>>>>>>>>>>>>      Move sText              To CodeItem.sValue
82704>>>>>>>>>>>>>>>>>>>      Move sBitmap            To CodeItem.sBitmap
82705>>>>>>>>>>>>>>>>>>>      Move iRefValue          To CodeItem.iRef
82706>>>>>>>>>>>>>>>>>>>      //Move (InsertInArray(CodeList,0,CodeItem)) To CodeList
82706>>>>>>>>>>>>>>>>>>>      Move CodeItem To CodeList[iCount]
82707>>>>>>>>>>>>>>>>>>>      Set pCodeList To CodeList
82708>>>>>>>>>>>>>>>>>>>    End
82708>>>>>>>>>>>>>>>>>>>>
82708>>>>>>>>>>>>>>>>>>>    Function_Return iRet
82709>>>>>>>>>>>>>>>>>>>  End_Function
82710>>>>>>>>>>>>>>>>>>>
82710>>>>>>>>>>>>>>>>>>>  Procedure Codelist_delete_data
82712>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82712>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82713>>>>>>>>>>>>>>>>>>>
82713>>>>>>>>>>>>>>>>>>>    Move (ResizeArray(CodeList,0)) To CodeList
82714>>>>>>>>>>>>>>>>>>>    Set pCodeList To CodeList
82715>>>>>>>>>>>>>>>>>>>  End_Procedure
82716>>>>>>>>>>>>>>>>>>>
82716>>>>>>>>>>>>>>>>>>>  Function Codelist_value Integer iItem Returns String
82718>>>>>>>>>>>>>>>>>>>    Integer iRefVal
82718>>>>>>>>>>>>>>>>>>>    String sText
82718>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82718>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82719>>>>>>>>>>>>>>>>>>>
82719>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
82720>>>>>>>>>>>>>>>>>>>    If (iItem < SizeOfArray(CodeList) and iItem<>-1) Begin
82722>>>>>>>>>>>>>>>>>>>      Move CodeList[iItem].sValue To sText
82723>>>>>>>>>>>>>>>>>>>      Move CodeList[iItem].iRef   To iRefVal
82724>>>>>>>>>>>>>>>>>>>    End
82724>>>>>>>>>>>>>>>>>>>>
82724>>>>>>>>>>>>>>>>>>>    Set piRefValue To iRefVal
82725>>>>>>>>>>>>>>>>>>>    Function_Return sText
82726>>>>>>>>>>>>>>>>>>>  End_Function
82727>>>>>>>>>>>>>>>>>>>
82727>>>>>>>>>>>>>>>>>>>  Function Codelist_bitmap Integer iItem Returns String
82729>>>>>>>>>>>>>>>>>>>    String sBitmap
82729>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82729>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82730>>>>>>>>>>>>>>>>>>>
82730>>>>>>>>>>>>>>>>>>>    Move "" To sBitmap
82731>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
82732>>>>>>>>>>>>>>>>>>>    If (iItem < SizeOfArray(CodeList) and iItem<>-1) Begin
82734>>>>>>>>>>>>>>>>>>>      Move CodeList[iItem].sBitmap To sBitmap
82735>>>>>>>>>>>>>>>>>>>    End
82735>>>>>>>>>>>>>>>>>>>>
82735>>>>>>>>>>>>>>>>>>>    If (sBitmap<>"") Begin
82737>>>>>>>>>>>>>>>>>>>      Get_File_Path sBitmap To sBitmap
82738>>>>>>>>>>>>>>>>>>>    End
82738>>>>>>>>>>>>>>>>>>>>
82738>>>>>>>>>>>>>>>>>>>    Function_Return sBitmap
82739>>>>>>>>>>>>>>>>>>>  End_Function
82740>>>>>>>>>>>>>>>>>>>
82740>>>>>>>>>>>>>>>>>>>  //
82740>>>>>>>>>>>>>>>>>>>  // This item number is used to refer to the ORIGINAL item id in the object that supplied the data
82740>>>>>>>>>>>>>>>>>>>  // it should not be used to retrieve the data of this array as you'll end up getting different data.
82740>>>>>>>>>>>>>>>>>>>  // Capiche?
82740>>>>>>>>>>>>>>>>>>>  //
82740>>>>>>>>>>>>>>>>>>>  Function Codelist_current_item Returns Integer
82742>>>>>>>>>>>>>>>>>>>    Integer iCurrent
82742>>>>>>>>>>>>>>>>>>>    Integer iItem
82742>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82742>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82743>>>>>>>>>>>>>>>>>>>
82743>>>>>>>>>>>>>>>>>>>    Move -1 To iItem
82744>>>>>>>>>>>>>>>>>>>    Get piCurrent To iCurrent
82745>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
82746>>>>>>>>>>>>>>>>>>>    If (iCurrent<>-1 and iCurrent < SizeOfArray(CodeList)) Begin
82748>>>>>>>>>>>>>>>>>>>      Move CodeList[iCurrent].iInsertOrder To iItem
82749>>>>>>>>>>>>>>>>>>>    End
82749>>>>>>>>>>>>>>>>>>>>
82749>>>>>>>>>>>>>>>>>>>    Function_Return iItem
82750>>>>>>>>>>>>>>>>>>>  End_Function
82751>>>>>>>>>>>>>>>>>>>
82751>>>>>>>>>>>>>>>>>>>  Function Codelist_find_item String sItem Returns Integer
82753>>>>>>>>>>>>>>>>>>>    Integer   iItem
82753>>>>>>>>>>>>>>>>>>>    tCodeList SearchCode
82753>>>>>>>>>>>>>>>>>>>    tCodeList SearchCode
82753>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82753>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82754>>>>>>>>>>>>>>>>>>>
82754>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
82755>>>>>>>>>>>>>>>>>>>    //Move (SearchArray(sItem, CodeList, Desktop, (RefFunc(DFSTRICMP)))) to iItem
82755>>>>>>>>>>>>>>>>>>>    Move (Lowercase(sItem)) To SearchCode.sSortValue
82756>>>>>>>>>>>>>>>>>>>    Move (SearchArray(SearchCode,CodeList)) To iItem
82757>>>>>>>>>>>>>>>>>>>    Set piCurrent To iItem
82758>>>>>>>>>>>>>>>>>>>    Function_Return iItem
82759>>>>>>>>>>>>>>>>>>>  End_Function
82760>>>>>>>>>>>>>>>>>>>
82760>>>>>>>>>>>>>>>>>>>  //
82760>>>>>>>>>>>>>>>>>>>  // Add index numbers to the array
82760>>>>>>>>>>>>>>>>>>>  //
82760>>>>>>>>>>>>>>>>>>>  Procedure LabelArray tCodeList[] ByRef CodeList
82762>>>>>>>>>>>>>>>>>>>    Integer iItem
82762>>>>>>>>>>>>>>>>>>>    Integer iCount
82762>>>>>>>>>>>>>>>>>>>
82762>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(CodeList)) To iCount
82763>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
82765>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
82771>>>>>>>>>>>>>>>>>>>>
82771>>>>>>>>>>>>>>>>>>>        Move iItem To CodeList[iItem].iInsertOrder
82772>>>>>>>>>>>>>>>>>>>      Loop
82773>>>>>>>>>>>>>>>>>>>>
82773>>>>>>>>>>>>>>>>>>>    End
82773>>>>>>>>>>>>>>>>>>>>
82773>>>>>>>>>>>>>>>>>>>  End_Procedure
82774>>>>>>>>>>>>>>>>>>>
82774>>>>>>>>>>>>>>>>>>>  // Does a few things:
82774>>>>>>>>>>>>>>>>>>>  // - Will first reverse the array as our items have been added instead of inserted like in the original code
82774>>>>>>>>>>>>>>>>>>>  // - Then it will add index numbers so that we can return original references
82774>>>>>>>>>>>>>>>>>>>  // - After which we will sort the list, this might not be needed, but it is a precaution for if somebody
82774>>>>>>>>>>>>>>>>>>>  //   made an error while inserting data in a non ascending order.
82774>>>>>>>>>>>>>>>>>>>  //
82774>>>>>>>>>>>>>>>>>>>  Procedure SortAscending
82776>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82776>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
82777>>>>>>>>>>>>>>>>>>>
82777>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
82778>>>>>>>>>>>>>>>>>>>    Move (ReverseArray(CodeList)) To CodeList
82779>>>>>>>>>>>>>>>>>>>    Send LabelArray (&CodeList)
82780>>>>>>>>>>>>>>>>>>>    //Move (SortArray(CodeList, Desktop, (RefFunc(DFSTRICMP)))) to CodeList
82780>>>>>>>>>>>>>>>>>>>    Move (SortArray(CodeList)) To CodeList
82781>>>>>>>>>>>>>>>>>>>    Set pCodeList To CodeList
82782>>>>>>>>>>>>>>>>>>>  End_Procedure
82783>>>>>>>>>>>>>>>>>>>
82783>>>>>>>>>>>>>>>>>>>  Procedure Set Codelist_style Integer iStyle
82785>>>>>>>>>>>>>>>>>>>  End_Procedure
82786>>>>>>>>>>>>>>>>>>>
82786>>>>>>>>>>>>>>>>>>>  Procedure Set Codelist_font Integer hFont
82788>>>>>>>>>>>>>>>>>>>  End_Procedure
82789>>>>>>>>>>>>>>>>>>>
82789>>>>>>>>>>>>>>>>>>>  //
82789>>>>>>>>>>>>>>>>>>>  // We don't use this in scintilla, instead we show the autocomplete list
82789>>>>>>>>>>>>>>>>>>>  // and pass the word to select.
82789>>>>>>>>>>>>>>>>>>>  //
82789>>>>>>>>>>>>>>>>>>>  //Function Codelist_SelectClosestItem String sText Returns Integer
82789>>>>>>>>>>>>>>>>>>>  //    Function_Return iItem
82789>>>>>>>>>>>>>>>>>>>  //End_Function
82789>>>>>>>>>>>>>>>>>>>
82789>>>>>>>>>>>>>>>>>>>  Function Codelist_Item_count Returns Integer
82791>>>>>>>>>>>>>>>>>>>    Integer iCount
82791>>>>>>>>>>>>>>>>>>>
82791>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(pCodeList(Self))) To iCount
82792>>>>>>>>>>>>>>>>>>>    Function_Return iCount
82793>>>>>>>>>>>>>>>>>>>  End_Function
82794>>>>>>>>>>>>>>>>>>>
82794>>>>>>>>>>>>>>>>>>>  //
82794>>>>>>>>>>>>>>>>>>>  // ToDo: Codelist_Beginning_Of_Data
82794>>>>>>>>>>>>>>>>>>>  //
82794>>>>>>>>>>>>>>>>>>>  Procedure Codelist_Beginning_Of_Data
82796>>>>>>>>>>>>>>>>>>>    //String sVal sLvItem
82796>>>>>>>>>>>>>>>>>>>    //Pointer pVal pLvItem
82796>>>>>>>>>>>>>>>>>>>    //Integer iRet iItem
82796>>>>>>>>>>>>>>>>>>>    //If (phoCodelist(self)) Eq 0 Procedure_Return
82796>>>>>>>>>>>>>>>>>>>
82796>>>>>>>>>>>>>>>>>>>    //zerotype LVITEM to sLvItem
82796>>>>>>>>>>>>>>>>>>>    //getaddress Of sLvItem to pLvItem
82796>>>>>>>>>>>>>>>>>>>    //
82796>>>>>>>>>>>>>>>>>>>    //put LVIF_STATE to sLvItem at LVITEM.mask
82796>>>>>>>>>>>>>>>>>>>    //put 0 to sLvItem at LVITEM.iItem
82796>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.state
82796>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.stateMask
82796>>>>>>>>>>>>>>>>>>>    //
82796>>>>>>>>>>>>>>>>>>>    //Move (ListView_SetItemState(phoCodelist(self),0,pLvItem)) to iRet
82796>>>>>>>>>>>>>>>>>>>    //If (Not(iRet)) Procedure_Return
82796>>>>>>>>>>>>>>>>>>>    //Move (ListView_EnsureVisible(phoCodelist(self),0,FALSE)) to iRet
82796>>>>>>>>>>>>>>>>>>>  End_Procedure
82797>>>>>>>>>>>>>>>>>>>
82797>>>>>>>>>>>>>>>>>>>  //
82797>>>>>>>>>>>>>>>>>>>  // ToDo: Codelist_End_Of_Data
82797>>>>>>>>>>>>>>>>>>>  //
82797>>>>>>>>>>>>>>>>>>>  Procedure Codelist_End_Of_Data
82799>>>>>>>>>>>>>>>>>>>    //String sVal sLvItem
82799>>>>>>>>>>>>>>>>>>>    //Pointer pVal pLvItem
82799>>>>>>>>>>>>>>>>>>>    //Integer iRet iItem
82799>>>>>>>>>>>>>>>>>>>    //If (phoCodelist(self)) Eq 0 Procedure_Return
82799>>>>>>>>>>>>>>>>>>>
82799>>>>>>>>>>>>>>>>>>>    //zerotype LVITEM to sLvItem
82799>>>>>>>>>>>>>>>>>>>    //getaddress Of sLvItem to pLvItem
82799>>>>>>>>>>>>>>>>>>>    //
82799>>>>>>>>>>>>>>>>>>>    //put LVIF_STATE to sLvItem at LVITEM.mask
82799>>>>>>>>>>>>>>>>>>>    ////Move (Listview_GetItemCount(phoCodelist(self))) to iItem
82799>>>>>>>>>>>>>>>>>>>    //Get Item_Count to iItem
82799>>>>>>>>>>>>>>>>>>>    //If iItem Eq -1 Procedure_Return
82799>>>>>>>>>>>>>>>>>>>    //Move (iItem-1) to iItem
82799>>>>>>>>>>>>>>>>>>>    //put iItem to sLvItem at LVITEM.iItem
82799>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.state
82799>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.stateMask
82799>>>>>>>>>>>>>>>>>>>    //
82799>>>>>>>>>>>>>>>>>>>    //Move (ListView_SetItemState(phoCodelist(self),iItem,pLvItem)) to iRet
82799>>>>>>>>>>>>>>>>>>>    //If (Not(iRet)) Procedure_Return
82799>>>>>>>>>>>>>>>>>>>    //Move (ListView_EnsureVisible(phoCodelist(self),iItem,FALSE)) to iRet
82799>>>>>>>>>>>>>>>>>>>  End_Procedure
82800>>>>>>>>>>>>>>>>>>>
82800>>>>>>>>>>>>>>>>>>>End_Class
82801>>>>>>>>>>>>>>>>>>>
82801>>>>>>>>>>>>>>>>>>>// BP CodeList Support
82801>>>>>>>>>>>>>>>>>>>// this object is just for testing the codelist functions
82801>>>>>>>>>>>>>>>>>>>// SVN
82801>>>>>>>>>>>>>>>>>>>Global_Variable Integer ghoCodeList
82801>>>>>>>>>>>>>>>>>>>Object oCodelist is a cSciCodelist
82803>>>>>>>>>>>>>>>>>>>  Object oClassDataCache is an Array
82805>>>>>>>>>>>>>>>>>>>  End_Object
82806>>>>>>>>>>>>>>>>>>>  Property Integer piListReason     0
82808>>>>>>>>>>>>>>>>>>>  Property Integer piSourceObject   0
82810>>>>>>>>>>>>>>>>>>>  Property Integer piSourceLine     0
82812>>>>>>>>>>>>>>>>>>>  Property String  psSourceLine     ""
82814>>>>>>>>>>>>>>>>>>>  Property String  psSourceRefVal   ""
82816>>>>>>>>>>>>>>>>>>>  Move self To ghoCodeList
82817>>>>>>>>>>>>>>>>>>>
82817>>>>>>>>>>>>>>>>>>>  Function Codelist_Add_CachedItem String sText String sBitmap Integer iRefValue Returns Integer
82820>>>>>>>>>>>>>>>>>>>    String  sArrayValue
82820>>>>>>>>>>>>>>>>>>>    Integer iRet
82820>>>>>>>>>>>>>>>>>>>
82820>>>>>>>>>>>>>>>>>>>    Move ( sText + "\new\" + (String(iRefValue)) + "\new\" ) To sArrayValue
82821>>>>>>>>>>>>>>>>>>>
82821>>>>>>>>>>>>>>>>>>>    If ( (pbUseBitmaps(self)) And (sBitmap Eq "") ) Begin
82823>>>>>>>>>>>>>>>>>>>      Move "default.bmp" To sBitmap
82824>>>>>>>>>>>>>>>>>>>    End
82824>>>>>>>>>>>>>>>>>>>>
82824>>>>>>>>>>>>>>>>>>>    If sBitmap Ne "" Begin
82826>>>>>>>>>>>>>>>>>>>      Move (sArrayValue + (String(sBitmap)) ) To sArrayValue
82827>>>>>>>>>>>>>>>>>>>    End
82827>>>>>>>>>>>>>>>>>>>>
82827>>>>>>>>>>>>>>>>>>>    Else Begin
82828>>>>>>>>>>>>>>>>>>>      Move (sArrayValue + "-1") To sArrayValue
82829>>>>>>>>>>>>>>>>>>>    End
82829>>>>>>>>>>>>>>>>>>>>
82829>>>>>>>>>>>>>>>>>>>    Move (sArrayValue + "\new\" ) To sArrayValue
82830>>>>>>>>>>>>>>>>>>>
82830>>>>>>>>>>>>>>>>>>>    Set Value Of oClassDataCache Item (item_count(oClassDataCache(self))) To sArrayValue
82831>>>>>>>>>>>>>>>>>>>
82831>>>>>>>>>>>>>>>>>>>    Set Value Item (CodeList_Item_Count(Self)) To sText
82832>>>>>>>>>>>>>>>>>>>    Function_Return iRet
82833>>>>>>>>>>>>>>>>>>>  End_Function
82834>>>>>>>>>>>>>>>>>>>
82834>>>>>>>>>>>>>>>>>>>  Procedure FillCodelistFromCache
82837>>>>>>>>>>>>>>>>>>>    Integer iItem iRet
82837>>>>>>>>>>>>>>>>>>>    String sText sRefValue sBitmap sLine
82837>>>>>>>>>>>>>>>>>>>
82837>>>>>>>>>>>>>>>>>>>    For iItem From 0 To ( (item_count(oClassDataCache(self))) -1)
82843>>>>>>>>>>>>>>>>>>>>
82843>>>>>>>>>>>>>>>>>>>      Get Value Of oClassDataCache Item iItem To sLine
82844>>>>>>>>>>>>>>>>>>>      Move (Left(sLine,((Pos("\new\",sLine))+4))) To sText
82845>>>>>>>>>>>>>>>>>>>      Move (Replace(sText,sLine,"")) To sLine
82846>>>>>>>>>>>>>>>>>>>      Move (Replace("\new\",sText,"")) To sText
82847>>>>>>>>>>>>>>>>>>>
82847>>>>>>>>>>>>>>>>>>>      Move (Left(sLine,((Pos("\new\",sLine))+4))) To sRefValue
82848>>>>>>>>>>>>>>>>>>>      Move (Replace(sRefValue,sLine,"")) To sBitmap
82849>>>>>>>>>>>>>>>>>>>      Move (Replace("\new\",sRefValue,"")) To sRefValue
82850>>>>>>>>>>>>>>>>>>>      Move (Replace("\new\",sBitmap,"")) To sBitmap
82851>>>>>>>>>>>>>>>>>>>
82851>>>>>>>>>>>>>>>>>>>      Get Codelist_Add_Item sText sBitmap sRefValue To iRet
82852>>>>>>>>>>>>>>>>>>>    Loop
82853>>>>>>>>>>>>>>>>>>>>
82853>>>>>>>>>>>>>>>>>>>  End_Procedure
82854>>>>>>>>>>>>>>>>>>>
82854>>>>>>>>>>>>>>>>>>>End_Object
82855>>>>>>>>>>>>>>>>>>>// BP
82855>>>>>>>>>>>>>>>>>>>
82855>>>>>>>>>>>>>>>>>Use DllHandler.pkg
Including file: DLLHandler.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\DLLHandler.pkg)
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//  File DllHandler.pkg
82855>>>>>>>>>>>>>>>>>>>//  Author: Wil van Antwerpen
82855>>>>>>>>>>>>>>>>>>>//  Company: Antwise Solutions
82855>>>>>>>>>>>>>>>>>>>//  License: LGPL
82855>>>>>>>>>>>>>>>>>>>//  Date: March 2, 2003
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>// This class helps you to manage the loading and unloading of DLLs in the address space
82855>>>>>>>>>>>>>>>>>>>// of our application.
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>// When you include this package into your application it will first create the class
82855>>>>>>>>>>>>>>>>>>>// and afterwards also create an object called oDllHandler
82855>>>>>>>>>>>>>>>>>>>// This object is automatically initialized and will try to set the psDllLoadPath property
82855>>>>>>>>>>>>>>>>>>>// with the workspace programs folder from the current application.
82855>>>>>>>>>>>>>>>>>>>// If no workspace is known, the current windows directory is taken instead and stored in
82855>>>>>>>>>>>>>>>>>>>// the psDllLoadPath property
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>// If a windows error occurs, the exact error is retrieved with the GetLastError function
82855>>>>>>>>>>>>>>>>>>>// and the code from that is stored in the piWindowsLastError property.
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>// Benefits of using this class are:
82855>>>>>>>>>>>>>>>>>>>//   - Easy loading a of DLL from the current programs workspace by calling the doLoadLibrary method
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//   - If a DLL is not found during runtime your application will by default show a
82855>>>>>>>>>>>>>>>>>>>//   message in the UI to the user which DLL from which path is missing and abort the program.
82855>>>>>>>>>>>>>>>>>>>//   This is desirable for most windows applications where DLLs are missing.
82855>>>>>>>>>>>>>>>>>>>//   Without this you get a runtime error each time the function is called and it usually
82855>>>>>>>>>>>>>>>>>>>//   results in a neverending number of warnings.
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//   This behaviour can be switched off by setting the pbErrorAbort method to false.
82855>>>>>>>>>>>>>>>>>>>//   In that case it is expected that the developer properly handles the event.
82855>>>>>>>>>>>>>>>>>>>//   You would need this for example in WebApps where the userinterface is the clients browser
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//   - Unloading of a DLL from the programs address space (hardly tested, but it seems to work fine)
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>//  o ToDo Extend the DoLoadLibrary method to also check on VersionInfo
82855>>>>>>>>>>>>>>>>>>>//=========================================================================================
82855>>>>>>>>>>>>>>>>>>>//  03-02-2003 **WvA First Draft
82855>>>>>>>>>>>>>>>>>>>//
82855>>>>>>>>>>>>>>>>>>>
82855>>>>>>>>>>>>>>>>>>>Use vWin32fh.pkg
82855>>>>>>>>>>>>>>>>>>>Use Set.pkg
82855>>>>>>>>>>>>>>>>>>>
82855>>>>>>>>>>>>>>>>>>>Define CS_ERRMISSINGDLLLINE1   For "There are essential components missing for the program to function properly.\n"
82855>>>>>>>>>>>>>>>>>>>Define CS_ERRMISSINGDLLLINE2   For "\nThe program was unable to load the module:\n "
82855>>>>>>>>>>>>>>>>>>>Define CS_ERRMISSINGDLLCAPTION For "Program Halted"
82855>>>>>>>>>>>>>>>>>>>
82855>>>>>>>>>>>>>>>>>>>Class cDllHandler is a DfObject
82856>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
82858>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
82860>>>>>>>>>>>>>>>>>>>    Property String  psDllLoadPath                  ""    // The default library path from where Dlls will be loaded
82861>>>>>>>>>>>>>>>>>>>    Property Integer pbErrorAbort                   True  // If true and a DLL fails to load then the application is aborted when using the doLoadLibrary method
82862>>>>>>>>>>>>>>>>>>>    Property Integer pbErrorReport                  True  // If true and a DLL fails, the error is displayed to the end-user by using a stop_box
82863>>>>>>>>>>>>>>>>>>>    Property Integer piLastWindowsError             0     // Holds the Windows Error from GetLastError
82864>>>>>>>>>>>>>>>>>>>
82864>>>>>>>>>>>>>>>>>>>    Object oModuleHandles is a Array
82866>>>>>>>>>>>>>>>>>>>    End_Object
82867>>>>>>>>>>>>>>>>>>>
82867>>>>>>>>>>>>>>>>>>>    Object oModuleNames is a Set
82869>>>>>>>>>>>>>>>>>>>    End_Object
82870>>>>>>>>>>>>>>>>>>>
82870>>>>>>>>>>>>>>>>>>>    Send Init   // Sets the DLlLoadpath
82871>>>>>>>>>>>>>>>>>>>  End_Procedure
82872>>>>>>>>>>>>>>>>>>>
82872>>>>>>>>>>>>>>>>>>>  Procedure Set ModuleHandle Integer iModule Integer hModule
82874>>>>>>>>>>>>>>>>>>>    Set Value Of oModuleHandles Item iModule To hModule
82875>>>>>>>>>>>>>>>>>>>  End_Procedure
82876>>>>>>>>>>>>>>>>>>>
82876>>>>>>>>>>>>>>>>>>>  //
82876>>>>>>>>>>>>>>>>>>>  // If sPath is "" then the programsfolder of the current workspace will be the first
82876>>>>>>>>>>>>>>>>>>>  // path which is searched
82876>>>>>>>>>>>>>>>>>>>  //
82876>>>>>>>>>>>>>>>>>>>  // Returns 0 if loading the dll was succesful
82876>>>>>>>>>>>>>>>>>>>  // Precondition:
82876>>>>>>>>>>>>>>>>>>>  //   If a path is passed in sPath, then it must always end with a "\"
82876>>>>>>>>>>>>>>>>>>>  //   You must always supply a Dllname
82876>>>>>>>>>>>>>>>>>>>  Function DllLoadLibrary String sPath String sFile Returns Integer
82878>>>>>>>>>>>>>>>>>>>    Handle  hModule 
82878>>>>>>>>>>>>>>>>>>>    Integer iModule
82878>>>>>>>>>>>>>>>>>>>    Integer iFailed iErr iFound
82878>>>>>>>>>>>>>>>>>>>    String  sModule 
82878>>>>>>>>>>>>>>>>>>>    Boolean bExists
82878>>>>>>>>>>>>>>>>>>>    
82878>>>>>>>>>>>>>>>>>>>    Move 0 To iFailed
82879>>>>>>>>>>>>>>>>>>>    Move 0 To hModule
82880>>>>>>>>>>>>>>>>>>>    Move (Uppercase(sFile)) To sFile
82881>>>>>>>>>>>>>>>>>>>    If sPath Eq "" Begin
82883>>>>>>>>>>>>>>>>>>>      Get psDllLoadPath To sPath
82884>>>>>>>>>>>>>>>>>>>      Get vFolderFormat sPath To sPath
82885>>>>>>>>>>>>>>>>>>>    End
82885>>>>>>>>>>>>>>>>>>>>
82885>>>>>>>>>>>>>>>>>>>    Get vFilePathExists (sPath+sFile) to bExists
82886>>>>>>>>>>>>>>>>>>>    If (bExists = True) Begin
82888>>>>>>>>>>>>>>>>>>>      Move (sPath+sFile+Character(0)) to sModule
82889>>>>>>>>>>>>>>>>>>>      Get Find_Element Of oModuleNames sFile To iModule
82890>>>>>>>>>>>>>>>>>>>      If iModule Ne -1 Begin
82892>>>>>>>>>>>>>>>>>>>        Get Value Item iModule To hModule
82893>>>>>>>>>>>>>>>>>>>        If hModule Eq 0 Begin
82895>>>>>>>>>>>>>>>>>>>          Move (LoadLibrary(sModule)) to hModule
82896>>>>>>>>>>>>>>>>>>>          If hModule Ne 0 Begin
82898>>>>>>>>>>>>>>>>>>>            Set Value Of oModuleHandles Item iModule To hModule
82899>>>>>>>>>>>>>>>>>>>          End
82899>>>>>>>>>>>>>>>>>>>>
82899>>>>>>>>>>>>>>>>>>>          Else Begin
82900>>>>>>>>>>>>>>>>>>>            // An error occured during the actual unloading by windows
82900>>>>>>>>>>>>>>>>>>>            // Get extended error information, call GetLastError.
82900>>>>>>>>>>>>>>>>>>>            Move 3 To iFailed
82901>>>>>>>>>>>>>>>>>>>            Move (GetLastError()) To iErr
82902>>>>>>>>>>>>>>>>>>>            Set piLastWindowsError To iErr
82903>>>>>>>>>>>>>>>>>>>          End
82903>>>>>>>>>>>>>>>>>>>>
82903>>>>>>>>>>>>>>>>>>>        End
82903>>>>>>>>>>>>>>>>>>>>
82903>>>>>>>>>>>>>>>>>>>      End
82903>>>>>>>>>>>>>>>>>>>>
82903>>>>>>>>>>>>>>>>>>>      Else Begin
82904>>>>>>>>>>>>>>>>>>>        Move (LoadLibrary(sModule)) to hModule
82905>>>>>>>>>>>>>>>>>>>        If hModule Ne 0 Begin
82907>>>>>>>>>>>>>>>>>>>          Send Add_Item hModule sFile
82908>>>>>>>>>>>>>>>>>>>        End
82908>>>>>>>>>>>>>>>>>>>>
82908>>>>>>>>>>>>>>>>>>>        Else Begin
82909>>>>>>>>>>>>>>>>>>>          // An error occured during the actual unloading by windows
82909>>>>>>>>>>>>>>>>>>>          // Get extended error information, call GetLastError.
82909>>>>>>>>>>>>>>>>>>>          Move 3 To iFailed
82910>>>>>>>>>>>>>>>>>>>          Move (GetLastError()) To iErr
82911>>>>>>>>>>>>>>>>>>>          Set piLastWindowsError To iErr
82912>>>>>>>>>>>>>>>>>>>        End
82912>>>>>>>>>>>>>>>>>>>>
82912>>>>>>>>>>>>>>>>>>>      End
82912>>>>>>>>>>>>>>>>>>>>
82912>>>>>>>>>>>>>>>>>>>    End
82912>>>>>>>>>>>>>>>>>>>>
82912>>>>>>>>>>>>>>>>>>>    Else Begin
82913>>>>>>>>>>>>>>>>>>>      Move 1 To iFailed // The file was not found
82914>>>>>>>>>>>>>>>>>>>    End
82914>>>>>>>>>>>>>>>>>>>>
82914>>>>>>>>>>>>>>>>>>>    Function_Return iFailed
82915>>>>>>>>>>>>>>>>>>>  End_Function
82916>>>>>>>>>>>>>>>>>>>
82916>>>>>>>>>>>>>>>>>>>  // Tries to load the DLL passed as sModuleName
82916>>>>>>>>>>>>>>>>>>>  // If pbErrorAbort is set the program is aborted and a message is displayed to
82916>>>>>>>>>>>>>>>>>>>  // the user.
82916>>>>>>>>>>>>>>>>>>>  // Calls DllLoadLibrary to actually load the DLL
82916>>>>>>>>>>>>>>>>>>>  //
82916>>>>>>>>>>>>>>>>>>>  // Does not return a value
82916>>>>>>>>>>>>>>>>>>>  Procedure doLoadLibrary String sModuleName
82918>>>>>>>>>>>>>>>>>>>    Integer iError bAbort bReport
82918>>>>>>>>>>>>>>>>>>>    String  sMessage sPath
82918>>>>>>>>>>>>>>>>>>>    Move 0 To iError
82919>>>>>>>>>>>>>>>>>>>    Get DllLoadLibrary "" sModuleName To iError
82920>>>>>>>>>>>>>>>>>>>    If (iError <> 0) Begin
82922>>>>>>>>>>>>>>>>>>>      Get pbErrorAbort  To bAbort
82923>>>>>>>>>>>>>>>>>>>      Get pbErrorReport To bReport
82924>>>>>>>>>>>>>>>>>>>      If (bReport) Begin
82926>>>>>>>>>>>>>>>>>>>        Get psDllLoadPath to sPath
82927>>>>>>>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
82928>>>>>>>>>>>>>>>>>>>        Move CS_ERRMISSINGDLLLINE1 To sMessage
82929>>>>>>>>>>>>>>>>>>>        Move (sMessage+CS_ERRMISSINGDLLLINE2) To sMessage
82930>>>>>>>>>>>>>>>>>>>        Move (sMessage+sPath+sModuleName+"\n\n") To sMessage
82931>>>>>>>>>>>>>>>>>>>        Send Stop_Box sMessage CS_ERRMISSINGDLLCAPTION
82932>>>>>>>>>>>>>>>>>>>      End
82932>>>>>>>>>>>>>>>>>>>>
82932>>>>>>>>>>>>>>>>>>>      If (bAbort) Begin
82934>>>>>>>>>>>>>>>>>>>        Abort
82935>>>>>>>>>>>>>>>>>>>>
82935>>>>>>>>>>>>>>>>>>>      End
82935>>>>>>>>>>>>>>>>>>>>
82935>>>>>>>>>>>>>>>>>>>    End
82935>>>>>>>>>>>>>>>>>>>>
82935>>>>>>>>>>>>>>>>>>>  End_Procedure
82936>>>>>>>>>>>>>>>>>>>
82936>>>>>>>>>>>>>>>>>>>  // Internal, do not use
82936>>>>>>>>>>>>>>>>>>>  //
82936>>>>>>>>>>>>>>>>>>>  // Precondition:
82936>>>>>>>>>>>>>>>>>>>  //  sFile must be UPPERCASEd
82936>>>>>>>>>>>>>>>>>>>  //  hModule must contain the windows module handle of the library that was mapped
82936>>>>>>>>>>>>>>>>>>>  //    into our address space
82936>>>>>>>>>>>>>>>>>>>  Procedure Add_Item Integer hModule Integer sFile
82938>>>>>>>>>>>>>>>>>>>    Integer iModule
82938>>>>>>>>>>>>>>>>>>>    Get Item_Count Of oModuleNames To iModule
82939>>>>>>>>>>>>>>>>>>>    Set Value Of oModuleNames Item iModule To sFile
82940>>>>>>>>>>>>>>>>>>>    Set ModuleHandle Item iModule To hModule
82941>>>>>>>>>>>>>>>>>>>  End_Procedure
82942>>>>>>>>>>>>>>>>>>>
82942>>>>>>>>>>>>>>>>>>>  // Clear the DLL handler
82942>>>>>>>>>>>>>>>>>>>  Procedure Delete_Data
82944>>>>>>>>>>>>>>>>>>>    Integer hModuleHandles
82944>>>>>>>>>>>>>>>>>>>    Integer hModuleNames
82944>>>>>>>>>>>>>>>>>>>    Move (oModuleHandles(Self)) To hModuleHandles
82945>>>>>>>>>>>>>>>>>>>    If hModuleHandles Ne 0 Begin
82947>>>>>>>>>>>>>>>>>>>      Send Delete_Data To hModuleHandles
82948>>>>>>>>>>>>>>>>>>>    End
82948>>>>>>>>>>>>>>>>>>>>
82948>>>>>>>>>>>>>>>>>>>    Move (oModuleNames(Self)) To hModuleNames
82949>>>>>>>>>>>>>>>>>>>    If hModuleNames Ne 0 Begin
82951>>>>>>>>>>>>>>>>>>>      Send Delete_Data To hModuleNames
82952>>>>>>>>>>>>>>>>>>>    End
82952>>>>>>>>>>>>>>>>>>>>
82952>>>>>>>>>>>>>>>>>>>    Forward Send Delete_Data
82954>>>>>>>>>>>>>>>>>>>  End_Procedure
82955>>>>>>>>>>>>>>>>>>>
82955>>>>>>>>>>>>>>>>>>>  // Returns the total nr of DLL files that are still loaded in memory
82955>>>>>>>>>>>>>>>>>>>  // Succesfully unloaded DLLs do not count.
82955>>>>>>>>>>>>>>>>>>>  //
82955>>>>>>>>>>>>>>>>>>>  // Precondition:
82955>>>>>>>>>>>>>>>>>>>  //  Only modules loaded by the DllLoadLibrary function count
82955>>>>>>>>>>>>>>>>>>>  Function LoadCount Returns Integer
82957>>>>>>>>>>>>>>>>>>>    Integer iModule iCount iLoaded
82957>>>>>>>>>>>>>>>>>>>    Integer hModule hModuleHandles
82957>>>>>>>>>>>>>>>>>>>    Move 0 To iLoaded
82958>>>>>>>>>>>>>>>>>>>    Move (oModuleHandles(Self)) To hModuleHandles
82959>>>>>>>>>>>>>>>>>>>    Move (Item_Count(hModuleHandles)-1) To iCount
82960>>>>>>>>>>>>>>>>>>>    For iModule From 0 To iCount
82966>>>>>>>>>>>>>>>>>>>>
82966>>>>>>>>>>>>>>>>>>>      Get Value Of hModuleHandles Item iModule To hModule
82967>>>>>>>>>>>>>>>>>>>      If (hModule <> 0) Begin
82969>>>>>>>>>>>>>>>>>>>        Increment iLoaded
82970>>>>>>>>>>>>>>>>>>>      End
82970>>>>>>>>>>>>>>>>>>>>
82970>>>>>>>>>>>>>>>>>>>    Loop
82971>>>>>>>>>>>>>>>>>>>>
82971>>>>>>>>>>>>>>>>>>>    Function_Return iLoaded
82972>>>>>>>>>>>>>>>>>>>  End_Function
82973>>>>>>>>>>>>>>>>>>>
82973>>>>>>>>>>>>>>>>>>>  // Get the total nr of modules that have been loaded using the
82973>>>>>>>>>>>>>>>>>>>  Function ItemCount Returns Integer
82975>>>>>>>>>>>>>>>>>>>    Function_Return (Item_Count(oModuleNames(Self)))
82976>>>>>>>>>>>>>>>>>>>  End_Function
82977>>>>>>>>>>>>>>>>>>>
82977>>>>>>>>>>>>>>>>>>>  // VDF syntax compatibility
82977>>>>>>>>>>>>>>>>>>>  Function Item_Count Returns Integer
82979>>>>>>>>>>>>>>>>>>>    Function_Return (ItemCount(Self))
82980>>>>>>>>>>>>>>>>>>>  End_Function
82981>>>>>>>>>>>>>>>>>>>
82981>>>>>>>>>>>>>>>>>>>  // Unload a Dllfile from memory
82981>>>>>>>>>>>>>>>>>>>  //
82981>>>>>>>>>>>>>>>>>>>  // sFile is the filename which was used to Load the library using the
82981>>>>>>>>>>>>>>>>>>>  //  DllLoadLibrary function from this class.
82981>>>>>>>>>>>>>>>>>>>  //
82981>>>>>>>>>>>>>>>>>>>  // Returns the following values:
82981>>>>>>>>>>>>>>>>>>>  // (False) if unloading of the dynamic Link library was succesful
82981>>>>>>>>>>>>>>>>>>>  // 1 if the DLL was not loaded in memory by the DllLoadLibrary function
82981>>>>>>>>>>>>>>>>>>>  // 2 if the DLL was already unloaded
82981>>>>>>>>>>>>>>>>>>>  // 3 An error occured during the actual unloading by windows
82981>>>>>>>>>>>>>>>>>>>  Function DllUnloadLibrary String sFile Returns Integer
82983>>>>>>>>>>>>>>>>>>>    Integer iFailed iErr
82983>>>>>>>>>>>>>>>>>>>    Integer iModule
82983>>>>>>>>>>>>>>>>>>>    Integer hModule hModuleHandles
82983>>>>>>>>>>>>>>>>>>>    Move 0 To iFailed
82984>>>>>>>>>>>>>>>>>>>    Move (UpperCase(sFile)) To sFile
82985>>>>>>>>>>>>>>>>>>>    Get Find_Element Of oModuleNames sFile To iModule
82986>>>>>>>>>>>>>>>>>>>    If iModule Ne -1 Begin
82988>>>>>>>>>>>>>>>>>>>      Move (oModuleHandles(Self)) To hModuleHandles
82989>>>>>>>>>>>>>>>>>>>      Get Value Of hModuleHandles Item iModule To hModule
82990>>>>>>>>>>>>>>>>>>>      If hModule Ne 0 Begin
82992>>>>>>>>>>>>>>>>>>>        //   Free ee Nelson Mandela  - oh yeah oh yeah...
82992>>>>>>>>>>>>>>>>>>>        Move (FreeLibrary(hModule)) To iErr
82993>>>>>>>>>>>>>>>>>>>        If iErr Ne 0 Begin  // If the function succeeds, the return value is nonzero.
82995>>>>>>>>>>>>>>>>>>>          Set Value Of hModuleHandles Item iModule To 0
82996>>>>>>>>>>>>>>>>>>>        End
82996>>>>>>>>>>>>>>>>>>>>
82996>>>>>>>>>>>>>>>>>>>        Else Begin
82997>>>>>>>>>>>>>>>>>>>          // An error occured during the actual unloading by windows
82997>>>>>>>>>>>>>>>>>>>          // Get extended error information, call GetLastError.
82997>>>>>>>>>>>>>>>>>>>          Move 3 To iFailed
82998>>>>>>>>>>>>>>>>>>>          Move (GetLastError()) To iErr
82999>>>>>>>>>>>>>>>>>>>          Set piLastWindowsError To iErr
83000>>>>>>>>>>>>>>>>>>>        End
83000>>>>>>>>>>>>>>>>>>>>
83000>>>>>>>>>>>>>>>>>>>      End
83000>>>>>>>>>>>>>>>>>>>>
83000>>>>>>>>>>>>>>>>>>>      Else Begin
83001>>>>>>>>>>>>>>>>>>>        Move 2 To iFailed // The DLL was already unloaded
83002>>>>>>>>>>>>>>>>>>>      End
83002>>>>>>>>>>>>>>>>>>>>
83002>>>>>>>>>>>>>>>>>>>    End
83002>>>>>>>>>>>>>>>>>>>>
83002>>>>>>>>>>>>>>>>>>>    Else Begin
83003>>>>>>>>>>>>>>>>>>>      Move 1 To iFailed // The DLL was not loaded in memory by the DllLoadLibrary function
83004>>>>>>>>>>>>>>>>>>>    End
83004>>>>>>>>>>>>>>>>>>>>
83004>>>>>>>>>>>>>>>>>>>    Function_Return iFailed
83005>>>>>>>>>>>>>>>>>>>  End_Function
83006>>>>>>>>>>>>>>>>>>>
83006>>>>>>>>>>>>>>>>>>>  Procedure Init
83008>>>>>>>>>>>>>>>>>>>    String  sPath
83008>>>>>>>>>>>>>>>>>>>
83008>>>>>>>>>>>>>>>>>>>    If sPath Eq "" Begin
83010>>>>>>>>>>>>>>>>>>>      Get_Current_Directory To sPath
83011>>>>>>>>>>>>>>>>>>>    End
83011>>>>>>>>>>>>>>>>>>>>
83011>>>>>>>>>>>>>>>>>>>    Move (vFolderFormat(sPath)) To sPath
83012>>>>>>>>>>>>>>>>>>>    Set psDllLoadPath To sPath
83013>>>>>>>>>>>>>>>>>>>  End_Procedure
83014>>>>>>>>>>>>>>>>>>>
83014>>>>>>>>>>>>>>>>>>>End_Class
83015>>>>>>>>>>>>>>>>>>>
83015>>>>>>>>>>>>>>>>>>>Object oDllHandler is a cDllHandler
83017>>>>>>>>>>>>>>>>>>>End_Object
83018>>>>>>>>>>>>>>>>>>>
83018>>>>>>>>>>>>>>>>>Use THDialog.pkg
Including file: THDialog.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\THDialog.pkg)
83018>>>>>>>>>>>>>>>>>>>// THDialog.pkg
83018>>>>>>>>>>>>>>>>>>>// By Sergey V. Natarov, Wil van Antwerpen
83018>>>>>>>>>>>>>>>>>>>//
83018>>>>>>>>>>>>>>>>>>>Use Windows.pkg
83018>>>>>>>>>>>>>>>>>>>Use Dfspnfrm.pkg
83018>>>>>>>>>>>>>>>>>>>Use Colr_dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Colr_dlg.pkg)
83018>>>>>>>>>>>>>>>>>>>>>Use VDFBase.pkg
83018>>>>>>>>>>>>>>>>>>>>>Use DLL.pkg
83018>>>>>>>>>>>>>>>>>>>>>Use RGB.pkg
83018>>>>>>>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
83018>>>>>>>>>>>>>>>>>>>>>
83018>>>>>>>>>>>>>>>>>>>>>
83018>>>>>>>>>>>>>>>>>>>>>External_Function ChooseColor 'ChooseColorA' COMDLG32.dll Pointer lpCC Returns DWord
83019>>>>>>>>>>>>>>>>>>>>>
83019>>>>>>>>>>>>>>>>>>>>>
83019>>>>>>>>>>>>>>>>>>>>>Class ColorDialog is a cObject
83020>>>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83022>>>>>>>>>>>>>>>>>>>>>        Integer iLoop
83022>>>>>>>>>>>>>>>>>>>>>        Handle hoCustomColors
83022>>>>>>>>>>>>>>>>>>>>>        
83022>>>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83024>>>>>>>>>>>>>>>>>>>>>        
83024>>>>>>>>>>>>>>>>>>>>>        Property Boolean FullOpen_State        True
83025>>>>>>>>>>>>>>>>>>>>>        Property Boolean PreventFullOpen_State False
83026>>>>>>>>>>>>>>>>>>>>>        Property Boolean SelectedColor_State   True
83027>>>>>>>>>>>>>>>>>>>>>        Property Integer SelectedColor         0
83028>>>>>>>>>>>>>>>>>>>>>        
83028>>>>>>>>>>>>>>>>>>>>>        Property Handle phoCustomColors (Create(Self, U_Array)) // create an array to hold the custom colors
83029>>>>>>>>>>>>>>>>>>>>>        
83029>>>>>>>>>>>>>>>>>>>>>        // Set all custom colors to white...
83029>>>>>>>>>>>>>>>>>>>>>        Get phoCustomColors to hoCustomColors
83030>>>>>>>>>>>>>>>>>>>>>        For iLoop from 0 to 15
83036>>>>>>>>>>>>>>>>>>>>>>
83036>>>>>>>>>>>>>>>>>>>>>            Set Value of hoCustomColors iLoop to clWhite
83037>>>>>>>>>>>>>>>>>>>>>        Loop
83038>>>>>>>>>>>>>>>>>>>>>>
83038>>>>>>>>>>>>>>>>>>>>>        
83038>>>>>>>>>>>>>>>>>>>>>    End_Procedure
83039>>>>>>>>>>>>>>>>>>>>>    
83039>>>>>>>>>>>>>>>>>>>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
83041>>>>>>>>>>>>>>>>>>>>>        Set Value of (phoCustomColors(Self)) iItem to rgbColor
83042>>>>>>>>>>>>>>>>>>>>>    End_Procedure
83043>>>>>>>>>>>>>>>>>>>>>    
83043>>>>>>>>>>>>>>>>>>>>>    Function Custom_Color Integer iItem Returns Integer
83045>>>>>>>>>>>>>>>>>>>>>        Function_Return (Integer_Value(phoCustomColors(Self), iItem))
83046>>>>>>>>>>>>>>>>>>>>>    End_Function
83047>>>>>>>>>>>>>>>>>>>>>    
83047>>>>>>>>>>>>>>>>>>>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
83049>>>>>>>>>>>>>>>>>>>>>        // Copies the custom colors from another ColorDialog instance
83049>>>>>>>>>>>>>>>>>>>>>        Integer iColor
83049>>>>>>>>>>>>>>>>>>>>>        
83049>>>>>>>>>>>>>>>>>>>>>        For iColor from 0 to 15
83055>>>>>>>>>>>>>>>>>>>>>>
83055>>>>>>>>>>>>>>>>>>>>>            Set Custom_Color iColor to (Value(hoSourceColorDialog, iColor))
83056>>>>>>>>>>>>>>>>>>>>>        Loop
83057>>>>>>>>>>>>>>>>>>>>>>
83057>>>>>>>>>>>>>>>>>>>>>    End_Procedure
83058>>>>>>>>>>>>>>>>>>>>>    
83058>>>>>>>>>>>>>>>>>>>>>    Function Value Integer iItem Returns String
83060>>>>>>>>>>>>>>>>>>>>>        // Provides support for the AssignCustomColors procedure, which requires
83060>>>>>>>>>>>>>>>>>>>>>        // that a "Get Value" interface is supported
83060>>>>>>>>>>>>>>>>>>>>>        Function_Return (Custom_Color(Self, iItem))
83061>>>>>>>>>>>>>>>>>>>>>    End_Function
83062>>>>>>>>>>>>>>>>>>>>>    
83062>>>>>>>>>>>>>>>>>>>>>    Function OwnerHandle Returns Handle
83064>>>>>>>>>>>>>>>>>>>>>        Handle hWnd
83064>>>>>>>>>>>>>>>>>>>>>        Handle hoObj
83064>>>>>>>>>>>>>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
83065>>>>>>>>>>>>>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
83066>>>>>>>>>>>>>>>>>>>>>        Function_Return hWnd
83067>>>>>>>>>>>>>>>>>>>>>    End_Function
83068>>>>>>>>>>>>>>>>>>>>>    
83068>>>>>>>>>>>>>>>>>>>>>    Function Show_Dialog Returns Boolean
83070>>>>>>>>>>>>>>>>>>>>>        //Shows the dialog. Returns True if the OK button was clicked.
83070>>>>>>>>>>>>>>>>>>>>>        Handle  hContainer hoCustomColors
83070>>>>>>>>>>>>>>>>>>>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
83070>>>>>>>>>>>>>>>>>>>>>        Integer rgbColor iFlags iLoop
83070>>>>>>>>>>>>>>>>>>>>>        String sCC sColors
83070>>>>>>>>>>>>>>>>>>>>>        tWinChooseColor ChseColor
83070>>>>>>>>>>>>>>>>>>>>>        tWinChooseColor ChseColor
83070>>>>>>>>>>>>>>>>>>>>>        
83070>>>>>>>>>>>>>>>>>>>>>        Get OwnerHandle to hContainer
83071>>>>>>>>>>>>>>>>>>>>>        
83071>>>>>>>>>>>>>>>>>>>>>        Get phoCustomColors to hoCustomColors
83072>>>>>>>>>>>>>>>>>>>>>        
83072>>>>>>>>>>>>>>>>>>>>>        Move '' to sColors
83073>>>>>>>>>>>>>>>>>>>>>        For iLoop from 0 to 15
83079>>>>>>>>>>>>>>>>>>>>>>
83079>>>>>>>>>>>>>>>>>>>>>            Get Value of hoCustomColors iLoop to rgbColor
83080>>>>>>>>>>>>>>>>>>>>>            Move (sColors + DWORDToBytes(rgbColor)) to sColors
83081>>>>>>>>>>>>>>>>>>>>>        Loop
83082>>>>>>>>>>>>>>>>>>>>>>
83082>>>>>>>>>>>>>>>>>>>>>        
83082>>>>>>>>>>>>>>>>>>>>>        Get FullOpen_State        to bFullOpen
83083>>>>>>>>>>>>>>>>>>>>>        Get PreventFullOpen_State to bNoOpen
83084>>>>>>>>>>>>>>>>>>>>>        Get SelectedColor_State   to bSelColor
83085>>>>>>>>>>>>>>>>>>>>>        Get SelectedColor         to rgbColor
83086>>>>>>>>>>>>>>>>>>>>>        
83086>>>>>>>>>>>>>>>>>>>>>        Move 0 to iFlags
83087>>>>>>>>>>>>>>>>>>>>>        If bFullOpen ;            Move (iFlags +CC_FULLOPEN)        to iFlags
83090>>>>>>>>>>>>>>>>>>>>>        If bNoOpen ;            Move (iFlags +CC_PREVENTFULLOPEN) to iFlags
83093>>>>>>>>>>>>>>>>>>>>>        If bSelColor ;            Move (iFlags +CC_RGBINIT)         to iFlags
83096>>>>>>>>>>>>>>>>>>>>>        
83096>>>>>>>>>>>>>>>>>>>>>        Move (SizeOfType(tWinChooseColor))     to ChseColor.lStructSize
83097>>>>>>>>>>>>>>>>>>>>>        Move hContainer           to ChseColor.hWndOWner
83098>>>>>>>>>>>>>>>>>>>>>        Move rgbColor             to ChseColor.rgbResult
83099>>>>>>>>>>>>>>>>>>>>>        Move (AddressOf(sColors)) to ChseColor.lpCustColors
83100>>>>>>>>>>>>>>>>>>>>>        Move iFlags               to ChseColor.flags
83101>>>>>>>>>>>>>>>>>>>>>        
83101>>>>>>>>>>>>>>>>>>>>>        Move (ChooseColor(AddressOf(ChseColor))) to bSelected
83102>>>>>>>>>>>>>>>>>>>>>        
83102>>>>>>>>>>>>>>>>>>>>>        If bSelected Begin
83104>>>>>>>>>>>>>>>>>>>>>            For iLoop from 0 to 15
83110>>>>>>>>>>>>>>>>>>>>>>
83110>>>>>>>>>>>>>>>>>>>>>                Move (DeRefDw(AddressOf(sColors), iLoop *4)) to rgbColor
83111>>>>>>>>>>>>>>>>>>>>>                Set Value of hoCustomColors iLoop to rgbColor
83112>>>>>>>>>>>>>>>>>>>>>            Loop
83113>>>>>>>>>>>>>>>>>>>>>>
83113>>>>>>>>>>>>>>>>>>>>>            Move ChseColor.rgbResult to rgbColor
83114>>>>>>>>>>>>>>>>>>>>>            Set SelectedColor to rgbColor
83115>>>>>>>>>>>>>>>>>>>>>        End
83115>>>>>>>>>>>>>>>>>>>>>>
83115>>>>>>>>>>>>>>>>>>>>>        Function_Return bSelected
83116>>>>>>>>>>>>>>>>>>>>>    End_Function
83117>>>>>>>>>>>>>>>>>>>>>    
83117>>>>>>>>>>>>>>>>>>>>>End_Class
83118>>>>>>>>>>>>>>>>>>>>>
83118>>>>>>>>>>>>>>>>>>>
83118>>>>>>>>>>>>>>>>>>>Define FindUp   for 0
83118>>>>>>>>>>>>>>>>>>>Define FindDown for 1
83118>>>>>>>>>>>>>>>>>>>
83118>>>>>>>>>>>>>>>>>>>Define ReplaceSelection for 0
83118>>>>>>>>>>>>>>>>>>>Define ReplaceBuffer    for 1
83118>>>>>>>>>>>>>>>>>>>
83118>>>>>>>>>>>>>>>>>>>// *** Find & Replace
83118>>>>>>>>>>>>>>>>>>>Struct tFindReplaceOptions
83118>>>>>>>>>>>>>>>>>>>  String  sSearchText
83118>>>>>>>>>>>>>>>>>>>  String  sReplaceText // +R
83118>>>>>>>>>>>>>>>>>>>  Boolean bWordMatch
83118>>>>>>>>>>>>>>>>>>>  Boolean bMatchCase
83118>>>>>>>>>>>>>>>>>>>  Boolean bRegExp
83118>>>>>>>>>>>>>>>>>>>  Boolean bPreserveCase // +R
83118>>>>>>>>>>>>>>>>>>>  Integer eFindOptions  // *R = eDirection -> eFindOptions
83118>>>>>>>>>>>>>>>>>>>  Boolean bDocumentStart
83118>>>>>>>>>>>>>>>>>>>  Boolean bStartFind
83118>>>>>>>>>>>>>>>>>>>  Boolean bMarkAll
83118>>>>>>>>>>>>>>>>>>>  Boolean bReplace      // +R
83118>>>>>>>>>>>>>>>>>>>  Boolean bReplaceAll   // +R
83118>>>>>>>>>>>>>>>>>>>  Boolean bCancel
83118>>>>>>>>>>>>>>>>>>>End_Struct
83118>>>>>>>>>>>>>>>>>>>
83118>>>>>>>>>>>>>>>>>>>Class cFindCheckBox is a CheckBox
83119>>>>>>>>>>>>>>>>>>>
83119>>>>>>>>>>>>>>>>>>>  Procedure doToggle
83121>>>>>>>>>>>>>>>>>>>    Boolean bState
83121>>>>>>>>>>>>>>>>>>>
83121>>>>>>>>>>>>>>>>>>>    Send DispatchHotkey  // no ringing bell on pressing your shortcut key please, that drives me nuts
83122>>>>>>>>>>>>>>>>>>>    Send Activate
83123>>>>>>>>>>>>>>>>>>>    Get Checked_State to bState
83124>>>>>>>>>>>>>>>>>>>    Set Checked_State to (not(bState))
83125>>>>>>>>>>>>>>>>>>>  End_Procedure
83126>>>>>>>>>>>>>>>>>>>End_Class
83127>>>>>>>>>>>>>>>>>>>
83127>>>>>>>>>>>>>>>>>>>Class cFindForm is a Form
83128>>>>>>>>>>>>>>>>>>>  Procedure Activate returns integer
83130>>>>>>>>>>>>>>>>>>>    Integer iRetVal
83130>>>>>>>>>>>>>>>>>>>    Send DispatchHotkey  // no ringing bell on pressing your shortcut key please, that drives me nuts
83131>>>>>>>>>>>>>>>>>>>    forward Get msg_activate to iRetVal
83133>>>>>>>>>>>>>>>>>>>    Procedure_Return iRetVal
83134>>>>>>>>>>>>>>>>>>>  End_Procedure
83135>>>>>>>>>>>>>>>>>>>End_Class
83136>>>>>>>>>>>>>>>>>>>
83136>>>>>>>>>>>>>>>>>>>Class cFindComboForm Is a ComboForm
83137>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
83139>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
83141>>>>>>>>>>>>>>>>>>>    Set Combo_Sort_State To False
83142>>>>>>>>>>>>>>>>>>>    Property String[] pSearchStrings
83143>>>>>>>>>>>>>>>>>>>  End_Procedure
83144>>>>>>>>>>>>>>>>>>>
83144>>>>>>>>>>>>>>>>>>>  Procedure Activate returns integer
83146>>>>>>>>>>>>>>>>>>>    Integer iRetVal
83146>>>>>>>>>>>>>>>>>>>    Send DispatchHotkey  // no ringing bell on pressing your shortcut key please, that drives me nuts
83147>>>>>>>>>>>>>>>>>>>    forward Get msg_activate to iRetVal
83149>>>>>>>>>>>>>>>>>>>    Procedure_Return iRetVal
83150>>>>>>>>>>>>>>>>>>>  End_Procedure
83151>>>>>>>>>>>>>>>>>>>
83151>>>>>>>>>>>>>>>>>>>  Procedure Combo_Fill_List
83153>>>>>>>>>>>>>>>>>>>    Integer  iItem
83153>>>>>>>>>>>>>>>>>>>    Integer  iCount
83153>>>>>>>>>>>>>>>>>>>    String[] SearchStrings
83154>>>>>>>>>>>>>>>>>>>
83154>>>>>>>>>>>>>>>>>>>    Get pSearchStrings To SearchStrings
83155>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(SearchStrings)) To iCount
83156>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
83158>>>>>>>>>>>>>>>>>>>      Send Combo_Delete_Data
83159>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
83165>>>>>>>>>>>>>>>>>>>>
83165>>>>>>>>>>>>>>>>>>>         Send Combo_Add_Item SearchStrings[iItem]
83166>>>>>>>>>>>>>>>>>>>      Loop
83167>>>>>>>>>>>>>>>>>>>>
83167>>>>>>>>>>>>>>>>>>>      Set Value To SearchStrings[0]
83168>>>>>>>>>>>>>>>>>>>    End
83168>>>>>>>>>>>>>>>>>>>>
83168>>>>>>>>>>>>>>>>>>>  End_Procedure
83169>>>>>>>>>>>>>>>>>>>
83169>>>>>>>>>>>>>>>>>>>  Procedure AddSearchString String sValue
83171>>>>>>>>>>>>>>>>>>>    Integer  iIndex
83171>>>>>>>>>>>>>>>>>>>    String[] SearchStrings
83172>>>>>>>>>>>>>>>>>>>
83172>>>>>>>>>>>>>>>>>>>    If (sValue<>"") Begin
83174>>>>>>>>>>>>>>>>>>>      Get pSearchStrings To SearchStrings
83175>>>>>>>>>>>>>>>>>>>      Move (SearchArray(sValue,SearchStrings,Desktop,(RefFunc(DFSTRICMP)))) To iIndex
83176>>>>>>>>>>>>>>>>>>>      If (iIndex>-1) Begin
83178>>>>>>>>>>>>>>>>>>>        Move (RemoveFromArray(SearchStrings,iIndex)) To SearchStrings // it will be moved up to the first position
83179>>>>>>>>>>>>>>>>>>>      End
83179>>>>>>>>>>>>>>>>>>>>
83179>>>>>>>>>>>>>>>>>>>      Move (InsertInArray(SearchStrings,0,sValue)) To SearchStrings
83180>>>>>>>>>>>>>>>>>>>      Set pSearchStrings To SearchStrings
83181>>>>>>>>>>>>>>>>>>>    End
83181>>>>>>>>>>>>>>>>>>>>
83181>>>>>>>>>>>>>>>>>>>  End_Procedure
83182>>>>>>>>>>>>>>>>>>>
83182>>>>>>>>>>>>>>>>>>>  Procedure Set SearchValue String sValue
83184>>>>>>>>>>>>>>>>>>>
83184>>>>>>>>>>>>>>>>>>>    If (sValue<>"") Begin
83186>>>>>>>>>>>>>>>>>>>      Send AddSearchString sValue
83187>>>>>>>>>>>>>>>>>>>      Send Combo_Fill_List
83188>>>>>>>>>>>>>>>>>>>    End
83188>>>>>>>>>>>>>>>>>>>>
83188>>>>>>>>>>>>>>>>>>>  End_Procedure
83189>>>>>>>>>>>>>>>>>>>
83189>>>>>>>>>>>>>>>>>>>End_Class
83190>>>>>>>>>>>>>>>>>>>
83190>>>>>>>>>>>>>>>>>>>
83190>>>>>>>>>>>>>>>>>>>// *** TH Parameters
83190>>>>>>>>>>>>>>>>>>>
83190>>>>>>>>>>>>>>>>>>>Register_Procedure  Request_SaveAllEntries
83190>>>>>>>>>>>>>>>>>>>Register_Procedure  NotifyChange
83190>>>>>>>>>>>>>>>>>>>Register_Object     oStatusHelp
83190>>>>>>>>>>>>>>>>>>>Register_Object     oOpenDialog
83190>>>>>>>>>>>>>>>>>>>
83190>>>>>>>>>>>>>>>>>>>Class cNotifierCheckBox is a CheckBox
83191>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83193>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83195>>>>>>>>>>>>>>>>>>>        On_Key key_F2 Send Request_SaveAllEntries
83196>>>>>>>>>>>>>>>>>>>        On_Key kCancel Send Close_Panel
83197>>>>>>>>>>>>>>>>>>>    End_Procedure
83198>>>>>>>>>>>>>>>>>>>    Procedure onChange
83200>>>>>>>>>>>>>>>>>>>        Delegate Send NotifyChange
83202>>>>>>>>>>>>>>>>>>>    End_Procedure
83203>>>>>>>>>>>>>>>>>>>    Procedure Set Status_Help String sHelp
83205>>>>>>>>>>>>>>>>>>>        String sToolTipText
83205>>>>>>>>>>>>>>>>>>>        Forward Set Status_Help to sHelp
83207>>>>>>>>>>>>>>>>>>>        Get psToolTip to sToolTipText
83208>>>>>>>>>>>>>>>>>>>        If (sToolTipText = "") Begin
83210>>>>>>>>>>>>>>>>>>>            Set psToolTip to sHelp
83211>>>>>>>>>>>>>>>>>>>        End
83211>>>>>>>>>>>>>>>>>>>>
83211>>>>>>>>>>>>>>>>>>>    End_Procedure
83212>>>>>>>>>>>>>>>>>>>End_Class
83213>>>>>>>>>>>>>>>>>>>
83213>>>>>>>>>>>>>>>>>>>Class cNotifierForm is a Form
83214>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83216>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83218>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83219>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83220>>>>>>>>>>>>>>>>>>>        On_Key key_F2 Send Request_SaveAllEntries
83221>>>>>>>>>>>>>>>>>>>        On_Key kCancel Send Close_Panel
83222>>>>>>>>>>>>>>>>>>>    End_Procedure
83223>>>>>>>>>>>>>>>>>>>    Procedure onChange
83225>>>>>>>>>>>>>>>>>>>        Delegate Send NotifyChange
83227>>>>>>>>>>>>>>>>>>>    End_Procedure
83228>>>>>>>>>>>>>>>>>>>    Procedure Set Status_Help String sHelp
83230>>>>>>>>>>>>>>>>>>>        String sToolTipText
83230>>>>>>>>>>>>>>>>>>>        Forward Set Status_Help to sHelp
83232>>>>>>>>>>>>>>>>>>>        Get psToolTip to sToolTipText
83233>>>>>>>>>>>>>>>>>>>        If (sToolTipText = "") Begin
83235>>>>>>>>>>>>>>>>>>>            Set psToolTip to sHelp
83236>>>>>>>>>>>>>>>>>>>        End
83236>>>>>>>>>>>>>>>>>>>>
83236>>>>>>>>>>>>>>>>>>>    End_Procedure
83237>>>>>>>>>>>>>>>>>>>End_Class
83238>>>>>>>>>>>>>>>>>>>
83238>>>>>>>>>>>>>>>>>>>Class cNotifierSpinForm is a Spinform
83239>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83241>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83243>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83244>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83245>>>>>>>>>>>>>>>>>>>        On_Key key_F2 Send Request_SaveAllEntries
83246>>>>>>>>>>>>>>>>>>>        On_Key kCancel Send Close_Panel
83247>>>>>>>>>>>>>>>>>>>    End_Procedure
83248>>>>>>>>>>>>>>>>>>>    Procedure onChange
83250>>>>>>>>>>>>>>>>>>>        Delegate Send NotifyChange
83252>>>>>>>>>>>>>>>>>>>    End_Procedure
83253>>>>>>>>>>>>>>>>>>>    Procedure Set Status_Help String sHelp
83255>>>>>>>>>>>>>>>>>>>        String sToolTipText
83255>>>>>>>>>>>>>>>>>>>        Forward Set Status_Help to sHelp
83257>>>>>>>>>>>>>>>>>>>        Get psToolTip to sToolTipText
83258>>>>>>>>>>>>>>>>>>>        If (sToolTipText = "") Begin
83260>>>>>>>>>>>>>>>>>>>            Set psToolTip to sHelp
83261>>>>>>>>>>>>>>>>>>>        End
83261>>>>>>>>>>>>>>>>>>>>
83261>>>>>>>>>>>>>>>>>>>    End_Procedure
83262>>>>>>>>>>>>>>>>>>>End_Class
83263>>>>>>>>>>>>>>>>>>>
83263>>>>>>>>>>>>>>>>>>>Class cNotifierComboForm is a ComboForm
83264>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83266>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83268>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83269>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83270>>>>>>>>>>>>>>>>>>>        On_Key key_F2 Send Request_SaveAllEntries
83271>>>>>>>>>>>>>>>>>>>        On_Key kCancel Send Close_Panel
83272>>>>>>>>>>>>>>>>>>>    End_Procedure
83273>>>>>>>>>>>>>>>>>>>    Procedure onChange
83275>>>>>>>>>>>>>>>>>>>        Delegate Send NotifyChange
83277>>>>>>>>>>>>>>>>>>>    End_Procedure
83278>>>>>>>>>>>>>>>>>>>    Procedure Set Status_Help String sHelp
83280>>>>>>>>>>>>>>>>>>>        String sToolTipText
83280>>>>>>>>>>>>>>>>>>>        Forward Set Status_Help to sHelp
83282>>>>>>>>>>>>>>>>>>>        Get psToolTip to sToolTipText
83283>>>>>>>>>>>>>>>>>>>        If (sToolTipText = "") Begin
83285>>>>>>>>>>>>>>>>>>>            Set psToolTip to sHelp
83286>>>>>>>>>>>>>>>>>>>        End
83286>>>>>>>>>>>>>>>>>>>>
83286>>>>>>>>>>>>>>>>>>>    End_Procedure
83287>>>>>>>>>>>>>>>>>>>End_Class
83288>>>>>>>>>>>>>>>>>>>
83288>>>>>>>>>>>>>>>>>>>Class cColorPicker is a Container3D
83289>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83291>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83293>>>>>>>>>>>>>>>>>>>        Set Size to 10 90
83294>>>>>>>>>>>>>>>>>>>        Set Location to 9 7
83295>>>>>>>>>>>>>>>>>>>        Set Border_Style to Border_Normal
83296>>>>>>>>>>>>>>>>>>>        Set Color to clWhite
83297>>>>>>>>>>>>>>>>>>>    End_Procedure
83298>>>>>>>>>>>>>>>>>>>    Procedure Mouse_Down Integer i1
83300>>>>>>>>>>>>>>>>>>>        Handle  hoDlg
83300>>>>>>>>>>>>>>>>>>>        Integer bOk iColor
83300>>>>>>>>>>>>>>>>>>>        Get Color to iColor
83301>>>>>>>>>>>>>>>>>>>        Object oColorDlg is a ColorDialog
83303>>>>>>>>>>>>>>>>>>>            Set SelectedColor   to iColor
83304>>>>>>>>>>>>>>>>>>>            Set Custom_Color 0  to iColor
83305>>>>>>>>>>>>>>>>>>>            Get Object_Id       to hoDlg
83306>>>>>>>>>>>>>>>>>>>        End_Object
83307>>>>>>>>>>>>>>>>>>>        Get Show_Dialog of hoDlg to bOK
83308>>>>>>>>>>>>>>>>>>>        If bOK Begin
83310>>>>>>>>>>>>>>>>>>>            Get SelectedColor of hoDlg to iColor
83311>>>>>>>>>>>>>>>>>>>            Set Color to iColor
83312>>>>>>>>>>>>>>>>>>>            Delegate Send OnColorChange
83314>>>>>>>>>>>>>>>>>>>        End
83314>>>>>>>>>>>>>>>>>>>>
83314>>>>>>>>>>>>>>>>>>>        Send Destroy to hoDlg
83315>>>>>>>>>>>>>>>>>>>        Forward Send Mouse_Down i1
83317>>>>>>>>>>>>>>>>>>>    End_Procedure
83318>>>>>>>>>>>>>>>>>>>End_Class
83319>>>>>>>>>>>>>>>>>>>
83319>>>>>>>>>>>>>>>>>>>Class cColorBox is a Container3d
83320>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
83322>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
83324>>>>>>>>>>>>>>>>>>>        Property Integer piColorerIndex
83325>>>>>>>>>>>>>>>>>>>        Set Size to 22 105
83326>>>>>>>>>>>>>>>>>>>        Set Border_Style to Border_Normal
83327>>>>>>>>>>>>>>>>>>>        Set Color to clWhite
83328>>>>>>>>>>>>>>>>>>>        Object oLabel is a TextBox
83330>>>>>>>>>>>>>>>>>>>            Set Auto_Size_State to False
83331>>>>>>>>>>>>>>>>>>>            Set Size to 15 106
83332>>>>>>>>>>>>>>>>>>>            Set Location to 0 0
83333>>>>>>>>>>>>>>>>>>>            Set Label to "Color"
83334>>>>>>>>>>>>>>>>>>>            Set Justification_Mode to JMode_Center
83335>>>>>>>>>>>>>>>>>>>            Set Transparent_State to True
83336>>>>>>>>>>>>>>>>>>>        End_Object
83337>>>>>>>>>>>>>>>>>>>        Object oColorPicker is a cColorPicker
83339>>>>>>>>>>>>>>>>>>>        End_Object
83340>>>>>>>>>>>>>>>>>>>    End_Procedure
83341>>>>>>>>>>>>>>>>>>>    Procedure OnColorChange
83343>>>>>>>>>>>>>>>>>>>    End_Procedure
83344>>>>>>>>>>>>>>>>>>>    Procedure Set Label String sLabel
83346>>>>>>>>>>>>>>>>>>>        Set Label of (oLabel(Self)) to sLabel
83347>>>>>>>>>>>>>>>>>>>    End_Procedure
83348>>>>>>>>>>>>>>>>>>>    Function Label Returns String
83350>>>>>>>>>>>>>>>>>>>        Function_Return (Label(oLabel(Self)))
83351>>>>>>>>>>>>>>>>>>>    End_Function
83352>>>>>>>>>>>>>>>>>>>    Procedure Set SlectedColor Integer iRGBColor
83354>>>>>>>>>>>>>>>>>>>        If (iRGBColor=-1) Begin
83356>>>>>>>>>>>>>>>>>>>            Move clWhite to iRGBColor
83357>>>>>>>>>>>>>>>>>>>        End
83357>>>>>>>>>>>>>>>>>>>>
83357>>>>>>>>>>>>>>>>>>>        Set Color of (oColorPicker(Self)) to iRGBColor
83358>>>>>>>>>>>>>>>>>>>    End_Procedure
83359>>>>>>>>>>>>>>>>>>>    Function SelectedColor Returns Integer
83361>>>>>>>>>>>>>>>>>>>        Function_Return (Color(oColorPicker(Self)))
83362>>>>>>>>>>>>>>>>>>>    End_Function
83363>>>>>>>>>>>>>>>>>>>End_Class
83364>>>>>>>>>>>>>>>>>Use Tools\Find.dg
Including file: Tools\Find.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\Tools\Find.dg)
83364>>>>>>>>>>>>>>>>>>>Use Windows.pkg
83364>>>>>>>>>>>>>>>>>>>Use MessageQueueHelpers.pkg
Including file: MessageQueueHelpers.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MessageQueueHelpers.pkg)
83364>>>>>>>>>>>>>>>>>>>>>//TH-Header
83364>>>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
83364>>>>>>>>>>>>>>>>>>>>>// Copyright (c)  2018 Your Company Name
83364>>>>>>>>>>>>>>>>>>>>>// All rights reserved.
83364>>>>>>>>>>>>>>>>>>>>>//
83364>>>>>>>>>>>>>>>>>>>>>// $FileName    : MessageQueueHelpers.pkg
83364>>>>>>>>>>>>>>>>>>>>>// $ProjectName : The Hammer 3
83364>>>>>>>>>>>>>>>>>>>>>// $Authors     :
83364>>>>>>>>>>>>>>>>>>>>>// $Created     : 02.08.2018  11:54
83364>>>>>>>>>>>>>>>>>>>>>//
83364>>>>>>>>>>>>>>>>>>>>>// Contents:
83364>>>>>>>>>>>>>>>>>>>>>//   Used for dispatching keys from the message queue.
83364>>>>>>>>>>>>>>>>>>>>>//
83364>>>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
83364>>>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
83364>>>>>>>>>>>>>>>>>>>>>// ********************
83364>>>>>>>>>>>>>>>>>>>>>// MODIFICATION SUMMARY
83364>>>>>>>>>>>>>>>>>>>>>// ********************
83364>>>>>>>>>>>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
83364>>>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
83364>>>>>>>>>>>>>>>>>>>>>
83364>>>>>>>>>>>>>>>>>>>>>
83364>>>>>>>>>>>>>>>>>>>>>Define WM_HOTKEY For |CI$0312  //  0x0312
83364>>>>>>>>>>>>>>>>>>>>>Define PM_REMOVE For 1
83364>>>>>>>>>>>>>>>>>>>>>
83364>>>>>>>>>>>>>>>>>>>>>
83364>>>>>>>>>>>>>>>>>>>>>// dll-function and msg-type needed for removing posted messages from the message queue
83364>>>>>>>>>>>>>>>>>>>>>// 28.1.2003 BP
83364>>>>>>>>>>>>>>>>>>>>>Struct tMSG
83364>>>>>>>>>>>>>>>>>>>>>  Handle   hwnd     //as Handle
83364>>>>>>>>>>>>>>>>>>>>>  Integer  message  //as Integer
83364>>>>>>>>>>>>>>>>>>>>>  Longptr  wParam   //as WPARAM
83364>>>>>>>>>>>>>>>>>>>>>  Longptr  lParam   //as LPARAM
83364>>>>>>>>>>>>>>>>>>>>>  DWord    Time     //as DWord
83364>>>>>>>>>>>>>>>>>>>>>  DWord    ptX      //as DWord
83364>>>>>>>>>>>>>>>>>>>>>  DWord    ptY      //as DWord
83364>>>>>>>>>>>>>>>>>>>>>  DWORD    lPrivate
83364>>>>>>>>>>>>>>>>>>>>>End_Struct
83364>>>>>>>>>>>>>>>>>>>>>
83364>>>>>>>>>>>>>>>>>>>>>External_Function TranslateMessage "TranslateMessage" user32.dll Pointer pMsg Returns Integer
83365>>>>>>>>>>>>>>>>>>>>>External_Function PeekMessage      "PeekMessageA"     user32.dll Pointer pMsg Handle hWnd Integer iMin Integer iMax Integer iRemove Returns Integer
83366>>>>>>>>>>>>>>>>>>>>>External_Function DispatchMessage  "DispatchMessageA" user32.dll Pointer pMsg Returns Integer
83367>>>>>>>>>>>>>>>>>>>>>
83367>>>>>>>>>>>>>>>>>>>>>//
83367>>>>>>>>>>>>>>>>>>>>>// Dispatches the next message in the queue if it is a hotkey
83367>>>>>>>>>>>>>>>>>>>>>// (a key that combined with the alt-keyboard key)
83367>>>>>>>>>>>>>>>>>>>>>//
83367>>>>>>>>>>>>>>>>>>>>>Procedure DispatchHotkey
83370>>>>>>>>>>>>>>>>>>>>>  Integer iPendingMessage
83370>>>>>>>>>>>>>>>>>>>>>  Integer iVoid iTranslated
83370>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83370>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83370>>>>>>>>>>>>>>>>>>>>>
83370>>>>>>>>>>>>>>>>>>>>>  Move 0 To WinMsg.ptX
83371>>>>>>>>>>>>>>>>>>>>>  If (PeekMessage(AddressOf(WinMsg), 0, 0, 0, PM_REMOVE)) Begin
83373>>>>>>>>>>>>>>>>>>>>>    Move WinMsg.message To iPendingMessage
83374>>>>>>>>>>>>>>>>>>>>>    If (iPendingMessage = WM_HOTKEY) Begin
83376>>>>>>>>>>>>>>>>>>>>>      Move (TranslateMessage(AddressOf(WinMsg))) To iTranslated
83377>>>>>>>>>>>>>>>>>>>>>      If (iTranslated) Begin
83379>>>>>>>>>>>>>>>>>>>>>        Move (DispatchMessage(AddressOf(WinMsg)))  To iVoid
83380>>>>>>>>>>>>>>>>>>>>>      End
83380>>>>>>>>>>>>>>>>>>>>>>
83380>>>>>>>>>>>>>>>>>>>>>    End
83380>>>>>>>>>>>>>>>>>>>>>>
83380>>>>>>>>>>>>>>>>>>>>>  End
83380>>>>>>>>>>>>>>>>>>>>>>
83380>>>>>>>>>>>>>>>>>>>>>End_Procedure
83381>>>>>>>>>>>>>>>>>>>>>
83381>>>>>>>>>>>>>>>>>>>>>//
83381>>>>>>>>>>>>>>>>>>>>>// Dispatches ANY key press from the loop, not just one, but all of them
83381>>>>>>>>>>>>>>>>>>>>>//
83381>>>>>>>>>>>>>>>>>>>>>Procedure DispatchAnyKey
83384>>>>>>>>>>>>>>>>>>>>>  Integer iPendingMessage
83384>>>>>>>>>>>>>>>>>>>>>  Integer iVoid iTranslated
83384>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83384>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83384>>>>>>>>>>>>>>>>>>>>>
83384>>>>>>>>>>>>>>>>>>>>>  Move 0 To WinMsg.ptX
83385>>>>>>>>>>>>>>>>>>>>>  If (PeekMessage(AddressOf(WinMsg), 0, 0, 0, PM_REMOVE)) Begin
83387>>>>>>>>>>>>>>>>>>>>>    Move WinMsg.message To iPendingMessage
83388>>>>>>>>>>>>>>>>>>>>>    If (iPendingMessage = WM_HOTKEY or iPendingMessage = WM_KEYDOWN or iPendingMessage = WM_KEYUP) Begin
83390>>>>>>>>>>>>>>>>>>>>>      Move (TranslateMessage(AddressOf(WinMsg))) To iTranslated
83391>>>>>>>>>>>>>>>>>>>>>      If (iTranslated) Begin
83393>>>>>>>>>>>>>>>>>>>>>        Move (DispatchMessage(AddressOf(WinMsg)))  To iVoid
83394>>>>>>>>>>>>>>>>>>>>>      End
83394>>>>>>>>>>>>>>>>>>>>>>
83394>>>>>>>>>>>>>>>>>>>>>    End
83394>>>>>>>>>>>>>>>>>>>>>>
83394>>>>>>>>>>>>>>>>>>>>>  End
83394>>>>>>>>>>>>>>>>>>>>>>
83394>>>>>>>>>>>>>>>>>>>>>End_Procedure
83395>>>>>>>>>>>>>>>>>>>>>
83395>>>>>>>>>>>>>>>>>>>Use THDialog.pkg
83395>>>>>>>>>>>>>>>>>>>
83395>>>>>>>>>>>>>>>>>>>Object oFindDialog is a ModalPanel
83397>>>>>>>>>>>>>>>>>>>    Set Size to 75 270
83398>>>>>>>>>>>>>>>>>>>    Set Label to "Find"
83399>>>>>>>>>>>>>>>>>>>    Set piMinSize to 75 270
83400>>>>>>>>>>>>>>>>>>>    Set Location to 44 47
83401>>>>>>>>>>>>>>>>>>>    Set Border_Style to Border_Thick
83402>>>>>>>>>>>>>>>>>>>    //Set Locate_Mode to POPUP_LOCATE -- locate mode isn't smart enough
83402>>>>>>>>>>>>>>>>>>>    Property Boolean pbStartFind
83404>>>>>>>>>>>>>>>>>>>    Property Boolean pbMarkAll
83406>>>>>>>>>>>>>>>>>>>
83406>>>>>>>>>>>>>>>>>>>    Set peAnchors to anAll
83407>>>>>>>>>>>>>>>>>>>    Set piMaxSize to 75 8000
83408>>>>>>>>>>>>>>>>>>>
83408>>>>>>>>>>>>>>>>>>>    Object oSearchFm is a cFindComboForm
83410>>>>>>>>>>>>>>>>>>>        Set Size to 13 160
83411>>>>>>>>>>>>>>>>>>>        Set Location to 10 45
83412>>>>>>>>>>>>>>>>>>>        Set Label to "W&hat:"
83413>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83414>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83415>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
83416>>>>>>>>>>>>>>>>>>>    End_Object
83417>>>>>>>>>>>>>>>>>>>
83417>>>>>>>>>>>>>>>>>>>    Object oWordMatchCb is a cFindCheckBox
83419>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83420>>>>>>>>>>>>>>>>>>>        Set Location to 26 45
83421>>>>>>>>>>>>>>>>>>>        Set Label to "Match &whole word only"
83422>>>>>>>>>>>>>>>>>>>    End_Object
83423>>>>>>>>>>>>>>>>>>>
83423>>>>>>>>>>>>>>>>>>>    Object oMatchCaseCb is a cFindCheckBox
83425>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83426>>>>>>>>>>>>>>>>>>>        Set Location to 37 45
83427>>>>>>>>>>>>>>>>>>>        Set Label to "Match &case"
83428>>>>>>>>>>>>>>>>>>>    End_Object
83429>>>>>>>>>>>>>>>>>>>
83429>>>>>>>>>>>>>>>>>>>    Object oRegExCb is a cFindCheckBox
83431>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83432>>>>>>>>>>>>>>>>>>>        Set Location to 48 45
83433>>>>>>>>>>>>>>>>>>>        Set Label to "Regular &expression"
83434>>>>>>>>>>>>>>>>>>>    End_Object
83435>>>>>>>>>>>>>>>>>>>
83435>>>>>>>>>>>>>>>>>>>    Object oDocumentStartCb is a cFindCheckBox
83437>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83438>>>>>>>>>>>>>>>>>>>        Set Location to 59 45
83439>>>>>>>>>>>>>>>>>>>        Set Label to "Start at first &line"
83440>>>>>>>>>>>>>>>>>>>    End_Object
83441>>>>>>>>>>>>>>>>>>>
83441>>>>>>>>>>>>>>>>>>>    Object oDirectionGrp is a RadioGroup
83443>>>>>>>>>>>>>>>>>>>        Set Size to 45 65
83444>>>>>>>>>>>>>>>>>>>        Set Location to 24 140
83445>>>>>>>>>>>>>>>>>>>        Set Label to "Direction"
83446>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
83447>>>>>>>>>>>>>>>>>>>
83447>>>>>>>>>>>>>>>>>>>        Object oUpRadio is a Radio
83449>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
83450>>>>>>>>>>>>>>>>>>>            Set Location to 14 10
83451>>>>>>>>>>>>>>>>>>>            Set Label to "&Up"
83452>>>>>>>>>>>>>>>>>>>        End_Object
83453>>>>>>>>>>>>>>>>>>>
83453>>>>>>>>>>>>>>>>>>>        Object oDownRadio is a Radio
83455>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
83456>>>>>>>>>>>>>>>>>>>            Set Location to 26 10
83457>>>>>>>>>>>>>>>>>>>            Set Label to "&Down"
83458>>>>>>>>>>>>>>>>>>>        End_Object
83459>>>>>>>>>>>>>>>>>>>    End_Object
83460>>>>>>>>>>>>>>>>>>>
83460>>>>>>>>>>>>>>>>>>>    Object oFindBtn is a Button
83462>>>>>>>>>>>>>>>>>>>        Set Label to "&Find"
83463>>>>>>>>>>>>>>>>>>>        Set Location to 10 215
83464>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83465>>>>>>>>>>>>>>>>>>>        Set Default_State to True
83466>>>>>>>>>>>>>>>>>>>
83466>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83469>>>>>>>>>>>>>>>>>>>            String sValue
83469>>>>>>>>>>>>>>>>>>>            Get Value of oSearchFm to sValue          // if the user types or changes the search string we should
83470>>>>>>>>>>>>>>>>>>>            Send AddSearchString of oSearchFm sValue  // store it in the array for next time.
83471>>>>>>>>>>>>>>>>>>>            Set pbStartFind to True
83472>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83473>>>>>>>>>>>>>>>>>>>        End_Procedure
83474>>>>>>>>>>>>>>>>>>>    End_Object
83475>>>>>>>>>>>>>>>>>>>
83475>>>>>>>>>>>>>>>>>>>    Object oMarkAllBtn is a Button
83477>>>>>>>>>>>>>>>>>>>        Set Location to 26 215
83478>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83479>>>>>>>>>>>>>>>>>>>        Set Label to "&Mark All"
83480>>>>>>>>>>>>>>>>>>>
83480>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83483>>>>>>>>>>>>>>>>>>>            Set pbStartFind to True
83484>>>>>>>>>>>>>>>>>>>            Set pbMarkAll   to True
83485>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83486>>>>>>>>>>>>>>>>>>>        End_Procedure
83487>>>>>>>>>>>>>>>>>>>    End_Object
83488>>>>>>>>>>>>>>>>>>>
83488>>>>>>>>>>>>>>>>>>>    Object oCancelBtn is a Button
83490>>>>>>>>>>>>>>>>>>>        Set Label    to "Cancel"
83491>>>>>>>>>>>>>>>>>>>        Set Location to 42 215
83492>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83493>>>>>>>>>>>>>>>>>>>
83493>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83496>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83497>>>>>>>>>>>>>>>>>>>        End_Procedure
83498>>>>>>>>>>>>>>>>>>>
83498>>>>>>>>>>>>>>>>>>>    End_Object
83499>>>>>>>>>>>>>>>>>>>
83499>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_H Send Activate  of oSearchFm
83500>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_W Send doToggle  of oWordMatchCb
83501>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_C Send doToggle  of oMatchCaseCb
83502>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_E Send doToggle  of oRegExCb
83503>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_L Send doToggle  of oDocumentStartCb
83504>>>>>>>>>>>>>>>>>>>    //On_Key Key_Alt+Key_U Send Activate  of oUpRadio
83504>>>>>>>>>>>>>>>>>>>    //On_Key Key_Alt+Key_D Send Activate  of oDownRadio
83504>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_F Send KeyAction of oFindBtn
83505>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_M Send KeyAction of oMarkAllBtn
83506>>>>>>>>>>>>>>>>>>>    On_Key kCancel       Send KeyAction of oCancelBtn
83507>>>>>>>>>>>>>>>>>>>
83507>>>>>>>>>>>>>>>>>>>    Procedure SettingsToOptions tFindReplaceOptions ByRef Options
83510>>>>>>>>>>>>>>>>>>>        Get Value         of oSearchFm        to Options.sSearchText
83511>>>>>>>>>>>>>>>>>>>        Move ""                               to Options.sReplaceText
83512>>>>>>>>>>>>>>>>>>>        Get Checked_State of oWordMatchCb     to Options.bWordMatch
83513>>>>>>>>>>>>>>>>>>>        Get Checked_State of oMatchCaseCb     to Options.bMatchCase
83514>>>>>>>>>>>>>>>>>>>        Get Checked_State of oRegExCb         to Options.bRegExp
83515>>>>>>>>>>>>>>>>>>>        Get Checked_State of oDocumentStartCb to Options.bDocumentStart
83516>>>>>>>>>>>>>>>>>>>        Get Current_Radio of oDirectionGrp    to Options.eFindOptions
83517>>>>>>>>>>>>>>>>>>>        Get pbMarkAll                         to Options.bMarkAll
83518>>>>>>>>>>>>>>>>>>>    End_Procedure
83519>>>>>>>>>>>>>>>>>>>
83519>>>>>>>>>>>>>>>>>>>    Procedure RequestDetails tFindReplaceOptions ByRef Options
83522>>>>>>>>>>>>>>>>>>>        Boolean bStartFind
83522>>>>>>>>>>>>>>>>>>>
83522>>>>>>>>>>>>>>>>>>>        Set pbStartFind to False
83523>>>>>>>>>>>>>>>>>>>        Set pbMarkAll   to False
83524>>>>>>>>>>>>>>>>>>>        Set SearchValue   of oSearchFm        to Options.sSearchText
83525>>>>>>>>>>>>>>>>>>>        Set Checked_State of oWordMatchCb     to Options.bWordMatch
83526>>>>>>>>>>>>>>>>>>>        Set Checked_State of oMatchCaseCb     to Options.bMatchCase
83527>>>>>>>>>>>>>>>>>>>        Set Checked_State of oRegExCb         to Options.bRegExp
83528>>>>>>>>>>>>>>>>>>>        Set Checked_State of oDocumentStartCb to Options.bDocumentStart
83529>>>>>>>>>>>>>>>>>>>        Set Current_Radio of oDirectionGrp    to Options.eFindOptions
83530>>>>>>>>>>>>>>>>>>>        Send Popup
83531>>>>>>>>>>>>>>>>>>>        Send SettingsToOptions (&Options)
83532>>>>>>>>>>>>>>>>>>>        Get pbStartFind to bStartFind
83533>>>>>>>>>>>>>>>>>>>        If (bStartFind) Begin
83535>>>>>>>>>>>>>>>>>>>            Move True to Options.bStartFind
83536>>>>>>>>>>>>>>>>>>>        End
83536>>>>>>>>>>>>>>>>>>>>
83536>>>>>>>>>>>>>>>>>>>    End_Procedure
83537>>>>>>>>>>>>>>>>>>>
83537>>>>>>>>>>>>>>>>>>>
83537>>>>>>>>>>>>>>>>>>>    Procedure Activating
83540>>>>>>>>>>>>>>>>>>>        Forward Send Activating
83542>>>>>>>>>>>>>>>>>>>    End_Procedure
83543>>>>>>>>>>>>>>>>>>>
83543>>>>>>>>>>>>>>>>>>>End_Object
83544>>>>>>>>>>>>>>>>>>>
83544>>>>>>>>>>>>>>>>>Use Tools\Replace.dg
Including file: Tools\Replace.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\Tools\Replace.dg)
83544>>>>>>>>>>>>>>>>>>>Use Windows.pkg
83544>>>>>>>>>>>>>>>>>>>Use MessageQueueHelpers.pkg
83544>>>>>>>>>>>>>>>>>>>Use THDialog.pkg
83544>>>>>>>>>>>>>>>>>>>
83544>>>>>>>>>>>>>>>>>>>Object oReplaceDialog is a ModalPanel
83546>>>>>>>>>>>>>>>>>>>    Set Label to "Find & Replace"
83547>>>>>>>>>>>>>>>>>>>    Set Size to 98 300
83548>>>>>>>>>>>>>>>>>>>    Set piMinSize to 95 300
83549>>>>>>>>>>>>>>>>>>>    Set Location to 44 47
83550>>>>>>>>>>>>>>>>>>>    Set Border_Style to Border_Thick
83551>>>>>>>>>>>>>>>>>>>    //Set Locate_Mode to POPUP_LOCATE -- locate mode isn't smart enough
83551>>>>>>>>>>>>>>>>>>>    Property Boolean pbReplaceAll
83553>>>>>>>>>>>>>>>>>>>    Property Boolean pbFindFirst
83555>>>>>>>>>>>>>>>>>>>    Property Handle  phoInvokingObject
83557>>>>>>>>>>>>>>>>>>>
83557>>>>>>>>>>>>>>>>>>>    Set peAnchors to anAll
83558>>>>>>>>>>>>>>>>>>>    Set piMaxSize to 100 8000
83559>>>>>>>>>>>>>>>>>>>
83559>>>>>>>>>>>>>>>>>>>    Object oFindFm is a cFindComboForm
83561>>>>>>>>>>>>>>>>>>>        Set Size to 13 185
83562>>>>>>>>>>>>>>>>>>>        Set Location to 10 55
83563>>>>>>>>>>>>>>>>>>>        Set Label to "&Find:"
83564>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83565>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83566>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
83567>>>>>>>>>>>>>>>>>>>    End_Object
83568>>>>>>>>>>>>>>>>>>>
83568>>>>>>>>>>>>>>>>>>>    Object oReplaceFm is a cFindComboForm
83570>>>>>>>>>>>>>>>>>>>        Set Size to 13 185
83571>>>>>>>>>>>>>>>>>>>        Set Location to 26 55
83572>>>>>>>>>>>>>>>>>>>        Set Label to "Re&place with:"
83573>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83574>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83575>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
83576>>>>>>>>>>>>>>>>>>>    End_Object
83577>>>>>>>>>>>>>>>>>>>
83577>>>>>>>>>>>>>>>>>>>    Object oWordMatchCb is a cFindCheckBox
83579>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83580>>>>>>>>>>>>>>>>>>>        Set Location to 46 55
83581>>>>>>>>>>>>>>>>>>>        Set Label to "Match &whole word only"
83582>>>>>>>>>>>>>>>>>>>    End_Object
83583>>>>>>>>>>>>>>>>>>>
83583>>>>>>>>>>>>>>>>>>>    Object oMatchCaseCb is a cFindCheckBox
83585>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83586>>>>>>>>>>>>>>>>>>>        Set Location to 57 55
83587>>>>>>>>>>>>>>>>>>>        Set Label to "Match &case"
83588>>>>>>>>>>>>>>>>>>>    End_Object
83589>>>>>>>>>>>>>>>>>>>
83589>>>>>>>>>>>>>>>>>>>    Object oRegExCb is a cFindCheckBox
83591>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83592>>>>>>>>>>>>>>>>>>>        Set Location to 68 55
83593>>>>>>>>>>>>>>>>>>>        Set Label to "Regular &expression"
83594>>>>>>>>>>>>>>>>>>>    End_Object
83595>>>>>>>>>>>>>>>>>>>
83595>>>>>>>>>>>>>>>>>>>    Object oCaseCb is a cFindCheckBox
83597>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83598>>>>>>>>>>>>>>>>>>>        Set Location to 79 55
83599>>>>>>>>>>>>>>>>>>>        Set Label to "Preser&ve case"
83600>>>>>>>>>>>>>>>>>>>    End_Object
83601>>>>>>>>>>>>>>>>>>>
83601>>>>>>>>>>>>>>>>>>>    Object oDocumentStartCb is a cFindCheckBox
83603>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
83604>>>>>>>>>>>>>>>>>>>        Set Location to 80 55
83605>>>>>>>>>>>>>>>>>>>        Set Label to "Start at first &line"
83606>>>>>>>>>>>>>>>>>>>    End_Object
83607>>>>>>>>>>>>>>>>>>>
83607>>>>>>>>>>>>>>>>>>>    Object oReplaceGrp is a RadioGroup
83609>>>>>>>>>>>>>>>>>>>        Set Size to 42 85
83610>>>>>>>>>>>>>>>>>>>        Set Location to 46 155
83611>>>>>>>>>>>>>>>>>>>        Set Label to "Replace in"
83612>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
83613>>>>>>>>>>>>>>>>>>>
83613>>>>>>>>>>>>>>>>>>>        Object oRplSelection is a Radio
83615>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
83616>>>>>>>>>>>>>>>>>>>            Set Location to 14 10
83617>>>>>>>>>>>>>>>>>>>            Set Label to "&Selection"
83618>>>>>>>>>>>>>>>>>>>        End_Object
83619>>>>>>>>>>>>>>>>>>>
83619>>>>>>>>>>>>>>>>>>>        Object oRplBuffer is a Radio
83621>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
83622>>>>>>>>>>>>>>>>>>>            Set Location to 26 10
83623>>>>>>>>>>>>>>>>>>>            Set Label to "Entire &Buffer"
83624>>>>>>>>>>>>>>>>>>>        End_Object
83625>>>>>>>>>>>>>>>>>>>    End_Object
83626>>>>>>>>>>>>>>>>>>>
83626>>>>>>>>>>>>>>>>>>>    Object oFindBtn is a Button
83628>>>>>>>>>>>>>>>>>>>        Set Label to "Find &Next"
83629>>>>>>>>>>>>>>>>>>>        Set Location to 10 245
83630>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83631>>>>>>>>>>>>>>>>>>>        Set Default_State to True
83632>>>>>>>>>>>>>>>>>>>
83632>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83635>>>>>>>>>>>>>>>>>>>            Handle  hoInvokingObject
83635>>>>>>>>>>>>>>>>>>>            Integer iFlags
83635>>>>>>>>>>>>>>>>>>>            String  sSearchText
83635>>>>>>>>>>>>>>>>>>>            tFindReplaceOptions ReplaceOptions
83635>>>>>>>>>>>>>>>>>>>            tFindReplaceOptions ReplaceOptions
83635>>>>>>>>>>>>>>>>>>>
83635>>>>>>>>>>>>>>>>>>>            Get phoInvokingObject to hoInvokingObject
83636>>>>>>>>>>>>>>>>>>>            If hoInvokingObject Begin
83638>>>>>>>>>>>>>>>>>>>                Send SettingsToOptions (&ReplaceOptions)
83639>>>>>>>>>>>>>>>>>>>                Get SetSearchOptions of hoInvokingObject ReplaceOptions to iFlags
83640>>>>>>>>>>>>>>>>>>>                Get Value of oFindFm to sSearchText
83641>>>>>>>>>>>>>>>>>>>                Send AddSearchString of oFindFm sSearchText  // make sure the search value is saved in the array
83642>>>>>>>>>>>>>>>>>>>                Set psSearchText of hoInvokingObject to sSearchText
83643>>>>>>>>>>>>>>>>>>>                If (ReplaceOptions.bDocumentStart=True and pbFindFirst(Self)=false) Begin
83645>>>>>>>>>>>>>>>>>>>                    Set pbFindFirst to True
83646>>>>>>>>>>>>>>>>>>>                    Send FindFirst to hoInvokingObject
83647>>>>>>>>>>>>>>>>>>>                End
83647>>>>>>>>>>>>>>>>>>>>
83647>>>>>>>>>>>>>>>>>>>                Else Begin
83648>>>>>>>>>>>>>>>>>>>                    Send FindNext to hoInvokingObject
83649>>>>>>>>>>>>>>>>>>>                End
83649>>>>>>>>>>>>>>>>>>>>
83649>>>>>>>>>>>>>>>>>>>            End
83649>>>>>>>>>>>>>>>>>>>>
83649>>>>>>>>>>>>>>>>>>>        End_Procedure
83650>>>>>>>>>>>>>>>>>>>    End_Object
83651>>>>>>>>>>>>>>>>>>>
83651>>>>>>>>>>>>>>>>>>>    Object oReplaceBtn is a Button
83653>>>>>>>>>>>>>>>>>>>        Set Location to 26 245
83654>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83655>>>>>>>>>>>>>>>>>>>        Set Label to "&Replace"
83656>>>>>>>>>>>>>>>>>>>
83656>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83659>>>>>>>>>>>>>>>>>>>            Handle hoInvokingObject
83659>>>>>>>>>>>>>>>>>>>            String sSearchText
83659>>>>>>>>>>>>>>>>>>>            String sReplaceWith
83659>>>>>>>>>>>>>>>>>>>            Get phoInvokingObject to hoInvokingObject
83660>>>>>>>>>>>>>>>>>>>            If hoInvokingObject Begin
83662>>>>>>>>>>>>>>>>>>>                Get Value of oFindFm to sSearchText
83663>>>>>>>>>>>>>>>>>>>                Get Value of oReplaceFm to sReplaceWith
83664>>>>>>>>>>>>>>>>>>>                Send AddSearchString of oReplaceFm sReplaceWith // save the replace string in the array for later use if wanted
83665>>>>>>>>>>>>>>>>>>>                Set psSearchText of hoInvokingObject to sSearchText
83666>>>>>>>>>>>>>>>>>>>                Send ReplaceText of hoInvokingObject sReplaceWith
83667>>>>>>>>>>>>>>>>>>>                Send FindNext to hoInvokingObject
83668>>>>>>>>>>>>>>>>>>>            End
83668>>>>>>>>>>>>>>>>>>>>
83668>>>>>>>>>>>>>>>>>>>        End_Procedure
83669>>>>>>>>>>>>>>>>>>>    End_Object
83670>>>>>>>>>>>>>>>>>>>
83670>>>>>>>>>>>>>>>>>>>    Object oReplaceAllBtn is a Button
83672>>>>>>>>>>>>>>>>>>>        Set Location to 42 245
83673>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83674>>>>>>>>>>>>>>>>>>>        Set Label to "Replace &All"
83675>>>>>>>>>>>>>>>>>>>
83675>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83678>>>>>>>>>>>>>>>>>>>            Set pbReplaceAll to True
83679>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83680>>>>>>>>>>>>>>>>>>>        End_Procedure
83681>>>>>>>>>>>>>>>>>>>    End_Object
83682>>>>>>>>>>>>>>>>>>>
83682>>>>>>>>>>>>>>>>>>>    Object oCancelBtn is a Button
83684>>>>>>>>>>>>>>>>>>>        Set Label to "&Cancel"
83685>>>>>>>>>>>>>>>>>>>        Set Location to 58 245
83686>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
83687>>>>>>>>>>>>>>>>>>>
83687>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83690>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83691>>>>>>>>>>>>>>>>>>>        End_Procedure
83692>>>>>>>>>>>>>>>>>>>
83692>>>>>>>>>>>>>>>>>>>    End_Object
83693>>>>>>>>>>>>>>>>>>>
83693>>>>>>>>>>>>>>>>>>>    Procedure doFind
83696>>>>>>>>>>>>>>>>>>>        Send DispatchHotkey
83697>>>>>>>>>>>>>>>>>>>        Send KeyAction of oFindBtn
83698>>>>>>>>>>>>>>>>>>>    End_Procedure
83699>>>>>>>>>>>>>>>>>>>
83699>>>>>>>>>>>>>>>>>>>    Procedure doReplace
83702>>>>>>>>>>>>>>>>>>>        Send DispatchHotkey
83703>>>>>>>>>>>>>>>>>>>        Send KeyAction of oReplaceBtn
83704>>>>>>>>>>>>>>>>>>>    End_Procedure
83705>>>>>>>>>>>>>>>>>>>
83705>>>>>>>>>>>>>>>>>>>    Procedure doReplaceAll
83708>>>>>>>>>>>>>>>>>>>        Send DispatchHotkey
83709>>>>>>>>>>>>>>>>>>>        Send KeyAction of oReplaceAllBtn
83710>>>>>>>>>>>>>>>>>>>    End_Procedure
83711>>>>>>>>>>>>>>>>>>>
83711>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_F Send Activate  of oFindFm
83712>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_P Send Activate  of oReplaceFm
83713>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_W Send doToggle  of oWordMatchCb
83714>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_C Send doToggle  of oMatchCaseCb
83715>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_E Send doToggle  of oRegExCb
83716>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_L Send doToggle  of oDocumentStartCb
83717>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_N Send doFind
83718>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_R Send doReplace
83719>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_A Send doReplaceAll
83720>>>>>>>>>>>>>>>>>>>    On_Key kCancel       Send KeyAction of oCancelBtn
83721>>>>>>>>>>>>>>>>>>>
83721>>>>>>>>>>>>>>>>>>>    Procedure SettingsToOptions tFindReplaceOptions ByRef Options
83724>>>>>>>>>>>>>>>>>>>        Get Value           of oFindFm          to Options.sSearchText
83725>>>>>>>>>>>>>>>>>>>        Get Value           of oReplaceFm       to Options.sReplaceText
83726>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oWordMatchCb     to Options.bWordMatch
83727>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oMatchCaseCb     to Options.bMatchCase
83728>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oRegExCb         to Options.bRegExp
83729>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oDocumentStartCb to Options.bDocumentStart
83730>>>>>>>>>>>>>>>>>>>        Get Current_Radio   of oReplaceGrp      to Options.eFindOptions
83731>>>>>>>>>>>>>>>>>>>        Move False                              to Options.bMarkAll
83732>>>>>>>>>>>>>>>>>>>    End_Procedure
83733>>>>>>>>>>>>>>>>>>>
83733>>>>>>>>>>>>>>>>>>>    Procedure RequestDetails tFindReplaceOptions ByRef Options Handle hoInvokingObject
83736>>>>>>>>>>>>>>>>>>>        Boolean bReplaceAll
83736>>>>>>>>>>>>>>>>>>>        If (hoInvokingObject=0) Begin
83738>>>>>>>>>>>>>>>>>>>            Procedure_Return
83739>>>>>>>>>>>>>>>>>>>        End
83739>>>>>>>>>>>>>>>>>>>>
83739>>>>>>>>>>>>>>>>>>>        Set phoInvokingObject                   to hoInvokingObject
83740>>>>>>>>>>>>>>>>>>>        //
83740>>>>>>>>>>>>>>>>>>>        Set pbReplaceAll                        to False
83741>>>>>>>>>>>>>>>>>>>        Set pbFindFirst                         to False
83742>>>>>>>>>>>>>>>>>>>        Move False                              to Options.bReplaceAll
83743>>>>>>>>>>>>>>>>>>>        Set SearchValue     of oFindFm          to Options.sSearchText
83744>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oWordMatchCb     to Options.bWordMatch
83745>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oMatchCaseCb     to Options.bMatchCase
83746>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oRegExCb         to Options.bRegExp
83747>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oDocumentStartCb to Options.bDocumentStart
83748>>>>>>>>>>>>>>>>>>>        Send Popup
83749>>>>>>>>>>>>>>>>>>>        Send SettingsToOptions (&Options)
83750>>>>>>>>>>>>>>>>>>>        Get pbReplaceAll to bReplaceAll
83751>>>>>>>>>>>>>>>>>>>        If (bReplaceAll) Begin
83753>>>>>>>>>>>>>>>>>>>            Move True                             to Options.bReplaceAll
83754>>>>>>>>>>>>>>>>>>>        End
83754>>>>>>>>>>>>>>>>>>>>
83754>>>>>>>>>>>>>>>>>>>    End_Procedure
83755>>>>>>>>>>>>>>>>>>>
83755>>>>>>>>>>>>>>>>>>>
83755>>>>>>>>>>>>>>>>>>>    Procedure Activating
83758>>>>>>>>>>>>>>>>>>>        Forward Send Activating
83760>>>>>>>>>>>>>>>>>>>    End_Procedure
83761>>>>>>>>>>>>>>>>>>>
83761>>>>>>>>>>>>>>>>>>>End_Object
83762>>>>>>>>>>>>>>>>>>>
83762>>>>>>>>>>>>>>>>>Use Tools\Goto.dg
Including file: Tools\Goto.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\Tools\Goto.dg)
83762>>>>>>>>>>>>>>>>>>>Use Windows.pkg
83762>>>>>>>>>>>>>>>>>>>Use MessageQueueHelpers.pkg
83762>>>>>>>>>>>>>>>>>>>Use THDialog.pkg
83762>>>>>>>>>>>>>>>>>>>
83762>>>>>>>>>>>>>>>>>>>Object oGotoDialog is a ModalPanel
83764>>>>>>>>>>>>>>>>>>>    Set Size to 50 138
83765>>>>>>>>>>>>>>>>>>>    Set Label to "Go To Line"
83766>>>>>>>>>>>>>>>>>>>    Set piMinSize to 50 138
83767>>>>>>>>>>>>>>>>>>>    Set Location to 44 47
83768>>>>>>>>>>>>>>>>>>>    //Set Locate_Mode to POPUP_LOCATE -- locate mode isn't smart enough
83768>>>>>>>>>>>>>>>>>>>    Property Boolean pbCancel
83770>>>>>>>>>>>>>>>>>>>
83770>>>>>>>>>>>>>>>>>>>    Set peAnchors to anAll
83771>>>>>>>>>>>>>>>>>>>    Set piMaxSize to 50 138
83772>>>>>>>>>>>>>>>>>>>    Set Border_Style to Border_Thick
83773>>>>>>>>>>>>>>>>>>>
83773>>>>>>>>>>>>>>>>>>>    Object oLineFm is a cFindForm
83775>>>>>>>>>>>>>>>>>>>        Set Size to 13 30
83776>>>>>>>>>>>>>>>>>>>        Set Location to 10 43
83777>>>>>>>>>>>>>>>>>>>        Set Label to "&Line:"
83778>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
83779>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
83780>>>>>>>>>>>>>>>>>>>        Set Form_Justification_Mode to Form_EditRight
83781>>>>>>>>>>>>>>>>>>>    End_Object
83782>>>>>>>>>>>>>>>>>>>
83782>>>>>>>>>>>>>>>>>>>    Object oOKBtn is a Button
83784>>>>>>>>>>>>>>>>>>>        Set Label to "&OK"
83785>>>>>>>>>>>>>>>>>>>        Set Location to 10 80
83786>>>>>>>>>>>>>>>>>>>        Set Default_State to True
83787>>>>>>>>>>>>>>>>>>>
83787>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83790>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83791>>>>>>>>>>>>>>>>>>>        End_Procedure
83792>>>>>>>>>>>>>>>>>>>    End_Object
83793>>>>>>>>>>>>>>>>>>>
83793>>>>>>>>>>>>>>>>>>>    Object oCancelBtn is a Button
83795>>>>>>>>>>>>>>>>>>>        Set Label    to "Cancel"
83796>>>>>>>>>>>>>>>>>>>        Set Location to 26 80
83797>>>>>>>>>>>>>>>>>>>
83797>>>>>>>>>>>>>>>>>>>        Procedure OnClick
83800>>>>>>>>>>>>>>>>>>>            Set pbCancel to True
83801>>>>>>>>>>>>>>>>>>>            Send Close_Panel
83802>>>>>>>>>>>>>>>>>>>        End_Procedure
83803>>>>>>>>>>>>>>>>>>>
83803>>>>>>>>>>>>>>>>>>>    End_Object
83804>>>>>>>>>>>>>>>>>>>
83804>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_L Send Activate  of oLineFm
83805>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOKBtn
83806>>>>>>>>>>>>>>>>>>>    On_Key kCancel       Send KeyAction of oCancelBtn
83807>>>>>>>>>>>>>>>>>>>
83807>>>>>>>>>>>>>>>>>>>    Procedure RequestDetails Integer ByRef iLine
83810>>>>>>>>>>>>>>>>>>>        Boolean bCancel
83810>>>>>>>>>>>>>>>>>>>        Set pbCancel    to False
83811>>>>>>>>>>>>>>>>>>>        Set Value       of oLineFm  to ""
83812>>>>>>>>>>>>>>>>>>>        Send Popup
83813>>>>>>>>>>>>>>>>>>>        Get pbCancel to bCancel
83814>>>>>>>>>>>>>>>>>>>        If (not(bCancel)) Begin
83816>>>>>>>>>>>>>>>>>>>            Get Value   of oLineFm  to iLine
83817>>>>>>>>>>>>>>>>>>>            Decrement iLine
83818>>>>>>>>>>>>>>>>>>>            If (iLine<0) Begin
83820>>>>>>>>>>>>>>>>>>>                Move 0 to iLine
83821>>>>>>>>>>>>>>>>>>>            End
83821>>>>>>>>>>>>>>>>>>>>
83821>>>>>>>>>>>>>>>>>>>        End
83821>>>>>>>>>>>>>>>>>>>>
83821>>>>>>>>>>>>>>>>>>>        Else Begin
83822>>>>>>>>>>>>>>>>>>>            Move -1 to iLine
83823>>>>>>>>>>>>>>>>>>>        End
83823>>>>>>>>>>>>>>>>>>>>
83823>>>>>>>>>>>>>>>>>>>    End_Procedure
83824>>>>>>>>>>>>>>>>>>>
83824>>>>>>>>>>>>>>>>>>>
83824>>>>>>>>>>>>>>>>>>>    Procedure Activating
83827>>>>>>>>>>>>>>>>>>>        Forward Send Activating
83829>>>>>>>>>>>>>>>>>>>    End_Procedure
83830>>>>>>>>>>>>>>>>>>>
83830>>>>>>>>>>>>>>>>>>>End_Object
83831>>>>>>>>>>>>>>>>>>>
83831>>>>>>>>>>>>>>>>>
83831>>>>>>>>>>>>>>>>>Define SCIMAGE_DLL For SCIMAGE32.DLL
83831>>>>>>>>>>>>>>>>>
83831>>>>>>>>>>>>>>>>>//
83831>>>>>>>>>>>>>>>>>//function specific for scintilla, create xpm icons
83831>>>>>>>>>>>>>>>>>//
83831>>>>>>>>>>>>>>>>>External_Function SciEditorIconXpm      "SciEditorIconXpm"      SCIMAGE_DLL Integer iIcon Returns Pointer
83832>>>>>>>>>>>>>>>>>External_Function SciLoadImageAsRGBA    "SciLoadImageAsRGBA"    SCIMAGE_DLL Pointer pFileName Pointer pImage Pointer pWidth Pointer pHeight Returns integer
83833>>>>>>>>>>>>>>>>>External_Function SciFreeRGBAImage      "SciFreeRGBAImage"      SCIMAGE_DLL Pointer pImage Returns integer
83834>>>>>>>>>>>>>>>>>
83834>>>>>>>>>>>>>>>>>
83834>>>>>>>>>>>>>>>>>
83834>>>>>>>>>>>>>>>>>Class cSciLexer is a DFControl // cUIObject  cObject
83835>>>>>>>>>>>>>>>>>
83835>>>>>>>>>>>>>>>>>  Import_Class_Protocol cSciLexerLanguageMixin
83836>>>>>>>>>>>>>>>>>
83836>>>>>>>>>>>>>>>>>  Register_Procedure OnWmSetFocus
83836>>>>>>>>>>>>>>>>>  Register_Procedure OnWmKillFocus
83836>>>>>>>>>>>>>>>>>  Register_Procedure OnWmPaint
83836>>>>>>>>>>>>>>>>>  Register_Procedure DoKeyReturn
83836>>>>>>>>>>>>>>>>>  Register_Procedure DoFileDropping
83836>>>>>>>>>>>>>>>>>  Register_Procedure onWmContextMenu
83836>>>>>>>>>>>>>>>>>
83836>>>>>>>>>>>>>>>>>
83836>>>>>>>>>>>>>>>>>
83836>>>>>>>>>>>>>>>>>  Procedure Construct_Object
83838>>>>>>>>>>>>>>>>>    // the scintilla DLL to load is in the programs folder, preload it
83838>>>>>>>>>>>>>>>>>    Set psDllLoadPath of oDllHandler to (psProgramPath(phoWorkspace(ghoApplication)))
83839>>>>>>>>>>>>>>>>>    Send doLoadLibrary Of oDllHandler "SciLexer32.dll"
83840>>>>>>>>>>>>>>>>>
83840>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
83842>>>>>>>>>>>>>>>>>    Set External_Class_Name "cScintillaEditor"  to CODEMAXWNDCLASS
83843>>>>>>>>>>>>>>>>>    Set External_Message WM_SETFOCUS            to msg_OnWmSetFocus
83844>>>>>>>>>>>>>>>>>    Set External_Message WM_KILLFOCUS           to msg_OnWmKillFocus
83845>>>>>>>>>>>>>>>>>    Set External_Message WM_PAINT               to msg_OnWmPaint
83846>>>>>>>>>>>>>>>>>    Set External_Message WM_DROPFILES           to msg_DoFileDropping
83847>>>>>>>>>>>>>>>>>    Set External_Message WM_RBUTTONUP           to msg_onWmContextMenu
83848>>>>>>>>>>>>>>>>>    //Set External_Message WM_KEYDOWN             to msg_onWmKeyDown  <<-- does not work
83848>>>>>>>>>>>>>>>>>
83848>>>>>>>>>>>>>>>>>
83848>>>>>>>>>>>>>>>>>
83848>>>>>>>>>>>>>>>>>    //
83848>>>>>>>>>>>>>>>>>    // Put any NEW properties HERE
83848>>>>>>>>>>>>>>>>>    Property String  psFileName              ""
83849>>>>>>>>>>>>>>>>>    Property Number  pnFileTimeStamp         0
83850>>>>>>>>>>>>>>>>>
83850>>>>>>>>>>>>>>>>>
83850>>>>>>>>>>>>>>>>>    // These Properties are filled by CM_GetSel
83850>>>>>>>>>>>>>>>>>    Property Integer piSelStartLine          0
83851>>>>>>>>>>>>>>>>>    Property Integer piSelStartCol           0
83852>>>>>>>>>>>>>>>>>    Property Integer piSelEndLine            0
83853>>>>>>>>>>>>>>>>>    Property Integer piSelEndCol             0
83854>>>>>>>>>>>>>>>>>
83854>>>>>>>>>>>>>>>>>    // Used to insert a self defined popup menu.
83854>>>>>>>>>>>>>>>>>    Property Integer Floating_Menu_Object    0
83855>>>>>>>>>>>>>>>>>
83855>>>>>>>>>>>>>>>>>    // These colors are stored in separate properties for easy access.
83855>>>>>>>>>>>>>>>>>    Property Integer piWindowColor                           0  // Set during CM_GetColor / CM_SetColor
83856>>>>>>>>>>>>>>>>>    Property Integer piTextColor                                     0  // ...
83857>>>>>>>>>>>>>>>>>
83857>>>>>>>>>>>>>>>>>    Property Integer peAutoIndentMode        CM_INDENT_PREVLINE
83858>>>>>>>>>>>>>>>>>    Property Boolean pbShowMatchingBraces    True
83859>>>>>>>>>>>>>>>>>    Property Boolean pbBraceHighLightState   False   // keeps track of brace highlight state so we can turn it off just one time instead of on each navigational action
83860>>>>>>>>>>>>>>>>>    Property String  psEOLChar               CS_CRLF // default End Of Line character to use
83861>>>>>>>>>>>>>>>>>    Property Handle  phMarkerLineHighLight   0       // scintilla marker handle that keeps track of the highlighted line
83862>>>>>>>>>>>>>>>>>    Property String  piMarginLineNumberDigits 3      // character width of the line number margin (counts the digits)
83863>>>>>>>>>>>>>>>>>    Property String[] psClearKeyBindings             // array that holds keyboard shortcut's that have to be cleared
83864>>>>>>>>>>>>>>>>>    Property String  psSearchText            ""      // text to use in a search
83865>>>>>>>>>>>>>>>>>    Property Boolean pbFindDocumentStart     False   // start search from begin of document, this property remembers the state of the checkbox
83866>>>>>>>>>>>>>>>>>    Property String  psLineOnEnter           ""      // content of the line when the cursor enters it (for line_changed_tracking)
83867>>>>>>>>>>>>>>>>>    //
83867>>>>>>>>>>>>>>>>>    //
83867>>>>>>>>>>>>>>>>>    // These properties used with CodeTip (SVN)
83867>>>>>>>>>>>>>>>>>    Property Integer phoCodeTipHandler           0
83868>>>>>>>>>>>>>>>>>    Property Integer pbCodetipRequest           False
83869>>>>>>>>>>>>>>>>>    Property Boolean pbQuickInfo                True // QuickInfo, tooltips that have info about your source structure
83870>>>>>>>>>>>>>>>>>    Property Integer piQuickInfoTime            1000 // default dwell time of the mouse before quickinfo triggers
83871>>>>>>>>>>>>>>>>>    Property Integer piCodeTipStyle              0   // not used for scintilla
83872>>>>>>>>>>>>>>>>>    Property Integer piCodeTipHighlightedStart  -1   // not used in scintilla, we set it directly
83873>>>>>>>>>>>>>>>>>    Property Integer piCodeTipHighlightedEnd    -1   // not used in scintilla, we set it directly
83874>>>>>>>>>>>>>>>>>    Property Integer piCodeTipArgument          -1   // denotes the current argument number that we are editing
83875>>>>>>>>>>>>>>>>>    Property Integer piCodeTipCurrLine          -1
83876>>>>>>>>>>>>>>>>>    Property String  psCodeTipCurrent           ""   // contains the actual tip string to display
83877>>>>>>>>>>>>>>>>>    Property Integer piCodeTipType              C_TIPTYPE_UNDEFINED
83878>>>>>>>>>>>>>>>>>    Property Boolean pbHadTipBeforeAutocomplete False// if codetip before autocomplete then please restore tip after the autocomplete is from the screen
83879>>>>>>>>>>>>>>>>>
83879>>>>>>>>>>>>>>>>>    Property Boolean pbIsCodelistActive         False
83880>>>>>>>>>>>>>>>>>
83880>>>>>>>>>>>>>>>>>    Property Boolean pbFileLoading              False // Set to true while loading file (for ex. in CM_Openfile)
83881>>>>>>>>>>>>>>>>>    Property Boolean pbBlockSelectActive        False // Set to true when in block select mode
83882>>>>>>>>>>>>>>>>>    Property Integer piBlockSelectAnchorPos     0
83883>>>>>>>>>>>>>>>>>    Property Integer piBlockSelectCaretPos      0
83884>>>>>>>>>>>>>>>>>    Property Boolean pbBlockSelectBackspace     False // Bug fix, backspace in a block select drops the block select state even while still visible
83885>>>>>>>>>>>>>>>>>    Property Boolean pbNormalizeCase            True  // Adjust scope/key word text case on enter
83886>>>>>>>>>>>>>>>>>    Property Integer piLinesToScrollAfterGoto   5     // Number of lines to scroll after you locate a line with a goto line
83887>>>>>>>>>>>>>>>>>    Property Integer piUndoRedoStartLine        0     // If an undo/redo actions starts, after the operation is done, we might be at a different line
83888>>>>>>>>>>>>>>>>>
83888>>>>>>>>>>>>>>>>>
83888>>>>>>>>>>>>>>>>>    // ****************************************************************************
83888>>>>>>>>>>>>>>>>>    // properties below are from old codemax, the might be removed if not needed or
83888>>>>>>>>>>>>>>>>>    // moved up if they can stay.
83888>>>>>>>>>>>>>>>>>    //
83888>>>>>>>>>>>>>>>>>    Property Integer phoIniHandler         Self
83889>>>>>>>>>>>>>>>>>
83889>>>>>>>>>>>>>>>>>    Property Integer piDragAcceptFilesState        True
83890>>>>>>>>>>>>>>>>>
83890>>>>>>>>>>>>>>>>>    // These Properties are filled by CM_PosFromChar.
83890>>>>>>>>>>>>>>>>>    Property Integer piPosStartX           0
83891>>>>>>>>>>>>>>>>>    Property Integer piPosStartY           0
83892>>>>>>>>>>>>>>>>>    Property Integer piPosEndX             0
83893>>>>>>>>>>>>>>>>>    Property Integer piPosEndY             0
83894>>>>>>>>>>>>>>>>>    // Thes Properties are filled by FillCurrentPosition
83894>>>>>>>>>>>>>>>>>    Property Integer piAbsPosXStart        0
83895>>>>>>>>>>>>>>>>>    Property Integer piAbsPosYStart        0
83896>>>>>>>>>>>>>>>>>    Property Integer piAbsPosXEnd          0
83897>>>>>>>>>>>>>>>>>    Property Integer piAbsPosYEnd          0
83898>>>>>>>>>>>>>>>>>    // Is used to do some actions when the find is done.
83898>>>>>>>>>>>>>>>>>    Property Integer piFindWrapMode        FindWrapMode_NoWrapMsg
83899>>>>>>>>>>>>>>>>>    // Is ised to Block keys.
83899>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysNo                   (Repeat("0",255))
83900>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysAlt                  (Repeat("0",255))
83901>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysShift                (Repeat("0",255))
83902>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysCtrl                 (Repeat("0",255))
83903>>>>>>>>>>>>>>>>>    // Is used to Block keys but only once.
83903>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysNoOnce               (Repeat("0",255))
83904>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysAltOnce              (Repeat("0",255))
83905>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysShiftOnce            (Repeat("0",255))
83906>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysCtrlOnce             (Repeat("0",255))
83907>>>>>>>>>>>>>>>>>    // Used with CMM_GetAllBookMarks.
83907>>>>>>>>>>>>>>>>>    Property Integer piBookMarkCnt         0
83908>>>>>>>>>>>>>>>>>    // To use with Absolute_GUIOrigin -> Overwrite it to force SelectionLists
83908>>>>>>>>>>>>>>>>>    // to popup relative to the cursor position.
83908>>>>>>>>>>>>>>>>>    Property Integer piDontOverwriteGUIOrigin          False
83909>>>>>>>>>>>>>>>>>    Property Integer piGUIOriginOffsetY                0
83910>>>>>>>>>>>>>>>>>    Property Integer piGUIOriginOffsetX                0
83911>>>>>>>>>>>>>>>>>    //
83911>>>>>>>>>>>>>>>>>    // These properties used with CodeList (SVN)
83911>>>>>>>>>>>>>>>>>    Property Integer phoCodeListHandler                0
83912>>>>>>>>>>>>>>>>>    Property Boolean pbAnsiMode                        True    // If true translate text to ANSI on open and back to OEM on save
83913>>>>>>>>>>>>>>>>>    
83913>>>>>>>>>>>>>>>>>    Property Boolean pbReindentStudioCommentOut        False   // If true, do not reindent comment lines starting at line 0, to keep studio comment out feature via ctrl+/
83914>>>>>>>>>>>>>>>>>    //
83914>>>>>>>>>>>>>>>>>    // I want to have a client border as default
83914>>>>>>>>>>>>>>>>>    Set Border_Style         to Border_ClientEdge
83915>>>>>>>>>>>>>>>>>    // Simulate these keys because they are overwritten by the DFControl.
83915>>>>>>>>>>>>>>>>>    On_Key key_Tab           Send Default_Key
83916>>>>>>>>>>>>>>>>>    On_Key Key_Shift+key_Tab Send Default_Key
83917>>>>>>>>>>>>>>>>>    On_Key kEnter            Send DoKeyReturn
83918>>>>>>>>>>>>>>>>>
83918>>>>>>>>>>>>>>>>>
83918>>>>>>>>>>>>>>>>>    Property Integer piRedrawState          True
83919>>>>>>>>>>>>>>>>>
83919>>>>>>>>>>>>>>>>>    Send Define_cSciLexerLanguageMixin
83920>>>>>>>>>>>>>>>>>  End_Procedure
83921>>>>>>>>>>>>>>>>>
83921>>>>>>>>>>>>>>>>>  Procedure End_Construct_Object
83923>>>>>>>>>>>>>>>>>    Forward Send End_Construct_Object
83925>>>>>>>>>>>>>>>>>
83925>>>>>>>>>>>>>>>>>  End_Procedure
83926>>>>>>>>>>>>>>>>>
83926>>>>>>>>>>>>>>>>>  Function SciLoadImageErrorText Integer iError Returns String
83928>>>>>>>>>>>>>>>>>    String  sErrorText
83928>>>>>>>>>>>>>>>>>
83928>>>>>>>>>>>>>>>>>    //ZeroString 300 to sErrorText
83928>>>>>>>>>>>>>>>>>    //Move (SciLoadImageErrorText(iError,AddressOf(sErrorText))) To iVoid
83928>>>>>>>>>>>>>>>>>    Move ("SciLoadImageAsRGBA, error "+trim(iError)) to sErrorText
83929>>>>>>>>>>>>>>>>>    Function_Return (CString(sErrorText))
83930>>>>>>>>>>>>>>>>>  End_Function
83931>>>>>>>>>>>>>>>>>
83931>>>>>>>>>>>>>>>>>
83931>>>>>>>>>>>>>>>>>  // Allows dropping files from Windows.
83931>>>>>>>>>>>>>>>>>  Procedure DoFileDropping Longptr wParam Longptr lParam
83933>>>>>>>>>>>>>>>>>    Handle  hDrop
83933>>>>>>>>>>>>>>>>>    Integer iCount iSize iC iRet
83933>>>>>>>>>>>>>>>>>    String  sFile
83933>>>>>>>>>>>>>>>>>    
83933>>>>>>>>>>>>>>>>>    Move wParam             to hDrop
83934>>>>>>>>>>>>>>>>>    Move (DragQueryFile(hDrop,|CI$FFFFFFFF,0,0))    to iCount
83935>>>>>>>>>>>>>>>>>    For iC from 0 to (iCount-1)
83941>>>>>>>>>>>>>>>>>>
83941>>>>>>>>>>>>>>>>>      Move (DragQueryFile(hDrop,iC,0,0))          to iSize
83942>>>>>>>>>>>>>>>>>      Move (Repeat(Character(0),iSize+1))         to sFile
83943>>>>>>>>>>>>>>>>>      Move (DragQueryFile(hDrop,iC,AddressOf(sFile),iSize+1))    to iRet
83944>>>>>>>>>>>>>>>>>      If iRet Begin
83946>>>>>>>>>>>>>>>>>        Move (CString(sFile))                   to sFile
83947>>>>>>>>>>>>>>>>>        Send onFileDropped sFile
83948>>>>>>>>>>>>>>>>>      End
83948>>>>>>>>>>>>>>>>>>
83948>>>>>>>>>>>>>>>>>    Loop
83949>>>>>>>>>>>>>>>>>>
83949>>>>>>>>>>>>>>>>>    Move (DragFinish(hDrop))                        to iRet
83950>>>>>>>>>>>>>>>>>  End_Procedure
83951>>>>>>>>>>>>>>>>>  Procedure OnFileDropped String sFile
83953>>>>>>>>>>>>>>>>>  End_Procedure
83954>>>>>>>>>>>>>>>>>
83954>>>>>>>>>>>>>>>>>  Procedure onWmContextMenu Longptr wParam Longptr lParam
83956>>>>>>>>>>>>>>>>>    Send DoRightClick wParam
83957>>>>>>>>>>>>>>>>>  End_Procedure
83958>>>>>>>>>>>>>>>>>
83958>>>>>>>>>>>>>>>>>  // This popups the SelectionList reltive to the cursor position
83958>>>>>>>>>>>>>>>>>  Function Absolute_GUIOrigin Returns Integer
83960>>>>>>>>>>>>>>>>>    Integer iX iY iRet
83960>>>>>>>>>>>>>>>>>    Forward Get Absolute_GUIOrigin  to iRet
83962>>>>>>>>>>>>>>>>>    If (piDontOverwriteGUIOrigin(Self)) Begin
83964>>>>>>>>>>>>>>>>>      Function_Return iRet
83965>>>>>>>>>>>>>>>>>    End
83965>>>>>>>>>>>>>>>>>>
83965>>>>>>>>>>>>>>>>>    Move (Hi(iRet))                                                 to iY
83966>>>>>>>>>>>>>>>>>    Move (Low(iRet))                                                to iX
83967>>>>>>>>>>>>>>>>>    Get  CM_GetSel False                                            to iRet
83968>>>>>>>>>>>>>>>>>    Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
83969>>>>>>>>>>>>>>>>>    Move (iY+piPosEndY(Self))                                       to iY
83970>>>>>>>>>>>>>>>>>    Move (iX+piPosEndX(Self))                                       to iX
83971>>>>>>>>>>>>>>>>>    Move (iY+piGUIOriginOffsetY(Self))                              to iY
83972>>>>>>>>>>>>>>>>>    Move (iX+piGUIOriginOffsetX(Self))                              to iX
83973>>>>>>>>>>>>>>>>>    Function_Return (MAKEWPARAM(iX,iY))
83974>>>>>>>>>>>>>>>>>  End_Function
83975>>>>>>>>>>>>>>>>>
83975>>>>>>>>>>>>>>>>>  // So the real GUIOrigin is always available too.
83975>>>>>>>>>>>>>>>>>  Function Absolute_GUIOriginEx Returns Integer
83977>>>>>>>>>>>>>>>>>    Integer iRet iOld
83977>>>>>>>>>>>>>>>>>    Get piDontOverwriteGUIOrigin    to iOld
83978>>>>>>>>>>>>>>>>>    Set piDontOverwriteGUIOrigin    to True
83979>>>>>>>>>>>>>>>>>    Get Absolute_GUIOrigin          to iRet
83980>>>>>>>>>>>>>>>>>    Set piDontOverwriteGUIOrigin    to iOld
83981>>>>>>>>>>>>>>>>>    Function_Return iRet
83982>>>>>>>>>>>>>>>>>  End_Function
83983>>>>>>>>>>>>>>>>>
83983>>>>>>>>>>>>>>>>>  // Implementing Dyn.Update.State with using WM_SETREDRAW
83983>>>>>>>>>>>>>>>>>  Procedure Set Dynamic_Update_State1 Integer iFlag
83985>>>>>>>>>>>>>>>>>    Integer iRet
83985>>>>>>>>>>>>>>>>>    If (window_handle(Self)) Eq 0 Begin
83987>>>>>>>>>>>>>>>>>      Procedure_Return
83988>>>>>>>>>>>>>>>>>    End
83988>>>>>>>>>>>>>>>>>>
83988>>>>>>>>>>>>>>>>>    Set piRedrawState   to iFlag
83989>>>>>>>>>>>>>>>>>    Move (SendMessage(Window_Handle(Self),WM_SETREDRAW,iFlag,0))            to iRet
83990>>>>>>>>>>>>>>>>>    If iFlag Begin
83992>>>>>>>>>>>>>>>>>      Move (RedrawWindow(Window_Handle(Self),0,0,RDW_INVALIDATE))    to iRet
83993>>>>>>>>>>>>>>>>>    End
83993>>>>>>>>>>>>>>>>>>
83993>>>>>>>>>>>>>>>>>  End_Procedure
83994>>>>>>>>>>>>>>>>>
83994>>>>>>>>>>>>>>>>>  Function Dynamic_Update_State1 Returns Integer
83996>>>>>>>>>>>>>>>>>    Function_Return (piRedrawState(Self))
83997>>>>>>>>>>>>>>>>>  End_Function
83998>>>>>>>>>>>>>>>>>
83998>>>>>>>>>>>>>>>>>  Procedure OnWmPaint
84000>>>>>>>>>>>>>>>>>  End_Procedure
84001>>>>>>>>>>>>>>>>>
84001>>>>>>>>>>>>>>>>>
84001>>>>>>>>>>>>>>>>>  Function CreateIndentation Integer iIndent Integer iTabSize Boolean bInsertSpaces Returns String
84003>>>>>>>>>>>>>>>>>    String sIndent
84003>>>>>>>>>>>>>>>>>
84003>>>>>>>>>>>>>>>>>    Move "" to sIndent
84004>>>>>>>>>>>>>>>>>    If (bInsertSpaces=False) Begin
84006>>>>>>>>>>>>>>>>>      While (iIndent>=iTabSize)
84010>>>>>>>>>>>>>>>>>        Move (sIndent+"\t") to sIndent
84011>>>>>>>>>>>>>>>>>        Move (iIndent-iTabSize) to iIndent
84012>>>>>>>>>>>>>>>>>      Loop
84013>>>>>>>>>>>>>>>>>>
84013>>>>>>>>>>>>>>>>>      Move (Replaces("\t",sIndent,Character(9))) to sIndent
84014>>>>>>>>>>>>>>>>>      While (iIndent>0)
84018>>>>>>>>>>>>>>>>>        Move (sIndent+" ") to sIndent
84019>>>>>>>>>>>>>>>>>        Decrement iIndent
84020>>>>>>>>>>>>>>>>>      Loop
84021>>>>>>>>>>>>>>>>>>
84021>>>>>>>>>>>>>>>>>    End
84021>>>>>>>>>>>>>>>>>>
84021>>>>>>>>>>>>>>>>>    Else Begin
84022>>>>>>>>>>>>>>>>>      Move (Repeat(" ",iIndent)) To sIndent
84023>>>>>>>>>>>>>>>>>    End
84023>>>>>>>>>>>>>>>>>>
84023>>>>>>>>>>>>>>>>>    Function_Return sIndent
84024>>>>>>>>>>>>>>>>>  End_Function
84025>>>>>>>>>>>>>>>>>
84025>>>>>>>>>>>>>>>>>  Function DefaultTabIndent Returns String
84027>>>>>>>>>>>>>>>>>    Boolean bUseTabs
84027>>>>>>>>>>>>>>>>>    Integer iTabSize
84027>>>>>>>>>>>>>>>>>    String  sIndent
84027>>>>>>>>>>>>>>>>>
84027>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH to iTabSize
84028>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS  to bUseTabs
84029>>>>>>>>>>>>>>>>>    Get CreateIndentation iTabSize iTabSize (not(bUseTabs)) To sIndent
84030>>>>>>>>>>>>>>>>>    Function_Return sIndent
84031>>>>>>>>>>>>>>>>>  End_Function
84032>>>>>>>>>>>>>>>>>
84032>>>>>>>>>>>>>>>>>  // Creates an Indent String while obeying the current settings
84032>>>>>>>>>>>>>>>>>  //
84032>>>>>>>>>>>>>>>>>  Function IndentString Integer iIndentWanted Returns String
84034>>>>>>>>>>>>>>>>>    Boolean bUseTabs
84034>>>>>>>>>>>>>>>>>    Integer iTabSize
84034>>>>>>>>>>>>>>>>>    String  sIndent
84034>>>>>>>>>>>>>>>>>
84034>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH to iTabSize
84035>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS  to bUseTabs
84036>>>>>>>>>>>>>>>>>    Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) To sIndent
84037>>>>>>>>>>>>>>>>>    Function_Return sIndent
84038>>>>>>>>>>>>>>>>>  End_Function
84039>>>>>>>>>>>>>>>>>
84039>>>>>>>>>>>>>>>>>  Function IndentStringForLine Integer iLine Returns String
84041>>>>>>>>>>>>>>>>>    Integer iIndent
84041>>>>>>>>>>>>>>>>>    String  sIndent
84041>>>>>>>>>>>>>>>>>
84041>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINEINDENTATION iLine to iIndent
84042>>>>>>>>>>>>>>>>>    Get IndentString iIndent To sIndent
84043>>>>>>>>>>>>>>>>>    Function_Return sIndent
84044>>>>>>>>>>>>>>>>>  End_Function
84045>>>>>>>>>>>>>>>>>
84045>>>>>>>>>>>>>>>>>  //
84045>>>>>>>>>>>>>>>>>  // iLine is the new line we are on and iIndentWanted is the indentation from the previous
84045>>>>>>>>>>>>>>>>>  // line. We will insert the wanted indentation and then place the cursor at the end of
84045>>>>>>>>>>>>>>>>>  // the line.
84045>>>>>>>>>>>>>>>>>  //
84045>>>>>>>>>>>>>>>>>  Procedure IndentAsPreviousLine Integer iLine Integer iIndentWanted
84047>>>>>>>>>>>>>>>>>    Integer iPos
84047>>>>>>>>>>>>>>>>>    Integer iLen
84047>>>>>>>>>>>>>>>>>    String  sIndent
84047>>>>>>>>>>>>>>>>>
84047>>>>>>>>>>>>>>>>>    Get IndentString iIndentWanted to sIndent
84048>>>>>>>>>>>>>>>>>    Move (Length(sIndent)) To iLen
84049>>>>>>>>>>>>>>>>>    Move (sIndent+Character(0)) to sIndent
84050>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE iLine to iPos
84051>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETTARGETRANGE iPos iPos
84052>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sIndent))
84053>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETSEL -1 (iPos+iLen) // position the cursor to the new line indentation point and remove the selection
84054>>>>>>>>>>>>>>>>>  End_Procedure
84055>>>>>>>>>>>>>>>>>
84055>>>>>>>>>>>>>>>>>  Procedure DoKeyReturn
84057>>>>>>>>>>>>>>>>>    Boolean bNormalizeCase
84057>>>>>>>>>>>>>>>>>    Integer iLine
84057>>>>>>>>>>>>>>>>>    Integer iIndent
84057>>>>>>>>>>>>>>>>>    Integer iPos
84057>>>>>>>>>>>>>>>>>    Integer iCol
84057>>>>>>>>>>>>>>>>>    Integer iTabSize
84057>>>>>>>>>>>>>>>>>    Integer iFoldLevel iNextFoldLevel
84057>>>>>>>>>>>>>>>>>    Integer eMode
84057>>>>>>>>>>>>>>>>>
84057>>>>>>>>>>>>>>>>>    Get pbNormalizeCase to bNormalizeCase
84058>>>>>>>>>>>>>>>>>    If (bNormalizeCase) Begin
84060>>>>>>>>>>>>>>>>>      Send doNormalizeCase
84061>>>>>>>>>>>>>>>>>    End
84061>>>>>>>>>>>>>>>>>>
84061>>>>>>>>>>>>>>>>>    If (pbIsCodelistActive(Self)) Begin
84063>>>>>>>>>>>>>>>>>      // We're in a autocomplete list, don't send enter, send TAB instead
84063>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_TAB
84064>>>>>>>>>>>>>>>>>    End
84064>>>>>>>>>>>>>>>>>>
84064>>>>>>>>>>>>>>>>>    Else Begin
84065>>>>>>>>>>>>>>>>>      Get peAutoIndentMode to eMode
84066>>>>>>>>>>>>>>>>>      Set psLineOnEnter    to ""
84067>>>>>>>>>>>>>>>>>      If (eMode=CM_INDENT_PREVLINE) Begin
84069>>>>>>>>>>>>>>>>>        Get  Current_Item To iLine
84070>>>>>>>>>>>>>>>>>        Get LineFoldLevel iLine To iFoldLevel
84071>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_BEGINUNDOACTION
84072>>>>>>>>>>>>>>>>>        Get  EditorMessage SCI_GETLINEINDENTATION iLine 0 to iIndent
84073>>>>>>>>>>>>>>>>>        Get  EditorMessage SCI_GETCURRENTPOS 0 0 To iPos
84074>>>>>>>>>>>>>>>>>        Get  EditorMessage SCI_GETCOLUMN  iPos 0 to iCol
84075>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_NEWLINE
84076>>>>>>>>>>>>>>>>>        Get LineFoldLevel (iLine+1) To iNextFoldLevel
84077>>>>>>>>>>>>>>>>>        If (iNextFoldLevel>iFoldLevel) Begin
84079>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETTABWIDTH 0 0 to iTabSize
84080>>>>>>>>>>>>>>>>>          Move (iTabSize+iIndent) To iIndent // we're just after a new scope, so indent 1 extra position
84081>>>>>>>>>>>>>>>>>        End
84081>>>>>>>>>>>>>>>>>>
84081>>>>>>>>>>>>>>>>>        If (iCol>=iIndent) Begin
84083>>>>>>>>>>>>>>>>>          Send IndentAsPreviousLine (iLine+1) iIndent
84084>>>>>>>>>>>>>>>>>        End
84084>>>>>>>>>>>>>>>>>>
84084>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_ENDUNDOACTION
84085>>>>>>>>>>>>>>>>>      End
84085>>>>>>>>>>>>>>>>>>
84085>>>>>>>>>>>>>>>>>      Else Begin
84086>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_NEWLINE
84087>>>>>>>>>>>>>>>>>      End
84087>>>>>>>>>>>>>>>>>>
84087>>>>>>>>>>>>>>>>>    End
84087>>>>>>>>>>>>>>>>>>
84087>>>>>>>>>>>>>>>>>  End_Procedure
84088>>>>>>>>>>>>>>>>>  
84088>>>>>>>>>>>>>>>>>  // To ensure that the Object with the WinFocus also owns the DF focus.
84088>>>>>>>>>>>>>>>>>  Procedure OnWmSetFocus
84090>>>>>>>>>>>>>>>>>    Send Activate
84091>>>>>>>>>>>>>>>>>  End_Procedure
84092>>>>>>>>>>>>>>>>>  
84092>>>>>>>>>>>>>>>>>  Procedure OnWmKillFocus
84094>>>>>>>>>>>>>>>>>  End_Procedure
84095>>>>>>>>>>>>>>>>>
84095>>>>>>>>>>>>>>>>>
84095>>>>>>>>>>>>>>>>>  Procedure EditorMessage Handle uMsg Longptr wParam Longptr lParam
84097>>>>>>>>>>>>>>>>>    Handle  hWnd
84097>>>>>>>>>>>>>>>>>    Integer iRet
84097>>>>>>>>>>>>>>>>>
84097>>>>>>>>>>>>>>>>>    Get Window_Handle to hWnd
84098>>>>>>>>>>>>>>>>>    If (hWnd) Begin
84100>>>>>>>>>>>>>>>>>      If num_arguments Eq 3 Begin
84102>>>>>>>>>>>>>>>>>        Move (SendMessage(hWnd,uMsg,wParam,lParam)) to iRet
84103>>>>>>>>>>>>>>>>>      End
84103>>>>>>>>>>>>>>>>>>
84103>>>>>>>>>>>>>>>>>      Else If num_arguments eq 2 Begin
84106>>>>>>>>>>>>>>>>>        Move (SendMessage(hWnd,uMsg,wParam,0)) to iRet
84107>>>>>>>>>>>>>>>>>      End
84107>>>>>>>>>>>>>>>>>>
84107>>>>>>>>>>>>>>>>>      Else If num_arguments eq 1 Begin
84110>>>>>>>>>>>>>>>>>        Move (SendMessage(hWnd,uMsg,0,0)) to iRet
84111>>>>>>>>>>>>>>>>>      End
84111>>>>>>>>>>>>>>>>>>
84111>>>>>>>>>>>>>>>>>    End
84111>>>>>>>>>>>>>>>>>>
84111>>>>>>>>>>>>>>>>>  End_Procedure
84112>>>>>>>>>>>>>>>>>  
84112>>>>>>>>>>>>>>>>>  Procedure EditorError String sMessage
84114>>>>>>>>>>>>>>>>>    String sStack
84114>>>>>>>>>>>>>>>>>    
84114>>>>>>>>>>>>>>>>>    CallStackDump sStack
84115>>>>>>>>>>>>>>>>>    Error DfErr_Program (sMessage+"\n"+sStack)
84116>>>>>>>>>>>>>>>>>>
84116>>>>>>>>>>>>>>>>>  End_Procedure
84117>>>>>>>>>>>>>>>>>
84117>>>>>>>>>>>>>>>>>  Function EditorMessage Handle uMsg Longptr wParam Longptr lParam Returns Longptr
84119>>>>>>>>>>>>>>>>>    Handle  hWnd
84119>>>>>>>>>>>>>>>>>    Longptr iRet
84119>>>>>>>>>>>>>>>>>
84119>>>>>>>>>>>>>>>>>    Move 0 To iRet
84120>>>>>>>>>>>>>>>>>    Get Window_Handle to hWnd
84121>>>>>>>>>>>>>>>>>    If (hWnd) Begin
84123>>>>>>>>>>>>>>>>>      Case Begin
84123>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 0)
84125>>>>>>>>>>>>>>>>>          Send EditorError "Programmer error, get editormessage without a parameter."
84126>>>>>>>>>>>>>>>>>          Case Break
84127>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 1)
84130>>>>>>>>>>>>>>>>>          Move (SendMessage(hWnd,uMsg,0,0)) To iRet
84131>>>>>>>>>>>>>>>>>          Case Break
84132>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 2)
84135>>>>>>>>>>>>>>>>>          Move (SendMessage(hWnd,uMsg,wParam,0)) To iRet
84136>>>>>>>>>>>>>>>>>          Case Break
84137>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 3)
84140>>>>>>>>>>>>>>>>>          Move (SendMessage(hWnd,uMsg,wParam,lParam)) To iRet
84141>>>>>>>>>>>>>>>>>          Case Break
84142>>>>>>>>>>>>>>>>>      Case End
84142>>>>>>>>>>>>>>>>>    End
84142>>>>>>>>>>>>>>>>>>
84142>>>>>>>>>>>>>>>>>    Function_Return iRet
84143>>>>>>>>>>>>>>>>>  End_Function
84144>>>>>>>>>>>>>>>>>
84144>>>>>>>>>>>>>>>>>  Procedure EditorMessageString Handle uMsg String ByRef sName String ByRef sValue
84146>>>>>>>>>>>>>>>>>    Handle  hWnd
84146>>>>>>>>>>>>>>>>>    Integer iRet
84146>>>>>>>>>>>>>>>>>
84146>>>>>>>>>>>>>>>>>    Get Window_Handle to hWnd
84147>>>>>>>>>>>>>>>>>    If (hWnd) Begin
84149>>>>>>>>>>>>>>>>>      Move (sName+ Character(0)) to sName
84150>>>>>>>>>>>>>>>>>      Move (sValue+Character(0)) to sValue
84151>>>>>>>>>>>>>>>>>      Move (SendMessage(hWnd,uMsg,AddressOf(sName),AddressOf(sValue))) to iRet
84152>>>>>>>>>>>>>>>>>    End
84152>>>>>>>>>>>>>>>>>>
84152>>>>>>>>>>>>>>>>>  End_Procedure
84153>>>>>>>>>>>>>>>>>
84153>>>>>>>>>>>>>>>>>  // By SVN - Apply Colorer
84153>>>>>>>>>>>>>>>>>  Procedure DefaultFontStyles
84155>>>>>>>>>>>>>>>>>    Integer iLexer
84155>>>>>>>>>>>>>>>>>    Integer iBackColor
84155>>>>>>>>>>>>>>>>>    String  sFont
84155>>>>>>>>>>>>>>>>>
84155>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLECLEARALL
84156>>>>>>>>>>>>>>>>>    // We have setup a default font for all, now set the specific fonts.
84156>>>>>>>>>>>>>>>>>    //
84156>>>>>>>>>>>>>>>>>    Set piTextColor   to gtColorer[EC_TEXT].iForeC //iTextColor
84157>>>>>>>>>>>>>>>>>    Set piWindowColor to gtColorer[EC_WINDOW].iForeC //iBackColor
84158>>>>>>>>>>>>>>>>>    // Caret
84158>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETCARETFORE       gtColorer[EC_TEXT].iForeC
84159>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETCARETWIDTH      3
84160>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_SETCARETSTYLE      CARETSTYLE_BLOCK // Good for overwrite mode (Default is Underline)
84160>>>>>>>>>>>>>>>>>    // Selection
84160>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_SETSELFORE True (Rgb($FF, $FF, $FF)) // Will overwrite selection highlighting
84160>>>>>>>>>>>>>>>>>    Move gtColorer[EC_WINDOW].iForeC to iBackColor
84161>>>>>>>>>>>>>>>>>    If (iBackColor<0) Begin
84163>>>>>>>>>>>>>>>>>      Move clWhite to iBackColor
84164>>>>>>>>>>>>>>>>>    End
84164>>>>>>>>>>>>>>>>>>
84164>>>>>>>>>>>>>>>>>    // *** Lets check either Selection color is set and if not, then allocate default selection
84164>>>>>>>>>>>>>>>>>    // Probably not the best algorithm, but we may improve at some stage if required ***
84164>>>>>>>>>>>>>>>>>    If (gtColorer[EC_SELECTION].iForeC<=0) Begin
84166>>>>>>>>>>>>>>>>>      If (iBackColor < (RGB($FF, $FF, $FF)/2-10000)) ;        Send EditorMessage SCI_SETSELBACK True (Rgb($00, $00, $AA)) // Set darker
84169>>>>>>>>>>>>>>>>>      Else ;        Send EditorMessage SCI_SETSELBACK True (RGB(170,195,240))   // Set lighter
84171>>>>>>>>>>>>>>>>>    End
84171>>>>>>>>>>>>>>>>>>
84171>>>>>>>>>>>>>>>>>    Else ;      Send EditorMessage SCI_SETSELBACK True gtColorer[EC_SELECTION].iForeC   // Set as per options
84173>>>>>>>>>>>>>>>>>    // # White space
84173>>>>>>>>>>>>>>>>>    // style.dataflex.0=fore:#808080
84173>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFORE STYLE_DEFAULT gtColorer[EC_TEXT].iForeC
84174>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK STYLE_DEFAULT iBackColor
84175>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK 0             iBackColor
84176>>>>>>>>>>>>>>>>>    // Retrieve lexer type for current window (eg. language) and apply the appearance for the language set.
84176>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLEXER to iLexer
84177>>>>>>>>>>>>>>>>>    Send SetAppearanceForLanguage iLexer
84178>>>>>>>>>>>>>>>>>    Send SetAppearance  STYLE_BRACELIGHT     EC_BRACEHLIGHT      // Colors for matching braces
84179>>>>>>>>>>>>>>>>>    Send SetAppearance  STYLE_BRACEBAD       EC_UNMATCHEDBRACE   // Colors for an unmatched brace (bracebad)
84180>>>>>>>>>>>>>>>>>    Send SetAppearance  STYLE_LINENUMBER     EC_LINENUMBERS      // Line Numbers Margin
84181>>>>>>>>>>>>>>>>>    Send EditorMessage  SCI_STYLESETSIZE     STYLE_LINENUMBER 10 // Set font size
84182>>>>>>>>>>>>>>>>>    //
84182>>>>>>>>>>>>>>>>>    // Colors for codetip tooltip
84182>>>>>>>>>>>>>>>>>    // font style to use for call tip
84182>>>>>>>>>>>>>>>>>    Move ("Segoe UI"+Character(0)) to sFont
84183>>>>>>>>>>>>>>>>>    //      Move ("Verdana"+Character(0)) to sFont
84183>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFONT STYLE_CALLTIP   (AddressOf(sFont))
84184>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETSIZE STYLE_CALLTIP   9
84185>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK STYLE_CALLTIP   (rgb($FF,$FF,$E1))
84186>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFORE STYLE_CALLTIP   (rgb($00,$00,$00)) // Code tooltip text color
84187>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPSETFOREHLT            (rgb($00,$00,$00)) // Code tooltip parameters color
84188>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPUSESTYLE 10 // tabs are filtered out of calltips, but we need to call this to have scintilla use our defined colors.
84189>>>>>>>>>>>>>>>>>    //
84189>>>>>>>>>>>>>>>>>    // tell the control we want to use our own font style for autocomplete
84189>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_AUTOCUSESTYLE
84190>>>>>>>>>>>>>>>>>    // font style to use for autocomplete (codelist)
84190>>>>>>>>>>>>>>>>>    //      Move ("DejaVu Sans Mono"+Character(0)) to sFont
84190>>>>>>>>>>>>>>>>>    Move ("Segoe UI"+Character(0)) to sFont
84191>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFONT STYLE_AUTOCOMPLETE (AddressOf(sFont))
84192>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETSIZE STYLE_AUTOCOMPLETE 10
84193>>>>>>>>>>>>>>>>>    // Status is bookmarks, debug pointer and breakpoints
84193>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINBACKN MARGIN_STATUS       gtColorer[EC_LEFTMARGIN].iForeC
84194>>>>>>>>>>>>>>>>>    // Changed line
84194>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINBACKN MARGIN_CHANGED_LINE gtColorer[EC_LEFTMARGIN].iForeC
84195>>>>>>>>>>>>>>>>>  End_Procedure
84196>>>>>>>>>>>>>>>>>
84196>>>>>>>>>>>>>>>>>  Procedure Set LexerProperty String sName String sValue
84198>>>>>>>>>>>>>>>>>    Send EditorMessageString SCI_SETPROPERTY (&sName) (&sValue)
84199>>>>>>>>>>>>>>>>>  End_Procedure
84200>>>>>>>>>>>>>>>>>
84200>>>>>>>>>>>>>>>>>  Procedure SetLexer
84202>>>>>>>>>>>>>>>>>  End_Procedure
84203>>>>>>>>>>>>>>>>>
84203>>>>>>>>>>>>>>>>>  Procedure SetDefaultFoldingStyle
84205>>>>>>>>>>>>>>>>>    Integer iFore
84205>>>>>>>>>>>>>>>>>    Integer iBack
84205>>>>>>>>>>>>>>>>>    Pointer pExpandIconXpm
84205>>>>>>>>>>>>>>>>>    Pointer pCollapseIconXpm
84205>>>>>>>>>>>>>>>>>    Pointer pBookmarkIconXpm
84205>>>>>>>>>>>>>>>>>    Pointer pChangedLineIconXpm
84205>>>>>>>>>>>>>>>>>    Pointer pSavedLineIconXpm
84205>>>>>>>>>>>>>>>>>    //
84205>>>>>>>>>>>>>>>>>    //line.margin.width=4
84205>>>>>>>>>>>>>>>>>    //margin.width=$(scale 16)
84205>>>>>>>>>>>>>>>>>    //fold.margin.width=$(scale 14)
84205>>>>>>>>>>>>>>>>>    Set LexerProperty "line.margin.width" to "4"
84206>>>>>>>>>>>>>>>>>    //Set LexerProperty "margin.width"      to "$(scale 16)"
84206>>>>>>>>>>>>>>>>>    //Set LexerProperty "fold.margin.width" to "$(scale 14)"
84206>>>>>>>>>>>>>>>>>    Set LexerProperty "margin.width"      to "16"
84207>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.margin.width" to "14"
84208>>>>>>>>>>>>>>>>>    //
84208>>>>>>>>>>>>>>>>>    // set folding defaults (can be changed if you want different behavior)
84208>>>>>>>>>>>>>>>>>    //
84208>>>>>>>>>>>>>>>>>    Set LexerProperty "fold"              to "1"
84209>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.compact"      to "1"
84210>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.flags"        to "1"
84211>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.comment"      to "1"
84212>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.preprocessor" to "1"
84213>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.dataflex.compilerlist" To "0"  // fold PRN files (is set to true when you open a prn/prp file)
84214>>>>>>>>>>>>>>>>>    //
84214>>>>>>>>>>>>>>>>>    // Now resize all the margins to zero
84214>>>>>>>>>>>>>>>>>    // (This will be done in a RecalcLineMargin method...)
84214>>>>>>>>>>>>>>>>>    //
84214>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 0
84215>>>>>>>>>>>>>>>>>    //
84215>>>>>>>>>>>>>>>>>    // Then Set the margin type and margin mask and resize it...
84215>>>>>>>>>>>>>>>>>    //      Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
84215>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING SC_MARGIN_SYMBOL
84216>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CODE_FOLDING SC_MASK_FOLDERS
84217>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 20
84218>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETFOLDMARGINCOLOUR    True gtColorer[EC_LINENUMBERS].iBackC
84219>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETFOLDMARGINHICOLOUR  True gtColorer[EC_LEFTMARGIN].iForeC
84220>>>>>>>>>>>>>>>>>    //
84220>>>>>>>>>>>>>>>>>    // Needs marker defines
84220>>>>>>>>>>>>>>>>>    Move (RGB($00,$00,$00)) to iBack
84221>>>>>>>>>>>>>>>>>    Move (RGB($bb,$bb,$bb)) to iFore
84222>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDEROPEN    SC_ALPHA_TRANSPARENT
84222>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(0)) To pExpandIconXpm       // get xpm icon from parser DLL
84223>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(1)) To pCollapseIconXpm     // These icons are created by hand by Sergey!
84224>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(2)) To pBookmarkIconXpm
84225>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(3)) To pChangedLineIconXpm
84226>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(4)) To pSavedLineIconXpm
84227>>>>>>>>>>>>>>>>>
84227>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPEN    iBack
84228>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPEN    iFore
84229>>>>>>>>>>>>>>>>>    If (pCollapseIconXpm<>0) Begin
84231>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPEN pCollapseIconXpm
84232>>>>>>>>>>>>>>>>>    End
84232>>>>>>>>>>>>>>>>>>
84232>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPEN    SC_MARK_CIRCLEMINUS
84232>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDER        SC_ALPHA_TRANSPARENT
84232>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDER        iBack
84233>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDER        iFore
84234>>>>>>>>>>>>>>>>>    If (pExpandIconXpm<>0) Begin
84236>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDER    pExpandIconXpm
84237>>>>>>>>>>>>>>>>>    End
84237>>>>>>>>>>>>>>>>>>
84237>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERSUB     iBack
84237>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERSUB     iFore
84237>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERSUB     SC_MARK_EMPTY //SC_MARK_VLINE       //SC_MARK_EMPTY
84238>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERTAIL    iBack
84238>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERTAIL    iFore
84238>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERTAIL    SC_MARK_EMPTY //SC_MARK_LCORNERCURVE
84239>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEREND     iBack
84240>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEREND     iFore
84241>>>>>>>>>>>>>>>>>    If (pExpandIconXpm<>0) Begin
84243>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEREND    pExpandIconXpm
84244>>>>>>>>>>>>>>>>>    End
84244>>>>>>>>>>>>>>>>>>
84244>>>>>>>>>>>>>>>>>    ///Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEREND     SC_MARK_EMPTY //SC_MARK_CIRCLEPLUSCONNECTED
84244>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPENMID iBack
84245>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPENMID iFore
84246>>>>>>>>>>>>>>>>>    If (pCollapseIconXpm<>0) Begin
84248>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPENMID pCollapseIconXpm
84249>>>>>>>>>>>>>>>>>    End
84249>>>>>>>>>>>>>>>>>>
84249>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPENMID SC_MARK_EMPTY //SC_MARK_CIRCLEMINUSCONNECTED
84249>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERMIDTAIL iBack
84249>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERMIDTAIL iFore
84249>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERMIDTAIL SC_MARK_EMPTY //SC_MARK_TCORNERCURVE
84250>>>>>>>>>>>>>>>>>    //
84250>>>>>>>>>>>>>>>>>    //
84250>>>>>>>>>>>>>>>>>    // SendEditor(SCI_SETFOLDFLAGS, 16, 0); // 16       Draw line below if not expanded
84250>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETFOLDFLAGS 16 0
84251>>>>>>>>>>>>>>>>>    //
84251>>>>>>>>>>>>>>>>>    // Tell scintilla we want to be notified about mouse clicks in the codefolding margin
84251>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_CODE_FOLDING 1
84252>>>>>>>>>>>>>>>>>    //
84252>>>>>>>>>>>>>>>>>    // Tell scintilla we want to be notified about mouse clicks in the status margin
84252>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_STATUS 1
84253>>>>>>>>>>>>>>>>>    //
84253>>>>>>>>>>>>>>>>>    // for marker 10 define a background color instead of the marker symbol
84253>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_LINEHIGHLIGHT SC_MARK_BACKGROUND
84254>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_LINEHIGHLIGHT gtColorer[EC_HLIGHTEDLINE].iForeC //(rgb($DE,$DE,$EF))
84255>>>>>>>>>>>>>>>>>    //
84255>>>>>>>>>>>>>>>>>    // for marker 11 connect it to sergey's bookmark symbol
84255>>>>>>>>>>>>>>>>>    //
84255>>>>>>>>>>>>>>>>>    If (pBookmarkIconXpm<>0) Begin
84257>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_BOOKMARK pBookmarkIconXpm
84258>>>>>>>>>>>>>>>>>    End
84258>>>>>>>>>>>>>>>>>>
84258>>>>>>>>>>>>>>>>>    Else Begin // fall back on default
84259>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_BOOKMARK  SC_MARK_BOOKMARK
84260>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_BOOKMARK  (rgb($DE,$00,$00))
84261>>>>>>>>>>>>>>>>>    End
84261>>>>>>>>>>>>>>>>>>
84261>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE SC_MARKNUM_BOOKMARK  (rgb($EE,$00,$00))
84261>>>>>>>>>>>>>>>>>    //
84261>>>>>>>>>>>>>>>>>    // for marker 12 and 13 connect it to the changedline icon
84261>>>>>>>>>>>>>>>>>    If (pChangedLineIconXpm<>0) Begin
84263>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINE pChangedLineIconXpm
84264>>>>>>>>>>>>>>>>>    End
84264>>>>>>>>>>>>>>>>>>
84264>>>>>>>>>>>>>>>>>    Else Begin
84265>>>>>>>>>>>>>>>>>      // We're using the SC_MARK_FULLRECT instead as we can set the color and width
84265>>>>>>>>>>>>>>>>>      // dynamically.
84265>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINE SC_MARK_FULLRECT
84266>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINE  (rgb($FF,$F2,$00)) // yellow
84267>>>>>>>>>>>>>>>>>    End
84267>>>>>>>>>>>>>>>>>>
84267>>>>>>>>>>>>>>>>>
84267>>>>>>>>>>>>>>>>>    If (pSavedLineIconXpm<>0) Begin
84269>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINESAVED pSavedLineIconXpm
84270>>>>>>>>>>>>>>>>>    End
84270>>>>>>>>>>>>>>>>>>
84270>>>>>>>>>>>>>>>>>    Else Begin
84271>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINESAVED SC_MARK_FULLRECT
84272>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINESAVED  (rgb($00,$FF,$00)) // green
84273>>>>>>>>>>>>>>>>>    End
84273>>>>>>>>>>>>>>>>>>
84273>>>>>>>>>>>>>>>>>    // for marker 14 set the debug breakpoint marker
84273>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_DEBUGBREAKPOINT SC_MARK_CIRCLE
84274>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_DEBUGBREAKPOINT (rgb($FE,$00,$00)) // red
84275>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_DEBUGBREAKPOINT iBack
84276>>>>>>>>>>>>>>>>>    // for marker 15 set the debug current position pointer
84276>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_DEBUGCURRENTPOSITION SC_MARK_SHORTARROW
84277>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_DEBUGCURRENTPOSITION (rgb($00,$FE,$00)) // green
84278>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_DEBUGCURRENTPOSITION iBack
84279>>>>>>>>>>>>>>>>>  End_Procedure
84280>>>>>>>>>>>>>>>>>
84280>>>>>>>>>>>>>>>>>  Procedure SetDefaultWordStyle
84282>>>>>>>>>>>>>>>>>    //
84282>>>>>>>>>>>>>>>>>    // Use the default sets of word and whitespace characters. This sets whitespace to space, tab and
84282>>>>>>>>>>>>>>>>>    // other characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
84282>>>>>>>>>>>>>>>>>    //
84282>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETCHARSDEFAULT
84283>>>>>>>>>>>>>>>>>  End_Procedure
84284>>>>>>>>>>>>>>>>>
84284>>>>>>>>>>>>>>>>>  // Should try to destroy the font object.
84284>>>>>>>>>>>>>>>>>  Procedure Destroy_Object
84286>>>>>>>>>>>>>>>>>    Forward Send Destroy_Object
84288>>>>>>>>>>>>>>>>>    //Move (CMUnregisterControl()) to iRet
84288>>>>>>>>>>>>>>>>>  End_Procedure
84289>>>>>>>>>>>>>>>>>
84289>>>>>>>>>>>>>>>>>  Procedure ApplyEditorOptions
84291>>>>>>>>>>>>>>>>>    Send SetLexer
84292>>>>>>>>>>>>>>>>>    Send DefaultFontStyles
84293>>>>>>>>>>>>>>>>>    Send SetDefaultFoldingStyle
84294>>>>>>>>>>>>>>>>>    Send SetDefaultWordStyle
84295>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_USEPOPUP        SC_POPUP_NEVER  // Don't use the embedded popup menu, send WM_CONTEXTMENU to parent window
84296>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMODEVENTMASK SC_MODEVENTMASKALL // show ALL events in SCN_MODIFIED
84297>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_LINE_NUMBERS SC_MARGIN_NUMBER // margin 0 is for line numbers
84298>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_STATUS       (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
84299>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_STATUS       16
84300>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_STATUS       SC_MASK_STATUS
84301>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CHANGED_LINE (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
84302>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CHANGED_LINE 3
84303>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CHANGED_LINE SC_MASK_CHANGEDLINE
84304>>>>>>>>>>>>>>>>>    //
84304>>>>>>>>>>>>>>>>>    Send ClearRegisteredKeyBindings
84305>>>>>>>>>>>>>>>>>    If (pbQuickInfo(Self)) Begin
84307>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMOUSEDWELLTIME (piQuickInfoTime(Self))
84308>>>>>>>>>>>>>>>>>    End
84308>>>>>>>>>>>>>>>>>>
84308>>>>>>>>>>>>>>>>>  End_Procedure
84309>>>>>>>>>>>>>>>>>
84309>>>>>>>>>>>>>>>>>  // Used to create the window...
84309>>>>>>>>>>>>>>>>>  Procedure Page_Object Integer iFlag
84311>>>>>>>>>>>>>>>>>    Integer iRet
84311>>>>>>>>>>>>>>>>>    Handle  hWnd
84311>>>>>>>>>>>>>>>>>    Forward Send Page_Object iFlag
84313>>>>>>>>>>>>>>>>>    If iFlag begin
84315>>>>>>>>>>>>>>>>>      If (piDragAcceptFilesState(Self)) Begin // Allow Dragging files into it.
84317>>>>>>>>>>>>>>>>>        Move (DragAcceptFiles(Window_Handle(Self),True)) to iRet
84318>>>>>>>>>>>>>>>>>      End
84318>>>>>>>>>>>>>>>>>>
84318>>>>>>>>>>>>>>>>>      Get Window_Handle to hWnd
84319>>>>>>>>>>>>>>>>>      If (hWnd<>0) Begin
84321>>>>>>>>>>>>>>>>>        Send SetAdjustments
84322>>>>>>>>>>>>>>>>>        Send ApplyEditorOptions
84323>>>>>>>>>>>>>>>>>        Send onPaged
84324>>>>>>>>>>>>>>>>>      End
84324>>>>>>>>>>>>>>>>>>
84324>>>>>>>>>>>>>>>>>    End
84324>>>>>>>>>>>>>>>>>>
84324>>>>>>>>>>>>>>>>>  End_Procedure
84325>>>>>>>>>>>>>>>>>
84325>>>>>>>>>>>>>>>>>  // Procedures for overwriting. (sent by page after Object is paged.)
84325>>>>>>>>>>>>>>>>>  Procedure SetAdjustments
84327>>>>>>>>>>>>>>>>>  End_Procedure
84328>>>>>>>>>>>>>>>>>  Procedure onPaged
84330>>>>>>>>>>>>>>>>>    // some temp code to find out defaults (to be removed)
84330>>>>>>>>>>>>>>>>>    //Integer i iCount iWidth
84330>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_GETMARGINS to iCount
84330>>>>>>>>>>>>>>>>>    //For i from 0 to (iCount-1)
84330>>>>>>>>>>>>>>>>>    //  Get EditorMessage SCI_GETMARGINWIDTHN i to iWidth
84330>>>>>>>>>>>>>>>>>    //Loop
84330>>>>>>>>>>>>>>>>>  End_Procedure
84331>>>>>>>>>>>>>>>>>
84331>>>>>>>>>>>>>>>>>  // Procedures for overwriting. (sent by copy and cut functions)
84331>>>>>>>>>>>>>>>>>  // 28.1.2003 BP
84331>>>>>>>>>>>>>>>>>  Procedure onBeforePaste
84333>>>>>>>>>>>>>>>>>  End_Procedure
84334>>>>>>>>>>>>>>>>>  Procedure onAfterPaste
84336>>>>>>>>>>>>>>>>>  End_Procedure
84337>>>>>>>>>>>>>>>>>  Procedure onBeforeCut
84339>>>>>>>>>>>>>>>>>  End_Procedure
84340>>>>>>>>>>>>>>>>>  Procedure onAfterCut
84342>>>>>>>>>>>>>>>>>  End_Procedure
84343>>>>>>>>>>>>>>>>>
84343>>>>>>>>>>>>>>>>>
84343>>>>>>>>>>>>>>>>>  //____CODEMAX_NATIVE_METHODs...___________________________________________________
84343>>>>>>>>>>>>>>>>>
84343>>>>>>>>>>>>>>>>>
84343>>>>>>>>>>>>>>>>>  //
84343>>>>>>>>>>>>>>>>>  //
84343>>>>>>>>>>>>>>>>>  Function CM_SetLanguage String sLanguage Returns Integer
84345>>>>>>>>>>>>>>>>>    String sLexer
84345>>>>>>>>>>>>>>>>>
84345>>>>>>>>>>>>>>>>>    Get ScintillaLexerForLanguage sLanguage to sLexer
84346>>>>>>>>>>>>>>>>>    Move (sLexer+Character(0)) to sLexer
84347>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETLEXERLANGUAGE 0 (AddressOf(sLexer))
84348>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84349>>>>>>>>>>>>>>>>>  End_Function
84350>>>>>>>>>>>>>>>>>
84350>>>>>>>>>>>>>>>>>  //
84350>>>>>>>>>>>>>>>>>  //
84350>>>>>>>>>>>>>>>>>  Function CM_GetLanguage Returns String
84352>>>>>>>>>>>>>>>>>    Integer iRet
84352>>>>>>>>>>>>>>>>>    String  sName
84352>>>>>>>>>>>>>>>>>    String  sLexer
84352>>>>>>>>>>>>>>>>>    String  sFileName
84352>>>>>>>>>>>>>>>>>
84352>>>>>>>>>>>>>>>>>    Get psFileName to sFileName
84353>>>>>>>>>>>>>>>>>    Move (ZeroString(250)) to sLexer
84354>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLEXERLANGUAGE 0 (AddressOf(sLexer)) to iRet
84355>>>>>>>>>>>>>>>>>    //Move "VDF" To szName
84355>>>>>>>>>>>>>>>>>    If (sLexer="cpp") Begin // cpp lexer hosts a number of languages
84357>>>>>>>>>>>>>>>>>      // use our filename extension logic instead
84357>>>>>>>>>>>>>>>>>      Get LanguageForFile of (phoIniHandler(Self)) sFileName  To sName
84358>>>>>>>>>>>>>>>>>    End
84358>>>>>>>>>>>>>>>>>>
84358>>>>>>>>>>>>>>>>>    If (sName="") Begin
84360>>>>>>>>>>>>>>>>>      Get LanguageForScintillaLexer sLexer to sName
84361>>>>>>>>>>>>>>>>>    End
84361>>>>>>>>>>>>>>>>>>
84361>>>>>>>>>>>>>>>>>    Function_Return sName
84362>>>>>>>>>>>>>>>>>  End_Function
84363>>>>>>>>>>>>>>>>>
84363>>>>>>>>>>>>>>>>>  Function CM_EnableColorSyntax Integer bEnable Returns Integer
84365>>>>>>>>>>>>>>>>>    //        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLORSYNTAX,  ( bEnable ), 0 ) )
84365>>>>>>>>>>>>>>>>>    Function_Return 0
84366>>>>>>>>>>>>>>>>>  End_Function
84367>>>>>>>>>>>>>>>>>
84367>>>>>>>>>>>>>>>>>  Function CM_IsColorSyntaxEnabled Returns Integer
84369>>>>>>>>>>>>>>>>>    //        Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLORSYNTAXENABLED, 0, 0 ) )
84369>>>>>>>>>>>>>>>>>    Function_Return 0
84370>>>>>>>>>>>>>>>>>  End_Function
84371>>>>>>>>>>>>>>>>>
84371>>>>>>>>>>>>>>>>>  Procedure onPreOpenFile String sFile
84373>>>>>>>>>>>>>>>>>  End_Procedure
84374>>>>>>>>>>>>>>>>>  Procedure onPostOpenFile String sFile
84376>>>>>>>>>>>>>>>>>  End_Procedure
84377>>>>>>>>>>>>>>>>>
84377>>>>>>>>>>>>>>>>>
84377>>>>>>>>>>>>>>>>>
84377>>>>>>>>>>>>>>>>>  Function CM_OpenFile String szFileName Returns Integer
84379>>>>>>>>>>>>>>>>>    Boolean bIsCRLF
84379>>>>>>>>>>>>>>>>>    Integer iChannel
84379>>>>>>>>>>>>>>>>>    Integer iResult
84379>>>>>>>>>>>>>>>>>    Integer iVoid
84379>>>>>>>>>>>>>>>>>    Integer iArgSize
84379>>>>>>>>>>>>>>>>>    Integer iNewArgSize
84379>>>>>>>>>>>>>>>>>    Integer iPerf
84379>>>>>>>>>>>>>>>>>    Integer iFileExists
84379>>>>>>>>>>>>>>>>>    String  sLine
84379>>>>>>>>>>>>>>>>>    String  sTextData
84379>>>>>>>>>>>>>>>>>    Address aTextData
84379>>>>>>>>>>>>>>>>>    UChar[] TextData
84380>>>>>>>>>>>>>>>>>
84380>>>>>>>>>>>>>>>>>    Send Cursor_Wait of Cursor_Control
84381>>>>>>>>>>>>>>>>>
84381>>>>>>>>>>>>>>>>>    Get StartPerfCounter of ghoApplication CPC_OpenFile szFileName to iPerf
84382>>>>>>>>>>>>>>>>>
84382>>>>>>>>>>>>>>>>>    Get vFilePathExists szFileName to iFileExists
84383>>>>>>>>>>>>>>>>>    If (iFileExists<>0) Begin
84385>>>>>>>>>>>>>>>>>
84385>>>>>>>>>>>>>>>>>      Set pbFileLoading to True
84386>>>>>>>>>>>>>>>>>      Send onPreOpenFile szFileName
84387>>>>>>>>>>>>>>>>>
84387>>>>>>>>>>>>>>>>>      Move True To bIsCRLF  // default, we are on windows
84388>>>>>>>>>>>>>>>>>      Get Seq_New_Channel to iChannel
84389>>>>>>>>>>>>>>>>>      If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84391>>>>>>>>>>>>>>>>>        Send Info_Box "No Channel Available for reading from a new file" "Error"
84392>>>>>>>>>>>>>>>>>        function_return CME_FAILURE
84393>>>>>>>>>>>>>>>>>      End
84393>>>>>>>>>>>>>>>>>>
84393>>>>>>>>>>>>>>>>>      // Need to use binary read mode if we want to preserve tab characters and not have automatic tab replacement
84393>>>>>>>>>>>>>>>>>      // First we look at the line ending of the first line for how the document is likely to be formatted.
84393>>>>>>>>>>>>>>>>>      Direct_Input channel iChannel ("binary:"+szFileName)
84395>>>>>>>>>>>>>>>>>      Readln Channel iChannel sLine
84397>>>>>>>>>>>>>>>>>      Close_Input Channel iChannel
84399>>>>>>>>>>>>>>>>>      // As we read in binary mode, the readln reads until it sees a LF, the LF is dropped from the line we
84399>>>>>>>>>>>>>>>>>      // read.
84399>>>>>>>>>>>>>>>>>      If (sLine<>"") Begin
84401>>>>>>>>>>>>>>>>>        If (Pos(CS_CR,sLine)>0) Begin  // if last char at line is CR then strip it
84403>>>>>>>>>>>>>>>>>          If (Right(sLine,1)=CS_CR) Begin
84405>>>>>>>>>>>>>>>>>            Move True To bIsCRLF
84406>>>>>>>>>>>>>>>>>          End
84406>>>>>>>>>>>>>>>>>>
84406>>>>>>>>>>>>>>>>>        End
84406>>>>>>>>>>>>>>>>>>
84406>>>>>>>>>>>>>>>>>        Else Begin
84407>>>>>>>>>>>>>>>>>          Move False To bIsCRLF
84408>>>>>>>>>>>>>>>>>        End
84408>>>>>>>>>>>>>>>>>>
84408>>>>>>>>>>>>>>>>>        Get CM_EnableCRLF bIsCRLF to iVoid
84409>>>>>>>>>>>>>>>>>      End
84409>>>>>>>>>>>>>>>>>>
84409>>>>>>>>>>>>>>>>>
84409>>>>>>>>>>>>>>>>>      //
84409>>>>>>>>>>>>>>>>>      Direct_Input channel iChannel ("binary:"+szFileName)
84411>>>>>>>>>>>>>>>>>      Read_Block Channel iChannel TextData -1
84413>>>>>>>>>>>>>>>>>      Close_Input channel iChannel
84415>>>>>>>>>>>>>>>>>
84415>>>>>>>>>>>>>>>>>      Move 0 To TextData[SizeOfArray(TextData)]  // add a zero at the end
84416>>>>>>>>>>>>>>>>>      If (pbAnsiMode(Self)) Begin
84418>>>>>>>>>>>>>>>>>        // move to a string so we can ToANSI the contents THEN move it back to the uchar array
84418>>>>>>>>>>>>>>>>>CompilerWarnings Off  // One of the few areas where you want ToANSI regardless of DF version
84418>>>>>>>>>>>>>>>>>        Get_Argument_Size to iArgSize
84419>>>>>>>>>>>>>>>>>        Move (SizeOfArray(TextData)+10) To iNewArgSize
84420>>>>>>>>>>>>>>>>>        If (iNewArgSize>iArgSize) Begin
84422>>>>>>>>>>>>>>>>>          Set_Argument_Size iNewArgSize
84423>>>>>>>>>>>>>>>>>>
84423>>>>>>>>>>>>>>>>>        End
84423>>>>>>>>>>>>>>>>>>
84423>>>>>>>>>>>>>>>>>        Move (UCharArrayToString(TextData,SizeOfArray(TextData))) To sTextData
84424>>>>>>>>>>>>>>>>>        Move (ToANSI(sTextData)) To sTextData
84425>>>>>>>>>>>>>>>>>        Move (StringToUCharArray(sTextData)) To TextData
84426>>>>>>>>>>>>>>>>>        Move "" To sTextData
84427>>>>>>>>>>>>>>>>>        If (iNewArgSize>iArgSize) Begin
84429>>>>>>>>>>>>>>>>>          Set_Argument_Size iArgSize
84430>>>>>>>>>>>>>>>>>>
84430>>>>>>>>>>>>>>>>>        End
84430>>>>>>>>>>>>>>>>>>
84430>>>>>>>>>>>>>>>>>CompilerWarnings On
84430>>>>>>>>>>>>>>>>>      End
84430>>>>>>>>>>>>>>>>>>
84430>>>>>>>>>>>>>>>>>      Move (AddressOf(TextData)) To aTextData
84431>>>>>>>>>>>>>>>>>      Send Seq_Release_Channel iChannel
84432>>>>>>>>>>>>>>>>>
84432>>>>>>>>>>>>>>>>>      // SCI_SETTEXT(<unused>, const char *text)
84432>>>>>>>>>>>>>>>>>      If (aTextData<>0) Begin
84434>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETTEXT 0 aTextData
84435>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_EMPTYUNDOBUFFER
84436>>>>>>>>>>>>>>>>>      End
84436>>>>>>>>>>>>>>>>>>
84436>>>>>>>>>>>>>>>>>      Move CME_SUCCESS to iResult
84437>>>>>>>>>>>>>>>>>
84437>>>>>>>>>>>>>>>>>      Send onPostOpenFile szFileName
84438>>>>>>>>>>>>>>>>>      Set pbFileLoading to False
84439>>>>>>>>>>>>>>>>>    End
84439>>>>>>>>>>>>>>>>>>
84439>>>>>>>>>>>>>>>>>    Else Begin
84440>>>>>>>>>>>>>>>>>      Error DfErr_Operator ("File"*szFileName*"cannot be found.")
84441>>>>>>>>>>>>>>>>>>
84441>>>>>>>>>>>>>>>>>    End
84441>>>>>>>>>>>>>>>>>>
84441>>>>>>>>>>>>>>>>>
84441>>>>>>>>>>>>>>>>>    Send StopPerfCounter of ghoApplication iPerf
84442>>>>>>>>>>>>>>>>>
84442>>>>>>>>>>>>>>>>>    Send Cursor_Ready of Cursor_Control
84443>>>>>>>>>>>>>>>>>
84443>>>>>>>>>>>>>>>>>    Function_Return iResult
84444>>>>>>>>>>>>>>>>>  End_Function
84445>>>>>>>>>>>>>>>>>
84445>>>>>>>>>>>>>>>>>  Function CM_InsertText String szText Integer iLine Integer iCol Returns Integer
84447>>>>>>>>>>>>>>>>>    Integer iStartPos
84447>>>>>>>>>>>>>>>>>    Integer iRet
84447>>>>>>>>>>>>>>>>>    String  sBuffer
84447>>>>>>>>>>>>>>>>>    //
84447>>>>>>>>>>>>>>>>>    Move (szText+Character(0)) To sBuffer
84448>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
84449>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_INSERTTEXT iStartPos (AddressOf(sBuffer)) to iRet
84450>>>>>>>>>>>>>>>>>    Move CME_SUCCESS To iRet
84451>>>>>>>>>>>>>>>>>    Function_Return iRet
84452>>>>>>>>>>>>>>>>>  End_Function
84453>>>>>>>>>>>>>>>>>
84453>>>>>>>>>>>>>>>>>  // **WvA 23-07-2003 Modified to fix a crash
84453>>>>>>>>>>>>>>>>>  // Quickly changing workspaces caused the window_handle to
84453>>>>>>>>>>>>>>>>>  // be zero. Sending a message to a window with address 0 is fatal.
84453>>>>>>>>>>>>>>>>>  Function CM_SetText String szText Returns Integer
84455>>>>>>>>>>>>>>>>>    Integer hoWnd iRetVal
84455>>>>>>>>>>>>>>>>>    String  sBuffer
84455>>>>>>>>>>>>>>>>>    Get Window_Handle to hoWnd
84456>>>>>>>>>>>>>>>>>    If (hoWnd) Begin
84458>>>>>>>>>>>>>>>>>      Move (szText+Character(0)) To sBuffer
84459>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_SETTEXT 0 (AddressOf(sBuffer)) to iRetVal
84460>>>>>>>>>>>>>>>>>      Move CME_SUCCESS To iRetVal
84461>>>>>>>>>>>>>>>>>    End
84461>>>>>>>>>>>>>>>>>>
84461>>>>>>>>>>>>>>>>>    Else Begin
84462>>>>>>>>>>>>>>>>>      Send Info_Box "Windows handle is ZXRO"
84463>>>>>>>>>>>>>>>>>      Move CME_FAILURE to iRetVal
84464>>>>>>>>>>>>>>>>>    End
84464>>>>>>>>>>>>>>>>>>
84464>>>>>>>>>>>>>>>>>    Function_Return iRetVal
84465>>>>>>>>>>>>>>>>>  End_Function
84466>>>>>>>>>>>>>>>>>
84466>>>>>>>>>>>>>>>>>  Function CM_EnableWhitespaceDisplay Integer bEnable Returns Integer
84468>>>>>>>>>>>>>>>>>    Integer iRet
84468>>>>>>>>>>>>>>>>>    Integer eStyle
84468>>>>>>>>>>>>>>>>>    If (bEnable) Begin
84470>>>>>>>>>>>>>>>>>      Move SCWS_VISIBLEALWAYS To eStyle
84471>>>>>>>>>>>>>>>>>    End
84471>>>>>>>>>>>>>>>>>>
84471>>>>>>>>>>>>>>>>>    Else Begin
84472>>>>>>>>>>>>>>>>>      Move SCWS_INVISIBLE To eStyle
84473>>>>>>>>>>>>>>>>>    End
84473>>>>>>>>>>>>>>>>>>
84473>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETVIEWWS eStyle to iRet
84474>>>>>>>>>>>>>>>>>    Set DisplayEOLCharacters to eStyle
84475>>>>>>>>>>>>>>>>>    Function_Return iRet
84476>>>>>>>>>>>>>>>>>  End_Function
84477>>>>>>>>>>>>>>>>>
84477>>>>>>>>>>>>>>>>>  Function CM_IsWhitespaceDisplayEnabled Returns Integer
84479>>>>>>>>>>>>>>>>>    Boolean bEnabled
84479>>>>>>>>>>>>>>>>>    Integer eStyle
84479>>>>>>>>>>>>>>>>>
84479>>>>>>>>>>>>>>>>>    Move False to bEnabled
84480>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETVIEWWS to eStyle
84481>>>>>>>>>>>>>>>>>    If (eStyle<>SCWS_INVISIBLE) Begin
84483>>>>>>>>>>>>>>>>>      Move True To bEnabled
84484>>>>>>>>>>>>>>>>>    End
84484>>>>>>>>>>>>>>>>>>
84484>>>>>>>>>>>>>>>>>    Function_Return bEnabled
84485>>>>>>>>>>>>>>>>>  End_Function
84486>>>>>>>>>>>>>>>>>
84486>>>>>>>>>>>>>>>>>  Procedure ShowIndentationGuides
84488>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
84489>>>>>>>>>>>>>>>>>  End_Procedure
84490>>>>>>>>>>>>>>>>>  Function CM_IsIndentationGuidesEnabled Returns Integer
84492>>>>>>>>>>>>>>>>>    Integer eStyle
84492>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETINDENTATIONGUIDES to eStyle
84493>>>>>>>>>>>>>>>>>    Function_Return eStyle
84494>>>>>>>>>>>>>>>>>  End_Function
84495>>>>>>>>>>>>>>>>>  Procedure ToggleIndentationGuides
84497>>>>>>>>>>>>>>>>>    Integer eStyle
84497>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETINDENTATIONGUIDES to eStyle
84498>>>>>>>>>>>>>>>>>    If (eStyle) ;      Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_NONE
84501>>>>>>>>>>>>>>>>>    Else ;      Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
84503>>>>>>>>>>>>>>>>>  End_Procedure
84504>>>>>>>>>>>>>>>>>    
84504>>>>>>>>>>>>>>>>>  Procedure ToggleScopeBlocks Integer iMode
84506>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_FOLDALL iMode
84507>>>>>>>>>>>>>>>>>  End_Procedure
84508>>>>>>>>>>>>>>>>>    
84508>>>>>>>>>>>>>>>>>  Function LineHasFoldPoint Integer iLine Returns Boolean
84510>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
84510>>>>>>>>>>>>>>>>>    Integer uFoldLevel
84510>>>>>>>>>>>>>>>>>      
84510>>>>>>>>>>>>>>>>>    Move False To bFoldPoint
84511>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel
84512>>>>>>>>>>>>>>>>>    Move ((uFoldLevel iAnd SC_FOLDLEVELHEADERFLAG)=SC_FOLDLEVELHEADERFLAG) To bFoldPoint
84513>>>>>>>>>>>>>>>>>    Function_Return bFoldPoint
84514>>>>>>>>>>>>>>>>>  End_Function
84515>>>>>>>>>>>>>>>>>    
84515>>>>>>>>>>>>>>>>>  Procedure CodeFoldOnScope String sScope Integer eMode
84517>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
84517>>>>>>>>>>>>>>>>>    Integer iCurrentLine
84517>>>>>>>>>>>>>>>>>    Integer iLine
84517>>>>>>>>>>>>>>>>>    Integer iLineCount
84517>>>>>>>>>>>>>>>>>    Integer iScopeLength
84517>>>>>>>>>>>>>>>>>    String  sLine
84517>>>>>>>>>>>>>>>>>        
84517>>>>>>>>>>>>>>>>>    Get CurrentLine To iCurrentLine
84518>>>>>>>>>>>>>>>>>    Move (Length(sScope)) to iScopeLength
84519>>>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
84520>>>>>>>>>>>>>>>>>    Move (iLineCount-1) To iLine
84521>>>>>>>>>>>>>>>>>    While (iLine>0)
84525>>>>>>>>>>>>>>>>>      If ((iLineCount-1)>iLine) Begin
84527>>>>>>>>>>>>>>>>>        Send GotoLine (iLine+1) // the line has to be visible in order to be able to get the fold level
84528>>>>>>>>>>>>>>>>>      End
84528>>>>>>>>>>>>>>>>>>
84528>>>>>>>>>>>>>>>>>      Get LineHasFoldPoint iLine To bFoldPoint
84529>>>>>>>>>>>>>>>>>      If (bFoldPoint) Begin
84531>>>>>>>>>>>>>>>>>        Get Value Item iLine To sLine
84532>>>>>>>>>>>>>>>>>        Move (lowercase(ltrim(sLine))) To sLine
84533>>>>>>>>>>>>>>>>>        If (Left(sLine,iScopeLength)=sScope) Begin
84535>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_FOLDLINE iLine eMode
84536>>>>>>>>>>>>>>>>>          //Send EditorMessage SCI_SETFOLDEXPANDED iLine (Not(bFold))
84536>>>>>>>>>>>>>>>>>        End
84536>>>>>>>>>>>>>>>>>>
84536>>>>>>>>>>>>>>>>>      End
84536>>>>>>>>>>>>>>>>>>
84536>>>>>>>>>>>>>>>>>      Decrement iLine
84537>>>>>>>>>>>>>>>>>    Loop
84538>>>>>>>>>>>>>>>>>>
84538>>>>>>>>>>>>>>>>>    If (iCurrentLine<iLineCount) Begin
84540>>>>>>>>>>>>>>>>>      Send GotoLine iCurrentLine
84541>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_ENSUREVISIBLE iCurrentLine
84542>>>>>>>>>>>>>>>>>    End
84542>>>>>>>>>>>>>>>>>>
84542>>>>>>>>>>>>>>>>>  End_Procedure
84543>>>>>>>>>>>>>>>>>    
84543>>>>>>>>>>>>>>>>>  Procedure CodeCollapseProcedures
84545>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "procedure " SC_FOLDACTION_CONTRACT
84546>>>>>>>>>>>>>>>>>  End_Procedure
84547>>>>>>>>>>>>>>>>>    
84547>>>>>>>>>>>>>>>>>  Procedure CodeExpandProcedures
84549>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "procedure " SC_FOLDACTION_EXPAND
84550>>>>>>>>>>>>>>>>>  End_Procedure
84551>>>>>>>>>>>>>>>>>    
84551>>>>>>>>>>>>>>>>>  Procedure CodeCollapseFunctions
84553>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "function " SC_FOLDACTION_CONTRACT
84554>>>>>>>>>>>>>>>>>  End_Procedure
84555>>>>>>>>>>>>>>>>>    
84555>>>>>>>>>>>>>>>>>  Procedure CodeExpandFunctions
84557>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "function " SC_FOLDACTION_EXPAND
84558>>>>>>>>>>>>>>>>>  End_Procedure
84559>>>>>>>>>>>>>>>>>    
84559>>>>>>>>>>>>>>>>>  Procedure CodeCollapseObjects
84561>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "object " SC_FOLDACTION_CONTRACT
84562>>>>>>>>>>>>>>>>>  End_Procedure
84563>>>>>>>>>>>>>>>>>    
84563>>>>>>>>>>>>>>>>>  Procedure CodeExpandObjects
84565>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "object " SC_FOLDACTION_EXPAND
84566>>>>>>>>>>>>>>>>>  End_Procedure
84567>>>>>>>>>>>>>>>>>    
84567>>>>>>>>>>>>>>>>>  Procedure CodeCollapseClasses
84569>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "class " SC_FOLDACTION_CONTRACT
84570>>>>>>>>>>>>>>>>>  End_Procedure
84571>>>>>>>>>>>>>>>>>    
84571>>>>>>>>>>>>>>>>>  Procedure CodeExpandClasses
84573>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "class " SC_FOLDACTION_EXPAND
84574>>>>>>>>>>>>>>>>>  End_Procedure
84575>>>>>>>>>>>>>>>>>    
84575>>>>>>>>>>>>>>>>>  Procedure CodeCollapseLineComments
84577>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "//" SC_FOLDACTION_CONTRACT
84578>>>>>>>>>>>>>>>>>  End_Procedure
84579>>>>>>>>>>>>>>>>>    
84579>>>>>>>>>>>>>>>>>  Procedure CodeExpandLineComments
84581>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "//" SC_FOLDACTION_EXPAND
84582>>>>>>>>>>>>>>>>>  End_Procedure
84583>>>>>>>>>>>>>>>>>
84583>>>>>>>>>>>>>>>>>  Procedure SelectTillEndOfLine Integer iMode
84585>>>>>>>>>>>>>>>>>    Integer iVirtualSpace
84585>>>>>>>>>>>>>>>>>    Boolean bBlockEdit
84585>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETSELEOLFILLED iMode
84586>>>>>>>>>>>>>>>>>    Move SCVS_NONE to iVirtualSpace
84587>>>>>>>>>>>>>>>>>    Move False     to bBlockEdit
84588>>>>>>>>>>>>>>>>>    If (iMode) Begin
84590>>>>>>>>>>>>>>>>>      Move (SCVS_RECTANGULARSELECTION+SCVS_USERACCESSIBLE) to iVirtualSpace
84591>>>>>>>>>>>>>>>>>      Move True To bBlockEdit
84592>>>>>>>>>>>>>>>>>    End
84592>>>>>>>>>>>>>>>>>>
84592>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETVIRTUALSPACEOPTIONS iVirtualSpace
84593>>>>>>>>>>>>>>>>>    // This supposedly supports blockedit as in codemax, but it is extremely buggy, let's roll it ourself.
84593>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETADDITIONALSELECTIONTYPING bBlockEdit
84594>>>>>>>>>>>>>>>>>  End_Procedure
84595>>>>>>>>>>>>>>>>>
84595>>>>>>>>>>>>>>>>>  Function CM_EnableTabExpand Integer bEnable  Returns Integer
84597>>>>>>>>>>>>>>>>>    Integer iRet
84597>>>>>>>>>>>>>>>>>    // bEnable = tabs change into spaces
84597>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETUSETABS (not(bEnable)) to iRet
84598>>>>>>>>>>>>>>>>>    Function_Return iRet
84599>>>>>>>>>>>>>>>>>  End_Function
84600>>>>>>>>>>>>>>>>>  Function CM_IsTabExpandEnabled Returns Integer
84602>>>>>>>>>>>>>>>>>    Boolean bUseTabs
84602>>>>>>>>>>>>>>>>>
84602>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS to bUseTabs
84603>>>>>>>>>>>>>>>>>    Function_Return (not(bUseTabs))
84604>>>>>>>>>>>>>>>>>  End_Function
84605>>>>>>>>>>>>>>>>>
84605>>>>>>>>>>>>>>>>>  Function CM_SetTabSize Integer iTabSize Returns Integer
84607>>>>>>>>>>>>>>>>>
84607>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETTABWIDTH iTabSize
84608>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84609>>>>>>>>>>>>>>>>>  End_Function
84610>>>>>>>>>>>>>>>>>
84610>>>>>>>>>>>>>>>>>  Function CM_GetTabSize Returns Integer
84612>>>>>>>>>>>>>>>>>    Integer iSize
84612>>>>>>>>>>>>>>>>>
84612>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH To iSize
84613>>>>>>>>>>>>>>>>>    Function_Return iSize
84614>>>>>>>>>>>>>>>>>  End_Function
84615>>>>>>>>>>>>>>>>>
84615>>>>>>>>>>>>>>>>>  Function CM_SetReadOnly Integer bReadOnly Returns Integer
84617>>>>>>>>>>>>>>>>>
84617>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETREADONLY bReadOnly
84618>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84619>>>>>>>>>>>>>>>>>  End_Function
84620>>>>>>>>>>>>>>>>>
84620>>>>>>>>>>>>>>>>>  Procedure Set Enabled_State Boolean bEnabled
84622>>>>>>>>>>>>>>>>>    Integer iRet
84622>>>>>>>>>>>>>>>>>    Get CM_SetReadOnly (not(bEnabled)) to iRet
84623>>>>>>>>>>>>>>>>>  End_Procedure
84624>>>>>>>>>>>>>>>>>
84624>>>>>>>>>>>>>>>>>  Function CM_IsReadOnly Returns Integer
84626>>>>>>>>>>>>>>>>>    Boolean bReadOnly
84626>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETREADONLY To bReadOnly
84627>>>>>>>>>>>>>>>>>    Function_Return bReadOnly
84628>>>>>>>>>>>>>>>>>  End_Function
84629>>>>>>>>>>>>>>>>>
84629>>>>>>>>>>>>>>>>>  // Does not exist in scintilla
84629>>>>>>>>>>>>>>>>>  //
84629>>>>>>>>>>>>>>>>>  // Line tooltips are:
84629>>>>>>>>>>>>>>>>>  // enable or disable the display of a tooltip window showing the topmost visible line number while scrolling with the vertical scrollbar
84629>>>>>>>>>>>>>>>>>  //    Function CM_EnableLineToolTips Integer bEnable Returns Integer
84629>>>>>>>>>>>>>>>>>  //    Function CM_IsLineToolTipsEnabled Returns Integer
84629>>>>>>>>>>>>>>>>>
84629>>>>>>>>>>>>>>>>>  // codemax: CMM_ENABLELEFTMARGIN
84629>>>>>>>>>>>>>>>>>  // show or hide the left margin display area. The left margin area is used for line selection and the display of bookmarks.
84629>>>>>>>>>>>>>>>>>  // scintilla has 5 margins, by default only margin 1 is set to 20 pixels, we keep it simple for now and
84629>>>>>>>>>>>>>>>>>  // pretend we only have 1 margin. (MARGIN_CODE_FOLDING=1)
84629>>>>>>>>>>>>>>>>>  Function CM_EnableLeftMargin Integer bEnable Returns Integer
84631>>>>>>>>>>>>>>>>>    Integer iWidth
84631>>>>>>>>>>>>>>>>>    If (bEnable) Begin
84633>>>>>>>>>>>>>>>>>      Move 20 To iWidth
84634>>>>>>>>>>>>>>>>>    End
84634>>>>>>>>>>>>>>>>>>
84634>>>>>>>>>>>>>>>>>    Else Begin
84635>>>>>>>>>>>>>>>>>      Move 0 To iWidth
84636>>>>>>>>>>>>>>>>>    End
84636>>>>>>>>>>>>>>>>>>
84636>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING iWidth
84637>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84638>>>>>>>>>>>>>>>>>  End_Function
84639>>>>>>>>>>>>>>>>>  Function CM_IsLeftMarginEnabled Returns Integer
84641>>>>>>>>>>>>>>>>>    Integer iWidth
84641>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_CODE_FOLDING to iWidth
84642>>>>>>>>>>>>>>>>>    Function_Return (iWidth<>0)
84643>>>>>>>>>>>>>>>>>  End_Function
84644>>>>>>>>>>>>>>>>>
84644>>>>>>>>>>>>>>>>>  Procedure Set DisplayEOLCharacters Boolean bEnabled
84646>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETVIEWEOL   bEnabled               // show end of line characters
84647>>>>>>>>>>>>>>>>>  End_Procedure
84648>>>>>>>>>>>>>>>>>
84648>>>>>>>>>>>>>>>>>  Function DisplayEOLCharacters Returns Boolean
84650>>>>>>>>>>>>>>>>>    Boolean bEnabled
84650>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETVIEWEOL to bEnabled
84651>>>>>>>>>>>>>>>>>    Function_Return bEnabled
84652>>>>>>>>>>>>>>>>>  End_Function
84653>>>>>>>>>>>>>>>>>
84653>>>>>>>>>>>>>>>>>  Procedure WriteBlock Integer iChannel Address aTextData Integer iPosition Integer iBlockSize
84655>>>>>>>>>>>>>>>>>    Boolean bOk
84655>>>>>>>>>>>>>>>>>    String  sBlock
84655>>>>>>>>>>>>>>>>>
84655>>>>>>>>>>>>>>>>>    Move ""   To sBlock
84656>>>>>>>>>>>>>>>>>    Move (ZeroString(iBlockSize)) To sBlock
84657>>>>>>>>>>>>>>>>>    Move (memcopy(AddressOf(sBlock), aTextData+iPosition, iBlockSize)) To bOk
84658>>>>>>>>>>>>>>>>>    If (pbAnsiMode(Self)) Begin
84660>>>>>>>>>>>>>>>>>CompilerWarnings Off  // One of the few areas where you want ToANSI regardless of DF version
84660>>>>>>>>>>>>>>>>>      // By SVN on 23/05/2017 -- National Languages support
84660>>>>>>>>>>>>>>>>>      Write Channel iChannel (ToOEM(sBlock))
84662>>>>>>>>>>>>>>>>>CompilerWarnings On
84662>>>>>>>>>>>>>>>>>    End
84662>>>>>>>>>>>>>>>>>>
84662>>>>>>>>>>>>>>>>>    Else Begin
84663>>>>>>>>>>>>>>>>>      Write Channel iChannel sBlock
84665>>>>>>>>>>>>>>>>>    End
84665>>>>>>>>>>>>>>>>>>
84665>>>>>>>>>>>>>>>>>  End_Procedure
84666>>>>>>>>>>>>>>>>>
84666>>>>>>>>>>>>>>>>>  // An application sends CMM_SAVEFILE to save the buffer contents to a specific file.
84666>>>>>>>>>>>>>>>>>  // bClearUndo
84666>>>>>>>>>>>>>>>>>  // If TRUE, the undo buffer is cleared if the file is successfully saved.
84666>>>>>>>>>>>>>>>>>  // If FALSE, the undo buffer is untouched and the user can undo past the last file save operation.
84666>>>>>>>>>>>>>>>>>  //CME_SUCCESS=1
84666>>>>>>>>>>>>>>>>>  Function CM_SaveFile String szFileName Integer bClearUndo  Returns Integer
84668>>>>>>>>>>>>>>>>>    Integer iBlockSize
84668>>>>>>>>>>>>>>>>>    Integer iChannel
84668>>>>>>>>>>>>>>>>>    Integer iPosition
84668>>>>>>>>>>>>>>>>>    Integer iResult
84668>>>>>>>>>>>>>>>>>    Address aTextData
84668>>>>>>>>>>>>>>>>>    Integer iTextLength
84668>>>>>>>>>>>>>>>>>
84668>>>>>>>>>>>>>>>>>    Send Cursor_Wait of Cursor_Control
84669>>>>>>>>>>>>>>>>>    Move 0    To iPosition
84670>>>>>>>>>>>>>>>>>    Move 1024 To iBlockSize
84671>>>>>>>>>>>>>>>>>    Move True To bClearUndo // looks like this was ignored by codemax and always true
84672>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETREADONLY 1
84673>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCHARACTERPOINTER to aTextData
84674>>>>>>>>>>>>>>>>>    Move (CStringLength(aTextData)) To iTextLength
84675>>>>>>>>>>>>>>>>>    If (iTextLength>=0) Begin
84677>>>>>>>>>>>>>>>>>
84677>>>>>>>>>>>>>>>>>      Get Seq_New_Channel to iChannel
84678>>>>>>>>>>>>>>>>>      If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84680>>>>>>>>>>>>>>>>>        Send Info_Box "No Channel Available for saving file" "Error"
84681>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETREADONLY 0
84682>>>>>>>>>>>>>>>>>        function_return CME_FAILURE
84683>>>>>>>>>>>>>>>>>      End
84683>>>>>>>>>>>>>>>>>>
84683>>>>>>>>>>>>>>>>>
84683>>>>>>>>>>>>>>>>>      Direct_Output channel iChannel szFileName
84685>>>>>>>>>>>>>>>>>      While ((iPosition+iBlockSize)<iTextLength)
84689>>>>>>>>>>>>>>>>>        Send WriteBlock iChannel aTextData iPosition iBlockSize
84690>>>>>>>>>>>>>>>>>
84690>>>>>>>>>>>>>>>>>        Move (iPosition+iBlockSize) To iPosition
84691>>>>>>>>>>>>>>>>>      Loop
84692>>>>>>>>>>>>>>>>>>
84692>>>>>>>>>>>>>>>>>      If (iPosition<iTextLength) Begin
84694>>>>>>>>>>>>>>>>>        Send WriteBlock iChannel aTextData iPosition (iTextLength-iPosition)
84695>>>>>>>>>>>>>>>>>      End
84695>>>>>>>>>>>>>>>>>>
84695>>>>>>>>>>>>>>>>>      Close_Output Channel iChannel
84697>>>>>>>>>>>>>>>>>      Send Seq_Release_Channel iChannel
84698>>>>>>>>>>>>>>>>>
84698>>>>>>>>>>>>>>>>>      If (bClearUndo) Begin
84700>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSAVEPOINT
84701>>>>>>>>>>>>>>>>>      End
84701>>>>>>>>>>>>>>>>>>
84701>>>>>>>>>>>>>>>>>
84701>>>>>>>>>>>>>>>>>      Move CME_SUCCESS To iResult
84702>>>>>>>>>>>>>>>>>    End
84702>>>>>>>>>>>>>>>>>>
84702>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETREADONLY 0
84703>>>>>>>>>>>>>>>>>    Send Cursor_Ready of Cursor_Control
84704>>>>>>>>>>>>>>>>>    Function_Return iResult
84705>>>>>>>>>>>>>>>>>  End_Function
84706>>>>>>>>>>>>>>>>>
84706>>>>>>>>>>>>>>>>>  // This returns the number of lines in the document.
84706>>>>>>>>>>>>>>>>>  // An empty document contains 1 line.
84706>>>>>>>>>>>>>>>>>  // A document holding only an end of line sequence has 2 lines.
84706>>>>>>>>>>>>>>>>>  Function SC_LineCount Returns Integer
84708>>>>>>>>>>>>>>>>>    Integer iLineCount
84708>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINECOUNT to iLineCount
84709>>>>>>>>>>>>>>>>>    Function_Return iLineCount
84710>>>>>>>>>>>>>>>>>  End_Function
84711>>>>>>>>>>>>>>>>>
84711>>>>>>>>>>>>>>>>>  // An application sends CMM_GETLINELENGTH to determine the length of a specific line in the edit buffer
84711>>>>>>>>>>>>>>>>>  // nLine
84711>>>>>>>>>>>>>>>>>  // The zero-based index of the line to retrieve the length of.
84711>>>>>>>>>>>>>>>>>  // bLogical
84711>>>>>>>>>>>>>>>>>  // TRUE to return the number of logical characters. FALSE to return the number of bytes (or double-bytes if Unicode version used).
84711>>>>>>>>>>>>>>>>>  // SCI_LINELENGTH returns bytes, we ignore bLogical
84711>>>>>>>>>>>>>>>>>  Function CM_GetLineLength Integer iLine Integer bLogical Returns Integer
84713>>>>>>>>>>>>>>>>>    Integer iLineLength
84713>>>>>>>>>>>>>>>>>    Integer iEOLPos
84713>>>>>>>>>>>>>>>>>    Integer iStartPos
84713>>>>>>>>>>>>>>>>>    // SCI_LINELENGTH also counts the EOL characters, not always handy
84713>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_LINELENGTH iLine to iLineLength
84713>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINEENDPOSITION iLine to iEOLPos
84714>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iStartPos
84715>>>>>>>>>>>>>>>>>    Move (iEOLPos-iStartPos) To iLineLength
84716>>>>>>>>>>>>>>>>>    Function_Return iLineLength
84717>>>>>>>>>>>>>>>>>  End_Function
84718>>>>>>>>>>>>>>>>>
84718>>>>>>>>>>>>>>>>>  // An application sends CMM_GETLINE to retrieve the text on a specific line.
84718>>>>>>>>>>>>>>>>>  // nLine - The zero-based line number of the line text to retrieve. nLine must be the index of a valid line number.
84718>>>>>>>>>>>>>>>>>  // The number of lines in the buffer can be determined with CMM_GETLINECOUNT.
84718>>>>>>>>>>>>>>>>>  // pszBuff - A pointer to a TCHAR buffer where to receive the line text.
84718>>>>>>>>>>>>>>>>>  // The necessary buffer size can be determined by first sending CMM_GETLINELENGTH. pszBuff must not be NULL.
84718>>>>>>>>>>>>>>>>>  Function CM_GetLine Integer iLine Returns String
84720>>>>>>>>>>>>>>>>>    Integer iEOLPos
84720>>>>>>>>>>>>>>>>>    Integer iStartPos
84720>>>>>>>>>>>>>>>>>    Integer iLineLength
84720>>>>>>>>>>>>>>>>>    Integer iRet
84720>>>>>>>>>>>>>>>>>    String  sBuffer
84720>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
84720>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
84720>>>>>>>>>>>>>>>>>
84720>>>>>>>>>>>>>>>>>    // Can't use sci_linelength and sci_getline as we need the text without EOL characters
84720>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_LINELENGTH iLine to iLineLength
84720>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) to iRet
84720>>>>>>>>>>>>>>>>>    Move "" To sBuffer
84721>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iStartPos
84722>>>>>>>>>>>>>>>>>    If (iStartPos>-1) Begin
84724>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETLINEENDPOSITION iLine to iEOLPos
84725>>>>>>>>>>>>>>>>>      Move (iEOLPos-iStartPos) To iLineLength
84726>>>>>>>>>>>>>>>>>      If (iLineLength<>0) Begin
84728>>>>>>>>>>>>>>>>>        Move iStartPos To Sel.chrg.cpMin
84729>>>>>>>>>>>>>>>>>        Move iEOLPos   To Sel.chrg.cpMax
84730>>>>>>>>>>>>>>>>>        Move (ZeroString(iLineLength+1)) To sBuffer
84731>>>>>>>>>>>>>>>>>        Move (AddressOf(sBuffer)) To Sel.lpstrText
84732>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
84733>>>>>>>>>>>>>>>>>        Move (CString(sBuffer)) To sBuffer
84734>>>>>>>>>>>>>>>>>      End
84734>>>>>>>>>>>>>>>>>>
84734>>>>>>>>>>>>>>>>>    End
84734>>>>>>>>>>>>>>>>>>
84734>>>>>>>>>>>>>>>>>    Function_Return sBuffer
84735>>>>>>>>>>>>>>>>>  End_Function
84736>>>>>>>>>>>>>>>>>
84736>>>>>>>>>>>>>>>>>  //
84736>>>>>>>>>>>>>>>>>  // This gets the complete line including the EOL character(s) of that line
84736>>>>>>>>>>>>>>>>>  //
84736>>>>>>>>>>>>>>>>>  Function SC_GetLine Integer iLine Returns String
84738>>>>>>>>>>>>>>>>>    Integer iLineLength
84738>>>>>>>>>>>>>>>>>    Integer iRet
84738>>>>>>>>>>>>>>>>>    String  sLine
84738>>>>>>>>>>>>>>>>>    String  szText
84738>>>>>>>>>>>>>>>>>
84738>>>>>>>>>>>>>>>>>    Move "" to szText
84739>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
84740>>>>>>>>>>>>>>>>>    Move (ZeroString(iLineLength)) To szText
84741>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) To iRet
84742>>>>>>>>>>>>>>>>>    Move (CString(szText)) To sLine
84743>>>>>>>>>>>>>>>>>    Function_Return sLine
84744>>>>>>>>>>>>>>>>>  End_Function
84745>>>>>>>>>>>>>>>>>
84745>>>>>>>>>>>>>>>>>  //
84745>>>>>>>>>>>>>>>>>  // An application sends CMM_GETWORDLENGTH to calculate the length of the word at a specific position in the buffer.
84745>>>>>>>>>>>>>>>>>  // pPos
84745>>>>>>>>>>>>>>>>>  // Pointer to a CM_POSITION structure that contains the buffer position of the word to be retrieved.
84745>>>>>>>>>>>>>>>>>  // If NULL, the current caret position is used.
84745>>>>>>>>>>>>>>>>>  // The hammer ONLY uses it internally in CM_GetWord, so we discard it and add it directly to
84745>>>>>>>>>>>>>>>>>  // CM_GetWord.
84745>>>>>>>>>>>>>>>>>  //Function CM_GetWordLength Integer pPos Integer bLogical Returns Integer
84745>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETWORDLENGTH,  ( pPos ), ( bLogical ) ) )
84745>>>>>>>>>>>>>>>>>  //End_Function
84745>>>>>>>>>>>>>>>>>
84745>>>>>>>>>>>>>>>>>  // An application sends CMM_GETWORD to retrieve the word at a specific position in the buffer.
84745>>>>>>>>>>>>>>>>>  Function CM_GetWord Integer iLine Integer iCol Returns String
84747>>>>>>>>>>>>>>>>>    Integer iPos
84747>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
84747>>>>>>>>>>>>>>>>>    Integer iRet iSize
84747>>>>>>>>>>>>>>>>>    String  sBuffer
84747>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
84747>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
84747>>>>>>>>>>>>>>>>>
84747>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
84748>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_WORDSTARTPOSITION iPos True to iStartPos
84749>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_WORDENDPOSITION   iPos True to iEndPos
84750>>>>>>>>>>>>>>>>>    If (iStartPos>=0 and iStartPos<>iEndPos) Begin
84752>>>>>>>>>>>>>>>>>      Move iStartPos To Sel.chrg.cpMin
84753>>>>>>>>>>>>>>>>>      Move iEndPos   To Sel.chrg.cpMax
84754>>>>>>>>>>>>>>>>>      Move ((iEndPos-iStartPos)+2) To iSize
84755>>>>>>>>>>>>>>>>>      Move (ZeroString(iSize)) To sBuffer
84756>>>>>>>>>>>>>>>>>      Move (AddressOf(sBuffer)) To Sel.lpstrText
84757>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
84758>>>>>>>>>>>>>>>>>      Move (CString(sBuffer)) To sBuffer
84759>>>>>>>>>>>>>>>>>    End
84759>>>>>>>>>>>>>>>>>>
84759>>>>>>>>>>>>>>>>>    Else Begin
84760>>>>>>>>>>>>>>>>>      Move "" To sBuffer
84761>>>>>>>>>>>>>>>>>    End
84761>>>>>>>>>>>>>>>>>>
84761>>>>>>>>>>>>>>>>>    Function_Return sBuffer
84762>>>>>>>>>>>>>>>>>  End_Function
84763>>>>>>>>>>>>>>>>>  // Gets the current word in a code max way.
84763>>>>>>>>>>>>>>>>>  Function CM_GetCurrentWord Returns String
84765>>>>>>>>>>>>>>>>>    String  sWord
84765>>>>>>>>>>>>>>>>>    Integer iRet
84765>>>>>>>>>>>>>>>>>    Get CM_GetSel False                                         to iRet
84766>>>>>>>>>>>>>>>>>    Get CM_GetWord (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
84767>>>>>>>>>>>>>>>>>    Function_Return sWord
84768>>>>>>>>>>>>>>>>>  End_Function
84769>>>>>>>>>>>>>>>>>
84769>>>>>>>>>>>>>>>>>  // Selfmade word getter, which doesnt stop the word on a "."
84769>>>>>>>>>>>>>>>>>  // So its easy to use it for getting a file under cursor.
84769>>>>>>>>>>>>>>>>>  Function CM_GetWordIncludingDot Integer iLine Integer iCol Returns String
84771>>>>>>>>>>>>>>>>>    Integer iStart iEnd iLen iC
84771>>>>>>>>>>>>>>>>>    String sLine
84771>>>>>>>>>>>>>>>>>    Get value item iLine    to sLine
84772>>>>>>>>>>>>>>>>>    Move (Length(sLine))    to iLen
84773>>>>>>>>>>>>>>>>>    For iEnd from (iCol+1) to iLen
84779>>>>>>>>>>>>>>>>>>
84779>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iEnd)) Eq " " Break
84782>>>>>>>>>>>>>>>>>    Loop
84783>>>>>>>>>>>>>>>>>>
84783>>>>>>>>>>>>>>>>>    For iC from 1 to iCol
84789>>>>>>>>>>>>>>>>>>
84789>>>>>>>>>>>>>>>>>      Move (iCol-iC+1)            to iStart
84790>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iStart)) Eq " " Break
84793>>>>>>>>>>>>>>>>>    Loop
84794>>>>>>>>>>>>>>>>>>
84794>>>>>>>>>>>>>>>>>    Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
84795>>>>>>>>>>>>>>>>>  End_Function
84796>>>>>>>>>>>>>>>>>  // Gets the current word under the cursor, but does not stop at a dot (.)
84796>>>>>>>>>>>>>>>>>  // only a space character ends the word.
84796>>>>>>>>>>>>>>>>>  Function CM_GetCurrentWordIncludingDot Returns String
84798>>>>>>>>>>>>>>>>>    String  sWord
84798>>>>>>>>>>>>>>>>>    Integer iRet
84798>>>>>>>>>>>>>>>>>    Get CM_GetSel False                                         to iRet
84799>>>>>>>>>>>>>>>>>    Get CM_GetWordIncludingDot (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
84800>>>>>>>>>>>>>>>>>    Function_Return sWord
84801>>>>>>>>>>>>>>>>>  End_Function
84802>>>>>>>>>>>>>>>>>
84802>>>>>>>>>>>>>>>>>  //
84802>>>>>>>>>>>>>>>>>  // Gets the whole variable as a word.
84802>>>>>>>>>>>>>>>>>  //
84802>>>>>>>>>>>>>>>>>  // Tried using CM_GetWordIncludingDot, but that function also includes () characters as part of the
84802>>>>>>>>>>>>>>>>>  // word and that's a problem. We really only want the variable "as a word".
84802>>>>>>>>>>>>>>>>>  //
84802>>>>>>>>>>>>>>>>>  Function WordVariable Integer iLine Integer iPos Returns String
84804>>>>>>>>>>>>>>>>>    Integer iWordCharLength
84804>>>>>>>>>>>>>>>>>    Integer iVoid
84804>>>>>>>>>>>>>>>>>    String  sDefaultWordChars // default characters that are part of a word
84804>>>>>>>>>>>>>>>>>    String  sWordChars
84804>>>>>>>>>>>>>>>>>    String  sWord
84804>>>>>>>>>>>>>>>>>
84804>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETWORDCHARS To iWordCharLength
84805>>>>>>>>>>>>>>>>>    Move (ZeroString(iWordCharLength)) To sDefaultWordChars
84806>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETWORDCHARS 0 (AddressOf(sDefaultWordChars)) To iVoid
84807>>>>>>>>>>>>>>>>>    Move (sDefaultWordChars+".") To sWordChars
84808>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETWORDCHARS 0 (AddressOf(sWordChars))
84809>>>>>>>>>>>>>>>>>    Get CM_GetWord iLine iPos to sWord
84810>>>>>>>>>>>>>>>>>    // restore default
84810>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETWORDCHARS 0 (AddressOf(sDefaultWordChars))
84811>>>>>>>>>>>>>>>>>    Function_Return sWord
84812>>>>>>>>>>>>>>>>>  End_Function
84813>>>>>>>>>>>>>>>>>
84813>>>>>>>>>>>>>>>>>  // **WvA; Really, why? WHY is this here?
84813>>>>>>>>>>>>>>>>>  //@RRS Selfmade word getter, which find the word from where the cursor is
84813>>>>>>>>>>>>>>>>>  Function CM_GetWord3 Integer iLine Integer iCol Returns String
84815>>>>>>>>>>>>>>>>>    Integer iStart iEnd iLen iC
84815>>>>>>>>>>>>>>>>>    String sLine
84815>>>>>>>>>>>>>>>>>
84815>>>>>>>>>>>>>>>>>    Get value item iLine    to sLine
84816>>>>>>>>>>>>>>>>>    Move (Length(sLine))    to iLen
84817>>>>>>>>>>>>>>>>>
84817>>>>>>>>>>>>>>>>>    Move iCol to iEnd
84818>>>>>>>>>>>>>>>>>    For iC from 1 to iCol
84824>>>>>>>>>>>>>>>>>>
84824>>>>>>>>>>>>>>>>>      Move (iCol-iC+1) to iStart
84825>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iStart)) Eq " " Break
84828>>>>>>>>>>>>>>>>>    Loop
84829>>>>>>>>>>>>>>>>>>
84829>>>>>>>>>>>>>>>>>    Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
84830>>>>>>>>>>>>>>>>>  End_Function
84831>>>>>>>>>>>>>>>>>
84831>>>>>>>>>>>>>>>>>
84831>>>>>>>>>>>>>>>>>  // **WvA; Again, why? WHY is this here, what is wrong with GetCurrentWord itself?
84831>>>>>>>>>>>>>>>>>  //@RRS Gets the current word in selfmade way.
84831>>>>>>>>>>>>>>>>>  Function CM_GetCurrentWord3 Returns String
84833>>>>>>>>>>>>>>>>>    String  sWord
84833>>>>>>>>>>>>>>>>>    Integer iRet
84833>>>>>>>>>>>>>>>>>    Get CM_GetSel False                                        to iRet
84834>>>>>>>>>>>>>>>>>    Get CM_GetWord3 (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
84835>>>>>>>>>>>>>>>>>    Function_Return sWord
84836>>>>>>>>>>>>>>>>>  End_Function
84837>>>>>>>>>>>>>>>>>
84837>>>>>>>>>>>>>>>>>  //@ RRS New Procedure Used by isReasonForFieldList
84837>>>>>>>>>>>>>>>>>  Procedure AdjustFileNameCase String sNew
84839>>>>>>>>>>>>>>>>>    String  sWord sTmp sLine
84839>>>>>>>>>>>>>>>>>    Integer iRet iLine iCol iColStart
84839>>>>>>>>>>>>>>>>>    Integer iStart iEnd iLen iC iPos iTmp
84839>>>>>>>>>>>>>>>>>
84839>>>>>>>>>>>>>>>>>    Move (piSelEndLine(Self))  to iLine
84840>>>>>>>>>>>>>>>>>    Move (piSelEndCol(Self))   to iCol
84841>>>>>>>>>>>>>>>>>
84841>>>>>>>>>>>>>>>>>    Get value item iLine to sLine
84842>>>>>>>>>>>>>>>>>    Move (Length(sLine)) to iLen
84843>>>>>>>>>>>>>>>>>
84843>>>>>>>>>>>>>>>>>    For iEnd from iCol to iLen
84849>>>>>>>>>>>>>>>>>>
84849>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iEnd)) Eq " " Break
84852>>>>>>>>>>>>>>>>>    Loop
84853>>>>>>>>>>>>>>>>>>
84853>>>>>>>>>>>>>>>>>    For iC from 1 to iCol
84859>>>>>>>>>>>>>>>>>>
84859>>>>>>>>>>>>>>>>>      Move (iCol-iC+1)            to iStart
84860>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iStart)) Eq " " Break
84863>>>>>>>>>>>>>>>>>    Loop
84864>>>>>>>>>>>>>>>>>>
84864>>>>>>>>>>>>>>>>>    Move sLine to sTmp
84865>>>>>>>>>>>>>>>>>    Repeat
84865>>>>>>>>>>>>>>>>>>
84865>>>>>>>>>>>>>>>>>      Move (Pos(Uppercase(sNew),Uppercase(sTmp))) to iTmp
84866>>>>>>>>>>>>>>>>>      If (iTmp) Begin
84868>>>>>>>>>>>>>>>>>        Move (Remove(sTmp,1,iTmp)) to sTmp
84869>>>>>>>>>>>>>>>>>        Move (iTmp+iPos) to iPos
84870>>>>>>>>>>>>>>>>>      End
84870>>>>>>>>>>>>>>>>>>
84870>>>>>>>>>>>>>>>>>    Until ((iPos>=iStart) or (iTmp=0))
84872>>>>>>>>>>>>>>>>>    //@if (iPos>=iStart) Move iPos to iStart
84872>>>>>>>>>>>>>>>>>    If (iPos) ;      Move iPos to iStart
84875>>>>>>>>>>>>>>>>>    Move (Overstrike(sNew,sLine,iStart)) to sLine
84876>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
84877>>>>>>>>>>>>>>>>>    Get CM_DeleteLine iLine to iRet
84878>>>>>>>>>>>>>>>>>    Get CM_InsertLine iLine sLine to iRet
84879>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
84880>>>>>>>>>>>>>>>>>    // our selection just got removed, put back the cursor where we expect it
84880>>>>>>>>>>>>>>>>>    Get CM_SetSel iLine iCol iLine iCol False to iRet
84881>>>>>>>>>>>>>>>>>  End_Procedure
84882>>>>>>>>>>>>>>>>>
84882>>>>>>>>>>>>>>>>>
84882>>>>>>>>>>>>>>>>>  // An application sends the CMM_ADDTEXT message to add the specified text to the end of the edit buffer.
84882>>>>>>>>>>>>>>>>>  //
84882>>>>>>>>>>>>>>>>>  Function CM_AddText String szText Returns Integer
84884>>>>>>>>>>>>>>>>>    Integer iRet
84884>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_APPENDTEXT (Length(szText)) (AddressOf(szText)) to iRet
84885>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84886>>>>>>>>>>>>>>>>>  End_Function
84887>>>>>>>>>>>>>>>>>
84887>>>>>>>>>>>>>>>>>  //
84887>>>>>>>>>>>>>>>>>  // An application sends CMM_DELETELINE to delete a line from the buffer.
84887>>>>>>>>>>>>>>>>>  //
84887>>>>>>>>>>>>>>>>>  Function CM_DeleteLine Integer iLine  Returns Integer
84889>>>>>>>>>>>>>>>>>    Integer iCol
84889>>>>>>>>>>>>>>>>>    Integer iStartPos
84889>>>>>>>>>>>>>>>>>    Integer iLineLength
84889>>>>>>>>>>>>>>>>>    Integer iRet
84889>>>>>>>>>>>>>>>>>
84889>>>>>>>>>>>>>>>>>    Move 0 To iCol
84890>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
84891>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH  iLine                 to iLineLength
84892>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_DELETERANGE iStartPos iLinelength to iRet
84893>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84894>>>>>>>>>>>>>>>>>  End_Function
84895>>>>>>>>>>>>>>>>>
84895>>>>>>>>>>>>>>>>>  //
84895>>>>>>>>>>>>>>>>>  // An application sends CMM_INSERTLINE to insert a line of text into the edit buffer.
84895>>>>>>>>>>>>>>>>>  // iLine
84895>>>>>>>>>>>>>>>>>  // The zero-based index of the line to insert before.
84895>>>>>>>>>>>>>>>>>  // pszText
84895>>>>>>>>>>>>>>>>>  // The text of the line to insert. This text should not contain any carriage returns or linefeeds.
84895>>>>>>>>>>>>>>>>>  //
84895>>>>>>>>>>>>>>>>>  Function CM_InsertLine Integer iLine String szText Returns Integer
84897>>>>>>>>>>>>>>>>>    Integer iCol
84897>>>>>>>>>>>>>>>>>    Integer iStartPos
84897>>>>>>>>>>>>>>>>>    Integer iRet
84897>>>>>>>>>>>>>>>>>    String  sEOLChar
84897>>>>>>>>>>>>>>>>>
84897>>>>>>>>>>>>>>>>>    Move 0 To iCol
84898>>>>>>>>>>>>>>>>>    Get psEOLChar to sEOLChar
84899>>>>>>>>>>>>>>>>>    Move (CString(szText)+sEOLChar+Character(0)) To szText
84900>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
84901>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_INSERTTEXT iStartPos  (AddressOf(sztext)) to iRet
84902>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84903>>>>>>>>>>>>>>>>>  End_Function
84904>>>>>>>>>>>>>>>>>
84904>>>>>>>>>>>>>>>>>  // Gets the active selection and fills it into the properties.
84904>>>>>>>>>>>>>>>>>  // Normalized: True=StartPosition always before EndPosition
84904>>>>>>>>>>>>>>>>>  // CMM_GETSEL
84904>>>>>>>>>>>>>>>>>  Function CM_GetSel Integer bNormalized Returns Integer
84906>>>>>>>>>>>>>>>>>    Integer iRet iLine iCol
84906>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
84906>>>>>>>>>>>>>>>>>
84906>>>>>>>>>>>>>>>>>    // With Scintilla we ignore the bNormalized option as it returns the start position as
84906>>>>>>>>>>>>>>>>>    // smaller anyways.
84906>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONSTART to iStartPos
84907>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEND   to iEndPos
84908>>>>>>>>>>>>>>>>>
84908>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iStartPos to iLine
84909>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iStartPos to iCol
84910>>>>>>>>>>>>>>>>>    Set piSelStartLine  to iLine
84911>>>>>>>>>>>>>>>>>    Set piSelStartCol   to iCol
84912>>>>>>>>>>>>>>>>>    If (iStartPos<>iEndPos) Begin
84914>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iEndPos   to iLine
84915>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCOLUMN        iEndPos   to iCol
84916>>>>>>>>>>>>>>>>>    End
84916>>>>>>>>>>>>>>>>>>
84916>>>>>>>>>>>>>>>>>    Set piSelEndLine  to iLine
84917>>>>>>>>>>>>>>>>>    Set piSelEndCol   to iCol
84918>>>>>>>>>>>>>>>>>    Move CME_SUCCESS To iRet
84919>>>>>>>>>>>>>>>>>    Function_Return iRet
84920>>>>>>>>>>>>>>>>>  End_Function
84921>>>>>>>>>>>>>>>>>
84921>>>>>>>>>>>>>>>>>  //
84921>>>>>>>>>>>>>>>>>  // This returns the current line for the current cursor position.
84921>>>>>>>>>>>>>>>>>  // Beware that the first line is line 0 and not line 1.
84921>>>>>>>>>>>>>>>>>  //
84921>>>>>>>>>>>>>>>>>  Function CurrentLine Returns Integer
84923>>>>>>>>>>>>>>>>>    Integer iPos
84923>>>>>>>>>>>>>>>>>    Integer iLine
84923>>>>>>>>>>>>>>>>>
84923>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS To iPos
84924>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
84925>>>>>>>>>>>>>>>>>    Function_Return iLine
84926>>>>>>>>>>>>>>>>>  End_Function
84927>>>>>>>>>>>>>>>>>
84927>>>>>>>>>>>>>>>>>  Function CurrentColumn Returns Integer
84929>>>>>>>>>>>>>>>>>    Integer iPos
84929>>>>>>>>>>>>>>>>>    Integer iCol
84929>>>>>>>>>>>>>>>>>
84929>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS to iPos
84930>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN     iPos to iCol
84931>>>>>>>>>>>>>>>>>    Function_Return iCol
84932>>>>>>>>>>>>>>>>>  End_Function
84933>>>>>>>>>>>>>>>>>
84933>>>>>>>>>>>>>>>>>  Function CursorPosition Returns Integer
84935>>>>>>>>>>>>>>>>>    Integer iSel iY iX iRet
84935>>>>>>>>>>>>>>>>>    Get CM_GetSel True to iSel
84936>>>>>>>>>>>>>>>>>    Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
84937>>>>>>>>>>>>>>>>>    Move (piPosEndY(Self))                                       to iY
84938>>>>>>>>>>>>>>>>>    Move (piPosEndX(Self))                                       to iX
84939>>>>>>>>>>>>>>>>>
84939>>>>>>>>>>>>>>>>>    Function_Return (MAKEWPARAM(iX, iY))
84940>>>>>>>>>>>>>>>>>  End_Function
84941>>>>>>>>>>>>>>>>>
84941>>>>>>>>>>>>>>>>>  // CMM_SETSEL
84941>>>>>>>>>>>>>>>>>  // bMakeVisible
84941>>>>>>>>>>>>>>>>>  // If TRUE, the selection will be scrolled into view. If FALSE, the window contents will not be scrolled.
84941>>>>>>>>>>>>>>>>>  Function CM_SetSel Integer iStartLine Integer iStartCol Integer iEndLine Integer iEndCol  Integer bMakeVisible Returns Integer
84943>>>>>>>>>>>>>>>>>    Integer iStartPos
84943>>>>>>>>>>>>>>>>>    Integer iEndPos
84943>>>>>>>>>>>>>>>>>    Integer iRet
84943>>>>>>>>>>>>>>>>>
84943>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iStartLine iStartCol to iStartPos
84944>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iEndLine   iEndCol   to iEndPos
84945>>>>>>>>>>>>>>>>>    If (bMakeVisible) Begin
84947>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSEL iStartPos iEndPos
84948>>>>>>>>>>>>>>>>>    End
84948>>>>>>>>>>>>>>>>>>
84948>>>>>>>>>>>>>>>>>    Else Begin
84949>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETEMPTYSELECTION iEndPos  // set caret at end pos to start with and empty previous selections
84950>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONSTART iStartPos
84951>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONEND   iEndPos
84952>>>>>>>>>>>>>>>>>    End
84952>>>>>>>>>>>>>>>>>>
84952>>>>>>>>>>>>>>>>>
84952>>>>>>>>>>>>>>>>>    Move CME_SUCCESS To iRet
84953>>>>>>>>>>>>>>>>>    Function_Return iRet
84954>>>>>>>>>>>>>>>>>  End_Function
84955>>>>>>>>>>>>>>>>>
84955>>>>>>>>>>>>>>>>>  // An application sends CMM_DELETESEL to delete the currently selected text from the buffer.
84955>>>>>>>>>>>>>>>>>  Function CM_DeleteSel Returns Integer
84957>>>>>>>>>>>>>>>>>    Integer iRet
84957>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
84957>>>>>>>>>>>>>>>>>    Integer iLength
84957>>>>>>>>>>>>>>>>>
84957>>>>>>>>>>>>>>>>>    Move CME_FAILURE To iRet
84958>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONSTART to iStartPos
84959>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEND   to iEndPos
84960>>>>>>>>>>>>>>>>>    Move (iEndPos-iStartPos) To iLength
84961>>>>>>>>>>>>>>>>>    If (iLength>0) Begin
84963>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_DELETERANGE iStartPos iLength
84964>>>>>>>>>>>>>>>>>      Move CME_SUCCESS To iRet
84965>>>>>>>>>>>>>>>>>    End
84965>>>>>>>>>>>>>>>>>>
84965>>>>>>>>>>>>>>>>>    Function_Return iRet
84966>>>>>>>>>>>>>>>>>  End_Function
84967>>>>>>>>>>>>>>>>>
84967>>>>>>>>>>>>>>>>>  // An application sends CMM_REPLACESEL to replace the current buffer selection with a body of text
84967>>>>>>>>>>>>>>>>>  Function CM_ReplaceSel String szText  Returns Integer
84969>>>>>>>>>>>>>>>>>    Move (szText+Character(0)) To szText
84970>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_REPLACESEL 0 (AddressOf(szText))
84971>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84972>>>>>>>>>>>>>>>>>  End_Function
84973>>>>>>>>>>>>>>>>>
84973>>>>>>>>>>>>>>>>>  //
84973>>>>>>>>>>>>>>>>>  // ToDo: CM_ExecuteCmd
84973>>>>>>>>>>>>>>>>>  //
84973>>>>>>>>>>>>>>>>>  Function CM_ExecuteCmd Integer wCmd Integer dwCmdData Returns Integer
84975>>>>>>>>>>>>>>>>>    Integer iSCICmd
84975>>>>>>>>>>>>>>>>>    Integer iLine
84975>>>>>>>>>>>>>>>>>    Integer iVoid
84975>>>>>>>>>>>>>>>>>
84975>>>>>>>>>>>>>>>>>    Move 0 To iSCICmd
84976>>>>>>>>>>>>>>>>>    Case Begin
84976>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_SELECTLINE)
84978>>>>>>>>>>>>>>>>>        Get piSelEndLine to iLine
84979>>>>>>>>>>>>>>>>>        Get CM_SelectLine iLine True to iVoid
84980>>>>>>>>>>>>>>>>>        Case Break
84981>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_LINEDELETE)
84984>>>>>>>>>>>>>>>>>        Get piSelEndLine to iLine
84985>>>>>>>>>>>>>>>>>        Get CM_DeleteLine iLine to iVoid
84986>>>>>>>>>>>>>>>>>        Case Break
84987>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_Find)
84990>>>>>>>>>>>>>>>>>        Send Find
84991>>>>>>>>>>>>>>>>>        Case Break
84992>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_FindNext)
84995>>>>>>>>>>>>>>>>>        Send FindNext
84996>>>>>>>>>>>>>>>>>        Case Break
84997>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_FINDPREV)
85000>>>>>>>>>>>>>>>>>        Send FindPrevious
85001>>>>>>>>>>>>>>>>>        Case Break
85002>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_FindReplace)
85005>>>>>>>>>>>>>>>>>        // ToDo: CMD_FindReplace
85005>>>>>>>>>>>>>>>>>        Case Break
85006>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_UPPERCASESELECTION)
85009>>>>>>>>>>>>>>>>>        Send SC_UppercaseSelection
85010>>>>>>>>>>>>>>>>>        Case Break
85011>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_LOWERCASESELECTION)
85014>>>>>>>>>>>>>>>>>        Send SC_LowercaseSelection
85015>>>>>>>>>>>>>>>>>        Case Break
85016>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKTOGGLE)
85019>>>>>>>>>>>>>>>>>        Send BookmarkToggle
85020>>>>>>>>>>>>>>>>>        Case Break
85021>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKCLEARALL)
85024>>>>>>>>>>>>>>>>>        Send BookmarkClearAll
85025>>>>>>>>>>>>>>>>>        Case Break
85026>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKJUMPTOFIRST)
85029>>>>>>>>>>>>>>>>>        Send BookmarkJumpToFirst
85030>>>>>>>>>>>>>>>>>        Case Break
85031>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKJUMPTOLAST)
85034>>>>>>>>>>>>>>>>>        Send BookmarkJumpToLast
85035>>>>>>>>>>>>>>>>>        Case Break
85036>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKNEXT)
85039>>>>>>>>>>>>>>>>>        Send BookmarkNext
85040>>>>>>>>>>>>>>>>>        Case Break
85041>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKPREV)
85044>>>>>>>>>>>>>>>>>        Send BookmarkPrevious
85045>>>>>>>>>>>>>>>>>        Case Break
85046>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_GOTOINDENTATION)
85049>>>>>>>>>>>>>>>>>        Case Break
85050>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_GOTOMATCHBRACE)
85053>>>>>>>>>>>>>>>>>        Send GotomatchBrace
85054>>>>>>>>>>>>>>>>>        Case Break
85055>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_RECORDMACRO)
85058>>>>>>>>>>>>>>>>>        Case Break
85059>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO1)
85062>>>>>>>>>>>>>>>>>        Case Break
85063>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO2)
85066>>>>>>>>>>>>>>>>>        Case Break
85067>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO3)
85070>>>>>>>>>>>>>>>>>        Case Break
85071>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO4)
85074>>>>>>>>>>>>>>>>>        Case Break
85075>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO5)
85078>>>>>>>>>>>>>>>>>        Case Break
85079>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO6)
85082>>>>>>>>>>>>>>>>>        Case Break
85083>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO7)
85086>>>>>>>>>>>>>>>>>        Case Break
85087>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO8)
85090>>>>>>>>>>>>>>>>>        Case Break
85091>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO9)
85094>>>>>>>>>>>>>>>>>        Case Break
85095>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO10)
85098>>>>>>>>>>>>>>>>>        Case Break
85099>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_CODETIP)
85102>>>>>>>>>>>>>>>>>        Get Msg_DoCodeTip to iVoid
85103>>>>>>>>>>>>>>>>>        Case Break
85104>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_CODELIST)
85107>>>>>>>>>>>>>>>>>        Get Msg_DoCodeList 0 to iVoid
85108>>>>>>>>>>>>>>>>>        Case Break
85109>>>>>>>>>>>>>>>>>    Case End
85109>>>>>>>>>>>>>>>>>    If (iSCICmd) Begin
85111>>>>>>>>>>>>>>>>>      Send EditorMessage iSCICmd
85112>>>>>>>>>>>>>>>>>    End
85112>>>>>>>>>>>>>>>>>>
85112>>>>>>>>>>>>>>>>>    //  Function_Return (SendMessage(Window_Handle(Self), CMM_EXECUTECMD,  ( wCmd ), ( dwCmdData ) ) )
85112>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85113>>>>>>>>>>>>>>>>>  End_Function
85114>>>>>>>>>>>>>>>>>
85114>>>>>>>>>>>>>>>>>  //
85114>>>>>>>>>>>>>>>>>  // ToDo: Currently no support for splitter screen
85114>>>>>>>>>>>>>>>>>  //
85114>>>>>>>>>>>>>>>>>  //    Function CM_SetSplitterPos Integer bHorz  Integer nPos Returns Integer
85114>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_SETSPLITTERPOS,  ( bHorz ), ( nPos ) ) )
85114>>>>>>>>>>>>>>>>>  //    End_Function
85114>>>>>>>>>>>>>>>>>  //    Function CM_GetSplitterPos Integer bHorz Returns Integer
85114>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_GETSPLITTERPOS,  ( bHorz ), 0 ) )
85114>>>>>>>>>>>>>>>>>  //    End_Function
85114>>>>>>>>>>>>>>>>>
85114>>>>>>>>>>>>>>>>>  //
85114>>>>>>>>>>>>>>>>>  // An application sends CMM_SETAUTOINDENTMODE to set the current auto-indent mode.
85114>>>>>>>>>>>>>>>>>  // The auto-indent mode determines how a new line is indented when ENTER is pressed
85114>>>>>>>>>>>>>>>>>  //
85114>>>>>>>>>>>>>>>>>  Function CM_SetAutoIndentMode Integer eMode Returns Integer
85116>>>>>>>>>>>>>>>>>    If (eMode=CM_INDENT_SCOPE) Begin
85118>>>>>>>>>>>>>>>>>      Move CM_INDENT_PREVLINE to eMode
85119>>>>>>>>>>>>>>>>>    End
85119>>>>>>>>>>>>>>>>>>
85119>>>>>>>>>>>>>>>>>    Set peAutoIndentMode to eMode
85120>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85121>>>>>>>>>>>>>>>>>  End_Function
85122>>>>>>>>>>>>>>>>>  //
85122>>>>>>>>>>>>>>>>>  // CMM_GETAUTOINDENTMODE
85122>>>>>>>>>>>>>>>>>  // An application sends CMM_GETAUTOINDENTMODE to determine the current auto-indent mode. The auto-indent mode determines how
85122>>>>>>>>>>>>>>>>>  // a new line is indented when ENTER is pressed.
85122>>>>>>>>>>>>>>>>>  //
85122>>>>>>>>>>>>>>>>>  // CM_INDENT_OFF - No indentation occurs. The next line begins at column zero (0).
85122>>>>>>>>>>>>>>>>>  // CM_INDENT_SCOPE - Language-specific scoping is used to determine the correct indentation level for the next line.
85122>>>>>>>>>>>>>>>>>  //                   This setting parses the buffer contents, looking backward for scope keywords until the start of
85122>>>>>>>>>>>>>>>>>  //                   the current scope is encountered. Once found, the indentation is copied to the next line.
85122>>>>>>>>>>>>>>>>>  //                   If no language is set, CM_INDENT_PREVLINE is used.
85122>>>>>>>>>>>>>>>>>  // CM_INDENT_PREVLINE - Indentation is copied from the previous line.
85122>>>>>>>>>>>>>>>>>  // The default setting is CM_INDENT_PREVLINE.
85122>>>>>>>>>>>>>>>>>  // CM_INDENT_SCOPE is not supported for Scintilla now
85122>>>>>>>>>>>>>>>>>  Function CM_GetAutoIndentMode Returns Integer
85124>>>>>>>>>>>>>>>>>    Integer eMode
85124>>>>>>>>>>>>>>>>>
85124>>>>>>>>>>>>>>>>>    Get peAutoIndentMode to eMode
85125>>>>>>>>>>>>>>>>>    Function_Return eMode
85126>>>>>>>>>>>>>>>>>  End_Function
85127>>>>>>>>>>>>>>>>>  Function CM_CanUndo Returns Integer
85129>>>>>>>>>>>>>>>>>    Integer iRet
85129>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CANUNDO to iRet
85130>>>>>>>>>>>>>>>>>    Function_Return iRet
85131>>>>>>>>>>>>>>>>>  End_Function
85132>>>>>>>>>>>>>>>>>  Function CM_CanRedo Returns Integer
85134>>>>>>>>>>>>>>>>>    Integer iRet
85134>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CANREDO to iRet
85135>>>>>>>>>>>>>>>>>    Function_Return iRet
85136>>>>>>>>>>>>>>>>>  End_Function
85137>>>>>>>>>>>>>>>>>  Function CM_Redo Returns Integer
85139>>>>>>>>>>>>>>>>>    Integer iRet
85139>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_REDO to iRet
85140>>>>>>>>>>>>>>>>>    Function_Return iRet
85141>>>>>>>>>>>>>>>>>  End_Function
85142>>>>>>>>>>>>>>>>>  Function CM_Undo Returns Integer
85144>>>>>>>>>>>>>>>>>    Integer iRet
85144>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_UNDO to iRet
85145>>>>>>>>>>>>>>>>>    Function_Return iRet
85146>>>>>>>>>>>>>>>>>  End_Function
85147>>>>>>>>>>>>>>>>>  Function CM_ClearUndoBuffer Returns Integer
85149>>>>>>>>>>>>>>>>>    Integer iRet
85149>>>>>>>>>>>>>>>>>    // This command tells Scintilla to forget any saved undo or redo history.
85149>>>>>>>>>>>>>>>>>    // It also sets the save point to the start of the undo buffer, so the document will appear to be unmodified.
85149>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_EMPTYUNDOBUFFER to iRet
85150>>>>>>>>>>>>>>>>>    Function_Return iRet
85151>>>>>>>>>>>>>>>>>  End_Function
85152>>>>>>>>>>>>>>>>>  Function CM_CanCut Returns Integer
85154>>>>>>>>>>>>>>>>>    Integer iRet
85154>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEMPTY to iRet
85155>>>>>>>>>>>>>>>>>    Function_Return (iRet=0)
85156>>>>>>>>>>>>>>>>>  End_Function
85157>>>>>>>>>>>>>>>>>  Function CM_CanCopy Returns Integer
85159>>>>>>>>>>>>>>>>>    Integer iRet
85159>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEMPTY to iRet
85160>>>>>>>>>>>>>>>>>    Function_Return (iRet=0)
85161>>>>>>>>>>>>>>>>>  End_Function
85162>>>>>>>>>>>>>>>>>  Function CM_CanPaste Returns Integer
85164>>>>>>>>>>>>>>>>>    Integer iRet
85164>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CANPASTE to iRet
85165>>>>>>>>>>>>>>>>>    Function_Return iRet
85166>>>>>>>>>>>>>>>>>  End_Function
85167>>>>>>>>>>>>>>>>>  Function CM_Cut Returns Integer
85169>>>>>>>>>>>>>>>>>    Integer iRet
85169>>>>>>>>>>>>>>>>>    Send OnBeforeCut
85170>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CUT to iRet
85171>>>>>>>>>>>>>>>>>    Send OnAfterCut
85172>>>>>>>>>>>>>>>>>    Function_Return iRet
85173>>>>>>>>>>>>>>>>>  End_Function
85174>>>>>>>>>>>>>>>>>  Function CM_Copy Returns Integer
85176>>>>>>>>>>>>>>>>>    Integer iRet
85176>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_COPY to iRet
85177>>>>>>>>>>>>>>>>>    Function_Return iRet
85178>>>>>>>>>>>>>>>>>  End_Function
85179>>>>>>>>>>>>>>>>>  Function CM_Paste Returns Integer
85181>>>>>>>>>>>>>>>>>    Integer iRet
85181>>>>>>>>>>>>>>>>>    Send OnBeforePaste
85182>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_PASTE to iRet
85183>>>>>>>>>>>>>>>>>    Send OnAfterPaste
85184>>>>>>>>>>>>>>>>>    Function_Return iRet
85185>>>>>>>>>>>>>>>>>  End_Function
85186>>>>>>>>>>>>>>>>>  Function CM_IsRecordingMacro Returns Integer
85188>>>>>>>>>>>>>>>>>    // Not sure if the function is for starting to record.
85188>>>>>>>>>>>>>>>>>    //Integer iRet
85188>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_STARTRECORD to iRet
85188>>>>>>>>>>>>>>>>>    //Function_Return iRet
85188>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISRECORDINGMACRO, 0, 0 ) )
85189>>>>>>>>>>>>>>>>>  End_Function
85190>>>>>>>>>>>>>>>>>  Function CM_IsPlayingMacro Returns Integer
85192>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPLAYINGMACRO, 0, 0 ) )
85193>>>>>>>>>>>>>>>>>  End_Function
85194>>>>>>>>>>>>>>>>>  //
85194>>>>>>>>>>>>>>>>>  // There is no undo limit in scintilla, the amount of free memory is the limit.
85194>>>>>>>>>>>>>>>>>  //
85194>>>>>>>>>>>>>>>>>  //    Function CM_SetUndoLimit Integer nLimit Returns Integer
85194>>>>>>>>>>>>>>>>>  //    Function CM_GetUndoLimit Returns Integer
85194>>>>>>>>>>>>>>>>>
85194>>>>>>>>>>>>>>>>>  Procedure ToggleLineChanged
85196>>>>>>>>>>>>>>>>>    Integer iLine
85196>>>>>>>>>>>>>>>>>
85196>>>>>>>>>>>>>>>>>    Get Current_Line to iLine
85197>>>>>>>>>>>>>>>>>    Send LineChangedMark iLine
85198>>>>>>>>>>>>>>>>>  End_Procedure
85199>>>>>>>>>>>>>>>>>
85199>>>>>>>>>>>>>>>>>  Function CM_IsModified Returns Integer
85201>>>>>>>>>>>>>>>>>    Integer iRet
85201>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMODIFY to iRet
85202>>>>>>>>>>>>>>>>>    Function_Return iRet
85203>>>>>>>>>>>>>>>>>  End_Function
85204>>>>>>>>>>>>>>>>>  //
85204>>>>>>>>>>>>>>>>>  // Does not seem to exist in Scintilla
85204>>>>>>>>>>>>>>>>>  //
85204>>>>>>>>>>>>>>>>>  //    Function CM_SetModified Integer bModified Returns Integer
85204>>>>>>>>>>>>>>>>>
85204>>>>>>>>>>>>>>>>>  Function CM_EnableOvertype Integer bEnable Returns Integer
85206>>>>>>>>>>>>>>>>>    Integer iRet
85206>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETOVERTYPE bEnable to iRet
85207>>>>>>>>>>>>>>>>>    Function_Return iRet
85208>>>>>>>>>>>>>>>>>  End_Function
85209>>>>>>>>>>>>>>>>>  Function CM_IsOvertypeEnabled Returns Integer
85211>>>>>>>>>>>>>>>>>    Integer iRet
85211>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETOVERTYPE to iRet
85212>>>>>>>>>>>>>>>>>    Function_Return iRet
85213>>>>>>>>>>>>>>>>>  End_Function
85214>>>>>>>>>>>>>>>>>  Function CM_EnableCaseSensitive Integer bEnable Returns Integer
85216>>>>>>>>>>>>>>>>>    Integer iFlags
85216>>>>>>>>>>>>>>>>>    Integer iRet
85216>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85217>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85219>>>>>>>>>>>>>>>>>      //
85219>>>>>>>>>>>>>>>>>      Move (iFlags iOr SCFIND_MATCHCASE) To iFlags
85220>>>>>>>>>>>>>>>>>    End
85220>>>>>>>>>>>>>>>>>>
85220>>>>>>>>>>>>>>>>>    Else Begin
85221>>>>>>>>>>>>>>>>>      Move (iFlags iAnd (iNot(SCFIND_MATCHCASE))) To iFlags
85222>>>>>>>>>>>>>>>>>    End
85222>>>>>>>>>>>>>>>>>>
85222>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet
85223>>>>>>>>>>>>>>>>>    Function_Return iRet
85224>>>>>>>>>>>>>>>>>  End_Function
85225>>>>>>>>>>>>>>>>>  Function CM_IsCaseSensitiveEnabled Returns Integer
85227>>>>>>>>>>>>>>>>>    Integer iFlags
85227>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85228>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_MATCHCASE) To iFlags
85229>>>>>>>>>>>>>>>>>    Function_Return (iFlags<>0)
85230>>>>>>>>>>>>>>>>>  End_Function
85231>>>>>>>>>>>>>>>>>
85231>>>>>>>>>>>>>>>>>  // Weird codemax feature, not in scintilla
85231>>>>>>>>>>>>>>>>>  // If TRUE, subsequent Find/Replace operations will format the Replace text such that it follows
85231>>>>>>>>>>>>>>>>>  // the same case pattern of the Find text:
85231>>>>>>>>>>>>>>>>>  //Function CM_EnablePreserveCase Integer bEnable Returns Integer
85231>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEPRESERVECASE,  ( bEnable ), 0 ) )
85231>>>>>>>>>>>>>>>>>  //End_Function
85231>>>>>>>>>>>>>>>>>  //Function CM_IsPreserveCaseEnabled Returns Integer
85231>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPRESERVECASEENABLED, 0, 0 ) )
85231>>>>>>>>>>>>>>>>>  //End_Function
85231>>>>>>>>>>>>>>>>>
85231>>>>>>>>>>>>>>>>>  // An application sends CMM_ENABLEWHOLEWORD to enable or disable whole word searching during a find or find and replace operation
85231>>>>>>>>>>>>>>>>>  Function CM_EnableWholeWord Integer bEnable Returns Integer
85233>>>>>>>>>>>>>>>>>    Integer iFlags
85233>>>>>>>>>>>>>>>>>    Integer iRet
85233>>>>>>>>>>>>>>>>>    //
85233>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85234>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85236>>>>>>>>>>>>>>>>>      //
85236>>>>>>>>>>>>>>>>>      Move (iFlags iOr SCFIND_WHOLEWORD) To iFlags
85237>>>>>>>>>>>>>>>>>    End
85237>>>>>>>>>>>>>>>>>>
85237>>>>>>>>>>>>>>>>>    Else Begin
85238>>>>>>>>>>>>>>>>>      Move (iFlags iAnd (iNot(SCFIND_WHOLEWORD))) To iFlags
85239>>>>>>>>>>>>>>>>>    End
85239>>>>>>>>>>>>>>>>>>
85239>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet
85240>>>>>>>>>>>>>>>>>    Function_Return iRet
85241>>>>>>>>>>>>>>>>>  End_Function
85242>>>>>>>>>>>>>>>>>  Function CM_IsWholeWordEnabled Returns Integer
85244>>>>>>>>>>>>>>>>>    Integer iFlags
85244>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85245>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_WHOLEWORD) To iFlags
85246>>>>>>>>>>>>>>>>>    Function_Return (iFlags<>0)
85247>>>>>>>>>>>>>>>>>  End_Function
85248>>>>>>>>>>>>>>>>>
85248>>>>>>>>>>>>>>>>>
85248>>>>>>>>>>>>>>>>>  Function CM_EnableRegExp Integer bEnable Returns Integer
85250>>>>>>>>>>>>>>>>>    Integer iFlags
85250>>>>>>>>>>>>>>>>>    Integer iRet
85250>>>>>>>>>>>>>>>>>    //
85250>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85251>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85253>>>>>>>>>>>>>>>>>      //
85253>>>>>>>>>>>>>>>>>      Move (iFlags iOr SCFIND_REGEXP) To iFlags
85254>>>>>>>>>>>>>>>>>    End
85254>>>>>>>>>>>>>>>>>>
85254>>>>>>>>>>>>>>>>>    Else Begin
85255>>>>>>>>>>>>>>>>>      Move (iFlags iAnd (iNot(SCFIND_REGEXP))) To iFlags
85256>>>>>>>>>>>>>>>>>    End
85256>>>>>>>>>>>>>>>>>>
85256>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet // CMM_ENABLEREGEXP
85257>>>>>>>>>>>>>>>>>    Function_Return iRet
85258>>>>>>>>>>>>>>>>>  End_Function
85259>>>>>>>>>>>>>>>>>
85259>>>>>>>>>>>>>>>>>  Function CM_IsRegExpEnabled Returns Integer
85261>>>>>>>>>>>>>>>>>    Integer iFlags
85261>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags // CMM_ISREGEXPENABLED
85262>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_REGEXP) To iFlags
85263>>>>>>>>>>>>>>>>>    Function_Return (iFlags<>0)
85264>>>>>>>>>>>>>>>>>  End_Function
85265>>>>>>>>>>>>>>>>>
85265>>>>>>>>>>>>>>>>>  // An application sends CMM_SETTOPINDEX to set the topmost visible line in a specific view.
85265>>>>>>>>>>>>>>>>>  // This might be the same as SCI_SETFIRSTVISIBLELINE(int displayLine) but not completely clear to me now.
85265>>>>>>>>>>>>>>>>>  //Function CM_SetTopIndex Integer nView Integer nLine Returns Integer
85265>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_SETTOPINDEX,  ( nView ), ( nLine ) ) )
85265>>>>>>>>>>>>>>>>>  //End_Function
85265>>>>>>>>>>>>>>>>>  //Function CM_GetTopIndex Integer nView Returns Integer
85265>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETTOPINDEX,  ( nView ), 0 ) )
85265>>>>>>>>>>>>>>>>>  //End_Function
85265>>>>>>>>>>>>>>>>>
85265>>>>>>>>>>>>>>>>>  // SCI_LINESONSCREEN
85265>>>>>>>>>>>>>>>>>  Function CM_GetVisibleLineCount Integer nView Integer bFullyVisible Returns Integer
85267>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETVISIBLELINECOUNT,  ( nView ), ( bFullyVisible ) ) )
85268>>>>>>>>>>>>>>>>>  End_Function
85269>>>>>>>>>>>>>>>>>
85269>>>>>>>>>>>>>>>>>  // An application sends CMM_ENABLECRLF to enable or disable the inclusion of carriage returns when
85269>>>>>>>>>>>>>>>>>  // multiple lines of text are retrieved from the edit buffer
85269>>>>>>>>>>>>>>>>>  // bEnable - If TRUE, multiple lines of text retrieved from the edit buffer are delimited by a
85269>>>>>>>>>>>>>>>>>  //  carriage return (\r) and a linefeed (\n). If FALSE, lines are delimited by only a linefeed (\n).
85269>>>>>>>>>>>>>>>>>  //  The default setting is TRUE.
85269>>>>>>>>>>>>>>>>>  Function CM_EnableCRLF Integer bEnable Returns Integer
85271>>>>>>>>>>>>>>>>>    Integer eMode
85271>>>>>>>>>>>>>>>>>
85271>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85273>>>>>>>>>>>>>>>>>      Move SC_EOL_CRLF to eMode
85274>>>>>>>>>>>>>>>>>      Set psEOLChar    to CS_CRLF
85275>>>>>>>>>>>>>>>>>    End
85275>>>>>>>>>>>>>>>>>>
85275>>>>>>>>>>>>>>>>>    Else Begin
85276>>>>>>>>>>>>>>>>>      Move SC_EOL_LF   To eMode
85277>>>>>>>>>>>>>>>>>      Set psEOLChar    to CS_LF
85278>>>>>>>>>>>>>>>>>    End
85278>>>>>>>>>>>>>>>>>>
85278>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETEOLMODE eMode
85279>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85280>>>>>>>>>>>>>>>>>  End_Function
85281>>>>>>>>>>>>>>>>>
85281>>>>>>>>>>>>>>>>>  // The return value is TRUE if multiple lines of text retrieved from the edit buffer are delimited by
85281>>>>>>>>>>>>>>>>>  // a carriage return (\r) and a linefeed (\n). The return value is FALSE if lines are delimited by
85281>>>>>>>>>>>>>>>>>  // only a linefeed (\n). The default setting is TRUE.
85281>>>>>>>>>>>>>>>>>  Function CM_IsCRLFEnabled Returns Boolean
85283>>>>>>>>>>>>>>>>>    Integer eMode
85283>>>>>>>>>>>>>>>>>    Boolean bEnabled
85283>>>>>>>>>>>>>>>>>    Move False to bEnabled
85284>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETEOLMODE to eMode
85285>>>>>>>>>>>>>>>>>    If (eMode=SC_EOL_CRLF) Begin
85287>>>>>>>>>>>>>>>>>      Move True to bEnabled
85288>>>>>>>>>>>>>>>>>    End
85288>>>>>>>>>>>>>>>>>>
85288>>>>>>>>>>>>>>>>>    Function_Return True
85289>>>>>>>>>>>>>>>>>  End_Function
85290>>>>>>>>>>>>>>>>>
85290>>>>>>>>>>>>>>>>>  Function CM_GetCurrentView Returns Integer
85292>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTVIEW, 0, 0 ) )
85293>>>>>>>>>>>>>>>>>  End_Function
85294>>>>>>>>>>>>>>>>>  // SVN
85294>>>>>>>>>>>>>>>>>  Function CM_SetCurrentView Integer nLine Returns Integer
85296>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETCURRENTVIEW, nLine, 0 ) )
85297>>>>>>>>>>>>>>>>>  End_Function
85298>>>>>>>>>>>>>>>>>  // SVN
85298>>>>>>>>>>>>>>>>>  Function CM_GetViewCount Returns Integer
85300>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETVIEWCOUNT, 0, 0 ) )
85301>>>>>>>>>>>>>>>>>  End_Function
85302>>>>>>>>>>>>>>>>>  Function CM_ShowScrollBar Integer bHorz  Integer bShow Returns Integer
85304>>>>>>>>>>>>>>>>>    Integer iRet
85304>>>>>>>>>>>>>>>>>    If (bHorz) Begin
85306>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETHSCROLLBAR bShow
85307>>>>>>>>>>>>>>>>>    End
85307>>>>>>>>>>>>>>>>>>
85307>>>>>>>>>>>>>>>>>    Else Begin
85308>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETVSCROLLBAR bShow
85309>>>>>>>>>>>>>>>>>    End
85309>>>>>>>>>>>>>>>>>>
85309>>>>>>>>>>>>>>>>>    Function_Return iRet
85310>>>>>>>>>>>>>>>>>  End_Function
85311>>>>>>>>>>>>>>>>>  Function CM_HasScrollBar Integer bHorz Returns Integer
85313>>>>>>>>>>>>>>>>>    Integer iRet
85313>>>>>>>>>>>>>>>>>    If (bHorz) Begin
85315>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETHSCROLLBAR to iRet
85316>>>>>>>>>>>>>>>>>    End
85316>>>>>>>>>>>>>>>>>>
85316>>>>>>>>>>>>>>>>>    Else Begin
85317>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETVSCROLLBAR to iRet
85318>>>>>>>>>>>>>>>>>    End
85318>>>>>>>>>>>>>>>>>>
85318>>>>>>>>>>>>>>>>>    Function_Return iRet
85319>>>>>>>>>>>>>>>>>  End_Function
85320>>>>>>>>>>>>>>>>>
85320>>>>>>>>>>>>>>>>>  Function CM_GetSelFromPoint Integer xClient Integer yClient Returns Integer
85322>>>>>>>>>>>>>>>>>    Integer iLine iCol
85322>>>>>>>>>>>>>>>>>    Integer iPos
85322>>>>>>>>>>>>>>>>>
85322>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMPOINT xClient yClient to iPos
85323>>>>>>>>>>>>>>>>>    If (iPos>-1) Begin
85325>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
85326>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCOLUMN        iPos to iCol
85327>>>>>>>>>>>>>>>>>
85327>>>>>>>>>>>>>>>>>      Set piSelStartLine                              to iLine
85328>>>>>>>>>>>>>>>>>      Set piSelStartCol                               to iCol
85329>>>>>>>>>>>>>>>>>      Set piSelEndLine                                to iLine
85330>>>>>>>>>>>>>>>>>      Set piSelEndCol                                 to iCol
85331>>>>>>>>>>>>>>>>>    End
85331>>>>>>>>>>>>>>>>>>
85331>>>>>>>>>>>>>>>>>    Function_Return iPos
85332>>>>>>>>>>>>>>>>>  End_Function
85333>>>>>>>>>>>>>>>>>
85333>>>>>>>>>>>>>>>>>  Procedure SC_LineCut
85335>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_LINECUT
85336>>>>>>>>>>>>>>>>>  End_Procedure
85337>>>>>>>>>>>>>>>>>
85337>>>>>>>>>>>>>>>>>  Procedure SC_UppercaseSelection
85339>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_UPPERCASE
85340>>>>>>>>>>>>>>>>>  End_Procedure
85341>>>>>>>>>>>>>>>>>
85341>>>>>>>>>>>>>>>>>  Procedure SC_LowercaseSelection
85343>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_LOWERCASE
85344>>>>>>>>>>>>>>>>>  End_Procedure
85345>>>>>>>>>>>>>>>>>
85345>>>>>>>>>>>>>>>>>  // An application sends CMM_SELECTLINE to select a line of text in the edit buffer
85345>>>>>>>>>>>>>>>>>  // bMakeVisible
85345>>>>>>>>>>>>>>>>>  // If TRUE, the line will be scrolled into view if necessary. If FALSE, the line will never be scrolled.
85345>>>>>>>>>>>>>>>>>  //
85345>>>>>>>>>>>>>>>>>  Function CM_SelectLine Integer iLine Integer bMakeVisible Returns Integer
85347>>>>>>>>>>>>>>>>>    Integer iAnchor
85347>>>>>>>>>>>>>>>>>    Integer iCaret
85347>>>>>>>>>>>>>>>>>    Integer iRet
85347>>>>>>>>>>>>>>>>>
85347>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iAnchor
85348>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINEENDPOSITION iline to iCaret
85349>>>>>>>>>>>>>>>>>    If (bMakeVisible) Begin
85351>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_SETSEL iAnchor iCaret to iRet
85352>>>>>>>>>>>>>>>>>    End
85352>>>>>>>>>>>>>>>>>>
85352>>>>>>>>>>>>>>>>>    Else Begin
85353>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONSTART iAnchor
85354>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONEND   iCaret
85355>>>>>>>>>>>>>>>>>    End
85355>>>>>>>>>>>>>>>>>>
85355>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85356>>>>>>>>>>>>>>>>>  End_Function
85357>>>>>>>>>>>>>>>>>  Function CM_HitTest Integer xClient Integer yClient Returns Integer
85359>>>>>>>>>>>>>>>>>    Integer iPos
85359>>>>>>>>>>>>>>>>>    Integer iRet
85359>>>>>>>>>>>>>>>>>
85359>>>>>>>>>>>>>>>>>    Move CM_NOWHERE to iRet
85360>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CHARPOSITIONFROMPOINT xClient yClient to iPos
85361>>>>>>>>>>>>>>>>>    If (iPos>-1) Begin
85363>>>>>>>>>>>>>>>>>      Move CM_EDITSPACE To iRet
85364>>>>>>>>>>>>>>>>>    End
85364>>>>>>>>>>>>>>>>>>
85364>>>>>>>>>>>>>>>>>    Function_Return (65536*iRet)
85365>>>>>>>>>>>>>>>>>  End_Function
85366>>>>>>>>>>>>>>>>>  Function CM_EnableDragDrop Integer bEnable Returns Integer
85368>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEDRAGDROP,  ( bEnable ), 0 ) )
85369>>>>>>>>>>>>>>>>>  End_Function
85370>>>>>>>>>>>>>>>>>  Function CM_IsDragDropEnabled Returns Integer
85372>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISDRAGDROPENABLED, 0, 0 ) )
85373>>>>>>>>>>>>>>>>>  End_Function
85374>>>>>>>>>>>>>>>>>
85374>>>>>>>>>>>>>>>>>  //
85374>>>>>>>>>>>>>>>>>  // ToDo: Currently no support for splitter screen
85374>>>>>>>>>>>>>>>>>  //
85374>>>>>>>>>>>>>>>>>  //    Function CM_EnableSplitter Integer bHorz Integer bEnable Returns Integer
85374>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESPLITTER,  ( bHorz ), ( bEnable ) ) )
85374>>>>>>>>>>>>>>>>>  //    End_Function
85374>>>>>>>>>>>>>>>>>  //    Function CM_IsSplitterEnabled Integer bHorz Returns Integer
85374>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_ISSPLITTERENABLED,  ( bHorz ), 0 ) )
85374>>>>>>>>>>>>>>>>>  //    End_Function
85374>>>>>>>>>>>>>>>>>  Function CM_EnableColumnSel Integer bEnable Returns Integer
85376>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLUMNSEL,  ( bEnable ), 0 ) )
85377>>>>>>>>>>>>>>>>>  End_Function
85378>>>>>>>>>>>>>>>>>  Function CM_IsColumnSelEnabled Returns Integer
85380>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLUMNSELENABLED, 0, 0 ) )
85381>>>>>>>>>>>>>>>>>  End_Function
85382>>>>>>>>>>>>>>>>>  Function CM_EnableGlobalProps Integer bEnable Returns Integer
85384>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEGLOBALPROPS,  ( bEnable ), 0 ) )
85385>>>>>>>>>>>>>>>>>  End_Function
85386>>>>>>>>>>>>>>>>>  Function CM_IsGlobalPropsEnabled Returns Integer
85388>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISGLOBALPROPSENABLED, 0, 0 ) )
85389>>>>>>>>>>>>>>>>>  End_Function
85390>>>>>>>>>>>>>>>>>  Function CM_SetDlgParent Integer hWndParent Returns Integer
85392>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETDLGPARENT,  ( hWndParent ), 0 ) )
85393>>>>>>>>>>>>>>>>>  End_Function
85394>>>>>>>>>>>>>>>>>  Function CM_EnableSelBounds Integer bEnable Returns Integer
85396>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESELBOUNDS,  ( bEnable ), 0 ) )
85397>>>>>>>>>>>>>>>>>  End_Function
85398>>>>>>>>>>>>>>>>>  Function CM_IsSelBoundsEnabled Returns Integer
85400>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISSELBOUNDSENABLED, 0, 0 ) )
85401>>>>>>>>>>>>>>>>>  End_Function
85402>>>>>>>>>>>>>>>>>
85402>>>>>>>>>>>>>>>>>  Function CM_SetLineStyle Integer nLine Integer dwStyle Returns Integer
85404>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETLINESTYLE,  ( nLine ), ( dwStyle ) ) )
85405>>>>>>>>>>>>>>>>>  End_Function
85406>>>>>>>>>>>>>>>>>  Function CM_GetLineStyle Integer nLine Returns Integer
85408>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETLINESTYLE,  ( nLine ), 0 ) )
85409>>>>>>>>>>>>>>>>>  End_Function
85410>>>>>>>>>>>>>>>>>  Procedure LineChangedMark Integer iLine
85412>>>>>>>>>>>>>>>>>    Boolean  bChanged
85412>>>>>>>>>>>>>>>>>    Handle   hMarkers
85412>>>>>>>>>>>>>>>>>    Handle   hChangedMark
85412>>>>>>>>>>>>>>>>>
85412>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERGET iLine to hMarkers
85413>>>>>>>>>>>>>>>>>    If ((hMarkers iAnd SC_MASK_CHANGEDLINEUNSAVED)=0) Begin
85415>>>>>>>>>>>>>>>>>      Get CM_IsModified to bChanged
85416>>>>>>>>>>>>>>>>>      If (bChanged) Begin
85418>>>>>>>>>>>>>>>>>        If (hMarkers iAnd SC_MASK_CHANGEDLINE) Begin
85420>>>>>>>>>>>>>>>>>          // There is a saved change line marker. We have to remove it or we won't see our current changed line mark
85420>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINESAVED
85421>>>>>>>>>>>>>>>>>        End
85421>>>>>>>>>>>>>>>>>>
85421>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_CHANGEDLINE to hChangedMark
85422>>>>>>>>>>>>>>>>>      End
85422>>>>>>>>>>>>>>>>>>
85422>>>>>>>>>>>>>>>>>    End
85422>>>>>>>>>>>>>>>>>>
85422>>>>>>>>>>>>>>>>>    Else Begin  // if the line has marker we need to check if the user brought the line back to original state so
85423>>>>>>>>>>>>>>>>>      // that we can remove the line. This code needs to be fast, so we start by comparing length.
85423>>>>>>>>>>>>>>>>>      If (Length(CM_GetLine(Self,iLine))=Length(psLineOnEnter(Self))) Begin
85425>>>>>>>>>>>>>>>>>        If (CM_GetLine(Self,iLine)=psLineOnEnter(Self)) Begin // again we want speed, so don't copy to local variables
85427>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
85428>>>>>>>>>>>>>>>>>        End
85428>>>>>>>>>>>>>>>>>>
85428>>>>>>>>>>>>>>>>>      End
85428>>>>>>>>>>>>>>>>>>
85428>>>>>>>>>>>>>>>>>    End
85428>>>>>>>>>>>>>>>>>>
85428>>>>>>>>>>>>>>>>>  End_Procedure
85429>>>>>>>>>>>>>>>>>
85429>>>>>>>>>>>>>>>>>  //
85429>>>>>>>>>>>>>>>>>  // Enumerates through all of the Changed Line markers in the document and sets them as saved
85429>>>>>>>>>>>>>>>>>  // changed line markers
85429>>>>>>>>>>>>>>>>>  //
85429>>>>>>>>>>>>>>>>>  Procedure MarkChangedLinesAsSaved
85431>>>>>>>>>>>>>>>>>    Integer iLine
85431>>>>>>>>>>>>>>>>>    Handle  hMark
85431>>>>>>>>>>>>>>>>>
85431>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_CHANGEDLINEUNSAVED to iLine
85432>>>>>>>>>>>>>>>>>    While (iLine>-1)
85436>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
85437>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_MARKERADD    iLine SC_MARKNUM_CHANGEDLINESAVED   to hMark
85438>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_MARKERNEXT  (iLine+1) SC_MASK_CHANGEDLINEUNSAVED to iLine
85439>>>>>>>>>>>>>>>>>    Loop
85440>>>>>>>>>>>>>>>>>>
85440>>>>>>>>>>>>>>>>>  End_Procedure
85441>>>>>>>>>>>>>>>>>
85441>>>>>>>>>>>>>>>>>  Function CM_SetBookmark Integer nLine Integer bEnable Returns Integer
85443>>>>>>>>>>>>>>>>>    Handle   hMarkers
85443>>>>>>>>>>>>>>>>>    Handle   hBookMark
85443>>>>>>>>>>>>>>>>>
85443>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERGET nLine to hMarkers
85444>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85446>>>>>>>>>>>>>>>>>      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)=false) Begin
85448>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_MARKERADD nLine SC_MARKNUM_BOOKMARK to hBookMark
85449>>>>>>>>>>>>>>>>>      End
85449>>>>>>>>>>>>>>>>>>
85449>>>>>>>>>>>>>>>>>    End
85449>>>>>>>>>>>>>>>>>>
85449>>>>>>>>>>>>>>>>>    Else Begin
85450>>>>>>>>>>>>>>>>>      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
85452>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_MARKERDELETE nLine SC_MARKNUM_BOOKMARK
85453>>>>>>>>>>>>>>>>>      End
85453>>>>>>>>>>>>>>>>>>
85453>>>>>>>>>>>>>>>>>    End
85453>>>>>>>>>>>>>>>>>>
85453>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85454>>>>>>>>>>>>>>>>>  End_Function
85455>>>>>>>>>>>>>>>>>  Function CM_GetBookmark Integer nLine Returns Integer
85457>>>>>>>>>>>>>>>>>    Boolean bHasBookMark
85457>>>>>>>>>>>>>>>>>    Handle hMarkers
85457>>>>>>>>>>>>>>>>>
85457>>>>>>>>>>>>>>>>>    Move False to bHasBookMark
85458>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERGET nLine to hMarkers
85459>>>>>>>>>>>>>>>>>    If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
85461>>>>>>>>>>>>>>>>>      Move True To bHasBookMark
85462>>>>>>>>>>>>>>>>>    End
85462>>>>>>>>>>>>>>>>>>
85462>>>>>>>>>>>>>>>>>    Function_Return bHasBookMark
85463>>>>>>>>>>>>>>>>>  End_Function
85464>>>>>>>>>>>>>>>>>
85464>>>>>>>>>>>>>>>>>  Procedure BookmarkToggle
85466>>>>>>>>>>>>>>>>>    Boolean bHasBookmark
85466>>>>>>>>>>>>>>>>>    Integer iLine
85466>>>>>>>>>>>>>>>>>    Integer iVoid
85466>>>>>>>>>>>>>>>>>
85466>>>>>>>>>>>>>>>>>    Get Current_Line to iLine
85467>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
85469>>>>>>>>>>>>>>>>>      Get CM_GetBookmark iLine to bHasBookmark
85470>>>>>>>>>>>>>>>>>      Get CM_SetBookmark iLine (not(bHasBookmark)) to iVoid
85471>>>>>>>>>>>>>>>>>    End
85471>>>>>>>>>>>>>>>>>>
85471>>>>>>>>>>>>>>>>>  End_Procedure
85472>>>>>>>>>>>>>>>>>
85472>>>>>>>>>>>>>>>>>  Procedure BookmarkNext
85474>>>>>>>>>>>>>>>>>    Integer iLine
85474>>>>>>>>>>>>>>>>>    Integer iLineStart
85474>>>>>>>>>>>>>>>>>    Get Current_Line to iLineStart
85475>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT (iLineStart+1) SC_MASK_BOOKMARK to iLine
85476>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
85478>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
85479>>>>>>>>>>>>>>>>>    End
85479>>>>>>>>>>>>>>>>>>
85479>>>>>>>>>>>>>>>>>  End_Procedure
85480>>>>>>>>>>>>>>>>>
85480>>>>>>>>>>>>>>>>>  Procedure BookmarkPrevious
85482>>>>>>>>>>>>>>>>>    Integer iLine
85482>>>>>>>>>>>>>>>>>    Integer iLineStart
85482>>>>>>>>>>>>>>>>>    Get Current_Line to iLineStart
85483>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERPREVIOUS (iLineStart-1) SC_MASK_BOOKMARK to iLine
85484>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
85486>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
85487>>>>>>>>>>>>>>>>>    End
85487>>>>>>>>>>>>>>>>>>
85487>>>>>>>>>>>>>>>>>  End_Procedure
85488>>>>>>>>>>>>>>>>>
85488>>>>>>>>>>>>>>>>>  Procedure BookmarkJumpToFirst
85490>>>>>>>>>>>>>>>>>    Integer iLine
85490>>>>>>>>>>>>>>>>>    Integer iLineStart
85490>>>>>>>>>>>>>>>>>
85490>>>>>>>>>>>>>>>>>    Move 0 to iLineStart
85491>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT iLineStart SC_MASK_BOOKMARK to iLine
85492>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
85494>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
85495>>>>>>>>>>>>>>>>>    End
85495>>>>>>>>>>>>>>>>>>
85495>>>>>>>>>>>>>>>>>  End_Procedure
85496>>>>>>>>>>>>>>>>>
85496>>>>>>>>>>>>>>>>>  Procedure BookmarkJumpToLast
85498>>>>>>>>>>>>>>>>>    Integer iLine
85498>>>>>>>>>>>>>>>>>    Integer iLineStart
85498>>>>>>>>>>>>>>>>>
85498>>>>>>>>>>>>>>>>>    Get SC_LineCount to iLineStart
85499>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERPREVIOUS iLineStart SC_MASK_BOOKMARK to iLine
85500>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
85502>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
85503>>>>>>>>>>>>>>>>>    End
85503>>>>>>>>>>>>>>>>>>
85503>>>>>>>>>>>>>>>>>  End_Procedure
85504>>>>>>>>>>>>>>>>>
85504>>>>>>>>>>>>>>>>>  Procedure BookmarkClearAll
85506>>>>>>>>>>>>>>>>>    Integer iLine
85506>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
85507>>>>>>>>>>>>>>>>>    While (iLine>-1)
85511>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_BOOKMARK
85512>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
85513>>>>>>>>>>>>>>>>>    Loop
85514>>>>>>>>>>>>>>>>>>
85514>>>>>>>>>>>>>>>>>  End_Procedure
85515>>>>>>>>>>>>>>>>>
85515>>>>>>>>>>>>>>>>>  Function CM_SetAllBookmarks Integer iCountNotUsed String sData Returns Integer
85517>>>>>>>>>>>>>>>>>    Integer   iCount
85517>>>>>>>>>>>>>>>>>    Integer   iItem
85517>>>>>>>>>>>>>>>>>    Integer   iLine
85517>>>>>>>>>>>>>>>>>    Integer   iVoid
85517>>>>>>>>>>>>>>>>>    Integer[] Bookmarks
85518>>>>>>>>>>>>>>>>>
85518>>>>>>>>>>>>>>>>>    Move (ConvertAsciiToIntegerArray(sData)) To Bookmarks
85519>>>>>>>>>>>>>>>>>    Move (SizeOfArray(Bookmarks)) To iCount
85520>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
85522>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
85528>>>>>>>>>>>>>>>>>>
85528>>>>>>>>>>>>>>>>>        Move Bookmarks[iItem] To iLine
85529>>>>>>>>>>>>>>>>>        If (iLine>0) Begin
85531>>>>>>>>>>>>>>>>>          Get CM_SetBookmark iLine True to iVoid
85532>>>>>>>>>>>>>>>>>        End
85532>>>>>>>>>>>>>>>>>>
85532>>>>>>>>>>>>>>>>>      Loop
85533>>>>>>>>>>>>>>>>>>
85533>>>>>>>>>>>>>>>>>    End
85533>>>>>>>>>>>>>>>>>>
85533>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85534>>>>>>>>>>>>>>>>>  End_Function
85535>>>>>>>>>>>>>>>>>
85535>>>>>>>>>>>>>>>>>  Function SC_AllBookmarksToIntegerArray Returns Integer[]
85537>>>>>>>>>>>>>>>>>    Integer iLine
85537>>>>>>>>>>>>>>>>>    Integer[] Bookmarks
85538>>>>>>>>>>>>>>>>>
85538>>>>>>>>>>>>>>>>>    Move (ResizeArray(Bookmarks,0)) To Bookmarks
85539>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
85540>>>>>>>>>>>>>>>>>    While (iLine>-1)
85544>>>>>>>>>>>>>>>>>      Move iLine To Bookmarks[SizeOfArray(Bookmarks)]
85545>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
85546>>>>>>>>>>>>>>>>>    Loop
85547>>>>>>>>>>>>>>>>>>
85547>>>>>>>>>>>>>>>>>    Function_Return Bookmarks
85548>>>>>>>>>>>>>>>>>  End_Function
85549>>>>>>>>>>>>>>>>>
85549>>>>>>>>>>>>>>>>>  Function CM_GetAllBookmarks Returns String
85551>>>>>>>>>>>>>>>>>    String sData
85551>>>>>>>>>>>>>>>>>    Integer[] Bookmarks
85552>>>>>>>>>>>>>>>>>
85552>>>>>>>>>>>>>>>>>    Get SC_AllBookmarksToIntegerArray to Bookmarks
85553>>>>>>>>>>>>>>>>>    Get ConvertIntegerArrayToAscii Bookmarks to sData
85554>>>>>>>>>>>>>>>>>    Function_Return sData
85555>>>>>>>>>>>>>>>>>  End_Function
85556>>>>>>>>>>>>>>>>>
85556>>>>>>>>>>>>>>>>>  //
85556>>>>>>>>>>>>>>>>>  // We're only offering On/Off, the iStart and iMode options are ignored.
85556>>>>>>>>>>>>>>>>>  //
85556>>>>>>>>>>>>>>>>>  Function CM_SetLineNumbering Integer bEnable Integer iStart Integer iMode Returns Integer
85558>>>>>>>>>>>>>>>>>    Integer iMarginWidth
85558>>>>>>>>>>>>>>>>>    Integer iDigits
85558>>>>>>>>>>>>>>>>>    Integer iLineCount
85558>>>>>>>>>>>>>>>>>    String  sMaxLine
85558>>>>>>>>>>>>>>>>>
85558>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85560>>>>>>>>>>>>>>>>>      // figure out the width we need based on max line count
85560>>>>>>>>>>>>>>>>>      Get SC_LineCount to iLineCount
85561>>>>>>>>>>>>>>>>>      If (iLineCount>999) Begin
85563>>>>>>>>>>>>>>>>>        Move (Length(Trim(iLineCount))) To iDigits
85564>>>>>>>>>>>>>>>>>        Move ("_"+repeat("9",iDigits)+Character(0)) To sMaxLine
85565>>>>>>>>>>>>>>>>>      End
85565>>>>>>>>>>>>>>>>>>
85565>>>>>>>>>>>>>>>>>      Else Begin  // so if it is called at that time then hardwire a fixed width
85566>>>>>>>>>>>>>>>>>        Move 3 To iDigits // we don't count the "_" offset, this is our default, we don't get lower as 3
85567>>>>>>>>>>>>>>>>>        Move ("_999"+Character(0)) To sMaxLine
85568>>>>>>>>>>>>>>>>>      End
85568>>>>>>>>>>>>>>>>>>
85568>>>>>>>>>>>>>>>>>      Set piMarginLineNumberDigits to iDigits
85569>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_TEXTWIDTH STYLE_LINENUMBER (AddressOf(sMaxLine)) to iMarginWidth
85570>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS iMarginWidth
85571>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMARGINMASKN  MARGIN_LINE_NUMBERS SC_MASK_MARGIN
85572>>>>>>>>>>>>>>>>>    End
85572>>>>>>>>>>>>>>>>>>
85572>>>>>>>>>>>>>>>>>    Else Begin
85573>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS 0
85574>>>>>>>>>>>>>>>>>    End
85574>>>>>>>>>>>>>>>>>>
85574>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85575>>>>>>>>>>>>>>>>>  End_Function
85576>>>>>>>>>>>>>>>>>  //
85576>>>>>>>>>>>>>>>>>  // Returns 0 if not enabled or CM_DECIMAL if it is
85576>>>>>>>>>>>>>>>>>  //
85576>>>>>>>>>>>>>>>>>  Function CM_GetLineNumbering Returns Integer
85578>>>>>>>>>>>>>>>>>    Integer iRet iWidth
85578>>>>>>>>>>>>>>>>>
85578>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS to iWidth
85579>>>>>>>>>>>>>>>>>    If (iWidth>0) Begin
85581>>>>>>>>>>>>>>>>>      Move CM_DECIMAL To iRet
85582>>>>>>>>>>>>>>>>>    End
85582>>>>>>>>>>>>>>>>>>
85582>>>>>>>>>>>>>>>>>    Else Begin
85583>>>>>>>>>>>>>>>>>      Move 0 To iRet
85584>>>>>>>>>>>>>>>>>    End
85584>>>>>>>>>>>>>>>>>>
85584>>>>>>>>>>>>>>>>>    Function_Return iRet
85585>>>>>>>>>>>>>>>>>  End_Function
85586>>>>>>>>>>>>>>>>>  Function CM_PosFromChar Integer iLine Integer iCol Returns Integer
85588>>>>>>>>>>>>>>>>>    Integer iX iY iPos
85588>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
85589>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POINTXFROMPOSITION 0 iPos to iX
85590>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POINTYFROMPOSITION 0 iPos to iY
85591>>>>>>>>>>>>>>>>>    Set piPosStartX                     to iX
85592>>>>>>>>>>>>>>>>>    Set piPosStartY                     to iY
85593>>>>>>>>>>>>>>>>>    Set piPosEndX                       to iX
85594>>>>>>>>>>>>>>>>>    Set piPosEndY                       to iY
85595>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85596>>>>>>>>>>>>>>>>>  End_Function
85597>>>>>>>>>>>>>>>>>  Function CM_EnableHideSel Integer bEnable Returns Integer
85599>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEHIDESEL,  ( bEnable ), 0 ) )
85600>>>>>>>>>>>>>>>>>  End_Function
85601>>>>>>>>>>>>>>>>>  Function CM_IsHideSelEnabled Returns Integer
85603>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISHIDESELENABLED, 0, 0 ) )
85604>>>>>>>>>>>>>>>>>  End_Function
85605>>>>>>>>>>>>>>>>>
85605>>>>>>>>>>>>>>>>>  //
85605>>>>>>>>>>>>>>>>>  // If a line is already highlighted then this will remove the highlight
85605>>>>>>>>>>>>>>>>>  //
85605>>>>>>>>>>>>>>>>>  Procedure ResetHighlightedLine
85607>>>>>>>>>>>>>>>>>    Handle  hMarker
85607>>>>>>>>>>>>>>>>>    Integer iLine
85607>>>>>>>>>>>>>>>>>    // Is there already a highlighted line? If so first delete the highlight on that line
85607>>>>>>>>>>>>>>>>>    Get phMarkerLineHighLight to hMarker
85608>>>>>>>>>>>>>>>>>    If (hMarker<>0) Begin
85610>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
85611>>>>>>>>>>>>>>>>>      If (iLine>-1) Begin
85613>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_LINEHIGHLIGHT
85614>>>>>>>>>>>>>>>>>      End
85614>>>>>>>>>>>>>>>>>>
85614>>>>>>>>>>>>>>>>>      Set phMarkerLineHighLight to 0
85615>>>>>>>>>>>>>>>>>    End
85615>>>>>>>>>>>>>>>>>>
85615>>>>>>>>>>>>>>>>>  End_Procedure
85616>>>>>>>>>>>>>>>>>
85616>>>>>>>>>>>>>>>>>  Function CM_SetHighlightedLine Integer iLine Returns Integer
85618>>>>>>>>>>>>>>>>>    Handle  hMarker
85618>>>>>>>>>>>>>>>>>
85618>>>>>>>>>>>>>>>>>    If (iLine>0) Begin
85620>>>>>>>>>>>>>>>>>      Send ResetHighlightedLine
85621>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_LINEHIGHLIGHT to hMarker
85622>>>>>>>>>>>>>>>>>      Set phMarkerLineHighLight to hMarker
85623>>>>>>>>>>>>>>>>>    End
85623>>>>>>>>>>>>>>>>>>
85623>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85624>>>>>>>>>>>>>>>>>  End_Function
85625>>>>>>>>>>>>>>>>>  //
85625>>>>>>>>>>>>>>>>>  // An application sends CMM_GETHIGHLIGHTEDLINE to retrieve the index of the currently highlighted line.
85625>>>>>>>>>>>>>>>>>  // The highlighted line can be used for marking the currently executing line when used in a debugger
85625>>>>>>>>>>>>>>>>>  // application
85625>>>>>>>>>>>>>>>>>  // Return Values
85625>>>>>>>>>>>>>>>>>  // The zero-based index of the line that is currently highlighted.
85625>>>>>>>>>>>>>>>>>  // If no line is highlighted, the return value is -1.
85625>>>>>>>>>>>>>>>>>  Function CM_GetHighlightedLine Returns Integer
85627>>>>>>>>>>>>>>>>>    Handle  hMarker
85627>>>>>>>>>>>>>>>>>    Integer iLine
85627>>>>>>>>>>>>>>>>>
85627>>>>>>>>>>>>>>>>>    Move -1 To iLine
85628>>>>>>>>>>>>>>>>>    Get phMarkerLineHighLight to hMarker
85629>>>>>>>>>>>>>>>>>    If (hMarker<>0) Begin
85631>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
85632>>>>>>>>>>>>>>>>>    End
85632>>>>>>>>>>>>>>>>>>
85632>>>>>>>>>>>>>>>>>    Function_Return iLine
85633>>>>>>>>>>>>>>>>>  End_Function
85634>>>>>>>>>>>>>>>>>  Function CM_EnableNormalizeCase Integer bEnable Returns Integer
85636>>>>>>>>>>>>>>>>>    Set pbNormalizeCase to bEnable
85637>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85638>>>>>>>>>>>>>>>>>  End_Function
85639>>>>>>>>>>>>>>>>>  Function CM_IsNormalizeCaseEnabled Returns Integer
85641>>>>>>>>>>>>>>>>>    Boolean bNormalized
85641>>>>>>>>>>>>>>>>>    Get pbNormalizeCase to bNormalized
85642>>>>>>>>>>>>>>>>>    Function_Return bNormalized
85643>>>>>>>>>>>>>>>>>  End_Function
85644>>>>>>>>>>>>>>>>>  Function CM_SetDivider Integer nLine Integer bEnable Returns Integer
85646>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETDIVIDER,  ( nLine ), ( bEnable ) ) )
85647>>>>>>>>>>>>>>>>>  End_Function
85648>>>>>>>>>>>>>>>>>  Function CM_GetDivider Integer nLine Returns Integer
85650>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETDIVIDER,  ( nLine ), 0 ) )
85651>>>>>>>>>>>>>>>>>  End_Function
85652>>>>>>>>>>>>>>>>>
85652>>>>>>>>>>>>>>>>>  //
85652>>>>>>>>>>>>>>>>>  // An application sends CMM_ENABLEOVERTYPECARET to control the size of the text caret when in overtype mode.
85652>>>>>>>>>>>>>>>>>  Function CM_EnableOvertypeCaret Integer bEnable Returns Integer
85654>>>>>>>>>>>>>>>>>    Integer iRet
85654>>>>>>>>>>>>>>>>>    Integer eCaretStyle
85654>>>>>>>>>>>>>>>>>    //
85654>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85656>>>>>>>>>>>>>>>>>      Move CARETSTYLE_BLOCK To eCaretStyle
85657>>>>>>>>>>>>>>>>>    End
85657>>>>>>>>>>>>>>>>>>
85657>>>>>>>>>>>>>>>>>    Else Begin
85658>>>>>>>>>>>>>>>>>      Move CARETSTYLE_LINE  To eCaretStyle
85659>>>>>>>>>>>>>>>>>    End
85659>>>>>>>>>>>>>>>>>>
85659>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETCARETSTYLE eCaretStyle to iRet
85660>>>>>>>>>>>>>>>>>    Function_Return iRet
85661>>>>>>>>>>>>>>>>>  End_Function
85662>>>>>>>>>>>>>>>>>  Function CM_IsOvertypeCaretEnabled Returns Integer
85664>>>>>>>>>>>>>>>>>    Boolean bEnabled
85664>>>>>>>>>>>>>>>>>    Integer eCaretStyle
85664>>>>>>>>>>>>>>>>>    //
85664>>>>>>>>>>>>>>>>>    Move False to bEnabled
85665>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETCARETSTYLE to eCaretStyle  // CMM_ISOVERTYPECARETENABLED
85666>>>>>>>>>>>>>>>>>    If (eCaretStyle=CARETSTYLE_BLOCK) Begin
85668>>>>>>>>>>>>>>>>>      Move True To bEnabled
85669>>>>>>>>>>>>>>>>>    End
85669>>>>>>>>>>>>>>>>>>
85669>>>>>>>>>>>>>>>>>    Function_Return bEnabled
85670>>>>>>>>>>>>>>>>>  End_Function
85671>>>>>>>>>>>>>>>>>  // An application sends CMM_SETFINDTEXT to change the text used in the most current search operation.
85671>>>>>>>>>>>>>>>>>  Function CM_SetFindText String szText  Returns Integer
85673>>>>>>>>>>>>>>>>>    Move (CString(szText)) To szText
85674>>>>>>>>>>>>>>>>>    Set psSearchText to szText
85675>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85676>>>>>>>>>>>>>>>>>  End_Function
85677>>>>>>>>>>>>>>>>>  Function CM_GetFindText Returns String
85679>>>>>>>>>>>>>>>>>    String szText
85679>>>>>>>>>>>>>>>>>    Get psSearchText to szText
85680>>>>>>>>>>>>>>>>>    Move (szText+Character(0)) to szText // check if it makes sense to make this a zero terminated string
85681>>>>>>>>>>>>>>>>>    Function_Return szText
85682>>>>>>>>>>>>>>>>>  End_Function
85683>>>>>>>>>>>>>>>>>
85683>>>>>>>>>>>>>>>>>  Function CM_Print Handle hDC Integer dwFlags Returns Integer
85685>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_PRINT,  ( hDC ), ( dwFlags ) ) )
85686>>>>>>>>>>>>>>>>>  End_Function
85687>>>>>>>>>>>>>>>>>  Function CM_SetCaretPos Integer nLine Integer nCol Returns Integer
85689>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETCARETPOS,  ( nLine ), ( nCol ) ) )
85690>>>>>>>>>>>>>>>>>  End_Function
85691>>>>>>>>>>>>>>>>>  Function CM_ViewColToBufferCol Integer nLine Integer nViewCol  Returns Integer
85693>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_VIEWCOLTOBUFFERCOL,  ( nLine ), ( nViewCol ) ) )
85694>>>>>>>>>>>>>>>>>  End_Function
85695>>>>>>>>>>>>>>>>>  Function CM_BufferColToViewCol Integer nLine Integer nBufferCol Returns Integer
85697>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_BUFFERCOLTOVIEWCOL,  ( nLine ), ( nBufferCol ) ) )
85698>>>>>>>>>>>>>>>>>  End_Function
85699>>>>>>>>>>>>>>>>>  Function CM_SetBorderStyle Integer dwStyle Returns Integer
85701>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETBORDERSTYLE,  ( dwStyle ), 0 ) )
85702>>>>>>>>>>>>>>>>>  End_Function
85703>>>>>>>>>>>>>>>>>  Function CM_GetBorderStyle Returns Integer
85705>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETBORDERSTYLE, 0, 0 ) )
85706>>>>>>>>>>>>>>>>>  End_Function
85707>>>>>>>>>>>>>>>>>  // SVN
85707>>>>>>>>>>>>>>>>>  Function CM_GetCurrentToken Returns Integer
85709>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTTOKEN, 0, 0 ) )
85710>>>>>>>>>>>>>>>>>  End_Function
85711>>>>>>>>>>>>>>>>>  Function CM_UpdateControlPositions Returns Integer
85713>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_UPDATECONTROLPOSITIONS, 0, 0 ) )
85714>>>>>>>>>>>>>>>>>  End_Function
85715>>>>>>>>>>>>>>>>>  // SVN
85715>>>>>>>>>>>>>>>>>
85715>>>>>>>>>>>>>>>>>  //_ADDITION_METHODS_for_an_easier_use.._________________
85715>>>>>>>>>>>>>>>>>
85715>>>>>>>>>>>>>>>>>
85715>>>>>>>>>>>>>>>>>  // ToDo: Out of Scope - Splitting window support in scintilla is not as natural. It can be done
85715>>>>>>>>>>>>>>>>>  // but for the moment I consider it out of scope. The documentation has this to say about it:
85715>>>>>>>>>>>>>>>>>  //
85715>>>>>>>>>>>>>>>>>  // The system is arranged in this way so that you can work with many documents in a single Scintilla
85715>>>>>>>>>>>>>>>>>  // window and so you can display a single document in multiple windows (for use with splitter windows).
85715>>>>>>>>>>>>>>>>>  //
85715>>>>>>>>>>>>>>>>>  //        // Tiling windows...
85715>>>>>>>>>>>>>>>>>  //    Procedure SplitWindowHorizontal
85715>>>>>>>>>>>>>>>>>  //        Integer iRet iPos
85715>>>>>>>>>>>>>>>>>  //        Move (CM_GetSplitterPos(Self,True))         to iPos
85715>>>>>>>>>>>>>>>>>  //        If iPos Eq 0 Move (Low(GuiSize(Self)))      to iPos
85715>>>>>>>>>>>>>>>>>  //        Else         Move 0                         to iPos
85715>>>>>>>>>>>>>>>>>  //        Move (iPos/2)                               to iPos
85715>>>>>>>>>>>>>>>>>  //        Move (CM_SetSplitterPos(Self,True,iPos))    to iRet
85715>>>>>>>>>>>>>>>>>  //    End_Procedure
85715>>>>>>>>>>>>>>>>>  //    Function isSplittedHorizonztal Returns Integer
85715>>>>>>>>>>>>>>>>>  //        Function_Return (CM_GetSplitterPos(Self,True) Ne 0)
85715>>>>>>>>>>>>>>>>>  //    End_Function
85715>>>>>>>>>>>>>>>>>  //    Procedure SplitWindowVertical
85715>>>>>>>>>>>>>>>>>  //        Integer iRet iPos
85715>>>>>>>>>>>>>>>>>  //        Move (CM_GetSplitterPos(Self,False))        to iPos
85715>>>>>>>>>>>>>>>>>  //        If iPos Eq 0 Move (Hi(GuiSize(Self)))       to iPos
85715>>>>>>>>>>>>>>>>>  //        Else         Move 0                         to iPos
85715>>>>>>>>>>>>>>>>>  //        Move (iPos/2)                               to iPos
85715>>>>>>>>>>>>>>>>>  //        Move (CM_SetSplitterPos(Self,False,iPos))   to iRet
85715>>>>>>>>>>>>>>>>>  //    End_Procedure
85715>>>>>>>>>>>>>>>>>  //    Function isSplittedVertical Returns Integer
85715>>>>>>>>>>>>>>>>>  //        Function_Return (CM_GetSplitterPos(Self,False) Ne 0)
85715>>>>>>>>>>>>>>>>>  //    End_Function
85715>>>>>>>>>>>>>>>>>  //        // Is a special usage for the splitter window.
85715>>>>>>>>>>>>>>>>>  //        // gren werden immer angepasst!
85715>>>>>>>>>>>>>>>>>  //    Procedure DuplicateWindow
85715>>>>>>>>>>>>>>>>>  //        If not (isSplittedHorizonztal(Self))     Send SplitWindowHorizontal
85715>>>>>>>>>>>>>>>>>  //        Else If not (isSplittedVertical(Self))   Send SplitWindowVertical
85715>>>>>>>>>>>>>>>>>  //    End_Procedure
85715>>>>>>>>>>>>>>>>>  //        // If all 4 sub windows are used. no more is possible.
85715>>>>>>>>>>>>>>>>>  //    Function isDuplicatePossible Returns Integer
85715>>>>>>>>>>>>>>>>>  //        If (isSplittedHorizonztal(Self)) If (isSplittedVertical(Self)) Function_Return 0
85715>>>>>>>>>>>>>>>>>  //        Function_Return 1
85715>>>>>>>>>>>>>>>>>  //    End_Function
85715>>>>>>>>>>>>>>>>>  //        // Check if some of the splitters are set.
85715>>>>>>>>>>>>>>>>>  //    Function isWindowDuplicated Returns Integer
85715>>>>>>>>>>>>>>>>>  //        If (isSplittedHorizonztal(Self)) Function_Return 1
85715>>>>>>>>>>>>>>>>>  //        If (isSplittedVertical(Self))    Function_Return 1
85715>>>>>>>>>>>>>>>>>  //        Function_Return 0
85715>>>>>>>>>>>>>>>>>  //    End_Function
85715>>>>>>>>>>>>>>>>>
85715>>>>>>>>>>>>>>>>>  // Removes all Splitter windows and
85715>>>>>>>>>>>>>>>>>  Procedure CloseWindow
85717>>>>>>>>>>>>>>>>>    //        If (isSplittedVertical(Self))           Send SplitWindowVertical
85717>>>>>>>>>>>>>>>>>    //        Else If (isSplittedHorizonztal(Self))   Send SplitWindowHorizontal
85717>>>>>>>>>>>>>>>>>  End_Procedure
85718>>>>>>>>>>>>>>>>>  // Select All
85718>>>>>>>>>>>>>>>>>  Procedure SelectAll
85720>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SELECTALL
85721>>>>>>>>>>>>>>>>>  End_Procedure
85722>>>>>>>>>>>>>>>>>
85722>>>>>>>>>>>>>>>>>  // Select this line...
85722>>>>>>>>>>>>>>>>>  Procedure SelectLine
85724>>>>>>>>>>>>>>>>>    Integer iRet
85724>>>>>>>>>>>>>>>>>    Get CM_ExecuteCmd CMD_SELECTLINE 0 to iRet
85725>>>>>>>>>>>>>>>>>  End_Procedure
85726>>>>>>>>>>>>>>>>>  // Deletes this line...
85726>>>>>>>>>>>>>>>>>  Procedure DeleteLine
85728>>>>>>>>>>>>>>>>>    Integer iRet
85728>>>>>>>>>>>>>>>>>    Get CM_ExecuteCmd CMD_LINEDELETE 0 to iRet
85729>>>>>>>>>>>>>>>>>  End_Procedure
85730>>>>>>>>>>>>>>>>>
85730>>>>>>>>>>>>>>>>>
85730>>>>>>>>>>>>>>>>>
85730>>>>>>>>>>>>>>>>>  Procedure MoveLineUp
85732>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MOVESELECTEDLINESUP
85733>>>>>>>>>>>>>>>>>  End_Procedure
85734>>>>>>>>>>>>>>>>>
85734>>>>>>>>>>>>>>>>>  Procedure MoveLineDown
85736>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MOVESELECTEDLINESDOWN
85737>>>>>>>>>>>>>>>>>  End_Procedure
85738>>>>>>>>>>>>>>>>>
85738>>>>>>>>>>>>>>>>>  Procedure DuplicateSelection
85740>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SELECTIONDUPLICATE
85741>>>>>>>>>>>>>>>>>  End_Procedure
85742>>>>>>>>>>>>>>>>>
85742>>>>>>>>>>>>>>>>>  Function SetSearchOptions tFindReplaceOptions FindOptions Returns Integer
85744>>>>>>>>>>>>>>>>>    Integer iFlags
85744>>>>>>>>>>>>>>>>>
85744>>>>>>>>>>>>>>>>>    Move 0 to iFlags
85745>>>>>>>>>>>>>>>>>    Move (If(FindOptions.bWordMatch,iFlags iOr SCFIND_WHOLEWORD,iFlags)) To iFlags
85746>>>>>>>>>>>>>>>>>    Move (If(FindOptions.bMatchCase,iFlags iOr SCFIND_MATCHCASE,iFlags)) To iFlags
85747>>>>>>>>>>>>>>>>>    Move (If(FindOptions.bRegExp   ,iFlags iOr SCFIND_REGEXP   ,iFlags)) To iFlags
85748>>>>>>>>>>>>>>>>>    Set pbFindDocumentStart To FindOptions.bDocumentStart
85749>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETSEARCHFLAGS iFlags
85750>>>>>>>>>>>>>>>>>    Function_Return iFlags
85751>>>>>>>>>>>>>>>>>  End_Function
85752>>>>>>>>>>>>>>>>>
85752>>>>>>>>>>>>>>>>>  Function CurrentSearchOptions String sSearchText Returns tFindReplaceOptions
85754>>>>>>>>>>>>>>>>>    Integer iFlags
85754>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
85754>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
85754>>>>>>>>>>>>>>>>>
85754>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85755>>>>>>>>>>>>>>>>>    Move sSearchText                    To FindOptions.sSearchText
85756>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_WHOLEWORD) To FindOptions.bWordMatch
85757>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_MATCHCASE) To FindOptions.bMatchCase
85758>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_REGEXP)    To FindOptions.bRegExp
85759>>>>>>>>>>>>>>>>>    Get pbFindDocumentStart To FindOptions.bDocumentStart
85760>>>>>>>>>>>>>>>>>    Function_Return FindOptions
85761>>>>>>>>>>>>>>>>>  End_Function
85762>>>>>>>>>>>>>>>>>
85762>>>>>>>>>>>>>>>>>
85762>>>>>>>>>>>>>>>>>  // Find...
85762>>>>>>>>>>>>>>>>>  Procedure Find
85764>>>>>>>>>>>>>>>>>    Integer iFlags
85764>>>>>>>>>>>>>>>>>    Integer iCaretPos
85764>>>>>>>>>>>>>>>>>    Integer iPos
85764>>>>>>>>>>>>>>>>>    Integer iLen
85764>>>>>>>>>>>>>>>>>    Integer iLine
85764>>>>>>>>>>>>>>>>>    Integer iVoid
85764>>>>>>>>>>>>>>>>>    String  sSearchText
85764>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
85764>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
85764>>>>>>>>>>>>>>>>>
85764>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
85765>>>>>>>>>>>>>>>>>    //
85765>>>>>>>>>>>>>>>>>    Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
85766>>>>>>>>>>>>>>>>>    Get CurrentSearchOptions sSearchText to FindOptions
85767>>>>>>>>>>>>>>>>>    Move FindDown         To FindOptions.eFindOptions // search down by default
85768>>>>>>>>>>>>>>>>>    Send RequestDetails of oFindDialog (&FindOptions)
85769>>>>>>>>>>>>>>>>>    If (FindOptions.bStartFind) Begin
85771>>>>>>>>>>>>>>>>>      // First update any changed search flags
85771>>>>>>>>>>>>>>>>>      Get SetSearchOptions FindOptions to iFlags
85772>>>>>>>>>>>>>>>>>      Move FindOptions.sSearchText To sSearchText
85773>>>>>>>>>>>>>>>>>      Set psSearchText to sSearchText
85774>>>>>>>>>>>>>>>>>      Move (Length(sSearchText)) To iLen
85775>>>>>>>>>>>>>>>>>      If (iLen>0) Begin
85777>>>>>>>>>>>>>>>>>        If (FindOptions.bDocumentStart=False) Begin
85779>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETCURRENTPOS To iCaretPos
85780>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETTARGETSTART iCaretPos
85781>>>>>>>>>>>>>>>>>        End
85781>>>>>>>>>>>>>>>>>>
85781>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
85782>>>>>>>>>>>>>>>>>        If (iPos > -1) Begin
85784>>>>>>>>>>>>>>>>>          If (FindOptions.bMarkAll=false) Begin
85786>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
85787>>>>>>>>>>>>>>>>>          End
85787>>>>>>>>>>>>>>>>>>
85787>>>>>>>>>>>>>>>>>          Else Begin  // Mark All logic
85788>>>>>>>>>>>>>>>>>            Move iPos To iCaretPos
85789>>>>>>>>>>>>>>>>>            While (iPos>-1)
85793>>>>>>>>>>>>>>>>>              // set bookmark for found position
85793>>>>>>>>>>>>>>>>>              Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
85794>>>>>>>>>>>>>>>>>              Get CM_SetBookmark iLine True to iVoid
85795>>>>>>>>>>>>>>>>>              // find next
85795>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
85796>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_SEARCHANCHOR
85797>>>>>>>>>>>>>>>>>              Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
85798>>>>>>>>>>>>>>>>>            Loop
85799>>>>>>>>>>>>>>>>>>
85799>>>>>>>>>>>>>>>>>            If (iCaretPos>-1) Begin
85801>>>>>>>>>>>>>>>>>              // select first found
85801>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
85802>>>>>>>>>>>>>>>>>            End
85802>>>>>>>>>>>>>>>>>>
85802>>>>>>>>>>>>>>>>>          End
85802>>>>>>>>>>>>>>>>>>
85802>>>>>>>>>>>>>>>>>        End
85802>>>>>>>>>>>>>>>>>>
85802>>>>>>>>>>>>>>>>>      End
85802>>>>>>>>>>>>>>>>>>
85802>>>>>>>>>>>>>>>>>    End
85802>>>>>>>>>>>>>>>>>>
85802>>>>>>>>>>>>>>>>>
85802>>>>>>>>>>>>>>>>>    //
85802>>>>>>>>>>>>>>>>>    // There's an alternative interface that works like this, not seeing why this would be more
85802>>>>>>>>>>>>>>>>>    // convenient.
85802>>>>>>>>>>>>>>>>>    //
85802>>>>>>>>>>>>>>>>>    //Integer iStartPos
85802>>>>>>>>>>>>>>>>>    //Integer iEndPos
85802>>>>>>>>>>>>>>>>>    //Sci_TextToFind ft
85802>>>>>>>>>>>>>>>>>    //
85802>>>>>>>>>>>>>>>>>    //Move 0 To iStartPos
85802>>>>>>>>>>>>>>>>>    //Move 100 to iEndPos
85802>>>>>>>>>>>>>>>>>    //Move iStartPos To ft.chrg.cpMin
85802>>>>>>>>>>>>>>>>>    //Move iEndPos   To ft.chrg.cpMax
85802>>>>>>>>>>>>>>>>>    //Move (sSearchText+Character(0)) To sSearchText
85802>>>>>>>>>>>>>>>>>    //Move (AddressOf(sSearchText)) To ft.pszText
85802>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85802>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_FINDTEXT iFlags (AddressOf(ft)) to iRet
85802>>>>>>>>>>>>>>>>>    //If (iRet > -1) Begin
85802>>>>>>>>>>>>>>>>>    //  Send none
85802>>>>>>>>>>>>>>>>>    //End
85802>>>>>>>>>>>>>>>>>  End_Procedure
85803>>>>>>>>>>>>>>>>>
85803>>>>>>>>>>>>>>>>>  // Find First
85803>>>>>>>>>>>>>>>>>  Procedure FindFirst
85805>>>>>>>>>>>>>>>>>    Integer iCaretPos
85805>>>>>>>>>>>>>>>>>    Integer iLen
85805>>>>>>>>>>>>>>>>>    Integer iPos
85805>>>>>>>>>>>>>>>>>    String  sSearchText
85805>>>>>>>>>>>>>>>>>
85805>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
85806>>>>>>>>>>>>>>>>>
85806>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
85807>>>>>>>>>>>>>>>>>    Move (Length(sSearchText)) To iLen
85808>>>>>>>>>>>>>>>>>    If (iLen>0) Begin
85810>>>>>>>>>>>>>>>>>      Move (sSearchText+character(0)) To sSearchText
85811>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETCURRENTPOS to iCaretPos
85812>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETTARGETSTART 0
85813>>>>>>>>>>>>>>>>>
85813>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
85814>>>>>>>>>>>>>>>>>      If (iPos>-1) Begin
85816>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
85817>>>>>>>>>>>>>>>>>      End
85817>>>>>>>>>>>>>>>>>>
85817>>>>>>>>>>>>>>>>>      Else Begin
85818>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
85819>>>>>>>>>>>>>>>>>        Set Status_Help to (_T("Find Next: No more occurrences have been found.",1606))
85820>>>>>>>>>>>>>>>>>        Send Request_Status_Help True
85821>>>>>>>>>>>>>>>>>      End
85821>>>>>>>>>>>>>>>>>>
85821>>>>>>>>>>>>>>>>>    End
85821>>>>>>>>>>>>>>>>>>
85821>>>>>>>>>>>>>>>>>  End_Procedure
85822>>>>>>>>>>>>>>>>>
85822>>>>>>>>>>>>>>>>>  // Find next
85822>>>>>>>>>>>>>>>>>  Procedure FindNext
85824>>>>>>>>>>>>>>>>>    Integer iCaretPos
85824>>>>>>>>>>>>>>>>>    Integer iFlags
85824>>>>>>>>>>>>>>>>>    Integer iLen
85824>>>>>>>>>>>>>>>>>    Integer iPos
85824>>>>>>>>>>>>>>>>>    Integer iStartPos
85824>>>>>>>>>>>>>>>>>    String  sSearchText
85824>>>>>>>>>>>>>>>>>
85824>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
85825>>>>>>>>>>>>>>>>>    Move (Length(sSearchText)) To iLen
85826>>>>>>>>>>>>>>>>>    If (iLen>0) Begin
85828>>>>>>>>>>>>>>>>>      Move (sSearchText+character(0)) To sSearchText
85829>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iCaretPos
85830>>>>>>>>>>>>>>>>>      Move (iCaretPos+iLen) To iStartPos
85831>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETCURRENTPOS iStartPos
85832>>>>>>>>>>>>>>>>>
85832>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SEARCHANCHOR
85833>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
85834>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
85835>>>>>>>>>>>>>>>>>      If (iPos>-1) Begin
85837>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
85838>>>>>>>>>>>>>>>>>      End
85838>>>>>>>>>>>>>>>>>>
85838>>>>>>>>>>>>>>>>>      Else Begin
85839>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
85840>>>>>>>>>>>>>>>>>        Set Status_Help to (_T("Find Next: No more occurrences have been found.",1606))
85841>>>>>>>>>>>>>>>>>        Send Request_Status_Help True
85842>>>>>>>>>>>>>>>>>      End
85842>>>>>>>>>>>>>>>>>>
85842>>>>>>>>>>>>>>>>>    End
85842>>>>>>>>>>>>>>>>>>
85842>>>>>>>>>>>>>>>>>  End_Procedure
85843>>>>>>>>>>>>>>>>>
85843>>>>>>>>>>>>>>>>>  Procedure FindPrevious
85845>>>>>>>>>>>>>>>>>    Integer iFlags
85845>>>>>>>>>>>>>>>>>    Integer iLen
85845>>>>>>>>>>>>>>>>>    Integer iPos
85845>>>>>>>>>>>>>>>>>    String  sSearchText
85845>>>>>>>>>>>>>>>>>
85845>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
85846>>>>>>>>>>>>>>>>>    Move (Length(sSearchText)) To iLen
85847>>>>>>>>>>>>>>>>>    If (iLen>0) Begin
85849>>>>>>>>>>>>>>>>>      Move (sSearchText+character(0)) To sSearchText
85850>>>>>>>>>>>>>>>>>
85850>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SEARCHANCHOR
85851>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
85852>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_SEARCHPREV iFlags (AddressOf(sSearchText)) to iPos
85853>>>>>>>>>>>>>>>>>      If (iPos>-1) Begin
85855>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
85856>>>>>>>>>>>>>>>>>      End
85856>>>>>>>>>>>>>>>>>>
85856>>>>>>>>>>>>>>>>>      Else Begin
85857>>>>>>>>>>>>>>>>>        Set Status_Help to (_T("Find Previous: No more occurrences have been found.",1607))
85858>>>>>>>>>>>>>>>>>        Send Request_Status_Help True
85859>>>>>>>>>>>>>>>>>      End
85859>>>>>>>>>>>>>>>>>>
85859>>>>>>>>>>>>>>>>>    End
85859>>>>>>>>>>>>>>>>>>
85859>>>>>>>>>>>>>>>>>  End_Procedure
85860>>>>>>>>>>>>>>>>>
85860>>>>>>>>>>>>>>>>>  Procedure Replace
85862>>>>>>>>>>>>>>>>>    Integer iCaretPos
85862>>>>>>>>>>>>>>>>>    Integer iPos
85862>>>>>>>>>>>>>>>>>    Integer iStartPos
85862>>>>>>>>>>>>>>>>>    Integer iLen
85862>>>>>>>>>>>>>>>>>    Integer iFlags
85862>>>>>>>>>>>>>>>>>    String  sSearchText
85862>>>>>>>>>>>>>>>>>    tFindReplaceOptions ReplaceOptions
85862>>>>>>>>>>>>>>>>>    tFindReplaceOptions ReplaceOptions
85862>>>>>>>>>>>>>>>>>
85862>>>>>>>>>>>>>>>>>    Move 0 To iCaretPos
85863>>>>>>>>>>>>>>>>>    Move 0 To iStartPos
85864>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
85865>>>>>>>>>>>>>>>>>    //
85865>>>>>>>>>>>>>>>>>    Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
85866>>>>>>>>>>>>>>>>>    Get CurrentSearchOptions sSearchText to ReplaceOptions
85867>>>>>>>>>>>>>>>>>
85867>>>>>>>>>>>>>>>>>    Send RequestDetails of oReplaceDialog (&ReplaceOptions) (Object_Id(Self))
85868>>>>>>>>>>>>>>>>>    If (ReplaceOptions.bReplaceAll) Begin
85870>>>>>>>>>>>>>>>>>      // First update any changed search flags
85870>>>>>>>>>>>>>>>>>      Get SetSearchOptions ReplaceOptions to iFlags
85871>>>>>>>>>>>>>>>>>      Move ReplaceOptions.sSearchText To sSearchText
85872>>>>>>>>>>>>>>>>>      Set psSearchText to sSearchText
85873>>>>>>>>>>>>>>>>>      Move (Length(sSearchText)) To iLen
85874>>>>>>>>>>>>>>>>>      If (iLen>0) Begin
85876>>>>>>>>>>>>>>>>>        Move 0 To iStartPos
85877>>>>>>>>>>>>>>>>>        If (ReplaceOptions.bDocumentStart=False) Begin
85879>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETCURRENTPOS To iCaretPos
85880>>>>>>>>>>>>>>>>>          Move iCaretPos To iStartPos
85881>>>>>>>>>>>>>>>>>        End
85881>>>>>>>>>>>>>>>>>>
85881>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETTARGETSTART iStartPos
85882>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
85883>>>>>>>>>>>>>>>>>        If (iPos > -1) Begin
85885>>>>>>>>>>>>>>>>>          Move iPos To iCaretPos
85886>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_BEGINUNDOACTION
85887>>>>>>>>>>>>>>>>>          While (iPos>-1)
85891>>>>>>>>>>>>>>>>>            // select found text then replace it
85891>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
85892>>>>>>>>>>>>>>>>>            Send ReplaceText ReplaceOptions.sReplaceText
85893>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETSEL (iPos+iLen) (iPos+iLen) // remove selection
85894>>>>>>>>>>>>>>>>>            // find next
85894>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
85895>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SEARCHANCHOR
85896>>>>>>>>>>>>>>>>>            Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
85897>>>>>>>>>>>>>>>>>          Loop
85898>>>>>>>>>>>>>>>>>>
85898>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_ENDUNDOACTION
85899>>>>>>>>>>>>>>>>>          // select first replaced
85899>>>>>>>>>>>>>>>>>          Move (Length(ReplaceOptions.sReplaceText)) To iLen
85900>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
85901>>>>>>>>>>>>>>>>>        End
85901>>>>>>>>>>>>>>>>>>
85901>>>>>>>>>>>>>>>>>      End
85901>>>>>>>>>>>>>>>>>>
85901>>>>>>>>>>>>>>>>>    End
85901>>>>>>>>>>>>>>>>>>
85901>>>>>>>>>>>>>>>>>  End_Procedure
85902>>>>>>>>>>>>>>>>>
85902>>>>>>>>>>>>>>>>>  Procedure ReplaceText String sReplaceWith
85904>>>>>>>>>>>>>>>>>    String sTargetText
85904>>>>>>>>>>>>>>>>>    String sReplaceText
85904>>>>>>>>>>>>>>>>>    String sSearchText
85904>>>>>>>>>>>>>>>>>    Integer iVoid
85904>>>>>>>>>>>>>>>>>
85904>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
85905>>>>>>>>>>>>>>>>>    If (sSearchText<>"") Begin
85907>>>>>>>>>>>>>>>>>      Move (sReplaceWith+"") To sReplaceText
85908>>>>>>>>>>>>>>>>>      Move (ZeroString(300)) to sTargetText
85909>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_TARGETFROMSELECTION
85910>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETTARGETTEXT 0 (AddressOf(sTargetText)) to iVoid
85911>>>>>>>>>>>>>>>>>      If (lowercase(Cstring(sTargetText)) = lowercase(sSearchText)) Begin
85913>>>>>>>>>>>>>>>>>        //Send EditorMessage SCI_SETTARGETRANGE iPos iPos
85913>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sReplaceText))
85914>>>>>>>>>>>>>>>>>      End
85914>>>>>>>>>>>>>>>>>>
85914>>>>>>>>>>>>>>>>>    End
85914>>>>>>>>>>>>>>>>>>
85914>>>>>>>>>>>>>>>>>  End_Procedure
85915>>>>>>>>>>>>>>>>>
85915>>>>>>>>>>>>>>>>>  //        // Replace
85915>>>>>>>>>>>>>>>>>  //    Procedure Replace
85915>>>>>>>>>>>>>>>>>  //        Integer iRet
85915>>>>>>>>>>>>>>>>>  //        Get CM_ExecuteCmd CMD_FindReplace 0 to iRet
85915>>>>>>>>>>>>>>>>>  //    End_Procedure
85915>>>>>>>>>>>>>>>>>
85915>>>>>>>>>>>>>>>>>  // Goto line...
85915>>>>>>>>>>>>>>>>>  // CMD_GOTOLINE - Moves to a user-specified line.
85915>>>>>>>>>>>>>>>>>  // ( int ) The zero-based line number to jump to.
85915>>>>>>>>>>>>>>>>>  // If no argument is passed then the user is prompted.
85915>>>>>>>>>>>>>>>>>  Procedure GotoLine Integer iNrEx
85917>>>>>>>>>>>>>>>>>    Integer iLine iRet
85917>>>>>>>>>>>>>>>>>    Integer iScreenLines
85917>>>>>>>>>>>>>>>>>    Integer iFirstLine
85917>>>>>>>>>>>>>>>>>    Integer iLinesToScroll
85917>>>>>>>>>>>>>>>>>
85917>>>>>>>>>>>>>>>>>    If NUM_Arguments Gt 0 Begin
85919>>>>>>>>>>>>>>>>>      Move iNrEx    to iLine
85920>>>>>>>>>>>>>>>>>    End
85920>>>>>>>>>>>>>>>>>>
85920>>>>>>>>>>>>>>>>>    Else Begin
85921>>>>>>>>>>>>>>>>>      Send RequestDetails to oGotoDialog (&iLine)
85922>>>>>>>>>>>>>>>>>      If (iLine<0) Begin
85924>>>>>>>>>>>>>>>>>        Procedure_Return
85925>>>>>>>>>>>>>>>>>      End
85925>>>>>>>>>>>>>>>>>>
85925>>>>>>>>>>>>>>>>>    End
85925>>>>>>>>>>>>>>>>>>
85925>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_GOTOLINE iLine
85926>>>>>>>>>>>>>>>>>    Get CM_SetHighlightedLine iLine to iRet
85927>>>>>>>>>>>>>>>>>    // SCI_LINESONSCREEN = get lines visible on screen
85927>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINESONSCREEN to iScreenLines
85928>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFIRSTVISIBLELINE to iFirstLine
85929>>>>>>>>>>>>>>>>>    Get piLinesToScrollAfterGoto to iLinesToScroll // scroll a few lines to display more context if at
85930>>>>>>>>>>>>>>>>>    If (iScreenLines > iLinesToScroll) Begin       // first or last line in the window after the goto line.
85932>>>>>>>>>>>>>>>>>      If (iLine=iFirstLine) Begin
85934>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_LINESCROLL 0 (-iLinesToScroll)
85935>>>>>>>>>>>>>>>>>      End
85935>>>>>>>>>>>>>>>>>>
85935>>>>>>>>>>>>>>>>>      Else If (iLine=(iFirstLine+iScreenLines-1)) Begin
85938>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_LINESCROLL 0 iLinesToScroll
85939>>>>>>>>>>>>>>>>>      End
85939>>>>>>>>>>>>>>>>>>
85939>>>>>>>>>>>>>>>>>    End
85939>>>>>>>>>>>>>>>>>>
85939>>>>>>>>>>>>>>>>>  End_Procedure
85940>>>>>>>>>>>>>>>>>
85940>>>>>>>>>>>>>>>>>  //
85940>>>>>>>>>>>>>>>>>  // useful for debugging
85940>>>>>>>>>>>>>>>>>  //
85940>>>>>>>>>>>>>>>>>  Procedure showCurrentLineStyle
85942>>>>>>>>>>>>>>>>>    Integer iVoid iStartLine //iStartCol iEndLine iEndCol
85942>>>>>>>>>>>>>>>>>    Integer iPosStart
85942>>>>>>>>>>>>>>>>>    Integer iPosChar iPos
85942>>>>>>>>>>>>>>>>>    Integer eStyle
85942>>>>>>>>>>>>>>>>>    Integer iLineLength
85942>>>>>>>>>>>>>>>>>    String  sLine
85942>>>>>>>>>>>>>>>>>
85942>>>>>>>>>>>>>>>>>    Get CM_GetSel False  to iVoid
85943>>>>>>>>>>>>>>>>>    Get piSelStartLine   to iStartLine
85944>>>>>>>>>>>>>>>>>    Get value item iStartLine to sLine
85945>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iStartLine to iPosStart
85946>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH iStartLine to iLineLength
85947>>>>>>>>>>>>>>>>>    Showln sLine
85949>>>>>>>>>>>>>>>>>    For iPosChar from iPosStart to (iPosStart+iLineLength)
85955>>>>>>>>>>>>>>>>>>
85955>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETSTYLEAT iPosChar to eStyle
85956>>>>>>>>>>>>>>>>>      Move (iPosChar-iPosStart+1) To iPos // to keep it simple,  this is the position in the sLine string
85957>>>>>>>>>>>>>>>>>      Showln "Style for [" (Mid(sLine,1,iPos)) "] " (iPosChar-iPosStart) " " eStyle
85964>>>>>>>>>>>>>>>>>    Loop
85965>>>>>>>>>>>>>>>>>>
85965>>>>>>>>>>>>>>>>>  End_Procedure
85966>>>>>>>>>>>>>>>>>
85966>>>>>>>>>>>>>>>>>  //
85966>>>>>>>>>>>>>>>>>  // Normalizes the selected line by finding the DataFlex keywords in the line and then
85966>>>>>>>>>>>>>>>>>  // matching those up with how they are defined and adjusting the case if needed.
85966>>>>>>>>>>>>>>>>>  // If bUndo is true then it will add an undo action for this line.
85966>>>>>>>>>>>>>>>>>  // Will return true if the line was changed.
85966>>>>>>>>>>>>>>>>>  //
85966>>>>>>>>>>>>>>>>>  Function LineNormalizeCase Integer iLine Boolean bUndo Returns Boolean
85968>>>>>>>>>>>>>>>>>    Boolean bChanged
85968>>>>>>>>>>>>>>>>>    Integer iPosStart
85968>>>>>>>>>>>>>>>>>    Integer iPosChar iPos
85968>>>>>>>>>>>>>>>>>    Integer eStyle eLastStyle
85968>>>>>>>>>>>>>>>>>    Integer iLineLength
85968>>>>>>>>>>>>>>>>>    Integer iWordStart
85968>>>>>>>>>>>>>>>>>    String  sLine sTALine
85968>>>>>>>>>>>>>>>>>    String  sWord sTAWord
85968>>>>>>>>>>>>>>>>>
85968>>>>>>>>>>>>>>>>>    Move False To bChanged
85969>>>>>>>>>>>>>>>>>    Get value item iLine to sLine
85970>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine to iPosStart
85971>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
85972>>>>>>>>>>>>>>>>>    Move sLine To sTALine
85973>>>>>>>>>>>>>>>>>    For iPosChar from iPosStart to (iPosStart+iLineLength)
85979>>>>>>>>>>>>>>>>>>
85979>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETSTYLEAT iPosChar to eStyle
85980>>>>>>>>>>>>>>>>>      Move (iPosChar-iPosStart+1) To iPos // to keep it simple,  this is the position in the sLine string
85981>>>>>>>>>>>>>>>>>      //Showln "Style " (iPosChar-iPosStart) " " eStyle
85981>>>>>>>>>>>>>>>>>      If (eStyle=SCE_DF_WORD and eLastStyle<>SCE_DF_WORD) Begin
85983>>>>>>>>>>>>>>>>>        Move SCE_DF_WORD To eLastStyle
85984>>>>>>>>>>>>>>>>>        Move iPos to iWordStart
85985>>>>>>>>>>>>>>>>>      End
85985>>>>>>>>>>>>>>>>>>
85985>>>>>>>>>>>>>>>>>      Else If (eStyle=SCE_DF_SCOPEWORD and eLastStyle<>SCE_DF_SCOPEWORD) Begin
85988>>>>>>>>>>>>>>>>>        Move SCE_DF_SCOPEWORD To eLastStyle
85989>>>>>>>>>>>>>>>>>        Move iPos To iWordStart
85990>>>>>>>>>>>>>>>>>      End
85990>>>>>>>>>>>>>>>>>>
85990>>>>>>>>>>>>>>>>>      If (eLastStyle=SCE_DF_WORD and eStyle<>SCE_DF_WORD) Begin
85992>>>>>>>>>>>>>>>>>        //Show " [" (Mid(sLine,iPos-iWordStart,iWordStart)) "]"
85992>>>>>>>>>>>>>>>>>        Move (Mid(sLine,iPos-iWordStart,iWordStart)) To sWord
85993>>>>>>>>>>>>>>>>>        Get FindKeyWord of oNormalizeCase SCLEX_DATAFLEX sWord to sTAWord
85994>>>>>>>>>>>>>>>>>        Move (Overstrike(sTAWord,sTALine,iWordStart)) To sTALine
85995>>>>>>>>>>>>>>>>>        Move 0 To eLastStyle
85996>>>>>>>>>>>>>>>>>      End
85996>>>>>>>>>>>>>>>>>>
85996>>>>>>>>>>>>>>>>>      Else If (eLastStyle=SCE_DF_SCOPEWORD and eStyle<>SCE_DF_SCOPEWORD) Begin
85999>>>>>>>>>>>>>>>>>        //Show " <" (Mid(sLine,iPos-iWordStart,iWordStart)) ">"
85999>>>>>>>>>>>>>>>>>        Move (Mid(sLine,iPos-iWordStart,iWordStart)) To sWord
86000>>>>>>>>>>>>>>>>>        Get FindScopeWord of oNormalizeCase SCLEX_DATAFLEX sWord to sTAWord
86001>>>>>>>>>>>>>>>>>        Move (Overstrike(sTAWord,sTALine,iWordStart)) To sTALine
86002>>>>>>>>>>>>>>>>>        Move 0 To eLastStyle
86003>>>>>>>>>>>>>>>>>      End
86003>>>>>>>>>>>>>>>>>>
86003>>>>>>>>>>>>>>>>>    Loop
86004>>>>>>>>>>>>>>>>>>
86004>>>>>>>>>>>>>>>>>    If (sLine<>sTALine) Begin
86006>>>>>>>>>>>>>>>>>      Move True To bChanged
86007>>>>>>>>>>>>>>>>>      If (bUndo) Begin
86009>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_BEGINUNDOACTION
86010>>>>>>>>>>>>>>>>>      End
86010>>>>>>>>>>>>>>>>>>
86010>>>>>>>>>>>>>>>>>      Set Value Item iLine To sTALine
86011>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_COLOURISE iPosStart (iPosStart+iLineLength)  // apply style to the changed text!
86012>>>>>>>>>>>>>>>>>      If (bUndo) Begin
86014>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_ENDUNDOACTION
86015>>>>>>>>>>>>>>>>>      End
86015>>>>>>>>>>>>>>>>>>
86015>>>>>>>>>>>>>>>>>    End
86015>>>>>>>>>>>>>>>>>>
86015>>>>>>>>>>>>>>>>>    Function_Return bChanged
86016>>>>>>>>>>>>>>>>>  End_Function
86017>>>>>>>>>>>>>>>>>
86017>>>>>>>>>>>>>>>>>
86017>>>>>>>>>>>>>>>>>  Procedure doNormalizeCase
86019>>>>>>>>>>>>>>>>>    Boolean bChanged
86019>>>>>>>>>>>>>>>>>    Integer iVoid iStartLine iStartCol iEndLine iEndCol
86019>>>>>>>>>>>>>>>>>
86019>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_CLEARCMDKEY ((65536*(SCMOD_CTRL))+Ascii("O"))
86019>>>>>>>>>>>>>>>>>
86019>>>>>>>>>>>>>>>>>    Get CM_GetSel False  to iVoid
86020>>>>>>>>>>>>>>>>>    Get piSelStartLine   to iStartLine
86021>>>>>>>>>>>>>>>>>    Get piSelStartCol    to iStartCol
86022>>>>>>>>>>>>>>>>>    Get piSelEndLine     to iEndLine
86023>>>>>>>>>>>>>>>>>    Get piSelEndCol      To iEndCol
86024>>>>>>>>>>>>>>>>>    Get LineNormalizeCase iStartLine True To bChanged
86025>>>>>>>>>>>>>>>>>    If (bChanged) Begin
86027>>>>>>>>>>>>>>>>>      // move cursor back to where it was
86027>>>>>>>>>>>>>>>>>      Get CM_SetSel iStartLine iStartCol iEndLine iEndCol True to iVoid
86028>>>>>>>>>>>>>>>>>    End
86028>>>>>>>>>>>>>>>>>>
86028>>>>>>>>>>>>>>>>>  End_Procedure
86029>>>>>>>>>>>>>>>>>
86029>>>>>>>>>>>>>>>>>  Procedure StartUndoTransaction
86031>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
86032>>>>>>>>>>>>>>>>>  End_Procedure
86033>>>>>>>>>>>>>>>>>
86033>>>>>>>>>>>>>>>>>  Procedure EndUndoTransaction
86035>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
86036>>>>>>>>>>>>>>>>>  End_Procedure
86037>>>>>>>>>>>>>>>>>
86037>>>>>>>>>>>>>>>>>
86037>>>>>>>>>>>>>>>>>  // Fills the position of the cursor in pixels into Properties.
86037>>>>>>>>>>>>>>>>>  // - getting the curren postion in Line / Col
86037>>>>>>>>>>>>>>>>>  // - Retrieving this Position in Pixesl with CM_PosFromChar
86037>>>>>>>>>>>>>>>>>  // - Retrieving the absolute position of the Window
86037>>>>>>>>>>>>>>>>>  // =  ABSOLUTE CURSOR POSITION in the Edit.
86037>>>>>>>>>>>>>>>>>  Procedure FillCurrentPosition
86039>>>>>>>>>>>>>>>>>    Integer iRet
86039>>>>>>>>>>>>>>>>>    Move (CM_GetSel(Self,False))                                        to iRet
86040>>>>>>>>>>>>>>>>>    Move (CM_PosFromChar(Self,piSelEndLine(Self),piSelEndCol(Self)))    to iRet
86041>>>>>>>>>>>>>>>>>    Set piAbsPosYEnd    to (Hi (Absolute_GuiOriginEx(Self))+piPosEndY(Self))
86042>>>>>>>>>>>>>>>>>    Set piAbsPosXEnd    to (Low(Absolute_GuiOriginEx(Self))+piPosEndX(Self))
86043>>>>>>>>>>>>>>>>>    Set piAbsPosYStart  to (Hi (Absolute_GuiOriginEx(Self))+piPosStartY(Self))
86044>>>>>>>>>>>>>>>>>    Set piAbsPosXStart  to (Low(Absolute_GuiOriginEx(Self))+piPosStartX(Self))
86045>>>>>>>>>>>>>>>>>  End_Procedure
86046>>>>>>>>>>>>>>>>>
86046>>>>>>>>>>>>>>>>>  // Delivers the current line.
86046>>>>>>>>>>>>>>>>>  Function Current_Item Returns Integer
86048>>>>>>>>>>>>>>>>>    Integer iRet
86048>>>>>>>>>>>>>>>>>    Get CM_GetSel False                 to iRet
86049>>>>>>>>>>>>>>>>>    Function_Return (piSelEndLine(Self))
86050>>>>>>>>>>>>>>>>>  End_Function
86051>>>>>>>>>>>>>>>>>  //  As I'm a bit thick, let's create a function with that name to make my life easier
86051>>>>>>>>>>>>>>>>>  Function Current_Line Returns Integer
86053>>>>>>>>>>>>>>>>>    Integer iRet
86053>>>>>>>>>>>>>>>>>    Get CM_GetSel False                 to iRet
86054>>>>>>>>>>>>>>>>>    Function_Return (piSelEndLine(Self))
86055>>>>>>>>>>>>>>>>>  End_Function
86056>>>>>>>>>>>>>>>>>  // For VDF closer access.    - number of lines.
86056>>>>>>>>>>>>>>>>>  Function Item_Count Returns Integer
86058>>>>>>>>>>>>>>>>>    Function_Return (SC_LineCount(Self))
86059>>>>>>>>>>>>>>>>>  End_Function
86060>>>>>>>>>>>>>>>>>  // Value of the line with the given LineNr.
86060>>>>>>>>>>>>>>>>>  Function Value Integer iItem Returns String
86062>>>>>>>>>>>>>>>>>    If iItem Eq -99 Begin
86064>>>>>>>>>>>>>>>>>      Move (Current_Item(Self)) to iItem
86065>>>>>>>>>>>>>>>>>    End
86065>>>>>>>>>>>>>>>>>>
86065>>>>>>>>>>>>>>>>>    Function_Return (CM_GetLine(Self,iItem))
86066>>>>>>>>>>>>>>>>>  End_Function
86067>>>>>>>>>>>>>>>>>
86067>>>>>>>>>>>>>>>>>  // Sets the value of a given line. (For compatibility with VDF)
86067>>>>>>>>>>>>>>>>>  Procedure Set Value Integer iItem String sValue
86069>>>>>>>>>>>>>>>>>    Integer iRet iC iCol iLine
86069>>>>>>>>>>>>>>>>>
86069>>>>>>>>>>>>>>>>>    Get CM_GetSel False                to iRet
86070>>>>>>>>>>>>>>>>>    Get piSelEndCol                    to iCol
86071>>>>>>>>>>>>>>>>>    Get piSelEndLine                   to iLine
86072>>>>>>>>>>>>>>>>>    If iItem Eq -99 Begin
86074>>>>>>>>>>>>>>>>>      Get Current_Item  to iItem
86075>>>>>>>>>>>>>>>>>    End
86075>>>>>>>>>>>>>>>>>>
86075>>>>>>>>>>>>>>>>>    Get CM_SelectLine iItem False      to iRet // select line up to EOL character
86076>>>>>>>>>>>>>>>>>    Get CM_DeleteSel                   to iRet
86077>>>>>>>>>>>>>>>>>    Get CM_InsertText sValue iItem 0   to iRet
86078>>>>>>>>>>>>>>>>>    If (iLine <> iItem) Begin
86080>>>>>>>>>>>>>>>>>      Get CM_SetSel iLine iCol iLine iCol False  to iRet
86081>>>>>>>>>>>>>>>>>    End
86081>>>>>>>>>>>>>>>>>>
86081>>>>>>>>>>>>>>>>>  End_Procedure
86082>>>>>>>>>>>>>>>>>
86082>>>>>>>>>>>>>>>>>  Procedure Delete_Data
86084>>>>>>>>>>>>>>>>>    // Unless the document is read-only, this deletes all the text.
86084>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CLEARALL
86085>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_EMPTYUNDOBUFFER
86086>>>>>>>>>>>>>>>>>    // Clear all styling information and reset the folding state.
86086>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CLEARDOCUMENTSTYLE
86087>>>>>>>>>>>>>>>>>  End_Procedure
86088>>>>>>>>>>>>>>>>>
86088>>>>>>>>>>>>>>>>>
86088>>>>>>>>>>>>>>>>>  // Inserts the Sting into the current Position.
86088>>>>>>>>>>>>>>>>>  Procedure Insert String sValue
86090>>>>>>>>>>>>>>>>>    Integer iRet
86090>>>>>>>>>>>>>>>>>    Get CM_GetSel False to iRet
86091>>>>>>>>>>>>>>>>>    Move (CM_InsertText(Self,sValue,piSelEndLine(Self),piSelEndCol(Self))) to iRet
86092>>>>>>>>>>>>>>>>>  End_Procedure
86093>>>>>>>>>>>>>>>>>
86093>>>>>>>>>>>>>>>>>  // This is en advanced set value which automatically indents the new
86093>>>>>>>>>>>>>>>>>  // value text as far as the text in the line was, or if empty the text of the line before.
86093>>>>>>>>>>>>>>>>>  Procedure Set ValueSmart Integer iLine String sVal
86095>>>>>>>>>>>>>>>>>    Integer iPos
86095>>>>>>>>>>>>>>>>>    String sValOld
86095>>>>>>>>>>>>>>>>>    Get value item iLine    to sValOld
86096>>>>>>>>>>>>>>>>>    If (Trim(sValOld)) Eq "" If iLine Gt 0 Begin
86100>>>>>>>>>>>>>>>>>      Get Value Item (iLine-1) to sValOld
86101>>>>>>>>>>>>>>>>>    End
86101>>>>>>>>>>>>>>>>>>
86101>>>>>>>>>>>>>>>>>    If (Trim(sValOld)) Ne "" Begin
86103>>>>>>>>>>>>>>>>>      For iPos from 1 to (Length(sValOld))
86109>>>>>>>>>>>>>>>>>>
86109>>>>>>>>>>>>>>>>>
86109>>>>>>>>>>>>>>>>>        If (Mid(sValOld,1,iPos)) Ne " " Break
86112>>>>>>>>>>>>>>>>>      Loop
86113>>>>>>>>>>>>>>>>>>
86113>>>>>>>>>>>>>>>>>
86113>>>>>>>>>>>>>>>>>      Move (LTrim(sVal))      to sVal
86114>>>>>>>>>>>>>>>>>      Move (Append(Repeat(" ",iPos-1),sVal))  to sVal
86115>>>>>>>>>>>>>>>>>    End
86115>>>>>>>>>>>>>>>>>>
86115>>>>>>>>>>>>>>>>>
86115>>>>>>>>>>>>>>>>>    Set value item iLine                        to sVal
86116>>>>>>>>>>>>>>>>>  End_Procedure
86117>>>>>>>>>>>>>>>>>
86117>>>>>>>>>>>>>>>>>  // To determine if an object is a cCodeMaxEdit
86117>>>>>>>>>>>>>>>>>  Function iscWinMaxEdit Returns Integer
86119>>>>>>>>>>>>>>>>>    Function_Return 1
86120>>>>>>>>>>>>>>>>>  End_Function
86121>>>>>>>>>>>>>>>>>
86121>>>>>>>>>>>>>>>>>  //____NOTIFICATION_TRAPPING..._____________________________________________
86121>>>>>>>>>>>>>>>>>  // all of the followinf procedures and functions are sent by the
86121>>>>>>>>>>>>>>>>>  // procedure Notify - which is caused by WM_Notify message.
86121>>>>>>>>>>>>>>>>>
86121>>>>>>>>>>>>>>>>>  // Key capturing...
86121>>>>>>>>>>>>>>>>>
86121>>>>>>>>>>>>>>>>>  // Blocks iKeyCode
86121>>>>>>>>>>>>>>>>>  Procedure BlockKey Integer iKeyCode Integer iExtKey Integer iFlag
86123>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT ;      Set psBlockedKeysNo    to (Overstrike(String(iFlag),psBlockedKeysNo   (Self),iKeyCode))
86126>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT ;      Set psBlockedKeysShift to (Overstrike(String(iFlag),psBlockedKeysShift(Self),iKeyCode))
86129>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT   ;      Set psBlockedKeysAlt   to (Overstrike(String(iFlag),psBlockedKeysAlt  (Self),iKeyCode))
86132>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL  ;      Set psBlockedKeysCtrl  to (Overstrike(String(iFlag),psBlockedKeysCtrl (Self),iKeyCode))
86135>>>>>>>>>>>>>>>>>  End_Procedure
86136>>>>>>>>>>>>>>>>>
86136>>>>>>>>>>>>>>>>>  Function isKeyBlocked Integer iKeyCode Integer iExtKey Returns Integer
86138>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT ;      Function_Return (Mid(psBlockedKeysNo   (Self),1,iKeyCode))
86141>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT ;      Function_Return (Mid(psBlockedKeysShift(Self),1,iKeyCode))
86144>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT   ;      Function_Return (Mid(psBlockedKeysAlt  (Self),1,iKeyCode))
86147>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL  ;      Function_Return (Mid(psBlockedKeysCtrl (Self),1,iKeyCode))
86150>>>>>>>>>>>>>>>>>    Function_Return 0
86151>>>>>>>>>>>>>>>>>  End_Function
86152>>>>>>>>>>>>>>>>>
86152>>>>>>>>>>>>>>>>>
86152>>>>>>>>>>>>>>>>>  // Like Block Key but the Blocked key is reset with onKeyUp.
86152>>>>>>>>>>>>>>>>>  Procedure BlockKeyOnce Integer iKeyCode Integer iExtKey Integer iFlag
86154>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT ;      Set psBlockedKeysNoOnce    to (Overstrike(String(iFlag),psBlockedKeysNoOnce   (Self),iKeyCode))
86157>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT ;      Set psBlockedKeysShiftOnce to (Overstrike(String(iFlag),psBlockedKeysShiftOnce(Self),iKeyCode))
86160>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT   ;      Set psBlockedKeysAltOnce   to (Overstrike(String(iFlag),psBlockedKeysAltOnce  (Self),iKeyCode))
86163>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL  ;      Set psBlockedKeysCtrlOnce  to (Overstrike(String(iFlag),psBlockedKeysCtrlOnce (Self),iKeyCode))
86166>>>>>>>>>>>>>>>>>  End_Procedure
86167>>>>>>>>>>>>>>>>>  Function isKeyBlockedOnce Integer iKeyCode Integer iExtKey Returns Integer
86169>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT  ;      Function_Return (Mid(psBlockedKeysNoOnce   (Self),1,iKeyCode))
86172>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT  ;      Function_Return (Mid(psBlockedKeysShiftOnce(Self),1,iKeyCode))
86175>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT    ;      Function_Return (Mid(psBlockedKeysAltOnce  (Self),1,iKeyCode))
86178>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL   ;      Function_Return (Mid(psBlockedKeysCtrlOnce (Self),1,iKeyCode))
86181>>>>>>>>>>>>>>>>>    Function_Return 0
86182>>>>>>>>>>>>>>>>>  End_Function
86183>>>>>>>>>>>>>>>>>
86183>>>>>>>>>>>>>>>>>  Procedure onCMKeyUp Longptr iKeyCode Longptr iKeyExt
86185>>>>>>>>>>>>>>>>>  End_Procedure
86186>>>>>>>>>>>>>>>>>  Procedure onCMKeyDown Longptr iKeyCode Longptr iKeyExt
86188>>>>>>>>>>>>>>>>>  End_Procedure
86189>>>>>>>>>>>>>>>>>  Procedure onCMKeyPress Longptr iKeyCode Longptr iKeyExt
86191>>>>>>>>>>>>>>>>>  End_Procedure
86192>>>>>>>>>>>>>>>>>
86192>>>>>>>>>>>>>>>>>  //
86192>>>>>>>>>>>>>>>>>  // We apparently can't use WM_KEYDOWN event, but our higher class depends on that. So from a keypress we now
86192>>>>>>>>>>>>>>>>>  // simulate that by only watching the specific keys that are handled. While hackish, this appears to work.
86192>>>>>>>>>>>>>>>>>  //
86192>>>>>>>>>>>>>>>>>  Procedure SimulateOnKeyDown
86194>>>>>>>>>>>>>>>>>    Integer iKeyCode iKeyExt iRet
86194>>>>>>>>>>>>>>>>>    Move 0 To iKeyCode
86195>>>>>>>>>>>>>>>>>    Move 0 To iKeyExt
86196>>>>>>>>>>>>>>>>>    If (GetKeyState(VK_HOME)) ;      Move VK_HOME To iKeyCode
86199>>>>>>>>>>>>>>>>>    Else If (GetKeyState(VK_END)) ;      Move VK_END To iKeyCode
86203>>>>>>>>>>>>>>>>>    Else If (GetKeyState(VK_RETURN)) ;      Move VK_RETURN To iKeyCode
86207>>>>>>>>>>>>>>>>>    If (GetKeyState(VK_CONTROL)) ;      Move CM_KEY_CTRL To iKeyExt
86210>>>>>>>>>>>>>>>>>    Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
86211>>>>>>>>>>>>>>>>>  End_Procedure
86212>>>>>>>>>>>>>>>>>
86212>>>>>>>>>>>>>>>>>  Procedure DoKeyAction Integer iChar  Longptr lParam
86214>>>>>>>>>>>>>>>>>    Integer iKeyExt iRet // iKeyCode iBlocked
86214>>>>>>>>>>>>>>>>>    Boolean bHasCallTip
86214>>>>>>>>>>>>>>>>>    //        Local_BUFFER_CPY sKeyData pKeyData CM_KEYDATA pCM_KeyData
86214>>>>>>>>>>>>>>>>>    //        GetBuff from sKeyData At CM_KeyData.nKeyCode        to iKeyCode
86214>>>>>>>>>>>>>>>>>    //        GetBuff from sKeyData At CM_KeyData.nKeyModifier    to iKeyExt
86214>>>>>>>>>>>>>>>>>    //        If (iMode=CMN_KEYUP   ) Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
86214>>>>>>>>>>>>>>>>>    //        If (iMode=CMN_KEYDOWN ) Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
86214>>>>>>>>>>>>>>>>>    //        If (iMode=CMN_KEYPRESS) Get Msg_onCMKeyPress   iKeyCode iKeyExt  to iRet
86214>>>>>>>>>>>>>>>>>
86214>>>>>>>>>>>>>>>>>    Send SimulateOnKeyDown
86215>>>>>>>>>>>>>>>>>    Get Msg_onCMKeyPress   iChar iKeyExt  to iRet
86216>>>>>>>>>>>>>>>>>
86216>>>>>>>>>>>>>>>>>    If (pbCodeTipRequest(Self)=False) Begin
86218>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_CALLTIPACTIVE to bHasCallTip
86219>>>>>>>>>>>>>>>>>      If (bHasCallTip) Begin
86221>>>>>>>>>>>>>>>>>        Set pbCodetipRequest to True // code tip is still on the screen, keep calculating to see if it has to be deactivated.
86222>>>>>>>>>>>>>>>>>      End
86222>>>>>>>>>>>>>>>>>>
86222>>>>>>>>>>>>>>>>>    End
86222>>>>>>>>>>>>>>>>>>
86222>>>>>>>>>>>>>>>>>
86222>>>>>>>>>>>>>>>>>    //            // Blocks keystrokes. (only with every ExtKey, dont need this at the moment)
86222>>>>>>>>>>>>>>>>>    //        If (isKeyBlocked(Self,iKeyCode,iKeyExt)) Begin
86222>>>>>>>>>>>>>>>>>    //            Procedure_Return 1
86222>>>>>>>>>>>>>>>>>    //        End
86222>>>>>>>>>>>>>>>>>    //            // Same as above but the Key blocking is released with KeyUp -> Block Key only once!
86222>>>>>>>>>>>>>>>>>    //        If (isKeyBlockedOnce(Self,iKeyCode,iKeyExt)) Begin
86222>>>>>>>>>>>>>>>>>    //            If (iMode=CMN_KEYUP) Send BlockKeyOnce iKeyCode iKeyExt False   // Reset Key.
86222>>>>>>>>>>>>>>>>>    //            Procedure_Return 1
86222>>>>>>>>>>>>>>>>>    //        End
86222>>>>>>>>>>>>>>>>>    Procedure_Return iRet
86223>>>>>>>>>>>>>>>>>  End_Procedure
86224>>>>>>>>>>>>>>>>>
86224>>>>>>>>>>>>>>>>>  Procedure onKeyUp Longptr iKey Longptr lParam
86226>>>>>>>>>>>>>>>>>    Boolean bHasCodeList
86226>>>>>>>>>>>>>>>>>    Integer iRet iKeyCode iKeyExt
86226>>>>>>>>>>>>>>>>>    Move iKey To iKeyCode
86227>>>>>>>>>>>>>>>>>    Forward Send onKeyUp iKey lParam
86229>>>>>>>>>>>>>>>>>    Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
86230>>>>>>>>>>>>>>>>>    If (pbIsCodelistActive(Self)) Begin
86232>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_AUTOCACTIVE to bHasCodeList
86233>>>>>>>>>>>>>>>>>      If (bHasCodeList=False) Begin
86235>>>>>>>>>>>>>>>>>        Send DoCodeListCancel
86236>>>>>>>>>>>>>>>>>      End
86236>>>>>>>>>>>>>>>>>>
86236>>>>>>>>>>>>>>>>>    End
86236>>>>>>>>>>>>>>>>>>
86236>>>>>>>>>>>>>>>>>  End_Procedure
86237>>>>>>>>>>>>>>>>>
86237>>>>>>>>>>>>>>>>>
86237>>>>>>>>>>>>>>>>>  Procedure Key Integer iKey
86239>>>>>>>>>>>>>>>>>    Boolean bBlockSelect
86239>>>>>>>>>>>>>>>>>    Boolean bDisableKey
86239>>>>>>>>>>>>>>>>>
86239>>>>>>>>>>>>>>>>>    Move False to bDisableKey
86240>>>>>>>>>>>>>>>>>    Set pbBlockSelectBackspace to False
86241>>>>>>>>>>>>>>>>>    If iKey Eq 2166 Begin
86243>>>>>>>>>>>>>>>>>      Send OnBeforePaste // Paste Ctrl+V
86244>>>>>>>>>>>>>>>>>    End
86244>>>>>>>>>>>>>>>>>>
86244>>>>>>>>>>>>>>>>>    If iKey Eq 2168 Begin
86246>>>>>>>>>>>>>>>>>      Send OnBeforeCut   // Cut Ctrl+X
86247>>>>>>>>>>>>>>>>>    End
86247>>>>>>>>>>>>>>>>>>
86247>>>>>>>>>>>>>>>>>    Get pbBlockSelectActive to bBlockSelect
86248>>>>>>>>>>>>>>>>>    If (bBlockSelect) Begin
86250>>>>>>>>>>>>>>>>>      Send BlockSelectRemoveTextBlockBugfix
86251>>>>>>>>>>>>>>>>>
86251>>>>>>>>>>>>>>>>>      If (iKey=KEY_TAB) Begin
86253>>>>>>>>>>>>>>>>>        // tab works, but not when only space characters at first line, then it is a mess.
86253>>>>>>>>>>>>>>>>>        // But if we then move the selection to the first column it works again. It's a bit ugly, but it works
86253>>>>>>>>>>>>>>>>>        Send BlockSelectTabKeyBugfix
86254>>>>>>>>>>>>>>>>>        Move True to bDisableKey
86255>>>>>>>>>>>>>>>>>      End
86255>>>>>>>>>>>>>>>>>>
86255>>>>>>>>>>>>>>>>>    End
86255>>>>>>>>>>>>>>>>>>
86255>>>>>>>>>>>>>>>>>    //IfNot (bDisableKey) Forward Send Key iKey
86255>>>>>>>>>>>>>>>>>    Forward Send Key iKey
86257>>>>>>>>>>>>>>>>>    If iKey Eq 2166 Begin
86259>>>>>>>>>>>>>>>>>      Send OnAfterPaste  // Paste Ctrl+V
86260>>>>>>>>>>>>>>>>>    End
86260>>>>>>>>>>>>>>>>>>
86260>>>>>>>>>>>>>>>>>    If iKey Eq 2168 Begin
86262>>>>>>>>>>>>>>>>>      Send OnAfterCut    // Cut Ctrl+X
86263>>>>>>>>>>>>>>>>>    End
86263>>>>>>>>>>>>>>>>>>
86263>>>>>>>>>>>>>>>>>    If (bBlockSelect) Begin
86265>>>>>>>>>>>>>>>>>      If (iKey=KEY_BACK_SPACE) Begin  // in block select the backspace reselection only works one time, to make it work well, we have to reselect by hand
86267>>>>>>>>>>>>>>>>>        Set pbBlockSelectBackspace to True
86268>>>>>>>>>>>>>>>>>      End
86268>>>>>>>>>>>>>>>>>>
86268>>>>>>>>>>>>>>>>>    End
86268>>>>>>>>>>>>>>>>>>
86268>>>>>>>>>>>>>>>>>  End_Procedure
86269>>>>>>>>>>>>>>>>>
86269>>>>>>>>>>>>>>>>>  Procedure onDrawLine Handle hDC Integer iTop Integer iLeft Integer iBottom Integer iRight Integer iColLeft Integer iColRight Integer iLine Pointer pItemData Integer iStyle
86271>>>>>>>>>>>>>>>>>    Integer iRet
86271>>>>>>>>>>>>>>>>>    String sTxt
86271>>>>>>>>>>>>>>>>>    
86271>>>>>>>>>>>>>>>>>    Move (Repeat(Character(0),20))  To sTxt
86272>>>>>>>>>>>>>>>>>    Move "Michis TestText"  to sTxt
86273>>>>>>>>>>>>>>>>>    Move (TextOut(hDC,iLeft,iTop,AddressOf(sTxt),15)) to iRet
86274>>>>>>>>>>>>>>>>>    Showln "iRet: " iRet
86277>>>>>>>>>>>>>>>>>
86277>>>>>>>>>>>>>>>>>    Procedure_Return
86278>>>>>>>>>>>>>>>>>    Showln "hDC "   hDC
86281>>>>>>>>>>>>>>>>>    Showln "iTop "  iTop
86284>>>>>>>>>>>>>>>>>    Showln "iLeft " iLeft
86287>>>>>>>>>>>>>>>>>    Showln "iBottom " iBottom
86290>>>>>>>>>>>>>>>>>    Showln "iRight " iRight
86293>>>>>>>>>>>>>>>>>    Showln "iColLeft " iColLeft
86296>>>>>>>>>>>>>>>>>    Showln "iColRight " iColRight
86299>>>>>>>>>>>>>>>>>    Showln "iLine " iLine
86302>>>>>>>>>>>>>>>>>    Showln "pItemData " pItemData
86305>>>>>>>>>>>>>>>>>    Showln "iStyle " iStyle
86308>>>>>>>>>>>>>>>>>  End_Procedure
86309>>>>>>>>>>>>>>>>>
86309>>>>>>>>>>>>>>>>>  Procedure DoDrawline Pointer pCM_DrawLineData
86311>>>>>>>>>>>>>>>>>    //        Local_BUFFER_CPY sDrawData pDrawData CM_DRAWLINEDATA pCM_DrawLineData
86311>>>>>>>>>>>>>>>>>    //        Integer iTop iBottom iLeft iRight iColLeft iColRight iLine iStyle
86311>>>>>>>>>>>>>>>>>    //        Pointer pItemData
86311>>>>>>>>>>>>>>>>>    //        Handle  hDC
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.top    to iTop
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.bottom to iBottom
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Left   to iLeft
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Right  to iRight
86311>>>>>>>>>>>>>>>>>    //
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.hDC           to hDC
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nLeftCol      to iColLeft
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nRightCol     to iColRight
86311>>>>>>>>>>>>>>>>>    //
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nLine         to iLine
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.lParam        to pItemData
86311>>>>>>>>>>>>>>>>>    //
86311>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.dwStyle       to iStyle
86311>>>>>>>>>>>>>>>>>    //        Send onDrawLine hDC iTop iLeft iBottom iRight iColLeft iColRight iLine pItemData iStyle
86311>>>>>>>>>>>>>>>>>  End_Procedure
86312>>>>>>>>>>>>>>>>>
86312>>>>>>>>>>>>>>>>>
86312>>>>>>>>>>>>>>>>>  // Trap buffer modification...
86312>>>>>>>>>>>>>>>>>  Procedure DoModifiedChange
86314>>>>>>>>>>>>>>>>>    Send onModifiedChange (CM_IsModified(Self))
86315>>>>>>>>>>>>>>>>>  End_Procedure
86316>>>>>>>>>>>>>>>>>  Procedure onModifiedChange Integer bModified
86318>>>>>>>>>>>>>>>>>  End_Procedure
86319>>>>>>>>>>>>>>>>>  // Property change notification...
86319>>>>>>>>>>>>>>>>>  Procedure onPropsChange
86321>>>>>>>>>>>>>>>>>  End_Procedure
86322>>>>>>>>>>>>>>>>>
86322>>>>>>>>>>>>>>>>>  Function IsBraceOpenCharacter Integer iChar Returns Boolean
86324>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86324>>>>>>>>>>>>>>>>>    String  sChar
86324>>>>>>>>>>>>>>>>>
86324>>>>>>>>>>>>>>>>>    Move False to bIsBraceChar
86325>>>>>>>>>>>>>>>>>    Move (Character(iChar)) To sChar
86326>>>>>>>>>>>>>>>>>    If (sChar="(" or sChar="[" or sChar="{") Begin
86328>>>>>>>>>>>>>>>>>      Move True to bIsBraceChar
86329>>>>>>>>>>>>>>>>>    End
86329>>>>>>>>>>>>>>>>>>
86329>>>>>>>>>>>>>>>>>    Function_Return bIsBraceChar
86330>>>>>>>>>>>>>>>>>  End_Function
86331>>>>>>>>>>>>>>>>>
86331>>>>>>>>>>>>>>>>>  Function IsBraceCloseCharacter Integer iChar Returns Boolean
86333>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86333>>>>>>>>>>>>>>>>>    String  sChar
86333>>>>>>>>>>>>>>>>>
86333>>>>>>>>>>>>>>>>>    Move False to bIsBraceChar
86334>>>>>>>>>>>>>>>>>    Move (Character(iChar)) To sChar
86335>>>>>>>>>>>>>>>>>    If (sChar="]" or sChar=")" or sChar="}") Begin
86337>>>>>>>>>>>>>>>>>      Move True to bIsBraceChar
86338>>>>>>>>>>>>>>>>>    End
86338>>>>>>>>>>>>>>>>>>
86338>>>>>>>>>>>>>>>>>    Function_Return bIsBraceChar
86339>>>>>>>>>>>>>>>>>  End_Function
86340>>>>>>>>>>>>>>>>>
86340>>>>>>>>>>>>>>>>>  Function IsBraceCharacter Integer iChar Returns Boolean
86342>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86342>>>>>>>>>>>>>>>>>
86342>>>>>>>>>>>>>>>>>    Get IsBraceOpenCharacter iChar to bIsBraceChar
86343>>>>>>>>>>>>>>>>>    If (bIsBraceChar=False) Begin
86345>>>>>>>>>>>>>>>>>      Get IsBraceCloseCharacter iChar to bIsBraceChar
86346>>>>>>>>>>>>>>>>>    End
86346>>>>>>>>>>>>>>>>>>
86346>>>>>>>>>>>>>>>>>    Function_Return bIsBraceChar
86347>>>>>>>>>>>>>>>>>  End_Function
86348>>>>>>>>>>>>>>>>>
86348>>>>>>>>>>>>>>>>>  // Selection has changed. (Position is included!)
86348>>>>>>>>>>>>>>>>>  Procedure onSelChange
86350>>>>>>>>>>>>>>>>>  End_Procedure
86351>>>>>>>>>>>>>>>>>
86351>>>>>>>>>>>>>>>>>  //
86351>>>>>>>>>>>>>>>>>  // Ordinary method to swap the contents of 2 integer variables
86351>>>>>>>>>>>>>>>>>  //
86351>>>>>>>>>>>>>>>>>  Procedure SwapIntegerVariables Integer ByRef iLine1 Integer ByRef iLine2
86353>>>>>>>>>>>>>>>>>    Integer iTemp
86353>>>>>>>>>>>>>>>>>    Move iLine1 To iTemp
86354>>>>>>>>>>>>>>>>>    Move iLine2 To iLine1
86355>>>>>>>>>>>>>>>>>    Move iTemp  To iLine2
86356>>>>>>>>>>>>>>>>>  End_Procedure
86357>>>>>>>>>>>>>>>>>
86357>>>>>>>>>>>>>>>>>  Function IsValidBraceCharMatch Integer iPos Integer iMatchPos Returns Boolean
86359>>>>>>>>>>>>>>>>>    Boolean bIsValid
86359>>>>>>>>>>>>>>>>>    Integer iLoop
86359>>>>>>>>>>>>>>>>>    Integer iLine
86359>>>>>>>>>>>>>>>>>    Integer iMatchLine
86359>>>>>>>>>>>>>>>>>    String  sLine
86359>>>>>>>>>>>>>>>>>
86359>>>>>>>>>>>>>>>>>    Move False to bIsValid
86360>>>>>>>>>>>>>>>>>    If (iMatchPos<>INVALID_POSITION) Begin
86362>>>>>>>>>>>>>>>>>      // check if the matched brace is on the same line
86362>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iPos      to iLine
86363>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iMatchPos to iMatchLine
86364>>>>>>>>>>>>>>>>>      If (iLine=iMatchLine) Begin
86366>>>>>>>>>>>>>>>>>        Move True To bIsValid
86367>>>>>>>>>>>>>>>>>      End
86367>>>>>>>>>>>>>>>>>>
86367>>>>>>>>>>>>>>>>>      Else Begin
86368>>>>>>>>>>>>>>>>>        // not on the same line, so can only be valid if the line ends with a ;
86368>>>>>>>>>>>>>>>>>        If (iLine>iMatchLine) Begin
86370>>>>>>>>>>>>>>>>>          Send SwapIntegerVariables (&iLine) (&iMatchLine)
86371>>>>>>>>>>>>>>>>>        End
86371>>>>>>>>>>>>>>>>>>
86371>>>>>>>>>>>>>>>>>        Move True To bIsValid
86372>>>>>>>>>>>>>>>>>        For iLoop from iLine to (iMatchLine-1)
86378>>>>>>>>>>>>>>>>>>
86378>>>>>>>>>>>>>>>>>          Get Value iLoop to sLine
86379>>>>>>>>>>>>>>>>>          Move (Rtrim(sLine)) To sLine
86380>>>>>>>>>>>>>>>>>          If (Right(sLine,1)<>";") Begin
86382>>>>>>>>>>>>>>>>>            Move False To bIsValid
86383>>>>>>>>>>>>>>>>>            Move iMatchLine To iLoop // stop
86384>>>>>>>>>>>>>>>>>          End
86384>>>>>>>>>>>>>>>>>>
86384>>>>>>>>>>>>>>>>>        Loop
86385>>>>>>>>>>>>>>>>>>
86385>>>>>>>>>>>>>>>>>      End
86385>>>>>>>>>>>>>>>>>>
86385>>>>>>>>>>>>>>>>>    End
86385>>>>>>>>>>>>>>>>>>
86385>>>>>>>>>>>>>>>>>    Function_Return bIsValid
86386>>>>>>>>>>>>>>>>>  End_Function
86387>>>>>>>>>>>>>>>>>
86387>>>>>>>>>>>>>>>>>  //
86387>>>>>>>>>>>>>>>>>  // Check if the style at the position supplied is either a comment or a DataFlex image
86387>>>>>>>>>>>>>>>>>  //
86387>>>>>>>>>>>>>>>>>  Function StyleAtPosIsComment Integer iPos Returns Boolean
86389>>>>>>>>>>>>>>>>>    Boolean bIsComment
86389>>>>>>>>>>>>>>>>>    Integer eStyle
86389>>>>>>>>>>>>>>>>>
86389>>>>>>>>>>>>>>>>>    Move False to bIsComment
86390>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
86391>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_IMAGE or eStyle=SCE_DF_COMMENTLINE) Begin
86393>>>>>>>>>>>>>>>>>      Move True to bIsComment
86394>>>>>>>>>>>>>>>>>    End
86394>>>>>>>>>>>>>>>>>>
86394>>>>>>>>>>>>>>>>>    Function_Return bIsComment
86395>>>>>>>>>>>>>>>>>  End_Function
86396>>>>>>>>>>>>>>>>>
86396>>>>>>>>>>>>>>>>>  Function StyleAtCurrentPosIsComment Returns Boolean
86398>>>>>>>>>>>>>>>>>    Boolean bIsComment
86398>>>>>>>>>>>>>>>>>    Integer iPos
86398>>>>>>>>>>>>>>>>>
86398>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS To iPos
86399>>>>>>>>>>>>>>>>>    Get StyleAtPosIsComment iPos To bIsComment
86400>>>>>>>>>>>>>>>>>    Function_Return bIsComment
86401>>>>>>>>>>>>>>>>>  End_Function
86402>>>>>>>>>>>>>>>>>
86402>>>>>>>>>>>>>>>>>  Function StyleAtPosIsDfImage Integer iPos Returns Boolean
86404>>>>>>>>>>>>>>>>>    Boolean bIsComment
86404>>>>>>>>>>>>>>>>>    Integer eStyle
86404>>>>>>>>>>>>>>>>>
86404>>>>>>>>>>>>>>>>>    Move False to bIsComment
86405>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
86406>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_IMAGE) Begin
86408>>>>>>>>>>>>>>>>>      Move True to bIsComment
86409>>>>>>>>>>>>>>>>>    End
86409>>>>>>>>>>>>>>>>>>
86409>>>>>>>>>>>>>>>>>    Function_Return bIsComment
86410>>>>>>>>>>>>>>>>>  End_Function
86411>>>>>>>>>>>>>>>>>
86411>>>>>>>>>>>>>>>>>  Function StyleAtPosIsDfKeyword Integer iPos Returns Boolean
86413>>>>>>>>>>>>>>>>>    Boolean bIsKeyword
86413>>>>>>>>>>>>>>>>>    Integer eStyle
86413>>>>>>>>>>>>>>>>>
86413>>>>>>>>>>>>>>>>>    Move False to bIsKeyword
86414>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
86415>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_SCOPEWORD) Begin // SCE_DF_WORD
86417>>>>>>>>>>>>>>>>>      Move True to bIsKeyword
86418>>>>>>>>>>>>>>>>>    End
86418>>>>>>>>>>>>>>>>>>
86418>>>>>>>>>>>>>>>>>    Function_Return bIsKeyword
86419>>>>>>>>>>>>>>>>>  End_Function
86420>>>>>>>>>>>>>>>>>
86420>>>>>>>>>>>>>>>>>  Function PosAtEndOfLine Integer iPos Returns Boolean
86422>>>>>>>>>>>>>>>>>    Boolean bAtEOL
86422>>>>>>>>>>>>>>>>>    Integer iLine
86422>>>>>>>>>>>>>>>>>    Integer iPosAtEOL
86422>>>>>>>>>>>>>>>>>
86422>>>>>>>>>>>>>>>>>    Move False To bAtEOL
86423>>>>>>>>>>>>>>>>>    Get Editormessage SCI_LINEFROMPOSITION   iPos  To iLine
86424>>>>>>>>>>>>>>>>>    Get Editormessage SCI_GETLINEENDPOSITION iLine To iPosAtEOL
86425>>>>>>>>>>>>>>>>>    If (iPos=(iPosAtEOL-1)) Begin
86427>>>>>>>>>>>>>>>>>      Move True to bAtEOL
86428>>>>>>>>>>>>>>>>>    End
86428>>>>>>>>>>>>>>>>>>
86428>>>>>>>>>>>>>>>>>    Function_Return bAtEOL
86429>>>>>>>>>>>>>>>>>  End_Function
86430>>>>>>>>>>>>>>>>>
86430>>>>>>>>>>>>>>>>>  // Shows matching braces for the characters ({[]})
86430>>>>>>>>>>>>>>>>>  // Note that SCI_BRACEHIGHLIGHT can only highlight two characters so it will not
86430>>>>>>>>>>>>>>>>>  // work for highlighting words like begin/end.
86430>>>>>>>>>>>>>>>>>  Procedure ShowMatchingBraces Integer iPos
86432>>>>>>>>>>>>>>>>>    Integer iChar
86432>>>>>>>>>>>>>>>>>    Integer imaxReStyle
86432>>>>>>>>>>>>>>>>>    Integer iMatchPos
86432>>>>>>>>>>>>>>>>>    Integer iMainSelection
86432>>>>>>>>>>>>>>>>>    Integer iVirtSpace
86432>>>>>>>>>>>>>>>>>    Boolean bMatchPreviousChar
86432>>>>>>>>>>>>>>>>>    Boolean bIsMatch
86432>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86432>>>>>>>>>>>>>>>>>    Boolean bIsComment
86432>>>>>>>>>>>>>>>>>    Boolean bPosAtEOL
86432>>>>>>>>>>>>>>>>>    // get the char
86432>>>>>>>>>>>>>>>>>    Move 0 To iVirtSpace
86433>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMAINSELECTION to iMainSelection
86434>>>>>>>>>>>>>>>>>    If (imainSelection>=0) Begin
86436>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETSELECTIONNCARETVIRTUALSPACE iMainSelection to iVirtSpace
86437>>>>>>>>>>>>>>>>>    End
86437>>>>>>>>>>>>>>>>>>
86437>>>>>>>>>>>>>>>>>    If (iVirtSpace>0) Begin  // we are navigating the cursor past the end of line into "virtual space"
86439>>>>>>>>>>>>>>>>>      If (pbBraceHighLightState(Self)) Begin
86441>>>>>>>>>>>>>>>>>        // remove the highlight
86441>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
86442>>>>>>>>>>>>>>>>>        Set pbBraceHighLightState to False
86443>>>>>>>>>>>>>>>>>      End
86443>>>>>>>>>>>>>>>>>>
86443>>>>>>>>>>>>>>>>>    End
86443>>>>>>>>>>>>>>>>>>
86443>>>>>>>>>>>>>>>>>    Else Begin
86444>>>>>>>>>>>>>>>>>      Move True to bMatchPreviousChar // this seems to make more sense as you see match while you type
86445>>>>>>>>>>>>>>>>>      Move False to bIsBraceChar
86446>>>>>>>>>>>>>>>>>      If (iPos>0 and bMatchPreviousChar) Begin
86448>>>>>>>>>>>>>>>>>        Move (iPos-1) To iPos
86449>>>>>>>>>>>>>>>>>      End
86449>>>>>>>>>>>>>>>>>>
86449>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCHARAT iPos to iChar
86450>>>>>>>>>>>>>>>>>      Get IsBraceCharacter iChar To bIsBraceChar
86451>>>>>>>>>>>>>>>>>      If (bIsBraceChar) Begin
86453>>>>>>>>>>>>>>>>>        Get StyleAtPosIsComment iPos To bIsComment
86454>>>>>>>>>>>>>>>>>        If (bIsComment=false) Begin
86456>>>>>>>>>>>>>>>>>          Move 0 to imaxReStyle
86457>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
86458>>>>>>>>>>>>>>>>>          Get IsValidBraceCharMatch iPos iMatchPos to bIsMatch
86459>>>>>>>>>>>>>>>>>          If (bIsMatch) Begin
86461>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_BRACEHIGHLIGHT iPos iMatchPos
86462>>>>>>>>>>>>>>>>>            Set pbBraceHighLightState to True
86463>>>>>>>>>>>>>>>>>          End
86463>>>>>>>>>>>>>>>>>>
86463>>>>>>>>>>>>>>>>>          Else Begin
86464>>>>>>>>>>>>>>>>>            Get PosAtEndOfLine iPos To bPosAtEOL
86465>>>>>>>>>>>>>>>>>            If (bPosAtEOL=false) Begin
86467>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_BRACEBADLIGHT iPos
86468>>>>>>>>>>>>>>>>>              Set pbBraceHighLightState to True
86469>>>>>>>>>>>>>>>>>            End
86469>>>>>>>>>>>>>>>>>>
86469>>>>>>>>>>>>>>>>>          End
86469>>>>>>>>>>>>>>>>>>
86469>>>>>>>>>>>>>>>>>        End
86469>>>>>>>>>>>>>>>>>>
86469>>>>>>>>>>>>>>>>>      End
86469>>>>>>>>>>>>>>>>>>
86469>>>>>>>>>>>>>>>>>      Else Begin
86470>>>>>>>>>>>>>>>>>        If (pbBraceHighLightState(Self)) Begin
86472>>>>>>>>>>>>>>>>>          // remove the highlight
86472>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
86473>>>>>>>>>>>>>>>>>          Set pbBraceHighLightState to False
86474>>>>>>>>>>>>>>>>>        End
86474>>>>>>>>>>>>>>>>>>
86474>>>>>>>>>>>>>>>>>      End
86474>>>>>>>>>>>>>>>>>>
86474>>>>>>>>>>>>>>>>>    End
86474>>>>>>>>>>>>>>>>>>
86474>>>>>>>>>>>>>>>>>  End_Procedure
86475>>>>>>>>>>>>>>>>>
86475>>>>>>>>>>>>>>>>>  //
86475>>>>>>>>>>>>>>>>>  // A preparsed line is a "normal" line but it has some of the parsing difficulties removed.
86475>>>>>>>>>>>>>>>>>  // Eg. all string literals are now underscores, eg. "abc" becomes ____
86475>>>>>>>>>>>>>>>>>  //                             or plus symbols  eg. 'abc' becomes ++++
86475>>>>>>>>>>>>>>>>>  //     all comments are cut off
86475>>>>>>>>>>>>>>>>>  //     all space characters on the right are trimmed
86475>>>>>>>>>>>>>>>>>  // So the relevant part of the line has just as much characters as before, but no longer creates
86475>>>>>>>>>>>>>>>>>  // parsing issues with parse targets that are embedded in strings or comments.
86475>>>>>>>>>>>>>>>>>  Function PreParsedLine Integer iLine Returns String
86477>>>>>>>>>>>>>>>>>    Boolean bDoubleQuote
86477>>>>>>>>>>>>>>>>>    Boolean bSingleQuote
86477>>>>>>>>>>>>>>>>>    Integer iChar
86477>>>>>>>>>>>>>>>>>    Integer iLength
86477>>>>>>>>>>>>>>>>>    String  sLine
86477>>>>>>>>>>>>>>>>>    String  sChar
86477>>>>>>>>>>>>>>>>>
86477>>>>>>>>>>>>>>>>>    Get CM_GetLine iLine to sLine
86478>>>>>>>>>>>>>>>>>    Move (Length(sLine)) To iLength
86479>>>>>>>>>>>>>>>>>    For iChar From 1 To iLength
86485>>>>>>>>>>>>>>>>>>
86485>>>>>>>>>>>>>>>>>      Move (Mid(sLine,1,iChar)) To sChar
86486>>>>>>>>>>>>>>>>>      If (sChar=Character(9)) Begin // tab characters should be treated as a single space char, this keeps the
86488>>>>>>>>>>>>>>>>>        Move (Overstrike(" ",sLine,iChar)) To sLine // position in the string the same.
86489>>>>>>>>>>>>>>>>>        Move " " To sChar
86490>>>>>>>>>>>>>>>>>      End
86490>>>>>>>>>>>>>>>>>>
86490>>>>>>>>>>>>>>>>>      If (bDoubleQuote and sChar='"') Begin
86492>>>>>>>>>>>>>>>>>        Move (Overstrike("_",sLine,iChar)) To sLine
86493>>>>>>>>>>>>>>>>>        Move "" To sChar
86494>>>>>>>>>>>>>>>>>        Move False To bDoubleQuote
86495>>>>>>>>>>>>>>>>>      End
86495>>>>>>>>>>>>>>>>>>
86495>>>>>>>>>>>>>>>>>      If (bSingleQuote and sChar="'") Begin
86497>>>>>>>>>>>>>>>>>        Move (Overstrike("+",sLine,iChar)) To sLine
86498>>>>>>>>>>>>>>>>>        Move "" To sChar
86499>>>>>>>>>>>>>>>>>        Move False To bSingleQuote
86500>>>>>>>>>>>>>>>>>      End
86500>>>>>>>>>>>>>>>>>>
86500>>>>>>>>>>>>>>>>>      If (sChar='"') ;        Move True To bDoubleQuote
86503>>>>>>>>>>>>>>>>>      If (sChar="'") ;        Move True To bSingleQuote
86506>>>>>>>>>>>>>>>>>      If bDoubleQuote ;        Move (Overstrike("_",sLine,iChar)) To sLine
86509>>>>>>>>>>>>>>>>>      Else ;        If bSingleQuote ;        Move (Overstrike("+",sLine,iChar)) To sLine
86513>>>>>>>>>>>>>>>>>      Else If (sChar="/") Begin
86516>>>>>>>>>>>>>>>>>        If (Mid(sLine,2,iChar)="//") Begin
86518>>>>>>>>>>>>>>>>>          Move (Left(sLine,iChar-1)) To sLine
86519>>>>>>>>>>>>>>>>>          Move iLength to iChar // end loop
86520>>>>>>>>>>>>>>>>>        End
86520>>>>>>>>>>>>>>>>>>
86520>>>>>>>>>>>>>>>>>      End
86520>>>>>>>>>>>>>>>>>>
86520>>>>>>>>>>>>>>>>>    Loop
86521>>>>>>>>>>>>>>>>>>
86521>>>>>>>>>>>>>>>>>    Move (Rtrim(sLine)) To sLine
86522>>>>>>>>>>>>>>>>>    Function_Return sLine
86523>>>>>>>>>>>>>>>>>  End_Function
86524>>>>>>>>>>>>>>>>>
86524>>>>>>>>>>>>>>>>>
86524>>>>>>>>>>>>>>>>>  Procedure BraceMatchLocation Integer iChar String sLine Integer iCol Integer ByRef iBraceCount Integer ByRef iBraceMatch
86526>>>>>>>>>>>>>>>>>    Boolean bOpenChar
86526>>>>>>>>>>>>>>>>>    Boolean bCloseChar
86526>>>>>>>>>>>>>>>>>    Integer iLinePos
86526>>>>>>>>>>>>>>>>>    Integer iLineChar
86526>>>>>>>>>>>>>>>>>    Integer iLength
86526>>>>>>>>>>>>>>>>>
86526>>>>>>>>>>>>>>>>>    Move (Length(sLine)) To iLength
86527>>>>>>>>>>>>>>>>>    If (iCol<=iLength) Begin
86529>>>>>>>>>>>>>>>>>      Get IsBraceOpenCharacter iChar to bOpenChar
86530>>>>>>>>>>>>>>>>>      If (bOpenChar) Begin
86532>>>>>>>>>>>>>>>>>        For iLinePos from iCol to iLength
86538>>>>>>>>>>>>>>>>>>
86538>>>>>>>>>>>>>>>>>          Move False to bOpenChar
86539>>>>>>>>>>>>>>>>>          Move False To bCloseChar
86540>>>>>>>>>>>>>>>>>          Move (Ascii(Mid(sLine,1,iLinePos))) To iLineChar
86541>>>>>>>>>>>>>>>>>          Get IsBraceOpenCharacter iLineChar to bOpenChar
86542>>>>>>>>>>>>>>>>>          If (bOpenChar) ;            Increment iBraceCount
86545>>>>>>>>>>>>>>>>>          Else ;            Get IsBraceCloseCharacter iLineChar to bCloseChar
86547>>>>>>>>>>>>>>>>>          If (bCloseChar) Begin
86549>>>>>>>>>>>>>>>>>            Decrement iBraceCount
86550>>>>>>>>>>>>>>>>>            If (iBraceCount=0) Begin
86552>>>>>>>>>>>>>>>>>              Move iLinePos To iBraceMatch
86553>>>>>>>>>>>>>>>>>              Move iLength  To iLinePos
86554>>>>>>>>>>>>>>>>>            End
86554>>>>>>>>>>>>>>>>>>
86554>>>>>>>>>>>>>>>>>          End
86554>>>>>>>>>>>>>>>>>>
86554>>>>>>>>>>>>>>>>>        Loop
86555>>>>>>>>>>>>>>>>>>
86555>>>>>>>>>>>>>>>>>      End
86555>>>>>>>>>>>>>>>>>>
86555>>>>>>>>>>>>>>>>>      Else Begin  // We're on a close brace
86556>>>>>>>>>>>>>>>>>        Move iCol To iLinePos
86557>>>>>>>>>>>>>>>>>        While (iLinePos>0)
86561>>>>>>>>>>>>>>>>>          Move False To bOpenChar
86562>>>>>>>>>>>>>>>>>          Move False To bCloseChar
86563>>>>>>>>>>>>>>>>>          Move (Ascii(Mid(sLine,1,iLinePos))) To iLineChar
86564>>>>>>>>>>>>>>>>>          Get IsBraceCloseCharacter iLineChar to bCloseChar
86565>>>>>>>>>>>>>>>>>          If (bCloseChar) ;            Increment iBraceCount
86568>>>>>>>>>>>>>>>>>          Else ;            Get IsBraceOpenCharacter iLineChar to bOpenChar
86570>>>>>>>>>>>>>>>>>          If (bOpenChar) Begin
86572>>>>>>>>>>>>>>>>>            Decrement iBraceCount
86573>>>>>>>>>>>>>>>>>            If (iBraceCount=0) Begin
86575>>>>>>>>>>>>>>>>>              Move iLinePos To iBraceMatch
86576>>>>>>>>>>>>>>>>>              Move -1 To iLinePos
86577>>>>>>>>>>>>>>>>>            End
86577>>>>>>>>>>>>>>>>>>
86577>>>>>>>>>>>>>>>>>          End
86577>>>>>>>>>>>>>>>>>>
86577>>>>>>>>>>>>>>>>>          Decrement iLinePos
86578>>>>>>>>>>>>>>>>>        Loop
86579>>>>>>>>>>>>>>>>>>
86579>>>>>>>>>>>>>>>>>      End
86579>>>>>>>>>>>>>>>>>>
86579>>>>>>>>>>>>>>>>>    End
86579>>>>>>>>>>>>>>>>>>
86579>>>>>>>>>>>>>>>>>  End_Procedure
86580>>>>>>>>>>>>>>>>>
86580>>>>>>>>>>>>>>>>>  Function FoldLevelWhiteLine Integer iLine Returns Boolean
86582>>>>>>>>>>>>>>>>>    Boolean bWhiteLine
86582>>>>>>>>>>>>>>>>>    Integer uFoldLevel
86582>>>>>>>>>>>>>>>>>
86582>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel // unmasked level
86583>>>>>>>>>>>>>>>>>    Move ((uFoldLevel iAnd SC_FOLDLEVELWHITEFLAG)=SC_FOLDLEVELWHITEFLAG) To bWhiteLine
86584>>>>>>>>>>>>>>>>>    Function_Return bWhiteLine
86585>>>>>>>>>>>>>>>>>  End_Function
86586>>>>>>>>>>>>>>>>>
86586>>>>>>>>>>>>>>>>>  Function MatchKeywordPosition Integer iMatchLine Boolean bFoldPoint Integer iFoldLevel Returns Integer
86588>>>>>>>>>>>>>>>>>    Boolean bWhiteLine
86588>>>>>>>>>>>>>>>>>    Integer eStyle
86588>>>>>>>>>>>>>>>>>    Integer iStartPos
86588>>>>>>>>>>>>>>>>>    Integer iEndPos
86588>>>>>>>>>>>>>>>>>    Integer iPos
86588>>>>>>>>>>>>>>>>>    Integer iMatchPos
86588>>>>>>>>>>>>>>>>>
86588>>>>>>>>>>>>>>>>>    Move -1 To iMatchPos
86589>>>>>>>>>>>>>>>>>    If (iMatchLine>-1) Begin
86591>>>>>>>>>>>>>>>>>      If (bFoldPoint) Begin // white lines are also part of the fold, move up if needed
86593>>>>>>>>>>>>>>>>>        Get FoldLevelWhiteLine iMatchLine to bWhiteLine
86594>>>>>>>>>>>>>>>>>        While (bWhiteLine)
86598>>>>>>>>>>>>>>>>>          Decrement iMatchLine
86599>>>>>>>>>>>>>>>>>          Get FoldLevelWhiteLine iMatchLine to bWhiteLine
86600>>>>>>>>>>>>>>>>>        Loop
86601>>>>>>>>>>>>>>>>>>
86601>>>>>>>>>>>>>>>>>      End
86601>>>>>>>>>>>>>>>>>>
86601>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_POSITIONFROMLINE   iMatchLine to iStartPos
86602>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETLINEENDPOSITION iMatchLine to iEndPos
86603>>>>>>>>>>>>>>>>>      For iPos From iStartPos To iEndPos
86609>>>>>>>>>>>>>>>>>>
86609>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
86610>>>>>>>>>>>>>>>>>        If (eStyle=SCE_DF_SCOPEWORD) Begin
86612>>>>>>>>>>>>>>>>>          Move iPos To iMatchPos
86613>>>>>>>>>>>>>>>>>          Move iEndPos To iPos
86614>>>>>>>>>>>>>>>>>        End
86614>>>>>>>>>>>>>>>>>>
86614>>>>>>>>>>>>>>>>>      Loop
86615>>>>>>>>>>>>>>>>>>
86615>>>>>>>>>>>>>>>>>    End
86615>>>>>>>>>>>>>>>>>>
86615>>>>>>>>>>>>>>>>>    Function_Return iMatchPos
86616>>>>>>>>>>>>>>>>>  End_Function
86617>>>>>>>>>>>>>>>>>
86617>>>>>>>>>>>>>>>>>  Function LineFoldLevel Integer iLine Returns Integer
86619>>>>>>>>>>>>>>>>>    Integer uFoldLevel
86619>>>>>>>>>>>>>>>>>    Integer iFoldLevel
86619>>>>>>>>>>>>>>>>>
86619>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFOLDLEVEL iLine To uFoldLevel // unmasked level
86620>>>>>>>>>>>>>>>>>    Move (uFoldLevel iAnd SC_FOLDLEVELNUMBERMASK) To iFoldLevel
86621>>>>>>>>>>>>>>>>>    Move (iFoldLevel-SC_FOLDLEVELBASE) To iFoldLevel
86622>>>>>>>>>>>>>>>>>    Function_Return iFoldLevel
86623>>>>>>>>>>>>>>>>>  End_Function
86624>>>>>>>>>>>>>>>>>
86624>>>>>>>>>>>>>>>>>  Procedure GotoMatchBraceKeyword Integer iPos Integer iLine
86626>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
86626>>>>>>>>>>>>>>>>>    Integer eStyle
86626>>>>>>>>>>>>>>>>>    Integer uFoldLevel
86626>>>>>>>>>>>>>>>>>    Integer iFoldLevel
86626>>>>>>>>>>>>>>>>>    Integer iMatchLine
86626>>>>>>>>>>>>>>>>>    Integer iMatchPos
86626>>>>>>>>>>>>>>>>>
86626>>>>>>>>>>>>>>>>>    Move -1 To iMatchPos
86627>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
86628>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_SCOPEWORD) Begin
86630>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel // unmasked level
86631>>>>>>>>>>>>>>>>>      Move (uFoldLevel iAnd SC_FOLDLEVELNUMBERMASK) To iFoldLevel
86632>>>>>>>>>>>>>>>>>      Move ((uFoldLevel iAnd SC_FOLDLEVELHEADERFLAG)=SC_FOLDLEVELHEADERFLAG)To bFoldPoint
86633>>>>>>>>>>>>>>>>>      If (bFoldPoint) Begin
86635>>>>>>>>>>>>>>>>>        Get Editormessage SCI_GETLASTCHILD iLine -1 to iMatchLine
86636>>>>>>>>>>>>>>>>>        //If (iMatchLine>-1 and iFoldLevel=(SC_FOLDLEVELBASE+1)) Decrement iMatchLine
86636>>>>>>>>>>>>>>>>>        Get MatchKeywordPosition iMatchLine bFoldPoint iFoldLevel to iMatchPos
86637>>>>>>>>>>>>>>>>>      End
86637>>>>>>>>>>>>>>>>>>
86637>>>>>>>>>>>>>>>>>      Else Begin
86638>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETFOLDPARENT iLine to iMatchLine
86639>>>>>>>>>>>>>>>>>        Get MatchKeywordPosition iMatchLine bFoldPoint iFoldLevel to iMatchPos
86640>>>>>>>>>>>>>>>>>      End
86640>>>>>>>>>>>>>>>>>>
86640>>>>>>>>>>>>>>>>>    End
86640>>>>>>>>>>>>>>>>>>
86640>>>>>>>>>>>>>>>>>    If (iMatchPos>-1) Begin
86642>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOPOS iMatchPos
86643>>>>>>>>>>>>>>>>>    End
86643>>>>>>>>>>>>>>>>>>
86643>>>>>>>>>>>>>>>>>  End_Procedure
86644>>>>>>>>>>>>>>>>>
86644>>>>>>>>>>>>>>>>>
86644>>>>>>>>>>>>>>>>>  Procedure GotoMatchBrace
86646>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86646>>>>>>>>>>>>>>>>>    Boolean bOpenChar
86646>>>>>>>>>>>>>>>>>    Integer iBraceCount
86646>>>>>>>>>>>>>>>>>    Integer iPos
86646>>>>>>>>>>>>>>>>>    Integer iCol
86646>>>>>>>>>>>>>>>>>    Integer iChar
86646>>>>>>>>>>>>>>>>>    Integer iLine
86646>>>>>>>>>>>>>>>>>    Integer iLineLength
86646>>>>>>>>>>>>>>>>>    Integer iBraceMatch
86646>>>>>>>>>>>>>>>>>    String  sLine
86646>>>>>>>>>>>>>>>>>
86646>>>>>>>>>>>>>>>>>    Move -1 To iBraceMatch
86647>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS To iPos
86648>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
86649>>>>>>>>>>>>>>>>>    If (iPos>0) Begin
86651>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCHARAT (iPos-1) to iChar
86652>>>>>>>>>>>>>>>>>    End
86652>>>>>>>>>>>>>>>>>>
86652>>>>>>>>>>>>>>>>>    Get IsBraceCharacter iChar To bIsBraceChar
86653>>>>>>>>>>>>>>>>>    If (bIsBraceChar) Begin
86655>>>>>>>>>>>>>>>>>      Get PreParsedLine iLine to sLine
86656>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCOLUMN (iPos-1) to iCol // zero based
86657>>>>>>>>>>>>>>>>>      Send BraceMatchLocation iChar sLine (iCol+1) (&iBraceCount) (&iBraceMatch)
86658>>>>>>>>>>>>>>>>>      If (iBraceMatch=-1) Begin
86660>>>>>>>>>>>>>>>>>        Move (iPos-iCol) To iPos
86661>>>>>>>>>>>>>>>>>        Move 0 To iCol // current column no longer relative as we are trying to match against another line
86662>>>>>>>>>>>>>>>>>        Get IsBraceOpenCharacter iChar to bOpenChar
86663>>>>>>>>>>>>>>>>>        If (bOpenChar) Begin
86665>>>>>>>>>>>>>>>>>          While (iBraceMatch=-1 and Right(sLine,1)=";")
86669>>>>>>>>>>>>>>>>>            Get EditorMessage SCI_LINELENGTH iLine to iLineLength
86670>>>>>>>>>>>>>>>>>            Move (iPos+iLineLength) To iPos
86671>>>>>>>>>>>>>>>>>            Increment iLine
86672>>>>>>>>>>>>>>>>>            Get PreParsedLine iLine to sLine
86673>>>>>>>>>>>>>>>>>            Send BraceMatchLocation iChar sLine 1 (&iBraceCount) (&iBraceMatch)
86674>>>>>>>>>>>>>>>>>          Loop
86675>>>>>>>>>>>>>>>>>>
86675>>>>>>>>>>>>>>>>>        End
86675>>>>>>>>>>>>>>>>>>
86675>>>>>>>>>>>>>>>>>        Else Begin // it's a closed char
86676>>>>>>>>>>>>>>>>>          If (iLine>1) Begin
86678>>>>>>>>>>>>>>>>>            Get PreParsedLine (iLine-1) to sLine
86679>>>>>>>>>>>>>>>>>            While (iBraceMatch=-1 and Right(sLine,1)=";" and iLine>1)
86683>>>>>>>>>>>>>>>>>              Send BraceMatchLocation iChar sLine (Length(sLine)) (&iBraceCount) (&iBraceMatch)
86684>>>>>>>>>>>>>>>>>              Decrement iLine
86685>>>>>>>>>>>>>>>>>              Get EditorMessage SCI_LINELENGTH iLine to iLineLength
86686>>>>>>>>>>>>>>>>>              Move (iPos-iLineLength) To iPos
86687>>>>>>>>>>>>>>>>>              Get PreParsedLine (iLine-1) to sLine
86688>>>>>>>>>>>>>>>>>            Loop
86689>>>>>>>>>>>>>>>>>>
86689>>>>>>>>>>>>>>>>>          End
86689>>>>>>>>>>>>>>>>>>
86689>>>>>>>>>>>>>>>>>        End
86689>>>>>>>>>>>>>>>>>>
86689>>>>>>>>>>>>>>>>>      End
86689>>>>>>>>>>>>>>>>>>
86689>>>>>>>>>>>>>>>>>      If (iBraceMatch>-1) Begin
86691>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_GOTOPOS (iPos-(iCol+1)+iBraceMatch)
86692>>>>>>>>>>>>>>>>>      End
86692>>>>>>>>>>>>>>>>>>
86692>>>>>>>>>>>>>>>>>    End
86692>>>>>>>>>>>>>>>>>>
86692>>>>>>>>>>>>>>>>>    Else Begin // not a brace char, is there a scope keyword under our cursor?
86693>>>>>>>>>>>>>>>>>      Send GotoMatchBraceKeyword iPos iLine
86694>>>>>>>>>>>>>>>>>    End
86694>>>>>>>>>>>>>>>>>>
86694>>>>>>>>>>>>>>>>>  End_Procedure
86695>>>>>>>>>>>>>>>>>
86695>>>>>>>>>>>>>>>>>  //
86695>>>>>>>>>>>>>>>>>  // Navigation, the cursor changed lines event
86695>>>>>>>>>>>>>>>>>  //
86695>>>>>>>>>>>>>>>>>  Procedure onLineChanged Integer iLineOld Integer iLineNew
86697>>>>>>>>>>>>>>>>>  End_Procedure
86698>>>>>>>>>>>>>>>>>
86698>>>>>>>>>>>>>>>>>  //
86698>>>>>>>>>>>>>>>>>  // Navigation, called when the cursor changes lines
86698>>>>>>>>>>>>>>>>>  //
86698>>>>>>>>>>>>>>>>>  Procedure LineChanged Integer iLineOld Integer iLineNew
86700>>>>>>>>>>>>>>>>>    Handle  hMarker
86700>>>>>>>>>>>>>>>>>    Integer iLine
86700>>>>>>>>>>>>>>>>>    String  sLine
86700>>>>>>>>>>>>>>>>>
86700>>>>>>>>>>>>>>>>>    Get phMarkerLineHighLight to hMarker
86701>>>>>>>>>>>>>>>>>    If (hMarker<>0) Begin
86703>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
86704>>>>>>>>>>>>>>>>>      If (iLine<>iLineNew) Begin
86706>>>>>>>>>>>>>>>>>        Send ResetHighlightedLine
86707>>>>>>>>>>>>>>>>>      End
86707>>>>>>>>>>>>>>>>>>
86707>>>>>>>>>>>>>>>>>    End
86707>>>>>>>>>>>>>>>>>>
86707>>>>>>>>>>>>>>>>>    If (iLineOld<>iLineNew) Begin
86709>>>>>>>>>>>>>>>>>      Get CM_GetLine iLineNew to sLine
86710>>>>>>>>>>>>>>>>>      Set psLineOnEnter       to sLine
86711>>>>>>>>>>>>>>>>>      Set Status_Help to "" // remove status help if anything in there
86712>>>>>>>>>>>>>>>>>      Send Request_Status_Help True
86713>>>>>>>>>>>>>>>>>    End
86713>>>>>>>>>>>>>>>>>>
86713>>>>>>>>>>>>>>>>>    Send onLineChanged iLineOld iLineNew
86714>>>>>>>>>>>>>>>>>  End_Procedure
86715>>>>>>>>>>>>>>>>>
86715>>>>>>>>>>>>>>>>>  Procedure onNavigate Integer iPos
86717>>>>>>>>>>>>>>>>>    Integer iLineOld
86717>>>>>>>>>>>>>>>>>    Integer iLineNew
86717>>>>>>>>>>>>>>>>>    Boolean bShowMatchingBraces
86717>>>>>>>>>>>>>>>>>
86717>>>>>>>>>>>>>>>>>    Get piSelEndLine to iLineOld
86718>>>>>>>>>>>>>>>>>    Get pbShowMatchingBraces to bShowMatchingBraces
86719>>>>>>>>>>>>>>>>>    If (bShowMatchingBraces) Begin
86721>>>>>>>>>>>>>>>>>      Send ShowMatchingBraces iPos
86722>>>>>>>>>>>>>>>>>    End
86722>>>>>>>>>>>>>>>>>>
86722>>>>>>>>>>>>>>>>>    Send onSelChange
86723>>>>>>>>>>>>>>>>>    Get piSelEndLine to iLineNew
86724>>>>>>>>>>>>>>>>>    If (iLineOld<>iLineNew) Begin
86726>>>>>>>>>>>>>>>>>      Send LineChanged iLineOld iLineNew
86727>>>>>>>>>>>>>>>>>    End
86727>>>>>>>>>>>>>>>>>>
86727>>>>>>>>>>>>>>>>>  End_Procedure
86728>>>>>>>>>>>>>>>>>
86728>>>>>>>>>>>>>>>>>  //
86728>>>>>>>>>>>>>>>>>  // Is called when the user has inserted or deleted text, so effectively when our document
86728>>>>>>>>>>>>>>>>>  // line count changes.
86728>>>>>>>>>>>>>>>>>  //
86728>>>>>>>>>>>>>>>>>  Procedure LineCountChanged
86730>>>>>>>>>>>>>>>>>    Integer iOldDigits
86730>>>>>>>>>>>>>>>>>    Integer iNewDigits
86730>>>>>>>>>>>>>>>>>    Integer iMinDigits
86730>>>>>>>>>>>>>>>>>    Integer iLineCount
86730>>>>>>>>>>>>>>>>>    Integer iVoid
86730>>>>>>>>>>>>>>>>>    Integer iWidth
86730>>>>>>>>>>>>>>>>>
86730>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS to iWidth
86731>>>>>>>>>>>>>>>>>    If (iWidth<>0) Begin  // we have a line number margin, how many lines?
86733>>>>>>>>>>>>>>>>>      Get Item_Count to iLineCount // the margin width is determined based on number of digits
86734>>>>>>>>>>>>>>>>>      Move 3 To iMinDigits         // we set a minimum digits width of 3 digits
86735>>>>>>>>>>>>>>>>>      Get piMarginLineNumberDigits    To iOldDigits
86736>>>>>>>>>>>>>>>>>      Move (Length(Trim(iLineCount))) To iNewDigits
86737>>>>>>>>>>>>>>>>>      If (inewDigits<iMinDigits) Begin
86739>>>>>>>>>>>>>>>>>        Move iMinDigits to iNewDigits
86740>>>>>>>>>>>>>>>>>      End
86740>>>>>>>>>>>>>>>>>>
86740>>>>>>>>>>>>>>>>>      If (iOldDigits<>iNewDigits) Begin
86742>>>>>>>>>>>>>>>>>        Get CM_SetLineNumbering True 0 0 to iVoid  // by enabling line numbering we tell the logic to update the width
86743>>>>>>>>>>>>>>>>>      End
86743>>>>>>>>>>>>>>>>>>
86743>>>>>>>>>>>>>>>>>    End
86743>>>>>>>>>>>>>>>>>>
86743>>>>>>>>>>>>>>>>>  End_Procedure
86744>>>>>>>>>>>>>>>>>
86744>>>>>>>>>>>>>>>>>  // Insert mode / Overwrite mode
86744>>>>>>>>>>>>>>>>>  Procedure onOvertypeChange
86746>>>>>>>>>>>>>>>>>  End_Procedure
86747>>>>>>>>>>>>>>>>>
86747>>>>>>>>>>>>>>>>>  Procedure RegisterKeyBindingToClear String sKey
86749>>>>>>>>>>>>>>>>>    String[] KeyBindings
86750>>>>>>>>>>>>>>>>>
86750>>>>>>>>>>>>>>>>>    Get psClearKeyBindings to KeyBindings
86751>>>>>>>>>>>>>>>>>    Move sKey To KeyBindings[SizeOfArray(KeyBindings)]
86752>>>>>>>>>>>>>>>>>    Set psClearKeyBindings to KeyBindings
86753>>>>>>>>>>>>>>>>>  End_Procedure
86754>>>>>>>>>>>>>>>>>
86754>>>>>>>>>>>>>>>>>  Procedure RemoveSCIKeyBinding String sKey
86756>>>>>>>>>>>>>>>>>    Integer iModKeys
86756>>>>>>>>>>>>>>>>>    Integer iKey
86756>>>>>>>>>>>>>>>>>    String  sKeyDefine
86756>>>>>>>>>>>>>>>>>    //
86756>>>>>>>>>>>>>>>>>    Move 0 To iModKeys
86757>>>>>>>>>>>>>>>>>    Move sKey To sKeyDefine
86758>>>>>>>>>>>>>>>>>    Move (Replaces(" ",sKey,"")) To sKey // in Sci we can have "Ctrl + F" so get rid of the space characters
86759>>>>>>>>>>>>>>>>>    Move (Uppercase(sKey)) To sKey
86760>>>>>>>>>>>>>>>>>    If (pos("CTRL+",sKey)<>0) Begin
86762>>>>>>>>>>>>>>>>>      Move (iModKeys iOr SCMOD_CTRL)   To iModKeys
86763>>>>>>>>>>>>>>>>>      Move (Replace("CTRL+",sKey,""))  To sKey
86764>>>>>>>>>>>>>>>>>    End
86764>>>>>>>>>>>>>>>>>>
86764>>>>>>>>>>>>>>>>>    If (Pos("ALT+",sKey)<>0) Begin
86766>>>>>>>>>>>>>>>>>      Move (iModKeys iOr SCMOD_ALT)    To iModKeys
86767>>>>>>>>>>>>>>>>>      Move (Replace("ALT+",sKey,""))   To sKey
86768>>>>>>>>>>>>>>>>>    End
86768>>>>>>>>>>>>>>>>>>
86768>>>>>>>>>>>>>>>>>    If (Pos("SHIFT+",sKey)<>0) Begin
86770>>>>>>>>>>>>>>>>>      Move (iModKeys iOr SCMOD_SHIFT)  To iModKeys
86771>>>>>>>>>>>>>>>>>      Move (Replace("SHIFT+",sKey,"")) To sKey
86772>>>>>>>>>>>>>>>>>    End
86772>>>>>>>>>>>>>>>>>>
86772>>>>>>>>>>>>>>>>>    If (Length(sKey)=1) Begin
86774>>>>>>>>>>>>>>>>>      Move (Ascii(sKey)) To iKey
86775>>>>>>>>>>>>>>>>>    End
86775>>>>>>>>>>>>>>>>>>
86775>>>>>>>>>>>>>>>>>    Else Begin
86776>>>>>>>>>>>>>>>>>      Case Begin  // It isn't clear to me if SCI uses VK_xxx keys, but it seems so
86776>>>>>>>>>>>>>>>>>        Case (sKey="F1")
86778>>>>>>>>>>>>>>>>>          Move VK_F1 To iKey
86779>>>>>>>>>>>>>>>>>          Case break
86780>>>>>>>>>>>>>>>>>        Case (sKey="F2")
86783>>>>>>>>>>>>>>>>>          Move VK_F2 To iKey
86784>>>>>>>>>>>>>>>>>          Case break
86785>>>>>>>>>>>>>>>>>        Case (sKey="F3")
86788>>>>>>>>>>>>>>>>>          Move VK_F3 To iKey
86789>>>>>>>>>>>>>>>>>          Case break
86790>>>>>>>>>>>>>>>>>        Case (sKey="F4")
86793>>>>>>>>>>>>>>>>>          Move VK_F4 To iKey
86794>>>>>>>>>>>>>>>>>          Case break
86795>>>>>>>>>>>>>>>>>        Case (sKey="F5")
86798>>>>>>>>>>>>>>>>>          Move VK_F5 To iKey
86799>>>>>>>>>>>>>>>>>          Case break
86800>>>>>>>>>>>>>>>>>        Case (sKey="F6")
86803>>>>>>>>>>>>>>>>>          Move VK_F6 To iKey
86804>>>>>>>>>>>>>>>>>          Case break
86805>>>>>>>>>>>>>>>>>        Case (sKey="F7")
86808>>>>>>>>>>>>>>>>>          Move VK_F7 To iKey
86809>>>>>>>>>>>>>>>>>          Case break
86810>>>>>>>>>>>>>>>>>        Case (sKey="F8")
86813>>>>>>>>>>>>>>>>>          Move VK_F8 To iKey
86814>>>>>>>>>>>>>>>>>          Case break
86815>>>>>>>>>>>>>>>>>        Case (sKey="F9")
86818>>>>>>>>>>>>>>>>>          Move VK_F9 To iKey
86819>>>>>>>>>>>>>>>>>          Case break
86820>>>>>>>>>>>>>>>>>        Case (sKey="F10")
86823>>>>>>>>>>>>>>>>>          Move VK_F10 To iKey
86824>>>>>>>>>>>>>>>>>          Case break
86825>>>>>>>>>>>>>>>>>        Case (sKey="F11")
86828>>>>>>>>>>>>>>>>>          Move VK_F11 To iKey
86829>>>>>>>>>>>>>>>>>          Case break
86830>>>>>>>>>>>>>>>>>        Case (sKey="F12")
86833>>>>>>>>>>>>>>>>>          Move VK_F12 To iKey
86834>>>>>>>>>>>>>>>>>          Case break
86835>>>>>>>>>>>>>>>>>        Case (sKey="ENTER")
86838>>>>>>>>>>>>>>>>>          Move SCK_RETURN To iKey
86839>>>>>>>>>>>>>>>>>        Case (sKey="DOWN")
86842>>>>>>>>>>>>>>>>>          Move SCK_DOWN To iKey
86843>>>>>>>>>>>>>>>>>        Case (sKey="UP")
86846>>>>>>>>>>>>>>>>>          Move SCK_UP To iKey
86847>>>>>>>>>>>>>>>>>      Case End
86847>>>>>>>>>>>>>>>>>    End
86847>>>>>>>>>>>>>>>>>>
86847>>>>>>>>>>>>>>>>>    If (iKey<>0) Begin
86849>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_CLEARCMDKEY ((65536*(iModKeys))+iKey)
86850>>>>>>>>>>>>>>>>>    End
86850>>>>>>>>>>>>>>>>>>
86850>>>>>>>>>>>>>>>>>    Else Begin
86851>>>>>>>>>>>>>>>>>      Send none
86852>>>>>>>>>>>>>>>>>      // might be handy for debugging, or just annoying :) so use send none instead
86852>>>>>>>>>>>>>>>>>      //Send Info_Box ("Scintilla unknown key to clear "+sKeyDefine)
86852>>>>>>>>>>>>>>>>>    End
86852>>>>>>>>>>>>>>>>>>
86852>>>>>>>>>>>>>>>>>  End_Procedure
86853>>>>>>>>>>>>>>>>>
86853>>>>>>>>>>>>>>>>>  Procedure ClearRegisteredKeyBindings
86855>>>>>>>>>>>>>>>>>    Integer iKey
86855>>>>>>>>>>>>>>>>>    Integer iCount
86855>>>>>>>>>>>>>>>>>    String[] KeyBindings
86856>>>>>>>>>>>>>>>>>
86856>>>>>>>>>>>>>>>>>    Get psClearKeyBindings to KeyBindings
86857>>>>>>>>>>>>>>>>>    Move (SizeOfArray(KeyBindings)) To iCount
86858>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
86860>>>>>>>>>>>>>>>>>      For iKey from 0 to (iCount-1)
86866>>>>>>>>>>>>>>>>>>
86866>>>>>>>>>>>>>>>>>        Send RemoveSCIKeyBinding KeyBindings[iKey]
86867>>>>>>>>>>>>>>>>>      Loop
86868>>>>>>>>>>>>>>>>>>
86868>>>>>>>>>>>>>>>>>      //Send EditorMessage SCI_CLEARALLCMDKEYS
86868>>>>>>>>>>>>>>>>>    End
86868>>>>>>>>>>>>>>>>>>
86868>>>>>>>>>>>>>>>>>    // each scintilla window can run this 1 time only
86868>>>>>>>>>>>>>>>>>    Move (ResizeArray(KeyBindings,0)) To KeyBindings
86869>>>>>>>>>>>>>>>>>    Set psClearKeyBindings to KeyBindings
86870>>>>>>>>>>>>>>>>>  End_Procedure
86871>>>>>>>>>>>>>>>>>  // Is sent when the end of the files was reached.
86871>>>>>>>>>>>>>>>>>  Procedure onFindWrapping
86873>>>>>>>>>>>>>>>>>  End_Procedure
86874>>>>>>>>>>>>>>>>>
86874>>>>>>>>>>>>>>>>>  Procedure DoFindWrapping
86876>>>>>>>>>>>>>>>>>    Integer iRet
86876>>>>>>>>>>>>>>>>>    Move False To Found // Sets the std. Found Indicator.
86877>>>>>>>>>>>>>>>>>    Get Msg_onFindWrapping    to iRet
86878>>>>>>>>>>>>>>>>>    If iRet Begin
86880>>>>>>>>>>>>>>>>>      Procedure_Return iRet
86881>>>>>>>>>>>>>>>>>    End
86881>>>>>>>>>>>>>>>>>>
86881>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrap Begin
86883>>>>>>>>>>>>>>>>>      Procedure_Return 1
86884>>>>>>>>>>>>>>>>>    End
86884>>>>>>>>>>>>>>>>>>
86884>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrapMsg Begin
86886>>>>>>>>>>>>>>>>>      If (Window_Handle(Self)) Eq (GetFocus()) Begin
86888>>>>>>>>>>>>>>>>>        Send Info_Box "Not Found."                  // Not so pretty but prevents object from loosing the focus.
86889>>>>>>>>>>>>>>>>>      End
86889>>>>>>>>>>>>>>>>>>
86889>>>>>>>>>>>>>>>>>      Procedure_Return 1
86890>>>>>>>>>>>>>>>>>    End
86890>>>>>>>>>>>>>>>>>>
86890>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_WrapSilent Begin
86892>>>>>>>>>>>>>>>>>      Procedure_Return 0
86893>>>>>>>>>>>>>>>>>    End
86893>>>>>>>>>>>>>>>>>>
86893>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_WrapAsk Begin
86895>>>>>>>>>>>>>>>>>      Get YesNo_Box "End of file reached restart from the beginning?"     to iRet
86896>>>>>>>>>>>>>>>>>      If iRet Eq MBR_Yes ;        Procedure_Return 0
86899>>>>>>>>>>>>>>>>>      Else ;        Procedure_Return 1
86901>>>>>>>>>>>>>>>>>    End
86901>>>>>>>>>>>>>>>>>>
86901>>>>>>>>>>>>>>>>>  End_Procedure
86902>>>>>>>>>>>>>>>>>
86902>>>>>>>>>>>>>>>>>  // Should be overwrited, returns True if Ok or false if failed
86902>>>>>>>>>>>>>>>>>  Function CM_InitCodeList Handle hCodeList Returns Integer
86904>>>>>>>>>>>>>>>>>    Function_Return 0
86905>>>>>>>>>>>>>>>>>  End_Function
86906>>>>>>>>>>>>>>>>>  // This procedure should Set codetip text etc...
86906>>>>>>>>>>>>>>>>>  Procedure OnCodeTip
86908>>>>>>>>>>>>>>>>>  End_Procedure
86909>>>>>>>>>>>>>>>>>  Procedure OnCodeTipInitialize
86911>>>>>>>>>>>>>>>>>  End_Procedure
86912>>>>>>>>>>>>>>>>>  Procedure OnCodeTipUpdate
86914>>>>>>>>>>>>>>>>>  End_Procedure
86915>>>>>>>>>>>>>>>>>  Procedure OnCodeTipCancel
86917>>>>>>>>>>>>>>>>>  End_Procedure
86918>>>>>>>>>>>>>>>>>  Function DoCodeListInit Handle hCodeList Returns Integer
86920>>>>>>>>>>>>>>>>>    Function_Return 0
86921>>>>>>>>>>>>>>>>>  End_Function
86922>>>>>>>>>>>>>>>>>  Procedure CM_CodeListItemSelected String sItem Integer iRefVal
86924>>>>>>>>>>>>>>>>>  End_Procedure
86925>>>>>>>>>>>>>>>>>
86925>>>>>>>>>>>>>>>>>  Function LoadAutoCompleteImage String sBitmap Integer iType Returns Boolean
86927>>>>>>>>>>>>>>>>>    Boolean bOK
86927>>>>>>>>>>>>>>>>>    Pointer pImage
86927>>>>>>>>>>>>>>>>>    UInteger uSize uWidth uHeight
86927>>>>>>>>>>>>>>>>>    UInteger iErr iVoid
86927>>>>>>>>>>>>>>>>>    String  sFileName
86927>>>>>>>>>>>>>>>>>    String  sError
86927>>>>>>>>>>>>>>>>>
86927>>>>>>>>>>>>>>>>>    Move False to bOK
86928>>>>>>>>>>>>>>>>>    Move (sBitmap+Character(0)) To sFileName
86929>>>>>>>>>>>>>>>>>    Move 0 To uWidth
86930>>>>>>>>>>>>>>>>>    Move 0 To uHeight
86931>>>>>>>>>>>>>>>>>    Move 0 To uSize
86932>>>>>>>>>>>>>>>>>    Move 0 To pImage
86933>>>>>>>>>>>>>>>>>    //Move (SciLoadPngAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight),AddressOf(uSize))) To iErr
86933>>>>>>>>>>>>>>>>>    Move (SciLoadImageAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight))) To iErr
86934>>>>>>>>>>>>>>>>>    If (iErr=0) Begin
86936>>>>>>>>>>>>>>>>>      //Send Info_Box ("Image Width= "+Trim(uWidth)+" Height= "+Trim(uHeight)+" Size = "+Trim(uSize))
86936>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_RGBAIMAGESETWIDTH  uWidth
86937>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_RGBAIMAGESETHEIGHT uHeight
86938>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_REGISTERRGBAIMAGE  iType pImage
86939>>>>>>>>>>>>>>>>>      Move (SciFreeRGBAImage(pImage)) To iVoid
86940>>>>>>>>>>>>>>>>>      Move True to bOK
86941>>>>>>>>>>>>>>>>>    End
86941>>>>>>>>>>>>>>>>>>
86941>>>>>>>>>>>>>>>>>    Else Begin
86942>>>>>>>>>>>>>>>>>      Get SciLoadImageErrorText iErr to sError
86943>>>>>>>>>>>>>>>>>      Send Info_Box (sError+"\nImage: "+sFileName+"\nNote that only uncompressed 24 bits and 32 bits bmp files are supported.") "Error loading CodeList image"
86944>>>>>>>>>>>>>>>>>    End
86944>>>>>>>>>>>>>>>>>>
86944>>>>>>>>>>>>>>>>>
86944>>>>>>>>>>>>>>>>>    Function_Return bOK
86945>>>>>>>>>>>>>>>>>  End_Function
86946>>>>>>>>>>>>>>>>>
86946>>>>>>>>>>>>>>>>>  //
86946>>>>>>>>>>>>>>>>>  // Scintilla calls the codelist feature autocomplete.
86946>>>>>>>>>>>>>>>>>  // When this is called the array phoCodelistHandler has our list that we want to display
86946>>>>>>>>>>>>>>>>>  // sWord is the word to select on
86946>>>>>>>>>>>>>>>>>  //
86946>>>>>>>>>>>>>>>>>  Procedure ShowAutoComplete String sWord
86948>>>>>>>>>>>>>>>>>    Boolean bAutoCompleteActive
86948>>>>>>>>>>>>>>>>>    Boolean bHasBmp
86948>>>>>>>>>>>>>>>>>    Handle  hoArray
86948>>>>>>>>>>>>>>>>>    Integer iChar
86948>>>>>>>>>>>>>>>>>    Integer iItem
86948>>>>>>>>>>>>>>>>>    Integer iCount
86948>>>>>>>>>>>>>>>>>    String  sItem
86948>>>>>>>>>>>>>>>>>    String  sBitmap
86948>>>>>>>>>>>>>>>>>    String  sList
86948>>>>>>>>>>>>>>>>>    String  sSelect
86948>>>>>>>>>>>>>>>>>
86948>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_AUTOCACTIVE to bAutoCompleteActive  // doesn't work already gone before recursion
86948>>>>>>>>>>>>>>>>>    Get pbIsCodelistActive to bAutoCompleteActive
86949>>>>>>>>>>>>>>>>>    If (bAutoCompleteActive=False) Begin
86951>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_AUTOCSETIGNORECASE True
86952>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE
86953>>>>>>>>>>>>>>>>>      //Send EditorMessage SCI_AUTOCSETORDER SC_ORDER_PERFORMSORT // we sort on our end as we need to know the item number
86953>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_AUTOCSETSEPARATOR (Ascii("|"))
86954>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_CLEARREGISTEREDIMAGES
86955>>>>>>>>>>>>>>>>>      Move "" To sList
86956>>>>>>>>>>>>>>>>>      Get phoCodelistHandler to hoArray
86957>>>>>>>>>>>>>>>>>      Send SortAscending of hoArray  // Our list MUST be ascending order or the autocomplete won't work!
86958>>>>>>>>>>>>>>>>>      Get Codelist_Item_Count of hoArray to iCount
86959>>>>>>>>>>>>>>>>>      If (iCount>0) Begin
86961>>>>>>>>>>>>>>>>>        For iItem from 0 To (iCount-1)
86967>>>>>>>>>>>>>>>>>>
86967>>>>>>>>>>>>>>>>>          Get Codelist_value  of hoArray Item iItem To sItem
86968>>>>>>>>>>>>>>>>>          Get Codelist_bitmap of hoArray item iItem to sBitmap
86969>>>>>>>>>>>>>>>>>          Move False to bHasBmp
86970>>>>>>>>>>>>>>>>>          If (sBitmap<>"") Begin  // bitmap exists and found
86972>>>>>>>>>>>>>>>>>            Get LoadAutoCompleteImage sBitmap (iItem+1) to bHasBmp
86973>>>>>>>>>>>>>>>>>          End
86973>>>>>>>>>>>>>>>>>>
86973>>>>>>>>>>>>>>>>>          If (bHasBmp) Begin
86975>>>>>>>>>>>>>>>>>            Move (sList+sItem+"?"+Trim(iItem+1)) To sList
86976>>>>>>>>>>>>>>>>>          End
86976>>>>>>>>>>>>>>>>>>
86976>>>>>>>>>>>>>>>>>          Else Begin
86977>>>>>>>>>>>>>>>>>            Move (sList+sItem) to sList
86978>>>>>>>>>>>>>>>>>          End
86978>>>>>>>>>>>>>>>>>>
86978>>>>>>>>>>>>>>>>>          If (iItem<(iCount-1)) Begin // separator character is pipe symbol, add everywhere except on last
86980>>>>>>>>>>>>>>>>>            Move (sList+"|") To sList
86981>>>>>>>>>>>>>>>>>          End
86981>>>>>>>>>>>>>>>>>>
86981>>>>>>>>>>>>>>>>>        Loop
86982>>>>>>>>>>>>>>>>>>
86982>>>>>>>>>>>>>>>>>        Move (Length(sWord)) To iChar
86983>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_AUTOCSHOW iChar (AddressOf(sList))
86984>>>>>>>>>>>>>>>>>        Move (String(sWord)+Character(0)) To sSelect
86985>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_AUTOCSELECT 0 (AddressOf(sSelect))
86986>>>>>>>>>>>>>>>>>      End
86986>>>>>>>>>>>>>>>>>>
86986>>>>>>>>>>>>>>>>>    End
86986>>>>>>>>>>>>>>>>>>
86986>>>>>>>>>>>>>>>>>  End_Procedure
86987>>>>>>>>>>>>>>>>>
86987>>>>>>>>>>>>>>>>>  //
86987>>>>>>>>>>>>>>>>>  // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter
86987>>>>>>>>>>>>>>>>>  // counting and doesn't look nice in presenting in tooltip et al.
86987>>>>>>>>>>>>>>>>>  // We reduce the spaces here to just one.
86987>>>>>>>>>>>>>>>>>  //
86987>>>>>>>>>>>>>>>>>  Procedure StripConcatenatingSpaces String ByRef sText
86989>>>>>>>>>>>>>>>>>    While (Pos("  ",sText)<>0)
86993>>>>>>>>>>>>>>>>>      Move (Replaces("  ",sText," ")) To sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
86994>>>>>>>>>>>>>>>>>    Loop
86995>>>>>>>>>>>>>>>>>>
86995>>>>>>>>>>>>>>>>>  End_Procedure
86996>>>>>>>>>>>>>>>>>
86996>>>>>>>>>>>>>>>>>  //
86996>>>>>>>>>>>>>>>>>  // Takes care of the argument highlighting
86996>>>>>>>>>>>>>>>>>  //
86996>>>>>>>>>>>>>>>>>  Procedure CodetipParameterHighLight
86998>>>>>>>>>>>>>>>>>    Integer iType
86998>>>>>>>>>>>>>>>>>    Integer iPos
86998>>>>>>>>>>>>>>>>>    Integer iLastPos
86998>>>>>>>>>>>>>>>>>    Integer iArg
86998>>>>>>>>>>>>>>>>>    Integer iSelectedArg
86998>>>>>>>>>>>>>>>>>    Integer iHighlightStart
86998>>>>>>>>>>>>>>>>>    Integer iHighlightEnd
86998>>>>>>>>>>>>>>>>>    String  sTip
86998>>>>>>>>>>>>>>>>>
86998>>>>>>>>>>>>>>>>>    Move 0 To iHighLightStart
86999>>>>>>>>>>>>>>>>>    Move 0 To iHighLightEnd
87000>>>>>>>>>>>>>>>>>    Get psCodeTipCurrent to sTip
87001>>>>>>>>>>>>>>>>>    If (sTip<>"") Begin
87003>>>>>>>>>>>>>>>>>      Move (Pos(Character(10),sTip)) To iPos
87004>>>>>>>>>>>>>>>>>      If (iPos>0) Begin
87006>>>>>>>>>>>>>>>>>        Move (Left(sTip,iPos-1)) to sTip // first line has the expression/function/method, next line is the description
87007>>>>>>>>>>>>>>>>>      End
87007>>>>>>>>>>>>>>>>>>
87007>>>>>>>>>>>>>>>>>      Send StripConcatenatingSpaces (&sTip)        // no double spaces as it confuses the argument counting logic
87008>>>>>>>>>>>>>>>>>      Get piCodeTipArgument to iSelectedArg
87009>>>>>>>>>>>>>>>>>      Get piCodeTipType to iType
87010>>>>>>>>>>>>>>>>>      If (iType=C_TIPTYPE_EXPRESSION) Begin
87012>>>>>>>>>>>>>>>>>        Move (Pos("(",sTip)) To iPos // start first argument
87013>>>>>>>>>>>>>>>>>        Move 0 To iArg
87014>>>>>>>>>>>>>>>>>        While (iPos>0)
87018>>>>>>>>>>>>>>>>>
87018>>>>>>>>>>>>>>>>>          If (iSelectedArg=iArg) Begin
87020>>>>>>>>>>>>>>>>>            Move (iPos+1) to iHighLightStart
87021>>>>>>>>>>>>>>>>>          End
87021>>>>>>>>>>>>>>>>>>
87021>>>>>>>>>>>>>>>>>          Move (Pos(",",sTip,iPos+1)) To iPos
87022>>>>>>>>>>>>>>>>>          If (iHighLightStart<>0) Begin
87024>>>>>>>>>>>>>>>>>            If (iPos=0) Begin
87026>>>>>>>>>>>>>>>>>              Move (Pos(")",sTip,iHighlightStart)) to iPos
87027>>>>>>>>>>>>>>>>>            End
87027>>>>>>>>>>>>>>>>>>
87027>>>>>>>>>>>>>>>>>            If (iPos<>0) Begin
87029>>>>>>>>>>>>>>>>>              Move (iPos-1) To iHighLightEnd
87030>>>>>>>>>>>>>>>>>              Move 0 To iPos
87031>>>>>>>>>>>>>>>>>            End
87031>>>>>>>>>>>>>>>>>>
87031>>>>>>>>>>>>>>>>>          End
87031>>>>>>>>>>>>>>>>>>
87031>>>>>>>>>>>>>>>>>          Increment iArg
87032>>>>>>>>>>>>>>>>>          If (iArg>100) Begin
87034>>>>>>>>>>>>>>>>>            Move 0 to iPos // should not happen, but .. never loop and hang!
87035>>>>>>>>>>>>>>>>>          End
87035>>>>>>>>>>>>>>>>>>
87035>>>>>>>>>>>>>>>>>        Loop
87036>>>>>>>>>>>>>>>>>>
87036>>>>>>>>>>>>>>>>>        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
87038>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
87039>>>>>>>>>>>>>>>>>        End
87039>>>>>>>>>>>>>>>>>>
87039>>>>>>>>>>>>>>>>>        Else Begin
87040>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT 0 0
87041>>>>>>>>>>>>>>>>>        End
87041>>>>>>>>>>>>>>>>>>
87041>>>>>>>>>>>>>>>>>      End
87041>>>>>>>>>>>>>>>>>>
87041>>>>>>>>>>>>>>>>>      Else If (iType=C_TIPTYPE_FUNCTION) Begin
87044>>>>>>>>>>>>>>>>>        // function foo string sBar Integer iVoid Returns integer
87044>>>>>>>>>>>>>>>>>        // function foo string sBar Integer ByRef iVoid Returns integer
87044>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip)) To iPos // start function name
87045>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above function
87046>>>>>>>>>>>>>>>>>        Move 0 To iArg
87047>>>>>>>>>>>>>>>>>        While (iPos>0)
87051>>>>>>>>>>>>>>>>>
87051>>>>>>>>>>>>>>>>>          If (iSelectedArg=iArg) Begin
87053>>>>>>>>>>>>>>>>>            Move iPos to iHighLightStart
87054>>>>>>>>>>>>>>>>>          End
87054>>>>>>>>>>>>>>>>>>
87054>>>>>>>>>>>>>>>>>          Move (Pos(" ",sTip,iPos+1)) To iPos
87055>>>>>>>>>>>>>>>>>          Move iPos To iLastPos
87056>>>>>>>>>>>>>>>>>          If (iPos<>0) Begin
87058>>>>>>>>>>>>>>>>>            Move (Pos(" ",sTip,iPos+1)) To iPos
87059>>>>>>>>>>>>>>>>>            If (Mid(lowercase(sTip),iPos-(iLastPos+1),iLastPos+1)="byref") Begin
87061>>>>>>>>>>>>>>>>>              Move (Pos(" ",sTip,iPos+1)) To iPos
87062>>>>>>>>>>>>>>>>>            End
87062>>>>>>>>>>>>>>>>>>
87062>>>>>>>>>>>>>>>>>          End
87062>>>>>>>>>>>>>>>>>>
87062>>>>>>>>>>>>>>>>>          If (iHighLightStart<>0) Begin
87064>>>>>>>>>>>>>>>>>            If (iPos=0) Begin
87066>>>>>>>>>>>>>>>>>              Move (Length(sTip)+1) to iPos
87067>>>>>>>>>>>>>>>>>            End
87067>>>>>>>>>>>>>>>>>>
87067>>>>>>>>>>>>>>>>>            If (iPos<>0) Begin
87069>>>>>>>>>>>>>>>>>              Move (iPos-1) To iHighLightEnd
87070>>>>>>>>>>>>>>>>>              Move 0 To iPos
87071>>>>>>>>>>>>>>>>>            End
87071>>>>>>>>>>>>>>>>>>
87071>>>>>>>>>>>>>>>>>          End
87071>>>>>>>>>>>>>>>>>>
87071>>>>>>>>>>>>>>>>>          Increment iArg
87072>>>>>>>>>>>>>>>>>          If (iArg>100) Begin
87074>>>>>>>>>>>>>>>>>            Move 0 to iPos // should not happen, but .. never loop and hang!
87075>>>>>>>>>>>>>>>>>          End
87075>>>>>>>>>>>>>>>>>>
87075>>>>>>>>>>>>>>>>>        Loop
87076>>>>>>>>>>>>>>>>>>
87076>>>>>>>>>>>>>>>>>        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
87078>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
87079>>>>>>>>>>>>>>>>>        End
87079>>>>>>>>>>>>>>>>>>
87079>>>>>>>>>>>>>>>>>        Else Begin
87080>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT 0 0
87081>>>>>>>>>>>>>>>>>        End
87081>>>>>>>>>>>>>>>>>>
87081>>>>>>>>>>>>>>>>>      End
87081>>>>>>>>>>>>>>>>>>
87081>>>>>>>>>>>>>>>>>      Else If (iType=C_TIPTYPE_PROCEDURE) Begin
87084>>>>>>>>>>>>>>>>>        // procedure foo string sBar Integer iVoid Returns integer
87084>>>>>>>>>>>>>>>>>        // procedure foo string sBar Integer iVoid
87084>>>>>>>>>>>>>>>>>        // procedure foo string sBar Integer ByRef iVoid
87084>>>>>>>>>>>>>>>>>        // procedure set foo string sBar Integer iVoid
87084>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip)) To iPos // start procedure name or set
87085>>>>>>>>>>>>>>>>>        If (Mid(lowercase(sTip),3,iPos+1)="set") Begin
87087>>>>>>>>>>>>>>>>>          Move (Pos(" ",sTip,iPos+1)) To iPos // at start procedure name
87088>>>>>>>>>>>>>>>>>        End
87088>>>>>>>>>>>>>>>>>>
87088>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above method
87089>>>>>>>>>>>>>>>>>        Move 0 To iArg
87090>>>>>>>>>>>>>>>>>        While (iPos>0)
87094>>>>>>>>>>>>>>>>>
87094>>>>>>>>>>>>>>>>>          If (iSelectedArg=iArg) Begin
87096>>>>>>>>>>>>>>>>>            Move iPos to iHighLightStart
87097>>>>>>>>>>>>>>>>>          End
87097>>>>>>>>>>>>>>>>>>
87097>>>>>>>>>>>>>>>>>          Move (Pos(" ",sTip,iPos+1)) To iPos
87098>>>>>>>>>>>>>>>>>          Move iPos To iLastPos
87099>>>>>>>>>>>>>>>>>          If (iPos<>0) Begin
87101>>>>>>>>>>>>>>>>>            Move (Pos(" ",sTip,iPos+1)) To iPos
87102>>>>>>>>>>>>>>>>>            If (Mid(lowercase(sTip),iPos-(iLastPos+1),iLastPos+1)="byref") Begin
87104>>>>>>>>>>>>>>>>>              Move (Pos(" ",sTip,iPos+1)) To iPos
87105>>>>>>>>>>>>>>>>>            End
87105>>>>>>>>>>>>>>>>>>
87105>>>>>>>>>>>>>>>>>          End
87105>>>>>>>>>>>>>>>>>>
87105>>>>>>>>>>>>>>>>>          If (iHighLightStart<>0) Begin
87107>>>>>>>>>>>>>>>>>            If (iPos=0) Begin
87109>>>>>>>>>>>>>>>>>              Move (Length(sTip)+1) to iPos
87110>>>>>>>>>>>>>>>>>            End
87110>>>>>>>>>>>>>>>>>>
87110>>>>>>>>>>>>>>>>>            If (iPos<>0) Begin
87112>>>>>>>>>>>>>>>>>              Move (iPos-1) To iHighLightEnd
87113>>>>>>>>>>>>>>>>>              Move 0 To iPos
87114>>>>>>>>>>>>>>>>>            End
87114>>>>>>>>>>>>>>>>>>
87114>>>>>>>>>>>>>>>>>          End
87114>>>>>>>>>>>>>>>>>>
87114>>>>>>>>>>>>>>>>>          Increment iArg
87115>>>>>>>>>>>>>>>>>          If (iArg>100) Begin
87117>>>>>>>>>>>>>>>>>            Move 0 to iPos // should not happen, but .. never loop and hang!
87118>>>>>>>>>>>>>>>>>          End
87118>>>>>>>>>>>>>>>>>>
87118>>>>>>>>>>>>>>>>>        Loop
87119>>>>>>>>>>>>>>>>>>
87119>>>>>>>>>>>>>>>>>        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
87121>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
87122>>>>>>>>>>>>>>>>>        End
87122>>>>>>>>>>>>>>>>>>
87122>>>>>>>>>>>>>>>>>        Else Begin
87123>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT 0 0
87124>>>>>>>>>>>>>>>>>        End
87124>>>>>>>>>>>>>>>>>>
87124>>>>>>>>>>>>>>>>>      End
87124>>>>>>>>>>>>>>>>>>
87124>>>>>>>>>>>>>>>>>    End
87124>>>>>>>>>>>>>>>>>>
87124>>>>>>>>>>>>>>>>>  End_Procedure
87125>>>>>>>>>>>>>>>>>
87125>>>>>>>>>>>>>>>>>  // Codetip requested: return the type of Codetip to display or CM_TIPSTYLE_NONE to not displaying a codetip
87125>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87125>>>>>>>>>>>>>>>>>  Procedure DoCodeTip
87127>>>>>>>>>>>>>>>>>    Boolean bCallTipActive
87127>>>>>>>>>>>>>>>>>    Integer iOk
87127>>>>>>>>>>>>>>>>>    Integer iPos
87127>>>>>>>>>>>>>>>>>    Integer iChar
87127>>>>>>>>>>>>>>>>>    String  sTip
87127>>>>>>>>>>>>>>>>>
87127>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CALLTIPACTIVE to bCallTipActive // calltip active on screen
87128>>>>>>>>>>>>>>>>>    If (bCallTipActive) Begin
87130>>>>>>>>>>>>>>>>>      If (piCodeTipType(Self)=C_TIPTYPE_EXPRESSION) Begin
87132>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETCURRENTPOS to iPos
87133>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETCHARAT (iPos-1) to iChar
87134>>>>>>>>>>>>>>>>>        If (iChar=Ascii(")")) Begin
87136>>>>>>>>>>>>>>>>>          Send DoCodeTipCancel
87137>>>>>>>>>>>>>>>>>        End
87137>>>>>>>>>>>>>>>>>>
87137>>>>>>>>>>>>>>>>>        Else Begin
87138>>>>>>>>>>>>>>>>>          Send DoCodeTipUpdate
87139>>>>>>>>>>>>>>>>>        End
87139>>>>>>>>>>>>>>>>>>
87139>>>>>>>>>>>>>>>>>      End
87139>>>>>>>>>>>>>>>>>>
87139>>>>>>>>>>>>>>>>>      Else Begin
87140>>>>>>>>>>>>>>>>>        Send DoCodeTipUpdate
87141>>>>>>>>>>>>>>>>>      End
87141>>>>>>>>>>>>>>>>>>
87141>>>>>>>>>>>>>>>>>    End
87141>>>>>>>>>>>>>>>>>>
87141>>>>>>>>>>>>>>>>>    Else Begin
87142>>>>>>>>>>>>>>>>>
87142>>>>>>>>>>>>>>>>>      Get msg_OnCodeTip to iOk
87143>>>>>>>>>>>>>>>>>      If (iOk) Begin
87145>>>>>>>>>>>>>>>>>        Get psCodeTipCurrent to sTip
87146>>>>>>>>>>>>>>>>>        If (sTip<>"") Begin
87148>>>>>>>>>>>>>>>>>          Send StripConcatenatingSpaces (&sTip)   // no gap of more than one space
87149>>>>>>>>>>>>>>>>>          Move (Replaces("//",sTip,"\n")) To sTip // display description on a new line
87150>>>>>>>>>>>>>>>>>          Move (Replaces("\n",sTip,Character(10))) To sTip
87151>>>>>>>>>>>>>>>>>          Move (sTip+"  ") To sTip // HACK to make the tip a tiny bit wider at the end, so that the bold argument does not cut anything off at the end.
87152>>>>>>>>>>>>>>>>>          // Cannot calc afterwards as dynamic bolding is done on existing tooltip.
87152>>>>>>>>>>>>>>>>>          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
87153>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
87154>>>>>>>>>>>>>>>>>        End
87154>>>>>>>>>>>>>>>>>>
87154>>>>>>>>>>>>>>>>>      End
87154>>>>>>>>>>>>>>>>>>
87154>>>>>>>>>>>>>>>>>    End
87154>>>>>>>>>>>>>>>>>>
87154>>>>>>>>>>>>>>>>>  End_Procedure
87155>>>>>>>>>>>>>>>>>  // Codetip is to be displayed: return TRUE if changes applied to the codetip structure or FALSE if not
87155>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87155>>>>>>>>>>>>>>>>>  Procedure DoCodeTipInitialize   Integer lParam
87157>>>>>>>>>>>>>>>>>    Integer iOk
87157>>>>>>>>>>>>>>>>>    Get msg_OnCodeTipInitialize to iOk
87158>>>>>>>>>>>>>>>>>    If (iOk) Begin
87160>>>>>>>>>>>>>>>>>      Send CodetipParameterHighLight
87161>>>>>>>>>>>>>>>>>      Procedure_Return 1
87162>>>>>>>>>>>>>>>>>    End
87162>>>>>>>>>>>>>>>>>>
87162>>>>>>>>>>>>>>>>>    Procedure_Return 0
87163>>>>>>>>>>>>>>>>>  End_Procedure
87164>>>>>>>>>>>>>>>>>
87164>>>>>>>>>>>>>>>>>  // Reset CodeTip Properties
87164>>>>>>>>>>>>>>>>>  Procedure CodeTipReset
87166>>>>>>>>>>>>>>>>>    Set piCodeTipHighlightedStart  to -1
87167>>>>>>>>>>>>>>>>>    Set piCodeTipHighlightedEnd    to -1
87168>>>>>>>>>>>>>>>>>    Set piCodeTipArgument          to -1
87169>>>>>>>>>>>>>>>>>    //
87169>>>>>>>>>>>>>>>>>    Set psCodeTipCurrent           to ""
87170>>>>>>>>>>>>>>>>>    Set piCodeTipCurrLine          to -1
87171>>>>>>>>>>>>>>>>>  End_Procedure
87172>>>>>>>>>>>>>>>>>
87172>>>>>>>>>>>>>>>>>  // Codetip is to be removed: return FALSE if the codetip should be removed or TRUE if to codetip should remain visible
87172>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87172>>>>>>>>>>>>>>>>>  Procedure DoCodeTipCancel
87174>>>>>>>>>>>>>>>>>    Integer iOk
87174>>>>>>>>>>>>>>>>>    //
87174>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPCANCEL
87175>>>>>>>>>>>>>>>>>    // Reset CodeTip Properties
87175>>>>>>>>>>>>>>>>>    Send CodeTipReset
87176>>>>>>>>>>>>>>>>>    Get msg_OnCodeTipCancel to iOk
87177>>>>>>>>>>>>>>>>>    Procedure_Return iOk
87178>>>>>>>>>>>>>>>>>  End_Procedure
87179>>>>>>>>>>>>>>>>>  // Codetip is to be updated (position, values...): return TRUE if changes applied to the codetip structure or FALSE if not
87179>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87179>>>>>>>>>>>>>>>>>  Procedure DoCodeTipUpdate
87181>>>>>>>>>>>>>>>>>    Integer iOk
87181>>>>>>>>>>>>>>>>>    Get msg_OnCodeTipUpdate to iOk
87182>>>>>>>>>>>>>>>>>    If (iOk) Begin
87184>>>>>>>>>>>>>>>>>      Send CodetipParameterHighLight
87185>>>>>>>>>>>>>>>>>      Procedure_Return 1
87186>>>>>>>>>>>>>>>>>    End
87186>>>>>>>>>>>>>>>>>>
87186>>>>>>>>>>>>>>>>>    Procedure_Return 0
87187>>>>>>>>>>>>>>>>>  End_Procedure
87188>>>>>>>>>>>>>>>>>
87188>>>>>>>>>>>>>>>>>  Procedure RestoreTipBeforeAutoComplete
87190>>>>>>>>>>>>>>>>>    Boolean bCallTipActive
87190>>>>>>>>>>>>>>>>>    Integer iPos
87190>>>>>>>>>>>>>>>>>    String  sTip
87190>>>>>>>>>>>>>>>>>
87190>>>>>>>>>>>>>>>>>    If (pbHadTipBeforeAutocomplete(Self)) Begin
87192>>>>>>>>>>>>>>>>>      Set pbCodetipRequest to True
87193>>>>>>>>>>>>>>>>>      Set pbHadTipBeforeAutocomplete to False
87194>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_CALLTIPACTIVE To bCallTipActive
87195>>>>>>>>>>>>>>>>>      If (bCallTipActive=False) Begin
87197>>>>>>>>>>>>>>>>>        // We first need to put the tooltip back up on the screen again
87197>>>>>>>>>>>>>>>>>        Get psCodeTipCurrent to sTip
87198>>>>>>>>>>>>>>>>>        If (sTip<>"") Begin
87200>>>>>>>>>>>>>>>>>          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
87201>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
87202>>>>>>>>>>>>>>>>>        End
87202>>>>>>>>>>>>>>>>>>
87202>>>>>>>>>>>>>>>>>      End
87202>>>>>>>>>>>>>>>>>>
87202>>>>>>>>>>>>>>>>>      Send CodetipParameterHighLight
87203>>>>>>>>>>>>>>>>>    End
87203>>>>>>>>>>>>>>>>>>
87203>>>>>>>>>>>>>>>>>  End_Procedure
87204>>>>>>>>>>>>>>>>>
87204>>>>>>>>>>>>>>>>>  // Remove the codelist window
87204>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87204>>>>>>>>>>>>>>>>>  Procedure CancelCodelist
87206>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_AUTOCCANCEL
87207>>>>>>>>>>>>>>>>>    Send RestoreTipBeforeAutoComplete
87208>>>>>>>>>>>>>>>>>  End_Procedure
87209>>>>>>>>>>>>>>>>>
87209>>>>>>>>>>>>>>>>>  // Remove the codetip window
87209>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87209>>>>>>>>>>>>>>>>>  Procedure CancelCodetip
87211>>>>>>>>>>>>>>>>>    Set pbCodeTipRequest  To False
87212>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPCANCEL
87213>>>>>>>>>>>>>>>>>  End_Procedure
87214>>>>>>>>>>>>>>>>>
87214>>>>>>>>>>>>>>>>>  Procedure Request_Cancel
87216>>>>>>>>>>>>>>>>>    Boolean bCodeListActive
87216>>>>>>>>>>>>>>>>>
87216>>>>>>>>>>>>>>>>>    Get pbIsCodelistActive to bCodeListActive
87217>>>>>>>>>>>>>>>>>    If (bCodeListActive) Begin
87219>>>>>>>>>>>>>>>>>      Send CancelCodeList
87220>>>>>>>>>>>>>>>>>      Send DoCodeListCancel
87221>>>>>>>>>>>>>>>>>    End
87221>>>>>>>>>>>>>>>>>>
87221>>>>>>>>>>>>>>>>>  End_Procedure
87222>>>>>>>>>>>>>>>>>
87222>>>>>>>>>>>>>>>>>  // BP CodeList Support
87222>>>>>>>>>>>>>>>>>  // DoCodeList: Notification that a Codelist is requested
87222>>>>>>>>>>>>>>>>>  // Connect the VDF-Codelist Object to the delivered codelist handle, adjust some features
87222>>>>>>>>>>>>>>>>>  // and fill in the requested lines.
87222>>>>>>>>>>>>>>>>>  Procedure DoCodeList            Integer lParam
87224>>>>>>>>>>>>>>>>>    Integer iRet
87224>>>>>>>>>>>>>>>>>    Handle hCodeList
87224>>>>>>>>>>>>>>>>>
87224>>>>>>>>>>>>>>>>>    If (not(phoCodeListHandler(Self))) Begin
87226>>>>>>>>>>>>>>>>>      Procedure_Return False
87227>>>>>>>>>>>>>>>>>    End
87227>>>>>>>>>>>>>>>>>>
87227>>>>>>>>>>>>>>>>>
87227>>>>>>>>>>>>>>>>>    Move 0 To hCodeList
87228>>>>>>>>>>>>>>>>>    Get DoCodeListInit hCodeList to iRet
87229>>>>>>>>>>>>>>>>>    If (iRet) Begin
87231>>>>>>>>>>>>>>>>>      Procedure_Return True
87232>>>>>>>>>>>>>>>>>    End
87232>>>>>>>>>>>>>>>>>>
87232>>>>>>>>>>>>>>>>>    Procedure_Return False
87233>>>>>>>>>>>>>>>>>  End_Procedure
87234>>>>>>>>>>>>>>>>>
87234>>>>>>>>>>>>>>>>>  Procedure OnCodelistCancel
87236>>>>>>>>>>>>>>>>>  End_Procedure
87237>>>>>>>>>>>>>>>>>
87237>>>>>>>>>>>>>>>>>  // DoCodelistCancel
87237>>>>>>>>>>>>>>>>>  // Notification that the listview was canceled without selecting a value
87237>>>>>>>>>>>>>>>>>  Procedure DoCodeListCancel
87239>>>>>>>>>>>>>>>>>    Send OnCodelistCancel
87240>>>>>>>>>>>>>>>>>    Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
87241>>>>>>>>>>>>>>>>>    Set pbIsCodelistActive To False
87242>>>>>>>>>>>>>>>>>    Procedure_Return False // return FALSE to remove the listview from screen
87243>>>>>>>>>>>>>>>>>  End_Procedure
87244>>>>>>>>>>>>>>>>>
87244>>>>>>>>>>>>>>>>>
87244>>>>>>>>>>>>>>>>>  // DoCodelistSelMade
87244>>>>>>>>>>>>>>>>>  // Notification that a item was selected within the listview
87244>>>>>>>>>>>>>>>>>  // Originally called DoCodelistSelMade, renamed as we have different parameters
87244>>>>>>>>>>>>>>>>>  Procedure DoAutoCompleteSelection Address aText
87246>>>>>>>>>>>>>>>>>    String sItem sText
87246>>>>>>>>>>>>>>>>>    Integer iRet iItem iRefVal iRetVal
87246>>>>>>>>>>>>>>>>>
87246>>>>>>>>>>>>>>>>>    If (not(phoCodeListHandler(Self))) Begin
87248>>>>>>>>>>>>>>>>>      Procedure_Return False
87249>>>>>>>>>>>>>>>>>    End
87249>>>>>>>>>>>>>>>>>>
87249>>>>>>>>>>>>>>>>>
87249>>>>>>>>>>>>>>>>>    If (aText<>0) Begin
87251>>>>>>>>>>>>>>>>>      Move aText To sText
87252>>>>>>>>>>>>>>>>>    End
87252>>>>>>>>>>>>>>>>>>
87252>>>>>>>>>>>>>>>>>    Else Begin
87253>>>>>>>>>>>>>>>>>      Move "" to sText
87254>>>>>>>>>>>>>>>>>    End
87254>>>>>>>>>>>>>>>>>>
87254>>>>>>>>>>>>>>>>>    If (sText<>"") Begin
87256>>>>>>>>>>>>>>>>>      Send CancelCodelist // we handle insertion of the value by ourself
87257>>>>>>>>>>>>>>>>>      Move sText to sItem // we still need the iRefVal as it is a helper variable for finding the relevant parts
87258>>>>>>>>>>>>>>>>>      Get Codelist_find_item of (phoCodeListHandler(Self)) sText To iItem
87259>>>>>>>>>>>>>>>>>      If iItem Ne -1 Begin
87261>>>>>>>>>>>>>>>>>        Get Codelist_value of (phoCodelistHandler(Self)) iItem to sItem  // get the item text of the selected item
87262>>>>>>>>>>>>>>>>>        Get piRefValue of (phoCodelistHandler(Self)) to iRefVal
87263>>>>>>>>>>>>>>>>>        Get msg_CM_CodeListItemSelected sItem iRefVal to iRetVal
87264>>>>>>>>>>>>>>>>>      End
87264>>>>>>>>>>>>>>>>>>
87264>>>>>>>>>>>>>>>>>    End
87264>>>>>>>>>>>>>>>>>>
87264>>>>>>>>>>>>>>>>>    Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
87265>>>>>>>>>>>>>>>>>  End_Procedure
87266>>>>>>>>>>>>>>>>>
87266>>>>>>>>>>>>>>>>>  // To be filled in at higher class
87266>>>>>>>>>>>>>>>>>  Function TranslateCharacter Integer iKey Returns Integer
87268>>>>>>>>>>>>>>>>>    Function_Return 0
87269>>>>>>>>>>>>>>>>>  End_Function
87270>>>>>>>>>>>>>>>>>
87270>>>>>>>>>>>>>>>>>  // To be filled in at higher class
87270>>>>>>>>>>>>>>>>>  Function ShouldTranslateCharacter Integer iKeyCode Returns Boolean
87272>>>>>>>>>>>>>>>>>    Function_Return false
87273>>>>>>>>>>>>>>>>>  End_Function
87274>>>>>>>>>>>>>>>>>
87274>>>>>>>>>>>>>>>>>
87274>>>>>>>>>>>>>>>>>  Procedure doCharacterTranslation Address aText Integer iLength
87276>>>>>>>>>>>>>>>>>    Boolean bTranslateChar
87276>>>>>>>>>>>>>>>>>    Integer iKey
87276>>>>>>>>>>>>>>>>>    Integer iNewKey
87276>>>>>>>>>>>>>>>>>    String  sText
87276>>>>>>>>>>>>>>>>>    String  sNewChar
87276>>>>>>>>>>>>>>>>>
87276>>>>>>>>>>>>>>>>>    If (pbFileLoading(Self)=false) Begin // don't translate text when loading from disk
87278>>>>>>>>>>>>>>>>>      If (aText<>0) Begin
87280>>>>>>>>>>>>>>>>>        Move aText To sText
87281>>>>>>>>>>>>>>>>>      End
87281>>>>>>>>>>>>>>>>>>
87281>>>>>>>>>>>>>>>>>      Else Begin
87282>>>>>>>>>>>>>>>>>        Move "" to sText
87283>>>>>>>>>>>>>>>>>      End
87283>>>>>>>>>>>>>>>>>>
87283>>>>>>>>>>>>>>>>>      If (sText<>"" and iLength=1) Begin
87285>>>>>>>>>>>>>>>>>        Move (Ascii(sText)) To iKey
87286>>>>>>>>>>>>>>>>>        Get ShouldTranslateCharacter iKey to bTranslateChar
87287>>>>>>>>>>>>>>>>>        If (bTranslateChar) Begin
87289>>>>>>>>>>>>>>>>>          Get TranslateCharacter iKey to iNewKey
87290>>>>>>>>>>>>>>>>>          If (iNewKey<>0) Begin
87292>>>>>>>>>>>>>>>>>            Move (Character(iNewKey)) To sNewChar
87293>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_CHANGEINSERTION 1 (AddressOf(sNewChar))
87294>>>>>>>>>>>>>>>>>          End
87294>>>>>>>>>>>>>>>>>>
87294>>>>>>>>>>>>>>>>>        End
87294>>>>>>>>>>>>>>>>>>
87294>>>>>>>>>>>>>>>>>      End
87294>>>>>>>>>>>>>>>>>>
87294>>>>>>>>>>>>>>>>>    End
87294>>>>>>>>>>>>>>>>>>
87294>>>>>>>>>>>>>>>>>  End_Procedure
87295>>>>>>>>>>>>>>>>>
87295>>>>>>>>>>>>>>>>>  Procedure UpdateUIBlockSelectEdit
87297>>>>>>>>>>>>>>>>>    Boolean bBlockSelect
87297>>>>>>>>>>>>>>>>>    Integer iCaretPos iAnchorPos
87297>>>>>>>>>>>>>>>>>
87297>>>>>>>>>>>>>>>>>    If (pbBlockSelectBackspace(Self)) Begin
87299>>>>>>>>>>>>>>>>>      // bugfix
87299>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONMODE SC_SEL_RECTANGLE
87300>>>>>>>>>>>>>>>>>    End
87300>>>>>>>>>>>>>>>>>>
87300>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SELECTIONISRECTANGLE to bBlockSelect
87301>>>>>>>>>>>>>>>>>    //Set pbBlockSelectActive to bBlockSelect
87301>>>>>>>>>>>>>>>>>    If (bBlockSelect) Begin
87303>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETRECTANGULARSELECTIONANCHOR to iAnchorPos
87304>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETRECTANGULARSELECTIONCARET  to iCaretPos
87305>>>>>>>>>>>>>>>>>      Set piBlockSelectAnchorPos to iAnchorPos
87306>>>>>>>>>>>>>>>>>      Set piBlockSelectCaretPos  to iCaretPos
87307>>>>>>>>>>>>>>>>>    End
87307>>>>>>>>>>>>>>>>>>
87307>>>>>>>>>>>>>>>>>    If (bBlockSelect=False) Begin
87309>>>>>>>>>>>>>>>>>      Set piBlockSelectAnchorPos to 0
87310>>>>>>>>>>>>>>>>>      Set piBlockSelectCaretPos  to 0
87311>>>>>>>>>>>>>>>>>    End
87311>>>>>>>>>>>>>>>>>>
87311>>>>>>>>>>>>>>>>>  End_Procedure
87312>>>>>>>>>>>>>>>>>
87312>>>>>>>>>>>>>>>>>  // tab works, but not when only space characters at first line, then it is a mess.
87312>>>>>>>>>>>>>>>>>  // But if I move the selection to the first column it works again. It's a bit ugly, but it works
87312>>>>>>>>>>>>>>>>>  Procedure BlockSelectTabKeyBugfix
87314>>>>>>>>>>>>>>>>>    Boolean bNeedBugfix
87314>>>>>>>>>>>>>>>>>    Integer iAnchorPos iCaretPos iColumn
87314>>>>>>>>>>>>>>>>>    Integer iLine iStartLine iEndLine
87314>>>>>>>>>>>>>>>>>    String  sLine sValue
87314>>>>>>>>>>>>>>>>>
87314>>>>>>>>>>>>>>>>>    Move True to bNeedBugfix
87315>>>>>>>>>>>>>>>>>    Get piBlockSelectAnchorPos to iAnchorPos
87316>>>>>>>>>>>>>>>>>    Get piBlockSelectCaretPos  to iCaretPos
87317>>>>>>>>>>>>>>>>>    // As it is a block select, the start column is the end column and thus we check the text of
87317>>>>>>>>>>>>>>>>>    // all selected lines from column 0 to iColumn
87317>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN  iAnchorPos to iColumn
87318>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87319>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87320>>>>>>>>>>>>>>>>>    For iLine from iStartLine to iEndLine
87326>>>>>>>>>>>>>>>>>>
87326>>>>>>>>>>>>>>>>>      Get Value item iLine to sLine
87327>>>>>>>>>>>>>>>>>      Move (Left(sLine,iColumn)) To sValue
87328>>>>>>>>>>>>>>>>>      If (sValue<>"") Begin
87330>>>>>>>>>>>>>>>>>        Move False To bNeedBugfix
87331>>>>>>>>>>>>>>>>>        Move iEndLine to iLine
87332>>>>>>>>>>>>>>>>>      End
87332>>>>>>>>>>>>>>>>>>
87332>>>>>>>>>>>>>>>>>    Loop
87333>>>>>>>>>>>>>>>>>>
87333>>>>>>>>>>>>>>>>>    If (bNeedBugfix) Begin
87335>>>>>>>>>>>>>>>>>      Send BlockSelectAdjustSelectionColumn iAnchorPos iCaretPos (-iColumn)
87336>>>>>>>>>>>>>>>>>    End
87336>>>>>>>>>>>>>>>>>>
87336>>>>>>>>>>>>>>>>>  End_Procedure
87337>>>>>>>>>>>>>>>>>
87337>>>>>>>>>>>>>>>>>  // If you do a block select and then start typing it should remove the selected block of text
87337>>>>>>>>>>>>>>>>>  // before it does the multiline text type.
87337>>>>>>>>>>>>>>>>>  Procedure BlockSelectRemoveTextBlockBugfix
87339>>>>>>>>>>>>>>>>>    Integer iCaretPos iAnchorPos
87339>>>>>>>>>>>>>>>>>    Integer iStartLine iStartColumn
87339>>>>>>>>>>>>>>>>>    Integer iEndLine   iEndColumn
87339>>>>>>>>>>>>>>>>>
87339>>>>>>>>>>>>>>>>>    Get piBlockSelectAnchorPos to iAnchorPos
87340>>>>>>>>>>>>>>>>>    Get piBlockSelectCaretPos  to iCaretPos
87341>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87342>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn
87343>>>>>>>>>>>>>>>>>
87343>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87344>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
87345>>>>>>>>>>>>>>>>>    If (iStartColumn<>iEndColumn) Begin
87347>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_DELETEBACK  //<--  this actually works ?\_(?)_/?
87348>>>>>>>>>>>>>>>>>    End
87348>>>>>>>>>>>>>>>>>>
87348>>>>>>>>>>>>>>>>>  End_Procedure
87349>>>>>>>>>>>>>>>>>
87349>>>>>>>>>>>>>>>>>  //
87349>>>>>>>>>>>>>>>>>  // Move the block selection by iAdjust positions to the left or right
87349>>>>>>>>>>>>>>>>>  //
87349>>>>>>>>>>>>>>>>>  Procedure BlockSelectAdjustSelectionColumn Integer iAnchorPos Integer iCaretPos Integer iAdjust
87351>>>>>>>>>>>>>>>>>    Integer iStartLine iStartColumn
87351>>>>>>>>>>>>>>>>>    Integer iEndLine   iEndColumn
87351>>>>>>>>>>>>>>>>>
87351>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87352>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn
87353>>>>>>>>>>>>>>>>>
87353>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87354>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
87355>>>>>>>>>>>>>>>>>    If (iStartColumn=iEndColumn) Begin
87357>>>>>>>>>>>>>>>>>      //
87357>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iStartLine (iStartColumn+iAdjust) to iAnchorPos
87358>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iEndLine   (iEndColumn+iAdjust)   to iCaretPos
87359>>>>>>>>>>>>>>>>>      // move selection to the new position
87359>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONANCHOR iAnchorPos
87360>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONCARET  iCaretPos
87361>>>>>>>>>>>>>>>>>    End
87361>>>>>>>>>>>>>>>>>>
87361>>>>>>>>>>>>>>>>>  End_Procedure
87362>>>>>>>>>>>>>>>>>
87362>>>>>>>>>>>>>>>>>  Procedure BlockSelectEdit Integer iChar Longptr lParam
87364>>>>>>>>>>>>>>>>>    Integer iCaretPos iAnchorPos
87364>>>>>>>>>>>>>>>>>    Integer iStartLine iStartColumn iLine
87364>>>>>>>>>>>>>>>>>    Integer iEndLine   iEndColumn iRet
87364>>>>>>>>>>>>>>>>>    String  sChar
87364>>>>>>>>>>>>>>>>>
87364>>>>>>>>>>>>>>>>>    Move (character(iChar)) To sChar
87365>>>>>>>>>>>>>>>>>    Get piBlockSelectAnchorPos to iAnchorPos
87366>>>>>>>>>>>>>>>>>    Get piBlockSelectCaretPos  to iCaretPos
87367>>>>>>>>>>>>>>>>>
87367>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87368>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn
87369>>>>>>>>>>>>>>>>>
87369>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87370>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
87371>>>>>>>>>>>>>>>>>    If (iStartColumn=iEndColumn) Begin
87373>>>>>>>>>>>>>>>>>      If (iStartLine>iEndLine) Begin
87375>>>>>>>>>>>>>>>>>        Send SwapIntegerVariables (&iStartLine) (&iEndLine)
87376>>>>>>>>>>>>>>>>>      End
87376>>>>>>>>>>>>>>>>>>
87376>>>>>>>>>>>>>>>>>      // easy type over multiple lines, cursor is on endline and will type itself
87376>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_BEGINUNDOACTION
87377>>>>>>>>>>>>>>>>>      For iLine from iStartLine to (iEndLine-1)
87383>>>>>>>>>>>>>>>>>>
87383>>>>>>>>>>>>>>>>>        Get CM_InsertText sChar iLine iStartColumn to iRet
87384>>>>>>>>>>>>>>>>>      Loop
87385>>>>>>>>>>>>>>>>>>
87385>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_ENDUNDOACTION
87386>>>>>>>>>>>>>>>>>      //
87386>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iStartLine (iStartColumn+1) to iAnchorPos
87387>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iEndLine   (iEndColumn+1)   to iCaretPos
87388>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONANCHOR iAnchorPos
87389>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONCARET  iCaretPos
87390>>>>>>>>>>>>>>>>>      //Send BlockSelectAdjustSelectionColumn iAnchorPos iCaretPos 1  // this one doesn't work, don't quite understand why
87390>>>>>>>>>>>>>>>>>    End
87390>>>>>>>>>>>>>>>>>>
87390>>>>>>>>>>>>>>>>>  End_Procedure
87391>>>>>>>>>>>>>>>>>
87391>>>>>>>>>>>>>>>>>  // BP
87391>>>>>>>>>>>>>>>>>
87391>>>>>>>>>>>>>>>>>  Procedure onBeforeFloatingMenu
87393>>>>>>>>>>>>>>>>>  End_Procedure
87394>>>>>>>>>>>>>>>>>  Procedure onAfterFloatingMenu
87396>>>>>>>>>>>>>>>>>  End_Procedure
87397>>>>>>>>>>>>>>>>>
87397>>>>>>>>>>>>>>>>>  // Is sent when a WM_Notify with NM_RCLICK occusrs.
87397>>>>>>>>>>>>>>>>>  // I use it to implement the Popup of the floating_poup_menu.
87397>>>>>>>>>>>>>>>>>  Procedure DoRightClick Longptr lParam
87399>>>>>>>>>>>>>>>>>    If (Floating_Menu_Object(Self)) Ne 0 Begin
87401>>>>>>>>>>>>>>>>>      Set phoServedObject of (Floating_menu_object(Self)) to Self
87402>>>>>>>>>>>>>>>>>      Send OnBeforeFloatingMenu
87403>>>>>>>>>>>>>>>>>      Send Popup  to (Floating_Menu_Object(Self))
87404>>>>>>>>>>>>>>>>>      Send OnAfterFloatingMenu
87405>>>>>>>>>>>>>>>>>      Procedure_Return 1
87406>>>>>>>>>>>>>>>>>    End
87406>>>>>>>>>>>>>>>>>>
87406>>>>>>>>>>>>>>>>>  End_Procedure
87407>>>>>>>>>>>>>>>>>
87407>>>>>>>>>>>>>>>>>  Procedure onSetFocus
87409>>>>>>>>>>>>>>>>>  End_Procedure
87410>>>>>>>>>>>>>>>>>  Procedure onKillFocus
87412>>>>>>>>>>>>>>>>>  End_Procedure
87413>>>>>>>>>>>>>>>>>  Procedure onChange
87415>>>>>>>>>>>>>>>>>  End_Procedure
87416>>>>>>>>>>>>>>>>>
87416>>>>>>>>>>>>>>>>>
87416>>>>>>>>>>>>>>>>>  Procedure OnCharAdded
87418>>>>>>>>>>>>>>>>>  End_Procedure
87419>>>>>>>>>>>>>>>>>
87419>>>>>>>>>>>>>>>>>  Procedure OnStyleNeeded
87421>>>>>>>>>>>>>>>>>  End_Procedure
87422>>>>>>>>>>>>>>>>>
87422>>>>>>>>>>>>>>>>>  Procedure OnSavePointReached
87424>>>>>>>>>>>>>>>>>  End_Procedure
87425>>>>>>>>>>>>>>>>>
87425>>>>>>>>>>>>>>>>>  Procedure OnSavePointLeft
87427>>>>>>>>>>>>>>>>>  End_Procedure
87428>>>>>>>>>>>>>>>>>
87428>>>>>>>>>>>>>>>>>  Procedure OnDoubleClick
87430>>>>>>>>>>>>>>>>>    //Send Info_Box "double click"
87430>>>>>>>>>>>>>>>>>  End_Procedure
87431>>>>>>>>>>>>>>>>>  
87431>>>>>>>>>>>>>>>>>  // If you double click on a brace character then we select
87431>>>>>>>>>>>>>>>>>  // the text underneath until the matching brace character
87431>>>>>>>>>>>>>>>>>  Procedure MatchingBracesSelectText Integer iPos
87433>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
87433>>>>>>>>>>>>>>>>>    Boolean bIsComment
87433>>>>>>>>>>>>>>>>>    Boolean bIsMatch
87433>>>>>>>>>>>>>>>>>    Integer iChar
87433>>>>>>>>>>>>>>>>>    Integer iMatchPos
87433>>>>>>>>>>>>>>>>>    Integer imaxRestyle
87433>>>>>>>>>>>>>>>>>    
87433>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCHARAT iPos 0 to iChar
87434>>>>>>>>>>>>>>>>>    Get IsBraceCharacter iChar To bIsBraceChar
87435>>>>>>>>>>>>>>>>>    If (bIsBraceChar) Begin
87437>>>>>>>>>>>>>>>>>      Get StyleAtPosIsComment iPos To bIsComment
87438>>>>>>>>>>>>>>>>>      If (bIsComment=false) Begin
87440>>>>>>>>>>>>>>>>>        Move 0 to imaxReStyle
87441>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
87442>>>>>>>>>>>>>>>>>        Get IsValidBraceCharMatch iPos iMatchPos to bIsMatch
87443>>>>>>>>>>>>>>>>>        If (bIsMatch) Begin
87445>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETEMPTYSELECTION iMatchPos  // remove existing selections
87446>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETSELECTIONSTART iPos
87447>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETSELECTIONEND   (iMatchPos+1)
87448>>>>>>>>>>>>>>>>>        End
87448>>>>>>>>>>>>>>>>>>
87448>>>>>>>>>>>>>>>>>      End
87448>>>>>>>>>>>>>>>>>>
87448>>>>>>>>>>>>>>>>>    End
87448>>>>>>>>>>>>>>>>>>
87448>>>>>>>>>>>>>>>>>  End_Procedure
87449>>>>>>>>>>>>>>>>>  
87449>>>>>>>>>>>>>>>>>  Procedure DoDoubleClick Integer iPos
87451>>>>>>>>>>>>>>>>>    Send MatchingBracesSelectText iPos
87452>>>>>>>>>>>>>>>>>    Send OnDoubleClick
87453>>>>>>>>>>>>>>>>>  End_Procedure
87454>>>>>>>>>>>>>>>>>
87454>>>>>>>>>>>>>>>>>  Procedure OnModified
87456>>>>>>>>>>>>>>>>>  End_Procedure
87457>>>>>>>>>>>>>>>>>  
87457>>>>>>>>>>>>>>>>>  Procedure onUpdateCursorPosition
87459>>>>>>>>>>>>>>>>>  End_Procedure
87460>>>>>>>>>>>>>>>>>  
87460>>>>>>>>>>>>>>>>>  Procedure onStatusMarginClicked Integer iLine
87462>>>>>>>>>>>>>>>>>  End_Procedure
87463>>>>>>>>>>>>>>>>>
87463>>>>>>>>>>>>>>>>>  Procedure OnMarginClick Integer iMargin Integer iLine
87465>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
87465>>>>>>>>>>>>>>>>>
87465>>>>>>>>>>>>>>>>>    Case Begin
87465>>>>>>>>>>>>>>>>>      Case (iMargin=MARGIN_CODE_FOLDING)
87467>>>>>>>>>>>>>>>>>        Get LineHasFoldPoint iLine To bFoldPoint
87468>>>>>>>>>>>>>>>>>        If (bFoldPoint) Begin
87470>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_TOGGLEFOLD iLine
87471>>>>>>>>>>>>>>>>>        End
87471>>>>>>>>>>>>>>>>>>
87471>>>>>>>>>>>>>>>>>        Case Break
87472>>>>>>>>>>>>>>>>>      Case (iMargin=MARGIN_STATUS)
87475>>>>>>>>>>>>>>>>>        Send onStatusMarginClicked iLine
87476>>>>>>>>>>>>>>>>>        Case Break
87477>>>>>>>>>>>>>>>>>    Case End
87477>>>>>>>>>>>>>>>>>  End_Procedure
87478>>>>>>>>>>>>>>>>>
87478>>>>>>>>>>>>>>>>>  Procedure OnMarginRightClick
87480>>>>>>>>>>>>>>>>>  End_Procedure
87481>>>>>>>>>>>>>>>>>
87481>>>>>>>>>>>>>>>>>  //
87481>>>>>>>>>>>>>>>>>  // Brace matching wasn't done on typing only when navigating, so we now call it from onCharAdd
87481>>>>>>>>>>>>>>>>>  //
87481>>>>>>>>>>>>>>>>>  Procedure BraceMatchingCharAdded
87483>>>>>>>>>>>>>>>>>    Boolean bShowMatchingBraces
87483>>>>>>>>>>>>>>>>>    Integer iPos
87483>>>>>>>>>>>>>>>>>    Get pbShowMatchingBraces to bShowMatchingBraces
87484>>>>>>>>>>>>>>>>>    If (bShowMatchingBraces) Begin
87486>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCURRENTPOS to iPos
87487>>>>>>>>>>>>>>>>>      Send ShowMatchingBraces iPos
87488>>>>>>>>>>>>>>>>>    End
87488>>>>>>>>>>>>>>>>>>
87488>>>>>>>>>>>>>>>>>  End_Procedure
87489>>>>>>>>>>>>>>>>>
87489>>>>>>>>>>>>>>>>>  Procedure onQuickInfo Integer iPos String ByRef sTooltip
87491>>>>>>>>>>>>>>>>>  End_Procedure
87492>>>>>>>>>>>>>>>>>  
87492>>>>>>>>>>>>>>>>>  Procedure ShowScopeQuickInfo Integer iPos String ByRef sTooltip
87494>>>>>>>>>>>>>>>>>    Integer iLine
87494>>>>>>>>>>>>>>>>>    Integer iMatchLine
87494>>>>>>>>>>>>>>>>>    Integer iColumn
87494>>>>>>>>>>>>>>>>>    Integer eStyle
87494>>>>>>>>>>>>>>>>>    String  sWord
87494>>>>>>>>>>>>>>>>>    String  sLine
87494>>>>>>>>>>>>>>>>>
87494>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT       iPos 0 To eStyle
87495>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iPos 0 To iLine
87496>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iPos 0 To iColumn
87497>>>>>>>>>>>>>>>>>    Get CM_GetWord iLine iColumn To sWord
87498>>>>>>>>>>>>>>>>>    If (sWord<>"" and eStyle=SCE_DF_SCOPEWORD) Begin
87500>>>>>>>>>>>>>>>>>      Move (lowercase(sWord)) To sWord
87501>>>>>>>>>>>>>>>>>      If (sWord="end_procedure" or sWord="end_function" or sWord="end_object" or sWord="end_class") Begin
87503>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETFOLDPARENT iLine 0 To iMatchLine
87504>>>>>>>>>>>>>>>>>        If (iMatchLine) Begin
87506>>>>>>>>>>>>>>>>>          Get CM_GetLine iMatchLine to sLine
87507>>>>>>>>>>>>>>>>>          Move (Ltrim(sLine)) To sTooltip
87508>>>>>>>>>>>>>>>>>        End
87508>>>>>>>>>>>>>>>>>>
87508>>>>>>>>>>>>>>>>>      End
87508>>>>>>>>>>>>>>>>>>
87508>>>>>>>>>>>>>>>>>    End
87508>>>>>>>>>>>>>>>>>>
87508>>>>>>>>>>>>>>>>>  End_Procedure
87509>>>>>>>>>>>>>>>>>  
87509>>>>>>>>>>>>>>>>>  Procedure doQuickInfo Integer iPos
87511>>>>>>>>>>>>>>>>>    String  sTip
87511>>>>>>>>>>>>>>>>>    
87511>>>>>>>>>>>>>>>>>    Get psCodeTipCurrent To sTip
87512>>>>>>>>>>>>>>>>>    Send ShowScopeQuickInfo iPos (&sTip)
87513>>>>>>>>>>>>>>>>>    Send onQuickInfo iPos (&sTip)
87514>>>>>>>>>>>>>>>>>    If (iPos>-1 and sTip<>"") Begin
87516>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
87517>>>>>>>>>>>>>>>>>    End
87517>>>>>>>>>>>>>>>>>>
87517>>>>>>>>>>>>>>>>>  End_Procedure
87518>>>>>>>>>>>>>>>>>
87518>>>>>>>>>>>>>>>>>  Procedure Notify Longptr wParam Longptr lParam
87520>>>>>>>>>>>>>>>>>    Integer iRet
87520>>>>>>>>>>>>>>>>>    Integer iCode
87520>>>>>>>>>>>>>>>>>    Integer iLine
87520>>>>>>>>>>>>>>>>>    Integer iPos
87520>>>>>>>>>>>>>>>>>    tSCNotification SCNotify
87520>>>>>>>>>>>>>>>>>    tSCNotification SCNotify
87520>>>>>>>>>>>>>>>>>
87520>>>>>>>>>>>>>>>>>    Move 0 To SCNotify.line // variable exists and is initialized
87521>>>>>>>>>>>>>>>>>    Move (CopyMemory(AddressOf(SCNotify),lParam,SizeOfType(tSCNotification))) to iRet
87522>>>>>>>>>>>>>>>>>    Move SCNotify.Nmhdr.uCode  to iCode
87523>>>>>>>>>>>>>>>>>
87523>>>>>>>>>>>>>>>>>    // Trap Events...________________________
87523>>>>>>>>>>>>>>>>>    Move 0 to iRet
87524>>>>>>>>>>>>>>>>>
87524>>>>>>>>>>>>>>>>>    Case Begin
87524>>>>>>>>>>>>>>>>>      Case (iCode=SCN_STYLENEEDED)
87526>>>>>>>>>>>>>>>>>        Send OnStyleNeeded
87527>>>>>>>>>>>>>>>>>        Case Break
87528>>>>>>>>>>>>>>>>>      Case (iCode=SCN_CHARADDED)
87531>>>>>>>>>>>>>>>>>        Send OnCharAdded
87532>>>>>>>>>>>>>>>>>        Get Msg_onChange                    to iRet
87533>>>>>>>>>>>>>>>>>        Get Msg_DoKeyAction SCNotify.ch lParam    to iRet
87534>>>>>>>>>>>>>>>>>        If (pbBlockSelectActive(Self)) Begin
87536>>>>>>>>>>>>>>>>>          Send BlockSelectEdit SCNotify.ch lParam
87537>>>>>>>>>>>>>>>>>        End
87537>>>>>>>>>>>>>>>>>>
87537>>>>>>>>>>>>>>>>>        Send BraceMatchingCharAdded
87538>>>>>>>>>>>>>>>>>        Case Break
87539>>>>>>>>>>>>>>>>>      Case (iCode=SCN_SAVEPOINTREACHED   )
87542>>>>>>>>>>>>>>>>>        Send OnSavePointReached
87543>>>>>>>>>>>>>>>>>        Get Msg_DoModifiedChange            to iRet
87544>>>>>>>>>>>>>>>>>        Case Break
87545>>>>>>>>>>>>>>>>>      Case (iCode=SCN_SAVEPOINTLEFT      )
87548>>>>>>>>>>>>>>>>>        Send OnSavePointLeft
87549>>>>>>>>>>>>>>>>>        Get Msg_DoModifiedChange            to iRet
87550>>>>>>>>>>>>>>>>>        Case Break
87551>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MODIFYATTEMPTRO    )
87554>>>>>>>>>>>>>>>>>        //Send Info_Box "Document cannot be changed, it is readonly"
87554>>>>>>>>>>>>>>>>>        Case Break
87555>>>>>>>>>>>>>>>>>      Case (iCode=SCN_KEY                )  //  Used on GTK+ because of some problems with keyboard focus and is not sent by the Windows version.
87558>>>>>>>>>>>>>>>>>        //Get Msg_DoKeyAction iCode lParam    to iRet
87558>>>>>>>>>>>>>>>>>        Send none
87559>>>>>>>>>>>>>>>>>        Case Break
87560>>>>>>>>>>>>>>>>>      Case (iCode=SCN_DOUBLECLICK        )
87563>>>>>>>>>>>>>>>>>        Send DoDoubleClick SCNotify.position
87564>>>>>>>>>>>>>>>>>        Case Break
87565>>>>>>>>>>>>>>>>>      Case (iCode=SCN_UPDATEUI           )
87568>>>>>>>>>>>>>>>>>        If (SCNotify.updated iAnd (SC_UPDATE_SELECTION+SC_UPDATE_V_SCROLL)) Begin
87570>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETCURRENTPOS to iPos
87571>>>>>>>>>>>>>>>>>          Send onNavigate iPos
87572>>>>>>>>>>>>>>>>>        End
87572>>>>>>>>>>>>>>>>>>
87572>>>>>>>>>>>>>>>>>        If (SCNotify.updated iAnd SC_UPDATE_SELECTION) Begin
87574>>>>>>>>>>>>>>>>>          Send UpdateUIBlockSelectEdit
87575>>>>>>>>>>>>>>>>>        End
87575>>>>>>>>>>>>>>>>>>
87575>>>>>>>>>>>>>>>>>        Case Break
87576>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MODIFIED           )
87579>>>>>>>>>>>>>>>>>        Send OnModified
87580>>>>>>>>>>>>>>>>>        If (SCNotify.modificationType iAnd (SC_MOD_INSERTTEXT+SC_MOD_DELETETEXT)) Begin
87582>>>>>>>>>>>>>>>>>          Send LineCountChanged
87583>>>>>>>>>>>>>>>>>          If ((SCNotify.modificationType iAnd SC_STARTACTION)=0) Begin
87585>>>>>>>>>>>>>>>>>            If (SCNotify.modificationType iAnd (SC_PERFORMED_REDO+SC_PERFORMED_UNDO+SC_PERFORMED_USER)) Begin
87587>>>>>>>>>>>>>>>>>              Get Msg_onChange                    to iRet
87588>>>>>>>>>>>>>>>>>            End
87588>>>>>>>>>>>>>>>>>>
87588>>>>>>>>>>>>>>>>>          End
87588>>>>>>>>>>>>>>>>>>
87588>>>>>>>>>>>>>>>>>
87588>>>>>>>>>>>>>>>>>        End
87588>>>>>>>>>>>>>>>>>>
87588>>>>>>>>>>>>>>>>>        If (SCNotify.modificationType = SC_MOD_INSERTCHECK) Begin
87590>>>>>>>>>>>>>>>>>          Send doCharacterTranslation SCNotify.Text SCNotify.length
87591>>>>>>>>>>>>>>>>>        End
87591>>>>>>>>>>>>>>>>>>
87591>>>>>>>>>>>>>>>>>        Case Break
87592>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MACRORECORD        )
87595>>>>>>>>>>>>>>>>>        Case Break
87596>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MARGINCLICK        )
87599>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_LINEFROMPOSITION SCNotify.position to iLine
87600>>>>>>>>>>>>>>>>>        Send OnMarginClick SCNotify.margin iLine
87601>>>>>>>>>>>>>>>>>        Case Break
87602>>>>>>>>>>>>>>>>>      Case (iCode=SCN_NEEDSHOWN          )
87605>>>>>>>>>>>>>>>>>        Case Break
87606>>>>>>>>>>>>>>>>>      Case (iCode=SCN_PAINTED            )
87609>>>>>>>>>>>>>>>>>        Case Break
87610>>>>>>>>>>>>>>>>>      Case (iCode=SCN_USERLISTSELECTION  )
87613>>>>>>>>>>>>>>>>>        Case Break
87614>>>>>>>>>>>>>>>>>      Case (iCode=SCN_URIDROPPED         )
87617>>>>>>>>>>>>>>>>>        Case Break
87618>>>>>>>>>>>>>>>>>      Case (iCode=SCN_DWELLSTART         )
87621>>>>>>>>>>>>>>>>>        Send doQuickInfo SCNotify.position
87622>>>>>>>>>>>>>>>>>        Case Break
87623>>>>>>>>>>>>>>>>>      Case (iCode=SCN_DWELLEND           )
87626>>>>>>>>>>>>>>>>>        Send CancelCodetip
87627>>>>>>>>>>>>>>>>>        Case Break
87628>>>>>>>>>>>>>>>>>      Case (iCode=SCN_ZOOM               )
87631>>>>>>>>>>>>>>>>>        Case Break
87632>>>>>>>>>>>>>>>>>      Case (iCode=SCN_HOTSPOTCLICK       )
87635>>>>>>>>>>>>>>>>>        Case Break
87636>>>>>>>>>>>>>>>>>      Case (iCode=SCN_HOTSPOTDOUBLECLICK )
87639>>>>>>>>>>>>>>>>>        Case Break
87640>>>>>>>>>>>>>>>>>      Case (iCode=SCN_CALLTIPCLICK       )
87643>>>>>>>>>>>>>>>>>        Case Break
87644>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCSELECTION     )
87647>>>>>>>>>>>>>>>>>        Get Msg_DoAutoCompleteSelection SCNotify.Text to iRet
87648>>>>>>>>>>>>>>>>>        Case Break
87649>>>>>>>>>>>>>>>>>      Case (iCode=SCN_INDICATORCLICK     )
87652>>>>>>>>>>>>>>>>>        Case Break
87653>>>>>>>>>>>>>>>>>      Case (iCode=SCN_INDICATORRELEASE   )
87656>>>>>>>>>>>>>>>>>        Case Break
87657>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCCANCELLED     )
87660>>>>>>>>>>>>>>>>>        Send DoCodeListCancel
87661>>>>>>>>>>>>>>>>>        Case Break
87662>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCCHARDELETED   )
87665>>>>>>>>>>>>>>>>>        Send none
87666>>>>>>>>>>>>>>>>>        Case Break
87667>>>>>>>>>>>>>>>>>      Case (iCode=SCN_HOTSPOTRELEASECLICK)
87670>>>>>>>>>>>>>>>>>        Case Break
87671>>>>>>>>>>>>>>>>>      Case (iCode=SCN_FOCUSIN            )
87674>>>>>>>>>>>>>>>>>        Send onUpdateCursorPosition
87675>>>>>>>>>>>>>>>>>        Get Msg_onSetFocus                  to iRet
87676>>>>>>>>>>>>>>>>>        Case Break
87677>>>>>>>>>>>>>>>>>      Case (iCode=SCN_FOCUSOUT           )
87680>>>>>>>>>>>>>>>>>        Get Msg_onKillFocus                 to iRet
87681>>>>>>>>>>>>>>>>>        Case Break
87682>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCCOMPLETED     )
87685>>>>>>>>>>>>>>>>>        // Only called when using built-in selection method, we do it manually
87685>>>>>>>>>>>>>>>>>        Case Break
87686>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MARGINRIGHTCLICK   )
87689>>>>>>>>>>>>>>>>>        Send OnMarginRightClick
87690>>>>>>>>>>>>>>>>>        Case Break
87691>>>>>>>>>>>>>>>>>      Case (iCode=SCEN_CHANGE            )
87694>>>>>>>>>>>>>>>>>        Send none
87695>>>>>>>>>>>>>>>>>        Case Break
87696>>>>>>>>>>>>>>>>>      Case (iCode=SCEN_SETFOCUS          )
87699>>>>>>>>>>>>>>>>>        Case Break
87700>>>>>>>>>>>>>>>>>      Case (iCode=SCEN_KILLFOCUS         )
87703>>>>>>>>>>>>>>>>>        Case Break
87704>>>>>>>>>>>>>>>>>    Case End
87704>>>>>>>>>>>>>>>>>
87704>>>>>>>>>>>>>>>>>    //// SVN CodeTip Support
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_CODETIPINITIALIZE   Get Msg_DoCodeTipInitialize lParam to iRet
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_CODETIPCANCEL       Get Msg_DoCodeTipCancel     to iRet
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_CODETIPUPDATE       Get Msg_DoCodeTipUpdate     to iRet
87704>>>>>>>>>>>>>>>>>    //// SVN
87704>>>>>>>>>>>>>>>>>    //
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_PROPSCHANGE         Get Msg_onPropsChange               to iRet
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_OVERTYPECHANGE      Get Msg_onOvertypeChange            to iRet
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_REGISTEREDCMD       Get Msg_DoRegisteredCmd   lParam    to iRet
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_FINDWRAPPED         Get Msg_DoFindWrapping              to iRet
87704>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_DRAWLINE            Get Msg_DoDrawLine        lParam    to iRet
87704>>>>>>>>>>>>>>>>>    Procedure_Return iRet
87705>>>>>>>>>>>>>>>>>  End_Procedure
87706>>>>>>>>>>>>>>>>>
87706>>>>>>>>>>>>>>>>>  // Delivers line and row (complex) from the given position
87706>>>>>>>>>>>>>>>>>  // -> Position local to the Edit!
87706>>>>>>>>>>>>>>>>>  Function LineRowFromRelativePosition Integer iY Integer iX  Returns Integer
87708>>>>>>>>>>>>>>>>>    Integer iLine iCol iRet
87708>>>>>>>>>>>>>>>>>    Integer iRow
87708>>>>>>>>>>>>>>>>>    Move -1 To iRow
87709>>>>>>>>>>>>>>>>>    If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin
87711>>>>>>>>>>>>>>>>>      Get CM_GetSelFromPoint iX iY        to iRet
87712>>>>>>>>>>>>>>>>>      Move (piSelStartLine(Self))         to iLine
87713>>>>>>>>>>>>>>>>>      Move (piSelStartCol (Self))         to iCol
87714>>>>>>>>>>>>>>>>>      Move (MAKEWPARAM(iCol,iLine)) To iRow
87715>>>>>>>>>>>>>>>>>    End
87715>>>>>>>>>>>>>>>>>>
87715>>>>>>>>>>>>>>>>>    Function_Return iRow
87716>>>>>>>>>>>>>>>>>  End_Function
87717>>>>>>>>>>>>>>>>>
87717>>>>>>>>>>>>>>>>>  // Same as above but uses absolute Screen coordinates.
87717>>>>>>>>>>>>>>>>>  Function LineRowFromAbsolutePosition Integer iY Integer iX  Returns Integer
87719>>>>>>>>>>>>>>>>>    Integer iPY iPX
87719>>>>>>>>>>>>>>>>>    Integer iRow
87719>>>>>>>>>>>>>>>>>    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
87720>>>>>>>>>>>>>>>>>    Move (Low(iPy))                     to iPx
87721>>>>>>>>>>>>>>>>>    Move (Hi(iPy))                      to iPy
87722>>>>>>>>>>>>>>>>>    Move (iY-iPy)                       to iY
87723>>>>>>>>>>>>>>>>>    Move (iX-iPx)                       to iX
87724>>>>>>>>>>>>>>>>>    Get LineRowFromRelativePosition iY iX to iRow
87725>>>>>>>>>>>>>>>>>    Function_Return iRow
87726>>>>>>>>>>>>>>>>>  End_Function
87727>>>>>>>>>>>>>>>>>
87727>>>>>>>>>>>>>>>>>  // Delivers the Line and Col under the Mouse Cursor.
87727>>>>>>>>>>>>>>>>>  Function LineRowUnderMouseCursor Returns Integer
87729>>>>>>>>>>>>>>>>>    Integer iX iY iRet
87729>>>>>>>>>>>>>>>>>    Integer iRow
87729>>>>>>>>>>>>>>>>>    tWinPoint wPoint
87729>>>>>>>>>>>>>>>>>    tWinPoint wPoint
87729>>>>>>>>>>>>>>>>>
87729>>>>>>>>>>>>>>>>>    Move 0 to wPoint.x
87730>>>>>>>>>>>>>>>>>    Move (GetCursorPos(AddressOf(wPoint)))     to iRet
87731>>>>>>>>>>>>>>>>>    Move wPoint.x to iX
87732>>>>>>>>>>>>>>>>>    Move wPoint.y to iY
87733>>>>>>>>>>>>>>>>>    Get LineRowFromAbsolutePosition iY iX to iRow
87734>>>>>>>>>>>>>>>>>    Function_Return iRow
87735>>>>>>>>>>>>>>>>>  End_Function
87736>>>>>>>>>>>>>>>>>
87736>>>>>>>>>>>>>>>>>
87736>>>>>>>>>>>>>>>>>  // To find the Scope for Inserting a Text.
87736>>>>>>>>>>>>>>>>>  Function GetScopeAboveFromLine Integer iLine Returns Integer
87738>>>>>>>>>>>>>>>>>    Integer iEnd
87738>>>>>>>>>>>>>>>>>    Integer iScope
87738>>>>>>>>>>>>>>>>>    String  sLine
87738>>>>>>>>>>>>>>>>>
87738>>>>>>>>>>>>>>>>>    Move 0  To iScope
87739>>>>>>>>>>>>>>>>>    Move "" To sLine
87740>>>>>>>>>>>>>>>>>    Move 0  To iEnd
87741>>>>>>>>>>>>>>>>>    Repeat
87741>>>>>>>>>>>>>>>>>>
87741>>>>>>>>>>>>>>>>>      If (Trim(sLine)) Ne "" ;        Move 1 to iEnd
87744>>>>>>>>>>>>>>>>>      If iLine Lt 0 ;        Move 1 to iEnd
87747>>>>>>>>>>>>>>>>>      If not iEnd ;        Get value item iLine to sLine
87750>>>>>>>>>>>>>>>>>      Decrement iLine
87751>>>>>>>>>>>>>>>>>    Until (iEnd)
87753>>>>>>>>>>>>>>>>>    If (sLine<>"") ;      Move (Pos(Trim(sLine),sLine)-1) To iScope
87756>>>>>>>>>>>>>>>>>    Function_Return iScope
87757>>>>>>>>>>>>>>>>>  End_Function
87758>>>>>>>>>>>>>>>>>  
87758>>>>>>>>>>>>>>>>>  Procedure NormalizeCaseRange Integer iLine Integer iCol Integer iLen
87760>>>>>>>>>>>>>>>>>    Boolean bChanged
87760>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
87760>>>>>>>>>>>>>>>>>    Integer iStartLine iStopLine
87760>>>>>>>>>>>>>>>>>    
87760>>>>>>>>>>>>>>>>>    If (pbNormalizeCase(Self)) Begin
87762>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
87763>>>>>>>>>>>>>>>>>      Move (iStartPos+iLen) To iEndPos
87764>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_COLOURISE iStartPos iEndPos  // apply style to the inserted text!
87765>>>>>>>>>>>>>>>>>      Move iLine To iStartLine
87766>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iEndPos 0 to iStopLine
87767>>>>>>>>>>>>>>>>>      For iLine from iStartLine to iStopLine
87773>>>>>>>>>>>>>>>>>>
87773>>>>>>>>>>>>>>>>>        Get LineNormalizeCase iLine False To bChanged
87774>>>>>>>>>>>>>>>>>      Loop
87775>>>>>>>>>>>>>>>>>>
87775>>>>>>>>>>>>>>>>>    End
87775>>>>>>>>>>>>>>>>>>
87775>>>>>>>>>>>>>>>>>  End_Procedure
87776>>>>>>>>>>>>>>>>>
87776>>>>>>>>>>>>>>>>>
87776>>>>>>>>>>>>>>>>>  // Inserts a Text at this Position.
87776>>>>>>>>>>>>>>>>>  // Understands commands like:
87776>>>>>>>>>>>>>>>>>  //  \n  ... New Line
87776>>>>>>>>>>>>>>>>>  //  \t  ... Keep ScopeLevel
87776>>>>>>>>>>>>>>>>>  //  \s  ... New Line and InsertColumn
87776>>>>>>>>>>>>>>>>>  Procedure InsertTextAtPosition Integer iLine Integer iCol String sTxt
87778>>>>>>>>>>>>>>>>>    Integer iRet iScopeCol
87778>>>>>>>>>>>>>>>>>    Integer iNewLineCount iMarker
87778>>>>>>>>>>>>>>>>>    String  sCR
87778>>>>>>>>>>>>>>>>>    Move 0 To iNewLineCount
87779>>>>>>>>>>>>>>>>>    Append sCR (Character(13)) (Character(10))
87781>>>>>>>>>>>>>>>>>    If (Left(sTxt,2)) Eq "\s" Begin
87783>>>>>>>>>>>>>>>>>      Move iCol              to iScopeCol
87784>>>>>>>>>>>>>>>>>    End
87784>>>>>>>>>>>>>>>>>>
87784>>>>>>>>>>>>>>>>>    Else Begin
87785>>>>>>>>>>>>>>>>>      Get GetScopeAboveFromLine iLine             to iScopeCol
87786>>>>>>>>>>>>>>>>>    End
87786>>>>>>>>>>>>>>>>>>
87786>>>>>>>>>>>>>>>>>    While (Pos("\n",sTxt))
87790>>>>>>>>>>>>>>>>>      Increment iNewLineCount
87791>>>>>>>>>>>>>>>>>      Move (Replace("\n",sTxt,sCR))               to sTxt               // TO insert a new Line.
87792>>>>>>>>>>>>>>>>>    Loop
87793>>>>>>>>>>>>>>>>>>
87793>>>>>>>>>>>>>>>>>    Move (Replaces("\t",sTxt,Repeat(" ",iScopeCol))) to sTxt               // To keep the scope level.
87794>>>>>>>>>>>>>>>>>    If (Left(sTxt,2)) Eq "\s" Begin                                        // Insert in new line.
87796>>>>>>>>>>>>>>>>>      Move (Replace("\s",sTxt,Append("",Repeat(" ",iCol))))   to sTxt    // TO insert a new Line.
87797>>>>>>>>>>>>>>>>>      Move 0                                                  to iCol
87798>>>>>>>>>>>>>>>>>    End
87798>>>>>>>>>>>>>>>>>>
87798>>>>>>>>>>>>>>>>>    Move (CM_InsertText(Self,sTxt,iLine,iCol))                  to iRet
87799>>>>>>>>>>>>>>>>>    Send NormalizeCaseRange iLine iCol (Length(sTxt))
87800>>>>>>>>>>>>>>>>>    For iMarker from 0 To (iNewLineCount-1)
87806>>>>>>>>>>>>>>>>>>
87806>>>>>>>>>>>>>>>>>      Set psLineOnEnter to ""
87807>>>>>>>>>>>>>>>>>      Increment iLine
87808>>>>>>>>>>>>>>>>>      Send LineChangedMark iLine
87809>>>>>>>>>>>>>>>>>    Loop
87810>>>>>>>>>>>>>>>>>>
87810>>>>>>>>>>>>>>>>>  End_Procedure
87811>>>>>>>>>>>>>>>>>
87811>>>>>>>>>>>>>>>>>  // Tries to insert a text after the character with the given relative
87811>>>>>>>>>>>>>>>>>  // position (Used for Drag and Drop)
87811>>>>>>>>>>>>>>>>>  Procedure Request_InsertTextAfterPosRel Integer iY Integer iX String sTxt
87813>>>>>>>>>>>>>>>>>    Integer iRet iLine iCol
87813>>>>>>>>>>>>>>>>>
87813>>>>>>>>>>>>>>>>>    If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin // Only if the Coord. are over the editspace.
87815>>>>>>>>>>>>>>>>>      Get CM_GetSelFromPoint iX iY    to iRet
87816>>>>>>>>>>>>>>>>>      If iRet Begin
87818>>>>>>>>>>>>>>>>>        Move (piSelStartLine(Self))         to iLine
87819>>>>>>>>>>>>>>>>>        Move (piSelStartCol (Self))         To iCol
87820>>>>>>>>>>>>>>>>>        Send GotoLine iLine // Move the cursor to the line where you insert the text
87821>>>>>>>>>>>>>>>>>        Send InsertTextAtPosition iLine iCol sTxt
87822>>>>>>>>>>>>>>>>>      End
87822>>>>>>>>>>>>>>>>>>
87822>>>>>>>>>>>>>>>>>    End
87822>>>>>>>>>>>>>>>>>>
87822>>>>>>>>>>>>>>>>>  End_Procedure
87823>>>>>>>>>>>>>>>>>
87823>>>>>>>>>>>>>>>>>
87823>>>>>>>>>>>>>>>>>
87823>>>>>>>>>>>>>>>>>
87823>>>>>>>>>>>>>>>>>  // Tries to insert a text after the character with the given absolut
87823>>>>>>>>>>>>>>>>>  // position (Used for Drag and Drop)
87823>>>>>>>>>>>>>>>>>  Procedure Request_InsertTextAfterPosAbs Integer iY Integer iX String sTxt
87825>>>>>>>>>>>>>>>>>    Integer iPY iPX
87825>>>>>>>>>>>>>>>>>    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
87826>>>>>>>>>>>>>>>>>    Move (Low(iPy))                     to iPx
87827>>>>>>>>>>>>>>>>>    Move (Hi(iPy))                      to iPy
87828>>>>>>>>>>>>>>>>>    Move (iY-iPy)                       to iY
87829>>>>>>>>>>>>>>>>>    Move (iX-iPx)                       to iX
87830>>>>>>>>>>>>>>>>>    Send Request_InsertTextAfterPosRel iY iX sTxt
87831>>>>>>>>>>>>>>>>>  End_Procedure
87832>>>>>>>>>>>>>>>>>  // Inserts text under the mouse cursor position.
87832>>>>>>>>>>>>>>>>>  Procedure Request_InsertTextUnderMouseCursor String sTxt
87834>>>>>>>>>>>>>>>>>    Integer iRet iX iY
87834>>>>>>>>>>>>>>>>>    tWinPoint wPoint
87834>>>>>>>>>>>>>>>>>    tWinPoint wPoint
87834>>>>>>>>>>>>>>>>>
87834>>>>>>>>>>>>>>>>>    Move 0 to wPoint.x
87835>>>>>>>>>>>>>>>>>    Move (GetCursorPos(AddressOf(wPoint)))     to iRet
87836>>>>>>>>>>>>>>>>>    Move wPoint.x to iX
87837>>>>>>>>>>>>>>>>>    Move wPoint.y to iY
87838>>>>>>>>>>>>>>>>>    Send Request_InsertTextAfterPosAbs iY iX sTxt
87839>>>>>>>>>>>>>>>>>  End_Procedure
87840>>>>>>>>>>>>>>>>>
87840>>>>>>>>>>>>>>>>>  Function HitTestCurrentMouse Returns Integer
87842>>>>>>>>>>>>>>>>>    Integer iRet iX iY iPy iPx
87842>>>>>>>>>>>>>>>>>    tWinPoint wPoint
87842>>>>>>>>>>>>>>>>>    tWinPoint wPoint
87842>>>>>>>>>>>>>>>>>    Move 0 to wPoint.x
87843>>>>>>>>>>>>>>>>>    Move (GetCursorPos(AddressOf(wPoint))) to iRet
87844>>>>>>>>>>>>>>>>>    Move wPoint.x to iX
87845>>>>>>>>>>>>>>>>>    Move wPoint.y to iY
87846>>>>>>>>>>>>>>>>>    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
87847>>>>>>>>>>>>>>>>>    Move (Low(iPy))                     to iPx
87848>>>>>>>>>>>>>>>>>    Move (Hi(iPy))                      to iPy
87849>>>>>>>>>>>>>>>>>    Move (iY-iPy)                       to iY
87850>>>>>>>>>>>>>>>>>    Move (iX-iPx)                       to iX
87851>>>>>>>>>>>>>>>>>    Function_Return (Hi(CM_HitTest(Self,iX,iY)))
87852>>>>>>>>>>>>>>>>>  End_Function
87853>>>>>>>>>>>>>>>>>
87853>>>>>>>>>>>>>>>>>  //
87853>>>>>>>>>>>>>>>>>  // For re-indenting when a line is a comment line or if it is a DataFlex image line it should not do
87853>>>>>>>>>>>>>>>>>  // the extra indent. So we have to figure out what it is...
87853>>>>>>>>>>>>>>>>>  //
87853>>>>>>>>>>>>>>>>>  Function LineIsComment Integer iLine String sLine Returns Boolean
87855>>>>>>>>>>>>>>>>>    Boolean bIsComment
87855>>>>>>>>>>>>>>>>>    Integer iPos
87855>>>>>>>>>>>>>>>>>    Integer iFirstChar
87855>>>>>>>>>>>>>>>>>
87855>>>>>>>>>>>>>>>>>    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
87856>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
87857>>>>>>>>>>>>>>>>>    Move (iPos+iFirstChar) To iPos
87858>>>>>>>>>>>>>>>>>    Get StyleAtPosIsComment iPos To bIsComment
87859>>>>>>>>>>>>>>>>>    Function_Return bIsComment
87860>>>>>>>>>>>>>>>>>  End_Function
87861>>>>>>>>>>>>>>>>>
87861>>>>>>>>>>>>>>>>>  //
87861>>>>>>>>>>>>>>>>>  // For re-indenting a DataFlex image should not be touched, so we cannot treat it the same as a comment
87861>>>>>>>>>>>>>>>>>  //
87861>>>>>>>>>>>>>>>>>  Function LineIsDfImage Integer iLine String sLine Returns Boolean
87863>>>>>>>>>>>>>>>>>    Boolean bIsImage
87863>>>>>>>>>>>>>>>>>    Integer iPos
87863>>>>>>>>>>>>>>>>>    Integer iFirstChar
87863>>>>>>>>>>>>>>>>>
87863>>>>>>>>>>>>>>>>>    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
87864>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
87865>>>>>>>>>>>>>>>>>    Move (iPos+iFirstChar) To iPos
87866>>>>>>>>>>>>>>>>>    Get StyleAtPosIsDfImage iPos To bIsImage
87867>>>>>>>>>>>>>>>>>    Function_Return bIsImage
87868>>>>>>>>>>>>>>>>>  End_Function
87869>>>>>>>>>>>>>>>>>    
87869>>>>>>>>>>>>>>>>>  Function LineIsGotoLabel Integer iLine String sLine Returns Boolean
87871>>>>>>>>>>>>>>>>>    Boolean iPos
87871>>>>>>>>>>>>>>>>>    Boolean iColonPos
87871>>>>>>>>>>>>>>>>>    Boolean bIsLabel
87871>>>>>>>>>>>>>>>>>      
87871>>>>>>>>>>>>>>>>>    Move False To bIsLabel
87872>>>>>>>>>>>>>>>>>    Get PreParsedLine iLine To sLine
87873>>>>>>>>>>>>>>>>>    If (Right(sLine,1)=":") Begin
87875>>>>>>>>>>>>>>>>>      Move True to bIsLabel
87876>>>>>>>>>>>>>>>>>      Move (Trim(sLine)) to sLine
87877>>>>>>>>>>>>>>>>>      Move (Pos(":",sLine)-1) to iColonPos
87878>>>>>>>>>>>>>>>>>      For iPos from 1 to iColonPos
87884>>>>>>>>>>>>>>>>>>
87884>>>>>>>>>>>>>>>>>        If (Mid(sLine,1,iPos)=" ") Begin
87886>>>>>>>>>>>>>>>>>          Move False To bIsLabel
87887>>>>>>>>>>>>>>>>>          MOve iColonPos To iPos // stop
87888>>>>>>>>>>>>>>>>>        End
87888>>>>>>>>>>>>>>>>>>
87888>>>>>>>>>>>>>>>>>      Loop
87889>>>>>>>>>>>>>>>>>>
87889>>>>>>>>>>>>>>>>>    End
87889>>>>>>>>>>>>>>>>>>
87889>>>>>>>>>>>>>>>>>    Function_Return bIsLabel
87890>>>>>>>>>>>>>>>>>  End_Function
87891>>>>>>>>>>>>>>>>>
87891>>>>>>>>>>>>>>>>>
87891>>>>>>>>>>>>>>>>>  Function ReIndentLineIndentation Integer iLine Integer iLineCount Integer iTabSize Boolean bUseTabs Integer ByRef iPrevLevel Returns String
87893>>>>>>>>>>>>>>>>>    Boolean bIsComment
87893>>>>>>>>>>>>>>>>>    Boolean bIsLabel
87893>>>>>>>>>>>>>>>>>    Integer iFoldLevel
87893>>>>>>>>>>>>>>>>>    Integer iNextLevel
87893>>>>>>>>>>>>>>>>>    Integer iLevel
87893>>>>>>>>>>>>>>>>>    Integer iIndentWanted
87893>>>>>>>>>>>>>>>>>    Integer iFirstChar
87893>>>>>>>>>>>>>>>>>    String  sLine
87893>>>>>>>>>>>>>>>>>    String  sIndent
87893>>>>>>>>>>>>>>>>>
87893>>>>>>>>>>>>>>>>>    If ((iLineCount-1)>iLine) Begin
87895>>>>>>>>>>>>>>>>>      //Send GotoLine (iLine+1) // the line has to be visible in order to be able to get the fold level
87895>>>>>>>>>>>>>>>>>    End
87895>>>>>>>>>>>>>>>>>>
87895>>>>>>>>>>>>>>>>>    Get LineFoldLevel iLine To iFoldLevel
87896>>>>>>>>>>>>>>>>>    If (iLine<(iLineCount-1)) Begin
87898>>>>>>>>>>>>>>>>>      Get LineFoldLevel (iLine+1) to iNextLevel
87899>>>>>>>>>>>>>>>>>    End
87899>>>>>>>>>>>>>>>>>>
87899>>>>>>>>>>>>>>>>>    Else Begin
87900>>>>>>>>>>>>>>>>>      Move 0 to iNextLevel
87901>>>>>>>>>>>>>>>>>    End
87901>>>>>>>>>>>>>>>>>>
87901>>>>>>>>>>>>>>>>>    Move iFoldLevel To iLevel
87902>>>>>>>>>>>>>>>>>    If (iNextLevel<iFoldLevel) Begin
87904>>>>>>>>>>>>>>>>>      Move iNextLevel to iLevel
87905>>>>>>>>>>>>>>>>>    End
87905>>>>>>>>>>>>>>>>>>
87905>>>>>>>>>>>>>>>>>    Get Value Item iLine To sLine
87906>>>>>>>>>>>>>>>>>    Get LineIsComment iLine sLine to bIsComment // a multi-line comment is also a code fold point, don't indent on that.
87907>>>>>>>>>>>>>>>>>    If (bIsComment) Begin
87909>>>>>>>>>>>>>>>>>      Move false To bIsComment
87910>>>>>>>>>>>>>>>>>      If (iLine>0) Begin
87912>>>>>>>>>>>>>>>>>        Get Value Item (iLine-1) to sLine
87913>>>>>>>>>>>>>>>>>        Get LineIsComment (iLine-1) sLine to bIsComment
87914>>>>>>>>>>>>>>>>>      End
87914>>>>>>>>>>>>>>>>>>
87914>>>>>>>>>>>>>>>>>      If (bIsComment) ;        Move iPrevLevel to iLevel
87917>>>>>>>>>>>>>>>>>      Get Value Item iLine to sLine  // get the correct line data again.
87918>>>>>>>>>>>>>>>>>      If (Left(sLine,2)="//" and pbReindentStudioCommentOut(Self)) Begin // if a comment starts at column 0, leave it alone
87920>>>>>>>>>>>>>>>>>        Move 0 To iLevel                                                 // (for Df Studio comment-out feature, see feature # 126)
87921>>>>>>>>>>>>>>>>>        Move False To bIsComment
87922>>>>>>>>>>>>>>>>>      End
87922>>>>>>>>>>>>>>>>>>
87922>>>>>>>>>>>>>>>>>    End
87922>>>>>>>>>>>>>>>>>>
87922>>>>>>>>>>>>>>>>>    Move (iLevel*iTabSize) To iIndentWanted
87923>>>>>>>>>>>>>>>>>    Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) To sIndent
87924>>>>>>>>>>>>>>>>>    Move (Length(sLine)-length(LTrim(sLine))+1) To iFirstChar // first non white space character on line is at this pos
87925>>>>>>>>>>>>>>>>>    // For macro's preserve the existing indentation
87925>>>>>>>>>>>>>>>>>    If (Mid(sLine,1,iFirstChar)="#") Begin
87927>>>>>>>>>>>>>>>>>        Move (Left(sLine,iFirstChar-1)) To sIndent
87928>>>>>>>>>>>>>>>>>    End
87928>>>>>>>>>>>>>>>>>>
87928>>>>>>>>>>>>>>>>>    Move (LTrim(sLine))  To sLine
87929>>>>>>>>>>>>>>>>>    // It is my opinion that a use should always be at the start of a line
87929>>>>>>>>>>>>>>>>>    // so I make exceptions for indenting on that and set the indent to ""
87929>>>>>>>>>>>>>>>>>    If (lowercase(Left(sLine,4))="use ") Begin
87931>>>>>>>>>>>>>>>>>        Move "" To sIndent
87932>>>>>>>>>>>>>>>>>    End
87932>>>>>>>>>>>>>>>>>>
87932>>>>>>>>>>>>>>>>>    // On labels and goto's you don't want indentation either
87932>>>>>>>>>>>>>>>>>    Get LineIsGotoLabel iLine sLine To bIsLabel
87933>>>>>>>>>>>>>>>>>    If (bIsLabel) Begin
87935>>>>>>>>>>>>>>>>>      Move "" To sIndent
87936>>>>>>>>>>>>>>>>>    End
87936>>>>>>>>>>>>>>>>>>
87936>>>>>>>>>>>>>>>>>    Move iLevel To iPrevLevel
87937>>>>>>>>>>>>>>>>>    //Showln iLine " -> " iFoldLevel " [-->] " iNextLevel " result {" sIndent "}" sLine
87937>>>>>>>>>>>>>>>>>
87937>>>>>>>>>>>>>>>>>    Function_Return sIndent
87938>>>>>>>>>>>>>>>>>  End_Function
87939>>>>>>>>>>>>>>>>>
87939>>>>>>>>>>>>>>>>>  // Standard Interface Support
87939>>>>>>>>>>>>>>>>>  // By SVN on 23/03/2017
87939>>>>>>>>>>>>>>>>>  Function CanCut Returns Integer
87941>>>>>>>>>>>>>>>>>    Function_Return (CM_CanCut(Self))
87942>>>>>>>>>>>>>>>>>  End_Function
87943>>>>>>>>>>>>>>>>>  Function CanCopy Returns Integer
87945>>>>>>>>>>>>>>>>>    Function_Return (CM_CanCopy(Self))
87946>>>>>>>>>>>>>>>>>  End_Function
87947>>>>>>>>>>>>>>>>>  Function CanPaste Returns Integer
87949>>>>>>>>>>>>>>>>>    Function_Return (CM_CanPaste(Self))
87950>>>>>>>>>>>>>>>>>  End_Function
87951>>>>>>>>>>>>>>>>>  Function CanUndo Returns Integer
87953>>>>>>>>>>>>>>>>>    Function_Return (CM_CanUndo(Self))
87954>>>>>>>>>>>>>>>>>  End_Function
87955>>>>>>>>>>>>>>>>>  Function CanRedo Returns Integer
87957>>>>>>>>>>>>>>>>>    Function_Return (CM_CanRedo(Self))
87958>>>>>>>>>>>>>>>>>  End_Function
87959>>>>>>>>>>>>>>>>>  Function CanDelete Returns Integer
87961>>>>>>>>>>>>>>>>>    Function_Return (CM_CanCut(Self))
87962>>>>>>>>>>>>>>>>>  End_Function
87963>>>>>>>>>>>>>>>>>  Procedure Redo
87965>>>>>>>>>>>>>>>>>    Integer iRet
87965>>>>>>>>>>>>>>>>>    Get CM_Redo to iRet
87966>>>>>>>>>>>>>>>>>  End_Procedure
87967>>>>>>>>>>>>>>>>>  Procedure Undo
87969>>>>>>>>>>>>>>>>>    Integer iRet
87969>>>>>>>>>>>>>>>>>    Get CM_Undo to iRet
87970>>>>>>>>>>>>>>>>>  End_Procedure
87971>>>>>>>>>>>>>>>>>  Procedure Cut
87973>>>>>>>>>>>>>>>>>    Integer iRet
87973>>>>>>>>>>>>>>>>>    Get CM_Cut to iRet
87974>>>>>>>>>>>>>>>>>  End_Procedure
87975>>>>>>>>>>>>>>>>>  Procedure Delete
87977>>>>>>>>>>>>>>>>>    Integer iRet
87977>>>>>>>>>>>>>>>>>    Get CM_Cut to iRet
87978>>>>>>>>>>>>>>>>>  End_Procedure
87979>>>>>>>>>>>>>>>>>  Procedure Copy
87981>>>>>>>>>>>>>>>>>    Integer iRet
87981>>>>>>>>>>>>>>>>>    Get CM_Copy to iRet
87982>>>>>>>>>>>>>>>>>  End_Procedure
87983>>>>>>>>>>>>>>>>>  Procedure Paste
87985>>>>>>>>>>>>>>>>>    Integer iRet
87985>>>>>>>>>>>>>>>>>    Get CM_Paste to iRet
87986>>>>>>>>>>>>>>>>>  End_Procedure
87987>>>>>>>>>>>>>>>>>  //
87987>>>>>>>>>>>>>>>>>
87987>>>>>>>>>>>>>>>>>  // Should Start the Properties.
87987>>>>>>>>>>>>>>>>>  Procedure Properties
87989>>>>>>>>>>>>>>>>>    //        Integer iRet
87989>>>>>>>>>>>>>>>>>    //Move (CM_ExecuteCmd(Self,CMD_PROPERTIES,0)) to iRet
87989>>>>>>>>>>>>>>>>>    //Send Info_Box "Start configuration screen for editor component"
87989>>>>>>>>>>>>>>>>>    //Send PopupEditorSettingsDialog Self
87989>>>>>>>>>>>>>>>>>  End_Procedure
87990>>>>>>>>>>>>>>>>>
87990>>>>>>>>>>>>>>>>>End_Class
87991>>>>>>>>>>>>>>>>>
87991>>>>>>>>>>>>>>>>>Define CM_NewFileName   For "Untitled"  // sometimes ver useful.
87991>>>>>>>>>>>>>>>Use Messagebox2.dg
Including file: MessageBox2.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MessageBox2.dg)
87991>>>>>>>>>>>>>>>>>Use Windows.pkg
87991>>>>>>>>>>>>>>>>>Use msgbox.pkg
87991>>>>>>>>>>>>>>>>>Use DTFUNC.PKG
Including file: DTFUNC.PKG    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\DTFUNC.PKG)
87991>>>>>>>>>>>>>>>>>>>// external function call used in Procedure DoStartDocument
87991>>>>>>>>>>>>>>>>>>>External_Function ShellExecute "ShellExecuteA" shell32.dll ;    Handle hWnd ;    String lpOperation ;    String lpFile ;    String lpParameters ;    String lpDirectory ;    Dword iShowCmd Returns Handle
87992>>>>>>>>>>>>>>>>>>>
87992>>>>>>>>>>>>>>>>>>>// this will perform an operation on a file (e.g. open) with the application
87992>>>>>>>>>>>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
87992>>>>>>>>>>>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
87992>>>>>>>>>>>>>>>>>>>
87992>>>>>>>>>>>>>>>>>>>Procedure DoStartDocument Global String sOperation String sDocument
87994>>>>>>>>>>>>>>>>>>>    Handle hInstance hWnd
87994>>>>>>>>>>>>>>>>>>>    Get Window_Handle To hWnd
87995>>>>>>>>>>>>>>>>>>>    Move (ShellExecute (hWnd, sOperation, (Trim (sDocument)), '', '', 1)) To hInstance
87996>>>>>>>>>>>>>>>>>>>End_Procedure
87997>>>>>>>>>>>>>>>>>>>
87997>>>>>>>>>>>>>>>>>>>Function ParseString String sString String sSeparator Returns Integer
88000>>>>>>>>>>>>>>>>>>>    Integer iCnt p hoRetVal
88000>>>>>>>>>>>>>>>>>>>    String sTemp
88000>>>>>>>>>>>>>>>>>>>
88000>>>>>>>>>>>>>>>>>>>    Object oArray is an Array
88002>>>>>>>>>>>>>>>>>>>        Move Self to hoRetVal
88003>>>>>>>>>>>>>>>>>>>    End_Object
88004>>>>>>>>>>>>>>>>>>>
88004>>>>>>>>>>>>>>>>>>>    Move (Trim(sString)+sSeparator) to sString
88005>>>>>>>>>>>>>>>>>>>    While (sString<>'')
88009>>>>>>>>>>>>>>>>>>>        Move (Pos(sSeparator,sString)) to p
88010>>>>>>>>>>>>>>>>>>>        Move (Left(sString,p-1)) to sTemp
88011>>>>>>>>>>>>>>>>>>>        Get item_count of hoRetVal to iCnt
88012>>>>>>>>>>>>>>>>>>>        Set Value of hoRetVal Item iCnt to sTemp
88013>>>>>>>>>>>>>>>>>>>        Move (Mid(sString,Length(sString),p+1)) to sString
88014>>>>>>>>>>>>>>>>>>>    Loop
88015>>>>>>>>>>>>>>>>>>>>
88015>>>>>>>>>>>>>>>>>>>
88015>>>>>>>>>>>>>>>>>>>    Function_Return hoRetVal
88016>>>>>>>>>>>>>>>>>>>End_Function
88017>>>>>>>>>>>>>>>>>>>
88017>>>>>>>>>>>>>>>>>>>Function ParseString2 Global String sStr String sDelim Returns String[]
88019>>>>>>>>>>>>>>>>>>>    String[] sRetVal
88020>>>>>>>>>>>>>>>>>>>    Integer i
88020>>>>>>>>>>>>>>>>>>>
88020>>>>>>>>>>>>>>>>>>>    If (Right(sStr,1)<>sDelim) Begin
88022>>>>>>>>>>>>>>>>>>>        Move (sStr+sDelim) to sStr
88023>>>>>>>>>>>>>>>>>>>    End
88023>>>>>>>>>>>>>>>>>>>>
88023>>>>>>>>>>>>>>>>>>>    Repeat
88023>>>>>>>>>>>>>>>>>>>>
88023>>>>>>>>>>>>>>>>>>>        Move (Left(sStr,Pos(sDelim,sStr)-1)) to sRetVal[i]
88024>>>>>>>>>>>>>>>>>>>        Add 1 to i
88025>>>>>>>>>>>>>>>>>>>        Move (Mid(sStr,Length(sStr),Pos(sDelim,sStr)+1)) to sStr
88026>>>>>>>>>>>>>>>>>>>    Until (sStr='')
88028>>>>>>>>>>>>>>>>>>>    Function_Return sRetVal
88029>>>>>>>>>>>>>>>>>>>End_Function
88030>>>>>>>>>>>>>>>>>>>
88030>>>>>>>>>>>>>>>>>>>Function ParseString3 Global String sStr String sDelim String sGroup Returns String[]
88032>>>>>>>>>>>>>>>>>>>    String[] sRetVal
88033>>>>>>>>>>>>>>>>>>>    Integer i p
88033>>>>>>>>>>>>>>>>>>>
88033>>>>>>>>>>>>>>>>>>>    If (Right(sStr,1)<>sDelim) Begin
88035>>>>>>>>>>>>>>>>>>>        Move (sStr+sDelim) to sStr
88036>>>>>>>>>>>>>>>>>>>    End
88036>>>>>>>>>>>>>>>>>>>>
88036>>>>>>>>>>>>>>>>>>>    Repeat
88036>>>>>>>>>>>>>>>>>>>>
88036>>>>>>>>>>>>>>>>>>>        If (Left(sStr,1)=sGroup) Begin
88038>>>>>>>>>>>>>>>>>>>            Move (Pos(sGroup,sStr,2)) to p
88039>>>>>>>>>>>>>>>>>>>            If (p=0) Begin
88041>>>>>>>>>>>>>>>>>>>                Move (Length(sStr)) to p
88042>>>>>>>>>>>>>>>>>>>            End
88042>>>>>>>>>>>>>>>>>>>>
88042>>>>>>>>>>>>>>>>>>>            Move (Mid(sStr,p-2,2)) to sRetVal[i]
88043>>>>>>>>>>>>>>>>>>>            Add 1 to i
88044>>>>>>>>>>>>>>>>>>>            Move (Mid(sStr,Length(sStr),p+2)) to sStr
88045>>>>>>>>>>>>>>>>>>>        End
88045>>>>>>>>>>>>>>>>>>>>
88045>>>>>>>>>>>>>>>>>>>        Else Begin
88046>>>>>>>>>>>>>>>>>>>            Move (Left(sStr,Pos(sDelim,sStr)-1)) to sRetVal[i]
88047>>>>>>>>>>>>>>>>>>>            Add 1 to i
88048>>>>>>>>>>>>>>>>>>>            Move (Mid(sStr,Length(sStr),Pos(sDelim,sStr)+1)) to sStr
88049>>>>>>>>>>>>>>>>>>>        End
88049>>>>>>>>>>>>>>>>>>>>
88049>>>>>>>>>>>>>>>>>>>    Until (sStr='')
88051>>>>>>>>>>>>>>>>>>>    Function_Return sRetVal
88052>>>>>>>>>>>>>>>>>>>End_Function
88053>>>>>>>>>>>>>>>>>Use MessageboxLanguage.pkg
Including file: MessageboxLanguage.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MessageboxLanguage.pkg)
88053>>>>>>>>>>>>>>>>>>>Use LanguageText.pkg
88053>>>>>>>>>>>>>>>>>>>
88053>>>>>>>>>>>>>>>>>>>
88053>>>>>>>>>>>>>>>>>>>
88053>>>>>>>>>>>>>>>>>Use Dftimer.pkg
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dftimer.pkg)
88053>>>>>>>>>>>>>>>>>>>Use LanguageText.pkg
88053>>>>>>>>>>>>>>>>>>>Use Windows.pkg
88053>>>>>>>>>>>>>>>>>>>Use WinUser.pkg
88053>>>>>>>>>>>>>>>>>>>
88053>>>>>>>>>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
88054>>>>>>>>>>>>>>>>>>>
88054>>>>>>>>>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
88055>>>>>>>>>>>>>>>>>>>
88055>>>>>>>>>>>>>>>>>>>// This global integer holds the ID of the object
88055>>>>>>>>>>>>>>>>>>>// that manages all timers.
88055>>>>>>>>>>>>>>>>>>>Integer giTimerManager
88055>>>>>>>>>>>>>>>>>>>
88055>>>>>>>>>>>>>>>>>>>// This class is used to store the object IDs
88055>>>>>>>>>>>>>>>>>>>// of the active timer objects. It augments
88055>>>>>>>>>>>>>>>>>>>// the Destroy_Object procedure to notify
88055>>>>>>>>>>>>>>>>>>>// the DFTimerManager to kill all its active
88055>>>>>>>>>>>>>>>>>>>// timers.
88055>>>>>>>>>>>>>>>>>>>// NOTE: This class looks very much like the
88055>>>>>>>>>>>>>>>>>>>// Set class. I didn't want to use Set because
88055>>>>>>>>>>>>>>>>>>>// Remove_Element shifts items which I don't
88055>>>>>>>>>>>>>>>>>>>// want to happen because item numbers are used
88055>>>>>>>>>>>>>>>>>>>// as timerIDs.
88055>>>>>>>>>>>>>>>>>>>
88055>>>>>>>>>>>>>>>>>>>Class TimersArray is an Array
88056>>>>>>>>>>>>>>>>>>>    
88056>>>>>>>>>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
88058>>>>>>>>>>>>>>>>>>>        Integer iMax
88058>>>>>>>>>>>>>>>>>>>        Integer iItem
88058>>>>>>>>>>>>>>>>>>>        Integer iValue
88058>>>>>>>>>>>>>>>>>>>        Get Item_count to iMax
88059>>>>>>>>>>>>>>>>>>>        Decrement iMax
88060>>>>>>>>>>>>>>>>>>>        For iItem from 1 to iMax
88066>>>>>>>>>>>>>>>>>>>>
88066>>>>>>>>>>>>>>>>>>>            Get Integer_Value iItem to iValue
88067>>>>>>>>>>>>>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
88070>>>>>>>>>>>>>>>>>>>        Loop
88071>>>>>>>>>>>>>>>>>>>>
88071>>>>>>>>>>>>>>>>>>>        Function_Return -1
88072>>>>>>>>>>>>>>>>>>>    End_Function
88073>>>>>>>>>>>>>>>>>>>    
88073>>>>>>>>>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
88075>>>>>>>>>>>>>>>>>>>        Integer iItem
88075>>>>>>>>>>>>>>>>>>>        Get Find_Object iObj to iItem
88076>>>>>>>>>>>>>>>>>>>        If (iItem < 0) Begin
88078>>>>>>>>>>>>>>>>>>>            Get Find_Object 0 to iItem
88079>>>>>>>>>>>>>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
88082>>>>>>>>>>>>>>>>>>>        End
88082>>>>>>>>>>>>>>>>>>>>
88082>>>>>>>>>>>>>>>>>>>        Set Array_Value iItem to iObj
88083>>>>>>>>>>>>>>>>>>>        Procedure_Return iItem
88084>>>>>>>>>>>>>>>>>>>    End_Procedure
88085>>>>>>>>>>>>>>>>>>>    
88085>>>>>>>>>>>>>>>>>>>    Procedure Remove_Object Integer iObj
88087>>>>>>>>>>>>>>>>>>>        Integer iItem
88087>>>>>>>>>>>>>>>>>>>        Get Find_Object iObj to iItem
88088>>>>>>>>>>>>>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
88091>>>>>>>>>>>>>>>>>>>    End_Procedure
88092>>>>>>>>>>>>>>>>>>>    
88092>>>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
88094>>>>>>>>>>>>>>>>>>>        Delegate Send Kill_All_Timers
88096>>>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
88098>>>>>>>>>>>>>>>>>>>    End_Procedure
88099>>>>>>>>>>>>>>>>>>>    
88099>>>>>>>>>>>>>>>>>>>End_Class
88100>>>>>>>>>>>>>>>>>>>
88100>>>>>>>>>>>>>>>>>>>// This class is the actual timer manager
88100>>>>>>>>>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
88100>>>>>>>>>>>>>>>>>>>// has been send. This message needs two arguments. The first
88100>>>>>>>>>>>>>>>>>>>// is the objectID of the object to receive the timer event,
88100>>>>>>>>>>>>>>>>>>>// and the second is state. The object which ID has been passed,
88100>>>>>>>>>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
88100>>>>>>>>>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
88100>>>>>>>>>>>>>>>>>>>// timer event occurs.
88100>>>>>>>>>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
88100>>>>>>>>>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
88100>>>>>>>>>>>>>>>>>>>// is the itemnumber of the object in the array.
88100>>>>>>>>>>>>>>>>>>>//
88100>>>>>>>>>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
88101>>>>>>>>>>>>>>>>>>>    
88101>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88103>>>>>>>>>>>>>>>>>>>        
88103>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88105>>>>>>>>>>>>>>>>>>>        
88105>>>>>>>>>>>>>>>>>>>        Set Visible_State to False
88106>>>>>>>>>>>>>>>>>>>        
88106>>>>>>>>>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
88107>>>>>>>>>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
88108>>>>>>>>>>>>>>>>>>>        
88108>>>>>>>>>>>>>>>>>>>        Object TimersArray is a TimersArray
88110>>>>>>>>>>>>>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
88111>>>>>>>>>>>>>>>>>>>        End_Object
88112>>>>>>>>>>>>>>>>>>>        
88112>>>>>>>>>>>>>>>>>>>        Move Self to giTimerManager
88113>>>>>>>>>>>>>>>>>>>        
88113>>>>>>>>>>>>>>>>>>>    End_Procedure
88114>>>>>>>>>>>>>>>>>>>    
88114>>>>>>>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
88116>>>>>>>>>>>>>>>>>>>        Integer iTimerID
88116>>>>>>>>>>>>>>>>>>>        Integer iTimeout
88116>>>>>>>>>>>>>>>>>>>        Integer iResult
88116>>>>>>>>>>>>>>>>>>>        Integer iSet
88116>>>>>>>>>>>>>>>>>>>        DWord   nResult
88116>>>>>>>>>>>>>>>>>>>        Handle  hWnd
88116>>>>>>>>>>>>>>>>>>>        
88116>>>>>>>>>>>>>>>>>>>        // Get the handle of this object
88116>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
88117>>>>>>>>>>>>>>>>>>>        If (not(hWnd)) Begin
88119>>>>>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
88120>>>>>>>>>>>>>>>>>>>>
88120>>>>>>>>>>>>>>>>>>>            Procedure_Return
88121>>>>>>>>>>>>>>>>>>>        End
88121>>>>>>>>>>>>>>>>>>>>
88121>>>>>>>>>>>>>>>>>>>        
88121>>>>>>>>>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
88121>>>>>>>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
88124>>>>>>>>>>>>>>>>>>>        
88124>>>>>>>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
88125>>>>>>>>>>>>>>>>>>>        
88125>>>>>>>>>>>>>>>>>>>        If (iSet) Begin
88127>>>>>>>>>>>>>>>>>>>            
88127>>>>>>>>>>>>>>>>>>>            // Let's create or modify a timer
88127>>>>>>>>>>>>>>>>>>>            If iState Begin
88129>>>>>>>>>>>>>>>>>>>                
88129>>>>>>>>>>>>>>>>>>>                // Get the exising to new TimerID
88129>>>>>>>>>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
88130>>>>>>>>>>>>>>>>>>>                
88130>>>>>>>>>>>>>>>>>>>                // Set/Modify the timer
88130>>>>>>>>>>>>>>>>>>>                Get Timeout of iObj to iTimeout
88131>>>>>>>>>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
88132>>>>>>>>>>>>>>>>>>>                If not iResult Begin
88134>>>>>>>>>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
88135>>>>>>>>>>>>>>>>>>>>
88135>>>>>>>>>>>>>>>>>>>                    Procedure_Return
88136>>>>>>>>>>>>>>>>>>>                End
88136>>>>>>>>>>>>>>>>>>>>
88136>>>>>>>>>>>>>>>>>>>                
88136>>>>>>>>>>>>>>>>>>>            End
88136>>>>>>>>>>>>>>>>>>>>
88136>>>>>>>>>>>>>>>>>>>            
88136>>>>>>>>>>>>>>>>>>>            // Let's kill an existing timer
88136>>>>>>>>>>>>>>>>>>>            Else Begin
88137>>>>>>>>>>>>>>>>>>>                
88137>>>>>>>>>>>>>>>>>>>                // Look up the object in the set
88137>>>>>>>>>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
88138>>>>>>>>>>>>>>>>>>>                
88138>>>>>>>>>>>>>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
88141>>>>>>>>>>>>>>>>>>>                
88141>>>>>>>>>>>>>>>>>>>                // Kill the timer
88141>>>>>>>>>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
88142>>>>>>>>>>>>>>>>>>>                If not iResult Begin
88144>>>>>>>>>>>>>>>>>>>                    Move (GetLastError()) to nResult
88145>>>>>>>>>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
88146>>>>>>>>>>>>>>>>>>>>
88146>>>>>>>>>>>>>>>>>>>                    Procedure_Return
88147>>>>>>>>>>>>>>>>>>>                End
88147>>>>>>>>>>>>>>>>>>>>
88147>>>>>>>>>>>>>>>>>>>                
88147>>>>>>>>>>>>>>>>>>>                // Remove the objectID
88147>>>>>>>>>>>>>>>>>>>                Send Remove_Object to iSet iObj
88148>>>>>>>>>>>>>>>>>>>            End
88148>>>>>>>>>>>>>>>>>>>>
88148>>>>>>>>>>>>>>>>>>>        End
88148>>>>>>>>>>>>>>>>>>>>
88148>>>>>>>>>>>>>>>>>>>    End_Procedure
88149>>>>>>>>>>>>>>>>>>>    
88149>>>>>>>>>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
88151>>>>>>>>>>>>>>>>>>>        Integer iResult
88151>>>>>>>>>>>>>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
88152>>>>>>>>>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
88153>>>>>>>>>>>>>>>>>>>    End_Function
88154>>>>>>>>>>>>>>>>>>>    
88154>>>>>>>>>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
88154>>>>>>>>>>>>>>>>>>>    Procedure Kill_All_Timers
88156>>>>>>>>>>>>>>>>>>>        Integer iMax
88156>>>>>>>>>>>>>>>>>>>        Integer iSet
88156>>>>>>>>>>>>>>>>>>>        Integer iItem
88156>>>>>>>>>>>>>>>>>>>        Integer iObj
88156>>>>>>>>>>>>>>>>>>>        Integer iResult
88156>>>>>>>>>>>>>>>>>>>        Handle  hWnd
88156>>>>>>>>>>>>>>>>>>>        
88156>>>>>>>>>>>>>>>>>>>        // Get the handle of this object
88156>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
88157>>>>>>>>>>>>>>>>>>>        If (not(hWnd)) Begin
88159>>>>>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
88160>>>>>>>>>>>>>>>>>>>>
88160>>>>>>>>>>>>>>>>>>>            Procedure_Return
88161>>>>>>>>>>>>>>>>>>>        End
88161>>>>>>>>>>>>>>>>>>>>
88161>>>>>>>>>>>>>>>>>>>        
88161>>>>>>>>>>>>>>>>>>>        // If the window handle is no longer valid, we
88161>>>>>>>>>>>>>>>>>>>        // leave this procedure. This can happen when the
88161>>>>>>>>>>>>>>>>>>>        // program is begin aborted using Exit_Application
88161>>>>>>>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
88164>>>>>>>>>>>>>>>>>>>        
88164>>>>>>>>>>>>>>>>>>>        // Scan the set and kill all known timers
88164>>>>>>>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
88165>>>>>>>>>>>>>>>>>>>        If (iSet) Begin
88167>>>>>>>>>>>>>>>>>>>            Get Item_Count of iSet to iMax
88168>>>>>>>>>>>>>>>>>>>            Decrement iMax
88169>>>>>>>>>>>>>>>>>>>            For iItem from 1 to iMax
88175>>>>>>>>>>>>>>>>>>>>
88175>>>>>>>>>>>>>>>>>>>                Get Integer_Value of iSet iItem to iObj
88176>>>>>>>>>>>>>>>>>>>                If iObj Begin
88178>>>>>>>>>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
88179>>>>>>>>>>>>>>>>>>>                    Set Array_Value of iSet iItem to 0
88180>>>>>>>>>>>>>>>>>>>                End
88180>>>>>>>>>>>>>>>>>>>>
88180>>>>>>>>>>>>>>>>>>>            Loop
88181>>>>>>>>>>>>>>>>>>>>
88181>>>>>>>>>>>>>>>>>>>        End
88181>>>>>>>>>>>>>>>>>>>>
88181>>>>>>>>>>>>>>>>>>>        
88181>>>>>>>>>>>>>>>>>>>    End_Procedure
88182>>>>>>>>>>>>>>>>>>>    
88182>>>>>>>>>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
88184>>>>>>>>>>>>>>>>>>>        Integer iObj
88184>>>>>>>>>>>>>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
88185>>>>>>>>>>>>>>>>>>>        If not iObj Begin
88187>>>>>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
88188>>>>>>>>>>>>>>>>>>>>
88188>>>>>>>>>>>>>>>>>>>            Procedure_Return
88189>>>>>>>>>>>>>>>>>>>        End
88189>>>>>>>>>>>>>>>>>>>>
88189>>>>>>>>>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
88190>>>>>>>>>>>>>>>>>>>    End_Procedure
88191>>>>>>>>>>>>>>>>>>>    
88191>>>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
88193>>>>>>>>>>>>>>>>>>>        Send Kill_All_Timers
88194>>>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
88196>>>>>>>>>>>>>>>>>>>        Move 0 to giTimerManager
88197>>>>>>>>>>>>>>>>>>>    End_Procedure
88198>>>>>>>>>>>>>>>>>>>    
88198>>>>>>>>>>>>>>>>>>>End_Class
88199>>>>>>>>>>>>>>>>>>>
88199>>>>>>>>>>>>>>>>>>>
88199>>>>>>>>>>>>>>>>>>>
88199>>>>>>>>>>>>>>>>>>>
88199>>>>>>>>>>>>>>>>>>>// This class acts as a container for the
88199>>>>>>>>>>>>>>>>>>>// timer manager object. This is needed because
88199>>>>>>>>>>>>>>>>>>>// A DFTimerManager object created directly at the
88199>>>>>>>>>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
88199>>>>>>>>>>>>>>>>>>>// need to create a Windoows timer. By placing
88199>>>>>>>>>>>>>>>>>>>// this non-visual container around the timer
88199>>>>>>>>>>>>>>>>>>>// manager, it does get a Window_Handle.
88199>>>>>>>>>>>>>>>>>>>// The procedure End_Construct_Object has been
88199>>>>>>>>>>>>>>>>>>>// augmented to create a window and also
88199>>>>>>>>>>>>>>>>>>>// automatically page all children, which will
88199>>>>>>>>>>>>>>>>>>>// be the timer manager.
88199>>>>>>>>>>>>>>>>>>>//
88199>>>>>>>>>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
88200>>>>>>>>>>>>>>>>>>>    
88200>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88202>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88204>>>>>>>>>>>>>>>>>>>        Set Visible_State to False
88205>>>>>>>>>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
88207>>>>>>>>>>>>>>>>>>>        End_Object
88208>>>>>>>>>>>>>>>>>>>    End_Procedure
88209>>>>>>>>>>>>>>>>>>>    
88209>>>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
88211>>>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
88213>>>>>>>>>>>>>>>>>>>        Send Page_Object True
88214>>>>>>>>>>>>>>>>>>>        Broadcast Send Page_Object True
88216>>>>>>>>>>>>>>>>>>>    End_Procedure
88217>>>>>>>>>>>>>>>>>>>    
88217>>>>>>>>>>>>>>>>>>>End_Class
88218>>>>>>>>>>>>>>>>>>>
88218>>>>>>>>>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
88218>>>>>>>>>>>>>>>>>>>
88218>>>>>>>>>>>>>>>>>>>
88218>>>>>>>>>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
88218>>>>>>>>>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
88218>>>>>>>>>>>>>>>>>>>Class DFTimer is a Textbox
88219>>>>>>>>>>>>>>>>>>>    
88219>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88221>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88223>>>>>>>>>>>>>>>>>>>        
88223>>>>>>>>>>>>>>>>>>>        // Make sure this object never appears
88223>>>>>>>>>>>>>>>>>>>        Set Visible_State to False
88224>>>>>>>>>>>>>>>>>>>        
88224>>>>>>>>>>>>>>>>>>>        Property Integer Private.Timeout    1000
88225>>>>>>>>>>>>>>>>>>>        
88225>>>>>>>>>>>>>>>>>>>        Property Integer Timer_Message      0
88226>>>>>>>>>>>>>>>>>>>        Property Integer Timer_Object       0
88227>>>>>>>>>>>>>>>>>>>        Property Integer Auto_Start_State   True
88228>>>>>>>>>>>>>>>>>>>        Property Integer Auto_Stop_State    True
88229>>>>>>>>>>>>>>>>>>>    End_Procedure
88230>>>>>>>>>>>>>>>>>>>    
88230>>>>>>>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
88232>>>>>>>>>>>>>>>>>>>        Integer iObj
88232>>>>>>>>>>>>>>>>>>>        Move Self to iObj
88233>>>>>>>>>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
88236>>>>>>>>>>>>>>>>>>>    End_Procedure
88237>>>>>>>>>>>>>>>>>>>    
88237>>>>>>>>>>>>>>>>>>>    Function Timer_Active_State Returns Integer
88239>>>>>>>>>>>>>>>>>>>        Integer iState
88239>>>>>>>>>>>>>>>>>>>        Integer iObj
88239>>>>>>>>>>>>>>>>>>>        Move Self to iObj
88240>>>>>>>>>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
88243>>>>>>>>>>>>>>>>>>>        Function_Return iState
88244>>>>>>>>>>>>>>>>>>>    End_Function
88245>>>>>>>>>>>>>>>>>>>    
88245>>>>>>>>>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
88247>>>>>>>>>>>>>>>>>>>        Integer iActive
88247>>>>>>>>>>>>>>>>>>>        Set Private.Timeout to iTimeout
88248>>>>>>>>>>>>>>>>>>>        Get Timer_Active_State to iActive
88249>>>>>>>>>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to True
88252>>>>>>>>>>>>>>>>>>>    End_Procedure
88253>>>>>>>>>>>>>>>>>>>    
88253>>>>>>>>>>>>>>>>>>>    Function Timeout Returns Integer
88255>>>>>>>>>>>>>>>>>>>        Integer iTimeout
88255>>>>>>>>>>>>>>>>>>>        Get Private.Timeout to iTimeout
88256>>>>>>>>>>>>>>>>>>>        Function_Return iTimeout
88257>>>>>>>>>>>>>>>>>>>    End_Function
88258>>>>>>>>>>>>>>>>>>>    
88258>>>>>>>>>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
88260>>>>>>>>>>>>>>>>>>>        Integer iMsg
88260>>>>>>>>>>>>>>>>>>>        Integer iObj
88260>>>>>>>>>>>>>>>>>>>        Get Timer_Message to iMsg
88261>>>>>>>>>>>>>>>>>>>        If (iMsg) Begin
88263>>>>>>>>>>>>>>>>>>>            Get Timer_Object  to iObj
88264>>>>>>>>>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
88267>>>>>>>>>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
88269>>>>>>>>>>>>>>>>>>>        End
88269>>>>>>>>>>>>>>>>>>>>
88269>>>>>>>>>>>>>>>>>>>    End_Procedure
88270>>>>>>>>>>>>>>>>>>>    
88270>>>>>>>>>>>>>>>>>>>    // Augmented to Auto_Start a timer
88270>>>>>>>>>>>>>>>>>>>    //
88270>>>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer iState
88272>>>>>>>>>>>>>>>>>>>        Forward Send Page_Object iState
88274>>>>>>>>>>>>>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
88277>>>>>>>>>>>>>>>>>>>    End_Procedure
88278>>>>>>>>>>>>>>>>>>>    
88278>>>>>>>>>>>>>>>>>>>    // Augmented to Auto_Stop a timer
88278>>>>>>>>>>>>>>>>>>>    //
88278>>>>>>>>>>>>>>>>>>>    Procedure Page_Delete
88280>>>>>>>>>>>>>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
88283>>>>>>>>>>>>>>>>>>>        Forward Send Page_Delete
88285>>>>>>>>>>>>>>>>>>>    End_Procedure
88286>>>>>>>>>>>>>>>>>>>    
88286>>>>>>>>>>>>>>>>>>>    // Augmented to stop the timer
88286>>>>>>>>>>>>>>>>>>>    //
88286>>>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
88288>>>>>>>>>>>>>>>>>>>        Set Timer_Active_State to False
88289>>>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
88291>>>>>>>>>>>>>>>>>>>    End_Procedure
88292>>>>>>>>>>>>>>>>>>>    
88292>>>>>>>>>>>>>>>>>>>End_Class
88293>>>>>>>>>>>>>>>>>>>
88293>>>>>>>>>>>>>>>>>>>//
88293>>>>>>>>>>>>>>>>>>>// This was moved into a method so it can be reliable created
88293>>>>>>>>>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
88293>>>>>>>>>>>>>>>>>>>//
88293>>>>>>>>>>>>>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
88295>>>>>>>>>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
88295>>>>>>>>>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
88297>>>>>>>>>>>>>>>>>>>    End_Object
88298>>>>>>>>>>>>>>>>>>>End_Procedure
88299>>>>>>>>>>>>>>>>>>>
88299>>>>>>>>>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
88300>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>Use monitor.pkg
Including file: monitor.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\monitor.pkg)
88300>>>>>>>>>>>>>>>>>>>Use Set.pkg
88300>>>>>>>>>>>>>>>>>>>//typedef struct tagPOINT {
88300>>>>>>>>>>>>>>>>>>>//  LONG x;
88300>>>>>>>>>>>>>>>>>>>//  LONG y;
88300>>>>>>>>>>>>>>>>>>>//} POINT, *PPOINT;
88300>>>>>>>>>>>>>>>>>>>//
88300>>>>>>>>>>>>>>>>>>>//typedef Struct _RECT {
88300>>>>>>>>>>>>>>>>>>>//  LONG left;
88300>>>>>>>>>>>>>>>>>>>//  LONG top;
88300>>>>>>>>>>>>>>>>>>>//  LONG right;
88300>>>>>>>>>>>>>>>>>>>//  LONG bottom;
88300>>>>>>>>>>>>>>>>>>>//} RECT, *PRECT;
88300>>>>>>>>>>>>>>>>>>>//
88300>>>>>>>>>>>>>>>>>>>//typedef Struct tagMONITORINFO {
88300>>>>>>>>>>>>>>>>>>>//  DWORD  cbSize;
88300>>>>>>>>>>>>>>>>>>>//  RECT   rcMonitor;
88300>>>>>>>>>>>>>>>>>>>//  RECT   rcWork;
88300>>>>>>>>>>>>>>>>>>>//  DWord  dwFlags;
88300>>>>>>>>>>>>>>>>>>>//} MONITORINFO, *LPMONITORINFO;
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>Struct tRECT
88300>>>>>>>>>>>>>>>>>>>  Integer Left
88300>>>>>>>>>>>>>>>>>>>  Integer Top
88300>>>>>>>>>>>>>>>>>>>  Integer Right
88300>>>>>>>>>>>>>>>>>>>  Integer Bottom
88300>>>>>>>>>>>>>>>>>>>End_Struct
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>Struct tMONITORINFO
88300>>>>>>>>>>>>>>>>>>>  DWord cbSize
88300>>>>>>>>>>>>>>>>>>>  tRECT rcMonitor
88300>>>>>>>>>>>>>>>>>>>  tRECT rcMonitor
88300>>>>>>>>>>>>>>>>>>>  tRECT rcWork
88300>>>>>>>>>>>>>>>>>>>  tRECT rcWork
88300>>>>>>>>>>>>>>>>>>>  DWord dwFlags
88300>>>>>>>>>>>>>>>>>>>End_Struct
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>//HMONITOR MonitorFromWindow(
88300>>>>>>>>>>>>>>>>>>>//  HWND hwnd,       // handle to a window
88300>>>>>>>>>>>>>>>>>>>//  DWord dwFlags    // determine return value
88300>>>>>>>>>>>>>>>>>>>//);
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>//BOOL GetMonitorInfo(
88300>>>>>>>>>>>>>>>>>>>//  HMONITOR hMonitor,  // handle to display monitor
88300>>>>>>>>>>>>>>>>>>>//  LPMONITORINFO lpmi  // display monitor information
88300>>>>>>>>>>>>>>>>>>>//);
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>//#define MONITOR_DEFAULTTONULL       0x00000000
88300>>>>>>>>>>>>>>>>>>>//#define MONITOR_DEFAULTTOPRIMARY    0x00000001
88300>>>>>>>>>>>>>>>>>>>//#define MONITOR_DEFAULTTONEAREST    0x00000002
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>Define MONITOR_DEFAULTONNULL For 0
88300>>>>>>>>>>>>>>>>>>>Define MONITOR_DEFAULTONPRIMARY For 1
88300>>>>>>>>>>>>>>>>>>>Define MONITOR_DEFAULTONNEAREST For 2
88300>>>>>>>>>>>>>>>>>>>
88300>>>>>>>>>>>>>>>>>>>// a set that contains a list of monitor handles
88300>>>>>>>>>>>>>>>>>>>Object oMonitorHandles is a Set
88302>>>>>>>>>>>>>>>>>>>End_Object
88303>>>>>>>>>>>>>>>>>>>
88303>>>>>>>>>>>>>>>>>>>// "brute force" monitor enumeration:
88303>>>>>>>>>>>>>>>>>>>//  we can't do a callback function so the Windows API is out
88303>>>>>>>>>>>>>>>>>>>//  this Procedure will determine what monitors (if any) are
88303>>>>>>>>>>>>>>>>>>>//  immediately adjacent to the primary monitor and store the
88303>>>>>>>>>>>>>>>>>>>//  monitor handles in a set for use later
88303>>>>>>>>>>>>>>>>>>>
88303>>>>>>>>>>>>>>>>>>>Procedure EnumerateMonitors
88306>>>>>>>>>>>>>>>>>>>  tMONITORINFO tPrimary
88306>>>>>>>>>>>>>>>>>>>  tMONITORINFO tPrimary
88306>>>>>>>>>>>>>>>>>>>  Handle hMonitor
88306>>>>>>>>>>>>>>>>>>>  Boolean bRetVal
88306>>>>>>>>>>>>>>>>>>>
88306>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(0,0,MONITOR_DEFAULTONPRIMARY)) To hMonitor
88307>>>>>>>>>>>>>>>>>>>  Set Value Of oMonitorHandles Item 0 To hMonitor
88308>>>>>>>>>>>>>>>>>>>  Move (SizeofType(tMONITORINFO)) To tPrimary.cbSize
88309>>>>>>>>>>>>>>>>>>>  Move (GetMonitorInfo(hMonitor, AddressOf(tPrimary))) To bRetVal
88310>>>>>>>>>>>>>>>>>>>  //
88310>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(-1,0,MONITOR_DEFAULTONNULL)) To hMonitor
88311>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88314>>>>>>>>>>>>>>>>>>>  //
88314>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(-1,-1,MONITOR_DEFAULTONNULL)) To hMonitor
88315>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88318>>>>>>>>>>>>>>>>>>>  //
88318>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(0,-1,MONITOR_DEFAULTONNULL)) To hMonitor
88319>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88322>>>>>>>>>>>>>>>>>>>  //
88322>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right+1,-1,MONITOR_DEFAULTONNULL)) To hMonitor
88323>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88326>>>>>>>>>>>>>>>>>>>  //
88326>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right+1,0,MONITOR_DEFAULTONNULL)) To hMonitor
88327>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88330>>>>>>>>>>>>>>>>>>>  //
88330>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right+1,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88331>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88334>>>>>>>>>>>>>>>>>>>  //
88334>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88335>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88338>>>>>>>>>>>>>>>>>>>  //
88338>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(0,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88339>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88342>>>>>>>>>>>>>>>>>>>  //
88342>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(-1,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88343>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88346>>>>>>>>>>>>>>>>>>>End_Procedure
88347>>>>>>>>>>>>>>>>>>>
88347>>>>>>>>>>>>>>>>>>>Send EnumerateMonitors
88348>>>>>>>>>>>>>>>>>>>
88348>>>>>>>>>>>>>>>>>>>Procedure DisplayMonitorInfo Handle hWnd
88351>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
88351>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
88351>>>>>>>>>>>>>>>>>>>  Boolean bRetVal
88351>>>>>>>>>>>>>>>>>>>  Integer i iCnt iRetVal
88351>>>>>>>>>>>>>>>>>>>  Handle hMonitor
88351>>>>>>>>>>>>>>>>>>>
88351>>>>>>>>>>>>>>>>>>>  Get item_count Of oMonitorHandles To iCnt
88352>>>>>>>>>>>>>>>>>>>  If (iCnt=0) ;    Send EnumerateMonitors
88355>>>>>>>>>>>>>>>>>>>  //
88355>>>>>>>>>>>>>>>>>>>  Get item_count Of oMonitorHandles To iCnt
88356>>>>>>>>>>>>>>>>>>>  For i From 0 To (iCnt-1)
88362>>>>>>>>>>>>>>>>>>>>
88362>>>>>>>>>>>>>>>>>>>    Get Value Of oMonitorHandles Item i To hMonitor
88363>>>>>>>>>>>>>>>>>>>    Move (SizeofType(tMONITORINFO)) To tMonInfo.cbSize
88364>>>>>>>>>>>>>>>>>>>    Move (GetMonitorInfo(hMonitor, AddressOf(tMonInfo))) To bRetVal
88365>>>>>>>>>>>>>>>>>>>    If (bRetVal=0) ;      Get ShowLastError To iRetVal
88368>>>>>>>>>>>>>>>>>>>    Showln "Monitor #" i
88371>>>>>>>>>>>>>>>>>>>    Showln "Top Left: " tMonInfo.rcMonitor.Left ',' tMonInfo.rcMonitor.Top
88376>>>>>>>>>>>>>>>>>>>    Showln "Bottom Right: " tMonInfo.rcMonitor.Right ',' tMonInfo.rcMonitor.Bottom
88381>>>>>>>>>>>>>>>>>>>    Showln "Resolution: " (tMonInfo.rcMonitor.Right-tMonInfo.rcMonitor.Left) 'x' (tMonInfo.rcMonitor.Bottom-tMonInfo.rcMonitor.Top)
88386>>>>>>>>>>>>>>>>>>>    Showln
88387>>>>>>>>>>>>>>>>>>>  Loop
88388>>>>>>>>>>>>>>>>>>>>
88388>>>>>>>>>>>>>>>>>>>End_Procedure
88389>>>>>>>>>>>>>>>>>>>
88389>>>>>>>>>>>>>>>>>>>Function MonitorInfo Handle hWnd Returns tMONITORINFO
88392>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
88392>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
88392>>>>>>>>>>>>>>>>>>>  Boolean bRetVal
88392>>>>>>>>>>>>>>>>>>>  Integer iRetVal
88392>>>>>>>>>>>>>>>>>>>  Handle hMonitor
88392>>>>>>>>>>>>>>>>>>>
88392>>>>>>>>>>>>>>>>>>>  Move (SizeofType(tMONITORINFO)) To tMonInfo.cbSize
88393>>>>>>>>>>>>>>>>>>>  Move (MonitorFromWindow(hWnd,MONITOR_DEFAULTONPRIMARY)) To hMonitor
88394>>>>>>>>>>>>>>>>>>>  Move (GetMonitorInfo(hMonitor, AddressOf(tMonInfo))) To bRetVal
88395>>>>>>>>>>>>>>>>>>>  If (bRetVal=0) ;    Get ShowLastError To iRetVal
88398>>>>>>>>>>>>>>>>>>>  Function_Return tMonInfo
88399>>>>>>>>>>>>>>>>>>>End_Function
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>//
88400>>>>>>>>>>>>>>>>>// "Message Box 2.02"
88400>>>>>>>>>>>>>>>>>//  Copyright 2014 Davidian Busines Services
88400>>>>>>>>>>>>>>>>>//  Free for use for any purpose, provided as-is
88400>>>>>>>>>>>>>>>>>//  Report bugs/send enhancements to:  matthewd@datatechag.com
88400>>>>>>>>>>>>>>>>>//
88400>>>>>>>>>>>>>>>>>// new and improved message box replacement "2.0"
88400>>>>>>>>>>>>>>>>>//  1. Works with new font system in 17.1 (not hardcoded to Microsoft Sans Serif)
88400>>>>>>>>>>>>>>>>>//  2. Backwards compatible with old 15.0 Message Box replacement, including Help button and Checkbox control
88400>>>>>>>>>>>>>>>>>//  3. Can be used via struct interface to define more elaborate message boxes, including support for:
88400>>>>>>>>>>>>>>>>>//      A. Multiple sections of text
88400>>>>>>>>>>>>>>>>>//      B. font size/bold/italic/underline formatting of text in each section (17.0+)
88400>>>>>>>>>>>>>>>>>//      C. Multiple checkboxes
88400>>>>>>>>>>>>>>>>>//      D. mini-icons (16x16 bitmaps)
88400>>>>>>>>>>>>>>>>>//      E. Buttons other than Ok/Cancel/Yes/No/Abort/Retry/Fail
88400>>>>>>>>>>>>>>>>>//  4. Message boxes can appear on the "correct" monitor in multi-monitor setups
88400>>>>>>>>>>>>>>>>>//
88400>>>>>>>>>>>>>>>>>// Changes since release 2.0:
88400>>>>>>>>>>>>>>>>>//  added global handle to refer to message box object:  ghoMessageBox
88400>>>>>>>>>>>>>>>>>//  add property of message box object pbDisplayOnFocusMonitor to display the dialog on the same monitor as focus object
88400>>>>>>>>>>>>>>>>>//  added hoMonitor member (a handle to a VDF object, not a monitor handle)
88400>>>>>>>>>>>>>>>>>//  implemented code for hMonitor member (this is a handle to a monitor)
88400>>>>>>>>>>>>>>>>>//  fixed StandardButtons function (wasn't returning a value, renamed to mbButtons)
88400>>>>>>>>>>>>>>>>>//  added helper messages to return messagebox and message structs
88400>>>>>>>>>>>>>>>>>//  MessageBoxLanguage.pkg with Dutch labels contributed by Pieter van Dieran, labels
88400>>>>>>>>>>>>>>>>>//      for additional languages should be added to this file.
88400>>>>>>>>>>>>>>>>>//  added property for button width, piButtonWidth, this is initialized to the
88400>>>>>>>>>>>>>>>>>//      constant C_mbButtonWidth defined in MessageBoxLanguage.pkg
88400>>>>>>>>>>>>>>>>>//
88400>>>>>>>>>>>>>>>>>// Possible future enhancements:
88400>>>>>>>>>>>>>>>>>//  Set maximum width and wrap text accordingly (defined in struct member .iWidth)
88400>>>>>>>>>>>>>>>>>//  Input dialog (for dates/strings/numbers/etc)
88400>>>>>>>>>>>>>>>>>//  Add other predefined bitmaps
88400>>>>>>>>>>>>>>>>>//
88400>>>>>>>>>>>>>>>>>// Changes since release 2.01:
88400>>>>>>>>>>>>>>>>>//  added a timeout property to automatically close the message box by setting the iTimeout member of the
88400>>>>>>>>>>>>>>>>>//  tmbMessageBox struct to the number of milliseconds to keep the message dialog open
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>Define MBR_CHECKED             For   |CI$01000000
88400>>>>>>>>>>>>>>>>>Define MBR_CHECKED2            For   |CI$02000000
88400>>>>>>>>>>>>>>>>>Define MBR_MASK                For   |CI$0000000F
88400>>>>>>>>>>>>>>>>>Define MB_ICONDOWNLOAD         For   |CI$00000050
88400>>>>>>>>>>>>>>>>>Define MB_DEFBUTTONMASK        For   |CI$00000F00
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>Struct tmbMessageText
88400>>>>>>>>>>>>>>>>>    String sMessage
88400>>>>>>>>>>>>>>>>>    String sBitmap              // "mini-icon" 16x16 icon that will appear to the left of the text section
88400>>>>>>>>>>>>>>>>>    Integer iIndent
88400>>>>>>>>>>>>>>>>>    Integer iFontPointHeight
88400>>>>>>>>>>>>>>>>>    Boolean bBold               // bold text
88400>>>>>>>>>>>>>>>>>    Boolean bItalic             // italic
88400>>>>>>>>>>>>>>>>>    Boolean bUnderline          // underline
88400>>>>>>>>>>>>>>>>>    Boolean bCheckbox           // if true, this message is a checkbox
88400>>>>>>>>>>>>>>>>>    Boolean bChecked            // default state of checkbox
88400>>>>>>>>>>>>>>>>>    Integer iSpaceAfter         // spacing after this message
88400>>>>>>>>>>>>>>>>>    Handle _hoCheckbox          // private, handle to checkbox object
88400>>>>>>>>>>>>>>>>>End_Struct
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>Struct tmbButtons
88400>>>>>>>>>>>>>>>>>    String sLabel               // label (not required if a predefined button)
88400>>>>>>>>>>>>>>>>>    Boolean bDefault            // set to true for one button
88400>>>>>>>>>>>>>>>>>    Integer iType               // return value when this button is clicked, MBR_Yes, MBR_OK, MBR_No, etc.
88400>>>>>>>>>>>>>>>>>    Handle hoObject
88400>>>>>>>>>>>>>>>>>End_Struct
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>Struct tmbMessageBox
88400>>>>>>>>>>>>>>>>>    String sTitle               // title of message box
88400>>>>>>>>>>>>>>>>>    String sBitmap              // bitmap to display
88400>>>>>>>>>>>>>>>>>    Integer iBitmap             // predefined bitmaps to display
88400>>>>>>>>>>>>>>>>>    Integer iWidth              // override calculated width
88400>>>>>>>>>>>>>>>>>    Integer iHelp               // help id (if zero, no help button)
88400>>>>>>>>>>>>>>>>>    String sHtmlHelpTopic       //
88400>>>>>>>>>>>>>>>>>    Handle hoMonitor            // a handle to a dataflex object; the message box will appear on the same monitor as this object
88400>>>>>>>>>>>>>>>>>    Handle hMonitor             // a monitor handle
88400>>>>>>>>>>>>>>>>>    tmbMessageText[] Message    // 1 or more messages/checkboxes to display
88400>>>>>>>>>>>>>>>>>    tmbMessageText[] Message    // 1 or more messages/checkboxes to display
88400>>>>>>>>>>>>>>>>>    tmbButtons[] Button         // 1 or more buttons
88400>>>>>>>>>>>>>>>>>    tmbButtons[] Button         // 1 or more buttons
88400>>>>>>>>>>>>>>>>>    Integer iRetVal             // return value of button clicked
88400>>>>>>>>>>>>>>>>>    Integer iTimeout            // milliseconds until automatic timeout
88400>>>>>>>>>>>>>>>>>    Integer iButtonWidth        // width of buttons (overrides piButtonWidth if set)
88400>>>>>>>>>>>>>>>>>    Integer iButtonHeight
88400>>>>>>>>>>>>>>>>>End_Struct
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>Struct tmbDeferredCheckbox
88400>>>>>>>>>>>>>>>>>    String sLabel               // label for checkbox
88400>>>>>>>>>>>>>>>>>    Integer iY                  // vertical pos for checkbox
88400>>>>>>>>>>>>>>>>>    Integer iMsgIndex           // index into tmbMessageText array for source of checkbox
88400>>>>>>>>>>>>>>>>>End_Struct
88400>>>>>>>>>>>>>>>>>
88400>>>>>>>>>>>>>>>>>Class cmbTextBox is a TextBox
88401>>>>>>>>>>>>>>>>>// dummy message
88401>>>>>>>>>>>>>>>>>    Procedure Set CurrentButtonState Integer iState
88403>>>>>>>>>>>>>>>>>    End_Procedure
88404>>>>>>>>>>>>>>>>>End_Class
88405>>>>>>>>>>>>>>>>>
88405>>>>>>>>>>>>>>>>>Register_Function piButtonWidth Returns Integer
88405>>>>>>>>>>>>>>>>>Register_Function piButtonHeight Returns Integer
88405>>>>>>>>>>>>>>>>>
88405>>>>>>>>>>>>>>>>>Class cmbButton is a Button
88406>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88408>>>>>>>>>>>>>>>>>        Property Integer piButtonType_private        0
88409>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88411>>>>>>>>>>>>>>>>>        Set Size to (piButtonHeight(Self)) (piButtonWidth(Self))
88412>>>>>>>>>>>>>>>>>        Set Default_State to False
88413>>>>>>>>>>>>>>>>>        On_Key Key_Right_Arrow Send previous
88414>>>>>>>>>>>>>>>>>        On_Key Key_Left_Arrow Send next
88415>>>>>>>>>>>>>>>>>    End_Procedure
88416>>>>>>>>>>>>>>>>>
88416>>>>>>>>>>>>>>>>>    Procedure Set piButtonType Integer iType
88418>>>>>>>>>>>>>>>>>        Set piButtonType_private to iType
88419>>>>>>>>>>>>>>>>>        If (iType=-1) Begin
88421>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxHelp    // -1
88422>>>>>>>>>>>>>>>>>        End
88422>>>>>>>>>>>>>>>>>>
88422>>>>>>>>>>>>>>>>>        If (iType=MBR_Ok) Begin
88424>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxOk      // 1
88425>>>>>>>>>>>>>>>>>        End
88425>>>>>>>>>>>>>>>>>>
88425>>>>>>>>>>>>>>>>>        If (iType=MBR_Cancel) Begin
88427>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxCancel  // 2
88428>>>>>>>>>>>>>>>>>        End
88428>>>>>>>>>>>>>>>>>>
88428>>>>>>>>>>>>>>>>>        If (iType=MBR_Abort) Begin
88430>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxAbort   // 3
88431>>>>>>>>>>>>>>>>>        End
88431>>>>>>>>>>>>>>>>>>
88431>>>>>>>>>>>>>>>>>        If (iType=MBR_Retry) Begin
88433>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxRetry   // 4
88434>>>>>>>>>>>>>>>>>        End
88434>>>>>>>>>>>>>>>>>>
88434>>>>>>>>>>>>>>>>>        If (iType=MBR_Ignore) Begin
88436>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxIgnore  // 5
88437>>>>>>>>>>>>>>>>>        End
88437>>>>>>>>>>>>>>>>>>
88437>>>>>>>>>>>>>>>>>        If (iType=MBR_Yes) Begin
88439>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxYes     // 6
88440>>>>>>>>>>>>>>>>>        End
88440>>>>>>>>>>>>>>>>>>
88440>>>>>>>>>>>>>>>>>        If (iType=MBR_No) Begin
88442>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxNo      // 7
88443>>>>>>>>>>>>>>>>>        End
88443>>>>>>>>>>>>>>>>>>
88443>>>>>>>>>>>>>>>>>    End_Procedure
88444>>>>>>>>>>>>>>>>>
88444>>>>>>>>>>>>>>>>>    Procedure OnClick
88446>>>>>>>>>>>>>>>>>        If (piButtonType_private(Self)>=0) Begin
88448>>>>>>>>>>>>>>>>>            Delegate Send OnClick (piButtonType_private(Self))
88450>>>>>>>>>>>>>>>>>        End
88450>>>>>>>>>>>>>>>>>>
88450>>>>>>>>>>>>>>>>>        Else Begin
88451>>>>>>>>>>>>>>>>>            Send help HELP_CONTEXT_ID
88452>>>>>>>>>>>>>>>>>        End
88452>>>>>>>>>>>>>>>>>>
88452>>>>>>>>>>>>>>>>>    End_Procedure
88453>>>>>>>>>>>>>>>>>End_Class
88454>>>>>>>>>>>>>>>>>
88454>>>>>>>>>>>>>>>>>Class cMessageBox_mixin is a cObject
88455>>>>>>>>>>>>>>>>>    Procedure Define_cMessageBox_mixin
88457>>>>>>>>>>>>>>>>>        Property Integer piButtonPressed 0
88458>>>>>>>>>>>>>>>>>        Property Boolean pbDisplayOnFocusMonitor True
88459>>>>>>>>>>>>>>>>>        Property Integer piButtonWidth C_mbButtonWidth
88460>>>>>>>>>>>>>>>>>        Property Integer piButtonHeight C_mbButtonHeight
88461>>>>>>>>>>>>>>>>>        Property String psMessageText ''
88462>>>>>>>>>>>>>>>>>
88462>>>>>>>>>>>>>>>>>        Set Size to 89 211
88463>>>>>>>>>>>>>>>>>        Set Label to C_$MessageBox
88464>>>>>>>>>>>>>>>>>        Set Location to 2 2
88465>>>>>>>>>>>>>>>>>        Set Border_Style to Border_Normal
88466>>>>>>>>>>>>>>>>>        Set Sysmenu_Icon to False
88467>>>>>>>>>>>>>>>>>        Set Minimize_Icon to False
88468>>>>>>>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_TOOLWINDOW False
88469>>>>>>>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
88470>>>>>>>>>>>>>>>>>
88470>>>>>>>>>>>>>>>>>        Object oBitmap is a BitmapContainer
88472>>>>>>>>>>>>>>>>>            Set Size to 20 22
88473>>>>>>>>>>>>>>>>>            Set guiSize to 48 48
88474>>>>>>>>>>>>>>>>>            Set Location to 6 6
88475>>>>>>>>>>>>>>>>>            Set Bitmap to "info256.bmp/3d"
88476>>>>>>>>>>>>>>>>>            Set Border_Style to Border_None
88477>>>>>>>>>>>>>>>>>        End_Object
88478>>>>>>>>>>>>>>>>>    End_Procedure
88479>>>>>>>>>>>>>>>>>
88479>>>>>>>>>>>>>>>>>    Procedure Set CurrentButtonState Integer iState
88481>>>>>>>>>>>>>>>>>    End_Procedure
88482>>>>>>>>>>>>>>>>>
88482>>>>>>>>>>>>>>>>>    // handle positioning: if pbDisplayOnFocusMonitor is true, get the focus object and place the
88482>>>>>>>>>>>>>>>>>    //  message box on the same monitor that the focus object is on, OTHERWISE
88482>>>>>>>>>>>>>>>>>    // hoMonitor may contain a Handle to a VDF Object, and put the message on the same monitor as it, OR
88482>>>>>>>>>>>>>>>>>    //  if hMonitor <> 0, use that monitor handle (to force messages to appear on secondary display(s)
88482>>>>>>>>>>>>>>>>>    //  since the primary display should always be zero)
88482>>>>>>>>>>>>>>>>>    // otherwise, use the CENTER_ON_SCREEN locate mode.
88482>>>>>>>>>>>>>>>>>    Procedure DeterminePosition tmbMessageBox Msg
88484>>>>>>>>>>>>>>>>>        tMONITORINFO MonitorInfo
88484>>>>>>>>>>>>>>>>>        tMONITORINFO MonitorInfo
88484>>>>>>>>>>>>>>>>>        Integer iSize iLoc iY iX
88484>>>>>>>>>>>>>>>>>        Handle hMonitor
88484>>>>>>>>>>>>>>>>>        Integer iRetVal
88484>>>>>>>>>>>>>>>>>
88484>>>>>>>>>>>>>>>>>        If (pbDisplayOnFocusMonitor(Self) and Msg.hoMonitor=0) Begin
88486>>>>>>>>>>>>>>>>>            Get Focus to Msg.hoMonitor
88487>>>>>>>>>>>>>>>>>        End
88487>>>>>>>>>>>>>>>>>>
88487>>>>>>>>>>>>>>>>>        //
88487>>>>>>>>>>>>>>>>>        If (Msg.hoMonitor=0 and Msg.hMonitor=0) Begin
88489>>>>>>>>>>>>>>>>>            Set Locate_Mode to CENTER_ON_SCREEN
88490>>>>>>>>>>>>>>>>>        End
88490>>>>>>>>>>>>>>>>>>
88490>>>>>>>>>>>>>>>>>        Else Begin
88491>>>>>>>>>>>>>>>>>            If (Msg.hMonitor=0) Begin
88493>>>>>>>>>>>>>>>>>                Get Absolute_GuiOrigin of Msg.hoMonitor to iLoc
88494>>>>>>>>>>>>>>>>>                Move (MonitorFromPoint(Low(iLoc),Hi(iLoc),MONITOR_DEFAULTONPRIMARY)) to hMonitor
88495>>>>>>>>>>>>>>>>>            End
88495>>>>>>>>>>>>>>>>>>
88495>>>>>>>>>>>>>>>>>            Else Begin
88496>>>>>>>>>>>>>>>>>                Move Msg.hMonitor to hMonitor
88497>>>>>>>>>>>>>>>>>            End
88497>>>>>>>>>>>>>>>>>>
88497>>>>>>>>>>>>>>>>>            //
88497>>>>>>>>>>>>>>>>>            Move (SizeofType(tMONITORINFO)) to MonitorInfo.cbSize
88498>>>>>>>>>>>>>>>>>            Move (GetMonitorInfo(hMonitor, AddressOf(MonitorInfo))) to iRetVal
88499>>>>>>>>>>>>>>>>>            If (iRetVal) Begin
88501>>>>>>>>>>>>>>>>>                Set Locate_Mode to NO_LOCATE
88502>>>>>>>>>>>>>>>>>                Get GUISize to iSize
88503>>>>>>>>>>>>>>>>>                Move MonitorInfo.rcMonitor.Top to iY
88504>>>>>>>>>>>>>>>>>                Add ((MonitorInfo.rcMonitor.bottom-monitorInfo.rcMonitor.Top)/2) to iY
88505>>>>>>>>>>>>>>>>>                Subtract (Hi(iSize)/2) From iY
88506>>>>>>>>>>>>>>>>>                Move MonitorInfo.rcMonitor.Left to iX
88507>>>>>>>>>>>>>>>>>                Add ((monitorInfo.rcMonitor.right-MonitorInfo.rcMonitor.Left)/2) to iX
88508>>>>>>>>>>>>>>>>>                Subtract (Low(iSize)/2) From iX
88509>>>>>>>>>>>>>>>>>                Set GuiLocation to iY iX
88510>>>>>>>>>>>>>>>>>                Send Adjust_Logicals
88511>>>>>>>>>>>>>>>>>            End
88511>>>>>>>>>>>>>>>>>>
88511>>>>>>>>>>>>>>>>>        End
88511>>>>>>>>>>>>>>>>>>
88511>>>>>>>>>>>>>>>>>    End_Procedure
88512>>>>>>>>>>>>>>>>>
88512>>>>>>>>>>>>>>>>>    Procedure ShowMessageBox tmbMessageBox ByRef Msg
88514>>>>>>>>>>>>>>>>>        Integer i
88514>>>>>>>>>>>>>>>>>        Handle[] hoObject
88515>>>>>>>>>>>>>>>>>
88515>>>>>>>>>>>>>>>>>        Get ConstructMessageBox (&Msg) to hoObject
88516>>>>>>>>>>>>>>>>>        // Nils. This is no longer needed for more recent DataFlex versions.
88516>>>>>>>>>>>>>>>>>        // In fact, not commenting it out will/can display the message box on the
88516>>>>>>>>>>>>>>>>>        // wrong screen/monitor.
88516>>>>>>>>>>>>>>>>>        Send DeterminePosition Msg
88517>>>>>>>>>>>>>>>>>        Send Popup
88518>>>>>>>>>>>>>>>>>        // get any checkbox values back into the struct
88518>>>>>>>>>>>>>>>>>        For i From 0 to (SizeOfArray(Msg.Message)-1)
88524>>>>>>>>>>>>>>>>>>
88524>>>>>>>>>>>>>>>>>            If (Msg.Message[i]._hoCheckbox<>0) Begin
88526>>>>>>>>>>>>>>>>>                Get checked_state of Msg.Message[i]._hoCheckbox to Msg.Message[i].bChecked
88527>>>>>>>>>>>>>>>>>            End
88527>>>>>>>>>>>>>>>>>>
88527>>>>>>>>>>>>>>>>>        Loop
88528>>>>>>>>>>>>>>>>>>
88528>>>>>>>>>>>>>>>>>        // resize the array in case a timer message was added (struct can then be re-used, not sure you would want to do that, but just in case)
88528>>>>>>>>>>>>>>>>>        If (Msg.iTimeout<>0) Begin
88530>>>>>>>>>>>>>>>>>            Move (ResizeArray(Msg.Message,SizeOfArray(Msg.Message)-1)) to Msg.Message
88531>>>>>>>>>>>>>>>>>        End
88531>>>>>>>>>>>>>>>>>>
88531>>>>>>>>>>>>>>>>>        // destroy objects
88531>>>>>>>>>>>>>>>>>        For i From 0 to (Sizeofarray(hoObject)-1)
88537>>>>>>>>>>>>>>>>>>
88537>>>>>>>>>>>>>>>>>            Send Destroy to hoObject[i]
88538>>>>>>>>>>>>>>>>>        Loop
88539>>>>>>>>>>>>>>>>>>
88539>>>>>>>>>>>>>>>>>        Get piButtonPressed to Msg.iRetVal
88540>>>>>>>>>>>>>>>>>    End_Procedure
88541>>>>>>>>>>>>>>>>>
88541>>>>>>>>>>>>>>>>>    // these are the default bitmaps
88541>>>>>>>>>>>>>>>>>    Function IconBitmap Integer iIcon Returns String
88543>>>>>>>>>>>>>>>>>        Move (iIcon iand MB_ICONMASK) to iIcon
88544>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONEXCLAMATION) Begin
88546>>>>>>>>>>>>>>>>>            Function_Return "warning256.bmp/3d"
88547>>>>>>>>>>>>>>>>>        End
88547>>>>>>>>>>>>>>>>>>
88547>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONHAND) Begin
88549>>>>>>>>>>>>>>>>>            Function_Return "stop256.bmp/3d"
88550>>>>>>>>>>>>>>>>>        End
88550>>>>>>>>>>>>>>>>>>
88550>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONASTERISK) Begin
88552>>>>>>>>>>>>>>>>>            Function_Return "info256.bmp/3d"
88553>>>>>>>>>>>>>>>>>        End
88553>>>>>>>>>>>>>>>>>>
88553>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONQUESTION) Begin
88555>>>>>>>>>>>>>>>>>            Function_Return "question256.bmp/3d"
88556>>>>>>>>>>>>>>>>>        End
88556>>>>>>>>>>>>>>>>>>
88556>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONDOWNLOAD) Begin
88558>>>>>>>>>>>>>>>>>            Function_Return "download256.bmp/3d"
88559>>>>>>>>>>>>>>>>>        End
88559>>>>>>>>>>>>>>>>>>
88559>>>>>>>>>>>>>>>>>    End_Function
88560>>>>>>>>>>>>>>>>>
88560>>>>>>>>>>>>>>>>>    Function ConstructMessageBox tmbMessageBox ByRef Msg Returns Handle[]
88562>>>>>>>>>>>>>>>>>        Boolean bButtonRepos
88562>>>>>>>>>>>>>>>>>        String sCR sText sLabel sMessageText
88562>>>>>>>>>>>>>>>>>        String[] sMsg
88563>>>>>>>>>>>>>>>>>        Integer i iCnt iLine yPos xPos iSize iMaxLength iWidth iFirstButton iFirstxPos iCheckboxCnt xMaxPos xMsgPos iLineWidth iFirstButtonIndex iButtonSpan
88563>>>>>>>>>>>>>>>>>        Integer iLoc
88563>>>>>>>>>>>>>>>>>        Handle hoObj hoFirstButton
88563>>>>>>>>>>>>>>>>>        Handle[] hoObject
88564>>>>>>>>>>>>>>>>>        tmbDeferredCheckbox[] Checkboxes
88564>>>>>>>>>>>>>>>>>        tmbDeferredCheckbox[] Checkboxes
88565>>>>>>>>>>>>>>>>>
88565>>>>>>>>>>>>>>>>>        Set private.Current_Action_button to 0
88566>>>>>>>>>>>>>>>>>        Set piButtonPressed to 0        // possible if Alt+F4 used
88567>>>>>>>>>>>>>>>>>
88567>>>>>>>>>>>>>>>>>        Move (Character(13)) to sCR
88568>>>>>>>>>>>>>>>>>        Move 8 to yPos
88569>>>>>>>>>>>>>>>>>        If (Msg.sBitmap<>'') Begin
88571>>>>>>>>>>>>>>>>>            Set Bitmap of oBitmap to Msg.sBitmap
88572>>>>>>>>>>>>>>>>>        End
88572>>>>>>>>>>>>>>>>>>
88572>>>>>>>>>>>>>>>>>        Else If (Msg.ibitmap<>0) Begin
88575>>>>>>>>>>>>>>>>>            Set Bitmap of oBitmap to (IconBitmap(Self,Msg.iBitmap))
88576>>>>>>>>>>>>>>>>>        End
88576>>>>>>>>>>>>>>>>>>
88576>>>>>>>>>>>>>>>>>        Set Label to Msg.sTitle
88577>>>>>>>>>>>>>>>>>        Set piButtonWidth to C_mbButtonWidth
88578>>>>>>>>>>>>>>>>>        Set piButtonHeight to C_mbButtonHeight
88579>>>>>>>>>>>>>>>>>        If (Msg.iButtonWidth<>0) Begin
88581>>>>>>>>>>>>>>>>>            Set piButtonWidth to Msg.iButtonWidth
88582>>>>>>>>>>>>>>>>>        End
88582>>>>>>>>>>>>>>>>>>
88582>>>>>>>>>>>>>>>>>        If (Msg.iButtonHeight<>0) Begin
88584>>>>>>>>>>>>>>>>>            Set piButtonHeight to Msg.iButtonHeight
88585>>>>>>>>>>>>>>>>>        End
88585>>>>>>>>>>>>>>>>>>
88585>>>>>>>>>>>>>>>>>        //
88585>>>>>>>>>>>>>>>>>        // following loop creates textbox/checkbox/bitmap objects for each line of the each message
88585>>>>>>>>>>>>>>>>>        //  line breaks should be indicated with the \n sequence
88585>>>>>>>>>>>>>>>>>        If (Msg.iTimeout<>0) Begin
88587>>>>>>>>>>>>>>>>>            Move (SizeOfArray(Msg.Message)) to i
88588>>>>>>>>>>>>>>>>>            Move (SFormat(C_$MessageBoxTimeout,String(Msg.iTimeout/1000))) to Msg.Message[i].sMessage
88589>>>>>>>>>>>>>>>>>        End
88589>>>>>>>>>>>>>>>>>>
88589>>>>>>>>>>>>>>>>>        For i From 0 to (SizeofArray(Msg.Message)-1)
88595>>>>>>>>>>>>>>>>>>
88595>>>>>>>>>>>>>>>>>            Move (Msg.Message[i].sMessage+"\n") to sText
88596>>>>>>>>>>>>>>>>>            Move (Replaces("\n",sText,sCR)) to sText
88597>>>>>>>>>>>>>>>>>            If (msg.message[i].bCheckbox=False) Begin
88599>>>>>>>>>>>>>>>>>                Move (sMessageText+sText) to sMessageText   // for copy Ctrl+C
88600>>>>>>>>>>>>>>>>>            End
88600>>>>>>>>>>>>>>>>>>
88600>>>>>>>>>>>>>>>>>
88600>>>>>>>>>>>>>>>>>            Move (ParseString2(sText,sCR)) to sMsg
88601>>>>>>>>>>>>>>>>>            //
88601>>>>>>>>>>>>>>>>>            Move 40 to xMsgPos
88602>>>>>>>>>>>>>>>>>            For iLine From 0 to (SizeOfArray(sMsg)-1)
88608>>>>>>>>>>>>>>>>>>
88608>>>>>>>>>>>>>>>>>                If (Msg.Message[i].bCheckbox and iLine=0) Begin
88610>>>>>>>>>>>>>>>>>                // checkbox object creation is deferred until after the buttons to set up the desired tab order
88610>>>>>>>>>>>>>>>>>                // we remember the settings here and use them after the buttons are created
88610>>>>>>>>>>>>>>>>>                    Move (SizeOfArray(Checkboxes)) to iCheckboxCnt
88611>>>>>>>>>>>>>>>>>                    Move sMsg[iLine] to Checkboxes[iCheckboxCnt].sLabel
88612>>>>>>>>>>>>>>>>>                    Add 8 to yPos
88613>>>>>>>>>>>>>>>>>                    Move yPos to checkboxes[iCheckboxCnt].iY
88614>>>>>>>>>>>>>>>>>                    Move i to Checkboxes[iCheckboxCnt].iMsgIndex
88615>>>>>>>>>>>>>>>>>                    If (hoObj) Begin
88617>>>>>>>>>>>>>>>>>                        Get size of hoObj to iSize
88618>>>>>>>>>>>>>>>>>                    End
88618>>>>>>>>>>>>>>>>>>
88618>>>>>>>>>>>>>>>>>                    Move 0 to hoObj
88619>>>>>>>>>>>>>>>>>                    Add (Hi(iSize)) to yPos
88620>>>>>>>>>>>>>>>>>                End
88620>>>>>>>>>>>>>>>>>>
88620>>>>>>>>>>>>>>>>>                Else Begin
88621>>>>>>>>>>>>>>>>>                    If (Msg.Message[i].sBitmap<>'' and iLine=0) Begin
88623>>>>>>>>>>>>>>>>>                        Object oBitmap is a BitmapContainer
88625>>>>>>>>>>>>>>>>>                            Set GuiSize to 16 16
88626>>>>>>>>>>>>>>>>>                            Set Location to yPos xMsgPos
88627>>>>>>>>>>>>>>>>>                            Set Bitmap to Msg.Message[i].sBitmap
88628>>>>>>>>>>>>>>>>>                            Set Border_Style to Border_None
88629>>>>>>>>>>>>>>>>>                            Move Self to hoObj
88630>>>>>>>>>>>>>>>>>                        End_Object
88631>>>>>>>>>>>>>>>>>                        Send Add_Focus to hoObj Self
88632>>>>>>>>>>>>>>>>>                        Move hoObj to hoObject[SizeOfArray(hoObject)]
88633>>>>>>>>>>>>>>>>>                        Move 54 to xMsgPos
88634>>>>>>>>>>>>>>>>>                    End
88634>>>>>>>>>>>>>>>>>>
88634>>>>>>>>>>>>>>>>>                    // indent text box position for multi-line checkbox message
88634>>>>>>>>>>>>>>>>>                    If (Msg.Message[i].bCheckbox) Begin
88636>>>>>>>>>>>>>>>>>                        Move 50 to xMsgPos
88637>>>>>>>>>>>>>>>>>                    End
88637>>>>>>>>>>>>>>>>>>
88637>>>>>>>>>>>>>>>>>                    If (sMsg[iLine]<>'') Begin
88639>>>>>>>>>>>>>>>>>                        Object oTextBox is a cmbTextbox
88641>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].iFontPointHeight<>0) Begin
88643>>>>>>>>>>>>>>>>>                                Set FontPointHeight to Msg.Message[i].iFontPointHeight
88644>>>>>>>>>>>>>>>>>                            End
88644>>>>>>>>>>>>>>>>>>
88644>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].bBold) Begin
88646>>>>>>>>>>>>>>>>>                                Set FontWeight to 800
88647>>>>>>>>>>>>>>>>>                            End
88647>>>>>>>>>>>>>>>>>>
88647>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].bItalic) Begin
88649>>>>>>>>>>>>>>>>>                                Set FontItalics to True
88650>>>>>>>>>>>>>>>>>                            End
88650>>>>>>>>>>>>>>>>>>
88650>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].bUnderline) Begin
88652>>>>>>>>>>>>>>>>>                                Set FontUnderline to True
88653>>>>>>>>>>>>>>>>>                            End
88653>>>>>>>>>>>>>>>>>>
88653>>>>>>>>>>>>>>>>>                            Set Auto_Size_State to True
88654>>>>>>>>>>>>>>>>>                            Set Transparent_State to True
88655>>>>>>>>>>>>>>>>>                            Set Label to sMsg[iLine]
88656>>>>>>>>>>>>>>>>>                            Set Location to yPos (xMsgPos+Msg.Message[i].iIndent)
88657>>>>>>>>>>>>>>>>>                            Set Justification_Mode to jMode_Left
88658>>>>>>>>>>>>>>>>>                            Move Self to hoObj
88659>>>>>>>>>>>>>>>>>                            Get size of hoObj to iSize
88660>>>>>>>>>>>>>>>>>                            Add (hi(iSize)) to yPos
88661>>>>>>>>>>>>>>>>>                        End_Object
88662>>>>>>>>>>>>>>>>>                        Send Add_Focus to hoObj Self
88663>>>>>>>>>>>>>>>>>                    End
88663>>>>>>>>>>>>>>>>>>
88663>>>>>>>>>>>>>>>>>                    Else Begin
88664>>>>>>>>>>>>>>>>>                    // blank line, just increase yPos
88664>>>>>>>>>>>>>>>>>                        Add (Hi(iSize)) to yPos
88665>>>>>>>>>>>>>>>>>                        Move 0 to hoObj
88666>>>>>>>>>>>>>>>>>                    End
88666>>>>>>>>>>>>>>>>>>
88666>>>>>>>>>>>>>>>>>                End
88666>>>>>>>>>>>>>>>>>>
88666>>>>>>>>>>>>>>>>>                If (hoObj<>0) Begin
88668>>>>>>>>>>>>>>>>>                // store object in array for destruction later
88668>>>>>>>>>>>>>>>>>                    Move hoObj to hoObject[SizeOfArray(hoObject)]
88669>>>>>>>>>>>>>>>>>                    // determine longest element so we know how wide to make the dialog
88669>>>>>>>>>>>>>>>>>                    Move (Low(iSize)+If(Msg.Message[i].sBitmap<>'',14,0)) to iLineWidth
88670>>>>>>>>>>>>>>>>>                    If (iLineWidth>iMaxLength) Begin
88672>>>>>>>>>>>>>>>>>                        Move iLineWidth to iMaxLength
88673>>>>>>>>>>>>>>>>>                    End
88673>>>>>>>>>>>>>>>>>>
88673>>>>>>>>>>>>>>>>>                End
88673>>>>>>>>>>>>>>>>>>
88673>>>>>>>>>>>>>>>>>            Loop
88674>>>>>>>>>>>>>>>>>>
88674>>>>>>>>>>>>>>>>>            Add Msg.Message[i].iSpaceAfter to yPos
88675>>>>>>>>>>>>>>>>>        Loop
88676>>>>>>>>>>>>>>>>>>
88676>>>>>>>>>>>>>>>>>        Set psMessageText to sMessageText
88677>>>>>>>>>>>>>>>>>        Add 8 to yPos
88678>>>>>>>>>>>>>>>>>        //
88678>>>>>>>>>>>>>>>>>        // determine button horizontal positioning
88678>>>>>>>>>>>>>>>>>        Move (SizeOfArray(Msg.Button)) to iCnt
88679>>>>>>>>>>>>>>>>>        If (Msg.iHelp<>0 or Msg.sHtmlHelpTopic<>'') Begin
88681>>>>>>>>>>>>>>>>>            Add 1 to iCnt
88682>>>>>>>>>>>>>>>>>        End
88682>>>>>>>>>>>>>>>>>>
88682>>>>>>>>>>>>>>>>>        Move ((iCnt*piButtonWidth(Self))+((iCnt-1)*4)) to iWidth
88683>>>>>>>>>>>>>>>>>        If (iMaxLength<120) Begin
88685>>>>>>>>>>>>>>>>>            Move 120 to iMaxLength
88686>>>>>>>>>>>>>>>>>        End
88686>>>>>>>>>>>>>>>>>>
88686>>>>>>>>>>>>>>>>>        If (iWidth>=iMaxLength+80) Begin
88688>>>>>>>>>>>>>>>>>            Move (iWidth+20) to iMaxLength
88689>>>>>>>>>>>>>>>>>        End
88689>>>>>>>>>>>>>>>>>>
88689>>>>>>>>>>>>>>>>>        Move (((iMaxLength+80)-iWidth)/2) to xPos
88690>>>>>>>>>>>>>>>>>        Move xPos to iFirstxPos
88691>>>>>>>>>>>>>>>>>        //
88691>>>>>>>>>>>>>>>>>        For i From 0 to (SizeOfArray(Msg.Button)-1)
88697>>>>>>>>>>>>>>>>>>
88697>>>>>>>>>>>>>>>>>            If (Msg.Button[i].bDefault) Begin
88699>>>>>>>>>>>>>>>>>                Move i to iFirstButton
88700>>>>>>>>>>>>>>>>>                Move xPos to iFirstxPos
88701>>>>>>>>>>>>>>>>>            End
88701>>>>>>>>>>>>>>>>>>
88701>>>>>>>>>>>>>>>>>            Add (piButtonWidth(Self)+4) to xPos
88702>>>>>>>>>>>>>>>>>        End
88703>>>>>>>>>>>>>>>>>>
88703>>>>>>>>>>>>>>>>>
88703>>>>>>>>>>>>>>>>>        // check for minimum dialog height
88703>>>>>>>>>>>>>>>>>        If (yPos<50) Begin
88705>>>>>>>>>>>>>>>>>            Move 50 to yPos
88706>>>>>>>>>>>>>>>>>        End
88706>>>>>>>>>>>>>>>>>>
88706>>>>>>>>>>>>>>>>>        // create the buttons: default button first, then the rest in order
88706>>>>>>>>>>>>>>>>>        Move iFirstButton to i
88707>>>>>>>>>>>>>>>>>        Move iFirstxPos to xPos
88708>>>>>>>>>>>>>>>>>        Repeat
88708>>>>>>>>>>>>>>>>>>
88708>>>>>>>>>>>>>>>>>            Get Create (RefClass(cmbButton)) to hoObj
88709>>>>>>>>>>>>>>>>>            Set Label of hoObj to Msg.Button[i].sLabel
88710>>>>>>>>>>>>>>>>>            Set Location of hoObj to yPos xPos
88711>>>>>>>>>>>>>>>>>            Set piButtonType of hoObj to Msg.Button[i].iType
88712>>>>>>>>>>>>>>>>>            If (iFirstButtonIndex=0) Begin
88714>>>>>>>>>>>>>>>>>                Move (SizeOfArray(hoObject)) to iFirstButtonIndex
88715>>>>>>>>>>>>>>>>>            End
88715>>>>>>>>>>>>>>>>>>
88715>>>>>>>>>>>>>>>>>            Move hoObj to hoObject[SizeOfArray(hoObject)]
88716>>>>>>>>>>>>>>>>>            Move hoObj to Msg.Button[i].hoObject
88717>>>>>>>>>>>>>>>>>            If (hoFirstButton=0) Begin
88719>>>>>>>>>>>>>>>>>                Move hoObj to hoFirstButton
88720>>>>>>>>>>>>>>>>>            End
88720>>>>>>>>>>>>>>>>>>
88720>>>>>>>>>>>>>>>>>            If (Pos("&",Label(hoObj))>0) Begin
88722>>>>>>>>>>>>>>>>>                Send SetupAccelerator hoObj
88723>>>>>>>>>>>>>>>>>            End
88723>>>>>>>>>>>>>>>>>>
88723>>>>>>>>>>>>>>>>>            If (xMaxPos<xPos) Begin
88725>>>>>>>>>>>>>>>>>                Move xPos to xMaxPos
88726>>>>>>>>>>>>>>>>>            End
88726>>>>>>>>>>>>>>>>>>
88726>>>>>>>>>>>>>>>>>            Send Add_Focus to hoObj Self
88727>>>>>>>>>>>>>>>>>            Add 1 to i
88728>>>>>>>>>>>>>>>>>            If (i>SizeOfArray(Msg.Button)-1) Begin
88730>>>>>>>>>>>>>>>>>                Move 0 to i
88731>>>>>>>>>>>>>>>>>                Move (((iMaxLength+80)-iWidth)/2) to xPos
88732>>>>>>>>>>>>>>>>>            End
88732>>>>>>>>>>>>>>>>>>
88732>>>>>>>>>>>>>>>>>            Else Begin
88733>>>>>>>>>>>>>>>>>                Add (piButtonWidth(Self)+4) to xPos
88734>>>>>>>>>>>>>>>>>            End
88734>>>>>>>>>>>>>>>>>>
88734>>>>>>>>>>>>>>>>>            Add (piButtonWidth(Self)+4) to iButtonSpan
88735>>>>>>>>>>>>>>>>>        Until (i=iFirstButton)
88737>>>>>>>>>>>>>>>>>
88737>>>>>>>>>>>>>>>>>        If (Msg.iTimeout<>0) Begin
88739>>>>>>>>>>>>>>>>>            Get Create (RefClass(dfTimer)) to hoObj
88740>>>>>>>>>>>>>>>>>            Set Timeout of hoObj to Msg.itimeout
88741>>>>>>>>>>>>>>>>>            Set timer_object of hoObj to hoFirstButton
88742>>>>>>>>>>>>>>>>>            Set Timer_Active_State of hoObj to True
88743>>>>>>>>>>>>>>>>>            Set Timer_Message of hoObj to msg_keyaction
88744>>>>>>>>>>>>>>>>>            Move hoObj to hoObject[SizeOfArray(hoObject)]
88745>>>>>>>>>>>>>>>>>        End
88745>>>>>>>>>>>>>>>>>>
88745>>>>>>>>>>>>>>>>>
88745>>>>>>>>>>>>>>>>>        // if a help id was included, create the help button
88745>>>>>>>>>>>>>>>>>        If (msg.iHelp<>0 or Msg.sHtmlHelpTopic<>'') Begin
88747>>>>>>>>>>>>>>>>>            Object oButton is a cmbButton
88749>>>>>>>>>>>>>>>>>                Set piButtonType to -1
88750>>>>>>>>>>>>>>>>>                Set Location to yPos (xMaxPos+piButtonWidth(Self)+4)
88751>>>>>>>>>>>>>>>>>                Set Help_Id to Msg.iHelp
88752>>>>>>>>>>>>>>>>>                Set psHtmlHelpTopic to Msg.sHtmlHelpTopic
88753>>>>>>>>>>>>>>>>>                Move Self to hoObj
88754>>>>>>>>>>>>>>>>>                Move hoObj to hoObject[SizeOfArray(hoObject)]
88755>>>>>>>>>>>>>>>>>            End_Object
88756>>>>>>>>>>>>>>>>>            If (Pos("&",Label(hoObj))>0) Begin
88758>>>>>>>>>>>>>>>>>                Send SetupAccelerator hoObj
88759>>>>>>>>>>>>>>>>>            End
88759>>>>>>>>>>>>>>>>>>
88759>>>>>>>>>>>>>>>>>        End
88759>>>>>>>>>>>>>>>>>>
88759>>>>>>>>>>>>>>>>>
88759>>>>>>>>>>>>>>>>>        For i From 0 to (SizeOfArray(Checkboxes)-1)
88765>>>>>>>>>>>>>>>>>>
88765>>>>>>>>>>>>>>>>>            Object oCheckbox is a Checkbox
88767>>>>>>>>>>>>>>>>>                Set Auto_Size_State to True
88768>>>>>>>>>>>>>>>>>                // Set FontSize to 14 0
88768>>>>>>>>>>>>>>>>>                Set Label to Checkboxes[i].sLabel
88769>>>>>>>>>>>>>>>>>                Set Location to Checkboxes[i].iY 40
88770>>>>>>>>>>>>>>>>>                Move Self to hoObj
88771>>>>>>>>>>>>>>>>>                Move Self to Msg.Message[checkboxes[i].iMsgIndex]._hoCheckbox
88772>>>>>>>>>>>>>>>>>                Set Checked_State to Msg.Message[checkboxes[i].iMsgIndex].bChecked
88773>>>>>>>>>>>>>>>>>                Get Size to iSize
88774>>>>>>>>>>>>>>>>>                Move (Low(iSize)+If(Msg.Message[i].sBitmap<>'',14,0)) to iLineWidth
88775>>>>>>>>>>>>>>>>>                If (iLineWidth>iMaxLength) Begin
88777>>>>>>>>>>>>>>>>>                    Move iLineWidth to iMaxLength
88778>>>>>>>>>>>>>>>>>                    Move True to bButtonRepos
88779>>>>>>>>>>>>>>>>>                End
88779>>>>>>>>>>>>>>>>>>
88779>>>>>>>>>>>>>>>>>                On_Key Key_Right_Arrow Send previous
88780>>>>>>>>>>>>>>>>>                On_Key Key_Left_Arrow Send next
88781>>>>>>>>>>>>>>>>>            End_Object
88782>>>>>>>>>>>>>>>>>            Send Add_Focus to hoObj Self
88783>>>>>>>>>>>>>>>>>            Move hoObj to hoObject[SizeOfArray(hoObject)]
88784>>>>>>>>>>>>>>>>>        Loop
88785>>>>>>>>>>>>>>>>>>
88785>>>>>>>>>>>>>>>>>
88785>>>>>>>>>>>>>>>>>        // if iMaxLength has changed, reposition buttons
88785>>>>>>>>>>>>>>>>>        If (bButtonRepos) Begin
88787>>>>>>>>>>>>>>>>>            Move (((iMaxLength+80)-iButtonSpan)/2) to xPos
88788>>>>>>>>>>>>>>>>>            For i From 0 to (SizeOfArray(Msg.Button)-1)
88794>>>>>>>>>>>>>>>>>>
88794>>>>>>>>>>>>>>>>>                If (Msg.Button[i].bDefault) Begin
88796>>>>>>>>>>>>>>>>>                    Move i to iFirstButton
88797>>>>>>>>>>>>>>>>>                    Move xPos to iFirstxPos
88798>>>>>>>>>>>>>>>>>                End
88798>>>>>>>>>>>>>>>>>>
88798>>>>>>>>>>>>>>>>>                Add (piButtonWidth(Self)+4) to xPos
88799>>>>>>>>>>>>>>>>>            Loop
88800>>>>>>>>>>>>>>>>>>
88800>>>>>>>>>>>>>>>>>            Move iFirstButton to i
88801>>>>>>>>>>>>>>>>>            Move iFirstxPos to xPos
88802>>>>>>>>>>>>>>>>>            Repeat
88802>>>>>>>>>>>>>>>>>>
88802>>>>>>>>>>>>>>>>>                Get Location of Msg.Button[i].hoObject to iLoc
88803>>>>>>>>>>>>>>>>>                Get size of Msg.button[i].hoObject to iSize
88804>>>>>>>>>>>>>>>>>                Set Location of Msg.Button[i].hoObject to (Hi(iLoc)) xPos
88805>>>>>>>>>>>>>>>>>                Add 1 to i
88806>>>>>>>>>>>>>>>>>                If (i>SizeOfArray(Msg.Button)-1) Begin
88808>>>>>>>>>>>>>>>>>                    Move 0 to i
88809>>>>>>>>>>>>>>>>>                    Move (((iMaxLength+80)-iButtonSpan)/2) to xPos
88810>>>>>>>>>>>>>>>>>                End
88810>>>>>>>>>>>>>>>>>>
88810>>>>>>>>>>>>>>>>>                Else Begin
88811>>>>>>>>>>>>>>>>>                    Add (piButtonWidth(Self)+4) to xPos
88812>>>>>>>>>>>>>>>>>                End
88812>>>>>>>>>>>>>>>>>>
88812>>>>>>>>>>>>>>>>>            Until (i=iFirstButton)
88814>>>>>>>>>>>>>>>>>        End
88814>>>>>>>>>>>>>>>>>>
88814>>>>>>>>>>>>>>>>>
88814>>>>>>>>>>>>>>>>>        Set Size to (yPos+piButtonHeight(Self)+4) (If(Msg.iWidth<>0,Msg.iWidth,iMaxLength+80))
88815>>>>>>>>>>>>>>>>>
88815>>>>>>>>>>>>>>>>>        On_Key key_ctrl+Key_C Send CopyMessageText
88816>>>>>>>>>>>>>>>>>        Function_Return hoObject        // return an array of object IDs
88817>>>>>>>>>>>>>>>>>    End_Function
88818>>>>>>>>>>>>>>>>>
88818>>>>>>>>>>>>>>>>>    Procedure CopyMessageText
88820>>>>>>>>>>>>>>>>>        Direct_Output "clipboard:"
88821>>>>>>>>>>>>>>>>>        Writeln (psMessageText(Self))
88823>>>>>>>>>>>>>>>>>        Close_Output
88824>>>>>>>>>>>>>>>>>    End_Procedure
88825>>>>>>>>>>>>>>>>>
88825>>>>>>>>>>>>>>>>>    Procedure OnClick Integer iButton
88827>>>>>>>>>>>>>>>>>        Set piButtonPressed to iButton
88828>>>>>>>>>>>>>>>>>        Send stop_modal_ui
88829>>>>>>>>>>>>>>>>>    End_Procedure
88830>>>>>>>>>>>>>>>>>
88830>>>>>>>>>>>>>>>>>    Procedure SetupAccelerator Handle hoObj
88832>>>>>>>>>>>>>>>>>        String sLabel
88832>>>>>>>>>>>>>>>>>        Get Label of hoObj to sLabel
88833>>>>>>>>>>>>>>>>>        Move (Uppercase(Mid(sLabel,1,Pos("&",sLabel)+1))) to sLabel
88834>>>>>>>>>>>>>>>>>        If (sLabel="A") Begin
88836>>>>>>>>>>>>>>>>>            On_Key Key_A Send KeyAction to hoObj
88837>>>>>>>>>>>>>>>>>        End
88837>>>>>>>>>>>>>>>>>>
88837>>>>>>>>>>>>>>>>>        Else If (sLabel="B") Begin
88840>>>>>>>>>>>>>>>>>            On_Key Key_B Send KeyAction to hoObj
88841>>>>>>>>>>>>>>>>>        End
88841>>>>>>>>>>>>>>>>>>
88841>>>>>>>>>>>>>>>>>        Else If (sLabel="C") Begin
88844>>>>>>>>>>>>>>>>>            On_Key Key_C Send KeyAction to hoObj
88845>>>>>>>>>>>>>>>>>        End
88845>>>>>>>>>>>>>>>>>>
88845>>>>>>>>>>>>>>>>>        Else If (sLabel="D") Begin
88848>>>>>>>>>>>>>>>>>            On_Key Key_D Send KeyAction to hoObj
88849>>>>>>>>>>>>>>>>>        End
88849>>>>>>>>>>>>>>>>>>
88849>>>>>>>>>>>>>>>>>        Else If (sLabel="E") Begin
88852>>>>>>>>>>>>>>>>>            On_Key Key_E Send KeyAction to hoObj
88853>>>>>>>>>>>>>>>>>        End
88853>>>>>>>>>>>>>>>>>>
88853>>>>>>>>>>>>>>>>>        Else If (sLabel="F") Begin
88856>>>>>>>>>>>>>>>>>            On_Key Key_F Send KeyAction to hoObj
88857>>>>>>>>>>>>>>>>>        End
88857>>>>>>>>>>>>>>>>>>
88857>>>>>>>>>>>>>>>>>        Else If (sLabel="G") Begin
88860>>>>>>>>>>>>>>>>>            On_Key Key_G Send KeyAction to hoObj
88861>>>>>>>>>>>>>>>>>        End
88861>>>>>>>>>>>>>>>>>>
88861>>>>>>>>>>>>>>>>>        Else If (sLabel="H") Begin
88864>>>>>>>>>>>>>>>>>            On_Key Key_H Send KeyAction to hoObj
88865>>>>>>>>>>>>>>>>>        End
88865>>>>>>>>>>>>>>>>>>
88865>>>>>>>>>>>>>>>>>        Else If (sLabel="I") Begin
88868>>>>>>>>>>>>>>>>>            On_Key Key_I Send KeyAction to hoObj
88869>>>>>>>>>>>>>>>>>        End
88869>>>>>>>>>>>>>>>>>>
88869>>>>>>>>>>>>>>>>>        Else If (sLabel="J") Begin
88872>>>>>>>>>>>>>>>>>            On_Key Key_J Send KeyAction to hoObj
88873>>>>>>>>>>>>>>>>>        End
88873>>>>>>>>>>>>>>>>>>
88873>>>>>>>>>>>>>>>>>        Else If (sLabel="K") Begin
88876>>>>>>>>>>>>>>>>>            On_Key Key_K Send KeyAction to hoObj
88877>>>>>>>>>>>>>>>>>        End
88877>>>>>>>>>>>>>>>>>>
88877>>>>>>>>>>>>>>>>>        Else If (sLabel="L") Begin
88880>>>>>>>>>>>>>>>>>            On_Key Key_L Send KeyAction to hoObj
88881>>>>>>>>>>>>>>>>>        End
88881>>>>>>>>>>>>>>>>>>
88881>>>>>>>>>>>>>>>>>        Else If (sLabel="M") Begin
88884>>>>>>>>>>>>>>>>>            On_Key Key_M Send KeyAction to hoObj
88885>>>>>>>>>>>>>>>>>        End
88885>>>>>>>>>>>>>>>>>>
88885>>>>>>>>>>>>>>>>>        Else If (sLabel="N") Begin
88888>>>>>>>>>>>>>>>>>            On_Key Key_N Send KeyAction to hoObj
88889>>>>>>>>>>>>>>>>>        End
88889>>>>>>>>>>>>>>>>>>
88889>>>>>>>>>>>>>>>>>        Else If (sLabel="O") Begin
88892>>>>>>>>>>>>>>>>>            On_Key Key_O Send KeyAction to hoObj
88893>>>>>>>>>>>>>>>>>        End
88893>>>>>>>>>>>>>>>>>>
88893>>>>>>>>>>>>>>>>>        Else If (sLabel="P") Begin
88896>>>>>>>>>>>>>>>>>            On_Key Key_P Send KeyAction to hoObj
88897>>>>>>>>>>>>>>>>>        End
88897>>>>>>>>>>>>>>>>>>
88897>>>>>>>>>>>>>>>>>        Else If (sLabel="Q") Begin
88900>>>>>>>>>>>>>>>>>            On_Key Key_Q Send KeyAction to hoObj
88901>>>>>>>>>>>>>>>>>        End
88901>>>>>>>>>>>>>>>>>>
88901>>>>>>>>>>>>>>>>>        Else If (sLabel="R") Begin
88904>>>>>>>>>>>>>>>>>            On_Key Key_R Send KeyAction to hoObj
88905>>>>>>>>>>>>>>>>>        End
88905>>>>>>>>>>>>>>>>>>
88905>>>>>>>>>>>>>>>>>        Else If (sLabel="S") Begin
88908>>>>>>>>>>>>>>>>>            On_Key Key_S Send KeyAction to hoObj
88909>>>>>>>>>>>>>>>>>        End
88909>>>>>>>>>>>>>>>>>>
88909>>>>>>>>>>>>>>>>>        Else If (sLabel="T") Begin
88912>>>>>>>>>>>>>>>>>            On_Key Key_T Send KeyAction to hoObj
88913>>>>>>>>>>>>>>>>>        End
88913>>>>>>>>>>>>>>>>>>
88913>>>>>>>>>>>>>>>>>        Else If (sLabel="U") Begin
88916>>>>>>>>>>>>>>>>>            On_Key Key_U Send KeyAction to hoObj
88917>>>>>>>>>>>>>>>>>        End
88917>>>>>>>>>>>>>>>>>>
88917>>>>>>>>>>>>>>>>>        Else If (sLabel="V") Begin
88920>>>>>>>>>>>>>>>>>            On_Key Key_V Send KeyAction to hoObj
88921>>>>>>>>>>>>>>>>>        End
88921>>>>>>>>>>>>>>>>>>
88921>>>>>>>>>>>>>>>>>        Else If (sLabel="W") Begin
88924>>>>>>>>>>>>>>>>>            On_Key Key_W Send KeyAction to hoObj
88925>>>>>>>>>>>>>>>>>        End
88925>>>>>>>>>>>>>>>>>>
88925>>>>>>>>>>>>>>>>>        Else If (sLabel="X") Begin
88928>>>>>>>>>>>>>>>>>            On_Key Key_X Send KeyAction to hoObj
88929>>>>>>>>>>>>>>>>>        End
88929>>>>>>>>>>>>>>>>>>
88929>>>>>>>>>>>>>>>>>        Else If (sLabel="Y") Begin
88932>>>>>>>>>>>>>>>>>            On_Key Key_Y Send KeyAction to hoObj
88933>>>>>>>>>>>>>>>>>        End
88933>>>>>>>>>>>>>>>>>>
88933>>>>>>>>>>>>>>>>>        Else If (sLabel="Z") Begin
88936>>>>>>>>>>>>>>>>>            On_Key Key_Z Send KeyAction to hoObj
88937>>>>>>>>>>>>>>>>>        End
88937>>>>>>>>>>>>>>>>>>
88937>>>>>>>>>>>>>>>>>        Else If (sLabel="Z") Begin
88940>>>>>>>>>>>>>>>>>            On_Key Key_Z Send KeyAction to hoObj
88941>>>>>>>>>>>>>>>>>        End
88941>>>>>>>>>>>>>>>>>>
88941>>>>>>>>>>>>>>>>>        Else If (sLabel="0") Begin
88944>>>>>>>>>>>>>>>>>            On_Key Key_0 Send KeyAction to hoObj
88945>>>>>>>>>>>>>>>>>        End
88945>>>>>>>>>>>>>>>>>>
88945>>>>>>>>>>>>>>>>>        Else If (sLabel="1") Begin
88948>>>>>>>>>>>>>>>>>            On_Key Key_1 Send KeyAction to hoObj
88949>>>>>>>>>>>>>>>>>        End
88949>>>>>>>>>>>>>>>>>>
88949>>>>>>>>>>>>>>>>>        Else If (sLabel="2") Begin
88952>>>>>>>>>>>>>>>>>            On_Key Key_2 Send KeyAction to hoObj
88953>>>>>>>>>>>>>>>>>        End
88953>>>>>>>>>>>>>>>>>>
88953>>>>>>>>>>>>>>>>>        Else If (sLabel="3") Begin
88956>>>>>>>>>>>>>>>>>            On_Key Key_3 Send KeyAction to hoObj
88957>>>>>>>>>>>>>>>>>        End
88957>>>>>>>>>>>>>>>>>>
88957>>>>>>>>>>>>>>>>>        Else If (sLabel="4") Begin
88960>>>>>>>>>>>>>>>>>            On_Key Key_4 Send KeyAction to hoObj
88961>>>>>>>>>>>>>>>>>        End
88961>>>>>>>>>>>>>>>>>>
88961>>>>>>>>>>>>>>>>>        Else If (sLabel="5") Begin
88964>>>>>>>>>>>>>>>>>            On_Key Key_5 Send KeyAction to hoObj
88965>>>>>>>>>>>>>>>>>        End
88965>>>>>>>>>>>>>>>>>>
88965>>>>>>>>>>>>>>>>>        Else If (sLabel="6") Begin
88968>>>>>>>>>>>>>>>>>            On_Key Key_6 Send KeyAction to hoObj
88969>>>>>>>>>>>>>>>>>        End
88969>>>>>>>>>>>>>>>>>>
88969>>>>>>>>>>>>>>>>>        Else If (sLabel="7") Begin
88972>>>>>>>>>>>>>>>>>            On_Key Key_7 Send KeyAction to hoObj
88973>>>>>>>>>>>>>>>>>        End
88973>>>>>>>>>>>>>>>>>>
88973>>>>>>>>>>>>>>>>>        Else If (sLabel="8") Begin
88976>>>>>>>>>>>>>>>>>            On_Key Key_8 Send KeyAction to hoObj
88977>>>>>>>>>>>>>>>>>        End
88977>>>>>>>>>>>>>>>>>>
88977>>>>>>>>>>>>>>>>>        Else If (sLabel="9") Begin
88980>>>>>>>>>>>>>>>>>            On_Key Key_9 Send KeyAction to hoObj
88981>>>>>>>>>>>>>>>>>        End
88981>>>>>>>>>>>>>>>>>>
88981>>>>>>>>>>>>>>>>>    End_Procedure
88982>>>>>>>>>>>>>>>>>
88982>>>>>>>>>>>>>>>>>    // helper functions that return a tmbButton struct for predefined buttons
88982>>>>>>>>>>>>>>>>>    Function mbOkButton Returns tmbButtons
88984>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88984>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88984>>>>>>>>>>>>>>>>>        Move MBR_Ok to RetVal.iType
88985>>>>>>>>>>>>>>>>>        Function_Return RetVal
88986>>>>>>>>>>>>>>>>>    End_Function
88987>>>>>>>>>>>>>>>>>
88987>>>>>>>>>>>>>>>>>    Function mbCancelButton Returns tmbButtons
88989>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88989>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88989>>>>>>>>>>>>>>>>>        Move MBR_Cancel to RetVal.iType
88990>>>>>>>>>>>>>>>>>        Function_Return RetVal
88991>>>>>>>>>>>>>>>>>    End_Function
88992>>>>>>>>>>>>>>>>>
88992>>>>>>>>>>>>>>>>>    Function mbYesButton Returns tmbButtons
88994>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88994>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88994>>>>>>>>>>>>>>>>>        Move MBR_Yes to RetVal.iType
88995>>>>>>>>>>>>>>>>>        Function_Return RetVal
88996>>>>>>>>>>>>>>>>>    End_Function
88997>>>>>>>>>>>>>>>>>
88997>>>>>>>>>>>>>>>>>    Function mbNoButton Returns tmbButtons
88999>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88999>>>>>>>>>>>>>>>>>        tmbButtons RetVal
88999>>>>>>>>>>>>>>>>>        Move MBR_No to RetVal.iType
89000>>>>>>>>>>>>>>>>>        Function_Return RetVal
89001>>>>>>>>>>>>>>>>>    End_Function
89002>>>>>>>>>>>>>>>>>
89002>>>>>>>>>>>>>>>>>    Function mbAbortButton Returns tmbButtons
89004>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89004>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89004>>>>>>>>>>>>>>>>>        Move MBR_Abort to RetVal.iType
89005>>>>>>>>>>>>>>>>>        Function_Return RetVal
89006>>>>>>>>>>>>>>>>>    End_Function
89007>>>>>>>>>>>>>>>>>
89007>>>>>>>>>>>>>>>>>    Function mbRetryButton Returns tmbButtons
89009>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89009>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89009>>>>>>>>>>>>>>>>>        Move MBR_Retry to RetVal.iType
89010>>>>>>>>>>>>>>>>>        Function_Return RetVal
89011>>>>>>>>>>>>>>>>>    End_Function
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>    Function mbIgnoreButton Returns tmbButtons
89014>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89014>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89014>>>>>>>>>>>>>>>>>        Move MBR_Ignore to RetVal.iType
89015>>>>>>>>>>>>>>>>>        Function_Return RetVal
89016>>>>>>>>>>>>>>>>>    End_Function
89017>>>>>>>>>>>>>>>>>
89017>>>>>>>>>>>>>>>>>    Function mbButtons Integer iButton1 Integer iButton2 Integer iButton3 Integer iButton4 Returns tmbButtons[]
89019>>>>>>>>>>>>>>>>>        tmbButtons[] RetVal
89019>>>>>>>>>>>>>>>>>        tmbButtons[] RetVal
89020>>>>>>>>>>>>>>>>>        Move iButton1 to RetVal[0].iType
89021>>>>>>>>>>>>>>>>>        If (num_arguments>1) Begin
89023>>>>>>>>>>>>>>>>>            Move iButton2 to RetVal[1].iType
89024>>>>>>>>>>>>>>>>>        End
89024>>>>>>>>>>>>>>>>>>
89024>>>>>>>>>>>>>>>>>        If (num_arguments>2) Begin
89026>>>>>>>>>>>>>>>>>            Move iButton3 to RetVal[2].iType
89027>>>>>>>>>>>>>>>>>        End
89027>>>>>>>>>>>>>>>>>>
89027>>>>>>>>>>>>>>>>>        If (num_arguments>3) Begin
89029>>>>>>>>>>>>>>>>>            Move iButton4 to RetVal[3].iType
89030>>>>>>>>>>>>>>>>>        End
89030>>>>>>>>>>>>>>>>>>
89030>>>>>>>>>>>>>>>>>        Function_Return RetVal
89031>>>>>>>>>>>>>>>>>    End_Function
89032>>>>>>>>>>>>>>>>>
89032>>>>>>>>>>>>>>>>>    Function mbMessageBox String sMessage String sTitle Integer iBitmap String sBitmap Integer iFontPointHeight Boolean bBold Boolean bItalic Boolean bUnderline Returns tmbMessageBox
89034>>>>>>>>>>>>>>>>>        tmbMessageBox mb
89034>>>>>>>>>>>>>>>>>        tmbMessageBox mb
89034>>>>>>>>>>>>>>>>>        Move sMessage to mb.Message[0].sMessage
89035>>>>>>>>>>>>>>>>>        Move sTitle to mb.sTitle
89036>>>>>>>>>>>>>>>>>        If (num_arguments>2) Begin
89038>>>>>>>>>>>>>>>>>            Move iBitmap to mb.iBitmap
89039>>>>>>>>>>>>>>>>>        End
89039>>>>>>>>>>>>>>>>>>
89039>>>>>>>>>>>>>>>>>        If (Num_arguments>3) Begin
89041>>>>>>>>>>>>>>>>>            Move sBitmap to mb.sBitmap
89042>>>>>>>>>>>>>>>>>        End
89042>>>>>>>>>>>>>>>>>>
89042>>>>>>>>>>>>>>>>>        If (num_arguments>4) Begin
89044>>>>>>>>>>>>>>>>>            Move iFontPointHeight to mb.Message[0].iFontPointHeight
89045>>>>>>>>>>>>>>>>>        End
89045>>>>>>>>>>>>>>>>>>
89045>>>>>>>>>>>>>>>>>        If (num_arguments>5) Begin
89047>>>>>>>>>>>>>>>>>            Move bBold to mb.Message[0].bBold
89048>>>>>>>>>>>>>>>>>        End
89048>>>>>>>>>>>>>>>>>>
89048>>>>>>>>>>>>>>>>>        If (num_arguments>6) Begin
89050>>>>>>>>>>>>>>>>>            Move bItalic to mb.Message[0].bItalic
89051>>>>>>>>>>>>>>>>>        End
89051>>>>>>>>>>>>>>>>>>
89051>>>>>>>>>>>>>>>>>        If (num_arguments>7) Begin
89053>>>>>>>>>>>>>>>>>            Move bUnderline to mb.Message[0].bUnderline
89054>>>>>>>>>>>>>>>>>        End
89054>>>>>>>>>>>>>>>>>>
89054>>>>>>>>>>>>>>>>>        Function_Return mb
89055>>>>>>>>>>>>>>>>>    End_Function
89056>>>>>>>>>>>>>>>>>
89056>>>>>>>>>>>>>>>>>    Function mbMessage String sMessage Boolean bCheckbox Boolean bChecked String sBitmap Integer iFontPointHeight Boolean bBold Boolean bItalic Boolean bUnderline Integer iSpaceAfter Returns tmbMessageText
89058>>>>>>>>>>>>>>>>>        tmbMessageText msg
89058>>>>>>>>>>>>>>>>>        tmbMessageText msg
89058>>>>>>>>>>>>>>>>>        Move sMessage to msg.sMessage
89059>>>>>>>>>>>>>>>>>        Move 4 to msg.iSpaceAfter
89060>>>>>>>>>>>>>>>>>        If (num_arguments>1) Begin
89062>>>>>>>>>>>>>>>>>            Move bCheckbox to msg.bCheckbox
89063>>>>>>>>>>>>>>>>>        End
89063>>>>>>>>>>>>>>>>>>
89063>>>>>>>>>>>>>>>>>        If (num_arguments>2) Begin
89065>>>>>>>>>>>>>>>>>            Move bChecked to msg.bChecked
89066>>>>>>>>>>>>>>>>>        End
89066>>>>>>>>>>>>>>>>>>
89066>>>>>>>>>>>>>>>>>        If (num_arguments>3) Begin
89068>>>>>>>>>>>>>>>>>            Move sBitmap to msg.sBitmap
89069>>>>>>>>>>>>>>>>>        End
89069>>>>>>>>>>>>>>>>>>
89069>>>>>>>>>>>>>>>>>        If (num_arguments>4) Begin
89071>>>>>>>>>>>>>>>>>            Move iFontPointHeight to msg.iFontPointHeight
89072>>>>>>>>>>>>>>>>>        End
89072>>>>>>>>>>>>>>>>>>
89072>>>>>>>>>>>>>>>>>        If (num_arguments>5) Begin
89074>>>>>>>>>>>>>>>>>            Move bBold to msg.bBold
89075>>>>>>>>>>>>>>>>>        End
89075>>>>>>>>>>>>>>>>>>
89075>>>>>>>>>>>>>>>>>        If (num_arguments>6) Begin
89077>>>>>>>>>>>>>>>>>            Move bItalic to msg.bItalic
89078>>>>>>>>>>>>>>>>>        End
89078>>>>>>>>>>>>>>>>>>
89078>>>>>>>>>>>>>>>>>        If (num_arguments>7) Begin
89080>>>>>>>>>>>>>>>>>            Move bUnderline to msg.bUnderline
89081>>>>>>>>>>>>>>>>>        End
89081>>>>>>>>>>>>>>>>>>
89081>>>>>>>>>>>>>>>>>        If (num_arguments>8) Begin
89083>>>>>>>>>>>>>>>>>            Move iSpaceAfter to msg.iSpaceAfter
89084>>>>>>>>>>>>>>>>>        End
89084>>>>>>>>>>>>>>>>>>
89084>>>>>>>>>>>>>>>>>        Function_Return msg
89085>>>>>>>>>>>>>>>>>    End_Function
89086>>>>>>>>>>>>>>>>>
89086>>>>>>>>>>>>>>>>>End_Class
89087>>>>>>>>>>>>>>>>>
89087>>>>>>>>>>>>>>>>>Class cMessageBoxPanel is a ModalPanel
89088>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89090>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89092>>>>>>>>>>>>>>>>>        Send Define_cMessageBox_mixin
89093>>>>>>>>>>>>>>>>>    End_Procedure
89094>>>>>>>>>>>>>>>>>
89094>>>>>>>>>>>>>>>>>    Import_Class_Protocol cMessageBox_mixin
89095>>>>>>>>>>>>>>>>>End_Class
89096>>>>>>>>>>>>>>>>>
89096>>>>>>>>>>>>>>>>>// following three classes are experimental
89096>>>>>>>>>>>>>>>>>//  here be dragons
89096>>>>>>>>>>>>>>>>>Class cMessageBoxTitle is a Container3d
89097>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89099>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89101>>>>>>>>>>>>>>>>>        Set Border_Style to Border_None
89102>>>>>>>>>>>>>>>>>        Set Location to 0 0
89103>>>>>>>>>>>>>>>>>        Object oTitle is a TextBox
89105>>>>>>>>>>>>>>>>>            Set peAnchors to anTopLeftRight
89106>>>>>>>>>>>>>>>>>            Set Location to 0 0
89107>>>>>>>>>>>>>>>>>            Set Color to clLtGray
89108>>>>>>>>>>>>>>>>>        End_Object
89109>>>>>>>>>>>>>>>>>    End_Procedure
89110>>>>>>>>>>>>>>>>>
89110>>>>>>>>>>>>>>>>>    Procedure Set Label String Val
89112>>>>>>>>>>>>>>>>>        Integer iSize
89112>>>>>>>>>>>>>>>>>        Set Label of oTitle to Val
89113>>>>>>>>>>>>>>>>>        Delegate Get Size to iSize
89115>>>>>>>>>>>>>>>>>        Set Size to 10 (Low(iSize))
89116>>>>>>>>>>>>>>>>>        Set Size of oTitle to 10 (Low(iSize))
89117>>>>>>>>>>>>>>>>>    End_Procedure
89118>>>>>>>>>>>>>>>>>End_Class
89119>>>>>>>>>>>>>>>>>
89119>>>>>>>>>>>>>>>>>Class cMessageBoxContainer is a Container3d
89120>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89122>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89124>>>>>>>>>>>>>>>>>        Set Border_Style to border_none
89125>>>>>>>>>>>>>>>>>        Send Define_cMessageBox_mixin
89126>>>>>>>>>>>>>>>>>        Set Location to 11 0
89127>>>>>>>>>>>>>>>>>        Set Visible_State to True
89128>>>>>>>>>>>>>>>>>        Set Shadow_State to False
89129>>>>>>>>>>>>>>>>>        Property Handle[] phoObjects
89130>>>>>>>>>>>>>>>>>    End_Procedure
89131>>>>>>>>>>>>>>>>>
89131>>>>>>>>>>>>>>>>>    Import_Class_Protocol cMessageBox_mixin
89132>>>>>>>>>>>>>>>>>
89132>>>>>>>>>>>>>>>>>    Procedure RefreshPreview tmbMessageBox ByRef Msg
89134>>>>>>>>>>>>>>>>>        Handle[] hoObject
89135>>>>>>>>>>>>>>>>>        Integer i
89135>>>>>>>>>>>>>>>>>
89135>>>>>>>>>>>>>>>>>        Get phoObjects to hoObject
89136>>>>>>>>>>>>>>>>>        For i From 0 to (Sizeofarray(hoObject)-1)
89142>>>>>>>>>>>>>>>>>>
89142>>>>>>>>>>>>>>>>>            Send Destroy to hoObject[i]
89143>>>>>>>>>>>>>>>>>        Loop
89144>>>>>>>>>>>>>>>>>>
89144>>>>>>>>>>>>>>>>>        Get ConstructMessageBox (&Msg) to hoObject
89145>>>>>>>>>>>>>>>>>        Set phoObjects to hoObject
89146>>>>>>>>>>>>>>>>>    End_Procedure
89147>>>>>>>>>>>>>>>>>
89147>>>>>>>>>>>>>>>>>    Procedure Set Label String Val
89149>>>>>>>>>>>>>>>>>        Delegate Set Label to Val
89151>>>>>>>>>>>>>>>>>    End_Procedure
89152>>>>>>>>>>>>>>>>>
89152>>>>>>>>>>>>>>>>>    Procedure Set Size Integer iHeight Integer iWidth
89154>>>>>>>>>>>>>>>>>        Forward Set Size to iHeight iWidth
89156>>>>>>>>>>>>>>>>>        Delegate Set Size to (iHeight+10) iWidth
89158>>>>>>>>>>>>>>>>>        Set Location to 11 0
89159>>>>>>>>>>>>>>>>>        Send Adjust_Logicals
89160>>>>>>>>>>>>>>>>>        Delegate Send Adjust_Logicals
89162>>>>>>>>>>>>>>>>>    End_Procedure
89163>>>>>>>>>>>>>>>>>
89163>>>>>>>>>>>>>>>>>End_Class
89164>>>>>>>>>>>>>>>>>
89164>>>>>>>>>>>>>>>>>Class cMessageBoxPreview is a Container3d
89165>>>>>>>>>>>>>>>>>
89165>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89167>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89169>>>>>>>>>>>>>>>>>        Object oTitle is a cMessageBoxTitle
89171>>>>>>>>>>>>>>>>>        End_Object
89172>>>>>>>>>>>>>>>>>        Object oPreviewer is a cMessageBoxContainer
89174>>>>>>>>>>>>>>>>>        End_Object
89175>>>>>>>>>>>>>>>>>        Send Add_Focus to oPreviewer Self
89176>>>>>>>>>>>>>>>>>    End_Procedure
89177>>>>>>>>>>>>>>>>>
89177>>>>>>>>>>>>>>>>>    Procedure Set Label String Val
89179>>>>>>>>>>>>>>>>>        Set Label of oTitle to Val
89180>>>>>>>>>>>>>>>>>    End_Procedure
89181>>>>>>>>>>>>>>>>>
89181>>>>>>>>>>>>>>>>>    Procedure createButton
89183>>>>>>>>>>>>>>>>>        Send CreateButton to oPreviewer
89184>>>>>>>>>>>>>>>>>    End_Procedure
89185>>>>>>>>>>>>>>>>>
89185>>>>>>>>>>>>>>>>>    Procedure RefreshPreview tmbMessageBox ByRef Msg
89187>>>>>>>>>>>>>>>>>        Send RefreshPreview to oPreviewer (&Msg)
89188>>>>>>>>>>>>>>>>>        Broadcast Set Visible_State to True
89190>>>>>>>>>>>>>>>>>    End_Procedure
89191>>>>>>>>>>>>>>>>>End_Class
89192>>>>>>>>>>>>>>>>>
89192>>>>>>>>>>>>>>>>>// create the main object that is used to display message boxes
89192>>>>>>>>>>>>>>>>>Global_Variable Handle ghoMessageBox
89192>>>>>>>>>>>>>>>>>Object oMessageBox is a cMessageBoxPanel
89194>>>>>>>>>>>>>>>>>    Move Self to ghoMessageBox
89195>>>>>>>>>>>>>>>>>End_Object
89196>>>>>>>>>>>>>>>>>
89196>>>>>>>>>>>>>>>>>// a standard message to access the enhanced message box functionality
89196>>>>>>>>>>>>>>>>>//  by passing a struct
89196>>>>>>>>>>>>>>>>>Procedure ShowMessageBox tmbMessageBox ByRef Msg
89199>>>>>>>>>>>>>>>>>    Send ShowMessageBox to ghoMessageBox (&Msg)
89200>>>>>>>>>>>>>>>>>End_Procedure
89201>>>>>>>>>>>>>>>>>
89201>>>>>>>>>>>>>>>>>// substitutes for the standard message box procedures/functions
89201>>>>>>>>>>>>>>>>>//  plus some extras (WarningBox, WarningCancelBox, AbortRetryIgnoreBox)
89201>>>>>>>>>>>>>>>>>Procedure StopBox String sText String sLabel Integer iHelp
89204>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89204>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89204>>>>>>>>>>>>>>>>>
89204>>>>>>>>>>>>>>>>>    If (num_arguments=1) Begin
89206>>>>>>>>>>>>>>>>>        Get StopBox sText to mb
89207>>>>>>>>>>>>>>>>>    End
89207>>>>>>>>>>>>>>>>>>
89207>>>>>>>>>>>>>>>>>    If (num_arguments=2) Begin
89209>>>>>>>>>>>>>>>>>        Get StopBox sText sLabel to mb
89210>>>>>>>>>>>>>>>>>    End
89210>>>>>>>>>>>>>>>>>>
89210>>>>>>>>>>>>>>>>>    If (num_arguments=3) Begin
89212>>>>>>>>>>>>>>>>>        Get StopBox sText sLabel iHelp to mb
89213>>>>>>>>>>>>>>>>>    End
89213>>>>>>>>>>>>>>>>>>
89213>>>>>>>>>>>>>>>>>    Send ShowMessageBox (&mb)
89214>>>>>>>>>>>>>>>>>End_Procedure
89215>>>>>>>>>>>>>>>>>
89215>>>>>>>>>>>>>>>>>Function StopBox String sText String sLabel Integer iHelp String sHtmlHelpTopic Returns tmbMessageBox
89218>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89218>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89218>>>>>>>>>>>>>>>>>
89218>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89219>>>>>>>>>>>>>>>>>    Move "stop256.bmp/3d" to mb.sBitmap
89220>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89222>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89223>>>>>>>>>>>>>>>>>    End
89223>>>>>>>>>>>>>>>>>>
89223>>>>>>>>>>>>>>>>>    Else Begin
89224>>>>>>>>>>>>>>>>>        Move C_$MessageBoxStop to mb.sTitle
89225>>>>>>>>>>>>>>>>>    End
89225>>>>>>>>>>>>>>>>>>
89225>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89227>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89228>>>>>>>>>>>>>>>>>    End
89228>>>>>>>>>>>>>>>>>>
89228>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89230>>>>>>>>>>>>>>>>>        Move sHtmlHelpTopic to mb.sHtmlHelpTopic
89231>>>>>>>>>>>>>>>>>    End
89231>>>>>>>>>>>>>>>>>>
89231>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89232>>>>>>>>>>>>>>>>>    Function_Return mb
89233>>>>>>>>>>>>>>>>>End_Function
89234>>>>>>>>>>>>>>>>>
89234>>>>>>>>>>>>>>>>>Procedure WarningBox String sText String sLabel Integer iHelp
89237>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89237>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89237>>>>>>>>>>>>>>>>>
89237>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89238>>>>>>>>>>>>>>>>>    Move "warning256.bmp/3d" to mb.sBitmap
89239>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89241>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89242>>>>>>>>>>>>>>>>>    End
89242>>>>>>>>>>>>>>>>>>
89242>>>>>>>>>>>>>>>>>    Else Begin
89243>>>>>>>>>>>>>>>>>        Move C_$MessageBoxWarning to mb.sTitle
89244>>>>>>>>>>>>>>>>>    End
89244>>>>>>>>>>>>>>>>>>
89244>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89246>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89247>>>>>>>>>>>>>>>>>    End
89247>>>>>>>>>>>>>>>>>>
89247>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89248>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89249>>>>>>>>>>>>>>>>>End_Procedure
89250>>>>>>>>>>>>>>>>>
89250>>>>>>>>>>>>>>>>>Procedure InfoBox String sText String sLabel Integer iHelp
89253>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89253>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89253>>>>>>>>>>>>>>>>>
89253>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89254>>>>>>>>>>>>>>>>>    Move "info256.bmp/3d" to mb.sBitmap
89255>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89257>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89258>>>>>>>>>>>>>>>>>    End
89258>>>>>>>>>>>>>>>>>>
89258>>>>>>>>>>>>>>>>>    Else Begin
89259>>>>>>>>>>>>>>>>>        Move C_$MessageBoxInfo to mb.sTitle
89260>>>>>>>>>>>>>>>>>    End
89260>>>>>>>>>>>>>>>>>>
89260>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89262>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89263>>>>>>>>>>>>>>>>>    End
89263>>>>>>>>>>>>>>>>>>
89263>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89264>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89265>>>>>>>>>>>>>>>>>End_Procedure
89266>>>>>>>>>>>>>>>>>
89266>>>>>>>>>>>>>>>>>Function WarningCancelBox String sText String sLabel Integer iHelp Returns Integer
89269>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89269>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89269>>>>>>>>>>>>>>>>>
89269>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89270>>>>>>>>>>>>>>>>>    Move "warning256.bmp/3d" to mb.sBitmap
89271>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89273>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89274>>>>>>>>>>>>>>>>>    End
89274>>>>>>>>>>>>>>>>>>
89274>>>>>>>>>>>>>>>>>    Else Begin
89275>>>>>>>>>>>>>>>>>        Move C_$MessageBoxWarning to mb.sTitle
89276>>>>>>>>>>>>>>>>>    End
89276>>>>>>>>>>>>>>>>>>
89276>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89278>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89279>>>>>>>>>>>>>>>>>    End
89279>>>>>>>>>>>>>>>>>>
89279>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89280>>>>>>>>>>>>>>>>>    Get mbCancelButton of (oMessageBox(Self)) to mb.Button[1]
89281>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89282>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89283>>>>>>>>>>>>>>>>>End_Function
89284>>>>>>>>>>>>>>>>>
89284>>>>>>>>>>>>>>>>>Function YesNoBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns Integer
89287>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89287>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89287>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89288>>>>>>>>>>>>>>>>>    Get mbYesButton of (oMessageBox(Self)) to mb.Button[0]
89289>>>>>>>>>>>>>>>>>    Get mbNoButton of (oMessageBox(Self)) to mb.Button[1]
89290>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89292>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89293>>>>>>>>>>>>>>>>>    End
89293>>>>>>>>>>>>>>>>>>
89293>>>>>>>>>>>>>>>>>    Else Begin
89294>>>>>>>>>>>>>>>>>        Move C_$MessageBoxQuestion to mb.sTitle
89295>>>>>>>>>>>>>>>>>    End
89295>>>>>>>>>>>>>>>>>>
89295>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89297>>>>>>>>>>>>>>>>>        If ((iDefButton iand MB_ICONMASK)<>0) Begin
89299>>>>>>>>>>>>>>>>>            Get IconBitmap of (oMessageBox(Self)) (iDefButton iand MB_ICONMASK) to mb.sBitmap
89300>>>>>>>>>>>>>>>>>        End
89300>>>>>>>>>>>>>>>>>>
89300>>>>>>>>>>>>>>>>>        Else Begin
89301>>>>>>>>>>>>>>>>>            Move "question256.bmp/3d" to mb.sBitmap
89302>>>>>>>>>>>>>>>>>        End
89302>>>>>>>>>>>>>>>>>>
89302>>>>>>>>>>>>>>>>>        Move (iDefButton iand MB_DEFBUTTONMASK) to iDefButton
89303>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON1) to mb.Button[0].bDefault
89304>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON2) to mb.Button[1].bDefault
89305>>>>>>>>>>>>>>>>>    End
89305>>>>>>>>>>>>>>>>>>
89305>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89307>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89308>>>>>>>>>>>>>>>>>    End
89308>>>>>>>>>>>>>>>>>>
89308>>>>>>>>>>>>>>>>>    If (num_arguments>=5) Begin
89310>>>>>>>>>>>>>>>>>        Move sCheckbox to mb.Message[1].sMessage
89311>>>>>>>>>>>>>>>>>        Move True to mb.Message[1].bCheckbox
89312>>>>>>>>>>>>>>>>>        If (num_arguments>=6) Begin
89314>>>>>>>>>>>>>>>>>            Move bChecked to mb.Message[1].bChecked
89315>>>>>>>>>>>>>>>>>        End
89315>>>>>>>>>>>>>>>>>>
89315>>>>>>>>>>>>>>>>>    End
89315>>>>>>>>>>>>>>>>>>
89315>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89316>>>>>>>>>>>>>>>>>    If (num_arguments>=5 and mb.Message[1].bChecked) Begin
89318>>>>>>>>>>>>>>>>>        Move (MBR_CHECKED ior mb.iRetVal) to mb.iRetVal
89319>>>>>>>>>>>>>>>>>    End
89319>>>>>>>>>>>>>>>>>>
89319>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89320>>>>>>>>>>>>>>>>>End_Function
89321>>>>>>>>>>>>>>>>>
89321>>>>>>>>>>>>>>>>>Function mbYesNoCancelBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns tmbMessageBox
89324>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89324>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89324>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89325>>>>>>>>>>>>>>>>>    Get mbYesButton of (oMessageBox(Self)) to mb.Button[0]
89326>>>>>>>>>>>>>>>>>    Get mbNoButton of (oMessageBox(Self)) to mb.Button[1]
89327>>>>>>>>>>>>>>>>>    Get mbCancelButton of (oMessageBox(Self)) to mb.Button[2]
89328>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89330>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89331>>>>>>>>>>>>>>>>>    End
89331>>>>>>>>>>>>>>>>>>
89331>>>>>>>>>>>>>>>>>    Else Begin
89332>>>>>>>>>>>>>>>>>        Move C_$MessageBoxQuestion to mb.sTitle
89333>>>>>>>>>>>>>>>>>    End
89333>>>>>>>>>>>>>>>>>>
89333>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89335>>>>>>>>>>>>>>>>>        If ((iDefButton iand MB_ICONMASK)<>0) Begin
89337>>>>>>>>>>>>>>>>>            Get IconBitmap of (oMessageBox(Self)) (iDefButton iand MB_ICONMASK) to mb.sBitmap
89338>>>>>>>>>>>>>>>>>        End
89338>>>>>>>>>>>>>>>>>>
89338>>>>>>>>>>>>>>>>>        Else Begin
89339>>>>>>>>>>>>>>>>>            Move "question256.bmp/3d" to mb.sBitmap
89340>>>>>>>>>>>>>>>>>        End
89340>>>>>>>>>>>>>>>>>>
89340>>>>>>>>>>>>>>>>>        Move (iDefButton iand MB_DEFBUTTONMASK) to iDefButton
89341>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON1) to mb.Button[0].bDefault
89342>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON2) to mb.Button[1].bDefault
89343>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON3) to mb.Button[2].bDefault
89344>>>>>>>>>>>>>>>>>    End
89344>>>>>>>>>>>>>>>>>>
89344>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89346>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89347>>>>>>>>>>>>>>>>>    End
89347>>>>>>>>>>>>>>>>>>
89347>>>>>>>>>>>>>>>>>    If (num_arguments>=5) Begin
89349>>>>>>>>>>>>>>>>>        Move sCheckbox to mb.Message[1].sMessage
89350>>>>>>>>>>>>>>>>>        Move True to mb.Message[1].bCheckbox
89351>>>>>>>>>>>>>>>>>        If (num_arguments>=6) Begin
89353>>>>>>>>>>>>>>>>>            Move bChecked to mb.Message[1].bChecked
89354>>>>>>>>>>>>>>>>>        End
89354>>>>>>>>>>>>>>>>>>
89354>>>>>>>>>>>>>>>>>    End
89354>>>>>>>>>>>>>>>>>>
89354>>>>>>>>>>>>>>>>>    Function_Return mb
89355>>>>>>>>>>>>>>>>>End_Function
89356>>>>>>>>>>>>>>>>>
89356>>>>>>>>>>>>>>>>>Function YesNoCancelBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns Integer
89359>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89359>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89359>>>>>>>>>>>>>>>>>
89359>>>>>>>>>>>>>>>>>    If (num_arguments=2) Begin
89361>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel to mb
89362>>>>>>>>>>>>>>>>>    End
89362>>>>>>>>>>>>>>>>>>
89362>>>>>>>>>>>>>>>>>    If (num_arguments=3) Begin
89364>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton to mb
89365>>>>>>>>>>>>>>>>>    End
89365>>>>>>>>>>>>>>>>>>
89365>>>>>>>>>>>>>>>>>    If (num_arguments=4) Begin
89367>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton iHelp to mb
89368>>>>>>>>>>>>>>>>>    End
89368>>>>>>>>>>>>>>>>>>
89368>>>>>>>>>>>>>>>>>    If (num_arguments=5) Begin
89370>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton iHelp sCheckbox False to mb
89371>>>>>>>>>>>>>>>>>    End
89371>>>>>>>>>>>>>>>>>>
89371>>>>>>>>>>>>>>>>>    If (num_arguments=6) Begin
89373>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton iHelp sCheckbox bChecked to mb
89374>>>>>>>>>>>>>>>>>    End
89374>>>>>>>>>>>>>>>>>>
89374>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89375>>>>>>>>>>>>>>>>>    If (num_arguments>=5 and mb.Message[1].bChecked) Begin
89377>>>>>>>>>>>>>>>>>        Move (MBR_CHECKED ior mb.iRetVal) to mb.iRetVal
89378>>>>>>>>>>>>>>>>>    End
89378>>>>>>>>>>>>>>>>>>
89378>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89379>>>>>>>>>>>>>>>>>End_Function
89380>>>>>>>>>>>>>>>>>
89380>>>>>>>>>>>>>>>>>Function AbortRetryIgnoreBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns Integer
89383>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89383>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89383>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89384>>>>>>>>>>>>>>>>>    Get mbAbortButton of (oMessageBox(Self)) to mb.Button[0]
89385>>>>>>>>>>>>>>>>>    Get mbRetryButton of (oMessageBox(Self)) to mb.Button[1]
89386>>>>>>>>>>>>>>>>>    Get mbIgnoreButton of (oMessageBox(Self)) to mb.Button[2]
89387>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89389>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89390>>>>>>>>>>>>>>>>>    End
89390>>>>>>>>>>>>>>>>>>
89390>>>>>>>>>>>>>>>>>    Else Begin
89391>>>>>>>>>>>>>>>>>        Move C_$MessageBoxProblem to mb.sTitle
89392>>>>>>>>>>>>>>>>>    End
89392>>>>>>>>>>>>>>>>>>
89392>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89394>>>>>>>>>>>>>>>>>        If ((iDefButton iand MB_ICONMASK)<>0) Begin
89396>>>>>>>>>>>>>>>>>            Get IconBitmap of (oMessageBox(Self)) (iDefButton iand MB_ICONMASK) to mb.sBitmap
89397>>>>>>>>>>>>>>>>>        End
89397>>>>>>>>>>>>>>>>>>
89397>>>>>>>>>>>>>>>>>        Else Begin
89398>>>>>>>>>>>>>>>>>            Move "warning256.bmp/3d" to mb.sBitmap
89399>>>>>>>>>>>>>>>>>        End
89399>>>>>>>>>>>>>>>>>>
89399>>>>>>>>>>>>>>>>>        Move (iDefButton iand MB_DEFBUTTONMASK) to iDefButton
89400>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON1) to mb.Button[0].bDefault
89401>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON2) to mb.Button[1].bDefault
89402>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON3) to mb.Button[2].bDefault
89403>>>>>>>>>>>>>>>>>    End
89403>>>>>>>>>>>>>>>>>>
89403>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89405>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89406>>>>>>>>>>>>>>>>>    End
89406>>>>>>>>>>>>>>>>>>
89406>>>>>>>>>>>>>>>>>    If (num_arguments>=5) Begin
89408>>>>>>>>>>>>>>>>>        Move sCheckbox to mb.Message[1].sMessage
89409>>>>>>>>>>>>>>>>>        Move True to mb.Message[1].bCheckbox
89410>>>>>>>>>>>>>>>>>        If (num_arguments>=6) Begin
89412>>>>>>>>>>>>>>>>>            Move bChecked to mb.Message[1].bChecked
89413>>>>>>>>>>>>>>>>>        End
89413>>>>>>>>>>>>>>>>>>
89413>>>>>>>>>>>>>>>>>    End
89413>>>>>>>>>>>>>>>>>>
89413>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89414>>>>>>>>>>>>>>>>>    If (num_arguments>=5 and mb.Message[1].bChecked) Begin
89416>>>>>>>>>>>>>>>>>        Move (MBR_CHECKED ior mb.iRetVal) to mb.iRetVal
89417>>>>>>>>>>>>>>>>>    End
89417>>>>>>>>>>>>>>>>>>
89417>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89418>>>>>>>>>>>>>>>>>End_Function
89419>>>>>>>>>>>>>>>
89419>>>>>>>>>>>>>>>Struct tRefactorResponse
89419>>>>>>>>>>>>>>>  String sObject
89419>>>>>>>>>>>>>>>  Integer eResponse
89419>>>>>>>>>>>>>>>  Boolean bPadded
89419>>>>>>>>>>>>>>>End_Struct
89419>>>>>>>>>>>>>>>
89419>>>>>>>>>>>>>>>Enum_List
89419>>>>>>>>>>>>>>>  Define CI_NoCaseStatement  For 0
89419>>>>>>>>>>>>>>>  Define CI_CaseBegin
89419>>>>>>>>>>>>>>>  Define CI_CaseCondition
89419>>>>>>>>>>>>>>>  Define CI_CaseBreak
89419>>>>>>>>>>>>>>>  Define CI_CaseEnd
89419>>>>>>>>>>>>>>>End_Enum_List
89419>>>>>>>>>>>>>>>
89419>>>>>>>>>>>>>>>Class cSciLexerRefactor Is a cSciLexer
89420>>>>>>>>>>>>>>>  Procedure Construct_Object
89422>>>>>>>>>>>>>>>    Forward Send Construct_Object
89424>>>>>>>>>>>>>>>    Property Boolean pbRefactorPadReplaceString    True
89425>>>>>>>>>>>>>>>    Property Boolean pbIndentCaseBreak             True // Indent on "case break", set to false if you don't want that.
89426>>>>>>>>>>>>>>>    Property tRefactorResponse[] pRefactorResponse      // Remember the refactoring response per object
89427>>>>>>>>>>>>>>>  End_Procedure
89428>>>>>>>>>>>>>>>
89428>>>>>>>>>>>>>>>  Function RefactorReplaceObjectConfirmation Integer iLine String sFind String sReplace Boolean bPadded Boolean bRemember Returns Integer
89430>>>>>>>>>>>>>>>    Integer eResponse
89430>>>>>>>>>>>>>>>    String  szAnnotate
89430>>>>>>>>>>>>>>>    String  sCheckbox1
89430>>>>>>>>>>>>>>>    String  sCheckbox2
89430>>>>>>>>>>>>>>>    tmbMessageBox mb
89430>>>>>>>>>>>>>>>    tmbMessageBox mb
89430>>>>>>>>>>>>>>>
89430>>>>>>>>>>>>>>>    Move ("Do you want to replace '"+sFind+"' with '"+sReplace+"' ?") To szAnnotate
89431>>>>>>>>>>>>>>>    Send GotoLine iLine
89432>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETSTYLE iLine STYLE_CALLTIP
89433>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETTEXT  iLine (AddressOf(szAnnotate))
89434>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETVISIBLE ANNOTATION_BOXED
89435>>>>>>>>>>>>>>>    Move "Keep same width padded with spaces"  To sCheckbox1
89436>>>>>>>>>>>>>>>    Move "Remember the choice for this object" To sCheckbox2
89437>>>>>>>>>>>>>>>    Get mbYesNoCancelBox "Change into suggestion?" "Question" MB_DEFBUTTON2 0 sCheckbox1 bPadded To mb
89438>>>>>>>>>>>>>>>    Move sCheckbox2 To mb.Message[2].sMessage
89439>>>>>>>>>>>>>>>    Move True       To mb.Message[2].bCheckbox
89440>>>>>>>>>>>>>>>    Move bRemember  To mb.Message[2].bChecked
89441>>>>>>>>>>>>>>>    Send ShowMessageBox (&mb)
89442>>>>>>>>>>>>>>>    Move (mb.iRetVal ior If(mb.message[1].bchecked,MBR_CHECKED,0))  To mb.iRetVal
89443>>>>>>>>>>>>>>>    Move (mb.iRetVal ior If(mb.message[2].bchecked,MBR_CHECKED2,0)) To mb.iRetVal
89444>>>>>>>>>>>>>>>    Move  mb.iRetVal To eResponse
89445>>>>>>>>>>>>>>>    Move "" To szAnnotate
89446>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETTEXT iLine (AddressOf(szAnnotate))
89447>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETVISIBLE ANNOTATION_HIDDEN
89448>>>>>>>>>>>>>>>    Function_Return eResponse
89449>>>>>>>>>>>>>>>  End_Function
89450>>>>>>>>>>>>>>>
89450>>>>>>>>>>>>>>>  //
89450>>>>>>>>>>>>>>>  // Sometimes we already know that we do not have to offer a replacement
89450>>>>>>>>>>>>>>>  //
89450>>>>>>>>>>>>>>>  Function IsDropSelfReplaceTargetValid String sReplace Returns Boolean
89452>>>>>>>>>>>>>>>    Boolean bIsValid
89452>>>>>>>>>>>>>>>
89452>>>>>>>>>>>>>>>    Move True To bIsValid
89453>>>>>>>>>>>>>>>    Move (Lowercase(sReplace)) To sReplace
89454>>>>>>>>>>>>>>>    If (sReplace = "parent") Begin
89456>>>>>>>>>>>>>>>      Move False To bIsValid
89457>>>>>>>>>>>>>>>    End
89457>>>>>>>>>>>>>>>>
89457>>>>>>>>>>>>>>>
89457>>>>>>>>>>>>>>>    Function_Return bIsValid
89458>>>>>>>>>>>>>>>  End_Function
89459>>>>>>>>>>>>>>>
89459>>>>>>>>>>>>>>>  Procedure RefactorLocateSourceObject String sLine Integer iPos Integer iLength Integer ByRef iPosStart Integer ByRef iPosEnd Integer ByRef iLevel
89461>>>>>>>>>>>>>>>    Integer iNext
89461>>>>>>>>>>>>>>>    String  sChar
89461>>>>>>>>>>>>>>>
89461>>>>>>>>>>>>>>>    Move (Pos("(",sLine,iPosStart+4)) To iPosStart // search for ( after " to " (or for functions after " of "
89462>>>>>>>>>>>>>>>    Move (Pos(")",sLine,iPosStart)) To iPosEnd     // find first close quote
89463>>>>>>>>>>>>>>>    If (iPos>=iPosStart and iPos<iPosEnd) Begin    // check what is between the quotes
89465>>>>>>>>>>>>>>>      // found one!
89465>>>>>>>>>>>>>>>      Move 0 To iLevel
89466>>>>>>>>>>>>>>>      Move iPosEnd To iNext
89467>>>>>>>>>>>>>>>      Move (Mid(sLine,1,iNext)) To sChar
89468>>>>>>>>>>>>>>>      While (iNext<=iLength and (sChar=" " or sChar=")" or sChar=Character(9)))
89472>>>>>>>>>>>>>>>        If (sChar=")") Begin
89474>>>>>>>>>>>>>>>          Move iNext To iPosEnd
89475>>>>>>>>>>>>>>>          Increment iLevel
89476>>>>>>>>>>>>>>>        End
89476>>>>>>>>>>>>>>>>
89476>>>>>>>>>>>>>>>        Increment iNext
89477>>>>>>>>>>>>>>>        Move (Mid(sLine,1,iNext)) To sChar
89478>>>>>>>>>>>>>>>      Loop
89479>>>>>>>>>>>>>>>>
89479>>>>>>>>>>>>>>>    End
89479>>>>>>>>>>>>>>>>
89479>>>>>>>>>>>>>>>  End_Procedure
89480>>>>>>>>>>>>>>>
89480>>>>>>>>>>>>>>>  //
89480>>>>>>>>>>>>>>>  // The refactoring dialog lets you remember the response per object.
89480>>>>>>>>>>>>>>>  // This function tests for your object if it already has an autoresponse.
89480>>>>>>>>>>>>>>>  //
89480>>>>>>>>>>>>>>>  Function RefactorObjectAutoResponse String sObject Returns Integer
89482>>>>>>>>>>>>>>>    Integer iItem
89482>>>>>>>>>>>>>>>    Integer iCount
89482>>>>>>>>>>>>>>>    Integer eResponse
89482>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
89482>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
89483>>>>>>>>>>>>>>>
89483>>>>>>>>>>>>>>>    Move 0 To eResponse
89484>>>>>>>>>>>>>>>    Move (lowercase(sObject)) To sObject
89485>>>>>>>>>>>>>>>    Get pRefactorResponse To RefactorResponse
89486>>>>>>>>>>>>>>>    Move (Sizeofarray(RefactorResponse)) To iCount
89487>>>>>>>>>>>>>>>    For iItem From 0 To (iCount-1)
89493>>>>>>>>>>>>>>>>
89493>>>>>>>>>>>>>>>      If (RefactorResponse[iItem].sObject=sObject) Begin
89495>>>>>>>>>>>>>>>        Move RefactorResponse[iItem].eResponse To eResponse
89496>>>>>>>>>>>>>>>        If (RefactorResponse[iItem].bPadded) Begin
89498>>>>>>>>>>>>>>>          Move (eResponse ior MBR_CHECKED) To eResponse
89499>>>>>>>>>>>>>>>        End
89499>>>>>>>>>>>>>>>>
89499>>>>>>>>>>>>>>>        Move iCount To iItem // done
89500>>>>>>>>>>>>>>>      End
89500>>>>>>>>>>>>>>>>
89500>>>>>>>>>>>>>>>    Loop
89501>>>>>>>>>>>>>>>>
89501>>>>>>>>>>>>>>>    Function_Return eResponse
89502>>>>>>>>>>>>>>>  End_Function
89503>>>>>>>>>>>>>>>
89503>>>>>>>>>>>>>>>  Procedure AddObjectToRefactorAutoResponse String sObject Integer eResponse Boolean bPadded
89505>>>>>>>>>>>>>>>    Integer iCount
89505>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
89505>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
89506>>>>>>>>>>>>>>>
89506>>>>>>>>>>>>>>>    Get pRefactorResponse To RefactorResponse
89507>>>>>>>>>>>>>>>    Move (Sizeofarray(RefactorResponse)) To iCount
89508>>>>>>>>>>>>>>>    Move (lowercase(sObject)) To RefactorResponse[iCount].sObject
89509>>>>>>>>>>>>>>>    Move eResponse            To RefactorResponse[iCount].eResponse
89510>>>>>>>>>>>>>>>    Move bPadded              To RefactorResponse[iCount].bPadded
89511>>>>>>>>>>>>>>>    Set pRefactorResponse To RefactorResponse
89512>>>>>>>>>>>>>>>  End_Procedure
89513>>>>>>>>>>>>>>>
89513>>>>>>>>>>>>>>>  Procedure ClearRefactorAutoResponse
89515>>>>>>>>>>>>>>>    tRefactorResponse[] AutoResponse
89515>>>>>>>>>>>>>>>    tRefactorResponse[] AutoResponse
89516>>>>>>>>>>>>>>>    Move (ResizeArray(AutoResponse,0)) To AutoResponse
89517>>>>>>>>>>>>>>>    Set pRefactorResponse To AutoResponse
89518>>>>>>>>>>>>>>>  End_Procedure
89519>>>>>>>>>>>>>>>
89519>>>>>>>>>>>>>>>  Procedure WipeUntilPosition Integer iPos String ByRef sLine
89521>>>>>>>>>>>>>>>    Integer iChar
89521>>>>>>>>>>>>>>>    If (iPos>0) Begin
89523>>>>>>>>>>>>>>>      For iChar From 1 To (iPos-1)
89529>>>>>>>>>>>>>>>>
89529>>>>>>>>>>>>>>>        Move (Overstrike(" ",sLine,iChar)) To sLine
89530>>>>>>>>>>>>>>>      Loop
89531>>>>>>>>>>>>>>>>
89531>>>>>>>>>>>>>>>    End
89531>>>>>>>>>>>>>>>>
89531>>>>>>>>>>>>>>>  End_Procedure
89532>>>>>>>>>>>>>>>
89532>>>>>>>>>>>>>>>  //
89532>>>>>>>>>>>>>>>  // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
89532>>>>>>>>>>>>>>>  // send/get/set as the first string and that complicates our detection.
89532>>>>>>>>>>>>>>>  // What this does is simply overwrite everything with spaces before our methods if
89532>>>>>>>>>>>>>>>  // we have such a compound statement.
89532>>>>>>>>>>>>>>>  // The variable sLine is not always lowercase.
89532>>>>>>>>>>>>>>>  //
89532>>>>>>>>>>>>>>>  Procedure ClearFirstCompoundBeforeMethod String ByRef sLine
89534>>>>>>>>>>>>>>>    Integer iPos
89534>>>>>>>>>>>>>>>    String  sLtrimLine
89534>>>>>>>>>>>>>>>
89534>>>>>>>>>>>>>>>    Move (lowercase(LTrim(sLine))) To sLTrimLine
89535>>>>>>>>>>>>>>>    If (Left(sLtrimLine,3)="if " or Left(sLtrimLine,5)="else " or Left(sLtrimLine,7)="on_key ") Begin
89537>>>>>>>>>>>>>>>      // a line that starts with an if or else can still call a method
89537>>>>>>>>>>>>>>>      Move (Pos("send ",lowercase(sLine))) To iPos
89538>>>>>>>>>>>>>>>      If (iPos=0) ;        Move (Pos("get ",lowercase(sLine))) To iPos
89541>>>>>>>>>>>>>>>      If (iPos=0) ;        Move (Pos("set ",lowercase(sLine))) To iPos
89544>>>>>>>>>>>>>>>      Send WipeUntilPosition iPos (&sLine)
89545>>>>>>>>>>>>>>>    End
89545>>>>>>>>>>>>>>>>
89545>>>>>>>>>>>>>>>  End_Procedure
89546>>>>>>>>>>>>>>>
89546>>>>>>>>>>>>>>>  Procedure RefactorDropSelf
89548>>>>>>>>>>>>>>>    Boolean bAutoResponse
89548>>>>>>>>>>>>>>>    Boolean bSuggestReplace
89548>>>>>>>>>>>>>>>    Boolean bPadded
89548>>>>>>>>>>>>>>>    Boolean bRemember
89548>>>>>>>>>>>>>>>    Boolean bCanceled
89548>>>>>>>>>>>>>>>    Integer iPos
89548>>>>>>>>>>>>>>>    Integer iPosStart
89548>>>>>>>>>>>>>>>    Integer iPosEnd
89548>>>>>>>>>>>>>>>    Integer iLevel
89548>>>>>>>>>>>>>>>    Integer iStartLine
89548>>>>>>>>>>>>>>>    Integer iLine
89548>>>>>>>>>>>>>>>    Integer iLineCount
89548>>>>>>>>>>>>>>>    Integer iLength
89548>>>>>>>>>>>>>>>    Integer eResponse
89548>>>>>>>>>>>>>>>    String  sLine
89548>>>>>>>>>>>>>>>    String  sFind
89548>>>>>>>>>>>>>>>    String  sReplace
89548>>>>>>>>>>>>>>>    String  sPad
89548>>>>>>>>>>>>>>>
89548>>>>>>>>>>>>>>>    Move False To bCanceled
89549>>>>>>>>>>>>>>>    Send ClearRefactorAutoResponse
89550>>>>>>>>>>>>>>>    Get pbRefactorPadReplaceString To bPadded
89551>>>>>>>>>>>>>>>    Get CurrentLine To iStartLine
89552>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
89553>>>>>>>>>>>>>>>    For iLine From iStartLine To iLineCount
89559>>>>>>>>>>>>>>>>
89559>>>>>>>>>>>>>>>      Move False To bSuggestReplace
89560>>>>>>>>>>>>>>>      Get PreParsedLine iLine To sLine
89561>>>>>>>>>>>>>>>      Move (Lowercase(sLine)) To sLine
89562>>>>>>>>>>>>>>>      Move (Pos("(self)",sLine)) To iPos
89563>>>>>>>>>>>>>>>      If (iPos>0) Begin
89565>>>>>>>>>>>>>>>        Send ClearFirstCompoundBeforeMethod (&sLine)
89566>>>>>>>>>>>>>>>        Move (Pos("(self)",sLine)) To iPos
89567>>>>>>>>>>>>>>>      End
89567>>>>>>>>>>>>>>>>
89567>>>>>>>>>>>>>>>      If (iPos>0) Begin // only check if there's a self in the line
89569>>>>>>>>>>>>>>>        If (Left(LTrim(sLine),5)="send ") Begin
89571>>>>>>>>>>>>>>>          Move (Pos(" to ",sLine)) To iPosStart
89572>>>>>>>>>>>>>>>          If (iPosStart=0) ;            Move (Pos(" of ",sLine)) To iPosStart
89575>>>>>>>>>>>>>>>          If (iPosStart<>0) Begin
89577>>>>>>>>>>>>>>>            Move (Length(sLine)) To iLength
89578>>>>>>>>>>>>>>>            Send RefactorLocateSourceObject sLine iPos iLength (&iPosStart) (&iPosEnd) (&iLevel)
89579>>>>>>>>>>>>>>>            Get Value iLine To sLine // real line data
89580>>>>>>>>>>>>>>>            Move (Mid(sLine,iPosEnd-iPosStart+1,iPosStart)) To sFind
89581>>>>>>>>>>>>>>>            Move sFind To sReplace
89582>>>>>>>>>>>>>>>            If (iLevel=2) Begin // not supporting multiple levels atm
89584>>>>>>>>>>>>>>>              Move (Left(sReplace,RightPos("(",sReplace)-1)) To sReplace
89585>>>>>>>>>>>>>>>              Move (Replace("(",sReplace,"")) To sReplace
89586>>>>>>>>>>>>>>>            End
89586>>>>>>>>>>>>>>>>
89586>>>>>>>>>>>>>>>            If (iLevel=2) Begin
89588>>>>>>>>>>>>>>>              Get IsDropSelfReplaceTargetValid sReplace To bSuggestReplace
89589>>>>>>>>>>>>>>>            End
89589>>>>>>>>>>>>>>>>
89589>>>>>>>>>>>>>>>          End
89589>>>>>>>>>>>>>>>>
89589>>>>>>>>>>>>>>>        End
89589>>>>>>>>>>>>>>>>
89589>>>>>>>>>>>>>>>        If (Left(LTrim(sLine),4)="get " or Left(LTrim(sLine),4)="set ") Begin
89591>>>>>>>>>>>>>>>          Move (Pos(" of ",sLine)) To iPosStart
89592>>>>>>>>>>>>>>>          If (iPosStart<>0) Begin
89594>>>>>>>>>>>>>>>            Move (Pos(" to ",sLine)) To iLength // don't search past the " to " bit
89595>>>>>>>>>>>>>>>            Send RefactorLocateSourceObject sLine iPos iLength (&iPosStart) (&iPosEnd) (&iLevel)
89596>>>>>>>>>>>>>>>            Get Value iLine To sLine // real line data
89597>>>>>>>>>>>>>>>            Move (Mid(sLine,iPosEnd-iPosStart+1,iPosStart)) To sFind
89598>>>>>>>>>>>>>>>            Move sFind To sReplace
89599>>>>>>>>>>>>>>>            If (iLevel=2) Begin // not supporting multiple levels atm
89601>>>>>>>>>>>>>>>              Move (Left(sReplace,RightPos("(",sReplace)-1)) To sReplace
89602>>>>>>>>>>>>>>>              Move (Replace("(",sReplace,"")) To sReplace
89603>>>>>>>>>>>>>>>            End
89603>>>>>>>>>>>>>>>>
89603>>>>>>>>>>>>>>>            If (iLevel=2) Begin
89605>>>>>>>>>>>>>>>              Get IsDropSelfReplaceTargetValid sReplace To bSuggestReplace
89606>>>>>>>>>>>>>>>            End
89606>>>>>>>>>>>>>>>>
89606>>>>>>>>>>>>>>>          End
89606>>>>>>>>>>>>>>>>
89606>>>>>>>>>>>>>>>        End
89606>>>>>>>>>>>>>>>>
89606>>>>>>>>>>>>>>>        If (bSuggestReplace) Begin
89608>>>>>>>>>>>>>>>          Move False To bAutoResponse
89609>>>>>>>>>>>>>>>          Get RefactorObjectAutoResponse sFind To eResponse
89610>>>>>>>>>>>>>>>          If (eResponse=0) Begin
89612>>>>>>>>>>>>>>>            Get RefactorReplaceObjectConfirmation iLine sFind sReplace bPadded bRemember To eResponse
89613>>>>>>>>>>>>>>>          End
89613>>>>>>>>>>>>>>>>
89613>>>>>>>>>>>>>>>          Else Begin
89614>>>>>>>>>>>>>>>            Move True To bAutoResponse
89615>>>>>>>>>>>>>>>          End
89615>>>>>>>>>>>>>>>>
89615>>>>>>>>>>>>>>>          If (IsFlagIn(MBR_CHECKED,eResponse)) Begin
89617>>>>>>>>>>>>>>>            Move True To bPadded
89618>>>>>>>>>>>>>>>            Move (eResponse-MBR_CHECKED) To eResponse
89619>>>>>>>>>>>>>>>          End
89619>>>>>>>>>>>>>>>>
89619>>>>>>>>>>>>>>>          Else Begin
89620>>>>>>>>>>>>>>>            Move False To bPadded
89621>>>>>>>>>>>>>>>          End
89621>>>>>>>>>>>>>>>>
89621>>>>>>>>>>>>>>>          If (IsFlagIn(MBR_CHECKED2,eResponse)) Begin
89623>>>>>>>>>>>>>>>            Move (eResponse-MBR_CHECKED2) To eResponse
89624>>>>>>>>>>>>>>>            Send AddObjectToRefactorAutoResponse sFind eResponse bPadded
89625>>>>>>>>>>>>>>>            Move True To bRemember
89626>>>>>>>>>>>>>>>          End
89626>>>>>>>>>>>>>>>>
89626>>>>>>>>>>>>>>>          Else If (not(bAutoResponse)) Begin
89629>>>>>>>>>>>>>>>            Move False To bRemember
89630>>>>>>>>>>>>>>>          End
89630>>>>>>>>>>>>>>>>
89630>>>>>>>>>>>>>>>
89630>>>>>>>>>>>>>>>          If (eResponse=MBR_Cancel) Begin
89632>>>>>>>>>>>>>>>            Move True To bCanceled
89633>>>>>>>>>>>>>>>            Move iLineCount To iLine
89634>>>>>>>>>>>>>>>          End
89634>>>>>>>>>>>>>>>>
89634>>>>>>>>>>>>>>>          Else If (eResponse=MBR_Yes) Begin
89637>>>>>>>>>>>>>>>            Set pbRefactorPadReplaceString To bPadded
89638>>>>>>>>>>>>>>>            If (bPadded) ;              Move "        " To sPad // the 8 spaces are so that you do not have to re-align your code manually
89641>>>>>>>>>>>>>>>            Else ;              Move ""         To sPad
89643>>>>>>>>>>>>>>>            Move (Replace(sFind,sLine,sReplace+sPad)) To sLine
89644>>>>>>>>>>>>>>>            Send EditorMessage SCI_BEGINUNDOACTION
89645>>>>>>>>>>>>>>>            Set Value iLine To sLine
89646>>>>>>>>>>>>>>>            Send EditorMessage SCI_ENDUNDOACTION
89647>>>>>>>>>>>>>>>          End
89647>>>>>>>>>>>>>>>>
89647>>>>>>>>>>>>>>>        End
89647>>>>>>>>>>>>>>>>
89647>>>>>>>>>>>>>>>      End
89647>>>>>>>>>>>>>>>>
89647>>>>>>>>>>>>>>>    Loop
89648>>>>>>>>>>>>>>>>
89648>>>>>>>>>>>>>>>    If (bSuggestReplace=false and bCanceled=false) Begin
89650>>>>>>>>>>>>>>>      Set Status_Help To (_T("Drop Self: No more occurrences have been found.",1606))
89651>>>>>>>>>>>>>>>      Send Request_Status_Help True
89652>>>>>>>>>>>>>>>    End
89652>>>>>>>>>>>>>>>>
89652>>>>>>>>>>>>>>>  End_Procedure
89653>>>>>>>>>>>>>>>
89653>>>>>>>>>>>>>>>  //
89653>>>>>>>>>>>>>>>  // Process the whole file and adjust the case of all scope and keywords to match the casing
89653>>>>>>>>>>>>>>>  // as defined in the language configuration.
89653>>>>>>>>>>>>>>>  //
89653>>>>>>>>>>>>>>>  Procedure RefactorNormalizeCase
89655>>>>>>>>>>>>>>>    Boolean bChanged
89655>>>>>>>>>>>>>>>    Integer iCurrentLine
89655>>>>>>>>>>>>>>>    Integer iLine
89655>>>>>>>>>>>>>>>    Integer iLineCount
89655>>>>>>>>>>>>>>>    
89655>>>>>>>>>>>>>>>    Get CurrentLine  To iCurrentLine
89656>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
89657>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
89658>>>>>>>>>>>>>>>    Send GotoLine iLineCount
89659>>>>>>>>>>>>>>>    Send PumpMsgQueue Of Desktop
89660>>>>>>>>>>>>>>>    Send GotoLine 1
89661>>>>>>>>>>>>>>>    For iLine From 0 To (iLineCount-1)
89667>>>>>>>>>>>>>>>>
89667>>>>>>>>>>>>>>>      Get LineNormalizeCase iLine false To bChanged
89668>>>>>>>>>>>>>>>    Loop
89669>>>>>>>>>>>>>>>>
89669>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
89670>>>>>>>>>>>>>>>    Send GotoLine iCurrentLine
89671>>>>>>>>>>>>>>>  End_Procedure
89672>>>>>>>>>>>>>>>  
89672>>>>>>>>>>>>>>>  //
89672>>>>>>>>>>>>>>>  // For re-indenting we want to know if we are on a case statement
89672>>>>>>>>>>>>>>>  //
89672>>>>>>>>>>>>>>>  Function LineIsCaseStatement String sLine Returns Integer
89674>>>>>>>>>>>>>>>    Boolean bIsCase
89674>>>>>>>>>>>>>>>    Integer eCaseStatus
89674>>>>>>>>>>>>>>>    Integer iFirstChar
89674>>>>>>>>>>>>>>>
89674>>>>>>>>>>>>>>>    Move CI_NoCaseStatement To eCaseStatus
89675>>>>>>>>>>>>>>>    Move (Length(sLine)-Length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
89676>>>>>>>>>>>>>>>    If (lowercase(Mid(sLine,4,iFirstChar+1))="case") Begin
89678>>>>>>>>>>>>>>>      Move True To bIsCase
89679>>>>>>>>>>>>>>>    End
89679>>>>>>>>>>>>>>>>
89679>>>>>>>>>>>>>>>    If (bIsCase) Begin
89681>>>>>>>>>>>>>>>      Move (LTrim(lowercase(sLine))) To sLine
89682>>>>>>>>>>>>>>>      Move (Right(sLine,Length(sLine)-4))  To sLine
89683>>>>>>>>>>>>>>>      Move (LTrim(sLine)) To sLine
89684>>>>>>>>>>>>>>>      If (Left(sLine,5)="begin") Begin
89686>>>>>>>>>>>>>>>        Move CI_CaseBegin To eCaseStatus
89687>>>>>>>>>>>>>>>      End
89687>>>>>>>>>>>>>>>>
89687>>>>>>>>>>>>>>>      Else If (Left(sLine,5)="break") Begin
89690>>>>>>>>>>>>>>>        Move CI_CaseBreak To eCaseStatus
89691>>>>>>>>>>>>>>>      End
89691>>>>>>>>>>>>>>>>
89691>>>>>>>>>>>>>>>      Else If (Left(sLine,3)="end") Begin
89694>>>>>>>>>>>>>>>        Move CI_CaseEnd To eCaseStatus
89695>>>>>>>>>>>>>>>      End
89695>>>>>>>>>>>>>>>>
89695>>>>>>>>>>>>>>>      Else Begin
89696>>>>>>>>>>>>>>>        Move CI_CaseCondition To eCaseStatus
89697>>>>>>>>>>>>>>>      End
89697>>>>>>>>>>>>>>>>
89697>>>>>>>>>>>>>>>    End
89697>>>>>>>>>>>>>>>>
89697>>>>>>>>>>>>>>>    Function_Return eCaseStatus
89698>>>>>>>>>>>>>>>  End_Function
89699>>>>>>>>>>>>>>>
89699>>>>>>>>>>>>>>>  //
89699>>>>>>>>>>>>>>>  // If we have a single line if/else statement that has its compound statement
89699>>>>>>>>>>>>>>>  // broken up over multiple lines using a semicolumn then we want an indentation
89699>>>>>>>>>>>>>>>  // on the next line.
89699>>>>>>>>>>>>>>>  // iLine = line of source code
89699>>>>>>>>>>>>>>>  // sLine = content of line
89699>>>>>>>>>>>>>>>  // bIndentActive = if already indenting because of this rule then there might be another line
89699>>>>>>>>>>>>>>>  //                 that ends on a ; and thus also needs the indent.
89699>>>>>>>>>>>>>>>  //
89699>>>>>>>>>>>>>>>  Function LineIsSingleLineIfElseStatement Integer iLine String sLine Boolean bIndentActive Returns Boolean
89701>>>>>>>>>>>>>>>    Boolean bIsIfElse
89701>>>>>>>>>>>>>>>    Integer iFirstChar
89701>>>>>>>>>>>>>>>
89701>>>>>>>>>>>>>>>    Move False To bIsIfElse
89702>>>>>>>>>>>>>>>    Move (Length(sLine)-Length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
89703>>>>>>>>>>>>>>>    Move (RTrim(lowercase(sLine))) To sLine
89704>>>>>>>>>>>>>>>    If ((Mid(sLine,3,iFirstChar+1)="if ") or (Mid(sLine,5,iFirstChar+1)="else ") or (Mid(sLine,5,iFirstChar+1)="else;") or bIndentActive) Begin
89706>>>>>>>>>>>>>>>      Get PreParsedLine iLine To sLine // strip any comments if there are any
89707>>>>>>>>>>>>>>>      If (Right(sLine,1)=";") Begin
89709>>>>>>>>>>>>>>>        Move True To bIsIfElse
89710>>>>>>>>>>>>>>>      End
89710>>>>>>>>>>>>>>>>
89710>>>>>>>>>>>>>>>    End
89710>>>>>>>>>>>>>>>>
89710>>>>>>>>>>>>>>>    Function_Return bIsIfElse
89711>>>>>>>>>>>>>>>  End_Function
89712>>>>>>>>>>>>>>>  
89712>>>>>>>>>>>>>>>  //
89712>>>>>>>>>>>>>>>  // Function returns true if the line of code we are on define's a command macro.
89712>>>>>>>>>>>>>>>  // We do not want to change the indentation on a macro definition
89712>>>>>>>>>>>>>>>  //
89712>>>>>>>>>>>>>>>  Function LineIsCommandMacro Integer iLine String sLine Boolean bMacroCommandOpen Returns Boolean
89714>>>>>>>>>>>>>>>    Boolean bIsCommandMacro
89714>>>>>>>>>>>>>>>    Boolean bHasFoldPoint
89714>>>>>>>>>>>>>>>    
89714>>>>>>>>>>>>>>>    Move bMacroCommandOpen To bIsCommandMacro
89715>>>>>>>>>>>>>>>    Get LineHasFoldPoint iLine To bHasFoldPoint
89716>>>>>>>>>>>>>>>    If (bHasFoldPoint Or bMacroCommandOpen) Begin
89718>>>>>>>>>>>>>>>      Move (LTrim(sLine)) To sLine
89719>>>>>>>>>>>>>>>      If (Left(sLine,1)="#") Begin
89721>>>>>>>>>>>>>>>        Move (Uppercase(sLine)) To sLine
89722>>>>>>>>>>>>>>>        If (Left(sLine,9)="#COMMAND ") Begin
89724>>>>>>>>>>>>>>>          Move True To bIsCommandMacro
89725>>>>>>>>>>>>>>>        End
89725>>>>>>>>>>>>>>>>
89725>>>>>>>>>>>>>>>        Else If (Left(sLine,11)="#ENDCOMMAND") Begin
89728>>>>>>>>>>>>>>>          Move False To bIsCommandMacro
89729>>>>>>>>>>>>>>>        End
89729>>>>>>>>>>>>>>>>
89729>>>>>>>>>>>>>>>      End
89729>>>>>>>>>>>>>>>>
89729>>>>>>>>>>>>>>>    End
89729>>>>>>>>>>>>>>>>
89729>>>>>>>>>>>>>>>    Function_Return bIsCommandMacro
89730>>>>>>>>>>>>>>>  End_Function
89731>>>>>>>>>>>>>>>
89731>>>>>>>>>>>>>>>  Procedure RefactorReIndent
89733>>>>>>>>>>>>>>>    Boolean bUseTabs
89733>>>>>>>>>>>>>>>    Boolean bIsDfImage
89733>>>>>>>>>>>>>>>    Boolean bIsIfElse bIsIfElseIndent
89733>>>>>>>>>>>>>>>    Boolean bMacroCommandOpen
89733>>>>>>>>>>>>>>>    Integer eCaseStatus
89733>>>>>>>>>>>>>>>    Integer iCurrentLine
89733>>>>>>>>>>>>>>>    Integer iLine
89733>>>>>>>>>>>>>>>    Integer iLineCount
89733>>>>>>>>>>>>>>>    Integer iTabSize
89733>>>>>>>>>>>>>>>    Integer iCaseLevel
89733>>>>>>>>>>>>>>>    Integer iPrevLevel
89733>>>>>>>>>>>>>>>    String  sIndent
89733>>>>>>>>>>>>>>>    String  sTab sTabLevel
89733>>>>>>>>>>>>>>>    String  sLine
89733>>>>>>>>>>>>>>>    String  sLineSave
89733>>>>>>>>>>>>>>>    UChar[] ucaLine
89734>>>>>>>>>>>>>>>    Address aTextData
89734>>>>>>>>>>>>>>>    UChar[] TextData
89735>>>>>>>>>>>>>>>  
89735>>>>>>>>>>>>>>>    Move 0 To iCaseLevel
89736>>>>>>>>>>>>>>>    Move (ResizeArray(TextData,0)) To TextData
89737>>>>>>>>>>>>>>>    Move False To bIsIfElseIndent
89738>>>>>>>>>>>>>>>    Move False To bMacroCommandOpen
89739>>>>>>>>>>>>>>>    Get CurrentLine To iCurrentLine
89740>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH To iTabSize
89741>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS  To bUseTabs
89742>>>>>>>>>>>>>>>    If (bUseTabs) ;      Move (Character(9)) To sTab
89745>>>>>>>>>>>>>>>    Else ;      Move (Repeat(" ",iTabSize)) To sTab
89747>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
89748>>>>>>>>>>>>>>>    Send GotoLine iLineCount
89749>>>>>>>>>>>>>>>    Send PumpMsgQueue Of Desktop
89750>>>>>>>>>>>>>>>    Send GotoLine 1
89751>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
89752>>>>>>>>>>>>>>>    For iLine From 0 To (iLineCount-1)
89758>>>>>>>>>>>>>>>>
89758>>>>>>>>>>>>>>>      Get SC_GetLine Item iLine To sLine
89759>>>>>>>>>>>>>>>      If (RTrim(sLine)<>"") Begin
89761>>>>>>>>>>>>>>>        Get LineIsDfImage iLine sLine To bIsDfImage
89762>>>>>>>>>>>>>>>        If (bIsDfImage=False) Begin
89764>>>>>>>>>>>>>>>          Get LineIsCaseStatement sLine To eCaseStatus
89765>>>>>>>>>>>>>>>          If (eCaseStatus<>CI_NoCaseStatement) Begin
89767>>>>>>>>>>>>>>>            If (eCaseStatus=CI_CaseBegin) Begin
89769>>>>>>>>>>>>>>>              Increment iCaseLevel
89770>>>>>>>>>>>>>>>            End
89770>>>>>>>>>>>>>>>>
89770>>>>>>>>>>>>>>>            Else If (eCaseStatus=CI_CaseEnd) Begin
89773>>>>>>>>>>>>>>>              Decrement iCaseLevel
89774>>>>>>>>>>>>>>>            End
89774>>>>>>>>>>>>>>>>
89774>>>>>>>>>>>>>>>          End
89774>>>>>>>>>>>>>>>>
89774>>>>>>>>>>>>>>>          Get LineIsSingleLineIfElseStatement iLine sLine bIsIfElseIndent To bIsIfElse
89775>>>>>>>>>>>>>>>          Get LineIsCommandMacro iLine sLine bMacroCommandOpen To bMacroCommandOpen
89776>>>>>>>>>>>>>>>          If (bMacroCommandOpen) Begin
89778>>>>>>>>>>>>>>>            Move sLine To sLineSave
89779>>>>>>>>>>>>>>>          End
89779>>>>>>>>>>>>>>>>
89779>>>>>>>>>>>>>>>          Move (LTrim(sLine))  To sLine
89780>>>>>>>>>>>>>>>          If (bIsIfElseIndent) Begin                      // don't indent on begin after single line if/else
89782>>>>>>>>>>>>>>>            If (Left(Lowercase(sLine),6)="begin ") Begin // scenario pointed out by Mike (Starzen), see
89784>>>>>>>>>>>>>>>              Move false To bIsIfElseIndent               // bug https://projects.vdf-guidance.com/issues/127
89785>>>>>>>>>>>>>>>            End
89785>>>>>>>>>>>>>>>>
89785>>>>>>>>>>>>>>>          End
89785>>>>>>>>>>>>>>>>
89785>>>>>>>>>>>>>>>          Get ReIndentLineIndentation iLine iLineCount iTabSize bUseTabs (&iPrevLevel) To sIndent
89786>>>>>>>>>>>>>>>          If (iCaseLevel>0) Begin
89788>>>>>>>>>>>>>>>            If (eCaseStatus=CI_NoCaseStatement or eCaseStatus=CI_CaseEnd or (eCaseStatus=CI_CaseBreak and pbIndentCaseBreak(Self))) Begin
89790>>>>>>>>>>>>>>>              Move (Repeat(sTab,iCaseLevel)) To sTabLevel
89791>>>>>>>>>>>>>>>              Move (sIndent+sTabLevel) To sIndent
89792>>>>>>>>>>>>>>>            End
89792>>>>>>>>>>>>>>>>
89792>>>>>>>>>>>>>>>            Else Begin
89793>>>>>>>>>>>>>>>              Move (Repeat(sTab,iCaseLevel-1)) To sTabLevel
89794>>>>>>>>>>>>>>>              Move (sIndent+sTabLevel) To sIndent
89795>>>>>>>>>>>>>>>            End
89795>>>>>>>>>>>>>>>>
89795>>>>>>>>>>>>>>>          End
89795>>>>>>>>>>>>>>>>
89795>>>>>>>>>>>>>>>          If (bIsIfElseIndent) Begin
89797>>>>>>>>>>>>>>>            Move (sIndent+sTab) To sIndent
89798>>>>>>>>>>>>>>>          End
89798>>>>>>>>>>>>>>>>
89798>>>>>>>>>>>>>>>          Move (sIndent+sLine) To sLine
89799>>>>>>>>>>>>>>>          If (bMacroCommandOpen) Begin
89801>>>>>>>>>>>>>>>            Move sLineSave To sLine
89802>>>>>>>>>>>>>>>          End
89802>>>>>>>>>>>>>>>>
89802>>>>>>>>>>>>>>>          Move bIsIfElse To bIsIfElseIndent
89803>>>>>>>>>>>>>>>        End
89803>>>>>>>>>>>>>>>>
89803>>>>>>>>>>>>>>>      End
89803>>>>>>>>>>>>>>>>
89803>>>>>>>>>>>>>>>      Move (StringToUCharArray(sLine)) To ucaLine
89804>>>>>>>>>>>>>>>      Move (AppendArray(TextData,ucaLine)) To TextData
89805>>>>>>>>>>>>>>>    Loop
89806>>>>>>>>>>>>>>>>
89806>>>>>>>>>>>>>>>    Move 0 To TextData[SizeOfArray(TextData)]  // add a zero at the end
89807>>>>>>>>>>>>>>>    Move (AddressOf(TextData)) To aTextData
89808>>>>>>>>>>>>>>>    If (aTextData<>0) Begin
89810>>>>>>>>>>>>>>>      Send EditorMessage SCI_CLEARALL 0 0
89811>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETTEXT  0 aTextData
89812>>>>>>>>>>>>>>>    End
89812>>>>>>>>>>>>>>>>
89812>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
89813>>>>>>>>>>>>>>>    Send GotoLine iCurrentLine
89814>>>>>>>>>>>>>>>  End_Procedure
89815>>>>>>>>>>>>>>>    
89815>>>>>>>>>>>>>>>End_Class
89816>>>>>>>>>>>>>Use cEditorHotKey_Mixin.pkg
Including file: cEditorHotKey_Mixin.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cEditorHotKey_Mixin.pkg)
89816>>>>>>>>>>>>>>>Use cSciLexer.h
89816>>>>>>>>>>>>>>>
89816>>>>>>>>>>>>>>>Register_Procedure CME_Find
89816>>>>>>>>>>>>>>>Register_Procedure CME_FindNext
89816>>>>>>>>>>>>>>>Register_Procedure CME_FindPrevious
89816>>>>>>>>>>>>>>>Register_Procedure CME_FindReplace
89816>>>>>>>>>>>>>>>Register_Procedure CME_GotoLine
89816>>>>>>>>>>>>>>>Register_Procedure CME_SelectAll
89816>>>>>>>>>>>>>>>Register_Function phoEditorEditView Returns Handle // it's actually a property, but this should do
89816>>>>>>>>>>>>>>>Register_Procedure CAPopUpFindInFiles
89816>>>>>>>>>>>>>>>Register_Procedure CASaveFile
89816>>>>>>>>>>>>>>>Register_Procedure CASaveFileAs
89816>>>>>>>>>>>>>>>Register_Procedure CASaveAllFiles
89816>>>>>>>>>>>>>>>Register_Procedure CACloseFile
89816>>>>>>>>>>>>>>>Register_Procedure CACloseAllFiles
89816>>>>>>>>>>>>>>>Register_Procedure CASelectWorkSpace
89816>>>>>>>>>>>>>>>Register_Procedure CABuildRun
89816>>>>>>>>>>>>>>>Register_Procedure CABuildRunCurrent
89816>>>>>>>>>>>>>>>Register_Procedure CABuildCompile
89816>>>>>>>>>>>>>>>Register_Procedure CABuildPreCompile
89816>>>>>>>>>>>>>>>Register_Procedure CABuildExecute
89816>>>>>>>>>>>>>>>Register_Procedure CABuildDebugRun
89816>>>>>>>>>>>>>>>Register_Procedure CABuildDebugRunCurrent
89816>>>>>>>>>>>>>>>
89816>>>>>>>>>>>>>>>Register_Procedure Define_EditViewHotkeys Handle hoEditView
89816>>>>>>>>>>>>>>>
89816>>>>>>>>>>>>>>>//
89816>>>>>>>>>>>>>>>// The hotkeys have to be defined in any object that is part of the main Editor view and as
89816>>>>>>>>>>>>>>>// such it is best declared in a mixin, so that it becomes easy to include.
89816>>>>>>>>>>>>>>>//
89816>>>>>>>>>>>>>>>Class cEditorHotKey_Mixin is a Mixin
89817>>>>>>>>>>>>>>>
89817>>>>>>>>>>>>>>>  Procedure Define_cEditorHotKey_Mixin
89819>>>>>>>>>>>>>>>    Send Define_EditorHotKeys
89820>>>>>>>>>>>>>>>  End_Procedure
89821>>>>>>>>>>>>>>>  
89821>>>>>>>>>>>>>>>  //
89821>>>>>>>>>>>>>>>  // If the focus is not in the editorview or editor control itself then it might even be outside of
89821>>>>>>>>>>>>>>>  // the client area (like in one of the toolpanels). In that case we need to reroute the hotkey action
89821>>>>>>>>>>>>>>>  // to the editor control. In that case we override this function and return true, so that we know
89821>>>>>>>>>>>>>>>  // the action needs to be rerouted.
89821>>>>>>>>>>>>>>>  //
89821>>>>>>>>>>>>>>>  Function RerouteHotKeys Returns Boolean
89823>>>>>>>>>>>>>>>    Function_Return False
89824>>>>>>>>>>>>>>>  End_Function
89825>>>>>>>>>>>>>>>  
89825>>>>>>>>>>>>>>>  Function IsInEditorView Returns Boolean
89827>>>>>>>>>>>>>>>    Boolean bInEditView
89827>>>>>>>>>>>>>>>    Integer hoEditView
89827>>>>>>>>>>>>>>>    
89827>>>>>>>>>>>>>>>    Move False To bInEditView
89828>>>>>>>>>>>>>>>    Get phoEditorEditView To hoEditView
89829>>>>>>>>>>>>>>>    If (hoEditView=Self) Begin
89831>>>>>>>>>>>>>>>      Move True To bInEditView
89832>>>>>>>>>>>>>>>    End
89832>>>>>>>>>>>>>>>>
89832>>>>>>>>>>>>>>>    Function_Return bInEditView
89833>>>>>>>>>>>>>>>  End_Function
89834>>>>>>>>>>>>>>>
89834>>>>>>>>>>>>>>>  Procedure DefineOnKey Integer iCmd Integer iMsg
89836>>>>>>>>>>>>>>>    Boolean bInEditView
89836>>>>>>>>>>>>>>>    Handle  hoEdit
89836>>>>>>>>>>>>>>>    Integer iDfKey
89836>>>>>>>>>>>>>>>    String  sKey
89836>>>>>>>>>>>>>>>    tSciCommandHotKey Command
89836>>>>>>>>>>>>>>>    tSciCommandHotKey Command
89836>>>>>>>>>>>>>>>
89836>>>>>>>>>>>>>>>    Get CMCommandToHotKeyStr iCmd To sKey
89837>>>>>>>>>>>>>>>    If (sKey<>"") Begin
89839>>>>>>>>>>>>>>>      Get IsInEditorView To bInEditView
89840>>>>>>>>>>>>>>>      If (bInEditView) Begin // only run in EditorEditView
89842>>>>>>>>>>>>>>>        Get phoCodeMaxEditor To hoEdit
89843>>>>>>>>>>>>>>>        If (hoEdit) Begin
89845>>>>>>>>>>>>>>>          // if we define a new keybinding, then we need to remove any old keybinding also
89845>>>>>>>>>>>>>>>          // as otherwise you end up with both actions.
89845>>>>>>>>>>>>>>>          Send RegisterKeyBindingToClear of hoEdit sKey
89846>>>>>>>>>>>>>>>        End
89846>>>>>>>>>>>>>>>>
89846>>>>>>>>>>>>>>>      End
89846>>>>>>>>>>>>>>>>
89846>>>>>>>>>>>>>>>      Get FindCommand of oSciCommandHotKeys iCmd to Command
89847>>>>>>>>>>>>>>>      If (Command.iCmd=iCmd) Begin
89849>>>>>>>>>>>>>>>        If (SizeOfArray(Command.HotKey.VKcode)>0) Begin
89851>>>>>>>>>>>>>>>          Get DataFlexOnKey of oSciCommandHotKeys Command.HotKey  to iDfkey
89852>>>>>>>>>>>>>>>          On_Key iDFKey Send iMsg
89853>>>>>>>>>>>>>>>        End
89853>>>>>>>>>>>>>>>>
89853>>>>>>>>>>>>>>>        If (SizeOfArray(Command.HotKey2.VKcode)>0) Begin
89855>>>>>>>>>>>>>>>          Get DataFlexOnKey of oSciCommandHotKeys Command.HotKey2 to iDfkey
89856>>>>>>>>>>>>>>>          On_Key iDFKey Send iMsg
89857>>>>>>>>>>>>>>>        End
89857>>>>>>>>>>>>>>>>
89857>>>>>>>>>>>>>>>      End
89857>>>>>>>>>>>>>>>>
89857>>>>>>>>>>>>>>>    End
89857>>>>>>>>>>>>>>>>
89857>>>>>>>>>>>>>>>  End_Procedure
89858>>>>>>>>>>>>>>>
89858>>>>>>>>>>>>>>>  Procedure onPreHotKey Integer iCmd
89860>>>>>>>>>>>>>>>    Boolean bHasAlt
89860>>>>>>>>>>>>>>>
89860>>>>>>>>>>>>>>>    Get HotKeyHasAlt of oSciCommandHotKeys iCmd to bHasAlt
89861>>>>>>>>>>>>>>>    If (bHasAlt) Begin
89863>>>>>>>>>>>>>>>      Send DispatchHotkey
89864>>>>>>>>>>>>>>>    End
89864>>>>>>>>>>>>>>>>
89864>>>>>>>>>>>>>>>  End_Procedure
89865>>>>>>>>>>>>>>>
89865>>>>>>>>>>>>>>>  Procedure HKSC_GotoMatchBrace
89867>>>>>>>>>>>>>>>    Send onPreHotKey CMD_GOTOMATCHBRACE
89868>>>>>>>>>>>>>>>    Send GotoMatchBrace
89869>>>>>>>>>>>>>>>  End_Procedure
89870>>>>>>>>>>>>>>>
89870>>>>>>>>>>>>>>>  // HKSC => Hot Key SCintilla
89870>>>>>>>>>>>>>>>  Procedure HKSC_OpenFile
89872>>>>>>>>>>>>>>>    Send DispatchHotKey  // don't leak a shortcut key into the text window
89873>>>>>>>>>>>>>>>    Send CAOpenFile
89874>>>>>>>>>>>>>>>  End_Procedure
89875>>>>>>>>>>>>>>>
89875>>>>>>>>>>>>>>>  Procedure HKSC_NewFile
89877>>>>>>>>>>>>>>>    Send DispatchHotKey  // don't leak a shortcut key into the text window
89878>>>>>>>>>>>>>>>    Send CANewFile
89879>>>>>>>>>>>>>>>  End_Procedure
89880>>>>>>>>>>>>>>>
89880>>>>>>>>>>>>>>>  Procedure HKSC_Properties
89882>>>>>>>>>>>>>>>    Send onPreHotKey CMD_PROPERTIES
89883>>>>>>>>>>>>>>>    Send Properties
89884>>>>>>>>>>>>>>>  End_Procedure
89885>>>>>>>>>>>>>>>
89885>>>>>>>>>>>>>>>  Procedure HKSC_LineCut
89887>>>>>>>>>>>>>>>    Send SC_LineCut
89888>>>>>>>>>>>>>>>  End_Procedure
89889>>>>>>>>>>>>>>>
89889>>>>>>>>>>>>>>>  Procedure HKSC_LowercaseSelection
89891>>>>>>>>>>>>>>>    Send SC_LowercaseSelection
89892>>>>>>>>>>>>>>>  End_Procedure
89893>>>>>>>>>>>>>>>
89893>>>>>>>>>>>>>>>  Procedure HKSC_UppercaseSelection
89895>>>>>>>>>>>>>>>    Send SC_UppercaseSelection
89896>>>>>>>>>>>>>>>  End_Procedure
89897>>>>>>>>>>>>>>>
89897>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkToggle
89899>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKTOGGLE
89900>>>>>>>>>>>>>>>    Send BookmarkToggle
89901>>>>>>>>>>>>>>>  End_Procedure
89902>>>>>>>>>>>>>>>
89902>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkNext
89904>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKNEXT
89905>>>>>>>>>>>>>>>    Send BookmarkNext
89906>>>>>>>>>>>>>>>  End_Procedure
89907>>>>>>>>>>>>>>>
89907>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkPrevious
89909>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKPREV
89910>>>>>>>>>>>>>>>    Send BookmarkPrevious
89911>>>>>>>>>>>>>>>  End_Procedure
89912>>>>>>>>>>>>>>>
89912>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkClearAll
89914>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKCLEARALL
89915>>>>>>>>>>>>>>>    Send BookmarkClearAll
89916>>>>>>>>>>>>>>>  End_Procedure
89917>>>>>>>>>>>>>>>
89917>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkJumpToFirst
89919>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKJUMPTOFIRST
89920>>>>>>>>>>>>>>>    Send BookmarkJumpToFirst
89921>>>>>>>>>>>>>>>  End_Procedure
89922>>>>>>>>>>>>>>>
89922>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkJumpToLast
89924>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKJUMPTOLAST
89925>>>>>>>>>>>>>>>    Send BookmarkJumpToLast
89926>>>>>>>>>>>>>>>  End_Procedure
89927>>>>>>>>>>>>>>>
89927>>>>>>>>>>>>>>>  Procedure HKSC_MoveLineUp
89929>>>>>>>>>>>>>>>    Send onPreHotKey CMD_MOVELINEUP
89930>>>>>>>>>>>>>>>    Send MoveLineUp
89931>>>>>>>>>>>>>>>  End_Procedure
89932>>>>>>>>>>>>>>>
89932>>>>>>>>>>>>>>>  Procedure HKSC_MoveLineDown
89934>>>>>>>>>>>>>>>    Send onPreHotKey CMD_MOVELINEDOWN
89935>>>>>>>>>>>>>>>    Send MoveLineDown
89936>>>>>>>>>>>>>>>  End_Procedure
89937>>>>>>>>>>>>>>>
89937>>>>>>>>>>>>>>>  Procedure HKSC_DuplicateSelection
89939>>>>>>>>>>>>>>>    Send onPreHotKey CMD_DUPLICATESELECTION
89940>>>>>>>>>>>>>>>    Send DuplicateSelection
89941>>>>>>>>>>>>>>>  End_Procedure
89942>>>>>>>>>>>>>>>
89942>>>>>>>>>>>>>>>  Procedure HKSC_InsertHeaderGlobal
89944>>>>>>>>>>>>>>>    Send onPreHotKey CMD_ToolsInsertHeaderGlobal
89945>>>>>>>>>>>>>>>    Send InsertHeaderGlobal
89946>>>>>>>>>>>>>>>  End_Procedure
89947>>>>>>>>>>>>>>>
89947>>>>>>>>>>>>>>>  Procedure HKSC_InsertHeaderUser
89949>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ToolsInsertHeaderUser
89950>>>>>>>>>>>>>>>    Send InsertHeaderUser
89951>>>>>>>>>>>>>>>  End_Procedure
89952>>>>>>>>>>>>>>>
89952>>>>>>>>>>>>>>>  Procedure HKSC_OpenFileUnderCursor
89954>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_OpenFileUnderCursor
89955>>>>>>>>>>>>>>>    Send OpenFileUnderCursor
89956>>>>>>>>>>>>>>>  End_Procedure
89957>>>>>>>>>>>>>>>
89957>>>>>>>>>>>>>>>  Procedure HKSC_InsertRevision
89959>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_InsertRevisionMark
89960>>>>>>>>>>>>>>>    Send InsertRevision
89961>>>>>>>>>>>>>>>  End_Procedure
89962>>>>>>>>>>>>>>>
89962>>>>>>>>>>>>>>>  Procedure HKSC_InsertColorValue
89964>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_InsertColor
89965>>>>>>>>>>>>>>>    Send InsertColorValue
89966>>>>>>>>>>>>>>>  End_Procedure
89967>>>>>>>>>>>>>>>
89967>>>>>>>>>>>>>>>  Procedure HKSC_WindowSwitchToCodeView
89969>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowSwitchToCodeView
89970>>>>>>>>>>>>>>>    Send WindowSwitchToCodeView
89971>>>>>>>>>>>>>>>  End_Procedure
89972>>>>>>>>>>>>>>>
89972>>>>>>>>>>>>>>>  Procedure HKSC_PAWindowSwitchToErrorView
89974>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowSwitchToErrorView
89975>>>>>>>>>>>>>>>    Send PAWindowSwitchToErrorView
89976>>>>>>>>>>>>>>>  End_Procedure
89977>>>>>>>>>>>>>>>
89977>>>>>>>>>>>>>>>  Procedure HKSC_SyncCodeView
89979>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowSyncCodeView
89980>>>>>>>>>>>>>>>    Send SyncCodeView
89981>>>>>>>>>>>>>>>  End_Procedure
89982>>>>>>>>>>>>>>>
89982>>>>>>>>>>>>>>>  Procedure HKSC_CASwitchToNextView
89984>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowNextView
89985>>>>>>>>>>>>>>>    Send CASwitchToNextView
89986>>>>>>>>>>>>>>>  End_Procedure
89987>>>>>>>>>>>>>>>
89987>>>>>>>>>>>>>>>  Procedure HKSC_CASwitchToPreviousView
89989>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowPreviousView
89990>>>>>>>>>>>>>>>    Send CASwitchToPreviousView
89991>>>>>>>>>>>>>>>  End_Procedure
89992>>>>>>>>>>>>>>>
89992>>>>>>>>>>>>>>>  Procedure HKSC_ListCreator
89994>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListCreator
89995>>>>>>>>>>>>>>>    Send ListCreator
89996>>>>>>>>>>>>>>>  End_Procedure
89997>>>>>>>>>>>>>>>
89997>>>>>>>>>>>>>>>  Procedure HKSC_ListObjects
89999>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListObjects
90000>>>>>>>>>>>>>>>    Send ListObjects
90001>>>>>>>>>>>>>>>  End_Procedure
90002>>>>>>>>>>>>>>>
90002>>>>>>>>>>>>>>>  Procedure HKSC_ListVars
90004>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListVars
90005>>>>>>>>>>>>>>>    Send ListVars
90006>>>>>>>>>>>>>>>  End_Procedure
90007>>>>>>>>>>>>>>>
90007>>>>>>>>>>>>>>>  Procedure HKSC_ListKeys
90009>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListKeys
90010>>>>>>>>>>>>>>>    Send ListKeys
90011>>>>>>>>>>>>>>>  End_Procedure
90012>>>>>>>>>>>>>>>
90012>>>>>>>>>>>>>>>  Procedure HKSC_ListProcedures
90014>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListProcedures
90015>>>>>>>>>>>>>>>    Send ListProcedures
90016>>>>>>>>>>>>>>>  End_Procedure
90017>>>>>>>>>>>>>>>
90017>>>>>>>>>>>>>>>  Procedure HKSC_ListFunctions
90019>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListFunctions
90020>>>>>>>>>>>>>>>    Send ListFunctions
90021>>>>>>>>>>>>>>>  End_Procedure
90022>>>>>>>>>>>>>>>
90022>>>>>>>>>>>>>>>  Procedure HKSC_ListClasses
90024>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListClasses
90025>>>>>>>>>>>>>>>    Send ListClasses
90026>>>>>>>>>>>>>>>  End_Procedure
90027>>>>>>>>>>>>>>>
90027>>>>>>>>>>>>>>>  Procedure HKSC_ListIDETags
90029>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListIDETags
90030>>>>>>>>>>>>>>>    Send ListIDETags
90031>>>>>>>>>>>>>>>  End_Procedure
90032>>>>>>>>>>>>>>>
90032>>>>>>>>>>>>>>>  Procedure HKSC_ToggleComment
90034>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ToggleComment
90035>>>>>>>>>>>>>>>    Send ToggleComment
90036>>>>>>>>>>>>>>>  End_Procedure
90037>>>>>>>>>>>>>>>
90037>>>>>>>>>>>>>>>  Procedure HKSC_Toggle_OnItem_AddItem
90039>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertOnItemToAddItem
90040>>>>>>>>>>>>>>>    Send Toggle_OnItem_AddItem
90041>>>>>>>>>>>>>>>  End_Procedure
90042>>>>>>>>>>>>>>>
90042>>>>>>>>>>>>>>>  Procedure HKSC_ConvertCStructToVDF
90044>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertCStructToVDF
90045>>>>>>>>>>>>>>>    Send ConvertCStructToVDF
90046>>>>>>>>>>>>>>>  End_Procedure
90047>>>>>>>>>>>>>>>
90047>>>>>>>>>>>>>>>  Procedure HKSC_ConvertCDllCallToVDF
90049>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertCDllCallToVDF
90050>>>>>>>>>>>>>>>    Send ConvertCDllCallToVDF
90051>>>>>>>>>>>>>>>  End_Procedure
90052>>>>>>>>>>>>>>>
90052>>>>>>>>>>>>>>>  Procedure HKSC_ConvertVDFTypeToHandler
90054>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertVDFTypeToHandler
90055>>>>>>>>>>>>>>>    Send ConvertVDFTypeToHandler
90056>>>>>>>>>>>>>>>  End_Procedure
90057>>>>>>>>>>>>>>>
90057>>>>>>>>>>>>>>>  Procedure HKSC_MarkScopeBlock
90059>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_MarkScopeBlock
90060>>>>>>>>>>>>>>>    Send MarkScopeBlock
90061>>>>>>>>>>>>>>>  End_Procedure
90062>>>>>>>>>>>>>>>
90062>>>>>>>>>>>>>>>  Procedure HKSC_PerfCounters
90064>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_DEBUGPERFCOUNTERS
90065>>>>>>>>>>>>>>>    Send DisplayPerfCounters of ghoApplication
90066>>>>>>>>>>>>>>>  End_Procedure
90067>>>>>>>>>>>>>>>
90067>>>>>>>>>>>>>>>  Procedure HKSC_RefactorDropSelf
90069>>>>>>>>>>>>>>>    Send DispatchHotKey  // don't leak a shortcut key into the text window
90070>>>>>>>>>>>>>>>    Send RefactorDropSelf
90071>>>>>>>>>>>>>>>  End_Procedure
90072>>>>>>>>>>>>>>>
90072>>>>>>>>>>>>>>>  Procedure HKSC_RefactorObjectNeighborhood
90074>>>>>>>>>>>>>>>    Send DispatchHotKey
90075>>>>>>>>>>>>>>>    Send RefactorObjectNeighborhood
90076>>>>>>>>>>>>>>>  End_Procedure
90077>>>>>>>>>>>>>>>
90077>>>>>>>>>>>>>>>  Procedure HKSC_RefactorReindent
90079>>>>>>>>>>>>>>>    Send DispatchHotKey
90080>>>>>>>>>>>>>>>    Send RefactorReIndent
90081>>>>>>>>>>>>>>>  End_Procedure
90082>>>>>>>>>>>>>>>
90082>>>>>>>>>>>>>>>  Procedure HKSC_GotoFirstIndentMismatch
90084>>>>>>>>>>>>>>>    Send DispatchHotKey
90085>>>>>>>>>>>>>>>    Send GoToFirstIndentationMismatch
90086>>>>>>>>>>>>>>>  End_Procedure
90087>>>>>>>>>>>>>>>
90087>>>>>>>>>>>>>>>  Procedure HKSC_RefactorMethodExtract
90089>>>>>>>>>>>>>>>    Send DispatchHotKey
90090>>>>>>>>>>>>>>>    Send RefactorMethodExtract
90091>>>>>>>>>>>>>>>  End_Procedure
90092>>>>>>>>>>>>>>>
90092>>>>>>>>>>>>>>>  Procedure DefinePredefinedHotKeys Boolean bInEditView
90094>>>>>>>>>>>>>>>    Boolean bReroute
90094>>>>>>>>>>>>>>>
90094>>>>>>>>>>>>>>>    If (bInEditView=false) Begin
90096>>>>>>>>>>>>>>>      Get RerouteHotKeys To bReroute
90097>>>>>>>>>>>>>>>      If (bReroute) Begin
90099>>>>>>>>>>>>>>>        Send RouteHotkeysToCurrentView
90100>>>>>>>>>>>>>>>      End
90100>>>>>>>>>>>>>>>>
90100>>>>>>>>>>>>>>>    End
90100>>>>>>>>>>>>>>>>
90100>>>>>>>>>>>>>>>    Else Begin
90101>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FIND                   (RefProc(CME_Find))
90102>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FindNext               (RefProc(CME_FindNext))
90103>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FINDPREV               (RefProc(CME_FindPrevious))
90104>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FindReplace            (RefProc(CME_FindReplace))
90105>>>>>>>>>>>>>>>      Send DefineOnKey CMD_GOTOLINE               (RefProc(CME_GotoLine))
90106>>>>>>>>>>>>>>>      Send DefineOnKey CMD_SELECTALL              (RefProc(CME_SelectAll))
90107>>>>>>>>>>>>>>>    End
90107>>>>>>>>>>>>>>>>
90107>>>>>>>>>>>>>>>    
90107>>>>>>>>>>>>>>>    Send DefineOnKey CMD_GOTOMATCHBRACE           (RefProc(HKSC_GotoMatchBrace))
90108>>>>>>>>>>>>>>>    Send DefineOnKey CMD_PROPERTIES               (RefProc(HKSC_Properties))
90109>>>>>>>>>>>>>>>    Send DefineOnKey CMD_LINECUT                  (RefProc(HKSC_LineCut))
90110>>>>>>>>>>>>>>>    Send DefineOnKey CMD_LOWERCASESELECTION       (RefProc(HKSC_LowercaseSelection))
90111>>>>>>>>>>>>>>>    Send DefineOnKey CMD_UPPERCASESELECTION       (RefProc(HKSC_UppercaseSelection))
90112>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKTOGGLE           (RefProc(HKSC_BookmarkToggle))
90113>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKNEXT             (RefProc(HKSC_BookmarkNext))
90114>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKPREV             (RefProc(HKSC_BookmarkPrevious))
90115>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKCLEARALL         (RefProc(HKSC_BookmarkClearAll))
90116>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKJUMPTOFIRST      (RefProc(HKSC_BookmarkJumpToFirst))
90117>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKJUMPTOLAST       (RefProc(HKSC_BookmarkJumpToLast))
90118>>>>>>>>>>>>>>>    Send DefineOnKey CMD_MOVELINEUP               (RefProc(HKSC_MoveLineUp))
90119>>>>>>>>>>>>>>>    Send DefineOnKey CMD_MOVELINEDOWN             (RefProc(HKSC_MoveLineDown))
90120>>>>>>>>>>>>>>>    Send DefineOnKey CMD_DUPLICATESELECTION       (RefProc(HKSC_DuplicateSelection))
90121>>>>>>>>>>>>>>>
90121>>>>>>>>>>>>>>>    // Window Menu.
90121>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowSwitchToCodeView   (RefProc(HKSC_WindowSwitchToCodeView))
90122>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowSwitchToErrorView  (RefProc(HKSC_PAWindowSwitchToErrorView))
90123>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowSyncCodeView       (RefProc(HKSC_SyncCodeView))
90124>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowNextView           (RefProc(HKSC_CASwitchToNextView))
90125>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowPreviousView       (RefProc(HKSC_CASwitchToPreviousView))
90126>>>>>>>>>>>>>>>
90126>>>>>>>>>>>>>>>    // Lists.
90126>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListCreator              (RefProc(HKSC_ListCreator))
90127>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListObjects              (RefProc(HKSC_ListObjects))
90128>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListVars                 (RefProc(HKSC_ListVars))
90129>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListKeys                 (RefProc(HKSC_ListKeys))
90130>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListProcedures           (RefProc(HKSC_ListProcedures))
90131>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListFunctions            (RefProc(HKSC_ListFunctions))
90132>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListClasses              (RefProc(HKSC_ListClasses))
90133>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListIDETags              (RefProc(HKSC_ListIDETags))
90134>>>>>>>>>>>>>>>
90134>>>>>>>>>>>>>>>    // Mixed
90134>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ToggleComment            (RefProc(HKSC_ToggleComment))
90135>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ToolsInsertHeaderGlobal  (RefProc(HKSC_InsertHeaderGlobal))
90136>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ToolsInsertHeaderUser    (RefProc(HKSC_InsertHeaderUser))
90137>>>>>>>>>>>>>>>    Send DefineOnKey CMD_OpenFileUnderCursor      (RefProc(HKSC_OpenFileUnderCursor))
90138>>>>>>>>>>>>>>>    Send DefineOnKey CMD_InsertRevisionMark       (RefProc(HKSC_InsertRevision))
90139>>>>>>>>>>>>>>>    Send DefineOnKey CMD_InsertColor              (RefProc(HKSC_InsertColorValue))
90140>>>>>>>>>>>>>>>
90140>>>>>>>>>>>>>>>    // Convetion.
90140>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertOnItemToAddItem   (RefProc(HKSC_Toggle_OnItem_AddItem))
90141>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertCStructToVDF      (RefProc(HKSC_ConvertCStructToVDF))
90142>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertCDllCallToVDF     (RefProc(HKSC_ConvertCDllCallToVDF))
90143>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertVDFTypeToHandler  (RefProc(HKSC_ConvertVDFTypeToHandler))
90144>>>>>>>>>>>>>>>
90144>>>>>>>>>>>>>>>    Send DefineOnKey CMD_MarkScopeBlock           (RefProc(HKSC_MarkScopeBlock))
90145>>>>>>>>>>>>>>>
90145>>>>>>>>>>>>>>>
90145>>>>>>>>>>>>>>>    Send DefineOnKey CMD_DEBUGPERFCOUNTERS        (RefProc(HKSC_PerfCounters))
90146>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTORDROPSELF         (RefProc(HKSC_RefactorDropSelf))
90147>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTOROBJECTNEIGHBORHOOD (RefProc(HKSC_RefactorObjectNeighborhood))
90148>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTORREINDENT         (RefProc(HKSC_RefactorReindent))
90149>>>>>>>>>>>>>>>    Send DefineOnKey CMD_GOTOFIRSTINDENTMISMATCH  (RefProc(HKSC_GotoFirstIndentMismatch))
90150>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTORMETHODEXTRACT    (RefProc(HKSC_RefactorMethodExtract))
90151>>>>>>>>>>>>>>>  End_Procedure
90152>>>>>>>>>>>>>>>  
90152>>>>>>>>>>>>>>>  Function CurrentView Returns Integer
90154>>>>>>>>>>>>>>>    Handle hoView
90154>>>>>>>>>>>>>>>    Handle hoClient
90154>>>>>>>>>>>>>>>
90154>>>>>>>>>>>>>>>    Move 0 To hoView
90155>>>>>>>>>>>>>>>    Get Client_ID To hoClient
90156>>>>>>>>>>>>>>>    If (hoClient) Begin
90158>>>>>>>>>>>>>>>//      Get FindCurrentView of hoClient To hoView
90158>>>>>>>>>>>>>>>    End
90158>>>>>>>>>>>>>>>>
90158>>>>>>>>>>>>>>>    Function_Return hoView
90159>>>>>>>>>>>>>>>  End_Function
90160>>>>>>>>>>>>>>>  
90160>>>>>>>>>>>>>>>  Procedure CurrentViewHotKeyReroute Integer iMsg
90162>>>>>>>>>>>>>>>    Handle hoView
90162>>>>>>>>>>>>>>>    
90162>>>>>>>>>>>>>>>    Get CurrentView To hoView
90163>>>>>>>>>>>>>>>    If (hoView<>0) Begin
90165>>>>>>>>>>>>>>>      Send DispatchHotkey
90166>>>>>>>>>>>>>>>      Send iMsg to hoView
90167>>>>>>>>>>>>>>>    End
90167>>>>>>>>>>>>>>>>
90167>>>>>>>>>>>>>>>  End_Procedure
90168>>>>>>>>>>>>>>>  
90168>>>>>>>>>>>>>>>  Procedure CurrentView_CAPopUpFindInFiles
90170>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CAPopUpFindInFiles))
90171>>>>>>>>>>>>>>>  End_Procedure
90172>>>>>>>>>>>>>>>  
90172>>>>>>>>>>>>>>>  Procedure CurrentView_HKSC_OpenFile
90174>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(HKSC_OpenFile))
90175>>>>>>>>>>>>>>>  End_Procedure
90176>>>>>>>>>>>>>>>  
90176>>>>>>>>>>>>>>>  Procedure CurrentView_CASaveFile
90178>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASaveFile))
90179>>>>>>>>>>>>>>>  End_Procedure
90180>>>>>>>>>>>>>>>  
90180>>>>>>>>>>>>>>>  Procedure CurrentView_CASaveFileAs
90182>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASaveFileAs))
90183>>>>>>>>>>>>>>>  End_Procedure
90184>>>>>>>>>>>>>>>  
90184>>>>>>>>>>>>>>>  Procedure CurrentView_CASaveAllFiles
90186>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASaveAllFiles))
90187>>>>>>>>>>>>>>>  End_Procedure
90188>>>>>>>>>>>>>>>  
90188>>>>>>>>>>>>>>>  Procedure CurrentView_CACloseFile
90190>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CACloseFile))
90191>>>>>>>>>>>>>>>  End_Procedure
90192>>>>>>>>>>>>>>>  
90192>>>>>>>>>>>>>>>  Procedure CurrentView_CACloseAllFiles
90194>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CACloseAllFiles))
90195>>>>>>>>>>>>>>>  End_Procedure
90196>>>>>>>>>>>>>>>  
90196>>>>>>>>>>>>>>>  Procedure CurrentView_HKSC_NewFile
90198>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(HKSC_NewFile))
90199>>>>>>>>>>>>>>>  End_Procedure
90200>>>>>>>>>>>>>>>  
90200>>>>>>>>>>>>>>>  Procedure CurrentView_CASelectWorkSpace
90202>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASelectWorkSpace))
90203>>>>>>>>>>>>>>>  End_Procedure
90204>>>>>>>>>>>>>>>  
90204>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildRun
90206>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildRun))
90207>>>>>>>>>>>>>>>  End_Procedure
90208>>>>>>>>>>>>>>>  
90208>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildRunCurrent
90210>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildRunCurrent))
90211>>>>>>>>>>>>>>>  End_Procedure
90212>>>>>>>>>>>>>>>  
90212>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildCompile
90214>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildCompile))
90215>>>>>>>>>>>>>>>  End_Procedure
90216>>>>>>>>>>>>>>>  
90216>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildPreCompile
90218>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildPreCompile))
90219>>>>>>>>>>>>>>>  End_Procedure
90220>>>>>>>>>>>>>>>  
90220>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildExecute
90222>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildExecute))
90223>>>>>>>>>>>>>>>  End_Procedure
90224>>>>>>>>>>>>>>>  
90224>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildDebugRun
90226>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildDebugRun))
90227>>>>>>>>>>>>>>>  End_Procedure
90228>>>>>>>>>>>>>>>  
90228>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildDebugRunCurrent
90230>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildDebugRunCurrent))
90231>>>>>>>>>>>>>>>  End_Procedure
90232>>>>>>>>>>>>>>>  
90232>>>>>>>>>>>>>>>  Procedure CurrentView_CME_Find
90234>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_Find))
90235>>>>>>>>>>>>>>>  End_Procedure
90236>>>>>>>>>>>>>>>                         
90236>>>>>>>>>>>>>>>  Procedure CurrentView_CME_FindNext
90238>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_FindNext))
90239>>>>>>>>>>>>>>>  End_Procedure
90240>>>>>>>>>>>>>>>  
90240>>>>>>>>>>>>>>>  Procedure CurrentView_CME_FindPrevious
90242>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_FindPrevious))
90243>>>>>>>>>>>>>>>  End_Procedure
90244>>>>>>>>>>>>>>>  
90244>>>>>>>>>>>>>>>  Procedure CurrentView_CME_FindReplace
90246>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_FindReplace))
90247>>>>>>>>>>>>>>>  End_Procedure
90248>>>>>>>>>>>>>>>  
90248>>>>>>>>>>>>>>>  Procedure CurrentView_CME_GotoLine
90250>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_GotoLine))
90251>>>>>>>>>>>>>>>  End_Procedure
90252>>>>>>>>>>>>>>>  
90252>>>>>>>>>>>>>>>  Procedure CurrentView_CME_SelectAll
90254>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_SelectAll))
90255>>>>>>>>>>>>>>>  End_Procedure
90256>>>>>>>>>>>>>>>  
90256>>>>>>>>>>>>>>>  Procedure RouteHotKeysToCurrentView
90258>>>>>>>>>>>>>>>
90258>>>>>>>>>>>>>>>    // File Menu
90258>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileOpenFile         (RefProc(CurrentView_HKSC_OpenFile))
90259>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileSaveFile         (RefProc(CurrentView_CASaveFile))
90260>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileSaveFileAs       (RefProc(CurrentView_CASaveFileAs))
90261>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileSaveAll          (RefProc(CurrentView_CASaveAllFiles))
90262>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileCloseFile        (RefProc(CurrentView_CACloseFile))
90263>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileCloseAllFiles    (RefProc(CurrentView_CACloseAllFiles))
90264>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileNewFile          (RefProc(CurrentView_HKSC_NewFile))
90265>>>>>>>>>>>>>>>
90265>>>>>>>>>>>>>>>    // Edit Menu
90265>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FindInFiles          (RefProc(CurrentView_CAPopUpFindInFiles))
90266>>>>>>>>>>>>>>>
90266>>>>>>>>>>>>>>>    // Options Menu
90266>>>>>>>>>>>>>>>    Send DefineOnKey CMD_SelectWorkSpace      (RefProc(CurrentView_CASelectWorkSpace))
90267>>>>>>>>>>>>>>>
90267>>>>>>>>>>>>>>>    // Build Menu
90267>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildRun             (RefProc(CurrentView_CABuildRun))
90268>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildRunCurrent      (RefProc(CurrentView_CABuildRunCurrent))
90269>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildCompileCurrent  (RefProc(CurrentView_CABuildCompile))
90270>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildPreCompile      (RefProc(CurrentView_CABuildPreCompile))
90271>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildExecute         (RefProc(CurrentView_CABuildExecute))
90272>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildDebugRun        (RefProc(CurrentView_CABuildDebugRun))
90273>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildDebugRunCurrent (RefProc(CurrentView_CABuildDebugRunCurrent))
90274>>>>>>>>>>>>>>>
90274>>>>>>>>>>>>>>>    // Find/replace/select all/gotoline
90274>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FIND                 (RefProc(CurrentView_CME_Find))
90275>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FindNext             (RefProc(CurrentView_CME_FindNext))
90276>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FINDPREV             (RefProc(CurrentView_CME_FindPrevious))
90277>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FindReplace          (RefProc(CurrentView_CME_FindReplace))
90278>>>>>>>>>>>>>>>    Send DefineOnKey CMD_GOTOLINE             (RefProc(CurrentView_CME_GotoLine))
90279>>>>>>>>>>>>>>>    Send DefineOnKey CMD_SELECTALL            (RefProc(CurrentView_CME_SelectAll))
90280>>>>>>>>>>>>>>>  End_Procedure
90281>>>>>>>>>>>>>>>
90281>>>>>>>>>>>>>>>  // This defines the on_key commands via editor hotkeys
90281>>>>>>>>>>>>>>>  Procedure Define_EditorHotKeys
90283>>>>>>>>>>>>>>>    Boolean bInEditView
90283>>>>>>>>>>>>>>>    //    Can't set the definition here as the message isn't known in the subclass
90283>>>>>>>>>>>>>>>    //      Send DefineOnKey CMD_FileNewFile msg_CANewFile
90283>>>>>>>>>>>>>>>    Get IsInEditorView to bInEditView
90284>>>>>>>>>>>>>>>    If (bInEditView) Begin
90286>>>>>>>>>>>>>>>      // Calls method in clientArea object to then execute the above DefineOnKey
90286>>>>>>>>>>>>>>>      Delegate Send Define_EditViewHotkeys Self
90288>>>>>>>>>>>>>>>    End
90288>>>>>>>>>>>>>>>>
90288>>>>>>>>>>>>>>>    //
90288>>>>>>>>>>>>>>>    Send DefinePredefinedHotkeys bInEditView
90289>>>>>>>>>>>>>>>    //
90289>>>>>>>>>>>>>>>  End_Procedure
90290>>>>>>>>>>>>>>>
90290>>>>>>>>>>>>>>>End_Class
90291>>>>>>>>>>>>>Use cCJCommandBarSystem.pkg
90291>>>>>>>>>>>>>Use cCJStandardMenuItemClasses.pkg
90291>>>>>>>>>>>>>Use Cursor.pkg
90291>>>>>>>>>>>>>//Use cEditorProperties.pkg  
90291>>>>>>>>>>>>>
90291>>>>>>>>>>>>>Register_Object oOpenFolderMenuItem
90291>>>>>>>>>>>>>
90291>>>>>>>>>>>>>Object oSciContextMenu is a cCJContextMenu
90293>>>>>>>>>>>>>    Property Handle phoServedObject 0
90295>>>>>>>>>>>>>
90295>>>>>>>>>>>>>    Object oSourceFileText_MenuItem is a cCJMenuItem
90297>>>>>>>>>>>>>        Set psCaption to "Select Source File"
90298>>>>>>>>>>>>>        Set psDescription to "Displays an Open File dialog to select a source file from (Ctrl+O)"
90299>>>>>>>>>>>>>        Set psImage to "ActionOpen.ico"
90300>>>>>>>>>>>>>        Set psShortcut to "Ctrl+O"
90301>>>>>>>>>>>>>
90301>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90304>>>>>>>>>>>>>            Forward Send OnExecute vCommandBarControl
90306>>>>>>>>>>>>>            Send Execute of (oOpenFolderMenuItem(ghoCommandBars))
90307>>>>>>>>>>>>>        End_Procedure
90308>>>>>>>>>>>>>
90308>>>>>>>>>>>>>        Function IsEnabled Returns Boolean
90311>>>>>>>>>>>>>            Boolean bState
90311>>>>>>>>>>>>>            String sSWSFile
90311>>>>>>>>>>>>>
90311>>>>>>>>>>>>>            Move False to bState
90312>>>>>>>>>>>>>            Get psSWSFile of ghoApplication to sSWSFile
90313>>>>>>>>>>>>>            Move (sSWSFile <> "") to bState
90314>>>>>>>>>>>>>
90314>>>>>>>>>>>>>            Function_Return bState
90315>>>>>>>>>>>>>        End_Function
90316>>>>>>>>>>>>>
90316>>>>>>>>>>>>>    End_Object
90317>>>>>>>>>>>>>
90317>>>>>>>>>>>>>    Object oCutMenuItem is a cCJCutMenuItem
90319>>>>>>>>>>>>>    End_Object
90320>>>>>>>>>>>>>
90320>>>>>>>>>>>>>    Object oCopyMenuItem is a cCJCopyMenuItem
90322>>>>>>>>>>>>>    End_Object
90323>>>>>>>>>>>>>
90323>>>>>>>>>>>>>    Object oPasteMenuItem is a cCJPasteMenuItem
90325>>>>>>>>>>>>>    End_Object
90326>>>>>>>>>>>>>
90326>>>>>>>>>>>>>    Object oFindMenuItem is a cCJMenuItem
90328>>>>>>>>>>>>>        Set pbControlBeginGroup to True
90329>>>>>>>>>>>>>        Set psCaption to "&Find"
90330>>>>>>>>>>>>>        Set psToolTip to "Find text"
90331>>>>>>>>>>>>>        Set psDescription to "Find text in current file"
90332>>>>>>>>>>>>>        Set psShortcut to "Ctrl+F"
90333>>>>>>>>>>>>>        Set psImage to "ActionFind.ico"
90334>>>>>>>>>>>>>
90334>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90337>>>>>>>>>>>>>            Send CME_Find of (phoServedObject(Self))
90338>>>>>>>>>>>>>        End_Procedure
90339>>>>>>>>>>>>>    End_Object
90340>>>>>>>>>>>>>
90340>>>>>>>>>>>>>    Object oFindNextMenuItem is a cCJMenuItem
90342>>>>>>>>>>>>>        Set psCaption to "Find &Next"
90343>>>>>>>>>>>>>        Set psToolTip to "Find next text"
90344>>>>>>>>>>>>>        Set psDescription to "Find next text in current file"
90345>>>>>>>>>>>>>        Set psShortcut to "F3"
90346>>>>>>>>>>>>>        Set psImage to "ActionFindNext.ico"
90347>>>>>>>>>>>>>
90347>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90350>>>>>>>>>>>>>            Send CME_FindNext of (phoServedObject(Self))
90351>>>>>>>>>>>>>        End_Procedure
90352>>>>>>>>>>>>>    End_Object
90353>>>>>>>>>>>>>
90353>>>>>>>>>>>>>    Object oFindPreviousMenuItem is a cCJMenuItem
90355>>>>>>>>>>>>>        Set psCaption to "Find &Previous"
90356>>>>>>>>>>>>>        Set psToolTip to "Find previous text"
90357>>>>>>>>>>>>>        Set psDescription to "Find previous text in current file"
90358>>>>>>>>>>>>>        Set psShortcut to "Shift+F3"
90359>>>>>>>>>>>>>        Set psImage to "ActionFindPrevious.ico"
90360>>>>>>>>>>>>>
90360>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90363>>>>>>>>>>>>>            Send CME_FindPrevious of (phoServedObject(Self))
90364>>>>>>>>>>>>>        End_Procedure
90365>>>>>>>>>>>>>    End_Object
90366>>>>>>>>>>>>>
90366>>>>>>>>>>>>>    Object oFindReplaceMenuItem is a cCJMenuItem
90368>>>>>>>>>>>>>        Set psCaption to "Find &Replace"
90369>>>>>>>>>>>>>        Set psToolTip to "Find Replace text"
90370>>>>>>>>>>>>>        Set psDescription to "Find and replace text in current file"
90371>>>>>>>>>>>>>        Set psShortcut to "Ctrl+Alt+F3"
90372>>>>>>>>>>>>>        Set psImage to "ActionFindAndReplace.ico"
90373>>>>>>>>>>>>>
90373>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90376>>>>>>>>>>>>>            Send CME_FindReplace of (phoServedObject(Self))
90377>>>>>>>>>>>>>        End_Procedure
90378>>>>>>>>>>>>>    End_Object
90379>>>>>>>>>>>>>
90379>>>>>>>>>>>>>    Object oGotoLineMenuItem is a cCJMenuItem
90381>>>>>>>>>>>>>        Set pbControlBeginGroup to True
90382>>>>>>>>>>>>>        Set psCaption to "Goto &Line"
90383>>>>>>>>>>>>>        Set psToolTip to "Goto Line"
90384>>>>>>>>>>>>>        Set psDescription to "Goto line in current file"
90385>>>>>>>>>>>>>        Set psShortcut to "Ctrl+G"
90386>>>>>>>>>>>>>        Set psImage to "ActionGoToLine.ico"
90387>>>>>>>>>>>>>
90387>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90390>>>>>>>>>>>>>            Send CME_GotoLine of (phoServedObject(Self))
90391>>>>>>>>>>>>>        End_Procedure
90392>>>>>>>>>>>>>    End_Object
90393>>>>>>>>>>>>>
90393>>>>>>>>>>>>>    Object oSelectAllMenuItem is a cCJMenuItem
90395>>>>>>>>>>>>>        Set psCaption to "Select &All"
90396>>>>>>>>>>>>>        Set psToolTip to "Select All"
90397>>>>>>>>>>>>>        Set psDescription to "Select All text in current file"
90398>>>>>>>>>>>>>        Set psShortcut to "Ctrl+A"
90399>>>>>>>>>>>>>        Set psImage to "ActionSelectAll.ico"
90400>>>>>>>>>>>>>
90400>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90403>>>>>>>>>>>>>            Send CME_SelectAll of (phoServedObject(Self))
90404>>>>>>>>>>>>>        End_Procedure
90405>>>>>>>>>>>>>    End_Object
90406>>>>>>>>>>>>>
90406>>>>>>>>>>>>>    Object oUndoMenuItem is a cCJMenuItem
90408>>>>>>>>>>>>>        Set psCaption to "Undo"
90409>>>>>>>>>>>>>        Set psToolTip to "Undo"
90410>>>>>>>>>>>>>        Set psDescription to "Undo the last editor action"
90411>>>>>>>>>>>>>        Set psShortcut to "Ctrl+Z"
90412>>>>>>>>>>>>>        Set psImage to "ActionUndo.ico"
90413>>>>>>>>>>>>>
90413>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90416>>>>>>>>>>>>>            Send CME_UndoAction of (phoServedObject(Self))
90417>>>>>>>>>>>>>        End_Procedure
90418>>>>>>>>>>>>>    End_Object
90419>>>>>>>>>>>>>
90419>>>>>>>>>>>>>    Object oNormalizeCaseMenuItem is a cCJMenuItem
90421>>>>>>>>>>>>>        Set psCaption to "Adjust Upper/Lowercase"
90422>>>>>>>>>>>>>        Set psToolTip to "Adjust Upper/Lowercase"
90423>>>>>>>>>>>>>        Set psDescription to "Normalize the case on all of the text in the current file"
90424>>>>>>>>>>>>>        Set pbControlBeginGroup to True
90425>>>>>>>>>>>>>        Set psImage to "ActionCasing.ico"
90426>>>>>>>>>>>>>
90426>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90429>>>>>>>>>>>>>            Send RefactorNormalizeCase of (phoServedObject(Self))
90430>>>>>>>>>>>>>        End_Procedure
90431>>>>>>>>>>>>>    End_Object
90432>>>>>>>>>>>>>
90432>>>>>>>>>>>>>    Object oReIndentMenuItem is a cCJMenuItem
90434>>>>>>>>>>>>>        Set psCaption to "Reindent code"
90435>>>>>>>>>>>>>        Set psToolTip to "Reindent code"
90436>>>>>>>>>>>>>        Set psDescription to "ReIndent all of the text in the current file"
90437>>>>>>>>>>>>>        Set psImage to "ActionIndent.ico"
90438>>>>>>>>>>>>>
90438>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90441>>>>>>>>>>>>>            Send RefactorReIndent of (phoServedObject(Self))
90442>>>>>>>>>>>>>        End_Procedure
90443>>>>>>>>>>>>>    End_Object
90444>>>>>>>>>>>>>
90444>>>>>>>>>>>>>    Object oDropSelfMenuItem is a cCJMenuItem
90446>>>>>>>>>>>>>        Set psCaption to "Drop Self"
90447>>>>>>>>>>>>>        Set psToolTip to "Drop Self"
90448>>>>>>>>>>>>>        Set psDescription to "Refactoring drop self method"
90449>>>>>>>>>>>>>        Set psImage to "ActionDrop.ico"
90450>>>>>>>>>>>>>
90450>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90453>>>>>>>>>>>>>            Send RefactorDropSelf of (phoServedObject(Self))
90454>>>>>>>>>>>>>        End_Procedure
90455>>>>>>>>>>>>>    End_Object
90456>>>>>>>>>>>>>
90456>>>>>>>>>>>>>End_Object
90457>>>>>>>>>>>>>
90457>>>>>>>>>>>>>Class cScintillaEdit is a cSciLexerRefactor
90458>>>>>>>>>>>>>
90458>>>>>>>>>>>>>    Import_Class_Protocol cEditorHotKey_Mixin
90459>>>>>>>>>>>>>
90459>>>>>>>>>>>>>    Procedure Construct_Object
90461>>>>>>>>>>>>>        Forward Send Construct_Object
90463>>>>>>>>>>>>>        Property Handle phoCodeMaxEditor   0
90464>>>>>>>>>>>>>        Property Handle phoEditorEditView  0 // This is only needed in The Hammer where an editor view has also components such as a treeview on the left
90465>>>>>>>>>>>>>        Set phoCodeMaxEditor     to Self
90466>>>>>>>>>>>>>        Set Floating_Menu_Object to oSciContextMenu
90467>>>>>>>>>>>>>        Set pbAnsiMode           to False    // Don't do any ANSI/OEM Translation on load and save
90468>>>>>>>>>>>>>        Send Define_cEditorHotKey_Mixin
90469>>>>>>>>>>>>>    End_Procedure
90470>>>>>>>>>>>>>
90470>>>>>>>>>>>>>    Procedure CME_Find
90472>>>>>>>>>>>>>        Handle hoEdit
90472>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90473>>>>>>>>>>>>>        If (hoEdit) Begin
90475>>>>>>>>>>>>>            Send Activate of hoEdit
90476>>>>>>>>>>>>>            Send Find of hoEdit
90477>>>>>>>>>>>>>        End
90477>>>>>>>>>>>>>>
90477>>>>>>>>>>>>>    End_Procedure
90478>>>>>>>>>>>>>
90478>>>>>>>>>>>>>    Procedure CME_FindNext
90480>>>>>>>>>>>>>        Handle hoEdit
90480>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90481>>>>>>>>>>>>>        If (hoEdit) Begin
90483>>>>>>>>>>>>>            Send Activate of hoEdit
90484>>>>>>>>>>>>>            Send FindNext of hoEdit
90485>>>>>>>>>>>>>        End
90485>>>>>>>>>>>>>>
90485>>>>>>>>>>>>>    End_Procedure
90486>>>>>>>>>>>>>
90486>>>>>>>>>>>>>    Procedure CME_FindPrevious
90488>>>>>>>>>>>>>        Handle hoEdit
90488>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90489>>>>>>>>>>>>>        If (hoEdit) Begin
90491>>>>>>>>>>>>>            Send Activate of hoEdit
90492>>>>>>>>>>>>>            Send FindPrevious of hoEdit
90493>>>>>>>>>>>>>        End
90493>>>>>>>>>>>>>>
90493>>>>>>>>>>>>>    End_Procedure
90494>>>>>>>>>>>>>
90494>>>>>>>>>>>>>    Procedure CME_FindReplace
90496>>>>>>>>>>>>>        Handle hoEdit
90496>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90497>>>>>>>>>>>>>        If (hoEdit) Begin
90499>>>>>>>>>>>>>            Send Activate of hoEdit
90500>>>>>>>>>>>>>            Send Replace of hoEdit
90501>>>>>>>>>>>>>        End
90501>>>>>>>>>>>>>>
90501>>>>>>>>>>>>>    End_Procedure
90502>>>>>>>>>>>>>
90502>>>>>>>>>>>>>    Procedure CME_GotoLine
90504>>>>>>>>>>>>>        Handle hoEdit
90504>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90505>>>>>>>>>>>>>        If (hoEdit) Begin
90507>>>>>>>>>>>>>            Send Activate of hoEdit
90508>>>>>>>>>>>>>            Send GotoLine of hoEdit
90509>>>>>>>>>>>>>        End
90509>>>>>>>>>>>>>>
90509>>>>>>>>>>>>>    End_Procedure
90510>>>>>>>>>>>>>
90510>>>>>>>>>>>>>    Procedure CME_SelectAll
90512>>>>>>>>>>>>>        Handle hoEdit
90512>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90513>>>>>>>>>>>>>        If (hoEdit) Begin
90515>>>>>>>>>>>>>            Send Activate of hoEdit
90516>>>>>>>>>>>>>            Send SelectAll of hoEdit
90517>>>>>>>>>>>>>        End
90517>>>>>>>>>>>>>>
90517>>>>>>>>>>>>>    End_Procedure
90518>>>>>>>>>>>>>
90518>>>>>>>>>>>>>    Procedure CME_UndoAction
90520>>>>>>>>>>>>>        Handle hoEdit
90520>>>>>>>>>>>>>        Integer iRet
90520>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90521>>>>>>>>>>>>>        If (hoEdit) Begin
90523>>>>>>>>>>>>>            Send Activate of hoEdit
90524>>>>>>>>>>>>>            Get CM_Undo to iRet
90525>>>>>>>>>>>>>        End
90525>>>>>>>>>>>>>>
90525>>>>>>>>>>>>>    End_Procedure
90526>>>>>>>>>>>>>
90526>>>>>>>>>>>>>    Function Can_UndoAction Returns Boolean
90528>>>>>>>>>>>>>        Handle hoEdit
90528>>>>>>>>>>>>>        Integer iRet
90528>>>>>>>>>>>>>        Move 0 to iRet
90529>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
90530>>>>>>>>>>>>>        If (hoEdit) Begin
90532>>>>>>>>>>>>>            Get CM_CanUndo to iRet
90533>>>>>>>>>>>>>        End
90533>>>>>>>>>>>>>>
90533>>>>>>>>>>>>>        Function_Return (iRet = 1)
90534>>>>>>>>>>>>>    End_Function
90535>>>>>>>>>>>>>
90535>>>>>>>>>>>>>    // Dummy methods, don't implement these as it will be a pain to keep in sync.
90535>>>>>>>>>>>>>    // If any of these below will be implemented then that is best done in
90535>>>>>>>>>>>>>    // coordinated effort with the Hammer.
90535>>>>>>>>>>>>>    Procedure CAOpenFile
90537>>>>>>>>>>>>>    End_Procedure
90538>>>>>>>>>>>>>    Procedure CANewFile
90540>>>>>>>>>>>>>    End_Procedure
90541>>>>>>>>>>>>>    Procedure InsertHeaderGlobal
90543>>>>>>>>>>>>>    End_Procedure
90544>>>>>>>>>>>>>    Procedure InsertHeaderUser
90546>>>>>>>>>>>>>    End_Procedure
90547>>>>>>>>>>>>>    Procedure OpenFileUnderCursor
90549>>>>>>>>>>>>>    End_Procedure
90550>>>>>>>>>>>>>    Procedure InsertRevision
90552>>>>>>>>>>>>>    End_Procedure
90553>>>>>>>>>>>>>    Procedure InsertColorValue
90555>>>>>>>>>>>>>    End_Procedure
90556>>>>>>>>>>>>>    Procedure WindowSwitchToCodeView
90558>>>>>>>>>>>>>    End_Procedure
90559>>>>>>>>>>>>>    Procedure PAWindowSwitchToErrorView
90561>>>>>>>>>>>>>    End_Procedure
90562>>>>>>>>>>>>>    Procedure SyncCodeView
90564>>>>>>>>>>>>>    End_Procedure
90565>>>>>>>>>>>>>    Procedure CASwitchToNextView
90567>>>>>>>>>>>>>    End_Procedure
90568>>>>>>>>>>>>>    Procedure CASwitchToPreviousView
90570>>>>>>>>>>>>>    End_Procedure
90571>>>>>>>>>>>>>    Procedure ListCreator
90573>>>>>>>>>>>>>    End_Procedure
90574>>>>>>>>>>>>>    Procedure ListObjects
90576>>>>>>>>>>>>>    End_Procedure
90577>>>>>>>>>>>>>    Procedure ListVars
90579>>>>>>>>>>>>>    End_Procedure
90580>>>>>>>>>>>>>    Procedure ListKeys
90582>>>>>>>>>>>>>    End_Procedure
90583>>>>>>>>>>>>>    Procedure ListProcedures
90585>>>>>>>>>>>>>    End_Procedure
90586>>>>>>>>>>>>>    Procedure ListFunctions
90588>>>>>>>>>>>>>    End_Procedure
90589>>>>>>>>>>>>>    Procedure ListClasses
90591>>>>>>>>>>>>>    End_Procedure
90592>>>>>>>>>>>>>    Procedure ListIDETags
90594>>>>>>>>>>>>>    End_Procedure
90595>>>>>>>>>>>>>    Procedure ToggleComment
90597>>>>>>>>>>>>>    End_Procedure
90598>>>>>>>>>>>>>    Procedure Toggle_OnItem_AddItem
90600>>>>>>>>>>>>>    End_Procedure
90601>>>>>>>>>>>>>    Procedure ConvertCStructToVDF
90603>>>>>>>>>>>>>    End_Procedure
90604>>>>>>>>>>>>>    Procedure ConvertCDllCallToVDF
90606>>>>>>>>>>>>>    End_Procedure
90607>>>>>>>>>>>>>    Procedure ConvertVDFTypeToHandler
90609>>>>>>>>>>>>>    End_Procedure
90610>>>>>>>>>>>>>    Procedure MarkScopeBlock
90612>>>>>>>>>>>>>    End_Procedure
90613>>>>>>>>>>>>>    Procedure RefactorObjectNeighborhood
90615>>>>>>>>>>>>>    End_Procedure
90616>>>>>>>>>>>>>    Procedure GoToFirstIndentationMismatch
90618>>>>>>>>>>>>>    End_Procedure
90619>>>>>>>>>>>>>    Procedure RefactorMethodExtract
90621>>>>>>>>>>>>>    End_Procedure
90622>>>>>>>>>>>>>
90622>>>>>>>>>>>>>    Procedure SetAdjustments
90624>>>>>>>>>>>>>        Integer hoIni iRet
90624>>>>>>>>>>>>>        // Font Face
90624>>>>>>>>>>>>>        String  sFontData
90624>>>>>>>>>>>>>        String  sFontTemp
90624>>>>>>>>>>>>>        String  sFontFace
90624>>>>>>>>>>>>>        Integer iFontSize
90624>>>>>>>>>>>>>        Integer iCharSet
90624>>>>>>>>>>>>>        //
90624>>>>>>>>>>>>>
90624>>>>>>>>>>>>>        Move (CM_ENABLEGLOBALPROPS(Self,False))    to iRet
90625>>>>>>>>>>>>>
90625>>>>>>>>>>>>>        Move ghoEditorProperties  to hoIni
90626>>>>>>>>>>>>>        Move (CM_SetLineNumbering(Self,Low(piLineNumbering(hoIni)),Hi(piLineNumbering(hoIni)),Low(piLineNumbering(hoIni)))) to iRet
90627>>>>>>>>>>>>>        Move (CM_EnableLeftMargin(Self,pbLeftMargin(hoIni)))            to iRet
90628>>>>>>>>>>>>>
90628>>>>>>>>>>>>>        Move (CM_SetLanguage(Self,psLanguage(hoIni)))                   to iRet
90629>>>>>>>>>>>>>        Move (CM_ShowScrollBar(Self,True,pbScrollBarH(hoIni)))          to iRet
90630>>>>>>>>>>>>>        Move (CM_ShowScrollBar(Self,False,pbScrollBarV(hoIni)))         to iRet
90631>>>>>>>>>>>>>        // Editor font face?
90631>>>>>>>>>>>>>        Move (psFontFace(ghoEditorProperties))                          to sFontData
90632>>>>>>>>>>>>>        If (sFontData="") Begin
90634>>>>>>>>>>>>>            Move "11pt; 0; Courier New"                   to sFontData
90635>>>>>>>>>>>>>        End
90635>>>>>>>>>>>>>>
90635>>>>>>>>>>>>>        // Font Size
90635>>>>>>>>>>>>>        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
90636>>>>>>>>>>>>>        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
90637>>>>>>>>>>>>>        Move (Trim(Replace("PT;", Uppercase(sFontTemp), "")))           to iFontSize
90638>>>>>>>>>>>>>        // Code Page
90638>>>>>>>>>>>>>        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
90639>>>>>>>>>>>>>        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
90640>>>>>>>>>>>>>        Move (Trim(Replace(";", sFontTemp, "")))                        to iCharSet
90641>>>>>>>>>>>>>        // Font Face
90641>>>>>>>>>>>>>        Move (Trim(sFontData))                                          to sFontFace
90642>>>>>>>>>>>>>        //
90642>>>>>>>>>>>>>        Move SC_CHARSET_OEM to iCharSet
90643>>>>>>>>>>>>>        //
90643>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETFONT STYLE_DEFAULT (AddressOf(sFontFace))
90644>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETSIZE STYLE_DEFAULT iFontSize
90645>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETCHARACTERSET STYLE_DEFAULT iCharSet
90646>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETSIZE STYLE_LINENUMBER (iFontSize-1) // Set font size
90647>>>>>>>>>>>>>        //
90647>>>>>>>>>>>>>        Set  pbShowMatchingBraces to (pbShowMatchingBraces(hoIni))
90648>>>>>>>>>>>>>        If  (pbShowIndentGuides(hoIni)) Begin
90650>>>>>>>>>>>>>            Send ShowIndentationGuides
90651>>>>>>>>>>>>>        End
90651>>>>>>>>>>>>>>
90651>>>>>>>>>>>>>        Send SelectTillEndOfLine (pbSelectWholeLine(hoIni))
90652>>>>>>>>>>>>>
90652>>>>>>>>>>>>>        Move (CM_EnableDragDrop(Self,pbDragDrop(hoIni)))                to iRet
90653>>>>>>>>>>>>>        Move (CM_EnableColumnSel(Self,pbColumnSel(hoIni)))              to iRet
90654>>>>>>>>>>>>>        Move (CM_SetAutoIndentMode(Self,piAutoIndentMode(hoIni)))       to iRet
90655>>>>>>>>>>>>>        Move (CM_SetTabSize(Self,piTabSize(hoIni)))                     to iRet
90656>>>>>>>>>>>>>        Move (CM_EnableTabExpand(Self,pbTabExpand(hoIni)))              to iRet
90657>>>>>>>>>>>>>        Move (CM_EnableNormalizeCase(Self,pbNormalizeCase(hoIni)))      to iRet
90658>>>>>>>>>>>>>        Move (CM_EnableSelBounds(Self,pbSelBounds(hoIni)))              to iRet
90659>>>>>>>>>>>>>        Move (CM_EnableCaseSensitive(Self,pbCaseSensitive(hoIni)))      to iRet
90660>>>>>>>>>>>>>        Move (CM_EnableWholeWord(Self,pbWholeWord(hoIni)))              to iRet
90661>>>>>>>>>>>>>    End_Procedure
90662>>>>>>>>>>>>>
90662>>>>>>>>>>>>>    Procedure SetLexer
90664>>>>>>>>>>>>>        Boolean bInit
90664>>>>>>>>>>>>>        Integer iRet
90664>>>>>>>>>>>>>        Integer iLanguage
90664>>>>>>>>>>>>>        Integer iLexer
90664>>>>>>>>>>>>>        String  sKeywords sScopeKeywords1 sScopeKeywords2 sOperators
90664>>>>>>>>>>>>>        String  sLanguage sLexerLang
90664>>>>>>>>>>>>>        String  sHotKeys
90664>>>>>>>>>>>>>
90664>>>>>>>>>>>>>        Get psLanguage of ghoEditorProperties  to sLanguage
90665>>>>>>>>>>>>>        Move (CM_SetLanguage(Self,sLanguage))  to iRet
90666>>>>>>>>>>>>>        Get EditorMessage SCI_GETLEXER 0 0     to iLexer
90667>>>>>>>>>>>>>        Move (ZeroString(255)) to sLexerLang
90668>>>>>>>>>>>>>        Get EditorMessage SCI_GETLEXERLANGUAGE 0 (AddressOf(sLexerLang)) to iRet
90669>>>>>>>>>>>>>        Get FindLanguage    of ghoEditorProperties sLanguage    to iLanguage
90670>>>>>>>>>>>>>
90670>>>>>>>>>>>>>        If (iLexer=SCLEX_DATAFLEX) Begin
90672>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szKeywords(ghoEditorProperties, iLanguage))         to sKeywords
90673>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szScopeKeywords1(ghoEditorProperties, iLanguage))   to sScopeKeywords1
90674>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szScopeKeywords2(ghoEditorProperties, iLanguage))   to sScopeKeywords2
90675>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szOperators(ghoEditorProperties,iLanguage))         to sOperators
90676>>>>>>>>>>>>>            Move (Replaces("^",sOperators,"")) to sOperators // The ^ char is a wildcard match in scintilla, the result is EVERYTHING is an operator, so remove it before passing it, it is a hardcoded operator in scintilla.
90677>>>>>>>>>>>>>            // Fill the arrays for normalizing case feature when typing
90677>>>>>>>>>>>>>            Get InitializedLanguage of oNormalizeCase SCLEX_DATAFLEX to bInit
90678>>>>>>>>>>>>>            If (bInit=False) Begin
90680>>>>>>>>>>>>>                Send AddKeywords   of oNormalizeCase SCLEX_DATAFLEX sKeywords
90681>>>>>>>>>>>>>                Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords1
90682>>>>>>>>>>>>>                Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords2
90683>>>>>>>>>>>>>            End
90683>>>>>>>>>>>>>>
90683>>>>>>>>>>>>>            // Supply the keywords/scope keywords in lower case as the lexer matches on lowercase characters
90683>>>>>>>>>>>>>            Move (Lowercase(sKeywords)) to sKeywords
90684>>>>>>>>>>>>>            Move (sKeywords+Character(0)) to sKeywords
90685>>>>>>>>>>>>>            Move (Lowercase(sScopeKeywords1)) to sScopeKeywords1
90686>>>>>>>>>>>>>            Move (Lowercase(sScopeKeywords2)) to sScopeKeywords2
90687>>>>>>>>>>>>>            Move (Lowercase(sOperators))      to sOperators
90688>>>>>>>>>>>>>            Send EditorMessage SCI_SETKEYWORDS 0 (AddressOf(sKeywords))         // language keywords
90689>>>>>>>>>>>>>            If (sScopeKeywords1<>"" and sScopeKeywords2<>"") Begin
90691>>>>>>>>>>>>>                Send EditorMessage SCI_SETKEYWORDS 1 (AddressOf(sScopeKeywords1)) // scope open
90692>>>>>>>>>>>>>                Send EditorMessage SCI_SETKEYWORDS 2 (AddressOf(sScopeKeywords2)) // scope close
90693>>>>>>>>>>>>>                Send EditorMessage SCI_SETKEYWORDS 3 (AddressOf(sOperators))      // operators
90694>>>>>>>>>>>>>            End
90694>>>>>>>>>>>>>>
90694>>>>>>>>>>>>>            //
90694>>>>>>>>>>>>>        End
90694>>>>>>>>>>>>>>
90694>>>>>>>>>>>>>        // Use shortcut keys as defined in hammer config codemaxedit.ini file.
90694>>>>>>>>>>>>>        Send RegisterAllInternalCommands
90695>>>>>>>>>>>>>        Send RegisterExtraCommands
90696>>>>>>>>>>>>>        Get psEditorHotKeys of ghoEditorProperties to sHotKeys
90697>>>>>>>>>>>>>        Get CMSetHotkeys sHotKeys  to iRet
90698>>>>>>>>>>>>>    End_Procedure
90699>>>>>>>>>>>>>
90699>>>>>>>>>>>>>    Function Line_Count Returns Integer
90701>>>>>>>>>>>>>        Integer iCount
90701>>>>>>>>>>>>>        Get SC_LineCount to iCount
90702>>>>>>>>>>>>>//        Get CM_GetLineCount to iCount
90702>>>>>>>>>>>>>        Function_Return iCount
90703>>>>>>>>>>>>>    End_Function
90704>>>>>>>>>>>>>
90704>>>>>>>>>>>>>    Function Line Integer iLine Returns String
90706>>>>>>>>>>>>>        String sLine
90706>>>>>>>>>>>>>        Get CM_GetLine iLine to sLine
90707>>>>>>>>>>>>>        Function_Return sLine
90708>>>>>>>>>>>>>    End_Function
90709>>>>>>>>>>>>>
90709>>>>>>>>>>>>>    Procedure AppendText String sText
90711>>>>>>>>>>>>>        Integer eSuccess
90711>>>>>>>>>>>>>        Get CM_AddText sText to eSuccess
90712>>>>>>>>>>>>>    End_Procedure
90713>>>>>>>>>>>>>
90713>>>>>>>>>>>>>End_Class
90714>>>>>>>>>>>Use seq_chnl.pkg
90714>>>>>>>>>>>
90714>>>>>>>>>>>// On_Key constant for Ctrl+Shift+Tab
90714>>>>>>>>>>>Define C_CtrlShiftTab for 7170
90714>>>>>>>>>>>Class cScintillaRefactorEditor is a cScintillaEdit
90715>>>>>>>>>>>    
90715>>>>>>>>>>>    Procedure Construct_Object
90717>>>>>>>>>>>        Forward Send Construct_Object
90719>>>>>>>>>>>
90719>>>>>>>>>>>        Set peAnchors to anAll
90720>>>>>>>>>>>        
90720>>>>>>>>>>>        Property Boolean piInSetFocus False
90721>>>>>>>>>>>        Property DateTime pdtCurrentFileDateTime
90722>>>>>>>>>>>        Property String psCodeFile
90723>>>>>>>>>>>        
90723>>>>>>>>>>>        On_Key Key_Ctrl+Key_Tab Send Switch_Next_View
90724>>>>>>>>>>>        On_Key C_CtrlShiftTab   Send Switch_Prior_View
90725>>>>>>>>>>>        On_Key Key_Ctrl+Key_S   Send Request_Save
90726>>>>>>>>>>>        On_Key Key_Ctrl+Key_F   Send CME_Find
90727>>>>>>>>>>>        On_Key Key_F3           Send CME_FindNext
90728>>>>>>>>>>>        On_Key Key_Shift+Key_F3 Send CME_FindPrevious   
90729>>>>>>>>>>>        On_Key Key_Ctrl+Key_G   Send CME_GotoLine  
90730>>>>>>>>>>>        
90730>>>>>>>>>>>        On_Key Key_Ctrl+Key_Alt+Key_F3 Send CME_FindReplace  
90731>>>>>>>>>>>    End_Procedure
90732>>>>>>>>>>>    
90732>>>>>>>>>>>    // These three should only be send when the function library is not called,
90732>>>>>>>>>>>    // from the main program DFRefactor. The program instead calls function 
90732>>>>>>>>>>>    // RefactorSourceFileInEditor from the EditorView.vw.
90732>>>>>>>>>>>    // Note that a WriteDataToEditor call is needed before calling these functions,
90732>>>>>>>>>>>    // to write the asSourceFile string array to the editor.
90732>>>>>>>>>>>    // After calling the function a WriteDataToDisk call should be made. 
90732>>>>>>>>>>>//    Function RefactorNormalizeCase String[] ByRef asSourceFile Returns Boolean
90732>>>>>>>>>>>//        Boolean bChanged bOK
90732>>>>>>>>>>>//        String[] ByRef asSourceFileOrg
90732>>>>>>>>>>>//        
90732>>>>>>>>>>>//        Move False to bChanged
90732>>>>>>>>>>>//        Move asSourceFile to asSourceFileOrg
90732>>>>>>>>>>>//        Get WriteDataToEditor asSourceFile to bOK
90732>>>>>>>>>>>//        If (bOK = True) Begin
90732>>>>>>>>>>>//            Send RefactorNormalizeCase                                   
90732>>>>>>>>>>>//            Get EditorDataAsStringArray to asSourceFile
90732>>>>>>>>>>>//            Move (not(IsSameArray(asSourceFile, asSourceFileOrg))) to bChanged
90732>>>>>>>>>>>//        End
90732>>>>>>>>>>>//        Function_Return bChanged
90732>>>>>>>>>>>//    End_Function
90732>>>>>>>>>>>//        
90732>>>>>>>>>>>//    Function RefactorReIndent String[] ByRef asSourceFile Returns Integer
90732>>>>>>>>>>>//        Boolean bChanged bOK
90732>>>>>>>>>>>//        String[] ByRef asSourceFileOrg
90732>>>>>>>>>>>//        
90732>>>>>>>>>>>//        Move False to bChanged
90732>>>>>>>>>>>//        Move asSourceFile to asSourceFileOrg
90732>>>>>>>>>>>//        Get WriteDataToEditor asSourceFile to bOK
90732>>>>>>>>>>>//        If (bOK = True) Begin
90732>>>>>>>>>>>//            Send RefactorReIndent
90732>>>>>>>>>>>//            Get EditorDataAsStringArray to asSourceFile
90732>>>>>>>>>>>//            Move (not(IsSameArray(asSourceFile, asSourceFileOrg))) to bChanged
90732>>>>>>>>>>>//        End
90732>>>>>>>>>>>//        Function_Return bChanged
90732>>>>>>>>>>>//    End_Function
90732>>>>>>>>>>>//        
90732>>>>>>>>>>>//    Function RefactorDropSelf String[] ByRef asSourceFile Returns Integer
90732>>>>>>>>>>>//        Boolean bChanged bOK
90732>>>>>>>>>>>//        String[] ByRef asSourceFileOrg
90732>>>>>>>>>>>//
90732>>>>>>>>>>>//        Move False to bChanged
90732>>>>>>>>>>>//        Move asSourceFile to asSourceFileOrg
90732>>>>>>>>>>>//        Get WriteDataToEditor asSourceFile to bOK
90732>>>>>>>>>>>//        If (bOK = True) Begin
90732>>>>>>>>>>>//            Send RefactorDropSelf
90732>>>>>>>>>>>//            Get EditorDataAsStringArray to asSourceFile
90732>>>>>>>>>>>//            Move (not(IsSameArray(asSourceFile, asSourceFileOrg))) to bChanged
90732>>>>>>>>>>>//        End
90732>>>>>>>>>>>//        Function_Return bChanged
90732>>>>>>>>>>>//    End_Function
90732>>>>>>>>>>>
90732>>>>>>>>>>>    Function ReadImageDataToStringArray Integer iImg Returns String[]
90734>>>>>>>>>>>        Integer iChannel iCount
90734>>>>>>>>>>>        String sTextValue sLine
90734>>>>>>>>>>>        Boolean bSeqEof
90734>>>>>>>>>>>        String[] asCode
90735>>>>>>>>>>>        
90735>>>>>>>>>>>        Move "" to sTextValue
90736>>>>>>>>>>>        Move 0 to iCount
90737>>>>>>>>>>>        
90737>>>>>>>>>>>        Get Seq_New_Channel to iChannel
90738>>>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
90740>>>>>>>>>>>             Send Stop_box "No channel available. Function: 'ReadImageDataToStringArray'"
90741>>>>>>>>>>>             Function_Return asCode
90742>>>>>>>>>>>        End
90742>>>>>>>>>>>>
90742>>>>>>>>>>>        
90742>>>>>>>>>>>        Send Delete_Data
90743>>>>>>>>>>>        Direct_Input channel iChannel ("image: " + String(iImg))
90745>>>>>>>>>>>        
90745>>>>>>>>>>>        While (SeqEof = False)
90749>>>>>>>>>>>            Readln channel iChannel sLine
90751>>>>>>>>>>>            Move sLine to asCode[iCount]
90752>>>>>>>>>>>            Increment iCount
90753>>>>>>>>>>>        Loop
90754>>>>>>>>>>>>
90754>>>>>>>>>>>        Close_Input channel iChannel
90756>>>>>>>>>>>        Send Seq_Release_Channel iChannel 
90757>>>>>>>>>>>        Move (ResizeArray(asCode, (iCount -1))) to asCode
90758>>>>>>>>>>>        
90758>>>>>>>>>>>        Function_Return asCode
90759>>>>>>>>>>>    End_Function
90760>>>>>>>>>>>    
90760>>>>>>>>>>>    Function ToggleScopeBlocks Returns Integer
90762>>>>>>>>>>>        Integer iMode
90762>>>>>>>>>>>        Get EditorMessage SCI_FOLDALL to iMode
90763>>>>>>>>>>>        Function_Return iMode
90764>>>>>>>>>>>    End_Function
90765>>>>>>>>>>>    
90765>>>>>>>>>>>    // Needed by the toolbar system.
90765>>>>>>>>>>>    Procedure Request_Save
90767>>>>>>>>>>>        Send SaveFile
90768>>>>>>>>>>>    End_Procedure
90769>>>>>>>>>>>    
90769>>>>>>>>>>>    Procedure Help
90771>>>>>>>>>>>       Delegate Send Help
90773>>>>>>>>>>>    End_Procedure
90774>>>>>>>>>>>
90774>>>>>>>>>>>    Procedure SaveFile
90776>>>>>>>>>>>        Boolean bOK
90776>>>>>>>>>>>
90776>>>>>>>>>>>        Send DispatchAnyKey
90777>>>>>>>>>>>        Get WriteToDisk to bOK
90778>>>>>>>>>>>        If (bOK = False) Begin
90780>>>>>>>>>>>            Send Info_Box "An error occured and the file couldn't be saved properly."
90781>>>>>>>>>>>        End
90781>>>>>>>>>>>>
90781>>>>>>>>>>>        Else Begin
90782>>>>>>>>>>>            Set ActionText of (StatusBar_Id(Self))  to "Changes saved!"
90783>>>>>>>>>>>        End
90783>>>>>>>>>>>>
90783>>>>>>>>>>>    End_Procedure
90784>>>>>>>>>>>    
90784>>>>>>>>>>>    // Helper function (to SaveFile)
90784>>>>>>>>>>>    Function WriteToDisk Returns Boolean
90786>>>>>>>>>>>        String sFileName
90786>>>>>>>>>>>        Integer eResult
90786>>>>>>>>>>>        Boolean bOK
90786>>>>>>>>>>>
90786>>>>>>>>>>>        Get psCodeFile to sFileName
90787>>>>>>>>>>>        Get CM_SaveFile sFileName False to eResult
90788>>>>>>>>>>>        Send FillFileTimeStamp sFileName // Update the filetime.
90789>>>>>>>>>>>
90789>>>>>>>>>>>        Function_Return (eResult = CME_SUCCESS)
90790>>>>>>>>>>>    End_Function
90791>>>>>>>>>>>
90791>>>>>>>>>>>    Function WriteDataToEditor String[] asCode Returns Boolean
90793>>>>>>>>>>>        Integer iCount iSize     
90793>>>>>>>>>>>        String sLine
90793>>>>>>>>>>>        
90793>>>>>>>>>>>        Send Delete_Data
90794>>>>>>>>>>>        Move (SizeOfArray(asCode)) to iSize
90795>>>>>>>>>>>        Decrement iSize
90796>>>>>>>>>>>        
90796>>>>>>>>>>>        For iCount from 0 to iSize
90802>>>>>>>>>>>>
90802>>>>>>>>>>>            Move asCode[iCount] to sLine
90803>>>>>>>>>>>            If (iCount < iSize) Begin
90805>>>>>>>>>>>                Move (sLine + CS_CRLF) to sLine
90806>>>>>>>>>>>            End
90806>>>>>>>>>>>>
90806>>>>>>>>>>>            Send AppendText sLine
90807>>>>>>>>>>>        Loop
90808>>>>>>>>>>>>
90808>>>>>>>>>>>        
90808>>>>>>>>>>>        Function_Return True
90809>>>>>>>>>>>    End_Function
90810>>>>>>>>>>>
90810>>>>>>>>>>>    Function EditorDataAsStringArray Returns String[]
90812>>>>>>>>>>>        String[] asCode
90813>>>>>>>>>>>        String sLine
90813>>>>>>>>>>>        Integer iSize iCount 
90813>>>>>>>>>>>        
90813>>>>>>>>>>>        Get Line_Count to iSize   
90814>>>>>>>>>>>        Decrement iSize
90815>>>>>>>>>>>        For iCount from 0 to iSize
90821>>>>>>>>>>>>
90821>>>>>>>>>>>            Get Line iCount to sLine
90822>>>>>>>>>>>            Move sLine to asCode[iCount]    
90823>>>>>>>>>>>        Loop                                  
90824>>>>>>>>>>>>
90824>>>>>>>>>>>        
90824>>>>>>>>>>>        Function_Return asCode
90825>>>>>>>>>>>    End_Function   
90826>>>>>>>>>>>
90826>>>>>>>>>>>    Procedure JumpToSourceLine Integer iLine
90828>>>>>>>>>>>        Handle hoEdit
90828>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit    
90829>>>>>>>>>>>        If (hoEdit <> 0) Begin
90831>>>>>>>>>>>            Send Activate of hoEdit
90832>>>>>>>>>>>            Send EditorMessage of hoEdit SCI_GOTOLINE iLine
90833>>>>>>>>>>>        End
90833>>>>>>>>>>>>
90833>>>>>>>>>>>    End_Procedure
90834>>>>>>>>>>>            
90834>>>>>>>>>>>    Procedure LoadFile String sFileName
90836>>>>>>>>>>>        Integer eStatus
90836>>>>>>>>>>>        
90836>>>>>>>>>>>        If (sFileName <> "") Begin
90838>>>>>>>>>>>            Set psCodeFile to sFileName
90839>>>>>>>>>>>            Send Delete_Data
90840>>>>>>>>>>>            Get CM_OpenFile sFileName to eStatus
90841>>>>>>>>>>>            Send FillFileTimeStamp sFileName // Update the filetime.  
90842>>>>>>>>>>>            // Activate the Editor object(!) and view.
90842>>>>>>>>>>>            Send Activate
90843>>>>>>>>>>>        End
90843>>>>>>>>>>>>
90843>>>>>>>>>>>    End_Procedure   
90844>>>>>>>>>>>    
90844>>>>>>>>>>>    Procedure Request_Clear
90846>>>>>>>>>>>        Send Delete_Data
90847>>>>>>>>>>>    End_Procedure
90848>>>>>>>>>>>
90848>>>>>>>>>>>    Function CharacterCount Returns Integer
90850>>>>>>>>>>>        Integer iLineCount iStartPos iEndPos
90850>>>>>>>>>>>        Integer iTotalCharacters
90850>>>>>>>>>>>
90850>>>>>>>>>>>        Move 0 to iTotalCharacters
90851>>>>>>>>>>>        Get EditorMessage SCI_GETLINECOUNT 0 0 to iLineCount
90852>>>>>>>>>>>        If (iLineCount > 0) Begin
90854>>>>>>>>>>>            Get EditorMessage SCI_POSITIONFROMLINE 0 0 to iStartPos
90855>>>>>>>>>>>            Get EditorMessage SCI_GETLINEENDPOSITION (iLineCount - 1) 0 to iEndPos
90856>>>>>>>>>>>            Get EditorMessage SCI_COUNTCHARACTERS iStartPos iEndPos to iTotalCharacters
90857>>>>>>>>>>>        End
90857>>>>>>>>>>>>
90857>>>>>>>>>>>
90857>>>>>>>>>>>        Function_Return iTotalCharacters
90858>>>>>>>>>>>    End_Function
90859>>>>>>>>>>>
90859>>>>>>>>>>>    Procedure ApplyEditorOptions
90861>>>>>>>>>>>        Forward Send ApplyEditorOptions
90863>>>>>>>>>>>    End_Procedure
90864>>>>>>>>>>>
90864>>>>>>>>>>>    Procedure FillFileTimeStamp String sFileName
90866>>>>>>>>>>>        DateTime dtCurrentFileDateTime
90866>>>>>>>>>>>        Get FileModTime sFileName  to dtCurrentFileDateTime
90867>>>>>>>>>>>        Set pdtCurrentFileDateTime to dtCurrentFileDateTime
90868>>>>>>>>>>>    End_Procedure
90869>>>>>>>>>>>
90869>>>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
90869>>>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
90871>>>>>>>>>>>        Date dDate
90871>>>>>>>>>>>        Integer iYY iHH iMM iSS
90871>>>>>>>>>>>        Boolean bExists
90871>>>>>>>>>>>        DateTime dtFileDateTime
90871>>>>>>>>>>>
90871>>>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
90872>>>>>>>>>>>        Get vFilePathExists sFileName to bExists
90873>>>>>>>>>>>        If (bExists = True) Begin
90875>>>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
90879>>>>>>>>>>>            Move dDate            to dtFileDateTime
90880>>>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
90881>>>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
90882>>>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
90883>>>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
90884>>>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
90885>>>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
90886>>>>>>>>>>>        End
90886>>>>>>>>>>>>
90886>>>>>>>>>>>
90886>>>>>>>>>>>        Function_Return dtFileDateTime
90887>>>>>>>>>>>    End_Function
90888>>>>>>>>>>>
90888>>>>>>>>>>>    Function IsFileTimeNewer String sFileName Returns Boolean
90890>>>>>>>>>>>        Boolean bExists bIsNewer
90890>>>>>>>>>>>        DateTime dtCurrentFileDateTime dtCompareFileDateTime
90890>>>>>>>>>>>
90890>>>>>>>>>>>        Move False to bIsNewer
90891>>>>>>>>>>>        Get vFilePathExists sFileName to bExists
90892>>>>>>>>>>>        If (bExists = True) Begin
90894>>>>>>>>>>>            Get pdtCurrentFileDateTime to dtCurrentFileDateTime
90895>>>>>>>>>>>            Get FileModTime sFileName  to dtCompareFileDateTime
90896>>>>>>>>>>>            Move (dtCompareFileDateTime > dtCurrentFileDateTime) to bIsNewer
90897>>>>>>>>>>>        End
90897>>>>>>>>>>>>
90897>>>>>>>>>>>        Function_Return bIsNewer
90898>>>>>>>>>>>    End_Function
90899>>>>>>>>>>>
90899>>>>>>>>>>>    Procedure Set piTabSize Integer iTabSize
90901>>>>>>>>>>>        Send EditorMessage SCI_SETTABWIDTH iTabSize
90902>>>>>>>>>>>        Set piTabSize of ghoEditorProperties to iTabSize
90903>>>>>>>>>>>        Send SaveIni  of ghoEditorProperties
90904>>>>>>>>>>>    End_Procedure
90905>>>>>>>>>>>
90905>>>>>>>>>>>    Function piTabSize Returns Integer
90907>>>>>>>>>>>        Integer iTabSize
90907>>>>>>>>>>>        Send EditorMessage SCI_GETTABWIDTH iTabSize
90908>>>>>>>>>>>        Function_Return iTabSize
90909>>>>>>>>>>>    End_Function
90910>>>>>>>>>>>
90910>>>>>>>>>>>    Procedure UpdateStatusBar String sText Boolean bIdleTextOnly Integer iLi Integer iChrs
90912>>>>>>>>>>>        Handle hoStatusBar
90912>>>>>>>>>>>        Integer iLines iCharacters
90912>>>>>>>>>>>
90912>>>>>>>>>>>        Move (StatusBar_Id(Self)) to hoStatusBar   
90913>>>>>>>>>>>        If (num_arguments > 2) Begin
90915>>>>>>>>>>>            Move iChrs to iCharacters
90916>>>>>>>>>>>            If (iCharacters = 0) Begin
90918>>>>>>>>>>>                Move 0 to iLines
90919>>>>>>>>>>>            End                 
90919>>>>>>>>>>>>
90919>>>>>>>>>>>            Else Begin
90920>>>>>>>>>>>                Move iLi to iLines
90921>>>>>>>>>>>            End
90921>>>>>>>>>>>>
90921>>>>>>>>>>>            Set NumberOfEditorLines      of hoStatusBar to iLines
90922>>>>>>>>>>>            Set NumberOfEditorCharacters of hoStatusBar to iCharacters
90923>>>>>>>>>>>        End
90923>>>>>>>>>>>>
90923>>>>>>>>>>>        Else Begin
90924>>>>>>>>>>>            If (bIdleTextOnly = True) Begin
90926>>>>>>>>>>>                Set psIdleText of hoStatusBar to sText
90927>>>>>>>>>>>                Set ActionText of hoStatusBar to ""
90928>>>>>>>>>>>            End
90928>>>>>>>>>>>>
90928>>>>>>>>>>>            Else Begin
90929>>>>>>>>>>>                Set ActionText of hoStatusBar to sText 
90930>>>>>>>>>>>            End
90930>>>>>>>>>>>>
90930>>>>>>>>>>>        End
90930>>>>>>>>>>>>
90930>>>>>>>>>>>        Send PumpMsgQueue of Desktop
90931>>>>>>>>>>>    End_Procedure    
90932>>>>>>>>>>>    
90932>>>>>>>>>>>    Procedure Request_Save
90934>>>>>>>>>>>        Send SaveFile    
90935>>>>>>>>>>>    End_Procedure
90936>>>>>>>>>>>    
90936>>>>>>>>>>>    Procedure Changed_State Boolean bChanged
90938>>>>>>>>>>>        Send EditorMessage SCI_GETMODIFY bChanged
90939>>>>>>>>>>>    End_Procedure
90940>>>>>>>>>>>    
90940>>>>>>>>>>>    Function Changed_State Returns Boolean
90942>>>>>>>>>>>        Boolean bChanged
90942>>>>>>>>>>>        Get CM_IsModified to bChanged
90943>>>>>>>>>>>        Function_Return bChanged        
90944>>>>>>>>>>>    End_Function
90945>>>>>>>>>>>    
90945>>>>>>>>>>>    Procedure OnChange
90947>>>>>>>>>>>        Boolean bChanged
90947>>>>>>>>>>>        Get CM_IsModified to bChanged
90948>>>>>>>>>>>        If (bChanged = True) Begin
90950>>>>>>>>>>>            Set ActionText of (StatusBar_Id(Self))  to ""
90951>>>>>>>>>>>        End
90951>>>>>>>>>>>>
90951>>>>>>>>>>>    End_Procedure
90952>>>>>>>>>>>
90952>>>>>>>>>>>    // Used for checking if the file in editor has changed externally and
90952>>>>>>>>>>>    // if so reload it.
90952>>>>>>>>>>>    Procedure OnSetFocus
90954>>>>>>>>>>>        Integer iRet iCurrentLine
90954>>>>>>>>>>>        String  sMsg  sFileName
90954>>>>>>>>>>>        Handle  hoMain hoEditor
90954>>>>>>>>>>>        Boolean bUserModified bHasChangedExternal bDoReloadFile
90954>>>>>>>>>>>        Integer iLines iSize
90954>>>>>>>>>>>
90954>>>>>>>>>>>        Get Line_Count to iLines
90955>>>>>>>>>>>        Get CharacterCount to iSize
90956>>>>>>>>>>>        Send UpdateStatusBar "" False iLines iSize
90957>>>>>>>>>>>        Send OnSelChange
90958>>>>>>>>>>>        Send OnOvertypeChange
90959>>>>>>>>>>>        Move False to bDoReloadFile
90960>>>>>>>>>>>
90960>>>>>>>>>>>        Get Main_Panel_Id to hoMain
90961>>>>>>>>>>>        If (not(piInSetFocus(Self))) Begin // recursive protection
90963>>>>>>>>>>>            Set piInSetFocus to True
90964>>>>>>>>>>>            Get psCodeFile to sFileName
90965>>>>>>>>>>>            If (sFileName = "") Begin
90967>>>>>>>>>>>                Procedure_Return
90968>>>>>>>>>>>            End
90968>>>>>>>>>>>>
90968>>>>>>>>>>>            Get IsFileTimeNewer sFileName to bHasChangedExternal
90969>>>>>>>>>>>            Get CM_IsModified to bUserModified
90970>>>>>>>>>>>            If (bHasChangedExternal and bUserModified) Begin
90972>>>>>>>>>>>                If (bUserModified) Begin
90974>>>>>>>>>>>                    Append sMsg "The file has been changed by another program.\n\n"
90975>>>>>>>>>>>                End
90975>>>>>>>>>>>>
90975>>>>>>>>>>>                Append sMsg "Do you want to reload it?\n"
90976>>>>>>>>>>>                If (bUserModified) Begin
90978>>>>>>>>>>>                    Append sMsg "Pressing YES will discard any changes made.\n"
90979>>>>>>>>>>>                End
90979>>>>>>>>>>>>
90979>>>>>>>>>>>
90979>>>>>>>>>>>                Get YesNo_Box sMsg (Label(hoMain)) to iRet
90980>>>>>>>>>>>                If (iRet = MBR_Yes) Begin  
90982>>>>>>>>>>>                    Move True to bDoReloadFile
90983>>>>>>>>>>>                End
90983>>>>>>>>>>>>
90983>>>>>>>>>>>                Else Begin
90984>>>>>>>>>>>                    Send FillFileTimeStamp sFileName // Update the file modified datetime.
90985>>>>>>>>>>>                End
90985>>>>>>>>>>>>
90985>>>>>>>>>>>            End
90985>>>>>>>>>>>>
90985>>>>>>>>>>>
90985>>>>>>>>>>>            // If file has changed externally, but we didn't edit, then do not ask, just refresh
90985>>>>>>>>>>>            If (bHasChangedExternal and bUserModified = False) Begin
90987>>>>>>>>>>>                Get SC_LineCount to iRet
90988>>>>>>>>>>>                If (iRet > 1) Begin
90990>>>>>>>>>>>                    Move True to bDoReloadFile
90991>>>>>>>>>>>                End
90991>>>>>>>>>>>>
90991>>>>>>>>>>>            End
90991>>>>>>>>>>>>
90991>>>>>>>>>>>            If (bDoReloadFile = True) Begin
90993>>>>>>>>>>>                Move "The Editor file has been changed by another program.\n\n" to sMsg
90994>>>>>>>>>>>                Append sMsg "Reload?\n"
90995>>>>>>>>>>>                Get YesNo_Box sMsg (Label(hoMain)) to iRet
90996>>>>>>>>>>>                If (iRet = MBR_Yes) Begin
90998>>>>>>>>>>>                    Get CurrentLine to iCurrentLine
90999>>>>>>>>>>>                    Get CM_OpenFile sFileName to iRet
91000>>>>>>>>>>>                    Send EditorMessage SCI_SETSAVEPOINT
91001>>>>>>>>>>>                    If (iCurrentLine <> 0) Begin
91003>>>>>>>>>>>                        Send EditorMessage SCI_GOTOLINE iCurrentLine
91004>>>>>>>>>>>                    End
91004>>>>>>>>>>>>
91004>>>>>>>>>>>                    Send FillFileTimeStamp sFileName // Update the file modified datetime.
91005>>>>>>>>>>>                End
91005>>>>>>>>>>>>
91005>>>>>>>>>>>            End
91005>>>>>>>>>>>>
91005>>>>>>>>>>>            Set piInSetFocus to False
91006>>>>>>>>>>>        End
91006>>>>>>>>>>>>
91006>>>>>>>>>>>    End_Procedure
91007>>>>>>>>>>>
91007>>>>>>>>>>>    Procedure End_Construct_Object
91009>>>>>>>>>>>        Forward Send End_Construct_Object
91011>>>>>>>>>>>
91011>>>>>>>>>>>    End_Procedure
91012>>>>>>>>>>>
91012>>>>>>>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
91014>>>>>>>>>>>        String sSWSFile
91014>>>>>>>>>>>        Forward Send OnFileDropped sFilename bLast
91016>>>>>>>>>>>        If (bLast = True) Begin
91018>>>>>>>>>>>            Get psSWSFile of ghoApplication to sSWSFile
91019>>>>>>>>>>>            If (sSWSFile = "") Begin
91021>>>>>>>>>>>                Send Info_Box "You need to select a workspace first."
91022>>>>>>>>>>>                Procedure_Return
91023>>>>>>>>>>>            End
91023>>>>>>>>>>>>
91023>>>>>>>>>>>            Send UpdateSourceFileNameDisplay of ghoApplication sFileName
91024>>>>>>>>>>>            Send LoadFile sFilename
91025>>>>>>>>>>>        End
91025>>>>>>>>>>>>
91025>>>>>>>>>>>    End_Procedure
91026>>>>>>>>>>>
91026>>>>>>>>>>>End_Class
91027>>>>>>>>>Use cRemoveUnusedLocals.pkg
91027>>>>>>>>>Use cUnusedSourceFiles.pkg
91027>>>>>>>>>Use cDDOReStyler.pkg
Including file: cDDOReStyler.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cDDOReStyler.pkg)
91027>>>>>>>>>>>// Copyright (c)  2014  KURANT Project
91027>>>>>>>>>>>// All rights reserved.
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// $FileName    : .\Hammer\AppSrc\DDOReStyler.src
91027>>>>>>>>>>>// $ProjectName : The Hammer 2.0
91027>>>>>>>>>>>// $Authors     : wil
91027>>>>>>>>>>>// $Created     : 11.14.2014  14:21
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// $Edited      : 09.21.2021 Nils Svedmyr. Refactored to a package for the "DFRefactor" project.
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// $Type        : LGPL
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// Contents:
91027>>>>>>>>>>>//  Unfortunately the naming style of datadictionaries over time has not been constant.
91027>>>>>>>>>>>//  The new style is
91027>>>>>>>>>>>//    Object o<tablename>_DD is a c<TableName>Datadictionary
91027>>>>>>>>>>>//  They also have a switch so you can keep on using the legacy style name which is
91027>>>>>>>>>>>//    Object o<tablename>_DD is a <tablename>_Datadictionary
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//  However before VDF12, the
91027>>>>>>>>>>>//    Object <tableName>_DD is a <tablename>_Datadictionary
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
91027>>>>>>>>>>>//  all over the place. Copying old code into new views/dialogs simply breaks and if your
91027>>>>>>>>>>>//  codebase has mixed styles then the compiler will not catch that.
91027>>>>>>>>>>>//  A code nightmare.
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//  This program allows you to switch between the following code styles:
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//  <TableName>_DD              == eDDOldStyle
91027>>>>>>>>>>>//  o<TableName>_DD             == eDDStudioStyle
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// How this code works:
91027>>>>>>>>>>>// 1. It scans your source file and for each file it will locate the datadictionary objects
91027>>>>>>>>>>>//    These datadictionary objects are then stored in an array
91027>>>>>>>>>>>// 2. We read the whole filelist into another array so that we know what table names can be
91027>>>>>>>>>>>//    used.
91027>>>>>>>>>>>// 3. The DDOs found in step 1) are classified against the filelist items and we determine
91027>>>>>>>>>>>//    the DDO style used for the declared DDOs. DDOs that could be verified are labeled
91027>>>>>>>>>>>//    on style used and marked as being verified.
91027>>>>>>>>>>>// 4. We scan the source again and replace the verified DDOs with the style wanted.
91027>>>>>>>>>>>// 5. Write the source out to disk (overwriting the original)
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// Please note that if your source already contains unknown DD objects (eg. You copied old
91027>>>>>>>>>>>// style code from another version of your appinto new style code) that this parser will
91027>>>>>>>>>>>// not try to correct that. The starting point should be correct working code.
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// Note if a detected DDO is in commented out source code then we will still replace it,
91027>>>>>>>>>>>// this is to make sure uncommenting code doesn't break the source.
91027>>>>>>>>>>>// Commented out DDO declarations are -not- detected.
91027>>>>>>>>>>>//
91027>>>>>>>>>>>// The following use cases are not supported by the DDRestyler:
91027>>>>>>>>>>>//   - include files,
91027>>>>>>>>>>>//   - source files with incorrect DDOs already in there
91027>>>>>>>>>>>//       (eg. declare o<table>_DD but later on use <table>_DD)
91027>>>>>>>>>>>//   - references to DDO's not declared in the source file (non autonomous usage)
91027>>>>>>>>>>>//
91027>>>>>>>>>>>//*****************************************************************************************
91027>>>>>>>>>>>Use seq_chnl.pkg
91027>>>>>>>>>>>Use RefactorFunctionConstants.inc
91027>>>>>>>>>>>Use vwin32fh.pkg
91027>>>>>>>>>>>Use cFilesystem.pkg
91027>>>>>>>>>>>Use cSysFileDataDictionary.dd
Including file: cSysFileDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cSysFileDataDictionary.dd)
91027>>>>>>>>>>>>>Use DataDict.pkg
91027>>>>>>>>>>>>>Use cDDOReStyler.pkg
91027>>>>>>>>>>>>>
91027>>>>>>>>>>>>>Open SysFile
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>Enum_List
91029>>>>>>>>>>>>>    Define eSplitUnknown              for 0 
91029>>>>>>>>>>>>>    Define eSplitBySpaceSemiColumn    for 1
91029>>>>>>>>>>>>>    Define eSplitBySemiColumn         for 2
91029>>>>>>>>>>>>>    Define eSplitByBeginEnd           for 3
91029>>>>>>>>>>>>>End_Enum_List
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>Define CS_SplitBySpaceSemiColumn    for "Split line space and semicolon"
91029>>>>>>>>>>>>>Define CS_SplitBySemiColumn         for "Split line with semicolon"
91029>>>>>>>>>>>>>Define CS_SplitByBeginEnd           for "Add a Begin/End block"
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>// ToDo: These doesn't feel right! Ask Wil about them
91029>>>>>>>>>>>>>// Aren't modern DD classes named o<tablename>_DataDictionary ?
91029>>>>>>>>>>>>>Enum_List
91029>>>>>>>>>>>>>    Define eDDUnknown       for 0 // style unknown or not yet classified
91029>>>>>>>>>>>>>    Define eDDOldStyle      for 1 // <tablename>_DD
91029>>>>>>>>>>>>>    Define eDDStudioStyle   for 2 // o<tablename>_DD
91029>>>>>>>>>>>>>    Define eDDNewStyle      for 3 // o<tablename>_dd
91029>>>>>>>>>>>>>End_Enum_List
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>Define CS_DDOldStyle      for "<tablename>_DD"
91029>>>>>>>>>>>>>Define CS_DDLegacyStyle   for "o<tablename>_DD"
91029>>>>>>>>>>>>>Define CS_DDNewStyle      for "o<tablename>_dd"
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>
91029>>>>>>>>>>>>>Object oSplitInFile is a DescriptionValidationTable
91031>>>>>>>>>>>>>    Procedure Fill_List
91034>>>>>>>>>>>>>        Forward Send Fill_List
91036>>>>>>>>>>>>>        Send Add_Table_Value eSplitBySpaceSemiColumn CS_SplitBySpaceSemiColumn
91037>>>>>>>>>>>>>        Send Add_Table_Value eSplitBySemiColumn      CS_SplitBySemiColumn
91038>>>>>>>>>>>>>        Send Add_Table_Value eSplitByBeginEnd        CS_SplitByBeginEnd
91039>>>>>>>>>>>>>    End_Procedure
91040>>>>>>>>>>>>>End_Object
91041>>>>>>>>>>>>>
91041>>>>>>>>>>>>>Object oDDOStyler is a DescriptionValidationTable
91043>>>>>>>>>>>>>    Procedure Fill_List
91046>>>>>>>>>>>>>        Forward Send Fill_List
91048>>>>>>>>>>>>>        Send Add_Table_Value eDDOldStyle    CS_DDOldStyle
91049>>>>>>>>>>>>>        Send Add_Table_Value eDDStudioStyle CS_DDLegacyStyle
91050>>>>>>>>>>>>>        Send Add_Table_Value eDDNewStyle    CS_DDNewStyle
91051>>>>>>>>>>>>>    End_Procedure
91052>>>>>>>>>>>>>End_Object
91053>>>>>>>>>>>>>
91053>>>>>>>>>>>>>Class cSysFileDataDictionary is a DataDictionary
91054>>>>>>>>>>>>>    
91054>>>>>>>>>>>>>    Procedure Construct_Object
91056>>>>>>>>>>>>>        Forward Send Construct_Object
91058>>>>>>>>>>>>>        Set Main_File to SysFile.File_Number
91059>>>>>>>>>>>>>
91059>>>>>>>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
91060>>>>>>>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
91061>>>>>>>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
91062>>>>>>>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
91063>>>>>>>>>>>>>
91063>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.PathStarZen to "Path to Starzen tool"
91064>>>>>>>>>>>>>
91064>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.PathSourceCompareTool to "Source Compare tool"
91065>>>>>>>>>>>>>        Set Field_Label_Short Field SysFile.PathSourceCompareTool to "Source Compare tool"
91066>>>>>>>>>>>>>        Set Status_Help Field SysFile.PathSourceCompareTool to "Path to a Source Compare tool"
91067>>>>>>>>>>>>>
91067>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.FileExtensionFilter to "File Extension Filter"
91068>>>>>>>>>>>>>        Set Field_Label_Short Field SysFile.FileExtensionFilter to "File Extension Filter"
91069>>>>>>>>>>>>>        Set Field_Class_Name Field SysFile.FileExtensionFilter to "Combo"
91070>>>>>>>>>>>>>
91070>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.bCountSourceLines to "Count number of source lines"
91071>>>>>>>>>>>>>        Set Field_Label_Short Field SysFile.bCountSourceLines to "Count source lines"
91072>>>>>>>>>>>>>        Set Field_Class_Name Field SysFile.bCountSourceLines to "Checkbox"
91073>>>>>>>>>>>>>        Set Field_Checkbox_Values Field SysFile.bCountSourceLines to "1" "0"
91074>>>>>>>>>>>>>        Set Status_Help Field SysFile.bCountSourceLines to "Note: This function must be run alone. All other functions will be ignored!"
91075>>>>>>>>>>>>>        Set Field_Checkbox_Values Field SysFile.bEditorDropSelf to "1" "0"
91076>>>>>>>>>>>>>
91076>>>>>>>>>>>>>    End_Procedure
91077>>>>>>>>>>>>>
91077>>>>>>>>>>>>>    Procedure Field_Defaults
91079>>>>>>>>>>>>>        Forward Send Field_Defaults
91081>>>>>>>>>>>>>        Set Field_Changed_Value Field SysFile.bCountSourceLines to 0
91082>>>>>>>>>>>>>        Set Field_Changed_Value Field SysFile.bEditorDropSelf to 0
91083>>>>>>>>>>>>>    End_Procedure 
91084>>>>>>>>>>>>>    
91084>>>>>>>>>>>>>    Procedure Update
91086>>>>>>>>>>>>>        Forward Send Update
91088>>>>>>>>>>>>>    End_Procedure
91089>>>>>>>>>>>>>
91089>>>>>>>>>>>>>End_Class
91090>>>>>>>>>>>
91090>>>>>>>>>>>Struct tFileList
91090>>>>>>>>>>>    Integer iFileNum
91090>>>>>>>>>>>    String  sRootName     // actual filename
91090>>>>>>>>>>>    String  sDisplayName  // description
91090>>>>>>>>>>>    String  sTable        // datadictionary name is based on sTable (see aliases)
91090>>>>>>>>>>>End_Struct
91090>>>>>>>>>>>
91090>>>>>>>>>>>Struct tDDO
91090>>>>>>>>>>>    String  sDDO          // sDDO name
91090>>>>>>>>>>>    Boolean bVerified     // sDDO name has been verified against filelist
91090>>>>>>>>>>>    Integer eDDOStyle     // DDO naming style
91090>>>>>>>>>>>    Integer iLine         // source line where the DDO is declared
91090>>>>>>>>>>>    Integer iFileNum      // Not needed at this stage, but we got the data, so stick it in
91090>>>>>>>>>>>    String  sTableName    // Just as easy to have
91090>>>>>>>>>>>End_Struct
91090>>>>>>>>>>>
91090>>>>>>>>>>>Class cDataFiles is a cObject
91091>>>>>>>>>>>    Procedure Construct_Object
91093>>>>>>>>>>>        Forward Send Construct_Object
91095>>>>>>>>>>>        Property tFileList[] pFileList
91096>>>>>>>>>>>    End_Procedure
91097>>>>>>>>>>>
91097>>>>>>>>>>>    // Loops through the Filelist.cfg and enumerates all tables.
91097>>>>>>>>>>>    Procedure EnumerateAllFiles
91099>>>>>>>>>>>        Integer iFile iIndex 
91099>>>>>>>>>>>        String sRoot sDisplay sTable
91099>>>>>>>>>>>        tFileList[] aFilelist
91099>>>>>>>>>>>        tFileList[] aFilelist
91100>>>>>>>>>>>
91100>>>>>>>>>>>        Move (ResizeArray(aFilelist,0)) to aFilelist
91101>>>>>>>>>>>        Move 0 to iFile
91102>>>>>>>>>>>        Move 0 to iIndex
91103>>>>>>>>>>>        Repeat
91103>>>>>>>>>>>>
91103>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iFile to iFile
91106>>>>>>>>>>>            If (iFile > 0) Begin
91108>>>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of iFile to sRoot
91111>>>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of iFile to sDisplay
91114>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sTable
91117>>>>>>>>>>>                Move iFile    to aFilelist[iIndex].iFileNum
91118>>>>>>>>>>>                Move sRoot    to aFilelist[iIndex].sRootName
91119>>>>>>>>>>>                Move sDisplay to aFilelist[iIndex].sDisplayName
91120>>>>>>>>>>>                Move sTable   to aFilelist[iIndex].sTable
91121>>>>>>>>>>>                Increment iIndex
91122>>>>>>>>>>>            End
91122>>>>>>>>>>>>
91122>>>>>>>>>>>        Until (iFile = 0)
91124>>>>>>>>>>>        
91124>>>>>>>>>>>        Set pFileList to aFilelist
91125>>>>>>>>>>>    End_Procedure
91126>>>>>>>>>>>
91126>>>>>>>>>>>End_Class
91127>>>>>>>>>>>
91127>>>>>>>>>>>//Class cStylerFolder is a cObject 
91127>>>>>>>>>>>//    Procedure Construct_Object
91127>>>>>>>>>>>//        Forward Send Construct_Object
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Property Boolean pbOk
91127>>>>>>>>>>>//        Property String  psFolderName  ""
91127>>>>>>>>>>>//        Property String  psFileMask    ""
91127>>>>>>>>>>>//        Property Integer peNewStyle    0
91127>>>>>>>>>>>//        
91127>>>>>>>>>>>//        Property String psHomePath
91127>>>>>>>>>>>//        Property String[] pasFolderNames
91127>>>>>>>>>>>//        Property String psFileFilter
91127>>>>>>>>>>>//        Property Handle phoFileSystem
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Object oFilesystem is a cFilesystem
91127>>>>>>>>>>>//            Set phoFileSystem to Self
91127>>>>>>>>>>>//        End_Object                   
91127>>>>>>>>>>>//        
91127>>>>>>>>>>>//    End_Procedure
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Procedure OnProcess
91127>>>>>>>>>>>//        Boolean bOk
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Get MainProcedure to bOK
91127>>>>>>>>>>>//        Set pbOk to bOk
91127>>>>>>>>>>>//    End_Procedure
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Procedure RestyleDDObjects String sFileName Integer eDDStyle
91127>>>>>>>>>>>//        Delegate Send RestyleDDObjects sFileName eDDStyle
91127>>>>>>>>>>>//    End_Procedure
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Function MainProcedure Returns Boolean
91127>>>>>>>>>>>//        Boolean bOk bStop bFound
91127>>>>>>>>>>>//        Integer iCount iSize iTmp
91127>>>>>>>>>>>//        String  sPath sFileName sFileFilter
91127>>>>>>>>>>>//        Handle  hoDir
91127>>>>>>>>>>>//        String[] asFolderNames
91127>>>>>>>>>>>//        tsSearchResult[] asSearchResult
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Get pasFolderNames to asFolderNames
91127>>>>>>>>>>>//        Get psFileFilter   to sFileFilter
91127>>>>>>>>>>>//        Get AllSourceFiles asFolderNames sFileFilter to asSearchResult
91127>>>>>>>>>>>//        Move (SizeOfArray(asSearchResult)) to iSize
91127>>>>>>>>>>>//        Decrement iSize
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        For iCount from 0 to iSize
91127>>>>>>>>>>>//            Move asSearchResult[iCount].sAlternateFileName to sPath
91127>>>>>>>>>>>//            Get vFolderFormat sPath               to sPath
91127>>>>>>>>>>>//            Move asSearchResult[iCount].sFilename to sFileName
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//            Send RestyleDDObjects (sPath + sFileName) (peNewStyle(Self))
91127>>>>>>>>>>>//        Loop
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Function_Return bOk
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Function NoFolderListAsArray Boolean bNoBackupFolder Returns String[]
91127>>>>>>>>>>>//        String sNoFolderList
91127>>>>>>>>>>>//        String[] saNoFolderList
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Move CS_NoFolderList to sNoFolderList
91127>>>>>>>>>>>//        If (bNoBackupFolder = False) Begin
91127>>>>>>>>>>>//            Move (sNoFolderList + "|" + CS_BackupFolder) to sNoFolderList
91127>>>>>>>>>>>//        End
91127>>>>>>>>>>>//        Move (Lowercase(sNoFolderList)) to sNoFolderList
91127>>>>>>>>>>>//        Move (StrSplitToArray(sNoFolderList, "|")) to saNoFolderList
91127>>>>>>>>>>>//        Function_Return saNoFolderList
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Function AllSourceFolders String[] asUserSelectedFolders Returns String[]
91127>>>>>>>>>>>//        String sHomePath
91127>>>>>>>>>>>//        String[] asNoFolderSearch asSourceFolders asAllSourceFolders
91127>>>>>>>>>>>//        Integer iSize iCount
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Get psHomePath to sHomePath
91127>>>>>>>>>>>//        Get vFolderFormat sHomePath to sHomePath
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Get NoFolderListAsArray False to asNoFolderSearch
91127>>>>>>>>>>>//        Move (SizeOfArray(asUserSelectedFolders)) to iSize
91127>>>>>>>>>>>//        Decrement iSize
91127>>>>>>>>>>>//        For iCount from 0 to iSize
91127>>>>>>>>>>>//            Get RecursiveSearchFolders asUserSelectedFolders[iCount] asNoFolderSearch to asSourceFolders
91127>>>>>>>>>>>//            Move (AppendArray(asAllSourceFolders, asSourceFolders)) to asAllSourceFolders
91127>>>>>>>>>>>//        Loop
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Function_Return asAllSourceFolders
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Function AllSourceFiles String[] asUserSelectedFolders String sFileFilter Returns tsSearchResult[]
91127>>>>>>>>>>>//        Boolean bIsFileInFilter
91127>>>>>>>>>>>//        String sSourceFolder sFileMask sFileName
91127>>>>>>>>>>>//        String[] asAllSourceFolders
91127>>>>>>>>>>>//        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
91127>>>>>>>>>>>//        Integer iFolder iFolders iFile iFiles
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Move asUserSelectedFolders to asAllSourceFolders
91127>>>>>>>>>>>//        Move (SizeOfArray(asAllSourceFolders)) to iFolders
91127>>>>>>>>>>>//        Decrement iFolders
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        // Folder loop:
91127>>>>>>>>>>>//        For iFolder from 0 to iFolders
91127>>>>>>>>>>>//            Move asAllSourceFolders[iFolder] to sSourceFolder
91127>>>>>>>>>>>//            Get vFolderFormat sSourceFolder to sSourceFolder
91127>>>>>>>>>>>//            Move (sSourceFolder + "*.*") to sFileMask
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//            Get FileSearch of (phoFileSystem(Self)) sFileMask DIRMODE_FILES_ONLY False to asSourceFiles
91127>>>>>>>>>>>//            Move (SizeOfArray(asSourceFiles)) to iFiles
91127>>>>>>>>>>>//            Decrement iFiles
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//            // File loop:
91127>>>>>>>>>>>//            For iFile from 0 to iFiles
91127>>>>>>>>>>>//                Move asSourceFiles[iFile].sFilename to sFileName
91127>>>>>>>>>>>//                Get IsFileInFilter sFileName sFileFilter to bIsFileInFilter
91127>>>>>>>>>>>//                If (bIsFileInFilter = True) Begin
91127>>>>>>>>>>>//                    // Store the path in the sAlternateFileName struct item
91127>>>>>>>>>>>//                    Move sSourceFolder to asSourceFiles[iFile].sAlternateFileName
91127>>>>>>>>>>>//                End
91127>>>>>>>>>>>//                Else Begin
91127>>>>>>>>>>>//                    Move (RemoveFromArray(asSourceFiles, iFile)) to asSourceFiles
91127>>>>>>>>>>>//                    Decrement iFile
91127>>>>>>>>>>>//                    Decrement iFiles
91127>>>>>>>>>>>//                End
91127>>>>>>>>>>>//            Loop
91127>>>>>>>>>>>//            Move (AppendArray(asSourceFilesTotal, asSourceFiles)) to asSourceFilesTotal
91127>>>>>>>>>>>//        Loop
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Function_Return asSourceFilesTotal
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Function IsFileInFilter String sFileName String sFileFilter Returns Boolean
91127>>>>>>>>>>>//        Integer iSearchIndex
91127>>>>>>>>>>>//        String sExtension sChar
91127>>>>>>>>>>>//        String[] asFileFilter
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Move (Lowercase(sFileName))      to sFileName
91127>>>>>>>>>>>//        Get ParseFileExtension sFileName to sExtension
91127>>>>>>>>>>>//        Move (Left(sExtension, 1))       to sChar
91127>>>>>>>>>>>//        If (sChar <> ".") Begin
91127>>>>>>>>>>>//            Move ("." + String(sExtension)) to sExtension
91127>>>>>>>>>>>//        End
91127>>>>>>>>>>>//        Move (Lowercase(sFileFilter))         to sFileFilter
91127>>>>>>>>>>>//        Move (Replaces("*", sFileFilter, "")) to sFileFilter
91127>>>>>>>>>>>//        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilter
91127>>>>>>>>>>>//        Move (SearchArray(sExtension, asFileFilter)) to iSearchIndex
91127>>>>>>>>>>>//        Function_Return (iSearchIndex <> -1)
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    // Returns True if the passed sFolderName exists in the passed string array.
91127>>>>>>>>>>>//    Function IsFolderInNoFolderList String[] saNoFolderList String sFolderName Returns Boolean
91127>>>>>>>>>>>//        Integer iSize iCount iIndex iCurrentFolder
91127>>>>>>>>>>>//        Boolean bOK bFound
91127>>>>>>>>>>>//        String sNoFolder sFolderNameShort
91127>>>>>>>>>>>//        String[] saFolderList
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Move False to bOK
91127>>>>>>>>>>>//        Move (SearchArray(".",  saNoFolderList)) to iCurrentFolder
91127>>>>>>>>>>>//        Move (iCurrentFolder <> -1) to bFound
91127>>>>>>>>>>>//        If (bFound = True) Begin
91127>>>>>>>>>>>//            // We need to remove "." from the array to avoid problems with folders containing a "."
91127>>>>>>>>>>>//            Move (RemoveFromArray(saNoFolderList, iCurrentFolder)) to saNoFolderList
91127>>>>>>>>>>>//            // The rightmost folder name:
91127>>>>>>>>>>>//            Get ParseFileName sFolderName to sFolderNameShort
91127>>>>>>>>>>>//            Move (sFolderNameShort = ".." or sFolderNameShort = ".") to bOK // Then we're done
91127>>>>>>>>>>>//        End
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        If (bOK = False) Begin
91127>>>>>>>>>>>//            Move (Lowercase(sFolderName)) to sFolderName
91127>>>>>>>>>>>//            Move (StrSplitToArray(sFolderName, CS_DirSeparator)) to saFolderList
91127>>>>>>>>>>>//            Move (Lowercase(sFolderName)) to sFolderName
91127>>>>>>>>>>>//            Move (SizeOfArray(saNoFolderList)) to iSize
91127>>>>>>>>>>>//            Decrement iSize
91127>>>>>>>>>>>//            For iCount from 0 to iSize
91127>>>>>>>>>>>//                Move (Lowercase(saNoFolderList[iCount])) to sNoFolder
91127>>>>>>>>>>>//                Move (SearchArray(sNoFolder, saFolderList)) to iIndex
91127>>>>>>>>>>>//                If (iIndex <> -1) Begin
91127>>>>>>>>>>>//                    Move True to bOK
91127>>>>>>>>>>>//                End
91127>>>>>>>>>>>//                If (bOK = True) Break
91127>>>>>>>>>>>//            Loop
91127>>>>>>>>>>>//        End
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Function_Return bOK
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//    Function RecursiveSearchFolders String sSourceFolder String[] asNoFolderList Returns String[]
91127>>>>>>>>>>>//        Boolean bFound
91127>>>>>>>>>>>//        Integer iCount iSize iItem
91127>>>>>>>>>>>//        String sMask sFileName sPrevFolderName sHomePath
91127>>>>>>>>>>>//        tsSearchResult[] asSearchResult
91127>>>>>>>>>>>//        String[] saSearchFolders
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        If (not(sSourceFolder contains ":")) Begin
91127>>>>>>>>>>>//            Get psHomePath to sHomePath
91127>>>>>>>>>>>//            Get vFolderFormat sHomePath to sHomePath
91127>>>>>>>>>>>//            Move (sHomePath + sSourceFolder) to sSourceFolder
91127>>>>>>>>>>>//        End
91127>>>>>>>>>>>//        Get vFolderFormat sSourceFolder to sSourceFolder
91127>>>>>>>>>>>//        Move (sSourceFolder + "*") to sMask
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Move 0 to iItem
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        // Recursive folder search
91127>>>>>>>>>>>//        Get FileSearchRecursive of ghoFileSystem sMask DIRMODE_DIRECTORIES_ONLY False to asSearchResult
91127>>>>>>>>>>>//        Move (SizeOfArray(asSearchResult)) to iSize
91127>>>>>>>>>>>//        Decrement iSize
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        // Remove folder names from array where we should not search for source files
91127>>>>>>>>>>>//        Move "" to sPrevFolderName
91127>>>>>>>>>>>//        For iCount from 0 to iSize
91127>>>>>>>>>>>//            Get IsFolderInNoFolderList of ghoApplication asNoFolderList asSearchResult[iCount].sFilename to bFound
91127>>>>>>>>>>>//            If (bFound = False) Begin
91127>>>>>>>>>>>//                If (asSearchResult[iCount].sFilename <> sPrevFolderName) Begin
91127>>>>>>>>>>>//                    Move asSearchResult[iCount].sFilename to saSearchFolders[iItem]
91127>>>>>>>>>>>//                    Increment iItem
91127>>>>>>>>>>>//                End
91127>>>>>>>>>>>//            End
91127>>>>>>>>>>>//            Move asSearchResult[iCount].sFilename to sPrevFolderName
91127>>>>>>>>>>>//        Loop
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Move sSourceFolder to saSearchFolders[SizeOfArray(saSearchFolders)]
91127>>>>>>>>>>>//        // Sort the folder array to get the top one first.
91127>>>>>>>>>>>//        Move (SortArray(saSearchFolders)) to saSearchFolders
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//        Function_Return saSearchFolders
91127>>>>>>>>>>>//    End_Function
91127>>>>>>>>>>>//
91127>>>>>>>>>>>//End_Class
91127>>>>>>>>>>>
91127>>>>>>>>>>>Class cDDOReStyler is a cObject
91128>>>>>>>>>>>    Procedure Construct_Object
91130>>>>>>>>>>>        Forward Send Construct_Object
91132>>>>>>>>>>>  
91132>>>>>>>>>>>        Property String   psFileName  ""
91133>>>>>>>>>>>        Property String[] psSource
91134>>>>>>>>>>>        Property tDDO[]   pDDObjects
91135>>>>>>>>>>>        Property Boolean  pbCreateBackup True
91136>>>>>>>>>>>        Property Boolean  pbStrict       True   // Only replace verified DDOs, non strict not supported atm (Search code if need)
91137>>>>>>>>>>>        Property Integer  peNewStyle     eDDNewStyle
91138>>>>>>>>>>>        Property Boolean  pbCamelCaseTableName True // For new tablename Camel Case the TableName in the object
91139>>>>>>>>>>>
91139>>>>>>>>>>>        Property String psHomePath
91140>>>>>>>>>>>        Property String[] pasAllSourceFiles
91141>>>>>>>>>>>        Property Handle phoFileSystem
91142>>>>>>>>>>>
91142>>>>>>>>>>>        Object oDataFiles is a cDataFiles
91144>>>>>>>>>>>        End_Object
91145>>>>>>>>>>>
91145>>>>>>>>>>>        Object oFilesystem is a cFilesystem
91147>>>>>>>>>>>            Set phoFileSystem to Self
91148>>>>>>>>>>>        End_Object                   
91149>>>>>>>>>>>        
91149>>>>>>>>>>>    End_Procedure
91150>>>>>>>>>>>
91150>>>>>>>>>>>    Function MainDDORestyler Returns Boolean
91152>>>>>>>>>>>        Boolean bOk 
91152>>>>>>>>>>>        Integer iCount iSize 
91152>>>>>>>>>>>        String[] asAllSourceFiles 
91153>>>>>>>>>>>
91153>>>>>>>>>>>        Get pasAllSourceFiles to asAllSourceFiles
91154>>>>>>>>>>>        Move (SizeOfArray(asAllSourceFiles)) to iSize
91155>>>>>>>>>>>        Decrement iSize
91156>>>>>>>>>>>
91156>>>>>>>>>>>        For iCount from 0 to iSize
91162>>>>>>>>>>>>
91162>>>>>>>>>>>            Send RestyleDDObjects asAllSourceFiles[iCount] (peNewStyle(Self))
91163>>>>>>>>>>>        Loop
91164>>>>>>>>>>>>
91164>>>>>>>>>>>
91164>>>>>>>>>>>        Function_Return bOk
91165>>>>>>>>>>>    End_Function
91166>>>>>>>>>>>
91166>>>>>>>>>>>    Procedure ReadFile String sFileName
91168>>>>>>>>>>>        Integer iChannel iLine
91168>>>>>>>>>>>        String sLine
91168>>>>>>>>>>>        String[] sSource
91169>>>>>>>>>>>
91169>>>>>>>>>>>        Move 0 to iLine
91170>>>>>>>>>>>        Move (ResizeArray(sSource, 0)) to sSource
91171>>>>>>>>>>>        Get OpenInput sFileName to iChannel
91172>>>>>>>>>>>        If (iChannel > 0) Begin
91174>>>>>>>>>>>            Set psFileName to sFileName
91175>>>>>>>>>>>            Repeat
91175>>>>>>>>>>>>
91175>>>>>>>>>>>                Readln channel iChannel sLine
91177>>>>>>>>>>>                If (not(SeqEof)) Begin
91179>>>>>>>>>>>                    Move (RTrim(sLine)) to sSource[iLine]
91180>>>>>>>>>>>                    Increment iLine
91181>>>>>>>>>>>                End
91181>>>>>>>>>>>>
91181>>>>>>>>>>>            Until (SeqEof)
91183>>>>>>>>>>>            Send CloseInput iChannel
91184>>>>>>>>>>>        End
91184>>>>>>>>>>>>
91184>>>>>>>>>>>        Set psSource to sSource
91185>>>>>>>>>>>    End_Procedure
91186>>>>>>>>>>>
91186>>>>>>>>>>>    // ToDo: Set this to the backup for the DFRefactor logic.
91186>>>>>>>>>>>    Procedure CreateBackup
91188>>>>>>>>>>>    End_Procedure
91189>>>>>>>>>>>
91189>>>>>>>>>>>    Procedure WriteFile
91191>>>>>>>>>>>        Boolean  bBackup
91191>>>>>>>>>>>        Integer  iChannel iLine iCount
91191>>>>>>>>>>>        String   sFileName sLine
91191>>>>>>>>>>>        String[] sSource
91192>>>>>>>>>>>
91192>>>>>>>>>>>        Get pbCreateBackup to bBackup
91193>>>>>>>>>>>        If (bBackup) Begin
91195>>>>>>>>>>>            Send Createbackup
91196>>>>>>>>>>>        End
91196>>>>>>>>>>>>
91196>>>>>>>>>>>        Get psSource to sSource
91197>>>>>>>>>>>        Get psFileName to sFileName
91198>>>>>>>>>>>        If (sFileName <> "") Begin
91200>>>>>>>>>>>            Get OpenOutput sFileName to iChannel
91201>>>>>>>>>>>            If (iChannel > 0) Begin
91203>>>>>>>>>>>                Move (SizeOfArray(sSource) -1) to iCount
91204>>>>>>>>>>>                If (iCount >= 0) Begin
91206>>>>>>>>>>>                    For iLine from 0 to iCount
91212>>>>>>>>>>>>
91212>>>>>>>>>>>                        If (iLine) Begin
91214>>>>>>>>>>>                            Move sSource[iLine] to sLine
91215>>>>>>>>>>>                        End
91215>>>>>>>>>>>>
91215>>>>>>>>>>>                        Writeln channel iChannel sLine
91218>>>>>>>>>>>                    Loop
91219>>>>>>>>>>>>
91219>>>>>>>>>>>                End
91219>>>>>>>>>>>>
91219>>>>>>>>>>>                Send CloseOutput iChannel
91220>>>>>>>>>>>            End
91220>>>>>>>>>>>>
91220>>>>>>>>>>>        End
91220>>>>>>>>>>>>
91220>>>>>>>>>>>    End_Procedure
91221>>>>>>>>>>>
91221>>>>>>>>>>>    // Scans the whole file and locates the declared datadictionary objects based on that
91221>>>>>>>>>>>    // the line will start with "Object" and ends with "_DataDictionary".
91221>>>>>>>>>>>    //
91221>>>>>>>>>>>    // The search is case insensitive, commented out source will be ignored.
91221>>>>>>>>>>>    //
91221>>>>>>>>>>>    // Example line that will be detected:
91221>>>>>>>>>>>    //  Object oCustomer_DD is a Customer_DataDictionary
91221>>>>>>>>>>>    //
91221>>>>>>>>>>>    Procedure FindCurrentDDObjects
91223>>>>>>>>>>>        Integer iCount iLine iPos iSpaceChars iDDO
91223>>>>>>>>>>>        String  sLine sDDObject sNline   // normalized line, lowercase and trimmed
91223>>>>>>>>>>>        String[] sSource
91224>>>>>>>>>>>        tDDO[] DDObjects
91224>>>>>>>>>>>        tDDO[] DDObjects
91225>>>>>>>>>>>
91225>>>>>>>>>>>        Move 0 to iDDO
91226>>>>>>>>>>>        Move (ResizeArray(DDObjects, 0)) to DDObjects
91227>>>>>>>>>>>        Get psSource to sSource
91228>>>>>>>>>>>        
91228>>>>>>>>>>>        Move (SizeOfArray(sSource) -1) to iCount
91229>>>>>>>>>>>        If (iCount >= 0) Begin
91231>>>>>>>>>>>            For iLine from 0 to iCount
91237>>>>>>>>>>>>
91237>>>>>>>>>>>                Move sSource[iLine] to sLine
91238>>>>>>>>>>>                Move (Lowercase(Trim(sLine))) to sNline
91239>>>>>>>>>>>                If (Pos("object ", sNline) = 1) Begin
91241>>>>>>>>>>>                    Move (Pos("_datadictionary", sNline)) to iPos
91242>>>>>>>>>>>                    If (iPos > 0) Begin
91244>>>>>>>>>>>                        Move (Replace("object ", sNline, "")) to sNline
91245>>>>>>>>>>>                        // Space characters on the left? Count them
91245>>>>>>>>>>>                        Move (Length(sNline) - (Length(Ltrim(sNline)))) to iSpaceChars
91246>>>>>>>>>>>                        Move (Ltrim(sNline)) to sNline // Remove them
91247>>>>>>>>>>>                        Move (Pos(" ", sNline)) to iPos
91248>>>>>>>>>>>                        If (iPos <> 0) Begin
91250>>>>>>>>>>>                            Move (Mid(Ltrim(sLine), (iPos -1), (8 + iSpaceChars))) to sDDObject
91251>>>>>>>>>>>                            Move sDDObject  to DDObjects[iDDO].sDDO
91252>>>>>>>>>>>                            Move iLine      to DDObjects[iDDO].iLine
91253>>>>>>>>>>>                            Move False      to DDObjects[iDDO].bVerified
91254>>>>>>>>>>>                            Move eDDUnknown to DDObjects[iDDO].eDDOStyle
91255>>>>>>>>>>>                            Increment iDDO
91256>>>>>>>>>>>                        End
91256>>>>>>>>>>>>
91256>>>>>>>>>>>                    End
91256>>>>>>>>>>>>
91256>>>>>>>>>>>                End
91256>>>>>>>>>>>>
91256>>>>>>>>>>>            Loop
91257>>>>>>>>>>>>
91257>>>>>>>>>>>        End
91257>>>>>>>>>>>>
91257>>>>>>>>>>>        
91257>>>>>>>>>>>        Set pDDObjects to DDObjects
91258>>>>>>>>>>>    End_Procedure
91259>>>>>>>>>>>
91259>>>>>>>>>>>    // Helper function for comparing tablenames in the filelist
91259>>>>>>>>>>>    //
91259>>>>>>>>>>>    // Custom comparison function:
91259>>>>>>>>>>>    //   Returns (GT) if struct value in first parameter > struct value in second parameter.
91259>>>>>>>>>>>    //   Returns (LT) if struct value in first parameter < struct value in second parameter.
91259>>>>>>>>>>>    //   Otherwise returns (EQ).
91259>>>>>>>>>>>    Function CompareTableNames tFileList  List1 tFileList List2 Returns Integer
91261>>>>>>>>>>>        Move (Lowercase(List1.sTable)) to List1.sTable
91262>>>>>>>>>>>        Move (Lowercase(List2.sTable)) to List2.sTable
91263>>>>>>>>>>>        If (List1.sTable > List2.sTable) Begin
91265>>>>>>>>>>>            Function_Return (GT)
91266>>>>>>>>>>>        End
91266>>>>>>>>>>>>
91266>>>>>>>>>>>        Else If (List1.sTable < List2.sTable) Begin
91269>>>>>>>>>>>            Function_Return (LT)
91270>>>>>>>>>>>        End
91270>>>>>>>>>>>>
91270>>>>>>>>>>>        Function_Return (EQ)
91271>>>>>>>>>>>    End_Function
91272>>>>>>>>>>>
91272>>>>>>>>>>>    // Looks at the DD Objects found in the source and
91272>>>>>>>>>>>    // tests them against the filelist plus determines the type
91272>>>>>>>>>>>    Procedure ClassifyDDObjects
91274>>>>>>>>>>>        Boolean bHasObjectPrefix bHasDDPostfix bHasDataDictionaryPostfix
91274>>>>>>>>>>>        Integer iListSize iCount iDDO iFile
91274>>>>>>>>>>>        String sDDO sTableName sTableNameO // exception if tablename actually starts with letter O
91274>>>>>>>>>>>        tDDO[] DDObjects
91274>>>>>>>>>>>        tDDO[] DDObjects
91275>>>>>>>>>>>        tFileList SearchFile
91275>>>>>>>>>>>        tFileList SearchFile
91275>>>>>>>>>>>        tFileList[] FileList
91275>>>>>>>>>>>        tFileList[] FileList
91276>>>>>>>>>>>
91276>>>>>>>>>>>        Send EnumerateAllFiles of oDataFiles // not entirely optimal to run this in each source file but meh
91277>>>>>>>>>>>        Get pFileList of oDataFiles    to FileList
91278>>>>>>>>>>>        Move (SizeOfArray(FileList)-1) to iListSize
91279>>>>>>>>>>>        Get pDDObjects to DDObjects
91280>>>>>>>>>>>        Move (SizeOfArray(DDObjects)-1) to iCount
91281>>>>>>>>>>>        
91281>>>>>>>>>>>        If (iListSize >= 0 and iCount >= 0) Begin
91283>>>>>>>>>>>            For iDDO from 0 to iCount
91289>>>>>>>>>>>>
91289>>>>>>>>>>>                Move False to bHasObjectPrefix
91290>>>>>>>>>>>                Move False to bHasDDPostfix
91291>>>>>>>>>>>                Move False to bHasDataDictionaryPostfix
91292>>>>>>>>>>>                Move ""    to sTableNameO
91293>>>>>>>>>>>                Move DDObjects[iDDO].sDDO to sDDO
91294>>>>>>>>>>>                Move (Trim(sDDO)) to sTableName
91295>>>>>>>>>>>                If (sTableName<>"") Begin
91297>>>>>>>>>>>                    If (Lowercase(Left(sTableName, 1)) = "o") Begin
91299>>>>>>>>>>>                        Move True to bHasObjectPrefix
91300>>>>>>>>>>>                        Move (Replace(Mid(sTableName, 1, 1), sTableName, "")) to sTableName
91301>>>>>>>>>>>                        Move (Trim(sDDO)) to sTableNameO // What if tablename actually starts with a letter "o" ?
91302>>>>>>>>>>>                    End
91302>>>>>>>>>>>>
91302>>>>>>>>>>>                    If (Lowercase(Right(sTableName, 3)) = "_dd") Begin
91304>>>>>>>>>>>                        Move True to bHasDDPostFix
91305>>>>>>>>>>>                        Move (Left(sTableName,Length(sTableName) -3)) to sTableName
91306>>>>>>>>>>>                        If (sTableNameO <> "") Begin
91308>>>>>>>>>>>                            Move (Left(sTableNameO,Length(sTableNameO) -3)) to sTableNameO
91309>>>>>>>>>>>                        End
91309>>>>>>>>>>>>
91309>>>>>>>>>>>                    End
91309>>>>>>>>>>>>
91309>>>>>>>>>>>                    Else If (Lowercase(Right(sTableName, 15)) = "_datadictionary") Begin
91312>>>>>>>>>>>                        Move True to bHasDataDictionaryPostFix
91313>>>>>>>>>>>                        Move (Left(sTableName, Length(sTableName) -15)) to sTableName
91314>>>>>>>>>>>                        If (sTableNameO <> "") Begin
91316>>>>>>>>>>>                            Move (Left(sTableNameO,Length(sTableNameO) -15)) to sTableNameO
91317>>>>>>>>>>>                        End
91317>>>>>>>>>>>>
91317>>>>>>>>>>>                    End
91317>>>>>>>>>>>>
91317>>>>>>>>>>>                    Move sTableName to SearchFile.sTable
91318>>>>>>>>>>>                    Move (SearchArray(SearchFile,FileList, Self, (RefFunc(CompareTableNames)) )) to iFile
91319>>>>>>>>>>>                    If (iFile >- 1) Begin
91321>>>>>>>>>>>                        Move True to DDObjects[iDDO].bVerified
91322>>>>>>>>>>>                        Move FileList[iFile].iFileNum to DDObjects[iDDO].iFileNum
91323>>>>>>>>>>>                        Move FileList[iFile].sTable   to DDObjects[iDDO].sTableName
91324>>>>>>>>>>>                    End
91324>>>>>>>>>>>>
91324>>>>>>>>>>>                    Else If (sTableNameO <> "") Begin
91327>>>>>>>>>>>                        Move sTableNameO to SearchFile.sTable
91328>>>>>>>>>>>                        Move (SearchArray(SearchFile,FileList, Self, (RefFunc(CompareTableNames)) )) to iFile
91329>>>>>>>>>>>                        If (iFile >- 1) Begin
91331>>>>>>>>>>>                            Move False to bHasObjectPrefix
91332>>>>>>>>>>>                            Move True  to DDObjects[iDDO].bVerified
91333>>>>>>>>>>>                            Move FileList[iFile].iFileNum to DDObjects[iDDO].iFileNum
91334>>>>>>>>>>>                            Move FileList[iFile].sTable   to DDObjects[iDDO].sTableName
91335>>>>>>>>>>>                        End
91335>>>>>>>>>>>>
91335>>>>>>>>>>>                    End
91335>>>>>>>>>>>>
91335>>>>>>>>>>>                    If (bHasObjectPrefix = False and bHasDDPostfix) Begin
91337>>>>>>>>>>>                        Move eDDOldStyle to DDObjects[iDDO].eDDOStyle
91338>>>>>>>>>>>                    End
91338>>>>>>>>>>>>
91338>>>>>>>>>>>                    Else If (bHasObjectPrefix) Begin
91341>>>>>>>>>>>                        If (bHasDDPostfix) Begin
91343>>>>>>>>>>>                            Move eDDStudioStyle to DDObjects[iDDO].eDDOStyle
91344>>>>>>>>>>>                        End
91344>>>>>>>>>>>>
91344>>>>>>>>>>>                    End
91344>>>>>>>>>>>>
91344>>>>>>>>>>>                End
91344>>>>>>>>>>>>
91344>>>>>>>>>>>            Loop
91345>>>>>>>>>>>>
91345>>>>>>>>>>>            Set pDDObjects to DDObjects
91346>>>>>>>>>>>        End
91346>>>>>>>>>>>>
91346>>>>>>>>>>>    End_Procedure
91347>>>>>>>>>>>
91347>>>>>>>>>>>    Function NewStyleName String sTableName Integer eNewStyle Returns String
91349>>>>>>>>>>>        String  sDDStyle
91349>>>>>>>>>>>        Boolean bCamelCase
91349>>>>>>>>>>>
91349>>>>>>>>>>>        Get pbCamelCaseTableName to bCamelCase
91350>>>>>>>>>>>        If (bCamelCase) Begin
91352>>>>>>>>>>>            // Camel Case makes the whole tablename lowercase except for the first Letter
91352>>>>>>>>>>>            Move (lowercase(sTableName)) to sTableName
91353>>>>>>>>>>>            Move (Overstrike(Uppercase(Left(sTableName,1)),sTableName,1)) to sTableName
91354>>>>>>>>>>>        End
91354>>>>>>>>>>>>
91354>>>>>>>>>>>
91354>>>>>>>>>>>        Case Begin
91354>>>>>>>>>>>            Case (eNewStyle = eDDOldStyle)
91356>>>>>>>>>>>                Move (sTableName + "_DD") to sDDStyle
91357>>>>>>>>>>>                Case Break
91358>>>>>>>>>>>            Case (eNewStyle = eDDStudioStyle)
91361>>>>>>>>>>>                Move ("o" + sTableName + "_DD") to sDDStyle
91362>>>>>>>>>>>                Case Break
91363>>>>>>>>>>>            Case (eNewStyle = eDDNewStyle)
91366>>>>>>>>>>>                Move ("o" + sTableName + "_DD") to sDDStyle
91367>>>>>>>>>>>                Case Break
91368>>>>>>>>>>>            Case Else
91368>>>>>>>>>>>                Showln ("Unexpected error new style" * Trim(eNewStyle) * "is undefined.")
91370>>>>>>>>>>>        Case End
91370>>>>>>>>>>>        Function_Return sDDStyle
91371>>>>>>>>>>>    End_Function
91372>>>>>>>>>>>
91372>>>>>>>>>>>    Procedure ApplyNewStyleForTable tDDO DDObject
91374>>>>>>>>>>>        Boolean bUpdated
91374>>>>>>>>>>>        Integer eNewStyle eOldStyle iCount iLine iPos iLen
91374>>>>>>>>>>>        String sLine sNline sNOldDDName sNewDDName
91374>>>>>>>>>>>        String[] sSource
91375>>>>>>>>>>>
91375>>>>>>>>>>>        Get peNewStyle to eNewStyle
91376>>>>>>>>>>>        Move DDObject.eDDOStyle to eOldStyle
91377>>>>>>>>>>>        If (eNewStyle <> eOldStyle) Begin
91379>>>>>>>>>>>            Get psSource to sSource
91380>>>>>>>>>>>            Move (Lowercase(DDObject.sDDO)) to sNOldDDName
91381>>>>>>>>>>>            Move (Length(sNOldDDName))      to iLen
91382>>>>>>>>>>>            Get NewStyleName DDObject.sTableName eNewStyle to sNewDDName
91383>>>>>>>>>>>            Move (SizeOfArray(sSource) -1)  to iCount
91384>>>>>>>>>>>            
91384>>>>>>>>>>>            If (iCount >= 0) Begin
91386>>>>>>>>>>>                For iLine from 0 to iCount
91392>>>>>>>>>>>>
91392>>>>>>>>>>>                    Move False to bUpdated
91393>>>>>>>>>>>                    Move sSource[iLine] to sLine
91394>>>>>>>>>>>                    
91394>>>>>>>>>>>                    // End of line happens, see Set DDO_Server To <table>_DD
91394>>>>>>>>>>>                    Move (sLine + " ") to sLine
91395>>>>>>>>>>>                    Move (Lowercase(sLine)) to sNline
91396>>>>>>>>>>>                    // Valid separate characters are: " ",",","(",")", EOL
91396>>>>>>>>>>>                    // The DDO objects are _never_ at the start of the line
91396>>>>>>>>>>>                    Move (Replaces(",", sNline, " ")) to sNline
91397>>>>>>>>>>>                    Move (Replaces("(", sNline, " ")) to sNline
91398>>>>>>>>>>>                    Move (Replaces(")", sNline, " ")) to sNline
91399>>>>>>>>>>>
91399>>>>>>>>>>>                    // Only one type of replacement left, easy testing :)
91399>>>>>>>>>>>                    Move (Pos(" " + sNOldDDName + " ", sNline)) to iPos
91400>>>>>>>>>>>                    While (iPos <> 0)
91404>>>>>>>>>>>                        Move True to bUpdated
91405>>>>>>>>>>>                        Move (Replace(" " + sNOldDDName + " ", sNline, " " + sNewDDName + " ")) to sNline
91406>>>>>>>>>>>                        // Don't know correct case in the actual line, use remove+insert
91406>>>>>>>>>>>                        // Can't use replace on the real line as it will end up replacing replaced
91406>>>>>>>>>>>                        Move (Remove(sLine, (iPos +1), iLen)) to sLine
91407>>>>>>>>>>>                        Move (Insert(sNewDDName, sLine, (iPos +1))) to sLine
91408>>>>>>>>>>>
91408>>>>>>>>>>>                        Move (Pos(" " + sNOldDDName + " ", sNline)) to iPos
91409>>>>>>>>>>>                    Loop
91410>>>>>>>>>>>>
91410>>>>>>>>>>>                    If (bUpdated) Begin
91412>>>>>>>>>>>                        Move (RTrim(sLine)) to sSource[iLine]
91413>>>>>>>>>>>                    End
91413>>>>>>>>>>>>
91413>>>>>>>>>>>                Loop
91414>>>>>>>>>>>>
91414>>>>>>>>>>>                Set psSource to sSource
91415>>>>>>>>>>>            End
91415>>>>>>>>>>>>
91415>>>>>>>>>>>        End
91415>>>>>>>>>>>>
91415>>>>>>>>>>>    End_Procedure
91416>>>>>>>>>>>
91416>>>>>>>>>>>    Procedure ApplyNewStyle
91418>>>>>>>>>>>        Boolean bStrict bReplace
91418>>>>>>>>>>>        Integer iFile iCount eStyle
91418>>>>>>>>>>>        String  sFileName
91418>>>>>>>>>>>        tDDO[]  DDObjects
91418>>>>>>>>>>>        tDDO[]  DDObjects
91419>>>>>>>>>>>
91419>>>>>>>>>>>        Get peNewStyle to eStyle
91420>>>>>>>>>>>
91420>>>>>>>>>>>        If (eStyle <> eDDUnknown) Begin
91422>>>>>>>>>>>            Get pbStrict to bStrict   // Default is to only rename DDO's that exist in filelist
91423>>>>>>>>>>>            Get ParseFileName (psFileName(Self)) to sFileName
91424>>>>>>>>>>>            Get pDDObjects to DDObjects
91425>>>>>>>>>>>            Move (SizeOfArray(DDObjects) - 1) to iCount
91426>>>>>>>>>>>            
91426>>>>>>>>>>>            If (iCount >= 0) Begin
91428>>>>>>>>>>>                For iFile from 0 to iCount
91434>>>>>>>>>>>>
91434>>>>>>>>>>>                    Move False to bReplace
91435>>>>>>>>>>>                    If (bStrict) Begin
91437>>>>>>>>>>>                        If (DDObjects[iFile].bVerified=True) Begin
91439>>>>>>>>>>>                            Move True to bReplace
91440>>>>>>>>>>>                        End
91440>>>>>>>>>>>>
91440>>>>>>>>>>>                        Else Begin
91441>>>>>>>>>>>                            Showln ("DDO" * DDObjects[iFile].sDDO * "was not found in the filelist. File" * sFileName)
91443>>>>>>>>>>>                        End
91443>>>>>>>>>>>>
91443>>>>>>>>>>>                    End
91443>>>>>>>>>>>>
91443>>>>>>>>>>>                    Else Begin
91444>>>>>>>>>>>                        // if you want to do non strict, you need to fill in ddobject.sTableName still!
91444>>>>>>>>>>>                        Move True to bReplace
91445>>>>>>>>>>>                    End
91445>>>>>>>>>>>>
91445>>>>>>>>>>>                    If (DDObjects[iFile].eDDOStyle = eDDUnknown) Begin
91447>>>>>>>>>>>                        Move False to bReplace
91448>>>>>>>>>>>                        Showln ("DDO" * DDObjects[iFile].sDDO * "style is not recognized. File" * sFileName)
91450>>>>>>>>>>>                    End
91450>>>>>>>>>>>>
91450>>>>>>>>>>>                    If (DDObjects[iFile].eDDOStyle = eStyle) Begin
91452>>>>>>>>>>>                        Move False to bReplace
91453>>>>>>>>>>>                        Showln ("DDO" * DDObjects[iFile].sDDO * "style already correct. File" * sFileName)
91455>>>>>>>>>>>                    End
91455>>>>>>>>>>>>
91455>>>>>>>>>>>                    If (bReplace) Begin
91457>>>>>>>>>>>                        Send ApplyNewStyleForTable DDObjects[iFile]
91458>>>>>>>>>>>                    End
91458>>>>>>>>>>>>
91458>>>>>>>>>>>                Loop
91459>>>>>>>>>>>>
91459>>>>>>>>>>>            End
91459>>>>>>>>>>>>
91459>>>>>>>>>>>        End 
91459>>>>>>>>>>>>
91459>>>>>>>>>>>    End_Procedure
91460>>>>>>>>>>>
91460>>>>>>>>>>>    Function OpenOutput String sFileName Returns Integer
91462>>>>>>>>>>>        Integer iChannel
91462>>>>>>>>>>>
91462>>>>>>>>>>>        Get Seq_New_Channel to iChannel
91463>>>>>>>>>>>        If (iChannel <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
91465>>>>>>>>>>>            Direct_Output channel iChannel sFileName
91467>>>>>>>>>>>        End
91467>>>>>>>>>>>>
91467>>>>>>>>>>>        Function_Return iChannel
91468>>>>>>>>>>>    End_Function
91469>>>>>>>>>>>
91469>>>>>>>>>>>    Procedure CloseOutput Integer iChannel
91471>>>>>>>>>>>        Close_Output channel iChannel
91473>>>>>>>>>>>        Send Seq_Release_Channel iChannel
91474>>>>>>>>>>>    End_Procedure
91475>>>>>>>>>>>
91475>>>>>>>>>>>    Function OpenInput String sFileName Returns Integer
91477>>>>>>>>>>>        Integer iChannel
91477>>>>>>>>>>>
91477>>>>>>>>>>>        Get Seq_New_Channel to iChannel
91478>>>>>>>>>>>        If (iChannel<>DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
91480>>>>>>>>>>>            Direct_Input channel iChannel ("binary:"+sFileName)
91482>>>>>>>>>>>        End
91482>>>>>>>>>>>>
91482>>>>>>>>>>>        Function_Return iChannel
91483>>>>>>>>>>>    End_Function
91484>>>>>>>>>>>
91484>>>>>>>>>>>    Procedure CloseInput Integer iChannel
91486>>>>>>>>>>>        Close_Input channel iChannel
91488>>>>>>>>>>>        Send Seq_Release_Channel iChannel
91489>>>>>>>>>>>    End_Procedure
91490>>>>>>>>>>>
91490>>>>>>>>>>>    // Code that handles the restyle on the DD Object in the source filename supplied
91490>>>>>>>>>>>    // and changes it to the new style eDDStyle
91490>>>>>>>>>>>    Procedure RestyleDDObjects String sFileName Integer eDDStyle
91492>>>>>>>>>>>        Send ReadFile sFilename
91493>>>>>>>>>>>        Send FindCurrentDDObjects
91494>>>>>>>>>>>        Send ClassifyDDObjects
91495>>>>>>>>>>>        Set peNewStyle to eDDStyle
91496>>>>>>>>>>>        Send ApplyNewStyle
91497>>>>>>>>>>>        Send WriteFile
91498>>>>>>>>>>>    End_Procedure
91499>>>>>>>>>>>
91499>>>>>>>>>>>End_Class
91500>>>>>>>>>// ToDo: Test with this package:
91500>>>>>>>>>//Use stringtokenizer.pkg
91500>>>>>>>>>
91500>>>>>>>>>Register_Function phoEditor Returns Handle 
91500>>>>>>>>>Register_Function phoRemoveUnusedLocals Returns Handle
91500>>>>>>>>>Register_Function phoReportUnusedSourceFiles Returns Handle
91500>>>>>>>>>
91500>>>>>>>>>
91500>>>>>>>>>Global_Variable Handle ghoStatusLog
91500>>>>>>>>>
91500>>>>>>>>>Use cSysFileDataDictionary.dd  
91500>>>>>>>>>Open FunctionsA
Including file: FunctionsA.fd    (C:\Projects\DF18\DfRefactor\DDSrc\FunctionsA.fd)
91502>>>>>>>>>
91502>>>>>>>>>Class cRefactorFunctionLibrary is a cObject
91503>>>>>>>>>    
91503>>>>>>>>>    Procedure Construct_Object
91505>>>>>>>>>        String[] asLocalVariableTypes asLocalVariableArrayTypes
91507>>>>>>>>>
91507>>>>>>>>>        Forward Send Construct_Object
91509>>>>>>>>>        Move Self to ghoRefactorFunctionLibrary
91510>>>>>>>>>
91510>>>>>>>>>        Property Handle phoEditor
91511>>>>>>>>>        Property Integer peNewStyle eDDUnknown
91512>>>>>>>>>
91512>>>>>>>>>        Property tRefactorSettings pRefactorSettings
91513>>>>>>>>>        //
91513>>>>>>>>>        Property Boolean pbToggleState True     
91514>>>>>>>>>        Property Boolean pbInRepeatLoop False
91515>>>>>>>>>        
91515>>>>>>>>>        Property String[] paCommands
91516>>>>>>>>>        Property String[] paCommandFunctions    
91517>>>>>>>>>        Property String[] pasLocalVariableTypes
91518>>>>>>>>>        Property String[] pasLocalVariableArrayTypes
91519>>>>>>>>>
91519>>>>>>>>>        Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
91520>>>>>>>>>        Set pasLocalVariableTypes to asLocalVariableTypes
91521>>>>>>>>>        Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
91522>>>>>>>>>        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes
91523>>>>>>>>>
91523>>>>>>>>>        // Properties for the RemovePRoejctObjectStructure function:
91523>>>>>>>>>        Property Boolean pbProjectObjectStructureStart False 
91524>>>>>>>>>        Property Boolean pbProjectObjectStructureEnd False
91525>>>>>>>>>        Property Boolean pbRegisterAllObjectsStart False    
91526>>>>>>>>>        Property Boolean pbRegisterAllObjectsEnd False
91527>>>>>>>>>        Property String[] pasObjectNames
91528>>>>>>>>>
91528>>>>>>>>>    End_Procedure
91529>>>>>>>>>
91529>>>>>>>>>    Procedure End_Construct_Object
91531>>>>>>>>>        Forward Send End_Construct_Object
91533>>>>>>>>>        Send AddAllCommands  
91534>>>>>>>>>        Send AddAllCommandFunctions
91535>>>>>>>>>    End_Procedure
91536>>>>>>>>>    
91536>>>>>>>>>    // *** External function package(s) must to be included here. ***
91536>>>>>>>>>    // Asolvi function package.  
91536>>>>>>>>>//    Define CS_Use_Asolvi for "UseAsolvi"
91536>>>>>>>>>
91536>>>>>>>>>    // ToDo: *** LINE-BY-LINE FUNCTIONS ***
91536>>>>>>>>>    
91536>>>>>>>>>    // Only does a replace of "Current_Object" to "Self"
91536>>>>>>>>>    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
91538>>>>>>>>>        String sText sStart sStop
91538>>>>>>>>>        Boolean bFound
91538>>>>>>>>>        Integer iPos
91538>>>>>>>>>        
91538>>>>>>>>>        Move sLine to sText
91539>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
91540>>>>>>>>>        If (bFound = True) Begin
91542>>>>>>>>>            Function_Return False
91543>>>>>>>>>        End
91543>>>>>>>>>>
91543>>>>>>>>>        Move (Lowercase(sText)) to sText
91544>>>>>>>>>        Move (Pos(lowercase(CS_Current_Object), sText)) to iPos
91545>>>>>>>>>        If (iPos = 0) Begin
91547>>>>>>>>>            Function_Return False
91548>>>>>>>>>        End                      
91548>>>>>>>>>>
91548>>>>>>>>>        Move (Left(sLine, (iPos -1))) to sStart
91549>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + Length(CS_Current_Object)))) to sStop
91550>>>>>>>>>        Move (sStart + CS_Self + String(sStop)) to sLine 
91551>>>>>>>>>        
91551>>>>>>>>>        // Note! Recursively calls the same function if there are more than one "current_object" in the code line.
91551>>>>>>>>>        Move (Lowercase(sLine)) to sText
91552>>>>>>>>>        Move (Pos(lowercase(CS_Current_Object), sText)) to iPos
91553>>>>>>>>>        If (iPos <> 0) Begin                             
91555>>>>>>>>>            Move sLine to sText
91556>>>>>>>>>            Get ChangeCurrent_ObjectToSelf sLine to sText
91557>>>>>>>>>        End                      
91557>>>>>>>>>>
91557>>>>>>>>>        
91557>>>>>>>>>        Function_Return True    
91558>>>>>>>>>    End_Function
91559>>>>>>>>>    
91559>>>>>>>>>    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
91559>>>>>>>>>    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
91561>>>>>>>>>        String sText sIndicator sCommand sEndString
91561>>>>>>>>>        Boolean bFound
91561>>>>>>>>>        Integer iPos 
91561>>>>>>>>>        
91561>>>>>>>>>        Move sLine to sText
91562>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
91563>>>>>>>>>        If (bFound = True) Begin
91565>>>>>>>>>            Function_Return False
91566>>>>>>>>>        End
91566>>>>>>>>>>
91566>>>>>>>>>        
91566>>>>>>>>>        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
91566>>>>>>>>>        Get IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) sText to bFound
91567>>>>>>>>>        If (bFound = False) Begin
91569>>>>>>>>>            Function_Return False
91570>>>>>>>>>        End
91570>>>>>>>>>>
91570>>>>>>>>>        
91570>>>>>>>>>        Move (Lowercase(sText)) to sText
91571>>>>>>>>>        While (bFound = True)
91575>>>>>>>>>            Move (Pos(Lowercase(CS_DfTrue), sText)) to iPos
91576>>>>>>>>>            If (iPos > 0) Begin
91578>>>>>>>>>                Move (Overstrike("||", sText, iPos)) to sText
91579>>>>>>>>>                Move (Overstrike("||", sLine, iPos)) to sLine
91580>>>>>>>>>            End
91580>>>>>>>>>>
91580>>>>>>>>>            Move (iPos > 0) to bFound
91581>>>>>>>>>            Move (Pos(Lowercase(CS_DfFalse), sText)) to iPos
91582>>>>>>>>>            If (iPos > 0) Begin
91584>>>>>>>>>                Move (Overstrike("||", sText, iPos)) to sText
91585>>>>>>>>>                Move (Overstrike("||", sLine, iPos)) to sLine
91586>>>>>>>>>            End
91586>>>>>>>>>>
91586>>>>>>>>>            If (bFound = False) Begin
91588>>>>>>>>>                Move (iPos > 0) to bFound
91589>>>>>>>>>            End
91589>>>>>>>>>>
91589>>>>>>>>>        Loop              
91590>>>>>>>>>>
91590>>>>>>>>>
91590>>>>>>>>>        Move (Replaces("||", sLine, "")) to sLine
91591>>>>>>>>>        Function_Return True
91592>>>>>>>>>    End_Function  
91593>>>>>>>>>    
91593>>>>>>>>>    // Changes; [Found] Loop --> Loop
91593>>>>>>>>>    Function ChangeFoundLoopIndicator String ByRef sLine String sParameter Returns Boolean
91595>>>>>>>>>        tCodeComponents LineComponents 
91595>>>>>>>>>        tCodeComponents LineComponents 
91595>>>>>>>>>        tBooleanIndicator BooleanIndicator
91595>>>>>>>>>        tBooleanIndicator BooleanIndicator
91595>>>>>>>>>        String sText                  
91595>>>>>>>>>        Boolean bIsLoopStatement bIsRepeatStatement bFound
91595>>>>>>>>>        Integer iFoundIndicator iPosLoop
91595>>>>>>>>>        
91595>>>>>>>>>        Get IsCommentLineOrBlank sLine to bFound
91596>>>>>>>>>        If (bFound = True) Begin
91598>>>>>>>>>            Function_Return False
91599>>>>>>>>>        End
91599>>>>>>>>>>
91599>>>>>>>>>
91599>>>>>>>>>        Get IsLoopStatement sLine to bIsLoopStatement  
91600>>>>>>>>>        If (bIsLoopStatement = False) Begin
91602>>>>>>>>>            Function_Return False
91603>>>>>>>>>        End
91603>>>>>>>>>>
91603>>>>>>>>>        
91603>>>>>>>>>        Get IsRepeatStatement sLine to bIsRepeatStatement
91604>>>>>>>>>        Get Tokenizer sLine to LineComponents
91605>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
91606>>>>>>>>>        If (bIsRepeatStatement = True) Begin
91608>>>>>>>>>            // We save the start of a Repeat/Loop in a class property, which gets set to False when a Loop statement is found.
91608>>>>>>>>>            If (BooleanIndicator.bHasBracket = False) Begin
91610>>>>>>>>>                Set pbInRepeatLoop to True
91611>>>>>>>>>                Function_Return False
91612>>>>>>>>>            End    
91612>>>>>>>>>>
91612>>>>>>>>>        End
91612>>>>>>>>>>
91612>>>>>>>>>        
91612>>>>>>>>>        // If no indicator e.g. "[Found]" before the Loop command, we're done.
91612>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
91614>>>>>>>>>            Set pbInRepeatLoop to False
91615>>>>>>>>>            Function_Return False
91616>>>>>>>>>        End        
91616>>>>>>>>>>
91616>>>>>>>>>        
91616>>>>>>>>>        If (pbInRepeatLoop(Self) = True) Begin
91618>>>>>>>>>            Move CS_Until to BooleanIndicator.sCode
91619>>>>>>>>>            Move (String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression)) to LineComponents.sCode
91620>>>>>>>>>        End 
91620>>>>>>>>>>
91620>>>>>>>>>        Else Begin
91621>>>>>>>>>            Move CS_Loop to LineComponents.sCode
91622>>>>>>>>>        End
91622>>>>>>>>>>
91622>>>>>>>>>        Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * String(LineComponents.sToStatement) + String(LineComponents.sRightComment))) to sLine
91623>>>>>>>>>        Set pbInRepeatLoop to False
91624>>>>>>>>>        
91624>>>>>>>>>        Function_Return True
91625>>>>>>>>>    End_Function
91626>>>>>>>>>
91626>>>>>>>>>    // Changes [Found] Reread (and other commnds _except Loop, While, [Select], and If & Begin
91626>>>>>>>>>    //     to: If (Found) command
91626>>>>>>>>>    Function ChangeFoundAndFindErrIndicators String ByRef sLine String sParameter Returns Boolean
91628>>>>>>>>>        String sText sIndicator sCommand sEndString
91628>>>>>>>>>        Boolean bChanged bFound
91628>>>>>>>>>        Integer iPos 
91628>>>>>>>>>        tCodeComponents LineComponents 
91628>>>>>>>>>        tCodeComponents LineComponents 
91628>>>>>>>>>        tBooleanIndicator BooleanIndicator
91628>>>>>>>>>        tBooleanIndicator BooleanIndicator
91628>>>>>>>>>        
91628>>>>>>>>>        Move sLine to sText
91629>>>>>>>>>        Get IsFoundOrFindErrIndicator sText to bFound
91630>>>>>>>>>        If (bFound = False) Begin
91632>>>>>>>>>            Function_Return False
91633>>>>>>>>>        End
91633>>>>>>>>>>
91633>>>>>>>>>        
91633>>>>>>>>>        Get Tokenizer sLine to LineComponents
91634>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
91635>>>>>>>>>        Move (Lowercase(BooleanIndicator.sExpression) contains Lowercase(CS_Found)) to bFound
91636>>>>>>>>>        // [Finderr]
91636>>>>>>>>>        If (bFound = False) Begin
91638>>>>>>>>>            Move ("(" + String(CS_Found) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression
91639>>>>>>>>>        End
91639>>>>>>>>>>
91639>>>>>>>>>        
91639>>>>>>>>>        Move (Pos(" ", LineComponents.sCode)) to iPos
91640>>>>>>>>>        Move (Mid(LineComponents.sCode, Length(LineComponents.sCode), (iPos + 1))) to LineComponents.sCode
91641>>>>>>>>>        // Must check that it isn't a "Repeat" or "While" or "Loop" command 
91641>>>>>>>>>   
91641>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Repeat)) to bFound
91642>>>>>>>>>        If (bFound = True) Begin
91644>>>>>>>>>            Function_Return False
91645>>>>>>>>>        End
91645>>>>>>>>>>
91645>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Loop)) to bFound
91646>>>>>>>>>        If (bFound = True) Begin
91648>>>>>>>>>            Function_Return False
91649>>>>>>>>>        End
91649>>>>>>>>>>
91649>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_While)) to bFound
91650>>>>>>>>>        If (bFound = True) Begin
91652>>>>>>>>>            Function_Return False
91653>>>>>>>>>        End
91653>>>>>>>>>>
91653>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Select)) to bFound
91654>>>>>>>>>        If (bFound = True) Begin
91656>>>>>>>>>            Function_Return False
91657>>>>>>>>>        End
91657>>>>>>>>>>
91657>>>>>>>>>        
91657>>>>>>>>>        Move "" to sEndString
91658>>>>>>>>>        If (LineComponents.sOfStatement <> "") Begin
91660>>>>>>>>>            Move (" " + String(LineComponents.sOfStatement)) to sEndString
91661>>>>>>>>>        End
91661>>>>>>>>>>
91661>>>>>>>>>        If (LineComponents.sToStatement <> "") Begin
91663>>>>>>>>>            Move (sEndString * String(LineComponents.sToStatement)) to sEndString
91664>>>>>>>>>        End
91664>>>>>>>>>>
91664>>>>>>>>>        If (LineComponents.sRightComment <> "") Begin
91666>>>>>>>>>            Move (sEndString * LineComponents.sRightComment) to sEndString
91667>>>>>>>>>        End 
91667>>>>>>>>>>
91667>>>>>>>>>        
91667>>>>>>>>>        Move (String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to LineComponents.sCode
91668>>>>>>>>>        Move (LineComponents.sIndentation + String(CS_If) * String(LineComponents.sCode) * String(sEndString)) to sLine
91669>>>>>>>>>        Function_Return True
91670>>>>>>>>>    End_Function 
91671>>>>>>>>>    
91671>>>>>>>>>    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
91671>>>>>>>>>    // For the function to do anything, the line needs to contain a "GetAddress" command.
91671>>>>>>>>>    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
91673>>>>>>>>>        Boolean bFound
91673>>>>>>>>>        String sText sToVar sOfVar sCommand
91673>>>>>>>>>        Integer iPos  
91673>>>>>>>>>        tCodeComponents CodeComponents
91673>>>>>>>>>        tCodeComponents CodeComponents
91673>>>>>>>>>
91673>>>>>>>>>        Move sLine to sText
91674>>>>>>>>>
91674>>>>>>>>>        // Skip line if it is a comment or blank
91674>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
91675>>>>>>>>>        If (bFound = True) Begin
91677>>>>>>>>>            Function_Return False
91678>>>>>>>>>        End
91678>>>>>>>>>>
91678>>>>>>>>>        // Skip line if it contains a semi colon
91678>>>>>>>>>        Get IsLineEndSemiColon sText to bFound    
91679>>>>>>>>>        If (bFound = True) Begin
91681>>>>>>>>>            Function_Return False
91682>>>>>>>>>        End
91682>>>>>>>>>>
91682>>>>>>>>>        Get _RetrieveFirstWord sText to sCommand
91683>>>>>>>>>        If (Lowercase(sCommand) = Lowercase(CS_Function)) Begin
91685>>>>>>>>>            Function_Return False
91686>>>>>>>>>        End
91686>>>>>>>>>>
91686>>>>>>>>>        
91686>>>>>>>>>        Get Tokenizer sLine to CodeComponents
91687>>>>>>>>>        Get IsKeywordInLine (CS_GetAddress + "|") CodeComponents.sCode to bFound
91688>>>>>>>>>        If (bFound = False) Begin
91690>>>>>>>>>            Function_Return False
91691>>>>>>>>>        End
91691>>>>>>>>>>
91691>>>>>>>>>        
91691>>>>>>>>>        If (CodeComponents.sRightComment <> "") Begin
91693>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + CodeComponents.sOfStatement + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
91694>>>>>>>>>        End 
91694>>>>>>>>>>
91694>>>>>>>>>        Else Begin
91695>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + CodeComponents.sOfStatement + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
91696>>>>>>>>>        End
91696>>>>>>>>>>
91696>>>>>>>>>        
91696>>>>>>>>>        Function_Return True
91697>>>>>>>>>    End_Function
91698>>>>>>>>>
91698>>>>>>>>>    // Changes e.g. "Indicate indicator as True" --> "Move (True) to indicator"
91698>>>>>>>>>    //              "[Select] Indicate Select as Windowindex Eq Fieldindex"
91698>>>>>>>>>    Function ChangeIndicateFoundToMoveTrueToFound String ByRef sLine String sParameter Returns Boolean
91700>>>>>>>>>        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis
91700>>>>>>>>>        String sText sVariable sExpression sIndicate sChar
91700>>>>>>>>>        Integer iPos                      
91700>>>>>>>>>        tCodeComponents CodeComponents
91700>>>>>>>>>        tCodeComponents CodeComponents
91700>>>>>>>>>        
91700>>>>>>>>>        Move False to bChanged
91701>>>>>>>>>        Move (Lowercase(sLine)) to sText
91702>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentLineOrBlank
91703>>>>>>>>>        If (bIsCommentLineOrBlank = True) Begin
91705>>>>>>>>>            Function_Return False
91706>>>>>>>>>        End
91706>>>>>>>>>>
91706>>>>>>>>>        
91706>>>>>>>>>        Move (Ltrim(Lowercase(sText))) to sText
91707>>>>>>>>>        Move (Pos(Lowercase(CS_Indicate + " "), sText)) to iPos
91708>>>>>>>>>        If (iPos <> 1) Begin
91710>>>>>>>>>            Function_Return False
91711>>>>>>>>>        End
91711>>>>>>>>>>
91711>>>>>>>>>        Get Tokenizer sLine to CodeComponents
91712>>>>>>>>>        Move (Pos(" ", CodeComponents.sCode)) to iPos
91713>>>>>>>>>        Move (Left(CodeComponents.sCode, (iPos -1))) to sIndicate
91714>>>>>>>>>        If ((Lowercase(sIndicate) + " ") <> (Lowercase(CS_Indicate) + " ")) Begin
91716>>>>>>>>>            Function_Return False
91717>>>>>>>>>        End                      
91717>>>>>>>>>>
91717>>>>>>>>>        
91717>>>>>>>>>        Move (Pos(" ", CodeComponents.sCode)) to iPos // Indicate (a < b) as False
91718>>>>>>>>>        Move (Left(CodeComponents.sCode, (iPos -1))) to sText //   (a < b) as False
91719>>>>>>>>>        Move (Replace(sText, CodeComponents.sCode, "")) to CodeComponents.sCode
91720>>>>>>>>>        Move (Trim(CodeComponents.sCode)) to CodeComponents.sCode
91721>>>>>>>>>        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(CodeComponents.sCode))) to iPos 
91722>>>>>>>>>        Move (Left(CodeComponents.sCode, (iPos -1))) to sExpression // (a < b)
91723>>>>>>>>>        Move (Replace(sExpression, CodeComponents.sCode, "")) to CodeComponents.sCode //  as False
91724>>>>>>>>>        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(CodeComponents.sCode))) to iPos         
91725>>>>>>>>>        Move (Mid(CodeComponents.sCode, Length(CodeComponents.sCode), (iPos + Length(CS_As) + 2))) to sVariable
91726>>>>>>>>>        Move (Left(sVariable, 1)) to sChar
91727>>>>>>>>>        Move (sChar = "(") to bIsParanthesis
91728>>>>>>>>>        If (bIsParanthesis = False) Begin
91730>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * "(" + String(sVariable) + ")" * CS_To * String(sExpression) + CodeComponents.sRightComment) to sLine
91731>>>>>>>>>        End 
91731>>>>>>>>>>
91731>>>>>>>>>        Else Begin
91732>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * String(sVariable) * CS_To * String(sExpression) + CodeComponents.sRightComment) to sLine
91733>>>>>>>>>        End
91733>>>>>>>>>>
91733>>>>>>>>>                                                            
91733>>>>>>>>>        Function_Return bChanged
91734>>>>>>>>>    End_Function 
91735>>>>>>>>>
91735>>>>>>>>>    // [Select] Indicate Select as Windowindex Eq Fieldindex --> If (Select) Move (Windowindex = Fieldindex) to Select // Comment
91735>>>>>>>>>    Function ChangeIndicatorToMoveStateToVariable String ByRef sLine String sParameter Returns Boolean
91737>>>>>>>>>        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis bStartIndicator bFound bIsIfStatement
91737>>>>>>>>>        String sText sVariable sExpression sIndicator sChar sOrgLine sIfStatement sCommand
91737>>>>>>>>>        Integer iPos iStart iEnd
91737>>>>>>>>>        tCodeComponents Components 
91737>>>>>>>>>        tCodeComponents Components 
91737>>>>>>>>>        tBooleanIndicator BooleanIndicator
91737>>>>>>>>>        tBooleanIndicator BooleanIndicator
91737>>>>>>>>>        
91737>>>>>>>>>        Move False to bChanged
91738>>>>>>>>>        Move sLine to sText                                        
91739>>>>>>>>>        Move sLine to sOrgLine
91740>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentLineOrBlank
91741>>>>>>>>>        If (bIsCommentLineOrBlank = True) Begin
91743>>>>>>>>>            Function_Return False
91744>>>>>>>>>        End              
91744>>>>>>>>>>
91744>>>>>>>>>        Move (Trim(sText)) to sChar
91745>>>>>>>>>        If (Left(sChar, 1) = "#") Begin
91747>>>>>>>>>            Function_Return False
91748>>>>>>>>>        End
91748>>>>>>>>>>
91748>>>>>>>>>        // While, Repeat, Loop and Until are delt with by other functions.
91748>>>>>>>>>        Get IsWhileStatement sText to bFound
91749>>>>>>>>>        If (bFound = True) Begin
91751>>>>>>>>>            Function_Return False
91752>>>>>>>>>        End
91752>>>>>>>>>>
91752>>>>>>>>>        Get IsRepeatStatement sText to bFound
91753>>>>>>>>>        If (bFound = True) Begin
91755>>>>>>>>>            Function_Return False
91756>>>>>>>>>        End
91756>>>>>>>>>>
91756>>>>>>>>>        Get IsLoopStatement sText to bFound
91757>>>>>>>>>        If (bFound = True) Begin
91759>>>>>>>>>            Function_Return False
91760>>>>>>>>>        End
91760>>>>>>>>>>
91760>>>>>>>>>        Get IsUntilStatement sText to bFound
91761>>>>>>>>>        If (bFound = True) Begin
91763>>>>>>>>>            Function_Return False
91764>>>>>>>>>        End
91764>>>>>>>>>>
91764>>>>>>>>>        Get _RetrieveFirstWord sLine to sIfStatement
91765>>>>>>>>>        Move (Lowercase(sIfStatement) = Lowercase(CS_If)) to bIsIfStatement
91766>>>>>>>>>        If (bIsIfStatement = True) Begin
91768>>>>>>>>>            Move "" to sIfStatement
91769>>>>>>>>>        End
91769>>>>>>>>>>
91769>>>>>>>>>
91769>>>>>>>>>        Get Tokenizer sText to Components
91770>>>>>>>>>        Get _ExtractIndicatorContent Components.sCode to BooleanIndicator
91771>>>>>>>>>        If (BooleanIndicator.bHasBracket = False and Components.bHasIndicateCommand = False) Begin
91773>>>>>>>>>            Function_Return False
91774>>>>>>>>>        End                                 
91774>>>>>>>>>>
91774>>>>>>>>>        
91774>>>>>>>>>        // There are other function dealing with loop, while & move statements.
91774>>>>>>>>>        Get IsRepeatStatement BooleanIndicator.sCode to bFound
91775>>>>>>>>>        If (bFound = True) Begin
91777>>>>>>>>>            Function_Return False
91778>>>>>>>>>        End
91778>>>>>>>>>>
91778>>>>>>>>>        Get IsWhileStatement BooleanIndicator.sCode to bFound
91779>>>>>>>>>        If (bFound = True) Begin
91781>>>>>>>>>            Function_Return False
91782>>>>>>>>>        End
91782>>>>>>>>>>
91782>>>>>>>>>        Get IsMoveCommand BooleanIndicator.sCode to bFound
91783>>>>>>>>>        If (bFound = True) Begin
91785>>>>>>>>>            Function_Return False
91786>>>>>>>>>        End           
91786>>>>>>>>>>
91786>>>>>>>>>        If (BooleanIndicator.sCode = "") Begin
91788>>>>>>>>>            Move Components.sCode to BooleanIndicator.sCode
91789>>>>>>>>>        End
91789>>>>>>>>>>
91789>>>>>>>>>        
91789>>>>>>>>>        If (Lowercase(BooleanIndicator.sCode) contains Lowercase(CS_Indicate)) Begin
91791>>>>>>>>>            Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iEnd
91792>>>>>>>>>            If (iEnd <> 0) Begin
91794>>>>>>>>>                Move (Pos(Lowercase(CS_Indicate + " "), Lowercase(BooleanIndicator.sCode))) to iStart
91795>>>>>>>>>                Move (Left(BooleanIndicator.sCode, (iStart + Length(CS_Indicate)))) to sText
91796>>>>>>>>>                Move (Replace(sText, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
91797>>>>>>>>>                Move (Pos(Lowercase(CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
91798>>>>>>>>>                Move (Left(BooleanIndicator.sCode, (iPos - 1))) to sIndicator
91799>>>>>>>>>                Move (Replace(sIndicator, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
91800>>>>>>>>>                Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
91801>>>>>>>>>                Move (Mid(BooleanIndicator.sCode, Length(BooleanIndicator.sCode), (iPos + 1 + Length(CS_As)))) to BooleanIndicator.sCode
91802>>>>>>>>>                Move (Trim(sIndicator)) to sIndicator
91803>>>>>>>>>                Move (String(CS_Move) * Trim(BooleanIndicator.sCode) * CS_To * String(sIndicator)) to BooleanIndicator.sCode
91804>>>>>>>>>                Get IsLegacyOperators BooleanIndicator.sCode to bFound
91805>>>>>>>>>                If (bFound = True) Begin            
91807>>>>>>>>>                    Move BooleanIndicator.sExpression to sText
91808>>>>>>>>>                    Get _AddExpressionParenthesis (&sText) to bFound  
91809>>>>>>>>>                    If (bFound = True) Begin
91811>>>>>>>>>                        Move sText to BooleanIndicator.sExpression
91812>>>>>>>>>                    End
91812>>>>>>>>>>
91812>>>>>>>>>                End
91812>>>>>>>>>>
91812>>>>>>>>>            End
91812>>>>>>>>>>
91812>>>>>>>>>        End
91812>>>>>>>>>>
91812>>>>>>>>>        
91812>>>>>>>>>        If (bIsIfStatement = True) Begin
91814>>>>>>>>>            Get _RetrieveFirstWord Components.sCode to sCommand
91815>>>>>>>>>            If (Lowercase(sCommand) = Lowercase(CS_If)) Begin
91817>>>>>>>>>                Move (String(Components.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
91818>>>>>>>>>            End
91818>>>>>>>>>>
91818>>>>>>>>>            Else Begin
91819>>>>>>>>>                Move (String(Components.sIndentation) + String(CS_If) * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
91820>>>>>>>>>            End
91820>>>>>>>>>>
91820>>>>>>>>>        End 
91820>>>>>>>>>>
91820>>>>>>>>>        Else If (BooleanIndicator.sExpression <> "" or BooleanIndicator.sCode <> "") Begin
91823>>>>>>>>>            If (Left(BooleanIndicator.sExpression, 1) = "(") Begin  
91825>>>>>>>>>                If (Components.sLineStartIndicator <> "") Begin
91827>>>>>>>>>                    If (Left(Components.sLineStartIndicator, 1) <> "(") Begin
91829>>>>>>>>>                        Move ("(" + String(Components.sLineStartIndicator) + ")") to Components.sLineStartIndicator
91830>>>>>>>>>                    End
91830>>>>>>>>>>
91830>>>>>>>>>                    Move (CS_If * String(Components.sLineStartIndicator)) to sLine 
91831>>>>>>>>>                    Move BooleanIndicator.sCode to sText
91832>>>>>>>>>                    Get _AddExpressionParenthesis (&sText) to bFound  // XXXX
91833>>>>>>>>>                    If (bFound = True) Begin
91835>>>>>>>>>                        Move sText to BooleanIndicator.sCode
91836>>>>>>>>>                    End
91836>>>>>>>>>>
91836>>>>>>>>>                    Move (String(sLine) * String(BooleanIndicator.sCode)) to BooleanIndicator.sCode
91837>>>>>>>>>                    Move "" to BooleanIndicator.sExpression
91838>>>>>>>>>                End
91838>>>>>>>>>>
91838>>>>>>>>>                Else Begin
91839>>>>>>>>>                    Move (CS_If * String(BooleanIndicator.sExpression)) to sLine
91840>>>>>>>>>                    Move (String(Components.sIndentation) + String(sLine) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
91841>>>>>>>>>                End
91841>>>>>>>>>>
91841>>>>>>>>>            End
91841>>>>>>>>>>
91841>>>>>>>>>            If (BooleanIndicator.sExpression <> "") Begin   
91843>>>>>>>>>                Move (String(Components.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
91844>>>>>>>>>            End
91844>>>>>>>>>>
91844>>>>>>>>>            Else Begin
91845>>>>>>>>>                Move (String(Components.sIndentation) + String(BooleanIndicator.sCode)) to sLine
91846>>>>>>>>>            End
91846>>>>>>>>>>
91846>>>>>>>>>        End
91846>>>>>>>>>>
91846>>>>>>>>>            
91846>>>>>>>>>        If (Components.sOfStatement <> "") Begin
91848>>>>>>>>>            Move (String(sLine) * CS_Of * String(Components.sOfStatement)) to sLine
91849>>>>>>>>>        End
91849>>>>>>>>>>
91849>>>>>>>>>        If (Components.sToStatement <> "") Begin
91851>>>>>>>>>            Move (String(sLine) * CS_To * String(Components.sToStatement)) to sLine
91852>>>>>>>>>        End                                                                
91852>>>>>>>>>>
91852>>>>>>>>>        If (Components.sRightComment <> "") Begin
91854>>>>>>>>>            Move (String(sLine) * String(Components.sRightComment)) to sLine
91855>>>>>>>>>        End
91855>>>>>>>>>>
91855>>>>>>>>>        Function_Return (sLine <> sOrgLine)
91856>>>>>>>>>    End_Function 
91857>>>>>>>>>    
91857>>>>>>>>>    // Changes; [Found] Repeat --> While (Found)
91857>>>>>>>>>    //          [not Seqeof] Repeat --> While (not(Seqeof))
91857>>>>>>>>>    Function ChangeIndicatorRepeatToWhile String ByRef sLine String sParameter Returns Boolean
91859>>>>>>>>>        tCodeComponents LineComponents 
91859>>>>>>>>>        tCodeComponents LineComponents 
91859>>>>>>>>>        tBooleanIndicator BooleanIndicator
91859>>>>>>>>>        tBooleanIndicator BooleanIndicator
91859>>>>>>>>>        String sChar sText sBoolean sNot sOrgLine
91859>>>>>>>>>        Boolean bIsRepeatStatement bFound
91859>>>>>>>>>        Integer iPosIndicator iPosRepeat iPos
91859>>>>>>>>>        
91859>>>>>>>>>        Move sLine to sText                      
91860>>>>>>>>>        Move sLine to sOrgLine
91861>>>>>>>>>        Get IsRepeatStatement sText to bIsRepeatStatement
91862>>>>>>>>>        If (bIsRepeatStatement = False) Begin
91864>>>>>>>>>            Function_Return False
91865>>>>>>>>>        End                      
91865>>>>>>>>>>
91865>>>>>>>>>        
91865>>>>>>>>>        Get Tokenizer sLine to LineComponents  
91866>>>>>>>>>        Get IsKeywordInLine (CS_Repeat + "|") LineComponents.sCode to bFound
91867>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
91868>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
91870>>>>>>>>>            Function_Return False
91871>>>>>>>>>        End        
91871>>>>>>>>>>
91871>>>>>>>>>
91871>>>>>>>>>        Move (CS_While * BooleanIndicator.sExpression) to LineComponents.sCode
91872>>>>>>>>>        Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * String(LineComponents.sToStatement) + String(LineComponents.sRightComment))) to sLine
91873>>>>>>>>>        
91873>>>>>>>>>        Function_Return (sLine <> sOrgLine)
91874>>>>>>>>>    End_Function
91875>>>>>>>>>    
91875>>>>>>>>>    // Changes; E.g. [Found] Begin --> If (Found) Begin  
91875>>>>>>>>>    //               [not Seqeof] Begin --> If (not(Seqeof)) Begin
91875>>>>>>>>>    Function ChangeIndicatorToIfBegin String ByRef sLine String sParameter Returns Boolean
91877>>>>>>>>>        tCodeComponents LineComponents   
91877>>>>>>>>>        tCodeComponents LineComponents   
91877>>>>>>>>>        tBooleanIndicator BooleanIndicator
91877>>>>>>>>>        tBooleanIndicator BooleanIndicator
91877>>>>>>>>>        String sText sNot sLogical
91877>>>>>>>>>        Boolean bFound bBegin
91877>>>>>>>>>        Integer iFoundIndicator iPosBegin iPos
91877>>>>>>>>>        
91877>>>>>>>>>        Move sLine to sText
91878>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
91879>>>>>>>>>        If (bFound = True) Begin
91881>>>>>>>>>            Function_Return False
91882>>>>>>>>>        End
91882>>>>>>>>>>
91882>>>>>>>>>        
91882>>>>>>>>>        Get IsBeginStatement sText to bBegin
91883>>>>>>>>>        If (bBegin = False) Begin
91885>>>>>>>>>            Function_Return False
91886>>>>>>>>>        End                      
91886>>>>>>>>>>
91886>>>>>>>>>        
91886>>>>>>>>>        Get Tokenizer sLine to LineComponents
91887>>>>>>>>>        
91887>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
91888>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
91890>>>>>>>>>            Function_Return False
91891>>>>>>>>>        End
91891>>>>>>>>>>
91891>>>>>>>>>        Move (CS_If * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to LineComponents.sCode 
91892>>>>>>>>>        If (bBegin = True) Begin
91894>>>>>>>>>            Move (LineComponents.sIndentation + String(LineComponents.sCode) * String(LineComponents.sRightComment)) to sLine
91895>>>>>>>>>        End
91895>>>>>>>>>>
91895>>>>>>>>>        Else Begin
91896>>>>>>>>>            Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * CS_To + String(LineComponents.sToStatement) * String(LineComponents.sRightComment))) to sLine
91897>>>>>>>>>        End
91897>>>>>>>>>>
91897>>>>>>>>>        
91897>>>>>>>>>        Function_Return True
91898>>>>>>>>>    End_Function     
91899>>>>>>>>>    
91899>>>>>>>>>    // Changes: Insert "," In sText At 2 --> Move (Inert(",", sText, 2)) to sText
91899>>>>>>>>>    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
91901>>>>>>>>>        Boolean bChanged bIsCommentOrBlank bIsReplace
91901>>>>>>>>>        String sText sStart sStop sVariableName sPlace sChar
91901>>>>>>>>>        Integer iPos 
91901>>>>>>>>>        tCodeComponents CodeComponents
91901>>>>>>>>>        tCodeComponents CodeComponents
91901>>>>>>>>>        
91901>>>>>>>>>        Move sLine to sText    
91902>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
91902>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
91903>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
91905>>>>>>>>>            Function_Return False
91906>>>>>>>>>        End
91906>>>>>>>>>>
91906>>>>>>>>>        Move (Ltrim(sText)) to sText
91907>>>>>>>>>        Move (Pos(Lowercase(CS_Insert + " "), Lowercase(sText))) to iPos
91908>>>>>>>>>        If (iPos < 1) Begin
91910>>>>>>>>>            Function_Return False
91911>>>>>>>>>        End
91911>>>>>>>>>>
91911>>>>>>>>>        
91911>>>>>>>>>        // Also check that the keyword is not part of a variable name:
91911>>>>>>>>>        Move (Mid(sText, 1, (iPos -1))) to sChar
91912>>>>>>>>>        If (sChar <> " " and sChar <> "(") Begin
91914>>>>>>>>>            Function_Return False
91915>>>>>>>>>        End
91915>>>>>>>>>>
91915>>>>>>>>>        
91915>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Insert to bChanged
91916>>>>>>>>>        Get Tokenizer sLine to CodeComponents
91917>>>>>>>>>        Move (Replace(CodeComponents.sIndentation, sLine, "")) to sLine
91918>>>>>>>>>        Send StripConcatenatingSpaces (&sLine)
91919>>>>>>>>>        Move (Lowercase(sLine)) to sText
91920>>>>>>>>>        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
91921>>>>>>>>>        Move (Overstrike("||||", sLine, iPos)) to sLine 
91922>>>>>>>>>        Move (Replace("||||", sLine, ", ")) to sLine
91923>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + 2))) to sStop
91924>>>>>>>>>        Move (Pos(" ", sStop)) to iPos
91925>>>>>>>>>        Move (Left(sStop, (iPos -1))) to sVariableName
91926>>>>>>>>>        Move (Lowercase(sLine)) to sText
91927>>>>>>>>>        Move (Pos(Lowercase(" " + CS_At + " "), sText)) to iPos
91928>>>>>>>>>        Move (Overstrike("||||", sLine, iPos)) to sLine
91929>>>>>>>>>        Move (Replace("||||", sLine, ", ")) to sLine
91930>>>>>>>>>
91930>>>>>>>>>        Move (CodeComponents.sIndentation + String(sLine) * String(sVariableName)) to sLine
91931>>>>>>>>>        Function_Return bChanged
91932>>>>>>>>>    End_Function
91933>>>>>>>>>    
91933>>>>>>>>>    // Replaces 'IN' with 'Contains
91933>>>>>>>>>    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
91935>>>>>>>>>        Boolean bChanged bIsPosCommand bIsCommentOrBlank bFound
91935>>>>>>>>>        String sPattern sOrg
91935>>>>>>>>>        String sMatched sRemain sHost sSub sText sKeyWord sStart
91935>>>>>>>>>        tRegexMatch[] myReg           
91935>>>>>>>>>        tRegexMatch[] myReg           
91936>>>>>>>>>        Integer iPos
91936>>>>>>>>>        tCodeComponents CodeComponents
91936>>>>>>>>>        tCodeComponents CodeComponents
91936>>>>>>>>>        
91936>>>>>>>>>        Move False to bChanged
91937>>>>>>>>>        Move sLine to sText 
91938>>>>>>>>>        Move sLine to sOrg   
91939>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
91939>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
91940>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
91942>>>>>>>>>            Function_Return False
91943>>>>>>>>>        End
91943>>>>>>>>>>
91943>>>>>>>>>
91943>>>>>>>>>        Get _OverstrikeStrings sText to sText
91944>>>>>>>>>        Move (Lowercase(sText)) to sText
91945>>>>>>>>>        Move (Ltrim(sText)) to sText
91946>>>>>>>>>        // First check if there is a "In" keyword in the source code.
91946>>>>>>>>>        Move (Lowercase((" " + CS_In + " "))) to sKeyWord
91947>>>>>>>>>        If (Pos(sKeyWord, sText) = 0) Begin
91949>>>>>>>>>            Function_Return False
91950>>>>>>>>>        End
91950>>>>>>>>>>
91950>>>>>>>>>
91950>>>>>>>>>        // Check for "home cocked" commands; in case we do nothing.
91950>>>>>>>>>        Get Tokenizer sLine to CodeComponents
91951>>>>>>>>>
91951>>>>>>>>>        // If we are in a "Pos", "Insert" or "Replace" command line, we're done.
91951>>>>>>>>>        Get IsKeywordInLine (CS_Pos + "|" + CS_Insert + "|" + CS_Replace + "|") CodeComponents.sCode to bFound
91952>>>>>>>>>        If (bFound = True) Begin
91954>>>>>>>>>            Function_Return False
91955>>>>>>>>>        End
91955>>>>>>>>>>
91955>>>>>>>>>        
91955>>>>>>>>>        If (CodeComponents.sOfStatement <> "") Begin
91957>>>>>>>>>            Move (CodeComponents.sCode * CS_Of * String(CodeComponents.sOfStatement)) to sText
91958>>>>>>>>>        End
91958>>>>>>>>>>
91958>>>>>>>>>        If (CodeComponents.sToStatement <> "") Begin
91960>>>>>>>>>            Move (CodeComponents.sCode * CS_To * String(CodeComponents.sToStatement)) to sText
91961>>>>>>>>>        End
91961>>>>>>>>>>
91961>>>>>>>>>            
91961>>>>>>>>>        Get _RetrieveFirstWord sText to sStart
91962>>>>>>>>>        Move (" " + Lowercase(sStart) + " ") to sStart
91963>>>>>>>>>        Get _FindFirstCommand sStart to iPos
91964>>>>>>>>>        If (iPos = 0) Begin
91966>>>>>>>>>            Get _TestCommandFunctions sStart to iPos
91967>>>>>>>>>        End
91967>>>>>>>>>>
91967>>>>>>>>>        If (iPos = 0) Begin
91969>>>>>>>>>            Function_Return False 
91970>>>>>>>>>        End
91970>>>>>>>>>>
91970>>>>>>>>>        
91970>>>>>>>>>        Move CodeComponents.sCode to sText
91971>>>>>>>>>        Move (Replaces('`', '(".*"|`.*`|\S+)\s+in\s+(".*"|`.*`|\S+)', "'")) to sPattern
91972>>>>>>>>>        Get Regex_Match sText sPattern True to myReg
91973>>>>>>>>>        If (SizeOfArray(myReg)) Begin
91975>>>>>>>>>            Move myReg[0].Val to sMatched
91976>>>>>>>>>            Move (Replaces('`', '(".*"|`.*`|\S+)\s+', "'")) to sPattern
91977>>>>>>>>>            Get Regex_Match sMatched sPattern True to myReg
91978>>>>>>>>>            Move (Trim(myReg[0].Val)) to sSub
91979>>>>>>>>>            Move (Trim(Replace(sSub, sMatched, ''))) to sRemain // Remove the subString
91980>>>>>>>>>            Move (Remove(sRemain,0 ,2)) to sRemain // Remove the 'In'
91981>>>>>>>>>            Move (Replaces('`', '\s+(".*"|`.*`|\S+)', "'")) to sPattern
91982>>>>>>>>>            Get Regex_Match sRemain sPattern True to myReg
91983>>>>>>>>>            Move (Trim(myReg[0].Val)) to sHost
91984>>>>>>>>>
91984>>>>>>>>>            Move (Replace(sMatched, sText, ("(" + sHost + ' contains ' + sSub + ")"))) to sLine
91985>>>>>>>>>            If (Length(CodeComponents.sIndentation)) Begin
91987>>>>>>>>>                Move (CodeComponents.sIndentation + String(sLine)) to sLine
91988>>>>>>>>>            End
91988>>>>>>>>>>
91988>>>>>>>>>            If (CodeComponents.sOfStatement <> "") Begin
91990>>>>>>>>>                Move (String(sLine) * String(CS_Of) * String(CodeComponents.sOfStatement)) to sLine
91991>>>>>>>>>            End
91991>>>>>>>>>>
91991>>>>>>>>>            If (CodeComponents.sToStatement <> "") Begin
91993>>>>>>>>>                Move (String(sLine) * String(CS_To) * String(CodeComponents.sToStatement)) to sLine
91994>>>>>>>>>            End    
91994>>>>>>>>>>
91994>>>>>>>>>            If (CodeComponents.sRightComment <> "") Begin
91996>>>>>>>>>                Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine
91997>>>>>>>>>            End
91997>>>>>>>>>>
91997>>>>>>>>>        End          
91997>>>>>>>>>>
91997>>>>>>>>>                
91997>>>>>>>>>        Function_Return (sLine <> sOrg)
91998>>>>>>>>>    End_Function
91999>>>>>>>>>
91999>>>>>>>>>    // Changes "Set Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
91999>>>>>>>>>    // and     "Set Object_Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
91999>>>>>>>>>    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
92001>>>>>>>>>        tCodeComponents LineComponents                       
92001>>>>>>>>>        tCodeComponents LineComponents                       
92001>>>>>>>>>        String sCode sState sFirstChar sText
92001>>>>>>>>>        Boolean bIsComment bIsOfOperator
92001>>>>>>>>>        Integer iPos
92001>>>>>>>>>        
92001>>>>>>>>>        Get IsCommentLineOrBlank sLine to bIsComment
92002>>>>>>>>>        If (bIsComment = True) Begin
92004>>>>>>>>>            Function_Return False
92005>>>>>>>>>        End
92005>>>>>>>>>>
92005>>>>>>>>>        
92005>>>>>>>>>        Get Tokenizer sLine to LineComponents
92006>>>>>>>>>        Move (Trim(sLine)) to sCode
92007>>>>>>>>>        Move (Lowercase(sCode)) to sCode
92008>>>>>>>>>        Move (Left(sCode, 1)) to sFirstChar 
92009>>>>>>>>>        
92009>>>>>>>>>        // There are two variants of shadow state; Shadow_State and Object_Shadow_State
92009>>>>>>>>>        Move "et shadow_state " to sText
92010>>>>>>>>>        Move (Pos(sText, sCode)) to iPos
92011>>>>>>>>>        If (iPos = 0) Begin
92013>>>>>>>>>            Move "et object_shadow_state " to sText
92014>>>>>>>>>            Move (Pos(sText, sCode)) to iPos
92015>>>>>>>>>        End   
92015>>>>>>>>>>
92015>>>>>>>>>        If (iPos = 0) Begin
92017>>>>>>>>>            Function_Return False
92018>>>>>>>>>        End
92018>>>>>>>>>>
92018>>>>>>>>>        
92018>>>>>>>>>        Move (Pos((" " + Lowercase(CS_To) + " "), sCode)) to iPos
92019>>>>>>>>>        If (iPos = 0) Begin
92021>>>>>>>>>            Function_Return False
92022>>>>>>>>>        End
92022>>>>>>>>>>
92022>>>>>>>>>    
92022>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + 3 + Length(LineComponents.sIndentation)))) to sState // Could also be a variable name (if get statement)
92023>>>>>>>>>        Move (Replace(LineComponents.sRightComment, sState, "")) to sState 
92024>>>>>>>>>        Move (" " + Trim(sState)) to sState
92025>>>>>>>>>    
92025>>>>>>>>>        // Set syntax:
92025>>>>>>>>>        If (sFirstChar = "s") Begin
92027>>>>>>>>>            If (Lowercase(sState) contains (" " + Lowercase(CS_True))) Begin
92029>>>>>>>>>                Move (" " + CS_False) to sState
92030>>>>>>>>>            End
92030>>>>>>>>>>
92030>>>>>>>>>            Else Begin   
92031>>>>>>>>>                If (Lowercase(sState) contains (" " + Lowercase(CS_False))) Begin
92033>>>>>>>>>                    Move CS_True to sState
92034>>>>>>>>>                End 
92034>>>>>>>>>>
92034>>>>>>>>>                Else Begin      
92035>>>>>>>>>                    If (Lowercase(sState) contains ("(" + Lowercase(CS_Not)) or sState contains ("( " + Lowercase(CS_Not)) or Lowercase(sState) contains (Lowercase(CS_Not + ")")) or Lowercase(sState) contains (Lowercase(CS_Not + " )"))) Begin
92037>>>>>>>>>                        Move (Replace(CS_Not, sState, "")) to sState
92038>>>>>>>>>                        Move (Replaces(")", sState, "")) to sState
92039>>>>>>>>>                        Move (Pos("(", sState)) to iPos
92040>>>>>>>>>                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
92041>>>>>>>>>                        Move (Pos("(", sState)) to iPos
92042>>>>>>>>>                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
92043>>>>>>>>>                    End   
92043>>>>>>>>>>
92043>>>>>>>>>                    Else Begin
92044>>>>>>>>>                        Move ("(" + CS_Not + "(" + Trim(sState) + "))") to sState
92045>>>>>>>>>                    End
92045>>>>>>>>>>
92045>>>>>>>>>                End
92045>>>>>>>>>>
92045>>>>>>>>>                    
92045>>>>>>>>>            End
92045>>>>>>>>>>
92045>>>>>>>>>            If (Length(LineComponents.sOfStatement)) Begin
92047>>>>>>>>>                Move (CS_Set * CS_Enabled_State * CS_Of * LineComponents.sOfStatement * CS_To * String(sState)) to sCode 
92048>>>>>>>>>            End
92048>>>>>>>>>>
92048>>>>>>>>>            Else Begin
92049>>>>>>>>>                Move (CS_Set * CS_Enabled_State * CS_To * Trim(sState)) to sCode 
92050>>>>>>>>>            End
92050>>>>>>>>>>
92050>>>>>>>>>        End           
92050>>>>>>>>>>
92050>>>>>>>>>    
92050>>>>>>>>>        // Get Syntax:
92050>>>>>>>>>        Else If (sFirstChar = "g") Begin                         
92053>>>>>>>>>            Move (Lowercase(LineComponents.sToStatement)) to sText
92054>>>>>>>>>            Move (Pos(Lowercase(CS_To), sText)) to iPos
92055>>>>>>>>>            // Remove "To" keyword:
92055>>>>>>>>>            If (iPos <> 0) Begin
92057>>>>>>>>>                Move (Mid(LineComponents.sToStatement, Length(LineComponents.sToStatement), (iPos + 3))) to LineComponents.sToStatement
92058>>>>>>>>>            End
92058>>>>>>>>>>
92058>>>>>>>>>            If (Length(LineComponents.sOfStatement)) Begin
92060>>>>>>>>>                Move (CS_Get * CS_Enabled_State * LineComponents.sOfStatement * CS_To * "(" + CS_Not + "(" + LineComponents.sToStatement + "))") to sCode
92061>>>>>>>>>            End
92061>>>>>>>>>>
92061>>>>>>>>>            Else Begin
92062>>>>>>>>>                Move (CS_Get * CS_Enabled_State * CS_To * "(" + CS_Not + "(" + LineComponents.sToStatement + "))") to sCode
92063>>>>>>>>>            End
92063>>>>>>>>>>
92063>>>>>>>>>        End
92063>>>>>>>>>>
92063>>>>>>>>>        If (LineComponents.sRightComment <> "") Begin
92065>>>>>>>>>             Move (LineComponents.sIndentation + String(sCode) * String(LineComponents.sRightComment)) to sLine
92066>>>>>>>>>        End
92066>>>>>>>>>>
92066>>>>>>>>>        Else Begin
92067>>>>>>>>>            Move (LineComponents.sIndentation + String(sCode)) to sLine
92068>>>>>>>>>        End
92068>>>>>>>>>>
92068>>>>>>>>>                                
92068>>>>>>>>>        Function_Return True
92069>>>>>>>>>    End_Function
92070>>>>>>>>>
92070>>>>>>>>>    // Dummy function (Asolvi)
92070>>>>>>>>>    Function ChangewsDoTranslateTo_ String ByRef sLine Returns Boolean
92072>>>>>>>>>        Function_Return False
92073>>>>>>>>>    End_Function
92074>>>>>>>>>
92074>>>>>>>>>    // Pass only the code part of a source line.
92074>>>>>>>>>    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>" for If-Begin lines and While statements.
92074>>>>>>>>>    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
92076>>>>>>>>>        String sSource sText sLeftExpression sRightExpression sStart sCommand sFirstChar sLastChar sOrg
92076>>>>>>>>>        Boolean bFound bChanged
92076>>>>>>>>>        Integer iPos                       
92076>>>>>>>>>        tCodeComponents CodeComponents
92076>>>>>>>>>        tCodeComponents CodeComponents
92076>>>>>>>>>
92076>>>>>>>>>        Move sLine to sText     
92077>>>>>>>>>        Move sLine to sOrg
92078>>>>>>>>>        // Skip line if it is a comment or blank
92078>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92079>>>>>>>>>        If (bFound = True) Begin
92081>>>>>>>>>            Function_Return False
92082>>>>>>>>>        End
92082>>>>>>>>>>
92082>>>>>>>>>        // Skip line if it contains a semi colon ?? Should we??
92082>>>>>>>>>        Get IsLineEndSemiColon sText to bFound
92083>>>>>>>>>        If (bFound = True) Begin
92085>>>>>>>>>            Function_Return False
92086>>>>>>>>>        End
92086>>>>>>>>>>
92086>>>>>>>>>        Get IsFirstWord sText CS_Find to bFound
92087>>>>>>>>>        If (bFound = True) Begin
92089>>>>>>>>>            Function_Return False
92090>>>>>>>>>        End                 
92090>>>>>>>>>>
92090>>>>>>>>>        Get IsFirstWord sText CS_Send to bFound
92091>>>>>>>>>        If (bFound = True) Begin
92093>>>>>>>>>            Function_Return False
92094>>>>>>>>>        End                 
92094>>>>>>>>>>
92094>>>>>>>>>        Get IsFirstWord sText CS_Constrain to bFound
92095>>>>>>>>>        If (bFound = True) Begin
92097>>>>>>>>>            Function_Return False 
92098>>>>>>>>>        End
92098>>>>>>>>>>
92098>>>>>>>>>        Get IsLegacyOperators sText to bFound
92099>>>>>>>>>        If (bFound = False) Begin
92101>>>>>>>>>            Function_Return False
92102>>>>>>>>>        End            
92102>>>>>>>>>>
92102>>>>>>>>>        Move (Lowercase(sText)) to sSource 
92103>>>>>>>>>        
92103>>>>>>>>>        Move (Pos(" gt ", sSource)) to iPos
92104>>>>>>>>>        While (iPos <> 0)
92108>>>>>>>>>            Move (Overstrike(" >_ ", sText, iPos)) to sText
92109>>>>>>>>>            Move (Replace(" >_ ", sText, " > ")) to sText
92110>>>>>>>>>            Move (Pos(" gt ", sText)) to iPos  
92111>>>>>>>>>        Loop
92112>>>>>>>>>>
92112>>>>>>>>>
92112>>>>>>>>>        Move (Pos(" ge ", sSource)) to iPos
92113>>>>>>>>>        While (iPos <> 0)
92117>>>>>>>>>            Move (Overstrike(" >= ", sText, iPos)) to sText
92118>>>>>>>>>            Move (Pos(" ge ", sText)) to iPos
92119>>>>>>>>>        Loop
92120>>>>>>>>>>
92120>>>>>>>>>
92120>>>>>>>>>        Move (Pos(" lt ", sSource)) to iPos
92121>>>>>>>>>        While (iPos <> 0)
92125>>>>>>>>>            Move (Overstrike(" <_ ", sText, iPos)) to sText
92126>>>>>>>>>            Move (Replace(" <_ ", sText, " < ")) to sText
92127>>>>>>>>>            Move (Pos(" lt ", sText)) to iPos
92128>>>>>>>>>        Loop
92129>>>>>>>>>>
92129>>>>>>>>>
92129>>>>>>>>>        Move (Pos(" le ", sSource)) to iPos
92130>>>>>>>>>        While (iPos <> 0)
92134>>>>>>>>>            Move (Overstrike(" <= ", sText, iPos)) to sText
92135>>>>>>>>>            Move (Pos(" le ", sText)) to iPos
92136>>>>>>>>>        Loop
92137>>>>>>>>>>
92137>>>>>>>>>
92137>>>>>>>>>        Move (Pos(" eq ", sSource)) to iPos
92138>>>>>>>>>        While (iPos <> 0)
92142>>>>>>>>>            Move (Overstrike(" =_ ", sText, iPos)) to sText
92143>>>>>>>>>            Move (Replace(" =_ ", sText, " = ")) to sText
92144>>>>>>>>>            Move (Pos(" eq ", sText)) to iPos
92145>>>>>>>>>        Loop
92146>>>>>>>>>>
92146>>>>>>>>>
92146>>>>>>>>>        Move (Pos(" ne ", sSource)) to iPos
92147>>>>>>>>>        While (iPos <> 0)
92151>>>>>>>>>            Move (Overstrike(" <> ", sText, iPos)) to sText
92152>>>>>>>>>            Move (Pos(" ne ", sText)) to iPos
92153>>>>>>>>>        Loop 
92154>>>>>>>>>>
92154>>>>>>>>>        
92154>>>>>>>>>        Move (String(sText) <> String(sLine)) to bChanged
92155>>>>>>>>>        If (bChanged = False) Begin
92157>>>>>>>>>            Function_Return False
92158>>>>>>>>>        End                      
92158>>>>>>>>>>
92158>>>>>>>>>        
92158>>>>>>>>>        Get Tokenizer sText to CodeComponents 
92159>>>>>>>>>        // For some reason we can get an exception error passing a struct member as
92159>>>>>>>>>        // a ByRef argument. Just moving to a local variable cures it.
92159>>>>>>>>>        Move CodeComponents.sCode to sText
92160>>>>>>>>>        Get _AddExpressionParenthesis (&sText) to bChanged
92161>>>>>>>>>        If (bChanged = True) Begin
92163>>>>>>>>>            Move sText to CodeComponents.sCode
92164>>>>>>>>>        End
92164>>>>>>>>>>
92164>>>>>>>>>                    
92164>>>>>>>>>        Move (String(CodeComponents.sIndentation + String(CodeComponents.sCode))) to sLine
92165>>>>>>>>>        If (CodeComponents.sOfStatement <> "") Begin
92167>>>>>>>>>            Move (String(sLine) * CodeComponents.sOfStatement) to sLine
92168>>>>>>>>>        End                   
92168>>>>>>>>>>
92168>>>>>>>>>        If (CodeComponents.sToStatement <> "") Begin
92170>>>>>>>>>            Move (String(sLine) * String(CS_To) * String(CodeComponents.sToStatement)) to sLine
92171>>>>>>>>>        End                                                                    
92171>>>>>>>>>>
92171>>>>>>>>>        If (CodeComponents.sRightComment <> "") Begin
92173>>>>>>>>>            Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine
92174>>>>>>>>>        End
92174>>>>>>>>>>
92174>>>>>>>>>
92174>>>>>>>>>        Function_Return (sLine <> sOrg)
92175>>>>>>>>>    End_Function 
92176>>>>>>>>>    
92176>>>>>>>>>    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
92178>>>>>>>>>        Boolean bChanged
92178>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
92179>>>>>>>>>        Function_Return bChanged
92180>>>>>>>>>    End_Function
92181>>>>>>>>>    
92181>>>>>>>>>    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
92183>>>>>>>>>        Boolean bChanged
92183>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
92184>>>>>>>>>        Function_Return bChanged
92185>>>>>>>>>    End_Function
92186>>>>>>>>>    
92186>>>>>>>>>    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
92186>>>>>>>>>    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
92188>>>>>>>>>        Boolean bChanged bFound
92188>>>>>>>>>        String sText sStart sStop sVariableName sOrg sFirstWord
92188>>>>>>>>>        Integer iPos 
92188>>>>>>>>>        tCodeComponents CodeComponents
92188>>>>>>>>>        tCodeComponents CodeComponents
92188>>>>>>>>>        
92188>>>>>>>>>        Move sLine to sOrg
92189>>>>>>>>>        Move sLine to sText    
92190>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
92190>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92191>>>>>>>>>        If (bFound = True) Begin
92193>>>>>>>>>            Function_Return False
92194>>>>>>>>>        End   
92194>>>>>>>>>>
92194>>>>>>>>>        Get IsKeywordInLine (CS_Replace + "|") sLine to bFound
92195>>>>>>>>>        If (bFound = False) Begin
92197>>>>>>>>>            Function_Return False
92198>>>>>>>>>        End
92198>>>>>>>>>>
92198>>>>>>>>>        
92198>>>>>>>>>        Get Tokenizer sLine to CodeComponents
92199>>>>>>>>>        // If a "#Replace" command line, we're done.
92199>>>>>>>>>        Move (Pos(("#"+ CS_Replace), CodeComponents.sCode)) to iPos
92200>>>>>>>>>        If (iPos <> 0) Begin
92202>>>>>>>>>            Function_Return False
92203>>>>>>>>>        End
92203>>>>>>>>>>
92203>>>>>>>>>
92203>>>>>>>>>        Move CodeComponents.sCode to sLine
92204>>>>>>>>>        Send StripConcatenatingSpaces (&sLine)
92205>>>>>>>>>        Move (Lowercase(sLine)) to sText
92206>>>>>>>>>
92206>>>>>>>>>        Get _RetrieveFirstWord sText to sFirstWord
92207>>>>>>>>>        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
92209>>>>>>>>>            Get _RemoveFirstWord sLine to sLine
92210>>>>>>>>>            Get _RemoveFirstWord sText to sText
92211>>>>>>>>>        End
92211>>>>>>>>>>
92211>>>>>>>>>
92211>>>>>>>>>        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
92212>>>>>>>>>        Move (Overstrike("||||", sLine, iPos)) to sLine 
92213>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + Length(" " + CS_In + " ")))) to sStop
92214>>>>>>>>>        Move (Pos(" ", sStop)) to iPos
92215>>>>>>>>>        Move (Left(sStop, (iPos -1))) to sVariableName
92216>>>>>>>>>        Move (Replace("||||", sLine, ", ")) to sLine
92217>>>>>>>>>        Move (Lowercase(sLine)) to sText
92218>>>>>>>>>        Move (Pos(Lowercase(" " + CS_With + " "), sText)) to iPos
92219>>>>>>>>>        Move (Overstrike("||||||", sLine, iPos)) to sLine
92220>>>>>>>>>        Move (Replace("||||||", sLine, ", ")) to sLine 
92221>>>>>>>>>        
92221>>>>>>>>>        Move (CS_Move * "(" + CS_Replace + "(" + String(sLine)) to sLine  
92222>>>>>>>>>//        Get Tokenizer sLine to CodeComponents
92222>>>>>>>>>//        Get _AddExpressionParenthesis (&sLine) to bChanged
92222>>>>>>>>>        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
92224>>>>>>>>>            Move (sLine + "))") to sLine
92225>>>>>>>>>        End
92225>>>>>>>>>>
92225>>>>>>>>>
92225>>>>>>>>>        Move (CodeComponents.sIndentation + String(sLine) * CS_To * String(sVariableName)) to sLine
92226>>>>>>>>>        If (CodeComponents.sRightComment <> "") Begin
92228>>>>>>>>>            Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine         
92229>>>>>>>>>        End               
92229>>>>>>>>>>
92229>>>>>>>>>        Function_Return (sLine <> sOrg)
92230>>>>>>>>>    End_Function
92231>>>>>>>>>    
92231>>>>>>>>>    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
92233>>>>>>>>>        String sText
92233>>>>>>>>>        Boolean bFound
92233>>>>>>>>>        Integer iPos
92233>>>>>>>>>        
92233>>>>>>>>>        Move (Lowercase(sLine)) to sText
92234>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92235>>>>>>>>>        If (bFound = True) Begin
92237>>>>>>>>>            Function_Return False
92238>>>>>>>>>        End
92238>>>>>>>>>>
92238>>>>>>>>>        
92238>>>>>>>>>        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
92238>>>>>>>>>        Get IsKeywordInLine (CS_Sysdate4 + "|") sText to bFound
92239>>>>>>>>>        If (bFound = False) Begin
92241>>>>>>>>>            Function_Return False
92242>>>>>>>>>        End                                   
92242>>>>>>>>>>
92242>>>>>>>>>        
92242>>>>>>>>>        Move (Pos(Lowercase(CS_Sysdate4), sText)) to iPos
92243>>>>>>>>>        Move (Overstrike("|", sLine, (iPos - 1 + Length(CS_Sysdate4)))) to sLine
92244>>>>>>>>>        Move (Replace("|", sLine, "")) to sLine
92245>>>>>>>>>        Function_Return True
92246>>>>>>>>>    End_Function
92247>>>>>>>>>
92247>>>>>>>>>    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
92249>>>>>>>>>        Boolean bChanged
92249>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Trim to bChanged
92250>>>>>>>>>        Function_Return bChanged
92251>>>>>>>>>    End_Function
92252>>>>>>>>>    
92252>>>>>>>>>    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
92254>>>>>>>>>        Boolean bChanged
92254>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
92255>>>>>>>>>        Function_Return bChanged
92256>>>>>>>>>    End_Function 
92257>>>>>>>>>    
92257>>>>>>>>>    // Changes: Until [expression] to Until (expression) and the same for the While command.
92257>>>>>>>>>    Function ChangeUntilAndWhileIndicators String ByRef sLine String sParameter Returns Boolean
92259>>>>>>>>>        String sText sCommand sNot
92259>>>>>>>>>        Boolean bFound
92259>>>>>>>>>        Integer iPos
92259>>>>>>>>>        tCodeComponents LineComponents 
92259>>>>>>>>>        tCodeComponents LineComponents 
92259>>>>>>>>>        tBooleanIndicator BooleanIndicator
92259>>>>>>>>>        tBooleanIndicator BooleanIndicator
92259>>>>>>>>>        
92259>>>>>>>>>        Move sLine to sText
92260>>>>>>>>>        // Skip line if it is a comment or blank
92260>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92261>>>>>>>>>        If (bFound = True) Begin
92263>>>>>>>>>            Function_Return False
92264>>>>>>>>>        End             
92264>>>>>>>>>>
92264>>>>>>>>>        // Skip line if it contains a semi colon
92264>>>>>>>>>        Get IsLineEndSemiColon sText to bFound
92265>>>>>>>>>        If (bFound = True) Begin
92267>>>>>>>>>            Function_Return False
92268>>>>>>>>>        End
92268>>>>>>>>>>
92268>>>>>>>>>        
92268>>>>>>>>>        Get IsWhileStatement sText to bFound
92269>>>>>>>>>        If (bFound = False) Begin
92271>>>>>>>>>            Get IsUntilStatement sText to bFound
92272>>>>>>>>>            If (bFound = False) Begin
92274>>>>>>>>>                Function_Return False
92275>>>>>>>>>            End
92275>>>>>>>>>>
92275>>>>>>>>>        End
92275>>>>>>>>>>
92275>>>>>>>>>        Get Tokenizer sLine to LineComponents
92276>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
92277>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
92279>>>>>>>>>            Function_Return False
92280>>>>>>>>>        End
92280>>>>>>>>>>
92280>>>>>>>>>
92280>>>>>>>>>        Move (LineComponents.sIndentation + String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression) + LineComponents.sRightComment) to sLine
92281>>>>>>>>>
92281>>>>>>>>>        Function_Return True
92282>>>>>>>>>    End_Function
92283>>>>>>>>>    
92283>>>>>>>>>    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
92283>>>>>>>>>    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
92285>>>>>>>>>        Boolean bChanged bValid bIgnore
92285>>>>>>>>>        String sTest sClassName sOldStyle sNewStyle
92285>>>>>>>>>        Integer iPos
92285>>>>>>>>>
92285>>>>>>>>>        Move False to bChanged
92286>>>>>>>>>        Move "" to sClassName
92287>>>>>>>>>        Move (Lowercase(sLine)) to sTest
92288>>>>>>>>>        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
92289>>>>>>>>>        Send StripConcatenatingSpaces (&sTest)
92290>>>>>>>>>        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
92290>>>>>>>>>        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
92291>>>>>>>>>        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
92292>>>>>>>>>        If (Pos(" create u_", sTest)) Begin
92294>>>>>>>>>            Move (Lowercase(sLine)) to sTest
92295>>>>>>>>>            Move (Pos("u_", sTest)) to iPos
92296>>>>>>>>>            Get IsValidClassCharacter sTest iPos to bValid
92297>>>>>>>>>            While (bValid)
92301>>>>>>>>>                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
92302>>>>>>>>>                Increment iPos
92303>>>>>>>>>                Get IsValidClassCharacter sTest iPos to bValid
92304>>>>>>>>>            Loop
92305>>>>>>>>>>
92305>>>>>>>>>        End
92305>>>>>>>>>>
92305>>>>>>>>>        If (sClassName <> "") Begin
92307>>>>>>>>>            Move True to bChanged
92308>>>>>>>>>            Move sClassName to sOldStyle
92309>>>>>>>>>            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
92310>>>>>>>>>            Move ("(RefClass(" + sClassName + "))") to sNewStyle
92311>>>>>>>>>            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
92312>>>>>>>>>        End
92312>>>>>>>>>>
92312>>>>>>>>>        Function_Return bChanged
92313>>>>>>>>>    End_Function
92314>>>>>>>>>    
92314>>>>>>>>>    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
92314>>>>>>>>>    Function ReplaceCalcWithMoveStatement String ByRef sLine String sParameter Returns Boolean
92316>>>>>>>>>        Boolean bChanged bIsIn bIsCommentOrBlank
92316>>>>>>>>>        String sTest sStart sStop
92316>>>>>>>>>        Integer iPos                             
92316>>>>>>>>>
92316>>>>>>>>>        Move False to bChanged
92317>>>>>>>>>        Move sLine to sTest
92318>>>>>>>>>
92318>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
92318>>>>>>>>>        Get IsCommentLineOrBlank sTest to bIsCommentOrBlank
92319>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
92321>>>>>>>>>            Function_Return False
92322>>>>>>>>>        End
92322>>>>>>>>>>
92322>>>>>>>>>
92322>>>>>>>>>        Move (Lowercase(sLine)) to sTest
92323>>>>>>>>>        Get _OverstrikeStrings sTest to sTest
92324>>>>>>>>>        // Replaces all quotes string contents to "_" so we don't get false positives.
92324>>>>>>>>>
92324>>>>>>>>>        // Check if line contains one of the keywords and that none of the keywords are within quotes.
92324>>>>>>>>>        Get IsKeywordInLine "calc|moveint|movenum|movereal|movestr|" sTest to bIsIn
92325>>>>>>>>>        If (bIsIn = False) Begin
92327>>>>>>>>>            Function_Return False
92328>>>>>>>>>        End
92328>>>>>>>>>>
92328>>>>>>>>>        
92328>>>>>>>>>        Case Begin
92328>>>>>>>>>            Case (Pos("calc ", sTest))
92330>>>>>>>>>                Move (Pos("calc ", sTest))         to iPos
92331>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
92332>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
92333>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
92334>>>>>>>>>                Move True                          to bChanged
92335>>>>>>>>>                Case Break
92336>>>>>>>>>
92336>>>>>>>>>            Case (Pos("moveint ", sTest))
92339>>>>>>>>>                Move (Pos("moveint ", sTest))      to iPos
92340>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
92341>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
92342>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
92343>>>>>>>>>                Move True                          to bChanged
92344>>>>>>>>>                Case Break
92345>>>>>>>>>
92345>>>>>>>>>            Case (Pos("movenum ", sTest))
92348>>>>>>>>>                Move (Pos("movenum ", sTest))      to iPos
92349>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
92350>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
92351>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
92352>>>>>>>>>                Move True                          to bChanged
92353>>>>>>>>>                Case Break
92354>>>>>>>>>
92354>>>>>>>>>            Case (Pos("movereal ", sTest))
92357>>>>>>>>>                Move (Pos("movereal ", sTest))     to iPos
92358>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
92359>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
92360>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
92361>>>>>>>>>                Move True                          to bChanged
92362>>>>>>>>>                Case Break
92363>>>>>>>>>
92363>>>>>>>>>            Case (Pos("movestr ", sTest))
92366>>>>>>>>>                Move (Pos("movestr ", sTest))      to iPos
92367>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
92368>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
92369>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
92370>>>>>>>>>                Move True                          to bChanged
92371>>>>>>>>>                Case Break
92372>>>>>>>>>        Case End
92372>>>>>>>>>
92372>>>>>>>>>        Function_Return bChanged
92373>>>>>>>>>    End_Function
92374>>>>>>>>>
92374>>>>>>>>>    // Removes local statement if present.
92374>>>>>>>>>    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
92376>>>>>>>>>        Boolean bChanged bFound
92376>>>>>>>>>        String sTest
92376>>>>>>>>>        Integer iPos
92376>>>>>>>>>
92376>>>>>>>>>        Move sLine to sTest
92377>>>>>>>>>        Get IsCommentLineOrBlank sTest to bFound
92378>>>>>>>>>        If (bFound = True) Begin
92380>>>>>>>>>            Function_Return False
92381>>>>>>>>>        End
92381>>>>>>>>>>
92381>>>>>>>>>        Move False to bChanged
92382>>>>>>>>>        Move (LTrim(sLine)) to sTest
92383>>>>>>>>>        Move (Left(sTest, 6)) to sTest
92384>>>>>>>>>        Move (Lowercase(sTest)) to sTest
92385>>>>>>>>>        If (sTest = (Lowercase(CS_Local) + " ")) Begin
92387>>>>>>>>>            // local must be the first word in the line.
92387>>>>>>>>>            // Now find the local statement in the line and remove it.
92387>>>>>>>>>            Move (Lowercase(sLine)) to sTest
92388>>>>>>>>>            Move (Pos((Lowercase(CS_Local) + " "), sTest)) to iPos
92389>>>>>>>>>            If (iPos > 0) Begin
92391>>>>>>>>>                Move (Remove(sLine, iPos, 6)) to sLine
92392>>>>>>>>>                Move True to bChanged
92393>>>>>>>>>            End
92393>>>>>>>>>>
92393>>>>>>>>>        End
92393>>>>>>>>>>
92393>>>>>>>>>        Function_Return bChanged
92394>>>>>>>>>    End_Function
92395>>>>>>>>>
92395>>>>>>>>>// This would compile but not work well with the ReplaceCalcWithMoveStatement function.
92395>>>>>>>>>// Reported by: JJ
92395>>>>>>>>>//    Procedure Testing
92395>>>>>>>>>//        // Before refactor
92395>>>>>>>>>//        String moveStr
92395>>>>>>>>>//        String s
92395>>>>>>>>>//        Move moveStr to s
92395>>>>>>>>>//       
92395>>>>>>>>>//        // After refactor
92395>>>>>>>>>//        String moveStr
92395>>>>>>>>>//        String s
92395>>>>>>>>>//        Move Move to s
92395>>>>>>>>>//    End_Procedure    
92395>>>>>>>>>
92395>>>>>>>>>    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
92397>>>>>>>>>        Boolean bChanged
92397>>>>>>>>>        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
92398>>>>>>>>>        Function_Return bChanged
92399>>>>>>>>>    End_Function
92400>>>>>>>>>    
92400>>>>>>>>>    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
92402>>>>>>>>>        Boolean bChanged
92402>>>>>>>>>        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
92403>>>>>>>>>        Function_Return bChanged
92404>>>>>>>>>    End_Function
92405>>>>>>>>>
92405>>>>>>>>>    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
92405>>>>>>>>>    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
92407>>>>>>>>>        Boolean bChanged bFound
92407>>>>>>>>>        String  sTestLine sTest
92407>>>>>>>>>
92407>>>>>>>>>        Move False to bChanged
92408>>>>>>>>>        Move (LTrim(sLine)) to sTestLine
92409>>>>>>>>>        Move (Lowercase(sTestLine)) to sTestLine
92410>>>>>>>>>        Get IsCommentLineOrBlank sTestLine to bFound
92411>>>>>>>>>        If (bFound = True) Begin
92413>>>>>>>>>            Function_Return False
92414>>>>>>>>>        End
92414>>>>>>>>>>
92414>>>>>>>>>        
92414>>>>>>>>>        Move False to bFound
92415>>>>>>>>>        // We check both for a space between the key word and the comment _and_
92415>>>>>>>>>        // comments placed directly after the key word _without_ a space between, aka "end_object//this is a comment"
92415>>>>>>>>>        //
92415>>>>>>>>>        // end_class:
92415>>>>>>>>>        Move (Left(sTestLine, 10)) to sTest
92416>>>>>>>>>        Move (sTest = "end_class ") to bFound
92417>>>>>>>>>        If (bFound = False) Begin
92419>>>>>>>>>            Move (Left(sTestLine, 11)) to sTest
92420>>>>>>>>>            Move (sTest = ("end_class" + CS_CommentSymbol)) to bFound
92421>>>>>>>>>        End
92421>>>>>>>>>>
92421>>>>>>>>>        If (bFound = True) Begin
92423>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
92424>>>>>>>>>            Function_Return bChanged
92425>>>>>>>>>        End
92425>>>>>>>>>>
92425>>>>>>>>>
92425>>>>>>>>>        // end_object:
92425>>>>>>>>>        Move (Left(sTestLine, 11)) to sTest
92426>>>>>>>>>        Move (sTest = "end_object ") to bFound
92427>>>>>>>>>        If (bFound = False) Begin
92429>>>>>>>>>            Move (Left(sTestLine, 12)) to sTest
92430>>>>>>>>>            Move (sTest = ("end_object" + CS_CommentSymbol)) to bFound
92431>>>>>>>>>        End
92431>>>>>>>>>>
92431>>>>>>>>>        If (bFound = True) Begin
92433>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
92434>>>>>>>>>            Function_Return bChanged
92435>>>>>>>>>        End
92435>>>>>>>>>>
92435>>>>>>>>>
92435>>>>>>>>>        // end_function:
92435>>>>>>>>>        Move (Left(sTestLine, 13)) to sTest
92436>>>>>>>>>        Move (sTest = "end_function ") to bFound
92437>>>>>>>>>        If (bFound = False) Begin
92439>>>>>>>>>            Move (Left(sTestLine, 14)) to sTest
92440>>>>>>>>>            Move (sTest = ("end_function" + CS_CommentSymbol)) to bFound
92441>>>>>>>>>        End
92441>>>>>>>>>>
92441>>>>>>>>>        If (bFound = True) Begin
92443>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
92444>>>>>>>>>            Function_Return bChanged
92445>>>>>>>>>        End
92445>>>>>>>>>>
92445>>>>>>>>>        
92445>>>>>>>>>        // end_procedure:
92445>>>>>>>>>        Move (Left(sTestLine, 14)) to sTest
92446>>>>>>>>>        Move (sTest = "end_procedure ") to bFound
92447>>>>>>>>>        If (bFound = False) Begin
92449>>>>>>>>>            Move (Left(sTestLine, 15)) to sTest
92450>>>>>>>>>            Move (sTest = ("end_procedure" + CS_CommentSymbol)) to bFound
92451>>>>>>>>>        End
92451>>>>>>>>>>
92451>>>>>>>>>        If (bFound = True) Begin
92453>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
92454>>>>>>>>>        End
92454>>>>>>>>>>
92454>>>>>>>>>
92454>>>>>>>>>        Function_Return bChanged
92455>>>>>>>>>    End_Function
92456>>>>>>>>>    
92456>>>>>>>>>    // Returns True if a legacy IDE (Studio) source code marker is found. 
92456>>>>>>>>>    // This is a "Remove Type Function".
92456>>>>>>>>>    Function RemoveOldStudioMarkers String sLine Returns Boolean
92458>>>>>>>>>        Boolean bFound
92458>>>>>>>>>
92458>>>>>>>>>        Move False to bFound
92459>>>>>>>>>        Move (Trim(sLine)) to sLine
92460>>>>>>>>>
92460>>>>>>>>>        Case Begin
92460>>>>>>>>>            Case (sLine = "//AB-IgnoreStart")
92462>>>>>>>>>                Move True to bFound
92463>>>>>>>>>                Case Break
92464>>>>>>>>>
92464>>>>>>>>>            Case (sLine = "//AB-IgnoreEnd")
92467>>>>>>>>>                Move True to bFound
92468>>>>>>>>>                Case Break
92469>>>>>>>>>
92469>>>>>>>>>            Case (sLine = "//AB-StoreStart")
92472>>>>>>>>>                Move True to bFound
92473>>>>>>>>>                Case Break
92474>>>>>>>>>
92474>>>>>>>>>            Case (sLine = "//AB-StoreEnd")
92477>>>>>>>>>                Move True to bFound
92478>>>>>>>>>                Case Break
92479>>>>>>>>>
92479>>>>>>>>>            Case (sLine = "//AB-StoreTopStart")
92482>>>>>>>>>                Move True to bFound
92483>>>>>>>>>                Case Break
92484>>>>>>>>>
92484>>>>>>>>>            Case (sLine = "//AB-StoreTopEnd")
92487>>>>>>>>>                Move True to bFound
92488>>>>>>>>>                Case Break
92489>>>>>>>>>
92489>>>>>>>>>            Case (sLine = "//AB-PanelStoreTopStart")
92492>>>>>>>>>                Move True to bFound
92493>>>>>>>>>                Case Break
92494>>>>>>>>>
92494>>>>>>>>>            Case (sLine = "//AB-PanelStoreTopEnd")
92497>>>>>>>>>                Move True to bFound
92498>>>>>>>>>                Case Break
92499>>>>>>>>>
92499>>>>>>>>>            Case (sLine = "//AB-PanelStoreStart")
92502>>>>>>>>>                Move True to bFound
92503>>>>>>>>>                Case Break
92504>>>>>>>>>
92504>>>>>>>>>            Case (sLine = "//AB-PanelStoreEnd")
92507>>>>>>>>>                Move True to bFound
92508>>>>>>>>>                Case Break
92509>>>>>>>>>
92509>>>>>>>>>            Case (sLine = "//AB-ClientStoreTopStart")
92512>>>>>>>>>                Move True to bFound
92513>>>>>>>>>                Case Break
92514>>>>>>>>>
92514>>>>>>>>>            Case (sLine = "//AB-ClientStoreTopEnd")
92517>>>>>>>>>                Move True to bFound
92518>>>>>>>>>                Case Break
92519>>>>>>>>>
92519>>>>>>>>>            Case (sLine = "//AB-ClientStoreStart")
92522>>>>>>>>>                Move True to bFound
92523>>>>>>>>>                Case Break
92524>>>>>>>>>
92524>>>>>>>>>            Case (sLine = "//AB-ClientStoreEnd")
92527>>>>>>>>>                Move True to bFound
92528>>>>>>>>>                Case Break
92529>>>>>>>>>
92529>>>>>>>>>            Case (sLine = "//AB-DDOStart")
92532>>>>>>>>>                Move True to bFound
92533>>>>>>>>>                Case Break
92534>>>>>>>>>
92534>>>>>>>>>            Case (sLine = "//AB-DDOEnd")
92537>>>>>>>>>                Move True to bFound
92538>>>>>>>>>                Case Break
92539>>>>>>>>>
92539>>>>>>>>>            Case (Left(sLine, 6) = "//AB/ ")
92542>>>>>>>>>                Move True to bFound
92543>>>>>>>>>                Case Break
92544>>>>>>>>>
92544>>>>>>>>>            Case (sLine = "//AB-MenuPackage")
92547>>>>>>>>>                Move True to bFound
92548>>>>>>>>>                Case Break
92549>>>>>>>>>
92549>>>>>>>>>            Case (sLine = "//AB-End")
92552>>>>>>>>>                Move True to bFound
92553>>>>>>>>>                Case Break
92554>>>>>>>>>
92554>>>>>>>>>            Case (sLine = "//AB-ToolbarPackage")
92557>>>>>>>>>                Move True to bFound
92558>>>>>>>>>                Case Break
92559>>>>>>>>>
92559>>>>>>>>>            Case (sLine = "//AB-ViewStart")
92562>>>>>>>>>                Move True to bFound
92563>>>>>>>>>                Case Break
92564>>>>>>>>>
92564>>>>>>>>>            Case (sLine = "//AB-ViewEnd")
92567>>>>>>>>>                Move True to bFound
92568>>>>>>>>>                Case Break
92569>>>>>>>>>
92569>>>>>>>>>            Case (sLine = "//AB-StatusBarPackage")
92572>>>>>>>>>                Move True to bFound
92573>>>>>>>>>                Case Break
92574>>>>>>>>>
92574>>>>>>>>>            Case (sLine = "//IDE-FileType=ftApplication")
92577>>>>>>>>>                Move True to bFound
92578>>>>>>>>>                Case Break
92579>>>>>>>>>
92579>>>>>>>>>        Case End
92579>>>>>>>>>
92579>>>>>>>>>        Function_Return bFound
92580>>>>>>>>>    End_Function
92581>>>>>>>>>
92581>>>>>>>>>    // To remove hardcoded MS Sans Serif fonts if present.
92581>>>>>>>>>    Function RemoveSansSerif String sLine Returns Boolean
92583>>>>>>>>>        String sTest
92583>>>>>>>>>        Boolean bWriteLine
92583>>>>>>>>>
92583>>>>>>>>>        Move False to bWriteLine
92584>>>>>>>>>        Move (Trim(sLine)) to sTest
92585>>>>>>>>>        Move (Lowercase(sTest)) to sTest
92586>>>>>>>>>        Move (Replaces(" ", sTest, ""))  to sTest
92587>>>>>>>>>        Move (Replaces("'", sTest, "*")) to sTest
92588>>>>>>>>>        Move (Replaces('"', sTest, "*")) to sTest
92589>>>>>>>>>        If (sTest contains 'settypefaceto*mssansserif*') Begin
92591>>>>>>>>>            Move True to bWriteLine
92592>>>>>>>>>        End
92592>>>>>>>>>>
92592>>>>>>>>>        Function_Return bWriteLine
92593>>>>>>>>>    End_Function
92594>>>>>>>>>
92594>>>>>>>>>    // Removes Studio generated comments:
92594>>>>>>>>>    //               "// fires when the button is clicked"
92594>>>>>>>>>    //               "//OnChange is called on every changed character
92594>>>>>>>>>    //               "// Visual DataFlex 14.0 Client Size Adjuster     
92594>>>>>>>>>    //               "// Visual DataFlex 14.0 Migration Utility,"
92594>>>>>>>>>    //               ...and so on 
92594>>>>>>>>>    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
92596>>>>>>>>>        String sText sComment
92596>>>>>>>>>        Boolean bFound bChanged
92596>>>>>>>>>        
92596>>>>>>>>>        Move False to bChanged
92597>>>>>>>>>        Move sLine to sText
92598>>>>>>>>>        Get IsCommentLine sText to bFound
92599>>>>>>>>>        If (bFound = False) Begin
92601>>>>>>>>>            Function_Return False
92602>>>>>>>>>        End                      
92602>>>>>>>>>>
92602>>>>>>>>>        
92602>>>>>>>>>        Move "fires when the button is clicked" to sComment   
92603>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92604>>>>>>>>>        If (bFound = True) Begin
92606>>>>>>>>>            Move "" to sLine  
92607>>>>>>>>>            Function_Return True
92608>>>>>>>>>        End
92608>>>>>>>>>>
92608>>>>>>>>>
92608>>>>>>>>>        Move "onchange is called on every changed character" to sComment
92609>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92610>>>>>>>>>        If (bFound = True) Begin
92612>>>>>>>>>            Move "" to sLine  
92613>>>>>>>>>            Function_Return True
92614>>>>>>>>>        End
92614>>>>>>>>>>
92614>>>>>>>>>        
92614>>>>>>>>>        Move "visual dataflex 14.0 client size adjuster" to sComment
92615>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92616>>>>>>>>>        If (bFound = True) Begin
92618>>>>>>>>>            Move "" to sLine  
92619>>>>>>>>>            Function_Return True
92620>>>>>>>>>        End             
92620>>>>>>>>>>
92620>>>>>>>>>        
92620>>>>>>>>>        Move "visual dataflex 14.0 migration utility," to sComment
92621>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92622>>>>>>>>>        If (bFound = True) Begin
92624>>>>>>>>>            Move "" to sLine  
92625>>>>>>>>>            Function_Return True
92626>>>>>>>>>        End             
92626>>>>>>>>>>
92626>>>>>>>>>        
92626>>>>>>>>>        Move "If you set Current_radio you must set this after the" to sComment
92627>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92628>>>>>>>>>        If (bFound = True) Begin
92630>>>>>>>>>            Move "" to sLine  
92631>>>>>>>>>            Function_Return True
92632>>>>>>>>>        End
92632>>>>>>>>>>
92632>>>>>>>>>        
92632>>>>>>>>>        Move "radio objects have been created AND after Notify_select_State has been" to sComment
92633>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92634>>>>>>>>>        If (bFound = True) Begin
92636>>>>>>>>>            Move "" to sLine  
92637>>>>>>>>>            Function_Return True
92638>>>>>>>>>        End
92638>>>>>>>>>>
92638>>>>>>>>>
92638>>>>>>>>>        Move "created. i.e. Set in bottom-code at end!!" to sComment
92639>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
92640>>>>>>>>>        If (bFound = True) Begin
92642>>>>>>>>>            Move "" to sLine  
92643>>>>>>>>>            Function_Return True
92644>>>>>>>>>        End
92644>>>>>>>>>>
92644>>>>>>>>>        
92644>>>>>>>>>        Function_Return bChanged
92645>>>>>>>>>    End_Function
92646>>>>>>>>>    
92646>>>>>>>>>    // Remove trailing spaces if present.
92646>>>>>>>>>    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
92648>>>>>>>>>        Integer iBefore iAfter
92648>>>>>>>>>        Boolean bChanged
92648>>>>>>>>>
92648>>>>>>>>>        Move (Length(sLine))     to iBefore
92649>>>>>>>>>        Move (RTrim(sLine))      to sLine
92650>>>>>>>>>        Move (Length(sLine))     to iAfter
92651>>>>>>>>>        Move (iBefore <> iAfter) to bChanged
92652>>>>>>>>>
92652>>>>>>>>>        Function_Return bChanged
92653>>>>>>>>>    End_Function  
92654>>>>>>>>>    
92654>>>>>>>>>    Procedure ResetProjectObjectStructureProperties
92656>>>>>>>>>        String[] asObjectNames
92657>>>>>>>>>        Set pbProjectObjectStructureStart to False 
92658>>>>>>>>>        Set pbProjectObjectStructureEnd   to False
92659>>>>>>>>>        Set pbRegisterAllObjectsStart     to False    
92660>>>>>>>>>        Set pbRegisterAllObjectsEnd       to False
92661>>>>>>>>>        Set pasObjectNames                to asObjectNames
92662>>>>>>>>>    End_Procedure
92663>>>>>>>>>
92663>>>>>>>>>    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
92665>>>>>>>>>        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
92665>>>>>>>>>        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
92665>>>>>>>>>        Move False to bWriteLine
92666>>>>>>>>>        String[] asObjectNames
92667>>>>>>>>>        
92667>>>>>>>>>        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
92668>>>>>>>>>        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd   
92669>>>>>>>>>        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
92670>>>>>>>>>        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
92671>>>>>>>>>        Get pasObjectNames                to asObjectNames
92672>>>>>>>>>        
92672>>>>>>>>>        If (bRegisterAllObjectsEnd = False) Begin
92674>>>>>>>>>            If (bRegisterAllObjectsStart = False) Begin
92676>>>>>>>>>                Get IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
92677>>>>>>>>>                Set pbRegisterAllObjectsStart       to bRegisterAllObjectsStart
92678>>>>>>>>>            End
92678>>>>>>>>>>
92678>>>>>>>>>            If (bRegisterAllObjectsStart = True) Begin
92680>>>>>>>>>                Get IsRegisterObjectInArray sLine asObjectNames to bWriteLine
92681>>>>>>>>>                Move False to bProjectObjectStructureStart
92682>>>>>>>>>                Set           pbProjectObjectStructureStart to False
92683>>>>>>>>>            End
92683>>>>>>>>>>
92683>>>>>>>>>            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
92685>>>>>>>>>                Get IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
92686>>>>>>>>>                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
92687>>>>>>>>>            End
92687>>>>>>>>>>
92687>>>>>>>>>            If (bProjectObjectStructureStart = True) Begin
92689>>>>>>>>>                Get IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
92690>>>>>>>>>            End
92690>>>>>>>>>>
92690>>>>>>>>>            Get IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
92691>>>>>>>>>            If (bRegisterAllObjectsEnd = True) Begin
92693>>>>>>>>>                Send ResetProjectObjectStructureProperties
92694>>>>>>>>>                // This means that we won't bother with the rest of the file.
92694>>>>>>>>>                Set pbRegisterAllObjectsEnd to True
92695>>>>>>>>>            End                                           
92695>>>>>>>>>>
92695>>>>>>>>>        End
92695>>>>>>>>>>
92695>>>>>>>>>        Function_Return bWriteLine
92696>>>>>>>>>    End_Function
92697>>>>>>>>>    
92697>>>>>>>>>    // The former passed parameters; eSplitBy and iTabSize has been made into
92697>>>>>>>>>    // class properties. That way we can have a uniform calling interface to all functions.
92697>>>>>>>>>    // The two user selected values can be found in Sysfile.
92697>>>>>>>>>    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
92699>>>>>>>>>        Boolean bStop bChanged
92699>>>>>>>>>        Integer iIndent eSplitBy iTabSize iID
92699>>>>>>>>>        String  sText
92699>>>>>>>>>        
92699>>>>>>>>>        // We need to get a second parameter; the tab-size:
92699>>>>>>>>>        Move FunctionsA.ID to iID
92700>>>>>>>>>        Clear FunctionsA
92701>>>>>>>>>        Move CS_EditorReIndent to FunctionsA.Function_Name
92702>>>>>>>>>        Find eq FunctionsA by Index.5
92703>>>>>>>>>>
92703>>>>>>>>>        If (Found = False) Begin
92705>>>>>>>>>            Send UserError ("Could not find function:" * CS_EditorReIndent)
92706>>>>>>>>>            Function_Return False
92707>>>>>>>>>        End                      
92707>>>>>>>>>>
92707>>>>>>>>>        Else Begin
92708>>>>>>>>>            Move (Trim(FunctionsA.Parameter)) to iTabSize
92709>>>>>>>>>            // Reset record buffert:
92709>>>>>>>>>            Move iID to FunctionsA.ID
92710>>>>>>>>>            Find Eq FunctionsA by Index.1
92711>>>>>>>>>>
92711>>>>>>>>>        End
92711>>>>>>>>>>
92711>>>>>>>>>        
92711>>>>>>>>>        Move False to bChanged
92712>>>>>>>>>        Move sParameter to eSplitBy
92713>>>>>>>>>        
92713>>>>>>>>>        Move (LTrim(sLine))     to sText
92714>>>>>>>>>        Move (Pos(sText,sLine) - 1) to iIndent
92715>>>>>>>>>        Move (Left(sText, 3))   to sText
92716>>>>>>>>>        Move (Lowercase(sText)) to sText
92717>>>>>>>>>        If (sText = (Lowercase(CS_If) + " ")) Begin
92719>>>>>>>>>            Get IsLineEndSemiColonOrBegin sLine to bStop
92720>>>>>>>>>            If (bStop = False) Begin
92722>>>>>>>>>                // It's one of those single line if statements, break it up
92722>>>>>>>>>                Move (Lowercase(sLine)) to sText
92723>>>>>>>>>                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
92724>>>>>>>>>            End
92724>>>>>>>>>>
92724>>>>>>>>>        End
92724>>>>>>>>>>
92724>>>>>>>>>        Else Begin
92725>>>>>>>>>            Move (LTrim(sLine))     to sText
92726>>>>>>>>>            Move (Left(sText, 5))   to sText
92727>>>>>>>>>            Move (Lowercase(sText)) to sText
92728>>>>>>>>>            If (sText = (Lowercase(CS_Else) + " ")) Begin
92730>>>>>>>>>                Get IsLineEndSemiColonOrBegin sLine to bStop
92731>>>>>>>>>                If (bStop = False) Begin
92733>>>>>>>>>                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
92734>>>>>>>>>                End
92734>>>>>>>>>>
92734>>>>>>>>>            End
92734>>>>>>>>>>
92734>>>>>>>>>        End
92734>>>>>>>>>>
92734>>>>>>>>>        Function_Return bChanged
92735>>>>>>>>>    End_Function
92736>>>>>>>>>
92736>>>>>>>>>    // ToDo: *** FULL SOURCE FILE FUNCTIONS ***
92736>>>>>>>>>    //
92736>>>>>>>>>    // Counts total number of source lines for the passed file name.
92736>>>>>>>>>    // It does _not_ count empty or comment lines. 
92736>>>>>>>>>    // it does _not_ count COM proxy class files generated by the Studio for COM/ActiveX components.
92736>>>>>>>>>    Function CountNumberOfLines String sFullSourceFileName String sParameter Returns Integer
92738>>>>>>>>>        Integer iLines iChannel 
92738>>>>>>>>>        String sLine     
92738>>>>>>>>>        Boolean bExists bBlank bIsCOM
92738>>>>>>>>>        
92738>>>>>>>>>        File_Exist sFullSourceFileName bExists
92739>>>>>>>>>        If (bExists = False) Begin
92741>>>>>>>>>            Send UserError ("Couldn't find file:" * String(sFullSourceFileName) * "No source lines added to counter for this file.")
92742>>>>>>>>>            Function_Return 0
92743>>>>>>>>>        End                  
92743>>>>>>>>>>
92743>>>>>>>>>
92743>>>>>>>>>        Get IsDataFlexCOMProxyClassesFile sFullSourceFileName to bIsCOM
92744>>>>>>>>>        If (bIsCOM = True) Begin
92746>>>>>>>>>            Function_Return 0
92747>>>>>>>>>        End
92747>>>>>>>>>>
92747>>>>>>>>>        
92747>>>>>>>>>        Get Seq_New_Channel to iChannel
92748>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
92750>>>>>>>>>            Send UserError "No Channel Available for Process: Procedure 'CountNumberOfLines'"
92751>>>>>>>>>            Function_Return 0
92752>>>>>>>>>        End
92752>>>>>>>>>>
92752>>>>>>>>>
92752>>>>>>>>>        Move 0 to iLines
92753>>>>>>>>>        Direct_Input channel iChannel sFullSourceFileName
92755>>>>>>>>>        While (SeqEof = False)
92759>>>>>>>>>            Readln channel iChannel sLine 
92761>>>>>>>>>            Get IsCommentLineOrBlank sLine to bBlank
92762>>>>>>>>>            If (bBlank = False) Begin
92764>>>>>>>>>                Increment iLines
92765>>>>>>>>>            End
92765>>>>>>>>>>
92765>>>>>>>>>        Loop
92766>>>>>>>>>>
92766>>>>>>>>>        Close_Input channel iChannel
92768>>>>>>>>>        Send Seq_Release_Channel iChannel
92769>>>>>>>>>        
92769>>>>>>>>>        Function_Return iLines
92770>>>>>>>>>    End_Function
92771>>>>>>>>>
92771>>>>>>>>>    // Pass the whole source file as a string array
92771>>>>>>>>>    // Removes all unusad locally defined (in Procedures & Functions) for the
92771>>>>>>>>>    // passed string array. Returns number of removed unused local variables.
92771>>>>>>>>>    Function RemoveUnusedLocals String[] ByRef asSourceFile String sParameter Returns Integer
92773>>>>>>>>>        Handle ho                               
92773>>>>>>>>>        Integer iRetval
92773>>>>>>>>>        Get phoRemoveUnusedLocals to ho
92774>>>>>>>>>        If (ho = 0) Begin
92776>>>>>>>>>            Send UserError "phoRemoveUnusedLocals = 0"
92777>>>>>>>>>            Function_Return 0
92778>>>>>>>>>        End                                                
92778>>>>>>>>>>
92778>>>>>>>>>        Get MainProcedure of ho asSourceFile to iRetval
92779>>>>>>>>>//        If (iRetval > 1) Begin
92779>>>>>>>>>//            Reread SysFile
92779>>>>>>>>>//                Add iRetval to SysFile.iCountUnusedLocals
92779>>>>>>>>>//                SaveRecord SysFile
92779>>>>>>>>>//            Unlock
92779>>>>>>>>>//        End
92779>>>>>>>>>
92779>>>>>>>>>        Function_Return iRetval
92780>>>>>>>>>    End_Function                                                          
92781>>>>>>>>>    
92781>>>>>>>>>    // Pass the whole source file as a string array.
92781>>>>>>>>>    // Removes  consecutive empty blank lines if more than piMaxNoOfEmptyLines.
92781>>>>>>>>>    // Returns the passed string array but with removed duplicated empty lines.
92781>>>>>>>>>    Function RemoveMultipleBlankLines String[] ByRef asSourceFile String sParameter Returns Integer
92783>>>>>>>>>        String[] asSourceFileOut
92784>>>>>>>>>        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines 
92784>>>>>>>>>        String sLine
92784>>>>>>>>>        Boolean bImageStart bImageEnd bMakeImageTest
92784>>>>>>>>>
92784>>>>>>>>>        Move False to bImageStart
92785>>>>>>>>>        Move False to bImageEnd
92786>>>>>>>>>        Move True  to bMakeImageTest
92787>>>>>>>>>        Move 0 to iCurrentNoOfEmptyLines                                           
92788>>>>>>>>>        Move sParameter to iMaxNoOfEmptyLines
92789>>>>>>>>>        
92789>>>>>>>>>        Move (SizeOfArray(asSourceFile)) to iSize
92790>>>>>>>>>        Decrement iSize
92791>>>>>>>>>
92791>>>>>>>>>        For iCount from 0 to iSize
92797>>>>>>>>>>
92797>>>>>>>>>            Move (Trim(asSourceFile[iCount])) to sLine
92798>>>>>>>>>
92798>>>>>>>>>            If (bMakeImageTest = True) Begin
92800>>>>>>>>>                If (bImageStart = False and bImageEnd = False) Begin
92802>>>>>>>>>                    Get IsImagePageStartOrEnd sLine True to bImageStart
92803>>>>>>>>>                End
92803>>>>>>>>>>
92803>>>>>>>>>            End
92803>>>>>>>>>>
92803>>>>>>>>>
92803>>>>>>>>>            If (bImageStart = False and bImageEnd = False) Begin
92805>>>>>>>>>                If (sLine = "") Begin
92807>>>>>>>>>                    Increment iCurrentNoOfEmptyLines
92808>>>>>>>>>                End
92808>>>>>>>>>>
92808>>>>>>>>>                Else Begin
92809>>>>>>>>>                    Move 0 to iCurrentNoOfEmptyLines
92810>>>>>>>>>                End
92810>>>>>>>>>>
92810>>>>>>>>>            End
92810>>>>>>>>>>
92810>>>>>>>>>            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
92812>>>>>>>>>                Move asSourceFile[iCount] to asSourceFileOut[SizeOfArray(asSourceFileOut)]
92813>>>>>>>>>            End
92813>>>>>>>>>>
92813>>>>>>>>>
92813>>>>>>>>>            If (bMakeImageTest = True) Begin
92815>>>>>>>>>                If (bImageStart = True) Begin
92817>>>>>>>>>                    Get IsImagePageStartOrEnd sLine False to bImageEnd
92818>>>>>>>>>                    If (bImageEnd = True) Begin
92820>>>>>>>>>                        Move False to bImageStart
92821>>>>>>>>>                        Move False to bImageEnd
92822>>>>>>>>>                        Move False to bMakeImageTest
92823>>>>>>>>>                    End
92823>>>>>>>>>>
92823>>>>>>>>>                End
92823>>>>>>>>>>
92823>>>>>>>>>            End
92823>>>>>>>>>>
92823>>>>>>>>>        Loop
92824>>>>>>>>>>
92824>>>>>>>>>
92824>>>>>>>>>        Move (SizeOfArray(asSourceFile) - SizeOfArray(asSourceFileOut)) to iEmptyLines
92825>>>>>>>>>        Move asSourceFileOut to asSourceFile
92826>>>>>>>>>
92826>>>>>>>>>        Function_Return iEmptyLines
92827>>>>>>>>>    End_Function    
92828>>>>>>>>>    
92828>>>>>>>>>    Function RestylelDDOs String[] ByRef asSourceFile String sParameter Returns Integer
92830>>>>>>>>>//        String sFileFilter sHomePath
92830>>>>>>>>>//        Handle ho 
92830>>>>>>>>>        Integer iRetval                  
92830>>>>>>>>>//        tRefactorSettings RefactorSettings
92830>>>>>>>>>//        tsSearchResult[] asAllSourceFiles
92830>>>>>>>>>//        
92830>>>>>>>>>//        // ToDo: This needs to be available for the unit tester as well.
92830>>>>>>>>>//        Get phoDDOReStyler to ho
92830>>>>>>>>>//        If (ho = 0) Begin
92830>>>>>>>>>//            Send UserError "phoDDORestyler = 0"
92830>>>>>>>>>//            Function_Return 0
92830>>>>>>>>>//        End
92830>>>>>>>>>//        
92830>>>>>>>>>//        Get psHomePath of ghoApplication to sHomePath 
92830>>>>>>>>>//        Get pRefactorSettings to RefactorSettings
92830>>>>>>>>>//        Get AllSourceFiles of ghoApplication RefactorSettings.asFolderNames RefactorSettings.sFileFilter to asAllSourceFiles
92830>>>>>>>>>//        
92830>>>>>>>>>//        Set psHomePath of ho to sHomePath
92830>>>>>>>>>//        Set peDDOStyle of ho to RefactorSettings.eDDOStyle
92830>>>>>>>>>//        Set pasAllSourceFiles of ho to asAllSourceFiles
92830>>>>>>>>>//        
92830>>>>>>>>>//        Get MainDDORestyler of ho to iRetval 
92830>>>>>>>>>        Function_Return iRetval
92831>>>>>>>>>    End_Function
92832>>>>>>>>>    
92832>>>>>>>>>    // ToDo: *** EDITOR FUNCTIONS ***   
92832>>>>>>>>>    //
92832>>>>>>>>>    // Wrapper functions for the cScintillaEdit editor
92832>>>>>>>>>    // Note that a full visible instantiation of the cScintillaEdit class
92832>>>>>>>>>    // should be used for usage, and the phoEditor property for that
92832>>>>>>>>>    // object _must_ be set to that editor object id.   
92832>>>>>>>>>    //
92832>>>>>>>>>    Function EditorNormalizeCase String[] ByRef asSourceFile String sParameter Returns Integer
92834>>>>>>>>>        Handle hoEditor                                       
92834>>>>>>>>>        Integer iRetval
92834>>>>>>>>>        Boolean bErr
92834>>>>>>>>>        
92834>>>>>>>>>        Get phoEditor to hoEditor
92835>>>>>>>>>        If (hoEditor = 0) Begin
92837>>>>>>>>>            Send UserError "phoEditor = 0 (Function: EditorNormalizeCase)"
92838>>>>>>>>>            Function_Return 0
92839>>>>>>>>>        End
92839>>>>>>>>>>
92839>>>>>>>>>        Send RefactorNormalizeCase of hoEditor 
92840>>>>>>>>>        If (Err = True) Begin
92842>>>>>>>>>            Move 0 to iRetval
92843>>>>>>>>>        End                  
92843>>>>>>>>>>
92843>>>>>>>>>        Else Begin
92844>>>>>>>>>            Move 1 to iRetval
92845>>>>>>>>>        End
92845>>>>>>>>>>
92845>>>>>>>>>        Move bErr to Err
92846>>>>>>>>>        Function_Return iRetval
92847>>>>>>>>>    End_Function
92848>>>>>>>>>
92848>>>>>>>>>    Function EditorReIndent String[] ByRef asSourceFile String sParameter Returns Integer
92850>>>>>>>>>        Handle hoEditor                                       
92850>>>>>>>>>        Integer iRetval 
92850>>>>>>>>>        Boolean bErr
92850>>>>>>>>>        
92850>>>>>>>>>        Move Err to bErr
92851>>>>>>>>>        Move False to Err
92852>>>>>>>>>        Get phoEditor to hoEditor
92853>>>>>>>>>        If (hoEditor = 0) Begin
92855>>>>>>>>>            Send UserError "phoEditor = 0 (Function: EditorReIndent)"
92856>>>>>>>>>            Function_Return 0
92857>>>>>>>>>        End                                            
92857>>>>>>>>>>
92857>>>>>>>>>        Set piTabSize of hoEditor to sParameter
92858>>>>>>>>>        Send RefactorReIndent of hoEditor
92859>>>>>>>>>        If (Err = True) Begin
92861>>>>>>>>>            Move 0 to iRetval
92862>>>>>>>>>        End                  
92862>>>>>>>>>>
92862>>>>>>>>>        Else Begin
92863>>>>>>>>>            Move 1 to iRetval
92864>>>>>>>>>        End
92864>>>>>>>>>>
92864>>>>>>>>>        Move bErr to Err
92865>>>>>>>>>        Function_Return iRetval
92866>>>>>>>>>    End_Function
92867>>>>>>>>>
92867>>>>>>>>>    Function EditorDropSelf String[] ByRef asSourceFile String sParameter Returns Integer
92869>>>>>>>>>        Handle hoEditor
92869>>>>>>>>>        Integer iRetval
92869>>>>>>>>>        Boolean bErr
92869>>>>>>>>>        
92869>>>>>>>>>        Get phoEditor to hoEditor
92870>>>>>>>>>        If (hoEditor = 0) Begin
92872>>>>>>>>>            Send UserError "phoEditor = 0 (Function: EditorDropSelf)"
92873>>>>>>>>>            Function_Return 0
92874>>>>>>>>>        End                  
92874>>>>>>>>>>
92874>>>>>>>>>        Send RefactorDropSelf of hoEditor
92875>>>>>>>>>        Else Begin
92876>>>>>>>>>            Move 1 to iRetval
92877>>>>>>>>>        End
92877>>>>>>>>>>
92877>>>>>>>>>        Move bErr to Err
92878>>>>>>>>>        Function_Return iRetval
92879>>>>>>>>>    End_Function
92880>>>>>>>>>
92880>>>>>>>>>
92880>>>>>>>>>    // ToDo: *** REPORT FUNCTIONS ***
92880>>>>>>>>>    //                        
92880>>>>>>>>>    Function ReportUnusedSourceFiles String[] ByRef asSourceFiles String sParameter Returns Integer
92882>>>>>>>>>        Handle ho                 
92882>>>>>>>>>        String sFilter                       
92882>>>>>>>>>        Integer iRetval
92882>>>>>>>>>        tRefactorSettings RefactorSettings
92882>>>>>>>>>        tRefactorSettings RefactorSettings
92882>>>>>>>>>        
92882>>>>>>>>>        Get phoReportUnusedSourceFiles to ho
92883>>>>>>>>>        If (ho = 0) Begin
92885>>>>>>>>>            Function_Return 0
92886>>>>>>>>>        End                              
92886>>>>>>>>>>
92886>>>>>>>>>        
92886>>>>>>>>>        Get pRefactorSettings to RefactorSettings
92887>>>>>>>>>        Set psFileFilter  of ho to RefactorSettings.sFileFilter
92888>>>>>>>>>//        Set pasAllFolders of ho to RefactorSettings.asFolderNames
92888>>>>>>>>>// ToDo: *** Change interface!!! ***
92888>>>>>>>>>//        Set pasSourceFiles of ho to asSourceFiles 
92888>>>>>>>>>Function_Return 0
92889>>>>>>>>>        
92889>>>>>>>>>        Send DoProcess    of ho  
92890>>>>>>>>>        
92890>>>>>>>>>        Get piNoOfUnusedSourceFiles of ho to iRetval
92891>>>>>>>>>        Reread SysFile
92895>>>>>>>>>            Move iRetval to SysFile.iCountUnusedSourceFiles
92896>>>>>>>>>            SaveRecord SysFile
92897>>>>>>>>>        Unlock
92898>>>>>>>>>>
92898>>>>>>>>>        Function_Return iRetval
92899>>>>>>>>>    End_Function
92900>>>>>>>>>    
92900>>>>>>>>>    // ToDo: *** HELPER FUNCTIONS ***   
92900>>>>>>>>>
92900>>>>>>>>>    // Note: It must only be the code part of a source line that is passed here.
92900>>>>>>>>>    //       Use the Tokenizer helper function first.
92900>>>>>>>>>    Function _AddExpressionParenthesis String ByRef sLine Returns Boolean
92902>>>>>>>>>        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
92902>>>>>>>>>        Boolean bFound bChanged bStartOperators bIfCommand bSecondCommand bWhile
92902>>>>>>>>>        Integer iPos iPos2
92902>>>>>>>>>        
92902>>>>>>>>>        Move sLine to sText    
92903>>>>>>>>>        Move sLine to sOrg             
92904>>>>>>>>>        // Do nothing if a Constrain command.
92904>>>>>>>>>        Get HasCommand sText (CS_Constrain + " ") to bFound
92905>>>>>>>>>        If (bFound = True) Begin
92907>>>>>>>>>            Function_Return False
92908>>>>>>>>>        End
92908>>>>>>>>>>
92908>>>>>>>>>
92908>>>>>>>>>        Move "" to sStart
92909>>>>>>>>>        Move "" to sLast                                  
92910>>>>>>>>>        Get ExpressionExtractor sText CI_LeftExpression to sExpression
92911>>>>>>>>>        If (Trim(sExpression) = "") Begin
92913>>>>>>>>>            Get ExpressionExtractor sText CI_OfExpression to sExpression
92914>>>>>>>>>            If (Trim(sExpression) = "") Begin
92916>>>>>>>>>                Get ExpressionExtractor sText CI_ToTexpression to sExpression
92917>>>>>>>>>            End
92917>>>>>>>>>>
92917>>>>>>>>>        End
92917>>>>>>>>>>
92917>>>>>>>>>        If (Trim(sExpression) = "") Begin
92919>>>>>>>>>            Function_Return False
92920>>>>>>>>>        End 
92920>>>>>>>>>>
92920>>>>>>>>>        Move (Pos(sExpression, sText)) to iPos
92921>>>>>>>>>        If (iPos <> 0) Begin
92923>>>>>>>>>            Move (Left(sLine, (iPos - 1))) to sStart
92924>>>>>>>>>            If (sStart <> "") Begin
92926>>>>>>>>>                Move (Replace(sStart, sLine, "")) to sText
92927>>>>>>>>>                Move (Replace(sExpression, sText, "")) to sLast
92928>>>>>>>>>            End
92928>>>>>>>>>>
92928>>>>>>>>>        End
92928>>>>>>>>>>
92928>>>>>>>>>//        If (sStart <> "") Begin
92928>>>>>>>>>//            Move sStart to sLine
92928>>>>>>>>>//        End                     
92928>>>>>>>>>        If (sExpression <> "") Begin               
92930>>>>>>>>>            Move sExpression to sText
92931>>>>>>>>>            Send StripConcatenatingSpaces (&sExpression)  
92932>>>>>>>>>            Move (Trim(sExpression)) to sExpression 
92933>>>>>>>>>            Get HasDoubleExpression sExpression to bFound
92934>>>>>>>>>            Move (Left(sExpression, 1)) to sChar
92935>>>>>>>>>            If (sChar <> "(" or bFound = True) Begin
92937>>>>>>>>>                Move ("(" + sExpression + ")") to sExpression
92938>>>>>>>>>            End                      
92938>>>>>>>>>>
92938>>>>>>>>>            If (sText = sLine) Begin
92940>>>>>>>>>                Move sExpression to sLine
92941>>>>>>>>>            End
92941>>>>>>>>>>
92941>>>>>>>>>        End                                                    
92941>>>>>>>>>>
92941>>>>>>>>>        If (sStart <> "" or sLast <> "") Begin    
92943>>>>>>>>>            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
92944>>>>>>>>>        End
92944>>>>>>>>>>
92944>>>>>>>>>        
92944>>>>>>>>>        Function_Return (sLine <> sOrg)
92945>>>>>>>>>    End_Function   
92946>>>>>>>>>                   
92946>>>>>>>>>    // Helper message for _ClearFirstCompoundBeforeMethod
92946>>>>>>>>>    Procedure _WipeUntilPosition Integer iPos String ByRef sLine
92948>>>>>>>>>        Integer iChar
92948>>>>>>>>>        If (iPos > 0) Begin
92950>>>>>>>>>            For iChar from 1 to (iPos - 1)
92956>>>>>>>>>>
92956>>>>>>>>>                Move (Overstrike(" ", sLine, iChar)) to sLine
92957>>>>>>>>>            Loop
92958>>>>>>>>>>
92958>>>>>>>>>        End
92958>>>>>>>>>>
92958>>>>>>>>>    End_Procedure
92959>>>>>>>>>
92959>>>>>>>>>    // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
92959>>>>>>>>>    // send/get/set as the first string and that complicates our detection.
92959>>>>>>>>>    // What this does is simply overwrite everything with spaces before our methods if
92959>>>>>>>>>    // we have such a compound statement.
92959>>>>>>>>>    // The variable sLine is not always lowercase.
92959>>>>>>>>>    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
92961>>>>>>>>>        Integer iPos
92961>>>>>>>>>        String  sLtrimLine sOrgLine
92961>>>>>>>>>        Boolean bChanged
92961>>>>>>>>>        
92961>>>>>>>>>        Move sLine to sOrgLine
92962>>>>>>>>>        Move (Lowercase(LTrim(sLine))) to sLTrimLine
92963>>>>>>>>>        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
92965>>>>>>>>>            // A line that starts with an "if" or "else" can still call a method
92965>>>>>>>>>            Move (Pos("send ", Lowercase(sLine))) to iPos
92966>>>>>>>>>            If (iPos = 0) Begin
92968>>>>>>>>>                Move (Pos("get ", Lowercase(sLine))) to iPos
92969>>>>>>>>>            End
92969>>>>>>>>>>
92969>>>>>>>>>            If (iPos = 0) Begin
92971>>>>>>>>>                Move (Pos("set ", Lowercase(sLine))) to iPos
92972>>>>>>>>>            End
92972>>>>>>>>>>
92972>>>>>>>>>            Send _WipeUntilPosition iPos (&sLine)
92973>>>>>>>>>        End       
92973>>>>>>>>>>
92973>>>>>>>>>        
92973>>>>>>>>>        Function_Return (sLine <> sOrgLine)
92974>>>>>>>>>    End_Function
92975>>>>>>>>>  
92975>>>>>>>>>    // Helper function to return expressions from a source line;
92975>>>>>>>>>    //   eExpressionMode can be any of; CI_LeftExpression, CI_OfExpression or CI_ToTexpression.
92975>>>>>>>>>    // As expressions only expressions in rounded parenthesis "()" are acted upon and returned (Not square brackets)
92975>>>>>>>>>    Function ExpressionExtractor String sLine Integer eExpressionMode Returns String
92977>>>>>>>>>        String sExpression sText sChar sStart sLast sCommand 
92977>>>>>>>>>        String[] asTokens asTokensLower
92979>>>>>>>>>        Integer iStart iEnd iLength iLeftParantheses iRightParantheses iPos iCount iSize
92979>>>>>>>>>        Boolean bFound bOperator bParenthesis 
92979>>>>>>>>>        tOperatorsInfo OperatorsInfo
92979>>>>>>>>>        tOperatorsInfo OperatorsInfo
92979>>>>>>>>>        tCodeComponents CodeComponents
92979>>>>>>>>>        tCodeComponents CodeComponents
92979>>>>>>>>>        
92979>>>>>>>>>        Get _RemoveEndComment sLine to sText
92980>>>>>>>>>        Move (Trim(sText)) to sText
92981>>>>>>>>>        Get _OverstrikeStrings sText to sText
92982>>>>>>>>>        Move (Pos("(", sText)) to iStart
92983>>>>>>>>>        Move (Pos(")", sText)) to iEnd 
92984>>>>>>>>>        Get IsLogicalOperators sText to OperatorsInfo
92985>>>>>>>>>        If (OperatorsInfo.bIsOperator = False and (iStart < 1 or iEnd < 1) ) Begin
92987>>>>>>>>>            Function_Return sLine
92988>>>>>>>>>        End
92988>>>>>>>>>>
92988>>>>>>>>>        
92988>>>>>>>>>        Move (Trim(sLine)) to sText
92989>>>>>>>>>//        Get StrSplitToArray sLine " " to asTokens
92989>>>>>>>>>//        Move (Lowercase(sLine)) to sText
92989>>>>>>>>>//        Get StrSplitToArray sText " " to asTokensLower
92989>>>>>>>>>        
92989>>>>>>>>>        Case Begin
92989>>>>>>>>>            Case (eExpressionMode = CI_LeftExpression) 
92991>>>>>>>>>                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
92992>>>>>>>>>                If (iPos > 0) Begin
92994>>>>>>>>>                    Move (Left(sText, (iPos -1))) to sText
92995>>>>>>>>>                End                                       
92995>>>>>>>>>>
92995>>>>>>>>>                Else Begin
92996>>>>>>>>>                    Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
92997>>>>>>>>>                End                                            
92997>>>>>>>>>>
92997>>>>>>>>>                If (iPos > 0) Begin
92999>>>>>>>>>                    Move (Left(sText, (iPos - 1))) to sText // XXX
93000>>>>>>>>>                End
93000>>>>>>>>>>
93000>>>>>>>>>                Case Break   
93001>>>>>>>>>            
93001>>>>>>>>>            // ToDo: This does not belong here:!!!    
93001>>>>>>>>>            // Move to Tokenizer???
93001>>>>>>>>>            Case (eExpressionMode = CI_CommandExpression)
93004>>>>>>>>>                Get Tokenizer sLine to CodeComponents 
93005>>>>>>>>>                If (Lowercase(CodeComponents.sLeftCommand) = Lowercase(CS_If)) Begin
93007>>>>>>>>>                    Move (lowercase(sLine) contains (" " + Lowercase(CS_Move) + " ")) to bFound
93008>>>>>>>>>                    If (bFound) Begin
93010>>>>>>>>>                        
93010>>>>>>>>>                    End
93010>>>>>>>>>>
93010>>>>>>>>>                End
93010>>>>>>>>>>
93010>>>>>>>>>                Case Break
93011>>>>>>>>>            Case (eExpressionMode = CI_OfExpression)
93014>>>>>>>>>                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
93015>>>>>>>>>                If (iPos > 0) Begin
93017>>>>>>>>>                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText
93018>>>>>>>>>                    Move (Pos((" " + Lowercase(CS_to) + " "), Lowercase(sText))) to iPos
93019>>>>>>>>>                    If (iPos > 0) Begin
93021>>>>>>>>>                        Move (Left(sText, (iPos -1))) to sText
93022>>>>>>>>>                    End
93022>>>>>>>>>>
93022>>>>>>>>>                    Get IsOperators sText to bOperator
93023>>>>>>>>>                    Move (sText contains "(" and sText contains ")") to bParenthesis
93024>>>>>>>>>                    If (bOperator = True or bParenthesis = True) Begin
93026>>>>>>>>>                        Move (Trim(sText)) to sExpression
93027>>>>>>>>>                    End
93027>>>>>>>>>>
93027>>>>>>>>>                End
93027>>>>>>>>>>
93027>>>>>>>>>                Else Begin
93028>>>>>>>>>                    Move "" to sText // Nothing to do.
93029>>>>>>>>>                End
93029>>>>>>>>>>
93029>>>>>>>>>                Case Break
93030>>>>>>>>>            Case (eExpressionMode = CI_ToTexpression)
93033>>>>>>>>>                Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
93034>>>>>>>>>                If (iPos > 0) Begin
93036>>>>>>>>>                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText 
93037>>>>>>>>>                    Get IsOperators sText to bOperator
93038>>>>>>>>>                    Move (sText contains "(" and sText contains ")") to bParenthesis
93039>>>>>>>>>                    If (bOperator = True or bParenthesis = True) Begin
93041>>>>>>>>>                        Move (Trim(sText)) to sExpression
93042>>>>>>>>>                    End
93042>>>>>>>>>>
93042>>>>>>>>>                End 
93042>>>>>>>>>>
93042>>>>>>>>>                Else Begin
93043>>>>>>>>>                    Move "" to sText // Nothing to do.
93044>>>>>>>>>                End
93044>>>>>>>>>>
93044>>>>>>>>>                Case Break 
93045>>>>>>>>>            Case Else
93045>>>>>>>>>                Move "" to sText
93046>>>>>>>>>        Case End
93046>>>>>>>>>        
93046>>>>>>>>>//        Move "" to sExpression  
93046>>>>>>>>>//        Move 0  to iLeftParantheses
93046>>>>>>>>>//        Move 0  to iRightParantheses
93046>>>>>>>>>        If (sText <> "") Begin
93048>>>>>>>>>//            Move (Pos("(", sText)) to iStart
93048>>>>>>>>>//            Move (Pos(")", sText)) to iEnd
93048>>>>>>>>>//            Get IsOperators sText to bOperator
93048>>>>>>>>>//            If (bOperator = False and (iStart = 0 or iEnd = 0) ) Begin
93048>>>>>>>>>//                Function_Return ""
93048>>>>>>>>>//            End 
93048>>>>>>>>>//
93048>>>>>>>>>            Get IsLogicalOperators sText to OperatorsInfo
93049>>>>>>>>>            If (OperatorsInfo.bIsOperator = True) Begin
93051>>>>>>>>>                Get _ExtractParenthesisExpression sText to sExpression
93052>>>>>>>>>                If (sExpression = "") Begin
93054>>>>>>>>>                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to sExpression
93055>>>>>>>>>                End
93055>>>>>>>>>>
93055>>>>>>>>>            End
93055>>>>>>>>>>
93055>>>>>>>>>//            Move (Length(sText)) to iLength
93055>>>>>>>>>//            For iCount from iStart to iLength
93055>>>>>>>>>//                Move (Mid(sText, 1, iCount)) to sChar
93055>>>>>>>>>//                If (sChar = "(" or sChar = ")") Begin
93055>>>>>>>>>//                    Add (sChar = "(") to iLeftParantheses
93055>>>>>>>>>//                    Add (sChar = ")") to iRightParantheses
93055>>>>>>>>>//                    Move iCount to iPos
93055>>>>>>>>>//                End                        
93055>>>>>>>>>//                If (sChar = " " and iLeftParantheses = iRightParantheses) Break
93055>>>>>>>>>//            Loop
93055>>>>>>>>>//            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
93055>>>>>>>>>//            If (sExpression = "" and (bOperator = True) and (iStart <> 1 or iEnd <> 0)) Begin
93055>>>>>>>>>//                Get _RemoveFirstWord sText to sText
93055>>>>>>>>>//                Get IsOperators sText to bOperator
93055>>>>>>>>>//                If (bOperator = True) Begin
93055>>>>>>>>>//                    Move sText to sExpression 
93055>>>>>>>>>//                    Move sLine to sText
93055>>>>>>>>>//                End
93055>>>>>>>>>//            End
93055>>>>>>>>>        End
93055>>>>>>>>>>
93055>>>>>>>>>        
93055>>>>>>>>>        // Check if we have an expression like; "If (psWrkSpcOpenFileName(ghoApplication)) <> "" Send WrkSpcDoForAllFiles"
93055>>>>>>>>>        //   which in case we need to add "<>" to the sExpression.
93055>>>>>>>>>        Get _RemoveLeft sExpression (&sText) to bFound
93056>>>>>>>>>        If (bFound = True) Begin
93058>>>>>>>>>            Get IsLogicalOperators sText to OperatorsInfo
93059>>>>>>>>>            If (OperatorsInfo.bIsOperator = True) Begin
93061>>>>>>>>>                Move (Pos(sExpression, sLine)) to iPos
93062>>>>>>>>>                If (iPos <> "") Begin        
93064>>>>>>>>>                    Move (Left(sLine, (iPos - 1))) to sStart
93065>>>>>>>>>                    Move (Replace(sStart, sLine, "")) to sLine
93066>>>>>>>>>                    Move (Trim(sText)) to sText 
93067>>>>>>>>>                    Move (Length(sText)) to iLength    
93068>>>>>>>>>                    Get _OverstrikeStrings sText to sText
93069>>>>>>>>>                    Get _FindFirstCommand sText to iPos
93070>>>>>>>>>                    If (iPos <> 0) Begin
93072>>>>>>>>>                        Move (Replace(sExpression, sLine, "")) to sLine 
93073>>>>>>>>>                        Move (Trim(sLine)) to sLine
93074>>>>>>>>>                        Move (Left(sLine, (iPos -1))) to sStart 
93075>>>>>>>>>                        Move (Trim(sStart)) to sStart
93076>>>>>>>>>                        If (sStart <> "") Begin
93078>>>>>>>>>                            Move (Right(sStart, 1)) to sChar
93079>>>>>>>>>                            If (sChar <> ")") Begin
93081>>>>>>>>>                                Move (String(sExpression) * String(sStart)) to sExpression    
93082>>>>>>>>>                            End
93082>>>>>>>>>>
93082>>>>>>>>>                        End
93082>>>>>>>>>>
93082>>>>>>>>>                    End
93082>>>>>>>>>>
93082>>>>>>>>>                End
93082>>>>>>>>>>
93082>>>>>>>>>            End
93082>>>>>>>>>>
93082>>>>>>>>>        End
93082>>>>>>>>>>
93082>>>>>>>>>        Function_Return sExpression
93083>>>>>>>>>    End_Function
93084>>>>>>>>>
93084>>>>>>>>>    // Rturns the first expression that exist in the passed sText string and that is within parenthesis,
93084>>>>>>>>>    // else it returns a blank string.
93084>>>>>>>>>    Function _ExtractParenthesisExpression String sText Returns String
93086>>>>>>>>>        String sExpression sChar
93086>>>>>>>>>        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
93086>>>>>>>>>        tOperatorsInfo OperatorInfo
93086>>>>>>>>>        tOperatorsInfo OperatorInfo
93086>>>>>>>>>        
93086>>>>>>>>>        Move "" to sExpression
93087>>>>>>>>>        Move 0  to iLeftParantheses
93088>>>>>>>>>        Move 0  to iRightParantheses
93089>>>>>>>>>        
93089>>>>>>>>>        If (sText <> "") Begin
93091>>>>>>>>>            Move (Pos("(", sText)) to iStart
93092>>>>>>>>>            Move (RightPos(")", sText)) to iEnd
93093>>>>>>>>>            Get IsLogicalOperators sText to OperatorInfo
93094>>>>>>>>>            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
93096>>>>>>>>>                Function_Return ""
93097>>>>>>>>>            End 
93097>>>>>>>>>>
93097>>>>>>>>>
93097>>>>>>>>>            Move (Length(sText)) to iLength
93098>>>>>>>>>            For iCount from iStart to iLength
93104>>>>>>>>>>
93104>>>>>>>>>                Move (Mid(sText, 1, iCount)) to sChar
93105>>>>>>>>>                If (sChar = "(" or sChar = ")") Begin
93107>>>>>>>>>                    Add (sChar = "(") to iLeftParantheses
93108>>>>>>>>>                    Add (sChar = ")") to iRightParantheses
93109>>>>>>>>>                    Move iCount to iPos
93110>>>>>>>>>                End                        
93110>>>>>>>>>>
93110>>>>>>>>>                If (iLeftParantheses = iRightParantheses) Break
93113>>>>>>>>>            Loop
93114>>>>>>>>>>
93114>>>>>>>>>            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
93115>>>>>>>>>        End
93115>>>>>>>>>>
93115>>>>>>>>>        Function_Return sExpression
93116>>>>>>>>>    End_Function
93117>>>>>>>>>
93117>>>>>>>>>    Function _ExtractExpressionNoParenthesis String sLine tOperatorsInfo OperatorsInfo Returns String
93119>>>>>>>>>        String sText sExpression sChar sFirst sLast sLeft sRight
93119>>>>>>>>>        Integer iCount iLength iSize iStart iEnd iPos
93119>>>>>>>>>        Boolean bStop bSpace bParanthesis
93119>>>>>>>>>        
93119>>>>>>>>>        // ToDo: Is this really correct in all cases?
93119>>>>>>>>>        If (OperatorsInfo.bIsOperator = False) Begin
93121>>>>>>>>>            Function_Return ""
93122>>>>>>>>>        End
93122>>>>>>>>>>
93122>>>>>>>>>        Move "" to sExpression  
93123>>>>>>>>>//        Move (Pos(Lowercase(" " + CS_As + " "), sLine)) to iPos 
93123>>>>>>>>>//        If (iPos <> 0) Begin
93123>>>>>>>>>//            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sText    
93123>>>>>>>>>//        End
93123>>>>>>>>>//        Else Begin
93123>>>>>>>>>            Move (OperatorsInfo.iPos - Length(OperatorsInfo.sOperator)) to iStart
93124>>>>>>>>>            Move (Left(sLine, (iStart + 1))) to sText
93125>>>>>>>>>//        End
93125>>>>>>>>>        Send StripConcatenatingSpaces (&sText)
93126>>>>>>>>>        Get _OverstrikeStrings (&sText) to sText
93127>>>>>>>>>        Move (Length(sText)) to iLength   
93128>>>>>>>>>        Move (Pos(Lowercase(" " + CS_As + " "), sText)) to iPos 
93129>>>>>>>>>        If (iPos <> 0) Begin
93131>>>>>>>>>            Move (Mid(sText, Length(sText), (iPos + 3))) to sText    
93132>>>>>>>>>        End
93132>>>>>>>>>>
93132>>>>>>>>>        
93132>>>>>>>>>        // First get the left part of the expression:
93132>>>>>>>>>        Move iLength to iStart
93133>>>>>>>>>        Move 0 to iCount
93134>>>>>>>>>        Move False to bSpace
93135>>>>>>>>>        Move (Pos(")", sText)) to bParanthesis
93136>>>>>>>>>        Repeat
93136>>>>>>>>>>
93136>>>>>>>>>            Move (Mid(sText, 1, (iStart - iCount))) to sChar
93137>>>>>>>>>            If (bParanthesis = True) Begin
93139>>>>>>>>>                Move ((iCount >= iLength) or (bSpace = True and sChar <> " ")) to bStop
93140>>>>>>>>>            End 
93140>>>>>>>>>>
93140>>>>>>>>>            Else Begin
93141>>>>>>>>>                Move (sChar = " " and bSpace) to bStop
93142>>>>>>>>>            End
93142>>>>>>>>>>
93142>>>>>>>>>            If (bSpace = False) Begin
93144>>>>>>>>>                Move (sChar = " ") to bSpace
93145>>>>>>>>>            End
93145>>>>>>>>>>
93145>>>>>>>>>            Increment iCount
93146>>>>>>>>>        Until (bStop = True)
93148>>>>>>>>>        Move (Left(sText, (iStart - iCount + 1))) to sFirst  
93149>>>>>>>>>        Move (Replace(sFirst, sText, "")) to sLeft
93150>>>>>>>>>        If (sLeft = "") Begin
93152>>>>>>>>>            Move sText to sLeft
93153>>>>>>>>>        End
93153>>>>>>>>>>
93153>>>>>>>>>        Move (Length(sLine)) to iLength   
93154>>>>>>>>>        
93154>>>>>>>>>        // Then get the right part of the expression:
93154>>>>>>>>>        Move 1 to iCount   
93155>>>>>>>>>        Move False to bSpace
93156>>>>>>>>>        Move (OperatorsInfo.iPos) to iStart
93157>>>>>>>>>        Move (Mid(sLine, iLength, (iStart + 1))) to sText  
93158>>>>>>>>>        Move (Length(sText)) to iLength
93159>>>>>>>>>        Move (Pos(")", sText)) to bParanthesis
93160>>>>>>>>>        Repeat
93160>>>>>>>>>>
93160>>>>>>>>>            Move (Mid(sLine, 1, (iStart + iCount))) to sChar
93161>>>>>>>>>            If (bParanthesis = False) Begin
93163>>>>>>>>>                Move ((iCount >= iLength) or (bSpace = True and sChar = " ")) to bStop
93164>>>>>>>>>            End 
93164>>>>>>>>>>
93164>>>>>>>>>            Else Begin
93165>>>>>>>>>                Move (sChar = " " and bSpace) to bStop
93166>>>>>>>>>            End
93166>>>>>>>>>>
93166>>>>>>>>>            If (bSpace = False) Begin
93168>>>>>>>>>                Move (sChar = " ") to bSpace
93169>>>>>>>>>            End
93169>>>>>>>>>>
93169>>>>>>>>>            Increment iCount
93170>>>>>>>>>        Until (bStop = True)
93172>>>>>>>>>                                                     
93172>>>>>>>>>        Move (Left(sText, (iCount - 1))) to sRight
93173>>>>>>>>>        Move (String(sLeft) * String(sRight)) to sExpression
93174>>>>>>>>>        
93174>>>>>>>>>        Function_Return (Trim(sExpression))
93175>>>>>>>>>    End_Function
93176>>>>>>>>>
93176>>>>>>>>>    // Syntax:
93176>>>>>>>>>    //    Get Tokenizer sTest to "tCodeComponents"
93176>>>>>>>>>    // Breaks up a source line into these tokens;
93176>>>>>>>>>    //     tCodeComponents
93176>>>>>>>>>    //  a) sIndentation = spaces or tab-characters to the left (start) of the source code line
93176>>>>>>>>>    //  b) sLineStartIndicator = [Found] or other indicators within brackets placed at beginning of line.   
93176>>>>>>>>>    //  c) sLeftCommand = "Move, Calc" etc. 
93176>>>>>>>>>    // ToDo: Should we add a Second left command param???
93176>>>>>>>>>    //  d) sCode = the source code itself (or left hand side code if a "of" or "to" or right comment)
93176>>>>>>>>>    //  e) sOfStatement = " of xxx"
93176>>>>>>>>>    //  f) sToStatement = " to xxx" 
93176>>>>>>>>>    //  g) sRightComment = any comment placed at the end of the line.
93176>>>>>>>>>    //
93176>>>>>>>>>    // It does not Rtrim the end-of-line comment.  Should it??
93176>>>>>>>>>    // Note: If the line is a compound statement (one that spans over several lines),
93176>>>>>>>>>    //       aka it contains a ";", the function will NOT try to break up the source code line.
93176>>>>>>>>>    //       Instead it returns a struct with empty members, except for the 
93176>>>>>>>>>    //       bHasEndSemiColon member that will be true.
93176>>>>>>>>>    Function Tokenizer String sLine Returns tCodeComponents
93178>>>>>>>>>        tCodeComponents LineComponents
93178>>>>>>>>>        tCodeComponents LineComponents
93178>>>>>>>>>        String sText sChar sCommand
93178>>>>>>>>>        Boolean bEndComment bStop bOfStatement bToStatement bIndicator bFound bMoveCommand
93178>>>>>>>>>        Integer iPos iStart iEnd
93178>>>>>>>>>                                                
93178>>>>>>>>>        Move "" to LineComponents.sIndentation
93179>>>>>>>>>        Move "" to LineComponents.sLineStartIndicator  
93180>>>>>>>>>        Move "" to LineComponents.sLeftCommand
93181>>>>>>>>>        Move "" to LineComponents.sCode
93182>>>>>>>>>        Move "" to LineComponents.sOfStatement
93183>>>>>>>>>        Move "" to LineComponents.sToStatement
93184>>>>>>>>>        Move "" to LineComponents.sRightComment
93185>>>>>>>>>        Move False to LineComponents.bHasEndSemiColon
93186>>>>>>>>>        
93186>>>>>>>>>        Get IsCommentLineOrBlank sLine to bStop
93187>>>>>>>>>        If (bStop = True) Begin
93189>>>>>>>>>            Function_Return LineComponents
93190>>>>>>>>>        End  
93190>>>>>>>>>>
93190>>>>>>>>>        
93190>>>>>>>>>        Get IsLineEndSemiColon sLine to bStop
93191>>>>>>>>>        If (bStop = True) Begin
93193>>>>>>>>>            Move True to LineComponents.bHasEndSemiColon
93194>>>>>>>>>            Function_Return LineComponents
93195>>>>>>>>>        End  
93195>>>>>>>>>>
93195>>>>>>>>>        
93195>>>>>>>>>        // Get the indentation part
93195>>>>>>>>>        Move (Ltrim(sLine)) to sText
93196>>>>>>>>>        If (sText <> sLine) Begin
93198>>>>>>>>>            Move (Replace(sText, sLine, "")) to LineComponents.sIndentation
93199>>>>>>>>>            Move (Replace(LineComponents.sIndentation, sLine, "")) to sLine
93200>>>>>>>>>        End     
93200>>>>>>>>>>
93200>>>>>>>>>        
93200>>>>>>>>>        Get IsKeywordInLine (CS_Indicate + "|") sLine to bFound
93201>>>>>>>>>        If (bFound = True) Begin
93203>>>>>>>>>            Move True to LineComponents.bHasIndicateCommand
93204>>>>>>>>>        End                                                
93204>>>>>>>>>>
93204>>>>>>>>>        
93204>>>>>>>>>        Get IsIndicatorStatement sLine to bIndicator
93205>>>>>>>>>        If (bIndicator = True) Begin
93207>>>>>>>>>            // Get the start indicator part
93207>>>>>>>>>            Move (Ltrim(sLine)) to sText
93208>>>>>>>>>            Move (Left(sText, 1)) to sChar
93209>>>>>>>>>            If (sChar = "[") Begin
93211>>>>>>>>>                Move (Pos("]", sText)) to iPos
93212>>>>>>>>>                Move (Left(sText, (iPos -1))) to LineComponents.sLineStartIndicator
93213>>>>>>>>>                Move (Left(LineComponents.sLineStartIndicator, 1)) to sChar
93214>>>>>>>>>                If (sChar = "[") Begin
93216>>>>>>>>>                    Move (Replace("[", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
93217>>>>>>>>>                End
93217>>>>>>>>>>
93217>>>>>>>>>                Move (Right(LineComponents.sLineStartIndicator, 1)) to sChar
93218>>>>>>>>>                If (sChar = "]") Begin
93220>>>>>>>>>                    Move (Replace("]", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
93221>>>>>>>>>                End
93221>>>>>>>>>>
93221>>>>>>>>>            End
93221>>>>>>>>>>
93221>>>>>>>>>            
93221>>>>>>>>>            // Get the End indicator part
93221>>>>>>>>>            Move (Trim(sLine)) to sText    
93222>>>>>>>>>            Get _RemoveEndComment sText to sText
93223>>>>>>>>>            Move (Right(sText, 1)) to sChar
93224>>>>>>>>>            If (sChar = "]") Begin  
93226>>>>>>>>>                Move (Pos(Lowercase(" to "), Lowercase(sText))) to iPos
93227>>>>>>>>>                If (iPos > 0) Begin
93229>>>>>>>>>                    Move (Mid(sText, Length(sText), (iPos + 4))) to sText
93230>>>>>>>>>                End
93230>>>>>>>>>>
93230>>>>>>>>>                // We need to check that this isn't an array/struct value.
93230>>>>>>>>>                Move (Pos(" [", sText)) to iStart
93231>>>>>>>>>                If (iStart > 0) Begin
93233>>>>>>>>>                    Move (Pos("]", sText)) to iEnd
93234>>>>>>>>>                    Move (Mid(sText, Length(sText), (iStart +1))) to LineComponents.sLineEndIndicator
93235>>>>>>>>>                    Move (Left(LineComponents.sLineEndIndicator, 1)) to sChar
93236>>>>>>>>>                    If (sChar = "[") Begin
93238>>>>>>>>>                        Move (Replace("[", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
93239>>>>>>>>>                    End
93239>>>>>>>>>>
93239>>>>>>>>>                    Move (Right(LineComponents.sLineEndIndicator, 1)) to sChar
93240>>>>>>>>>                    If (sChar = "]") Begin
93242>>>>>>>>>                        Move (Replace("]", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
93243>>>>>>>>>                    End
93243>>>>>>>>>>
93243>>>>>>>>>                End
93243>>>>>>>>>>
93243>>>>>>>>>            End
93243>>>>>>>>>>
93243>>>>>>>>>        End
93243>>>>>>>>>>
93243>>>>>>>>>
93243>>>>>>>>>        Get IsMoveCommand sText to bMoveCommand
93244>>>>>>>>>        If (bMoveCommand = True) Begin
93246>>>>>>>>>            Move (Pos(" ", sText)) to iPos
93247>>>>>>>>>            Move (Left(sText, (iPos - 1))) to sCommand
93248>>>>>>>>>            Move sCommand to LineComponents.sLeftCommand
93249>>>>>>>>>        End                                             
93249>>>>>>>>>>
93249>>>>>>>>>        
93249>>>>>>>>>        // Get the end comment part
93249>>>>>>>>>        Move sLine to sText
93250>>>>>>>>>        Get _RemoveComments (&sText) to bEndComment
93251>>>>>>>>>        If (bEndComment = True) Begin
93253>>>>>>>>>            Move (Replace(sText, sLine, "")) to LineComponents.sRightComment
93254>>>>>>>>>            Move (Replace(LineComponents.sRightComment, sLine, "")) to sLine
93255>>>>>>>>>        End     
93255>>>>>>>>>>
93255>>>>>>>>>        
93255>>>>>>>>>        // Get the " to " part
93255>>>>>>>>>        Move (Lowercase(sLine)) to sText
93256>>>>>>>>>        Move (sText contains (" " + Lowercase(CS_To) + " ")) to bToStatement
93257>>>>>>>>>        If (bToStatement = True) Begin
93259>>>>>>>>>            Move (Pos((" " + Lowercase(CS_To) + " "), sText)) to iPos
93260>>>>>>>>>            Move (Mid(sLine, Length(sLine), (iPos +1))) to LineComponents.sToStatement
93261>>>>>>>>>            Move (Replace(LineComponents.sToStatement, sLine, "")) to sLine
93262>>>>>>>>>            Move (Replace((CS_To) + " ", LineComponents.sToStatement, "")) to LineComponents.sToStatement
93263>>>>>>>>>            Move (Trim(LineComponents.sToStatement)) to LineComponents.sToStatement
93264>>>>>>>>>        End
93264>>>>>>>>>>
93264>>>>>>>>>        
93264>>>>>>>>>        // Get the " of xxxx " part
93264>>>>>>>>>        Move (Lowercase(sLine)) to sText
93265>>>>>>>>>        Move (sText contains (" " + Lowercase(CS_Of) + " ")) to bOfStatement
93266>>>>>>>>>        If (bOfStatement = True) Begin
93268>>>>>>>>>            Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sLine))) to iPos
93269>>>>>>>>>            Move (Mid(sLine, (Length(sLine) -1), (iPos + Length(CS_Of) + 1))) to LineComponents.sOfStatement
93270>>>>>>>>>            Move (Left(sLine, (iPos - 1))) to sLine
93271>>>>>>>>>            Move (Trim(LineComponents.sOfStatement)) to LineComponents.sOfStatement
93272>>>>>>>>>        End    
93272>>>>>>>>>>
93272>>>>>>>>>        
93272>>>>>>>>>        // The reminder of the code line
93272>>>>>>>>>        Move (Trim(sLine)) to LineComponents.sCode
93273>>>>>>>>>                                      
93273>>>>>>>>>        Function_Return LineComponents
93274>>>>>>>>>    End_Function       
93275>>>>>>>>>    
93275>>>>>>>>>    // Helper function.
93275>>>>>>>>>    Function _BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
93277>>>>>>>>>        Boolean bChanged
93277>>>>>>>>>        Integer iPos
93277>>>>>>>>>        String  sLineIndent
93277>>>>>>>>>        String  sIndent
93277>>>>>>>>>        String  sLine1 sLine2
93277>>>>>>>>>        String  sText
93277>>>>>>>>>
93277>>>>>>>>>        Move False to bChanged
93278>>>>>>>>>        Move (Lowercase(sLine)) to sText
93279>>>>>>>>>        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
93280>>>>>>>>>        Move (Repeat(" ", iLineIndent)) to sLineIndent
93281>>>>>>>>>        Get _OverstrikeStrings sText to sText
93282>>>>>>>>>        Get _FindFirstCommand sText to iPos
93283>>>>>>>>>        If (iPos <> 0) Begin
93285>>>>>>>>>            Move True to bChanged
93286>>>>>>>>>            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
93288>>>>>>>>>                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
93289>>>>>>>>>            End
93289>>>>>>>>>>
93289>>>>>>>>>            Else If (eSplitBy = eSplitBySemiColumn) Begin
93292>>>>>>>>>                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
93293>>>>>>>>>            End
93293>>>>>>>>>>
93293>>>>>>>>>            Else If (eSplitBy = eSplitByBeginEnd) Begin
93296>>>>>>>>>                Move (Insert((" Begin" + CS_CRLF + sLineIndent + sIndent), sLine, iPos)) to sLine
93297>>>>>>>>>                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
93298>>>>>>>>>            End
93298>>>>>>>>>>
93298>>>>>>>>>
93298>>>>>>>>>            // Remove any spaces before the point on which we break the line
93298>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine1
93299>>>>>>>>>            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
93300>>>>>>>>>            Move (RTrim(sLine1)) to sLine1
93301>>>>>>>>>            Move (sLine1 + sLine2) to sLine
93302>>>>>>>>>        End
93302>>>>>>>>>>
93302>>>>>>>>>        Function_Return bChanged
93303>>>>>>>>>    End_Function
93304>>>>>>>>>
93304>>>>>>>>>    // Takes a string like: [not Seqeof] Begin
93304>>>>>>>>>    // and returns struct as: True, True, "(not(Seqeof))" and "Begin",
93304>>>>>>>>>    //   _but_ it doesn't do anything with a line that starts with a [Select] stetement;
93304>>>>>>>>>    //   "[Select] Indicate Select as Windowindex Eq Fieldindex"
93304>>>>>>>>>    // Note: The brackets _must_ be at the start of code line.
93304>>>>>>>>>    //       bHasBracket denotes that the line starts with a "[", bHasNot denotes that the expression has a "not" in it.
93304>>>>>>>>>    Function _ExtractIndicatorContent String sLine Returns tBooleanIndicator
93306>>>>>>>>>        Integer iPos                                             
93306>>>>>>>>>        String sText sChar sNot sBoolean sFirstWord sCommand sExpression
93306>>>>>>>>>        Boolean bRightSideIndicator bFound bIndicateWord
93306>>>>>>>>>        tBooleanIndicator BooleanIndicator  
93306>>>>>>>>>        tBooleanIndicator BooleanIndicator  
93306>>>>>>>>>        tOperatorsInfo OperatorsInfo
93306>>>>>>>>>        tOperatorsInfo OperatorsInfo
93306>>>>>>>>>        
93306>>>>>>>>>        Move False to BooleanIndicator.bHasBracket
93307>>>>>>>>>        Move False to BooleanIndicator.bHasNot
93308>>>>>>>>>        Move ""    to BooleanIndicator.sCode
93309>>>>>>>>>        Move ""    to BooleanIndicator.sExpression
93310>>>>>>>>>        
93310>>>>>>>>>        Get IsIndicatorStatement sLine to bFound
93311>>>>>>>>>        Move (Lowercase(sLine) contains Lowercase(CS_Indicate)) to bIndicateWord
93312>>>>>>>>>        If (bFound = False and bIndicateWord = False) Begin
93314>>>>>>>>>            Function_Return BooleanIndicator
93315>>>>>>>>>        End
93315>>>>>>>>>>
93315>>>>>>>>>        Move (Trim(sLine)) to sText 
93316>>>>>>>>>        Get _OverstrikeStrings sText to sText
93317>>>>>>>>>        Move (sText contains "[" and sText contains "]") to BooleanIndicator.bHasBracket  
93318>>>>>>>>>        
93318>>>>>>>>>        Move "" to sNot
93319>>>>>>>>>        Get _RetrieveFirstWord sText to sFirstWord
93320>>>>>>>>>        // Is the indicator placed on the right hand side of the command?
93320>>>>>>>>>        Move (Pos("[", sFirstWord) = 0) to bRightSideIndicator
93321>>>>>>>>>        If (bRightSideIndicator = True) Begin
93323>>>>>>>>>            Move (Pos("[", sText)) to iPos
93324>>>>>>>>>            Move (Mid(sText, Length(sText), iPos)) to sBoolean
93325>>>>>>>>>        End
93325>>>>>>>>>>
93325>>>>>>>>>        Else Begin
93326>>>>>>>>>            Move (Pos("]", sText)) to iPos
93327>>>>>>>>>            If (iPos <> 0) Begin
93329>>>>>>>>>                Move (Left(sText, iPos)) to sBoolean 
93330>>>>>>>>>                Move (Mid(sText, Length(sText), (iPos + 1))) to sFirstWord
93331>>>>>>>>>                Move sFirstWord to BooleanIndicator.sCode
93332>>>>>>>>>            End
93332>>>>>>>>>>
93332>>>>>>>>>        End
93332>>>>>>>>>>
93332>>>>>>>>>        Move (Trim(sFirstWord)) to sCommand
93333>>>>>>>>>        Move (Replaces("[", sBoolean, "")) to sBoolean
93334>>>>>>>>>        Move (Replaces("]", sBoolean, "")) to sBoolean
93335>>>>>>>>>        Move (Trim(sBoolean)) to sBoolean
93336>>>>>>>>>
93336>>>>>>>>>        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
93337>>>>>>>>>        If (iPos <> 0) Begin
93339>>>>>>>>>            Move (Mid(sBoolean, Length(sBoolean), (iPos + 4))) to sBoolean
93340>>>>>>>>>            Move (String(CS_Not)) to sNot
93341>>>>>>>>>        End                    
93341>>>>>>>>>>
93341>>>>>>>>>        If (sNot <> "") Begin
93343>>>>>>>>>            Move ("(" + String(sBoolean) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression 
93344>>>>>>>>>            Move True to BooleanIndicator.bHasNot
93345>>>>>>>>>        End 
93345>>>>>>>>>>
93345>>>>>>>>>        Else If (Lowercase(sBoolean) = Lowercase(CS_Finderr)) Begin
93348>>>>>>>>>            Move ("(" + CS_Found * " = " * CS_False + ")") to BooleanIndicator.sExpression
93349>>>>>>>>>        End
93349>>>>>>>>>>
93349>>>>>>>>>        Else Begin                
93350>>>>>>>>>            Get IsLogicalOperators sText to OperatorsInfo
93351>>>>>>>>>            If (OperatorsInfo.bIsOperator = True) Begin
93353>>>>>>>>>                Get _ExtractParenthesisExpression sText to BooleanIndicator.sExpression
93354>>>>>>>>>                If (BooleanIndicator.sExpression = "") Begin
93356>>>>>>>>>                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to BooleanIndicator.sExpression
93357>>>>>>>>>                End
93357>>>>>>>>>>
93357>>>>>>>>>//                Move True to BooleanIndicator.bHasNot 
93357>>>>>>>>>                Move sLine to sCommand
93358>>>>>>>>>            End
93358>>>>>>>>>>
93358>>>>>>>>>            Else Begin
93359>>>>>>>>>                Move ("(" + String(sBoolean) + ")") to BooleanIndicator.sExpression
93360>>>>>>>>>                Move False to BooleanIndicator.bHasNot
93361>>>>>>>>>            End
93361>>>>>>>>>>
93361>>>>>>>>>        End
93361>>>>>>>>>>
93361>>>>>>>>>        Move (Trim(sCommand)) to BooleanIndicator.sCode
93362>>>>>>>>>            
93362>>>>>>>>>        Function_Return BooleanIndicator
93363>>>>>>>>>    End_Function
93364>>>>>>>>>    
93364>>>>>>>>>    // Tries to find the first DataFlex command found in the passed string.
93364>>>>>>>>>    // Returns the starting pos of that same command (or 0 if not found).
93364>>>>>>>>>    Function _FindFirstCommand String sTest Returns Integer
93366>>>>>>>>>        Boolean bRemoved
93366>>>>>>>>>        Integer iCount iSize iPos iTest
93366>>>>>>>>>        String  sCommand
93366>>>>>>>>>        String[] asCommands
93367>>>>>>>>>
93367>>>>>>>>>        Move 0 to iPos
93368>>>>>>>>>        Move (" " + sTest) to sTest
93369>>>>>>>>>        Get _RemoveComments (&sTest) to bRemoved
93370>>>>>>>>>        Get paCommands to asCommands
93371>>>>>>>>>        Move (SizeOfArray(asCommands)) to iSize
93372>>>>>>>>>        If (iSize = 0) Begin
93374>>>>>>>>>            Send AddAllCommands
93375>>>>>>>>>            Get paCommands to asCommands
93376>>>>>>>>>            Move (SizeOfArray(asCommands)) to iSize        
93377>>>>>>>>>        End
93377>>>>>>>>>>
93377>>>>>>>>>        Decrement iSize
93378>>>>>>>>>        For iCount from 0 to iSize
93384>>>>>>>>>>
93384>>>>>>>>>            Move asCommands[iCount] to sCommand
93385>>>>>>>>>            Move (Pos(" " + Lowercase(sCommand), Lowercase(sTest))) to iTest // The command MUST start with a space and MIGHT end with a space.
93386>>>>>>>>>            If (iTest <> 0) Begin
93388>>>>>>>>>                If (iPos = 0) Begin
93390>>>>>>>>>                    Move iTest to iPos
93391>>>>>>>>>                End
93391>>>>>>>>>>
93391>>>>>>>>>                Else Begin
93392>>>>>>>>>                    If (iTest < iPos) Begin
93394>>>>>>>>>                        Move iTest to iPos
93395>>>>>>>>>                    End
93395>>>>>>>>>>
93395>>>>>>>>>                End
93395>>>>>>>>>>
93395>>>>>>>>>            End
93395>>>>>>>>>>
93395>>>>>>>>>        Loop              
93396>>>>>>>>>>
93396>>>>>>>>>        // We added a beginning " " at the top of this function, so adjust for that now.
93396>>>>>>>>>//        If (iPos = 1) Begin
93396>>>>>>>>>//            Move 0 to iPos
93396>>>>>>>>>//        End
93396>>>>>>>>>        Function_Return iPos
93397>>>>>>>>>    End_Function
93398>>>>>>>>>    
93398>>>>>>>>>    // Parses the method name from the string
93398>>>>>>>>>    Function _MethodName String sMethod Returns String
93400>>>>>>>>>        Integer iPos
93400>>>>>>>>>        Get _RemoveFirstWord sMethod to sMethod
93401>>>>>>>>>        Move (Right(sMethod, (Length(sMethod) - iPos))) to sMethod
93402>>>>>>>>>        If (Uppercase(Left(Trim(sMethod), 4)) = "SET ") Begin
93404>>>>>>>>>            Get _RemoveFirstWord sMethod to sMethod
93405>>>>>>>>>        End
93405>>>>>>>>>>
93405>>>>>>>>>        // Remove any trailing arguments
93405>>>>>>>>>        Move (Pos(" ", sMethod)) to iPos
93406>>>>>>>>>        Function_Return (Left(sMethod, (iPos - 1)))
93407>>>>>>>>>    End_Function
93408>>>>>>>>>
93408>>>>>>>>>    // For declarations like "string [] saAddress"
93408>>>>>>>>>    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
93410>>>>>>>>>        Boolean bChanged
93410>>>>>>>>>        String sText
93410>>>>>>>>>        Move sLine to sText
93411>>>>>>>>>        While (Pos(" [", sText) > 0)
93415>>>>>>>>>          Move (Replace(" [", sText, "[")) to sText
93416>>>>>>>>>        Loop                                       
93417>>>>>>>>>>
93417>>>>>>>>>        Move (sLine = sText) to bChanged
93418>>>>>>>>>        Function_Return bChanged
93419>>>>>>>>>    End_Function
93420>>>>>>>>>
93420>>>>>>>>>    //  This will pad out the strings in a line and overstrike them
93420>>>>>>>>>    //  with _ characters for a "string" and + characters for a 'string'
93420>>>>>>>>>    Function _OverstrikeStrings String sLine Returns String
93422>>>>>>>>>        Boolean bDoubleQuote bSingleQuote bChanged
93422>>>>>>>>>        Integer iChar iLength
93422>>>>>>>>>        String  sChar sText
93422>>>>>>>>>
93422>>>>>>>>>        Move False to bChanged 
93423>>>>>>>>>        Move sLine to sText
93424>>>>>>>>>        Move (Length(sText)) to iLength
93425>>>>>>>>>        For iChar from 1 to iLength
93431>>>>>>>>>>
93431>>>>>>>>>            Move (Mid(sText, 1, iChar)) to sChar
93432>>>>>>>>>            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
93434>>>>>>>>>                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
93435>>>>>>>>>                Move True to bChanged
93436>>>>>>>>>                Move " " to sChar
93437>>>>>>>>>            End
93437>>>>>>>>>>
93437>>>>>>>>>            If (bDoubleQuote and sChar= '"') Begin
93439>>>>>>>>>                Move (Overstrike("_", sText, iChar)) to sText
93440>>>>>>>>>                Move True to bChanged
93441>>>>>>>>>                Move "" to sChar
93442>>>>>>>>>                Move False to bDoubleQuote
93443>>>>>>>>>            End
93443>>>>>>>>>>
93443>>>>>>>>>            If (bSingleQuote and sChar = "'") Begin
93445>>>>>>>>>                Move (Overstrike("+", sText, iChar)) to sText
93446>>>>>>>>>                Move True to bChanged
93447>>>>>>>>>                Move "" to sChar
93448>>>>>>>>>                Move False to bSingleQuote
93449>>>>>>>>>            End
93449>>>>>>>>>>
93449>>>>>>>>>            If (bSingleQuote = False and sChar ='"') Begin
93451>>>>>>>>>                Move True to bDoubleQuote
93452>>>>>>>>>            End
93452>>>>>>>>>>
93452>>>>>>>>>            If (bDoubleQuote = False and sChar = "'") Begin
93454>>>>>>>>>                Move True to bSingleQuote
93455>>>>>>>>>            End
93455>>>>>>>>>>
93455>>>>>>>>>            If bDoubleQuote Begin
93457>>>>>>>>>                Move (Overstrike("_", sText, iChar)) to sText
93458>>>>>>>>>                Move True to bChanged
93459>>>>>>>>>            End
93459>>>>>>>>>>
93459>>>>>>>>>            Else If bSingleQuote Begin
93462>>>>>>>>>                Move (Overstrike("+", sText, iChar)) to sText
93463>>>>>>>>>                Move True to bChanged
93464>>>>>>>>>            End
93464>>>>>>>>>>
93464>>>>>>>>>        Loop
93465>>>>>>>>>>
93465>>>>>>>>>
93465>>>>>>>>>        If (bChanged = True) Begin
93467>>>>>>>>>            Move sText to sLine
93468>>>>>>>>>        End
93468>>>>>>>>>>
93468>>>>>>>>>        Function_Return sLine
93469>>>>>>>>>    End_Function
93470>>>>>>>>>
93470>>>>>>>>>    Function _RemoveComments String ByRef sLine Returns Boolean
93472>>>>>>>>>        Boolean bRemoved
93472>>>>>>>>>        Integer iPos
93472>>>>>>>>>
93472>>>>>>>>>        Move False to bRemoved
93473>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
93474>>>>>>>>>        If (iPos > 0) Begin
93476>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine
93477>>>>>>>>>            Move True to bRemoved
93478>>>>>>>>>        End
93478>>>>>>>>>>
93478>>>>>>>>>        Function_Return bRemoved
93479>>>>>>>>>    End_Function    
93480>>>>>>>>>
93480>>>>>>>>>    // Returns an end comment if exists. It also removes the end comment
93480>>>>>>>>>    // from the passed string.
93480>>>>>>>>>    Function _RemoveEndComment String sLine Returns String
93482>>>>>>>>>        Integer iPos
93482>>>>>>>>>        String sTest
93482>>>>>>>>>
93482>>>>>>>>>        Move (Trim(sLine)) to sTest
93483>>>>>>>>>        Move (Pos(CS_CommentSymbol, sTest)) to iPos
93484>>>>>>>>>        // Only remove comment if the line is not commented at the beginning.
93484>>>>>>>>>        If (iPos > 1) Begin
93486>>>>>>>>>            Move (Pos(CS_CommentSymbol, sLine)) to iPos
93487>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine
93488>>>>>>>>>        End
93488>>>>>>>>>>
93488>>>>>>>>>        Function_Return sLine
93489>>>>>>>>>    End_Function
93490>>>>>>>>>
93490>>>>>>>>>    // Removes the first word of any input string
93490>>>>>>>>>    // all up to the first space encountered
93490>>>>>>>>>    Function _RemoveFirstWord String sLine Returns String
93492>>>>>>>>>        Integer iPos
93492>>>>>>>>>        Boolean bChanged
93492>>>>>>>>>        Move (Trim(sLine)) to sLine
93493>>>>>>>>>        Get _NormalizeArrayNotation (&sLine) to bChanged
93494>>>>>>>>>        Move (Pos(" ", sLine)) to iPos
93495>>>>>>>>>        Function_Return (Right(sLine, (Length(sLine) - iPos)))
93496>>>>>>>>>    End_Function
93497>>>>>>>>>
93497>>>>>>>>>    // Returns the first word of any input string
93497>>>>>>>>>    // all up to the first space encountered
93497>>>>>>>>>    Function _RetrieveFirstWord String sLine Returns String
93499>>>>>>>>>        String sFirstWord
93499>>>>>>>>>        Boolean bChanged
93499>>>>>>>>>        Get _RemoveFirstWord sLine            to sFirstWord
93500>>>>>>>>>        Move (Replace(sFirstWord, sLine, "")) to sFirstWord
93501>>>>>>>>>        Move (Trim(sFirstWord))               to sFirstWord
93502>>>>>>>>>        Get _NormalizeArrayNotation (&sFirstWord) to bChanged
93503>>>>>>>>>        Function_Return sFirstWord
93504>>>>>>>>>    End_Function
93505>>>>>>>>>
93505>>>>>>>>>    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
93505>>>>>>>>>    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
93505>>>>>>>>>    // RemoveLeft("D", "ABC")                   -> "ABC"
93505>>>>>>>>>    // RemoveLeft("is ", "This is an example")  -> "an example"    
93505>>>>>>>>>    // Note: It it also looks within strings aka "This is a string"
93505>>>>>>>>>    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
93507>>>>>>>>>        Integer iPosStart iPosEnd 
93507>>>>>>>>>        String sText
93507>>>>>>>>>        
93507>>>>>>>>>        Move sHostString to sText
93508>>>>>>>>>        Move (Pos(sSubString, sText)) to iPosStart
93509>>>>>>>>>        Move (iPosStart + Length(sSubString) - 1) to iPosEnd
93510>>>>>>>>>
93510>>>>>>>>>        If (iPosStart) Begin                                
93512>>>>>>>>>            If (iPosEnd = Length(sText)) Begin
93514>>>>>>>>>                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
93515>>>>>>>>>            End 
93515>>>>>>>>>>
93515>>>>>>>>>            Else Begin
93516>>>>>>>>>                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
93517>>>>>>>>>            End
93517>>>>>>>>>>
93517>>>>>>>>>        End                                              
93517>>>>>>>>>>
93517>>>>>>>>>        
93517>>>>>>>>>        Function_Return (sHostString <> sText)
93518>>>>>>>>>    End_Function
93519>>>>>>>>>
93519>>>>>>>>>    // Helper function
93519>>>>>>>>>    Function _RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
93521>>>>>>>>>        Boolean bChanged
93521>>>>>>>>>        String sText
93521>>>>>>>>>        Integer iPos
93521>>>>>>>>>
93521>>>>>>>>>        Move False to bChanged
93522>>>>>>>>>        Move (LTrim(sLine))     to sText
93523>>>>>>>>>        Move (Left(sText, 9))   to sText
93524>>>>>>>>>        Move (Lowercase(sText)) to sText
93525>>>>>>>>>        If (sText = "property ") Begin
93527>>>>>>>>>            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
93528>>>>>>>>>            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
93529>>>>>>>>>            If (iPos = 0) Begin // if there's a tab char instead of a space then..
93531>>>>>>>>>                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
93532>>>>>>>>>            End
93532>>>>>>>>>>
93532>>>>>>>>>            If (iPos > 0) Begin
93534>>>>>>>>>                Move (Overstrike(Repeat(" ", Length(sPubPriv)), sLine, iPos + 1)) to sLine // skip first character, don't overwrite a tab with a space
93535>>>>>>>>>                Move True to bChanged
93536>>>>>>>>>            End
93536>>>>>>>>>>
93536>>>>>>>>>        End
93536>>>>>>>>>>
93536>>>>>>>>>        Function_Return bChanged
93537>>>>>>>>>    End_Function
93538>>>>>>>>>
93538>>>>>>>>>    // helper function for IsKeywordInLine, when a keyword is found in a string declaration
93538>>>>>>>>>    Function _RemoveStringsFromLine String sLine Returns String
93540>>>>>>>>>        Integer iLength iPos
93540>>>>>>>>>        Boolean bSep1 bSep2
93540>>>>>>>>>        String  sChar sSep1 sSep2 sReturn
93540>>>>>>>>>
93540>>>>>>>>>        Move False to bSep1
93541>>>>>>>>>        Move False to bSep2
93542>>>>>>>>>        Move "'" to sSep1
93543>>>>>>>>>        Move '"' to sSep2
93544>>>>>>>>>        Move ""  to sReturn
93545>>>>>>>>>        Move (Length(sLine)) to iLength
93546>>>>>>>>>
93546>>>>>>>>>        For iPos from 1 to iLength
93552>>>>>>>>>>
93552>>>>>>>>>            Move (Mid(sLine, 1, iPos)) to sChar
93553>>>>>>>>>            If (bSep1 = False and bSep2 = False) Begin
93555>>>>>>>>>                If (sChar = sSep1) Begin
93557>>>>>>>>>                    Move True to bSep1
93558>>>>>>>>>                End
93558>>>>>>>>>>
93558>>>>>>>>>                Else If (sChar = sSep2) Begin
93561>>>>>>>>>                    Move True to bSep2
93562>>>>>>>>>                End
93562>>>>>>>>>>
93562>>>>>>>>>                If (bSep1 = False and bSep2 = False) Begin
93564>>>>>>>>>                    Move (sReturn + sChar) to sReturn
93565>>>>>>>>>                End
93565>>>>>>>>>>
93565>>>>>>>>>            End
93565>>>>>>>>>>
93565>>>>>>>>>            Else Begin
93566>>>>>>>>>                If (bSep1) Begin
93568>>>>>>>>>                    If (sChar = sSep1) Begin
93570>>>>>>>>>                        Move False to bSep1
93571>>>>>>>>>                    End
93571>>>>>>>>>>
93571>>>>>>>>>                End
93571>>>>>>>>>>
93571>>>>>>>>>                Else If (bSep2) Begin
93574>>>>>>>>>                    If (sChar = sSep2) Begin
93576>>>>>>>>>                        Move False to bSep2
93577>>>>>>>>>                    End
93577>>>>>>>>>>
93577>>>>>>>>>                End
93577>>>>>>>>>>
93577>>>>>>>>>            End
93577>>>>>>>>>>
93577>>>>>>>>>        Loop
93578>>>>>>>>>>
93578>>>>>>>>>
93578>>>>>>>>>        Function_Return sReturn
93579>>>>>>>>>    End_Function
93580>>>>>>>>>
93580>>>>>>>>>    Function _SingleCommandSyntaxToFunction String ByRef sLine String sKeyWord Returns Boolean
93582>>>>>>>>>        Boolean bChanged bIsCommentOrBlank bFound bIfStatement bIsFirstKeyWord
93582>>>>>>>>>        tCodeComponents CodeComponents
93582>>>>>>>>>        tCodeComponents CodeComponents
93582>>>>>>>>>        String sText sLowerKeyWord sLowerCase sFirstWord sExpression
93582>>>>>>>>>        Integer iPos
93582>>>>>>>>>        
93582>>>>>>>>>        Move False to bChanged
93583>>>>>>>>>        Move False to bIsFirstKeyWord  
93584>>>>>>>>>        Move "" to sExpression
93585>>>>>>>>>        Move sLine to sText
93586>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
93587>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
93589>>>>>>>>>            Function_Return False
93590>>>>>>>>>        End      
93590>>>>>>>>>>
93590>>>>>>>>>        
93590>>>>>>>>>        Get HasCommand sText sKeyWord to bFound
93591>>>>>>>>>        If (bFound = False) Begin
93593>>>>>>>>>            Function_Return False
93594>>>>>>>>>        End
93594>>>>>>>>>>
93594>>>>>>>>>        
93594>>>>>>>>>        Get IsIfCommand sText to bIfStatement
93595>>>>>>>>>        Move (Lowercase(sKeyWord)) to sLowerKeyWord
93596>>>>>>>>>        If (bIfStatement = False) Begin
93598>>>>>>>>>            Get _RetrieveFirstWord sText to sFirstWord
93599>>>>>>>>>            If (Lowercase(sFirstWord) = Lowercase(sKeyWord)) Begin
93601>>>>>>>>>                Get _RemoveFirstWord sText to sText
93602>>>>>>>>>            End    
93602>>>>>>>>>>
93602>>>>>>>>>//            If (Lowercase(sFirstWord) <> sLowerKeyWord) Begin
93602>>>>>>>>>//                Function_Return False
93602>>>>>>>>>//            End
93602>>>>>>>>>        End
93602>>>>>>>>>>
93602>>>>>>>>>        If (bIfStatement = True) Begin
93604>>>>>>>>>            Get ExpressionExtractor sText CI_LeftExpression to sExpression  
93605>>>>>>>>>            If (Trim(sExpression) <> "") Begin
93607>>>>>>>>>                Move (Pos(sExpression, sText)) to iPos
93608>>>>>>>>>                Move (Mid(sText, Length(sText), (iPos + Length(sExpression)))) to sText
93609>>>>>>>>>                Move (Mid(sLine, Length(sLine), (iPos + Length(sExpression)))) to sLine
93610>>>>>>>>>            End
93610>>>>>>>>>>
93610>>>>>>>>>            // Do we still have the keyword in the line?
93610>>>>>>>>>            Get HasCommand sText sKeyWord to bFound
93611>>>>>>>>>            If (bFound = False) Begin   
93613>>>>>>>>>                Move (String(sExpression) + String(sLine)) to sLine 
93614>>>>>>>>>                If (bIfStatement = True) Begin
93616>>>>>>>>>                    Move (CS_If * String(sLine)) to sLine
93617>>>>>>>>>                End
93617>>>>>>>>>>
93617>>>>>>>>>                Function_Return False
93618>>>>>>>>>            End
93618>>>>>>>>>>
93618>>>>>>>>>        End
93618>>>>>>>>>>
93618>>>>>>>>>        
93618>>>>>>>>>//        Move (Pos(sLowerKeyWord, Lowercase(sText))) to iPos
93618>>>>>>>>>        Move sLine to sText
93619>>>>>>>>>        Get Tokenizer sText to CodeComponents
93620>>>>>>>>>        
93620>>>>>>>>>        // If the line starts with the Key word.
93620>>>>>>>>>//        If (Pos(sLowerKeyWord, Lowercase(CodeComponents.sCode)) = 1) Begin
93620>>>>>>>>>//            Move (sLowerKeyWord + " ") to sLowerKeyWord
93620>>>>>>>>>//        End                                  
93620>>>>>>>>>//        Else Begin
93620>>>>>>>>>//            Move (" " + String(sLowerKeyWord) + " ") to sLowerKeyWord
93620>>>>>>>>>//        End
93620>>>>>>>>>//        Move (Lowercase(CodeComponents.sCode) contains sLowerKeyWord) to bFound
93620>>>>>>>>>        Get _RetrieveFirstWord sText to sFirstWord
93621>>>>>>>>>        Move (Lowercase(sFirstWord) = Lowercase(sKeyWord)) to bFound
93622>>>>>>>>>        If (bFound = False) Begin      
93624>>>>>>>>>//            If (sExpression <> "") Begin
93624>>>>>>>>>//                Move (CS_If * String(sExpression) + String(sLine)) to sLine
93624>>>>>>>>>//            End
93624>>>>>>>>>            Function_Return False
93625>>>>>>>>>        End
93625>>>>>>>>>>
93625>>>>>>>>>        
93625>>>>>>>>>        Move (Lowercase(CodeComponents.sCode)) to sText
93626>>>>>>>>>        Move (Mid(CodeComponents.sCode, (Length(CodeComponents.sCode)), (Length(sKeyWord) + 1))) to sText
93627>>>>>>>>>        Move (Ltrim(sText)) to sText   
93628>>>>>>>>>        If (sKeyWord = CS_Pos) Begin
93630>>>>>>>>>            Move (Lowercase(sText)) to sLowerCase
93631>>>>>>>>>            Move (Pos(" in ", sLowerCase)) to iPos
93632>>>>>>>>>            If (iPos <> 0) Begin
93634>>>>>>>>>                Move (Overstrike("____", sText, iPos)) to sText
93635>>>>>>>>>                Move (Replace("____", sText, ", ")) to sText
93636>>>>>>>>>                Move True to bChanged
93637>>>>>>>>>            End
93637>>>>>>>>>>
93637>>>>>>>>>        End                                                                                                                              
93637>>>>>>>>>>
93637>>>>>>>>>        If (Length(CodeComponents.sRightComment)  > 0) Begin
93639>>>>>>>>>            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
93640>>>>>>>>>            Move True to bChanged
93641>>>>>>>>>        End
93641>>>>>>>>>>
93641>>>>>>>>>        Else Begin
93642>>>>>>>>>            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
93643>>>>>>>>>            Move True to bChanged
93644>>>>>>>>>        End
93644>>>>>>>>>>
93644>>>>>>>>>        
93644>>>>>>>>>        Function_Return bChanged
93645>>>>>>>>>    End_Function
93646>>>>>>>>>
93646>>>>>>>>>    // Helper function. This is a list of commands that also exists as global build in functions.
93646>>>>>>>>>    Function _TestCommandFunctions String sTest Returns Integer
93648>>>>>>>>>        Boolean bRemoved
93648>>>>>>>>>        Integer iCount iSize iPos iTest
93648>>>>>>>>>        String  sCommand
93648>>>>>>>>>        String[] asCommandFunctions
93649>>>>>>>>>
93649>>>>>>>>>        Move 0 to iPos
93650>>>>>>>>>        Get _RemoveComments (&sTest) to bRemoved
93651>>>>>>>>>        Get paCommandFunctions to asCommandFunctions
93652>>>>>>>>>        Move (SizeOfArray(asCommandFunctions)) to iSize
93653>>>>>>>>>        If (iSize = 0) Begin
93655>>>>>>>>>            Send AddAllCommandFunctions
93656>>>>>>>>>            Get paCommandFunctions to asCommandFunctions
93657>>>>>>>>>            Move (SizeOfArray(asCommandFunctions)) to iSize        
93658>>>>>>>>>        End
93658>>>>>>>>>>
93658>>>>>>>>>        Decrement iSize
93659>>>>>>>>>        For iCount from 0 to iSize
93665>>>>>>>>>>
93665>>>>>>>>>            Move asCommandFunctions[iCount] to sCommand
93666>>>>>>>>>            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
93667>>>>>>>>>            If (iTest <> 0) Begin
93669>>>>>>>>>                If (iPos = 0) Begin
93671>>>>>>>>>                    Move iTest to iPos
93672>>>>>>>>>                End
93672>>>>>>>>>>
93672>>>>>>>>>                Else Begin
93673>>>>>>>>>                    If (iTest < iPos) Begin
93675>>>>>>>>>                        Move iTest to iPos
93676>>>>>>>>>                    End
93676>>>>>>>>>>
93676>>>>>>>>>                End
93676>>>>>>>>>>
93676>>>>>>>>>            End
93676>>>>>>>>>>
93676>>>>>>>>>        Loop
93677>>>>>>>>>>
93677>>>>>>>>>
93677>>>>>>>>>        Function_Return iPos
93678>>>>>>>>>    End_Function
93679>>>>>>>>>
93679>>>>>>>>>    Function HasDoubleExpression String sLine Returns Boolean
93681>>>>>>>>>        Boolean bFound      
93681>>>>>>>>>        Integer iCount iSize iOpCount iParanthesis
93681>>>>>>>>>        String sChar sOperators
93681>>>>>>>>>        
93681>>>>>>>>>        Move False to bFound  
93682>>>>>>>>>        Move 0 to iParanthesis           
93683>>>>>>>>>        Move "<=>" to sOperators
93684>>>>>>>>>        Move (Length(sLine)) to iSize
93685>>>>>>>>>        For iCount from 1 to iSize
93691>>>>>>>>>>
93691>>>>>>>>>            Move (Mid(sLine, 1, iCount)) to sChar
93692>>>>>>>>>            If (sChar = "(") Begin
93694>>>>>>>>>                Increment iOpCount          
93695>>>>>>>>>                Increment iParanthesis
93696>>>>>>>>>            End
93696>>>>>>>>>>
93696>>>>>>>>>            If (sChar = ")") Begin
93698>>>>>>>>>                Decrement iOpCount
93699>>>>>>>>>            End
93699>>>>>>>>>>
93699>>>>>>>>>            If (iParanthesis <> 0 and sOperators contains sChar) Begin
93701>>>>>>>>>                If (iOpCount = 0) Begin
93703>>>>>>>>>                    Move True to bFound
93704>>>>>>>>>                    Move iSize to iCount // We're done.
93705>>>>>>>>>                End
93705>>>>>>>>>>
93705>>>>>>>>>            End
93705>>>>>>>>>>
93705>>>>>>>>>        Loop
93706>>>>>>>>>>
93706>>>>>>>>>        
93706>>>>>>>>>        Function_Return bFound
93707>>>>>>>>>    End_Function
93708>>>>>>>>>    
93708>>>>>>>>>    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
93708>>>>>>>>>    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
93708>>>>>>>>>    Function HasCommand String sLine String sCommand Returns Boolean
93710>>>>>>>>>        Boolean bFound bOk
93710>>>>>>>>>        String sText
93710>>>>>>>>>        
93710>>>>>>>>>        Move False to bFound 
93711>>>>>>>>>        Move sLine to sText
93712>>>>>>>>>        Get _RemoveComments (&sText) to bOK
93713>>>>>>>>>//        Move (Trim(sText)) to sText
93713>>>>>>>>>        Get _OverstrikeStrings sText to sText
93714>>>>>>>>>        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound
93715>>>>>>>>>        
93715>>>>>>>>>        Function_Return bFound
93716>>>>>>>>>    End_Function
93717>>>>>>>>>    
93717>>>>>>>>>    // Returns True iif the source line contains a "Begin" statement.
93717>>>>>>>>>    Function IsBeginStatement String sLine Returns Boolean
93719>>>>>>>>>        Boolean bFound
93719>>>>>>>>>        Get HasCommand sLine (" " + CS_Begin) to bFound
93720>>>>>>>>>        Function_Return bFound
93721>>>>>>>>>    End_Function   
93722>>>>>>>>>    
93722>>>>>>>>>    Function IsBlankLine String sLine Returns Boolean
93724>>>>>>>>>        Boolean bIsBlank
93724>>>>>>>>>        
93724>>>>>>>>>        Move False to bIsBlank
93725>>>>>>>>>        Move (Trim(sLine)) to sLine
93726>>>>>>>>>        If (Length(sLine) = 0) Begin
93728>>>>>>>>>            Move True to bIsBlank
93729>>>>>>>>>        End
93729>>>>>>>>>>
93729>>>>>>>>>        
93729>>>>>>>>>        Function_Return bIsBlank        
93730>>>>>>>>>    End_Function
93731>>>>>>>>>    
93731>>>>>>>>>    Function IsCommentLine String sLine Returns Boolean
93733>>>>>>>>>        Boolean bIsComment
93733>>>>>>>>>        Integer iPos
93733>>>>>>>>>        
93733>>>>>>>>>        Move False to bIsComment
93734>>>>>>>>>//        Move (Trim(sLine)) to sLine
93734>>>>>>>>>//        Move (Pos(CS_CommentSymbol, sLine)) to iPos
93734>>>>>>>>>//        If (iPos = 1) Begin
93734>>>>>>>>>//            Move True to bIsComment
93734>>>>>>>>>//        End
93734>>>>>>>>>        // Replaces all quotes string contents to "_" so we don't get false positives.
93734>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
93735>>>>>>>>>        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment
93736>>>>>>>>>        
93736>>>>>>>>>        Function_Return bIsComment
93737>>>>>>>>>    End_Function
93738>>>>>>>>>
93738>>>>>>>>>    // Returns True if this is a comment line with "//" to the left,
93738>>>>>>>>>    // or if the line is blank.
93738>>>>>>>>>    Function IsCommentLineOrBlank String sLine Returns Boolean
93740>>>>>>>>>        Boolean bIsComment bIsBlank
93740>>>>>>>>>        
93740>>>>>>>>>        Get IsCommentLine sLine to bIsComment
93741>>>>>>>>>        Get IsBlankLine sLine to bIsBlank
93742>>>>>>>>>        
93742>>>>>>>>>        Function_Return (bIsComment = True or bIsBlank = True)
93743>>>>>>>>>    End_Function
93744>>>>>>>>>
93744>>>>>>>>>    // Returns False if the first line in the passed file is _not_ an automatically generated
93744>>>>>>>>>    // COM wrapper file created by the Studio.
93744>>>>>>>>>    // If it returns True, we should not process that file.
93744>>>>>>>>>    Function IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
93746>>>>>>>>>        Boolean bIsDFCOMProxyClasses bExists        
93746>>>>>>>>>        Integer iCh iPos
93746>>>>>>>>>        String sLine
93746>>>>>>>>>        
93746>>>>>>>>>        Move False to bIsDFCOMProxyClasses  
93747>>>>>>>>>        File_Exist sFileName bExists
93748>>>>>>>>>        If (bExists = False) Begin
93750>>>>>>>>>            Error ("The file doesn't exist:" * String(sFileName))
93751>>>>>>>>>>
93751>>>>>>>>>            Function_Return False
93752>>>>>>>>>        End
93752>>>>>>>>>>
93752>>>>>>>>>        Get Seq_New_Channel to iCh
93753>>>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93755>>>>>>>>>            Error "No Channel Available for Process: Procedure 'IsDataFlexCOMProxyClassesFile'"
93756>>>>>>>>>>
93756>>>>>>>>>            Function_Return False
93757>>>>>>>>>        End
93757>>>>>>>>>>
93757>>>>>>>>>        
93757>>>>>>>>>        Direct_Input channel iCh sFileName
93759>>>>>>>>>        Readln channel iCh sLine
93761>>>>>>>>>        Close_Input channel ich
93763>>>>>>>>>        Send Seq_Release_Channel iCh
93764>>>>>>>>>        Move (Trim(sLine)) to sLine
93765>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
93766>>>>>>>>>        If (iPos <> 1) Begin
93768>>>>>>>>>            Function_Return False
93769>>>>>>>>>        End
93769>>>>>>>>>>
93769>>>>>>>>>
93769>>>>>>>>>        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses
93770>>>>>>>>>        
93770>>>>>>>>>        Function_Return bIsDFCOMProxyClasses
93771>>>>>>>>>    End_Function
93772>>>>>>>>>    
93772>>>>>>>>>    // Returns True iif the source line starts with the sCommand statement.
93772>>>>>>>>>    Function IsFirstWord String sLine String sCommand Returns Boolean
93774>>>>>>>>>        Boolean bFound
93774>>>>>>>>>        Integer iPos  
93774>>>>>>>>>        String sFirstWord
93774>>>>>>>>>        
93774>>>>>>>>>        Move (Ltrim(Lowercase(sLine))) to sLine
93775>>>>>>>>>        Move (Ltrim(Lowercase(sCommand))) to sCommand
93776>>>>>>>>>        If (sLine = sCommand) Begin
93778>>>>>>>>>            Function_Return True
93779>>>>>>>>>        End
93779>>>>>>>>>>
93779>>>>>>>>>        Move (sCommand + " ") to sCommand
93780>>>>>>>>>        Move (Pos(" ", sLine)) to iPos
93781>>>>>>>>>        Move (Left(sLine, iPos)) to sFirstWord
93782>>>>>>>>>        Move (sFirstWord = sCommand) to bFound
93783>>>>>>>>>        Function_Return bFound
93784>>>>>>>>>    End_Function   
93785>>>>>>>>>    
93785>>>>>>>>>    // Returns True if source line contains a "[Found]", or "[FindErr]".
93785>>>>>>>>>    Function IsFoundOrFindErrIndicator String sLine Returns Boolean
93787>>>>>>>>>        Boolean bFound
93787>>>>>>>>>        Integer iLeft iRight iPos
93787>>>>>>>>>        String sText
93787>>>>>>>>>        
93787>>>>>>>>>        Get IsIndicatorStatement sLine to bFound
93788>>>>>>>>>        If (bFound = False) Begin
93790>>>>>>>>>            Function_Return False
93791>>>>>>>>>        End
93791>>>>>>>>>>
93791>>>>>>>>>
93791>>>>>>>>>        Get _RemoveComments (&sLine) to bFound
93792>>>>>>>>>        Get _OverstrikeStrings sLine to sText  
93793>>>>>>>>>        Send StripConcatenatingSpaces (&sText) sLine
93794>>>>>>>>>        Move (Pos("[", sLine)) to iLeft
93795>>>>>>>>>        Move (Pos("]", sLine)) to iRight
93796>>>>>>>>>        Move (Pos(("[" + Lowercase(CS_Found)), sLine)) to iPos
93797>>>>>>>>>        If (iPos = 0) Begin
93799>>>>>>>>>            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
93800>>>>>>>>>        End
93800>>>>>>>>>>
93800>>>>>>>>>        If (iPos = 0) Begin
93802>>>>>>>>>            Move (Pos(("[" + Lowercase(CS_Finderr)), sLine)) to iPos
93803>>>>>>>>>        End
93803>>>>>>>>>>
93803>>>>>>>>>        If (iPos = 0) Begin
93805>>>>>>>>>            Move (Pos((Lowercase(CS_Finderr) + "]"), sLine)) to iPos
93806>>>>>>>>>        End
93806>>>>>>>>>>
93806>>>>>>>>>            
93806>>>>>>>>>        Function_Return (iPos <> 0)    
93807>>>>>>>>>    End_Function
93808>>>>>>>>>    
93808>>>>>>>>>    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
93808>>>>>>>>>    // Note: The source line must first have been stripped of any comments
93808>>>>>>>>>    Function IsIfBeginStatement String sLine Returns Boolean
93810>>>>>>>>>        Boolean bisIfBegin bIsBeginStatement 
93810>>>>>>>>>        Get IsIfCommand sLine to bisIfBegin
93811>>>>>>>>>        Get IsBeginStatement sLine to bIsBeginStatement
93812>>>>>>>>>        Function_Return (bisIfBegin = True and bIsBeginStatement = True)
93813>>>>>>>>>    End_Function   
93814>>>>>>>>>    
93814>>>>>>>>>    Function IsIfCommand String sLine Returns Boolean
93816>>>>>>>>>        Boolean bFound
93816>>>>>>>>>        Get HasCommand sLine (CS_If + " ") to bFound
93817>>>>>>>>>        Function_Return bFound
93818>>>>>>>>>    End_Function                                                  
93819>>>>>>>>>    
93819>>>>>>>>>    Function IsImagePageStartOrEnd String sLine Boolean bCheckImageStart Returns Boolean
93821>>>>>>>>>        Boolean bFound
93821>>>>>>>>>        Integer iPos
93821>>>>>>>>>
93821>>>>>>>>>        Move False to bFound
93822>>>>>>>>>        Move (Trim(sLine)) to sLine
93823>>>>>>>>>        If (bCheckImageStart = True) Begin
93825>>>>>>>>>            Get IsImageStart sLine to bFound
93826>>>>>>>>>        End
93826>>>>>>>>>>
93826>>>>>>>>>        Else Begin
93827>>>>>>>>>            Move (Pos(CS_ImageNameEnd, sLine)) to iPos
93828>>>>>>>>>            If (iPos = 1) Begin
93830>>>>>>>>>                Move True to bFound
93831>>>>>>>>>            End
93831>>>>>>>>>>
93831>>>>>>>>>        End
93831>>>>>>>>>>
93831>>>>>>>>>
93831>>>>>>>>>        Function_Return bFound
93832>>>>>>>>>    End_Function
93833>>>>>>>>>
93833>>>>>>>>>    Function IsImageStart String sLine Returns Boolean
93835>>>>>>>>>        Boolean bIsChar
93835>>>>>>>>>        Integer iPos
93835>>>>>>>>>        String sChar
93835>>>>>>>>>
93835>>>>>>>>>        Move False to bIsChar
93836>>>>>>>>>        Move (Trim(sLine)) to sLine
93837>>>>>>>>>        Move (Pos(CS_ImageNameStart, sLine)) to iPos
93838>>>>>>>>>        If (iPos = 1) Begin
93840>>>>>>>>>            Move (Mid(sLine, 1, 2)) to sChar
93841>>>>>>>>>            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsChar
93842>>>>>>>>>        End
93842>>>>>>>>>>
93842>>>>>>>>>
93842>>>>>>>>>        Function_Return bIsChar
93843>>>>>>>>>    End_Function
93844>>>>>>>>>
93844>>>>>>>>>    // Returns True if source code contains both a "[" and a "]", but not a "[]"
93844>>>>>>>>>    Function IsIndicatorStatement String sLine Returns Boolean
93846>>>>>>>>>        Boolean bFound bIndicatorWord
93846>>>>>>>>>        Integer iLeft iRight iPos
93846>>>>>>>>>        String sChar sLeftBracket
93846>>>>>>>>>        
93846>>>>>>>>>        Get IsCommentLineOrBlank sLine to bFound
93847>>>>>>>>>        If (bFound = True) Begin
93849>>>>>>>>>            Function_Return False
93850>>>>>>>>>        End
93850>>>>>>>>>>
93850>>>>>>>>>        Get _RemoveComments (&sLine) to bFound
93851>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
93852>>>>>>>>>        Move (Left(sLine, 1)) to sChar
93853>>>>>>>>>        If (sChar = "[") Begin
93855>>>>>>>>>            Move "[" to sLeftBracket
93856>>>>>>>>>        End                         
93856>>>>>>>>>>
93856>>>>>>>>>        Else Begin
93857>>>>>>>>>            Move " [" to sLeftBracket
93858>>>>>>>>>        End
93858>>>>>>>>>>
93858>>>>>>>>>//        Move (Lowercase(sLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
93858>>>>>>>>>        Move (bIndicatorWord = True or (sLine contains sLeftBracket and sLine contains "]")) to bFound
93859>>>>>>>>>        If (bFound = True) Begin
93861>>>>>>>>>            Move (Pos(sLeftBracket, sLine)) to iLeft
93862>>>>>>>>>            Move (Pos("]", sLine)) to iRight
93863>>>>>>>>>            Move ((iRight - iLeft) > 1) to bFound
93864>>>>>>>>>        End
93864>>>>>>>>>>
93864>>>>>>>>>        Function_Return (bIndicatorWord or bFound)
93865>>>>>>>>>    End_Function
93866>>>>>>>>>
93866>>>>>>>>>    // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
93866>>>>>>>>>    Function IsKeywordInLine String sKeywords String sLine Returns Boolean
93868>>>>>>>>>        String sKeyword sChar  
93868>>>>>>>>>        Integer iPos   
93868>>>>>>>>>        Boolean bOK
93868>>>>>>>>>
93868>>>>>>>>>        Move (Lowercase(sKeywords)) to sKeywords
93869>>>>>>>>>        Move (Lowercase(sLine)) to sLine
93870>>>>>>>>>        Get _RemoveStringsFromLine sLine to sLine
93871>>>>>>>>>        Move (Pos(" ", sLine)) to iPos
93872>>>>>>>>>        // Then there is only one "word" in sLine. Check if the sKeywords = sLine
93872>>>>>>>>>        If (iPos = 0) Begin
93874>>>>>>>>>            Move (Replace("|", sKeywords, "")) to sKeyword
93875>>>>>>>>>            If (Trim(sKeyword) = Trim(sLine)) Begin
93877>>>>>>>>>                Function_Return True
93878>>>>>>>>>            End
93878>>>>>>>>>>
93878>>>>>>>>>        End
93878>>>>>>>>>>
93878>>>>>>>>>        
93878>>>>>>>>>        While (sKeywords <> "")
93882>>>>>>>>>            Move (Left(sKeywords, (Pos("|", sKeywords)))) to sKeyword
93883>>>>>>>>>            Move (Replace(sKeyword, sKeywords, "")) to sKeywords
93884>>>>>>>>>            Move (Trim(Replace("|", sKeyword, ""))) to sKeyword
93885>>>>>>>>>            Move ((sKeyword <> "") and ((Pos((" " + sKeyword + " "), sLine)) <> 0)) to bOK
93886>>>>>>>>>            If (bOK = False) Begin
93888>>>>>>>>>                Move ((sKeyword <> "") and ((Pos((sKeyword + " "), sLine)) <> 0) ) to bOK
93889>>>>>>>>>            End
93889>>>>>>>>>>
93889>>>>>>>>>            // Also check if this might be the very first statement on the sLine 
93889>>>>>>>>>            If (bOK = True) Begin    
93891>>>>>>>>>                Move (Left(sKeyword, 1)) to sChar
93892>>>>>>>>>                // Is this a command?
93892>>>>>>>>>                If (sChar = "#") Begin
93894>>>>>>>>>                    Function_Return False
93895>>>>>>>>>                End
93895>>>>>>>>>>
93895>>>>>>>>>                Else Begin
93896>>>>>>>>>                    Function_Return True
93897>>>>>>>>>                End
93897>>>>>>>>>>
93897>>>>>>>>>            End
93897>>>>>>>>>>
93897>>>>>>>>>        Loop
93898>>>>>>>>>>
93898>>>>>>>>>        Function_Return False
93899>>>>>>>>>    End_Function
93900>>>>>>>>>
93900>>>>>>>>>    Function IsMethodStart String sLine Returns Boolean
93902>>>>>>>>>        Boolean bMethodStart
93902>>>>>>>>>
93902>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
93903>>>>>>>>>        Move (Lowercase(Trim(sLine))) to sLine
93904>>>>>>>>>        Move (Left(sLine, 10) = "procedure " or Left(sLine, 9) = "function ") to bMethodStart
93905>>>>>>>>>
93905>>>>>>>>>        Function_Return bMethodStart
93906>>>>>>>>>    End_Function
93907>>>>>>>>>
93907>>>>>>>>>    Function IsMethodEnd String sLine Returns Boolean
93909>>>>>>>>>        Boolean bMethodEnd
93909>>>>>>>>>
93909>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
93910>>>>>>>>>        Get _RemoveEndComment  sLine to sLine
93911>>>>>>>>>        Move (Lowercase(Trim(sLine))) to sLine
93912>>>>>>>>>        Move (Left(sLine, 14) = "end_procedure " or Left(sLine, 13) = "end_function ") to bMethodEnd
93913>>>>>>>>>
93913>>>>>>>>>        Function_Return bMethodEnd
93914>>>>>>>>>    End_Function
93915>>>>>>>>>
93915>>>>>>>>>    // Pass only the code part of a source line.
93915>>>>>>>>>    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>" 
93915>>>>>>>>>    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator. 
93915>>>>>>>>>    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
93915>>>>>>>>>    Function IsLogicalOperators String sLine Returns tOperatorsInfo
93917>>>>>>>>>        Boolean bHas 
93917>>>>>>>>>        tOperatorsInfo OperatorsInfo
93917>>>>>>>>>        tOperatorsInfo OperatorsInfo
93917>>>>>>>>>        
93917>>>>>>>>>        Get IsCommentLineOrBlank sLine to bHas
93918>>>>>>>>>        If (bHas = True) Begin
93920>>>>>>>>>            Function_Return OperatorsInfo
93921>>>>>>>>>        End
93921>>>>>>>>>>
93921>>>>>>>>>        Get _RemoveComments (&sLine) to bHas
93922>>>>>>>>>        Get _OverstrikeStrings sLine to sLine 
93923>>>>>>>>>        Move (Lowercase(sLine)) to sLine
93924>>>>>>>>>
93924>>>>>>>>>        Case Begin                
93924>>>>>>>>>            // "Legacy" operators;
93924>>>>>>>>>            Case (sLine contains " gt ")
93926>>>>>>>>>                Move (Pos(" gt ", sLine))   to OperatorsInfo.iPos
93927>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93928>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
93929>>>>>>>>>                Move "gt"                   to OperatorsInfo.sOperator
93930>>>>>>>>>                Case Break
93931>>>>>>>>>            Case (sLine contains " ge ")
93934>>>>>>>>>                Move (Pos(" ge ", sLine))   to OperatorsInfo.iPos
93935>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93936>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
93937>>>>>>>>>                Move "ge"                   to OperatorsInfo.sOperator
93938>>>>>>>>>                Case Break
93939>>>>>>>>>            Case (sLine contains " lt ")
93942>>>>>>>>>                Move (Pos(" lt ", sLine))   to OperatorsInfo.iPos
93943>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93944>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
93945>>>>>>>>>                Move "lt"                   to OperatorsInfo.sOperator
93946>>>>>>>>>                Case Break
93947>>>>>>>>>            Case (sLine contains " le ")
93950>>>>>>>>>                Move (Pos(" le ", sLine))   to OperatorsInfo.iPos
93951>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93952>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
93953>>>>>>>>>                Move "le"                   to OperatorsInfo.sOperator
93954>>>>>>>>>                Case Break
93955>>>>>>>>>            Case (sLine contains " eq ")
93958>>>>>>>>>                Move (Pos(" eq ", sLine))   to OperatorsInfo.iPos
93959>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93960>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
93961>>>>>>>>>                Move "eq"                   to OperatorsInfo.sOperator
93962>>>>>>>>>                Case Break
93963>>>>>>>>>            Case (sLine contains " ne ")
93966>>>>>>>>>                Move (Pos(" ne ", sLine))   to OperatorsInfo.iPos
93967>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93968>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
93969>>>>>>>>>                Move "ne"                   to OperatorsInfo.sOperator
93970>>>>>>>>>                Case Break
93971>>>>>>>>>            
93971>>>>>>>>>            // "Modern" operators;
93971>>>>>>>>>            Case (sLine contains ">")
93974>>>>>>>>>                Move (Pos(">", sLine))      to OperatorsInfo.iPos
93975>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93976>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
93977>>>>>>>>>                Move ">"                    to OperatorsInfo.sOperator
93978>>>>>>>>>                Case Break
93979>>>>>>>>>            Case (sLine contains ">=")
93982>>>>>>>>>                Move (Pos(">=", sLine))     to OperatorsInfo.iPos
93983>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93984>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
93985>>>>>>>>>                Move ">="                   to OperatorsInfo.sOperator
93986>>>>>>>>>                Case Break
93987>>>>>>>>>            Case (sLine contains "<")
93990>>>>>>>>>                Move (Pos("<", sLine))      to OperatorsInfo.iPos
93991>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
93992>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
93993>>>>>>>>>                Move "<"                    to OperatorsInfo.sOperator
93994>>>>>>>>>                Case Break
93995>>>>>>>>>            Case (sLine contains "<=")
93998>>>>>>>>>                Move (Pos("<=", sLine))     to OperatorsInfo.iPos
93999>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94000>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94001>>>>>>>>>                Move "<="                   to OperatorsInfo.sOperator
94002>>>>>>>>>                Case Break
94003>>>>>>>>>            Case (sLine contains "=")
94006>>>>>>>>>                Move (Pos("=", sLine))      to OperatorsInfo.iPos
94007>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94008>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94009>>>>>>>>>                Move "="                    to OperatorsInfo.sOperator
94010>>>>>>>>>                Case Break
94011>>>>>>>>>            Case (sLine contains "<>")
94014>>>>>>>>>                Move (Pos("<>", sLine))     to OperatorsInfo.iPos
94015>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94016>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94017>>>>>>>>>                Move "<>"                   to OperatorsInfo.sOperator
94018>>>>>>>>>                Case Break
94019>>>>>>>>>            Case Else
94019>>>>>>>>>                Move -1                     to OperatorsInfo.iPos
94020>>>>>>>>>                Move False                  to OperatorsInfo.bIsOperator
94021>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94022>>>>>>>>>                Move ""                     to OperatorsInfo.sOperator
94023>>>>>>>>>        Case End
94023>>>>>>>>>                
94023>>>>>>>>>        Function_Return OperatorsInfo
94024>>>>>>>>>    End_Function
94025>>>>>>>>>    
94025>>>>>>>>>    // Pass only the code part of a source line.
94025>>>>>>>>>    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
94025>>>>>>>>>    Function IsLegacyOperators String sLine Returns Boolean
94027>>>>>>>>>        Boolean bHas bFound
94027>>>>>>>>>        
94027>>>>>>>>>        Get IsCommentLineOrBlank sLine to bFound
94028>>>>>>>>>        If (bFound = True) Begin
94030>>>>>>>>>            Function_Return False
94031>>>>>>>>>        End
94031>>>>>>>>>>
94031>>>>>>>>>        Get _RemoveComments (&sLine) to bHas
94032>>>>>>>>>        Get _OverstrikeStrings sLine to sLine 
94033>>>>>>>>>        Move (Lowercase(sLine)) to sLine
94034>>>>>>>>>
94034>>>>>>>>>        Case Begin
94034>>>>>>>>>            Case (sLine contains " gt ")
94036>>>>>>>>>                Move True to bHas
94037>>>>>>>>>                Case Break
94038>>>>>>>>>            Case (sLine contains " ge ")
94041>>>>>>>>>                Move True to bHas
94042>>>>>>>>>                Case Break
94043>>>>>>>>>            Case (sLine contains " lt ")
94046>>>>>>>>>                Move True to bHas
94047>>>>>>>>>                Case Break
94048>>>>>>>>>            Case (sLine contains " le ")
94051>>>>>>>>>                Move True to bHas
94052>>>>>>>>>                Case Break
94053>>>>>>>>>            Case (sLine contains " eq ")
94056>>>>>>>>>                Move True to bHas
94057>>>>>>>>>                Case Break
94058>>>>>>>>>            Case (sLine contains " ne ")
94061>>>>>>>>>                Move True to bHas
94062>>>>>>>>>                Case Break
94063>>>>>>>>>            Case Else
94063>>>>>>>>>                Move False to bHas
94064>>>>>>>>>        Case End
94064>>>>>>>>>                
94064>>>>>>>>>        Function_Return bHas
94065>>>>>>>>>    End_Function
94066>>>>>>>>>    
94066>>>>>>>>>    // Pass only the code part of a source line.
94066>>>>>>>>>    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
94066>>>>>>>>>    Function IsOperators String sLine Returns Boolean
94068>>>>>>>>>        Boolean bHas
94068>>>>>>>>>        
94068>>>>>>>>>        Get _RemoveComments (&sLine) to bHas 
94069>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
94070>>>>>>>>>
94070>>>>>>>>>        Case Begin
94070>>>>>>>>>            Case (sLine contains ">")
94072>>>>>>>>>                Move True to bHas
94073>>>>>>>>>                Case Break
94074>>>>>>>>>            Case (sLine contains ">=")
94077>>>>>>>>>                Move True to bHas
94078>>>>>>>>>                Case Break
94079>>>>>>>>>            Case (sLine contains "<")
94082>>>>>>>>>                Move True to bHas
94083>>>>>>>>>                Case Break
94084>>>>>>>>>            Case (sLine contains "<=")
94087>>>>>>>>>                Move True to bHas
94088>>>>>>>>>                Case Break
94089>>>>>>>>>            Case (sLine contains "=")
94092>>>>>>>>>                Move True to bHas
94093>>>>>>>>>                Case Break
94094>>>>>>>>>            Case (sLine contains "<>")
94097>>>>>>>>>                Move True to bHas
94098>>>>>>>>>                Case Break
94099>>>>>>>>>            Case Else
94099>>>>>>>>>                Move False to bHas
94100>>>>>>>>>        Case End
94100>>>>>>>>>                
94100>>>>>>>>>        Function_Return bHas
94101>>>>>>>>>    End_Function
94102>>>>>>>>>    
94102>>>>>>>>>    Function IsLineEndSemiColon String sLine Returns Boolean
94104>>>>>>>>>        Boolean bRemoved
94104>>>>>>>>>        String  sText
94104>>>>>>>>>        
94104>>>>>>>>>        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
94105>>>>>>>>>        Get _RemoveComments (&sLine) to bRemoved
94106>>>>>>>>>        Move (RTrim(sLine)) to sText
94107>>>>>>>>>        If (Right(sText, 1) = ";") Begin
94109>>>>>>>>>            Function_Return True
94110>>>>>>>>>        End
94110>>>>>>>>>>
94110>>>>>>>>>        Function_Return False
94111>>>>>>>>>    End_Function
94112>>>>>>>>>
94112>>>>>>>>>    Function IsLineEndSemiColonOrBegin String sLine Returns Boolean
94114>>>>>>>>>        Boolean bRemoved
94114>>>>>>>>>        Boolean bStop
94114>>>>>>>>>        String  sTest
94114>>>>>>>>>        
94114>>>>>>>>>        Move False to bStop
94115>>>>>>>>>        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
94116>>>>>>>>>        Get _RemoveComments (&sLine) to bRemoved
94117>>>>>>>>>        Move (RTrim(sLine)) to sTest
94118>>>>>>>>>        If (Right(sTest, 1) = ";") Begin
94120>>>>>>>>>            Move True to bStop
94121>>>>>>>>>        End
94121>>>>>>>>>>
94121>>>>>>>>>        If (bStop = False) Begin
94123>>>>>>>>>            Move (Lowercase(sTest)) to sTest
94124>>>>>>>>>            If (Right(sTest, 5) = "begin") Begin
94126>>>>>>>>>                Move True to bStop
94127>>>>>>>>>            End
94127>>>>>>>>>>
94127>>>>>>>>>        End
94127>>>>>>>>>>
94127>>>>>>>>>        Function_Return bStop
94128>>>>>>>>>    End_Function    
94129>>>>>>>>>    
94129>>>>>>>>>    // Returns True iif the source line is a "Loop" statement.
94129>>>>>>>>>    Function IsLoopStatement String sLine Returns Boolean
94131>>>>>>>>>        Boolean bFound
94131>>>>>>>>>        Get HasCommand sLine (" " + CS_Loop) to bFound
94132>>>>>>>>>        Function_Return bFound
94133>>>>>>>>>    End_Function   
94134>>>>>>>>>
94134>>>>>>>>>    Function IsMoveCommand String sLine Returns Boolean
94136>>>>>>>>>        Boolean bFound
94136>>>>>>>>>        Get HasCommand sLine (" " + String(CS_Move) + " ") to bFound
94137>>>>>>>>>        If (bFound = False) Begin
94139>>>>>>>>>            Get HasCommand sLine (String(CS_Move) + " ") to bFound
94140>>>>>>>>>        End
94140>>>>>>>>>>
94140>>>>>>>>>        Function_Return bFound
94141>>>>>>>>>    End_Function                                                  
94142>>>>>>>>>    
94142>>>>>>>>>    // Returns True iif the source line is a "Until" statement.
94142>>>>>>>>>    Function IsUntilStatement String sLine Returns Boolean
94144>>>>>>>>>        Boolean bFound
94144>>>>>>>>>        Get HasCommand sLine (" " + CS_Until) to bFound
94145>>>>>>>>>        If (bFound = False) Begin
94147>>>>>>>>>            Get HasCommand sLine (CS_Until + " ") to bFound
94148>>>>>>>>>            If (bFound = False) Begin
94150>>>>>>>>>                Get HasCommand sLine (CS_Until) to bFound
94151>>>>>>>>>            End
94151>>>>>>>>>>
94151>>>>>>>>>        End  
94151>>>>>>>>>>
94151>>>>>>>>>            
94151>>>>>>>>>        Function_Return bFound
94152>>>>>>>>>    End_Function   
94153>>>>>>>>>
94153>>>>>>>>>    Function IsVariableDeclarationLine String sLine Returns Boolean
94155>>>>>>>>>        Boolean bVariableDeclaration
94155>>>>>>>>>        String[] asLocalVariableTypes asLocalVariableArrayTypes
94157>>>>>>>>>        Integer iRetval
94157>>>>>>>>>        String sFirstWord
94157>>>>>>>>>
94157>>>>>>>>>        Move False to bVariableDeclaration
94158>>>>>>>>>        Get pasLocalVariableTypes      to asLocalVariableTypes
94159>>>>>>>>>        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
94160>>>>>>>>>        Move (Trim(sLine)) to sLine
94161>>>>>>>>>        Get _RetrieveFirstWord sLine to sFirstWord
94162>>>>>>>>>        Move (Uppercase(sFirstWord)) to sFirstWord
94163>>>>>>>>>        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
94164>>>>>>>>>        If (iRetval <> -1) Begin
94166>>>>>>>>>            Move True to bVariableDeclaration
94167>>>>>>>>>        End
94167>>>>>>>>>>
94167>>>>>>>>>        Else Begin
94168>>>>>>>>>            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
94169>>>>>>>>>            If (iRetval <> -1) Begin
94171>>>>>>>>>                Move True to bVariableDeclaration
94172>>>>>>>>>            End
94172>>>>>>>>>>
94172>>>>>>>>>        End
94172>>>>>>>>>>
94172>>>>>>>>>
94172>>>>>>>>>        Function_Return bVariableDeclaration
94173>>>>>>>>>    End_Function
94174>>>>>>>>>
94174>>>>>>>>>    Function IsVariableInLine String sLine String sVariableName Returns Boolean
94176>>>>>>>>>        Boolean bIsUseLine
94176>>>>>>>>>        String sChar
94176>>>>>>>>>        Integer iPos
94176>>>>>>>>>
94176>>>>>>>>>        Move False to bIsUseLine
94177>>>>>>>>>        Move (Uppercase(sLine)) to sLine
94178>>>>>>>>>        Move (Uppercase(sVariableName)) to sVariableName
94179>>>>>>>>>
94179>>>>>>>>>        If (sLine contains sVariableName) Begin
94181>>>>>>>>>            Move (Pos(sVariableName, sLine)) to iPos
94182>>>>>>>>>            If (iPos > 0) Begin
94184>>>>>>>>>                Repeat
94184>>>>>>>>>>
94184>>>>>>>>>                    Move (Mid(sLine, 1, (iPos - 1))) to sChar
94185>>>>>>>>>                    If (CS_ValidLeftCharacters contains sChar) Begin
94187>>>>>>>>>                        Move True to bIsUseLine
94188>>>>>>>>>                    End
94188>>>>>>>>>>
94188>>>>>>>>>                    If (bIsUseLine = False) Begin
94190>>>>>>>>>                        Move (Replace(sVariableName, sLine, "")) to sLine
94191>>>>>>>>>                        Move (Pos(sVariableName, sLine)) to iPos
94192>>>>>>>>>                    End
94192>>>>>>>>>>
94192>>>>>>>>>                Until (bIsUseLine = True or iPos = 0)
94194>>>>>>>>>            End
94194>>>>>>>>>>
94194>>>>>>>>>        End
94194>>>>>>>>>>
94194>>>>>>>>>
94194>>>>>>>>>        Function_Return bIsUseLine
94195>>>>>>>>>    End_Function
94196>>>>>>>>>
94196>>>>>>>>>    Function IsProjectObjectStructureLine String sLine String[] ByRef asObjectNames Returns Boolean
94198>>>>>>>>>        Boolean bWriteLine
94198>>>>>>>>>        Integer iPos iSize
94198>>>>>>>>>        String sObjectName
94198>>>>>>>>>
94198>>>>>>>>>        Move (Trim(sLine)) to sLine
94199>>>>>>>>>        Move True to bWriteLine
94200>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
94201>>>>>>>>>        If (iPos = 1) Begin
94203>>>>>>>>>            Move (Lowercase(sLine)) to sLine
94204>>>>>>>>>            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
94205>>>>>>>>>            If (bWriteLine = False) Begin
94207>>>>>>>>>                Move (SizeOfArray(asObjectNames)) to iSize
94208>>>>>>>>>                Move (Pos(" is a", sLine)) to iPos
94209>>>>>>>>>                Move (Left(sLine, (iPos -1))) to sObjectName
94210>>>>>>>>>                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
94211>>>>>>>>>                Move (Trim(sObjectName)) to sObjectName
94212>>>>>>>>>                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
94213>>>>>>>>>            End
94213>>>>>>>>>>
94213>>>>>>>>>        End
94213>>>>>>>>>>
94213>>>>>>>>>        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
94215>>>>>>>>>            Move False to bWriteLine
94216>>>>>>>>>        End
94216>>>>>>>>>>
94216>>>>>>>>>        Function_Return bWriteLine
94217>>>>>>>>>    End_Function
94218>>>>>>>>>
94218>>>>>>>>>    // Returns True iif the source line contains a "Repeat" statement.
94218>>>>>>>>>    Function IsRepeatStatement String sLine Returns Boolean
94220>>>>>>>>>        Boolean bFound
94220>>>>>>>>>        Get HasCommand sLine (" " + CS_Repeat) to bFound
94221>>>>>>>>>        Function_Return bFound
94222>>>>>>>>>    End_Function   
94223>>>>>>>>>    
94223>>>>>>>>>    Function IsRegisterObjectInArray String sLine String[] ByRef asObjectNames Returns Boolean
94225>>>>>>>>>        Boolean bWriteLine bRegisterObjectStart
94225>>>>>>>>>        Integer iPos
94225>>>>>>>>>
94225>>>>>>>>>        Move False to bWriteLine
94226>>>>>>>>>        Get IsRegisterAllObjectsStart sLine to bRegisterObjectStart
94227>>>>>>>>>        If (bRegisterObjectStart = False) Begin
94229>>>>>>>>>            Move (Lowercase(sLine)) to sLine
94230>>>>>>>>>            Move (Replace("register_object", sLine, "")) to sLine
94231>>>>>>>>>            Move (Trim(sLine)) to sLine
94232>>>>>>>>>            Move (SearchArray(sLine, asObjectNames)) to iPos
94233>>>>>>>>>            Move (iPos = -1) to bWriteLine
94234>>>>>>>>>        End
94234>>>>>>>>>>
94234>>>>>>>>>
94234>>>>>>>>>        Function_Return bWriteLine
94235>>>>>>>>>    End_Function
94236>>>>>>>>>
94236>>>>>>>>>    Function IsStudioGeneratedComment String sLine String sComment Returns Boolean
94238>>>>>>>>>        String sText
94238>>>>>>>>>        
94238>>>>>>>>>        Move (Lowercase(sLine)) to sText      
94239>>>>>>>>>        
94239>>>>>>>>>        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
94241>>>>>>>>>            Function_Return True 
94242>>>>>>>>>        End
94242>>>>>>>>>>
94242>>>>>>>>>        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) Begin
94245>>>>>>>>>            Function_Return True 
94246>>>>>>>>>        End                 
94246>>>>>>>>>>
94246>>>>>>>>>        
94246>>>>>>>>>        Function_Return False
94247>>>>>>>>>    End_Function
94248>>>>>>>>>    
94248>>>>>>>>>    // Returns True iif the source line contains a "While" statement.
94248>>>>>>>>>    Function IsWhileStatement String sLine Returns Boolean
94250>>>>>>>>>        Boolean bFound
94250>>>>>>>>>        Get HasCommand sLine (CS_While + " ") to bFound
94251>>>>>>>>>        Function_Return bFound
94252>>>>>>>>>    End_Function   
94253>>>>>>>>>    
94253>>>>>>>>>    Function IsProjectObjectStructureStart String sLine Returns Boolean
94255>>>>>>>>>        Boolean bFound
94255>>>>>>>>>        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
94256>>>>>>>>>        Function_Return bFound
94257>>>>>>>>>    End_Function
94258>>>>>>>>>
94258>>>>>>>>>    Function IsRegisterAllObjectsStart String sLine Returns Boolean
94260>>>>>>>>>        Boolean bFound
94260>>>>>>>>>        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
94261>>>>>>>>>        Function_Return bFound
94262>>>>>>>>>    End_Function
94263>>>>>>>>>
94263>>>>>>>>>    Function IsRegisterAllObjectsEnd String sLine Returns Boolean
94265>>>>>>>>>        Boolean bFound
94265>>>>>>>>>        Integer iPos
94265>>>>>>>>>        String sFirstWord
94265>>>>>>>>>
94265>>>>>>>>>        Move False to bFound
94266>>>>>>>>>        Move (Lowercase(sLine)) to sLine
94267>>>>>>>>>        Move (Trim(sLine)) to sLine
94268>>>>>>>>>        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
94270>>>>>>>>>            Move (Pos(" ", sLine)) to iPos
94271>>>>>>>>>            If (iPos <> 0) Begin
94273>>>>>>>>>                Move (Left(sLine, (iPos -1))) to sFirstWord
94274>>>>>>>>>                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
94275>>>>>>>>>            End
94275>>>>>>>>>>
94275>>>>>>>>>        End
94275>>>>>>>>>>
94275>>>>>>>>>        Function_Return bFound
94276>>>>>>>>>    End_Function
94277>>>>>>>>>
94277>>>>>>>>>    Function IsRegisterObjectLine String sLine Returns Boolean
94279>>>>>>>>>        Boolean bFound
94279>>>>>>>>>        Integer iPos
94279>>>>>>>>>        Move False to bFound
94280>>>>>>>>>        Move (Pos(CS_RegisterObject, sLine)) to iPos
94281>>>>>>>>>        If (iPos = 1) Begin
94283>>>>>>>>>            Move True to bFound
94284>>>>>>>>>        End
94284>>>>>>>>>>
94284>>>>>>>>>        Function_Return bFound
94285>>>>>>>>>    End_Function
94286>>>>>>>>>
94286>>>>>>>>>    // Tests if the lowercase character passed in sLine on position iPos is
94286>>>>>>>>>    // a valid character for a class name
94286>>>>>>>>>    Function IsValidClassCharacter String sLine Integer iPos Returns Boolean
94288>>>>>>>>>        Boolean bIsValid
94288>>>>>>>>>        String  sChar
94288>>>>>>>>>        Move False to bIsValid
94289>>>>>>>>>        Move (Mid(sLine, 1, iPos)) to sChar
94290>>>>>>>>>        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
94292>>>>>>>>>            Move True to bIsValid
94293>>>>>>>>>        End
94293>>>>>>>>>>
94293>>>>>>>>>        Function_Return bIsValid
94294>>>>>>>>>    End_Function
94295>>>>>>>>>      
94295>>>>>>>>>    // (nicked from cSciLexer.pkg)
94295>>>>>>>>>    // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter counting.
94295>>>>>>>>>    // We reduce the spaces here to just one.
94295>>>>>>>>>    Procedure StripConcatenatingSpaces String ByRef sText
94297>>>>>>>>>        While (Pos("  ", sText) <> 0)
94301>>>>>>>>>            Move (Replaces("  ", sText, " ")) to sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
94302>>>>>>>>>        Loop
94303>>>>>>>>>>
94303>>>>>>>>>    End_Procedure
94304>>>>>>>>>
94304>>>>>>>>>    Procedure AddCommand String sCommand
94306>>>>>>>>>        String[] Commands
94307>>>>>>>>>
94307>>>>>>>>>        Get paCommands to Commands
94308>>>>>>>>>        Move (Lowercase(sCommand)) to sCommand
94309>>>>>>>>>        Move sCommand to Commands[SizeOfArray(Commands)]
94310>>>>>>>>>        Set paCommands to Commands
94311>>>>>>>>>    End_Procedure
94312>>>>>>>>>
94312>>>>>>>>>    Procedure AddCommandFunction String sCommand
94314>>>>>>>>>        String[] aCommandFunctions
94315>>>>>>>>>
94315>>>>>>>>>        Get paCommandFunctions to aCommandFunctions
94316>>>>>>>>>        Move (Lowercase(sCommand)) to sCommand
94317>>>>>>>>>        Move sCommand to aCommandFunctions[SizeOfArray(aCommandFunctions)]
94318>>>>>>>>>        Set paCommandFunctions to aCommandFunctions
94319>>>>>>>>>    End_Procedure
94320>>>>>>>>>
94320>>>>>>>>>    // Command list used for testing against inline if/else statements et. al.
94320>>>>>>>>>    // Note that it is not a complete command list and that we should be careful
94320>>>>>>>>>    // about commands that might be used as functions or in functions!
94320>>>>>>>>>    // For example, it is by intention that none of the variable declaration commands
94320>>>>>>>>>    // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
94320>>>>>>>>>    //
94320>>>>>>>>>    // All commands can be entered case insensitive
94320>>>>>>>>>    // Standalone commands can end on a end of line, such as Abort.
94320>>>>>>>>>    // Other commands need more parameters and in such case we can improve our success rate
94320>>>>>>>>>    // by adding a space character.
94320>>>>>>>>>    //
94320>>>>>>>>>    Procedure AddAllCommands
94322>>>>>>>>>        String[] Empty
94323>>>>>>>>>
94323>>>>>>>>>        Set paCommands to Empty
94324>>>>>>>>>
94324>>>>>>>>>        //Send AddCommand "Repeat"  // nope, it is a function too
94324>>>>>>>>>        Send AddCommand "Abort"
94325>>>>>>>>>        Send AddCommand "Abort_Transaction"
94326>>>>>>>>>        Send AddCommand "Activate_View "
94327>>>>>>>>>        Send AddCommand "Add "
94328>>>>>>>>>        Send AddCommand "Address "
94329>>>>>>>>>        Send AddCommand "Append "
94330>>>>>>>>>        Send AddCommand "Append_Output "
94331>>>>>>>>>        Send AddCommand "Attach "
94332>>>>>>>>>        Send AddCommand "Begin_Constraints"
94333>>>>>>>>>        Send AddCommand "Begin_Transaction"
94334>>>>>>>>>        Send AddCommand "Broadcast "
94335>>>>>>>>>        Send AddCommand "Broadcast_Focus "
94336>>>>>>>>>        Send AddCommand "Calc "
94337>>>>>>>>>        Send AddCommand "Calculate "
94338>>>>>>>>>        Send AddCommand "Call_Driver "
94339>>>>>>>>>        Send AddCommand "CallStackDump "
94340>>>>>>>>>        Send AddCommand "Case "
94341>>>>>>>>>        Send AddCommand "Clear "
94342>>>>>>>>>        Send AddCommand "Close "
94343>>>>>>>>>        Send AddCommand "Close_Input"
94344>>>>>>>>>        Send AddCommand "Close_Output"
94345>>>>>>>>>        Send AddCommand "Constrain "
94346>>>>>>>>>        Send AddCommand "Constrained_Clear "
94347>>>>>>>>>        Send AddCommand "Constrained_Find "
94348>>>>>>>>>        Send AddCommand "Constraint_Set"
94349>>>>>>>>>        Send AddCommand "Constraint_Validate"
94350>>>>>>>>>        Send AddCommand "Copy_db "
94351>>>>>>>>>        Send AddCommand "Copy_Records "
94352>>>>>>>>>        Send AddCommand "Copyfile "
94353>>>>>>>>>        Send AddCommand "Create_Field "
94354>>>>>>>>>        Send AddCommand "Create_Index "
94355>>>>>>>>>        Send AddCommand "Declare_DataFile "
94356>>>>>>>>>        Send AddCommand "Decrement "
94357>>>>>>>>>        Send AddCommand "Delegate "
94358>>>>>>>>>        Send AddCommand "Delete "
94359>>>>>>>>>        Send AddCommand "Delete_db "
94360>>>>>>>>>        Send AddCommand "Delete_Field "
94361>>>>>>>>>        Send AddCommand "Delete_Index "
94362>>>>>>>>>        Send AddCommand "Direct_Input "
94363>>>>>>>>>        Send AddCommand "Direct_Output "
94364>>>>>>>>>        Send AddCommand "DiskFree "
94365>>>>>>>>>        Send AddCommand "EraseFile "
94366>>>>>>>>>        Send AddCommand "Error "
94367>>>>>>>>>        Send AddCommand "Field_Map "
94368>>>>>>>>>        Send AddCommand "File_Exist "
94369>>>>>>>>>        Send AddCommand "Fill_Field "
94370>>>>>>>>>        Send AddCommand "Find "
94371>>>>>>>>>        Send AddCommand "For "
94372>>>>>>>>>        Send AddCommand "For_All "
94373>>>>>>>>>        Send AddCommand "Forward "
94374>>>>>>>>>        Send AddCommand "Function_Return " // you might have code that does not return a value, I'd consider that a warning
94375>>>>>>>>>        Send AddCommand "Get "
94376>>>>>>>>>        Send AddCommand "Get_Argument_Size "
94377>>>>>>>>>        Send AddCommand "Get_Attribute "
94378>>>>>>>>>        Send AddCommand "Get_Channel_Position "
94379>>>>>>>>>        Send AddCommand "Get_Channel_Size "
94380>>>>>>>>>        Send AddCommand "Get_Current_Directory "
94381>>>>>>>>>        Send AddCommand "Get_Current_Input_Channel "
94382>>>>>>>>>        Send AddCommand "Get_Current_Output_Channel "
94383>>>>>>>>>        Send AddCommand "Get_Current_User_Count "
94384>>>>>>>>>        Send AddCommand "Get_Date_Attribute "
94385>>>>>>>>>        Send AddCommand "Get_Directory "
94386>>>>>>>>>        Send AddCommand "Get_Environment "
94387>>>>>>>>>        Send AddCommand "Get_Field_Value "
94388>>>>>>>>>        Send AddCommand "Get_FieldNumber "
94389>>>>>>>>>        Send AddCommand "Get_File_Mod_Time "
94390>>>>>>>>>        Send AddCommand "Get_File_Path "
94391>>>>>>>>>        Send AddCommand "Get_FileNumber "
94392>>>>>>>>>        Send AddCommand "Get_Licensed_Max_Users "
94393>>>>>>>>>        Send AddCommand "Get_StrictEval "
94394>>>>>>>>>        Send AddCommand "Get_Transaction_Retry "
94395>>>>>>>>>        Send AddCommand "Get_Windows_Directory "
94396>>>>>>>>>        Send AddCommand "GetAddress "
94397>>>>>>>>>        Send AddCommand "GetBuff "
94398>>>>>>>>>        Send AddCommand "GetBuff_String "
94399>>>>>>>>>        Send AddCommand "GetDskInfo "
94400>>>>>>>>>        Send AddCommand "Global_Variable "
94401>>>>>>>>>        Send AddCommand "Include_Resource "
94402>>>>>>>>>        Send AddCommand "Increment "
94403>>>>>>>>>        Send AddCommand "Indicate "
94404>>>>>>>>>        Send AddCommand "Indicator "
94405>>>>>>>>>        Send AddCommand "Load_Def "
94406>>>>>>>>>        Send AddCommand "Load_Driver "
94407>>>>>>>>>        Send AddCommand "Lock"
94408>>>>>>>>>        Send AddCommand "Login "
94409>>>>>>>>>        Send AddCommand "Logout"
94410>>>>>>>>>        Send AddCommand "Make_Directory "
94411>>>>>>>>>        Send AddCommand "Make_File "
94412>>>>>>>>>        Send AddCommand "Make_Temp_File "
94413>>>>>>>>>        Send AddCommand "Move "
94414>>>>>>>>>        Send AddCommand "Movedate "
94415>>>>>>>>>        Send AddCommand "Moveint "
94416>>>>>>>>>        Send AddCommand "Movenum "
94417>>>>>>>>>        Send AddCommand "Movereal "
94418>>>>>>>>>        Send AddCommand "Movestr "
94419>>>>>>>>>        Send AddCommand "NewRecord "
94420>>>>>>>>>        Send AddCommand "On_Item"
94421>>>>>>>>>        Send AddCommand "On_key "
94422>>>>>>>>>        Send AddCommand "Open "
94423>>>>>>>>>        Send AddCommand "Output "
94424>>>>>>>>>        Send AddCommand "Output_Aux_File "
94425>>>>>>>>>        Send AddCommand "Output_Wrap"
94426>>>>>>>>>        Send AddCommand "Playwave "
94427>>>>>>>>>        Send AddCommand "Procedure_Return"
94428>>>>>>>>>        Send AddCommand "Property "
94429>>>>>>>>>        Send AddCommand "Put "
94430>>>>>>>>>        Send AddCommand "Read "
94431>>>>>>>>>        Send AddCommand "Read_Block "
94432>>>>>>>>>        Send AddCommand "Read_hex "
94433>>>>>>>>>        Send AddCommand "Readln "
94434>>>>>>>>>        Send AddCommand "Reg_Close_Key "
94435>>>>>>>>>        Send AddCommand "Reg_Enum_Key "
94436>>>>>>>>>        Send AddCommand "Reg_Enum_Key_Info "
94437>>>>>>>>>        Send AddCommand "Reg_Enum_Value "
94438>>>>>>>>>        Send AddCommand "Relate "
94439>>>>>>>>>        Send AddCommand "Remove_Directory "
94440>>>>>>>>>        Send AddCommand "Renamefile "
94441>>>>>>>>>        Send AddCommand "Report_Breaks "
94442>>>>>>>>>        Send AddCommand "Reread"
94443>>>>>>>>>        Send AddCommand "RunProgram "
94444>>>>>>>>>        Send AddCommand "Save "
94445>>>>>>>>>        Send AddCommand "SaveRecord "
94446>>>>>>>>>        Send AddCommand "Send "
94447>>>>>>>>>        Send AddCommand "Set "
94448>>>>>>>>>        Send AddCommand "Set_Argument_Size "
94449>>>>>>>>>        Send AddCommand "Set_Attribute "
94450>>>>>>>>>        Send AddCommand "Set_Channel_Position "
94451>>>>>>>>>        Send AddCommand "Set_Date_Attribute "
94452>>>>>>>>>        Send AddCommand "Set_Directory "
94453>>>>>>>>>        Send AddCommand "Set_Field_Value "
94454>>>>>>>>>        Send AddCommand "Set_File_Mod_Time "
94455>>>>>>>>>        Send AddCommand "Set_Foreign_Profile_String "
94456>>>>>>>>>        Send AddCommand "set_registry_root "
94457>>>>>>>>>        Send AddCommand "Set_Relate "
94458>>>>>>>>>        Send AddCommand "Set_StrictEval "
94459>>>>>>>>>        Send AddCommand "Set_Transaction_Retry "
94460>>>>>>>>>        Send AddCommand "Shift_State "
94461>>>>>>>>>        Send AddCommand "Show "
94462>>>>>>>>>        Send AddCommand "Showln"
94463>>>>>>>>>        Send AddCommand "Sleep "
94464>>>>>>>>>        Send AddCommand "Sort "
94465>>>>>>>>>        Send AddCommand "Start_UI"
94466>>>>>>>>>        Send AddCommand "Structure_Abort "
94467>>>>>>>>>        Send AddCommand "Structure_Copy "
94468>>>>>>>>>        Send AddCommand "Structure_End "
94469>>>>>>>>>        Send AddCommand "Structure_Start "
94470>>>>>>>>>        Send AddCommand "Subtract "
94471>>>>>>>>>        Send AddCommand "Sysdate "
94472>>>>>>>>>        Send AddCommand "Sysdate4 "
94473>>>>>>>>>        Send AddCommand "Unload_Driver "
94474>>>>>>>>>        Send AddCommand "Unlock"   
94475>>>>>>>>>        Send AddCommand "Until"
94476>>>>>>>>>        Send AddCommand "Valid_Drive "
94477>>>>>>>>>        Send AddCommand "ValueTreeDeserializeParameter "
94478>>>>>>>>>        Send AddCommand "ValueTreeSerializeParameter "
94479>>>>>>>>>        Send AddCommand "VConstrain "
94480>>>>>>>>>        Send AddCommand "Version_Information "
94481>>>>>>>>>        Send AddCommand "VFind "
94482>>>>>>>>>        Send AddCommand "Virtual_Key "
94483>>>>>>>>>        Send AddCommand "WebGet "
94484>>>>>>>>>        Send AddCommand "WebPublishFunction "
94485>>>>>>>>>        Send AddCommand "WebPublishProcedure "
94486>>>>>>>>>        Send AddCommand "WebSet "
94487>>>>>>>>>        Send AddCommand "WebSetResponsive "
94488>>>>>>>>>        Send AddCommand "While "
94489>>>>>>>>>        Send AddCommand "Write "
94490>>>>>>>>>        Send AddCommand "Write_Hex "
94491>>>>>>>>>        Send AddCommand "WriteLn"
94492>>>>>>>>>        Send AddCommand "ZeroFile "
94493>>>>>>>>>        Send AddCommand "ZeroString "
94494>>>>>>>>>        Send AddCommand "ZeroType "
94495>>>>>>>>>    End_Procedure
94496>>>>>>>>>
94496>>>>>>>>>    Procedure AddAllCommandFunctions
94498>>>>>>>>>        String[] Empty
94499>>>>>>>>>
94499>>>>>>>>>        Set paCommandFunctions to Empty
94500>>>>>>>>>
94500>>>>>>>>>        Send AddCommandFunction "Repeat"  
94501>>>>>>>>>        Send AddCommandFunction "If "
94502>>>>>>>>>        Send AddCommandFunction "Else "  
94503>>>>>>>>>        Send AddCommandFunction "Pos"
94504>>>>>>>>>        Send AddCommandFunction "Insert"
94505>>>>>>>>>    End_Procedure
94506>>>>>>>>>
94506>>>>>>>>>//    Procedure Activating
94506>>>>>>>>>//        Send AddAllCommands  
94506>>>>>>>>>//        Send AddAllCommandFunctions
94506>>>>>>>>>//    End_Procedure
94506>>>>>>>>>
94506>>>>>>>>>    // splits a line to a string array.
94506>>>>>>>>>    // Ignores any special characters, spaces or new line, CR "multi line"
94506>>>>>>>>>    Function SplitTextByLengthPure Global String sText Integer iAntal Returns String[]
94508>>>>>>>>>        String s
94508>>>>>>>>>        String[] saText
94509>>>>>>>>>    
94509>>>>>>>>>        Move sText to s
94510>>>>>>>>>    
94510>>>>>>>>>        While (Length(s) > 0)
94514>>>>>>>>>            Move (Mid(s, iAntal, 1)) to saText[(SizeOfArray(saText))]
94515>>>>>>>>>            Move (Mid(s, (Length(s) - iAntal), (iAntal + 1))) to s
94516>>>>>>>>>        Loop
94517>>>>>>>>>>
94517>>>>>>>>>    
94517>>>>>>>>>        Function_Return saText
94518>>>>>>>>>    End_Function
94519>>>>>>>>>
94519>>>>>>>>>    // Splits a string to a string array.
94519>>>>>>>>>    Function Split String sSplitKey String sText Returns String[]
94521>>>>>>>>>        String[] sArray
94522>>>>>>>>>        Integer iLeftPos
94522>>>>>>>>>        Boolean bAtLeastOneSplit
94522>>>>>>>>>    
94522>>>>>>>>>        Move (ResizeArray(sArray, 0)) to sArray
94523>>>>>>>>>        If ((sSplitKey = "") and ((Length(sSplitKey)) = 0)) Begin
94525>>>>>>>>>            For iLeftPos from 1 to ((Length(sText)))
94531>>>>>>>>>>
94531>>>>>>>>>                Move (Mid(sText, 1, iLeftPos)) to sArray[SizeOfArray(sArray)]
94532>>>>>>>>>            Loop
94533>>>>>>>>>>
94533>>>>>>>>>        End
94533>>>>>>>>>>
94533>>>>>>>>>        Else Begin
94534>>>>>>>>>            Move (Pos(sSplitKey, sText)) to iLeftPos
94535>>>>>>>>>    
94535>>>>>>>>>            While (iLeftPos > 0)
94539>>>>>>>>>                Move True to bAtLeastOneSplit
94540>>>>>>>>>                Move (Left(sText, iLeftPos - 1)) to sArray[SizeOfArray(sArray)]
94541>>>>>>>>>                Move (Right(sText, ((Length(sText) - (iLeftPos + (Length(sSplitKey))) )+1))) to sText
94542>>>>>>>>>                Move (Pos(sSplitKey, sText)) to iLeftPos
94543>>>>>>>>>            Loop
94544>>>>>>>>>>
94544>>>>>>>>>    
94544>>>>>>>>>            // Ta med text hger om sista splittecknet
94544>>>>>>>>>            Move sText to sArray[SizeOfArray(sArray)]
94545>>>>>>>>>        End
94545>>>>>>>>>>
94545>>>>>>>>>    
94545>>>>>>>>>        Function_Return sArray
94546>>>>>>>>>    End_Function
94547>>>>>>>>>
94547>>>>>>>>>    // Create a string by joining array elements using a separator
94547>>>>>>>>>    Function JoinArray Global String[] saValues String sSeparator Returns String
94549>>>>>>>>>        Integer i iLength
94549>>>>>>>>>        String sRet
94549>>>>>>>>>        Move "" to sRet
94550>>>>>>>>>        Move (SizeOfArray(saValues)-1) to iLength
94551>>>>>>>>>        For i from 0 to iLength
94557>>>>>>>>>>
94557>>>>>>>>>            // First element
94557>>>>>>>>>            If (i = 0) Begin
94559>>>>>>>>>                Append sRet saValues[i]
94560>>>>>>>>>            End
94560>>>>>>>>>>
94560>>>>>>>>>            // Other elements
94560>>>>>>>>>            Else Begin
94561>>>>>>>>>                Append sRet sSeparator saValues[i]
94563>>>>>>>>>            End
94563>>>>>>>>>>
94563>>>>>>>>>        Loop
94564>>>>>>>>>>
94564>>>>>>>>>        Function_Return sRet
94565>>>>>>>>>    End_Function
94566>>>>>>>>>
94566>>>>>>>>>    // Convert Integer to a binary value
94566>>>>>>>>>    // Courtesy of Frank Cheng.
94566>>>>>>>>>    Function IntToBinary Global Integer i Returns String
94568>>>>>>>>>        String sResult
94568>>>>>>>>>        If (i < 0) Function_Return ""
94571>>>>>>>>>        Move "" to sResult
94572>>>>>>>>>        Repeat
94572>>>>>>>>>>
94572>>>>>>>>>            Move (String(Mod(i, 2)) + sResult) to sResult
94573>>>>>>>>>            Move (i / 2) to i
94574>>>>>>>>>        Until (i = 0)
94576>>>>>>>>>        Function_Return sResult
94577>>>>>>>>>    End_Function
94578>>>>>>>>>
94578>>>>>>>>>    // Courtesy of Frank Cheng.
94578>>>>>>>>>    // There is another verion (HexToInt) in mStrConv.pkg
94578>>>>>>>>>    Function HexToInt2 Global String sNum Returns Integer
94580>>>>>>>>>        Integer iLength iDigit iNum iPower
94580>>>>>>>>>        Move (Length(sNum)) to iLength
94581>>>>>>>>>        Move 1 to iPower
94582>>>>>>>>>        Move 0 to iNum
94583>>>>>>>>>        While (iLength > 0)
94587>>>>>>>>>            Move (Ascii(Mid(sNum,1,iLength))) to iDigit
94588>>>>>>>>>            Subtract (If(iDigit > 57, 55, 48)) from iDigit
94589>>>>>>>>>            Add (iDigit * iPower) to iNum
94590>>>>>>>>>            Move (iPower * 16) to iPower
94591>>>>>>>>>            Decrement iLength
94592>>>>>>>>>        Loop
94593>>>>>>>>>>
94593>>>>>>>>>        Function_Return iNum
94594>>>>>>>>>    End_Function
94595>>>>>>>>>
94595>>>>>>>>>    // Curtesy of Evertjan Dondergoor DAE
94595>>>>>>>>>    Function SQLDateTimeToDFDateTime String s Returns DateTime
94597>>>>>>>>>        DateTime dt
94597>>>>>>>>>        Integer iYear iMonth iDay
94597>>>>>>>>>        Integer iHour iMinute iSecond
94597>>>>>>>>>
94597>>>>>>>>>        Move (Mid(s, 4,  1)) to iYear
94598>>>>>>>>>        Move (Mid(s, 2,  6)) to iMonth
94599>>>>>>>>>        Move (Mid(s, 2,  9)) to iDay
94600>>>>>>>>>        Move (Mid(s, 2, 12)) to iHour
94601>>>>>>>>>        Move (Mid(s, 2, 15)) to iMinute
94602>>>>>>>>>        Move (Mid(s, 2, 18)) to iSecond
94603>>>>>>>>>
94603>>>>>>>>>        Move (DateSetYear  (dt, iYear  )) to dt
94604>>>>>>>>>        Move (DateSetMonth (dt, iMonth )) to dt
94605>>>>>>>>>        Move (DateSetDay   (dt, iDay   )) to dt
94606>>>>>>>>>        Move (DateSetHour  (dt, iHour  )) to dt
94607>>>>>>>>>        Move (DateSetMinute(dt, iMinute)) to dt
94608>>>>>>>>>        Move (DateSetSecond(dt, iSecond)) to dt
94609>>>>>>>>>
94609>>>>>>>>>        Function_Return dt
94610>>>>>>>>>    End_Function
94611>>>>>>>>>
94611>>>>>>>>>    // Returns True if the "sCheckFieldName" field exists in the passed iFile datbase table.
94611>>>>>>>>>    // If it doesn't exist, False is returned
94611>>>>>>>>>    Function IsFieldExisting Integer iFile String sCheckFieldName Returns Boolean
94613>>>>>>>>>        Integer iNumFields iCount                                      
94613>>>>>>>>>        String sFieldName
94613>>>>>>>>>      
94613>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
94616>>>>>>>>>        Decrement iNumFields
94617>>>>>>>>>        For iCount from 0 to iNumFields  
94623>>>>>>>>>>
94623>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iCount to sFieldName        
94626>>>>>>>>>            If ((Uppercase (sFieldName)) = (Uppercase (sCheckFieldName))) Begin
94628>>>>>>>>>                Function_Return True
94629>>>>>>>>>            End
94629>>>>>>>>>>
94629>>>>>>>>>        Loop
94630>>>>>>>>>>
94630>>>>>>>>>      
94630>>>>>>>>>        Function_Return False
94631>>>>>>>>>    End_Function
94632>>>>>>>>>
94632>>>>>>>>>End_Class       
94633>>>>>>>Use vWin32fh.pkg
94633>>>>>>>
94633>>>>>>>Struct tUnusedLocals
94633>>>>>>>    Boolean bInUse
94633>>>>>>>    String VarName
94633>>>>>>>    String MethodName
94633>>>>>>>    Integer Line#
94633>>>>>>>End_Struct
94633>>>>>>>
94633>>>>>>>Define CS_UnusedVariablesLogFile for "UnusedVariables.txt"
94633>>>>>>>
94633>>>>>>>Class cRemoveUnusedLocals is a cObject
94634>>>>>>>    Procedure Construct_Object
94636>>>>>>>        String[] asLocalVariableTypes asLocalVariableArrayTypes
94638>>>>>>>
94638>>>>>>>        Forward Send Construct_Object
94640>>>>>>>        
94640>>>>>>>        Property String[] pasLocalVariableTypes
94641>>>>>>>            Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
94642>>>>>>>            Set pasLocalVariableTypes to asLocalVariableTypes
94643>>>>>>>
94643>>>>>>>        Property String[] pasLocalVariableArrayTypes
94644>>>>>>>            Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
94645>>>>>>>            Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes
94646>>>>>>>
94646>>>>>>>        Property String[] pasSourceFile
94647>>>>>>>        Property Integer piNoOfUnusedLocalVariables 0
94648>>>>>>>
94648>>>>>>>    End_Procedure
94649>>>>>>>
94649>>>>>>>    // Remove all variables that are used.
94649>>>>>>>    Function CleanupLocalVariables tUnusedLocals[] asLocalVariables Returns tUnusedLocals
94651>>>>>>>        Integer iCount iSize
94651>>>>>>>
94651>>>>>>>        Move (SortArray(asLocalVariables))   to asLocalVariables
94652>>>>>>>        Move (SizeOfArray(asLocalVariables)) to iSize
94653>>>>>>>        Decrement iSize
94654>>>>>>>        For iCount From 0 to iSize
94660>>>>>>>>
94660>>>>>>>            If (asLocalVariables[iCount].bInUse = True) Begin
94662>>>>>>>                Move (RemoveFromArray(asLocalVariables, iCount)) to asLocalVariables
94663>>>>>>>                Decrement iSize
94664>>>>>>>                Decrement iCount
94665>>>>>>>            End
94665>>>>>>>>
94665>>>>>>>        Loop
94666>>>>>>>>
94666>>>>>>>
94666>>>>>>>        Function_Return asLocalVariables
94667>>>>>>>    End_Function
94668>>>>>>>
94668>>>>>>>    // Custom comparison function:
94668>>>>>>>    //   Returns (GT) struct value in first parameter > struct value in second parameter.
94668>>>>>>>    //   Returns (LT) struct value in first parameter < struct value in second parameter.
94668>>>>>>>    //   Otherwise returns (EQ).
94668>>>>>>>    Function CompareLineNum tUnusedLocals Local1 tUnusedLocals Local2 Returns Integer
94670>>>>>>>        If (Local1.Line# > Local2.Line#) ;            Function_Return (GT)
94673>>>>>>>        If (Local1.Line# < Local2.Line#) ;            Function_Return (LT)
94676>>>>>>>        Function_Return (EQ)
94677>>>>>>>    End_Function
94678>>>>>>>
94678>>>>>>>    // We now have the source file array and the unused variables struct array.
94678>>>>>>>    // Remove those unused variables from the source file array.
94678>>>>>>>    Procedure RemoveUnusedVariablesFromSourceArray String[] ByRef asSourceFile tUnusedLocals[] asLocalVariables Integer ByRef iUnusedLocalVariables
94680>>>>>>>        Integer iCount iSize iItem iLength iOffset
94680>>>>>>>        String sVarName sLine sVarType sVariableDeclarationConstant
94680>>>>>>>        Boolean bInUse bFound bIgnore bChanged
94680>>>>>>>
94680>>>>>>>        Move 0 to iOffset
94681>>>>>>>        Get CleanupLocalVariables asLocalVariables      to asLocalVariables
94682>>>>>>>        Move (SizeOfArray(asLocalVariables))            to iSize
94683>>>>>>>        // sort array by line number as otherwise the iOffset logic won't work!
94683>>>>>>>        Move (SortArray(asLocalVariables, Self, (RefFunc(CompareLineNum)))) to asLocalVariables
94684>>>>>>>        Decrement iSize
94685>>>>>>>        For iCount From 0 to iSize
94691>>>>>>>>
94691>>>>>>>            Move asLocalVariables[iCount].bInUse        to bInUse
94692>>>>>>>            If (bInUse = False) Begin
94694>>>>>>>                Move asLocalVariables[iCount].Line#     to iItem
94695>>>>>>>                Move (iItem - 1 + iOffset)              to iItem
94696>>>>>>>                Move asLocalVariables[iCount].VarName   to sVarName
94697>>>>>>>                Move (Length(sVarName))                 to iLength
94698>>>>>>>                Move asSourceFile[iItem]                to sLine
94699>>>>>>>                Get RemoveLocalKeyWord of ghoRefactorFunctionLibrary (&sLine) to bIgnore
94700>>>>>>>                Get _RetrieveFirstWord of ghoRefactorFunctionLibrary sLine    to sVarType
94701>>>>>>>
94701>>>>>>>                Move ((sLine+" ") contains (" " + sVarName + " "))  to bFound
94702>>>>>>>                If (bFound = False) Begin
94704>>>>>>>                    Move (sLine contains sVarName)      to bFound
94705>>>>>>>                End
94705>>>>>>>>
94705>>>>>>>                If (bFound = True) Begin
94707>>>>>>>                    Move (Replace((" " + sVarName + " "), sLine+" ", " ")) to sLine
94708>>>>>>>                End
94708>>>>>>>>
94708>>>>>>>
94708>>>>>>>                Get _NormalizeArrayNotation of ghoRefactorFunctionLibrary (&sLine) to bChanged
94709>>>>>>>                // If all that remains on the line is the variable type declaration,
94709>>>>>>>                // remove the line from the source array.
94709>>>>>>>                Move sLine to sVariableDeclarationConstant
94710>>>>>>>                Get RemoveLocalKeyWord of ghoRefactorFunctionLibrary (&sVariableDeclarationConstant) to bIgnore
94711>>>>>>>                Get _RemoveEndComment of ghoRefactorFunctionLibrary sVariableDeclarationConstant to sVariableDeclarationConstant
94712>>>>>>>                Move (Trim(sVariableDeclarationConstant)) to sVariableDeclarationConstant
94713>>>>>>>                If (sVarType = sVariableDeclarationConstant) Begin
94715>>>>>>>                    Move (RemoveFromArray(asSourceFile, iItem)) to asSourceFile
94716>>>>>>>                    Decrement iOffset
94717>>>>>>>                End
94717>>>>>>>>
94717>>>>>>>                Else Begin
94718>>>>>>>                    Move (RTrim(sLine)) to sLine
94719>>>>>>>                    Move sLine to asSourceFile[iItem]
94720>>>>>>>                End
94720>>>>>>>>
94720>>>>>>>
94720>>>>>>>                Increment iUnusedLocalVariables
94721>>>>>>>            End
94721>>>>>>>>
94721>>>>>>>        Loop
94722>>>>>>>>
94722>>>>>>>
94722>>>>>>>        Procedure_Return
94723>>>>>>>    End_Procedure
94724>>>>>>>    
94724>>>>>>>    // *** MAIN PROCEDURE ***
94724>>>>>>>    // Call this and pass a source file as string ByRef array.
94724>>>>>>>    // Returns number of unused local variables
94724>>>>>>>    Function MainProcedure String[] ByRef asSourceFile Returns Integer
94726>>>>>>>        Set piNoOfUnusedLocalVariables to 0
94727>>>>>>>        Send ParseFile (&asSourceFile)
94728>>>>>>>        Function_Return (piNoOfUnusedLocalVariables(Self))
94729>>>>>>>    End_Function
94730>>>>>>>
94730>>>>>>>    Procedure ParseFile String[] ByRef asSourceFile
94732>>>>>>>        String sLine sVars sVariableName sMethodName sSourceFile
94732>>>>>>>        Integer iArrayCount iMax iCounter iItems iLineCount iUnusedLocalVariables iSize iCount
94732>>>>>>>        tUnusedLocals[] asLocalVars
94732>>>>>>>        tUnusedLocals[] asLocalVars
94733>>>>>>>        String[] asVars
94734>>>>>>>        Boolean bComment bInMethod bVariableDeclaration bIsVariable bMethodEnd bIgnore
94734>>>>>>>
94734>>>>>>>        Move (SizeOfArray(asSourceFile)) to iSize
94735>>>>>>>        If (iSize = 0) Begin
94737>>>>>>>            Get psIdleText of (phoStatusBar(ghoCommandBars)) to sSourceFile
94738>>>>>>>            Send Info_Box ("Source File Array is empty.\n" + String(sSourceFile)) "Error in ParseFile method [cRemoveUnusedLocals.pkg]"
94739>>>>>>>            Move True to Err
94740>>>>>>>            Procedure_Return
94741>>>>>>>        End
94741>>>>>>>>
94741>>>>>>>
94741>>>>>>>        Move False to bMethodEnd
94742>>>>>>>        Decrement iSize
94743>>>>>>>        Move False to Err
94744>>>>>>>        Move 0 to iUnusedLocalVariables
94745>>>>>>>
94745>>>>>>>        For iCount From 0 to iSize
94751>>>>>>>>
94751>>>>>>>            Move asSourceFile[iCount] to sLine
94752>>>>>>>            Move (Trim(sLine)) to sLine
94753>>>>>>>            Get _OverstrikeStrings of ghoRefactorFunctionLibrary sLine to sLine
94754>>>>>>>            Get _RemoveEndComment  of ghoRefactorFunctionLibrary sLine to sLine
94755>>>>>>>            Get IsCommentLine      of ghoRefactorFunctionLibrary sLine to bComment
94756>>>>>>>
94756>>>>>>>            If (bComment = False and Trim(sLine) <> "") Begin
94758>>>>>>>                Get IsMethodStart of ghoRefactorFunctionLibrary sLine to bInMethod
94759>>>>>>>                Get IsMethodEnd   of ghoRefactorFunctionLibrary sLine to bMethodEnd
94760>>>>>>>                If (bInMethod = True and bMethodEnd = False) Begin
94762>>>>>>>                    Get _MethodName of ghoRefactorFunctionLibrary sLine to sMethodName
94763>>>>>>>                    // To start reading the next line after the start "Procedure" or "Function" line
94763>>>>>>>                    Move (iCount + 1) to iLineCount
94764>>>>>>>                    // If the method declaration is split over multiple lines, then we need to get past that part
94764>>>>>>>                    While (Right(Trim(sLine), 1) = ";")
94768>>>>>>>                        If (iLineCount <= iSize) Begin
94770>>>>>>>                            Move asSourceFile[iLineCount] to sLine
94771>>>>>>>                        End
94771>>>>>>>>
94771>>>>>>>                        Else Begin
94772>>>>>>>                          Move "" to sLine
94773>>>>>>>                        End
94773>>>>>>>>
94773>>>>>>>
94773>>>>>>>                        Get _OverstrikeStrings sLine to sLine
94774>>>>>>>                        Get _RemoveEndComment of ghoRefactorFunctionLibrary sLine to sLine
94775>>>>>>>                        Increment iLineCount
94776>>>>>>>                    Loop
94777>>>>>>>>
94777>>>>>>>
94777>>>>>>>                    // Begin search line-by-line until "End_Procedure" or "End_Function"
94777>>>>>>>                    Repeat
94777>>>>>>>>
94777>>>>>>>                        If (iLineCount <= iSize) Begin
94779>>>>>>>                            Move asSourceFile[iLineCount] to sLine
94780>>>>>>>                        End
94780>>>>>>>>
94780>>>>>>>
94780>>>>>>>                        Move (Trim(sLine)) to sLine
94781>>>>>>>                        Get _OverstrikeStrings of ghoRefactorFunctionLibrary sLine to sLine
94782>>>>>>>                        Get _RemoveEndComment  of ghoRefactorFunctionLibrary sLine to sLine
94783>>>>>>>                        Get IsCommentLine      of ghoRefactorFunctionLibrary sLine to bComment
94784>>>>>>>                        Get IsMethodEnd        of ghoRefactorFunctionLibrary sLine to bMethodEnd
94785>>>>>>>                        If (bComment = False and bMethodEnd = False and Trim(sLine) <> "") Begin
94787>>>>>>>                            Get RemoveLocalKeyWord of ghoRefactorFunctionLibrary (&sLine) to bIgnore
94788>>>>>>>
94788>>>>>>>                            // Does the line contain one or more variable declarations?
94788>>>>>>>                            Get IsVariableDeclarationLine of ghoRefactorFunctionLibrary sLine to bVariableDeclaration
94789>>>>>>>                            If (bVariableDeclaration = True) Begin
94791>>>>>>>                            // Remove the data type command
94791>>>>>>>                                Get _RemoveFirstWord of ghoRefactorFunctionLibrary sLine to sVars
94792>>>>>>>                                Move (StrSplitToArray(Trim(sVars), " ")) to asVars
94793>>>>>>>
94793>>>>>>>                                // Loop through the variable's array and add to struct array of locally declared variables.
94793>>>>>>>                                // Need to do this here because we don't know where the programmer will place variable declarations,
94793>>>>>>>                                // so we need to update the array as they occur.
94793>>>>>>>                                Move (SizeOfArray(asVars)) to iItems
94794>>>>>>>                                Decrement iItems
94795>>>>>>>                                For iCounter From 0 to iItems
94801>>>>>>>>
94801>>>>>>>                                    Move asVars[iCounter] to sVariableName
94802>>>>>>>                                    Move (SizeOfArray(asLocalVars)) to iArrayCount
94803>>>>>>>
94803>>>>>>>                                    // If the procedure or function line is wrapped, it may
94803>>>>>>>                                    // contain the variable type, and we don't want that
94803>>>>>>>                                    // showing up as an unused variable
94803>>>>>>>                                    If ((not((CS_VarTypes + ";") contains Uppercase(sVariableName+";")) or not(CS_VarArrayTypes contains Uppercase(sVariableName))) and Trim(sVariableName) <> "") Begin
94805>>>>>>>                                        Move sVariableName    to asLocalVars[iArrayCount].VarName
94806>>>>>>>                                        Move False            to asLocalVars[iArrayCount].bInUse
94807>>>>>>>                                        Move sMethodName      to asLocalVars[iArrayCount].MethodName
94808>>>>>>>                                        // Array item number (zero based) to source code line number:
94808>>>>>>>                                        Move (iLineCount + 1) to asLocalVars[iArrayCount].Line#
94809>>>>>>>                                    End
94809>>>>>>>>
94809>>>>>>>                                Loop
94810>>>>>>>>
94810>>>>>>>                            End
94810>>>>>>>>
94810>>>>>>>
94810>>>>>>>                            // If not a variable declaration line. For each line, we look in the asLocalVars array,
94810>>>>>>>                            // and if the variable is found we mark it as "used"
94810>>>>>>>                            Else Begin
94811>>>>>>>                                If (Trim(sLine) <> "") Begin
94813>>>>>>>                                    Move (SizeOfArray(asLocalVars)) to iMax
94814>>>>>>>                                    Decrement iMax
94815>>>>>>>                                    For iCounter From 0 to iMax
94821>>>>>>>>
94821>>>>>>>                                        If (asLocalVars[iCounter].bInUse = False and asLocalVars[iCounter].MethodName = sMethodName) Begin
94823>>>>>>>                                            Get IsVariableInLine of ghoRefactorFunctionLibrary sLine asLocalVars[iCounter].VarName to bIsVariable
94824>>>>>>>                                            If (bIsVariable = True) Begin
94826>>>>>>>                                                // Mark as found
94826>>>>>>>                                                Move True to asLocalVars[iCounter].bInUse
94827>>>>>>>                                            End
94827>>>>>>>>
94827>>>>>>>                                        End
94827>>>>>>>>
94827>>>>>>>                                    Loop
94828>>>>>>>>
94828>>>>>>>                                End
94828>>>>>>>>
94828>>>>>>>                            End
94828>>>>>>>>
94828>>>>>>>                        End
94828>>>>>>>>
94828>>>>>>>
94828>>>>>>>                        Increment iLineCount
94829>>>>>>>                    Until (bMethodEnd or iCount = iSize or iLineCount >= iSize)
94831>>>>>>>                End
94831>>>>>>>>
94831>>>>>>>            End
94831>>>>>>>>
94831>>>>>>>            If (iCount < iLineCount) Begin
94833>>>>>>>                Move iLineCount to iCount
94834>>>>>>>            End
94834>>>>>>>>
94834>>>>>>>        Loop
94835>>>>>>>>
94835>>>>>>>
94835>>>>>>>        If (SizeOfArray(asLocalVars)) Begin
94837>>>>>>>            Send RemoveUnusedVariablesFromSourceArray (&asSourceFile) asLocalVars (&iUnusedLocalVariables)
94838>>>>>>>        End
94838>>>>>>>>
94838>>>>>>>
94838>>>>>>>        Get piNoOfUnusedLocalVariables to iCounter
94839>>>>>>>        Set piNoOfUnusedLocalVariables to (iCounter + iUnusedLocalVariables)
94840>>>>>>>    End_Procedure
94841>>>>>>>
94841>>>>>>>End_Class
94842>>>>>Use cUnusedSourceFiles.pkg
94842>>>>>Use cScintillaRefactorEditor.pkg
94842>>>>>Use cRefactorFunctionLibrary.pkg
94842>>>>>
94842>>>>>Use cSysFileDataDictionary.dd      
94842>>>>>Use cFunctionsDataDictionary.dd
Including file: cFunctionsDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cFunctionsDataDictionary.dd)
94842>>>>>>>Use DataDict.pkg  
94842>>>>>>>Use RefactorFunctionConstants.inc
94842>>>>>>>
94842>>>>>>>Open SysFile    
94844>>>>>>>Open Functions
Including file: Functions.fd    (C:\Projects\DF18\DfRefactor\DDSrc\Functions.fd)
94846>>>>>>>Open FunctionsA
94848>>>>>>>Set_Attribute DF_FILE_ALIAS of Functions.File_Number to DF_FILE_IS_MASTER
94851>>>>>>>Set_Attribute DF_FILE_ALIAS of FunctionsA.File_Number to DF_FILE_IS_ALIAS
94854>>>>>>>
94854>>>>>>>Struct tFunctionTypes
94854>>>>>>>    Integer iAll_Functions
94854>>>>>>>    Integer iStandard_Function
94854>>>>>>>    Integer iRemove_Function
94854>>>>>>>    Integer iEditor_Function
94854>>>>>>>    Integer iReport_Function   
94854>>>>>>>    Integer iReport_FunctionAll
94854>>>>>>>    Integer iOther_Function
94854>>>>>>>    Integer iOther_FunctionAll
94854>>>>>>>End_Struct
94854>>>>>>>
94854>>>>>>>Enum_List
94854>>>>>>>    Define eAll_Functions         for 0 
94854>>>>>>>    Define eStandard_Function     for 1   // One source line at a time will be passed for these functions.
94854>>>>>>>    Define eRemove_Function       for 2   // One source line at a time will be passed for these functions.
94854>>>>>>>    Define eEditor_Function       for 3   // A source file as a string array will be passed
94854>>>>>>>    Define eReport_Function       for 4   // A source file as a string array. Makes no source changes.
94854>>>>>>>    Define eReport_FunctionAll    for 5   // Makes no source changes.
94854>>>>>>>    Define eOther_Function        for 6   // A source file as a string array will be passed.
94854>>>>>>>    Define eOther_FunctionAll     for 7   // All selected files as a string array will be passed. 
94854>>>>>>>End_Enum_List
94854>>>>>>>
94854>>>>>>>Define CS_All_Functions             for "All functions"
94854>>>>>>>Define CS_Standard_Function         for "Standard - Line-by-line"
94854>>>>>>>Define CS_Remove_Function           for "Remove   - Line-by-line"
94854>>>>>>>Define CS_Editor_Function           for "Editor   - One File"
94854>>>>>>>Define CS_Report_Function           for "Report   - One File"   // Makes no source changes.
94854>>>>>>>Define CS_Report_FunctionAll        for "Report   - All Files"  // Makes no source changes.
94854>>>>>>>Define CS_Other_Function            for "Other    - One File"
94854>>>>>>>Define CS_Other_FunctionAll         for "Other    - All Files"
94854>>>>>>>
94854>>>>>>>Object oFunctionTypes is a DescriptionValidationTable
94856>>>>>>>    Procedure Fill_List
94859>>>>>>>        Forward Send Fill_List
94861>>>>>>>        Send Add_Table_Value eStandard_Function   CS_Standard_Function
94862>>>>>>>        Send Add_Table_Value eRemove_Function     CS_Remove_Function
94863>>>>>>>        Send Add_Table_Value eEditor_Function     CS_Editor_Function
94864>>>>>>>        Send Add_Table_Value eReport_Function     CS_Report_Function
94865>>>>>>>        Send Add_Table_Value eReport_FunctionAll  CS_Report_FunctionAll
94866>>>>>>>        Send Add_Table_Value eOther_Function      CS_Other_Function
94867>>>>>>>        Send Add_Table_Value eOther_FunctionAll   CS_Other_FunctionAll
94868>>>>>>>    End_Procedure
94869>>>>>>>End_Object
94870>>>>>>>
94870>>>>>>>Register_Object oFunctions_sl
94870>>>>>>>
94870>>>>>>>Class cFunctionsDataDictionary is a DataDictionary
94871>>>>>>>    
94871>>>>>>>    Procedure Construct_Object
94873>>>>>>>        Forward Send Construct_Object        
94875>>>>>>>        
94875>>>>>>>        Property Integer piFunctionType eAll_Functions
94876>>>>>>>
94876>>>>>>>        Set Main_File to Functions.File_Number
94877>>>>>>>        Set Add_System_File to SysFile.File_Number DD_Lock_On_All
94878>>>>>>>
94878>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
94879>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
94880>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
94881>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
94882>>>>>>>
94882>>>>>>>        Set Field_Auto_Increment Field Functions.ID to File_Field SysFile.Next_Functions_ID
94883>>>>>>>        Set Key_Field_State Field Functions.ID to True
94884>>>>>>>        Set Field_Prompt_Object Field Functions.ID to oFunctions_sl
94885>>>>>>>        Set Status_Help Field Functions.ID to "Automatically generated ID number"
94886>>>>>>>
94886>>>>>>>        Set Field_Prompt_Object Field Functions.Function_Name to oFunctions_sl
94887>>>>>>>        Set Status_Help Field Functions.Function_Name to "the name entered must be exactly the same as the function name itself. Then the code must be added to the cRefactorDbView class (cRefactorDbView.pkg). See class code for standard function parameters."
94888>>>>>>>
94888>>>>>>>        Set Status_Help Field Functions.Function_Description to "A short description of what the function does. Appears in grids next to the function name."
94889>>>>>>>
94889>>>>>>>        Set Status_Help Field Functions.Function_Help to "Longer explanation on what the function does. Shows when the mouse hovers above a function grid."
94890>>>>>>>
94890>>>>>>>        Set Status_Help Field Functions.Function_Summary to "Function summary text that appears after a refactoring has run."
94891>>>>>>>
94891>>>>>>>        Set Field_Class_Name Field Functions.Selected to "Checkbox"
94892>>>>>>>        Set Field_Checkbox_Values Field Functions.Selected to "1" "0"
94893>>>>>>>        Set Status_Help Field Functions.Selected to "Selected function"
94894>>>>>>>
94894>>>>>>>        Set Field_Value_Table Field Functions.Type to oFunctionTypes
94895>>>>>>>        Set Status_Help Field Functions.Type to "The type of function. The type determines what data is send to the function: Line-by-line, as a String array, or all files as a string array."
94896>>>>>>>        Set Field_Class_Name Field Functions.Type to "Combo"
94897>>>>>>>
94897>>>>>>>        Set Status_Help Field Functions.Count to "Counter for the current refactoring run."
94898>>>>>>>
94898>>>>>>>        Set Field_Class_Name Field Functions.bHasParameter to "Checkbox"
94899>>>>>>>        Set Field_Checkbox_Values Field Functions.bHasParameter to "1" "0"
94900>>>>>>>        Set Status_Help Field Functions.bHasParameter to "This is a system function and may not be changed, because it is handled a bit differently."
94901>>>>>>>
94901>>>>>>>    End_Procedure
94902>>>>>>>
94902>>>>>>>    Procedure Field_Defaults
94904>>>>>>>        Forward Send Field_Defaults
94906>>>>>>>        Set Field_Changed_Value Field Functions.Selected to 0
94907>>>>>>>        Set Field_Changed_Value Field Functions.Type to 0
94908>>>>>>>        Set Field_Changed_Value Field Functions.bHasParameter to 0
94909>>>>>>>    End_Procedure  
94910>>>>>>>    
94910>>>>>>>    Procedure Update
94912>>>>>>>        Integer iType iIndex
94912>>>>>>>        Boolean bState bChangeWriteProtected 
94912>>>>>>>        String sFunctionName sParam sValue
94912>>>>>>>        String[] asValidations
94913>>>>>>>        
94913>>>>>>>        Move Functions.Selected to bState
94914>>>>>>>        Move Functions.Type to iType
94915>>>>>>>        Send AdjustSelected bState iType
94916>>>>>>>        Move (Trim(Functions.Function_Name)) to sFunctionName
94917>>>>>>>        If (not(Lowercase(Functions.Function_Help) contains Lowercase("Function:" * String(sFunctionName)))) Begin
94919>>>>>>>            Move (Trim(Functions.Function_Help) * String("(Function:" * String(sFunctionName) + ")")) ;                to Functions.Function_Help
94920>>>>>>>        End      
94920>>>>>>>>
94920>>>>>>>        
94920>>>>>>>        If (Functions.bHasParameter = True) Begin
94922>>>>>>>            Move (Trim(Functions.Parameter)) to sParam    
94923>>>>>>>            Move (Trim(Functions.ParameterValidation)) to sValue
94924>>>>>>>            Move (StrSplitToArray(sValue, ",")) to asValidations
94925>>>>>>>            Move (SearchArray(sParam, asValidations)) to iIndex
94926>>>>>>>            If (iIndex = -1) Begin
94928>>>>>>>                Send UserError ("Invalid value. Must be one of:" * String(sValue))
94929>>>>>>>            End
94929>>>>>>>>
94929>>>>>>>        End 
94929>>>>>>>>
94929>>>>>>>        Else Begin
94930>>>>>>>            If (Trim(Functions.Parameter) <> "") Begin
94932>>>>>>>                Send UserError "This function doesn't use a parameter and you are therefore not allowed to enter one."
94933>>>>>>>            End
94933>>>>>>>>
94933>>>>>>>        End
94933>>>>>>>>
94933>>>>>>>    End_Procedure
94934>>>>>>>    
94934>>>>>>>    Procedure Backout
94936>>>>>>>        Integer iType iState
94936>>>>>>>        Move Functions.Selected to iState
94937>>>>>>>        Move Functions.Type to iType
94938>>>>>>>        Send AdjustSelected (-iState) iType
94939>>>>>>>    End_Procedure  
94940>>>>>>>    
94940>>>>>>>    Procedure AdjustSelected Integer iState Integer iType 
94942>>>>>>>        String sFunctionName
94942>>>>>>>        Integer iTotFunctions
94942>>>>>>>
94942>>>>>>>        Get TotalNoOfFunctions to iTotFunctions
94943>>>>>>>        Move (Lowercase(Trim(Functions.Function_Name))) to sFunctionName  
94944>>>>>>>        // For handling of special functions.
94944>>>>>>>        Case Begin
94944>>>>>>>            Case (sFunctionName = Lowercase(CS_CountSourceLines)) 
94946>>>>>>>                Move Functions.Selected to SysFile.bCountSourceLines  
94947>>>>>>>                Case Break
94948>>>>>>>            Case (sFunctionName = Lowercase(CS_EditorDropSelf))
94951>>>>>>>                Move Functions.Selected to SysFile.bEditorDropSelf
94952>>>>>>>                Case Break
94953>>>>>>>        Case End
94953>>>>>>>         
94953>>>>>>>        If (iState = 0 or SysFile.SelectedFunctionTotal < iTotFunctions) Begin
94955>>>>>>>            Add iState to SysFile.SelectedFunctionTotal
94956>>>>>>>        End
94956>>>>>>>>
94956>>>>>>>            
94956>>>>>>>        Case Begin
94956>>>>>>>            Case (iType = eStandard_Function) 
94958>>>>>>>                Add iState to SysFile.SelectedStandardFunctions
94959>>>>>>>                Case Break
94960>>>>>>>            Case (iType = eRemove_Function) 
94963>>>>>>>                Add iState to SysFile.SelectedRemoveFunctions
94964>>>>>>>                Case Break
94965>>>>>>>            Case (iType = eEditor_Function) 
94968>>>>>>>                Add iState to SysFile.SelectedEditorFunctions
94969>>>>>>>                Case Break
94970>>>>>>>            Case (iType = eReport_Function) 
94973>>>>>>>                Add iState to SysFile.SelectedReportFunctions
94974>>>>>>>                Case Break
94975>>>>>>>            Case (iType = eReport_FunctionAll) 
94978>>>>>>>                Add iState to SysFile.SelectedReportAllFunctions
94979>>>>>>>                Case Break
94980>>>>>>>            Case (iType = eOther_Function) 
94983>>>>>>>                Add iState to SysFile.SelectedOtherFunctions
94984>>>>>>>                Case Break
94985>>>>>>>            Case (iType = eOther_FunctionAll) 
94988>>>>>>>                Add iState to SysFile.SelectedOtherAllFunctions
94989>>>>>>>                Case Break
94990>>>>>>>        Case End      
94990>>>>>>>            
94990>>>>>>>        SaveRecord SysFile
94991>>>>>>>    End_Procedure
94992>>>>>>>    
94992>>>>>>>    Procedure SelectAll
94994>>>>>>>        Send SelectItems True
94995>>>>>>>    End_Procedure
94996>>>>>>>    
94996>>>>>>>    Procedure DeSelectAll
94998>>>>>>>        Send SelectItems False
94999>>>>>>>    End_Procedure
95000>>>>>>>    
95000>>>>>>>    Procedure SelectItems Boolean bSelect
95002>>>>>>>        Boolean bFound
95002>>>>>>>        Integer iItems iSelected iType iID
95002>>>>>>>        tFunctionTypes FunctionsTypes
95002>>>>>>>        tFunctionTypes FunctionsTypes
95002>>>>>>>        
95002>>>>>>>        Get piFunctionType to iType
95003>>>>>>>        If (bSelect = True) Begin
95005>>>>>>>            Move 1 to iSelected
95006>>>>>>>        End          
95006>>>>>>>>
95006>>>>>>>        Else Begin
95007>>>>>>>            Move -1 to iSelected
95008>>>>>>>        End
95008>>>>>>>>
95008>>>>>>>        
95008>>>>>>>        Move Functions.ID to iID
95009>>>>>>>
95009>>>>>>>        Constraint_Set (Self) Clear  
95011>>>>>>>        Constrained_Clear eq Functions by Index.2 
95014>>>>>>>        If (iType <> eAll_Functions) Begin
95016>>>>>>>            Constrain Functions.Type eq iType
95018>>>>>>>        End
95018>>>>>>>>
95018>>>>>>>        Constrained_Find First Functions by Index.2
95023>>>>>>>        While (Found)
95027>>>>>>>            Reread Functions SysFile    
95034>>>>>>>                Move bSelect to Functions.Selected
95035>>>>>>>                SaveRecord Functions
95036>>>>>>>                Send AdjustSelected bSelect iType
95037>>>>>>>            Unlock
95038>>>>>>>>
95038>>>>>>>            Constrained_Find Next
95039>>>>>>>        Loop
95040>>>>>>>>
95040>>>>>>>
95040>>>>>>>        If (bSelect = False) Begin
95042>>>>>>>            Reread SysFile
95046>>>>>>>                Move 0 to SysFile.SelectedFunctionTotal
95047>>>>>>>                Move 0 to SysFile.SelectedStandardFunctions          
95048>>>>>>>                Move 0 to SysFile.SelectedEditorFunctions          
95049>>>>>>>                Move 0 to SysFile.SelectedReportFunctions          
95050>>>>>>>                Move 0 to SysFile.SelectedReportAllFunctions          
95051>>>>>>>                Move 0 to SysFile.SelectedRemoveFunctions          
95052>>>>>>>                Move 0 to SysFile.SelectedOtherFunctions          
95053>>>>>>>                Move 0 to SysFile.SelectedOtherAllFunctions          
95054>>>>>>>                SaveRecord SysFile
95055>>>>>>>            Unlock
95056>>>>>>>>
95056>>>>>>>        End
95056>>>>>>>>
95056>>>>>>>
95056>>>>>>>    End_Procedure
95057>>>>>>>    
95057>>>>>>>    // Pass one of the pre-defined function types;
95057>>>>>>>    //   eStandard_Function, eEditor_Function, eReport_Function or eRemove_Function  
95057>>>>>>>    // Returns number of selected functions for the passed type.
95057>>>>>>>    Function SelectedTypeFunctions Integer iType Returns Integer
95059>>>>>>>        Integer iItems        
95059>>>>>>>        
95059>>>>>>>        Case Begin
95059>>>>>>>            Case (iType = eStandard_Function) 
95061>>>>>>>                Move SysFile.SelectedStandardFunctions to iItems
95062>>>>>>>                Case Break
95063>>>>>>>            Case (iType = eEditor_Function) 
95066>>>>>>>                Move SysFile.SelectedEditorFunctions to iItems
95067>>>>>>>                Case Break
95068>>>>>>>            Case (iType = eReport_Function) 
95071>>>>>>>                Move SysFile.SelectedReportFunctions to iItems
95072>>>>>>>                Case Break
95073>>>>>>>            Case (iType = eRemove_Function) 
95076>>>>>>>                Move SysFile.SelectedRemoveFunctions to iItems
95077>>>>>>>                Case Break
95078>>>>>>>            Case Else 
95078>>>>>>>                Move SysFile.SelectedFunctionTotal to iItems                               
95079>>>>>>>        Case End
95079>>>>>>>
95079>>>>>>>        Function_Return iItems
95080>>>>>>>    End_Function   
95081>>>>>>>    
95081>>>>>>>    // Finds the first selected Function record for the passed type.
95081>>>>>>>    // Returns True if a match was found.
95081>>>>>>>    // NOTE: It leaves the FunctionsA global record buffer after
95081>>>>>>>    //       a successful find, to be used elsewhere.
95081>>>>>>>    Function FindFirstSelectedFunction Integer iType Returns Boolean
95083>>>>>>>        Clear FunctionsA
95084>>>>>>>        Move True  to FunctionsA.Selected
95085>>>>>>>        Move iType to FunctionsA.Type
95086>>>>>>>        Find gt FunctionsA by Index.4
95087>>>>>>>>
95087>>>>>>>        Function_Return (Found and FunctionsA.Type = iType)
95088>>>>>>>    End_Function
95089>>>>>>>    
95089>>>>>>>    // Finds the next selected function for the passed type
95089>>>>>>>    // Returns True if a match was found.
95089>>>>>>>    // It is mandatory to start a loop by first calling the 
95089>>>>>>>    // FindFirstSelectedFunction function.
95089>>>>>>>    // NOTE: It leaves the FunctionsA global record buffer after
95089>>>>>>>    //       a successful find, to be used elsewhere.
95089>>>>>>>    Function FindNextSelectedFunction Integer iType Returns Boolean
95091>>>>>>>        Move True  to FunctionsA.Selected
95092>>>>>>>        Move iType to FunctionsA.Type        
95093>>>>>>>        Find gt FunctionsA by Index.4
95094>>>>>>>>
95094>>>>>>>        Function_Return (Found and FunctionsA.Type = iType)
95095>>>>>>>    End_Function
95096>>>>>>>    
95096>>>>>>>    // Returns the total number of selected functions for all types.
95096>>>>>>>    Function SelectedFunctions Returns Integer
95098>>>>>>>        Function_Return (SysFile.SelectedFunctionTotal)
95099>>>>>>>    End_Function  
95100>>>>>>>    
95100>>>>>>>    // Returns the total number of functions in the database.
95100>>>>>>>    Function TotalNoOfFunctions Returns Integer
95102>>>>>>>        Integer iItems
95102>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of FunctionsA.File_Number to iItems
95105>>>>>>>        Function_Return iItems
95106>>>>>>>    End_Function
95107>>>>>>>    
95107>>>>>>>    // Zeroe's out all line counters
95107>>>>>>>    Procedure ResetLineCounters
95109>>>>>>>        Constraint_Set (Self  + 1) Clear  
95111>>>>>>>        Constrained_Clear eq FunctionsA by Index.1
95114>>>>>>>        Constrained_Find First FunctionsA by Index.1
95119>>>>>>>        While (Found)
95123>>>>>>>            Reread FunctionsA
95127>>>>>>>                Move 0 to FunctionsA.Count
95128>>>>>>>                SaveRecord FunctionsA
95129>>>>>>>            Unlock
95130>>>>>>>>
95130>>>>>>>            Constrained_Find Next
95131>>>>>>>        Loop                                 
95132>>>>>>>>
95132>>>>>>>        Reread SysFile
95136>>>>>>>            Move 0 to SysFile.iCountNumberOfFiles  
95137>>>>>>>            Move 0 to SysFile.iCountNumberOfChangedFiles
95138>>>>>>>            Move 0 to SysFile.iCountNumberOfLines    
95139>>>>>>>            Move 0 to SysFile.iCountProjectObjectStructures
95140>>>>>>>            Move 0 to SysFile.iCountRemoveBlankLines
95141>>>>>>>            Move 0 to SysFile.iCountUnusedSourceFiles 
95142>>>>>>>            Move 0 to SysFile.iCountUnusedLocals
95143>>>>>>>            SaveRecord SysFile
95144>>>>>>>        Unlock
95145>>>>>>>>
95145>>>>>>>    End_Procedure
95146>>>>>>>    
95146>>>>>>>End_Class
95147>>>>>>>
95147>>>>>>>Use Functions.sl
Including file: Functions.sl    (C:\Projects\DF18\DfRefactor\AppSrc\Functions.sl)
95147>>>>>>>>>// Functions.sl
95147>>>>>>>>>// Functions Lookup List
95147>>>>>>>>>
95147>>>>>>>>>Use DFClient.pkg
95147>>>>>>>>>Use cDbCJGridPromptList.pkg
95147>>>>>>>>>Use cDbCJGridColumn.pkg
95147>>>>>>>>>Use Windows.pkg
95147>>>>>>>>>
95147>>>>>>>>>Use cFunctionsDataDictionary.dd
95147>>>>>>>>>
95147>>>>>>>>>CD_Popup_Object oFunctions_sl is a dbModalPanel
95165>>>>>>>>>>
95165>>>>>>>>>    Set Location to 5 5
95166>>>>>>>>>    Set Size to 134 269
95167>>>>>>>>>    Set Label To "Functions Lookup List"
95168>>>>>>>>>    Set Border_Style to Border_Thick
95169>>>>>>>>>    Set Minimize_Icon to False
95170>>>>>>>>>
95170>>>>>>>>>    Object oFunctions_DD is a cFunctionsDataDictionary
95172>>>>>>>>>    End_Object 
95173>>>>>>>>>
95173>>>>>>>>>    Set Main_DD To oFunctions_DD
95174>>>>>>>>>    Set Server  To oFunctions_DD
95175>>>>>>>>>
95175>>>>>>>>>    Object oSelList is a cDbCJGridPromptList
95177>>>>>>>>>        Set Size to 105 259
95178>>>>>>>>>        Set Location to 5 5
95179>>>>>>>>>        Set peAnchors to anAll
95180>>>>>>>>>        Set psLayoutSection to "oFunctions_sl_oSelList"
95181>>>>>>>>>        Set Ordering to 1
95182>>>>>>>>>        Set pbAutoServer to True
95183>>>>>>>>>
95183>>>>>>>>>        Object oFunctions_ID is a cDbCJGridColumn
95185>>>>>>>>>            Entry_Item Functions.ID
95186>>>>>>>>>            Set piWidth to 31
95187>>>>>>>>>            Set psCaption to "ID"
95188>>>>>>>>>        End_Object 
95189>>>>>>>>>
95189>>>>>>>>>        Object oFunctions_Function_Name is a cDbCJGridColumn
95191>>>>>>>>>            Entry_Item Functions.Function_Name
95192>>>>>>>>>            Set piWidth to 284
95193>>>>>>>>>            Set psCaption to "Function Name"
95194>>>>>>>>>        End_Object 
95195>>>>>>>>>
95195>>>>>>>>>        Object oFunctions_Type is a cDbCJGridColumn
95197>>>>>>>>>            Entry_Item Functions.Type
95198>>>>>>>>>            Set piWidth to 117
95199>>>>>>>>>            Set psCaption to "Type"
95200>>>>>>>>>            Set pbComboButton to True
95201>>>>>>>>>        End_Object 
95202>>>>>>>>>
95202>>>>>>>>>    End_Object 
95203>>>>>>>>>
95203>>>>>>>>>    Object oOk_bn is a Button
95205>>>>>>>>>        Set Label to "&Ok"
95206>>>>>>>>>        Set Location to 115 106
95207>>>>>>>>>        Set peAnchors to anBottomRight
95208>>>>>>>>>
95208>>>>>>>>>        Procedure OnClick
95211>>>>>>>>>            Send OK of oSelList
95212>>>>>>>>>        End_Procedure
95213>>>>>>>>>
95213>>>>>>>>>    End_Object 
95214>>>>>>>>>
95214>>>>>>>>>    Object oCancel_bn is a Button
95216>>>>>>>>>        Set Label to "&Cancel"
95217>>>>>>>>>        Set Location to 115 160
95218>>>>>>>>>        Set peAnchors to anBottomRight
95219>>>>>>>>>
95219>>>>>>>>>        Procedure OnClick
95222>>>>>>>>>            Send Cancel of oSelList
95223>>>>>>>>>        End_Procedure
95224>>>>>>>>>
95224>>>>>>>>>    End_Object 
95225>>>>>>>>>
95225>>>>>>>>>    Object oSearch_bn is a Button
95227>>>>>>>>>        Set Label to "&Search..."
95228>>>>>>>>>        Set Location to 115 214
95229>>>>>>>>>        Set peAnchors to anBottomRight
95230>>>>>>>>>
95230>>>>>>>>>        Procedure OnClick
95233>>>>>>>>>            Send Search of oSelList
95234>>>>>>>>>        End_Procedure
95235>>>>>>>>>
95235>>>>>>>>>    End_Object 
95236>>>>>>>>>
95236>>>>>>>>>    Procedure Activating
95239>>>>>>>>>        Set Icon to "FunctionLibrary.ico"
95240>>>>>>>>>    End_Procedure
95241>>>>>>>>>
95241>>>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
95242>>>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
95243>>>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
95244>>>>>>>>>Cd_End_Object
95246>>>>>>>>>>
95246>>>>>Use cFunctionsADataDictionary.dd
Including file: cFunctionsADataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cFunctionsADataDictionary.dd)
95246>>>>>>>Use cFunctionsDataDictionary.dd
95246>>>>>>>
95246>>>>>>>Open FunctionsA
95248>>>>>>>Set_Attribute DF_FILE_ALIAS of FunctionsA.File_Number to DF_FILE_IS_ALIAS
95251>>>>>>>
95251>>>>>>>Class cFunctionsADataDictionary is a cFunctionsDataDictionary
95252>>>>>>>    
95252>>>>>>>    Procedure Construct_Object
95254>>>>>>>        Forward Send Construct_Object
95256>>>>>>>        Set Alias_File to FunctionsA.File_Number
95257>>>>>>>        Set pbForeignReadOnly to True
95258>>>>>>>        Set pbUseDDRelates to True
95259>>>>>>>        Set pbNoCascadeDeleteStrict to True
95260>>>>>>>    End_Procedure
95261>>>>>>>    
95261>>>>>>>    Procedure Update
95263>>>>>>>    End_Procedure
95264>>>>>>> 
95264>>>>>>>    Procedure Backout
95266>>>>>>>    End_Procedure
95267>>>>>>>
95267>>>>>>>    Procedure Deleting
95269>>>>>>>    End_Procedure
95270>>>>>>>    
95270>>>>>>>    Procedure Creating
95272>>>>>>>    End_Procedure
95273>>>>>>>    
95273>>>>>>>    Function Validate_Save Returns Integer
95275>>>>>>>    End_Function
95276>>>>>>>
95276>>>>>>>    Function Validate_Delete Returns Integer
95278>>>>>>>    End_Function
95279>>>>>>>    
95279>>>>>>>    Function Validate_Cascade_Delete Returns Boolean
95281>>>>>>>    End_Function
95282>>>>>>>    
95282>>>>>>>    Procedure OnSaveRecord
95284>>>>>>>    End_Procedure
95285>>>>>>>    
95285>>>>>>>    Procedure OnPreFind Integer eMessage
95287>>>>>>>    End_Procedure
95288>>>>>>>
95288>>>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
95290>>>>>>>    End_Procedure
95291>>>>>>>    
95291>>>>>>>    Procedure OnConstrain
95293>>>>>>>    End_Procedure
95294>>>>>>>    
95294>>>>>>>End_Class
95295>>>>>
95295>>>>>
95295>>>>>Class cRefactorStatusLog is a StatusDbLog
95296>>>>>    Procedure Construct_Object
95298>>>>>        Forward Send Construct_Object
95300>>>>>        Move Self to ghoStatusLog
95301>>>>>        Open StatLog
95303>>>>>    End_Procedure                    
95304>>>>>    
95304>>>>>    Procedure OnNewRecord
95306>>>>>        String sFunctionName  
95306>>>>>        Integer iDateFormat
95306>>>>>        Move (Trim(Functions.Function_Name)) to sFunctionName
95307>>>>>        If (sFunctionName = "") Begin
95309>>>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName
95310>>>>>        End
95310>>>>>>
95310>>>>>        Move sFunctionName to StatLog.FunctionName
95311>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
95314>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
95317>>>>>        Move (CurrentDateTime()) to StatLog.Time
95318>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
95321>>>>>    End_Procedure
95322>>>>>    
95322>>>>>End_Class
95323>>>>>
95323>>>>>Class cRefactorDbView is a dbView
95324>>>>>
95324>>>>>    Procedure Construct_Object
95326>>>>>        Forward Send Construct_Object
95328>>>>>
95328>>>>>        Set Border_Style to Border_Thick
95329>>>>>        Set pbAutoActivate to True
95330>>>>>
95330>>>>>        Property String  psLineBreak ""
95331>>>>>        Property Boolean pbLastLineBreak False
95332>>>>>        
95332>>>>>        // Object handles:
95332>>>>>        Property Handle private.phoEditor
95333>>>>>        Property Handle phoBPO 
95334>>>>>        Property Handle phoRemoveUnusedLocals
95335>>>>>        Property Handle phoReportUnusedSourceFiles 
95336>>>>>        Property Handle phoDDOReStyler
95337>>>>>        
95337>>>>>        Object Status_Log is a cRefactorStatusLog
95339>>>>>            Move Self to ghoStatusLog
95340>>>>>        End_Object
95341>>>>>
95341>>>>>        Object oRemoveUnusedLocals is a cRemoveUnusedLocals
95343>>>>>            Set phoRemoveUnusedLocals to Self
95344>>>>>        End_Object
95345>>>>>    
95345>>>>>        Object oReportUnusedSourceFiles is a cUnusedSourceFiles
95347>>>>>            Set phoReportUnusedSourceFiles to Self
95348>>>>>        End_Object
95349>>>>>        
95349>>>>>        Object oDDOReStyler is a cDDOReStyler
95351>>>>>            Set phoDDOReStyler to Self
95352>>>>>        End_Object
95353>>>>>
95353>>>>>        // *** MAIN FUNCTION LIBRARY ***
95353>>>>>        //
95353>>>>>        Object oRefactorFunctionLibrary is a cRefactorFunctionLibrary
95355>>>>>        End_Object
95356>>>>>        
95356>>>>>        Set pbAutoActivate to True
95357>>>>>        Set Verify_Save_msg to (RefFunc(No_Confirmation))
95358>>>>>
95358>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
95359>>>>>        On_Key Key_Escape Send None
95360>>>>>        On_Key Key_Ctrl+Key_F4 Send None   
95361>>>>>        Send Switch_Prior_View //of (ClientAreaObject (ghoCommandBars))
95362>>>>>    End_Procedure
95363>>>>>
95363>>>>>    Procedure Set phoEditor Handle ho
95365>>>>>        Set private.phoEditor to ho
95366>>>>>        Set phoEditor of ghoRefactorFunctionLibrary to ho
95367>>>>>    End_Procedure
95368>>>>>    
95368>>>>>    Function phoEditor Returns Handle
95370>>>>>        Function_Return (private.phoEditor(Self))
95371>>>>>    End_Function
95372>>>>>        
95372>>>>>    Procedure RefactorCheckboxChanged Boolean bState Handle hObject Boolean bReportFunction
95374>>>>>    End_Procedure
95375>>>>>
95375>>>>>    Procedure WaitForFileToGetWritten String sFile
95377>>>>>        Integer iCh iMaxSec
95377>>>>>        Boolean bOK bExist
95377>>>>>        DateTime dtStart dtStartCheck
95377>>>>>        TimeSpan tsTime
95377>>>>>
95377>>>>>        Move False to bOK
95378>>>>>        Move 3 to iMaxSec
95379>>>>>        Get vFilePathExists sFile to bExist
95380>>>>>        If (bExist = False) Begin
95382>>>>>            Procedure_Return
95383>>>>>        End
95383>>>>>>
95383>>>>>        Move (CurrentDateTime()) to dtStart
95384>>>>>        Get Seq_New_Channel to iCh   
95385>>>>>        // No channel available 
95385>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
95387>>>>>            Error "No Channel Available for Process: Procedure 'WaitForFileToGetWritten'"
95388>>>>>>
95388>>>>>            Procedure_Return
95389>>>>>        End
95389>>>>>>
95389>>>>>        
95389>>>>>        Repeat
95389>>>>>>
95389>>>>>            Direct_Input channel iCh
95390>>>>>            Move (SeqEof = False) to bOK
95391>>>>>            If (bOK = False) Begin
95393>>>>>                Close_Input channel iCh
95395>>>>>            End
95395>>>>>>
95395>>>>>            Move (CurrentDateTime()) to dtStartCheck
95396>>>>>            Move (dtStartCheck - dtStart) to tsTime
95397>>>>>            If (SpanSeconds(tsTime) > iMaxSec) Begin
95399>>>>>                Move True to bOK
95400>>>>>            End
95400>>>>>>
95400>>>>>        Until (bOK = True)
95402>>>>>
95402>>>>>        Close_Input channel iCh
95404>>>>>        Send Seq_Release_Channel iCh
95405>>>>>    End_Procedure
95406>>>>>
95406>>>>>    Function ReadSourceFileToArray String sSourceFile Returns String[]
95408>>>>>        Boolean bLastLineBreak bEndOfFile bFirstLine
95408>>>>>        Integer iLine iChannel iFileSize
95408>>>>>        String sLine sLastLine sLineBreak sFileNameOnly
95408>>>>>        String[] asSourceFile
95409>>>>>
95409>>>>>        Move 0 to iLine
95410>>>>>        Move True  to bFirstLine
95411>>>>>        Move False to bEndOfFile
95412>>>>>        Move False to bLastLineBreak
95413>>>>>        Move ""    to sLastLine
95414>>>>>
95414>>>>>        Get Seq_New_Channel to iChannel
95415>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
95417>>>>>            Error "No Channel Available for Process: Procedure 'ReadSourceFileToArray'"
95418>>>>>>
95418>>>>>            Function_Return asSourceFile
95419>>>>>        End
95419>>>>>>
95419>>>>>
95419>>>>>        Get ParseFileName sSourceFile to sFileNameOnly
95420>>>>>        Set Message_Text of ghoStatusPanel to ("Reading:" * String(sFileNameOnly))
95421>>>>>        Get vWin32_APIFileSize sSourceFile to iFileSize
95422>>>>>        Move (ResizeArray(asSourceFile, iFileSize)) to asSourceFile
95423>>>>>
95423>>>>>        // Need to use binary read mode if we want to preserve tab characters and not have automatic tab replacement
95423>>>>>        // filemode options don't seem to work as documented, not sure why.
95423>>>>>        // Direct_Input channel iInChannel ("binary: "+"cr: 13: "+"eof: 26: "+sSourceFile)
95423>>>>>        // Direct_Input channel iInChannel ("binary: "+"cr: 13:"+"eof: 26:"+sSourceFile)
95423>>>>>        Direct_Input channel iChannel ("binary:" + sSourceFile)
95425>>>>>
95425>>>>>        While (bEndOfFile = False)
95429>>>>>            Readln channel iChannel sLine
95431>>>>>            Move (SeqEof) to bEndOfFile
95432>>>>>            If (bEndOfFile and Length(sLastLine) > 0) Begin
95434>>>>>                If (Right(sLastLine, 1) = CS_CR) Begin
95436>>>>>                    Move True to bLastLineBreak
95437>>>>>                End
95437>>>>>>
95437>>>>>            End
95437>>>>>>
95437>>>>>            Move sLine to sLastLine
95438>>>>>            If (bFirstLine = True) Begin
95440>>>>>                Move False to bFirstLine
95441>>>>>                // Determine the linebreak character to use for the file based on what is in the first line
95441>>>>>                // The readline automatically reads Until LF, but does not report LF back in the string
95441>>>>>                If (Length(sLine) > 0 and Right(sLine, 1) = CS_CR) Begin
95443>>>>>                    Move CS_CRLF to sLineBreak
95444>>>>>                End
95444>>>>>>
95444>>>>>                Else Begin
95445>>>>>                    Move CS_LF to sLineBreak
95446>>>>>                End
95446>>>>>>
95446>>>>>                Set psLineBreak to sLineBreak
95447>>>>>            End
95447>>>>>>
95447>>>>>            If (sLineBreak = CS_CRLF) Begin
95449>>>>>                If (Right(sLine, 1) = CS_CR) Begin
95451>>>>>                    Move (Left(sLine, Length(sLine) - 1)) to sLine
95452>>>>>                End
95452>>>>>>
95452>>>>>            End
95452>>>>>>
95452>>>>>            If (bEndOfFile = False) Begin
95454>>>>>                Move sLine to asSourceFile[iLine]
95455>>>>>                Increment iLine
95456>>>>>            End
95456>>>>>>
95456>>>>>        Loop
95457>>>>>>
95457>>>>>
95457>>>>>        Move (ResizeArray(asSourceFile, iLine)) to asSourceFile
95458>>>>>        Set pbLastLineBreak to bLastLineBreak
95459>>>>>        Close_Input channel iChannel
95461>>>>>        Send Seq_Release_Channel iChannel
95462>>>>>
95462>>>>>        Function_Return asSourceFile
95463>>>>>    End_Function
95464>>>>>
95464>>>>>    Function WriteArrayToSourceFile String sSourceFile String[] asNewSourceFile Returns Boolean
95466>>>>>        Boolean bLastLineBreak
95466>>>>>        Integer iOutChannel iSize iCount
95466>>>>>        String  sLineBreak
95466>>>>>
95466>>>>>        Move False to Err
95467>>>>>        Get psLineBreak     to sLineBreak
95468>>>>>        Get pbLastLineBreak to bLastLineBreak
95469>>>>>        Get Seq_New_Channel to iOutChannel
95470>>>>>        If (iOutChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
95472>>>>>            Error "No Channel Available for Process: Procedure 'WriteArrayToSourceFile'"
95473>>>>>>
95473>>>>>            Function_Return False
95474>>>>>        End
95474>>>>>>
95474>>>>>
95474>>>>>        Direct_Output channel iOutChannel sSourceFile
95476>>>>>        Move (SizeOfArray(asNewSourceFile)) to iSize
95477>>>>>        Decrement iSize   
95478>>>>>        If (iSize >= 0) Begin
95480>>>>>            For iCount from 0 to (iSize-1)
95486>>>>>>
95486>>>>>                Write channel iOutChannel asNewSourceFile[iCount] sLineBreak
95489>>>>>            Loop
95490>>>>>>
95490>>>>>            If (bLastLineBreak=True) Begin
95492>>>>>                Write channel iOutChannel asNewSourceFile[iSize] sLineBreak
95495>>>>>            End
95495>>>>>>
95495>>>>>            Else Begin
95496>>>>>                Write channel iOutChannel asNewSourceFile[iSize]
95498>>>>>            End
95498>>>>>>
95498>>>>>        End
95498>>>>>>
95498>>>>>
95498>>>>>        Close_Input channel iOutChannel
95500>>>>>        Send Seq_Release_Channel iOutChannel
95501>>>>>        Function_Return (Err = False)
95502>>>>>    End_Function  
95503>>>>>    
95503>>>>>    Function TimeSpanToString TimeSpan tsTime Returns String
95505>>>>>        Integer iDays iHours iMinutes iSeconds iMilliseconds
95505>>>>>        String  sTime
95505>>>>>
95505>>>>>        Move "" to sTime
95506>>>>>        Move (SpanDays(tsTime))    to iDays
95507>>>>>        Move (SpanHours(tsTime))   to iHours
95508>>>>>        Move (SpanMinutes(tsTime)) to iMinutes
95509>>>>>        Move (SpanSeconds(tsTime)) to iSeconds
95510>>>>>        Move (SpanMilliSeconds(tsTime)) to iMilliSeconds
95511>>>>>        If (iDays > 0) Begin   // Don't show days if it is zero
95513>>>>>            Move (String(iDays) + ":") to sTime
95514>>>>>        End
95514>>>>>>
95514>>>>>        If (iHours < 10) Begin
95516>>>>>            Move (sTime+"0") to sTime
95517>>>>>        End
95517>>>>>>
95517>>>>>        Move (sTime + String(iHours) + ":") to sTime
95518>>>>>        If (iMinutes < 10) Begin
95520>>>>>            Move (sTime + "0") to sTime
95521>>>>>        End
95521>>>>>>
95521>>>>>        Move (sTime + String(iMinutes) + ":") to sTime
95522>>>>>        If (iSeconds < 10) Begin
95524>>>>>            Move (sTime + "0") to sTime
95525>>>>>        End
95525>>>>>>
95525>>>>>        Move (sTime + String(iSeconds) + "." + String(iMilliSeconds)) to sTime
95526>>>>>
95526>>>>>        Function_Return sTime
95527>>>>>    End_Function
95528>>>>>
95528>>>>>    // ToDo: Should probably be done by the function in the library.
95528>>>>>    Procedure RemoveReportLogFiles String sPath
95530>>>>>        Boolean bOK
95530>>>>>        tRefactorSettings RefactorSettings
95530>>>>>        tRefactorSettings RefactorSettings
95530>>>>>
95530>>>>>        Get pRefactorSettings of ghoRefactorFunctionLibrary to RefactorSettings
95531>>>>>        Get vFolderFormat sPath to sPath
95532>>>>>        Send Info_Box "To be done! (RemoveReportLogFiles)"
95533>>>>>//        If (RefactorSettings.bUnusedSourceFiles = True) Begin
95533>>>>>//            Get vDeleteFile (sPath + CS_BackupFolder + CS_DirSeparator + CS_UnusedSourceLogFile) to bOK
95533>>>>>//        End
95533>>>>>    End_Procedure
95534>>>>>
95534>>>>>    Function pbShouldSave Returns Boolean
95536>>>>>        Boolean bChanged bIsReadOnly
95536>>>>>        Handle hoEditor
95536>>>>>
95536>>>>>        Get phoEditor to hoEditor
95537>>>>>        If (hoEditor <> 0) Begin
95539>>>>>            Get CM_IsModified of hoEditor to bChanged
95540>>>>>            Get CM_IsReadOnly of hoEditor to bIsReadOnly
95541>>>>>        End
95541>>>>>>
95541>>>>>        Function_Return (bChanged = True and bIsReadOnly = False)
95542>>>>>    End_Function
95543>>>>>
95543>>>>>    Procedure Request_Save
95545>>>>>        Handle hoEditor
95545>>>>>        Boolean bChanged
95545>>>>>
95545>>>>>        Get phoEditor to hoEditor
95546>>>>>        Get pbShouldSave to bChanged
95547>>>>>        If (hoEditor <> 0 and bChanged = True) Begin
95549>>>>>            Send SaveFile of hoEditor
95550>>>>>        End  
95550>>>>>>
95550>>>>>        Forward Send Request_Save
95552>>>>>    End_Procedure
95553>>>>>
95553>>>>>    Procedure Request_Clear
95555>>>>>        Handle hoEditor
95555>>>>>        Get phoEditor to hoEditor
95556>>>>>        If (hoEditor <> 0) Begin
95558>>>>>            Send Delete_Data of hoEditor
95559>>>>>        End
95559>>>>>>
95559>>>>>        Send UpdateStatusBar "" False   
95560>>>>>        Forward Send Request_Clear
95562>>>>>    End_Procedure
95563>>>>>
95563>>>>>    Procedure Request_Clear_All
95565>>>>>        Handle hoEditor
95565>>>>>        Get phoEditor to hoEditor
95566>>>>>        If (hoEditor <> 0) Begin
95568>>>>>            Send Delete_Data of hoEditor
95569>>>>>        End
95569>>>>>>
95569>>>>>        Send UpdateStatusBar "" False  
95570>>>>>        // ToDo: I don't quite understand this, but if we forward send
95570>>>>>        // it activates the EditorView.vw!?
95570>>>>>        // Forward Send Request_Clear_All
95570>>>>>    End_Procedure
95571>>>>>
95571>>>>>    Procedure UpdateStatusBar String sText Boolean bIdleTextOnly Integer iLi Integer iChrs
95573>>>>>        Handle hoStatusBar
95573>>>>>        Integer iLines iCharacters
95573>>>>>
95573>>>>>        Move (StatusBar_Id(Self)) to hoStatusBar
95574>>>>>        If (num_arguments > 2) Begin
95576>>>>>            Move iChrs to iCharacters
95577>>>>>            If (iCharacters = 0) Begin
95579>>>>>                Move 0 to iLines
95580>>>>>            End                 
95580>>>>>>
95580>>>>>            Else Begin
95581>>>>>                Move iLi to iLines
95582>>>>>            End
95582>>>>>>
95582>>>>>            Set NumberOfEditorLines      of hoStatusBar to iLines
95583>>>>>            Set NumberOfEditorCharacters of hoStatusBar to iCharacters
95584>>>>>        End
95584>>>>>>
95584>>>>>        Else Begin
95585>>>>>            If (bIdleTextOnly = True) Begin
95587>>>>>                Set psIdleText of hoStatusBar to sText
95588>>>>>                Set ActionText of hoStatusBar to ""
95589>>>>>            End
95589>>>>>>
95589>>>>>            Else Begin
95590>>>>>                Set ActionText of hoStatusBar to sText
95591>>>>>            End
95591>>>>>>
95591>>>>>        End
95591>>>>>>
95591>>>>>    End_Procedure
95592>>>>>
95592>>>>>    // To enable Ctrl+MouseWheel in the grid to change font size.
95592>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
95594>>>>>       Integer iKeys iClicks iX iY iCONTROL
95594>>>>>       Short iDelta     // Short signed integer
95594>>>>>       Boolean bok 
95594>>>>>       
95594>>>>>       Move 0 to iDelta
95595>>>>>       Move (Low(wParam)) to iKeys           // any keys down when pressed
95596>>>>>       Move (MemCopy(AddressOf(iDelta),AddressOf(wParam)+2,2)) to bok
95597>>>>>       // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
95597>>>>>       Move (iDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
95598>>>>>       Move (Low(lParam)) to iX  // cursor position
95599>>>>>       Move (Hi(lParam)) to iY   
95600>>>>>
95600>>>>>       Move (iKeys iand MK_CONTROL ) to iCONTROL  //$008
95601>>>>>       If (iCONTROL) Begin
95603>>>>>            Broadcast Recursive Send ScaleFont iClicks
95605>>>>>       End
95605>>>>>>
95605>>>>>
95605>>>>>       // Tell windows that we've handled the event.    
95605>>>>>       Set Windows_Override_State to True    
95606>>>>>    End_Procedure
95607>>>>>        
95607>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
95609>>>>>        Integer iSize jSize kSize iSup iInf iDef
95609>>>>>        Handle hoPaintManager hoFont
95609>>>>>        Variant vFont
95609>>>>>        
95609>>>>>        Move 3 to iInf      //max size
95610>>>>>        Move 18 to iSup     //min size
95611>>>>>        Move 8 to iDef      //default
95612>>>>>        Boolean blimite
95612>>>>>        Get phoReportPaintManager to hoPaintManager
95613>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
95615>>>>>            Procedure_Return
95616>>>>>        End
95616>>>>>>
95616>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
95617>>>>>        Get ComTextFont of hoPaintManager to vFont
95618>>>>>        Set pvComObject of hoFont to vFont
95619>>>>>        If (iDirection = 0) Begin
95621>>>>>            Set ComSize of hoFont to iDef
95622>>>>>        End
95622>>>>>>
95622>>>>>        Else Begin
95623>>>>>           Get ComSize of hoFont to iSize
95624>>>>>           Move iSize to jSize
95625>>>>>           Repeat
95625>>>>>>
95625>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
95626>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
95627>>>>>                If (not(blimite)) Begin       
95629>>>>>                   Set ComSize of hoFont to jSize
95630>>>>>                   Get ComSize of hoFont to kSize
95631>>>>>                End
95631>>>>>>
95631>>>>>            Until (iSize <> kSize or blimite)
95633>>>>>        End
95633>>>>>>
95633>>>>>        Send Destroy to hoFont 
95634>>>>>        Send ComRedraw  
95635>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
95636>>>>>    End_Procedure 
95637>>>>>
95637>>>>>End_Class
95638>>>Use Cursor.pkg
95638>>>Use dfLine.pkg
95638>>>Use cCJCommandBarSystem.pkg
95638>>>Use DFEnChk.pkg
95638>>>Use dfTabDlg.pkg
95638>>>
95638>>>Use cRDCDbCJGrid.pkg  
Including file: cRDCDbCJGrid.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGrid.pkg)
95638>>>>>Use cDbCJGrid.pkg
95638>>>>>Use cRDCDbCJGridColumnHyperLink.pkg
Including file: cRDCDbCJGridColumnHyperLink.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGridColumnHyperLink.pkg)
95638>>>>>>>// Written by Peter Bragg.
95638>>>>>>>// Subclass for using hyperlinks in cDbCJGrid/cCJGrid column objects.
95638>>>>>>>//
95638>>>>>>>// Set pbHyperLink to True and it will call the Function "IsHyperLink" passing the Row Index.
95638>>>>>>>// To be honest you don't really need this property at all - the function on its own would do.
95638>>>>>>>//
95638>>>>>>>// Anyway, code this function accordingly to return True or False If the row value for that column
95638>>>>>>>// should be displayed as a hyperlink or not. (Within this Function you can call "Get RowValue"
95638>>>>>>>// to Get the value for that column)
95638>>>>>>>//
95638>>>>>>>// All you then need to do is Add the following to your Grid Class:
95638>>>>>>>//
95638>>>>>>>//    Procedure OnComHyperlinkClick Variant llRow Variant llItem Integer llHyperlinkIndex
95638>>>>>>>//        Handle  hoRow hoItem hoColumn
95638>>>>>>>//        String  sLink
95638>>>>>>>//        Integer iRow iColumn
95638>>>>>>>//
95638>>>>>>>//        Get phoReportRow to hoRow
95638>>>>>>>//        Get phoReportRecordItem to hoItem
95638>>>>>>>//
95638>>>>>>>//        Set pvComObject of hoItem to llItem
95638>>>>>>>//        Get ComIndex    of hoItem to iColumn
95638>>>>>>>//        Set pvComObject of hoRow to llRow
95638>>>>>>>//        Get ComIndex    of hoRow to iRow
95638>>>>>>>//        Get ColumnObject iColumn to hoColumn
95638>>>>>>>//        Get RowValue of hoColumn iRow to sLink
95638>>>>>>>//
95638>>>>>>>//        Send OnLinkClicked of hoColumn sLink iRow
95638>>>>>>>//    End_Procedure
95638>>>>>>>
95638>>>>>>>Use cDbCJGridColumn.pkg
95638>>>>>>>
95638>>>>>>>Class cDbCJGridColumnHyperLink is a cDbCJGridColumn
95639>>>>>>>
95639>>>>>>>    Procedure Construct_Object
95641>>>>>>>        Forward Send Construct_Object
95643>>>>>>>
95643>>>>>>>        Property Boolean pbHyperlink    False
95644>>>>>>>    End_Procedure
95645>>>>>>>
95645>>>>>>>    Function IsHyperlink Integer iRow Returns Boolean
95647>>>>>>>        Function_Return False
95648>>>>>>>    End_Function
95649>>>>>>>
95649>>>>>>>    Procedure OnLinkClicked String sLink Integer iRow
95651>>>>>>>    End_Procedure
95652>>>>>>>
95652>>>>>>>    Procedure DrawCell Handle hoRow Handle hoItem Handle hoMetrics Integer iRow String sValue
95654>>>>>>>        Boolean bIsHyperlink
95654>>>>>>>        Variant vHyperLinks vHyperLink
95654>>>>>>>        Handle  hoHyperLinks
95654>>>>>>>        Integer iLinks
95654>>>>>>>
95654>>>>>>>        Get pbHyperlink to bIsHyperlink
95655>>>>>>>        If (bIsHyperlink) Begin
95657>>>>>>>            Get IsHyperlink iRow to bIsHyperlink
95658>>>>>>>        End
95658>>>>>>>>
95658>>>>>>>
95658>>>>>>>        Get ComHyperlinks of hoItem to vHyperLinks
95659>>>>>>>        Get Create (RefClass(cCJReportHyperlinks)) to hoHyperLinks
95660>>>>>>>        Set pvComObject of hoHyperLinks to vHyperLinks
95661>>>>>>>        Get ComCount of hoHyperLinks to iLinks
95662>>>>>>>        If (bIsHyperlink) Begin
95664>>>>>>>            If (iLinks=0) Begin
95666>>>>>>>                Get ComAddHyperlink of hoHyperLinks 0 (Length(sValue)) to vHyperLink
95667>>>>>>>            End
95667>>>>>>>>
95667>>>>>>>        End
95667>>>>>>>>
95667>>>>>>>        Else If (iLinks>0) Begin
95670>>>>>>>            Send ComRemoveAll of hoHyperLinks
95671>>>>>>>        End
95671>>>>>>>>
95671>>>>>>>        Send Destroy of hoHyperLinks
95672>>>>>>>
95672>>>>>>>        Forward Send DrawCell hoRow hoItem hoMetrics iRow sValue
95674>>>>>>>    End_Procedure
95675>>>>>>>
95675>>>>>>>    Procedure OnCreateColumn
95677>>>>>>>        Variant vHyperLinkStyle
95677>>>>>>>        Handle  hoPaintManager hoHyperLinkStyle
95677>>>>>>>
95677>>>>>>>        Forward Send OnCreateColumn
95679>>>>>>>        Get phoReportPaintManager to hoPaintManager
95680>>>>>>>        Get ComHyperlinkStyle of hoPaintManager to vHyperLinkStyle
95681>>>>>>>        Get Create (RefClass(cCJReportHyperlinkStyle)) to hoHyperLinkStyle
95682>>>>>>>        Set pvComObject of hoHyperLinkStyle to vHyperLinkStyle
95683>>>>>>>        Set ComTextDecoration of hoHyperLinkStyle to xtpReportTextDecorationUnderline
95684>>>>>>>        Send Destroy of hoHyperLinkStyle
95685>>>>>>>    End_Procedure
95686>>>>>>>
95686>>>>>>>End_Class
95687>>>>>Use RefactorFunctionConstants.inc
95687>>>>>
95687>>>>>Enum_List
95687>>>>>    Define cx_DbSelect_All
95687>>>>>    Define cx_DbSelect_None
95687>>>>>    Define cx_DbSelect_Invert
95687>>>>>End_Enum_List
95687>>>>>
95687>>>>>
95687>>>>>// Classes used by the cRDCCJSelectionGrid
95687>>>>>Class cRDCDbCJToggleSelectMenuItem is a cCJMenuItem
95688>>>>>
95688>>>>>    Procedure Construct_Object
95690>>>>>        Forward Send Construct_Object
95692>>>>>        Set psCaption to "Toggle Current Item"
95693>>>>>        Set psImage to "ToggleOn.ico"
95694>>>>>        Set psShortcut to "Space-Bar"
95695>>>>>    End_Procedure
95696>>>>>
95696>>>>>    Procedure OnExecute Variant vCommandBarControl
95698>>>>>        Forward Send OnExecute vCommandBarControl
95700>>>>>        Send ToggleCurrentItem
95701>>>>>    End_Procedure
95702>>>>>
95702>>>>>End_Class
95703>>>>>
95703>>>>>Class cRDCDbCJSelectAllMenuItem is a cCJMenuItem
95704>>>>>
95704>>>>>    Procedure Construct_Object
95706>>>>>        Forward Send Construct_Object
95708>>>>>        Set pbControlBeginGroup to True
95709>>>>>        Set psCaption to "Select All"
95710>>>>>        Set psImage to "SelectAll.ico"
95711>>>>>        Set psShortcut to "Ctrl+A"
95712>>>>>    End_Procedure
95713>>>>>
95713>>>>>    Procedure OnExecute Variant vCommandBarControl
95715>>>>>        Forward Send OnExecute vCommandBarControl
95717>>>>>        Send SelectAll of (Server(Self))
95718>>>>>        Send RefreshSelectionUpdate
95719>>>>>    End_Procedure
95720>>>>>
95720>>>>>End_Class
95721>>>>>
95721>>>>>Class cRDCDbCJDeSelectAllMenuItem is a cCJMenuItem
95722>>>>>
95722>>>>>    Procedure Construct_Object
95724>>>>>        Forward Send Construct_Object
95726>>>>>        Set psCaption to "Select None"
95727>>>>>        Set psImage to "SelectNone.ico"
95728>>>>>        Set psShortcut to "Ctrl+N"
95729>>>>>    End_Procedure
95730>>>>>
95730>>>>>    Procedure OnExecute Variant vCommandBarControl
95732>>>>>        Forward Send OnExecute vCommandBarControl
95734>>>>>        Send DeSelectAll of (Server(Self)) 
95735>>>>>        Send RefreshSelectionUpdate
95736>>>>>    End_Procedure
95737>>>>>
95737>>>>>End_Class
95738>>>>>
95738>>>>>Class cRDCDbCJInvertSelectionsMenuItem is a cCJMenuItem
95739>>>>>
95739>>>>>    Procedure Construct_Object
95741>>>>>        Forward Send Construct_Object
95743>>>>>        Set psCaption to "Invert Selection"
95744>>>>>        Set psImage to "SelectInvert.ico"
95745>>>>>        Set psShortcut to "Ctrl+I"
95746>>>>>    End_Procedure
95747>>>>>
95747>>>>>    Procedure OnExecute Variant vCommandBarControl
95749>>>>>        Forward Send OnExecute vCommandBarControl
95751>>>>>//        Set SelectItems to cx_Select_Invert
95751>>>>>    End_Procedure
95752>>>>>
95752>>>>>End_Class
95753>>>>>
95753>>>>>Class cRDCDbCJAddFolderMenuItem is a cCJMenuItem
95754>>>>>
95754>>>>>    Procedure Construct_Object
95756>>>>>        Forward Send Construct_Object
95758>>>>>        Set psCaption to "Add Folder"
95759>>>>>        Set psImage to "AddFolder.ico"
95760>>>>>        Set psShortcut to "Ins"
95761>>>>>    End_Procedure
95762>>>>>
95762>>>>>    Procedure OnExecute Variant vCommandBarControl
95764>>>>>        Forward Send OnExecute vCommandBarControl
95766>>>>>        Send BrowseForFolder
95767>>>>>    End_Procedure
95768>>>>>
95768>>>>>End_Class
95769>>>>>
95769>>>>>Class cRDCDbCJRemoveItemMenuItem is a cCJMenuItem
95770>>>>>
95770>>>>>    Procedure Construct_Object
95772>>>>>        Forward Send Construct_Object
95774>>>>>        Set psCaption to "Remove From Grid"
95775>>>>>        Set psImage to "ActionDelete.ico"
95776>>>>>        Set psShortcut to "Del"
95777>>>>>    End_Procedure
95778>>>>>
95778>>>>>    Procedure OnExecute Variant vCommandBarControl
95780>>>>>        Forward Send OnExecute vCommandBarControl
95782>>>>>        Send Request_Delete
95783>>>>>    End_Procedure
95784>>>>>
95784>>>>>End_Class
95785>>>>>
95785>>>>>Register_Function pbDbShowAddFolderMenuItem Returns Boolean
95785>>>>>Register_Function pbDbShowRemoveFolderMenuItem Returns Boolean
95785>>>>>Register_Function pbDbShowInvertSelectionsMenuItem Returns Boolean
95785>>>>>
95785>>>>>Class cDbGridContext_mnu is a cCJContextMenu
95786>>>>>    Procedure Construct_Object
95788>>>>>        Handle hoMenuItem
95788>>>>>        Forward Send Construct_Object
95790>>>>>
95790>>>>>        Get Create (RefClass(cRDCDbCJToggleSelectMenuItem))      to hoMenuItem
95791>>>>>        Get Create (RefClass(cRDCDbCJSelectAllMenuItem))         to hoMenuItem
95792>>>>>        Get Create (RefClass(cRDCDbCJDeSelectAllMenuItem))       to hoMenuItem
95793>>>>>        If (pbDbShowInvertSelectionsMenuItem(Self) = True) Begin
95795>>>>>            Get Create (RefClass(cRDCDbCJInvertSelectionsMenuItem))  to hoMenuItem
95796>>>>>        End
95796>>>>>>
95796>>>>>        If (pbDbShowAddFolderMenuItem(Self) = True) Begin
95798>>>>>            Get Create (RefClass(cRDCDbCJAddFolderMenuItem))  to hoMenuItem
95799>>>>>            Set pbControlBeginGroup of hoMenuItem to True
95800>>>>>        End
95800>>>>>>
95800>>>>>        If (pbDbShowRemoveFolderMenuItem(Self) = True) Begin
95802>>>>>            Get Create (RefClass(cRDCDbCJRemoveItemMenuItem))  to hoMenuItem
95803>>>>>            If (pbDbShowAddFolderMenuItem(Self) = False) Begin
95805>>>>>                Set pbControlBeginGroup of hoMenuItem to True
95806>>>>>            End
95806>>>>>>
95806>>>>>        End
95806>>>>>>
95806>>>>>    End_Procedure
95807>>>>>
95807>>>>>End_Class
95808>>>>>
95808>>>>>Class cRDCDbCJGrid is a cDbCJGrid
95809>>>>>
95809>>>>>    Procedure Construct_Object
95811>>>>>        Forward Send Construct_Object
95813>>>>>
95813>>>>>        // Set to true if an descending index is in use
95813>>>>>        Property Boolean pbDescendingIndexInUse False
95814>>>>>
95814>>>>>        // If you quickly double-right-click, or quickly click around a cCJGrid
95814>>>>>        // (using a combination of middle-clicks, right-clicks and left-clicks), the application can crash.
95814>>>>>        // To guard against this see the augmented procedure OnComRowRClick below.
95814>>>>>        Property Boolean pbRightClickProcessing False   
95815>>>>>        Property Handle phoCheckbox_Col
95816>>>>>        Property Handle phoData_Col
95817>>>>>        Property Boolean pbDbShowAddFolderMenuItem False
95818>>>>>        Property Boolean pbDbShowRemoveFolderMenuItem False
95819>>>>>        Property Boolean pbDbShowInvertSelectionsMenuItem False
95820>>>>>        
95820>>>>>        Set pbRestoreLayout to True
95821>>>>>        Set psLayoutSection to ((Object_Label(Parent(Self))) + "-" + (Object_Label(Self)))
95822>>>>>        Set pbUseAlternateRowBackgroundColor to True     
95823>>>>>        Set pbUseFocusCellRectangle to False
95824>>>>>        Set pbShowRowFocus to True
95825>>>>>        Set pbHotTracking to True
95826>>>>>        Set pbSelectionEnable to True
95827>>>>>        Set piSelectedRowBackColor to clGreenGreyLight
95828>>>>>        Set piHighlightBackColor   to clGreenGreyLight
95829>>>>>        Set pbShowFooter to True  
95830>>>>>        Set peAnchors to anAll
95831>>>>>        Set peVisualTheme to xtpReportThemeExplorer
95832>>>>>
95832>>>>>        On_Key Key_End   Send MoveToLastEnterableColumn
95833>>>>>        On_Key Key_Home  Send MoveToFirstEnterableColumn
95834>>>>>        On_Key Key_Space Send ToggleCurrentItem
95835>>>>>    End_Procedure
95836>>>>>
95836>>>>>    Procedure End_Construct_Object    
95838>>>>>        Handle hoContextMenu
95838>>>>>        Forward Send End_Construct_Object
95840>>>>>        Get Create (RefClass(cDbGridContext_mnu)) to hoContextMenu
95841>>>>>        Set phoContextMenu to hoContextMenu
95842>>>>>    End_Procedure
95843>>>>>
95843>>>>>    // Set checkbox column to selected states.
95843>>>>>    // iState can be one of the following:
95843>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
95843>>>>>    Procedure Set SelectItems Integer iState
95845>>>>>        Integer iCount iSize iCheckbox_Col
95845>>>>>        Boolean bChecked
95845>>>>>        Handle hoDataSource hoCheckBox_Col hoDD
95845>>>>>        tDataSourceRow[] TheData
95845>>>>>        tDataSourceRow[] TheData
95846>>>>>        
95846>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
95847>>>>>        If (hoCheckBox_Col = 0) Begin
95849>>>>>            Procedure_Return
95850>>>>>        End                 
95850>>>>>>
95850>>>>>        
95850>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
95851>>>>>        Get phoDataSource               to hoDataSource
95852>>>>>        Get DataSource of hoDataSource  to TheData
95853>>>>>        Move (SizeOfArray(TheData))     to iSize
95854>>>>>        Decrement iSize
95855>>>>>        For iCount from 0 to iSize
95861>>>>>>
95861>>>>>            Case Begin
95861>>>>>                Case (iState = cx_DbSelect_All)
95863>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
95864>>>>>                    Case Break
95865>>>>>                Case (iState = cx_DbSelect_None)
95868>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
95869>>>>>                    Case Break
95870>>>>>                Case (iState = cx_DbSelect_Invert)
95873>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
95874>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
95875>>>>>                    Case Break
95876>>>>>            Case End
95876>>>>>        Loop
95877>>>>>>
95877>>>>>
95877>>>>>        Send ReInitializeData TheData False
95878>>>>>        Send Request_Save
95879>>>>>        Get Main_DD to hoDD
95880>>>>>        If (hoDD <> 0) Begin    
95882>>>>>            If (iState = cx_DbSelect_All) Begin
95884>>>>>                Send SelectAll of hoDD
95885>>>>>            End 
95885>>>>>>
95885>>>>>            If (iState = cx_DbSelect_None) Begin
95887>>>>>                Send DeSelectAll of hoDD
95888>>>>>            End 
95888>>>>>>
95888>>>>>            Send Request_Assign of hoDD
95889>>>>>            Send Refind_Records of hoDD
95890>>>>>        End
95890>>>>>>
95890>>>>>        Send DoSetCheckboxFooterText
95891>>>>>    End_Procedure
95892>>>>>
95892>>>>>    Procedure RefreshSelectionUpdate 
95894>>>>>        Handle hoDataSource
95894>>>>>        Integer iSelectedRow
95894>>>>>        Get phoDataSource to hoDataSource 
95895>>>>>        Get SelectedRow of hoDataSource to iSelectedRow
95896>>>>>        Send RefreshDataFromDD iSelectedRow
95897>>>>>    End_Procedure
95898>>>>>
95898>>>>>Register_Object oCheckbox_Col
95898>>>>>
95898>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
95898>>>>>    Function SelectedItems Returns String[]
95900>>>>>        Integer i iItems iSize iCheckbox_Col iData_Col
95900>>>>>        String[] sDataArray
95901>>>>>        Handle hoDataSource hoData_Col hoCheckBox_Col
95901>>>>>        tDataSourceRow[] TheData
95901>>>>>        tDataSourceRow[] TheData
95902>>>>>        Boolean bChecked
95902>>>>>
95902>>>>>        Get phoData_Col to hoData_Col
95903>>>>>        If (hoData_Col = 0) Begin
95905>>>>>            Move 1 to iData_Col
95906>>>>>        End                    
95906>>>>>>
95906>>>>>        Else Begin
95907>>>>>            Get piColumnId of hoData_Col to iData_Col
95908>>>>>        End                                          
95908>>>>>>
95908>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
95909>>>>>        If (hoCheckBox_Col = 0) Begin
95911>>>>>            Function_Return sDataArray
95912>>>>>        End                           
95912>>>>>>
95912>>>>>        Else Begin
95913>>>>>            Get piColumnId of oCheckbox_Col to iCheckbox_Col
95914>>>>>        End
95914>>>>>>
95914>>>>>
95914>>>>>        Get phoDataSource to hoDataSource
95915>>>>>        Get DataSource of hoDataSource to TheData
95916>>>>>        Move (SizeOfArray(TheData)) to iItems
95917>>>>>        Decrement iItems
95918>>>>>
95918>>>>>        For i from 0 to iItems
95924>>>>>>
95924>>>>>            Move TheData[i].sValue[iCheckbox_Col] to bChecked
95925>>>>>            If (bChecked = True) Begin
95927>>>>>                Move (SizeOfArray(sDataArray)) to iSize
95928>>>>>                Move TheData[i].sValue[iData_Col] to sDataArray[iSize]
95929>>>>>            End
95929>>>>>>
95929>>>>>        Loop
95930>>>>>>
95930>>>>>
95930>>>>>        Function_Return sDataArray
95931>>>>>    End_Function
95932>>>>>
95932>>>>>    Procedure SelectAll
95934>>>>>        Set SelectItems to cx_DbSelect_All
95935>>>>>    End_Procedure
95936>>>>>
95936>>>>>    Procedure SelectNone
95938>>>>>        Set SelectItems to cx_DbSelect_None
95939>>>>>    End_Procedure
95940>>>>>
95940>>>>>    Procedure SelectInvert
95942>>>>>        Set SelectItems to cx_DbSelect_Invert
95943>>>>>    End_Procedure
95944>>>>>
95944>>>>>    Procedure AddItem String sDataValue
95946>>>>>        Handle hoDataSource
95946>>>>>        tDataSourceRow[] TheData
95946>>>>>        tDataSourceRow[] TheData
95947>>>>>        tsSearchResult[] asFolderArray
95947>>>>>        tsSearchResult[] asFolderArray
95948>>>>>        Integer iSize iData_Col iCheckbox_Col
95948>>>>>
95948>>>>>        If (not(IsComObjectCreated(Self))) Begin
95950>>>>>            Procedure_Return
95951>>>>>        End
95951>>>>>>
95951>>>>>
95951>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
95952>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
95953>>>>>        Get phoDataSource to hoDataSource
95954>>>>>        Get DataSource of hoDataSource to TheData
95955>>>>>        Move (SizeOfArray(TheData)) to iSize
95956>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
95957>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
95958>>>>>
95958>>>>>        Send ReInitializeData TheData False
95959>>>>>        Send MoveToFirstRow
95960>>>>>    End_Procedure
95961>>>>>
95961>>>>>    Procedure BrowseForFolder
95963>>>>>        String sFolderName
95963>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
95964>>>>>        If (sFolderName <> "") Begin
95966>>>>>            Send AddItem sFolderName
95967>>>>>        End
95967>>>>>>
95967>>>>>    End_Procedure
95968>>>>>
95968>>>>>    // Returns number of items.
95968>>>>>    Function ItemCount Returns Integer
95970>>>>>        Integer iItems
95970>>>>>        Handle hoDataSource
95970>>>>>        tDataSourceRow[] TheData
95970>>>>>        tDataSourceRow[] TheData
95971>>>>>
95971>>>>>        Get phoDataSource to hoDataSource
95972>>>>>        Get DataSource of hoDataSource to TheData
95973>>>>>        Move (SizeOfArray(TheData)) to iItems
95974>>>>>
95974>>>>>        Function_Return iItems
95975>>>>>    End_Function
95976>>>>>
95976>>>>>    // Returns number of checked items.
95976>>>>>    Function CheckedItems Returns Integer
95978>>>>>        Integer iCount iItems iCheckbox_Col iRetval
95978>>>>>        Handle hoDataSource hoCheckbox_Col
95978>>>>>        tDataSourceRow[] TheData
95978>>>>>        tDataSourceRow[] TheData
95979>>>>>        Boolean bChecked
95979>>>>>        
95979>>>>>        Move 0 to iRetval
95980>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
95981>>>>>        If (hoCheckbox_Col = 0) Begin
95983>>>>>            Procedure_Return
95984>>>>>        End
95984>>>>>>
95984>>>>>        Get piColumnId of hoCheckbox_Col to iCheckbox_Col
95985>>>>>        Get phoDataSource to hoDataSource
95986>>>>>        Get DataSource of hoDataSource to TheData
95987>>>>>        Move (SizeOfArray(TheData)) to iItems
95988>>>>>        Decrement iItems
95989>>>>>
95989>>>>>        For iCount from 0 to iItems
95995>>>>>>
95995>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
95996>>>>>            If (bChecked = True) Begin
95998>>>>>                Increment iRetval
95999>>>>>            End
95999>>>>>>
95999>>>>>        Loop
96000>>>>>>
96000>>>>>
96000>>>>>        Function_Return iRetval
96001>>>>>    End_Function
96002>>>>>
96002>>>>>    // Toggles the current row on/off (the checkbox)
96002>>>>>    Procedure ToggleCurrentItem
96004>>>>>        Boolean bChecked
96004>>>>>        Integer iCol
96004>>>>>        Handle hoCol hoCheckbox_Col hoDD
96004>>>>>
96004>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
96005>>>>>        If (hoCheckbox_Col = 0) Begin
96007>>>>>            Procedure_Return
96008>>>>>        End
96008>>>>>>
96008>>>>>        Get piColumnId of hoCheckbox_Col to iCol
96009>>>>>        Get ColumnObject iCol   to hoCol
96010>>>>>        Get SelectedRowValue    of hoCol to bChecked
96011>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
96012>>>>>        Get Server to hoDD
96013>>>>>        If (hoDD <> 0) Begin
96015>>>>>            Send Request_Save of hoDD
96016>>>>>        End
96016>>>>>>
96016>>>>>        Send DoSetCheckboxFooterText
96017>>>>>    End_Procedure
96018>>>>>
96018>>>>>    Procedure DoSetCheckboxFooterText
96020>>>>>        Integer iCol iSelected iItems
96020>>>>>        Handle hoCol hoCheckbox_Col hoData_Col
96020>>>>>        
96020>>>>>        Get phoData_Col to hoData_Col
96021>>>>>        If (hoData_Col = 0) Begin
96023>>>>>            Move 0 to iCol
96024>>>>>        End
96024>>>>>>
96024>>>>>        Else Begin
96025>>>>>            Get piColumnId of hoData_Col to iCol
96026>>>>>        End
96026>>>>>>
96026>>>>>        Get ItemCount to iItems
96027>>>>>        Get CheckedItems to iSelected
96028>>>>>        Get ColumnObject iCol to hoCol
96029>>>>>        If (hoCol <> 0) Begin
96031>>>>>            Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))            
96032>>>>>        End
96032>>>>>>
96032>>>>>    End_Procedure
96033>>>>>
96033>>>>>    Procedure OnCreateGridControl
96035>>>>>        Forward Send OnCreateGridControl
96037>>>>>        Send DoChangeTooltipStyle
96038>>>>>    End_Procedure    
96039>>>>>    
96039>>>>>    Procedure Activating
96041>>>>>        Send DoChangeFontSize      
96042>>>>>    End_Procedure    
96043>>>>>
96043>>>>>    Procedure DoChangeFontSize
96045>>>>>        Handle hoFont hoPaintManager
96045>>>>>        Variant vFont
96045>>>>>        String sFont sFontSize
96045>>>>>        Boolean bCreated
96045>>>>>        Integer iVal
96045>>>>>
96045>>>>>        Get IsComObjectCreated to bCreated  // When program is started, grid object isn't created yet.
96046>>>>>        If (bCreated = False) Begin
96048>>>>>            Procedure_Return
96049>>>>>        End
96049>>>>>>
96049>>>>>
96049>>>>>        Get phoReportPaintManager to hoPaintManager
96050>>>>>        Get Create (RefClass(cComStdFont)) to hoFont  // Create a font object
96051>>>>>        Get ComTextFont of hoPaintManager to vFont    // Bind the font object to the Grid's text font
96052>>>>>        Set pvComObject of hoFont to vFont            // Connect DataFlex object with com object
96053>>>>>
96053>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iVal
96054>>>>>        Set ComSize of hoFont to iVal
96055>>>>>        Send ComRedraw
96056>>>>>        Send Destroy to hoFont                        // Destroy the font object (releases memory)
96057>>>>>    End_Procedure
96058>>>>>
96058>>>>>    Procedure DoChangeTooltipStyle
96060>>>>>        Handle  hoTooltip
96060>>>>>        Integer iIcon iStyle iWidth
96060>>>>>        Boolean bBaloon
96060>>>>>
96060>>>>>        Get phoToolTipContext to hoTooltip
96061>>>>>
96061>>>>>        // This is the programs global tooltip control defined at desktop level.
96061>>>>>        If (ghoToolTipController > 0) Begin
96063>>>>>            Get piIcon of ghoToolTipController    to iIcon
96064>>>>>            // The global tooltip controller allows the icons to be
96064>>>>>            // from 0-5, but the tooltip context class only allows
96064>>>>>            // the tooltip icon to be between 0-3.
96064>>>>>            If (iIcon > 3) Begin
96066>>>>>                Move xtpToolTipIconInfo to iIcon
96067>>>>>            End
96067>>>>>>
96067>>>>>            Get piMaxWidth of ghoToolTipController to iWidth
96068>>>>>            Get pbBalloonStyle of ghoToolTipController to bBaloon
96069>>>>>            If (bBaloon = True) Begin
96071>>>>>                Move xtpToolTipBalloon to iStyle
96072>>>>>            End
96072>>>>>>
96072>>>>>            Else Begin
96073>>>>>                Move xtpToolTipOffice2007 to iStyle
96074>>>>>            End
96074>>>>>>
96074>>>>>        End
96074>>>>>>
96074>>>>>        Else Begin
96075>>>>>            Move xtpToolTipIconInfo   to iIcon
96076>>>>>            Move xtpToolTipOffice2007 to iStyle
96077>>>>>            Move 400                  to iWidth
96078>>>>>        End
96078>>>>>>
96078>>>>>
96078>>>>>        Set ComStyle of hoTooltip to iStyle
96079>>>>>        Set ComMaxTipWidth of hoTooltip to iWidth
96080>>>>>    End_Procedure    
96081>>>>>    
96081>>>>>    Procedure OnComGetToolTipInfo Variant lltoolTipInfo
96083>>>>>        Forward Send OnComGetToolTipInfo lltoolTipInfo
96085>>>>>    End_Procedure
96086>>>>>
96086>>>>>    // When changing to new row, update the form 'No of Rows'
96086>>>>>    Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
96088>>>>>        Forward Send OnRowChanged iOldRow iNewSelectedRow
96090>>>>>        Send DoSetCurrentRow
96091>>>>>    End_Procedure
96092>>>>>
96092>>>>>    // When loading data, update the footer 'No of Items' text
96092>>>>>    Procedure Refresh Integer eMode
96094>>>>>        Forward Send Refresh eMode
96096>>>>>        Send DoSetCurrentRow
96097>>>>>    End_Procedure
96098>>>>>
96098>>>>>    Procedure DoSetCurrentRow
96100>>>>>        Send DoSetCheckboxFooterText
96101>>>>>    End_Procedure
96102>>>>>
96102>>>>>    Function Checkbox_item_State Integer iItem Returns Integer
96104>>>>>        Forward Get Checkbox_Item_State to iItem
96106>>>>>        Send DoSetCheckboxFooterText
96107>>>>>        Function_Return iItem
96108>>>>>    End_Function
96109>>>>>    
96109>>>>>    Procedure OnComHyperlinkClick Variant llRow Variant llItem Integer llHyperlinkIndex
96111>>>>>        Handle  hoRow hoItem hoColumn
96111>>>>>        String  sLink
96111>>>>>        Integer iRow iColumn
96111>>>>>
96111>>>>>        Get phoReportRow to hoRow
96112>>>>>        Get phoReportRecordItem to hoItem
96113>>>>>
96113>>>>>        Set pvComObject of hoItem to llItem
96114>>>>>        Get ComIndex    of hoItem to iColumn
96115>>>>>        Set pvComObject of hoRow to llRow
96116>>>>>        Get ComIndex    of hoRow to iRow
96117>>>>>        Get ColumnObject iColumn to hoColumn
96118>>>>>        Get RowValue of hoColumn iRow to sLink
96119>>>>>
96119>>>>>        Send OnLinkClicked of hoColumn sLink iRow
96120>>>>>    End_Procedure
96121>>>>>
96121>>>>>    // Redisplay the grid records around the current record.
96121>>>>>    // If the  record no longer exists or no longer conforms to the current constraints
96121>>>>>    // this will redisplay the records with the same iOffset.
96121>>>>>    // If both finds fail the grid will not be updated so we need to clear it.
96121>>>>>    Procedure RefreshGrid
96123>>>>>        Send Find to (Server(Self)) GE (Ordering(Self))   // to refresh grid
96124>>>>>        If (not(Found)) Begin
96126>>>>>            If (pbDescendingIndexInUse(Self) = True or pbReverseOrdering(Self) = True) Begin
96128>>>>>                Send Find to (Server(Self)) FIRST_RECORD (Ordering(Self))
96129>>>>>            End
96129>>>>>>
96129>>>>>            Else If (pbDescendingIndexInUse(Self) = False or pbReverseOrdering(Self) = False) Begin
96132>>>>>                Send Find to (Server(Self)) LAST_RECORD (Ordering(Self))
96133>>>>>            End
96133>>>>>>
96133>>>>>        End
96133>>>>>>
96133>>>>>        If (not(Found) and IsComObjectCreated(Self)) Begin
96135>>>>>            Send ResetGrid
96136>>>>>        End
96136>>>>>>
96136>>>>>    End_Procedure
96137>>>>>
96137>>>>>    Procedure Request_Delete
96139>>>>>        Forward Send Request_Delete
96141>>>>>
96141>>>>>        // Needed to ensure list of remaining records displayed correctly
96141>>>>>        Send RefreshGrid
96142>>>>>    End_Procedure
96143>>>>>
96143>>>>>    // If you quickly double-right-click, or quickly click around a cCJGrid
96143>>>>>    // (using a combination of middle-clicks, right-clicks and left-clicks), the application can crash.
96143>>>>>    // This fixes that little problem.
96143>>>>>    Procedure OnComRowRClick Variant llRow Variant llItem
96145>>>>>        Boolean bProcessing
96145>>>>>        Get pbRightClickProcessing to bProcessing
96146>>>>>        If (not(bProcessing)) Begin
96148>>>>>            Set pbRightClickProcessing to True
96149>>>>>            Forward Send OnComRowRClick llRow llItem
96151>>>>>            Set pbRightClickProcessing to False
96152>>>>>        End
96152>>>>>>
96152>>>>>    End_Procedure
96153>>>>>
96153>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
96155>>>>>        Integer iSize jSize kSize iSup iInf iDef
96155>>>>>        Handle hoPaintManager hoFont
96155>>>>>        Variant vFont
96155>>>>>        
96155>>>>>        Move 3 to iInf      //max size
96156>>>>>        Move 18 to iSup     //min size
96157>>>>>        Move 8 to iDef      //default
96158>>>>>        Boolean blimite
96158>>>>>        Get phoReportPaintManager to hoPaintManager
96159>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
96161>>>>>            Procedure_Return
96162>>>>>        End
96162>>>>>>
96162>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
96163>>>>>        Get ComTextFont of hoPaintManager to vFont
96164>>>>>        Set pvComObject of hoFont to vFont
96165>>>>>        If (iDirection = 0) Begin
96167>>>>>            Set ComSize of hoFont to iDef
96168>>>>>        End
96168>>>>>>
96168>>>>>        Else Begin
96169>>>>>           Get ComSize of hoFont to iSize
96170>>>>>           Move iSize to jSize
96171>>>>>           Repeat
96171>>>>>>
96171>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
96172>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
96173>>>>>                If (not(blimite)) Begin       
96175>>>>>                   Set ComSize of hoFont to jSize
96176>>>>>                   Get ComSize of hoFont to kSize
96177>>>>>                End
96177>>>>>>
96177>>>>>            Until (iSize <> kSize or blimite)
96179>>>>>        End
96179>>>>>>
96179>>>>>        Send Destroy to hoFont 
96180>>>>>        Send ComRedraw  
96181>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
96182>>>>>    End_Procedure 
96183>>>>>
96183>>>>>End_Class
96184>>>Use cRDCDbCJGridColumn.pkg
Including file: cRDCDbCJGridColumn.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGridColumn.pkg)
96184>>>>>Use cDbCJGridColumn.pkg
96184>>>>>
96184>>>>>Class cRDCDbCJGridColumn is a cDbCJGridColumn
96185>>>>>
96185>>>>>    Procedure Construct_Object
96187>>>>>        Forward Send Construct_Object
96189>>>>>        Set psToolTip to "Right-click grid for context sensitive menu options"
96190>>>>>
96190>>>>>    End_Procedure
96191>>>>>
96191>>>>>    Procedure End_Construct_Object
96193>>>>>        Forward Send End_Construct_Object
96195>>>>>
96195>>>>>    End_Procedure
96196>>>>>
96196>>>>>//    Function OnGetTooltip Integer iRow String sValue String sText Returns String
96196>>>>>//        String sRetVal
96196>>>>>//        Forward Get OnGetTooltip iRow sValue sText to sRetVal
96196>>>>>//        Function_Return sRetVal
96196>>>>>//    End_Function
96196>>>>>
96196>>>>>End_Class
96197>>>Use cRDCCJSelectionGrid.pkg
96197>>>Use cRDCDbComboForm.pkg
Including file: cRDCDbComboForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbComboForm.pkg)
96197>>>>>//****************************************************************************
96197>>>>>// $Module type: Package
96197>>>>>// $Module name: cRDCDbComboform.pkg
96197>>>>>//
96197>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96197>>>>>// Copyright (c) 2014 RDC Tools International
96197>>>>>// E-mail      : support@rdctools.com
96197>>>>>// Web-site    : http://www.rdctools.com
96197>>>>>//
96197>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
96197>>>>>//
96197>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
96197>>>>>//               The auto-size combo width logic was developed by Raveen.
96197>>>>>//
96197>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96197>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96197>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96197>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96197>>>>>// in the help folder for more details.
96197>>>>>//
96197>>>>>//****************************************************************************
96197>>>>>Use Dfcentry.pkg
96197>>>>>
96197>>>>>// Used by the "Page" message below to show
96197>>>>>// a focus rectangle around ComboForm and Checkbox objects.
96197>>>>>Define WM_CHANGEUISTATE For |CI$0127
96197>>>>>Define WM_UPDATEUISTATE For |CI$0128
96197>>>>>Define WM_QUERYUISTATE  For |CI$0129
96197>>>>>Define UIS_SET          For 1
96197>>>>>Define UIS_CLEAR        For 2
96197>>>>>Define UIS_INITIALIZE   For 3
96197>>>>>Define UISF_HIDEFOCUS   For |CI$1
96197>>>>>Define UISF_HIDEACCEL   For |CI$2
96197>>>>>Define UISF_ACTIVE      For |CI$4
96197>>>>>
96197>>>>>Class cDbComboFormIdleHandler is a cIdleHandler
96198>>>>>    Procedure Construct_Object
96200>>>>>        Forward Send Construct_Object
96202>>>>>
96202>>>>>        Set Label_Row_Offset to 0
96203>>>>>        Set Label_Col_Offset to 2
96204>>>>>        Set Label_Justification_Mode to jMode_Right
96205>>>>>        Set Combo_Sort_State to False
96206>>>>>        Set Entry_State to False
96207>>>>>
96207>>>>>    End_Procedure
96208>>>>>
96208>>>>>    Procedure OnIdle
96210>>>>>        Delegate Send DoUpdate
96212>>>>>    End_Procedure
96213>>>>>
96213>>>>>End_Class
96214>>>>>
96214>>>>>Class cRDCDbComboForm is a dbComboForm
96215>>>>>    Procedure Construct_Object
96217>>>>>        Forward Send Construct_Object
96219>>>>>
96219>>>>>        Property Boolean pbAutoListWidth True
96220>>>>>
96220>>>>>        Property Boolean pbAutoShadowLabelObject True
96221>>>>>
96221>>>>>        Property Boolean pbAutoEnable False
96222>>>>>        Set Label_Col_Offset to 2
96223>>>>>        Property Boolean pbEnabled True
96224>>>>>        Set Label_Justification_Mode to JMode_Right
96225>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cDbComboFormIdleHandler)))
96226>>>>>
96226>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
96227>>>>>        On_Key kCancel Send None
96228>>>>>        On_Key Key_F3  Send None 
96229>>>>>        On_Key Key_Ctrl+Key_F4 Send None
96230>>>>>    End_Procedure
96231>>>>>
96231>>>>>    Procedure End_Construct_Object
96233>>>>>        Boolean bAutoShadowLabelObject
96233>>>>>        String sTooltip sStatus_Help
96233>>>>>
96233>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
96234>>>>>        If (bAutoShadowLabelObject = True) Begin
96236>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
96237>>>>>        End
96237>>>>>>
96237>>>>>
96237>>>>>        Forward Send End_Construct_Object
96239>>>>>
96239>>>>>        Get psToolTip   to sTooltip
96240>>>>>        Get Status_Help to sStatus_Help
96241>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96243>>>>>            Set psToolTip to sStatus_Help
96244>>>>>        End
96244>>>>>>
96244>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
96247>>>>>            Set Status_Help to sTooltip
96248>>>>>        End
96248>>>>>>
96248>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96249>>>>>
96249>>>>>    End_Procedure
96250>>>>>
96250>>>>>    Procedure DoUpdate
96252>>>>>        If (pbAutoEnable(Self) = False) Begin
96254>>>>>            Procedure_Return
96255>>>>>        End
96255>>>>>>
96255>>>>>        Set Enabled_State to (IsEnabled(Self))
96256>>>>>    End_Procedure
96257>>>>>
96257>>>>>    Function IsEnabled Returns Boolean
96259>>>>>        Boolean bEnabled
96259>>>>>        Get pbEnabled to bEnabled
96260>>>>>        Function_Return bEnabled
96261>>>>>    End_Function
96262>>>>>
96262>>>>>    // Enable the idle handler timer when the object is activated
96262>>>>>    Procedure Activating
96264>>>>>        Forward Send Activating
96266>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96267>>>>>    End_Procedure
96268>>>>>
96268>>>>>    // Disable the idle handler when the object is deactivated
96268>>>>>    Procedure Deactivating
96270>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96271>>>>>        Forward Send Deactivating
96273>>>>>    End_Procedure
96274>>>>>
96274>>>>>    // To "un-select" the text in the comboform on startup
96274>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
96276>>>>>        Integer iStart iEnd
96276>>>>>
96276>>>>>        If (Focus(Desktop)=Self) Begin
96278>>>>>            Get SelStart to iStart
96279>>>>>            Get SelEnd   to iEnd
96280>>>>>        End
96280>>>>>>
96280>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
96282>>>>>        Send SetSel iStart iEnd
96283>>>>>    End_Procedure
96284>>>>>
96284>>>>>    // Message that will drop down the list without the user clicking it,
96284>>>>>    // so you can send "DropDownList" to the combo to show the list.
96284>>>>>    Procedure DropDownList
96286>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
96287>>>>>    End_Procedure
96288>>>>>
96288>>>>>    Procedure SizeComboWidth
96290>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
96290>>>>>        String sVal
96290>>>>>
96290>>>>>        // Initialise Width
96290>>>>>        Set ListWidth to 0
96291>>>>>        Send DoSetListWidth
96292>>>>>
96292>>>>>        Get ListRowCount     to iRows
96293>>>>>        Get Combo_Item_Count to iCount
96294>>>>>
96294>>>>>        // Vertical scroll-bar adjustment is needed
96294>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
96295>>>>>        If (iVertAdj) Begin
96297>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
96298>>>>>        End
96298>>>>>>
96298>>>>>        Else Begin
96299>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
96300>>>>>        End
96300>>>>>>
96300>>>>>
96300>>>>>        // Calculate New Width
96300>>>>>        Decrement iCount
96301>>>>>        For iItem from 0 to iCount
96307>>>>>>
96307>>>>>            Get Combo_Value iItem to sVal
96308>>>>>            If (sVal <> "") Begin
96310>>>>>                Get Text_Extent sVal to iTextExt
96311>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
96312>>>>>                If (iWd > iNewWd) Begin
96314>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
96315>>>>>                End
96315>>>>>>
96315>>>>>            End
96315>>>>>>
96315>>>>>        Loop
96316>>>>>>
96316>>>>>
96316>>>>>        // Set New Width
96316>>>>>        Set ListWidth to iNewWd
96317>>>>>        Send DoSetListWidth
96318>>>>>    End_Procedure
96319>>>>>
96319>>>>>    Procedure Combo_Add_Item String sValue
96321>>>>>        Forward Send Combo_Add_Item sValue
96323>>>>>        If (pbAutoListWidth(Self)) Begin
96325>>>>>            Send SizeComboWidth
96326>>>>>        End
96326>>>>>>
96326>>>>>    End_Procedure
96327>>>>>
96327>>>>>    Procedure Combo_Fill_List
96329>>>>>        Forward Send Combo_Fill_List
96331>>>>>        If (pbAutoListWidth(Self)) Begin
96333>>>>>            Send SizeComboWidth
96334>>>>>        End
96334>>>>>>
96334>>>>>    End_Procedure
96335>>>>>
96335>>>>>    // Fix for a bug when using manifest files & running Vista and above.
96335>>>>>    // The bug being that the focus rectangle doesn't show.
96335>>>>>    Procedure Page Integer iPageObject
96337>>>>>        Handle hWnd
96337>>>>>        Integer iRet iState
96337>>>>>
96337>>>>>        Forward Send Page iPageObject
96339>>>>>
96339>>>>>        If (iPageObject) Begin
96341>>>>>            Get Window_Handle to hWnd
96342>>>>>            If (hWnd) Begin
96344>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
96345>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
96347>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
96348>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
96349>>>>>                End
96349>>>>>>
96349>>>>>            End
96349>>>>>>
96349>>>>>        End
96349>>>>>>
96349>>>>>
96349>>>>>        // To "un-select" the text in the comboform
96349>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
96351>>>>>            Send SetSel 0 0
96352>>>>>        End
96352>>>>>>
96352>>>>>    End_Procedure
96353>>>>>
96353>>>>>End_Class
96354>>>Use cRDCDbHeaderGroup.pkg
Including file: cRDCDbHeaderGroup.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbHeaderGroup.pkg)
96354>>>>>//****************************************************************************
96354>>>>>// $Module type: Package
96354>>>>>// $Module name: cRDCHeaderGroup.pkg
96354>>>>>//
96354>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96354>>>>>// Copyright (c) 2017 RDC Tools International
96354>>>>>// E-mail      : support@rdctools.com
96354>>>>>// Web-site    : http://www.rdctools.com
96354>>>>>//
96354>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
96354>>>>>//
96354>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96354>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96354>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96354>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96354>>>>>// in the help folder for more details.
96354>>>>>//
96354>>>>>//****************************************************************************
96354>>>>>Use Dfclient.pkg
96354>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLinkButton.pkg)
96354>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
96354>>>>>>>// older versions you will just get a regular great big button.
96354>>>>>>>
96354>>>>>>>Use Windows.pkg
96354>>>>>>>Use CharTranslate.pkg
96354>>>>>>>
96354>>>>>>>Class cCommandLinkButton is a Button
96355>>>>>>>    
96355>>>>>>>    Procedure Construct_Object
96357>>>>>>>        Forward Send Construct_Object
96359>>>>>>>        Property String psPrivateNote
96360>>>>>>>    End_Procedure
96361>>>>>>>    
96361>>>>>>>    Procedure Set psNote String sNote
96363>>>>>>>        Boolean bSupported
96363>>>>>>>        Set psPrivateNote to sNote
96364>>>>>>>        Get IsExControlSupported to bSupported
96365>>>>>>>        If bSupported Begin
96367>>>>>>>            Send SetWinNote
96368>>>>>>>        End
96368>>>>>>>>
96368>>>>>>>    End_Procedure
96369>>>>>>>    
96369>>>>>>>    Procedure SetWinNote
96371>>>>>>>        String sNote
96371>>>>>>>        Handle hWnd
96371>>>>>>>        Integer i
96371>>>>>>>        Address aVar
96371>>>>>>>        Get Form_Window_Handle 0 to hWnd
96372>>>>>>>        If hWnd Begin
96374>>>>>>>            Get psNote to sNote
96375>>>>>>>            Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
96376>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
96377>>>>>>>            Move (Free(aVar)) to i
96378>>>>>>>        End
96378>>>>>>>>
96378>>>>>>>    End_Procedure
96379>>>>>>>    
96379>>>>>>>    
96379>>>>>>>    Function psNote Returns String
96381>>>>>>>        Function_Return (psPrivateNote(Self))
96382>>>>>>>    End_Function
96383>>>>>>>    
96383>>>>>>>    
96383>>>>>>>    Procedure Page Integer iState
96385>>>>>>>        Integer i hWnd
96385>>>>>>>        Boolean bSupported
96385>>>>>>>        Get IsExControlSupported to bSupported
96386>>>>>>>        If (iState=1 and bSupported) Begin
96388>>>>>>>            Get form_style i to i
96389>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
96390>>>>>>>            Forward Send Page iState
96392>>>>>>>            Send SetWinNote
96393>>>>>>>        End
96393>>>>>>>>
96393>>>>>>>        Else Begin
96394>>>>>>>            Forward Send Page iState
96396>>>>>>>        End
96396>>>>>>>>
96396>>>>>>>    End_Procedure
96397>>>>>>>    
96397>>>>>>>End_Class
96398>>>>>
96398>>>>>Class cRDCDbHeaderGroupImage is a cCommandLinkButton
96399>>>>>    Procedure Construct_Object
96401>>>>>        Forward Send Construct_Object
96403>>>>>
96403>>>>>        Set Size to 18 19
96404>>>>>        Set Focus_Mode to NonFocusable
96405>>>>>        Set peImageAlign to Button_ImageList_Align_Top
96406>>>>>        Set pbAutoResizeIcons to True
96407>>>>>    End_Procedure
96408>>>>>
96408>>>>>    Procedure OnClick
96410>>>>>        Broadcast Send Prompt of (Parent(Self))
96412>>>>>    End_Procedure
96413>>>>>
96413>>>>>    Procedure Set Bitmap String sBitmapName
96415>>>>>        Forward Set psImage to sBitmapName
96417>>>>>    End_Procedure
96418>>>>>
96418>>>>>    Procedure End_Construct_Object
96420>>>>>        Set pbShield to False
96421>>>>>        Forward Send End_Construct_Object
96423>>>>>    End_Procedure
96424>>>>>
96424>>>>>End_Class
96425>>>>>
96425>>>>>// Intermediate class - don't use.
96425>>>>>Class _cRDCDbHeaderGroup is a dbContainer3d
96426>>>>>
96426>>>>>    Procedure Construct_Object
96428>>>>>        Forward Send Construct_Object
96430>>>>>
96430>>>>>        Property String private.psImage
96431>>>>>        Property String private.psLabel
96432>>>>>
96432>>>>>    End_Procedure
96433>>>>>
96433>>>>>    Procedure Set psImage String sImage
96435>>>>>        Set private.psImage to sImage
96436>>>>>    End_Procedure
96437>>>>>
96437>>>>>    Function psImage Returns String
96439>>>>>        Function_Return (private.psImage(Self))
96440>>>>>    End_Function
96441>>>>>
96441>>>>>    Procedure Set psLabel String sLabel
96443>>>>>        Set private.psLabel to sLabel
96444>>>>>    End_Procedure
96445>>>>>
96445>>>>>    Function psLabel Returns String
96447>>>>>        Function_Return (private.psLabel(Self))
96448>>>>>    End_Function
96449>>>>>
96449>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
96449>>>>>    Procedure Set Label String sLabel
96451>>>>>        Set psLabel to sLabel
96452>>>>>    End_Procedure
96453>>>>>
96453>>>>>    Function Label Returns String
96455>>>>>        Function_Return (private.psLabel(Self))
96456>>>>>    End_Function
96457>>>>>
96457>>>>>End_Class
96458>>>>>
96458>>>>>Register_Procedure NavigatePrevious
96458>>>>>Register_Procedure NavigateNext
96458>>>>>
96458>>>>>Class cRDCDbHeaderGroup is a _cRDCDbHeaderGroup
96459>>>>>
96459>>>>>    Procedure Construct_Object
96461>>>>>        Forward Send Construct_Object
96463>>>>>
96463>>>>>        Set peAnchors to anTopBottom //anTopLeftRight
96464>>>>>        Set pbAcceptDropFiles to True
96465>>>>>        Set Border_Style to Border_Normal
96466>>>>>
96466>>>>>        Property Integer private.piColorOrg
96467>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
96468>>>>>        Property String private.psToolTip ""
96469>>>>>
96469>>>>>        Property Integer piImageColOffset 4
96470>>>>>        Property Integer piImageRowOffset -1
96471>>>>>        Property String psNote ""
96472>>>>>        Property Boolean pbLargeImageSize True
96473>>>>>        Property Integer private.piLargeImageSize 24
96474>>>>>        Property Integer private.piSmallImageSize 16
96475>>>>>        Property Boolean pbUseHotspotColor False
96476>>>>>        Property Integer piHeaderHotspotColor clAqua
96477>>>>>        Property String private.psLabel ""
96478>>>>>        Property Integer piLabelColor clGreenGrey
96479>>>>>        Property Boolean pbLabelFontItalics False
96480>>>>>        Property Integer piLabelLargeFontHeight 12
96481>>>>>        Property Integer piLabelSmallFontHeight 10
96482>>>>>        Property Boolean pbUseLargeFontHeight False
96483>>>>>
96483>>>>>        Property Integer piLabelFontPointWeight fw_Bold
96484>>>>>        Property Integer piLabelColOffset 28
96485>>>>>        Property Integer piLabelRowOffset 4
96486>>>>>        Property Boolean pbCreateTooltipItem True
96487>>>>>
96487>>>>>        Set pbAcceptDropFiles to True
96488>>>>>
96488>>>>>        Send Define_ToolTip_Support_Mixin
96489>>>>>
96489>>>>>        // For the Studio to render the header image
96489>>>>>        Set Bitmap to "Default32x32.bmp"
96490>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
96490>>>>>        // to render some text in the header when in design mode?
96490>>>>>        Set Label to "HEADER TEXT"
96491>>>>>
96491>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
96492>>>>>        On_Key kCancel Send None
96493>>>>>        On_Key Key_F3  Send None 
96494>>>>>        On_Key Key_Ctrl+Key_F4 Send None
96495>>>>>        On_Key kLeftArrow  Send NavigatePrevious
96496>>>>>        On_Key kUpArrow    Send NavigatePrevious
96497>>>>>        On_Key kRightArrow Send NavigateNext
96498>>>>>        On_Key kDownArrow  Send NavigateNext
96499>>>>>        On_Key kSwitch     Send Switch_Next_Area
96500>>>>>    End_Procedure
96501>>>>>
96501>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
96502>>>>>
96502>>>>>    Procedure Set psImage String sImage
96504>>>>>        Set Bitmap to ""
96505>>>>>        Forward Set psImage to sImage
96507>>>>>    End_Procedure
96508>>>>>
96508>>>>>    Function psImage Returns String
96510>>>>>        Function_Return (psImage(Self))
96511>>>>>    End_Function
96512>>>>>
96512>>>>>    Procedure Set Label String sLabel
96514>>>>>        Forward Set psLabel to sLabel
96516>>>>>    End_Procedure
96517>>>>>
96517>>>>>    Procedure Set psToolTip String sToolTip
96519>>>>>        Set private.psToolTip to sToolTip
96520>>>>>    End_Procedure
96521>>>>>
96521>>>>>    Function psToolTip Returns String
96523>>>>>        Function_Return (private.psToolTip(Self))
96524>>>>>    End_Function
96525>>>>>
96525>>>>>    Procedure End_Construct_Object
96527>>>>>        String sNote sLabel
96527>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
96527>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
96527>>>>>
96527>>>>>        Forward Send End_Construct_Object
96529>>>>>
96529>>>>>        Get piLabelColOffset to iLabelColOffset
96530>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
96531>>>>>        If (bUseLargeFontHeight = True) Begin
96533>>>>>            Get piLabelLargeFontHeight to iFontHeight
96534>>>>>            Move 8 to iLabelRowOffset
96535>>>>>        End
96535>>>>>>
96535>>>>>        Else Begin
96536>>>>>            Get piLabelSmallFontHeight to iFontHeight
96537>>>>>            Move 6 to iLabelRowOffset
96538>>>>>        End
96538>>>>>>
96538>>>>>
96538>>>>>        Get pbLargeImageSize to bLargeImageSize
96539>>>>>        If (bLargeImageSize = True) Begin
96541>>>>>            Get private.piLargeImageSize to iImageSize
96542>>>>>        End
96542>>>>>>
96542>>>>>        Else Begin
96543>>>>>            Get private.piSmallImageSize to iImageSize
96544>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
96545>>>>>        End
96545>>>>>>
96545>>>>>
96545>>>>>        Object oHeaderGroupImage is a cRDCDbHeaderGroupImage
96547>>>>>            Set piImageSize to iImageSize
96548>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
96549>>>>>            Set psImage to (private.psImage(Self))
96550>>>>>            Set peImageAlign to Button_ImageList_Align_Center
96551>>>>>            Set psToolTip to (private.psToolTip(Self))
96552>>>>>        End_Object
96553>>>>>
96553>>>>>        Object oHeaderGroupInfo_tb is a TextBox
96555>>>>>            Set Size to 12 100
96556>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
96557>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
96558>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
96559>>>>>            Set FontPointHeight to iFontHeight
96560>>>>>            Set Label to (private.psLabel(Self))
96561>>>>>            Set TextColor to (piLabelColor(Self))
96562>>>>>            Set psToolTip to (private.psToolTip(Self))
96563>>>>>            Get Size to iSize
96564>>>>>        End_Object
96565>>>>>
96565>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
96565>>>>>        // How can it be improved?
96565>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
96566>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
96568>>>>>            Get private.psLabel to sLabel
96569>>>>>            Get Text_Extent sLabel to iTextOffset
96570>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
96571>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
96573>>>>>                Set Size to 10 10
96574>>>>>                If (bUseLargeFontHeight = True) Begin
96576>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
96576>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
96577>>>>>                End
96577>>>>>>
96577>>>>>                Else Begin
96578>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
96578>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
96579>>>>>                End
96579>>>>>>
96579>>>>>                Set psToolTip to (private.psToolTip(Self))
96580>>>>>                Set Bitmap to "ActionAbout.bmp"
96581>>>>>            End_Object
96582>>>>>        End
96582>>>>>>
96582>>>>>
96582>>>>>        Get psNote to sNote
96583>>>>>        If (Trim(sNote) <> "") Begin
96585>>>>>            Object oHeaderGroupNote_tb is a TextBox
96587>>>>>                Set Size to 12 100
96588>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
96589>>>>>                Set Label to ("-" * String(sNote))
96590>>>>>                Set TextColor to (piLabelColor(Self))
96591>>>>>                Set FontPointHeight to 9
96592>>>>>                Set psToolTip to (private.psToolTip(Self))
96593>>>>>            End_Object
96594>>>>>        End
96594>>>>>>
96594>>>>>
96594>>>>>    End_Procedure
96595>>>>>
96595>>>>>    Function Popup_State Returns Boolean
96597>>>>>        Boolean bIsPopup
96597>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
96598>>>>>        Function_Return bIsPopup
96599>>>>>    End_Function
96600>>>>>
96600>>>>>    Procedure OnEnterArea Handle hoFrom
96602>>>>>        Integer iColor
96602>>>>>        Forward Send OnEnterArea hoFrom
96604>>>>>        // Not ideal, but works most of the time.
96604>>>>>        //       When navigating to i.e a popup we don't want
96604>>>>>        //       the coloring to appear. Else there will be 2
96604>>>>>        //       cRDCHeaderGroup's with the highlight color...
96604>>>>>        // Is there a better way?
96604>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
96606>>>>>            Procedure_Return
96607>>>>>        End
96607>>>>>>
96607>>>>>        If (pbUseHotspotColor(Self) = True) Begin
96609>>>>>            Get Color to iColor
96610>>>>>            Set private.piColorOrg to iColor
96611>>>>>            Get piHeaderHotspotColor to iColor
96612>>>>>            Set Color to iColor
96613>>>>>            Broadcast Recursive Set Color to iColor
96615>>>>>        End
96615>>>>>>
96615>>>>>    End_Procedure
96616>>>>>
96616>>>>>    Procedure OnExitArea Handle hoFrom
96618>>>>>        Integer iColor
96618>>>>>        Forward Send OnExitArea hoFrom
96620>>>>>        If (pbUseHotspotColor(Self) = True) Begin
96622>>>>>            Get private.piColorOrg to iColor
96623>>>>>            Set Color to iColor
96624>>>>>            Broadcast Recursive Set Color to iColor
96626>>>>>        End
96626>>>>>>
96626>>>>>    End_Procedure
96627>>>>>
96627>>>>>    // Public access message to change the group header text color at runtime.
96627>>>>>    Procedure Set Label_Color Integer iColor
96629>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
96630>>>>>    End_Procedure
96631>>>>>
96631>>>>>    Procedure NavigatePrevious
96633>>>>>        Integer iMulti ivoid iLastErr
96633>>>>>        Handle hWnd
96633>>>>>        Boolean bErr
96633>>>>>
96633>>>>>        Move Err to bErr
96634>>>>>        Move LastErr to iLastErr
96635>>>>>
96635>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96636>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
96637>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96638>>>>>        If (Err) Begin
96640>>>>>            Move bErr to Err
96641>>>>>            Move iLastErr to LastErr
96642>>>>>            Procedure_Return
96643>>>>>        End
96643>>>>>>
96643>>>>>
96643>>>>>        Move bErr to Err
96644>>>>>        Move iLastErr to LastErr
96645>>>>>        If (iMulti = Multi_Select) Begin
96647>>>>>            Send Previous
96648>>>>>        End
96648>>>>>>
96648>>>>>        Else Begin
96649>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
96650>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
96651>>>>>        End
96651>>>>>>
96651>>>>>    End_Procedure
96652>>>>>
96652>>>>>    Procedure NavigateNext
96654>>>>>        Integer iMulti iVoid iLastErr
96654>>>>>        Handle hWnd
96654>>>>>        Boolean bErr
96654>>>>>
96654>>>>>        Move Err to bErr
96655>>>>>        Move LastErr to iLastErr
96656>>>>>
96656>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96657>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
96658>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96659>>>>>        If (Err) Begin
96661>>>>>            Move bErr to Err
96662>>>>>            Move iLastErr to LastErr
96663>>>>>            Procedure_Return
96664>>>>>        End
96664>>>>>>
96664>>>>>
96664>>>>>        Move bErr to Err
96665>>>>>        Move iLastErr to LastErr
96666>>>>>        If (iMulti = Multi_Select) Begin
96668>>>>>            Send Next
96669>>>>>        End
96669>>>>>>
96669>>>>>        Else Begin
96670>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
96671>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
96672>>>>>        End
96672>>>>>>
96672>>>>>
96672>>>>>    End_Procedure
96673>>>>>
96673>>>>>    Procedure Enable_Window Integer iState
96675>>>>>        Handle hWnd
96675>>>>>        Get Window_Handle to hWnd
96676>>>>>        If hWnd Begin
96678>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
96679>>>>>        End
96679>>>>>>
96679>>>>>    End_Procedure
96680>>>>>
96680>>>>>    Procedure Page_Object Integer iState
96682>>>>>        Handle hWnd
96682>>>>>        Get Window_Handle to hWnd
96683>>>>>        Forward Send Page_Object iState
96685>>>>>        If (hWnd = 0 and iState) Begin
96687>>>>>            Send Shadow_Display
96688>>>>>        End
96688>>>>>>
96688>>>>>    End_Procedure
96689>>>>>
96689>>>>>    Procedure Shadow_Display
96691>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
96692>>>>>    End_Procedure
96693>>>>>
96693>>>>>    Function Explicit_Shadow_State Returns Boolean
96695>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
96696>>>>>    End_Function
96697>>>>>
96697>>>>>    // For some reason we need to augment this event to allow
96697>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
96697>>>>>    // happen.
96697>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
96699>>>>>        Delegate Send OnFileDropped sFilename bLast
96701>>>>>    End_Procedure
96702>>>>>
96702>>>>>End_Class
96703>>>>>
96703>>>>>// We don't want the broadcast of setting color to set the background
96703>>>>>// color for forms that are within a cRDCHeaderGroup object.
96703>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
96703>>>>>// behave as it always has. But if you don't like this; just comment
96703>>>>>// it out.
96703>>>>>//Procedure Set Color for Form Integer eColor
96703>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
96703>>>>>//    Integer iLastErr
96703>>>>>//
96703>>>>>//    Move Err to bErr
96703>>>>>//    Move LastErr to iLastErr
96703>>>>>//
96703>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96703>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
96703>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96703>>>>>//    Move bErr to Err
96703>>>>>//    Move iLastErr to LastErr
96703>>>>>//    If (bIsHeaderGroup = False) Begin
96703>>>>>//        Forward Set Color to eColor
96703>>>>>//    End
96703>>>>>//End_Procedure
96703>>>Use cRDCDbForm.pkg
Including file: cRDCDbForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbForm.pkg)
96703>>>>>Use DFEntry.pkg
96703>>>>>
96703>>>>>Class cRDCDbForm is a dbForm
96704>>>>>
96704>>>>>    Procedure Construct_Object
96706>>>>>        Forward Send Construct_Object
96708>>>>>
96708>>>>>        Set Label_Justification_mode to JMode_Right
96709>>>>>        Set Label_Col_Offset to 2
96710>>>>>        Set Label_Row_Offset to 0
96711>>>>>
96711>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
96712>>>>>        On_Key kCancel Send None
96713>>>>>        On_Key Key_F3  Send None 
96714>>>>>        On_Key Key_Ctrl+Key_F4 Send None
96715>>>>>    End_Procedure
96716>>>>>
96716>>>>>    Procedure End_Construct_Object
96718>>>>>        String sTooltip sStatus_Help
96718>>>>>
96718>>>>>        Forward Send End_Construct_Object
96720>>>>>
96720>>>>>        Get psToolTip   to sTooltip
96721>>>>>        Get Status_Help to sStatus_Help
96722>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96724>>>>>            Set psToolTip to sStatus_Help
96725>>>>>        End
96725>>>>>>
96725>>>>>    End_Procedure
96726>>>>>
96726>>>>>End_Class
96727>>>Use cRDCDbSpinForm.pkg
Including file: cRDCDbSpinForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbSpinForm.pkg)
96727>>>>>//****************************************************************************
96727>>>>>// $Module type: Class
96727>>>>>// $Module name: cRDCDbSpinForm
96727>>>>>// $Author     : Nils Svedmyr, RDC Tools International
96727>>>>>// Created     : 2021-08-24 @ 10:24
96727>>>>>//
96727>>>>>// Description :
96727>>>>>//
96727>>>>>// $Rev History:
96727>>>>>//    2021-08-24  Module header created
96727>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96727>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96727>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96727>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96727>>>>>// in the help folder for more details.
96727>>>>>//
96727>>>>>//****************************************************************************
96727>>>>>Use Windows.pkg
96727>>>>>Use Dfspnent.pkg
96727>>>>>
96727>>>>>Class cDbSpinFormIdleHandler is a cIdleHandler
96728>>>>>    Procedure Construct_Object
96730>>>>>        Forward Send Construct_Object
96732>>>>>
96732>>>>>    End_Procedure
96733>>>>>
96733>>>>>    Procedure OnIdle
96735>>>>>        Delegate Send DoUpdate
96737>>>>>    End_Procedure
96738>>>>>
96738>>>>>End_Class
96739>>>>>
96739>>>>>Class cRDCDbSpinForm is a dbSpinForm
96740>>>>>
96740>>>>>    Procedure Construct_Object
96742>>>>>        Forward Send Construct_Object
96744>>>>>
96744>>>>>        Property Boolean pbAutoEnable False
96745>>>>>
96745>>>>>        Property Boolean pbEnabled True
96746>>>>>
96746>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cDbSpinFormIdleHandler)))
96747>>>>>
96747>>>>>        Set Label_Justification_mode to JMode_Right
96748>>>>>        Set Label_Col_Offset to 2
96749>>>>>        Set Label_Row_Offset to 0
96750>>>>>    End_Procedure
96751>>>>>
96751>>>>>    Procedure End_Construct_Object
96753>>>>>        String sTooltip sStatus_Help
96753>>>>>
96753>>>>>        Forward Send End_Construct_Object
96755>>>>>
96755>>>>>        Get psToolTip   to sTooltip
96756>>>>>        Get Status_Help to sStatus_Help
96757>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96759>>>>>            Set psToolTip to sStatus_Help
96760>>>>>        End
96760>>>>>>
96760>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96761>>>>>    End_Procedure
96762>>>>>
96762>>>>>    Procedure DoUpdate
96764>>>>>        If (pbAutoEnable(Self) = False) Begin
96766>>>>>            Procedure_Return
96767>>>>>        End
96767>>>>>>
96767>>>>>        Set Enabled_State to (IsEnabled(Self))
96768>>>>>    End_Procedure
96769>>>>>
96769>>>>>    Function IsEnabled Returns Boolean
96771>>>>>        Boolean bEnabled
96771>>>>>        Get pbEnabled to bEnabled
96772>>>>>        Function_Return bEnabled
96773>>>>>    End_Function
96774>>>>>
96774>>>>>    // Enable the idle handler timer when the object is activated
96774>>>>>    Procedure Activating
96776>>>>>        Forward Send Activating
96778>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96779>>>>>    End_Procedure
96780>>>>>
96780>>>>>    // Disable the idle handler when the object is deactivated
96780>>>>>    Procedure Deactivating
96782>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96783>>>>>        Forward Send Deactivating
96785>>>>>    End_Procedure
96786>>>>>
96786>>>>>    // For some reason spinforms doesn't change the background color
96786>>>>>    // when disabled - only the frame around it changes to "none".
96786>>>>>    // This makes it hard to see that the object is unavailable.
96786>>>>>    // This augmentation changes the background color to "gray",
96786>>>>>    // when disabled.
96786>>>>>    //    Procedure Set Enabled_State Integer bState
96786>>>>>    //        Forward Set Enabled_State to bState
96786>>>>>    //        If (bState = False) Begin
96786>>>>>    //            Set Color to clBtnFace
96786>>>>>    //        End
96786>>>>>    //        Else Begin
96786>>>>>    //            Set Color to clWindow
96786>>>>>    //        End
96786>>>>>    //    End_Procedure
96786>>>>>
96786>>>>>End_Class  
96787>>>Use cRDCButton.pkg
96787>>>Use StatusLog.dg
Including file: StatusLog.dg    (C:\Projects\DF18\DfRefactor\AppSrc\StatusLog.dg)
96787>>>>>Use cRDCDbModalPanel.pkg
Including file: cRDCDbModalPanel.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbModalPanel.pkg)
96787>>>>>>>Use Dfclient.pkg
96787>>>>>>>Use cCJCommandBarSystem.pkg
96787>>>>>>>
96787>>>>>>>Class cRDCDbModalPanel is a dbModalPanel
96788>>>>>>>
96788>>>>>>>    Procedure Construct_Object
96790>>>>>>>        Forward Send Construct_Object
96792>>>>>>>
96792>>>>>>>        Set Border_Style to Border_Thick
96793>>>>>>>        Set Locate_Mode to Center_On_Parent
96794>>>>>>>        Set Minimize_Icon to False
96795>>>>>>>
96795>>>>>>>        Property String Private_Icon
96796>>>>>>>        Property Handle phoDialogCommandbar
96797>>>>>>>        Property Handle phoModalPanelHandle (Self)
96798>>>>>>>
96798>>>>>>>        On_Key kCancel Send Close_Panel
96799>>>>>>>    End_Procedure
96800>>>>>>>
96800>>>>>>>    Procedure Set Icon String sIcon
96802>>>>>>>        Forward Set Icon to sIcon
96804>>>>>>>        Set Private_Icon to sIcon
96805>>>>>>>    End_Procedure
96806>>>>>>>
96806>>>>>>>    Function Icon Returns String
96808>>>>>>>        String sIcon
96808>>>>>>>        Get Private_Icon to sIcon
96809>>>>>>>        Function_Return sIcon
96810>>>>>>>    End_Function
96811>>>>>>>
96811>>>>>>>    // Due to a bug in VDF we need to set the
96811>>>>>>>    // panel icon here.
96811>>>>>>>    Procedure Page Integer iPageObject
96813>>>>>>>        String sIcon
96813>>>>>>>
96813>>>>>>>        Get Private_Icon to sIcon
96814>>>>>>>        If (sIcon <> "") Begin
96816>>>>>>>            Set Icon to sIcon
96817>>>>>>>        End
96817>>>>>>>>
96817>>>>>>>
96817>>>>>>>        //        Get Window_Handle to hWnd
96817>>>>>>>        //
96817>>>>>>>        //        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96817>>>>>>>        //            Send ComRemoveWindow to ghoSkinFramework hWnd
96817>>>>>>>        //            Send ComApplyWindow  to ghoSkinFramework hWnd
96817>>>>>>>        //        End
96817>>>>>>>        Forward Send Page iPageObject
96819>>>>>>>    End_Procedure
96820>>>>>>>
96820>>>>>>>    // Put a status bar at the bottom of the panel, which makes
96820>>>>>>>    // status_help work and puts a gripper in the lower right corner.
96820>>>>>>>    Procedure End_Construct_Object
96822>>>>>>>        Integer iStyle iSize iOffset
96822>>>>>>>
96822>>>>>>>        Forward Send End_Construct_Object
96824>>>>>>>
96824>>>>>>>        Get Border_Style to iStyle
96825>>>>>>>        Move 8 to iOffset
96826>>>>>>>        If (iStyle = Border_Thick) Begin
96828>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96830>>>>>>>                Object oStatusBar is a cCJStatusBar
96832>>>>>>>                    Set phoDialogCommandbar to Self
96833>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96835>>>>>>>                        Set piId to sbpIDIdlePane
96836>>>>>>>                        Set pbStyleStretch to True
96837>>>>>>>                    End_Object
96838>>>>>>>                End_Object
96839>>>>>>>            End_Object
96840>>>>>>>            Get Size to iSize
96841>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96842>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96843>>>>>>>        End
96843>>>>>>>>
96843>>>>>>>
96843>>>>>>>    End_Procedure
96844>>>>>>>
96844>>>>>>>    Procedure Popup
96846>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96847>>>>>>>        Forward Send Popup
96849>>>>>>>    End_Procedure
96850>>>>>>>
96850>>>>>>>End_Class
96851>>>>>Use cStatLogDataDictionary.dd
Including file: cStatLogDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cStatLogDataDictionary.dd)
96851>>>>>>>Use DataDict.pkg
96851>>>>>>>
96851>>>>>>>Open StatLog
96853>>>>>>>
96853>>>>>>>Class cStatLogDataDictionary is a DataDictionary
96854>>>>>>>    
96854>>>>>>>    Procedure Construct_Object
96856>>>>>>>        Forward Send Construct_Object
96858>>>>>>>        Set Main_File to StatLog.File_Number
96859>>>>>>>
96859>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
96860>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
96861>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
96862>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
96863>>>>>>>
96863>>>>>>>    End_Procedure
96864>>>>>>>
96864>>>>>>>End_Class
96865>>>>>Use cRDCDbCJGrid.pkg
96865>>>>>Use cdbCJGridColumn.pkg
96865>>>>>
96865>>>>>Object oStatusLog_dg is a cRDCDbModalPanel
96867>>>>>    Set Label to "Error Log"
96868>>>>>    Set Size to 247 560
96869>>>>>    Set piMinSize to 89 211
96870>>>>>    Set Location to 2 2
96871>>>>>    Set Border_Style to Border_Thick
96872>>>>>    Set Icon to "ErrorLog.ico"
96873>>>>>
96873>>>>>    Object oStatLog_DD is a cStatLogDataDictionary
96875>>>>>    End_Object
96876>>>>>
96876>>>>>    Set Main_DD to oStatLog_DD
96877>>>>>    Set Server to oStatLog_DD
96878>>>>>
96878>>>>>    Object oClose_btn is a Button
96880>>>>>        Set Size to 14 50
96881>>>>>        Set Label    to "&Close"
96882>>>>>        Set Location to 226 502
96883>>>>>        Set peAnchors to anBottomRight
96884>>>>>
96884>>>>>        Procedure OnClick
96887>>>>>           Send Close_Panel
96888>>>>>        End_Procedure
96889>>>>>
96889>>>>>    End_Object
96890>>>>>
96890>>>>>    Object oInternalErrors_grd is a cRDCDbCJGrid
96892>>>>>        Set Size to 205 542
96893>>>>>        Set Location to 11 9
96894>>>>>        Set peAnchors to anAll
96895>>>>>        Set pbUseAlternateRowBackgroundColor to True
96896>>>>>        Set peVisualTheme to xtpReportThemeExplorer
96897>>>>>        Set pbAllowEdit to False
96898>>>>>        Set pbAllowInsertRow to False
96899>>>>>        Set pbAutoAppend to False
96900>>>>>        Set pbAutoSave to False
96901>>>>>        Set pbHeaderReorders to True
96902>>>>>        Set pbHeaderTogglesDirection to True
96903>>>>>        Set pbReadOnly to True
96904>>>>>        Set pbRestoreLayout to True
96905>>>>>        Set pbStaticData to True
96906>>>>>
96906>>>>>        Object oStatLog_FunctionName is a cDbCJGridColumn
96908>>>>>            Entry_Item StatLog.FunctionName
96909>>>>>            Set piWidth to 262
96910>>>>>            Set psCaption to "FunctionName"
96911>>>>>        End_Object
96912>>>>>
96912>>>>>        Object oStatLog_Description is a cDbCJGridColumn
96914>>>>>            Entry_Item StatLog.Description
96915>>>>>            Set piWidth to 436
96916>>>>>            Set psCaption to "Description"
96917>>>>>        End_Object
96918>>>>>
96918>>>>>        Object oStatLog_Date is a cDbCJGridColumn
96920>>>>>            Entry_Item StatLog.Date
96921>>>>>            Set piWidth to 83
96922>>>>>            Set psCaption to "Date"  
96923>>>>>            Set pbVisible to False
96924>>>>>        End_Object
96925>>>>>
96925>>>>>        Object oStatLog_Time is a cDbCJGridColumn
96927>>>>>            Entry_Item StatLog.Time
96928>>>>>            Set piWidth to 123
96929>>>>>            Set psCaption to "Time"
96930>>>>>        End_Object
96931>>>>>    End_Object
96932>>>>>
96932>>>>>    Object oZeroFile_btn is a Button
96934>>>>>        Set Size to 14 68
96935>>>>>        Set Label to "Delete All Records"
96936>>>>>        Set Location to 226 408
96937>>>>>        Set peAnchors to anBottomRight
96938>>>>>
96938>>>>>        Procedure OnClick
96941>>>>>            Integer eResponse
96941>>>>>            Get YesNo_Box "Are you sure you want to delete all logged error messages?" to eResponse
96942>>>>>            If (eResponse <> MBR_Yes) Begin
96944>>>>>                Procedure_Return
96945>>>>>            End
96945>>>>>>
96945>>>>>            ZeroFile StatLog  
96946>>>>>            Send MoveToFirstRow of oInternalErrors_grd
96947>>>>>        End_Procedure
96948>>>>>
96948>>>>>    End_Object
96949>>>>>
96949>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oClose_btn
96950>>>>>End_Object
96951>>>
96951>>>Use cFunctionsDataDictionary.dd
96951>>>Use cSysFileDataDictionary.dd
96951>>>Use cdbCJGridColumn.pkg
96951>>>Use Windows.pkg
96951>>>
96951>>>Enum_List
96951>>>    Integer Ico_Folders
96951>>>    Integer Ico_Functions
96951>>>End_Enum_List
96951>>>
96951>>>Object oImageList is a cImageList32
96953>>>    Set piMaxImages to 2
96954>>>    Set piImageHeight to 24
96955>>>    Set piImageWidth to 24
96956>>>    Procedure OnCreate
96959>>>        Get AddImage "Folder.ico"          to Ico_Folders
96960>>>        Get AddImage "FunctionLibrary.ico" to Ico_Functions
96961>>>    End_Procedure
96962>>>End_Object
96963>>>
96963>>>Activate_View Activate_oRefactorView for oRefactorView
96973>>>>
96973>>>Object oRefactorView is a cRefactorDbView
96975>>>    Set Location to 1 0
96976>>>    Set Size to 311 578
96977>>>    Set Label to "Refactoring Selections"
96978>>>    Set Icon to "DFRefactor.ico"
96979>>>    Set pbAcceptDropFiles to True
96980>>>    Set Auto_Clear_DEO_State to False  
96981>>>    Set Auto_Top_Panel_State to False
96982>>>
96982>>>    Set phoRefactorView of ghoApplication to Self
96983>>>
96983>>>    Object oSysFile_DD is a cSysFileDataDictionary
96985>>>    End_Object
96986>>>
96986>>>    Object oFunctions_DD is a cFunctionsDataDictionary  
96988>>>        
96988>>>        Procedure Request_Save
96991>>>            Send Request_Save of oSysFile_DD
96992>>>            Forward Send Request_Save
96994>>>        End_Procedure
96995>>>        
96995>>>        Procedure OnConstrain
96998>>>            If (piFunctionType(Self) <> eAll_Functions) Begin
97000>>>                Constrain Functions.Type eq (piFunctionType(Self))
97002>>>            End
97002>>>>
97002>>>        End_Procedure
97003>>>    End_Object
97004>>>
97004>>>    Procedure Request_Save
97007>>>        Send Request_Save of oFunctions_DD
97008>>>    End_Procedure
97009>>>    
97009>>>    Set Main_DD to oFunctions_DD
97010>>>    Set Server to oFunctions_DD
97011>>>                                    
97011>>>    // *** BPO Object ***
Including file: oBPO.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\oBPO.pkg)
97011>>>>Use Batchdd.pkg
97011>>>>Use cRefactorFunctionLibrary.pkg
97011>>>>Use cSysFileDataDictionary.dd
97011>>>>Use cFunctionsDataDictionary.dd
97011>>>> 
97011>>>>Object oBPO is a BusinessProcess
97013>>>>    Set Allow_Cancel_State to True 
97014>>>>    Set Status_Panel_State to True
97015>>>>    Set Status_Log_State to True
97016>>>>    Set Display_Error_State to False
97017>>>>
97017>>>>    Delegate Set phoBPO to Self
97019>>>>
97019>>>>    Procedure OnProcess
97022>>>>        String  sFolderName sFileName
97022>>>>        Boolean bOk bExists bStop bWriteLine bWorkspaceMode bIsStudioGenerated
97022>>>>        String[] asFolderNames
97023>>>>        String sFileFilter sPath sFullFileName sFunctionName sParameter
97023>>>>        Integer iCount iSourceFiles iItems iNoOfLines iTotNoOfLines iTotNoOfFiles iRetval iFunctionID
97023>>>>        Handle hoReportUnusedSource
97023>>>>        tRefactorSettings RefactorSettings
97023>>>>        tRefactorSettings RefactorSettings
97023>>>>        tsSearchResult[] asSelectedSourceFiles
97023>>>>        tsSearchResult[] asSelectedSourceFiles
97024>>>>
97024>>>>        Move True to bOk
97025>>>>        Move True to bWriteLine
97026>>>>        Move 0 to iTotNoOfFiles
97027>>>>        Move 0 to iTotNoOfLines
97028>>>>        Move 0 to iCount
97029>>>>        Get pRefactorSettings of ghoRefactorFunctionLibrary to RefactorSettings
97030>>>>        Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
97031>>>>
97031>>>>        // Workspace:
97031>>>>        If (bWorkspaceMode = True) Begin
97033>>>>            Move RefactorSettings.asFolderNames  to asFolderNames
97034>>>>            Move RefactorSettings.sFileFilter    to sFileFilter    
97035>>>>            // Get all selected files to a common string array.
97035>>>>            Get AllSourceFiles of ghoApplication asFolderNames sFileFilter to asSelectedSourceFiles
97036>>>>        End
97036>>>>>
97036>>>>        // Single file:
97036>>>>        Else Begin 
97037>>>>            Get psCurrentSourceFileName of ghoApplication to sFullFileName
97038>>>>            Get ParseFolderName sFullFileName to sFolderName   
97039>>>>            Get ParseFileName   sFullFileName to sFileName
97040>>>>//            Get ApplyRefactorFunctions sFullFileName to sFileName
97040>>>>            Move sFolderName to asSelectedSourceFiles[0].sAlternateFileName
97041>>>>            Move sFileName   to asSelectedSourceFiles[0].sFilename
97042>>>>        End
97042>>>>>
97042>>>>
97042>>>>        Move (SizeOfArray(asSelectedSourceFiles)) to iSourceFiles
97043>>>>        Decrement iSourceFiles   
97044>>>>        
97044>>>>        // If any 'line-by-iine' or 'full source file' functions was selected:
97044>>>>        If (RefactorSettings.bCountSourceLines = True or RefactorSettings.iSelectedLineByLineFunctions <> 0 or RefactorSettings.iSelectedFullFileFunctions <> 0) Begin
97046>>>>
97046>>>>            // Loop through all selected files:
97046>>>>            For iCount from 0 to iSourceFiles
97052>>>>>
97052>>>>                Move asSelectedSourceFiles[iCount].sAlternateFileName to sFolderName
97053>>>>                Move asSelectedSourceFiles[iCount].sFilename          to sFileName
97054>>>>
97054>>>>                // We do _not_ refactor files generated by the Studio for COM components (.ocx files et al)
97054>>>>                Get IsDataFlexCOMProxyClassesFile of ghoRefactorFunctionLibrary (sFolderName + String(sFileName)) to bIsStudioGenerated
97055>>>>                If (bIsStudioGenerated = False) Begin
97057>>>>                    Set Caption_text of ghoStatusPanel to "Refactoring Source Code"
97058>>>>                    Set Title_Text of ghoStatusPanel to ("Folder:" * String(sFolderName))
97059>>>>                    Set Message_Text of ghoStatusPanel to ("File:" * String(sFileName))
97060>>>>                    Send Update_status ("File No:" * String(iCount + 1) * "of:" * String(iSourceFiles + 1))
97061>>>>                    Get vFolderFormat sFolderName to sFolderName
97062>>>>
97062>>>>                    // *** Count source lines ***
97062>>>>                    If (RefactorSettings.bCountSourceLines = True) Begin
97064>>>>                        Get CountNumberOfLines of ghoRefactorFunctionLibrary (sFolderName + sFileName) to iNoOfLines
97065>>>>                        Add iNoOfLines to iTotNoOfLines   
97066>>>>                        Add 1          to iTotNoOfFiles
97067>>>>                    End                 
97067>>>>>
97067>>>>                    // *** Process one file with selected functions ***
97067>>>>                    Else Begin
97068>>>>                        Get ProcessFile (String(sFolderName) + String(sFileName)) to bOK
97069>>>>                    End
97069>>>>>
97069>>>>                End
97069>>>>>
97069>>>>
97069>>>>                // We only check for "Cancel" once every new file.
97069>>>>                Get Cancel_Check to bStop
97070>>>>                If (bStop = True) Begin  
97072>>>>                    Procedure_Return
97073>>>>                End
97073>>>>>
97073>>>>            Loop
97074>>>>>
97074>>>>
97074>>>>            If (RefactorSettings.bCountSourceLines = True) Begin   
97076>>>>                Reread SysFile
97080>>>>                    Move iTotNoOfLines to SysFile.iCountNumberOfLines 
97081>>>>                    Move iTotNoOfFiles to SysFile.iCountNumberOfFiles
97082>>>>                    SaveRecord SysFile
97083>>>>                Unlock
97084>>>>>
97084>>>>            End
97084>>>>>
97084>>>>        End 
97084>>>>>
97084>>>>        
97084>>>>        // *** All Selected Source File Functions *** 
97084>>>>        //
97084>>>>        // For these functions All selected source files are passed as a String array (with full path).
97084>>>>        // Note: These will be called _after_ files has been changed by the Scintilla editor (if selected).
97084>>>>        Else If (RefactorSettings.iSelectedAllFilesFunctions <> 0) Begin
97087>>>>            
97087>>>>            // *** Other Functions - All source files ***
97087>>>>            If (RefactorSettings.iSelectedOtherAllFunctions > 0) Begin                
97089>>>>                Constraint_Set (Self + 20) Clear  
97091>>>>                Constrained_Clear eq FunctionsA by Index.4
97094>>>>                Constrain FunctionsA.Selected eq True
97096>>>>                Constrain FunctionsA.Type eq eOther_FunctionAll
97098>>>>                Constrained_Find First FunctionsA by Index.4
97103>>>>                While (Found)
97107>>>>                    Move (Trim(FunctionsA.Parameter)) to sParameter
97108>>>>                    Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97109>>>>                    Move (Eval("get_" - (sFunctionName))) to iFunctionID
97110>>>>                    // Data send as ByRef to have a consistent calling convention for all refactoring functions:
97110>>>>                    Get iFunctionID of ghoRefactorFunctionLibrary (&asSelectedSourceFiles) sParameter to iRetval
97111>>>>                    If (iRetval <> 0) Begin
97113>>>>                        Reread FunctionsA
97117>>>>                            Add iRetval to FunctionsA.Count
97118>>>>                            SaveRecord FunctionsA
97119>>>>                        Unlock
97120>>>>>
97120>>>>                    End
97120>>>>>
97120>>>>                    Constrained_Find Next
97121>>>>                Loop
97122>>>>>
97122>>>>            End
97122>>>>>
97122>>>>            
97122>>>>            // *** Report Functions - All source files ***      (Makes _no_ source code changes)
97122>>>>            If (RefactorSettings.iSelectedReportAllFunctions > 0) Begin                
97124>>>>                Constraint_Set (Self + 21) Clear  
97126>>>>                Constrained_Clear eq FunctionsA by Index.4
97129>>>>                Constrain FunctionsA.Selected eq True
97131>>>>                Constrain FunctionsA.Type eq eReport_FunctionAll
97133>>>>                Constrained_Find First FunctionsA by Index.4
97138>>>>                While (Found)
97142>>>>                    Move (Trim(FunctionsA.Parameter)) to sParameter
97143>>>>                    Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97144>>>>                    Move (Eval("get_" - (sFunctionName))) to iFunctionID
97145>>>>                    // Data send as ByRef to have a consistent calling convention for all refactoring functions:
97145>>>>                    Get iFunctionID of ghoRefactorFunctionLibrary (&asSelectedSourceFiles) sParameter to iRetval
97146>>>>                    If (iRetval <> 0) Begin
97148>>>>                        Reread FunctionsA
97152>>>>                            Add iRetval to FunctionsA.Count
97153>>>>                            SaveRecord FunctionsA
97154>>>>                        Unlock
97155>>>>>
97155>>>>                    End
97155>>>>>
97155>>>>                    Constrained_Find Next
97156>>>>                Loop
97157>>>>>
97157>>>>            End
97157>>>>>
97157>>>>        
97157>>>>        End
97157>>>>>
97157>>>>
97157>>>>//        If (SysFile.bRemoveUnusedLocals = True) Begin
97157>>>>//            Get RemoveUnusedLocals of ghoRefactorFunctionLibrary (sFolderName + sFileName) to iRetval
97157>>>>//            Reread SysFile
97157>>>>//                Add iRetval to SysFile.iCountUnusedLocals
97157>>>>//                SaveRecord SysFile
97157>>>>//            Unlock
97157>>>>//        End
97157>>>>        
97157>>>>    End_Procedure
97158>>>>
97158>>>>    // Processes the file passed (with path) and performs the actions that have been chosen on it.
97158>>>>    // This function will always create a backup file and then call ApplyRefactorFunctions
97158>>>>    // for the actual work.
97158>>>>    Function ProcessFile String sFileName Returns Boolean
97161>>>>        Boolean bSuccess bSaveBak bChanged bExists 
97161>>>>        String sBackupFile
97161>>>>        Integer iRetval
97161>>>>        
97161>>>>        File_Exist sFileName bExists
97162>>>>        If (bExists = False) Begin
97164>>>>            Send UserError ("File doesn't exist." * String(sFileName) * String("ProcessFile in oBPO"))
97165>>>>            Function_Return False
97166>>>>        End
97166>>>>>
97166>>>>        Move True to bSuccess
97167>>>>        Get SaveBackupFile of ghoApplication sFileName to bSuccess
97168>>>>        If (bSuccess = False) Begin
97170>>>>            Send Info_Box ("The file could not be copied to the backup area and no attempt was made to change it.\n" * String(sFileName))
97171>>>>            Function_Return False
97172>>>>        End
97172>>>>>
97172>>>>        
97172>>>>        Send UpdateStatusBar sFileName True
97173>>>>        Send ResetProjectObjectStructureProperties of ghoRefactorFunctionLibrary
97174>>>>        
97174>>>>        // *** Make changes to source ***
97174>>>>        Get ApplyRefactorFunctions sFileName to bSuccess
97175>>>>        
97175>>>>        Send IncrementFileCount bSuccess
97176>>>>        // ** If the process failed we move tha backup copy back to its  original location **
97176>>>>        If (bSuccess = False) Begin
97178>>>>            Get BackupFileName of ghoApplication sFileName to sBackupFile  
97179>>>>            File_Exist sBackupFile bExists
97180>>>>            If (bExists = True) Begin
97182>>>>                Get vMoveFile sBackupFile sFileName to iRetval
97183>>>>                If (iRetval <> 0) Begin
97185>>>>                    Showln "Error moving file: " sBackupFile
97188>>>>                End
97188>>>>>
97188>>>>            End
97188>>>>>
97188>>>>        End
97188>>>>>
97188>>>>
97188>>>>        Function_Return bSuccess
97189>>>>    End_Function
97190>>>>
97190>>>>    // Here all functions are applied on the source 
97190>>>>    // _except_ for eOther_FunctionAll & eReport_FunctionAll Function types, which are called from the OnProcess event.
97190>>>>    Function ApplyRefactorFunctions String sSourceFile Returns Boolean
97193>>>>        Boolean bParseOK bChanged bWriteOK bWebAppFile bFound bWorkSpaceMode
97193>>>>        Boolean bEditorFunctions bSaved bIsSame bWriteLine bChangesMade
97193>>>>        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd bRegisterAllObjectsStart bRegisterAllObjectsEnd 
97193>>>>        Integer iLine iRetval iSize iFunctionID
97193>>>>        String  sLine sBasePath sFileNameOnly sExtension sFunctionName sParameter
97193>>>>        Handle hoEditor
97193>>>>        String[] asSourceFile asOrgSourceFile asObjectNames
97196>>>>        tRefactorSettings RefactorSettings
97196>>>>        tRefactorSettings RefactorSettings
97196>>>>
97196>>>>        Move False to Err
97197>>>>        Move False to bChangesMade
97198>>>>        Move False to bParseOK
97199>>>>        Move False to bProjectObjectStructureStart
97200>>>>        Move False to bProjectObjectStructureEnd
97201>>>>        Move False to bRegisterAllObjectsStart
97202>>>>        Move False to bRegisterAllObjectsEnd      
97203>>>>        Get phoEditor of ghoApplication to hoEditor
97204>>>>        Get pbWorkspaceMode of ghoApplication to bWorkSpaceMode
97205>>>>        
97205>>>>        Get pRefactorSettings of ghoRefactorFunctionLibrary to RefactorSettings
97206>>>>        Get ParseFileName      sSourceFile to sFileNameOnly
97207>>>>        Get ParseFileExtension sSourceFile to sExtension
97208>>>>        Move (".wo;.html;.asp;.css;.js" contains lowercase(sExtension)) to bWebAppFile
97209>>>>
97209>>>>        Get ReadSourceFileToArray sSourceFile to asSourceFile
97210>>>>        // We will make changes to asSourceFile, and keep asOrgSourceFile as a reference to check if anything has changed.
97210>>>>        Move asSourceFile to asOrgSourceFile
97211>>>>        Move (SizeOfArray(asSourceFile)) to iSize
97212>>>>        Set Message_Text of ghoStatusPanel to ("Parsing:" * String(sFileNameOnly) * "Lines:" * String(iSize))
97213>>>>        Decrement iSize
97214>>>>        
97214>>>>        // ***Count source lines: ***
97214>>>>        If (RefactorSettings.bCountSourceLines = True) Begin
97216>>>>            Get CountNumberOfLines sSourceFile to iRetval
97217>>>>            Reread SysFile
97221>>>>                Move iRetval to SysFile.iCountNumberOfLines
97222>>>>                SaveRecord SysFile
97223>>>>            Unlock
97224>>>>>
97224>>>>            Function_Return (Err = False) // We are done!
97225>>>>        End
97225>>>>>
97225>>>>    
97225>>>>        // *** Line-by-line functions: ***
97225>>>>        Else If (RefactorSettings.iSelectedLineByLineFunctions) Begin
97228>>>>
97228>>>>            For iLine from 0 to iSize
97234>>>>>
97234>>>>                Send UpdateStatusBar ("Refactoring line:" * String(iLine) * "of:" * String(iSize + 1)) True
97235>>>>                Set Action_Text of ghoStatusPanel  to ("Refactoring line:" * String(iLine) * "of:" * String(iSize + 1))
97236>>>>    
97236>>>>                // Read a line from the source file's string array.
97236>>>>                // This is the same string that potentially gets changed by several
97236>>>>                // refactoring functions, as it will be passed as ByRef.
97236>>>>                Move asSourceFile[iLine] to sLine
97237>>>>                // If at least one of these functions sets bWriteLine to false,
97237>>>>                // the read source line will _not_ be written back to disk.
97237>>>>                Move True to bWriteLine
97238>>>>                
97238>>>>                // eRemove_Function   
97238>>>>                If (RefactorSettings.iSelectedRemoveFunctions > 0) Begin
97240>>>>                    Constraint_Set (Self) Clear
97242>>>>                    Constrained_Clear eq FunctionsA by Index.4  
97245>>>>                    Constrain FunctionsA.Selected eq True
97247>>>>                    Constrain FunctionsA.Type eq eRemove_Function
97249>>>>                    Constrained_Find First FunctionsA by Index.4
97254>>>>                    While (Found = True)    
97258>>>>                        Move (Trim(FunctionsA.Parameter)) to sParameter
97259>>>>                        Move (Trim(FunctionsA.Function_Name)) to sFunctionName
97260>>>>                        Move (Eval("get_" - (sFunctionName))) to iFunctionID
97261>>>>                        Get iFunctionID of ghoRefactorFunctionLibrary (&sLine) sParameter to bChanged
97262>>>>                        If (bChanged = True) Begin
97264>>>>                            Move False to bWriteLine     
97265>>>>                            Reread FunctionsA
97269>>>>                                Add 1 to FunctionsA.Count
97270>>>>                                SaveRecord FunctionsA
97271>>>>                                Move True to bChangesMade
97272>>>>                            Unlock
97273>>>>>
97273>>>>                        End
97273>>>>>
97273>>>>                        Constrained_Find Next            
97274>>>>                    Loop
97275>>>>>
97275>>>>                End
97275>>>>>
97275>>>>    
97275>>>>                If (bWriteLine = True) Begin
97277>>>>    
97277>>>>                    // eStandard_Function   
97277>>>>                    If (RefactorSettings.iSelectedStandardFunctions > 0) Begin
97279>>>>                        Constraint_Set (Self + 1) Clear
97281>>>>                        Constrained_Clear eq FunctionsA by Index.4  
97284>>>>                        Constrain FunctionsA.Selected eq True
97286>>>>                        Constrain FunctionsA.Type eq eStandard_Function        
97288>>>>                        Constrained_Find First FunctionsA by Index.4
97293>>>>                        While (Found = True)    
97297>>>>                            Move (Trim(FunctionsA.Parameter)) to sParameter
97298>>>>                            Move (Trim(FunctionsA.Function_Name)) to sFunctionName
97299>>>>                            Move (Eval("get_" - (sFunctionName))) to iFunctionID
97300>>>>                            Get iFunctionID of ghoRefactorFunctionLibrary (&sLine) sParameter to bChanged
97301>>>>                            If (bChanged = True) Begin
97303>>>>                                Reread FunctionsA
97307>>>>                                    Add 1 to FunctionsA.Count
97308>>>>                                    SaveRecord FunctionsA
97309>>>>                                    Move True to bChangesMade
97310>>>>                                Unlock
97311>>>>>
97311>>>>                            End
97311>>>>>
97311>>>>                            Constrained_Find Next            
97312>>>>                        Loop
97313>>>>>
97313>>>>                        
97313>>>>                        // NOTE: Here the changed line is "saved" back to the array.
97313>>>>                        If (bWriteLine = True) Begin
97315>>>>                            Move sLine to asSourceFile[iLine]
97316>>>>                        End
97316>>>>>
97316>>>>                    End
97316>>>>>
97316>>>>                End
97316>>>>>
97316>>>>            
97316>>>>            Loop
97317>>>>>
97317>>>>        End                        
97317>>>>>
97317>>>>        
97317>>>>        // *** Other Functions - One source file as a string array is passed ***  
97317>>>>        If (RefactorSettings.iSelectedOtherFunctions <> 0) Begin
97319>>>>            Constraint_Set (Self + 2) Clear  
97321>>>>            Constrained_Clear eq FunctionsA by Index.4
97324>>>>            Constrain FunctionsA.Selected eq True
97326>>>>            Constrain FunctionsA.Type eq eOther_Function
97328>>>>            Constrained_Find First FunctionsA by Index.4
97333>>>>            While (Found = True)    
97337>>>>                Move (Trim(FunctionsA.Parameter)) to sParameter
97338>>>>                Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97339>>>>                Move (Eval("get_" - (sFunctionName))) to iFunctionID
97340>>>>                // Data send as ByRef to have a consistent calling convention for all refactoring functions:
97340>>>>                Get iFunctionID of ghoRefactorFunctionLibrary (&asSourceFile) sParameter to iRetval
97341>>>>                If (iRetval <> 0) Begin
97343>>>>                    Reread FunctionsA
97347>>>>                        Add iRetval to FunctionsA.Count
97348>>>>                        SaveRecord FunctionsA
97349>>>>                        Move True to bChangesMade
97350>>>>                    Unlock
97351>>>>>
97351>>>>                End
97351>>>>>
97351>>>>                Constrained_Find Next
97352>>>>            Loop
97353>>>>>
97353>>>>        End
97353>>>>>
97353>>>>        // Note: eOther_FunctionAll function types are called from the OnProcess event, after "ApplyRefactorFunctions" has been called.
97353>>>>        
97353>>>>        // *** Editor Functions ***
97353>>>>        If (RefactorSettings.iSelectedEditorFunctions <> 0) Begin
97355>>>>            // This will load the file in the editor and display the file in the toolbar.
97355>>>>            Send UpdateSourceFileNameDisplay of ghoApplication sSourceFile
97356>>>>            // Change source file in editor.
97356>>>>            Get RefactorSourceFileInEditor of hoEditor (&asSourceFile) to bChanged
97357>>>>        End
97357>>>>>
97357>>>>        
97357>>>>        // *** Report Functions - One source file ***      (Makes _no_ source code changes) 
97357>>>>        If (RefactorSettings.iSelectedReportFunctions > 0) Begin            
97359>>>>            Constraint_Set (Self + 4) Clear  
97361>>>>            Constrained_Clear eq FunctionsA by Index.4
97364>>>>            Constrain FunctionsA.Selected eq True
97366>>>>            Constrain FunctionsA.Type eq eReport_Function
97368>>>>            Constrained_Find First FunctionsA by Index.4
97373>>>>            While (Found = True)    
97377>>>>                Move (Trim(FunctionsA.Parameter)) to sParameter
97378>>>>                Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97379>>>>                Move (Eval("get_" - (sFunctionName))) to iFunctionID
97380>>>>                // Data send as ByRef to have a consistent calling convention for all refactoring functions:
97380>>>>                Get iFunctionID of ghoRefactorFunctionLibrary (&asSourceFile) sParameter to iRetval
97381>>>>                If (iRetval <> 0) Begin
97383>>>>                    Reread FunctionsA
97387>>>>                        Add iRetval to FunctionsA.Count
97388>>>>                        SaveRecord FunctionsA
97389>>>>                        Move True to bChangesMade
97390>>>>                    Unlock
97391>>>>>
97391>>>>                End
97391>>>>>
97391>>>>                Constrained_Find Next
97392>>>>            Loop
97393>>>>>
97393>>>>        End
97393>>>>>
97393>>>>        
97393>>>>        // If source code changes was made, we should save them to the source file.
97393>>>>        Move (IsSameArray(asSourceFile, asOrgSourceFile)) to bIsSame
97394>>>>        If (bIsSame = False) Begin
97396>>>>            Get WriteArrayToSourceFile sSourceFile asSourceFile to bWriteOK
97397>>>>            If (bWriteOK = False) Begin
97399>>>>                Function_Return False
97400>>>>            End
97400>>>>>
97400>>>>            Send WaitForFileToGetWritten sSourceFile
97401>>>>        End
97401>>>>>
97401>>>>
97401>>>>        Function_Return (Err = False)
97402>>>>    End_Function
97403>>>>
97403>>>>    Procedure Update_Status String sProgress
97406>>>>        String  sPath
97406>>>>        Boolean bWorkspaceMode
97406>>>>
97406>>>>        Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
97407>>>>        If (bWorkspaceMode = True) Begin
97409>>>>            Get psHomePath of ghoApplication to sPath
97410>>>>            If (sPath <> "") Begin
97412>>>>                // Strip out the path, so we can see the filename without it being cut off.
97412>>>>                Move (Replace(sPath, sProgress, "..")) to sProgress
97413>>>>            End
97413>>>>>
97413>>>>        End
97413>>>>>
97413>>>>        Forward Send Update_Status sProgress
97415>>>>    End_Procedure
97416>>>>
97416>>>>    Procedure IncrementFileCount Boolean bChangesMade
97419>>>>        Reread SysFile
97423>>>>            Add 1 to SysFile.iCountNumberOfFiles
97424>>>>            If (bChangesMade = True) Begin
97426>>>>                Add 1 to SysFile.iCountNumberOfChangedFiles                
97427>>>>            End
97427>>>>>
97427>>>>            SaveRecord SysFile
97428>>>>        Unlock
97429>>>>>
97429>>>>    End_Procedure
97430>>>>
97430>>>>    Procedure OnError Integer ErrNum Integer iErrLine String ErrMsg
97433>>>>        Send Log_Status of ghoStatusLog ("iErrNum =" * String(ErrNum) * "iErrLine =" * String(iErrLine) * "ErrMsg =" * String(ErrMsg))
97434>>>>    End_Procedure
97435>>>>    
97435>>>>End_Object
97436>>>>
97436>>>                                    
97436>>>    Object oMain_TabDialog is a dbTabDialog
97438>>>        Set Size to 254 578
97439>>>        Set piMinSize to 140 510
97440>>>        Set Location to 6 -2
97441>>>        Set Rotate_Mode to RM_Rotate
97442>>>        Set peAnchors to anAll
97443>>>        Set Auto_Clear_DEO_State to False  
97444>>>        Set Auto_Top_Panel_State to False
97445>>>        Set phoImageList to oImageList
97446>>>        Set Default_Tab to -1
97447>>>        
97447>>>        Object oFolders_tp is a dbTabPage
97449>>>            Set Label to "Select Folders and Files"
97450>>>            Set piImageIndex to Ico_Folders
97451>>>            Set pbAcceptDropFiles to True
97452>>>
97452>>>            Procedure OnFileDropped String sFileFolderName Boolean bLast
97455>>>                String sFileExt
97455>>>                Boolean bFile bFolder bSWSFile
97455>>>        
97455>>>                Delegate Send OnFileDropped sFileFolderName bLast
97457>>>            End_Procedure
97458>>>    
97458>>>            Object oSourceFolders_grp is a cRDCDbHeaderGroup
97460>>>                Set Location to 4 0
97461>>>                Set Size to 233 570
97462>>>                Set Label to "Select Source Code Folders"
97463>>>                Set psImage to "Folder.ico"
97464>>>                Set psNote to "Right click grid for options"
97465>>>                Set psToolTip to "You can add a folder with drag and drop from Windows Explorer, or by using the right-click mouse menu."
97466>>>                Set peAnchors to anAll
97467>>>                Set Border_Style to Border_None
97468>>>                Set piMinSize to 126 490
97469>>>    
97469>>>                Object oFolders_grd is a cRDCCJSelectionGrid
97471>>>                    Set Size to 204 557
97472>>>                    Set Location to 27 9
97473>>>                    Set psNoItemsText to "No Workspace selected yet..."
97474>>>                    Set pbShowAddFolderMenuItem to True
97475>>>                    Set pbShowRemoveFolderMenuItem to True 
97476>>>
97476>>>                    Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
97478>>>                        Set piWidth to 30
97479>>>                    End_Object
97480>>>
97480>>>                    Object oFoldername_Col is a cCJGridColumn
97482>>>                        // NOTE: This must be set here!
97482>>>                        Set phoData_Col to Self
97483>>>                        Set piWidth to 797
97484>>>                        Set psCaption to "Folder Name"
97485>>>                        Set psToolTip to "The process will run on all files that match the 'File Extensions Filter' comboform for the selected folders and all subfolders"
97486>>>                        Set pbEditable to False
97487>>>                        Set psFooterText to "No of Folders Selected:"
97488>>>
97488>>>                        Function OnGetTooltip Integer iRow String sValue String sText Returns String
97491>>>                            Move "The process will run on all files that match the 'File Extensions Filter' comboform for the selected folders and all subfolders" to sText
97492>>>                            Function_Return sText
97493>>>                        End_Function
97494>>>                        
97494>>>                        Procedure Set psFooterText String sValue  
97497>>>                            Integer iPos
97497>>>                            String sFolderNo
97497>>>                            
97497>>>                            Move "0" to sFolderNo
97498>>>                            Forward Set psFooterText to sValue
97500>>>                            Move (Pos(":", sValue)) to iPos
97501>>>                            If (iPos <> 0) Begin
97503>>>                                Move (Mid(sValue, 6, (iPos + 1))) to sFolderNo
97504>>>                                Move (Pos(" of ", sFolderNo)) to iPos
97505>>>                                If (iPos <> 0) Begin
97507>>>                                    Move (Left(sFolderNo, iPos)) to sFolderNo
97508>>>                                    Move (Trim(sFolderNo)) to sFolderNo        
97509>>>                                End
97509>>>>
97509>>>                            End
97509>>>>
97509>>>                            Set Value of oNoOfSelectedFolders_fm to sFolderNo
97510>>>                        End_Procedure
97511>>>
97511>>>                    End_Object
97512>>>
97512>>>                    // This column is created automatically by the cRDCCJGrid class.
97512>>>                    // Object oCheckbox_Col is a cCJGridColumn
97512>>>                    // End_Object
97512>>>
97512>>>                    Procedure LoadData
97515>>>                        String sHomePath sFolderName sDefaultFolders
97515>>>                        String[] asNoFolderList asStartFolder asFolderArray asDefaultFolders
97519>>>                        Handle hoDataSource
97519>>>                        tDataSourceRow[] TheData TheDataEmpty
97519>>>                        tDataSourceRow[] TheData TheDataEmpty
97521>>>                        Integer iSize iRow iCount iFolderCol iCheckBoxCol iDefaultFolders iFolder
97521>>>                        Boolean bChecked
97521>>>
97521>>>                        If (not(IsComObjectCreated(Self))) Begin
97523>>>                            Procedure_Return
97524>>>                        End
97524>>>>
97524>>>
97524>>>                        Get psWorkspaceHomePath of ghoApplication to sHomePath
97525>>>                        If (sHomePath = "") Begin
97527>>>                            Procedure_Return
97528>>>                        End
97528>>>>
97528>>>
97528>>>                        Send Cursor_Wait of Cursor_Control
97529>>>                        Get vFolderFormat sHomePath to sHomePath
97530>>>                        Move sHomePath to asStartFolder[0]
97531>>>                        Get AllSourceFolders of ghoApplication asStartFolder to asFolderArray
97532>>>                        Move (SizeOfArray(asFolderArray)) to iSize
97533>>>                        If (iSize = 0) Begin
97535>>>                            Send Cursor_Ready of Cursor_Control
97536>>>                            Procedure_Return
97537>>>                        End
97537>>>>
97537>>>                        Decrement iSize
97538>>>
97538>>>                        Move 0 to iCount
97539>>>                        Get phoDataSource to hoDataSource
97540>>>                        Get DataSource of hoDataSource to TheData
97541>>>                        Move TheDataEmpty to TheData
97542>>>                        Get piColumnId of (phoData_Col(Self))     to iFolderCol
97543>>>                        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
97544>>>                        Get NoFolderListAsArray of ghoApplication False to asNoFolderList
97545>>>
97545>>>                        Move CS_DefaultSourceFolders to sDefaultFolders
97546>>>                        Move (Lowercase(sDefaultFolders)) to sDefaultFolders
97547>>>                        Move (StrSplitToArray(sDefaultFolders, "|")) to asDefaultFolders
97548>>>                        Move (SizeOfArray(asDefaultFolders)) to iDefaultFolders
97549>>>                        Decrement iDefaultFolders
97550>>>
97550>>>                        Move 0 to iRow
97551>>>                        For iCount from 0 to iSize
97557>>>>
97557>>>                            Move asFolderArray[iCount] to sFolderName
97558>>>                            Move sFolderName to TheData[iRow].sValue[iFolderCol]
97559>>>                            Get IsFolderInDefaultsFolderList of ghoApplication sFolderName to bChecked
97560>>>                            Move bChecked to TheData[iRow].sValue[iCheckBoxCol]
97561>>>                            Increment iRow
97562>>>                        Loop
97563>>>>
97563>>>
97563>>>                        If (iRow <> 0) Begin
97565>>>                            Send ReInitializeData TheData False
97566>>>                            Send MoveToFirstRow
97567>>>                        End
97567>>>>
97567>>>                        Else Begin
97568>>>                            Send InitializeData TheDataEmpty
97569>>>                        End
97569>>>>
97569>>>                        Get CheckedItems to iCount
97570>>>                        Set psFooterText of oFoldername_Col  to ("Selected Items:" * String(iCount) * "of" * String(iSize + 1))
97571>>>                        Send Cursor_Ready of Cursor_Control
97572>>>                    End_Procedure
97573>>>
97573>>>                    On_Key kClear Send ActivateProcess
97574>>>                End_Object
97575>>>
97575>>>                Object oFileNameFilters_cf is a cRDCDbComboForm 
97577>>>                    Entry_Item SysFile.FileExtensionFilter
97578>>>                    Set Server to oSysFile_DD
97579>>>                    Set Size to 12 256
97580>>>                    Set Location to 6 310
97581>>>                    Set Label to "Select File Extensions Filter"
97582>>>                    Set psToolTip to "Each extension must start with a wildcard character and a dot (*.) and file extensions must be separated with a semicolon (;)"
97583>>>                    Set Status_Help to (psToolTip(Self))
97584>>>                    Set Combo_Sort_State to False
97585>>>                    Set pbAutoEnable to True
97586>>>                    Set peAnchors to anTopRight
97587>>>
97587>>>                    Property Integer piMaxUserFilters 8
97589>>>
97589>>>                    Procedure Combo_Fill_List
97592>>>                        String sDFExtensions sDFVersion
97592>>>                        Integer iMajorVersion iMinorVersion iCount iSize
97592>>>                        String[] asUserExtensions
97593>>>
97593>>>                        Forward Send Combo_Fill_List
97595>>>                        Move FMAC_VERSION  to iMajorVersion
97596>>>                        Move FMAC_REVISION to iMinorVersion
97597>>>                        Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sDFVersion
97598>>>                        Get StudioFileExtensions of ghoApplication sDFVersion to sDFExtensions
97599>>>
97599>>>                        Send Combo_Add_Item CS_StdExtensions
97600>>>                        Send Combo_Add_Item CS_DFAndTemplExt
97601>>>                        Send Combo_Add_Item CS_PkgIncExt
97602>>>                        Send Combo_Add_Item CS_SrcPkgExt
97603>>>
97603>>>                        If (sDFExtensions <> String(cx_RegKeyDFKeyDoesNotExist)) Begin
97605>>>                            Send Combo_Add_Item sDFExtensions
97606>>>                        End
97606>>>>
97606>>>
97606>>>                        Get UserSavedExtensions to asUserExtensions
97607>>>                        Move (SizeOfArray(asUserExtensions)) to iSize
97608>>>                        Decrement iSize
97609>>>                        For iCount from 0 to iSize
97615>>>>
97615>>>                            Send Combo_Add_Item (Trim(asUserExtensions[iCount]))
97616>>>                        Loop
97617>>>>
97617>>>
97617>>>                        Set Value to CS_StdExtensions
97618>>>                    End_Procedure
97619>>>
97619>>>                    Function UserSavedExtensions Returns String[]
97622>>>                        String[] asUserExtensions
97623>>>                        String sExt
97623>>>                        Integer iCount iSize
97623>>>
97623>>>                        Get piMaxUserFilters to iSize
97624>>>                        For iCount from 0 to iSize
97630>>>>
97630>>>                            Get ReadString  of ghoApplication CS_Settings (CS_DFExtensionsKey + String(iCount)) "" to sExt
97631>>>                            If (sExt <> "") Begin
97633>>>                                Move sExt to asUserExtensions[SizeOfArray(asUserExtensions)]
97634>>>                            End
97634>>>>
97634>>>                        Loop
97635>>>>
97635>>>
97635>>>                        Function_Return asUserExtensions
97636>>>                    End_Function
97637>>>
97637>>>                    // Note: Can't save new extensions entered by user with the
97637>>>                    // OnChange event, as it would save character per character.
97637>>>                    Procedure OnExitObject
97640>>>                        String sDFExtensions sDFVersion sNewExt
97640>>>                        Integer iMajorVersion iMinorVersion iCount iSize iMaxUserFilters iItem
97640>>>                        String[] asUserExtensions
97641>>>                        Boolean bExists
97641>>>
97641>>>                        Move FMAC_VERSION  to iMajorVersion
97642>>>                        Move FMAC_REVISION to iMinorVersion
97643>>>                        Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sDFVersion
97644>>>                        Get StudioFileExtensions of ghoApplication sDFVersion to sDFExtensions
97645>>>
97645>>>                        Get piMaxUserFilters to iSize
97646>>>                        Get Value to sNewExt
97647>>>                        If (sNewExt <> CS_StdExtensions and ;                            sNewExt <> CS_DFAndTemplExt and ;                            sNewExt <> CS_PkgIncExt and ;                            sNewExt <> CS_SrcPkgExt and ;                            sNewExt <> sDFExtensions) Begin
97649>>>
97649>>>                            Get IsExtensionInRegistry sNewExt to bExists
97650>>>
97650>>>                            If (bExists = False) Begin
97652>>>                                Get UserSavedExtensions to asUserExtensions
97653>>>                                // Push the new item on top of the list
97653>>>                                Send WriteString of ghoApplication CS_Settings (CS_DFExtensionsKey + String("0")) sNewExt
97654>>>                                Get piMaxUserFilters to iMaxUserFilters
97655>>>                                Move (SizeOfArray(asUserExtensions)) to iSize
97656>>>                                Move (iMaxUserFilters min iSize) to iSize
97657>>>                                Decrement iSize
97658>>>                                Move 0 to iItem
97659>>>                                For iCount from 0 to iSize
97665>>>>
97665>>>                                    Send WriteString of ghoApplication CS_Settings (CS_DFExtensionsKey + String(iCount + 1)) asUserExtensions[iItem]
97666>>>                                    Increment iItem
97667>>>                                Loop
97668>>>>
97668>>>                                Get piMaxUserFilters to iSize
97669>>>                                Move iSize to iCount // Get out of loop
97670>>>                            End
97670>>>>
97670>>>                        End
97670>>>>
97670>>>
97670>>>                    End_Procedure
97671>>>
97671>>>                    Function IsExtensionInRegistry String sExt Returns Boolean
97674>>>                        Boolean bExists
97674>>>                        String[] asUserExtensions
97675>>>                        Integer iCount iSize
97675>>>
97675>>>                        Move False to bExists
97676>>>                        Get UserSavedExtensions to asUserExtensions
97677>>>                        Move (SizeOfArray(asUserExtensions)) to iSize
97678>>>                        Decrement iSize
97679>>>                        For iCount from 0 to iSize
97685>>>>
97685>>>                            If (Lowercase(asUserExtensions[iCount]) = Lowercase(sExt)) Begin
97687>>>                                Move True to bExists
97688>>>                                Move iSize to iCount // We're done.
97689>>>                            End
97689>>>>
97689>>>                        Loop
97690>>>>
97690>>>                        Function_Return bExists
97691>>>                    End_Function
97692>>>
97692>>>                End_Object
97693>>>
97693>>>                Procedure UpdateEnabledState
97696>>>                    Boolean bWorkspaceMode
97696>>>                    String sSWSFile
97696>>>                    Get psSWSFile of ghoApplication to sSWSFile
97697>>>                    Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
97698>>>                    Set Enabled_State to (bWorkspaceMode = True and sSWSFile <> "")
97699>>>                End_Procedure
97700>>>
97700>>>            End_Object
97701>>>
97701>>>        End_Object
97702>>>
97702>>>        Object oSelectFunctions_tp is a dbTabPage
97704>>>            Set Label to "Select Functions"
97705>>>
97705>>>            Object oSelectFunctions_grp is a cRDCDbHeaderGroup
97707>>>                Set Size to 233 570
97708>>>                Set piMinSize to 126 490
97709>>>                Set Location to 4 0
97710>>>                Set Label to "Select Functions"             
97711>>>                Set psImage to "FunctionLibrary.ico"
97712>>>                Set psNote to "Refactoring functions"
97713>>>                Set psToolTip to "Standard refactoring functions are functions that are called once for each source line."
97714>>>                Set Border_Style to Border_None
97715>>>                Set peAnchors to anAll
97716>>>                Set piImageIndex to Ico_Functions
97717>>>
97717>>>Register_Procedure RefreshSelectionUpdate
97717>>>
97717>>>                Object oFunctionSelection_grd is a cRDCDbCJGrid
97719>>>                    Set Size to 204 557
97720>>>                    Set Location to 27 10
97721>>>                    Set Ordering to 5
97722>>>                    Set pbAllowAppendRow to False
97723>>>                    Set pbAllowDeleteRow to False
97724>>>                    Set pbAllowInsertRow to False
97725>>>                    Set pbAutoAppend to False
97726>>>                    Set pbEditOnTyping to False
97727>>>                    Set piLayoutBuild to 4
97728>>>                    Set pbHeaderReorders to True
97729>>>                    Set pbHeaderTogglesDirection to True
97730>>>                        
97730>>>                    Procedure Activating
97733>>>                        Forward Send Activating  
97735>>>                        Send DoChangeFontSize
97736>>>                    End_Procedure
97737>>>            
97737>>>                    Object oFunctions_ID is a cRDCDbCJGridColumn
97739>>>                        Entry_Item Functions.ID
97740>>>                        Set piWidth to 29
97741>>>                        Set psCaption to "ID"
97742>>>                        Set pbEditable to False
97743>>>                    End_Object
97744>>>
97744>>>                    Object oFunctions_Function_Name is a cRDCDbCJGridColumn
97746>>>                        Entry_Item Functions.Function_Name
97747>>>                        Set piWidth to 262
97748>>>                        Set psCaption to "Function Name"
97749>>>                        Set pbEditable to False   
97750>>>                        Set phoData_Col to Self   
97751>>>                        Set psToolTip to "The name of the refactoring function. Hover the mouse over a function row to see more help on what it does."
97752>>>                                    
97752>>>                        Function OnGetTooltip Integer iRow String sValue String sText Returns String
97755>>>                            Get RowValue of oFunctions_Function_Help iRow to sText
97756>>>                            Function_Return sText
97757>>>                        End_Function
97758>>>            
97758>>>                    End_Object
97759>>>                        
97759>>>                    Object oFunctions_Function_Description is a cRDCDbCJGridColumn
97761>>>                        Entry_Item Functions.Function_Description
97762>>>                        Set piWidth to 356
97763>>>                        Set psCaption to "Description"
97764>>>                        Set pbEditable to False
97765>>>                        Set psToolTip to "A short description of whate the refactoring function does. Hover the mouse over a function row to see more help on what it does."
97766>>>            
97766>>>                        Function OnGetTooltip Integer iRow String sValue String sText Returns String
97769>>>                            Get RowValue of oFunctions_Function_Help iRow to sText
97770>>>                            Function_Return sText
97771>>>                        End_Function
97772>>>            
97772>>>                    End_Object
97773>>>
97773>>>                    Object oFunctions_Type is a cRDCDbCJGridColumn
97775>>>                        Entry_Item Functions.Type
97776>>>                        Set piWidth to 138
97777>>>                        Set psCaption to "Type"
97778>>>                        Set peHeaderAlignment to xtpAlignmentCenter  
97779>>>                        Set pbComboButton to True
97780>>>                        Set psToolTip to "The function type rules how data is feed to the function. For 'Standard' and 'Remove' functions one source line at a time are send. To others either a full source file as a string array is passed, or the last option is to pass all selected files as a string array with full pathing."
97781>>>            
97781>>>                        Function OnGetTooltip Integer iRow String sValue String sText Returns String
97784>>>                            Get RowValue of oFunctions_Function_Help iRow to sText
97785>>>                            Function_Return sText
97786>>>                        End_Function
97787>>>            
97787>>>                    End_Object                    
97788>>>
97788>>>                    Object oFunctions_Parameter is a cDbCJGridColumn
97790>>>                        Entry_Item Functions.Parameter
97791>>>                        Set piWidth to 67
97792>>>                        Set psCaption to "Option"
97793>>>                        Set psToolTip to "For some functions an extra parameter can be passed. You can only change existing values. Hover the mouse over a value to see valid values to be selected from."
97794>>>            
97794>>>                        Function OnGetTooltip Integer iRow String sValue String sText Returns String
97797>>>                            Get RowValue of oFunctions_ParameterHelp iRow to sText
97798>>>                            Move (Replaces("\n", sText, CS_CRLF)) to sText
97799>>>                            Function_Return sText
97800>>>                        End_Function
97801>>>            
97801>>>                    End_Object
97802>>>
97802>>>                    Object oFunctions_ParameterHelp is a cDbCJGridColumn
97804>>>                        Entry_Item Functions.ParameterHelp
97805>>>                        Set piWidth to 200
97806>>>                        Set psCaption to "Parameter Help"
97807>>>                        Set pbVisible to False
97808>>>                    End_Object
97809>>>
97809>>>                    Object oFunctions_Function_Help is a cRDCDbCJGridColumn
97811>>>                        Entry_Item Functions.Function_Help
97812>>>                        Set piWidth to 221
97813>>>                        Set psCaption to "Help"
97814>>>                        Set pbVisible to False
97815>>>                    End_Object
97816>>>            
97816>>>                    Object oFunctions_Selected is a cRDCDbCJGridColumn
97818>>>                        Entry_Item Functions.Selected
97819>>>                        Set piWidth to 77
97820>>>                        Set psCaption to "Select"
97821>>>                        Set pbCheckbox to True
97822>>>                        Set peHeaderAlignment to xtpAlignmentCenter  
97823>>>                        Set phoCheckbox_Col to Self
97824>>>                        Set peFooterAlignment to  xtpAlignmentCenter
97825>>>            
97825>>>                        Function OnGetTooltip Integer iRow String sValue String sText Returns String
97828>>>                            Get RowValue of oFunctions_Function_Help iRow to sText
97829>>>                            Function_Return sText
97830>>>                        End_Function
97831>>>            
97831>>>                    End_Object
97832>>>
97832>>>                    Procedure Refresh Integer eMode
97835>>>                        Integer iChecked
97835>>>                        Forward Send Refresh eMode
97837>>>                        Set Value of oNoOfSelectedFunctions2_fm to SysFile.SelectedFunctionTotal
97838>>>                    End_Procedure
97839>>>                                
97839>>>                End_Object
97840>>>
97840>>>                Object oSelectAll_btn is a Button
97842>>>                    Set Size to 14 62
97843>>>                    Set Location to 4 203
97844>>>                    Set Label to "Select All"
97845>>>                    Set psImage to "SelectAll.ico"
97846>>>                    Set peAnchors to anTopRight
97847>>>                    Procedure OnClick
97850>>>                        Send SelectAll of (Main_DD(Self))
97851>>>                        Send RefreshSelectionUpdate of oFunctionSelection_grd
97852>>>                    End_Procedure
97853>>>                End_Object
97854>>>
97854>>>                Object oDeselectAll_btn is a Button
97856>>>                    Set Size to 14 62
97857>>>                    Set Location to 4 269
97858>>>                    Set Label to "Select None"
97859>>>                    Set psImage to "SelectNone.ico"
97860>>>                    Set peAnchors to anTopRight
97861>>>                    Procedure OnClick
97864>>>                        Send DeSelectAll of (Main_DD(Self))
97865>>>                        Send RefreshSelectionUpdate of oFunctionSelection_grd
97866>>>                    End_Procedure
97867>>>                End_Object
97868>>>
97868>>>                Object oConstrainByType_cf is a ComboForm
97870>>>                    Set Size to 14 84
97871>>>                    Set Location to 4 397
97872>>>                    Set peAnchors to anTopRight
97873>>>                    Set Label_Col_Offset to 2
97874>>>                    Set Label_Justification_Mode to JMode_Right
97875>>>                    Set Label to "Constrain by Type"
97876>>>                    Set Entry_State to False
97877>>>                    Set Combo_Sort_State to False
97878>>>                  
97878>>>                    Procedure Combo_Fill_List
97881>>>                        Send Combo_Add_Item CS_All_Functions
97882>>>                        Send Combo_Add_Item CS_Standard_Function
97883>>>                        Send Combo_Add_Item CS_Remove_Function
97884>>>                        Send Combo_Add_Item CS_Editor_Function
97885>>>                        Send Combo_Add_Item CS_Report_Function   
97886>>>                        Send Combo_Add_Item CS_Report_FunctionAll
97887>>>                        Send Combo_Add_Item CS_Other_Function   
97888>>>                        Send Combo_Add_Item CS_Other_FunctionAll
97889>>>                    End_Procedure
97890>>>                  
97890>>>                    Procedure OnChange
97893>>>                        String sValue                      
97893>>>                        Integer iType
97893>>>                        
97893>>>                        Get Value to sValue
97894>>>                        Case Begin
97894>>>                            Case (sValue = CS_All_Functions)
97896>>>                                Move eAll_Functions to iType
97897>>>                                Case Break
97898>>>                            Case (sValue = CS_Standard_Function)
97901>>>                                Move eStandard_Function to iType
97902>>>                                Case Break
97903>>>                            Case (sValue = CS_Remove_Function)
97906>>>                                Move eRemove_Function to iType
97907>>>                                Case Break                            
97908>>>                            Case (sValue = CS_Editor_Function)
97911>>>                                Move eEditor_Function to iType
97912>>>                                Case Break
97913>>>                            Case (sValue = CS_Report_Function)
97916>>>                                Move eReport_Function to iType
97917>>>                                Case Break
97918>>>                            Case (sValue = CS_Report_FunctionAll)
97921>>>                                Move eReport_FunctionAll to iType
97922>>>                                Case Break
97923>>>                            Case (sValue = CS_Other_Function)
97926>>>                                Move eOther_Function to iType
97927>>>                                Case Break
97928>>>                            Case (sValue = CS_Other_FunctionAll)
97931>>>                                Move eOther_FunctionAll to iType
97932>>>                                Case Break
97933>>>                            Case Else
97933>>>                        Case End
97933>>>                            
97933>>>                        Set piFunctionType of (Main_DD(Self)) to iType
97934>>>                        Send Rebuild_Constraints of (Main_DD(Self)) 
97935>>>                        Send RefreshDataFromDD of oFunctionSelection_grd 0
97936>>>                    End_Procedure
97937>>>                  
97937>>>                End_Object
97938>>>    
97938>>>                Object oDisabledInfo_txt is a TextBox
97940>>>                    Set Auto_Size_State to False
97941>>>                    Set Size to 22 100
97942>>>                    Set Location to 2 89
97943>>>                    Set Justification_Mode to JMode_Left
97944>>>                    Set FontWeight to fw_Bold
97945>>>                    Set peAnchors to anTopRight
97946>>>                    
97946>>>                    Object oDisabledInfo_Idle is an cIdleHandler
97948>>>                        Set pbEnabled to True
97949>>>                        Procedure OnIdle
97952>>>                            String sText  
97952>>>                            Boolean bSelected
97952>>>                            
97952>>>                            Get Field_Current_Value of oSysFile_DD Field SysFile.bCountSourceLines to bSelected
97953>>>                            If (bSelected = True) Begin
97955>>>                                Move "Grid is Disabled! Function 'Only count Source Lines' selected!" to sText
97956>>>                            End                 
97956>>>>
97956>>>                            Else Begin
97957>>>                                Move "" to sText
97958>>>                            End
97958>>>>
97958>>>                            Set Value of oDisabledInfo_txt to sText    
97959>>>                        End_Procedure
97960>>>                    End_Object
97961>>>            
97961>>>                End_Object
97962>>>                
97962>>>            End_Object
97963>>>                    
97963>>>        End_Object
97964>>>    
97964>>>        Procedure UpdateEnabledState
97967>>>            String sSWSFile
97967>>>            Get psSWSFile of ghoApplication to sSWSFile
97968>>>            Set Enabled_State to (sSWSFile <> "")
97969>>>        End_Procedure   
97970>>>        
97970>>>    End_Object
97971>>>                
97971>>>    Procedure UpdateEnabledState
97974>>>        String sSWSFile
97974>>>        Get psSWSFile of ghoApplication to sSWSFile
97975>>>        Set Enabled_State to (sSWSFile <> "")
97976>>>    End_Procedure
97977>>>
97977>>>    Object oRunNow_grp is a cRDCDbHeaderGroup
97979>>>        Set Size to 46 558
97980>>>        Set Location to 262 11
97981>>>        Set psLabel to "Refactor Selected Code"
97982>>>        Set psNote to "Process selected functions for the selected folders/source files" 
97983>>>        Set psToolTip to "Process selected refactoring functions for the source code matching the selected folders and file extensions."
97984>>>        Set psImage to "DFRefactor.ico"
97985>>>        Set peAnchors to anBottomLeftRight
97986>>>//        Set Border_Style to Border_None
97986>>>        Set pbUseLargeFontHeight to True
97987>>>
97987>>>        Object oNoOfSelectedFolders_fm is a Form
97989>>>            Set Size to 13 15
97990>>>            Set Location to 15 420
97991>>>            Set Label_Justification_Mode to JMode_Right
97992>>>            Set Label to "Number of Selected Folders"
97993>>>            Set psToolTip to "Total number of folders selected."
97994>>>            Set Enabled_State to False
97995>>>            Set peAnchors to anBottomRight
97996>>>            Set Label_FontWeight to fw_Bold
97997>>>            Set Label_Col_Offset to 1
97998>>>            Set FontWeight to fw_Bold  
97999>>>            Set Form_Datatype to Mask_Numeric_Window   
98000>>>            Set Form_Mask to "####"
98001>>>        End_Object
98002>>>
98002>>>        Object oNoOfSelectedFunctions2_fm is a cRDCDbForm
98004>>>            Entry_Item SysFile.SelectedFunctionTotal
98005>>>            Set Server to oSysFile_DD
98006>>>            Set Size to 13 15
98007>>>            Set Location to 29 420
98008>>>            Set Label_Justification_Mode to JMode_Right
98009>>>            Set Label to "Number of Selected Functions"
98010>>>            Set psToolTip to "Total number of functions selected."
98011>>>            Set Enabled_State to False
98012>>>            Set peAnchors to anBottomRight
98013>>>            Set Label_FontWeight to fw_Bold
98014>>>            Set Label_Col_Offset to 1
98015>>>            Set FontWeight to fw_Bold              
98016>>>        End_Object
98017>>>
98017>>>        Object oExecute_btn is a cRDCButton
98019>>>            Set Size to 25 109
98020>>>            Set Location to 17 442
98021>>>            Set Label to "Start &Refactoring!" //"&Refactor Code Now!"
98022>>>            Set psToolTip to "Start processing the selected refactoring functions. If 'Workspace' mode has been selected from the toolbar all source files that matches the 'File Extensions Filter' will be processed. Else the operations will take place on a single file only. (Alt+R or Ctrl+R)"
98023>>>//            Set MultiLineState to True
98023>>>            Set psImage to "Start.ico"
98024>>>            Set pbAutoEnable to True
98025>>>            Set peAnchors to anBottomRight
98026>>>            Set Default_State to True
98027>>>            Set piImageMarginLeft to 7
98028>>>            Set piImageSize to 32
98029>>>
98029>>>            Procedure End_Construct_Object
98032>>>                Forward Send End_Construct_Object
98034>>>                // Note: We use Form_FontWeight instead of FontWeight to _not_ make the object larger
98034>>>                // because of the bold font.
98034>>>                Set Form_FontWeight to FW_BOLD
98035>>>            End_Procedure
98036>>>
98036>>>            Procedure OnClick  
98039>>>                Send START_MAIN_PROCESS
98040>>>            End_Procedure
98041>>>
98041>>>            Function IsEnabled Returns Boolean
98044>>>                Boolean bEnabled bWorkspaceMode
98044>>>                String sFileName sSWSFile
98044>>>                Integer iSelectedFunctions iFolders
98044>>>
98044>>>                Get pbWorkspaceMode         of ghoApplication to bWorkspaceMode
98045>>>                Get psSWSFile               of ghoApplication to sSWSFile
98046>>>                Get psCurrentSourceFileName of ghoApplication to sFileName
98047>>>
98047>>>                If (bWorkspaceMode = True) Begin
98049>>>                    Move (sSWSFile <> "") to bEnabled
98050>>>                End
98050>>>>
98050>>>                Else Begin
98051>>>                    Move (sFileName <> "") to bEnabled
98052>>>                End
98052>>>>
98052>>>
98052>>>                If (bEnabled = True) Begin
98054>>>                    Move (SysFile.SelectedFunctionTotal > 0) to bEnabled
98055>>>                End
98055>>>>
98055>>>
98055>>>                If (bEnabled = True) Begin
98057>>>                    Get CheckedItems of oFolders_grd to iFolders
98058>>>                    Move (iFolders <> 0) to bEnabled
98059>>>                End          
98059>>>>
98059>>>                If (bEnabled = False) Begin
98061>>>                    Get Field_Current_Value of oSysFile_DD Field SysFile.bCountSourceLines to bEnabled
98062>>>                End
98062>>>>
98062>>>
98062>>>                Function_Return bEnabled
98063>>>            End_Function
98064>>>
98064>>>        End_Object
98065>>>
98065>>>        Procedure UpdateEnabledState
98068>>>            String sSWSFile
98068>>>            Get psSWSFile of ghoApplication to sSWSFile
98069>>>            Set Enabled_State to (sSWSFile <> "")
98070>>>        End_Procedure
98071>>>
98071>>>        Object oSysFile_CountSourceLines_cb is a dbCheckBox
98073>>>            Entry_Item SysFile.bCountSourceLines
98074>>>            Set Server to oSysFile_DD
98075>>>            Set Location to 4 444
98076>>>            Set Size to 8 109
98077>>>            Set Label to "Only count Source Lines"   
98078>>>            Set FontWeight to fw_Bold
98079>>>            Set peAnchors to anBottomRight 
98080>>>            Set psToolTip to (String("This function will tell you have big your workspace is by counting the number of real source lines for all selected folders and file extensions.") + String(CS_CR) + String("Note: It will skip blank or comments lines, and it will not count files generated by the Studio from COM components.") + String(CS_CR) + String(CS_CR) + String("This function needs be run alone, all other functions will be ignored."))
98081>>>            
98081>>>            Procedure OnChange
98084>>>                Boolean bChecked
98084>>>                Integer iSelectedFunctions
98084>>>                
98084>>>                Get Checked_State to bChecked
98085>>>                Set Enabled_State of oFunctionSelection_grd to (bChecked = False) 
98086>>>                If (bChecked = True) Begin
98088>>>                    Move 1 to iSelectedFunctions
98089>>>                End                             
98089>>>>
98089>>>                Else Begin
98090>>>                    Move SysFile.SelectedFunctionTotal to iSelectedFunctions
98091>>>                End
98091>>>>
98091>>>                Set Value of oNoOfSelectedFunctions2_fm to iSelectedFunctions
98092>>>                Set Changed_State of oSysFile_DD to False
98093>>>            End_Procedure
98094>>>
98094>>>        End_Object
98095>>>
98095>>>    End_Object
98096>>>
98096>>>    // Hidden object!
98096>>>    // This _must_ be here, else we will get inficite recursion and a crash because there
98096>>>    // will be no object to take the focus when the view is disabled.
98096>>>//    Object oHidden_Focus_Object is a Form
98096>>>//        Set Size to 13 27
98096>>>//        Set Location to 280 150
98096>>>//        Set Label to "Hidden focus object!"
98096>>>//        Set Visible_State to False
98096>>>//        Set Label_Justification_Mode to JMode_Right
98096>>>//        Set Label_Col_Offset to 2
98096>>>//    End_Object
98096>>>
98096>>>
98096>>>    Procedure InitializeCounters
98099>>>        Send ResetLineCounters of (Main_DD(Self))
98100>>>        Set piNoOfUnusedLocalVariables of (phoRemoveUnusedLocals(Self)) to 0
98101>>>    End_Procedure
98102>>>
98102>>>    // Collect all settings to one common struct to be passed amongst the main operating procedures.
98102>>>    Procedure CollectSettings
98105>>>        tRefactorSettings RefactorSettings                   
98105>>>        tRefactorSettings RefactorSettings                   
98105>>>        String sPath sFileName 
98105>>>        Boolean bWorkspaceMode
98105>>>                                                                                
98105>>>        Get SelectedItems of oFolders_grd         to RefactorSettings.asFolderNames
98106>>>        Move (Trim(SysFile.FileExtensionFilter))  to RefactorSettings.sFileFilter
98107>>>                                                
98107>>>        Move SysFile.SelectedStandardFunctions    to RefactorSettings.iSelectedStandardFunctions
98108>>>        Move SysFile.SelectedRemoveFunctions      to RefactorSettings.iSelectedRemoveFunctions
98109>>>        Move SysFile.SelectedEditorFunctions      to RefactorSettings.iSelectedEditorFunctions
98110>>>        Move SysFile.SelectedReportFunctions      to RefactorSettings.iSelectedReportFunctions
98111>>>        Move SysFile.SelectedReportAllFunctions   to RefactorSettings.iSelectedReportAllFunctions
98112>>>        Move SysFile.SelectedOtherFunctions       to RefactorSettings.iSelectedOtherFunctions
98113>>>        Move SysFile.SelectedOtherAllFunctions    to RefactorSettings.iSelectedOtherAllFunctions
98114>>>        
98114>>>        // All functions that work on a line-by-line basis.
98114>>>        Move (SysFile.SelectedStandardFunctions + SysFile.SelectedRemoveFunctions) ;            to RefactorSettings.iSelectedLineByLineFunctions
98115>>>        
98115>>>        // All functions that are feed with a full source file as a string array:
98115>>>        Move (SysFile.SelectedEditorFunctions + SysFile.SelectedReportFunctions + SysFile.SelectedOtherFunctions) ;            to RefactorSettings.iSelectedFullFileFunctions
98116>>>
98116>>>        // All functions that are feed with a string array containing all selected files (including path):
98116>>>        Move (SysFile.SelectedReportAllFunctions + SysFile.SelectedOtherAllFunctions) ;            to RefactorSettings.iSelectedAllFilesFunctions
98117>>>
98117>>>        Move SysFile.bCountSourceLines              to RefactorSettings.bCountSourceLines
98118>>>        Move SysFile.bEditorDropSelf                to RefactorSettings.bEditorDropSelf
98119>>>
98119>>>        Set pRefactorSettings of ghoRefactorFunctionLibrary to RefactorSettings
98120>>>    End_Procedure
98121>>>
98121>>>    // At least one action should have been selected, unless we're counting source lines.
98121>>>    // Also checks that spinform values are correct.
98121>>>    Function IsValidActions Returns Boolean
98124>>>        Boolean bOK bWorkspaceMode bFileExists                
98124>>>        Handle hoDD
98124>>>        Integer iTabSize iSelectedFunctions iMaxLines iMinLines iRetval
98124>>>        String  sFileName sFileFilter
98124>>>        tRefactorSettings RefactorSettings
98124>>>        tRefactorSettings RefactorSettings
98124>>>        
98124>>>        Move (Main_DD(Self)) to hoDD
98125>>>        Get pRefactorSettings of ghoRefactorFunctionLibrary to RefactorSettings
98126>>>        
98126>>>        If (RefactorSettings.bCountSourceLines = True) Begin
98128>>>            Get YesNo_Box "The Function 'Count number of source lines' needs to be run in solitude! All other functions will be ignored. Continue?" to iRetval
98129>>>            If (iRetval <> MBR_Yes) Begin
98131>>>                Function_Return False
98132>>>            End                  
98132>>>>
98132>>>            Function_Return True
98133>>>        End
98133>>>>
98133>>>        
98133>>>        Get SelectedFunctions of hoDD to iSelectedFunctions
98134>>>        Move (iSelectedFunctions > 0) to bOK
98135>>>        If (bOK = False) Begin
98137>>>            Send Info_Box "You should at least check ONE action/function for the process to run."
98138>>>            Function_Return False
98139>>>        End
98139>>>>
98139>>>
98139>>>//        Get Minimum_Position of oMaxBlankLines_sf to iMinLines
98139>>>//        Get Maximum_Position of oMaxBlankLines_sf to iMaxLines
98139>>>//
98139>>>//        If (RefactorSettings.iMaxBlankLines < iMinLines or SysFile.MaxBlankLines > iMaxLines) Begin
98139>>>//            Send Info_Box ("The number of blank lines needs to be between" * String(iMinLines) * String("and") * String(iMaxLines))
98139>>>//            Move False to bOK
98139>>>//        End
98139>>>
98139>>>        Get pbWorkspaceMode of ghoApplication to bWorkspaceMode
98140>>>        If (bWorkspaceMode = True) Begin
98142>>>            Move RefactorSettings.sFileFilter to sFileFilter
98143>>>            If (not(sFileFilter contains "." and (not(sFileFilter contains "*") or not(sFileFilter contains "?")))) Begin
98145>>>                Send Info_Box "You need to select at least one file name extenstion. Please adjust and try again."
98146>>>                Move False to bOK
98147>>>            End
98147>>>>
98147>>>        End
98147>>>>
98147>>>        Else Begin
98148>>>            Get psCurrentSourceFileName of ghoApplication to sFileName
98149>>>            Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bFileExists
98150>>>            If (bFileExists = False) Begin
98152>>>                Send Info_Box "The specified source file couldn't be found." "Process Halted"
98153>>>                Move False to bOK
98154>>>            End
98154>>>>
98154>>>        End
98154>>>>
98154>>>
98154>>>        Function_Return bOK
98155>>>    End_Function
98156>>>    
98156>>>    //
98156>>>    // ToDo: *** START_MAIN_PROCESSS ***
98156>>>    //
98156>>>    Procedure START_MAIN_PROCESS
98159>>>        String[] asFolderNames
98160>>>        String sFileFilter sPath sFileName sText sTotalTime sFolderName
98160>>>        Handle hoBPO
98160>>>        Boolean bOK bWorkspaceMode bEditorFunctions bExists
98160>>>        Integer eResponse iErrors
98160>>>        DateTime dtExecStart dtExecEnd
98160>>>        TimeSpan tsTotalTime
98160>>>        tRefactorSettings RefactorSettings 
98160>>>        tRefactorSettings RefactorSettings 
98160>>>
98160>>>        Send Request_Save
98161>>>        Send CollectSettings
98162>>>        Get IsValidActions to bOk
98163>>>        If (bOk = False) Begin
98165>>>            Procedure_Return
98166>>>        End    
98166>>>>
98166>>>
98166>>>        Get IsBackupFolder of ghoApplication to bExists
98167>>>        If (bExists = False) Begin
98169>>>            Get CreateBackupFolder of ghoApplication "" to sFolderName
98170>>>        End    
98170>>>>
98170>>>        Get IsBackupFolder of ghoApplication to bExists
98171>>>        If (bExists = False) Begin
98173>>>            Send Info_Box ("Backup folder could not be created! Cannot continue:" * String(sFolderName + CS_BackupFolder))
98174>>>            Procedure_Return
98175>>>        End
98175>>>>
98175>>>
98175>>>        Get pbWorkspaceMode         of ghoApplication to bWorkspaceMode
98176>>>        Get psCurrentSourceFileName of ghoApplication to sFileName
98177>>>        Get pRefactorSettings       of ghoRefactorFunctionLibrary to RefactorSettings
98178>>>
98178>>>        If (RefactorSettings.bCountSourceLines = False) Begin
98180>>>            Get StartWarning bWorkspaceMode sFileName to eResponse
98181>>>            If (eResponse <> MBR_Yes) Begin
98183>>>                Procedure_Return
98184>>>            End
98184>>>>
98184>>>        End
98184>>>>
98184>>>
98184>>>        Move False to Err
98185>>>        Move 0 to LastErr
98186>>>        Send InitializeCounters 
98187>>>        Move (CurrentDateTime()) to dtExecStart
98188>>>        
98188>>>        // *** Business Process where the calls to selected refactoring functions are made ***
98188>>>        Get phoBPO to hoBPO
98189>>>        Send DoProcess of hoBPO
98190>>>
98190>>>        Get Error_Count of hoBPO to iErrors
98191>>>        If (iErrors = 0) Begin
98193>>>            Move (CurrentDateTime()) to dtExecEnd
98194>>>            Move (dtExecEnd - dtExecStart) to tsTotalTime
98195>>>            Get TimeSpanToString tsTotalTime to sTotalTime
98196>>>            Send UpdateStatusBar (CS_CRLF + "Process completed. Elapsed Time:" * sTotalTime) True
98197>>>            Get vFolderFormat sPath to sPath
98198>>>
98198>>>            Set Changed_State of (phoEditorView(ghoApplication)) to False
98199>>>            Get SummaryText True to sText
98200>>>            Send ActivateLogFile
98201>>>
98201>>>            If (SysFile.iCountUnusedSourceFiles <> 0) Begin
98203>>>                Send DisplayUnusedSourceFilesDialog of (Client_Id(ghoCommandBars))
98204>>>            End
98204>>>>
98204>>>        End
98204>>>>
98204>>>        Else Begin
98205>>>            Send Info_Box "The Process was unsuccessful." (psProduct(ghoApplication))
98206>>>            Send Popup of (oStatusLog_dg(Client_Id(phoMainPanel(ghoApplication))))
98207>>>        End
98207>>>>
98207>>>
98207>>>    End_Procedure
98208>>>
98208>>>    // ToDo: *** Text Messages ***
98208>>>    //
98208>>>    Function StartWarning Boolean bWorkspaceMode String sFileName Returns Integer
98211>>>        Boolean bSaveBak
98211>>>        Integer eResponse iSelectedFunctionsCount
98211>>>        String  sMessage
98211>>>
98211>>>        Get SelectedFunctions of (Main_DD(Self)) to iSelectedFunctionsCount
98212>>>        If (bWorkspaceMode) Begin
98214>>>            Append sMessage ("You have selected" * String(iSelectedFunctionsCount) * "refactoring functions that will be applied ")
98215>>>            Append sMessage ("to files for the selected folders and subfolders that matches these extensions:" * Trim(SysFile.FileExtensionFilter))
98216>>>            Append sMessage "\n\nPrior running these routines you should ALWAYS have checked in the source code with a version control system and/or "
98217>>>            Append sMessage "made a backup of the source code!"
98218>>>            Append sMessage "\n\nContinue?"
98219>>>        End
98219>>>>
98219>>>        Else Begin
98220>>>            Append sMessage ("You have selected" * String(iSelectedFunctionsCount) * "refactoring functions that will be applied to this source file:\n ")
98221>>>            Append sMessage sFileName
98222>>>            Append sMessage "\n\nContinue?"
98223>>>        End
98223>>>>
98223>>>
98223>>>        Get YesNo_Box sMessage "" MB_DEFBUTTON2 to eResponse
98224>>>        Function_Return eResponse
98225>>>    End_Function
98226>>>
98226>>>    Function SummaryText Boolean bWriteLogFile Returns String
98229>>>        String sText sLogText sLogFile sPath sTimeText sProgram sFormatString sValue
98229>>>        Integer iChangedFiles iCount iSize
98229>>>        Integer iFileCount iChannel
98229>>>        tRefactorSettings RefactorSettings
98229>>>        tRefactorSettings RefactorSettings
98229>>>        DateTime dtToday
98229>>>        Boolean bExists
98229>>>        
98229>>>        Move SysFile.iCountNumberOfChangedFiles to iChangedFiles
98230>>>        Move SysFile.iCountNumberOfFiles        to iFileCount
98231>>>        Get pRefactorSettings  of ghoRefactorFunctionLibrary to RefactorSettings
98232>>>        Move ("  File Filter:  " * Trim(RefactorSettings.sFileFilter) + "\n") to sText
98233>>>        Move (SizeOfArray(RefactorSettings.asFolderNames)) to iSize
98234>>>        Append sText ("Number of Folders:" * String(iSize) + "\n")
98235>>>        Decrement iSize
98236>>>        For iCount from 0  to iSize
98242>>>>
98242>>>            Append sText "  " RefactorSettings.asFolderNames[iCount] "\n"
98245>>>        Loop
98246>>>>
98246>>>
98246>>>        Append sText "\nStatistics:\n==========="
98247>>>        
98247>>>        // If source line counting this will be the only action for this run:
98247>>>        If (RefactorSettings.bCountSourceLines = True) Begin
98249>>>            Move ",#." to sFormatString
98250>>>            Move (FormatValue(SysFile.iCountNumberOfLines, sFormatString)) to sValue
98251>>>            Append sText ("\no Count of Source lines. Number of files:" * String(SysFile.iCountNumberOfFiles) * String("Total Number of Lines:") * String(sValue))
98252>>>            Append sText (String("\n  Skipped all COM wrapper files generated by the Studio."))
98253>>>        End
98253>>>>
98253>>>
98253>>>        Else Begin
98254>>>            
98254>>>            // Remove functions:
98254>>>            // One source line at a time was passed to these fucntions.
98254>>>            If (RefactorSettings.iSelectedRemoveFunctions <> 0) Begin
98256>>>                Append sText ("\n\n" + CS_Remove_Function +"(s):")
98257>>>                Constraint_Set (Self + 1) Clear
98259>>>                Constrained_Clear eq FunctionsA by Index.4  
98262>>>                Constrain FunctionsA.Selected eq True
98264>>>                Constrain FunctionsA.Type eq eRemove_Function
98266>>>                Constrained_Find First FunctionsA by Index.4
98271>>>                While (Found)
98275>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "lines" * Trim(FunctionsA.Function_Summary))
98276>>>                    Constrained_Find Next            
98277>>>                Loop
98278>>>>
98278>>>            End
98278>>>>
98278>>>            
98278>>>            // Standard functions:
98278>>>            // One source line at a time was passed to these fucntions.
98278>>>            If (RefactorSettings.iSelectedStandardFunctions <> 0) Begin
98280>>>                Append sText ("\n\n" + CS_Standard_Function +"(s):")
98281>>>                Constraint_Set (Self) Clear
98283>>>                Constrained_Clear eq FunctionsA by Index.4  
98286>>>                Constrain FunctionsA.Selected eq True
98288>>>                Constrain FunctionsA.Type eq eStandard_Function        
98290>>>                Constrained_Find First FunctionsA by Index.4
98295>>>                While (Found)
98299>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "lines" * Trim(FunctionsA.Function_Summary))
98300>>>                    Constrained_Find Next            
98301>>>                Loop
98302>>>>
98302>>>            End
98302>>>>
98302>>>            
98302>>>            // Editor functions:
98302>>>            // One source file at a time was passed as a string array.
98302>>>            If (RefactorSettings.iSelectedEditorFunctions <> 0) Begin
98304>>>                Append sText ("\n\n" + CS_Editor_Function +"(s):")
98305>>>                Constraint_Set (Self + 2) Clear
98307>>>                Constrained_Clear eq FunctionsA by Index.4  
98310>>>                Constrain FunctionsA.Selected eq True
98312>>>                Constrain FunctionsA.Type eq eEditor_Function
98314>>>                Constrained_Find First FunctionsA by Index.4
98319>>>                While (Found)
98323>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "file(s)" * Trim(FunctionsA.Function_Summary))
98324>>>                    Constrained_Find Next            
98325>>>                Loop
98326>>>>
98326>>>            End
98326>>>>
98326>>>            
98326>>>            // Other functions:
98326>>>            // One source file at a time was passed as a string array.
98326>>>            If (RefactorSettings.iSelectedOtherFunctions <> 0) Begin
98328>>>                Append sText ("\n\n" + CS_Other_Function +"(s):")
98329>>>                Constraint_Set (Self + 5) Clear
98331>>>                Constrained_Clear eq FunctionsA by Index.4  
98334>>>                Constrain FunctionsA.Selected eq True
98336>>>                Constrain FunctionsA.Type eq eOther_Function
98338>>>                Constrained_Find First FunctionsA by Index.4
98343>>>                While (Found)
98347>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "lines" * Trim(FunctionsA.Function_Summary))
98348>>>                    Constrained_Find Next            
98349>>>                Loop
98350>>>>
98350>>>            End
98350>>>>
98350>>>
98350>>>            // OthertAll functions:
98350>>>            // All selected files were passed as a string array (with full path)
98350>>>            If (RefactorSettings.iSelectedOtherAllFunctions <> 0) Begin
98352>>>                Append sText ("\n\n" + CS_Other_FunctionAll +"(s):")
98353>>>                Constraint_Set (Self + 6) Clear
98355>>>                Constrained_Clear eq FunctionsA by Index.4  
98358>>>                Constrain FunctionsA.Selected eq True
98360>>>                Constrain FunctionsA.Type eq eOther_FunctionAll
98362>>>                Constrained_Find First FunctionsA by Index.4
98367>>>                While (Found)
98371>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "file(s)" * Trim(FunctionsA.Function_Summary))
98372>>>                    Constrained_Find Next            
98373>>>                Loop
98374>>>>
98374>>>            End
98374>>>>
98374>>>            
98374>>>            // Report functions: These makes no code changes.
98374>>>            // One source file at a time was passed as a string array.
98374>>>            If (RefactorSettings.iSelectedReportFunctions <> 0) Begin
98376>>>                Append sText ("\n\n" + CS_Report_Function +"(s):")
98377>>>                Constraint_Set (Self + 3) Clear
98379>>>                Constrained_Clear eq FunctionsA by Index.4  
98382>>>                Constrain FunctionsA.Selected eq True
98384>>>                Constrain FunctionsA.Type eq eReport_Function
98386>>>                Constrained_Find First FunctionsA by Index.4
98391>>>                While (Found)
98395>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "file(s)" * Trim(FunctionsA.Function_Summary))
98396>>>                    Constrained_Find Next            
98397>>>                Loop
98398>>>>
98398>>>            End
98398>>>>
98398>>>
98398>>>            // ReportAll functions: These makes no code changes.
98398>>>            // All selected files were passed as a string array (with full path)
98398>>>            If (RefactorSettings.iSelectedReportAllFunctions <> 0) Begin
98400>>>                Append sText ("\n\n" + CS_Report_FunctionAll +"(s):")
98401>>>                Constraint_Set (Self + 4) Clear
98403>>>                Constrained_Clear eq FunctionsA by Index.4  
98406>>>                Constrain FunctionsA.Selected eq True
98408>>>                Constrain FunctionsA.Type eq eReport_FunctionAll
98410>>>                Constrained_Find First FunctionsA by Index.4
98415>>>                While (Found)
98419>>>                    Append sText ("\no" * Trim(FunctionsA.Count) * "file(s)" * Trim(FunctionsA.Function_Summary))
98420>>>                    Constrained_Find Next            
98421>>>                Loop
98422>>>>
98422>>>            End
98422>>>>
98422>>>            
98422>>>            // ToDo: This needs to be handled in a different way.
98422>>>            //       Perhaps in the function library function itself?
98422>>>            //       Or perhaps in Functions.Lines?
98422>>>//            If (RefactorSettings.bRemoveUnusedLocals = True) Begin
98422>>>//                If (SysFile.iCountUnusedLocals <> 0) Begin
98422>>>//                    Append sText ("\noRemoved Unused local variables:" * String(SysFile.iCountUnusedLocals))
98422>>>//                End
98422>>>//            End
98422>>>        End
98422>>>>
98422>>>        
98422>>>        If (bWriteLogFile = True) Begin
98424>>>            Get psIdleText of (phoStatusBar(ghoCommandBars)) to sTimeText    
98425>>>            Move (Replace(CS_CRLF, sTimeText, "")) to sTimeText
98426>>>            Get psHomePath of ghoApplication to sPath
98427>>>            Get vFolderFormat sPath to sPath
98428>>>            Move (sPath + CS_BackupFolder + CS_DirSeparator + CS_SummaryLogfileName) to sLogFile
98429>>>            Get Seq_New_Channel to iChannel
98430>>>            // No channel available 
98430>>>            If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
98432>>>                Error "No Channel Available for Process: Procedure 'SummaryText'"
98433>>>>
98433>>>                Function_Return ""
98434>>>            End
98434>>>>
98434>>>            Append_Output channel iChannel sLogFile
98436>>>            Move (Replaces("\n", sText, (Character(13) + Character(10)))) to sLogText
98437>>>            Get psProduct of ghoApplication to sProgram
98438>>>            Move (CurrentDateTime()) to dtToday
98439>>>            Writeln channel iChannel "====================================================================================="
98442>>>            Writeln channel iChannel "CREATED BY: " sProgram " -- " dtToday
98448>>>            Writeln channel iChannel sLogText
98451>>>            Writeln channel iChannel
98453>>>            Writeln channel iChannel ("Total number of files changed:" * String(iChangedFiles) * "out of" * String(iFileCount) * "Files.")
98456>>>            Writeln channel iChannel sTimeText
98459>>>            Writeln channel iChannel
98461>>>            Close_Input channel iChannel
98463>>>            Send Seq_Release_Channel iChannel
98464>>>        End
98464>>>>
98464>>>
98464>>>        Function_Return sText
98465>>>    End_Function
98466>>>
98466>>>    Function pbShouldSave Returns Boolean
98469>>>        Function_Return (Changed_State(Self))
98470>>>    End_Function
98471>>>
98471>>>    Procedure Request_Clear
98474>>>        Set Changed_State to False
98475>>>        Forward Send Request_Clear
98477>>>    End_Procedure
98478>>>
98478>>>    Procedure Request_Clear_All
98481>>>        Set Changed_State to False
98482>>>        Send Request_Clear_All of oFolders_grd
98483>>>        Forward Send Request_Clear_All
98485>>>    End_Procedure
98486>>>
98486>>>    Procedure Close_Panel
98489>>>    End_Procedure
98490>>>
98490>>>    Procedure OnSetFocus
98493>>>        Integer iSelectedFunctions                 
98493>>>        Boolean bCountSourceLines
98493>>>
98493>>>        Set piActiveView of ghoApplication to CI_CleanupSource Self
98494>>>
98494>>>        Move (SysFile.bCountSourceLines = True) to bCountSourceLines
98495>>>        If (bCountSourceLines = True) Begin
98497>>>            Move 1 to iSelectedFunctions
98498>>>        End                             
98498>>>>
98498>>>        Else Begin
98499>>>            Move SysFile.SelectedFunctionTotal to iSelectedFunctions
98500>>>        End
98500>>>>
98500>>>        Set Value of oNoOfSelectedFunctions2_fm to iSelectedFunctions
98501>>>        Set Changed_State of oSysFile_DD to False
98502>>>    End_Procedure
98503>>>
98503>>>    Procedure OnWorkspaceLoaded
98506>>>        Send LoadData of oFolders_grd
98507>>>    End_Procedure
98508>>>
98508>>>    // Allow a source file, .sws file or a folder to be dropped on the view:
98508>>>    Procedure OnFileDropped String sFileFolderName Boolean bLast
98511>>>        String sFileExt
98511>>>        Boolean bFile bFolder bSWSFile
98511>>>
98511>>>        Forward Send OnFileDropped sFileFolderName bLast
98513>>>
98513>>>        // Try to find out if a file or a folder name was dropped on the view:
98513>>>        Get ParseFileExtension sFileFolderName to sFileExt
98514>>>        Move (Lowercase(sFileExt)) to sFileExt
98515>>>        Move (sFileExt = "")    to bFolder
98516>>>        Move (sFileExt = "sws") to bSWSFile
98517>>>        Move (bSWSFile = False and bFolder = False) to bFile
98518>>>        
98518>>>        If (bFolder = True) Begin
98520>>>            Send AddItem of oFolders_grd sFileFolderName
98521>>>        End
98521>>>>
98521>>>        Else If (bLast = True) Begin
98524>>>            If (bFile = True) Begin
98526>>>                Send UpdateSourceFileNameDisplay of ghoApplication sFileFolderName
98527>>>                Set pbWorkspaceMode of ghoApplication to False
98528>>>            End
98528>>>>
98528>>>            If (bSWSFile = True) Begin
98530>>>                Send UpdateWorkspaceSelectorDisplay of ghoApplication sFileFolderName
98531>>>                Set pbWorkspaceMode of ghoApplication to True
98532>>>            End
98532>>>>
98532>>>        End
98532>>>>
98532>>>        Else Begin
98533>>>            Send Info_Box "Only on file can be dropped on the view at a time. The last will be used."
98534>>>        End
98534>>>>
98534>>>    End_Procedure
98535>>>
98535>>>    Object oView_IdleHandler is a cIdleHandler
98537>>>        Set pbEnabled to True
98538>>>        Procedure OnIdle
98541>>>            Broadcast Recursive Send UpdateEnabledState of (Parent(Self))
98543>>>        End_Procedure
98544>>>    End_Object
98545>>>
98545>>>End_Object
98546>        Use EditorView.vw
Including file: EditorView.vw    (C:\Projects\DF18\DfRefactor\AppSrc\EditorView.vw)
98546>>>Use Windows.pkg
98546>>>Use cRefactorDbView.pkg
98546>>>Use cScintillaRefactorEditor.pkg
98546>>>Use oEditorProperties.pkg
98546>>>Use mfiletime.pkg
Including file: mFileTime.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\mFileTime.pkg)
98546>>>>>//*****************************************************************************************
98546>>>>>// Copyright (c) 2000 Michael Kurz
98546>>>>>// All rights reserved.
98546>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
98546>>>>>//
98546>>>>>// $FileName    : mFILETIME_ft.pkg
98546>>>>>// $ProjectName : Shared Methods
98546>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
98546>>>>>// $Created     : 01-25-2001 @ 19:00
98546>>>>>//
98546>>>>>// Contents:
98546>>>>>//      Gets the FILETIME_ft with a slightly changed Get_File_Mod_Time command which gets the
98546>>>>>//      date in 4 digit format.
98546>>>>>//      And also creates a TimeStamp.
98546>>>>>//
98546>>>>>// $Rev History
98546>>>>>//
98546>>>>>//*****************************************************************************************
98546>>>>>
98546>>>>>//Use mWinAPIErrorText.pkg
98546>>>>>// Function's needed for getting the FILETIME_ft. 16.05.01 Bernhard
98546>>>>>    External_Function FileTimeToSystemTime "FileTimeToSystemTime" kernel32.dll Pointer pSYSTEMTIME_ft Pointer pFILETIME Returns Integer
98547>>>>>    External_Function CloseHandle "CloseHandle" kernel32.dll Handle hFile Returns Integer
98548>>>>>    External_Function FindFirstFile "FindFirstFileA" kernel32.dll Pointer lpFile Pointer lpFindFileData Returns Integer
98549>>>>>    External_Function FindClose "FindClose" kernel32.dll Handle hFile Returns Integer
98550>>>>>// Types needed for getting the FILETIME. 16.05.01 Bernhard
98550>>>>>Type SYSTEMTIME_ft
98550>>>>>Field SYSTEMTIME_ft.wYear          as WORD
98550>>>>>Field SYSTEMTIME_ft.wMonth         as WORD
98550>>>>>Field SYSTEMTIME_ft.wDayOfWeek     as WORD
98550>>>>>Field SYSTEMTIME_ft.wDay           as WORD
98550>>>>>Field SYSTEMTIME_ft.wHour          as WORD
98550>>>>>Field SYSTEMTIME_ft.wMinute        as WORD
98550>>>>>Field SYSTEMTIME_ft.wSecond        as WORD
98550>>>>>Field SYSTEMTIME_ft.wMilliseconds  as WORD
98550>>>>>End_Type
98550>>>>>
98550>>>>>Type FILETIME_ft
98550>>>>>Field FILETIME_ft.dwLowDateTime    as DWord
98550>>>>>Field FIELTIME.dwHighDateTime   as DWord
98550>>>>>End_Type
98550>>>>>
98550>>>>>Type WIN32_FIND_DATA_ft
98550>>>>>Field WIN32_FIND_DATA_ft.dwFileAttributes as DWord
98550>>>>>Field WIN32_FIND_DATA_ft.ftCreationTime as Char 8
98550>>>>>Field WIN32_FIND_DATA_ft.ftLastAccessTime as Char 8
98550>>>>>Field WIN32_FIND_DATA_ft.ftLastWriteTime as Char 8
98550>>>>>Field WIN32_FIND_DATA_ft.nFileSizeHigh as DWord
98550>>>>>Field WIN32_FIND_DATA_ft.nFileSizeLow as DWord
98550>>>>>Field WIN32_FIND_DATA_ft.dwReserved0 as DWord
98550>>>>>Field WIN32_FIND_DATA_ft.dwReserverd1 as DWord
98550>>>>>Field WIN32_FIND_DATA_ft.cFileName as Char 260
98550>>>>>Field WIN32_FIND_DATA_ft.cAlternateFileName as Char 14
98550>>>>>End_Type
98550>>>>>
98550>>>>>// Convert 3 Integer's to a Date based on the System-Settings. 16.05.01 Bernhard
98550>>>>>Function MKConvertYearMonthDay Integer iYear Integer iMonth Integer iDay Returns Date
98553>>>>>    Integer iFormat iSeparator
98553>>>>>    String sSeparator
98553>>>>>    Date dRetVal
98553>>>>>
98553>>>>>    Get_Attribute DF_DATE_FORMAT to iFormat
98556>>>>>    Get_Attribute DF_DATE_SEPARATOR to iSeparator
98559>>>>>    Move (Character(iSeparator)) to sSeparator
98560>>>>>
98560>>>>>    If iFormat Eq DF_DATE_USA Begin
98562>>>>>        Move ( (String(iMonth)) + sSeparator + (String(iDay)) + sSeparator + (String(iYear))) to dRetVal
98563>>>>>    End
98563>>>>>>
98563>>>>>    If iFormat Eq DF_DATE_EUROPEAN Begin
98565>>>>>        Move ( (String(iDay)) + sSeparator + (String(iMonth)) + sSeparator + (String(iYear))) to dRetVal
98566>>>>>    End
98566>>>>>>
98566>>>>>    If iFormat Eq DF_DATE_MILITARY Begin
98568>>>>>        Move ( (String(iYear)) + sSeparator + (String(iMonth)) + sSeparator + (String(iDay))) to dRetVal
98569>>>>>    End
98569>>>>>>
98569>>>>>    Function_Return dRetVal
98570>>>>>End_Function
98571>>>>>
98571>>>>>// Creates a time stamp which is a Number value which contains Date,Time in Seconds.
98571>>>>>Function MKCreateTimeStamp Global Date dDat Integer iH Integer iM Integer is Returns Number
98573>>>>>    Number nDays
98573>>>>>    Number  nRet
98573>>>>>    Move dDat                                   to nDays
98574>>>>>    Move ((nDays*24*3600)+(iH*3600)+(iM*60)+is) to nRet
98575>>>>>    Function_Return nRet
98576>>>>>End_Function
98577>>>>>
98577>>>>>// Does a correction of the DateValue becouse the native command gets only 2 digit!
98577>>>>>
98577>>>>>// Retrieves the FILETIME with the command above and creates a TimeStamp out of it.
98577>>>>>// Changed to workaround a bug in vdf's get_file_mod_time. 16.05.01 Bernhard
98577>>>>>Function MKTimeStampOfFile Global String sFile Returns Number
98579>>>>>    Date dDat
98579>>>>>    Number nH nM nS
98579>>>>>    String sDir sFILETIME_ft sSYSTEMTIME_ft sFindData sDirSep
98579>>>>>    Pointer pFile pFILETIME_ft pSYSTEMTIME_ft pFindData
98579>>>>>    Integer iRet iYear iDay iMonth
98579>>>>>    Handle hFile
98579>>>>>
98579>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
98580>>>>>    If (Left(sFile, 2) = ("." + sDir)) Begin
98582>>>>>        Get_Current_Directory to sDir
98583>>>>>        Move (Replace(("." + sDir), sFile, "")) to sFile
98584>>>>>        Move (sDir + sDir + sFile) to sFile
98585>>>>>    End
98585>>>>>>
98585>>>>>
98585>>>>>    Move (sFile + (Character(0))) to sFile
98586>>>>>    GetAddress of sFile to pFile
98587>>>>>    Move (OemToAnsi(pFile,pFile)) to iRet
98588>>>>>    ZeroType WIN32_FIND_DATA_ft to sFindData
98589>>>>>    GetAddress of sFindData to pFindData
98590>>>>>    Move (FindFirstFile(pFile,pFindData)) to hFile
98591>>>>>
98591>>>>>    If hFile Gt 0 Begin
98593>>>>>        GetBuff_String From sFindData At WIN32_FIND_DATA_ft.ftLastWriteTime to sFILETIME_ft
98594>>>>>        ZeroType SYSTEMTIME_ft to sSYSTEMTIME_ft
98595>>>>>        GetAddress of sFILETIME_ft to pFILETIME_ft
98596>>>>>        GetAddress of sSYSTEMTIME_ft to pSYSTEMTIME_ft
98597>>>>>        Move (FiletimeToSystemtime(pFILETIME_ft,pSYSTEMTIME_ft)) to iRet
98598>>>>>        If (iRet) Begin
98600>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wYear to iYear
98601>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMonth to iMonth
98602>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wDay to iDay
98603>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wHour to nH
98604>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMinute to nM
98605>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wSecond to nS
98606>>>>>            Move (MKConvertYearMonthDay(Self,iYear,iMonth,iDay)) to dDat
98607>>>>>        End
98607>>>>>>
98607>>>>>        Move (FindClose(hFile)) to iRet
98608>>>>>    End
98608>>>>>>
98608>>>>>    Function_Return (MKCreateTimeStamp(dDat,nH,nM,nS))
98609>>>>>End_Function
98610>>>>>
98610>>>>>// Delivers a string with the file date and time.
98610>>>>>Function MKFileTimeString Global String sFile Returns String
98612>>>>>    Date dDat
98612>>>>>    Number nH nM nS
98612>>>>>    String sDir sFILETIME_ft sSYSTEMTIME_ft sFindData sDirSep
98612>>>>>    Pointer pFile pFILETIME_ft pSYSTEMTIME_ft pFindData
98612>>>>>    Integer iRet iYear iDay iMonth
98612>>>>>    Handle hFile
98612>>>>>    String sRet
98612>>>>>
98612>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
98613>>>>>    If (Left(sFile,2) = ("." + sDirSep)) Begin
98615>>>>>        Get_Current_Directory to sDir
98616>>>>>        Move (Replace(("." + sDir), sFile, "")) to sFile
98617>>>>>        Move (sDir + sDir + sFile) to sFile
98618>>>>>    End
98618>>>>>>
98618>>>>>
98618>>>>>    Move (sFile + (Character(0))) to sFile
98619>>>>>    GetAddress of sFile to pFile
98620>>>>>    Move (OemToAnsi(pFile,pFile)) to iRet
98621>>>>>    ZeroType WIN32_FIND_DATA_ft to sFindData
98622>>>>>    GetAddress of sFindData to pFindData
98623>>>>>    Move (FindFirstFile(pFile,pFindData)) to hFile
98624>>>>>
98624>>>>>    If hFile Gt 0 Begin
98626>>>>>        GetBuff_String From sFindData At WIN32_FIND_DATA_ft.ftLastWriteTime to sFILETIME_ft
98627>>>>>        ZeroType SYSTEMTIME_ft to sSYSTEMTIME_ft
98628>>>>>        GetAddress of sFILETIME_ft to pFILETIME_ft
98629>>>>>        GetAddress of sSYSTEMTIME_ft to pSYSTEMTIME_ft
98630>>>>>        Move (FiletimeToSystemtime(pFILETIME_ft,pSYSTEMTIME_ft)) to iRet
98631>>>>>        If (iRet) Begin
98633>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wYear to iYear
98634>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMonth to iMonth
98635>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wDay to iDay
98636>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wHour to nH
98637>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMinute to nM
98638>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wSecond to nS
98639>>>>>            Move (MKConvertYearMonthDay(Self,iYear,iMonth,iDay)) to dDat
98640>>>>>        End
98640>>>>>>
98640>>>>>        Move (FindClose(hFile)) to iRet
98641>>>>>    End
98641>>>>>>
98641>>>>>    Append sRet dDat " " (Right(Append("0",nH),2)) ":" (Right(Append("0",nM),2)) ":" (Right(Append("0",nS),2))
98648>>>>>    Function_Return sRet
98649>>>>>End_Function
98650>>>>>
98650>>>>>Define FILE_ATTRIBUTE_READONLY  For |CI$00000001
98650>>>>>Define FILE_ATTRIBUTE_ARCHIVE   For |CI$00000020
98650>>>>>
98650>>>>>// Retrieves the FILETIME_ft with the command above and creates a TimeStamp out of it.
98650>>>>>// Changed to workaround a bug in vdf's get_file_mod_time. 16.05.01 Bernhard
98650>>>>>Function MKAttribOfFile Global String sFile Returns DWord // **WvA: 18-3-2003 This is not a number according to VDF8
98652>>>>>    String sDir sFindData sDirSep
98652>>>>>    Pointer pFile pFindData
98652>>>>>    Integer iRet iAttr
98652>>>>>    Handle hFile
98652>>>>>
98652>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
98653>>>>>    If (Left(sFile, 2) = ("." + sDirSep)) Begin
98655>>>>>        Get_Current_Directory to sDir
98656>>>>>        Move (Replace(("." + sDir), sFile, "")) to sFile
98657>>>>>        Move (sDir + sDir + sFile) to sFile
98658>>>>>    End
98658>>>>>>
98658>>>>>
98658>>>>>    Move (sFile + (Character(0))) to sFile
98659>>>>>    GetAddress of sFile to pFile
98660>>>>>    Move (OemToAnsi(pFile,pFile)) to iRet
98661>>>>>    ZeroType WIN32_FIND_DATA_ft to sFindData
98662>>>>>    GetAddress of sFindData to pFindData
98663>>>>>    Move (FindFirstFile(pFile,pFindData)) to hFile
98664>>>>>
98664>>>>>    If hFile Gt 0 Begin
98666>>>>>        GetBuff From sFindData At WIN32_FIND_DATA_ft.dwFileAttributes to iAttr
98667>>>>>        Move (FindClose(hFile)) to iRet
98668>>>>>    End
98668>>>>>>
98668>>>>>    Else Begin
98669>>>>>        Move -1 to iAttr
98670>>>>>    End
98670>>>>>>
98670>>>>>    Function_Return iAttr
98671>>>>>End_Function
98672>>>>>
98672>>>>>// Delivers true when the given file has the Readonly attribute set to true.
98672>>>>>Function MKisFileReadOnly Global String sFile Returns Integer
98674>>>>>    Function_Return (MKAttribOfFile(sFile) Iand FILE_ATTRIBUTE_READONLY)
98675>>>>>End_Function
98676>>>Use vWin32fh.pkg
98676>>>Use cFunctionsDataDictionary.dd
98676>>>
98676>>>Activate_View Activate_oEditorView_vw For oEditorView_vw
98686>>>>
98686>>>Object oEditorView_vw is a cRefactorDbView
98688>>>    Set Size to 263 492
98689>>>    Set Border_Style to Border_Thick
98690>>>    Set Maximize_Icon to True
98691>>>    Set Label to "Refactoring Editor"
98692>>>    Set pbAutoActivate to True
98693>>>    Set pbAcceptDropFiles to True
98694>>>    Set Icon to "Editor.ico"
98695>>>    Set Label to "Editor used by 'Editor Function' types"
98696>>>    Set phoEditorView of ghoApplication to Self
98697>>>
98697>>>    Object oEditor_edt is a cScintillaRefactorEditor
98699>>>        Set Size to 248 473
98700>>>        Set Location to 8 10
98701>>>        Set peAnchors to anAll
98702>>>        Set Enabled_State to False
98703>>>
98703>>>        Delegate Set phoEditor to (Self)
98705>>>        Set phoEditor of ghoApplication to (Self) 
98706>>>        Property Boolean piInSetFocus False
98708>>>
98708>>>        Function RefactorSourceFileInEditor  String[] ByRef asSourceFile Returns Boolean
98711>>>            Integer iFunctionsSelected iFunctionID
98711>>>            Boolean bFound bChanged bOK
98711>>>            String sFunctionName sParameter 
98711>>>            String[] asSourceFileNew 
98712>>>                                                                  
98712>>>            Move False to Err
98713>>>            Move 0 to LastErr
98714>>>            Move False to bChanged
98715>>>            
98715>>>            Send UpdateStatusBar "Updating source code in editor..." False
98716>>>            Get WriteDataToEditor asSourceFile to bOK
98717>>>            Send Activate
98718>>>            
98718>>>            Constraint_Set Self Clear  
98720>>>            Constrained_Clear eq FunctionsA by Index.4
98723>>>            Constrain FunctionsA.Selected eq True
98725>>>            Constrain FunctionsA.Type eq eEditor_Function
98727>>>            Constrained_Find First FunctionsA by Index.4
98732>>>            
98732>>>            While (Found = True)
98736>>>                Move (Trim(FunctionsA.Parameter)) to sParameter
98737>>>                Move (Lowercase(Trim(FunctionsA.Function_Name))) to sFunctionName 
98738>>>                Move (Eval("get_" - (sFunctionName))) to iFunctionID             
98739>>>                If (sFunctionName = CS_EditorDropSelf) Begin
98741>>>                    Send Stop_StatusPanel of ghoStatusPanel
98742>>>                End
98742>>>>
98742>>>                Get iFunctionID of ghoRefactorFunctionLibrary asSourceFile sParameter to bChanged
98743>>>                If (sFunctionName = CS_EditorDropSelf) Begin
98745>>>                    Send Start_StatusPanel of ghoStatusPanel
98746>>>                End
98746>>>>
98746>>>                If (bChanged = True) Begin                        
98748>>>                    Reread FunctionsA
98752>>>                        Add 1 to FunctionsA.Count  
98753>>>                        SaveRecord FunctionsA
98754>>>                    Unlock
98755>>>>
98755>>>                End
98755>>>>
98755>>>                Constrained_Find Next
98756>>>            Loop
98757>>>>
98757>>>
98757>>>            Get EditorDataAsStringArray to asSourceFileNew
98758>>>            Move (not(IsSameArray(asSourceFileNew, asSourceFile))) to bChanged
98759>>>            If (bChanged = True) Begin
98761>>>                Move asSourceFileNew to asSourceFile
98762>>>            End
98762>>>>
98762>>>            
98762>>>            // To not get an "Editor change" data loss message when exiting program.
98762>>>            Set Changed_State to False
98763>>>            Function_Return bChanged
98764>>>        End_Function
98765>>>
98765>>>        // We con't care about potential data loss here.
98765>>>        Function pbShouldSave Returns Boolean
98768>>>            Function_Return False
98769>>>        End_Function
98770>>>
98770>>>        // Note: We need this "intermediate" procedure because the phoMainPanel property
98770>>>        //       is zero when the program starts - which generates a runtime error.
98770>>>        Procedure SwitchNextView
98773>>>            Send Switch_Next_View of (Client_Id(phoMainPanel(ghoApplication)))
98774>>>        End_Procedure
98775>>>
98775>>>        Object oIdleHandler is a cIdleHandler 
98777>>>            Procedure OnIdle
98780>>>                String sSWSFile
98780>>>                Get psSWSFile of ghoApplication to sSWSFile
98781>>>                Set Enabled_State to (sSWSFile <> "")
98782>>>            End_Procedure
98783>>>        End_Object
98784>>>
98784>>>        Procedure Activating
98787>>>            Forward Send Activating
98789>>>            Set pbEnabled of oIdleHandler to True
98790>>>        End_Procedure
98791>>>    
98791>>>        Procedure Deactivating
98794>>>            Set pbEnabled of oIdleHandler to False
98795>>>            Forward Send DeActivating 
98797>>>        End_Procedure
98798>>>
98798>>>        // This short-cut key will keep the UI consistent, as the editor was "grabbing" this
98798>>>        // key combination and did nothing, but everywhere else it flips through the views/tab-pages.
98798>>>        On_Key Key_Ctrl+Key_Tab Send SwitchNextView
98799>>>        On_Key Key_Ctrl+Key_S   Send Request_Save
98800>>>    End_Object
98801>>>
98801>>>    // Allow a .sws file, source file or folder to be dropped on the view:
98801>>>    Procedure OnFileDropped String sFilename Boolean bLast
98804>>>        String sFileExt sSWSFile
98804>>>        Boolean bFile bFolder bSWSFile
98804>>>        Handle hoEditor
98804>>>
98804>>>        Get phoEditor of ghoApplication to hoEditor
98805>>>        Forward Send OnFileDropped sFilename bLast
98807>>>
98807>>>        // Try to find out if a file or a folder name
98807>>>        // was dropped on the view:
98807>>>        If (bLast = True) Begin
98809>>>            Get ParseFileExtension sFilename to sFileExt
98810>>>            Move (Lowercase(sFileExt)) to sFileExt
98811>>>            Move (sFileExt = "")    to bFolder
98812>>>            Move (sFileExt = "sws") to bSWSFile
98813>>>            Move (bSWSFile = False and bFolder = False) to bFile
98814>>>            If (bFile = True) Begin
98816>>>                Get psSWSFile of ghoApplication to sSWSFile
98817>>>                If (sSWSFile = "") Begin
98819>>>                    Send Info_Box "You need to select a workspace first."
98820>>>                    Procedure_Return
98821>>>                End
98821>>>>
98821>>>                Send UpdateSourceFileNameDisplay of ghoApplication sFileName
98822>>>                Send LoadFile of hoEditor sFilename
98823>>>                Send Activate_oEditorView_vw
98824>>>                Set pbWorkspaceMode of ghoApplication to False
98825>>>            End
98825>>>>
98825>>>            Else Begin
98826>>>                Send UpdateWorkspaceSelectorDisplay of ghoApplication sFilename
98827>>>                Set pbWorkspaceMode of ghoApplication to True
98828>>>            End
98828>>>>
98828>>>        End
98828>>>>
98828>>>        Else Begin
98829>>>            Send Info_Box "Only one file can be dropped on the view. The last file will be used."
98830>>>        End
98830>>>>
98830>>>    End_Procedure
98831>>>
98831>>>    Procedure OnSetFocus
98834>>>        Set piActiveView of ghoApplication to CI_CodeIndenter Self
98835>>>    End_Procedure
98836>>>
98836>>>    Object oView_IdleHandler is a cIdleHandler
98838>>>        Set pbEnabled to True
98839>>>        Procedure OnIdle
98842>>>            String sSWSFile
98842>>>            Get psSWSFile of ghoApplication to sSWSFile
98843>>>            Set Enabled_State to (sSWSFile <> "")
98844>>>        End_Procedure
98845>>>    End_Object
98846>>>
98846>>>    Procedure Activate_View Returns Integer
98849>>>        String sSourceFilename   
98849>>>
98849>>>        Forward Send Activate_View
98851>>>
98851>>>        Get psCurrentSourceFileName of ghoApplication to sSourceFilename
98852>>>        If (sSourceFilename <> "") Begin
98854>>>            Send UpdateSourceFileNameDisplay of ghoApplication sSourceFilename
98855>>>            Send Top_of_Panel
98856>>>        End
98856>>>>
98856>>>
98856>>>    End_Procedure
98857>>>
98857>>>    Procedure End_Construct_Object
98860>>>        Forward Send End_Construct_Object
98862>>>        // Define the save procedure for the editor object.
98862>>>        Send DefineOnKey of (phoEditor(ghoApplication)) CMD_FileSaveAll msg_Request_Save
98863>>>    End_Procedure
98864>>>    
98864>>>    // We con't care about potential data loss here.
98864>>>    Function pbShouldSave Returns Boolean
98867>>>        Function_Return False
98868>>>    End_Function
98869>>>        
98869>>>End_Object
98870>
98870>        Use oEditorProperties.pkg
98870>        Use ProgramSetup.dg
Including file: ProgramSetup.dg    (C:\Projects\DF18\DfRefactor\AppSrc\ProgramSetup.dg)
98870>>>Use Dfspnfrm.pkg
98870>>>Use cLinkLabel.pkg
Including file: cLinkLabel.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cLinkLabel.pkg)
98870>>>>>Use Windows.pkg
98870>>>>>Use GlobalFunctionsProcedures.pkg
98870>>>>>Use Commctrl.pkg
98870>>>>>Use tWinStructs.pkg
98870>>>>>Use CharTranslate.pkg
98870>>>>>
98870>>>>>// we use container3d because it has better next/previous navigation logic
98870>>>>>// we use a container because it works better (fonts and things are correct)
98870>>>>>Class cLinkLabel is a container3d
98871>>>>>    
98871>>>>>    Import_Class_Protocol Label_Mixin
98872>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
98873>>>>>    
98873>>>>>    Procedure Construct_Object
98875>>>>>        Boolean bSupported
98875>>>>>        Forward Send Construct_Object
98877>>>>>        
98877>>>>>        
98877>>>>>        Send Define_ToolTip_Support_Mixin
98878>>>>>        
98878>>>>>        // determines if enter key opens link or is passed to parent
98878>>>>>        Property Boolean pbEnterPassThrough False
98879>>>>>        
98879>>>>>        // if true, height is adjusted to fit width and text
98879>>>>>        Property Boolean pbAutoSizeHeight True
98880>>>>>        
98880>>>>>        
98880>>>>>        // Setting this allows it to take the DataFlex focus. Don't change!
98880>>>>>        Set Client_Area_State to False
98881>>>>>        
98881>>>>>        // only supported in XP and above. If not supported, you get no useful control
98881>>>>>        Get IsControlSupported to bSupported
98882>>>>>        If not bSupported Begin
98884>>>>>            Send OnControlNotSupported
98885>>>>>            Procedure_Return
98886>>>>>        End
98886>>>>>>
98886>>>>>        
98886>>>>>        Set Color to clBtnFace
98887>>>>>        Set Size to 14 100
98888>>>>>        Set Border_Style to Border_None
98889>>>>>        // if True, the links are not navigated to via keyboard.
98889>>>>>        Set Skip_State to True
98890>>>>>        // needed by tooltip
98890>>>>>        Set pbUseFormWindowHandle to False
98891>>>>>        
98891>>>>>        Set External_Class_Name "DFSysLink" to "SysLink"
98892>>>>>        //Set Window_Style LWS_TRANSPARENT to True
98892>>>>>        Set Window_Style WS_CLIPCHILDREN to False
98893>>>>>        // to be consistent with other VDF controls like TextBox
98893>>>>>        Set Window_Style WS_CLIPSIBLINGS to True
98894>>>>>        Set External_Message WM_NOTIFY to msg_Notify
98895>>>>>        
98895>>>>>    End_Procedure
98896>>>>>    
98896>>>>>    // control is only supported in XP (5.1) and above.
98896>>>>>    Function IsControlSupported Returns Boolean
98898>>>>>        Integer iMajor iMinor
98898>>>>>        Boolean bSupported
98898>>>>>        // this is supported in 5.1 and above
98898>>>>>        Move (SysConf(SYSCONF_COMCTL_REV)) to iMajor
98899>>>>>        Move (Low(iMajor)) to iMinor
98900>>>>>        Move (Hi(iMajor)) to iMajor
98901>>>>>        // Check for XP or above (5.1 or above)
98901>>>>>        Move (iMajor>5 or (iMajor=5 and iMinor>0)) to bSupported
98902>>>>>        Function_Return bSupported
98903>>>>>    End_Function
98904>>>>>    
98904>>>>>    // augmented to handle NC_CLICK and NM_RETURN
98904>>>>>    Procedure Notify Longptr wParam Longptr lParam
98906>>>>>        tWinNmHdr Hdr
98906>>>>>        tWinNmHdr Hdr
98906>>>>>        tWinNmLink nmLink
98906>>>>>        tWinNmLink nmLink
98906>>>>>        tWinLItem LItem
98906>>>>>        tWinLItem LItem
98906>>>>>        Boolean bOk bPass
98906>>>>>        Integer i
98906>>>>>        String sID sUrl
98906>>>>>        
98906>>>>>        Move (MemCopy(AddressOf(Hdr),lParam,SizeOfType(tWinNmHdr))) to i
98907>>>>>        If (Hdr.code=NM_CLICK or Hdr.code=NM_RETURN) Begin
98909>>>>>            If (Hdr.code=NM_CLICK) Begin
98911>>>>>                // if click, the LItem data is passed to us
98911>>>>>                Move (MemCopy(AddressOf(nmLink),lParam,SizeOfType(tWinNmLink))) to i
98912>>>>>                Move nmLink.item to LItem
98913>>>>>            End
98913>>>>>>
98913>>>>>            Else Begin
98914>>>>>                // do nothing is we pass Enters through
98914>>>>>                Get pbEnterPassThrough to bPass
98915>>>>>                If bPass Begin
98917>>>>>                    Procedure_Return
98918>>>>>                End
98918>>>>>>
98918>>>>>                // If Enter, we need to see which item has the focus.
98918>>>>>                Get GetCurrentItem (&LItem) to bOK
98919>>>>>                If not bOk Begin
98921>>>>>                    Procedure_Return
98922>>>>>                End
98922>>>>>>
98922>>>>>            End
98922>>>>>>
98922>>>>>            
98922>>>>>            Get GetLItemIDtoString LItem to sID
98923>>>>>            Get GetLItemURLtoString LItem to sUrl
98924>>>>>            Send OnClick LItem.iLink sID sUrl
98925>>>>>            
98925>>>>>        End
98925>>>>>>
98925>>>>>        
98925>>>>>    End_Procedure
98926>>>>>    
98926>>>>>    // get the ideal GUI height based on current GUI width and size of text
98926>>>>>    Function IdealGUIHeight Returns Integer
98928>>>>>        Integer iSize iGuiHeight
98928>>>>>        Handle hWnd
98928>>>>>        tWinSize Size1
98928>>>>>        tWinSize Size1
98928>>>>>        
98928>>>>>        Get Window_Handle to hWnd
98929>>>>>        If (hWnd=0) Begin
98931>>>>>            Error DFERR_PROGRAM "LM_GETIDEALSIZE has been called before the windows control is paged"
98932>>>>>>
98932>>>>>            Function_Return
98933>>>>>        End
98933>>>>>>
98933>>>>>        
98933>>>>>        Get GuiSize to iSize
98934>>>>>        Move (WindowsMessage( LM_GETIDEALSIZE, low(iSize), AddressOf(Size1))) to iGuiHeight
98935>>>>>        Function_Return iGuiHeight
98936>>>>>    End_Function
98937>>>>>    
98937>>>>>    // set the controls height to make it fit
98937>>>>>    Procedure AutoSizeHeight
98939>>>>>        Integer iSize iHeight
98939>>>>>        Get Size to iSize
98940>>>>>        Get IdealGUIHeight to iHeight
98941>>>>>        Get GuiToDialog iHeight 0 to iHeight
98942>>>>>        Set Size to (hi(iHeight)) (Low(iSize))
98943>>>>>    End_Procedure
98944>>>>>    
98944>>>>>    // get item by item number. Returns the item data byref in a tWinLItem struct and
98944>>>>>    // returns true if the item existed. Note that the string data returns in Unicode.
98944>>>>>    Function GetItem Integer iItem tWinLItem ByRef LItem Returns Boolean
98946>>>>>        Integer iRet
98946>>>>>        Move iItem to Litem.iLink
98947>>>>>        Move (LIS_ENABLED ior LIS_FOCUSED ior LIS_VISITED ior LIS_HOTTRACK ior LIS_DEFAULTCOLORS) to Litem.stateMask
98948>>>>>        Move (LIF_ITEMID ior LIF_ITEMINDEX ior LIF_STATE ior LIF_URL) to Litem.Mask
98949>>>>>        Move (WindowsMessage( LM_GETITEM, 0, AddressOf(Litem))) to iRet
98950>>>>>        Function_Return (iRet<>0)
98951>>>>>    End_Function
98952>>>>>    
98952>>>>>    // get the item current, the item that has the windows focus.
98952>>>>>    // Returns the item data ByRef in a tWinLItem Struct and
98952>>>>>    // returns true if a current focus item exists. If the object does not have the
98952>>>>>    // focus there is no current item.
98952>>>>>    Function GetCurrentItem tWinLItem ByRef LItem Returns Boolean
98954>>>>>        Integer iRet i
98954>>>>>        Boolean bOk
98954>>>>>        Repeat
98954>>>>>>
98954>>>>>            Get GetItem i (&LItem) to bOk
98955>>>>>            If (bOk and (LItem.state iand LIS_FOCUSED)) Begin
98957>>>>>                Function_Return True
98958>>>>>            End
98958>>>>>>
98958>>>>>            Increment i
98959>>>>>        Until (not(bOk))
98961>>>>>        Function_Return False
98962>>>>>        
98962>>>>>    End_Function
98963>>>>>    
98963>>>>>    // pass utf16 in pointer and return an OEM string
98963>>>>>    Function UniCodeToString Address pWideBuf Integer iWideLen Returns String
98965>>>>>        String sID
98965>>>>>        Address pOEMBuf
98965>>>>>        Integer iOk
98965>>>>>        
98965>>>>>        Move (Utf16ToOemBuffer(pWideBuf,iWideLen)) to pOEMBuf
98966>>>>>        Move (Repeat(Character(0),iWideLen)) to sID
98967>>>>>        Move (MemCopy(AddressOf(sID),pOEMBuf,iWideLen)) to iOk
98968>>>>>        Move (Free(pOEMBuf)) to iOk
98969>>>>>        
98969>>>>>        Function_Return (CString(sID))
98970>>>>>    End_Function
98971>>>>>    
98971>>>>>    // convert unicode ID string in tWinLItem to an OEM string
98971>>>>>    Function GetLItemIDtoString tWinLItem LItem Returns String
98973>>>>>        Address pWideBuf
98973>>>>>        String sID
98973>>>>>        
98973>>>>>        Move (AddressOf(LItem.szID)) to pWideBuf
98974>>>>>        Get UniCodeToString pWideBuf MAX_LINKID_TEXT to sID
98975>>>>>        Function_Return sID
98976>>>>>    End_Function
98977>>>>>    
98977>>>>>    // convert unicode URL string in tWinLItem to an OEM string
98977>>>>>    Function GetLItemURLtoString tWinLItem LItem Returns String
98979>>>>>        Address pWideBuf
98979>>>>>        String sID
98979>>>>>        
98979>>>>>        Move (AddressOf(LItem.szUrl)) to pWideBuf
98980>>>>>        Get UniCodeToString pWideBuf L_MAX_URL_LENGTH to sID
98981>>>>>        Function_Return sID
98982>>>>>    End_Function
98983>>>>>    
98983>>>>>    
98983>>>>>    // augmented to switch to next item and then switch to next object
98983>>>>>    Procedure Next
98985>>>>>        tWinLItem LItem
98985>>>>>        tWinLItem LItem
98985>>>>>        Boolean bOK
98985>>>>>        Get GetCurrentItem (&LItem) to Bok
98986>>>>>        If bOK Begin
98988>>>>>            // if next item exists, let windows handle this.
98988>>>>>            Get GetItem (LItem.iLink+1) (&LItem) to bOK
98989>>>>>            If bOK Begin
98991>>>>>                Set Windows_Override_State to False
98992>>>>>                Procedure_Return
98993>>>>>            End
98993>>>>>>
98993>>>>>        End
98993>>>>>>
98993>>>>>        Forward Send Next
98995>>>>>    End_Procedure
98996>>>>>    
98996>>>>>    // augmented to switch to the previuous item and then switch to previous object
98996>>>>>    Procedure Previous
98998>>>>>        tWinLItem LItem
98998>>>>>        tWinLItem LItem
98998>>>>>        Boolean bOK
98998>>>>>        Get GetCurrentItem (&LItem) to Bok
98999>>>>>        // if prior item exists, let windows handle this.
98999>>>>>        If (bOK and LItem.iLink>0) Begin
99001>>>>>            Set Windows_Override_State to False
99002>>>>>            Procedure_Return
99003>>>>>        End
99003>>>>>>
99003>>>>>        Forward Send Previous
99005>>>>>    End_Procedure
99006>>>>>    
99006>>>>>    // augmented to determine if an Enter should be handled here or passed to
99006>>>>>    // the container.
99006>>>>>    Procedure Default_action
99008>>>>>        Boolean bPass
99008>>>>>        Get pbEnterPassThrough to bPass
99009>>>>>        If bPass Begin
99011>>>>>            Forward Send Default_action
99013>>>>>        End
99013>>>>>>
99013>>>>>        Else Begin
99014>>>>>            Set Windows_Override_State to False
99015>>>>>        End
99015>>>>>>
99015>>>>>    End_Procedure
99016>>>>>    
99016>>>>>    // augmented to only page if the control is supported and to
99016>>>>>    // autosize as needed
99016>>>>>    Procedure Page Integer iPageObject
99018>>>>>        Boolean bAutoSize bSupported
99018>>>>>        Integer iSize iHeight
99018>>>>>        
99018>>>>>        Get IsControlSupported to bSupported
99019>>>>>        If not bSupported Begin
99021>>>>>            Procedure_Return
99022>>>>>        End
99022>>>>>>
99022>>>>>        
99022>>>>>        Forward Send Page iPageObject
99024>>>>>        
99024>>>>>        If (iPageObject=1) Begin
99026>>>>>            Send Shadow_Display // synch enabled_state
99027>>>>>            Get pbAutoSizeHeight to bAutoSize
99028>>>>>            If bAutoSize Begin
99030>>>>>                Send AutoSizeHeight
99031>>>>>            End
99031>>>>>>
99031>>>>>        End
99031>>>>>>
99031>>>>>    End_Procedure
99032>>>>>    
99032>>>>>    // augmented to handle tooltips
99032>>>>>    Procedure Page_Object Integer iState
99034>>>>>        Handle hWnd
99034>>>>>        Get Window_Handle to hWnd
99035>>>>>        Forward Send Page_Object iState
99037>>>>>        
99037>>>>>        // Handle tooltip support....
99037>>>>>        If (iState = 0) Begin
99039>>>>>            Send RequestDeleteToolTip
99040>>>>>        End
99040>>>>>>
99040>>>>>        Else Begin
99041>>>>>            Send RequestAddToolTip
99042>>>>>        End
99042>>>>>>
99042>>>>>        
99042>>>>>    End_Procedure
99043>>>>>    
99043>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
99043>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
99043>>>>>    // is implemented in a mixin class.
99043>>>>>    Procedure RequestAddToolTip
99045>>>>>        Send AddToolTip
99046>>>>>    End_Procedure
99047>>>>>    
99047>>>>>    
99047>>>>>    // Called by Page_Object. Handles tooltip removal.
99047>>>>>    Procedure RequestDeleteToolTip
99049>>>>>        Send DeleteToolTip
99050>>>>>    End_Procedure
99051>>>>>    
99051>>>>>    // augmented to autosize as needed.
99051>>>>>    Procedure Set Value Integer iItem String sValue
99053>>>>>        Boolean bAutoSize
99053>>>>>        Forward Set Value to sValue
99055>>>>>        // only autosize if paged and we allow autosizing
99055>>>>>        If (Window_Handle(Self)) Begin
99057>>>>>            Get pbAutoSizeHeight to bAutoSize
99058>>>>>            If bAutoSize Begin
99060>>>>>                Send AutoSizeHeight
99061>>>>>            End
99061>>>>>>
99061>>>>>        End
99061>>>>>>
99061>>>>>    End_Procedure
99062>>>>>    
99062>>>>>    // default OnClick behavior shells and executes the URL if one exists. If Id is used
99062>>>>>    // or you wish other things with your url you must augment this.
99062>>>>>    Procedure OnClick Integer iItem String sID String sUrl
99064>>>>>        
99064>>>>>        If (sUrl<>"") Begin
99066>>>>>            Runprogram Shell Background sUrl
99067>>>>>        End
99067>>>>>>
99067>>>>>        
99067>>>>>    End_Procedure
99068>>>>>    
99068>>>>>    // sent if this is run on a pre-XP system. This could be augmented to raise
99068>>>>>    // an error, warning or whatever.
99068>>>>>    Procedure OnControlNotSupported
99070>>>>>    End_Procedure
99071>>>>>    
99071>>>>>    
99071>>>>>    Procedure Enable_Window Integer iState
99073>>>>>        Handle hWnd
99073>>>>>        Get Window_Handle to hWnd
99074>>>>>        If hWnd Begin
99076>>>>>            // note that disabling the control makes no visual change but it does make it
99076>>>>>            // impossible to select the item
99076>>>>>            Move (EnableWindow(hWnd,iState)) to hWnd
99077>>>>>        End
99077>>>>>>
99077>>>>>    End_Procedure
99078>>>>>    
99078>>>>>    // must override because container class does nothing here.
99078>>>>>    Procedure Shadow_Display
99080>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
99081>>>>>    End_Procedure
99082>>>>>    
99082>>>>>End_Class
99083>>>Use cRegistry.pkg
99083>>>Use cRDCDbModalPanel.pkg
99083>>>Use cRDCDbHeaderGroup.pkg
99083>>>Use cRDCButtonDPI.pkg
99083>>>Use cRDCCheckbox.pkg
Including file: cRDCCheckbox.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCCheckbox.pkg)
99083>>>>>//****************************************************************************
99083>>>>>// $Module type: Package
99083>>>>>// $Module name: cRDCCheckbox.pkg
99083>>>>>//
99083>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
99083>>>>>// Copyright (c) 2016 RDC Tools International
99083>>>>>// E-mail      : support@rdctools.com
99083>>>>>// Web-site    : http://www.rdctools.com
99083>>>>>//
99083>>>>>// Created     : 2016-01-05 @ 19:04 (Military date format - Year-Month-Day)
99083>>>>>//
99083>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
99083>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
99083>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
99083>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
99083>>>>>// in the help folder for more details.
99083>>>>>//
99083>>>>>//****************************************************************************
99083>>>>>Use Windows.pkg
99083>>>>>
99083>>>>>// Used by the "Page" message below to show
99083>>>>>// a rectangle around ComboForm and Checkbox objects.
99083>>>>>
99083>>>>>Register_Function private.phoCheckBox Returns Handle
99083>>>>>
99083>>>>>Class _CheckBoxTextBox is a TextBox
99084>>>>>
99084>>>>>    Procedure Mouse_Down integer iWindowNumber integer iPosition
99086>>>>>        Handle hoParent
99086>>>>>        Get private.phoCheckBox to hoParent
99087>>>>>        Forward Send Mouse_Down iWindowNumber iPosition
99089>>>>>        If (hoParent <> 0) Begin
99091>>>>>            Send DoToggle of hoParent
99092>>>>>        End
99092>>>>>>
99092>>>>>    End_Procedure
99093>>>>>End_Class
99094>>>>>
99094>>>>>Register_Procedure OnChangeEvent
99094>>>>>Register_Procedure Set private.Checked_State
99094>>>>>Register_Function private.Checked_State Returns Boolean
99094>>>>>Class _NewCheckBox is a CheckBox
99095>>>>>
99095>>>>>    Procedure DoToggle
99097>>>>>        Boolean bChecked
99097>>>>>        Get Checked_State to bChecked
99098>>>>>        Set Checked_State to (not(bChecked))
99099>>>>>    End_Procedure
99100>>>>>
99100>>>>>    Procedure OnChange
99102>>>>>        Boolean bState
99102>>>>>        Handle hoCheckBox
99102>>>>>
99102>>>>>        Forward Send OnChange
99104>>>>>        Get private.phoCheckBox to hoCheckBox
99105>>>>>        Get Checked_State to bState
99106>>>>>        Set private.Checked_State to bState
99107>>>>>        If (Desktop <> Self and hoCheckBox <> 0) Begin
99109>>>>>            Send OnChangeEvent
99110>>>>>        End
99110>>>>>>
99110>>>>>    End_Procedure
99111>>>>>
99111>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99111>>>>>    // The bug being that the focus rectangle doesn't show.
99111>>>>>    Procedure Page Integer iPageObject
99113>>>>>        Handle hWnd
99113>>>>>        Integer iRet iState
99113>>>>>
99113>>>>>        Forward Send Page iPageObject
99115>>>>>
99115>>>>>        If (iPageObject) Begin
99117>>>>>            Get Window_Handle to hWnd
99118>>>>>            If (hWnd) Begin
99120>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99121>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99123>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99124>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99125>>>>>                End
99125>>>>>>
99125>>>>>            End
99125>>>>>>
99125>>>>>        End
99125>>>>>>
99125>>>>>    End_Procedure
99126>>>>>
99126>>>>>End_Class
99127>>>>>
99127>>>>>// Intermediate class - don't use.
99127>>>>>Class _cCheckBoxContainer is a Container
99128>>>>>
99128>>>>>    Register_Object oInfo_tb
99128>>>>>
99128>>>>>    Procedure Construct_Object
99130>>>>>        Forward Send Construct_Object
99132>>>>>
99132>>>>>        Property String private.psImage
99133>>>>>        Property String private.psLabel
99134>>>>>        Property String private.psToolTip
99135>>>>>        Property Boolean private.Checked_State
99136>>>>>        Property Boolean private.Auto_Size_State True
99137>>>>>        Property Integer private.iHeight
99138>>>>>        Property Integer private.iWidth
99139>>>>>        Property Integer private.iRowPos
99140>>>>>        Property Integer private.iColPos
99141>>>>>        Property Handle private.phoCheckBox
99142>>>>>        Property Integer private.peAnchors
99143>>>>>
99143>>>>>        Property Boolean pbCreateInfoItem True
99144>>>>>
99144>>>>>        Set Border_Style to Border_None
99145>>>>>    End_Procedure
99146>>>>>
99146>>>>>    Procedure End_Construct_Object
99148>>>>>        Handle hoCheckBox
99148>>>>>        Integer iRowPos iColPos iSize
99148>>>>>        String sLabel sToolTip
99148>>>>>        Boolean bCreateInfoItem
99148>>>>>
99148>>>>>        Forward Send End_Construct_Object
99150>>>>>
99150>>>>>        Get pbCreateInfoItem to bCreateInfoItem
99151>>>>>        Get CreateNamed (RefClass(_NewCheckBox)) "oRDCCheckboxChild" to hoCheckBox
99152>>>>>        Set private.phoCheckBox to hoCheckBox
99153>>>>>        Set Auto_Size_State of hoCheckBox to (private.Auto_Size_State(Self))
99154>>>>>        Get private.psLabel to sLabel
99155>>>>>        Set Label of hoCheckBox to sLabel
99156>>>>>        Send Autosize of hoCheckBox sLabel
99157>>>>>        Set Checked_State of hoCheckBox to (private.Checked_State(Self))
99158>>>>>        Get Size of hoCheckBox to iSize
99159>>>>>
99159>>>>>        Set Location of hoCheckBox to (private.iRowPos(Self)) (private.iColPos(Self))
99160>>>>>        Get private.iRowPos to iRowPos
99161>>>>>        Get private.iColPos to iColPos
99162>>>>>        Get private.psToolTip to sToolTip
99163>>>>>        Set Status_Help of hoCheckBox to sToolTip
99164>>>>>
99164>>>>>        If (bCreateInfoItem = True and sToolTip <> "") Begin
99166>>>>>            Object oInfo_tb is a TextBox
99168>>>>>                Set Size to 10 10
99169>>>>>                Set Location to iRowPos (Low(iSize) + iColPos)
99170>>>>>                Set psToolTip to sToolTip
99171>>>>>                Set Bitmap to "ActionAbout.bmp"
99172>>>>>            End_Object
99173>>>>>        End
99173>>>>>>
99173>>>>>        Else Begin
99174>>>>>            Set psToolTip of hoCheckBox to sToolTip
99175>>>>>        End
99175>>>>>>
99175>>>>>
99175>>>>>    End_Procedure
99176>>>>>
99176>>>>>    Procedure OnChangeEvent
99178>>>>>    End_Procedure
99179>>>>>
99179>>>>>    Procedure Set Location Integer iRowPos Integer iColPos
99181>>>>>        Forward Set Location to iRowPos iColPos
99183>>>>>        If (iRowPos <> 0 and iColPos <> 0) Begin
99185>>>>>            Set private.iRowPos to iRowPos
99186>>>>>            Set private.iColPos to iColPos
99187>>>>>        End
99187>>>>>>
99187>>>>>    End_Procedure
99188>>>>>
99188>>>>>    Procedure Set psImage String sImage
99190>>>>>        Set private.psImage to sImage
99191>>>>>    End_Procedure
99192>>>>>
99192>>>>>    Function psImage Returns String
99194>>>>>        Function_Return (private.psImage(Self))
99195>>>>>    End_Function
99196>>>>>
99196>>>>>    // We support both the "Set Label" & "Set psLabel" interface.
99196>>>>>    Procedure Set psLabel String sLabel
99198>>>>>        Set private.psLabel to sLabel
99199>>>>>    End_Procedure
99200>>>>>
99200>>>>>    Function psLabel Returns String
99202>>>>>        Function_Return (private.psLabel(Self))
99203>>>>>    End_Function
99204>>>>>
99204>>>>>    Procedure Set Label String sLabel
99206>>>>>        Set psLabel to sLabel
99207>>>>>    End_Procedure
99208>>>>>
99208>>>>>    Function Label Returns String
99210>>>>>        Function_Return (private.psLabel(Self))
99211>>>>>    End_Function
99212>>>>>
99212>>>>>    Procedure Set Checked_State Boolean bState
99214>>>>>        Handle hoCheckBox
99214>>>>>        Set private.Checked_State to bState
99215>>>>>        Get private.phoCheckBox to hoCheckBox
99216>>>>>        If (hoCheckBox <> 0) Begin
99218>>>>>            Set Checked_State of hoCheckBox to bState
99219>>>>>        End
99219>>>>>>
99219>>>>>    End_Procedure
99220>>>>>
99220>>>>>    Function Checked_State Returns Boolean
99222>>>>>        Function_Return (private.Checked_State(Self))
99223>>>>>    End_Function
99224>>>>>
99224>>>>>    Procedure Set Auto_Size_State Boolean bState
99226>>>>>        Set private.Auto_Size_State to bState
99227>>>>>    End_Procedure
99228>>>>>
99228>>>>>    Function Auto_Size_State Returns Boolean
99230>>>>>        Function_Return (private.Auto_Size_State(Self))
99231>>>>>    End_Function
99232>>>>>
99232>>>>>    Procedure Set peAnchors Integer eAnchorMode
99234>>>>>        Forward Set peAnchors to eAnchorMode
99236>>>>>        Set private.peAnchors to eAnchorMode
99237>>>>>    End_Procedure
99238>>>>>
99238>>>>>    Function peAnchors Returns Integer
99240>>>>>        Function_Return (private.peAnchors(Self))
99241>>>>>    End_Function
99242>>>>>    Procedure Set psToolTip String sToolTip
99244>>>>>        Set private.psToolTip to sToolTip
99245>>>>>    End_Procedure
99246>>>>>
99246>>>>>    Function psToolTip Returns String
99248>>>>>        Function_Return (private.psToolTip(Self))
99249>>>>>    End_Function
99250>>>>>
99250>>>>>End_Class
99251>>>>>
99251>>>>>Class cRDCCheckBox is a _cCheckBoxContainer
99252>>>>>    Procedure Construct_Object
99254>>>>>        Forward Send Construct_Object
99256>>>>>        On_Key kSwitch Send Switch_Next_Area
99257>>>>>    End_Procedure
99258>>>>>
99258>>>>>    Procedure Set Checked_State Boolean bState
99260>>>>>        Forward Set Checked_State to bState
99262>>>>>    End_Procedure
99263>>>>>
99263>>>>>    Function Checked_State Returns Boolean
99265>>>>>        Function_Return (private.Checked_State(Self))
99266>>>>>    End_Function
99267>>>>>
99267>>>>>    Procedure Set Label String sLabel
99269>>>>>        Set psLabel to sLabel
99270>>>>>    End_Procedure
99271>>>>>
99271>>>>>    Function Label Returns String
99273>>>>>        Function_Return (private.psLabel(Self))
99274>>>>>    End_Function
99275>>>>>
99275>>>>>    Procedure Set psToolTip String sToolTip
99277>>>>>        String sStatusHelp
99277>>>>>
99277>>>>>        Get Status_Help to sStatusHelp
99278>>>>>        If (sStatusHelp = "") Begin
99280>>>>>            Set Status_Help to sToolTip
99281>>>>>        End
99281>>>>>>
99281>>>>>
99281>>>>>        Forward Set psToolTip to sToolTip
99283>>>>>    End_Procedure
99284>>>>>
99284>>>>>End_Class
99285>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
99285>>>>>//****************************************************************************
99285>>>>>// $Module type: Package
99285>>>>>// $Module name: cRDCComboform.pkg
99285>>>>>//
99285>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
99285>>>>>// Copyright (c) 2014 RDC Tools International
99285>>>>>// E-mail      : support@rdctools.com
99285>>>>>// Web-site    : http://www.rdctools.com
99285>>>>>//
99285>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
99285>>>>>//
99285>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
99285>>>>>//               The auto-size combo width logic was developed by Raveen.
99285>>>>>//
99285>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
99285>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
99285>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
99285>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
99285>>>>>// in the help folder for more details.
99285>>>>>//
99285>>>>>//****************************************************************************
99285>>>>>Use Windows.pkg
99285>>>>>
99285>>>>>// Used by the "Page" message below to show
99285>>>>>// a focus rectangle around ComboForm and Checkbox objects.
99285>>>>>
99285>>>>>Class cComboFormIdleHandler is a cIdleHandler
99286>>>>>    Procedure Construct_Object
99288>>>>>        Forward Send Construct_Object
99290>>>>>
99290>>>>>        Set Label_Row_Offset to 0
99291>>>>>        Set Label_Col_Offset to 2
99292>>>>>        Set Label_Justification_Mode to jMode_Right
99293>>>>>        Set Combo_Sort_State to False
99294>>>>>        Set Entry_State to False
99295>>>>>
99295>>>>>    End_Procedure
99296>>>>>
99296>>>>>    Procedure OnIdle
99298>>>>>        Delegate Send DoUpdate
99300>>>>>    End_Procedure
99301>>>>>
99301>>>>>End_Class
99302>>>>>
99302>>>>>Class cRDCComboForm is a ComboForm
99303>>>>>    Procedure Construct_Object
99305>>>>>        Forward Send Construct_Object
99307>>>>>
99307>>>>>        Property Boolean pbAutoListWidth True
99308>>>>>
99308>>>>>        Property Boolean pbAutoShadowLabelObject True
99309>>>>>
99309>>>>>        Property Boolean pbAutoEnable False
99310>>>>>        Set Label_Col_Offset to 2
99311>>>>>        Property Boolean pbEnabled True
99312>>>>>        Set Label_Justification_Mode to JMode_Right
99313>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
99314>>>>>
99314>>>>>    End_Procedure
99315>>>>>
99315>>>>>    Procedure End_Construct_Object
99317>>>>>        Boolean bAutoShadowLabelObject
99317>>>>>        String sTooltip sStatus_Help
99317>>>>>
99317>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
99318>>>>>        If (bAutoShadowLabelObject = True) Begin
99320>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
99321>>>>>        End
99321>>>>>>
99321>>>>>
99321>>>>>        Forward Send End_Construct_Object
99323>>>>>
99323>>>>>        Get psToolTip   to sTooltip
99324>>>>>        Get Status_Help to sStatus_Help
99325>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
99327>>>>>            Set psToolTip to sStatus_Help
99328>>>>>        End
99328>>>>>>
99328>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
99331>>>>>            Set Status_Help to sTooltip
99332>>>>>        End
99332>>>>>>
99332>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
99333>>>>>
99333>>>>>    End_Procedure
99334>>>>>
99334>>>>>    Procedure DoUpdate
99336>>>>>        If (pbAutoEnable(Self) = False) Begin
99338>>>>>            Procedure_Return
99339>>>>>        End
99339>>>>>>
99339>>>>>        Set Enabled_State to (IsEnabled(Self))
99340>>>>>    End_Procedure
99341>>>>>
99341>>>>>    Function IsEnabled Returns Boolean
99343>>>>>        Boolean bEnabled
99343>>>>>        Get pbEnabled to bEnabled
99344>>>>>        Function_Return bEnabled
99345>>>>>    End_Function
99346>>>>>
99346>>>>>    // Enable the idle handler timer when the object is activated
99346>>>>>    Procedure Activating
99348>>>>>        Forward Send Activating
99350>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
99351>>>>>    End_Procedure
99352>>>>>
99352>>>>>    // Disable the idle handler when the object is deactivated
99352>>>>>    Procedure Deactivating
99354>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
99355>>>>>        Forward Send Deactivating
99357>>>>>    End_Procedure
99358>>>>>
99358>>>>>    // To "un-select" the text in the comboform on startup
99358>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
99360>>>>>        Integer iStart iEnd
99360>>>>>
99360>>>>>        If (Focus(Desktop)=Self) Begin
99362>>>>>            Get SelStart to iStart
99363>>>>>            Get SelEnd   to iEnd
99364>>>>>        End
99364>>>>>>
99364>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
99366>>>>>        Send SetSel iStart iEnd
99367>>>>>    End_Procedure
99368>>>>>
99368>>>>>    // Message that will drop down the list without the user clicking it,
99368>>>>>    // so you can send "DropDownList" to the combo to show the list.
99368>>>>>    Procedure DropDownList
99370>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
99371>>>>>    End_Procedure
99372>>>>>
99372>>>>>    Procedure SizeComboWidth
99374>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
99374>>>>>        String sVal
99374>>>>>
99374>>>>>        // Initialise Width
99374>>>>>        Set ListWidth to 0
99375>>>>>        Send DoSetListWidth
99376>>>>>
99376>>>>>        Get ListRowCount     to iRows
99377>>>>>        Get Combo_Item_Count to iCount
99378>>>>>
99378>>>>>        // Vertical scroll-bar adjustment is needed
99378>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
99379>>>>>        If (iVertAdj) Begin
99381>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
99382>>>>>        End
99382>>>>>>
99382>>>>>        Else Begin
99383>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
99384>>>>>        End
99384>>>>>>
99384>>>>>
99384>>>>>        // Calculate New Width
99384>>>>>        Decrement iCount
99385>>>>>        For iItem from 0 to iCount
99391>>>>>>
99391>>>>>            Get Combo_Value iItem to sVal
99392>>>>>            If (sVal <> "") Begin
99394>>>>>                Get Text_Extent sVal to iTextExt
99395>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
99396>>>>>                If (iWd > iNewWd) Begin
99398>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
99399>>>>>                End
99399>>>>>>
99399>>>>>            End
99399>>>>>>
99399>>>>>        Loop
99400>>>>>>
99400>>>>>
99400>>>>>        // Set New Width
99400>>>>>        Set ListWidth to iNewWd
99401>>>>>        Send DoSetListWidth
99402>>>>>    End_Procedure
99403>>>>>
99403>>>>>    Procedure Combo_Add_Item String sValue
99405>>>>>        Forward Send Combo_Add_Item sValue
99407>>>>>        If (pbAutoListWidth(Self)) Begin
99409>>>>>            Send SizeComboWidth
99410>>>>>        End
99410>>>>>>
99410>>>>>    End_Procedure
99411>>>>>
99411>>>>>    Procedure Combo_Fill_List
99413>>>>>        Forward Send Combo_Fill_List
99415>>>>>        If (pbAutoListWidth(Self)) Begin
99417>>>>>            Send SizeComboWidth
99418>>>>>        End
99418>>>>>>
99418>>>>>    End_Procedure
99419>>>>>
99419>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99419>>>>>    // The bug being that the focus rectangle doesn't show.
99419>>>>>    Procedure Page Integer iPageObject
99421>>>>>        Handle hWnd
99421>>>>>        Integer iRet iState
99421>>>>>
99421>>>>>        Forward Send Page iPageObject
99423>>>>>
99423>>>>>        If (iPageObject) Begin
99425>>>>>            Get Window_Handle to hWnd
99426>>>>>            If (hWnd) Begin
99428>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99429>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99431>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99432>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99433>>>>>                End
99433>>>>>>
99433>>>>>            End
99433>>>>>>
99433>>>>>        End
99433>>>>>>
99433>>>>>
99433>>>>>        // To "un-select" the text in the comboform
99433>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
99435>>>>>            Send SetSel 0 0
99436>>>>>        End
99436>>>>>>
99436>>>>>    End_Procedure
99437>>>>>
99437>>>>>End_Class
99438>>>Use vWin32fh.pkg
99438>>>Use RefactorFunctionConstants.inc
99438>>>Use cSysFileDataDictionary.dd
99438>>>
99438>>>// Note: The "Visual" part will automatically be removed if
99438>>>// the current DataFlex version is above 17.
99438>>>Define CS_StudioPath        For "Software\Data Access Worldwide\Visual DataFlex Tools\"
99438>>>Define CS_StudioTools       For "\Studio\Tools"
99438>>>Define CS_RegWorkspace      For "<workspace>"
99438>>>Define CS_RegApplication    For "<application>"
99438>>>Define CS_RegProject        For "<project>"
99438>>>Define CS_RegFileName       For "<file>"
99438>>>Define CS_SaveAll           For "<saveall>"
99438>>>Define CS_CommandLine       For "CommandLine"
99438>>>Define CS_Name              For "Name"
99438>>>Define CS_Separator         For "Separator"
99438>>>Define CS_Command           For "Command"
99438>>>Define CS_CleanMarkersFlag  For "/c"
99438>>>Define CS_CleanMarkers      For "(Cleanup Source Code)"
99438>>>Define CS_CodeIndentFlag    For "/i"
99438>>>Define CS_CodeIndent        For "(Code Indent)"
99438>>>
99438>>>
99438>>>Object oProgramSetup_dg is a cRDCDbModalPanel
99440>>>    Object oSysFile_DD is a cSysFileDataDictionary
99442>>>    End_Object
99443>>>
99443>>>    Set Main_DD to oSysFile_DD
99444>>>    Set Server to oSysFile_DD
99445>>>
99445>>>    Set Size to 281 400
99446>>>    Set Label to "Program Settings"
99447>>>    Set piMinSize to 79 211
99448>>>    Set Location to 0 2
99449>>>    Set Icon to "Settings.ico"
99450>>>
99450>>>    Object oStudioIntegration_grp is a cRDCDbHeaderGroup
99452>>>        Set Size to 44 374
99453>>>        Set Location to 0 14
99454>>>        Set Label to "DataFlex Studio Integration"
99455>>>        Set psNote to "Add to Studio's Tools Menu"
99456>>>        Set psToolTip to "Adds this tool to the Studio's 'Tools' menu for easy access"
99457>>>        Set psImage to "ActionAddStudio.ico"
99458>>>
99458>>>        Object oStudioMajorVersion_sf is a SpinForm
99460>>>            Set Size to 12 27
99461>>>            Set Location to 24 173
99462>>>            Set Maximum_Position to 30
99463>>>            Set Minimum_Position to 14
99464>>>            Set Label_Col_Offset to 2
99465>>>            Set Label_Justification_Mode to JMode_Right
99466>>>            Set Label to "Major Version"
99467>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
99468>>>            Set Value to FMAC_VERSION
99469>>>            Set peAnchors to anNone
99470>>>        End_Object
99471>>>
99471>>>        Object oStudioMinorVersion_sf is a SpinForm
99473>>>            Set Size to 12 27
99474>>>            Set Location to 24 254
99475>>>            Set Label_Col_Offset to 2
99476>>>            Set Label to "Minor Version"
99477>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
99478>>>            Set Maximum_Position to 9
99479>>>            Set Minimum_Position to 0
99480>>>            Set Value to FMAC_REVISION
99481>>>            Set Label_Justification_Mode to JMode_Right
99482>>>            Set peAnchors to anNone
99483>>>        End_Object
99484>>>
99484>>>        Object oOK_btn is a cRDCButtonDPI
99486>>>            Set Location to 23 290
99487>>>            Set Size to 13 72
99488>>>            Set Label to "Add to Studio"
99489>>>            Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu. When selected from the Studio it will pass the current project name on the command line so that the current program's manifest file is automatically loaded by the program."
99490>>>            Set psImage to "ActionAdd.ico"
99491>>>            Set piImageMarginLeft to 8
99492>>>            Set peAnchors to anTopRight
99493>>>
99493>>>            Procedure OnClick
99496>>>                Integer iRetval iMajorVersion iMinorVersion
99496>>>                String sText sStudioVersion
99496>>>
99496>>>                Get Value of oStudioMajorVersion_sf to iMajorVersion
99497>>>                If (iMajorVersion < 14) Begin
99499>>>                    Send Info_Box ("Really? You have a DataFlex Studio version" * String(iMajorVersion) * "and expect this to work?")
99500>>>                    Procedure_Return
99501>>>                End
99501>>>>
99501>>>                Get Value of oStudioMinorVersion_sf to iMinorVersion
99502>>>                Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
99503>>>                Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
99504>>>
99504>>>                Case Begin
99504>>>                    Case (iRetval = cx_RegKeyAlreadyExist)
99506>>>                        Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
99507>>>                        Break
99508>>>                    Case (iRetval = cx_RegKeyCreated)
99511>>>                        Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
99512>>>                        Break
99513>>>                    Case (iRetval = cx_RegkeyFailed)
99516>>>                        Move "Failed. Could not create the registry key For adding the program to the DataFlex Studio's Tools menu." to sText
99517>>>                        Break
99518>>>                    Case (iRetval = cx_RegKeyDFKeyDoesNotExist)
99521>>>                        Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
99522>>>                        Break
99523>>>                    Case (iRetval = cx_InstalledOkDFUnder16)
99526>>>                        Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed For an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
99527>>>                        Break
99528>>>                Case End
99528>>>
99528>>>                Send Info_Box sText
99529>>>            End_Procedure
99530>>>
99530>>>        End_Object
99531>>>
99531>>>    End_Object
99532>>>
99532>>>    Object oDFSourceExplorer_grp is a cRDCDbHeaderGroup
99534>>>        Set Size to 58 374
99535>>>        Set Location to 51 14
99536>>>        Set Label to "Starzen's DataFlex Source Explorer"
99537>>>        Set psImage to "DataFlexSourceExplorer.ico"
99538>>>        Set psNote to "The Starzen's tool can be downloaded from:"
99539>>>        Set psToolTip to "This tool needs to be downloaded and installed separately"
99540>>>
99540>>>        Object oStarzen_lnk is a cLinkLabel
99542>>>            Set Size to 8 41
99543>>>            Set Location to 14 185
99544>>>            Set Label to '<A href="http://www.starzen.com/products/dataflex-tools/dataflex-source-code-browser">Starzen.com</A>'
99545>>>            Set psToolTip to "Opens link in web-browser"
99546>>>            Set Skip_State to False
99547>>>        End_Object
99548>>>
99548>>>        Object oSourceExplorerProgram_fm is a dbForm
99550>>>            Entry_Item SysFile.PathStarZen
99551>>>            Set Size to 13 331
99552>>>            Set Location to 36 29
99553>>>            Set Prompt_Button_Mode to pb_PromptOn
99554>>>            Set Label_Row_Offset to 1
99555>>>            Set Label_Col_Offset to 0
99556>>>            Set Label_Justification_Mode to JMode_Top
99557>>>            Set Label to "Path and file name:"
99558>>>
99558>>>            Procedure Prompt
99561>>>                Integer bOpen
99561>>>                String sFileName
99561>>>
99561>>>                Get Show_Dialog of oOpenDialog to bOpen
99562>>>                If bOpen Begin
99564>>>                    Get File_Name of oOpenDialog to sFileName
99565>>>                    Set Changed_Value Item 0 to sFileName
99566>>>                End
99566>>>>
99566>>>            End_Procedure
99567>>>
99567>>>            Function Changed_State Returns Boolean
99570>>>                Boolean bState
99570>>>                Forward Get Changed_State to bState
99572>>>                Function_Return bState
99573>>>            End_Function
99574>>>
99574>>>        End_Object
99575>>>
99575>>>        Function Changed_State Returns Boolean
99578>>>            Boolean bState
99578>>>            Broadcast Get Changed_State to bState
99580>>>            Function_Return bState
99581>>>        End_Function
99582>>>
99582>>>    End_Object
99583>>>
99583>>>    Object oCompareEditor_grp is a cRDCDbHeaderGroup
99585>>>        Set Location to 116 14
99586>>>        Set Size to 56 374
99587>>>        Set Label to "Compare Tool"
99588>>>        Set psImage to "Compare.ico"
99589>>>        Set psNote to "Select a file comparison tool like:"
99590>>>        Set psToolTip to "This tool needs to be downloaded and installed separately"
99591>>>
99591>>>        Object oBeyondCompare_lnk is a cLinkLabel
99593>>>            Set Size to 8 60
99594>>>            Set Location to 14 150
99595>>>            Set Label to '<A href="http://www.scootersoftware.com">Beyond Compare</A>'
99596>>>            Set psToolTip to "Opens link in web-browser"
99597>>>            Set Skip_State to False
99598>>>        End_Object
99599>>>
99599>>>        Object oWinMerge_lnk is a cLinkLabel
99601>>>            Set Size to 8 37
99602>>>            Set Location to 14 214
99603>>>            Set Label to '<A href="http://www.winmerge.org">WinMerge</A>'
99604>>>            Set psToolTip to "Opens link in web-browser"
99605>>>            Set Skip_State to False
99606>>>        End_Object
99607>>>
99607>>>        Object oAraxisMerge_lnk is a cLinkLabel
99609>>>            Set Size to 8 46
99610>>>            Set Location to 14 256
99611>>>            Set Label to '<A href="http://www.araxis.com/merge">Araxis Merge</A>'
99612>>>            Set psToolTip to "Opens link in web-browser"
99613>>>            Set Skip_State to False
99614>>>        End_Object
99615>>>
99615>>>        Object oCompareprogram_fm is a dbForm
99617>>>            Entry_Item SysFile.PathSourceCompareTool
99618>>>            Set Size to 13 331
99619>>>            Set Location to 36 29
99620>>>            Set Prompt_Button_Mode to pb_PromptOn
99621>>>            Set Label_Col_Offset to 0
99622>>>            Set Label_Row_Offset to 1
99623>>>            Set Label_Justification_Mode to JMode_Top
99624>>>            Set Label to "Path and file name:"
99625>>>            Set psToolTip to "Select a file comparison tool, such as 'Beyond Compare', 'WinMerge', 'Araxis Merge' etc.."
99626>>>
99626>>>            Procedure Prompt
99629>>>                Integer bOpen
99629>>>                String sFileName
99629>>>
99629>>>                Get Show_Dialog of oOpenDialog to bOpen
99630>>>                If bOpen Begin
99632>>>                    Get File_Name of oOpenDialog to sFileName
99633>>>                    Set Value to sFileName
99634>>>                    Set Changed_State to True
99635>>>                End
99635>>>>
99635>>>            End_Procedure
99636>>>
99636>>>            Function Changed_State Returns Boolean
99639>>>                Boolean bState
99639>>>                Forward Get Changed_State to bState
99641>>>                Function_Return bState
99642>>>            End_Function
99643>>>
99643>>>        End_Object
99644>>>
99644>>>        Function Changed_State Returns Boolean
99647>>>            Boolean bState
99647>>>            Broadcast Get Changed_State to bState
99649>>>            Function_Return bState
99650>>>        End_Function
99651>>>
99651>>>    End_Object
99652>>>
99652>>>//    Object oBackup_grp is a cRDCDbHeaderGroup
99652>>>//        Set Size to 40 374
99652>>>//        Set Location to 181 14
99652>>>//        Set Label to "Backup Settings"
99652>>>//        Set psImage to "ActionBackup.ico"
99652>>>//        Set psToolTip to "Please note that you always also need to make your own backup of the source code before running this program and/or checking in the source with a source control software."
99652>>>//
99652>>>//        Object oCreateBackupFiles_cb is a cRDCCheckbox
99652>>>//            Set Size to 7 266
99652>>>//            Set Location to 22 30
99652>>>//            Set Label to "Create backup files in backup folders (<workspace>\DFRefactor Backup\...)"
99652>>>//            Set psToolTip to "The tool creates a 'DFRefactor Backup' folder in the workspace home (root) folder. It then creates a series of subfolders to match the workspace that is to be worked on."
99652>>>//            Set Checked_State to True   
99652>>>//        End_Object
99652>>>//
99652>>>//    End_Object
99652>>>
99652>>>    Object oVisual_grp is a cRDCDbHeaderGroup
99654>>>        Set Size to 73 374
99655>>>        Set Location to 180 14
99656>>>        Set Label to "Visual Settings"
99657>>>        Set psImage to "VisualSettings.ico"
99658>>>        Set psToolTip to "Various visual program settings."
99659>>>
99659>>>        Object oToolbarIconSize_cf is a cRDCComboForm
99661>>>            Set Size to 13 100
99662>>>            Set Location to 17 98
99663>>>            Set Label to "Toolbar Icon Size"
99664>>>            Set Entry_State to False
99665>>>            Set Label_Col_Offset to 2
99666>>>            Set Label_Justification_Mode to JMode_Right
99667>>>
99667>>>            Procedure Combo_Fill_List
99670>>>                Integer iSize
99670>>>                String sValue
99670>>>
99670>>>                Send Combo_Add_Item "16x16 Icons"
99671>>>                Send Combo_Add_Item "24x24 Icons"
99672>>>                Send Combo_Add_Item "32x32 Icons"
99673>>>
99673>>>                Get piToolbarIconSize of ghoApplication to iSize
99674>>>                Case Begin
99674>>>                    Case (iSize = 16)
99676>>>                        Move "16x16 Icons" to sValue
99677>>>                        Case Break
99678>>>                    Case (iSize = 24)
99681>>>                        Move "24x24 Icons" to sValue
99682>>>                        Case Break
99683>>>                    Case (iSize = 32)
99686>>>                        Move "32x32 Icons" to sValue
99687>>>                        Case Break
99688>>>                Case End
99688>>>                Set Value to sValue
99689>>>            End_Procedure
99690>>>
99690>>>        End_Object
99691>>>
99691>>>        Object oGridRowColor_cf is a cRDCComboForm
99693>>>            Set Size to 13 100
99694>>>            Set Location to 17 258
99695>>>            Set psToolTip to "Sets the current row background color (piSelectedRowBackColor)"
99696>>>            Set Label to "Grid row color"
99697>>>            Set Label_Col_Offset to 2
99698>>>            Set Label_Justification_Mode to JMode_Right
99699>>>            Set Entry_State to False
99700>>>            Set Combo_Sort_State to False
99701>>>
99701>>>            Procedure Combo_Fill_List
99704>>>                String sColor
99704>>>
99704>>>                Send Combo_Add_Item "clGreenGreyLight"
99705>>>                Send Combo_Add_Item "clGreenGrey"
99706>>>                Send Combo_Add_Item "clNone"
99707>>>                Send Combo_Add_Item "clAqua"
99708>>>                Send Combo_Add_Item "clBlack"
99709>>>                Send Combo_Add_Item "clBlue"
99710>>>                Send Combo_Add_Item "clDkGray"
99711>>>                Send Combo_Add_Item "clFuchsia"
99712>>>                Send Combo_Add_Item "clGray"
99713>>>                Send Combo_Add_Item "clGreen"
99714>>>                Send Combo_Add_Item "clLime"
99715>>>                Send Combo_Add_Item "clLtGray"
99716>>>                Send Combo_Add_Item "clMaroon"
99717>>>                Send Combo_Add_Item "clNavy"
99718>>>                Send Combo_Add_Item "clOlive"
99719>>>                Send Combo_Add_Item "clPurple"
99720>>>                Send Combo_Add_Item "clRed"
99721>>>                Send Combo_Add_Item "clSilver"
99722>>>                Send Combo_Add_Item "clTeal"
99723>>>
99723>>>                Get psGridRowBackgroundColor of ghoApplication to sColor
99724>>>                Set Value to sColor
99725>>>            End_Procedure
99726>>>
99726>>>            Procedure OnChange
99729>>>                String sColor
99729>>>                Get Value to sColor
99730>>>                If (sColor = "") Begin
99732>>>                    Move clGreenGreyLight to sColor
99733>>>                End
99733>>>>
99733>>>                Set psGridRowBackgroundColor of ghoApplication to sColor
99734>>>            End_Procedure
99735>>>
99735>>>        End_Object
99736>>>
99736>>>        Object oGridFontSize_cf is a cRDCComboForm
99738>>>            Set Size to 13 100
99739>>>            Set Location to 34 258
99740>>>            Set Label to "Grid font size"
99741>>>            Set psToolTip to "Sets the font size for grids"
99742>>>            Set Label_Col_Offset to 2
99743>>>            Set Label_Justification_Mode to JMode_Right
99744>>>            Set Entry_State to False
99745>>>            Set Combo_Sort_State to False
99746>>>
99746>>>            Procedure Combo_Fill_List
99749>>>                Integer iSize
99749>>>
99749>>>                Send Combo_Add_Item "6"
99750>>>                Send Combo_Add_Item "7"
99751>>>                Send Combo_Add_Item "8"
99752>>>                Send Combo_Add_Item "9"
99753>>>                Send Combo_Add_Item "10"
99754>>>                Send Combo_Add_Item "11"
99755>>>                Send Combo_Add_Item "12"
99756>>>                Send Combo_Add_Item "13"
99757>>>                Send Combo_Add_Item "14"
99758>>>                Send Combo_Add_Item "15"
99759>>>                Send Combo_Add_Item "16"
99760>>>
99760>>>                Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iSize
99761>>>                Set Value to iSize
99762>>>            End_Procedure
99763>>>
99763>>>            Procedure OnChange     
99766>>>                Integer iSize
99766>>>                Get Value to iSize
99767>>>                Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
99768>>>            End_Procedure
99769>>>
99769>>>        End_Object
99770>>>
99770>>>    End_Object
99771>>>
99771>>>    Object oSave_Btn is a cRDCButtonDPI
99773>>>        Set Size to 14 50
99774>>>        Set Label    to "Save"
99775>>>        Set Location to 260 283
99776>>>        Set peAnchors to anBottomRight
99777>>>        Set psImage to "ActionSave.ico"
99778>>>        Set pbAutoEnable to True
99779>>>
99779>>>        Procedure OnClick
99782>>>            String sFile sValue
99782>>>            Boolean bState
99782>>>            Integer iSize
99782>>>
99782>>>            Get Value of oCompareprogram_fm to sFile
99783>>>            Set psFileCompareApp of ghoApplication to sFile
99784>>>
99784>>>            Get Value of oSourceExplorerProgram_fm to sFile
99785>>>            Set psStarZenSourceExplorer of ghoApplication to sFile
99786>>>
99786>>>            // The backup setting has been made mandatory.
99786>>>//            Get Checked_State of oCreateBackupFiles_cb to bState
99786>>>            Set pbShouldBackupFile of ghoApplication to True
99787>>>
99787>>>            Get Value of oToolbarIconSize_cf to sValue
99788>>>            Case Begin
99788>>>                Case (sValue contains "16")
99790>>>                    Move 16 to iSize
99791>>>                    Case Break
99792>>>                Case (sValue contains "24")
99795>>>                    Move 24 to iSize
99796>>>                    Case Break
99797>>>                Case (sValue contains "32")
99800>>>                    Move 32 to iSize
99801>>>                    Case Break
99802>>>                Case Else
99802>>>                    Move 24 to iSize
99803>>>            Case End
99803>>>            Set piToolbarIconSize of ghoApplication to iSize
99804>>>
99804>>>            Send Info_Box "Changes saved."
99805>>>            Send Close_Panel
99806>>>        End_Procedure
99807>>>
99807>>>        Function IsEnabled Returns Boolean
99810>>>            Boolean bChangedState
99810>>>            Delegate Get Changed_State to bChangedState // Ask the view.
99812>>>            If (bChangedState = False) Begin
99814>>>                Get Should_Save of oSysFile_DD to bChangedState
99815>>>            End
99815>>>>
99815>>>            Function_Return bChangedState
99816>>>        End_Function
99817>>>
99817>>>    End_Object
99818>>>
99818>>>    Object oCancel_Btn is a cRDCButtonDPI
99820>>>        Set Label to "&Cancel"
99821>>>        Set Location to 260 339
99822>>>        Set peAnchors to anBottomRight
99823>>>
99823>>>        Procedure OnClick
99826>>>            Send Close_Panel
99827>>>        End_Procedure
99828>>>
99828>>>    End_Object
99829>>>
99829>>>    Object oOpenDialog is a OpenDialog
99831>>>        Set Dialog_Caption to "Select your file compare application of choice"
99832>>>        Set Filter_String to "Programs|*.exe|Any file|*.*"
99833>>>    End_Object
99834>>>
99834>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
99837>>>        Boolean bOk bExists bOpen
99837>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath sTag sCommandLine
99837>>>        Handle hoReg hoArray
99837>>>        Integer i iItems iCreated iRetval
99837>>>
99837>>>        Move False to bOk
99838>>>        Move (CS_RegWorkspace * CS_RegFileName * CS_SaveAll) to sTag
99839>>>
99839>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
99840>>>        If (sStudioVersion > "17.1") Begin
99842>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
99843>>>        End
99843>>>>
99843>>>
99843>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
99844>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
99845>>>        Get vFolderFormat sProgramPath to sProgramPath
99846>>>        Get psProduct of (phoWorkspace(ghoApplication)) to sProduct
99847>>>        Get Module_Name to sProgram
99848>>>
99848>>>        Get Create (RefClass(cRegistry)) to hoReg
99849>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
99850>>>        // First check if the DataFlex version is installed
99850>>>        Get KeyExists of hoReg sStudioPath to bExists
99851>>>        If (bExists = False) Begin
99853>>>            Send Destroy of hoReg
99854>>>            Function_Return cx_RegKeyDFKeyDoesNotExist
99855>>>        End
99855>>>>
99855>>>
99855>>>        // Then check if any tools have been installed in the Tools Menu.
99855>>>        // If no tools created yet, create the Tools registry key.
99855>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
99856>>>        Get KeyExists of hoReg sStudioPath to bExists
99857>>>        If (bExists = False) Begin
99859>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
99860>>>            Get CreateKey of hoReg sStudioPath to iCreated
99861>>>            If (iCreated <> 0) Begin
99863>>>                Move cx_RegkeyFailed to iRetval
99864>>>            End
99864>>>>
99864>>>            Else Begin
99865>>>                Move True to bExists
99866>>>            End
99866>>>>
99866>>>        End
99866>>>>
99866>>>
99866>>>        If (bExists = True) Begin
99868>>>            Get OpenKey of hoReg sStudioPath to bOk
99869>>>            If (bOk = True) Begin
99871>>>                Get Create (RefClass(Array)) to hoArray
99872>>>                Get GetSubkeys of hoReg hoArray to iItems
99873>>>                Decrement iItems
99874>>>                Move False to bExists
99875>>>                Set pfAccessRights of hoReg to KEY_READ
99876>>>                // Check if the key already exists:
99876>>>                For i From 0 to iItems
99882>>>>
99882>>>                    Get Value of hoArray i to sKey
99883>>>                    Move (sStudioPath + CS_DirSeparator + sKey) to sKey
99884>>>                    Get OpenKey of hoReg sKey to bOpen
99885>>>                    If (bOpen = True) Begin
99887>>>                        Get ReadString of hoReg CS_Name to sValue
99888>>>                        Get ReadString of hoReg CS_CommandLine to sCommandLine
99889>>>                        If (Uppercase(sValue) = Uppercase(sProduct) and Uppercase(sCommandLine) = Uppercase(sTag)) Begin
99891>>>                            Move True to bExists
99892>>>                        End
99892>>>>
99892>>>                    End
99892>>>>
99892>>>                Loop
99893>>>>
99893>>>                Send Destroy of hoArray
99894>>>
99894>>>                If (bExists = False) Begin
99896>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
99897>>>                    // We need to create the next key number:
99897>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
99897>>>                    Increment iItems
99898>>>                    Increment iItems
99899>>>                    Get CreateKey of hoReg (sStudioPath + CS_DirSeparator + String(iItems)) to iCreated
99900>>>                    If (iCreated = 0) Begin
99902>>>                        Send WriteString of hoReg CS_Name sProduct
99903>>>                        // From DataFlex 16 and up the params For the Studio's Tools menu changed slightly:
99903>>>                        If (sStudioVersion >= "16.0") Begin
99905>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
99906>>>                            Send WriteString of hoReg CS_CommandLine sTag
99907>>>                        End
99907>>>>
99907>>>                        Else Begin
99908>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * String(sTag))
99909>>>                            Move cx_InstalledOkDFUnder16 to iRetval
99910>>>                        End
99910>>>>
99910>>>                        Send WriteDword of hoReg CS_Separator 1
99911>>>                        Move cx_RegKeyCreated to iRetval
99912>>>                    End
99912>>>>
99912>>>                    Else Begin
99913>>>                        Move cx_RegkeyFailed to iRetval
99914>>>                    End
99914>>>>
99914>>>                End
99914>>>>
99914>>>                Else Begin
99915>>>                    Move cx_RegKeyAlreadyExist to iRetval
99916>>>                End
99916>>>>
99916>>>                Send CloseKey of hoReg
99917>>>            End
99917>>>>
99917>>>        End
99917>>>>
99917>>>
99917>>>        Send Destroy of hoReg
99918>>>        Function_Return iRetval
99919>>>    End_Function
99920>>>
99920>>>    Procedure Popup
99923>>>        String sProgram
99923>>>        Boolean bState
99923>>>
99923>>>//        Get psFileCompareApp of ghoApplication to sProgram
99923>>>//        Set Value of oCompareprogram_fm to sProgram
99923>>>//        Get psStarZenSourceExplorer of ghoApplication to sProgram
99923>>>//        Set Value of oSourceExplorerProgram_fm to sProgram
99923>>>//        Get pbShouldBackupFile of ghoApplication to bState
99923>>>//        Set Checked_State of oCreateBackupFiles_cb to bState
99923>>>
99923>>>        // Note: We reread from registry before popup and therefor also reset the changed_state
99923>>>        // For these objects.
99923>>>//        Broadcast Recursive Set Changed_State to False
99923>>>        If (SysFile.Recnum = 0) Begin
99925>>>            Find ge SysFile by Recnum
99926>>>>
99926>>>        End
99926>>>>
99926>>>        Forward Send Popup
99928>>>    End_Procedure
99929>>>
99929>>>    // We do not track changes For the first two (group) items as they
99929>>>    // are For making changes to the Studio only, so there is nothing
99929>>>    // to save.
99929>>>    // Note: Contrary to what the help says, "broadcast recursive get" only
99929>>>    //       works two level deep. Since we need three levels, a changed_state
99929>>>    //       function was inserted into each of the cRDCHeaderGroup objects
99929>>>    //       to get this to work.
99929>>>    //       This is the solution to the problem suggested by John Tuohy back in 2011.
99929>>>    Function Changed_State Returns Boolean
99932>>>        Boolean bChangedState
99932>>>//        Broadcast Recursive Get Changed_State of oCompareEditor_grp to bChangedState
99932>>>//        If (bChangedState = False) Begin
99932>>>//            Broadcast Recursive Get Changed_State of oDFSourceExplorer_grp to bChangedState
99932>>>//        End
99932>>>//        If (bChangedState = False) Begin
99932>>>//            Broadcast Recursive Get Changed_State of oBackup_grp to bChangedState
99932>>>//        End
99932>>>        If (bChangedState = False) Begin
99934>>>            Broadcast Recursive Get Changed_State of oVisual_grp to bChangedState
99936>>>        End
99936>>>>
99936>>>
99936>>>        Function_Return bChangedState
99937>>>    End_Function
99938>>>
99938>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99939>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99940>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
99941>>>End_Object
99942>        Use ScintillaParameters.dg
Including file: ScintillaParameters.dg    (C:\Projects\DF18\DfRefactor\AppSrc\ScintillaParameters.dg)
99942>>>Use cRDCModalPanel.pkg
99942>>>Use cImageList32.pkg
99942>>>Use dfSpnFrm.pkg
99942>>>Use dfLine.pkg
99942>>>Use dfTreeVw.pkg
99942>>>Use Colr_Dlg.pkg
99942>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRichEdit.pkg)
99942>>>>>Use Windows.pkg
99942>>>>>Use cEdit_Mixin.pkg
99942>>>>>
99942>>>>>// constants used for RichEdit Properties
99942>>>>>// peAlignment
99942>>>>>Enum_List
99942>>>>>    Define alLeft   for 1
99942>>>>>    Define alRight  for 2
99942>>>>>    Define alCenter for 3
99942>>>>>End_Enum_List
99942>>>>>
99942>>>>>// peBullets
99942>>>>>Enum_List
99942>>>>>    Define buNone
99942>>>>>    Define buBullets
99942>>>>>    Define buArabicNumbers
99942>>>>>    Define buLowerLetters
99942>>>>>    Define buUpperLetters
99942>>>>>    Define buLowerRomans
99942>>>>>    Define buUpperRomans
99942>>>>>End_Enum_List
99942>>>>>
99942>>>>>// peBulletStyle
99942>>>>>Enum_List
99942>>>>>    Define busRightParen   for 0
99942>>>>>    Define busEncloseParen for 256
99942>>>>>    Define busPeriod       for 512
99942>>>>>    Define busNumberOnly   for 768
99942>>>>>    Define busNoDisplay    for 1024
99942>>>>>End_Enum_List
99942>>>>>
99942>>>>>// peLineSpacingType
99942>>>>>Enum_List
99942>>>>>    Define lstSingle
99942>>>>>    Define lstSingleAndOneHalf
99942>>>>>    Define lstDouble
99942>>>>>End_Enum_List
99942>>>>>
99942>>>>>Class cRichEdit is a DFBaseRichEdit
99943>>>>>    
99943>>>>>    Procedure Construct_Object
99945>>>>>        Forward Send Construct_Object
99947>>>>>        Send Define_cEdit_Mixin
99948>>>>>        
99948>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
99949>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
99950>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
99951>>>>>        
99951>>>>>    End_Procedure
99952>>>>>    
99952>>>>>    Import_Class_Protocol cEdit_Mixin
99953>>>>>    
99953>>>>>    Procedure ToggleBold
99955>>>>>        Set pbBold to (not(pbBold(Self)))
99956>>>>>    End_Procedure
99957>>>>>    
99957>>>>>    Procedure ToggleItalics
99959>>>>>        Set pbItalics to (not(pbItalics(Self)))
99960>>>>>    End_Procedure
99961>>>>>    
99961>>>>>    Procedure ToggleUnderline
99963>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
99964>>>>>    End_Procedure
99965>>>>>    
99965>>>>>End_Class
99966>>>>>
99966>>>>>
99966>>>Use oEditorProperties.pkg
99966>>>Use THColorer.pkg
Including file: THColorer.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\THColorer.pkg)
99966>>>>>// THColorer.pkg
99966>>>>>// This is TheHammer 3.0 Code Colorer
99966>>>>>// by Sergey V. Natarov
99966>>>>>
99966>>>>>// *** COLORS ***
99966>>>>>// _WindowColr_ _LftMrgnClr_ _BookmarkCl_ _BookmarkBg_ _TextColorX_ _TextBackgr_ _NumberColr_ _NumberBkGr_ _KeywordsCl_ _KeywordsBg_ _OperatorCl_ _OperatorBg_ _ScopeKwClr_ _ScopeKwBkg_ _CommentClr_ _CommentBkg_ _StringColr_ _StringBkgr_ _TagTextClr_ _TagTextBkg_ _TagEntyClr_ _TagEntyBkg_ _TagElemClr_ _TagElemBkg_ _TagAttrClr_ _TagAttrBkg_ _LineNrColr_ _LineNrBkgr_ _HrDivLinCl_ _VrDivLinCl_ _HiLtLineCl_
99966>>>>>// 255255255000 192192192000 255255255255 255255255255 000000000000 255255255000 255000255000 255255255000 000000255000 255255255000 255000000000 255255255000 000000255000 255255255000 000128000000 255255255000 128128128000 255255255000 000128128000 255255255255 255000000000 255255255255 000000255000 255255255255 128000000000 255255255255 255255255000 128128128000 255255255255 192192192000 192192192000 000
99966>>>>>//      1            2             3           4             5           6             7            8            9           10            11          12            13          14           15           16            17          18           19          20            21            22           23         24            25           26           27           28          29            30          31
99966>>>>>
99966>>>>>// *** FONTS *** (PSFONTSTYLES)
99966>>>>>//      Nr       Sc Ct    TT En    At
99966>>>>>//   _  _  _  _  _  _  _  _  _  _  _  _
99966>>>>>// 000000000000000002000001000001000000000
99966>>>>>//   _     -  -        -        -     -
99966>>>>>//   Tx    Kw Op       St       El    Ln
99966>>>>>//   1  2  3  4  5  6  7  8  9 10 11 12
99966>>>>>//          1         2         3
99966>>>>>
99966>>>>>
99966>>>>>// Normal           = 0
99966>>>>>// Bold             = 1
99966>>>>>// Italics          = 2
99966>>>>>// Bold + Italics   = 3
99966>>>>>// Underline        = 4
99966>>>>>// B+U              = 5
99966>>>>>// I+U              = 6
99966>>>>>// B+I+U            = 7
99966>>>>>
99966>>>>>Use cRichEdit.pkg
99966>>>>>Use THColorer.h
99966>>>>>
99966>>>>>Procedure Add_Color_Element Integer iIndex String sName Integer iFront Integer iBack Integer iFont Integer iStyle Integer iCM
99969>>>>>    // iIndex = Element Index
99969>>>>>    // Name of the Element
99969>>>>>    Move sName  to gtColorer[iIndex].sName
99970>>>>>    // Front Color OffSet *at the color line (if any)
99970>>>>>    Move iFront to gtColorer[iIndex].iForeOff
99971>>>>>    // Background Color OffSet *at the color line (if any)
99971>>>>>    Move iBack  to gtColorer[iIndex].iBackOff
99972>>>>>    // Font attributes allowed
99972>>>>>    Move iFont  to gtColorer[iIndex].iFont
99973>>>>>    // Font Style
99973>>>>>    Move iStyle to gtColorer[iIndex].iStyle
99974>>>>>    // CodeMax Support
99974>>>>>    Move iCM    to gtColorer[iIndex].iCM
99975>>>>>End_Procedure
99976>>>>>
99976>>>>>Function RGBColorFromString String sColorStr Returns Integer
99979>>>>>    Integer iRed iGreen iBlue
99979>>>>>    If (Length(sColorStr)<>12) Begin
99981>>>>>        Function_Return 0
99982>>>>>    End
99982>>>>>>
99982>>>>>    If (sColorStr="255255255255") Begin
99984>>>>>        Function_Return -1 // Default color
99985>>>>>    End
99985>>>>>>
99985>>>>>    // 1  4  7
99985>>>>>    // RRRGGGBBBAAA
99985>>>>>    Move (Mid(sColorStr, 3, 1)) to iRed
99986>>>>>    Move (Mid(sColorStr, 3, 4)) to iGreen
99987>>>>>    Move (Mid(sColorStr, 3, 7)) to iBlue
99988>>>>>    Function_Return (RGB(iRed, iGreen, iBlue))
99989>>>>>End_Function
99990>>>>>
99990>>>>>Function RGBStringFromRGB String iRed String iGreen String iBlue Returns String
99993>>>>>    String sColorStr
99993>>>>>    Move (sColorStr+Right(("000"+iRed), 3))   to sColorStr
99994>>>>>    Move (sColorStr+Right(("000"+iGreen), 3)) to sColorStr
99995>>>>>    Move (sColorStr+Right(("000"+iBlue), 3))  to sColorStr
99996>>>>>    Move (sColorStr+"000") to sColorStr
99997>>>>>    // Returns string as RRRGGGBBBAAA (128128128000)
99997>>>>>    Function_Return sColorStr
99998>>>>>End_Function
99999>>>>>
99999>>>>>Procedure SetColorerCurrentStyles String sColors String sFontStyle
100002>>>>>    Integer iItem iItems iColor iFont
100002>>>>>    String  sColorStr sFontStr
100002>>>>>    //
100002>>>>>    If (sColors="") ;        Get psColors        of ghoEditorProperties to sColors
100005>>>>>    If (sFontStyle="") ;        Get psFontStyles    of ghoEditorProperties to sFontStyle
100008>>>>>    //
100008>>>>>    Move (SizeOfArray(gtColorer)) to iItems
100009>>>>>    For iItem from 0 to (iItems-1)
100015>>>>>>
100015>>>>>        If (gtColorer[iItem].iForeOff) Begin
100017>>>>>            Move (Mid(sColors, 12, ((gtColorer[iItem].iForeOff-1)*12)+1)) to sColorStr
100018>>>>>            Get RGBColorFromString sColorStr to iColor
100019>>>>>            Move iColor to gtColorer[iItem].iForeC
100020>>>>>        End
100020>>>>>>
100020>>>>>        If (gtColorer[iItem].iBackOff) Begin
100022>>>>>            Move (Mid(sColors, 12, ((gtColorer[iItem].iBackOff-1)*12)+1)) to sColorStr
100023>>>>>            Get RGBColorFromString sColorStr to iColor
100024>>>>>            Move iColor to gtColorer[iItem].iBackC
100025>>>>>        End
100025>>>>>>
100025>>>>>        If (gtColorer[iItem].iFont) Begin
100027>>>>>            Move (Mid(sFontStyle, 3, ((gtColorer[iItem].iStyle-1)*3)+1)) to sFontStr
100028>>>>>            Move sFontStr to iFont
100029>>>>>            Move ((iFont iand THFS_BOLD     )<>0)   to gtColorer[iItem].iBold
100030>>>>>            Move ((iFont iand THFS_ITALICS  )<>0)   to gtColorer[iItem].iItalics
100031>>>>>            Move ((iFont iand THFS_UNDERLINE)<>0)   to gtColorer[iItem].iUnderline
100032>>>>>        End
100032>>>>>>
100032>>>>>    Loop
100033>>>>>>
100033>>>>>End_Procedure
100034>>>>>
100034>>>>>Procedure Register_Color_Elements
100037>>>>>    tColorer[] ltColorer
100037>>>>>    tColorer[] ltColorer
100038>>>>>    Move ltColorer to gtColorer
100039>>>>>    //                      Index               Name                         Tran   Fr  Bk  Fnt  Stl  CM
100039>>>>>    Send Add_Color_Element  EC_WINDOW           (_T("Window"               , 1063))  1   0   0    0   1
100040>>>>>    Send Add_Color_Element  EC_LEFTMARGIN       (_T("Left Margin"          , 1064))  2   0   0    0   1
100041>>>>>    Send Add_Color_Element  EC_BOOKMARK         (_T("Bookmarks"            , 1065))  3   4   0    0   1
100042>>>>>    Send Add_Color_Element  EC_TEXT             (_T("Text"                 , 1066))  5   6   1    1   1
100043>>>>>    Send Add_Color_Element  EC_NUMBERS          (_T("Numbers"              , 1067))  7   8   1    2   1
100044>>>>>    Send Add_Color_Element  EC_KEYWORDS         (_T("Keywords"             , 1068))  9  10   1    3   1
100045>>>>>    Send Add_Color_Element  EC_OPERATORS        (_T("Operators"            , 1069)) 11  12   1    4   1
100046>>>>>    Send Add_Color_Element  EC_SCOPEKWORDS      (_T("Scope Keywords"       , 1070)) 13  14   1    5   1
100047>>>>>    Send Add_Color_Element  EC_COMMENTS         (_T("Comments"             , 1071)) 15  16   1    6   1
100048>>>>>    Send Add_Color_Element  EC_STRINGS          (_T("String"               , 1072)) 17  18   1    7   1
100049>>>>>    Send Add_Color_Element  EC_TAGTEXT          (_T("Tag Text"             , 1073)) 19  20   1    8   1
100050>>>>>    Send Add_Color_Element  EC_TAGENTITIES      (_T("Tag Entities"         , 1074)) 21  22   1    9   1
100051>>>>>    Send Add_Color_Element  EC_TAGELEMENT       (_T("Tag Element Names"    , 1075)) 23  24   1   10   1
100052>>>>>    Send Add_Color_Element  EC_TAGATTRIBUTE     (_T("Tag Attributes"       , 1076)) 25  26   1   11   1
100053>>>>>    Send Add_Color_Element  EC_LINENUMBERS      (_T("Line Numbers"         , 1077)) 27  28   1   12   1
100054>>>>>    Send Add_Color_Element  EC_HDIVLINES        (_T("Horz Divider Lines"   , 1078)) 29   0   0    0   1
100055>>>>>    Send Add_Color_Element  EC_VDIVLINES        (_T("Vert Divider Lines"   , 1079)) 30   0   0    0   1
100056>>>>>    Send Add_Color_Element  EC_HLIGHTEDLINE     (_T("Highlighted Line"     , 1080)) 31   0   0    0   1
100057>>>>>    // Scintilla extras (Not supported by CodeMax, see CM column)
100057>>>>>    Send Add_Color_Element  EC_STRINGTYPING     (_T("String Typing"        , 1081)) 32  33   1   13   0
100058>>>>>    Send Add_Color_Element  EC_BRACEHLIGHT      (_T("Brace Highlight"      , 1082)) 34  35   1   14   0
100059>>>>>    Send Add_Color_Element  EC_UNMATCHEDBRACE   (_T("Unmatched Brace"      , 1083)) 36  37   1   15   0
100060>>>>>    Send Add_Color_Element  EC_METATAGS         (_T("Meta Tags"            , 1084)) 38  39   1   16   0
100061>>>>>    Send Add_Color_Element  EC_SELECTION        (_T("Selection"            , 1085)) 40   0   0    0   0
100062>>>>>    Send Add_Color_Element  EC_PREPROCESSOR     (_T("Pre-processor (Macro)", 1086)) 41  42   1   17   0
100063>>>>>    // Load current options
100063>>>>>    Send SetColorerCurrentStyles "" ""
100064>>>>>End_Procedure
100065>>>>>Send Register_Color_Elements
100066>>>>>
100066>>>>>Function CurrentColors Returns String
100069>>>>>    String[SC_COLORS_STRSIZE] sNewColors
100070>>>>>    Integer iElement iElements
100070>>>>>    String  sColorStr sColors
100070>>>>>    Integer iClr
100070>>>>>    Move (SizeOfArray(gtColorer)) to iElements
100071>>>>>    For iElement from 0 to (iElements-1)
100077>>>>>>
100077>>>>>        If (gtColorer[iElement].iForeOff) Begin
100079>>>>>            Move gtColorer[iElement].iForeC to iClr
100080>>>>>            If (iClr=-1) Begin
100082>>>>>                Move "255255255255" to sColorStr
100083>>>>>            End
100083>>>>>>
100083>>>>>            Else Begin
100084>>>>>                Get RGBStringFromRGB (R_From_RGB(iClr)) (G_From_RGB(iClr)) (B_From_RGB(iClr)) to sColorStr
100085>>>>>            End
100085>>>>>>
100085>>>>>            Move sColorStr to sNewColors[gtColorer[iElement].iForeOff-1]
100086>>>>>        End
100086>>>>>>
100086>>>>>        If (gtColorer[iElement].iBackOff) Begin
100088>>>>>            Move gtColorer[iElement].iBackC to iClr
100089>>>>>            If (iClr=-1) Begin
100091>>>>>                Move "255255255255" to sColorStr
100092>>>>>            End
100092>>>>>>
100092>>>>>            Else Begin
100093>>>>>                Get RGBStringFromRGB (R_From_RGB(iClr)) (G_From_RGB(iClr)) (B_From_RGB(iClr)) to sColorStr
100094>>>>>            End
100094>>>>>>
100094>>>>>            Move sColorStr to sNewColors[gtColorer[iElement].iBackOff-1]
100095>>>>>        End
100095>>>>>>
100095>>>>>    Loop
100096>>>>>>
100096>>>>>    //
100096>>>>>    Move "" to sColors
100097>>>>>    For iElement from 0 to (SizeOfArray(sNewColors)-1)
100103>>>>>>
100103>>>>>        Move (sColors + sNewColors[iElement]) to sColors
100104>>>>>    Loop
100105>>>>>>
100105>>>>>    Move (sColors+"000") to sColors
100106>>>>>    Function_Return sColors
100107>>>>>End_Function
100108>>>>>
100108>>>>>Function CurrentFontStyles Returns String
100111>>>>>    String[17] sFontStyle
100112>>>>>    Integer iElement iElements
100112>>>>>    String  sFontStr sFontStyles
100112>>>>>    Integer iFont
100112>>>>>    Move (SizeOfArray(gtColorer)) to iElements
100113>>>>>    For iElement from 0 to (iElements-1)
100119>>>>>>
100119>>>>>        If (gtColorer[iElement].iFont) Begin
100121>>>>>            Move (gtColorer[iElement].iBold+gtColorer[iElement].iItalics+gtColorer[iElement].iUnderline) to sFontStr
100122>>>>>            Move (Right('000'+sFontStr, 3)) to sFontStr
100123>>>>>            Move sFontStr to sFontStyle[gtColorer[iElement].iStyle-1]
100124>>>>>        End
100124>>>>>>
100124>>>>>    Loop
100125>>>>>>
100125>>>>>    //
100125>>>>>    Move "" to sFontStyles
100126>>>>>    For iElement from 0 to (SizeOfArray(sFontStyle)-1)
100132>>>>>>
100132>>>>>        Move (sFontStyles + sFontStyle[iElement]) to sFontStyles
100133>>>>>    Loop
100134>>>>>>
100134>>>>>    Move (sFontStyles+"000") to sFontStyles
100135>>>>>    Function_Return sFontStyles
100136>>>>>End_Function
100137>>>>>
100137>>>>>Class cEditorPreview is a cRichEdit
100138>>>>>    Procedure Construct_Object
100140>>>>>        Forward Send Construct_Object
100142>>>>>        Set Border_Style to Border_None
100143>>>>>        Set psTypeFace   to "Courier New"
100144>>>>>        Set piFontSize      to (10*20)
100145>>>>>        Set Read_Only_State to True
100146>>>>>    End_Procedure
100147>>>>>    
100147>>>>>    Procedure ChangeFontStyle String sFont Integer iFontSize
100149>>>>>        Send HideSelection True
100150>>>>>        Send Select_All    
100151>>>>>        Set psTypeFace      to sFont
100152>>>>>        Set piFontSize      to (iFontSize*20)
100153>>>>>        Send SetSel        0 0 // remove selection
100154>>>>>        Send HideSelection False
100155>>>>>    End_Procedure
100156>>>>>    
100156>>>>>    Procedure AddElement Integer iElement String sElement
100158>>>>>        Set TextColor       to  gtColorer[iElement].iForeC
100159>>>>>        Set TextBackColor   to  gtColorer[iElement].iBackC
100160>>>>>        Set pbBold          to  gtColorer[iElement].iBold
100161>>>>>        Set pbItalics       to  gtColorer[iElement].iItalics
100162>>>>>        Set pbUnderline     to  gtColorer[iElement].iUnderline
100163>>>>>        Send AppendText         sElement
100164>>>>>    End_Procedure
100165>>>>>    Procedure AddComment String sComment
100167>>>>>        Send AddElement EC_COMMENTS sComment
100168>>>>>    End_Procedure
100169>>>>>    Procedure AddScopeKeyword String sKeyword
100171>>>>>        Send AddElement EC_SCOPEKWORDS sKeyword
100172>>>>>    End_Procedure
100173>>>>>    Procedure AddKeyword String sKeyword
100175>>>>>        Send AddElement EC_KEYWORDS sKeyword
100176>>>>>    End_Procedure
100177>>>>>    Procedure AddText String sText
100179>>>>>        Send AddElement EC_TEXT sText
100180>>>>>    End_Procedure
100181>>>>>    Procedure AddNumber String sNumber
100183>>>>>        Send AddElement EC_NUMBERS sNumber
100184>>>>>    End_Procedure
100185>>>>>    Procedure AddOperator String sOperator
100187>>>>>        Send AddElement EC_OPERATORS sOperator
100188>>>>>    End_Procedure
100189>>>>>    Procedure AddString String sString
100191>>>>>        Send AddElement EC_STRINGS sString
100192>>>>>    End_Procedure
100193>>>>>    Procedure AddStringTyping String sString
100195>>>>>        Send AddElement EC_STRINGTYPING sString
100196>>>>>    End_Procedure
100197>>>>>    Procedure AddBraceHLight String sBraces
100199>>>>>        Send AddElement EC_BRACEHLIGHT sBraces
100200>>>>>    End_Procedure
100201>>>>>    Procedure AddUnmatchedBrace String sBraces
100203>>>>>        Send AddElement EC_UNMATCHEDBRACE sBraces
100204>>>>>    End_Procedure
100205>>>>>    Procedure AddPreProcessor String sMacro
100207>>>>>        Send AddElement EC_PREPROCESSOR sMacro
100208>>>>>    End_Procedure
100209>>>>>    Procedure AddSpacing String sSpaces
100211>>>>>        Set TextColor       to  gtColorer[EC_TEXT].iForeC
100212>>>>>        Set TextBackColor   to  gtColorer[EC_TEXT].iBackC
100213>>>>>        Set pbBold          to  0
100214>>>>>        Set pbItalics       to  0
100215>>>>>        Set pbUnderline     to  0
100216>>>>>        Send AppendText         sSpaces
100217>>>>>    End_Procedure
100218>>>>>    Procedure AddMetaTag String sMeta
100220>>>>>        Send AddElement EC_METATAGS sMeta
100221>>>>>    End_Procedure
100222>>>>>End_Class
100223>>>>>
100223>>>Use THDialog.pkg
100223>>>Use Font_dlg.pkg
100223>>>Use cImageList32.pkg
100223>>>Use cTextEdit.pkg
100223>>>Use cSCNotifierCheckBox.pkg
Including file: cSCNotifierCheckBox.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cSCNotifierCheckBox.pkg)
100223>>>>>Use cRDCCheckbox.pkg
100223>>>>>
100223>>>>>Class cSCNotifierCheckBox is a cRDCCheckbox
100224>>>>>
100224>>>>>    Procedure Construct_Object
100226>>>>>        Forward Send Construct_Object
100228>>>>>
100228>>>>>        On_Key key_F2 Send Request_SaveAllEntries
100229>>>>>        On_Key kCancel Send Close_Panel
100230>>>>>
100230>>>>>    End_Procedure
100231>>>>>
100231>>>>>    Procedure OnChange
100233>>>>>        Delegate Send NotifyChange
100235>>>>>    End_Procedure
100236>>>>>
100236>>>>>End_Class
100237>>>Use cSCWsGrid.pkg
Including file: cSCWsGrid.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cSCWsGrid.pkg)
100237>>>>>Use Windows.pkg
100237>>>>>
100237>>>>>Register_Procedure mRemoveLine
100237>>>>>Register_Procedure mInsertLine
100237>>>>>
100237>>>>>// Language Definition
100237>>>>>Struct tSCLanguage
100237>>>>>    String   sName
100237>>>>>    Integer  iProcedural
100237>>>>>    Integer  iCaseSensitive
100237>>>>>    String   sLineComments
100237>>>>>    String   sStringDelimiter
100237>>>>>    String   sMultiLineCommentStart
100237>>>>>    String   sMultiLineCommentStop
100237>>>>>    String   sEscapeChar
100237>>>>>    String   sLineTerminationChar
100237>>>>>    String   sMetaStart
100237>>>>>    String   sMetaStop
100237>>>>>    String[] saScopeStart
100237>>>>>    String[] saScopeStop
100237>>>>>    String[] saKeywords
100237>>>>>    String[] saOperators
100237>>>>>    String[] saTags
100237>>>>>    String[] saEntities
100237>>>>>    String[] saAttributes
100237>>>>>End_Struct
100237>>>>>
100237>>>>>Class cSCWsGrid is a Grid
100238>>>>>    Procedure Construct_Object
100240>>>>>        Forward Send Construct_Object
100242>>>>>
100242>>>>>        Set Size to 115 233
100243>>>>>        Set Location to 11 7
100244>>>>>        //        Set CurrentCellColor     to (RGB(39,150,216))
100244>>>>>        //        Set CurrentCellTextColor to clWhite
100244>>>>>        //        Set CurrentRowColor      to (RGB(39,150,216))
100244>>>>>        //        Set CurrentRowTextColor  to clWhite
100244>>>>>        Set Resize_Column_State to False
100245>>>>>        Set Highlight_Row_State to True
100246>>>>>        Set GridLine_Mode to Grid_Visible_Horz
100247>>>>>        Set Select_Mode to No_Select
100248>>>>>
100248>>>>>        On_Key Key_Delete Send mRemoveLine
100249>>>>>        On_Key Key_Insert Send mInsertLine
100250>>>>>        On_Key Key_Enter  Send Next
100251>>>>>    End_Procedure
100252>>>>>
100252>>>>>    Procedure DoFillGrid
100254>>>>>    End_Procedure
100255>>>>>
100255>>>>>    Function Base_Row_Item Integer iItem Returns Integer
100257>>>>>        Function_Return (iItem - Mod(iItem, Low(Matrix_Size(Self))))
100258>>>>>    End_Function
100259>>>>>
100259>>>>>End_Class
100260>>>Use cRDCHeaderGroup.pkg
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
100260>>>>>//****************************************************************************
100260>>>>>// $Module type: Package
100260>>>>>// $Module name: cRDCHeaderGroup.pkg
100260>>>>>//
100260>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100260>>>>>// Copyright (c) 2017 RDC Tools International
100260>>>>>// E-mail      : support@rdctools.com
100260>>>>>// Web-site    : http://www.rdctools.com
100260>>>>>//
100260>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
100260>>>>>//
100260>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100260>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100260>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100260>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100260>>>>>// in the help folder for more details.
100260>>>>>//
100260>>>>>//****************************************************************************
100260>>>>>Use Windows.pkg
100260>>>>>Use cCommandLinkButton.pkg
100260>>>>>
100260>>>>>
100260>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
100261>>>>>    Procedure Construct_Object
100263>>>>>        Forward Send Construct_Object
100265>>>>>
100265>>>>>        Set Size to 18 19
100266>>>>>        Set Focus_Mode to NonFocusable
100267>>>>>        Set peImageAlign to Button_ImageList_Align_Top
100268>>>>>        Set pbAutoResizeIcons to True
100269>>>>>    End_Procedure
100270>>>>>
100270>>>>>    Procedure OnClick
100272>>>>>        Broadcast Send Prompt of (Parent(Self))
100274>>>>>    End_Procedure
100275>>>>>
100275>>>>>    Procedure Set Bitmap String sBitmapName
100277>>>>>        Forward Set psImage to sBitmapName
100279>>>>>    End_Procedure
100280>>>>>
100280>>>>>    Procedure End_Construct_Object
100282>>>>>        Set pbShield to False
100283>>>>>        Forward Send End_Construct_Object
100285>>>>>    End_Procedure
100286>>>>>
100286>>>>>End_Class
100287>>>>>
100287>>>>>// Intermediate class - don't use.
100287>>>>>Class _cRDCHeaderGroup is a Container3d
100288>>>>>
100288>>>>>    Procedure Construct_Object
100290>>>>>        Forward Send Construct_Object
100292>>>>>
100292>>>>>        Property String private.psImage
100293>>>>>        Property String private.psLabel
100294>>>>>
100294>>>>>    End_Procedure
100295>>>>>
100295>>>>>    Procedure Set psImage String sImage
100297>>>>>        Set private.psImage to sImage
100298>>>>>    End_Procedure
100299>>>>>
100299>>>>>    Function psImage Returns String
100301>>>>>        Function_Return (private.psImage(Self))
100302>>>>>    End_Function
100303>>>>>
100303>>>>>    Procedure Set psLabel String sLabel
100305>>>>>        Set private.psLabel to sLabel
100306>>>>>    End_Procedure
100307>>>>>
100307>>>>>    Function psLabel Returns String
100309>>>>>        Function_Return (private.psLabel(Self))
100310>>>>>    End_Function
100311>>>>>
100311>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
100311>>>>>    Procedure Set Label String sLabel
100313>>>>>        Set psLabel to sLabel
100314>>>>>    End_Procedure
100315>>>>>
100315>>>>>    Function Label Returns String
100317>>>>>        Function_Return (private.psLabel(Self))
100318>>>>>    End_Function
100319>>>>>
100319>>>>>End_Class
100320>>>>>
100320>>>>>Register_Procedure NavigatePrevious
100320>>>>>Register_Procedure NavigateNext
100320>>>>>
100320>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
100321>>>>>
100321>>>>>    Procedure Construct_Object
100323>>>>>        Forward Send Construct_Object
100325>>>>>
100325>>>>>        Set peAnchors to anTopLeftRight
100326>>>>>        Set pbAcceptDropFiles to True
100327>>>>>        Set Border_Style to Border_Normal
100328>>>>>
100328>>>>>        Property Integer private.piColorOrg
100329>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
100330>>>>>        Property String private.psToolTip ""
100331>>>>>
100331>>>>>        Property Integer piImageColOffset 4
100332>>>>>        Property Integer piImageRowOffset -1
100333>>>>>        Property String psNote ""
100334>>>>>        Property Boolean pbLargeImageSize True
100335>>>>>        Property Integer private.piLargeImageSize 24
100336>>>>>        Property Integer private.piSmallImageSize 16
100337>>>>>        Property Boolean pbUseHotspotColor False
100338>>>>>        Property Integer piHeaderHotspotColor clAqua
100339>>>>>        Property String private.psLabel ""
100340>>>>>        Property Integer piLabelColor clGreenGrey
100341>>>>>        Property Boolean pbLabelFontItalics False
100342>>>>>        Property Integer piLabelLargeFontHeight 12
100343>>>>>        Property Integer piLabelSmallFontHeight 10
100344>>>>>        Property Boolean pbUseLargeFontHeight False
100345>>>>>
100345>>>>>        Property Integer piLabelFontPointWeight fw_Bold
100346>>>>>        Property Integer piLabelColOffset 28
100347>>>>>        Property Integer piLabelRowOffset 4
100348>>>>>        Property Boolean pbCreateTooltipItem True
100349>>>>>
100349>>>>>        Set pbAcceptDropFiles to True
100350>>>>>
100350>>>>>        Send Define_ToolTip_Support_Mixin
100351>>>>>
100351>>>>>        // For the Studio to render the header image
100351>>>>>        Set Bitmap to "Default32x32.bmp"
100352>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
100352>>>>>        // to render some text in the header when in design mode?
100352>>>>>        Set Label to "HEADER TEXT"
100353>>>>>
100353>>>>>        On_Key kLeftArrow  Send NavigatePrevious
100354>>>>>        On_Key kUpArrow    Send NavigatePrevious
100355>>>>>        On_Key kRightArrow Send NavigateNext
100356>>>>>        On_Key kDownArrow  Send NavigateNext
100357>>>>>        On_Key kSwitch     Send Switch_Next_Area
100358>>>>>    End_Procedure
100359>>>>>
100359>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
100360>>>>>
100360>>>>>    Procedure Set psImage String sImage
100362>>>>>        Set Bitmap to ""
100363>>>>>        Forward Set psImage to sImage
100365>>>>>    End_Procedure
100366>>>>>
100366>>>>>    Function psImage Returns String
100368>>>>>        Function_Return (psImage(Self))
100369>>>>>    End_Function
100370>>>>>
100370>>>>>    Procedure Set Label String sLabel
100372>>>>>        Forward Set psLabel to sLabel
100374>>>>>    End_Procedure
100375>>>>>
100375>>>>>    Procedure Set psToolTip String sToolTip
100377>>>>>        Set private.psToolTip to sToolTip
100378>>>>>    End_Procedure
100379>>>>>
100379>>>>>    Function psToolTip Returns String
100381>>>>>        Function_Return (private.psToolTip(Self))
100382>>>>>    End_Function
100383>>>>>
100383>>>>>    Procedure End_Construct_Object
100385>>>>>        String sNote sLabel
100385>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
100385>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
100385>>>>>
100385>>>>>        Forward Send End_Construct_Object
100387>>>>>
100387>>>>>        Get piLabelColOffset to iLabelColOffset
100388>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
100389>>>>>        If (bUseLargeFontHeight = True) Begin
100391>>>>>            Get piLabelLargeFontHeight to iFontHeight
100392>>>>>            Move 8 to iLabelRowOffset
100393>>>>>        End
100393>>>>>>
100393>>>>>        Else Begin
100394>>>>>            Get piLabelSmallFontHeight to iFontHeight
100395>>>>>            Move 6 to iLabelRowOffset
100396>>>>>        End
100396>>>>>>
100396>>>>>
100396>>>>>        Get pbLargeImageSize to bLargeImageSize
100397>>>>>        If (bLargeImageSize = True) Begin
100399>>>>>            Get private.piLargeImageSize to iImageSize
100400>>>>>        End
100400>>>>>>
100400>>>>>        Else Begin
100401>>>>>            Get private.piSmallImageSize to iImageSize
100402>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
100403>>>>>        End
100403>>>>>>
100403>>>>>
100403>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
100405>>>>>            Set piImageSize to iImageSize
100406>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
100407>>>>>            Set psImage to (private.psImage(Self))
100408>>>>>            Set peImageAlign to Button_ImageList_Align_Center
100409>>>>>            Set psToolTip to (private.psToolTip(Self))
100410>>>>>        End_Object
100411>>>>>
100411>>>>>        Object oHeaderGroupInfo_tb is a TextBox
100413>>>>>            Set Size to 12 100
100414>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
100415>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
100416>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
100417>>>>>            Set FontPointHeight to iFontHeight
100418>>>>>            Set Label to (private.psLabel(Self))
100419>>>>>            Set TextColor to (piLabelColor(Self))
100420>>>>>            Set psToolTip to (private.psToolTip(Self))
100421>>>>>            Get Size to iSize
100422>>>>>        End_Object
100423>>>>>
100423>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
100423>>>>>        // How can it be improved?
100423>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
100424>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
100426>>>>>            Get private.psLabel to sLabel
100427>>>>>            Get Text_Extent sLabel to iTextOffset
100428>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
100429>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
100431>>>>>                Set Size to 10 10
100432>>>>>                If (bUseLargeFontHeight = True) Begin
100434>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
100434>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
100435>>>>>                End
100435>>>>>>
100435>>>>>                Else Begin
100436>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
100436>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
100437>>>>>                End
100437>>>>>>
100437>>>>>                Set psToolTip to (private.psToolTip(Self))
100438>>>>>                Set Bitmap to "ActionAbout.bmp"
100439>>>>>            End_Object
100440>>>>>        End
100440>>>>>>
100440>>>>>
100440>>>>>        Get psNote to sNote
100441>>>>>        If (Trim(sNote) <> "") Begin
100443>>>>>            Object oHeaderGroupNote_tb is a TextBox
100445>>>>>                Set Size to 12 100
100446>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
100447>>>>>                Set Label to ("-" * String(sNote))
100448>>>>>                Set TextColor to (piLabelColor(Self))
100449>>>>>                Set FontPointHeight to 9
100450>>>>>                Set psToolTip to (private.psToolTip(Self))
100451>>>>>            End_Object
100452>>>>>        End
100452>>>>>>
100452>>>>>
100452>>>>>    End_Procedure
100453>>>>>
100453>>>>>    Function Popup_State Returns Boolean
100455>>>>>        Boolean bIsPopup
100455>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
100456>>>>>        Function_Return bIsPopup
100457>>>>>    End_Function
100458>>>>>
100458>>>>>    Procedure OnEnterArea Handle hoFrom
100460>>>>>        Integer iColor
100460>>>>>        Forward Send OnEnterArea hoFrom
100462>>>>>        // Not ideal, but works most of the time.
100462>>>>>        //       When navigating to i.e a popup we don't want
100462>>>>>        //       the coloring to appear. Else there will be 2
100462>>>>>        //       cRDCHeaderGroup's with the highlight color...
100462>>>>>        // Is there a better way?
100462>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
100464>>>>>            Procedure_Return
100465>>>>>        End
100465>>>>>>
100465>>>>>        If (pbUseHotspotColor(Self) = True) Begin
100467>>>>>            Get Color to iColor
100468>>>>>            Set private.piColorOrg to iColor
100469>>>>>            Get piHeaderHotspotColor to iColor
100470>>>>>            Set Color to iColor
100471>>>>>            Broadcast Recursive Set Color to iColor
100473>>>>>        End
100473>>>>>>
100473>>>>>    End_Procedure
100474>>>>>
100474>>>>>    Procedure OnExitArea Handle hoFrom
100476>>>>>        Integer iColor
100476>>>>>        Forward Send OnExitArea hoFrom
100478>>>>>        If (pbUseHotspotColor(Self) = True) Begin
100480>>>>>            Get private.piColorOrg to iColor
100481>>>>>            Set Color to iColor
100482>>>>>            Broadcast Recursive Set Color to iColor
100484>>>>>        End
100484>>>>>>
100484>>>>>    End_Procedure
100485>>>>>
100485>>>>>    // Public access message to change the group header text color at runtime.
100485>>>>>    Procedure Set Label_Color Integer iColor
100487>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
100488>>>>>    End_Procedure
100489>>>>>
100489>>>>>    Procedure NavigatePrevious
100491>>>>>        Integer iMulti ivoid iLastErr
100491>>>>>        Handle hWnd
100491>>>>>        Boolean bErr
100491>>>>>
100491>>>>>        Move Err to bErr
100492>>>>>        Move LastErr to iLastErr
100493>>>>>
100493>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100494>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
100495>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100496>>>>>        If (Err) Begin
100498>>>>>            Move bErr to Err
100499>>>>>            Move iLastErr to LastErr
100500>>>>>            Procedure_Return
100501>>>>>        End
100501>>>>>>
100501>>>>>
100501>>>>>        Move bErr to Err
100502>>>>>        Move iLastErr to LastErr
100503>>>>>        If (iMulti = Multi_Select) Begin
100505>>>>>            Send Previous
100506>>>>>        End
100506>>>>>>
100506>>>>>        Else Begin
100507>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
100508>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
100509>>>>>        End
100509>>>>>>
100509>>>>>    End_Procedure
100510>>>>>
100510>>>>>    Procedure NavigateNext
100512>>>>>        Integer iMulti iVoid iLastErr
100512>>>>>        Handle hWnd
100512>>>>>        Boolean bErr
100512>>>>>
100512>>>>>        Move Err to bErr
100513>>>>>        Move LastErr to iLastErr
100514>>>>>
100514>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100515>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
100516>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100517>>>>>        If (Err) Begin
100519>>>>>            Move bErr to Err
100520>>>>>            Move iLastErr to LastErr
100521>>>>>            Procedure_Return
100522>>>>>        End
100522>>>>>>
100522>>>>>
100522>>>>>        Move bErr to Err
100523>>>>>        Move iLastErr to LastErr
100524>>>>>        If (iMulti = Multi_Select) Begin
100526>>>>>            Send Next
100527>>>>>        End
100527>>>>>>
100527>>>>>        Else Begin
100528>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
100529>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
100530>>>>>        End
100530>>>>>>
100530>>>>>
100530>>>>>    End_Procedure
100531>>>>>
100531>>>>>    Procedure Enable_Window Integer iState
100533>>>>>        Handle hWnd
100533>>>>>        Get Window_Handle to hWnd
100534>>>>>        If hWnd Begin
100536>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
100537>>>>>        End
100537>>>>>>
100537>>>>>    End_Procedure
100538>>>>>
100538>>>>>    Procedure Page_Object Integer iState
100540>>>>>        Handle hWnd
100540>>>>>        Get Window_Handle to hWnd
100541>>>>>        Forward Send Page_Object iState
100543>>>>>        If (hWnd = 0 and iState) Begin
100545>>>>>            Send Shadow_Display
100546>>>>>        End
100546>>>>>>
100546>>>>>    End_Procedure
100547>>>>>
100547>>>>>    Procedure Shadow_Display
100549>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
100550>>>>>    End_Procedure
100551>>>>>
100551>>>>>    Function Explicit_Shadow_State Returns Boolean
100553>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
100554>>>>>    End_Function
100555>>>>>
100555>>>>>    // For some reason we need to augment this event to allow
100555>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
100555>>>>>    // happen.
100555>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
100557>>>>>        Delegate Send OnFileDropped sFilename bLast
100559>>>>>    End_Procedure
100560>>>>>
100560>>>>>End_Class
100561>>>>>
100561>>>>>// We don't want the broadcast of setting color to set the background
100561>>>>>// color for forms that are within a cRDCHeaderGroup object.
100561>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
100561>>>>>// behave as it always has. But if you don't like this; just comment
100561>>>>>// it out.
100561>>>>>//Procedure Set Color for Form Integer eColor
100561>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
100561>>>>>//    Integer iLastErr
100561>>>>>//
100561>>>>>//    Move Err to bErr
100561>>>>>//    Move LastErr to iLastErr
100561>>>>>//
100561>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100561>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
100561>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100561>>>>>//    Move bErr to Err
100561>>>>>//    Move iLastErr to LastErr
100561>>>>>//    If (bIsHeaderGroup = False) Begin
100561>>>>>//        Forward Set Color to eColor
100561>>>>>//    End
100561>>>>>//End_Procedure
100561>>>Use cRDCButtonDPI.pkg
100561>>>Use RefactorFunctionConstants.inc
100561>>>Use Windows.pkg
100561>>>
100561>>>Struct tFontSpecs
100561>>>    String sFontName
100561>>>    Integer iSize
100561>>>    Integer iCharSet
100561>>>End_Struct
100561>>>
100561>>>Function ScintillaFontAsStruct Global String sFace Returns tFontSpecs
100563>>>    Integer iSize iCharSet
100563>>>    String sFont sFontSz sCharSet
100563>>>    tFontSpecs FontSpecs
100563>>>    tFontSpecs FontSpecs
100563>>>
100563>>>    If (sFace = "") Begin
100565>>>        Move "11pt; 0; Courier New"             to sFace
100566>>>    End
100566>>>>
100566>>>    Move (Left(sFace, Pos(';', sFace)))         to sFontSz
100567>>>    Move (Trim(Replace(sFontSz, sFace, "")))    to sFace
100568>>>    Move (Replaces(' ', sFontSz, ""))           to sFontSz
100569>>>    Move (Left(sFontSz, Length(sFontSz)-3))     to FontSpecs.iSize
100570>>>    Move (Left(sFace, Pos(';', sFace)))         to sCharSet
100571>>>    Move (Trim(Replace(sCharSet, sFace, "")))   to FontSpecs.sFontName
100572>>>    Move (Left(sCharSet, Length(sCharSet)-1))   to FontSpecs.iCharSet
100573>>>
100573>>>    Function_Return FontSpecs
100574>>>End_Function
100575>>>
100575>>>Function ScintillaEditorFontFormat Global tFontSpecs FontSpecs Returns String
100577>>>    Function_Return (String(FontSpecs.iSize) + "pt;" * String(FontSpecs.iCharSet) + ";" * FontSpecs.sFontName)
100578>>>End_Function
100579>>>
100579>>>Function ScintillaReadableFontFormat Global String sFace Returns String
100581>>>    tFontSpecs FontSpecs
100581>>>    tFontSpecs FontSpecs
100581>>>    Get ScintillaFontAsStruct sFace to FontSpecs
100582>>>    Function_Return (FontSpecs.sFontName + "," * String(FontSpecs.iSize) + "pt")
100583>>>End_Function
100584>>>
100584>>>Object oScintillaParameters_dg is a cRDCModalPanel
100586>>>    Set Size to 258 447
100587>>>    Set Label to "Editor Settings"
100588>>>    Set piMinSize to 238 439
100589>>>    Set Location to 2 2
100590>>>    Set Icon to "EditorSettings.ico"
100591>>>
100591>>>    Object oImages_lst is a cImageList32
100593>>>        Set piMaxImages to 4
100594>>>        Procedure OnCreate
100597>>>            Integer iItem
100597>>>            Get AddIcon "Colors.ico"            to iItem
100598>>>            Get AddIcon "KeyWords.ico"          to iItem
100599>>>            Get AddIcon "Keyboard.ico"          to iItem
100600>>>            Get AddIcon "SettingsEditor.ico"    to iItem
100601>>>        End_Procedure
100602>>>    End_Object
100603>>>
100603>>>    Object oEditorTabDialog is a TabDialog
100605>>>        Set Size to 228 441
100606>>>        Set Location to 4 3
100607>>>        Set phoImageList to oImages_lst
100608>>>        Set peAnchors to anAll
100609>>>
100609>>>        Object oFontsPage is a TabPage
100611>>>            Set Label to "Color/Font"
100612>>>            Set piImageIndex to 0
100613>>>
100613>>>            Object oColorsGroup is a cRDCHeaderGroup
100615>>>                Set Size to 206 428
100616>>>                Set Location to 5 4
100617>>>                Set Label to "Colors and Font"
100618>>>                Set psImage to "Colors.ico"
100619>>>                Set peAnchors to anAll
100620>>>
100620>>>                Object oCategory is a TreeView
100622>>>                    Set Size to 153 106
100623>>>                    Set Location to 46 7
100624>>>                    Set pbFullRowSelect to True
100625>>>                    Set piTextColor to clBlack
100626>>>                    Set pbExplorerStyle to True
100627>>>                    Set peAnchors to anTopBottomLeft
100628>>>
100628>>>                    // Initializes colorer and populates the Tree
100628>>>                    Procedure OnCreateTree
100631>>>                        Handle  hItem
100631>>>                        Integer iItem iItems
100631>>>
100631>>>                        Move (SizeOfArray(gtColorer)) to iItems
100632>>>                        For iItem From 0 to (iItems-1)
100638>>>>
100638>>>                            Get AddTreeItem gtColorer[iItem].sName 0 iItem 0 0 to hItem
100639>>>                        Loop
100640>>>>
100640>>>                        Set Visible_State of oColor         to False
100641>>>                        Set Visible_State of oBackground    to False
100642>>>                    End_Procedure
100643>>>
100643>>>                    Procedure OnItemChanged Handle hItem Handle hItemOld
100646>>>                        Integer iIndex
100646>>>                        String  sLabel
100646>>>
100646>>>                        // Collect Item Data of the selected Colorer Item
100646>>>                        Get ItemData  hItem to iIndex
100647>>>                        Get ItemLabel hItem to sLabel
100648>>>
100648>>>                        // Manage color pickers
100648>>>                        Set Visible_State of oColor         to gtColorer[iIndex].iForeOff
100649>>>                        Set Visible_State of oBackground    to gtColorer[iIndex].iBackOff
100650>>>                        Set Visible_State of oFontBold      to gtColorer[iIndex].iBackOff
100651>>>                        Set Visible_State of oFontItalics   to gtColorer[iIndex].iBackOff
100652>>>                        Set Visible_State of oFontUnderline to gtColorer[iIndex].iBackOff
100653>>>
100653>>>                        // Show the current color if applicable
100653>>>                        Set piColorerIndex of oColor        to iIndex
100654>>>                        Set piColorerIndex of oBackground   to iIndex
100655>>>                        If (gtColorer[iIndex].iForeOff) ;                        Set SlectedColor of oColor      to gtColorer[iIndex].iForeC
100658>>>                        If (gtColorer[iIndex].iBackOff) ;                        Set SlectedColor of oBackground to gtColorer[iIndex].iBackC
100661>>>
100661>>>                        // Font flags
100661>>>                        Set piColorerIndex of oFontBold      to iIndex
100662>>>                        Set piColorerIndex of oFontItalics   to iIndex
100663>>>                        Set piColorerIndex of oFontUnderline to iIndex
100664>>>                        Set Checked_State  of oFontBold      to gtColorer[iIndex].iBold
100665>>>                        Set Checked_State  of oFontItalics   to gtColorer[iIndex].iItalics
100666>>>                        Set Checked_State  of oFontUnderline to gtColorer[iIndex].iUnderline
100667>>>
100667>>>                        // Notify color picker about current colorer element
100667>>>                        Send mGeneratePreview
100668>>>                    End_Procedure
100669>>>
100669>>>                    On_Key Key_Up_Arrow Send Up
100670>>>                    On_Key Key_Down_Arrow Send Down
100671>>>                End_Object
100672>>>
100672>>>                Object oColor is a cColorBox
100674>>>                    Set Size to 22 105
100675>>>                    Set Location to 47 120
100676>>>                    Set Label to "Color"
100677>>>                    Procedure OnColorChange
100680>>>                        Integer iColor
100680>>>                        Get SelectedColor to iColor
100681>>>                        Move iColor to gtColorer[piColorerIndex(Self)].iForeC
100682>>>                        Send mGeneratePreview
100683>>>                        Delegate Send NotifyChange
100685>>>                    End_Procedure
100686>>>                End_Object
100687>>>
100687>>>                Object oBackground is a cColorBox
100689>>>                    Set Size to 22 105
100690>>>                    Set Location to 72 120
100691>>>                    Set Label to "Background"
100692>>>                    Procedure OnColorChange
100695>>>                        Integer iColor
100695>>>                        Get SelectedColor to iColor
100696>>>                        Move iColor to gtColorer[piColorerIndex(Self)].iBackC
100697>>>                        Send mGeneratePreview
100698>>>                        Delegate Send NotifyChange
100700>>>                    End_Procedure
100701>>>                End_Object
100702>>>
100702>>>                Object oFontBold is a CheckBox
100704>>>                    Property Integer piColorerIndex
100706>>>                    Set Size to 10 50
100707>>>                    Set Location to 107 151
100708>>>                    Set Label to "Bold"
100709>>>                    Set FontWeight to fw_Bold
100710>>>                    Set Visible_State to False
100711>>>                    Procedure OnChange
100714>>>                        If (Focus(Desktop)=Self) Begin
100716>>>                            Get Checked_State to gtColorer[piColorerIndex(Self)].iBold
100717>>>                            Send mGeneratePreview
100718>>>                            Delegate Send NotifyChange
100720>>>                        End
100720>>>>
100720>>>                    End_Procedure
100721>>>                End_Object
100722>>>
100722>>>                Object oFontItalics is a CheckBox
100724>>>                    Property Integer piColorerIndex
100726>>>                    Set Size to 10 50
100727>>>                    Set Location to 118 151
100728>>>                    Set Label to "Italics"
100729>>>                    Set FontItalics to True
100730>>>                    Set Visible_State to False
100731>>>                    Procedure OnChange
100734>>>                        If (Focus(Desktop)=Self) Begin
100736>>>                            Get Checked_State to gtColorer[piColorerIndex(Self)].iItalics
100737>>>                            Send mGeneratePreview
100738>>>                            Delegate Send NotifyChange
100740>>>                        End
100740>>>>
100740>>>                    End_Procedure
100741>>>                End_Object
100742>>>
100742>>>                Object oFontUnderline is a CheckBox
100744>>>                    Property Integer piColorerIndex
100746>>>                    Set Size to 10 50
100747>>>                    Set Location to 129 151
100748>>>                    Set Label to "Underline"
100749>>>                    Set FontUnderline to True
100750>>>                    Set Visible_State to False
100751>>>                    Procedure OnChange
100754>>>                        If (Focus(Desktop)=Self) Begin
100756>>>                            Get Checked_State to gtColorer[piColorerIndex(Self)].iUnderline
100757>>>                            Send mGeneratePreview
100758>>>                            Delegate Send NotifyChange
100760>>>                        End
100760>>>>
100760>>>                    End_Procedure
100761>>>                End_Object
100762>>>
100762>>>                Object oPreview is a Container3d
100764>>>                    Set Size to 157 190
100765>>>                    Set Location to 46 232
100766>>>                    Set Border_Style to Border_ClientEdge
100767>>>                    Set Color to clWhite
100768>>>                    Set peAnchors to anAll
100769>>>
100769>>>                    Object oLeftMarginPreview is a Container3d
100771>>>                        Set Size to 156 14
100772>>>                        Set Location to 0 0
100773>>>                        Set Border_Style to Border_None
100774>>>                        Set peAnchors to anAll
100775>>>                    End_Object
100776>>>
100776>>>                    Object oNumbersPreview is a TextBox
100778>>>                        Set Auto_Size_State to False
100779>>>                        Set Size to 179 12
100780>>>                        Set Location to 0 14
100781>>>                        Set Label to ("01"+Character(10)+"02"+Character(10)+"03"+Character(10)+"04"+Character(10)+"05"+ ;                        Character(10)+"06"+Character(10)+"07"+Character(10)+"08"+Character(10)+"09"+ ;                        Character(10)+"10"+Character(10)+"11"+Character(10)+"12"+Character(10)+"13"+ ;                        Character(10)+"14"+Character(10)+"15"+Character(10)+"16"+Character(10)+"17"+ ;                        Character(10)+"18"+Character(10)+"19")
100782>>>                        Set FontWeight to fw_Bold
100783>>>                        Set Color to clDkGray
100784>>>                        Set TextColor to clWhite
100785>>>                        Set Justification_Mode to JMode_Center
100786>>>                        Set Typeface to "Courier New"
100787>>>                        Set peAnchors to anTopBottomLeft
100788>>>                    End_Object
100789>>>
100789>>>                    Object oEditorPreview is a cEditorPreview
100791>>>                        Set Size to 162 158
100792>>>                        Set Location to 0 29
100793>>>                        Set peAnchors to anAll
100794>>>                    End_Object
100795>>>
100795>>>                End_Object
100796>>>
100796>>>                Procedure mGeneratePreview
100799>>>                    Integer iForeColor iOriFore iSize
100799>>>                    String sFont
100799>>>                    tFontSpecs FontSpecs
100799>>>                    tFontSpecs FontSpecs
100799>>>
100799>>>                    Set Dynamic_Update_State of oEditorPreview to False
100800>>>                    Send Delete_Data to oEditorPreview
100801>>>
100801>>>                    // General Appearance
100801>>>                    Move gtColorer[EC_WINDOW].iForeC  to iForeColor
100802>>>                    If (iForeColor<0) Begin
100804>>>                        Move clWhite to iForeColor
100805>>>                    End
100805>>>>
100805>>>                    Set Color of oEditorPreview to iForeColor
100806>>>                    Set Color of oPreview to iForeColor
100807>>>
100807>>>                    // Left Marging
100807>>>                    Set Color               of oLeftMarginPreview   to gtColorer[EC_LEFTMARGIN].iForeC
100808>>>
100808>>>                    // Line Numbers
100808>>>                    Set TextColor           of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iForeC //iForeColor
100809>>>                    Set Color               of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iBackC //iBackColor
100810>>>                    Set FontWeight          of oNumbersPreview      to (gtColorer[EC_LINENUMBERS].iBold * 800)
100811>>>                    Set FontItalics         of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iItalics
100812>>>                    Set FontUnderline       of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iUnderline
100813>>>
100813>>>                    // Font
100813>>>                    Get psEditorFont of oFontFace to sFont
100814>>>                    Get ScintillaFontAsStruct sFont to FontSpecs
100815>>>                    Move FontSpecs.sFontName to sFont
100816>>>                    Move ((FontSpecs.iSize - 2) * 20) to iSize
100817>>>                    Set psTypeFace          of oEditorPreview to sFont
100818>>>                    Set piFontSize          of oEditorPreview to iSize
100819>>>
100819>>>                    // Elements
100819>>>                    Get TextColor           of oEditorPreview to iOriFore
100820>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Pre-processor/Macro", 1055))
100821>>>                    Send AppendTextLn       to oEditorPreview ""
100822>>>                    Send AddPreProcessor    to oEditorPreview "#COMMAND _DEBUG"
100823>>>                    Send AppendTextLn       to oEditorPreview ""
100824>>>                    Send AddPreProcessor    to oEditorPreview "#ENDCOMMAND"
100825>>>                    Send AppendTextLn       to oEditorPreview ""
100826>>>                    Send AppendTextLn       to oEditorPreview ""
100827>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Metatags, Keywords, Strings", 1056))
100828>>>                    Send AppendTextLn       to oEditorPreview ""
100829>>>                    Send AddMetaTag         to oEditorPreview ('{Description="'+ _T("Meta tag", 1057) +'"}')
100830>>>                    Send AppendTextLn       to oEditorPreview ""
100831>>>                    Send AddScopeKeyword    to oEditorPreview "Function"
100832>>>                    Send AddSpacing         to oEditorPreview " "
100833>>>                    Send AddText            to oEditorPreview "mFoo"
100834>>>                    Send AddText            to oEditorPreview " "
100835>>>                    Send AddKeyword         to oEditorPreview "Returns String"
100836>>>                    Send AppendTextLn       to oEditorPreview ""
100837>>>                    Send AddSpacing         to oEditorPreview "    "
100838>>>                    Send AddKeyword         to oEditorPreview "String"
100839>>>                    Send AddSpacing         to oEditorPreview " "
100840>>>                    Send AddText            to oEditorPreview "sRetVal"
100841>>>                    Send AppendTextLn       to oEditorPreview ""
100842>>>                    Send AddSpacing         to oEditorPreview "    "
100843>>>                    Send AddKeyword         to oEditorPreview "Move"
100844>>>                    Send AddSpacing         to oEditorPreview " "
100845>>>                    Send AddText            to oEditorPreview "("
100846>>>                    Send AddString          to oEditorPreview ('"'+_T("Hello", 1058)+'"')
100847>>>                    Send AddSpacing         to oEditorPreview " "
100848>>>                    Send AddOperator        to oEditorPreview "*"
100849>>>                    Send AddSpacing         to oEditorPreview " "
100850>>>                    Send AddString          to oEditorPreview ('"'+_T("World!", 1059)+'"')
100851>>>                    Send AddText            to oEditorPreview ")"
100852>>>                    Send AddSpacing         to oEditorPreview " "
100853>>>                    Send AddOperator        to oEditorPreview ";"
100854>>>                    Send AppendTextLn       to oEditorPreview ""
100855>>>                    Send AddSpacing         to oEditorPreview "        "
100856>>>                    Send AddKeyword         to oEditorPreview "to"
100857>>>                    Send AddSpacing         to oEditorPreview " "
100858>>>                    Send AddText            to oEditorPreview "sRetVal"
100859>>>                    Send AppendTextLn       to oEditorPreview ""
100860>>>                    Send AddSpacing         to oEditorPreview "    "
100861>>>                    Send AddKeyword         to oEditorPreview "Function_Return"
100862>>>                    Send AddSpacing         to oEditorPreview " "
100863>>>                    Send AddText            to oEditorPreview "sRetVal"
100864>>>                    Send AppendTextLn       to oEditorPreview ""
100865>>>                    Send AddScopeKeyword    to oEditorPreview "End_Function"
100866>>>                    Send AddSpacing         to oEditorPreview " "
100867>>>                    Send AddComment         to oEditorPreview "// mFoo"
100868>>>                    Send AppendTextLn       to oEditorPreview ""
100869>>>                    Send AppendTextLn       to oEditorPreview ""
100870>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Numbers & Braces", 1060))
100871>>>                    Send AppendTextLn       to oEditorPreview ""
100872>>>                    Send AddKeyword         to oEditorPreview "Number"
100873>>>                    Send AddSpacing         to oEditorPreview " "
100874>>>                    Send AddText            to oEditorPreview "nVal"
100875>>>                    Send AppendTextLn       to oEditorPreview ""
100876>>>                    Send AddKeyword         to oEditorPreview "Move"
100877>>>                    Send AddSpacing         to oEditorPreview " "
100878>>>                    Send AddBraceHLight     to oEditorPreview "("
100879>>>                    Send AddNumber          to oEditorPreview '1.23'
100880>>>                    Send AddSpacing         to oEditorPreview " "
100881>>>                    Send AddOperator        to oEditorPreview "+"
100882>>>                    Send AddSpacing         to oEditorPreview " "
100883>>>                    Send AddText            to oEditorPreview "("
100884>>>                    Send AddNumber          to oEditorPreview '12'
100885>>>                    Send AddSpacing         to oEditorPreview " "
100886>>>                    Send AddOperator        to oEditorPreview "*"
100887>>>                    Send AddSpacing         to oEditorPreview " "
100888>>>                    Send AddNumber          to oEditorPreview '$02'
100889>>>                    Send AddText            to oEditorPreview ")"
100890>>>                    Send AddBraceHLight     to oEditorPreview ")"
100891>>>                    Send AddUnmatchedBrace  to oEditorPreview ")"
100892>>>                    Send AddSpacing         to oEditorPreview " "
100893>>>                    Send AddKeyword         to oEditorPreview "to"
100894>>>                    Send AddSpacing         to oEditorPreview " "
100895>>>                    Send AddText            to oEditorPreview "nVal"
100896>>>
100896>>>                    Send AppendTextLn       to oEditorPreview ""
100897>>>                    Send AppendTextLn       to oEditorPreview ""
100898>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Typing String", 1061))
100899>>>                    Send AppendTextLn       to oEditorPreview ""
100900>>>                    Send AddKeyword         to oEditorPreview "Move"
100901>>>                    Send AddSpacing         to oEditorPreview " "
100902>>>                    Send AddStringTyping    to oEditorPreview ('"'+_T("Typing new String", 1062))
100903>>>                    Send AppendTextLn       to oEditorPreview ""
100904>>>
100904>>>                    Set TextColor   of oEditorPreview to iOriFore
100905>>>                    Set Enabled_State of oSave to False
100906>>>                    Send ChangeFontStyle     of oEditorPreview sFont FontSpecs.iSize
100907>>>                    Set Dynamic_Update_State of oEditorPreview to True
100908>>>                    Send Beginning_of_Data   of oEditorPreview
100909>>>                    // Make the line numbers line up with the new font
100909>>>                    Set Typeface        of oNumbersPreview to sFont
100910>>>                    Set FontPointHeight of oNumbersPreview to FontSpecs.iSize
100911>>>                End_Procedure
100912>>>
100912>>>                Object oSchemaSelect is a ComboForm
100914>>>                    Set Size to 13 106
100915>>>                    Set Location to 30 7
100916>>>                    Set Label to "Color Theme:"
100917>>>                    Set Label_Col_Offset to 0
100918>>>                    Set Label_Justification_Mode to JMode_Top
100919>>>                    Set Label_Row_Offset to 1
100920>>>
100920>>>                    Procedure Combo_Fill_List
100923>>>                        String  sCur
100923>>>
100923>>>                        // Defauls Schemas
100923>>>                        Send Combo_Add_Item TH_DEFSCHEMA_WHITE_STR
100924>>>                        Send Combo_Add_Item TH_DEFSCHEMA_BLACK_STR
100925>>>                        Send Combo_Add_Item TH_DEFSCHEMA_BLUE_STR
100926>>>                        Send Combo_Add_Item TH_DEFSCHEMA_LIME_STR
100927>>>                        Send Combo_Add_Item TH_DEFSCHEMA_SERENE_STR
100928>>>                        Send Combo_Add_Item TH_DEFSCHEMA_SAHARA_STR
100929>>>
100929>>>                        Get psColorSchema of ghoEditorProperties to sCur
100930>>>                        If (sCur = "") Begin
100932>>>                            Move TH_DEFSCHEMA_WHITE_STR to sCur
100933>>>                            Set psColorSchema of ghoEditorProperties to sCur
100934>>>                        End
100934>>>>
100934>>>
100934>>>                        Set Value to sCur
100935>>>                        Set Entry_State to False
100936>>>                    End_Procedure
100937>>>
100937>>>                    Procedure OnChange
100940>>>                        Boolean bDefaultSchema
100940>>>                        String sName sSchema sFontStyles
100940>>>                        Integer iC iPos
100940>>>
100940>>>                        If (Focus(Desktop) = Self) Begin
100942>>>                            Move True to bDefaultSchema
100943>>>                            Get Value Item 0 to sName
100944>>>                            Move TH_COLORSCHEMA_WHITE to sSchema
100945>>>                            Get psFontStyles of ghoEditorProperties to sFontStyles
100946>>>                            If (sName = TH_DEFSCHEMA_BLACK_STR) Begin
100948>>>                                Move TH_COLORSCHEMA_BLACK to sSchema
100949>>>                            End
100949>>>>
100949>>>                            Else If (sName = TH_DEFSCHEMA_BLUE_STR) Begin
100952>>>                                Move TH_COLORSCHEMA_BLUE to sSchema
100953>>>                            End
100953>>>>
100953>>>                            Else If (sName = TH_DEFSCHEMA_LIME_STR) Begin
100956>>>                                Move TH_COLORSCHEMA_LIME to sSchema
100957>>>                            End
100957>>>>
100957>>>                            Else If (sName=TH_DEFSCHEMA_SERENE_STR) Begin
100960>>>                                Move TH_COLORSCHEMA_SERENE   to sSchema
100961>>>                            End
100961>>>>
100961>>>                            Else If (sName=TH_DEFSCHEMA_SAHARA_STR) Begin
100964>>>                                Move TH_COLORSCHEMA_SAHARA   to sSchema
100965>>>                            End
100965>>>>
100965>>>                            Else If (sName <> TH_DEFSCHEMA_WHITE_STR) Begin
100968>>>                                Move False to bDefaultSchema
100969>>>                                Get FindColorSchema of ghoEditorProperties sName to iC
100970>>>                                If (iC >= 0) Begin
100972>>>                                    Get psColorSchemas.psSchemaColors       of ghoEditorProperties Item iC to sSchema
100973>>>                                    Get psColorSchemas.psSchemaFontStyles   of ghoEditorProperties Item iC to sFontStyles
100974>>>                                End
100974>>>>
100974>>>                            End
100974>>>>
100974>>>                            If (bDefaultSchema) Begin
100976>>>                                Move (Pos(",", sSchema)) to iPos
100977>>>                                If (iPos>0) Begin
100979>>>                                    Move (Right(sSchema, Length(sSchema) - iPos)) to sFontStyles
100980>>>                                    Move (Left(sSchema, (iPos - 1))) to sSchema
100981>>>                                End
100981>>>>
100981>>>                                Else Begin
100982>>>                                // use the default font style if not defined.
100982>>>                                    Move (Repeat('0', 3 * 16) + "000") to sFontStyles
100983>>>                                End
100983>>>>
100983>>>                            End
100983>>>>
100983>>>
100983>>>                            Send SetColorerCurrentStyles sSchema sFontStyles
100984>>>                            Send mGeneratePreview to oColorsGroup
100985>>>
100985>>>                            Delegate Send NotifyChange
100987>>>                        End
100987>>>>
100987>>>                    End_Procedure
100988>>>
100988>>>                    On_Key Key_F2  Send SaveEntries
100989>>>                    On_Key kCancel Send Close_Panel
100990>>>                End_Object
100991>>>
100991>>>                Object oFontFace is a Form
100993>>>                    Set Size to 13 105
100994>>>                    Set Location to 30 120
100995>>>                    Set Label_Col_Offset to 0
100996>>>                    Set Label_Justification_Mode to JMode_Top
100997>>>                    Set Prompt_Button_Mode to PB_PromptOn
100998>>>                    Set Label to "Font:"
100999>>>                    Set Label_Row_Offset to 1
101000>>>
101000>>>                    // The editor font, size & type is saved as a string with
101000>>>                    // the format: "11pt; 0; Consolas" in the .ini file. This is
101000>>>                    // also the format used to populate the popup font selection dialog.
101000>>>                    // However, we like to present the font as "Consolas, 11pt".
101000>>>                    Property String private.psEditorFont ""
101002>>>
101002>>>                    Procedure Set psEditorFont String sFont
101005>>>                        String sFontText
101005>>>                        Set private.psEditorFont to sFont
101006>>>                        Get ScintillaReadableFontFormat sFont to sFontText
101007>>>                        Set Value to sFontText
101008>>>                    End_Procedure
101009>>>
101009>>>                    Function psEditorFont Returns String
101012>>>                        Function_Return (private.psEditorFont(Self))
101013>>>                    End_Function
101014>>>
101014>>>                    Procedure Key Integer iKey Returns Integer
101017>>>                        Integer iRetVal
101017>>>                        // Left, Right, Shft+Left, Shift+Right, Home, End, Shft+Home, Shft+End
101017>>>                        If ((iKey=260)or(iKey=261)or(iKey=5127)or(iKey=5128)or ;                        (iKey=294)or(iKey=295)or(iKey=5129)or(iKey=5130) ) ;                        Forward Get Msg_Key iKey to iRetVal
101021>>>                        Procedure_Return iRetVal
101022>>>                    End_Procedure
101023>>>
101023>>>                    Function CanPaste Returns Boolean
101026>>>                        Function_Return False
101027>>>                    End_Function
101028>>>                    Function CanCut Returns Boolean
101031>>>                        Function_Return False
101032>>>                    End_Function
101033>>>                    Function CanDelete Returns Boolean
101036>>>                        Function_Return False
101037>>>                    End_Function
101038>>>                    Function CanUndo Returns Boolean
101041>>>                        Function_Return False
101042>>>                    End_Function
101043>>>                    Procedure Paste Integer Arg1 Integer Arg2 Integer Arg3
101046>>>                    End_Procedure
101047>>>                    Procedure Cut Integer Arg1 Integer Arg2 Integer Arg3
101050>>>                    End_Procedure
101051>>>                    Procedure Delete
101054>>>                    End_Procedure
101055>>>                    Procedure Undo
101058>>>                    End_Procedure
101059>>>
101059>>>                    Procedure Prompt
101062>>>                        Handle hoFontDlg
101062>>>                        Integer iOK
101062>>>                        tFontSpecs FontSpecs
101062>>>                        tFontSpecs FontSpecs
101062>>>                        String sFace sSize sCharSet sFontText
101062>>>
101062>>>                        Get psEditorFont to sFace
101063>>>                        Get ScintillaFontAsStruct sFace to FontSpecs
101064>>>                        Get Create (RefClass(FontDialog)) to hoFontDlg
101065>>>
101065>>>                        Set FixedPitchOnly_State    of hoFontDlg to True
101066>>>                        Set FaceName                of hoFontDlg to FontSpecs.sFontName
101067>>>                        Set FontPointSize           of hoFontDlg to (FontSpecs.iSize * 10)
101068>>>                        Set FontCharSet             of hoFontDlg to FontSpecs.iCharSet
101069>>>                        Set FontItalic              of hoFontDlg to False
101070>>>                        Set FontUnderline           of hoFontDlg to False
101071>>>                        Set FontWeight              of hoFontDlg to FW_REGULAR
101072>>>                        Set FontType                of hoFontDlg to REGULAR_FONTTYPE
101073>>>                        Get FontDialog              of hoFontDlg to iOK
101074>>>                        If (iOk) Begin
101076>>>                            Move "" to FontSpecs.sFontName
101077>>>                            Move 0  to FontSpecs.iSize
101078>>>                            Move 0  to FontSpecs.iCharSet
101079>>>                            // Note: We _must_ trim the FaceName, FontPointSize & FontCharSet, else we can't append anything to the string.
101079>>>                            // Perhaps the functions does not make a proper DataFlex string ending?
101079>>>                            Get FaceName                of hoFontDlg to sFace
101080>>>                            Move (CString(sFace))       to FontSpecs.sFontName
101081>>>                            Get FontPointSize           of hoFontDlg to sSize
101082>>>                            Move (CString(sSize))       to sSize
101083>>>                            If (sSize = "") Begin
101085>>>                                Move 110    to sSize
101086>>>                            End
101086>>>>
101086>>>                            Move (sSize / 10)           to FontSpecs.iSize
101087>>>                            Get FontCharSet             of hoFontDlg to sCharSet
101088>>>                            Move (CString(sCharSet))    to FontSpecs.iCharSet
101089>>>                            Append sFontText FontSpecs.sFontName ", " (String(FontSpecs.iSize)) "pt"
101093>>>
101093>>>                            Set Value                   to sFontText
101094>>>                            Get ScintillaEditorFontFormat FontSpecs to sFace
101095>>>                            Set psEditorFont            to sFace
101096>>>                            Send mGeneratePreview
101097>>>                            Delegate Send NotifyChange
101099>>>                        End
101099>>>>
101099>>>                        Send Destroy                    to hoFontDlg
101100>>>                    End_Procedure
101101>>>
101101>>>                End_Object
101102>>>
101102>>>                Object oColorSelectionInfo_tb is a TextBox
101104>>>                    Set Auto_Size_State to False
101105>>>                    Set Size to 24 105
101106>>>                    Set Location to 150 120
101107>>>                    Set Label to "Click on a color above to select a new color from the popup dialog"
101108>>>                    Set Justification_Mode to JMode_Left
101109>>>                    Set FontItalics to True
101110>>>                End_Object
101111>>>
101111>>>            End_Object
101112>>>
101112>>>        End_Object
101113>>>
101113>>>        Object oLanguagePage is a TabPage
101115>>>            Set Label to "Language"
101116>>>            Set piImageIndex to 1
101117>>>
101117>>>            Object oLanguageGroup is a cRDCHeaderGroup
101119>>>                Set Size to 206 428
101120>>>                Set Location to 5 4
101121>>>                Set psImage to "KeyWords.ico"
101122>>>                Set Label to "Keywords and Operators"
101123>>>                Set psNote to "Used by Editor when the 'Adjust Upper/Lowercase' refactor function is selected"
101124>>>                Set peAnchors to anAll
101125>>>
101125>>>                Object oScopes is a cSCWsGrid
101127>>>                    Set Size to 137 180
101128>>>                    Set Location to 35 6
101129>>>                    Set Line_Width to 2 0
101130>>>                    Set GridLine_Mode to Grid_Visible_None
101131>>>
101131>>>                    Set Form_Width 0 to 85
101132>>>                    Set Header_Label 0 to "Scope Start"
101133>>>                    Set Status_Help Item 0 to "Scope keyword start"
101134>>>
101134>>>                    Set Form_Width 1 to 85
101135>>>                    Set Header_Label 1 to "Scope End"
101136>>>                    Set Status_Help Item 1 to "Scope keyword stop"
101137>>>
101137>>>                    Property String psSepCharacter "\n"
101139>>>
101139>>>                    Set peAnchors to anTopBottom
101140>>>
101140>>>                    Procedure OnChange Integer iItem
101143>>>                        Integer iScopes
101143>>>                        Delegate Send NotifyChange
101145>>>                        Get Item_Count to iScopes
101146>>>                        Set Label of oScopesInfo_tb to ("Scopes:" * String(iScopes / 2))
101147>>>                    End_Procedure
101148>>>
101148>>>                    Procedure Add_New_Line String sStart String sStop Integer iColor
101151>>>                        Send Add_Item Msg_None sStart
101152>>>                        If (iColor) Begin
101154>>>                            Set ItemTextColor (Item_Count(Self) - 1) to iColor
101155>>>                        End
101155>>>>
101155>>>                        Send Add_Item Msg_None sStop
101156>>>                        If (iColor) Begin
101158>>>                            Set ItemTextColor (Item_Count(Self) - 1) to iColor
101159>>>                        End
101159>>>>
101159>>>                    End_Procedure
101160>>>
101160>>>                    Procedure mInsertLine
101163>>>                        Send Add_New_Line "" "" clRed
101164>>>                        Send OnChange 0
101165>>>                        Send End_of_Data
101166>>>                    End_Procedure
101167>>>
101167>>>                    Procedure mRemoveLine
101170>>>                        Integer iRowBase
101170>>>                        If (Item_Count(Self) = 0) Begin
101172>>>                            Procedure_Return
101173>>>                        End
101173>>>>
101173>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
101174>>>                        Send Delete_Item (iRowBase + 1)
101175>>>                        Send Delete_Item iRowBase
101176>>>                        Send OnChange 0
101177>>>                    End_Procedure
101178>>>
101178>>>                    Procedure mMoveDown
101181>>>                        Integer iCount iRowBase
101181>>>                        String  sStart sStop
101181>>>
101181>>>                        Get Item_Count to iCount
101182>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
101183>>>                        Get Value Item iRowBase to sStart
101184>>>                        Get Value Item (iRowBase + 1) to sStop
101185>>>                        If (sStart = "") Begin
101187>>>                            Set Current_Item to iRowBase
101188>>>                        End
101188>>>>
101188>>>                        Else If (sStop = "") Begin
101191>>>                            Set Current_Item to (iRowBase + 1)
101192>>>                        End
101192>>>>
101192>>>                        Else Begin
101193>>>                            If (iRowBase = (iCount - 2)) Begin
101195>>>                                Send mInsertLine
101196>>>                                Set Current_Item to (iRowBase + 2)
101197>>>                            End
101197>>>>
101197>>>                            Send Down
101198>>>                            Set Current_Item to (iRowBase + 2)
101199>>>                        End
101199>>>>
101199>>>                    End_Procedure
101200>>>
101200>>>                    Procedure mMoveUp
101203>>>                        Integer iRowBase
101203>>>                        String  sStart sStop
101203>>>
101203>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
101204>>>                        Get Value Item iRowBase to sStart
101205>>>                        Get Value Item (iRowBase + 1) to sStop
101206>>>                        If (sStart = "" and sStop = "") Begin
101208>>>                            Send mRemoveLine
101209>>>                        End
101209>>>>
101209>>>                        Else If (sStart = "" or sStop = "") Begin
101212>>>                            Send Stop_Box (_T("Scope 'Start' and 'Stop' keywords must be specified!", 1455)) (_T("Problem", 1474))
101213>>>                        End
101213>>>>
101213>>>                        Else Begin
101214>>>                            Send Up
101215>>>                        End
101215>>>>
101215>>>                    End_Procedure
101216>>>
101216>>>                    Function GetValue Integer iColumn Returns String
101219>>>                        Integer iC iColumns
101219>>>                        String  sRet sSep
101219>>>
101219>>>                        Move (Low(Matrix_Size(Self))) to iColumns
101220>>>                        Get psSepCharacter to sSep
101221>>>                        If (sSep = "") Begin
101223>>>                            Move "\n" to sSep
101224>>>                        End
101224>>>>
101224>>>                        For iC From 0 to (Item_Count(Self) - 1)
101230>>>>
101230>>>                            If (Value(Self, iC + iColumn) <> "") Begin
101232>>>                                If (sRet <> "") Begin
101234>>>                                    Move (sRet + sSep) to sRet
101235>>>                                End
101235>>>>
101235>>>                                Move (sRet + Value(Self, iC + iColumn)) to sRet
101236>>>                            End
101236>>>>
101236>>>                            Move (iC + iColumns - 1) to iC
101237>>>                        Loop
101238>>>>
101238>>>                        Function_Return sRet
101239>>>                    End_Function
101240>>>
101240>>>                    Procedure DoLoad tSCLanguage ByRef ltSCLanguage
101243>>>                        Integer iScope iScopes
101243>>>                        Send Delete_Data
101244>>>                        Move (SizeOfArray(ltSCLanguage.saScopeStart)) to iScopes
101245>>>                        For iScope From 0 to (iScopes -1)
101251>>>>
101251>>>                            Send Add_New_Line ltSCLanguage.saScopeStart[iScope] ltSCLanguage.saScopeStop[iScope] 0
101252>>>                        Loop
101253>>>>
101253>>>                        Set Label of oScopesInfo_tb to ("Scopes:" * String(iScopes))
101254>>>                    End_Procedure
101255>>>
101255>>>                    On_Key key_F2       Send Request_SaveAllEntries
101256>>>                    On_Key kCancel      Send Close_Panel
101257>>>                    On_Key kDownArrow   Send mMoveDown
101258>>>                    On_Key kUpArrow     Send mMoveUp
101259>>>                    On_Key Key_Tab      Send mMoveDown
101260>>>                End_Object
101261>>>
101261>>>                Object oScopesInfo_tb is a TextBox
101263>>>                    Set Auto_Size_State to False
101264>>>                    Set Size to 9 50
101265>>>                    Set Location to 174 6
101266>>>                    Set Label to "Scopes:"
101267>>>                    Set peAnchors to anBottomLeft
101268>>>                End_Object
101269>>>
101269>>>                Object oAddScope is a cRDCButtonDPI
101271>>>                    Set Size to 15 50
101272>>>                    Set Location to 185 7
101273>>>                    Set Label to "Add"
101274>>>                    Set psImage to "ActionAdd.ico"
101275>>>                    Set peAnchors to anBottomLeft
101276>>>                    Procedure OnClick
101279>>>                        Send mInsertLine to oScopes
101280>>>                    End_Procedure
101281>>>                End_Object
101282>>>
101282>>>                Object oRemoveScope is a cRDCButtonDPI
101284>>>                    Set Size to 15 50
101285>>>                    Set Location to 185 60
101286>>>                    Set Label to "Remove"
101287>>>                    Set psImage to "Remove.ico"
101288>>>                    Set peAnchors to anBottomLeft
101289>>>                    Procedure OnClick
101292>>>                        Send mRemoveLine to oScopes
101293>>>                    End_Procedure
101294>>>                End_Object
101295>>>
101295>>>                Object oLineControl2 is a LineControl
101297>>>                    Set Size to 164 3
101298>>>                    Set Location to 36 190
101299>>>                    Set Horizontal_State to False
101300>>>                    Set peAnchors to anTopBottom
101301>>>                End_Object
101302>>>
101302>>>                Object oKeywords is a cSCWsGrid
101304>>>                    Set Size to 137 112
101305>>>                    Set Location to 35 195
101306>>>                    Set Header_Label 0 to "Keyword"
101307>>>                    Set Status_Help Item 0 to "List of the available keywords"
101308>>>                    Set Line_Width to 1 0
101309>>>                    Set Form_Width 0 to 101
101310>>>                    Set GridLine_Mode to Grid_Visible_None
101311>>>                    Set peAnchors to anTopBottom
101312>>>
101312>>>                    Property String  psSepCharacter "\n"
101314>>>
101314>>>                    Procedure mMoveUp
101317>>>                        Integer iItem
101317>>>                        String sValue
101317>>>                        Get Current_Item to iItem
101318>>>                        Get Value Item iItem to sValue
101319>>>                        If ((iItem=Item_Count(Self) -1) and sValue = "") Begin
101321>>>                            Send mRemoveLine
101322>>>                        End
101322>>>>
101322>>>                        Else Begin
101323>>>                            Send Up
101324>>>                        End
101324>>>>
101324>>>                    End_Procedure
101325>>>
101325>>>                    Procedure mMoveDown
101328>>>                        Integer iItem
101328>>>                        String sValue
101328>>>                        Get Current_Item to iItem
101329>>>                        Get Value Item iItem to sValue
101330>>>                        If (sValue <> "") Begin
101332>>>                            If (iItem=Item_Count(Self) -1) Begin
101334>>>                                Send Add_New_Line "" 0
101335>>>                            End
101335>>>>
101335>>>                            Send Down
101336>>>                        End
101336>>>>
101336>>>                    End_Procedure
101337>>>
101337>>>                    Procedure OnChange Integer iItem  
101340>>>                        Integer iKeywords
101340>>>                        Delegate Send NotifyChange
101342>>>                        Get Item_Count to iKeywords
101343>>>                        Set Label of oKeywordsInfo_tb to ("Keywords:" * String(iKeywords))
101344>>>                    End_Procedure
101345>>>
101345>>>                    Procedure Add_New_Line String sKeyword Integer iColor
101348>>>                        Send Add_Item Msg_None sKeyword
101349>>>                        If (iColor) Begin
101351>>>                            Set ItemTextColor (Item_Count(Self) -1) to iColor
101352>>>                        End
101352>>>>
101352>>>                    End_Procedure
101353>>>
101353>>>                    Procedure mInsertLine
101356>>>                        Send Add_New_Line "" clRed
101357>>>                        Send onChange 0
101358>>>                        Send End_of_Data
101359>>>                    End_Procedure
101360>>>
101360>>>                    Procedure mRemoveLine
101363>>>                        Integer iRowBase
101363>>>                        If (Item_Count(Self) = 0) Begin
101365>>>                            Procedure_Return
101366>>>                        End
101366>>>>
101366>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
101367>>>                        Send Delete_Item iRowBase
101368>>>                        Send OnChange 0
101369>>>                    End_Procedure
101370>>>
101370>>>                    Function GetValue Integer iColumn Returns String
101373>>>                        Integer iC iColumns
101373>>>                        String  sRet sSep
101373>>>                        Move (Low(Matrix_Size(Self))) to iColumns
101374>>>                        Get psSepCharacter to sSep
101375>>>                        If (sSep = "") Begin
101377>>>                            Move "\n" to sSep
101378>>>                        End
101378>>>>
101378>>>                        For iC From 0 to (Item_Count(Self) -1)
101384>>>>
101384>>>                            If (Value(Self, iC + iColumn) <> "") Begin
101386>>>                                If (sRet <> "") Begin
101388>>>                                    Move (sRet + sSep) to sRet
101389>>>                                End
101389>>>>
101389>>>                                Move (sRet + Value(Self, iC + iColumn)) to sRet
101390>>>                            End
101390>>>>
101390>>>                            Move (iC + iColumns - 1) to iC
101391>>>                        Loop
101392>>>>
101392>>>                        Function_Return sRet
101393>>>                    End_Function
101394>>>
101394>>>                    Procedure DoLoad tSCLanguage ByRef ltSCLanguage
101397>>>                        Integer iKeyword iKeywords
101397>>>
101397>>>                        Send Delete_Data
101398>>>                        Move (SortArray(ltSCLanguage.saKeywords)) to ltSCLanguage.saKeywords
101399>>>                        Move (SizeOfArray(ltSCLanguage.saKeywords)) to iKeywords
101400>>>                        For iKeyword From 0 to (iKeywords - 1)
101406>>>>
101406>>>                            Send Add_New_Line ltSCLanguage.saKeywords[iKeyword] 0
101407>>>                        Loop
101408>>>>
101408>>>                        Set Label of oKeywordsInfo_tb to ("Keywords:" * String(iKeywords))
101409>>>                    End_Procedure
101410>>>
101410>>>                    On_Key Key_F2       Send Request_SaveAllEntries
101411>>>                    On_Key kCancel      Send Close_Panel
101412>>>                    On_Key kUpArrow     Send mMoveUp
101413>>>                    On_Key kDownArrow   Send mMoveDown
101414>>>                    On_Key Key_Tab      Send mMoveDown
101415>>>                End_Object
101416>>>
101416>>>                Object oKeywordsInfo_tb is a TextBox
101418>>>                    Set Auto_Size_State to False
101419>>>                    Set Size to 9 50
101420>>>                    Set Location to 174 195
101421>>>                    Set Label to "Keywords:"
101422>>>                    Set peAnchors to anBottomLeft
101423>>>                End_Object
101424>>>
101424>>>                Object oAddKeyword is a cRDCButtonDPI
101426>>>                    Set Size to 15 50
101427>>>                    Set Location to 185 195
101428>>>                    Set Label to "Add"
101429>>>                    Set psImage to "ActionAdd.ico"
101430>>>                    Set peAnchors to anBottomLeft
101431>>>                    Procedure OnClick
101434>>>                        Send mInsertLine to oKeywords
101435>>>                    End_Procedure
101436>>>                End_Object
101437>>>
101437>>>                Object oRemoveKeyword is a cRDCButtonDPI
101439>>>                    Set Size to 15 50
101440>>>                    Set Location to 185 248
101441>>>                    Set Label to "Remove"
101442>>>                    Set psImage to "Remove.ico"
101443>>>                    Set peAnchors to anBottomLeft
101444>>>                    Procedure OnClick
101447>>>                        Send mRemoveLine to oKeywords
101448>>>                    End_Procedure
101449>>>                End_Object
101450>>>
101450>>>                Object oLineControl2 is a LineControl
101452>>>                    Set Size to 164 3
101453>>>                    Set Location to 36 311
101454>>>                    Set Horizontal_State to False
101455>>>                    Set peAnchors to anTopBottom
101456>>>                End_Object
101457>>>
101457>>>                Object oOperators is a cSCWsGrid
101459>>>                    Set Size to 137 107
101460>>>                    Set Location to 35 316
101461>>>                    Set Header_Label 0 to "Operator"
101462>>>                    Set Status_Help Item 0 to "List of the available operators"
101463>>>                    Set Line_Width to 1 0
101464>>>                    Set Form_Width 0 to 96
101465>>>                    Set GridLine_Mode to Grid_Visible_None
101466>>>                    Set peAnchors to anTopBottom
101467>>>
101467>>>                    Property String psSepCharacter "\n"
101469>>>
101469>>>                    Procedure mMoveUp
101472>>>                        Integer iItem
101472>>>                        String sValue
101472>>>                        Get Current_Item to iItem
101473>>>                        Get Value Item iItem to sValue
101474>>>                        If ((iItem = Item_Count(Self) -1) and sValue = "") Begin
101476>>>                            Send mRemoveLine
101477>>>                        End
101477>>>>
101477>>>                        Else Begin
101478>>>                            Send Up
101479>>>                        End
101479>>>>
101479>>>                    End_Procedure
101480>>>
101480>>>                    Procedure mMoveDown
101483>>>                        Integer iItem
101483>>>                        String sValue
101483>>>                        Get Current_Item to iItem
101484>>>                        Get Value Item iItem to sValue
101485>>>                        If (sValue <> "") Begin
101487>>>                            If (iItem = Item_Count(Self) -1) Begin
101489>>>                                Send Add_New_Line "" 0
101490>>>                            End
101490>>>>
101490>>>                            Send Down
101491>>>                        End
101491>>>>
101491>>>                    End_Procedure
101492>>>
101492>>>                    Procedure OnChange Integer iItem
101495>>>                        Integer iOperators
101495>>>                        Delegate Send NotifyChange
101497>>>                        Get Item_Count to iOperators
101498>>>                        Set Label of oOperatorsInfo_tb to ("Operators:" * String(iOperators))
101499>>>                    End_Procedure
101500>>>
101500>>>                    Procedure Add_New_Line String sOperator Integer iColor
101503>>>                        Send Add_Item Msg_None sOperator
101504>>>                        If (iColor) Begin
101506>>>                            Set ItemTextColor (Item_Count(Self) -1) to iColor
101507>>>                        End
101507>>>>
101507>>>                    End_Procedure
101508>>>
101508>>>                    Procedure mInsertLine
101511>>>                        Send Add_New_Line "" clRed
101512>>>                        Send onChange 0
101513>>>                        Send End_of_Data
101514>>>                    End_Procedure
101515>>>
101515>>>                    Procedure mRemoveLine
101518>>>                        Integer iRowBase
101518>>>                        If (Item_Count(Self) = 0) Begin
101520>>>                            Procedure_Return
101521>>>                        End
101521>>>>
101521>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
101522>>>                        Send Delete_Item iRowBase
101523>>>                        Send OnChange 0
101524>>>                    End_Procedure
101525>>>
101525>>>                    Function GetValue Integer iColumn Returns String
101528>>>                        Integer iC iColumns
101528>>>                        String  sRet sSep
101528>>>
101528>>>                        Move (Low(Matrix_Size(Self))) to iColumns
101529>>>                        Get psSepCharacter to sSep
101530>>>                        If (sSep = "") Begin
101532>>>                            Move "\n" to sSep
101533>>>                        End
101533>>>>
101533>>>                        For iC From 0 to (Item_Count(Self) -1)
101539>>>>
101539>>>                            If (Value(Self, iC + iColumn) <> "") Begin
101541>>>                                If (sRet <> "") Begin
101543>>>                                    Move (sRet + sSep) to sRet
101544>>>                                End
101544>>>>
101544>>>                                Move (sRet + Value(Self, iC + iColumn)) to sRet
101545>>>                            End
101545>>>>
101545>>>                            Move (iC + iColumns - 1) to iC
101546>>>                        Loop
101547>>>>
101547>>>                        Function_Return sRet
101548>>>                    End_Function
101549>>>
101549>>>                    Procedure DoLoad tSCLanguage ByRef ltSCLanguage
101552>>>                        Integer iOperator iOperators
101552>>>                        Send Delete_Data
101553>>>                        Move (SortArray(ltSCLanguage.saOperators)) to ltSCLanguage.saOperators
101554>>>                        Move (SizeOfArray(ltSCLanguage.saOperators)) to iOperators
101555>>>                        For iOperator From 0 to (iOperators -1)
101561>>>>
101561>>>                            Send Add_New_Line ltSCLanguage.saOperators[iOperator] 0
101562>>>                        Loop
101563>>>>
101563>>>                        Set Label of oOperatorsInfo_tb to ("Operators:" * String(iOperators))
101564>>>                    End_Procedure
101565>>>
101565>>>                    On_Key key_F2       Send Request_SaveAllEntries
101566>>>                    On_Key kCancel      Send Close_Panel
101567>>>                    On_Key kUpArrow     Send mMoveUp
101568>>>                    On_Key kDownArrow   Send mMoveDown
101569>>>                    On_Key Key_Tab      Send mMoveDown
101570>>>                End_Object
101571>>>
101571>>>                Object oOperatorsInfo_tb is a TextBox
101573>>>                    Set Auto_Size_State to False
101574>>>                    Set Size to 9 50
101575>>>                    Set Location to 174 316
101576>>>                    Set Label to "Operators:"
101577>>>                    Set peAnchors to anBottomLeft
101578>>>                End_Object
101579>>>
101579>>>                Object oAddOperator is a cRDCButtonDPI
101581>>>                    Set Size to 15 50
101582>>>                    Set Location to 185 316
101583>>>                    Set Label to "Add"
101584>>>                    Set psImage to "ActionAdd.ico"
101585>>>                    Set peAnchors to anBottomLeft
101586>>>                    Procedure OnClick
101589>>>                        Send mInsertLine to oOperators
101590>>>                    End_Procedure
101591>>>                End_Object
101592>>>
101592>>>                Object oRemoveOperator is a cRDCButtonDPI
101594>>>                    Set Size to 15 50
101595>>>                    Set Location to 185 369
101596>>>                    Set Label to "Remove"
101597>>>                    Set psImage to "Remove.ico"
101598>>>                    Set peAnchors to anBottomLeft
101599>>>                    Procedure OnClick
101602>>>                        Send mRemoveLine to oOperators
101603>>>                    End_Procedure
101604>>>                End_Object
101605>>>
101605>>>                // Fill lists
101605>>>                Procedure End_Construct_Object
101608>>>                    String sLanguage
101608>>>                    Integer iC
101608>>>
101608>>>                    Forward Send End_Construct_Object
101610>>>                    Move "VDF" to sLanguage
101611>>>                    Get FindLanguage of ghoEditorProperties sLanguage to iC
101612>>>                    If (iC >= 0) Begin
101614>>>                        Send LoadEntries iC
101615>>>                    End
101615>>>>
101615>>>                    Else Begin
101616>>>                        Send ClearEntries
101617>>>                    End
101617>>>>
101617>>>
101617>>>                End_Procedure
101618>>>
101618>>>                Procedure LoadEntries Integer iC
101621>>>                    tSCLanguage tSCLanguage
101621>>>                    tSCLanguage tSCLanguage
101621>>>
101621>>>                    Get psLanguages.dwStyle                 of ghoEditorProperties iC to tSCLanguage.iProcedural
101622>>>                    Get psLanguages.bIsCaseSensitive        of ghoEditorProperties iC to tSCLanguage.iCaseSensitive
101623>>>                    Get psLanguages.szStringDelims          of ghoEditorProperties iC to tSCLanguage.sStringDelimiter
101624>>>                    Get psLanguages.chEscape                of ghoEditorProperties iC to tSCLanguage.sEscapeChar
101625>>>                    Get psLanguages.chTerminator            of ghoEditorProperties iC to tSCLanguage.sLineTerminationChar
101626>>>                    Get psLanguages.szSingleLineComments    of ghoEditorProperties iC to tSCLanguage.sLineComments
101627>>>                    Get psLanguages.szMultiLineComments1    of ghoEditorProperties iC to tSCLanguage.sMultiLineCommentStart
101628>>>                    Get psLanguages.szMultiLineComments2    of ghoEditorProperties iC to tSCLanguage.sMultiLineCommentStop
101629>>>
101629>>>                    Send LoadElementString (psLanguages.szScopeKeywords1(ghoEditorProperties,iC))       "\n" (&tSCLanguage.saScopeStart)
101630>>>                    Send LoadElementString (psLanguages.szScopeKeywords2(ghoEditorProperties,iC))       "\n" (&tSCLanguage.saScopeStop)
101631>>>                    Send LoadElementString (psLanguages.szKeywords(ghoEditorProperties,iC))             "\n" (&tSCLanguage.saKeywords)
101632>>>                    Send LoadElementString (psLanguages.szOperators(ghoEditorProperties,iC))            "\n" (&tSCLanguage.saOperators)
101633>>>
101633>>>                    Send LoadElementString (psLanguages.pszTagElementNames(ghoEditorProperties,iC))     "\n" (&tSCLanguage.saTags)
101634>>>                    Send LoadElementString (psLanguages.pszTagAttributeNames(ghoEditorProperties,iC))   "\n" (&tSCLanguage.saAttributes)
101635>>>                    Send LoadElementString (psLanguages.pszTagEntities(ghoEditorProperties,iC))         "\n" (&tSCLanguage.saEntities)
101636>>>
101636>>>                    Send DoLoad to oScopes      (&tSCLanguage)
101637>>>                    Send DoLoad to oKeywords    (&tSCLanguage)
101638>>>                    Send DoLoad to oOperators   (&tSCLanguage)
101639>>>                End_Procedure
101640>>>
101640>>>                Procedure SaveEntries
101643>>>                    Integer iC
101643>>>                    String  sName
101643>>>
101643>>>                    Move "VDF" to sName
101644>>>                    Get FindLanguage                 of ghoEditorProperties sName   to iC
101645>>>                    If (iC < 0) Begin
101647>>>                        Get psLanguages.Count       of ghoEditorProperties         to iC
101648>>>                    End
101648>>>>
101648>>>                    Set psLanguages                  of ghoEditorProperties Item iC to sName
101649>>>
101649>>>                    Set psLanguages.szScopeKeywords1 of ghoEditorProperties Item iC to (GetValue(oScopes(Self), 0))
101650>>>                    Set psLanguages.szScopeKeywords2 of ghoEditorProperties Item iC to (GetValue(oScopes(Self), 1))
101651>>>                    Set psLanguages.szKeywords       of ghoEditorProperties Item iC to (GetValue(oKeywords(Self), 0))
101652>>>                    Set psLanguages.szOperators      of ghoEditorProperties Item iC to (GetValue(oOperators(Self), 0))
101653>>>
101653>>>                    Send RegisterLanguage to ghoEditorProperties iC
101654>>>                End_Procedure
101655>>>
101655>>>                Procedure ClearEntries
101658>>>                    Send Delete_Data    to oScopes
101659>>>                    Send Delete_Data    to oKeywords
101660>>>                    Send Delete_Data    to oOperators
101661>>>                End_Procedure
101662>>>
101662>>>                Procedure LoadElementString String sElement String sSeparator String[] ByRef saElements
101665>>>                    Integer iC iItem
101665>>>                    Handle hoParser
101665>>>
101665>>>                    Get Create (RefClass(cLineParser)) to hoParser
101666>>>                    Set psSepCharacter of hoParser to sSeparator
101667>>>                    Send ParseLine     to hoParser sElement
101668>>>                    For iC From 0 to (Item_Count(hoParser) -1)
101674>>>>
101674>>>                        Move (SizeOfArray(saElements)) to iItem
101675>>>                        Get Value of hoParser Item iC to saElements[iItem]
101676>>>                    Loop
101677>>>>
101677>>>                    Send Destroy_Object to hoParser
101678>>>                End_Procedure
101679>>>
101679>>>            End_Object
101680>>>
101680>>>        End_Object
101681>>>
101681>>>        Object oKeyboardPage is a TabPage
101683>>>            Set Label to "Keyboard"
101684>>>            Set piImageIndex to 2
101685>>>
101685>>>            Object oHotKeysGroup is a cRDCHeaderGroup
101687>>>                Set Size to 206 428
101688>>>                Set Location to 5 4
101689>>>                Set peAnchors to anAll
101690>>>                Set psImage to "Keyboard.ico"
101691>>>                Set Label to "Keyboard Key Assignments"
101692>>>                Set psNote to "Assign keyboard shortcuts to commands"
101693>>>
101693>>>                Property Integer piCurrentCommand 0 // command we can customize
101695>>>
101695>>>                Object oCommands is a TreeView
101697>>>                    Set Size to 143 126
101698>>>                    Set Location to 53 10
101699>>>                    Set Label_Justification_Mode to JMode_Top
101700>>>                    Set Label_Col_Offset to 2
101701>>>                    Set pbFullRowSelect to True
101702>>>                    Set piTextColor to clBlack
101703>>>                    Set pbExplorerStyle to True
101704>>>
101704>>>                    Property String psCurrentLanguage ""
101706>>>
101706>>>                    Set peAnchors to anTopBottom
101707>>>
101707>>>                    Procedure DoBuildList String sFilter
101710>>>                        Handle hItem
101710>>>                        Integer iItem
101710>>>                        Integer iCount
101710>>>                        tSciCommandHotKey[] ltCommands
101710>>>                        tSciCommandHotKey[] ltCommands
101711>>>
101711>>>                        Set Dynamic_Update_State to False
101712>>>                        Send ClearAll
101713>>>                        Move (Trim(Uppercase(sFilter))) to sFilter
101714>>>                        Send SortByCommandName of oSciCommandHotKeys
101715>>>                        Get pCommands of oSciCommandHotKeys to ltCommands
101716>>>                        Move (SizeOfArray(ltCommands)) to iCount
101717>>>                        For iItem From 0 to (iCount-1)
101723>>>>
101723>>>                            If ((sFilter="")or(Uppercase(ltCommands[iItem].sName) contains sFilter)) ;                            Get AddTreeItem ltCommands[iItem].sName 0 ltCommands[iItem].iCmd 0 0 to hItem
101726>>>                        Loop
101727>>>>
101727>>>                        Set Dynamic_Update_State to True
101728>>>                    End_Procedure
101729>>>
101729>>>                    Procedure OnCreateTree
101732>>>                        Send DoBuildList ""
101733>>>                    End_Procedure
101734>>>
101734>>>                    Procedure OnItemChanged Handle hItem Handle hItemOld
101737>>>                        Integer iCmd
101737>>>                        Get ItemData hItem to iCmd
101738>>>                        Set piCurrentCommand to iCmd
101739>>>                        Send DisplayCommandDetails
101740>>>                        Send ClearKey of oNewKey
101741>>>                    End_Procedure
101742>>>
101742>>>                    On_Key Key_Up_Arrow Send Up
101743>>>                    On_Key Key_Down_Arrow Send Down
101744>>>                End_Object
101745>>>
101745>>>                Object oCurrentShortcut is a Form
101747>>>                    Set Size to 13 200
101748>>>                    Set Location to 53 146
101749>>>                    Set Label to "Current Shortcut:"
101750>>>                    Set Label_Justification_Mode to JMode_Top
101751>>>                    Set Label_Col_Offset to 0
101752>>>                    Set Enabled_State to False
101753>>>                    Set Label_Row_Offset to 1
101754>>>                End_Object
101755>>>
101755>>>                Object oNewKey is a Form
101757>>>                    Set Size to 13 200
101758>>>                    Set Location to 91 146
101759>>>                    Set Label to "New Key Assignment:"
101760>>>                    Set Label_Justification_Mode to JMode_Top
101761>>>                    Set Label_Col_Offset to 0
101762>>>                    Set psToolTip to "Type your key assignment in this field"
101763>>>                    Set Label_Row_Offset to  1
101764>>>
101764>>>                    Property tShortCut pNewShortCut
101766>>>
101766>>>                    Procedure Key Integer iKeyValue Returns Integer
101769>>>                        Integer iRetval
101769>>>                        String  sShortCut
101769>>>                        Integer[] Keys
101770>>>                        tShortCut NewShortCut
101770>>>                        tShortCut NewShortCut
101770>>>                        Move "" to sShortCut
101771>>>                        Get ReadKeyboardState   of oSciCommandHotKeys to Keys
101772>>>                        Get KeysToString        of oSciCommandHotKeys Keys to sShortCut
101773>>>                        Set Value               of oNewShortcut to sShortCut
101774>>>                        Move iKeyValue          to NewShortCut.iDFKey
101775>>>                        Move Keys               to NewShortCut.VKcode
101776>>>                        Set pNewShortCut        to NewShortCut
101777>>>                        Send DispatchAnyKey
101778>>>                        Procedure_Return iRetVal
101779>>>                    End_Procedure
101780>>>
101780>>>                    Procedure ClearKey
101783>>>                        tShortCut EmptyShortCut
101783>>>                        tShortCut EmptyShortCut
101783>>>                        Set Value to ""
101784>>>                        Set Value of oNewShortCut to ""
101785>>>                        Set pNewShortCut to EmptyShortCut
101786>>>                    End_Procedure
101787>>>
101787>>>                    On_Key Key_F1            Send Default_Key
101788>>>                    On_Key Key_F4            Send Default_Key
101789>>>                    On_Key Key_F6            Send Default_Key
101790>>>                    On_Key Key_F10           Send Default_Key  // <-- clear does not work but not forwarding msg_key helps :)
101791>>>                    On_Key Key_Shift+Key_F4  Send Default_Key
101792>>>                    On_Key Key_Shift+Key_F5  Send Default_Key
101793>>>                    On_Key Key_Shift+Key_F6  Send Default_Key
101794>>>                    On_Key Key_Shift+Key_F10 Send Default_Key
101795>>>                    On_Key Key_Ctrl+Key_F4   Send Default_Key
101796>>>                    On_Key Key_Ctrl+Key_F6   Send Default_Key
101797>>>                    On_Key Key_Alt+Key_F4    Send Default_Key
101798>>>                    On_Key Key_Alt+Key_F6    Send Default_Key
101799>>>                    On_Key Key_Alt+Key_C     Send Default_Key
101800>>>                    On_Key Key_Alt+Key_O     Send Default_Key
101801>>>                    On_Key kEnter            Send Default_Key
101802>>>                    On_Key kNext_Item        Send Default_Key
101803>>>                    On_Key kPrevious_Item    Send Default_Key
101804>>>                    On_Key Key_Ctrl+Key_Tab  Send Default_Key
101805>>>                End_Object
101806>>>
101806>>>                Object oNewShortcut is a Form
101808>>>                    Set Size to 13 200
101809>>>                    Set Location to 120 146
101810>>>                    Set Label to "New Shortcut:"
101811>>>                    Set Label_Justification_Mode to JMode_Top
101812>>>                    Set Label_Col_Offset to 0
101813>>>                    Set Enabled_State to False
101814>>>                    Set Label_Row_Offset to 1
101815>>>                End_Object
101816>>>
101816>>>                Object oAssign is a cRDCButtonDPI
101818>>>                    Set Location to 90 359
101819>>>                    Set Label to "Assign"
101820>>>                    Set psImage to "Assign.ico"
101821>>>                    Procedure OnClick
101824>>>                        Integer iCmd
101824>>>                        tShortCut ShortCut
101824>>>                        tShortCut ShortCut
101824>>>                        Get piCurrentCommand to iCmd
101825>>>                        Get pNewShortCut of oNewKey to ShortCut
101826>>>                        If (iCmd<>0 and SizeOfArray(ShortCut.VKcode)>0) Begin
101828>>>                            Send AssignShortCutToCmd of oSciCommandHotKeys iCmd ShortCut
101829>>>                            Send DisplayCommandDetails
101830>>>                            Send Activate to oNewKey
101831>>>                            Delegate Send NotifyChange
101833>>>                        End
101833>>>>
101833>>>                    End_Procedure
101834>>>                End_Object
101835>>>
101835>>>                Object oRemove is a cRDCButtonDPI
101837>>>                    Set Location to 107 359
101838>>>                    Set Label to "Remove"
101839>>>                    Set psImage to "Remove.ico"
101840>>>                    Procedure OnClick
101843>>>                        Integer iCmd
101843>>>                        Get piCurrentCommand to iCmd
101844>>>                        If (iCmd<>0) Begin
101846>>>                            Send RemoveShortCutFromCmd of oSciCommandHotKeys iCmd
101847>>>                            Send DisplayCommandDetails
101848>>>                            Send Activate to oNewKey
101849>>>                            Delegate Send NotifyChange
101851>>>                        End
101851>>>>
101851>>>                    End_Procedure
101852>>>                End_Object
101853>>>
101853>>>                Object oCommandHelpTb is a cTextEdit
101855>>>                    Set Size to 40 200
101856>>>                    Set Location to 155 146
101857>>>                    Set Enabled_State to False
101858>>>                    Set Label to "Description:"
101859>>>                    Set peAnchors to anTopBottom
101860>>>                End_Object
101861>>>
101861>>>                Object oSearch is a Form
101863>>>                    Set Size to 11 126
101864>>>                    Set Location to 41 10
101865>>>                    Set Label to "Command:"
101866>>>                    Set Label_Col_Offset to 0
101867>>>                    Set Label_Row_Offset to 1
101868>>>                    Set Label_Justification_Mode to JMode_Top
101869>>>
101869>>>                    Procedure OnChange
101872>>>                        String sValue
101872>>>                        Get Value to sValue
101873>>>                        Set Color to clWindow
101874>>>                        If (sValue <> "") Begin
101876>>>                            Set Color to (RGB(255,200,200))
101877>>>                        End
101877>>>>
101877>>>                        Send DoBuildList to oCommands sValue
101878>>>                    End_Procedure
101879>>>
101879>>>                    On_Key Key_Down_Arrow Send Activate to oCommands
101880>>>                    On_Key Key_Tab        Send Activate to oCommands
101881>>>                End_Object
101882>>>
101882>>>                Procedure DisplayCommandDetails
101885>>>                    Boolean bHasHotKey
101885>>>                    Integer iCmd
101885>>>                    String  sDescription
101885>>>                    String  sShortCut
101885>>>                    tSciCommandHotKey Command
101885>>>                    tSciCommandHotKey Command
101885>>>
101885>>>                    Move "" to sDescription
101886>>>                    Send Delete_Data of oCommandHelpTb
101887>>>                    Set Value of oCurrentShortcut to ""
101888>>>
101888>>>                    Get piCurrentCommand to iCmd
101889>>>                    If (iCmd <> 0) Begin
101891>>>                        Get FindCommand of oSciCommandHotKeys iCmd to Command
101892>>>                        If (Command.iCmd = iCmd) Begin
101894>>>                            Send AppendTextLn of oCommandHelpTb Command.sDescription
101895>>>                        End
101895>>>>
101895>>>                        Get CommandHasHotKey of oSciCommandHotKeys Command to bHasHotKey
101896>>>                        If (bHasHotKey) Begin
101898>>>                            Get CommandHotKeyString of oSciCommandHotKeys Command to sShortCut
101899>>>                            Set Value of oCurrentShortCut to sShortCut
101900>>>                        End
101900>>>>
101900>>>                    End
101900>>>>
101900>>>                End_Procedure
101901>>>
101901>>>            End_Object
101902>>>
101902>>>        End_Object
101903>>>
101903>>>        Object oOptionsPage is a TabPage
101905>>>            Set Label to "Misc"
101906>>>            Set piImageIndex to 3
101907>>>
101907>>>            Object oOptionsGrp is a cRDCHeaderGroup
101909>>>                Set Size to 206 428
101910>>>                Set Location to 5 4
101911>>>                Set peAnchors to anAll
101912>>>                Set Label to "Other Editor Settings"
101913>>>                Set psNote to "Miscellaneous editor settings"
101914>>>                Set psImage to "SettingsEditor.ico"
101915>>>
101915>>>                Object oLineNumbers is a cSCNotifierCheckBox
101917>>>                    Set Size to 10 50
101918>>>                    Set Location to 37 28
101919>>>                    Set Label to "Show line numbers"
101920>>>                    Set psToolTip to "Show line numbers in the leftmost column of the editor"
101921>>>                End_Object
101922>>>
101922>>>                Object oScopeMargin is a cSCNotifierCheckBox
101924>>>                    Set Size to 10 50
101925>>>                    Set Location to 48 28
101926>>>                    Set Label to "Show scope blocks margin"
101927>>>                    Set psToolTip to "Show scope blocks margin in the editor"
101928>>>                End_Object
101929>>>
101929>>>                Object oIndent is a cSCNotifierCheckBox
101931>>>                    Set Size to 10 50
101932>>>                    Set Location to 59 28
101933>>>                    Set Label to "Auto indent"
101934>>>                    Set psToolTip to "Apply auto indentation to inserted code"
101935>>>                End_Object
101936>>>
101936>>>                Object oGuides is a cSCNotifierCheckBox
101938>>>                    Set Size to 10 50
101939>>>                    Set Location to 70 28
101940>>>                    Set Label to "Show indentation guides"
101941>>>                    Set psToolTip to "Connect indentations with vertical lines to easier see which indentations belongs together"
101942>>>                End_Object
101943>>>
101943>>>                Object oSelect is a cSCNotifierCheckBox
101945>>>                    Set Size to 10 50
101946>>>                    Set Location to 81 28
101947>>>                    Set Label to "Highlight whole line on selection"
101948>>>                    Set psToolTip to "Highlight the whole line when selected"
101949>>>                End_Object
101950>>>
101950>>>                Object oTabs is a cSCNotifierCheckBox
101952>>>                    Set Size to 10 50
101953>>>                    Set Location to 93 28
101954>>>                    Set Label to "Convert tabs to spaces"
101955>>>                    Set psToolTip to "Change tab character to spaces when indenting code"
101956>>>                End_Object
101957>>>
101957>>>                Object oAdjustCase is a cSCNotifierCheckBox
101959>>>                    Set Size to 10 50
101960>>>                    Set Location to 104 28
101961>>>                    Set Label to "Adjust text case of typed keywords"
101962>>>                    Set psToolTip to "Automatically adjust the casing of key words as they are typed"
101963>>>                End_Object
101964>>>
101964>>>                Object oTrimEOLonSave is a cSCNotifierCheckBox
101966>>>                    Set Size to 10 50
101967>>>                    Set Location to 115 28
101968>>>                    Set Label to "Trim EOL on save"
101969>>>                    Set psToolTip to "Remove and trailing line spaces when the file is saved"
101970>>>                End_Object
101971>>>
101971>>>                Object oBraces is a cSCNotifierCheckBox
101973>>>                    Set Size to 10 50
101974>>>                    Set Location to 126 28
101975>>>                    Set Label to "Show matching braces"
101976>>>                    Set psToolTip to "Highlight matching braces"
101977>>>                End_Object
101978>>>
101978>>>                Object oTabSize is a cNotifierSpinForm
101980>>>                    Set Size to 13 30
101981>>>                    Set Location to 37 225
101982>>>                    Set Status_Help to "Number of spaces to replace TAB character"
101983>>>                    Set psToolTip to "The number of spaces to use when indenting code"
101984>>>                    Set Label to "Tab size:"
101985>>>                End_Object
101986>>>
101986>>>            End_Object
101987>>>
101987>>>        End_Object
101988>>>
101988>>>    End_Object
101989>>>
101989>>>    Procedure SaveEntries
101992>>>        Integer iC
101992>>>        String  sHotKey
101992>>>        String  sColors
101992>>>        String  sFontFace
101992>>>        String  sFontStyles
101992>>>        String  sSchemaName
101992>>>
101992>>>        Get psColors of ghoEditorProperties to sColors
101993>>>        // Re-format to support Scintilla
101993>>>        If (Length(sColors)=CM_COLORS_STRSIZE) ;        Move (sColors + Repeat('0', SC_COLORS_STRSIZE-CM_COLORS_STRSIZE)) to sColors
101996>>>        Get CurrentColors           to sColors
101997>>>        Get CurrentFontStyles       to sFontStyles
101998>>>        Get Value of oSchemaSelect  to sSchemaName
101999>>>        If (sSchemaName<>"") Begin
102001>>>            If ((sSchemaName<>TH_DEFSCHEMA_BLACK_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_WHITE_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_BLUE_STR)  and ;            (sSchemaName<>TH_DEFSCHEMA_SERENE_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_SAHARA_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_LIME_STR)) Begin
102003>>>                Get FindColorSchema of ghoEditorProperties sSchemaName to iC
102004>>>                If (iC<0) Begin
102006>>>                    Get psColorSchemas.Count           of ghoEditorProperties to iC
102007>>>                End
102007>>>>
102007>>>                Set psColorSchemas                     of ghoEditorProperties Item iC  to sSchemaName
102008>>>                Set psColorSchemas.psSchemaColors      of ghoEditorProperties Item iC  to sColors
102009>>>                Set psColorSchemas.psSchemaFontStyles  of ghoEditorProperties Item iC  to sFontStyles
102010>>>            End
102010>>>>
102010>>>            Set psColorSchema  of ghoEditorProperties  to sSchemaName
102011>>>            Set psColors       of ghoEditorProperties  to sColors
102012>>>            Set psFontStyles   of ghoEditorProperties  to sFontStyles
102013>>>        End
102013>>>>
102013>>>
102013>>>        // Font
102013>>>        Get psEditorFont of oFontFace   to sFontFace
102014>>>        If (sFontFace = "") Begin
102016>>>            Move "11pt; 0; Courier New" to sFontFace
102017>>>        End
102017>>>>
102017>>>        Set psFontFace             of ghoEditorProperties to sFontFace
102018>>>
102018>>>        Set piLineNumbering        of ghoEditorProperties to (Checked_State(oLineNumbers(Self)))
102019>>>        Set pbLeftMargin           of ghoEditorProperties to (Checked_State(oScopeMargin(Self)))
102020>>>        Set piAutoIndentMode       of ghoEditorProperties to (Checked_State(oIndent(Self)))
102021>>>        Set pbShowMatchingBraces   of ghoEditorProperties to (Checked_State(oBraces(Self)))
102022>>>        Set pbShowIndentGuides     of ghoEditorProperties to (Checked_State(oGuides(Self)))
102023>>>        Set pbSelectWholeLine      of ghoEditorProperties to (Checked_State(oSelect(Self)))
102024>>>        Set pbTabExpand            of ghoEditorProperties to (Checked_State(oTabs(Self)))
102025>>>        Set piTabSize              of ghoEditorProperties to (Value(oTabSize(Self),0))
102026>>>        Set pbNormalizeCase        of ghoEditorProperties to (Checked_State(oAdjustCase(Self)))
102027>>>        Set pbTrimEOLOnSave        of ghoEditorProperties to (Checked_State(oTrimEOLonSave(Self)))
102028>>>
102028>>>        Get ShortCutKeyDefinitions of oSciCommandHotKeys  to sHotKey
102029>>>        Set psEditorHotKeys        of ghoEditorProperties to sHotKey
102030>>>
102030>>>    End_Procedure
102031>>>
102031>>>    Procedure LoadEntries
102034>>>        String sFontFace
102034>>>
102034>>>        Get psFontFace of ghoEditorProperties to sFontFace
102035>>>        If (sFontFace="") Begin
102037>>>            Move "11pt; 0; Courier New"       to sFontFace
102038>>>        End
102038>>>>
102038>>>        Set psEditorFont   of oFontFace       to sFontFace
102039>>>
102039>>>        Set Value          of oTabSize        to (piTabSize(ghoEditorProperties))
102040>>>        Set Checked_State  of oLineNumbers    to (piLineNumbering(ghoEditorProperties))
102041>>>        Set Checked_State  of oScopeMargin    to (pbLeftMargin(ghoEditorProperties))
102042>>>        Set Checked_State  of oIndent         to (piAutoIndentMode(ghoEditorProperties))
102043>>>        Set Checked_State  of oBraces         to (pbShowMatchingBraces(ghoEditorProperties))
102044>>>        Set Checked_State  of oGuides         to (pbShowIndentGuides(ghoEditorProperties))
102045>>>        Set Checked_State  of oSelect         to (pbSelectWholeLine(ghoEditorProperties))
102046>>>        Set Checked_State  of oTabs           to (pbTabExpand(ghoEditorProperties))
102047>>>        Set Checked_State  of oAdjustCase     to (pbNormalizeCase(ghoEditorProperties))
102048>>>        Set Checked_State  of oTrimEOLonSave  to (pbTrimEOLOnSave(ghoEditorProperties))
102049>>>
102049>>>    End_Procedure
102050>>>
102050>>>    Procedure NotifyChange
102053>>>        Set Enabled_State of oSave to True
102054>>>    End_Procedure
102055>>>
102055>>>    Procedure Request_SaveAllEntries
102058>>>        If (Enabled_State(oSave(Self))) Begin
102060>>>            Send SaveAllEntries
102061>>>        End
102061>>>>
102061>>>    End_Procedure
102062>>>
102062>>>    Procedure ApplyToEditor
102065>>>        Handle hClientArea hView
102065>>>        Get Client_Id to hClientArea
102066>>>        Get Next_Mdi_Dialog of hClientArea True to hView // find first view
102067>>>        While (hView <> 0)
102071>>>            If (Active_State(hView)) Begin
102073>>>                // create the action
102073>>>                Broadcast Send SetAdjustments     to hView
102075>>>                Broadcast Send ApplyEditorOptions to hView
102077>>>                Broadcast Send OnPropsChange      to hView
102079>>>            End
102079>>>>
102079>>>            Get Next_Mdi_Dialog of hClientArea False to hView // find next
102080>>>        Loop
102081>>>>
102081>>>    End_Procedure
102082>>>
102082>>>    Procedure SaveAllEntries
102085>>>        Send SaveEntries of oFontsPage
102086>>>        Send SaveEntries of oOptionsPage
102087>>>        Send SaveEntries of oLanguageGroup
102088>>>        Send SaveEntries of oKeyboardPage
102089>>>        Send SaveEntries
102090>>>        Send SaveIni to ghoEditorProperties
102091>>>
102091>>>        If (Focus(Desktop) = oSave(Self)) Begin
102093>>>            Send Activate to oClose
102094>>>        End
102094>>>>
102094>>>        Send ApplyToEditor
102095>>>        Set Enabled_State of oSave to False
102096>>>    End_Procedure
102097>>>
102097>>>    Object oSave is a cRDCButtonDPI
102099>>>        Set Label to "Save"
102100>>>        Set Location to 236 340
102101>>>        Set peAnchors to anBottomRight
102102>>>        Set Enabled_State to False
102103>>>        Set psImage to "ActionSaveRecord.ico"
102104>>>        Procedure OnClick
102107>>>            Send SaveAllEntries
102108>>>        End_Procedure
102109>>>    End_Object
102110>>>
102110>>>    Object oClose is a cRDCButtonDPI
102112>>>        Set Label to "Close"
102113>>>        Set Location to 236 393
102114>>>        Set peAnchors to anBottomRight
102115>>>        Procedure OnClick
102118>>>            Send Close_Panel
102119>>>        End_Procedure
102120>>>    End_Object
102121>>>
102121>>>    Procedure Popup
102124>>>        Send LoadEntries
102125>>>        Set Enabled_State of oSave to False
102126>>>        Forward Send Popup
102128>>>    End_Procedure
102129>>>
102129>>>    On_Key Key_Alt+Key_O Send KeyAction of oSave
102130>>>    On_Key Key_Alt+Key_C Send KeyAction of oClose
102131>>>    On_Key Key_Escape    Send KeyAction of oClose
102132>>>End_Object
102133>        Use BackupFiles.dg
Including file: BackupFiles.dg    (C:\Projects\DF18\DfRefactor\AppSrc\BackupFiles.dg)
102133>>>Use Windows.pkg
102133>>>Use Cursor.pkg
102133>>>Use vWin32fh.pkg
102133>>>Use cRDCCJSelectionGrid.pkg
102133>>>Use cCJCommandBarSystem.pkg
102133>>>Use RefactorFunctionConstants.inc
102133>>>Use cRefactorTextbox.pkg
Including file: cRefactorTextbox.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorTextbox.pkg)
102133>>>>>Use Windows.pkg
102133>>>>>Use RefactorFunctionConstants.inc  
102133>>>>>
102133>>>>>Class cRefactorTextbox is a TextBox
102134>>>>>
102134>>>>>    Procedure Construct_Object
102136>>>>>        Forward Send Construct_Object
102138>>>>>        Property Handle phoCheckbox
102139>>>>>
102139>>>>>        Set Auto_Size_State to False
102140>>>>>        Set TextColor to clGreenGrey
102141>>>>>    End_Procedure
102142>>>>>
102142>>>>>    Procedure End_Construct_Object
102144>>>>>        Forward Send End_Construct_Object
102146>>>>>
102146>>>>>    End_Procedure
102147>>>>>
102147>>>>>    Procedure Mouse_Down Integer iWindowNumber Integer iPosition
102149>>>>>        Handle hoCheckbox
102149>>>>>
102149>>>>>        Forward Send Mouse_Down iWindowNumber iPosition
102151>>>>>        Get phoCheckbox to hoCheckbox
102152>>>>>        If (hoCheckbox <> 0) Begin
102154>>>>>            Send DoToggle of hoCheckbox
102155>>>>>        End
102155>>>>>>
102155>>>>>    End_Procedure
102156>>>>>
102156>>>>>End_Class
102157>>>Use cRDCButtonDPI.pkg    
102157>>>Use cRDCModalPanel.pkg
102157>>>
102157>>>Object oBackupFiles_dg is a cRDCModalPanel
102159>>>    Set Label to "Move Backup Files Back to Original Folder(s) to restore changes"
102160>>>    Set Size to 209 549
102161>>>    Set Location to 2 2
102162>>>    Set piMinSize to 209 548
102163>>>    Set Icon to "UndoRefactoring.ico"
102164>>>
102164>>>    Property tsSearchResult[] psaSearchResultArray
102166>>>
102166>>>    Object oBackupFiles_grd is a cRDCCJSelectionGrid
102168>>>        Set Size to 164 522
102169>>>        Set Location to 14 14
102170>>>
102170>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
102172>>>            Set piWidth to 24
102173>>>            Set pbResizable to False
102174>>>        End_Object
102175>>>
102175>>>        Object oFileName_col is a cCJGridColumn
102177>>>            Set piWidth to 217
102178>>>            Set psCaption to "Backup File Name"
102179>>>            Set psToolTip to "Backup file name without path"
102180>>>        End_Object
102181>>>
102181>>>        Object oFileDate_col is a cCJGridColumn
102183>>>            Set piWidth to 183
102184>>>            Set psCaption to "File Date & Time"
102185>>>            Set psToolTip to "The backed up file name including full path"
102186>>>            Set pbResizable to False
102187>>>        End_Object
102188>>>
102188>>>        Object oPath_col is a cCJGridColumn
102190>>>            // This must be here:
102190>>>            Set phoData_Col to Self
102191>>>
102191>>>            Set piWidth to 657
102192>>>            Set psCaption to "Full Path and File Name"
102193>>>        End_Object
102194>>>
102194>>>        Procedure LoadData
102197>>>            Handle hoDataSource
102197>>>            tDataSourceRow[] TheData TheDataEmpty
102197>>>            tDataSourceRow[] TheData TheDataEmpty
102199>>>            tsSearchResult[] saSearchResultArray
102199>>>            tsSearchResult[] saSearchResultArray
102200>>>            Integer iSize iRow iCount iFileNameCol iPathCol iFileDateCol iCheckBoxCol
102200>>>
102200>>>            If (not(IsComObjectCreated(Self))) Begin
102202>>>                Procedure_Return
102203>>>            End
102203>>>>
102203>>>
102203>>>            Get psaSearchResultArray to saSearchResultArray
102204>>>            Move (SizeOfArray(saSearchResultArray)) to iSize
102205>>>            If (iSize = 0) Begin
102207>>>                Procedure_Return
102208>>>            End
102208>>>>
102208>>>
102208>>>            Move 0 to iCount
102209>>>            Decrement iSize
102210>>>            Get phoDataSource to hoDataSource
102211>>>            Get DataSource of hoDataSource to TheData
102212>>>            Move TheDataEmpty to TheData
102213>>>            Get piColumnId of oFileName_col to iFileNameCol
102214>>>            Get piColumnId of oFileDate_col to iFileDateCol
102215>>>            Get piColumnId of oPath_col     to iPathCol
102216>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
102217>>>
102217>>>            Move 0 to iRow
102218>>>            For iCount from 0 to iSize
102224>>>>
102224>>>                Move saSearchResultArray[iCount].sFilename           to TheData[iRow].sValue[iFileNameCol]
102225>>>                Move saSearchResultArray[iCount].dtLastWriteDateTime to TheData[iRow].sValue[iFileDateCol]
102226>>>                Move (Trim(saSearchResultArray[iCount].sAlternateFileName) + Trim(saSearchResultArray[iCount].sFilename)) to TheData[iRow].sValue[iPathCol]
102227>>>                Move False                                           to TheData[iRow].sValue[iCheckBoxCol]
102228>>>                Increment iRow
102229>>>            Loop
102230>>>>
102230>>>
102230>>>            If (iRow <> 0) Begin
102232>>>                Send ReInitializeData TheData False
102233>>>                Send MoveToFirstRow
102234>>>            End
102234>>>>
102234>>>            Else Begin
102235>>>                Send InitializeData TheDataEmpty
102236>>>            End
102236>>>>
102236>>>            Get CheckedItems to iCount
102237>>>            Set psFooterText of oFileName_col  to ("No of Backup Files:" * String(iCount))
102238>>>        End_Procedure
102239>>>
102239>>>    End_Object
102240>>>
102240>>>    Object oInfo_tb is a cRefactorTextbox
102242>>>        Set Size to 10 204
102243>>>        Set Location to 189 156
102244>>>        Set Label to "The selections will overwrite files in AppSrc, to 'Undo' changes."
102245>>>        Set peAnchors to anBottomRight
102246>>>        Set Justification_Mode to JMode_Left
102247>>>    End_Object
102248>>>
102248>>>    Object oOK_Btn is a cRDCButtonDPI
102250>>>        Set Size to 14 60
102251>>>        Set Label    to "Move Files"
102252>>>        Set Location to 186 364
102253>>>        Set peAnchors to anBottomRight
102254>>>        Set psToolTip to "The selected backup files will be moved to their original place, overwriting what is already there."
102255>>>        Set psImage to "ActionMoveBack.ico"
102256>>>        Set pbAutoEnable to True
102257>>>
102257>>>        Procedure OnClick
102260>>>            Integer iCheckedItems iRetval
102260>>>
102260>>>            Get CheckedItems of oBackupFiles_grd to iCheckedItems
102261>>>            If (iCheckedItems = 0) Begin
102263>>>                Send Info_Box "No backup files selected - nothing to do."
102264>>>                Procedure_Return
102265>>>            End
102265>>>>
102265>>>
102265>>>            Get YesNo_Box ("Are you sure you want to overwrite" * String(iCheckedItems) * "source file(s) with the selected backup file(s)?\n\nNo check will be performed if files already exists. Nor will any check be done if files are newer or not.") to iRetval
102266>>>            If (iRetval <> MBR_Yes) Begin
102268>>>                Procedure_Return
102269>>>            End
102269>>>>
102269>>>            Get YesNo_Box ("Are you REALLY sure?") to iRetval
102270>>>            If (iRetval <> MBR_Yes) Begin
102272>>>                Procedure_Return
102273>>>            End
102273>>>>
102273>>>
102273>>>            Send MoveBackBackupFiles
102274>>>            Send Info_Box "Ready!"
102275>>>            Send Close_Panel
102276>>>        End_Procedure
102277>>>
102277>>>        Function IsEnabled Returns Boolean
102280>>>            Integer iCheckedItems
102280>>>
102280>>>            Get CheckedItems of oBackupFiles_grd to iCheckedItems
102281>>>
102281>>>            Function_Return (iCheckedItems <> 0)
102282>>>        End_Function
102283>>>
102283>>>    End_Object
102284>>>
102284>>>    Object oCompare_btn is a cRDCButtonDPI
102286>>>        Set Location to 186 428
102287>>>        Set Label to "Compare"
102288>>>        Set psImage to "Compare.ico"
102289>>>        Set psToolTip to "Start the compare tool that has been setup on the 'Program Settings' dialog, to compare and copy files from the backup area."
102290>>>        Set pbAutoEnable to True
102291>>>        Set peAnchors to anBottomRight
102292>>>
102292>>>        Procedure OnClick
102295>>>            String sCompareApp
102295>>>            Get psFileCompareApp of ghoApplication to sCompareApp
102296>>>            Send ComparePaths of ghoApplication sCompareApp
102297>>>        End_Procedure
102298>>>
102298>>>        Function IsEnabled Returns Boolean
102301>>>            String sCompareApp
102301>>>            Boolean bOK
102301>>>
102301>>>            Move False to bOK
102302>>>            Get psFileCompareApp of ghoApplication to sCompareApp
102303>>>            Move (sCompareApp <> "") to bOK
102304>>>
102304>>>            Function_Return bOK
102305>>>        End_Function
102306>>>
102306>>>    End_Object
102307>>>
102307>>>    Object oCancel_Btn is a cRDCButton
102309>>>        Set Label to "&Close"
102310>>>        Set Location to 186 486
102311>>>        Set peAnchors to anBottomRight
102312>>>
102312>>>        Procedure OnClick
102315>>>            Send Close_Panel
102316>>>        End_Procedure
102317>>>
102317>>>    End_Object
102318>>>
102318>>>    Object oTextBox1 is a TextBox
102320>>>        Set Size to 9 86
102321>>>        Set Location to 3 25
102322>>>        Set Label to "Right click grid for options"
102323>>>    End_Object
102324>>>
102324>>>    Procedure MoveBackBackupFiles
102327>>>        Integer iSize iCount iRetval
102327>>>        String sBackupFileName sSourceFileName
102327>>>        String[] saSelectedItems
102328>>>
102328>>>        Get SelectedItems of oBackupFiles_grd to saSelectedItems
102329>>>        Move (SizeOfArray(saSelectedItems)) to iSize
102330>>>        Decrement iSize
102331>>>
102331>>>        For iCount from 0 to iSize
102337>>>>
102337>>>            Move saSelectedItems[iCount] to sBackupFileName
102338>>>            Move (Replace((CS_DirSeparator + CS_BackupFolder), sBackupFileName, "")) to sSourceFileName
102339>>>            Get vMoveFile sBackupFileName sSourceFileName to iRetval
102340>>>            If (iRetval = 0) Begin
102342>>>                Showln "Moved File: " sBackupFileName " To: " sSourceFileName
102347>>>            End
102347>>>>
102347>>>            Else Begin
102348>>>                Showln "Error moving file: " sBackupFileName
102351>>>            End
102351>>>>
102351>>>        Loop
102352>>>>
102352>>>
102352>>>    End_Procedure
102353>>>
102353>>>    On_Key Key_Alt+Key_A  Send SelectAll
102354>>>    On_Key Key_Ctrl+Key_A Send SelectAll
102355>>>    On_Key Key_Alt+Key_N  Send SelectNone
102356>>>    On_Key Key_Ctrl+Key_N Send SelectNone
102357>>>    On_Key Key_Alt+Key_I  Send SelectInvert
102358>>>    On_Key Key_Ctrl+Key_I Send SelectInvert
102359>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
102360>>>End_Object
102361>>>
102361>>>Procedure FillBackupFilesDialog  tsSearchResult[] SearchResultArray
102364>>>    Handle ho
102364>>>
102364>>>    Move (oBackupFiles_dg(Self)) to ho
102365>>>    Set psaSearchResultArray of ho to SearchResultArray
102366>>>    Send Popup of ho
102367>>>End_Procedure
102368>        Use UnusedSourceFiles.dg
Including file: UnusedSourceFiles.dg    (C:\Projects\DF18\DfRefactor\AppSrc\UnusedSourceFiles.dg)
102368>>>Use cRDCModalPanel.pkg
102368>>>Use Cursor.pkg
102368>>>Use vWin32fh.pkg
102368>>>Use cRDCCJSelectionGrid.pkg
102368>>>Use cRefactorTextbox.pkg
102368>>>Use cRDCButtonDPI.pkg
102368>>>Use RefactorFunctionConstants.inc
102368>>>Use cUnusedSourceFiles.pkg
102368>>>
102368>>>Object oUnusedSourceFiles_dg is a cRDCModalPanel
102370>>>    Set Label to "Unused Source Files"
102371>>>    Set Size to 209 366
102372>>>    Set Location to 2 2
102373>>>    Set piMinSize to 209 366
102374>>>    Set Icon to "UnusedSourceFiles.ico"
102375>>>
102375>>>    Property tUnusedSourceFiles[] psaSourceFileArray
102377>>>
102377>>>    Object oUnusedSourceFiles_grd is a cRDCCJSelectionGrid
102379>>>        Set Size to 164 338
102380>>>        Set Location to 14 14
102381>>>
102381>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
102383>>>            Set piWidth to 25
102384>>>            Set pbResizable to False
102385>>>        End_Object
102386>>>
102386>>>        Object oSourceFile_col is a cCJGridColumn
102388>>>            // This must be here:
102388>>>            Set phoData_Col to Self
102389>>>            Set piWidth to 675
102390>>>            Set psCaption to "Full Path and File Name"
102391>>>        End_Object
102392>>>
102392>>>        Procedure LoadData
102395>>>            Handle hoDataSource
102395>>>            tDataSourceRow[] TheData TheDataEmpty
102395>>>            tDataSourceRow[] TheData TheDataEmpty
102397>>>            tUnusedSourceFiles[] saSourceFileArray
102397>>>            tUnusedSourceFiles[] saSourceFileArray
102398>>>            Integer iSize iRow iCount iDataCol iCheckBoxCol
102398>>>
102398>>>            If (not(IsComObjectCreated(Self))) Begin
102400>>>                Procedure_Return
102401>>>            End
102401>>>>
102401>>>
102401>>>            Get psaSourceFileArray to saSourceFileArray
102402>>>            Move (SizeOfArray(saSourceFileArray)) to iSize
102403>>>            If (iSize = 0) Begin
102405>>>                Procedure_Return
102406>>>            End
102406>>>>
102406>>>
102406>>>            Move 0 to iCount
102407>>>            Decrement iSize
102408>>>            Get phoDataSource to hoDataSource
102409>>>            Get DataSource of hoDataSource to TheData
102410>>>            Move TheDataEmpty to TheData
102411>>>            Get piColumnId of oSourceFile_col         to iDataCol
102412>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
102413>>>
102413>>>            Move 0 to iRow
102414>>>            For iCount from 0 to iSize                  
102420>>>>
102420>>>                Move (saSourceFileArray[iCount].sPath + String(saSourceFileArray[iCount].sFileName)) to TheData[iRow].sValue[iDataCol]
102421>>>                Move False  to TheData[iRow].sValue[iCheckBoxCol]
102422>>>                Increment iRow
102423>>>            Loop
102424>>>>
102424>>>
102424>>>            If (iRow <> 0) Begin
102426>>>                Send ReInitializeData TheData False
102427>>>                Send MoveToFirstRow
102428>>>            End
102428>>>>
102428>>>            Else Begin
102429>>>                Send InitializeData TheDataEmpty
102430>>>            End
102430>>>>
102430>>>            Move (iSize + 1) to iCount
102431>>>            Set psFooterText of oSourceFile_col  to ("No of Files:" * String(iCount))
102432>>>        End_Procedure
102433>>>
102433>>>    End_Object
102434>>>
102434>>>    Object oOK_Btn is a cRDCButtonDPI
102436>>>        Set Size to 14 60
102437>>>        Set Label    to "Move Files"
102438>>>        Set Location to 186 235
102439>>>        Set peAnchors to anBottomRight
102440>>>        Set psToolTip to "The selected unused source files will be moved to the backup area."
102441>>>        Set psImage to "ActionMoveBack.ico"
102442>>>        Set pbAutoEnable to True
102443>>>
102443>>>        Procedure OnClick
102446>>>            Integer iCheckedItems iRetval
102446>>>
102446>>>            Get CheckedItems of oUnusedSourceFiles_grd to iCheckedItems
102447>>>            If (iCheckedItems = 0) Begin
102449>>>                Send Info_Box "No files selected - nothing to do."
102450>>>                Procedure_Return
102451>>>            End
102451>>>>
102451>>>
102451>>>            Get YesNo_Box ("Are you sure you want to move" * String(iCheckedItems) * "source file(s) to the backup area?") to iRetval
102452>>>            If (iRetval <> MBR_Yes) Begin
102454>>>                Procedure_Return
102455>>>            End
102455>>>>
102455>>>
102455>>>            Send MoveFilesToBackupArea
102456>>>            Send Info_Box "Ready!"
102457>>>            Send Close_Panel
102458>>>        End_Procedure
102459>>>
102459>>>        Function IsEnabled Returns Boolean
102462>>>            Integer iCheckedItems
102462>>>
102462>>>            Get CheckedItems of oUnusedSourceFiles_grd to iCheckedItems
102463>>>
102463>>>            Function_Return (iCheckedItems <> 0)
102464>>>        End_Function
102465>>>
102465>>>    End_Object
102466>>>
102466>>>    Procedure MoveFilesToBackupArea
102469>>>        Integer iSize iCount iRetval
102469>>>        String sBackupFileName sSourceFileName
102469>>>        String[] saSelectedItems
102470>>>
102470>>>        Send Cursor_Wait of Cursor_Control
102471>>>        Get SelectedItems of oUnusedSourceFiles_grd to saSelectedItems
102472>>>        Move (SizeOfArray(saSelectedItems)) to iSize
102473>>>        Decrement iSize
102474>>>
102474>>>        For iCount from 0 to iSize
102480>>>>
102480>>>            Move saSelectedItems[iCount] to sSourceFileName
102481>>>            Get BackupFileName of ghoApplication sSourceFileName to sBackupFileName
102482>>>            Get vMoveFile sSourceFileName sBackupFileName to iRetval
102483>>>            If (iRetval <> 0) Begin
102485>>>                Showln "Error moving file: " sSourceFileName " to: " sBackupFileName
102490>>>            End
102490>>>>
102490>>>        Loop
102491>>>>
102491>>>        Send Cursor_Ready of Cursor_Control
102492>>>
102492>>>    End_Procedure
102493>>>
102493>>>    Object oCancel_Btn is a cRDCButton
102495>>>        Set Label to "&Close"
102496>>>        Set Location to 186 303
102497>>>        Set peAnchors to anBottomRight
102498>>>
102498>>>        Procedure OnClick
102501>>>            Send Close_Panel
102502>>>        End_Procedure
102503>>>
102503>>>    End_Object
102504>>>
102504>>>    Object oInfo_tb is a cRefactorTextbox
102506>>>        Set Size to 10 217
102507>>>        Set Location to 189 11
102508>>>        Set Label to "The selected unused source files will be moved to the backup area."
102509>>>        Set peAnchors to anBottomRight
102510>>>        Set Justification_Mode to JMode_Left
102511>>>    End_Object
102512>>>
102512>>>    Object oTextBox1 is a TextBox
102514>>>        Set Size to 9 86
102515>>>        Set Location to 3 25
102516>>>        Set Label to "Right click grid for options"
102517>>>    End_Object
102518>>>
102518>>>    On_Key Key_Alt+Key_A  Send SelectAll
102519>>>    On_Key Key_Ctrl+Key_A Send SelectAll
102520>>>    On_Key Key_Alt+Key_N  Send SelectNone
102521>>>    On_Key Key_Ctrl+Key_N Send SelectNone
102522>>>    On_Key Key_Alt+Key_I  Send SelectInvert
102523>>>    On_Key Key_Ctrl+Key_I Send SelectInvert
102524>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
102525>>>End_Object
102526>>>
102526>>>Procedure FillUnusedSourceFilesDialog tUnusedSourceFiles[] saSourceFileArray
102529>>>    Handle ho
102529>>>
102529>>>    Move (oUnusedSourceFiles_dg(Self)) to ho
102530>>>    If (not(SizeOfArray(saSourceFileArray))) Begin
102532>>>        Procedure_Return
102533>>>    End
102533>>>>
102533>>>    Set psaSourceFileArray of ho to saSourceFileArray
102534>>>
102534>>>End_Procedure
102535>>>
102535>>>Procedure DisplayUnusedSourceFilesDialog
102538>>>    Handle ho
102538>>>    tUnusedSourceFiles[] saSourceFileArray
102538>>>    tUnusedSourceFiles[] saSourceFileArray
102539>>>
102539>>>    Move (oUnusedSourceFiles_dg(Self)) to ho
102540>>>    Get psaSourceFileArray of ho to saSourceFileArray
102541>>>    If (not(SizeOfArray(saSourceFileArray))) Begin
102543>>>        Procedure_Return
102544>>>    End
102544>>>>
102544>>>
102544>>>    Send Popup of ho
102545>>>End_Procedure
102546>        Use LogFileDialog.dg   
Including file: LogFileDialog.dg    (C:\Projects\DF18\DfRefactor\AppSrc\LogFileDialog.dg)
102546>>>Use Windows.pkg
102546>>>Use cRichEdit.pkg
102546>>>Use cRDCButtonDPI.pkg
102546>>>Use cRDCModalPanel.pkg
102546>>>Use seq_chnl.pkg
102546>>>Use vWin32fh.pkg
102546>>>
102546>>>Object oLogFileDialog_dg is a cRDCModalPanel
102548>>>    Set Size to 269 624
102549>>>    Set Label to "Log File Dialog"
102550>>>    Set piMinSize to 89 211
102551>>>    Set Location to 2 2
102552>>>    Set Icon to "OpenLogFile.ico"
102553>>>
102553>>>    Property String psLogFileName ""
102555>>>    Property Integer piIndent
102557>>>
102557>>>    Object oLogFile_edt is a cRichEdit
102559>>>        Set Size to 224 603
102560>>>        Set Location to 16 11
102561>>>        Set TextColor to clBlack
102562>>>        Set peAnchors to anAll
102563>>>        Set Label_Row_Offset to 3
102564>>>        Set Label_TextColor to clGreenGreyLight
102565>>>        Set TextColor to clGreenGreyLight 
102566>>>        Set Label_FontItalics to True
102567>>>        Set piFontSize to 200
102568>>>        Set psTypeFace to 'Consolas'
102569>>>
102569>>>        Delegate Set piIndent to (piParagraphIndent(Self))
102571>>>
102571>>>        Procedure DoSaveDocument
102574>>>            String sLogFileName
102574>>>            Boolean bOk bOkToSave bChanged
102574>>>
102574>>>            Move False to bOkToSave
102575>>>            Get pbCanUndo to bChanged
102576>>>            If (bChanged = False) Begin
102578>>>                Procedure_Return
102579>>>            End
102579>>>>
102579>>>
102579>>>            Get psLogFileName to sLogFileName
102580>>>            Send Write sLogFileName
102581>>>            // clear undo buffer on save
102581>>>            // we want undo buffer to only apply to the new document
102581>>>            Send ClearUndoBuffer
102582>>>            Send Info_Box "Changes saved."
102583>>>        End_Procedure
102584>>>
102584>>>        Procedure LoadData
102587>>>            String sLogFileName
102587>>>            Integer iTwips iIndent
102587>>>
102587>>>            Get psLogFileName to sLogFileName
102588>>>            Set Label to sLogFileName  
102589>>>            Move 1440 to iTwips
102590>>>            Get piIndent to iIndent
102591>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
102592>>>
102592>>>            Send Read sLogFileName
102593>>>        End_Procedure
102594>>>        
102594>>>        Procedure DisplayCurrentSourceLine
102597>>>            Integer iLine iPos iSize
102597>>>            String sLine sSearch           
102597>>>            Boolean bFound    
102597>>>            Handle ho
102597>>>            
102597>>>//            Get phoEditorRefactored of ghoApplication to ho
102597>>>//            Get Line_Count of ho to iSize
102597>>>//            If (iSize <= 1) Begin
102597>>>//                Procedure_Return
102597>>>//            End
102597>>>//            
102597>>>//            Move -1 to iLine    
102597>>>//            Move " ON LINE: " to sSearch
102597>>>//            Get LineFromChar iLine to iLine
102597>>>//            Get Line iLine to sLine     
102597>>>//            Move (Pos(sSearch, sLine)) to iPos
102597>>>//            If (iPos <> 0) Begin
102597>>>//                Move (Mid(sLine, Length(sLine), (iPos + Length(sSearch)))) to sLine
102597>>>//                Move (Pos(" ", sLine)) to iPos
102597>>>//                Move (Left(sLine, (iPos - 1))) to sLine
102597>>>//                Move (Trim(sLine)) to iLine 
102597>>>//                Decrement iLine
102597>>>//                Move True to bFound
102597>>>//            End
102597>>>//            
102597>>>//            If (bFound = True) Begin         
102597>>>//                Send Close_Panel
102597>>>//                Send JumpToSourceLine of (Client_Id(phoMainPanel(ghoApplication))) iLine    
102597>>>//                Send Activate of ho
102597>>>//            End
102597>>>        End_Procedure   
102598>>>        
102598>>>        Procedure Mouse_Click
102601>>>            Send DisplayCurrentSourceLine
102602>>>        End_Procedure
102603>>>
102603>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
102604>>>        On_Key kCancel Send Cancel  
102605>>>        On_Key kEnter  Send DisplayCurrentSourceLine
102606>>>    End_Object
102607>>>
102607>>>    Object oCancel_Btn is a cRDCButtonDPI
102609>>>        Set Label    to "&Close"
102610>>>        Set Location to 248 564
102611>>>        Set peAnchors to anBottomRight
102612>>>
102612>>>        Procedure OnClick
102615>>>            Send Close_Panel
102616>>>        End_Procedure
102617>>>
102617>>>    End_Object
102618>>>
102618>>>
102618>>>    Object oFirstRun_btn is a cRDCButtonDPI
102620>>>        Set Location to 248 450
102621>>>        Set Label to "View Top"
102622>>>        Set peAnchors to anBottomRight
102623>>>
102623>>>        Procedure OnClick
102626>>>            Send Beginning_of_Data to oLogFile_edt
102627>>>        End_Procedure
102628>>>
102628>>>    End_Object
102629>>>
102629>>>    Object oLatestRun_btn is a cRDCButtonDPI
102631>>>        Set Location to 248 507
102632>>>        Set Label to "View Bottom"
102633>>>        Set peAnchors to anBottomRight
102634>>>
102634>>>        Procedure OnClick
102637>>>            Send End_of_Data to oLogFile_edt
102638>>>        End_Procedure
102639>>>
102639>>>    End_Object
102640>>>
102640>>>    // Automatically load data into the grid when activating.
102640>>>    Procedure Activating
102643>>>        Handle ho  
102643>>>        String sLogFileName
102643>>>        
102643>>>        Forward Send Activating
102645>>>        Move (oLogFile_edt(Self)) to ho
102646>>>        Send LoadData    of ho
102647>>>        // We need to active before we can send end_of_data.
102647>>>        Send Activate    of ho
102648>>>        Send End_of_Data to ho
102649>>>        Get psLogFileName to sLogFileName
102650>>>        Set psText of (oStatusIdle(Statusbar_Id(Self))) to sLogFileName
102651>>>    End_Procedure
102652>>>
102652>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRun_btn
102653>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRun_btn
102654>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRun_btn
102655>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRun_btn
102656>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
102657>>>End_Object
102658>>>
102658>>>Procedure ActivateLogFileDialog String sLogFile
102661>>>    Handle ho
102661>>>    Boolean bExists
102661>>>
102661>>>    Get vFilePathExists sLogFile to bExists
102662>>>    If (bExists = False) Begin
102664>>>        Send Info_Box "The logfile doesn't exist."
102665>>>        Procedure_Return
102666>>>    End
102666>>>>
102666>>>    Move (oLogFileDialog_dg(Self)) to ho
102667>>>    Set psLogFileName of ho to sLogFile
102668>>>    Send Popup of ho
102669>>>End_Procedure
102670>        Use StatusLog.dg
102670>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\StdAbout.pkg)
102670>>>//************************************************************************
102670>>>// Confidential Trade Secret.
102670>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
102670>>>// as an unpublished work.  All rights reserved.
102670>>>// DataFlex is a registered trademark of Data Access Corporation.
102670>>>//
102670>>>//************************************************************************
102670>>>//************************************************************************
102670>>>//
102670>>>// $File name  : StdAbout.pkg
102670>>>// $File title : Standard about object package for VDF
102670>>>// Notice      :
102670>>>// $Author(s)  : John Tuohy
102670>>>//
102670>>>// $Rev History
102670>>>//
102670>>>// JT 06/27/97   File created
102670>>>//************************************************************************
102670>>>
102670>>>// This provides a quick and simple way to create an about package for a program.
102670>>>// You need to create a message inside you client area called Activate_About.
102670>>>// Within this message you should send the message DoAbout passing needed
102670>>>// string information.
102670>>>//
102670>>>//       Procedure Activate_About
102670>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
102670>>>//       End_Procedure
102670>>>//    where: sTitle =     Name of application. If none provided, uses caption
102670>>>//                        bar title
102670>>>//           sVersion   = Version Line. If none provided, will be blank
102670>>>//           sCopyRight = Copyright Line. If none provided, will be blank
102670>>>//           sAuthor    = Author name, blank if none provided
102670>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
102670>>>//                        is used.
102670>>>// It is expected that you will place this in your own object package. For
102670>>>// example an order about package may look like this:
102670>>>//
102670>>>//   // OrderAbout.pkg
102670>>>//   Use StdAbout.pkg
102670>>>//   Procedure Activate_About
102670>>>//      String sTitle sCopyright sVersion sAuthor
102670>>>//      Move "My Order Entry System" to sTitle
102670>>>//      Move "Version 2.1" to sVersion
102670>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
102670>>>//      Move "John Smith"  to sAuthor
102670>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
102670>>>//   end_procedure
102670>>>//   // end of file.
102670>>>
102670>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\DfAbout.pkg)
102670>>>>>Use LanguageText.pkg
102670>>>>>Use Windows.pkg
102670>>>>>Use Dfclient.pkg
102670>>>>>Use DFbitmap.pkg
102670>>>>>Use GlobalFunctionsProcedures.pkg
102670>>>>>Use cRichEdit.pkg
102670>>>>>Use cTextEdit.pkg
102670>>>>>Use cRichEdit.pkg
102670>>>>>Use gFormatNumbers.pkg
102670>>>>>Use tWinStructs.pkg
102670>>>>>
102670>>>>>Use cli.pkg
102670>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
102670>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
102670>>>>>>>// Notice      : This package contains constants and commands, used to call
102670>>>>>>>//               specific functions in the DFBTRDRV.
102670>>>>>>>Use Ui
102670>>>>>>>//
102670>>>>>>>// Driver Indentification
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>// Driver attributes
102670>>>>>>>//
102670>>>>>>>// Call_Driver functions ID's
102670>>>>>>>//
102670>>>>>>>//
102670>>>>>>>// DFBTRFN_CONVERT_FILE options
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// DFBTRFN_SET_OWNER options
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to create all vars which may be needed
102670>>>>>>>// in other commands.
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to set the owner of a Btrieve file.
102670>>>>>>>// File must have been opened.
102670>>>>>>>// Filenumber needs to be passed.
102670>>>>>>>// To clear set the owner to "".
102670>>>>>>>// Examples:
102670>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
102670>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
102670>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
102670>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
102670>>>>>>>// To clear:
102670>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to parse DFBTR_SET_OWNVER
102670>>>>>>>// options.
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to parse for Callback
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to clear the owner of a Btrieve file.
102670>>>>>>>// File must have been opened.
102670>>>>>>>// Filenumber needs to be passed.
102670>>>>>>>// Examples:
102670>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to add a owner name to the internal list of ownernames
102670>>>>>>>// which will be tries when opening files.
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to remove all owners from the internal list of ownernames
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to set the owner name to be used when opening the DDF files.
102670>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
102670>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
102670>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to change the transaction type.
102670>>>>>>>// Valid types are:
102670>>>>>>>//     DFBTRTT_NONE
102670>>>>>>>//     DFBTRTT_EXCLUSIVE
102670>>>>>>>//     DFBTRTT_CONCURRENT
102670>>>>>>>//
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to get the current transaction type.
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to set explicit_locking
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to get explicit locking
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>//
102670>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
102670>>>>>>>//
102670>>>>>>>
102670>>>>>>>// Purpose: An instance of this class can be used as a broker object to
102670>>>>>>>//          call several Dfbtrdrv releated methods.
102670>>>>>>>
102670>>>>>>>Class cDFBtrDrvHandler is an Array
102671>>>>>>>    
102671>>>>>>>    Procedure Construct_Object Integer iImage
102673>>>>>>>        Forward Send Construct_object iImage
102675>>>>>>>        
102675>>>>>>>        Property String  psDriverID "DFBTRDRV"
102676>>>>>>>    End_Procedure
102677>>>>>>>    
102677>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
102677>>>>>>>    //
102677>>>>>>>    
102677>>>>>>>    Function CKRevision Returns String
102679>>>>>>>        String  sDriverID
102679>>>>>>>        String  sRevision
102679>>>>>>>        String  sVoid
102679>>>>>>>        Integer iRetval
102679>>>>>>>        
102679>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
102679>>>>>>>        // This error would otherwise be raised when we have an older
102679>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
102679>>>>>>>        Send Ignore_error to Error_object_Id 20491
102680>>>>>>>        Get psDriverID to sDriverID
102681>>>>>>>        Move (Repeat(" ", 255)) to sRevision
102682>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
102687>>>>>>>        Send Trap_Error to Error_object_Id 20491
102688>>>>>>>        If (Trim(sRevision) = "") Begin
102690>>>>>>>            // Unable to get the revision. return all zeroes.
102690>>>>>>>            Move "0.0.0.0" to sRevision
102691>>>>>>>        End
102691>>>>>>>>
102691>>>>>>>        Function_Return sRevision
102692>>>>>>>    End_Function
102693>>>>>>>    
102693>>>>>>>    Function CkUsesUri Returns Integer
102695>>>>>>>        String  sDriverID
102695>>>>>>>        String  sVoid1
102695>>>>>>>        String  sVoid2
102695>>>>>>>        Integer iRetval
102695>>>>>>>        
102695>>>>>>>        Get psDriverID to sDriverID
102696>>>>>>>        
102696>>>>>>>        Move 0 to iRetval
102697>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
102697>>>>>>>        // This error would otherwise be raised when we have an older
102697>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
102697>>>>>>>        Send Ignore_error to Error_object_Id 20491
102698>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
102703>>>>>>>        Send Trap_Error to Error_object_Id 20491
102704>>>>>>>        
102704>>>>>>>        Function_Return iRetval
102705>>>>>>>    End_Function
102706>>>>>>>    
102706>>>>>>>    
102706>>>>>>>    
102706>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
102706>>>>>>>    //
102706>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
102706>>>>>>>    //
102706>>>>>>>    
102706>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
102708>>>>>>>        Integer iPartRev
102708>>>>>>>        Integer iCurrentPart
102708>>>>>>>        Integer iSeparatorPos
102708>>>>>>>        
102708>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
102711>>>>>>>        
102711>>>>>>>        Move 0 to iCurrentPart
102712>>>>>>>        Repeat
102712>>>>>>>>
102712>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
102713>>>>>>>            If (iSeparatorPos > 0) Begin
102715>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
102716>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
102717>>>>>>>                Increment iCurrentPart
102718>>>>>>>            End
102718>>>>>>>>
102718>>>>>>>            Else If (sRevision <> "") Begin
102721>>>>>>>                Move sRevision to iPartRev
102722>>>>>>>                Move "" to sRevision
102723>>>>>>>                Increment iCurrentPart
102724>>>>>>>            End
102724>>>>>>>>
102724>>>>>>>            Else ;                Move -1 to iPartRev
102726>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
102728>>>>>>>        
102728>>>>>>>        Function_Return iPartRev
102729>>>>>>>    End_Function
102730>>>>>>>    
102730>>>>>>>    
102730>>>>>>>    
102730>>>>>>>    //
102730>>>>>>>    //  Returns the major revision of the CK
102730>>>>>>>    //
102730>>>>>>>    
102730>>>>>>>    Function CKMajorRevision Returns Integer
102732>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
102733>>>>>>>    End_Function
102734>>>>>>>    
102734>>>>>>>    
102734>>>>>>>    
102734>>>>>>>    //  Returns the minor revision of the CK
102734>>>>>>>    //
102734>>>>>>>    
102734>>>>>>>    Function CKMinorRevision Returns Integer
102736>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
102737>>>>>>>    End_Function
102738>>>>>>>    
102738>>>>>>>    
102738>>>>>>>    //  Returns the release revision of the CK
102738>>>>>>>    //
102738>>>>>>>    
102738>>>>>>>    Function CKReleaseRevision Returns Integer
102740>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
102741>>>>>>>    End_Function
102742>>>>>>>    
102742>>>>>>>    
102742>>>>>>>    //  Returns the major revision of the CK
102742>>>>>>>    //
102742>>>>>>>    
102742>>>>>>>    Function CKBuildRevision Returns Integer
102744>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
102745>>>>>>>    End_Function
102746>>>>>>>    
102746>>>>>>>    
102746>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
102746>>>>>>>    //
102746>>>>>>>    
102746>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
102748>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
102751>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
102754>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
102757>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
102760>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
102763>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
102767>>>>>>>            End
102767>>>>>>>>
102767>>>>>>>        End
102767>>>>>>>>
102767>>>>>>>        
102767>>>>>>>        Function_Return (False)
102768>>>>>>>    End_Function
102769>>>>>>>    
102769>>>>>>>    //   Functions to query the Pervasive.SQL version:
102769>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
102769>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
102769>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
102769>>>>>>>    //
102769>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
102769>>>>>>>    //   in the following format:
102769>>>>>>>    //       <version>.<revision>.<type>
102769>>>>>>>    //   possible values for <type>:
102769>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
102769>>>>>>>    //         server using Workgroup authentication mode
102769>>>>>>>    //       C for client cache engine
102769>>>>>>>    //       D for DOS workstation
102769>>>>>>>    //       N for client Requester
102769>>>>>>>    //       S for NetWare server
102769>>>>>>>    //       T for 32-bit Windows server engine
102769>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
102769>>>>>>>    //
102769>>>>>>>    //   example:
102769>>>>>>>    //       8.50.T
102769>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
102769>>>>>>>    //   32-bits Windows server.
102769>>>>>>>    //
102769>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
102769>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
102769>>>>>>>    //
102769>>>>>>>    //   If the version information is not available or can not be obtained
102769>>>>>>>    //   the functions will return "0.0.0"
102769>>>>>>>    
102769>>>>>>>    //  Returns the version information of the
102769>>>>>>>    //           Pervasive.SQL Client requester.
102769>>>>>>>    
102769>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
102771>>>>>>>        
102771>>>>>>>        String  sDriverID
102771>>>>>>>        String  sVersion
102771>>>>>>>        String  sVoid
102771>>>>>>>        Integer iRetval
102771>>>>>>>        
102771>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
102771>>>>>>>        // This error would otherwise be raised when we have an older
102771>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
102771>>>>>>>        Send Ignore_error to Error_object_Id 20491
102772>>>>>>>        Get psDriverID to sDriverID
102773>>>>>>>        Move (Repeat(" ", 255)) to sVersion
102774>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
102779>>>>>>>        Send Trap_Error to Error_object_Id 20491
102780>>>>>>>        If (Trim(sVersion) = "") Begin
102782>>>>>>>            // Unable to get the revision. return all zeroes.
102782>>>>>>>            Move "0.0.0" to sVersion
102783>>>>>>>        End
102783>>>>>>>>
102783>>>>>>>        Function_Return sVersion
102784>>>>>>>    End_Function
102785>>>>>>>    
102785>>>>>>>    //           Pervasive.SQL Engine
102785>>>>>>>    
102785>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
102787>>>>>>>        
102787>>>>>>>        String  sDriverID
102787>>>>>>>        String  sVersion
102787>>>>>>>        String  sVoid
102787>>>>>>>        Integer iRetval
102787>>>>>>>        
102787>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
102787>>>>>>>        // This error would otherwise be raised when we have an older
102787>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
102787>>>>>>>        Send Ignore_error to Error_object_Id 20491
102788>>>>>>>        Get psDriverID to sDriverID
102789>>>>>>>        Move (Repeat(" ", 255)) to sVersion
102790>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
102795>>>>>>>        Send Trap_Error to Error_object_Id 20491
102796>>>>>>>        If (Trim(sVersion) = "") Begin
102798>>>>>>>            // Unable to get the revision. return all zeroes.
102798>>>>>>>            Move "0.0.0" to sVersion
102799>>>>>>>        End
102799>>>>>>>>
102799>>>>>>>        Function_Return sVersion
102800>>>>>>>    End_Function
102801>>>>>>>    
102801>>>>>>>    //  Returns the version information of the
102801>>>>>>>    //           Pervasive.SQL Server Engine
102801>>>>>>>    
102801>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
102803>>>>>>>        
102803>>>>>>>        String  sDriverID
102803>>>>>>>        String  sVersion
102803>>>>>>>        String  sVoid
102803>>>>>>>        Integer iRetval
102803>>>>>>>        
102803>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
102803>>>>>>>        // This error would otherwise be raised when we have an older
102803>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
102803>>>>>>>        Send Ignore_error to Error_object_Id 20491
102804>>>>>>>        Get psDriverID to sDriverID
102805>>>>>>>        Move (Repeat(" ", 255)) to sVersion
102806>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
102811>>>>>>>        Send Trap_Error to Error_object_Id 20491
102812>>>>>>>        If (Trim(sVersion) = "") Begin
102814>>>>>>>            // Unable to get the revision. return all zeroes.
102814>>>>>>>            Move "0.0.0" to sVersion
102815>>>>>>>        End
102815>>>>>>>>
102815>>>>>>>        Function_Return sVersion
102816>>>>>>>    End_Function
102817>>>>>>>    
102817>>>>>>>End_Class
102818>>>>>>>
102818>>>>>>>
102818>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
102818>>>>>>>//     Package that declares MS SQL driver constants and functions.
102818>>>>>>>//     This package can be used by developers who want to add Data Access
102818>>>>>>>//     MS SQL Client specific code to a DataFlex application.
102818>>>>>>>
102818>>>>>>>Use Cli.pkg
102818>>>>>>>Use SQL.pkg
102818>>>>>>>
102818>>>>>>>//   Driver Indentification
102818>>>>>>>
102818>>>>>>>//   Error number constants
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>// SQL Server spcific types.
102818>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
102818>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
102818>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
102818>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
102818>>>>>>>
102818>>>>>>>// SQL Server spcific types.
102818>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
102818>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
102818>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
102818>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
102818>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
102818>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
102818>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
102818>>>>>>>//
102818>>>>>>>//     Setup a constraint for a file.
102818>>>>>>>
102818>>>>>>>
102818>>>>>>>Class cMSSQLHandler is a cCLIHandler
102819>>>>>>>    
102819>>>>>>>    Procedure Construct_Object
102821>>>>>>>        Forward Send Construct_Object
102823>>>>>>>        
102823>>>>>>>        Set psDriverID to MSSQLDRV_ID
102824>>>>>>>    End_Procedure
102825>>>>>>>    
102825>>>>>>>    
102825>>>>>>>    
102825>>>>>>>    //   Extract the list from the out connect string.
102825>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
102827>>>>>>>        String  sItem
102827>>>>>>>        Integer iStart
102827>>>>>>>        Integer iEnd
102827>>>>>>>        
102827>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
102830>>>>>>>        
102830>>>>>>>        Send Delete_Data to hoStore
102831>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
102832>>>>>>>        While (iStart > 0)
102836>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
102837>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
102840>>>>>>>            Else Begin
102841>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
102842>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
102843>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
102846>>>>>>>                
102846>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
102849>>>>>>>                
102849>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
102852>>>>>>>            End
102852>>>>>>>>
102852>>>>>>>        Loop
102853>>>>>>>>
102853>>>>>>>        
102853>>>>>>>        Function_Return (Item_Count(hoStore))
102854>>>>>>>    End_Function
102855>>>>>>>    
102855>>>>>>>    
102855>>>>>>>    
102855>>>>>>>    //   Call the driver's browse connect function
102855>>>>>>>    Function BrowseConnect String sInConnStr Returns String
102857>>>>>>>        String  sDriver
102857>>>>>>>        String  sOutConnStr
102857>>>>>>>        Integer iArg
102857>>>>>>>        Integer iRetval
102857>>>>>>>        
102857>>>>>>>        Get psDriverID to sDriver
102858>>>>>>>        If (sDriver <> "") Begin
102860>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
102861>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
102866>>>>>>>        End
102866>>>>>>>>
102866>>>>>>>        
102866>>>>>>>        Function_Return sOutConnStr
102867>>>>>>>    End_Function// BrowseConnect
102868>>>>>>>    
102868>>>>>>>    
102868>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
102870>>>>>>>        String  sDriver
102870>>>>>>>        String  sOutConnStr
102870>>>>>>>        Integer iArg
102870>>>>>>>        Integer iRetval
102870>>>>>>>        
102870>>>>>>>        Move 1 to iArg // Browses only local
102871>>>>>>>        
102871>>>>>>>        Get psDriverID to sDriver
102872>>>>>>>        If (sDriver <> "") Begin
102874>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
102875>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
102880>>>>>>>        End
102880>>>>>>>>
102880>>>>>>>        
102880>>>>>>>        Function_Return sOutConnStr
102881>>>>>>>    End_Function// BrowseConnect
102882>>>>>>>    
102882>>>>>>>    
102882>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
102884>>>>>>>        
102884>>>>>>>        String  sServerList
102884>>>>>>>        Integer iNumServers
102884>>>>>>>        Integer iDriver
102884>>>>>>>        Integer iClientVersion
102884>>>>>>>        String  sDriver
102884>>>>>>>        
102884>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
102885>>>>>>>        
102885>>>>>>>        If (iDriver) Begin
102887>>>>>>>            
102887>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
102890>>>>>>>            
102890>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
102891>>>>>>>            
102891>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
102892>>>>>>>            If (iNetworkLocal = 0) Begin
102894>>>>>>>                Get BrowseConnect sDriver to sServerList
102895>>>>>>>            End
102895>>>>>>>>
102895>>>>>>>            Else Begin
102896>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
102897>>>>>>>            End
102897>>>>>>>>
102897>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
102898>>>>>>>        End
102898>>>>>>>>
102898>>>>>>>        
102898>>>>>>>        Function_Return iNumServers
102899>>>>>>>        
102899>>>>>>>    End_Function
102900>>>>>>>    
102900>>>>>>>    //   Enumerate the available SQL Server database servers
102900>>>>>>>    //   This function will return all SQL Server instances on the network.
102900>>>>>>>    //   This may take a long time.
102900>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
102900>>>>>>>    Function EnumerateServers Returns Integer
102902>>>>>>>        
102902>>>>>>>        Integer iNumServers
102902>>>>>>>        Integer iNetworkLocal
102902>>>>>>>        
102902>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
102903>>>>>>>        
102903>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
102904>>>>>>>        
102904>>>>>>>        Function_Return iNumServers
102905>>>>>>>        
102905>>>>>>>    End_Function
102906>>>>>>>    
102906>>>>>>>    
102906>>>>>>>    //   Enumerate the available SQL Server database servers
102906>>>>>>>    //   This function will return only return SQL Server instance on the local machine
102906>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
102906>>>>>>>    Function EnumerateServersLocal Returns Integer
102908>>>>>>>        
102908>>>>>>>        Integer iNumServers
102908>>>>>>>        Integer iNetworkLocal
102908>>>>>>>        
102908>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
102909>>>>>>>        
102909>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
102910>>>>>>>        
102910>>>>>>>        Function_Return iNumServers
102911>>>>>>>        
102911>>>>>>>    End_Function
102912>>>>>>>    
102912>>>>>>>    
102912>>>>>>>    
102912>>>>>>>    //   Enumerate database in a given server.
102912>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
102914>>>>>>>        Integer hoSQL
102914>>>>>>>        String  sConnect
102914>>>>>>>        String  sDatabase
102914>>>>>>>        Integer hdbc
102914>>>>>>>        Integer hstmt
102914>>>>>>>        Integer iFetchResult
102914>>>>>>>        
102914>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
102917>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
102920>>>>>>>        
102920>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
102923>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
102925>>>>>>>        
102925>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
102927>>>>>>>            Move Current_Object to hoSQL
102928>>>>>>>        End_Object
102929>>>>>>>        
102929>>>>>>>        If (hoSQL <> 0) Begin
102931>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
102932>>>>>>>            If (hdbc <> 0) Begin
102934>>>>>>>                Get SQLOpen of hdbc to hstmt
102935>>>>>>>                If (hstmt <> 0) Begin
102937>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
102937>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
102937>>>>>>>                    //   approach in case meta data might change, the stored procedure will
102937>>>>>>>                    //   stay the same.
102937>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
102938>>>>>>>                    Send SQLCall to hstmt
102939>>>>>>>                    Repeat
102939>>>>>>>>
102939>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
102940>>>>>>>                        If (iFetchResult <> 0) Begin
102942>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
102943>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
102944>>>>>>>                        End
102944>>>>>>>>
102944>>>>>>>                    Until (iFetchResult = 0)
102946>>>>>>>                    
102946>>>>>>>                    Send SQLClose to hstmt
102947>>>>>>>                End
102947>>>>>>>>
102947>>>>>>>                Send SQLDisconnect to hdbc
102948>>>>>>>            End
102948>>>>>>>>
102948>>>>>>>        End
102948>>>>>>>>
102948>>>>>>>        Send Destroy_Object to hoSQL
102949>>>>>>>        
102949>>>>>>>        Function_Return (Item_Count(Current_Object))
102950>>>>>>>    End_Function
102951>>>>>>>    
102951>>>>>>>    
102951>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
102953>>>>>>>        
102953>>>>>>>        String  sSqlServerClientVersionName
102953>>>>>>>        
102953>>>>>>>        
102953>>>>>>>        Case Begin
102953>>>>>>>            
102953>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
102955>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
102956>>>>>>>                Case Break
102957>>>>>>>                
102957>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
102960>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
102961>>>>>>>                Case Break
102962>>>>>>>            
102962>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
102965>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
102966>>>>>>>                Case Break
102967>>>>>>>            
102967>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
102970>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
102971>>>>>>>                Case Break
102972>>>>>>>            
102972>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
102975>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
102976>>>>>>>                Case Break
102977>>>>>>>            
102977>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
102980>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
102981>>>>>>>                Case Break
102982>>>>>>>            
102982>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
102985>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
102986>>>>>>>                Case Break
102987>>>>>>>            
102987>>>>>>>            Case Else
102987>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
102988>>>>>>>                
102988>>>>>>>        Case End
102988>>>>>>>        
102988>>>>>>>        
102988>>>>>>>        Function_Return sSqlServerClientVersionName
102989>>>>>>>        
102989>>>>>>>    End_Function
102990>>>>>>>
102990>>>>>>>
102990>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
102992>>>>>>>        
102992>>>>>>>        String  sSqlServerClientDriverName
102992>>>>>>>        
102992>>>>>>>        Case Begin
102992>>>>>>>            
102992>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
102994>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
102995>>>>>>>                Case Break
102996>>>>>>>                
102996>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
102999>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
103000>>>>>>>                Case Break
103001>>>>>>>            
103001>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
103004>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
103005>>>>>>>                Case Break
103006>>>>>>>            
103006>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
103009>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
103010>>>>>>>                Case Break
103011>>>>>>>            
103011>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
103014>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
103015>>>>>>>                Case Break
103016>>>>>>>            
103016>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
103019>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
103020>>>>>>>                Case Break
103021>>>>>>>            
103021>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
103024>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
103025>>>>>>>                Case Break
103026>>>>>>>            
103026>>>>>>>            Case Else
103026>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
103027>>>>>>>                
103027>>>>>>>        Case End
103027>>>>>>>        
103027>>>>>>>        
103027>>>>>>>        Function_Return sSqlServerClientDriverName
103028>>>>>>>        
103028>>>>>>>    End_Function
103029>>>>>>>    
103029>>>>>>>    
103029>>>>>>>End_Class
103030>>>>>>>
103030>>>>>>>
103030>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
103030>>>>>>>// DB2_DRV.PKG                                                          
103030>>>>>>>//   Package that declares DB2 driver constants and functions.          
103030>>>>>>>//   This package can be used by developers who want to add DB2 driver  
103030>>>>>>>//   specific code to a DataFlex application.                           
103030>>>>>>>
103030>>>>>>>Use Cli.pkg
103030>>>>>>>
103030>>>>>>>// Driver attributes
103030>>>>>>>
103030>>>>>>>
103030>>>>>>>// Driver Indentification
103030>>>>>>>
103030>>>>>>>// Error number constants
103030>>>>>>>
103030>>>>>>>// Call driver function identifiers
103030>>>>>>>
103030>>>>>>>// DB2 specific data types
103030>>>>>>>Define SQL_CLOB           for   (-99)
103030>>>>>>>Define SQL_BLOB           for   (-98)
103030>>>>>>>Define SQL_XML            for   (-370)
103030>>>>>>>// DB2 Graphic types are Unicode types
103030>>>>>>>Define SQL_GRAPHIC        for   (-95)
103030>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
103030>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
103030>>>>>>>Define SQL_DBCLOB         for   (-350)
103030>>>>>>>
103030>>>>>>>
103030>>>>>>>// Extra DB2 commands
103030>>>>>>>
103030>>>>>>>
103030>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
103030>>>>>>>//   Setup a constraint for a file.                                     
103030>>>>>>>
103030>>>>>>>
103030>>>>>>>
103030>>>>>>>Class cDB2Handler is a cCLIHandler
103031>>>>>>>    
103031>>>>>>>    Procedure Construct_Object
103033>>>>>>>        Forward Send Construct_Object
103035>>>>>>>        
103035>>>>>>>        Set psDriverID to DB2_DRV_ID
103036>>>>>>>    End_Procedure
103037>>>>>>>    
103037>>>>>>>    
103037>>>>>>>    
103037>>>>>>>    // Reset the datasource list to the beginning
103037>>>>>>>    Procedure SeedDataSources
103039>>>>>>>        String  sDriver
103039>>>>>>>        String  sVoid
103039>>>>>>>        Integer iRetval
103039>>>>>>>        
103039>>>>>>>        Get psDriverID to sDriver
103040>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
103047>>>>>>>    End_Procedure
103048>>>>>>>    
103048>>>>>>>    
103048>>>>>>>    
103048>>>>>>>    // Call the driver's data sources function
103048>>>>>>>    Function DataSources Returns String
103050>>>>>>>        String  sDriver
103050>>>>>>>        String  sDataSource
103050>>>>>>>        String  sDescription
103050>>>>>>>        Integer iLength
103050>>>>>>>        Integer iRetval
103050>>>>>>>        
103050>>>>>>>        Get psDriverID to sDriver
103051>>>>>>>        If (sDriver <> "") Begin
103053>>>>>>>            Move 8192 to iLength
103054>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
103055>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
103056>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
103061>>>>>>>        End
103061>>>>>>>>
103061>>>>>>>        
103061>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
103064>>>>>>>        Else ;            Function_Return ""
103066>>>>>>>    End_Function
103067>>>>>>>    
103067>>>>>>>End_Class
103068>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
103068>>>>>>>//   Package that declares ODBC driver constants and functions.         
103068>>>>>>>//   This package can be used by developers who want to add Data Access 
103068>>>>>>>//   ODBC Client specific code to a DataFlex application.               
103068>>>>>>>
103068>>>>>>>Use Cli.pkg
103068>>>>>>>
103068>>>>>>>// Driver Indentification
103068>>>>>>>
103068>>>>>>>// Error number constants
103068>>>>>>>
103068>>>>>>>// Call driver function identifiers
103068>>>>>>>
103068>>>>>>>Class cODBCHandler is a cCLIHandler
103069>>>>>>>    
103069>>>>>>>    Procedure Construct_Object
103071>>>>>>>        Forward Send Construct_Object
103073>>>>>>>        
103073>>>>>>>        Set psDriverID to ODBC_DRV_ID
103074>>>>>>>    End_Procedure
103075>>>>>>>    
103075>>>>>>>    
103075>>>>>>>    
103075>>>>>>>    // Setup the type of data sources returned by the datasources function
103075>>>>>>>    Procedure Set DataSourceType Integer iNewType
103077>>>>>>>        String  sDriver
103077>>>>>>>        String  sVoid
103077>>>>>>>        Integer iRetval
103077>>>>>>>        
103077>>>>>>>        Get psDriverID to sDriver
103078>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
103085>>>>>>>    End_Procedure
103086>>>>>>>    
103086>>>>>>>    
103086>>>>>>>    // Call the driver's data sources function
103086>>>>>>>    Function DataSources Returns String
103088>>>>>>>        String  sDriver
103088>>>>>>>        String  sDataSource
103088>>>>>>>        String  sDescription
103088>>>>>>>        Integer iLength
103088>>>>>>>        Integer iRetval
103088>>>>>>>        
103088>>>>>>>        Get psDriverID to sDriver
103089>>>>>>>        If (sDriver <> "") Begin
103091>>>>>>>            Move 8192 to iLength
103092>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
103093>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
103094>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
103099>>>>>>>        End
103099>>>>>>>>
103099>>>>>>>        
103099>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
103102>>>>>>>        Else ;            Function_Return ""
103104>>>>>>>    End_Function
103105>>>>>>>    
103105>>>>>>>End_Class
103106>>>>>>>
103106>>>>>Use seq_chnl.pkg
103106>>>>>
103106>>>>>Register_Function phoWorkspace Returns Handle
103106>>>>>Register_Function Help_filename Returns String
103106>>>>>Register_Function GetHelpFile Returns String
103106>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
103106>>>>>
103106>>>>>// Use of Mertech drivers:
103106>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
103106>>>>>
103106>>>>>    Define ORAFLEX   for "ORA_DRV"
103106>>>>>
103106>>>>>    Define SQLFLEX   for "SQL_DRV"
103106>>>>>
103106>>>>>    Define MDSPgSQL  for "MDSPGSQL"
103106>>>>>
103106>>>>>    Define MDSMySQL  for "MDSMYSQL"
103106>>>>>
103106>>>>>// *** Constant Declarations: ***
103106>>>>>//
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>
103106>>>>>    Define DATAFLEX_ID for "DATAFLEX"
103106>>>>>
103106>>>>>// System icon menu constants. If the upper left hand
103106>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
103106>>>>>    Define SC_RESTORE  for |CI$F120
103106>>>>>    Define SC_MOVE     for |CI$F010
103106>>>>>    Define SC_SIZE     for |CI$F000
103106>>>>>    Define SC_MINIMIZE for |CI$F020
103106>>>>>    Define SC_MAXIMIZE for |CI$F030
103106>>>>>    Define SC_CLOSE    for |CI$F060
103106>>>>>    Define SC_KEYMENU  for |CI$F100
103106>>>>>    Define SC_NEXTWINDOW for |CI$F040
103106>>>>>    Define SC_PREVWINDOW for |CI$F050
103106>>>>>
103106>>>>>Define CS_SignProgram        for "signtool.exe"
103106>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
103106>>>>>Define CS_VerifyCredentials  for "verify"
103106>>>>>Define CS_VerifyFileParam    for "/a"
103106>>>>>Define CS_DefAuthVerPolicy   for "/pa"
103106>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
103106>>>>>
103106>>>>>// *** Struct Declarations: ***
103106>>>>>
103106>>>>>Struct AboutSHELLEXECUTEINFO
103106>>>>>    DWord   cbSize
103106>>>>>    Integer fMask
103106>>>>>    Handle  hwnd
103106>>>>>    Pointer lpVerb
103106>>>>>    Pointer lpFile
103106>>>>>    Pointer lpParameters
103106>>>>>    Pointer lpDirectory
103106>>>>>    Integer nShow
103106>>>>>    Pointer hInstApp
103106>>>>>    Pointer lpIDList
103106>>>>>    Pointer lpClass
103106>>>>>    Handle  hkeyClass
103106>>>>>    DWord   dwHotKey
103106>>>>>    Handle  hIconMonitor // Union
103106>>>>>    //Handle  hMonitor     // Union
103106>>>>>    Handle  hProcess
103106>>>>>End_Struct
103106>>>>>
103106>>>>>
103106>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
103106>>>>>//Type MEMORYSTATUS
103106>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
103106>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
103106>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
103106>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
103106>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
103106>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
103106>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
103106>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
103106>>>>>//End_Type
103106>>>>>
103106>>>>>// *** External Function calls: ***
103106>>>>>//
103106>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
103107>>>>>
103107>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
103108>>>>>
103108>>>>>
103108>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
103109>>>>>
103109>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
103110>>>>>
103110>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
103111>>>>>
103111>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
103112>>>>>
103112>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
103113>>>>>
103113>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
103114>>>>>
103114>>>>>// *** Global/Desktop Function Declarations: ***
103114>>>>>
103114>>>>>Function ComputerName Desktop Returns String
103116>>>>>    String sName
103116>>>>>    Get_Environment "COMPUTERNAME" to sName
103117>>>>>>
103117>>>>>    Function_Return sName
103118>>>>>End_Function
103119>>>>>
103119>>>>>Function Network_User_Name Desktop Returns String
103121>>>>>    String sName
103121>>>>>    Get_Environment "USERNAME" to sName
103122>>>>>>
103122>>>>>    Function_Return sName
103123>>>>>End_Function
103124>>>>>
103124>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
103126>>>>>    String sClient sDriver sClientDriver
103126>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
103126>>>>>    Handle hoMsqlDrv
103126>>>>>
103126>>>>>    Move 0 to iDriver
103127>>>>>    Move "" to sClient
103128>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
103131>>>>>    For iCount from 1 to iNumberOfDrivers
103137>>>>>>
103137>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
103140>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
103142>>>>>            Move iCount to iDriver
103143>>>>>            Move iNumberOfDrivers to iCount // We're done.
103144>>>>>        End
103144>>>>>>
103144>>>>>    Loop
103145>>>>>>
103145>>>>>
103145>>>>>    // This info is (at current) only available for the MS SQL driver:
103145>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
103147>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
103150>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
103151>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
103152>>>>>        Send Destroy of hoMsqlDrv
103153>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
103154>>>>>    End
103154>>>>>>
103154>>>>>
103154>>>>>    Function_Return sClient
103155>>>>>End_Function
103156>>>>>
103156>>>>>// *** Class Declarations: ***
103156>>>>>//
103156>>>>>Class cBitmapContainerDFLink is a BitmapContainer
103157>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
103159>>>>>        Send Mouse_Up iWindowNumber iPosition
103160>>>>>    End_Procedure
103161>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
103163>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
103165>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
103166>>>>>    End_Procedure
103167>>>>>End_Class
103168>>>>>
103168>>>>>Class cCopyEditorContentButton is a Button
103169>>>>>    Procedure Construct_Object
103171>>>>>        Forward Send Construct_Object
103173>>>>>        Property Handle phoEditorHandle
103174>>>>>        Set psToolTip to C_$DescCopy
103175>>>>>    End_Procedure
103176>>>>>
103176>>>>>    Procedure CopyToWindowsClipboard
103178>>>>>        Handle hoEditor
103178>>>>>        Boolean bCanCopy
103178>>>>>        Address aEditorAddress
103178>>>>>
103178>>>>>        Get phoEditorHandle to hoEditor
103179>>>>>        Send Select_All of hoEditor
103180>>>>>        Get CanCopy of hoEditor to bCanCopy
103181>>>>>        If (bCanCopy = True) Begin
103183>>>>>            Get paValue of hoEditor to aEditorAddress
103184>>>>>            Send Copy   of hoEditor
103185>>>>>            // Remove the selection after text is copied to the clipboard.
103185>>>>>            Send Beginning_of_Data of hoEditor
103186>>>>>            Send Info_Box C_$CopyToClipboard_Text
103187>>>>>        End
103187>>>>>>
103187>>>>>    End_Procedure
103188>>>>>End_Class
103189>>>>>
103189>>>>>Class SysinfoDisplay is a cTextEdit
103190>>>>>    Procedure Construct_Object
103192>>>>>        Forward Send Construct_Object
103194>>>>>
103194>>>>>        Set Size to 100 245
103195>>>>>        Set Location to 6 6
103196>>>>>        Set Border_Style to Border_None
103197>>>>>        Set Read_Only_State to True
103198>>>>>        Set pbWrap to True
103199>>>>>        Set peAnchors to anAll
103200>>>>>    End_Procedure
103201>>>>>
103201>>>>>    // Augmented class message to adjust certain text strings that are wrong...
103201>>>>>
103201>>>>>    Procedure AppendTextLn String sText
103203>>>>>        String sWorkspaceWSFile
103203>>>>>
103203>>>>>        // Only works for English:
103203>>>>>        If (ghoApplication > 0) Begin
103205>>>>>            If (sText contains "Workspace Name") Begin
103207>>>>>                Move "Workspace Config Filename:" to sText
103208>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
103209>>>>>                Move (sText * sWorkspaceWSFile) to sText
103210>>>>>            End
103210>>>>>>
103210>>>>>        End
103210>>>>>>
103210>>>>>        Send AppendText sText
103211>>>>>        Send AppendText (character(10))
103212>>>>>    End_Procedure
103213>>>>>
103213>>>>>    //    This method will show the name Of the current directory in the system
103213>>>>>    //    information box
103213>>>>>    Procedure Show_Current_Directory
103215>>>>>        String sDir
103215>>>>>
103215>>>>>        Get_Current_Directory To sDir
103216>>>>>
103216>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
103217>>>>>    End_Procedure
103218>>>>>
103218>>>>>    Procedure Show_Windows_Directory
103220>>>>>        String sWindir
103220>>>>>
103220>>>>>        Get_Windows_Directory To sWindir
103221>>>>>
103221>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
103222>>>>>    End_Procedure
103223>>>>>
103223>>>>>    Procedure Show_Current_User
103225>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
103226>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
103227>>>>>    End_Procedure
103228>>>>>
103228>>>>>    Procedure Show_Number_Format
103230>>>>>        Integer iFormat
103230>>>>>        String sFormatText
103230>>>>>
103230>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
103233>>>>>        Move (Character (iFormat)) To sFormatText
103234>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
103235>>>>>
103235>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
103238>>>>>        Move (Character (iFormat)) to sFormatText
103239>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
103240>>>>>    End_Procedure
103241>>>>>
103241>>>>>    Procedure Show_Filelist_Name
103243>>>>>        String sFilename
103243>>>>>
103243>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
103246>>>>>
103246>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
103247>>>>>    End_Procedure
103248>>>>>
103248>>>>>    Procedure Show_Lock_Delay
103250>>>>>        Integer iLockdelay
103250>>>>>
103250>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
103253>>>>>
103253>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
103254>>>>>    End_Procedure
103255>>>>>
103255>>>>>    Procedure Show_Lock_Timeout
103257>>>>>        Integer iLockTimeout
103257>>>>>
103257>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
103260>>>>>
103260>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
103261>>>>>    End_Procedure
103262>>>>>
103262>>>>>    Procedure Show_Screen_Size
103264>>>>>        Integer iYscreensize iXscreensize
103264>>>>>
103264>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
103265>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
103266>>>>>
103266>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
103267>>>>>    End_Procedure
103268>>>>>
103268>>>>>    Procedure Show_Page_Size
103270>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
103271>>>>>    End_procedure
103272>>>>>
103272>>>>>    Procedure Show_Date
103274>>>>>        Date dToday
103274>>>>>
103274>>>>>        Move (CurrentDateTime()) to dToday
103275>>>>>
103275>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
103276>>>>>    End_procedure
103277>>>>>
103277>>>>>    Procedure Show_Date_Format
103279>>>>>        Integer iDateFormat
103279>>>>>        String sDateFormat
103279>>>>>
103279>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
103282>>>>>        Case Begin
103282>>>>>            Case (iDateFormat = DF_DATE_USA)
103284>>>>>                Move C_$USA To sDateFormat
103285>>>>>                Case Break
103286>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
103289>>>>>                Move C_$European To sDateFormat
103290>>>>>                Case Break
103291>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
103294>>>>>                Move C_$Military To sDateFormat
103295>>>>>                Case Break
103296>>>>>            Case Else
103296>>>>>                Move C_$UnknownDateType To sDateFormat
103297>>>>>                Case Break
103298>>>>>        Case End
103298>>>>>
103298>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
103299>>>>>    End_Procedure
103300>>>>>
103300>>>>>    // 2013-08-14 NGS
103300>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
103300>>>>>    Procedure Show_Systemresources
103302>>>>>        tWinMemoryStatusEx MemoryStatusInfo
103302>>>>>        tWinMemoryStatusEx MemoryStatusInfo
103302>>>>>        Integer iRetval
103302>>>>>        Number nValue
103302>>>>>        String sValue
103302>>>>>
103302>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
103303>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
103304>>>>>        If (iRetval = 0) Begin
103306>>>>>            Move (ShowLastError ()) to iRetval
103307>>>>>            Procedure_Return
103308>>>>>        End
103308>>>>>>
103308>>>>>
103308>>>>>        Send AppendTextLn ""
103309>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
103310>>>>>
103310>>>>>        // Show memory in Gigabytes:
103310>>>>>        Move (nValue/1024/1024/1024) to nValue
103311>>>>>        Move (Round(nValue)) to nValue
103312>>>>>        Get FormatNumber nValue 2 to sValue
103313>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
103314>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
103315>>>>>
103315>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
103315>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
103316>>>>>        Move (Round(nValue)) to nValue
103317>>>>>        Get FormatNumber nValue 0 to sValue
103318>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
103319>>>>>
103319>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
103319>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
103320>>>>>        Move (Round(nValue)) to nValue
103321>>>>>        Get FormatNumber nValue 0 to sValue
103322>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
103323>>>>>
103323>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
103323>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
103324>>>>>        Move (Round(nValue)) to nValue
103325>>>>>        Get FormatNumber nValue 0 to sValue
103326>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
103327>>>>>
103327>>>>>        // Add an empty row after the memory information:
103327>>>>>        Send AppendTextLn ""
103328>>>>>    End_Procedure
103329>>>>>
103329>>>>>    Procedure Show_Registration
103331>>>>>        String sRegName
103331>>>>>        Integer iSN iUsersMax iUserCount
103331>>>>>
103331>>>>>        Registration sRegName iSN
103332>>>>>>
103332>>>>>        Get_Licensed_Max_Users to iUsersMax
103333>>>>>        Get_Current_User_Count to iUserCount
103334>>>>>
103334>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
103335>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
103336>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
103337>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
103338>>>>>    End_Procedure
103339>>>>>
103339>>>>>    //****************************************************************************
103339>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
103339>>>>>    // To the workspace object passing the an object and message To send back
103339>>>>>    // To this object. It is expected that the workspace object will send this
103339>>>>>    // message for every line Of information it wants displayed (passing the
103339>>>>>    // information To be displayed
103339>>>>>    //****************************************************************************
103339>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
103339>>>>>
103339>>>>>    Procedure Show_ServicePack
103341>>>>>        String sKey sVersion sDataFlex
103341>>>>>        Handle hoRegistry
103341>>>>>        Boolean bExists bOpened
103341>>>>>
103341>>>>>        Move "DataFlex"        to sDataFlex
103342>>>>>
103342>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
103343>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
103344>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
103345>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
103346>>>>>
103346>>>>>        If (bExists) Begin
103348>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
103349>>>>>        End
103349>>>>>>
103349>>>>>        Else Begin
103350>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
103351>>>>>        End
103351>>>>>>
103351>>>>>        Get KeyExists of hoRegistry sKey to bExists
103352>>>>>        If (bExists) Begin
103354>>>>>            Get OpenKey of hoRegistry sKey to bOpened
103355>>>>>            If (bOpened) Begin
103357>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
103358>>>>>                If (bExists) Begin
103360>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
103361>>>>>                End
103361>>>>>>
103361>>>>>                Send CloseKey of hoRegistry
103362>>>>>            End
103362>>>>>>
103362>>>>>        End
103362>>>>>>
103362>>>>>        Send Destroy of hoRegistry
103363>>>>>
103363>>>>>        If (sVersion <> "") Begin
103365>>>>>           Send AppendTextLn sVersion
103366>>>>>           Send AppendTextLn ""
103367>>>>>        End
103367>>>>>>
103367>>>>>    End_Procedure
103368>>>>>
103368>>>>>    Procedure Show_WorkspaceInformation
103370>>>>>        Integer hoWorkspace
103370>>>>>
103370>>>>>        If (ghoApplication <> 0) Begin
103372>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
103373>>>>>            If (hoWorkspace <> 0) Begin
103375>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
103376>>>>>            End
103376>>>>>>
103376>>>>>        End
103376>>>>>>
103376>>>>>    End_Procedure
103377>>>>>
103377>>>>>    //****************************************************************************
103377>>>>>    // If connection ids are used, we will send the message EnumerateConnections
103377>>>>>    // to the connection manager object passing the an object and message to send
103377>>>>>    // back to this object. It is expected that the connection manager object will
103377>>>>>    // send this message for every line Of information it wants displayed (passing
103377>>>>>    // the information To be displayed
103377>>>>>    //****************************************************************************
103377>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
103377>>>>>
103377>>>>>    Procedure Show_ConnectionIdInformation
103379>>>>>        If (ghoConnection > 0) Begin
103381>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
103382>>>>>            Send AppendTextLn ""
103383>>>>>        End
103383>>>>>>
103383>>>>>    End_Procedure
103384>>>>>
103384>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
103386>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
103387>>>>>    End_Function
103388>>>>>
103388>>>>>    Procedure Show_Versions
103390>>>>>        Integer iVersion iRevision iBuild
103390>>>>>
103390>>>>>        Version_information iVersion iRevision iBuild
103392>>>>>
103392>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
103393>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
103394>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
103395>>>>>        Send AppendTextLn "This is a 32-bit exe file"
103396>>>>>    End_Procedure
103397>>>>>
103397>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
103399>>>>>        Boolean bOK
103399>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
103400>>>>>        Function_Return bOK
103401>>>>>    End_Function
103402>>>>>
103402>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
103404>>>>>        Boolean bOK
103404>>>>>        Function_Return bOK
103405>>>>>    End_Function
103406>>>>>
103406>>>>>    //***
103406>>>>>    //*** BW
103406>>>>>    //*** Procedure: Show_Drivers
103406>>>>>    //*** Purpose  : Show loaded database drivers
103406>>>>>    //***
103406>>>>>
103406>>>>>    Procedure Show_Drivers
103408>>>>>        String sDriverID sVersion sClient sValue
103408>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
103408>>>>>        Handle hoCLIHandler hoBtrvHandler
103408>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
103408>>>>>
103408>>>>>        Move False to bStudioLicense
103409>>>>>
103409>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
103410>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
103411>>>>>
103411>>>>>        // For testing purposes:
103411>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
103411>>>>>//        Load_Driver MSSQLDRV_ID
103411>>>>>//        Load_Driver ODBC_DRV_ID
103411>>>>>//        Load_Driver DB2_DRV_ID
103411>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
103411>>>>>//
103411>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
103411>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
103411>>>>>//            Load_Driver SQLFLEX
103411>>>>>//            Load_Driver MDSPgSQL
103411>>>>>//            Load_Driver MDSMySQL
103411>>>>>//            Load_Driver ORAFLEX
103411>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
103411>>>>>//        #ENDIF
103411>>>>>        Move False to Err
103412>>>>>
103412>>>>>        // Loop through all loaded drivers.
103412>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
103415>>>>>        If (iNumberOfDrivers > 1) Begin
103417>>>>>            Send AppendTextLn ""
103418>>>>>        End
103418>>>>>>
103418>>>>>        For iDriver from 1 to iNumberOfDrivers
103424>>>>>>
103424>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
103424>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
103424>>>>>            // would be thrown, so we safeguard from that here.
103424>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
103425>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
103428>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
103429>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
103430>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
103431>>>>>
103431>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
103433>>>>>
103433>>>>>                // Pervasive/Btrieve database
103433>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
103435>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
103436>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
103437>>>>>                    If (sClient <> "0.0.0") Begin
103439>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
103440>>>>>                    End
103440>>>>>>
103440>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
103441>>>>>                    If (sClient <> "0.0.0") Begin
103443>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
103444>>>>>                    End
103444>>>>>>
103444>>>>>                End
103444>>>>>>
103444>>>>>
103444>>>>>                Else Begin
103445>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
103446>>>>>                    Move 0 to iNumServers
103447>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
103449>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
103452>>>>>                    End
103452>>>>>>
103452>>>>>
103452>>>>>                    If (bIsDAWDriver = True) Begin
103454>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
103456>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
103457>>>>>                        End
103457>>>>>>
103457>>>>>                        Get CKRevision of hoCLIHandler to sVersion
103458>>>>>                    End
103458>>>>>>
103458>>>>>
103458>>>>>                    If (bIsMertechDriver = True) Begin
103460>>>>>                    End
103460>>>>>>
103460>>>>>
103460>>>>>                    // If the serialnumber is = 0, it means that the
103460>>>>>                    // Studio licens is in use and there is no
103460>>>>>                    // number of max users defined because the driver is
103460>>>>>                    // relying on the info from the VDF license.
103460>>>>>                    If (bStudioLicense = False) Begin
103462>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
103463>>>>>                        Move (iSerialNo = 0) to bStudioLicense
103464>>>>>                    End
103464>>>>>>
103464>>>>>                End
103464>>>>>>
103464>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
103465>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
103467>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
103468>>>>>                End
103468>>>>>>
103468>>>>>                If (iNumServers <> 0) Begin
103470>>>>>                    For iCount from 1 to iNumServers
103476>>>>>>
103476>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
103479>>>>>                        If (not(sValue contains ";PWD=")) Begin
103481>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
103482>>>>>                        End
103482>>>>>>
103482>>>>>                    Loop
103483>>>>>>
103483>>>>>                End
103483>>>>>>
103483>>>>>            End
103483>>>>>>
103483>>>>>        Loop
103484>>>>>>
103484>>>>>
103484>>>>>        Send AppendTextLn ""
103485>>>>>        If (bStudioLicense = False) Begin
103487>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
103488>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
103489>>>>>        End
103489>>>>>>
103489>>>>>        Else Begin
103490>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
103491>>>>>        End
103491>>>>>>
103491>>>>>        Send Destroy of hoCLIHandler
103492>>>>>        Send Destroy of hoBtrvHandler
103493>>>>>    End_Procedure
103494>>>>>
103494>>>>>    Procedure Show_HelpFile
103496>>>>>        String sHelpFile
103496>>>>>        Integer eHelpType
103496>>>>>
103496>>>>>        If (ghoApplication <> 0) Begin
103498>>>>>            Get peHelpType Of ghoApplication To eHelpType
103499>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
103501>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
103502>>>>>            End
103502>>>>>>
103502>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
103505>>>>>                Get Help_filename Of Help_object_id To sHelpFile
103506>>>>>            End
103506>>>>>>
103506>>>>>            Else Begin
103507>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
103508>>>>>            End
103508>>>>>>
103508>>>>>
103508>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
103509>>>>>        End
103509>>>>>>
103509>>>>>    End_Procedure
103510>>>>>
103510>>>>>    Procedure Show_EnterAsTab
103512>>>>>        Boolean bEnterKeyAsTabKey
103512>>>>>        String sText
103512>>>>>
103512>>>>>        If (ghoApplication <> 0) Begin
103514>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
103515>>>>>            If (bEnterKeyAsTabKey) Begin
103517>>>>>                Move "True" To sText
103518>>>>>            End
103518>>>>>>
103518>>>>>            Else Begin
103519>>>>>                Move "False" To sText
103520>>>>>            End
103520>>>>>>
103520>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
103521>>>>>        End
103521>>>>>>
103521>>>>>    End_Procedure
103522>>>>>
103522>>>>>    //    During activation we will remove the old information and add the newly
103522>>>>>    //    found systeminformation
103522>>>>>    Procedure Add_Focus Integer hoRoot
103524>>>>>        Forward Send Add_Focus hoRoot
103526>>>>>
103526>>>>>        Send Delete_Data
103527>>>>>
103527>>>>>        Set Changed_State To False
103528>>>>>        Set Read_Only_State To True
103529>>>>>
103529>>>>>        Send Show_Registration
103530>>>>>        Send Show_Drivers
103531>>>>>        Send Show_ServicePack
103532>>>>>        Send Show_Versions
103533>>>>>        Send AppendTextLn ""
103534>>>>>
103534>>>>>        If (ghoApplication <> 0) Begin
103536>>>>>            Send Show_WorkSpaceInformation
103537>>>>>            Send Show_HelpFile
103538>>>>>            Send AppendTextLn ""
103539>>>>>        End
103539>>>>>>
103539>>>>>        Else Begin
103540>>>>>            Send AppendTextLn ""
103541>>>>>        End
103541>>>>>>
103541>>>>>
103541>>>>>        If (ghoConnection <> 0) Begin
103543>>>>>            Send Show_ConnectionIdInformation
103544>>>>>        End
103544>>>>>>
103544>>>>>
103544>>>>>        Send Show_Current_User
103545>>>>>        Send Show_Windows_Directory
103546>>>>>        Send Show_Current_Directory
103547>>>>>
103547>>>>>        // This is already shown in the workspace details,
103547>>>>>        // unless no workspace object is present:
103547>>>>>        If (ghoApplication = 0) Begin
103549>>>>>            Send Show_Filelist_Name
103550>>>>>        End
103550>>>>>>
103550>>>>>
103550>>>>>        If (ghoApplication <> 0) Begin
103552>>>>>            Send AppendTextLn ""
103553>>>>>            Send Show_EnterAsTab
103554>>>>>        End
103554>>>>>>
103554>>>>>
103554>>>>>        Send Show_Screen_Size
103555>>>>>        Send Show_Page_Size
103556>>>>>        Send Show_Number_Format
103557>>>>>        Send Show_Date_Format
103558>>>>>        Send Show_Lock_Delay
103559>>>>>        Send Show_Lock_Timeout
103560>>>>>        Send Show_Date
103561>>>>>        Send Show_Systemresources
103562>>>>>        Send Beginning_of_Data
103563>>>>>
103563>>>>>        Set Icon to 'default.ico'
103564>>>>>    End_Procedure
103565>>>>>End_Class
103566>>>>>
103566>>>>>Class SysInfoDialog is a ModalPanel
103567>>>>>    Procedure Construct_Object
103569>>>>>        Forward Send Construct_Object
103571>>>>>
103571>>>>>        Set Label to C_$SystemInformation
103572>>>>>        Set Size to 140 267
103573>>>>>        Set Locate_Mode to CENTER_ON_PARENT
103574>>>>>        Set Border_Style to Border_Thick
103575>>>>>        Set Sysmenu_Icon to False
103576>>>>>
103576>>>>>        // "+1" will make the panel to paint correctly.
103576>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
103577>>>>>
103577>>>>>        // 2014-09-14 NGS
103577>>>>>        // Added a container object around the cTexteditor
103577>>>>>        // object to get a border around the text.
103577>>>>>        Object oSysinfoDisplayContainer is a Container3d
103579>>>>>            Set Location to 2 4
103580>>>>>            Set Size to 110 255
103581>>>>>            Set Border_Style to Border_ClientEdge
103582>>>>>            Set Color to clWhite
103583>>>>>            Set peAnchors to anAll
103584>>>>>
103584>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
103586>>>>>            End_Object
103587>>>>>
103587>>>>>        End_Object
103588>>>>>
103588>>>>>        Object oCloseButton is a Button
103590>>>>>            Set Label to C_$Close
103591>>>>>            Set Location to 120 210
103592>>>>>            Set Message item 0 to msg_Close_Panel
103593>>>>>            Set Default_State To True
103594>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
103594>>>>>            // and changes its peAnchors, we might as well prepare this object
103594>>>>>            // for that situation.
103594>>>>>            Set peAnchors to anBottomRight
103595>>>>>        End_Object
103596>>>>>
103596>>>>>        Object oCopyButton is a cCopyEditorContentButton
103598>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
103599>>>>>            Set Size to 14 50
103600>>>>>            Set Location to 120 158
103601>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
103601>>>>>            // we might as well prepare the object for it.
103601>>>>>            Set peAnchors to anBottomRight
103602>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
103603>>>>>        End_Object
103604>>>>>
103604>>>>>        On_Key kCancel Send Close_Panel
103605>>>>>    End_Procedure
103606>>>>>
103606>>>>>    Procedure Page Integer iPageObject
103608>>>>>        Handle hMenu
103608>>>>>        Integer iPrevState
103608>>>>>
103608>>>>>        Forward Send Page iPageObject
103610>>>>>
103610>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
103610>>>>>        //
103610>>>>>    End_Procedure
103611>>>>>
103611>>>>>End_Class
103612>>>>>
103612>>>>>Class cAboutEdit is an cRichEdit
103613>>>>>    Procedure Construct_Object
103615>>>>>        Forward Send Construct_Object
103617>>>>>
103617>>>>>        Property String psContentText
103618>>>>>
103618>>>>>        Set Size to 77 153
103619>>>>>        Set Location to 8 60
103620>>>>>        Set Read_Only_State to True
103621>>>>>        Set Skip_State to True
103622>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
103622>>>>>        // or 1/20 of a printer's point.
103622>>>>>        Set piRightMargin to (0.1 * 1440)
103623>>>>>        Set Border_Style  to Border_None
103624>>>>>    End_Procedure
103625>>>>>
103625>>>>>    // Adds a line of text to the edit object
103625>>>>>    Procedure Add_Line String sText
103627>>>>>        String sContentText
103627>>>>>        Get psContentText to sContentText
103628>>>>>        Move (sContentText + String(sText)) to sContentText
103629>>>>>        Set psContentText to sContentText
103630>>>>>    End_Procedure
103631>>>>>
103631>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
103631>>>>>    // Note that we use a property psContentText and add to it,
103631>>>>>    // because the object isn't paged yet when we add these
103631>>>>>    // values and the COM edit object needs to be paged
103631>>>>>    // for the text to become visible. See Also: Procedure Page below.
103631>>>>>    Procedure Add_LineLn String sText
103633>>>>>        String sContentText sCR
103633>>>>>
103633>>>>>        Move (Character(10) + String(Character(13))) to sCR
103634>>>>>        Get psContentText to sContentText
103635>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
103636>>>>>        Set psContentText to sContentText
103637>>>>>    End_Procedure
103638>>>>>
103638>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
103640>>>>>        String sLinkText
103640>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
103641>>>>>        Send Show_HomePage sLinkText
103642>>>>>    End_Procedure
103643>>>>>
103643>>>>>    Procedure Page Integer iPageObject
103645>>>>>        String sContentText
103645>>>>>
103645>>>>>        Forward Send Page iPageObject
103647>>>>>        Get psContentText to sContentText
103648>>>>>        Send AppendText sContentText
103649>>>>>        send Beginning_of_Data
103650>>>>>    End_Procedure
103651>>>>>
103651>>>>>End_Class
103652>>>>>
103652>>>>>Class AboutDialog is a ModalPanel
103653>>>>>    Procedure Construct_Object
103655>>>>>
103655>>>>>        Forward Send Construct_Object
103657>>>>>
103657>>>>>        Set Label to C_$About
103658>>>>>        Set Size to 118 230
103659>>>>>        Set Locate_Mode to CENTER_ON_PARENT
103660>>>>>        Set Border_Style to Border_Thick
103661>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
103662>>>>>
103662>>>>>        Object oSysInfoDialog is a SysInfoDialog
103664>>>>>        End_Object
103665>>>>>
103665>>>>>        Object oBox is a Container3d
103667>>>>>            Set Border_Style to Border_Normal
103668>>>>>            Set Size to 90 220
103669>>>>>            Set Location to 4 5
103670>>>>>            Set Color to clWhite
103671>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
103671>>>>>            // we might as well prepare the object for it.
103671>>>>>            Set peAnchors to anAll
103672>>>>>
103672>>>>>            Object oAboutGraphic is a BitmapContainer
103674>>>>>                Set Border_Style To Border_None
103675>>>>>                Set Bitmap_Style to Bitmap_Center
103676>>>>>                Set Color to clWhite
103677>>>>>                Set Size to 45 50
103678>>>>>                Set Location to 0 3
103679>>>>>            End_Object
103680>>>>>
103680>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
103682>>>>>                Set Border_Style to Border_None
103683>>>>>                Set Bitmap_Style to Bitmap_Center
103684>>>>>                Set Color to clWhite
103685>>>>>                Set Size to 30 55
103686>>>>>                Set Location to 50 3
103687>>>>>            End_Object
103688>>>>>
103688>>>>>            Object oInfoList_Editor is an cAboutEdit
103690>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
103690>>>>>                // we might as well prepare the object for it.
103690>>>>>                Set peAnchors to anAll
103691>>>>>            End_Object
103692>>>>>
103692>>>>>            // These objects are here for backwards compatability only.
103692>>>>>            // They are not used.
103692>>>>>            Object oProductName is a TextBox
103694>>>>>                Set Label To C_$ProductName
103695>>>>>                Set Size To 10 45
103696>>>>>                Set Location To 8 53
103697>>>>>                Set Visible_State to False
103698>>>>>                Set Focus_Mode to NonFocusable
103699>>>>>            End_Object
103700>>>>>
103700>>>>>            Object oVersion is a TextBox
103702>>>>>                Set Label To C_$Version
103703>>>>>                Set Size To 10 25
103704>>>>>                Set Location To 21 53
103705>>>>>                Set Visible_State to False
103706>>>>>                Set Focus_Mode to NonFocusable
103707>>>>>            End_Object
103708>>>>>
103708>>>>>            Object oCopyright is a TextBox
103710>>>>>                Set Label To C_$Copyright
103711>>>>>                Set Size To 10 31
103712>>>>>                Set Location To 34 53
103713>>>>>                Set Visible_State to False
103714>>>>>                Set Focus_Mode to NonFocusable
103715>>>>>            End_Object
103716>>>>>
103716>>>>>            Object oAuthor is a TextBox
103718>>>>>                Set Label To C_$Author
103719>>>>>                Set Size To 10 22
103720>>>>>                Set Location To 46 53
103721>>>>>                Set Visible_State to False
103722>>>>>                Set Focus_Mode to NonFocusable
103723>>>>>            End_Object
103724>>>>>
103724>>>>>        End_Object
103725>>>>>
103725>>>>>        Object oOKButton is a Button
103727>>>>>            On_Item C_$Close Send Close_Panel
103728>>>>>            Set Location to 98 176
103729>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
103729>>>>>            // we might as well prepare the object for it.
103729>>>>>            Set peAnchors to anBottomRight
103730>>>>>        End_Object
103731>>>>>
103731>>>>>        Object oSysInfoButton is a Button
103733>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
103734>>>>>            Set Location to 98 123
103735>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
103735>>>>>            // we might as well prepare the object for it.
103735>>>>>            Set peAnchors to anBottomRight
103736>>>>>        End_Object
103737>>>>>
103737>>>>>        Object oCopyButton is a cCopyEditorContentButton
103739>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
103740>>>>>            Set Size to 14 50
103741>>>>>            Set Location to 98 70
103742>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
103742>>>>>            // we might as well prepare the object for it.
103742>>>>>            Set peAnchors to anBottomRight
103743>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
103744>>>>>        End_Object
103745>>>>>
103745>>>>>        On_Key Kcancel Send KeyAction of oOKButton
103746>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
103747>>>>>        Set LogoDF to "DF32.bmp"
103748>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
103748>>>>>    End_Procedure
103749>>>>>
103749>>>>>    Procedure Page Integer iPageObject
103751>>>>>        Handle hMenu
103751>>>>>        Integer iPrevState
103751>>>>>
103751>>>>>        Forward Send Page iPageObject
103753>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
103753>>>>>        Set Icon to "Default.ico"
103754>>>>>
103754>>>>>        // Shadow upper left corner menu items: (icon menu items)
103754>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
103755>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
103756>>>>>        // The "Move" menu command may come in handy to have.
103756>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
103756>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
103757>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
103758>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
103759>>>>>        // The "Close" menu command may be good to have.
103759>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
103759>>>>>    End_Procedure
103760>>>>>
103760>>>>>    Procedure Set ProductName String sText
103762>>>>>        Set Value of oProductName to sText
103763>>>>>    End_Procedure
103764>>>>>
103764>>>>>    Procedure Set Copyright String sText
103766>>>>>        Set Value of oCopyright to sText
103767>>>>>    End_Procedure
103768>>>>>
103768>>>>>    Procedure Set Author String sText
103770>>>>>        Set Value of oAuthor to sText
103771>>>>>    End_Procedure
103772>>>>>
103772>>>>>    Procedure Set Version String sVersion
103774>>>>>        Handle hoVersionInfo
103774>>>>>        Boolean bIncluded
103774>>>>>        Integer iMajor iMinor iRelease iBuild
103774>>>>>//        Date dCompileDate
103774>>>>>        String sCertInfo sCompileDateAndTime
103774>>>>>
103774>>>>>        If (sVersion = "") Begin
103776>>>>>            // This automatically shows the program version of the program, if available.
103776>>>>>            // It will be displayed as the second item in the edit object.
103776>>>>>            If (ghoApplication <> 0) Begin
103778>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
103779>>>>>                If (hoVersionInfo <> 0) Begin
103781>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
103782>>>>>                    If (bIncluded) Begin
103784>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
103785>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
103786>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
103787>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
103788>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
103789>>>>>                    End
103789>>>>>>
103789>>>>>                End
103789>>>>>>
103789>>>>>            End
103789>>>>>>
103789>>>>>        End
103789>>>>>>
103789>>>>>
103789>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
103789>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
103790>>>>>        If (sCompileDateAndTime <> "") Begin
103792>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
103793>>>>>        End
103793>>>>>>
103793>>>>>//        Get GetCompileDate to dCompileDate
103793>>>>>//        If (sVersion <> "") Begin
103793>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
103793>>>>>//        End
103793>>>>>
103793>>>>>        Get IsProgramDigitallySigned to sCertInfo
103794>>>>>        If (sCertInfo <> "-1") Begin
103796>>>>>            If (sCertInfo <> "") Begin
103798>>>>>                Send Add_LineLn sCertInfo
103799>>>>>            End
103799>>>>>>
103799>>>>>            Else Begin
103800>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
103801>>>>>            End
103801>>>>>>
103801>>>>>        End
103801>>>>>>
103801>>>>>    End_Procedure
103802>>>>>
103802>>>>>    Function IsDate String sDate Returns Boolean
103804>>>>>        Boolean bIsDate
103804>>>>>        String sGoodCharacters sChar
103804>>>>>        Integer iCount iLength
103804>>>>>
103804>>>>>        Move True to bIsDate
103805>>>>>        Move "0123456789-/" to sGoodCharacters
103806>>>>>        Move (Length(sDate)) to iLength
103807>>>>>        For iCount from 1 to iLength
103813>>>>>>
103813>>>>>            Move (Left(sDate, 1)) to sChar
103814>>>>>            Move (Mid(sDate, 12, 2)) to sDate
103815>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
103816>>>>>            If (bIsDate = False) Begin
103818>>>>>                Move iLength to iCount
103819>>>>>            End
103819>>>>>>
103819>>>>>        Loop
103820>>>>>>
103820>>>>>        Function_Return bIsDate
103821>>>>>    End_Function
103822>>>>>
103822>>>>>    Function GetCompileDate Returns Date
103824>>>>>        Date dCompileDate
103824>>>>>        String sAppFilename sProgram sData sCompileDate
103824>>>>>        Integer iChannel iPos iDateFormat iCount iSize
103824>>>>>        Boolean bIsValid   
103824>>>>>        
103824>>>>>        Move 0 to dCompileDate
103825>>>>>        // Get full path to the current running executable
103825>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
103826>>>>>        Get GetApplicationName     of ghoApplication to sProgram
103827>>>>>
103827>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
103827>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
103828>>>>>
103828>>>>>        Get_Argument_Size to iSize
103829>>>>>        Set_Argument_Size 20000000
103830>>>>>>
103830>>>>>        Read_Block channel iChannel sData 20000000   // This must be big enough to reach the compile date location
103832>>>>>        Move (Pos(sProgram, sData)) to iPos
103833>>>>>        If (iPos > 0) Begin
103835>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
103835>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
103836>>>>>
103836>>>>>            // If the current date format is non US, we need to temporary
103836>>>>>            // change the format and then move the string to the date variable.
103836>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
103839>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
103842>>>>>            Send Ignore_Error of Error_Object_Id 16 
103843>>>>>            If (Left(sCompileDate, 1) = "0") Begin
103845>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
103846>>>>>            End
103846>>>>>>
103846>>>>>            Move (Date(sCompileDate))    to dCompileDate
103847>>>>>            Send Trap_Error of Error_Object_Id 16
103848>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
103851>>>>>        End
103851>>>>>>
103851>>>>>        Else Begin
103852>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
103853>>>>>>
103853>>>>>        End
103853>>>>>>
103853>>>>>
103853>>>>>        Send Seq_Close_Channel iChannel
103854>>>>>        Set_Argument_Size iSize
103855>>>>>>
103855>>>>>
103855>>>>>        Function_Return dCompileDate
103856>>>>>    End_Function
103857>>>>>
103857>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
103857>>>>>    // (the passed program), has been finished
103857>>>>>    // The DOS box does also _not_ flash briefly.
103857>>>>>    Procedure RunProgramWait String sProgram String sParameter
103859>>>>>        Handle hProcess
103859>>>>>        Integer iVoid
103859>>>>>        AboutSHELLEXECUTEINFO sInfo
103859>>>>>        AboutSHELLEXECUTEINFO sInfo
103859>>>>>
103859>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
103860>>>>>
103860>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
103861>>>>>        Move SW_SHOW                 to sInfo.nShow
103862>>>>>
103862>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
103863>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
103864>>>>>        // This will "hide" the DOS box from showing (no flasing box):
103864>>>>>        Move 0                       to sInfo.nShow
103865>>>>>
103865>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
103866>>>>>        Move sInfo.hProcess to hProcess
103867>>>>>        If (hProcess) Begin
103869>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
103870>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
103871>>>>>        End
103871>>>>>>
103871>>>>>    End_Procedure
103872>>>>>
103872>>>>>    Function AddFolderDelimiter String sPath Returns String
103874>>>>>        String sDirSep
103874>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
103875>>>>>        Move (Trim(sPath)) to sPath
103876>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
103878>>>>>            Move (sPath + sDirSep) to sPath
103879>>>>>        End
103879>>>>>>
103879>>>>>        Function_Return sPath
103880>>>>>    End_Function
103881>>>>>
103881>>>>>    // Returns an empty string if the current program is not digitally signed,
103881>>>>>    // or there is a problem with the certificate.
103881>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
103881>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
103881>>>>>    Function IsProgramDigitallySigned Returns String
103883>>>>>        Boolean bExists
103883>>>>>        String sPath sProgram sParams sRetval
103883>>>>>        Integer iCh
103883>>>>>
103883>>>>>        Move "" to sRetval
103884>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
103885>>>>>        Get AddFolderDelimiter sPath to sPath
103886>>>>>        File_Exist (sPath + CS_SignProgram) bExists
103887>>>>>        If (bExists = False) Begin
103889>>>>>            Function_Return "-1"
103890>>>>>        End
103890>>>>>>
103890>>>>>
103890>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
103891>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
103892>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
103893>>>>>        Move (sParams * String("| clip"))    to sParams
103894>>>>>        Get Seq_New_Channel to iCh
103895>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
103897>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
103900>>>>>        Close_Output channel iCh
103902>>>>>        // New ShellExecute based message that waits for the passed process to end.
103902>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
103903>>>>>        Direct_Input channel iCh "CLIPBOARD:"
103905>>>>>            Readln channel iCh sRetval
103907>>>>>            Readln channel iCh sRetval
103909>>>>>            Readln channel iCh sRetval
103911>>>>>            Readln channel iCh sRetval
103913>>>>>        Close_Input channel iCh
103915>>>>>        Send Seq_Release_Channel iCh
103916>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
103918>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
103919>>>>>        End
103919>>>>>>
103919>>>>>        Else Begin
103920>>>>>            Move "" to sRetval
103921>>>>>        End
103921>>>>>>
103921>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
103921>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
103922>>>>>>
103922>>>>>        Function_Return sRetval
103923>>>>>    End_Function
103924>>>>>
103924>>>>>    Procedure Add_LineLn String sValue
103926>>>>>        Send Add_LineLn of oInfoList_Editor sValue
103927>>>>>    End_Procedure
103928>>>>>
103928>>>>>    Procedure Add_Line String sValue
103930>>>>>        Send Add_Line of oInfoList_Editor sValue
103931>>>>>    End_Procedure
103932>>>>>
103932>>>>>    Procedure Set Logo string sLogo
103934>>>>>        // Square bitmaps of 80x80 work best
103934>>>>>        Set Bitmap of oAboutGraphic to sLogo
103935>>>>>    End_Procedure
103936>>>>>
103936>>>>>    Procedure Set LogoDF String sLogo
103938>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
103939>>>>>    End_Procedure
103940>>>>>
103940>>>>>    Procedure Show_Sysinfo
103942>>>>>        Send Popup_Modal of oSysinfoDialog
103943>>>>>    End_Procedure
103944>>>>>
103944>>>>>    Procedure Show_HomePage String sWebpage
103946>>>>>        Handle hWnd
103946>>>>>        Get Window_Handle to hWnd
103947>>>>>        Runprogram Shell Background (Trim(sWebpage))
103948>>>>>    End_Procedure
103949>>>>>
103949>>>>>End_Class
103950>>>
103950>>>// *************************************************************************
103950>>>//  Public message. This is the default message. It is expected that you will
103950>>>//   create your own message to override this
103950>>>// *************************************************************************
103950>>>
103950>>>Procedure Activate_About
103953>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
103954>>>End_Procedure
103955>>>
103955>>>// *************************************************************************
103955>>>//  Public message. It is expected that you will send this message (most
103955>>>//  likely from Activate_About. This creates an about object, activates it
103955>>>//  and destroys it when done. It is not exepected that you will augment this.
103955>>>// *************************************************************************
103955>>>// Sample usage:
103955>>>//   The first two params will automatically be filled from the application settings if not provided.
103955>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
103955>>>
103955>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
103958>>>    Integer hoObj hoMain iArgs
103958>>>    String sValue
103958>>>
103958>>>    // Create object
103958>>>    Object About is an AboutDialog
103960>>>    // Uncomment these two lines if you would like to have a resizable About object.
103960>>>    //            Set Border_Style to Border_Thick
103960>>>    //            Set peAnchors to anAll
103960>>>
103960>>>    // Add checking for the number of arguments passed to avoid runtime errors
103960>>>    // if one of them is not passed. This makes the interface
103960>>>    // more flexible.
103960>>>        Move num_arguments to iArgs
103961>>>
103961>>>        // If no title is passed use the label of the main panel (if a main panel exists).
103961>>>        If (iArgs > 0 and sTitle = "") Begin
103963>>>            Get Main_Window of Desktop to hoMain
103964>>>            If hoMain Begin
103966>>>                Get Label of hoMain to sValue
103967>>>            End
103967>>>>
103967>>>        End
103967>>>>
103967>>>        Else If (iArgs > 0 and sTitle <> "") Begin
103970>>>            Move sTitle to sValue
103971>>>        End
103971>>>>
103971>>>        Else If (iArgs = 0) Begin
103974>>>            Get Main_Window of Desktop to hoMain
103975>>>            If hoMain Begin
103977>>>                Get Label of hoMain to sValue
103978>>>            End
103978>>>>
103978>>>        End
103978>>>>
103978>>>
103978>>>        If (sValue <> "") Begin
103980>>>            Send Add_LineLn sValue
103981>>>        End
103981>>>>
103981>>>        Move "" to sValue
103982>>>
103982>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
103982>>>        // For this to work the Project Properties Version must have been set in the Studio.
103982>>>        If (iArgs < 2) Begin
103984>>>            Move "" to sValue
103985>>>        End
103985>>>>
103985>>>        Else Begin
103986>>>            Move sVersion to sValue
103987>>>        End
103987>>>>
103987>>>        Set Version to sValue
103988>>>
103988>>>        If (iArgs > 2 and sCopyRight <> "") Begin
103990>>>            Send Add_LineLn sCopyRight
103991>>>        End
103991>>>>
103991>>>
103991>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
103991>>>        // else we do.
103991>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
103993>>>            Send Add_Line sAuthor
103994>>>        End
103994>>>>
103994>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
103997>>>            Send Add_LineLn sAuthor
103998>>>        End
103998>>>>
103998>>>
103998>>>        // Square bitmaps of 80x80 works best
103998>>>        If (iArgs > 4 and sBitmap <> "") Begin
104000>>>            Set Logo to sBitMap
104001>>>        End
104001>>>>
104001>>>
104001>>>        // Here starts handling of the five optional params:
104001>>>        If (iArgs = 6 and sParam6  <> "") Begin
104003>>>            Send Add_Line sParam6
104004>>>        End
104004>>>>
104004>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
104007>>>            Send Add_LineLn sParam6
104008>>>        End
104008>>>>
104008>>>
104008>>>        If (iArgs = 7 and sParam7  <> "") Begin
104010>>>            Send Add_Line sParam7
104011>>>        End
104011>>>>
104011>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
104014>>>            Send Add_LineLn sParam7
104015>>>        End
104015>>>>
104015>>>
104015>>>        If (iArgs = 8 and sParam8  <> "") Begin
104017>>>            Send Add_Line sParam8
104018>>>        End
104018>>>>
104018>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
104021>>>            Send Add_LineLn sParam8
104022>>>        End
104022>>>>
104022>>>
104022>>>        If (iArgs = 9 and sParam9  <> "") Begin
104024>>>            Send Add_Line sParam9
104025>>>        End
104025>>>>
104025>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
104028>>>            Send Add_LineLn sParam9
104029>>>        End
104029>>>>
104029>>>
104029>>>        If (iArgs = 10 and sParam10 <> "") Begin
104031>>>            Send Add_Line sParam10
104032>>>        End
104032>>>>
104032>>>
104032>>>        Move Self to hoObj
104033>>>    End_Object
104034>>>
104034>>>    Send Popup   of hoObj // Popup the about object
104035>>>    Send Destroy of hoObj // When done, it will be destroyed
104036>>>End_Procedure
104037>
104037>        Procedure Activate_About
104040>            Send DoAbout "" "" "" ;            "Authors: Nils Svedmyr, Wil van Antwerpen, Sean Bamforth, Allan Kim Eriksen, Chris Spencer, Bob Worsley and Marcia Booth" ;            "DFRefactor72x72.bmp" "http://www.rdctools.com" "http://vdf-guidance.com"
104041>        End_Procedure
104042>
104042>        // We doesn't  allow closing of a view - it just doesn't make
104042>        // sense with a tabbed interface.
104042>        Function Exit_Loss_Confirmation For cUIObject Returns Integer
104044>            Function_Return 1
104045>        End_Function
104046>
104046>        Function Verify_Exit_Application Returns Integer
104049>            Integer iFail
104049>            Boolean bChanged
104049>
104049>            Broadcast Recursive Get pbShouldSave to bChanged
104051>            If (bChanged = True) Begin
104053>                Get YesNoCancel_Box "Changes exists! Do you want to save changes?" "" MB_DEFBUTTON3 to iFail
104054>                If (iFail = MBR_Yes) Begin
104056>                    Send Execute of (oSave_ToolItem(ghoCommandBars))
104057>                    Move 0 to iFail
104058>                End
104058>                If (iFail = MBR_No) Begin
104060>                    Move 0 to iFail
104061>                End
104061>                If (iFail = MBR_Cancel) Begin
104063>                    Move 1 to iFail
104064>                End
104064>            End
104064>            Function_Return iFail
104065>        End_Function
104066>
104066>    End_Object
104067>
104067>    Procedure ActivateWorkspaceDialog
104070>        Send Execute of (oWorkspaceOpen_Menuitem(ghoCommandBars))
104071>    End_Procedure
104072>
104072>    Procedure ActivateFileRadioButton
104075>        Send Execute of (oFileRadioMenuItem(ghoCommandBars))
104076>    End_Procedure
104077>
104077>    Procedure ActivateCompare
104080>        Send Execute of (oCompare_MenuItem(ghoCommandBars))
104081>    End_Procedure
104082>
104082>    Procedure ActivateBrowseDialog
104085>        Send Execute of (oOpenFolderMenuItem(ghoCommandBars))
104086>    End_Procedure
104087>
104087>    Procedure ActivateProcess
104090>        Send KeyAction of (oExecute_btn(oRefactorView(client_id(phoMainPanel(ghoApplication)))))
104091>    End_Procedure
104092>
104092>    Procedure ActivateSave
104095>        Send Execute of (oSave_ToolItem(ghoCommandBars))
104096>    End_Procedure
104097>
104097>    Procedure ActivateClear
104100>        Send Execute of (oResetSourceFile_MenuItem(ghoCommandBars))
104101>    End_Procedure
104102>
104102>    Procedure ActivateClearAll
104105>        Send Execute of (oResetWorkspace_MenuItem(ghoCommandBars))
104106>    End_Procedure
104107>
104107>    Procedure ActivateSourceExplorer
104110>        Send Execute of (oCodeExplorer_ToolbarButton(ghoCommandBars))
104111>    End_Procedure
104112>
104112>    Procedure ActivateSettings
104115>        Send Execute of (oSettings_Toolbarbutton(ghoCommandBars))
104116>    End_Procedure
104117>
104117>    Procedure ActivateEditorSettings
104120>        Send Execute of (oScintillaEditorSettings_Mentuitem(ghoCommandBars))
104121>    End_Procedure
104122>
104122>    Procedure ActivateHistoryDialog
104125>        Send Execute of (oRemoveWorkspaceHistory_Menuitem(ghoCommandBars))
104126>    End_Procedure
104127>
104127>    Procedure ActivateLogFile
104130>        Send Execute of (oOpenLogFile_MenuItem(ghoCommandBars))
104131>    End_Procedure
104132>
104132>    Procedure ActivateUnusedSourceFiles
104135>        Send Execute of (oUnusedSourceFiles_MenuItem(ghoCommandBars))
104136>    End_Procedure
104137>
104137>    Procedure ActivateUndoRefactoringDialog
104140>        Send Execute of (oUndoRefactoring_MenuItem(ghoCommandBars))
104141>    End_Procedure
104142>
104142>    Procedure ActivateShapshot
104145>        //        Send TakeSnapshot False
104145>    End_Procedure
104146>
104146>    Procedure Switch_Prior_View
104149>        Send Switch_Prior_View of (ClientAreaObject (ghoCommandBars))
104150>    End_Procedure
104151>
104151>    Procedure Switch_Next_View
104154>        Send Switch_Next_View of (ClientAreaObject (ghoCommandBars))
104155>    End_Procedure
104156>
104156>    Procedure ToggleActionButton
104159>        Integer iActiveView
104159>        Handle  hoView
104159>        Get piActiveView of ghoApplication to iActiveView
104160>        If (iActiveView = CI_CleanupSource) Begin
104162>            Get phoActiveView of ghoApplication to hoView
104163>            Send ToggleActionButton of hoView
104164>        End
104164>    End_Procedure 
104165>    
104165>    On_Key Key_Alt+Key_D   Send ActivateEditorSettings
104166>    On_Key Key_Ctrl+Key_D  Send ActivateEditorSettings
104167>    On_Key Key_Ctrl+Key_E  Send ActivateSourceExplorer
104168>    On_Key Key_Alt+Key_E   Send ActivateSourceExplorer
104169>    On_Key Key_Ctrl+Key_F  Send ActivateFileRadioButton
104170>    On_Key Key_Alt+Key_F   Send ActivateFileRadioButton
104171>    On_Key Key_Alt+Key_G   Send ToggleActionButton
104172>    On_Key Key_Ctrl+Key_G  Send ToggleActionButton
104173>    On_Key Key_Alt+Key_H   Send ActivateHistoryDialog
104174>    On_Key Key_Alt+Key_I   Send ActivateUnusedSourceFiles
104175>    On_Key Key_Alt+Key_L   Send ActivateLogFile
104176>    On_Key Key_Ctrl+Key_M  Send ActivateCompare
104177>    On_Key Key_Alt+Key_M   Send ActivateCompare
104178>    On_Key Key_Ctrl+Key_N  Send ActivateClear
104179>    On_Key Key_Alt+Key_N   Send ActivateClear
104180>    On_Key Key_Ctrl+Key_O  Send ActivateBrowseDialog
104181>    On_Key Key_Alt+Key_O   Send ActivateBrowseDialog
104182>    On_Key Key_Ctrl+Key_P  Send ActivateProcess
104183>    On_Key Key_Alt+Key_P   Send ActivateProcess
104184>    On_Key Key_Ctrl+Key_R  Send ActivateProcess
104185>    On_Key Key_Alt+Key_R   Send ActivateProcess
104186>    On_Key Key_Ctrl+Key_S  Send ActivateSave
104187>    On_Key Key_Alt+Key_S   Send ActivateSave
104188>    On_Key Key_Ctrl+Key_T  Send ActivateSettings
104189>    On_Key Key_Alt+Key_T   Send ActivateSettings
104190>    On_Key Key_Alt+Key_U   Send ActivateUndoRefactoringDialog
104191>    On_Key Key_Ctrl+Key_W  Send ActivateWorkspaceDialog
104192>    On_Key Key_Alt+Key_W   Send ActivateWorkspaceDialog
104193>    On_Key Key_Alt+Key_X   Send Exit_Application
104194>    On_Key Key_F2          Send ActivateSave
104195>    On_Key Key_Ctrl+Key_F4 Send ActivateBrowseDialog
104196>    On_Key Key_F5          Send ActivateClear
104197>    On_Key Key_F10         Send ActivateShapshot
104198>    On_Key Key_Ctrl+Key_F5 Send ActivateClearAll
104199>
104199>    // On_Key constant for Ctrl+Shift+Tab
104199>
104199>    On_Key C_CtrlShiftTab   Send Switch_Prior_View
104200>    On_Key Key_Ctrl+Key_Tab Send Switch_Next_View  
104201>End_Object
104202>
104202>Procedure OnStartup
104204>    String sSWSFile
104204>//    String sCompileTime
104204>//
104204>//    Direct_Input "resource: res_CompileHeader"
104204>//    Readln sCompileTime
104204>//    Close_Input
104204>//
104204>    Get psSWSFile of ghoApplication to sSWSFile
104205>    If (sSWSFile <> "") Begin
104207>        Send DisplayWorkspaceItem of (oWorkspaceSelector_Menuitem(ghoCommandBars)) sSWSFile
104208>    End
104208>    Send Activate_oRefactorView of (ClientAreaObject(ghoCommandBars))
104209>End_Procedure      
104210>Send OnStartup
104211>
104211>Start_UI
104212>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 57550
Total Resources: 1
Total Commands : 104211
Total Windows  : 0
Total Pages    : 0
Static Data    : 797717
Message area   : 695517
Total Blocks   : 37936
