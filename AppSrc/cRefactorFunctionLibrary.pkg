Use UI
Use RefactorFunctionConstants.inc
Use cScintillaRefactorEditor.pkg
Use cRemoveUnusedLocals.pkg
Use cUnusedSourceFiles.pkg
Use cDDOReStyler.pkg

Register_Function phoEditor Returns Handle 
Register_Function phoRemoveUnusedLocals Returns Handle
Register_Function phoReportUnusedSourceFiles Returns Handle

#IFNDEF ghoRefactorFunctionLibrary
Global_Variable Handle ghoRefactorFunctionLibrary
#ENDIF

#IFNDEF ghoStatusLog
Global_Variable Handle ghoStatusLog
#ENDIF

Use cSysFileDataDictionary.dd  
Open FunctionsA

Class cRefactorFunctionLibrary is a cObject
    
    Procedure Construct_Object
        String[] asLocalVariableTypes asLocalVariableArrayTypes

        Forward Send Construct_Object
        Move Self to ghoRefactorFunctionLibrary

        Property Handle phoEditor
        Property Integer peNewStyle eDDUnknown

        Property tRefactorSettings pRefactorSettings
        //
        Property Boolean pbToggleState True     
        Property Boolean pbInRepeatLoop False
        
        Property String[] paCommands
        Property String[] paCommandFunctions    
        Property String[] pasLocalVariableTypes
        Property String[] pasLocalVariableArrayTypes

        Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
        Set pasLocalVariableTypes to asLocalVariableTypes
        Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes

        // Properties for the RemovePRoejctObjectStructure function:
        Property Boolean pbProjectObjectStructureStart False 
        Property Boolean pbProjectObjectStructureEnd False
        Property Boolean pbRegisterAllObjectsStart False    
        Property Boolean pbRegisterAllObjectsEnd False
        Property String[] pasObjectNames

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        Send AddAllCommands  
        Send AddAllCommandFunctions
    End_Procedure
    
    // *** External function package(s) must be included here. ***
    // Use this for your own special functions package.  
// Define CS_Use_MyPackage for "UseMyPackage"
    #IFDEF CS_Use_MyPackage
        #Include MyRefactorFunctions.pkg
    #ENDIF
//    #IFNDEF CS_Use_Asolvi
//        // Dummy function (Asolvi)
//        Function ChangewsDoTranslateTo_ String ByRef sLine Returns Boolean
//            Function_Return False
//        End_Function
//    #ENDIF
//
    // ToDo: *** LINE-BY-LINE FUNCTIONS ***
    // Replaces "Current_Object" to "Self"   
    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
        String sText sStart sStop
        Boolean bFound
        Integer iPos
        
        Move sLine to sText
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(sText)) to sText
        Move (Pos(lowercase(CS_Current_Object), sText)) to iPos
        If (iPos = 0) Begin
            Function_Return False
        End                      
        Move (Left(sLine, (iPos -1))) to sStart
        Move (Mid(sLine, Length(sLine), (iPos + Length(CS_Current_Object)))) to sStop
        Move (sStart + CS_Self + String(sStop)) to sLine 
        
        // Note! Recursively calls the same function if there are more than one "current_object" in the code line.
        Move (Lowercase(sLine)) to sText
        Move (Pos(lowercase(CS_Current_Object), sText)) to iPos
        If (iPos <> 0) Begin                             
            Move sLine to sText
            Get ChangeCurrent_ObjectToSelf (&sLine) to sText
        End                      
        
        Function_Return True    
    End_Function

    // Changes; [Found] Loop --> Loop
    Function ChangeFoundLoopIndicator String ByRef sLine String sParameter Returns Boolean
        tCodeComponents LineComponents 
        tBooleanIndicator BooleanIndicator
        String sText                  
        Boolean bIsLoopStatement bIsRepeatStatement bFound
        Integer iFoundIndicator iPosLoop
        
        Get IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get IsLoopStatement sLine to bIsLoopStatement  
        If (bIsLoopStatement = False) Begin
            Function_Return False
        End
        
        Get IsRepeatStatement sLine to bIsRepeatStatement
        Get Tokenizer sLine to LineComponents
        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
        If (bIsRepeatStatement = True) Begin
            // We save the start of a Repeat/Loop in a class property, which gets set to False when a Loop statement is found.
            If (BooleanIndicator.bHasBracket = False) Begin
                Set pbInRepeatLoop to True
                Function_Return False
            End    
        End
        
        // If no indicator e.g. "[Found]" before the Loop command, we're done.
        If (BooleanIndicator.bHasBracket = False) Begin
            Set pbInRepeatLoop to False
            Function_Return False
        End        
        
        If (pbInRepeatLoop(Self) = True) Begin
            Move CS_Until to BooleanIndicator.sCode
            Move (String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression)) to LineComponents.sCode
        End 
        Else Begin
            Move CS_Loop to LineComponents.sCode
        End
        Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * String(LineComponents.sToStatement) + String(LineComponents.sRightComment))) to sLine
        Set pbInRepeatLoop to False
        
        Function_Return True
    End_Function

    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
        String sText sIndicator sCommand sEndString
        Boolean bFound
        Integer iPos 
        
        Move sLine to sText
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Move (Lowercase(sText)) to sText
        While (bFound = True)
            Move (Pos(Lowercase(CS_DfTrue), sText)) to iPos
            If (iPos > 0) Begin
                Move (Overstrike("||", sText, iPos)) to sText
                Move (Overstrike("||", sLine, iPos)) to sLine
            End
            Move (iPos > 0) to bFound
            Move (Pos(Lowercase(CS_DfFalse), sText)) to iPos
            If (iPos > 0) Begin
                Move (Overstrike("||", sText, iPos)) to sText
                Move (Overstrike("||", sLine, iPos)) to sLine
            End
            If (bFound = False) Begin
                Move (iPos > 0) to bFound
            End
        Loop              

        Move (Replaces("||", sLine, "")) to sLine
        Function_Return True
    End_Function  
    
    // Changes [Found] Reread (and other commnds _except Loop, While, [Select], and If & Begin
    //     to: If (Found) command
    Function ChangeFoundAndFindErrIndicators String ByRef sLine String sParameter Returns Boolean
        String sText sIndicator sCommand sEndString
        Boolean bChanged bFound
        Integer iPos 
        tCodeComponents LineComponents 
        tBooleanIndicator BooleanIndicator
        
        Move sLine to sText
        Get IsFoundOrFindErrIndicator sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Get Tokenizer sLine to LineComponents
        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
        Move (Lowercase(BooleanIndicator.sExpression) contains Lowercase(CS_Found)) to bFound
        // [Finderr]
        If (bFound = False) Begin
            Move ("(" + String(CS_Found) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression
        End
        
        Move (Pos(" ", LineComponents.sCode)) to iPos
        Move (Mid(LineComponents.sCode, Length(LineComponents.sCode), (iPos + 1))) to LineComponents.sCode
        // Must check that it isn't a "Repeat" or "While" or "Loop" command 
   
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Repeat)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Loop)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_While)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Select)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        Move "" to sEndString
        If (LineComponents.sOfStatement <> "") Begin
            Move (" " + String(LineComponents.sOfStatement)) to sEndString
        End
        If (LineComponents.sToStatement <> "") Begin
            Move (sEndString * String(LineComponents.sToStatement)) to sEndString
        End
        If (LineComponents.sRightComment <> "") Begin
            Move (sEndString * LineComponents.sRightComment) to sEndString
        End 
        
        Move (String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to LineComponents.sCode
        Move (LineComponents.sIndentation + String(CS_If) * String(LineComponents.sCode) * String(sEndString)) to sLine
        Function_Return True
    End_Function 
    
    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
    // For the function to do anything, the line needs to contain a "GetAddress" command.
    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sText sToVar sOfVar sCommand
        Integer iPos  
        tCodeComponents CodeComponents

        Move sLine to sText

        // Skip line if it is a comment or blank
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon
        Get IsLineEndSemiColon sText to bFound    
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RetrieveFirstWord sText to sCommand
        If (Lowercase(sCommand) = Lowercase(CS_Function)) Begin
            Function_Return False
        End
        
        Get Tokenizer sLine to CodeComponents
        Get IsKeywordInLine (CS_GetAddress + "|") CodeComponents.sCode to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        If (CodeComponents.sRightComment <> "") Begin
            Move (CodeComponents.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + CodeComponents.sOfStatement + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
        End 
        Else Begin
            Move (CodeComponents.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + CodeComponents.sOfStatement + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
        End
        
        Function_Return True
    End_Function

    // Changes e.g. "Indicate indicator as True" --> "Move (True) to indicator"
    //              "[Select] Indicate Select as Windowindex Eq Fieldindex"
    Function ChangeIndicateFoundToMoveTrueToFound String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis
        String sText sVariable sExpression sIndicate sChar
        Integer iPos                      
        tCodeComponents CodeComponents
        
        Move False to bChanged
        Move (Lowercase(sLine)) to sText
        Get IsCommentLineOrBlank sText to bIsCommentLineOrBlank
        If (bIsCommentLineOrBlank = True) Begin
            Function_Return False
        End
        
        Move (Ltrim(Lowercase(sText))) to sText
        Move (Pos(Lowercase(CS_Indicate + " "), sText)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End
        Get Tokenizer sLine to CodeComponents
        Move (Pos(" ", CodeComponents.sCode)) to iPos
        Move (Left(CodeComponents.sCode, (iPos -1))) to sIndicate
        If ((Lowercase(sIndicate) + " ") <> (Lowercase(CS_Indicate) + " ")) Begin
            Function_Return False
        End                      
        
        Move (Pos(" ", CodeComponents.sCode)) to iPos // Indicate (a < b) as False
        Move (Left(CodeComponents.sCode, (iPos -1))) to sText //   (a < b) as False
        Move (Replace(sText, CodeComponents.sCode, "")) to CodeComponents.sCode
        Move (Trim(CodeComponents.sCode)) to CodeComponents.sCode
        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(CodeComponents.sCode))) to iPos 
        Move (Left(CodeComponents.sCode, (iPos -1))) to sExpression // (a < b)
        Move (Replace(sExpression, CodeComponents.sCode, "")) to CodeComponents.sCode //  as False
        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(CodeComponents.sCode))) to iPos         
        Move (Mid(CodeComponents.sCode, Length(CodeComponents.sCode), (iPos + Length(CS_As) + 2))) to sVariable
        Move (Left(sVariable, 1)) to sChar
        Move (sChar = "(") to bIsParanthesis
        If (bIsParanthesis = False) Begin
            Move (CodeComponents.sIndentation + CS_Move * "(" + String(sVariable) + ")" * CS_To * String(sExpression) + CodeComponents.sRightComment) to sLine
        End 
        Else Begin
            Move (CodeComponents.sIndentation + CS_Move * String(sVariable) * CS_To * String(sExpression) + CodeComponents.sRightComment) to sLine
        End
                                                            
        Function_Return bChanged
    End_Function 

    // [Select] Indicate Select as Windowindex Eq Fieldindex --> If (Select) Move (Windowindex = Fieldindex) to Select // Comment
    Function ChangeIndicatorToMoveStateToVariable String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis bStartIndicator bFound bIsIfStatement
        String sText sVariable sExpression sIndicator sChar sOrgLine sIfStatement sCommand
        Integer iPos iStart iEnd
        tCodeComponents Components 
        tBooleanIndicator BooleanIndicator
        
        Move False to bChanged
        Move sLine to sText                                        
        Move sLine to sOrgLine
        Get IsCommentLineOrBlank sText to bIsCommentLineOrBlank
        If (bIsCommentLineOrBlank = True) Begin
            Function_Return False
        End              
        Move (Trim(sText)) to sChar
        If (Left(sChar, 1) = "#") Begin
            Function_Return False
        End
        // While, Repeat, Loop and Until are delt with by other functions.
        Get IsWhileStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsRepeatStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsLoopStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsUntilStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RetrieveFirstWord sLine to sIfStatement
        Move (Lowercase(sIfStatement) = Lowercase(CS_If)) to bIsIfStatement
        If (bIsIfStatement = True) Begin
            Move "" to sIfStatement
        End

        Get Tokenizer sText to Components
        Get _ExtractIndicatorContent Components.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False and Components.bHasIndicateCommand = False) Begin
            Function_Return False
        End                                 
        
        // There are other function dealing with loop, while & move statements.
        Get IsRepeatStatement BooleanIndicator.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsWhileStatement BooleanIndicator.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsMoveCommand BooleanIndicator.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End           
        If (BooleanIndicator.sCode = "") Begin
            Move Components.sCode to BooleanIndicator.sCode
        End
        
        If (Lowercase(BooleanIndicator.sCode) contains Lowercase(CS_Indicate)) Begin
            Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iEnd
            If (iEnd <> 0) Begin
                Move (Pos(Lowercase(CS_Indicate + " "), Lowercase(BooleanIndicator.sCode))) to iStart
                Move (Left(BooleanIndicator.sCode, (iStart + Length(CS_Indicate)))) to sText
                Move (Replace(sText, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
                Move (Pos(Lowercase(CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
                Move (Left(BooleanIndicator.sCode, (iPos - 1))) to sIndicator
                Move (Replace(sIndicator, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
                Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
                Move (Mid(BooleanIndicator.sCode, Length(BooleanIndicator.sCode), (iPos + 1 + Length(CS_As)))) to BooleanIndicator.sCode
                Move (Trim(sIndicator)) to sIndicator
                Move (String(CS_Move) * Trim(BooleanIndicator.sCode) * CS_To * String(sIndicator)) to BooleanIndicator.sCode
                Get IsLegacyOperators BooleanIndicator.sCode to bFound
                If (bFound = True) Begin            
                    Move BooleanIndicator.sExpression to sText
                    Get _AddExpressionParenthesis (&sText) to bFound  
                    If (bFound = True) Begin
                        Move sText to BooleanIndicator.sExpression
                    End
                End
            End
        End
        
        If (bIsIfStatement = True) Begin
            Get _RetrieveFirstWord Components.sCode to sCommand
            If (Lowercase(sCommand) = Lowercase(CS_If)) Begin
                Move (String(Components.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
            Else Begin
                Move (String(Components.sIndentation) + String(CS_If) * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
        End 
        Else If (BooleanIndicator.sExpression <> "" or BooleanIndicator.sCode <> "") Begin
            If (Left(BooleanIndicator.sExpression, 1) = "(") Begin  
                If (Components.sLineStartIndicator <> "") Begin
                    If (Left(Components.sLineStartIndicator, 1) <> "(") Begin
                        Move ("(" + String(Components.sLineStartIndicator) + ")") to Components.sLineStartIndicator
                    End
                    Move (CS_If * String(Components.sLineStartIndicator)) to sLine 
                    Move BooleanIndicator.sCode to sText
                    Get _AddExpressionParenthesis (&sText) to bFound  // XXXX
                    If (bFound = True) Begin
                        Move sText to BooleanIndicator.sCode
                    End
                    Move (String(sLine) * String(BooleanIndicator.sCode)) to BooleanIndicator.sCode
                    Move "" to BooleanIndicator.sExpression
                End
                Else Begin
                    Move (CS_If * String(BooleanIndicator.sExpression)) to sLine
                    Move (String(Components.sIndentation) + String(sLine) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
                End
            End
            If (BooleanIndicator.sExpression <> "") Begin   
                Move (String(Components.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
            Else Begin
                Move (String(Components.sIndentation) + String(BooleanIndicator.sCode)) to sLine
            End
        End
            
        If (Components.sOfStatement <> "") Begin
            Move (String(sLine) * CS_Of * String(Components.sOfStatement)) to sLine
        End
        If (Components.sToStatement <> "") Begin
            Move (String(sLine) * CS_To * String(Components.sToStatement)) to sLine
        End                                                                
        If (Components.sRightComment <> "") Begin
            Move (String(sLine) * String(Components.sRightComment)) to sLine
        End
        Function_Return (sLine <> sOrgLine)
    End_Function 
    
    // Changes; [Found] Repeat --> While (Found)
    //          [not Seqeof] Repeat --> While (not(Seqeof))
    Function ChangeIndicatorRepeatToWhile String ByRef sLine String sParameter Returns Boolean
        tCodeComponents LineComponents 
        tBooleanIndicator BooleanIndicator
        String sChar sText sBoolean sNot sOrgLine
        Boolean bIsRepeatStatement bFound
        Integer iPosIndicator iPosRepeat iPos
        
        Move sLine to sText                      
        Move sLine to sOrgLine
        Get IsRepeatStatement sText to bIsRepeatStatement
        If (bIsRepeatStatement = False) Begin
            Function_Return False
        End                      
        
        Get Tokenizer sLine to LineComponents  
        Get IsKeywordInLine (CS_Repeat + "|") LineComponents.sCode to bFound
        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False) Begin
            Function_Return False
        End        

        Move (CS_While * BooleanIndicator.sExpression) to LineComponents.sCode
        Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * String(LineComponents.sToStatement) + String(LineComponents.sRightComment))) to sLine
        
        Function_Return (sLine <> sOrgLine)
    End_Function
    
    // Changes; E.g. [Found] Begin --> If (Found) Begin  
    //               [not Seqeof] Begin --> If (not(Seqeof)) Begin
    Function ChangeIndicatorToIfBegin String ByRef sLine String sParameter Returns Boolean
        tCodeComponents LineComponents   
        tBooleanIndicator BooleanIndicator
        String sText sNot sLogical
        Boolean bFound bBegin
        Integer iFoundIndicator iPosBegin iPos
        
        Move sLine to sText
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        Get IsBeginStatement sText to bBegin
        If (bBegin = False) Begin
            Function_Return False
        End                      
        
        Get Tokenizer sLine to LineComponents
        
        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False) Begin
            Function_Return False
        End
        Move (CS_If * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to LineComponents.sCode 
        If (bBegin = True) Begin
            Move (LineComponents.sIndentation + String(LineComponents.sCode) * String(LineComponents.sRightComment)) to sLine
        End
        Else Begin
            Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * CS_To + String(LineComponents.sToStatement) * String(LineComponents.sRightComment))) to sLine
        End
        
        Function_Return True
    End_Function     
    
    // Changes: Insert "," In sText At 2 --> Move (Inert(",", sText, 2)) to sText
    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentOrBlank bIsReplace
        String sText sStart sStop sVariableName sPlace sChar
        Integer iPos 
        tCodeComponents CodeComponents
        
        Move sLine to sText    
        // Check if this is a comment line, in case we do nothing.
        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End
        Move (Ltrim(sText)) to sText
        Move (Pos(Lowercase(CS_Insert + " "), Lowercase(sText))) to iPos
        If (iPos < 1) Begin
            Function_Return False
        End
        
        // Also check that the keyword is not part of a variable name:
        Move (Mid(sText, 1, (iPos -1))) to sChar
        If (sChar <> " " and sChar <> "(") Begin
            Function_Return False
        End
        
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Insert to bChanged
        Get Tokenizer sLine to CodeComponents
        Move (Replace(CodeComponents.sIndentation, sLine, "")) to sLine
        Send StripConcatenatingSpaces (&sLine)
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine 
        Move (Replace("||||", sLine, ", ")) to sLine
        Move (Mid(sLine, Length(sLine), (iPos + 2))) to sStop
        Move (Pos(" ", sStop)) to iPos
        Move (Left(sStop, (iPos -1))) to sVariableName
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_At + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Replace("||||", sLine, ", ")) to sLine

        Move (CodeComponents.sIndentation + String(sLine) * String(sVariableName)) to sLine
        Function_Return bChanged
    End_Function
    
    // Replaces 'IN' with 'Contains
    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsPosCommand bIsCommentOrBlank bFound
        String sPattern sOrg
        String sMatched sRemain sHost sSub sText sKeyWord sStart
        tRegexMatch[] myReg           
        Integer iPos
        tCodeComponents CodeComponents
        
        Move False to bChanged
        Move sLine to sText 
        Move sLine to sOrg   
        // Check if this is a comment line, in case we do nothing.
        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End

        Get _OverstrikeStrings sText to sText
        Move (Lowercase(sText)) to sText
        Move (Ltrim(sText)) to sText
        // First check if there is a "In" keyword in the source code.
        Move (Lowercase((" " + CS_In + " "))) to sKeyWord
        If (Pos(sKeyWord, sText) = 0) Begin
            Function_Return False
        End

        // Check for "home cocked" commands; in case we do nothing.
        Get Tokenizer sLine to CodeComponents

        // If we are in a "Pos", "Insert" or "Replace" command line, we're done.
        Get IsKeywordInLine (CS_Pos + "|" + CS_Insert + "|" + CS_Replace + "|") CodeComponents.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        If (CodeComponents.sOfStatement <> "") Begin
            Move (CodeComponents.sCode * CS_Of * String(CodeComponents.sOfStatement)) to sText
        End
        If (CodeComponents.sToStatement <> "") Begin
            Move (CodeComponents.sCode * CS_To * String(CodeComponents.sToStatement)) to sText
        End
            
        Get _RetrieveFirstWord sText to sStart
        Move (" " + Lowercase(sStart) + " ") to sStart
        Get _FindFirstCommand sStart to iPos
        If (iPos = 0) Begin
            Get _TestCommandFunctions sStart to iPos
        End
        If (iPos = 0) Begin
            Function_Return False 
        End
        
        Move CodeComponents.sCode to sText
        Move (Replaces('`', '(".*"|`.*`|\S+)\s+in\s+(".*"|`.*`|\S+)', "'")) to sPattern
        Get Regex_Match sText sPattern True to myReg
        If (SizeOfArray(myReg)) Begin
            Move myReg[0].Val to sMatched
            Move (Replaces('`', '(".*"|`.*`|\S+)\s+', "'")) to sPattern
            Get Regex_Match sMatched sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sSub
            Move (Trim(Replace(sSub, sMatched, ''))) to sRemain // Remove the subString
            Move (Remove(sRemain,0 ,2)) to sRemain // Remove the 'In'
            Move (Replaces('`', '\s+(".*"|`.*`|\S+)', "'")) to sPattern
            Get Regex_Match sRemain sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sHost

            Move (Replace(sMatched, sText, ("(" + sHost + ' contains ' + sSub + ")"))) to sLine
            If (Length(CodeComponents.sIndentation)) Begin
                Move (CodeComponents.sIndentation + String(sLine)) to sLine
            End
            If (CodeComponents.sOfStatement <> "") Begin
                Move (String(sLine) * String(CS_Of) * String(CodeComponents.sOfStatement)) to sLine
            End
            If (CodeComponents.sToStatement <> "") Begin
                Move (String(sLine) * String(CS_To) * String(CodeComponents.sToStatement)) to sLine
            End    
            If (CodeComponents.sRightComment <> "") Begin
                Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine
            End
        End          
                
        Function_Return (sLine <> sOrg)
    End_Function

    // Changes "Set Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
    // and     "Set Object_Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
        tCodeComponents LineComponents                       
        String sCode sState sFirstChar sText
        Boolean bIsComment bIsOfOperator
        Integer iPos
        
        Get IsCommentLineOrBlank sLine to bIsComment
        If (bIsComment = True) Begin
            Function_Return False
        End
        
        Get Tokenizer sLine to LineComponents
        Move (Trim(sLine)) to sCode
        Move (Lowercase(sCode)) to sCode
        Move (Left(sCode, 1)) to sFirstChar 
        
        // There are two variants of shadow state; Shadow_State and Object_Shadow_State
        Move "et shadow_state " to sText
        Move (Pos(sText, sCode)) to iPos
        If (iPos = 0) Begin
            Move "et object_shadow_state " to sText
            Move (Pos(sText, sCode)) to iPos
        End   
        If (iPos = 0) Begin
            Function_Return False
        End
        
        Move (Pos((" " + Lowercase(CS_To) + " "), sCode)) to iPos
        If (iPos = 0) Begin
            Function_Return False
        End
    
        Move (Mid(sLine, Length(sLine), (iPos + 3 + Length(LineComponents.sIndentation)))) to sState // Could also be a variable name (if get statement)
        Move (Replace(LineComponents.sRightComment, sState, "")) to sState 
        Move (" " + Trim(sState)) to sState
    
        // Set syntax:
        If (sFirstChar = "s") Begin
            If (Lowercase(sState) contains (" " + Lowercase(CS_True))) Begin
                Move (" " + CS_False) to sState
            End
            Else Begin   
                If (Lowercase(sState) contains (" " + Lowercase(CS_False))) Begin
                    Move CS_True to sState
                End 
                Else Begin      
                    If (Lowercase(sState) contains ("(" + Lowercase(CS_Not)) or sState contains ("( " + Lowercase(CS_Not)) or Lowercase(sState) contains (Lowercase(CS_Not + ")")) or Lowercase(sState) contains (Lowercase(CS_Not + " )"))) Begin
                        Move (Replace(CS_Not, sState, "")) to sState
                        Move (Replaces(")", sState, "")) to sState
                        Move (Pos("(", sState)) to iPos
                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
                        Move (Pos("(", sState)) to iPos
                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
                    End   
                    Else Begin
                        Move ("(" + CS_Not + "(" + Trim(sState) + "))") to sState
                    End
                End
                    
            End
            If (Length(LineComponents.sOfStatement)) Begin
                Move (CS_Set * CS_Enabled_State * CS_Of * LineComponents.sOfStatement * CS_To * String(sState)) to sCode 
            End
            Else Begin
                Move (CS_Set * CS_Enabled_State * CS_To * Trim(sState)) to sCode 
            End
        End           
    
        // Get Syntax:
        Else If (sFirstChar = "g") Begin                         
            Move (Lowercase(LineComponents.sToStatement)) to sText
            Move (Pos(Lowercase(CS_To), sText)) to iPos
            // Remove "To" keyword:
            If (iPos <> 0) Begin
                Move (Mid(LineComponents.sToStatement, Length(LineComponents.sToStatement), (iPos + 3))) to LineComponents.sToStatement
            End
            If (Length(LineComponents.sOfStatement)) Begin
                Move (CS_Get * CS_Enabled_State * LineComponents.sOfStatement * CS_To * "(" + CS_Not + "(" + LineComponents.sToStatement + "))") to sCode
            End
            Else Begin
                Move (CS_Get * CS_Enabled_State * CS_To * "(" + CS_Not + "(" + LineComponents.sToStatement + "))") to sCode
            End
        End
        If (LineComponents.sRightComment <> "") Begin
             Move (LineComponents.sIndentation + String(sCode) * String(LineComponents.sRightComment)) to sLine
        End
        Else Begin
            Move (LineComponents.sIndentation + String(sCode)) to sLine
        End
                                
        Function_Return True
    End_Function

    // Pass only the code part of a source line.
    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>" for If-Begin lines and While statements.
    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
        String sSource sText sLeftExpression sRightExpression sStart sCommand sFirstChar sLastChar sOrg
        Boolean bFound bChanged
        Integer iPos                       
        tCodeComponents CodeComponents

        Move sLine to sText     
        Move sLine to sOrg
        // Skip line if it is a comment or blank
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon ?? Should we??
        Get IsLineEndSemiColon sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsFirstWord sText CS_Find to bFound
        If (bFound = True) Begin
            Function_Return False
        End                 
        Get IsFirstWord sText CS_Send to bFound
        If (bFound = True) Begin
            Function_Return False
        End                 
        Get IsFirstWord sText CS_Constrain to bFound
        If (bFound = True) Begin
            Function_Return False 
        End
        Get IsLegacyOperators sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End            
        Move (Lowercase(sText)) to sSource 
        
        Move (Pos(" gt ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" >_ ", sText, iPos)) to sText
            Move (Replace(" >_ ", sText, " > ")) to sText
            Move (Pos(" gt ", sText)) to iPos  
        Loop

        Move (Pos(" ge ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" >= ", sText, iPos)) to sText
            Move (Pos(" ge ", sText)) to iPos
        Loop

        Move (Pos(" lt ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <_ ", sText, iPos)) to sText
            Move (Replace(" <_ ", sText, " < ")) to sText
            Move (Pos(" lt ", sText)) to iPos
        Loop

        Move (Pos(" le ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <= ", sText, iPos)) to sText
            Move (Pos(" le ", sText)) to iPos
        Loop

        Move (Pos(" eq ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" =_ ", sText, iPos)) to sText
            Move (Replace(" =_ ", sText, " = ")) to sText
            Move (Pos(" eq ", sText)) to iPos
        Loop

        Move (Pos(" ne ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <> ", sText, iPos)) to sText
            Move (Pos(" ne ", sText)) to iPos
        Loop 
        
        Move (String(sText) <> String(sLine)) to bChanged
        If (bChanged = False) Begin
            Function_Return False
        End                      
        
        Get Tokenizer sText to CodeComponents 
        // For some reason we can get an exception error passing a struct member as
        // a ByRef argument. Just moving to a local variable cures it.
        Move CodeComponents.sCode to sText
        Get _AddExpressionParenthesis (&sText) to bChanged
        If (bChanged = True) Begin
            Move sText to CodeComponents.sCode
        End
                    
        Move (String(CodeComponents.sIndentation + String(CodeComponents.sCode))) to sLine
        If (CodeComponents.sOfStatement <> "") Begin
            Move (String(sLine) * CodeComponents.sOfStatement) to sLine
        End                   
        If (CodeComponents.sToStatement <> "") Begin
            Move (String(sLine) * String(CS_To) * String(CodeComponents.sToStatement)) to sLine
        End                                                                    
        If (CodeComponents.sRightComment <> "") Begin
            Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine
        End

        Function_Return (sLine <> sOrg)
    End_Function 
    
    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
        Function_Return bChanged
    End_Function
    
    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
        Function_Return bChanged
    End_Function
    
    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sText sStart sStop sVariableName sOrg sFirstWord
        Integer iPos 
        tCodeComponents CodeComponents
        
        Move sLine to sOrg
        Move sLine to sText    
        // Check if this is a comment line, in case we do nothing.
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End   
        Get IsKeywordInLine (CS_Replace + "|") sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Get Tokenizer sLine to CodeComponents
        // If a "#Replace" command line, we're done.
        Move (Pos(("#"+ CS_Replace), CodeComponents.sCode)) to iPos
        If (iPos <> 0) Begin
            Function_Return False
        End

        Move CodeComponents.sCode to sLine
        Send StripConcatenatingSpaces (&sLine)
        Move (Lowercase(sLine)) to sText

        Get _RetrieveFirstWord sText to sFirstWord
        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
            Get _RemoveFirstWord sLine to sLine
            Get _RemoveFirstWord sText to sText
        End

        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine 
        Move (Mid(sLine, Length(sLine), (iPos + Length(" " + CS_In + " ")))) to sStop
        Move (Pos(" ", sStop)) to iPos
        Move (Left(sStop, (iPos -1))) to sVariableName
        Move (Replace("||||", sLine, ", ")) to sLine
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_With + " "), sText)) to iPos
        Move (Overstrike("||||||", sLine, iPos)) to sLine
        Move (Replace("||||||", sLine, ", ")) to sLine 
        
        Move (CS_Move * "(" + CS_Replace + "(" + String(sLine)) to sLine  
//        Get Tokenizer sLine to CodeComponents
//        Get _AddExpressionParenthesis (&sLine) to bChanged
        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
            Move (sLine + "))") to sLine
        End

        Move (CodeComponents.sIndentation + String(sLine) * CS_To * String(sVariableName)) to sLine
        If (CodeComponents.sRightComment <> "") Begin
            Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine         
        End               
        Function_Return (sLine <> sOrg)
    End_Function
    
    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
        String sText
        Boolean bFound
        Integer iPos
        
        Move (Lowercase(sLine)) to sText
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get IsKeywordInLine (CS_Sysdate4 + "|") sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End                                   
        
        Move (Pos(Lowercase(CS_Sysdate4), sText)) to iPos
        Move (Overstrike("|", sLine, (iPos - 1 + Length(CS_Sysdate4)))) to sLine
        Move (Replace("|", sLine, "")) to sLine
        Function_Return True
    End_Function

    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Trim to bChanged
        Function_Return bChanged
    End_Function
    
    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
        Function_Return bChanged
    End_Function 
    
    // Changes: Until [expression] to Until (expression) and the same for the While command.
    Function ChangeUntilAndWhileIndicators String ByRef sLine String sParameter Returns Boolean
        String sText sCommand sNot
        Boolean bFound
        Integer iPos
        tCodeComponents LineComponents 
        tBooleanIndicator BooleanIndicator
        
        Move sLine to sText
        // Skip line if it is a comment or blank
        Get IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End             
        // Skip line if it contains a semi colon
        Get IsLineEndSemiColon sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        Get IsWhileStatement sText to bFound
        If (bFound = False) Begin
            Get IsUntilStatement sText to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End
        Get Tokenizer sLine to LineComponents
        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False) Begin
            Function_Return False
        End

        Move (LineComponents.sIndentation + String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression) + LineComponents.sRightComment) to sLine

        Function_Return True
    End_Function
    
    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bValid bIgnore
        String sTest sClassName sOldStyle sNewStyle
        Integer iPos

        Move False to bChanged
        Move "" to sClassName
        Move (Lowercase(sLine)) to sTest
        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
        Send StripConcatenatingSpaces (&sTest)
        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
        If (Pos(" create u_", sTest)) Begin
            Move (Lowercase(sLine)) to sTest
            Move (Pos("u_", sTest)) to iPos
            Get IsValidClassCharacter sTest iPos to bValid
            While (bValid)
                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
                Increment iPos
                Get IsValidClassCharacter sTest iPos to bValid
            Loop
        End
        If (sClassName <> "") Begin
            Move True to bChanged
            Move sClassName to sOldStyle
            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
            Move ("(RefClass(" + sClassName + "))") to sNewStyle
            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
        End
        Function_Return bChanged
    End_Function
    
    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
    // This would compile but not work well with the ReplaceCalcWithMoveStatement function.
    // Reported by: JJ
    //    Procedure Testing
    //        // Before refactor
    //        String moveStr
    //        String s
    //        Move moveStr to s
    //       
    //        // After refactor
    //        String moveStr
    //        String s
    //        Move Move to s
    //    End_Procedure    
    Function ReplaceCalcWithMoveStatement String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsIn bIsCommentOrBlank
        String sTest sStart sStop
        Integer iPos                             

        Move False to bChanged
        Move sLine to sTest

        // Check if this is a comment line, in case we do nothing.
        Get IsCommentLineOrBlank sTest to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End

        Move (Lowercase(sLine)) to sTest
        Get _OverstrikeStrings sTest to sTest
        // Replaces all quotes string contents to "_" so we don't get false positives.

        // Check if line contains one of the keywords and that none of the keywords are within quotes.
        Get IsKeywordInLine "calc|moveint|movenum|movereal|movestr|" sTest to bIsIn
        If (bIsIn = False) Begin
            Function_Return False
        End
        
        Case Begin
            Case (Pos("calc ", sTest))
                Move (Pos("calc ", sTest))         to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("moveint ", sTest))
                Move (Pos("moveint ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movenum ", sTest))
                Move (Pos("movenum ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movereal ", sTest))
                Move (Pos("movereal ", sTest))     to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movestr ", sTest))
                Move (Pos("movestr ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break
        Case End

        Function_Return bChanged
    End_Function

    // Removes local statement if present.
    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sTest
        Integer iPos

        Move sLine to sTest
        Get IsCommentLineOrBlank sTest to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move False to bChanged
        Move (LTrim(sLine)) to sTest
        Move (Left(sTest, 6)) to sTest
        Move (Lowercase(sTest)) to sTest
        If (sTest = (Lowercase(CS_Local) + " ")) Begin
            // local must be the first word in the line.
            // Now find the local statement in the line and remove it.
            Move (Lowercase(sLine)) to sTest
            Move (Pos((Lowercase(CS_Local) + " "), sTest)) to iPos
            If (iPos > 0) Begin
                Move (Remove(sLine, iPos, 6)) to sLine
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
        Function_Return bChanged
    End_Function
    
    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
        Function_Return bChanged
    End_Function

    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String  sTestLine sTest

        Move False to bChanged
        Move (LTrim(sLine)) to sTestLine
        Move (Lowercase(sTestLine)) to sTestLine
        Get IsCommentLineOrBlank sTestLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        
        Move False to bFound
        // We check both for a space between the key word and the comment _and_
        // comments placed directly after the key word _without_ a space between, aka "end_object//this is a comment"
        //
        // end_class:
        Move (Left(sTestLine, 10)) to sTest
        Move (sTest = "end_class ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 11)) to sTest
            Move (sTest = ("end_class" + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_object:
        Move (Left(sTestLine, 11)) to sTest
        Move (sTest = "end_object ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 12)) to sTest
            Move (sTest = ("end_object" + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_function:
        Move (Left(sTestLine, 13)) to sTest
        Move (sTest = "end_function ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 14)) to sTest
            Move (sTest = ("end_function" + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End
        
        // end_procedure:
        Move (Left(sTestLine, 14)) to sTest
        Move (sTest = "end_procedure ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 15)) to sTest
            Move (sTest = ("end_procedure" + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
        End

        Function_Return bChanged
    End_Function
    
    // Returns True if a legacy IDE (Studio) source code marker is found. 
    // This is a "Remove Type Function".
    Function RemoveOldStudioMarkers String sLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Trim(sLine)) to sLine

        Case Begin
            Case (sLine = "//AB-IgnoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-IgnoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-DDOStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-DDOEnd")
                Move True to bFound
                Case Break

            Case (Left(sLine, 6) = "//AB/ ")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-MenuPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-End")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ToolbarPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ViewStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ViewEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StatusBarPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//IDE-FileType=ftApplication")
                Move True to bFound
                Case Break

        Case End

        Function_Return bFound
    End_Function

    // To remove hardcoded MS Sans Serif fonts if present.
    Function RemoveSansSerif String sLine Returns Boolean
        String sTest
        Boolean bWriteLine

        Move False to bWriteLine
        Move (Trim(sLine)) to sTest
        Move (Lowercase(sTest)) to sTest
        Move (Replaces(" ", sTest, ""))  to sTest
        Move (Replaces("'", sTest, "*")) to sTest
        Move (Replaces('"', sTest, "*")) to sTest
        If (sTest contains 'settypefaceto*mssansserif*') Begin
            Move True to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // Removes Studio generated comments:
    //               "// fires when the button is clicked"
    //               "//OnChange is called on every changed character
    //               "// Visual DataFlex 14.0 Client Size Adjuster     
    //               "// Visual DataFlex 14.0 Migration Utility,"
    //               ...and so on 
    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
        String sText sComment
        Boolean bFound bChanged
        
        Move False to bChanged
        Move sLine to sText
        Get IsCommentLine sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End                      
        
        Move "fires when the button is clicked" to sComment   
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End

        Move "onchange is called on every changed character" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End
        
        Move "visual dataflex 14.0 client size adjuster" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End             
        
        Move "visual dataflex 14.0 migration utility," to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End             
        
        Move "If you set Current_radio you must set this after the" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End
        
        Move "radio objects have been created AND after Notify_select_State has been" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End

        Move "created. i.e. Set in bottom-code at end!!" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine  
            Function_Return True
        End
        
        Function_Return bChanged
    End_Function
    
    // Remove trailing spaces if present.
    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
        Integer iBefore iAfter
        Boolean bChanged

        Move (Length(sLine))     to iBefore
        Move (RTrim(sLine))      to sLine
        Move (Length(sLine))     to iAfter
        Move (iBefore <> iAfter) to bChanged

        Function_Return bChanged
    End_Function  
    
    Procedure ResetProjectObjectStructureProperties
        String[] asObjectNames
        Set pbProjectObjectStructureStart to False 
        Set pbProjectObjectStructureEnd   to False
        Set pbRegisterAllObjectsStart     to False    
        Set pbRegisterAllObjectsEnd       to False
        Set pasObjectNames                to asObjectNames
    End_Procedure

    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
        Move False to bWriteLine
        String[] asObjectNames
        
        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd   
        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
        Get pasObjectNames                to asObjectNames
        
        If (bRegisterAllObjectsEnd = False) Begin
            If (bRegisterAllObjectsStart = False) Begin
                Get IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
                Set pbRegisterAllObjectsStart       to bRegisterAllObjectsStart
            End
            If (bRegisterAllObjectsStart = True) Begin
                Get IsRegisterObjectInArray sLine asObjectNames to bWriteLine
                Move False to bProjectObjectStructureStart
                Set           pbProjectObjectStructureStart to False
            End
            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
                Get IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
            End
            If (bProjectObjectStructureStart = True) Begin
                Get IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
            End
            Get IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
            If (bRegisterAllObjectsEnd = True) Begin
                Send ResetProjectObjectStructureProperties
                // This means that we won't bother with the rest of the file.
                Set pbRegisterAllObjectsEnd to True
            End                                           
        End
        Function_Return bWriteLine
    End_Function
    
    // The former passed parameters; eSplitBy and iTabSize has been made into
    // class properties. That way we can have a uniform calling interface to all functions.
    // The two user selected values can be found in Sysfile.  
    // Valid sParameter values;
    //    CI_SplitWithSpaceAndSemicolon 
    //    CI_SplitWithSemicolon         
    //    CI_SplitAddBeginEndBlock      
    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
        Boolean bStop bChanged
        Integer iIndent eSplitBy iTabSize iID
        String  sText
        
        // We need to get a second parameter; the tab-size:
        Move FunctionsA.ID to iID
        Clear FunctionsA
        Move CS_EditorReIndent to FunctionsA.Function_Name
        Find eq FunctionsA by Index.5
        If (Found = False) Begin
            Send UserError ("Could not find function:" * CS_EditorReIndent)
            Function_Return False
        End                      
        Else Begin
            Move (Trim(FunctionsA.Parameter)) to iTabSize
            // Reset record buffert:
            Move iID to FunctionsA.ID
            Find Eq FunctionsA by Index.1
        End
        
        Move False to bChanged
        Move sParameter to eSplitBy
        
        Move (LTrim(sLine))     to sText
        Move (Pos(sText,sLine) - 1) to iIndent
        Move (Left(sText, 3))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_If) + " ")) Begin
            Get IsLineEndSemiColonOrBegin sLine to bStop
            If (bStop = False) Begin
                // It's one of those single line if statements, break it up
                Move (Lowercase(sLine)) to sText
                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
            End
        End
        Else Begin
            Move (LTrim(sLine))     to sText
            Move (Left(sText, 5))   to sText
            Move (Lowercase(sText)) to sText
            If (sText = (Lowercase(CS_Else) + " ")) Begin
                Get IsLineEndSemiColonOrBegin sLine to bStop
                If (bStop = False) Begin
                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
                End
            End
        End
        Function_Return bChanged
    End_Function

    // ToDo: *** FULL SOURCE FILE FUNCTIONS ***
    //
    // Counts total number of source lines for the passed file name.
    // It does _not_ count empty or comment lines. 
    // it does _not_ count COM proxy class files generated by the Studio for COM/ActiveX components.
    Function CountNumberOfLines String sFullSourceFileName String sParameter Returns Integer
        Integer iLines iChannel 
        String sLine     
        Boolean bExists bBlank bIsCOM
        
        File_Exist sFullSourceFileName bExists
        If (bExists = False) Begin
            Send UserError ("Couldn't find file:" * String(sFullSourceFileName) * "No source lines added to counter for this file.")
            Function_Return 0
        End                  

        Get IsDataFlexCOMProxyClassesFile sFullSourceFileName to bIsCOM
        If (bIsCOM = True) Begin
            Function_Return 0
        End
        
        Get Seq_New_Channel to iChannel
        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Send UserError "No Channel Available for Process: Procedure 'CountNumberOfLines'"
            Function_Return 0
        End

        Move 0 to iLines
        Direct_Input channel iChannel sFullSourceFileName
        While (SeqEof = False)
            Readln channel iChannel sLine 
            Get IsCommentLineOrBlank sLine to bBlank
            If (bBlank = False) Begin
                Increment iLines
            End
        Loop
        Close_Input channel iChannel
        Send Seq_Release_Channel iChannel
        
        Function_Return iLines
    End_Function

    // Pass the whole source file as a string array
    // Removes all unusad locally defined (in Procedures & Functions) for the
    // passed string array. Returns number of removed unused local variables.
    Function RemoveUnusedLocals String[] ByRef asSourceFile String sParameter Returns Integer
        Handle ho                               
        Integer iRetval
        Get phoRemoveUnusedLocals to ho
        If (ho = 0) Begin
            Send UserError "phoRemoveUnusedLocals = 0"
            Function_Return 0
        End                                                
        Get MainProcedure of ho asSourceFile to iRetval
//        If (iRetval > 1) Begin
//            Reread SysFile
//                Add iRetval to SysFile.iCountUnusedLocals
//                SaveRecord SysFile
//            Unlock
//        End

        Function_Return iRetval
    End_Function                                                          
    
    // Pass the whole source file as a string array.
    // Removes  consecutive empty blank lines if more than piMaxNoOfEmptyLines.
    // Returns the passed string array but with removed duplicated empty lines.
    Function RemoveMultipleBlankLines String[] ByRef asSourceFile String sParameter Returns Integer
        String[] asSourceFileOut
        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines 
        String sLine
        Boolean bImageStart bImageEnd bMakeImageTest

        Move False to bImageStart
        Move False to bImageEnd
        Move True  to bMakeImageTest
        Move 0 to iCurrentNoOfEmptyLines                                           
        Move sParameter to iMaxNoOfEmptyLines
        
        Move (SizeOfArray(asSourceFile)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (Trim(asSourceFile[iCount])) to sLine

            If (bMakeImageTest = True) Begin
                If (bImageStart = False and bImageEnd = False) Begin
                    Get IsImagePageStartOrEnd sLine True to bImageStart
                End
            End

            If (bImageStart = False and bImageEnd = False) Begin
                If (sLine = "") Begin
                    Increment iCurrentNoOfEmptyLines
                End
                Else Begin
                    Move 0 to iCurrentNoOfEmptyLines
                End
            End
            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
                Move asSourceFile[iCount] to asSourceFileOut[SizeOfArray(asSourceFileOut)]
            End

            If (bMakeImageTest = True) Begin
                If (bImageStart = True) Begin
                    Get IsImagePageStartOrEnd sLine False to bImageEnd
                    If (bImageEnd = True) Begin
                        Move False to bImageStart
                        Move False to bImageEnd
                        Move False to bMakeImageTest
                    End
                End
            End
        Loop

        Move (SizeOfArray(asSourceFile) - SizeOfArray(asSourceFileOut)) to iEmptyLines
        Move asSourceFileOut to asSourceFile

        Function_Return iEmptyLines
    End_Function    
    
    Function RestylelDDOs String[] ByRef asSourceFile String sParameter Returns Integer
//        String sFileFilter sHomePath
//        Handle ho 
        Integer iRetval                  
//        tRefactorSettings RefactorSettings
//        tsSearchResult[] asAllSourceFiles
//        
//        // ToDo: This needs to be available for the unit tester as well.
//        Get phoDDOReStyler to ho
//        If (ho = 0) Begin
//            Send UserError "phoDDORestyler = 0"
//            Function_Return 0
//        End
//        
//        Get psHomePath of ghoApplication to sHomePath 
//        Get pRefactorSettings to RefactorSettings
//        Get AllSourceFiles of ghoApplication RefactorSettings.asFolderNames RefactorSettings.sFileFilter to asAllSourceFiles
//        
//        Set psHomePath of ho to sHomePath
//        Set peDDOStyle of ho to RefactorSettings.eDDOStyle
//        Set pasAllSourceFiles of ho to asAllSourceFiles
//        
//        Get MainDDORestyler of ho to iRetval 
        Function_Return iRetval
    End_Function
    
    // ToDo: *** EDITOR FUNCTIONS ***   
    //
    // Wrapper functions for the cScintillaEdit editor
    // Note that a full visible instantiation of the cScintillaEdit class
    // should be used for usage, and the phoEditor property for that
    // object _must_ be set to that editor object id.   
    //
    Function EditorNormalizeCase String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor                                       
        Integer iRetval
        Boolean bErr
        
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorNormalizeCase)"
            Function_Return 0
        End
        Send RefactorNormalizeCase of hoEditor 
        If (Err = True) Begin
            Move 0 to iRetval
        End                  
        Else Begin
            Move 1 to iRetval
        End
        Move bErr to Err
        Function_Return iRetval
    End_Function

    Function EditorReIndent String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor                                       
        Integer iRetval 
        Boolean bErr
        
        Move Err to bErr
        Move False to Err
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorReIndent)"
            Function_Return 0
        End                                            
        Set piTabSize of hoEditor to sParameter
        Send RefactorReIndent of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End                  
        Else Begin
            Move 1 to iRetval
        End
        Move bErr to Err
        Function_Return iRetval
    End_Function

    Function EditorDropSelf String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval
        Boolean bErr
        
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorDropSelf)"
            Function_Return 0
        End                  
        Send RefactorDropSelf of hoEditor
        Else Begin
            Move 1 to iRetval
        End
        Move bErr to Err
        Function_Return iRetval
    End_Function


    // ToDo: *** REPORT FUNCTIONS ***
    //                        
    Function ReportUnusedSourceFiles String[] ByRef asSourceFiles String sParameter Returns Integer
        Handle ho                 
        String sFilter                       
        Integer iRetval
        tRefactorSettings RefactorSettings
        
        Get phoReportUnusedSourceFiles to ho
        If (ho = 0) Begin
            Function_Return 0
        End                              
        
        Get pRefactorSettings to RefactorSettings
        Set psFileFilter  of ho to RefactorSettings.sFileFilter
//        Set pasAllFolders of ho to RefactorSettings.asFolderNames
// ToDo: *** Change interface!!! ***
//        Set pasSourceFiles of ho to asSourceFiles 
Function_Return 0
        
        Send DoProcess    of ho  
        
        Get piNoOfUnusedSourceFiles of ho to iRetval
        Reread SysFile
            Move iRetval to SysFile.iCountUnusedSourceFiles
            SaveRecord SysFile
        Unlock
        Function_Return iRetval
    End_Function
    
    // ToDo: *** HELPER FUNCTIONS ***   

    // Note: It must only be the code part of a source line that is passed here.
    //       Use the Tokenizer helper function first.
    Function _AddExpressionParenthesis String ByRef sLine Returns Boolean
        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
        Boolean bFound bChanged bStartOperators bIfCommand bSecondCommand bWhile
        Integer iPos iPos2
        
        Move sLine to sText    
        Move sLine to sOrg             
        // Do nothing if a Constrain command.
        Get HasCommand sText (CS_Constrain + " ") to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move "" to sStart
        Move "" to sLast                                  
        Get ExpressionExtractor sText CI_LeftExpression to sExpression
        If (Trim(sExpression) = "") Begin
            Get ExpressionExtractor sText CI_OfExpression to sExpression
            If (Trim(sExpression) = "") Begin
                Get ExpressionExtractor sText CI_ToTexpression to sExpression
            End
        End
        If (Trim(sExpression) = "") Begin
            Function_Return False
        End 
        Move (Pos(sExpression, sText)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sLine, (iPos - 1))) to sStart
            If (sStart <> "") Begin
                Move (Replace(sStart, sLine, "")) to sText
                Move (Replace(sExpression, sText, "")) to sLast
            End
        End
//        If (sStart <> "") Begin
//            Move sStart to sLine
//        End                     
        If (sExpression <> "") Begin               
            Move sExpression to sText
            Send StripConcatenatingSpaces (&sExpression)  
            Move (Trim(sExpression)) to sExpression 
            Get HasDoubleExpression sExpression to bFound
            Move (Left(sExpression, 1)) to sChar
            If (sChar <> "(" or bFound = True) Begin
                Move ("(" + sExpression + ")") to sExpression
            End                      
            If (sText = sLine) Begin
                Move sExpression to sLine
            End
        End                                                    
        If (sStart <> "" or sLast <> "") Begin    
            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
        End
        
        Function_Return (sLine <> sOrg)
    End_Function   
                   
    // Helper message for _ClearFirstCompoundBeforeMethod
    Procedure _WipeUntilPosition Integer iPos String ByRef sLine
        Integer iChar
        If (iPos > 0) Begin
            For iChar from 1 to (iPos - 1)
                Move (Overstrike(" ", sLine, iChar)) to sLine
            Loop
        End
    End_Procedure

    // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
    // send/get/set as the first string and that complicates our detection.
    // What this does is simply overwrite everything with spaces before our methods if
    // we have such a compound statement.
    // The variable sLine is not always lowercase.
    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
        Integer iPos
        String  sLtrimLine sOrgLine
        Boolean bChanged
        
        Move sLine to sOrgLine
        Move (Lowercase(LTrim(sLine))) to sLTrimLine
        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
            // A line that starts with an "if" or "else" can still call a method
            Move (Pos("send ", Lowercase(sLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos("get ", Lowercase(sLine))) to iPos
            End
            If (iPos = 0) Begin
                Move (Pos("set ", Lowercase(sLine))) to iPos
            End
            Send _WipeUntilPosition iPos (&sLine)
        End       
        
        Function_Return (sLine <> sOrgLine)
    End_Function
  
    // Helper function to return expressions from a source line;
    //   eExpressionMode can be any of; CI_LeftExpression, CI_OfExpression or CI_ToTexpression.
    // As expressions only expressions in rounded parenthesis "()" are acted upon and returned (Not square brackets)
    Function ExpressionExtractor String sLine Integer eExpressionMode Returns String
        String sExpression sText sChar sStart sLast sCommand 
        String[] asTokens asTokensLower
        Integer iStart iEnd iLength iLeftParantheses iRightParantheses iPos iCount iSize
        Boolean bFound bOperator bParenthesis 
        tOperatorsInfo OperatorsInfo
        tCodeComponents CodeComponents
        
        Get _RemoveEndComment sLine to sText
        Move (Trim(sText)) to sText
        Get _OverstrikeStrings sText to sText
        Move (Pos("(", sText)) to iStart
        Move (Pos(")", sText)) to iEnd 
        Get IsLogicalOperators sText to OperatorsInfo
        If (OperatorsInfo.bIsOperator = False and (iStart < 1 or iEnd < 1) ) Begin
            Function_Return sLine
        End
        
        Move (Trim(sLine)) to sText
//        Get StrSplitToArray sLine " " to asTokens
//        Move (Lowercase(sLine)) to sText
//        Get StrSplitToArray sText " " to asTokensLower
        
        Case Begin
            Case (eExpressionMode = CI_LeftExpression) 
                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Left(sText, (iPos -1))) to sText
                End                                       
                Else Begin
                    Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
                End                                            
                If (iPos > 0) Begin
                    Move (Left(sText, (iPos - 1))) to sText // XXX
                End
                Case Break   
            
            // ToDo: Needs to be finished after changes to the Tokenizer.    
            Case (eExpressionMode = CI_CommandExpression)
                Get Tokenizer sLine to CodeComponents 
                If (Lowercase(CodeComponents.sLeftCommand) = Lowercase(CS_If)) Begin
                    Move (lowercase(sLine) contains (" " + Lowercase(CS_Move) + " ")) to bFound
                    If (bFound) Begin
                        
                    End
                End
                Case Break
            Case (eExpressionMode = CI_OfExpression)
                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText
                    Move (Pos((" " + Lowercase(CS_to) + " "), Lowercase(sText))) to iPos
                    If (iPos > 0) Begin
                        Move (Left(sText, (iPos -1))) to sText
                    End
                    Get IsOperators sText to bOperator
                    Move (sText contains "(" and sText contains ")") to bParenthesis
                    If (bOperator = True or bParenthesis = True) Begin
                        Move (Trim(sText)) to sExpression
                    End
                End
                Else Begin
                    Move "" to sText // Nothing to do.
                End
                Case Break
            Case (eExpressionMode = CI_ToTexpression)
                Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText 
                    Get IsOperators sText to bOperator
                    Move (sText contains "(" and sText contains ")") to bParenthesis
                    If (bOperator = True or bParenthesis = True) Begin
                        Move (Trim(sText)) to sExpression
                    End
                End 
                Else Begin
                    Move "" to sText // Nothing to do.
                End
                Case Break 
            Case Else
                Move "" to sText
        Case End
        
//        Move "" to sExpression  
//        Move 0  to iLeftParantheses
//        Move 0  to iRightParantheses
        If (sText <> "") Begin
//            Move (Pos("(", sText)) to iStart
//            Move (Pos(")", sText)) to iEnd
//            Get IsOperators sText to bOperator
//            If (bOperator = False and (iStart = 0 or iEnd = 0) ) Begin
//                Function_Return ""
//            End 
//
            Get IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Get _ExtractParenthesisExpression sText to sExpression
                If (sExpression = "") Begin
                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to sExpression
                End
            End
//            Move (Length(sText)) to iLength
//            For iCount from iStart to iLength
//                Move (Mid(sText, 1, iCount)) to sChar
//                If (sChar = "(" or sChar = ")") Begin
//                    Add (sChar = "(") to iLeftParantheses
//                    Add (sChar = ")") to iRightParantheses
//                    Move iCount to iPos
//                End                        
//                If (sChar = " " and iLeftParantheses = iRightParantheses) Break
//            Loop
//            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
//            If (sExpression = "" and (bOperator = True) and (iStart <> 1 or iEnd <> 0)) Begin
//                Get _RemoveFirstWord sText to sText
//                Get IsOperators sText to bOperator
//                If (bOperator = True) Begin
//                    Move sText to sExpression 
//                    Move sLine to sText
//                End
//            End
        End
        
        // Check if we have an expression like; "If (psWrkSpcOpenFileName(ghoApplication)) <> "" Send WrkSpcDoForAllFiles"
        //   which in case we need to add "<>" to the sExpression.
        Get _RemoveLeft sExpression (&sText) to bFound
        If (bFound = True) Begin
            Get IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Move (Pos(sExpression, sLine)) to iPos
                If (iPos <> "") Begin        
                    Move (Left(sLine, (iPos - 1))) to sStart
                    Move (Replace(sStart, sLine, "")) to sLine
                    Move (Trim(sText)) to sText 
                    Move (Length(sText)) to iLength    
                    Get _OverstrikeStrings sText to sText
                    Get _FindFirstCommand sText to iPos
                    If (iPos <> 0) Begin
                        Move (Replace(sExpression, sLine, "")) to sLine 
                        Move (Trim(sLine)) to sLine
                        Move (Left(sLine, (iPos -1))) to sStart 
                        Move (Trim(sStart)) to sStart
                        If (sStart <> "") Begin
                            Move (Right(sStart, 1)) to sChar
                            If (sChar <> ")") Begin
                                Move (String(sExpression) * String(sStart)) to sExpression    
                            End
                        End
                    End
                End
            End
        End
        Function_Return sExpression
    End_Function

    // Rturns the first expression that exist in the passed sText string and that is within parenthesis,
    // else it returns a blank string.
    Function _ExtractParenthesisExpression String sText Returns String
        String sExpression sChar
        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
        tOperatorsInfo OperatorInfo
        
        Move "" to sExpression
        Move 0  to iLeftParantheses
        Move 0  to iRightParantheses
        
        If (sText <> "") Begin
            Move (Pos("(", sText)) to iStart
            Move (RightPos(")", sText)) to iEnd
            Get IsLogicalOperators sText to OperatorInfo
            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
                Function_Return ""
            End 

            Move (Length(sText)) to iLength
            For iCount from iStart to iLength
                Move (Mid(sText, 1, iCount)) to sChar
                If (sChar = "(" or sChar = ")") Begin
                    Add (sChar = "(") to iLeftParantheses
                    Add (sChar = ")") to iRightParantheses
                    Move iCount to iPos
                End                        
                If (iLeftParantheses = iRightParantheses) Break
            Loop
            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
        End
        Function_Return sExpression
    End_Function

    Function _ExtractExpressionNoParenthesis String sLine tOperatorsInfo OperatorsInfo Returns String
        String sText sExpression sChar sFirst sLast sLeft sRight
        Integer iCount iLength iSize iStart iEnd iPos
        Boolean bStop bSpace bParanthesis
        
        // ToDo: Is this really correct in all cases?
        If (OperatorsInfo.bIsOperator = False) Begin
            Function_Return ""
        End
        Move "" to sExpression  
//        Move (Pos(Lowercase(" " + CS_As + " "), sLine)) to iPos 
//        If (iPos <> 0) Begin
//            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sText    
//        End
//        Else Begin
            Move (OperatorsInfo.iPos - Length(OperatorsInfo.sOperator)) to iStart
            Move (Left(sLine, (iStart + 1))) to sText
//        End
        Send StripConcatenatingSpaces (&sText)
        Get _OverstrikeStrings (&sText) to sText
        Move (Length(sText)) to iLength   
        Move (Pos(Lowercase(" " + CS_As + " "), sText)) to iPos 
        If (iPos <> 0) Begin
            Move (Mid(sText, Length(sText), (iPos + 3))) to sText    
        End
        
        // First get the left part of the expression:
        Move iLength to iStart
        Move 0 to iCount
        Move False to bSpace
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sText, 1, (iStart - iCount))) to sChar
            If (bParanthesis = True) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar <> " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
        Move (Left(sText, (iStart - iCount + 1))) to sFirst  
        Move (Replace(sFirst, sText, "")) to sLeft
        If (sLeft = "") Begin
            Move sText to sLeft
        End
        Move (Length(sLine)) to iLength   
        
        // Then get the right part of the expression:
        Move 1 to iCount   
        Move False to bSpace
        Move (OperatorsInfo.iPos) to iStart
        Move (Mid(sLine, iLength, (iStart + 1))) to sText  
        Move (Length(sText)) to iLength
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sLine, 1, (iStart + iCount))) to sChar
            If (bParanthesis = False) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar = " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
                                                     
        Move (Left(sText, (iCount - 1))) to sRight
        Move (String(sLeft) * String(sRight)) to sExpression
        
        Function_Return (Trim(sExpression))
    End_Function

    // Syntax:
    //    Get Tokenizer sTest to "tCodeComponents"
    // Breaks up a source line into these tokens;
    //     tCodeComponents
    //  a) sIndentation = spaces or tab-characters to the left (start) of the source code line
    //  b) sLineStartIndicator = [Found] or other indicators within brackets placed at beginning of line.   
    //  c) sLeftCommand = "Move, Calc" etc. 
    // ToDo: Should we add a Second left command param???
    //  d) sCode = the source code itself (or left hand side code if a "of" or "to" or right comment)
    //  e) sOfStatement = " of xxx"
    //  f) sToStatement = " to xxx" 
    //  g) sRightComment = any comment placed at the end of the line.
    //
    // It does not Rtrim the end-of-line comment.  Should it??
    // Note: If the line is a compound statement (one that spans over several lines),
    //       aka it contains a ";", the function will NOT try to break up the source code line.
    //       Instead it returns a struct with empty members, except for the 
    //       bHasEndSemiColon member that will be true.
    Function Tokenizer String sLine Returns tCodeComponents
        tCodeComponents LineComponents
        String sText sChar sCommand
        Boolean bEndComment bStop bOfStatement bToStatement bIndicator bFound bMoveCommand
        Integer iPos iStart iEnd
                                                
        Move "" to LineComponents.sIndentation
        Move "" to LineComponents.sLineStartIndicator  
        Move "" to LineComponents.sLeftCommand
        Move "" to LineComponents.sCode
        Move "" to LineComponents.sOfStatement
        Move "" to LineComponents.sToStatement
        Move "" to LineComponents.sRightComment
        Move False to LineComponents.bHasEndSemiColon
        
        Get IsCommentLineOrBlank sLine to bStop
        If (bStop = True) Begin
            Function_Return LineComponents
        End  
        
        Get IsLineEndSemiColon sLine to bStop
        If (bStop = True) Begin
            Move True to LineComponents.bHasEndSemiColon
            Function_Return LineComponents
        End  
        
        // Get the indentation part
        Move (Ltrim(sLine)) to sText
        If (sText <> sLine) Begin
            Move (Replace(sText, sLine, "")) to LineComponents.sIndentation
            Move (Replace(LineComponents.sIndentation, sLine, "")) to sLine
        End     
        
        Get IsKeywordInLine (CS_Indicate + "|") sLine to bFound
        If (bFound = True) Begin
            Move True to LineComponents.bHasIndicateCommand
        End                                                
        
        Get IsIndicatorStatement sLine to bIndicator
        If (bIndicator = True) Begin
            // Get the start indicator part
            Move (Ltrim(sLine)) to sText
            Move (Left(sText, 1)) to sChar
            If (sChar = "[") Begin
                Move (Pos("]", sText)) to iPos
                Move (Left(sText, (iPos -1))) to LineComponents.sLineStartIndicator
                Move (Left(LineComponents.sLineStartIndicator, 1)) to sChar
                If (sChar = "[") Begin
                    Move (Replace("[", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
                End
                Move (Right(LineComponents.sLineStartIndicator, 1)) to sChar
                If (sChar = "]") Begin
                    Move (Replace("]", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
                End
            End
            
            // Get the End indicator part
            Move (Trim(sLine)) to sText    
            Get _RemoveEndComment sText to sText
            Move (Right(sText, 1)) to sChar
            If (sChar = "]") Begin  
                Move (Pos(Lowercase(" to "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 4))) to sText
                End
                // We need to check that this isn't an array/struct value.
                Move (Pos(" [", sText)) to iStart
                If (iStart > 0) Begin
                    Move (Pos("]", sText)) to iEnd
                    Move (Mid(sText, Length(sText), (iStart +1))) to LineComponents.sLineEndIndicator
                    Move (Left(LineComponents.sLineEndIndicator, 1)) to sChar
                    If (sChar = "[") Begin
                        Move (Replace("[", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
                    End
                    Move (Right(LineComponents.sLineEndIndicator, 1)) to sChar
                    If (sChar = "]") Begin
                        Move (Replace("]", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
                    End
                End
            End
        End

        Get IsMoveCommand sText to bMoveCommand
        If (bMoveCommand = True) Begin
            Move (Pos(" ", sText)) to iPos
            Move (Left(sText, (iPos - 1))) to sCommand
            Move sCommand to LineComponents.sLeftCommand
        End                                             
        
        // Get the end comment part
        Move sLine to sText
        Get _RemoveComments (&sText) to bEndComment
        If (bEndComment = True) Begin
            Move (Replace(sText, sLine, "")) to LineComponents.sRightComment
            Move (Replace(LineComponents.sRightComment, sLine, "")) to sLine
        End     
        
        // Get the " to " part
        Move (Lowercase(sLine)) to sText
        Move (sText contains (" " + Lowercase(CS_To) + " ")) to bToStatement
        If (bToStatement = True) Begin
            Move (Pos((" " + Lowercase(CS_To) + " "), sText)) to iPos
            Move (Mid(sLine, Length(sLine), (iPos +1))) to LineComponents.sToStatement
            Move (Replace(LineComponents.sToStatement, sLine, "")) to sLine
            Move (Replace((CS_To) + " ", LineComponents.sToStatement, "")) to LineComponents.sToStatement
            Move (Trim(LineComponents.sToStatement)) to LineComponents.sToStatement
        End
        
        // Get the " of xxxx " part
        Move (Lowercase(sLine)) to sText
        Move (sText contains (" " + Lowercase(CS_Of) + " ")) to bOfStatement
        If (bOfStatement = True) Begin
            Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sLine))) to iPos
            Move (Mid(sLine, (Length(sLine) -1), (iPos + Length(CS_Of) + 1))) to LineComponents.sOfStatement
            Move (Left(sLine, (iPos - 1))) to sLine
            Move (Trim(LineComponents.sOfStatement)) to LineComponents.sOfStatement
        End    
        
        // The reminder of the code line
        Move (Trim(sLine)) to LineComponents.sCode
                                      
        Function_Return LineComponents
    End_Function       
    
    // Helper function.
    Function _BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
        Boolean bChanged
        Integer iPos
        String  sLineIndent
        String  sIndent
        String  sLine1 sLine2
        String  sText

        Move False to bChanged
        Move (Lowercase(sLine)) to sText
        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
        Move (Repeat(" ", iLineIndent)) to sLineIndent
        Get _OverstrikeStrings sText to sText
        Get _FindFirstCommand sText to iPos
        If (iPos <> 0) Begin
            Move True to bChanged
            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitBySemiColumn) Begin
                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitByBeginEnd) Begin
                Move (Insert((" Begin" + CS_CRLF + sLineIndent + sIndent), sLine, iPos)) to sLine
                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
            End

            // Remove any spaces before the point on which we break the line
            Move (Left(sLine, iPos - 1)) to sLine1
            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
            Move (RTrim(sLine1)) to sLine1
            Move (sLine1 + sLine2) to sLine
        End
        Function_Return bChanged
    End_Function

    // Takes a string like: [not Seqeof] Begin
    // and returns struct as: True, True, "(not(Seqeof))" and "Begin",
    //   _but_ it doesn't do anything with a line that starts with a [Select] stetement;
    //   "[Select] Indicate Select as Windowindex Eq Fieldindex"
    // Note: The brackets _must_ be at the start of code line.
    //       bHasBracket denotes that the line starts with a "[", bHasNot denotes that the expression has a "not" in it.
    Function _ExtractIndicatorContent String sLine Returns tBooleanIndicator
        Integer iPos                                             
        String sText sChar sNot sBoolean sFirstWord sCommand sExpression
        Boolean bRightSideIndicator bFound bIndicateWord
        tBooleanIndicator BooleanIndicator  
        tOperatorsInfo OperatorsInfo
        
        Move False to BooleanIndicator.bHasBracket
        Move False to BooleanIndicator.bHasNot
        Move ""    to BooleanIndicator.sCode
        Move ""    to BooleanIndicator.sExpression
        
        Get IsIndicatorStatement sLine to bFound
        Move (Lowercase(sLine) contains Lowercase(CS_Indicate)) to bIndicateWord
        If (bFound = False and bIndicateWord = False) Begin
            Function_Return BooleanIndicator
        End
        Move (Trim(sLine)) to sText 
        Get _OverstrikeStrings sText to sText
        Move (sText contains "[" and sText contains "]") to BooleanIndicator.bHasBracket  
        
        Move "" to sNot
        Get _RetrieveFirstWord sText to sFirstWord
        // Is the indicator placed on the right hand side of the command?
        Move (Pos("[", sFirstWord) = 0) to bRightSideIndicator
        If (bRightSideIndicator = True) Begin
            Move (Pos("[", sText)) to iPos
            Move (Mid(sText, Length(sText), iPos)) to sBoolean
        End
        Else Begin
            Move (Pos("]", sText)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sText, iPos)) to sBoolean 
                Move (Mid(sText, Length(sText), (iPos + 1))) to sFirstWord
                Move sFirstWord to BooleanIndicator.sCode
            End
        End
        Move (Trim(sFirstWord)) to sCommand
        Move (Replaces("[", sBoolean, "")) to sBoolean
        Move (Replaces("]", sBoolean, "")) to sBoolean
        Move (Trim(sBoolean)) to sBoolean

        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sBoolean, Length(sBoolean), (iPos + 4))) to sBoolean
            Move (String(CS_Not)) to sNot
        End                    
        If (sNot <> "") Begin
            Move ("(" + String(sBoolean) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression 
            Move True to BooleanIndicator.bHasNot
        End 
        Else If (Lowercase(sBoolean) = Lowercase(CS_Finderr)) Begin
            Move ("(" + CS_Found * " = " * CS_False + ")") to BooleanIndicator.sExpression
        End
        Else Begin                
            Get IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Get _ExtractParenthesisExpression sText to BooleanIndicator.sExpression
                If (BooleanIndicator.sExpression = "") Begin
                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to BooleanIndicator.sExpression
                End
//                Move True to BooleanIndicator.bHasNot 
                Move sLine to sCommand
            End
            Else Begin
                Move ("(" + String(sBoolean) + ")") to BooleanIndicator.sExpression
                Move False to BooleanIndicator.bHasNot
            End
        End
        Move (Trim(sCommand)) to BooleanIndicator.sCode
            
        Function_Return BooleanIndicator
    End_Function
    
    // Tries to find the first DataFlex command found in the passed string.
    // Returns the starting pos of that same command (or 0 if not found).
    Function _FindFirstCommand String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommands

        Move 0 to iPos
        Move (" " + sTest) to sTest
        Get _RemoveComments (&sTest) to bRemoved
        Get paCommands to asCommands
        Move (SizeOfArray(asCommands)) to iSize
        If (iSize = 0) Begin
            Send AddAllCommands
            Get paCommands to asCommands
            Move (SizeOfArray(asCommands)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommands[iCount] to sCommand
            Move (Pos(" " + Lowercase(sCommand), Lowercase(sTest))) to iTest // The command MUST start with a space and MIGHT end with a space.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop              
        // We added a beginning " " at the top of this function, so adjust for that now.
//        If (iPos = 1) Begin
//            Move 0 to iPos
//        End
        Function_Return iPos
    End_Function
    
    // Parses the method name from the string
    Function _MethodName String sMethod Returns String
        Integer iPos
        Get _RemoveFirstWord sMethod to sMethod
        Move (Right(sMethod, (Length(sMethod) - iPos))) to sMethod
        If (Uppercase(Left(Trim(sMethod), 4)) = "SET ") Begin
            Get _RemoveFirstWord sMethod to sMethod
        End
        // Remove any trailing arguments
        Move (Pos(" ", sMethod)) to iPos
        Function_Return (Left(sMethod, (iPos - 1)))
    End_Function

    // For declarations like "string [] saAddress"
    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
        Boolean bChanged
        String sText
        Move sLine to sText
        While (Pos(" [", sText) > 0)
          Move (Replace(" [", sText, "[")) to sText
        Loop                                       
        Move (sLine = sText) to bChanged
        Function_Return bChanged
    End_Function

    //  This will pad out the strings in a line and overstrike them
    //  with _ characters for a "string" and + characters for a 'string'
    Function _OverstrikeStrings String sLine Returns String
        Boolean bDoubleQuote bSingleQuote bChanged
        Integer iChar iLength
        String  sChar sText

        Move False to bChanged 
        Move sLine to sText
        Move (Length(sText)) to iLength
        For iChar from 1 to iLength
            Move (Mid(sText, 1, iChar)) to sChar
            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
                Move True to bChanged
                Move " " to sChar
            End
            If (bDoubleQuote and sChar= '"') Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bDoubleQuote
            End
            If (bSingleQuote and sChar = "'") Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bSingleQuote
            End
            If (bSingleQuote = False and sChar ='"') Begin
                Move True to bDoubleQuote
            End
            If (bDoubleQuote = False and sChar = "'") Begin
                Move True to bSingleQuote
            End
            If bDoubleQuote Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
            End
            Else If bSingleQuote Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
            End
        Loop

        If (bChanged = True) Begin
            Move sText to sLine
        End
        Function_Return sLine
    End_Function

    Function _RemoveComments String ByRef sLine Returns Boolean
        Boolean bRemoved
        Integer iPos

        Move False to bRemoved
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, iPos - 1)) to sLine
            Move True to bRemoved
        End
        Function_Return bRemoved
    End_Function    

    // Returns an end comment if exists. It also removes the end comment
    // from the passed string.
    Function _RemoveEndComment String sLine Returns String
        Integer iPos
        String sTest

        Move (Trim(sLine)) to sTest
        Move (Pos(CS_CommentSymbol, sTest)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (Pos(CS_CommentSymbol, sLine)) to iPos
            Move (Left(sLine, iPos - 1)) to sLine
        End
        Function_Return sLine
    End_Function

    // Removes the first word of any input string
    // all up to the first space encountered
    Function _RemoveFirstWord String sLine Returns String
        Integer iPos
        Boolean bChanged
        Move (Trim(sLine)) to sLine
        Get _NormalizeArrayNotation (&sLine) to bChanged
        Move (Pos(" ", sLine)) to iPos
        Function_Return (Right(sLine, (Length(sLine) - iPos)))
    End_Function

    // Returns the first word of any input string
    // all up to the first space encountered
    Function _RetrieveFirstWord String sLine Returns String
        String sFirstWord
        Boolean bChanged
        Get _RemoveFirstWord sLine            to sFirstWord
        Move (Replace(sFirstWord, sLine, "")) to sFirstWord
        Move (Trim(sFirstWord))               to sFirstWord
        Get _NormalizeArrayNotation (&sFirstWord) to bChanged
        Function_Return sFirstWord
    End_Function

    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
    // RemoveLeft("D", "ABC")                   -> "ABC"
    // RemoveLeft("is ", "This is an example")  -> "an example"    
    // Note: It it also looks within strings aka "This is a string"
    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
        Integer iPosStart iPosEnd 
        String sText
        
        Move sHostString to sText
        Move (Pos(sSubString, sText)) to iPosStart
        Move (iPosStart + Length(sSubString) - 1) to iPosEnd

        If (iPosStart) Begin                                
            If (iPosEnd = Length(sText)) Begin
                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
            End 
            Else Begin
                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
            End
        End                                              
        
        Function_Return (sHostString <> sText)
    End_Function

    // Helper function
    Function _RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
        Boolean bChanged
        String sText
        Integer iPos

        Move False to bChanged
        Move (LTrim(sLine))     to sText
        Move (Left(sText, 9))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = "property ") Begin
            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
            If (iPos = 0) Begin // if there's a tab char instead of a space then..
                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
            End
            If (iPos > 0) Begin
                Move (Overstrike(Repeat(" ", Length(sPubPriv)), sLine, iPos + 1)) to sLine // skip first character, don't overwrite a tab with a space
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // helper function for IsKeywordInLine, when a keyword is found in a string declaration
    Function _RemoveStringsFromLine String sLine Returns String
        Integer iLength iPos
        Boolean bSep1 bSep2
        String  sChar sSep1 sSep2 sReturn

        Move False to bSep1
        Move False to bSep2
        Move "'" to sSep1
        Move '"' to sSep2
        Move ""  to sReturn
        Move (Length(sLine)) to iLength

        For iPos from 1 to iLength
            Move (Mid(sLine, 1, iPos)) to sChar
            If (bSep1 = False and bSep2 = False) Begin
                If (sChar = sSep1) Begin
                    Move True to bSep1
                End
                Else If (sChar = sSep2) Begin
                    Move True to bSep2
                End
                If (bSep1 = False and bSep2 = False) Begin
                    Move (sReturn + sChar) to sReturn
                End
            End
            Else Begin
                If (bSep1) Begin
                    If (sChar = sSep1) Begin
                        Move False to bSep1
                    End
                End
                Else If (bSep2) Begin
                    If (sChar = sSep2) Begin
                        Move False to bSep2
                    End
                End
            End
        Loop

        Function_Return sReturn
    End_Function

    Function _SingleCommandSyntaxToFunction String ByRef sLine String sKeyWord Returns Boolean
        Boolean bChanged bIsCommentOrBlank bFound bIfStatement bIsFirstKeyWord
        tCodeComponents CodeComponents
        String sText sLowerKeyWord sLowerCase sFirstWord sExpression
        Integer iPos
        
        Move False to bChanged
        Move False to bIsFirstKeyWord  
        Move "" to sExpression
        Move sLine to sText
        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End      
        
        Get HasCommand sText sKeyWord to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Get IsIfCommand sText to bIfStatement
        Move (Lowercase(sKeyWord)) to sLowerKeyWord
        If (bIfStatement = False) Begin
            Get _RetrieveFirstWord sText to sFirstWord
            If (Lowercase(sFirstWord) = Lowercase(sKeyWord)) Begin
                Get _RemoveFirstWord sText to sText
            End    
//            If (Lowercase(sFirstWord) <> sLowerKeyWord) Begin
//                Function_Return False
//            End
        End
        If (bIfStatement = True) Begin
            Get ExpressionExtractor sText CI_LeftExpression to sExpression  
            If (Trim(sExpression) <> "") Begin
                Move (Pos(sExpression, sText)) to iPos
                Move (Mid(sText, Length(sText), (iPos + Length(sExpression)))) to sText
                Move (Mid(sLine, Length(sLine), (iPos + Length(sExpression)))) to sLine
            End
            // Do we still have the keyword in the line?
            Get HasCommand sText sKeyWord to bFound
            If (bFound = False) Begin   
                Move (String(sExpression) + String(sLine)) to sLine 
                If (bIfStatement = True) Begin
                    Move (CS_If * String(sLine)) to sLine
                End
                Function_Return False
            End
        End
        
//        Move (Pos(sLowerKeyWord, Lowercase(sText))) to iPos
        Move sLine to sText
        Get Tokenizer sText to CodeComponents
        
        // If the line starts with the Key word.
//        If (Pos(sLowerKeyWord, Lowercase(CodeComponents.sCode)) = 1) Begin
//            Move (sLowerKeyWord + " ") to sLowerKeyWord
//        End                                  
//        Else Begin
//            Move (" " + String(sLowerKeyWord) + " ") to sLowerKeyWord
//        End
//        Move (Lowercase(CodeComponents.sCode) contains sLowerKeyWord) to bFound
        Get _RetrieveFirstWord sText to sFirstWord
        Move (Lowercase(sFirstWord) = Lowercase(sKeyWord)) to bFound
        If (bFound = False) Begin      
//            If (sExpression <> "") Begin
//                Move (CS_If * String(sExpression) + String(sLine)) to sLine
//            End
            Function_Return False
        End
        
        Move (Lowercase(CodeComponents.sCode)) to sText
        Move (Mid(CodeComponents.sCode, (Length(CodeComponents.sCode)), (Length(sKeyWord) + 1))) to sText
        Move (Ltrim(sText)) to sText   
        If (sKeyWord = CS_Pos) Begin
            Move (Lowercase(sText)) to sLowerCase
            Move (Pos(" in ", sLowerCase)) to iPos
            If (iPos <> 0) Begin
                Move (Overstrike("____", sText, iPos)) to sText
                Move (Replace("____", sText, ", ")) to sText
                Move True to bChanged
            End
        End                                                                                                                              
        If (Length(CodeComponents.sRightComment)  > 0) Begin
            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
            Move True to bChanged
        End
        Else Begin
            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
            Move True to bChanged
        End
        
        Function_Return bChanged
    End_Function

    // Helper function. This is a list of commands that also exists as global build in functions.
    Function _TestCommandFunctions String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommandFunctions

        Move 0 to iPos
        Get _RemoveComments (&sTest) to bRemoved
        Get paCommandFunctions to asCommandFunctions
        Move (SizeOfArray(asCommandFunctions)) to iSize
        If (iSize = 0) Begin
            Send AddAllCommandFunctions
            Get paCommandFunctions to asCommandFunctions
            Move (SizeOfArray(asCommandFunctions)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommandFunctions[iCount] to sCommand
            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop

        Function_Return iPos
    End_Function

    Function HasDoubleExpression String sLine Returns Boolean
        Boolean bFound      
        Integer iCount iSize iOpCount iParanthesis
        String sChar sOperators
        
        Move False to bFound  
        Move 0 to iParanthesis           
        Move "<=>" to sOperators
        Move (Length(sLine)) to iSize
        For iCount from 1 to iSize
            Move (Mid(sLine, 1, iCount)) to sChar
            If (sChar = "(") Begin
                Increment iOpCount          
                Increment iParanthesis
            End
            If (sChar = ")") Begin
                Decrement iOpCount
            End
            If (iParanthesis <> 0 and sOperators contains sChar) Begin
                If (iOpCount = 0) Begin
                    Move True to bFound
                    Move iSize to iCount // We're done.
                End
            End
        Loop
        
        Function_Return bFound
    End_Function
    
    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
    Function HasCommand String sLine String sCommand Returns Boolean
        Boolean bFound bOk
        String sText
        
        Move False to bFound 
        Move sLine to sText
        Get _RemoveComments (&sText) to bOK
//        Move (Trim(sText)) to sText
        Get _OverstrikeStrings sText to sText
        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound
        
        Function_Return bFound
    End_Function
    
    // Returns True iif the source line contains a "Begin" statement.
    Function IsBeginStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Begin) to bFound
        Function_Return bFound
    End_Function   
    
    Function IsBlankLine String sLine Returns Boolean
        Boolean bIsBlank
        
        Move False to bIsBlank
        Move (Trim(sLine)) to sLine
        If (Length(sLine) = 0) Begin
            Move True to bIsBlank
        End
        
        Function_Return bIsBlank        
    End_Function
    
    Function IsCommentLine String sLine Returns Boolean
        Boolean bIsComment
        Integer iPos
        
        Move False to bIsComment
//        Move (Trim(sLine)) to sLine
//        Move (Pos(CS_CommentSymbol, sLine)) to iPos
//        If (iPos = 1) Begin
//            Move True to bIsComment
//        End
        // Replaces all quotes string contents to "_" so we don't get false positives.
        Get _OverstrikeStrings sLine to sLine
        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment
        
        Function_Return bIsComment
    End_Function

    // Returns True if this is a comment line with "//" to the left,
    // or if the line is blank.
    Function IsCommentLineOrBlank String sLine Returns Boolean
        Boolean bIsComment bIsBlank
        
        Get IsCommentLine sLine to bIsComment
        Get IsBlankLine sLine to bIsBlank
        
        Function_Return (bIsComment = True or bIsBlank = True)
    End_Function

    // Returns False if the first line in the passed file is _not_ an automatically generated
    // COM wrapper file created by the Studio.
    // If it returns True, we should not process that file.
    Function IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
        Boolean bIsDFCOMProxyClasses bExists        
        Integer iCh iPos
        String sLine
        
        Move False to bIsDFCOMProxyClasses  
        File_Exist sFileName bExists
        If (bExists = False) Begin
            Error ("The file doesn't exist:" * String(sFileName))
            Function_Return False
        End
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error "No Channel Available for Process: Procedure 'IsDataFlexCOMProxyClassesFile'"
            Function_Return False
        End
        
        Direct_Input channel iCh sFileName
        Readln channel iCh sLine
        Close_Input channel ich
        Send Seq_Release_Channel iCh
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End

        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses
        
        Function_Return bIsDFCOMProxyClasses
    End_Function
    
    // Returns True iif the source line starts with the sCommand statement.
    Function IsFirstWord String sLine String sCommand Returns Boolean
        Boolean bFound
        Integer iPos  
        String sFirstWord
        
        Move (Ltrim(Lowercase(sLine))) to sLine
        Move (Ltrim(Lowercase(sCommand))) to sCommand
        If (sLine = sCommand) Begin
            Function_Return True
        End
        Move (sCommand + " ") to sCommand
        Move (Pos(" ", sLine)) to iPos
        Move (Left(sLine, iPos)) to sFirstWord
        Move (sFirstWord = sCommand) to bFound
        Function_Return bFound
    End_Function   
    
    // Returns True if source line contains a "[Found]", or "[FindErr]".
    Function IsFoundOrFindErrIndicator String sLine Returns Boolean
        Boolean bFound
        Integer iLeft iRight iPos
        String sText
        
        Get IsIndicatorStatement sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get _RemoveComments (&sLine) to bFound
        Get _OverstrikeStrings sLine to sText  
        Send StripConcatenatingSpaces (&sText) sLine
        Move (Pos("[", sLine)) to iLeft
        Move (Pos("]", sLine)) to iRight
        Move (Pos(("[" + Lowercase(CS_Found)), sLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos(("[" + Lowercase(CS_Finderr)), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Finderr) + "]"), sLine)) to iPos
        End
            
        Function_Return (iPos <> 0)    
    End_Function
    
    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
    // Note: The source line must first have been stripped of any comments
    Function IsIfBeginStatement String sLine Returns Boolean
        Boolean bisIfBegin bIsBeginStatement 
        Get IsIfCommand sLine to bisIfBegin
        Get IsBeginStatement sLine to bIsBeginStatement
        Function_Return (bisIfBegin = True and bIsBeginStatement = True)
    End_Function   
    
    Function IsIfCommand String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (CS_If + " ") to bFound
        Function_Return bFound
    End_Function                                                  
    
    Function IsImagePageStartOrEnd String sLine Boolean bCheckImageStart Returns Boolean
        Boolean bFound
        Integer iPos

        Move False to bFound
        Move (Trim(sLine)) to sLine
        If (bCheckImageStart = True) Begin
            Get IsImageStart sLine to bFound
        End
        Else Begin
            Move (Pos(CS_ImageNameEnd, sLine)) to iPos
            If (iPos = 1) Begin
                Move True to bFound
            End
        End

        Function_Return bFound
    End_Function

    Function IsImageStart String sLine Returns Boolean
        Boolean bIsChar
        Integer iPos
        String sChar

        Move False to bIsChar
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_ImageNameStart, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Mid(sLine, 1, 2)) to sChar
            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsChar
        End

        Function_Return bIsChar
    End_Function

    // Returns True if source code contains both a "[" and a "]", but not a "[]"
    Function IsIndicatorStatement String sLine Returns Boolean
        Boolean bFound bIndicatorWord
        Integer iLeft iRight iPos
        String sChar sLeftBracket
        
        Get IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sLine) to bFound
        Get _OverstrikeStrings sLine to sLine
        Move (Left(sLine, 1)) to sChar
        If (sChar = "[") Begin
            Move "[" to sLeftBracket
        End                         
        Else Begin
            Move " [" to sLeftBracket
        End
//        Move (Lowercase(sLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
        Move (bIndicatorWord = True or (sLine contains sLeftBracket and sLine contains "]")) to bFound
        If (bFound = True) Begin
            Move (Pos(sLeftBracket, sLine)) to iLeft
            Move (Pos("]", sLine)) to iRight
            Move ((iRight - iLeft) > 1) to bFound
        End
        Function_Return (bIndicatorWord or bFound)
    End_Function

    // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
    Function IsKeywordInLine String sKeywords String sLine Returns Boolean
        String sKeyword sChar  
        Integer iPos   
        Boolean bOK

        Move (Lowercase(sKeywords)) to sKeywords
        Move (Lowercase(sLine)) to sLine
        Get _RemoveStringsFromLine sLine to sLine
        Move (Pos(" ", sLine)) to iPos
        // Then there is only one "word" in sLine. Check if the sKeywords = sLine
        If (iPos = 0) Begin
            Move (Replace("|", sKeywords, "")) to sKeyword
            If (Trim(sKeyword) = Trim(sLine)) Begin
                Function_Return True
            End
        End
        
        While (sKeywords <> "")
            Move (Left(sKeywords, (Pos("|", sKeywords)))) to sKeyword
            Move (Replace(sKeyword, sKeywords, "")) to sKeywords
            Move (Trim(Replace("|", sKeyword, ""))) to sKeyword
            Move ((sKeyword <> "") and ((Pos((" " + sKeyword + " "), sLine)) <> 0)) to bOK
            If (bOK = False) Begin
                Move ((sKeyword <> "") and ((Pos((sKeyword + " "), sLine)) <> 0) ) to bOK
            End
            // Also check if this might be the very first statement on the sLine 
            If (bOK = True) Begin    
                Move (Left(sKeyword, 1)) to sChar
                // Is this a command?
                If (sChar = "#") Begin
                    Function_Return False
                End
                Else Begin
                    Function_Return True
                End
            End
        Loop
        Function_Return False
    End_Function

    Function IsMethodStart String sLine Returns Boolean
        Boolean bMethodStart

        Get _OverstrikeStrings sLine to sLine
        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 10) = "procedure " or Left(sLine, 9) = "function ") to bMethodStart

        Function_Return bMethodStart
    End_Function

    Function IsMethodEnd String sLine Returns Boolean
        Boolean bMethodEnd

        Get _OverstrikeStrings sLine to sLine
        Get _RemoveEndComment  sLine to sLine
        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 14) = "end_procedure " or Left(sLine, 13) = "end_function ") to bMethodEnd

        Function_Return bMethodEnd
    End_Function

    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>" 
    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator. 
    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
    Function IsLogicalOperators String sLine Returns tOperatorsInfo
        Boolean bHas 
        tOperatorsInfo OperatorsInfo
        
        Get IsCommentLineOrBlank sLine to bHas
        If (bHas = True) Begin
            Function_Return OperatorsInfo
        End
        Get _RemoveComments (&sLine) to bHas
        Get _OverstrikeStrings sLine to sLine 
        Move (Lowercase(sLine)) to sLine

        Case Begin                
            // "Legacy" operators;
            Case (sLine contains " gt ")
                Move (Pos(" gt ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "gt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " ge ")
                Move (Pos(" ge ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ge"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " lt ")
                Move (Pos(" lt ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "lt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " le ")
                Move (Pos(" le ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "le"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " eq ")
                Move (Pos(" eq ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "eq"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " ne ")
                Move (Pos(" ne ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ne"                   to OperatorsInfo.sOperator
                Case Break
            
            // "Modern" operators;
            Case (sLine contains ">")
                Move (Pos(">", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">"                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains ">=")
                Move (Pos(">=", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">="                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<")
                Move (Pos("<", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<"                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<=")
                Move (Pos("<=", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<="                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "=")
                Move (Pos("=", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "="                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<>")
                Move (Pos("<>", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<>"                   to OperatorsInfo.sOperator
                Case Break
            Case Else
                Move -1                     to OperatorsInfo.iPos
                Move False                  to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ""                     to OperatorsInfo.sOperator
        Case End
                
        Function_Return OperatorsInfo
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
    Function IsLegacyOperators String sLine Returns Boolean
        Boolean bHas bFound
        
        Get IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sLine) to bHas
        Get _OverstrikeStrings sLine to sLine 
        Move (Lowercase(sLine)) to sLine

        Case Begin
            Case (sLine contains " gt ")
                Move True to bHas
                Case Break
            Case (sLine contains " ge ")
                Move True to bHas
                Case Break
            Case (sLine contains " lt ")
                Move True to bHas
                Case Break
            Case (sLine contains " le ")
                Move True to bHas
                Case Break
            Case (sLine contains " eq ")
                Move True to bHas
                Case Break
            Case (sLine contains " ne ")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
    Function IsOperators String sLine Returns Boolean
        Boolean bHas
        
        Get _RemoveComments (&sLine) to bHas 
        Get _OverstrikeStrings sLine to sLine

        Case Begin
            Case (sLine contains ">")
                Move True to bHas
                Case Break
            Case (sLine contains ">=")
                Move True to bHas
                Case Break
            Case (sLine contains "<")
                Move True to bHas
                Case Break
            Case (sLine contains "<=")
                Move True to bHas
                Case Break
            Case (sLine contains "=")
                Move True to bHas
                Case Break
            Case (sLine contains "<>")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    Function IsLineEndSemiColon String sLine Returns Boolean
        Boolean bRemoved
        String  sText
        
        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
        Get _RemoveComments (&sLine) to bRemoved
        Move (RTrim(sLine)) to sText
        If (Right(sText, 1) = ";") Begin
            Function_Return True
        End
        Function_Return False
    End_Function

    Function IsLineEndSemiColonOrBegin String sLine Returns Boolean
        Boolean bRemoved
        Boolean bStop
        String  sTest
        
        Move False to bStop
        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
        Get _RemoveComments (&sLine) to bRemoved
        Move (RTrim(sLine)) to sTest
        If (Right(sTest, 1) = ";") Begin
            Move True to bStop
        End
        If (bStop = False) Begin
            Move (Lowercase(sTest)) to sTest
            If (Right(sTest, 5) = "begin") Begin
                Move True to bStop
            End
        End
        Function_Return bStop
    End_Function    
    
    // Returns True iif the source line is a "Loop" statement.
    Function IsLoopStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Loop) to bFound
        Function_Return bFound
    End_Function   

    Function IsMoveCommand String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + String(CS_Move) + " ") to bFound
        If (bFound = False) Begin
            Get HasCommand sLine (String(CS_Move) + " ") to bFound
        End
        Function_Return bFound
    End_Function                                                  
    
    // Returns True iif the source line is a "Until" statement.
    Function IsUntilStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Until) to bFound
        If (bFound = False) Begin
            Get HasCommand sLine (CS_Until + " ") to bFound
            If (bFound = False) Begin
                Get HasCommand sLine (CS_Until) to bFound
            End
        End  
            
        Function_Return bFound
    End_Function   

    Function IsVariableDeclarationLine String sLine Returns Boolean
        Boolean bVariableDeclaration
        String[] asLocalVariableTypes asLocalVariableArrayTypes
        Integer iRetval
        String sFirstWord

        Move False to bVariableDeclaration
        Get pasLocalVariableTypes      to asLocalVariableTypes
        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
        Move (Trim(sLine)) to sLine
        Get _RetrieveFirstWord sLine to sFirstWord
        Move (Uppercase(sFirstWord)) to sFirstWord
        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
        If (iRetval <> -1) Begin
            Move True to bVariableDeclaration
        End
        Else Begin
            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
            If (iRetval <> -1) Begin
                Move True to bVariableDeclaration
            End
        End

        Function_Return bVariableDeclaration
    End_Function

    Function IsVariableInLine String sLine String sVariableName Returns Boolean
        Boolean bIsUseLine
        String sChar
        Integer iPos

        Move False to bIsUseLine
        Move (Uppercase(sLine)) to sLine
        Move (Uppercase(sVariableName)) to sVariableName

        If (sLine contains sVariableName) Begin
            Move (Pos(sVariableName, sLine)) to iPos
            If (iPos > 0) Begin
                Repeat
                    Move (Mid(sLine, 1, (iPos - 1))) to sChar
                    If (CS_ValidLeftCharacters contains sChar) Begin
                        Move True to bIsUseLine
                    End
                    If (bIsUseLine = False) Begin
                        Move (Replace(sVariableName, sLine, "")) to sLine
                        Move (Pos(sVariableName, sLine)) to iPos
                    End
                Until (bIsUseLine = True or iPos = 0)
            End
        End

        Function_Return bIsUseLine
    End_Function

    Function IsProjectObjectStructureLine String sLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine
        Integer iPos iSize
        String sObjectName

        Move (Trim(sLine)) to sLine
        Move True to bWriteLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Lowercase(sLine)) to sLine
            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
            If (bWriteLine = False) Begin
                Move (SizeOfArray(asObjectNames)) to iSize
                Move (Pos(" is a", sLine)) to iPos
                Move (Left(sLine, (iPos -1))) to sObjectName
                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
                Move (Trim(sObjectName)) to sObjectName
                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
            End
        End
        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
            Move False to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // Returns True iif the source line contains a "Repeat" statement.
    Function IsRepeatStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Repeat) to bFound
        Function_Return bFound
    End_Function   
    
    Function IsRegisterObjectInArray String sLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine bRegisterObjectStart
        Integer iPos

        Move False to bWriteLine
        Get IsRegisterAllObjectsStart sLine to bRegisterObjectStart
        If (bRegisterObjectStart = False) Begin
            Move (Lowercase(sLine)) to sLine
            Move (Replace("register_object", sLine, "")) to sLine
            Move (Trim(sLine)) to sLine
            Move (SearchArray(sLine, asObjectNames)) to iPos
            Move (iPos = -1) to bWriteLine
        End

        Function_Return bWriteLine
    End_Function

    Function IsStudioGeneratedComment String sLine String sComment Returns Boolean
        String sText
        
        Move (Lowercase(sLine)) to sText      
        
        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
            Function_Return True 
        End
        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) Begin
            Function_Return True 
        End                 
        
        Function_Return False
    End_Function
    
    // Returns True iif the source line contains a "While" statement.
    Function IsWhileStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (CS_While + " ") to bFound
        Function_Return bFound
    End_Function   
    
    Function IsProjectObjectStructureStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterAllObjectsStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterAllObjectsEnd String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        String sFirstWord

        Move False to bFound
        Move (Lowercase(sLine)) to sLine
        Move (Trim(sLine)) to sLine
        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
            Move (Pos(" ", sLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sLine, (iPos -1))) to sFirstWord
                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
            End
        End
        Function_Return bFound
    End_Function

    Function IsRegisterObjectLine String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        Move False to bFound
        Move (Pos(CS_RegisterObject, sLine)) to iPos
        If (iPos = 1) Begin
            Move True to bFound
        End
        Function_Return bFound
    End_Function

    // Tests if the lowercase character passed in sLine on position iPos is
    // a valid character for a class name
    Function IsValidClassCharacter String sLine Integer iPos Returns Boolean
        Boolean bIsValid
        String  sChar
        Move False to bIsValid
        Move (Mid(sLine, 1, iPos)) to sChar
        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
            Move True to bIsValid
        End
        Function_Return bIsValid
    End_Function
      
    // (nicked from cSciLexer.pkg)
    // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter counting.
    // We reduce the spaces here to just one.
    Procedure StripConcatenatingSpaces String ByRef sText
        While (Pos("  ", sText) <> 0)
            Move (Replaces("  ", sText, " ")) to sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
        Loop
    End_Procedure

    Procedure AddCommand String sCommand
        String[] Commands

        Get paCommands to Commands
        Move (Lowercase(sCommand)) to sCommand
        Move sCommand to Commands[SizeOfArray(Commands)]
        Set paCommands to Commands
    End_Procedure

    Procedure AddCommandFunction String sCommand
        String[] aCommandFunctions

        Get paCommandFunctions to aCommandFunctions
        Move (Lowercase(sCommand)) to sCommand
        Move sCommand to aCommandFunctions[SizeOfArray(aCommandFunctions)]
        Set paCommandFunctions to aCommandFunctions
    End_Procedure

    // Command list used for testing against inline if/else statements et. al.
    // Note that it is not a complete command list and that we should be careful
    // about commands that might be used as functions or in functions!
    // For example, it is by intention that none of the variable declaration commands
    // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
    //
    // All commands can be entered case insensitive
    // Standalone commands can end on a end of line, such as Abort.
    // Other commands need more parameters and in such case we can improve our success rate
    // by adding a space character.
    //
    Procedure AddAllCommands
        String[] Empty

        Set paCommands to Empty

        //Send AddCommand "Repeat"  // nope, it is a function too
        Send AddCommand "Abort"
        Send AddCommand "Abort_Transaction"
        Send AddCommand "Activate_View "
        Send AddCommand "Add "
        Send AddCommand "Address "
        Send AddCommand "Append "
        Send AddCommand "Append_Output "
        Send AddCommand "Attach "
        Send AddCommand "Begin_Constraints"
        Send AddCommand "Begin_Transaction"
        Send AddCommand "Broadcast "
        Send AddCommand "Broadcast_Focus "
        Send AddCommand "Calc "
        Send AddCommand "Calculate "
        Send AddCommand "Call_Driver "
        Send AddCommand "CallStackDump "
        Send AddCommand "Case "
        Send AddCommand "Clear "
        Send AddCommand "Close "
        Send AddCommand "Close_Input"
        Send AddCommand "Close_Output"
        Send AddCommand "Constrain "
        Send AddCommand "Constrained_Clear "
        Send AddCommand "Constrained_Find "
        Send AddCommand "Constraint_Set"
        Send AddCommand "Constraint_Validate"
        Send AddCommand "Copy_db "
        Send AddCommand "Copy_Records "
        Send AddCommand "Copyfile "
        Send AddCommand "Create_Field "
        Send AddCommand "Create_Index "
        Send AddCommand "Declare_DataFile "
        Send AddCommand "Decrement "
        Send AddCommand "Delegate "
        Send AddCommand "Delete "
        Send AddCommand "Delete_db "
        Send AddCommand "Delete_Field "
        Send AddCommand "Delete_Index "
        Send AddCommand "Direct_Input "
        Send AddCommand "Direct_Output "
        Send AddCommand "DiskFree "
        Send AddCommand "EraseFile "
        Send AddCommand "Error "
        Send AddCommand "Field_Map "
        Send AddCommand "File_Exist "
        Send AddCommand "Fill_Field "
        Send AddCommand "Find "
        Send AddCommand "For "
        Send AddCommand "For_All "
        Send AddCommand "Forward "
        Send AddCommand "Function_Return " // you might have code that does not return a value, I'd consider that a warning
        Send AddCommand "Get "
        Send AddCommand "Get_Argument_Size "
        Send AddCommand "Get_Attribute "
        Send AddCommand "Get_Channel_Position "
        Send AddCommand "Get_Channel_Size "
        Send AddCommand "Get_Current_Directory "
        Send AddCommand "Get_Current_Input_Channel "
        Send AddCommand "Get_Current_Output_Channel "
        Send AddCommand "Get_Current_User_Count "
        Send AddCommand "Get_Date_Attribute "
        Send AddCommand "Get_Directory "
        Send AddCommand "Get_Environment "
        Send AddCommand "Get_Field_Value "
        Send AddCommand "Get_FieldNumber "
        Send AddCommand "Get_File_Mod_Time "
        Send AddCommand "Get_File_Path "
        Send AddCommand "Get_FileNumber "
        Send AddCommand "Get_Licensed_Max_Users "
        Send AddCommand "Get_StrictEval "
        Send AddCommand "Get_Transaction_Retry "
        Send AddCommand "Get_Windows_Directory "
        Send AddCommand "GetAddress "
        Send AddCommand "GetBuff "
        Send AddCommand "GetBuff_String "
        Send AddCommand "GetDskInfo "
        Send AddCommand "Global_Variable "
        Send AddCommand "Include_Resource "
        Send AddCommand "Increment "
        Send AddCommand "Indicate "
        Send AddCommand "Indicator "
        Send AddCommand "Load_Def "
        Send AddCommand "Load_Driver "
        Send AddCommand "Lock"
        Send AddCommand "Login "
        Send AddCommand "Logout"
        Send AddCommand "Make_Directory "
        Send AddCommand "Make_File "
        Send AddCommand "Make_Temp_File "
        Send AddCommand "Move "
        Send AddCommand "Movedate "
        Send AddCommand "Moveint "
        Send AddCommand "Movenum "
        Send AddCommand "Movereal "
        Send AddCommand "Movestr "
        Send AddCommand "NewRecord "
        Send AddCommand "On_Item"
        Send AddCommand "On_key "
        Send AddCommand "Open "
        Send AddCommand "Output "
        Send AddCommand "Output_Aux_File "
        Send AddCommand "Output_Wrap"
        Send AddCommand "Playwave "
        Send AddCommand "Procedure_Return"
        Send AddCommand "Property "
        Send AddCommand "Put "
        Send AddCommand "Read "
        Send AddCommand "Read_Block "
        Send AddCommand "Read_hex "
        Send AddCommand "Readln "
        Send AddCommand "Reg_Close_Key "
        Send AddCommand "Reg_Enum_Key "
        Send AddCommand "Reg_Enum_Key_Info "
        Send AddCommand "Reg_Enum_Value "
        Send AddCommand "Relate "
        Send AddCommand "Remove_Directory "
        Send AddCommand "Renamefile "
        Send AddCommand "Report_Breaks "
        Send AddCommand "Reread"
        Send AddCommand "RunProgram "
        Send AddCommand "Save "
        Send AddCommand "SaveRecord "
        Send AddCommand "Send "
        Send AddCommand "Set "
        Send AddCommand "Set_Argument_Size "
        Send AddCommand "Set_Attribute "
        Send AddCommand "Set_Channel_Position "
        Send AddCommand "Set_Date_Attribute "
        Send AddCommand "Set_Directory "
        Send AddCommand "Set_Field_Value "
        Send AddCommand "Set_File_Mod_Time "
        Send AddCommand "Set_Foreign_Profile_String "
        Send AddCommand "set_registry_root "
        Send AddCommand "Set_Relate "
        Send AddCommand "Set_StrictEval "
        Send AddCommand "Set_Transaction_Retry "
        Send AddCommand "Shift_State "
        Send AddCommand "Show "
        Send AddCommand "Showln"
        Send AddCommand "Sleep "
        Send AddCommand "Sort "
        Send AddCommand "Start_UI"
        Send AddCommand "Structure_Abort "
        Send AddCommand "Structure_Copy "
        Send AddCommand "Structure_End "
        Send AddCommand "Structure_Start "
        Send AddCommand "Subtract "
        Send AddCommand "Sysdate "
        Send AddCommand "Sysdate4 "
        Send AddCommand "Unload_Driver "
        Send AddCommand "Unlock"   
        Send AddCommand "Until"
        Send AddCommand "Valid_Drive "
        Send AddCommand "ValueTreeDeserializeParameter "
        Send AddCommand "ValueTreeSerializeParameter "
        Send AddCommand "VConstrain "
        Send AddCommand "Version_Information "
        Send AddCommand "VFind "
        Send AddCommand "Virtual_Key "
        Send AddCommand "WebGet "
        Send AddCommand "WebPublishFunction "
        Send AddCommand "WebPublishProcedure "
        Send AddCommand "WebSet "
        Send AddCommand "WebSetResponsive "
        Send AddCommand "While "
        Send AddCommand "Write "
        Send AddCommand "Write_Hex "
        Send AddCommand "WriteLn"
        Send AddCommand "ZeroFile "
        Send AddCommand "ZeroString "
        Send AddCommand "ZeroType "
    End_Procedure

    Procedure AddAllCommandFunctions
        String[] Empty

        Set paCommandFunctions to Empty

        Send AddCommandFunction "Repeat"  
        Send AddCommandFunction "If "
        Send AddCommandFunction "Else "  
        Send AddCommandFunction "Pos"
        Send AddCommandFunction "Insert"
    End_Procedure

//    Procedure Activating
//        Send AddAllCommands  
//        Send AddAllCommandFunctions
//    End_Procedure

    // splits a line to a string array.
    // Ignores any special characters, spaces or new line, CR "multi line"
    Function SplitTextByLengthPure String sText Integer iCount Returns String[]
        String sLine
        String[] saText
    
        Move sText to sLine
    
        While (Length(sLine) > 0)
            Move (Mid(sLine, iCount, 1)) to saText[(SizeOfArray(saText))]
            Move (Mid(sLine, (Length(sLine) - iCount), (iCount + 1))) to sLine
        Loop
    
        Function_Return saText
    End_Function

    // Splits a string to a string array.
    Function Split String sSplitKey String sText Returns String[]
        String[] sArray
        Integer iLeftPos
        Boolean bAtLeastOneSplit
    
        Move (ResizeArray(sArray, 0)) to sArray
        If ((sSplitKey = "") and ((Length(sSplitKey)) = 0)) Begin
            For iLeftPos from 1 to ((Length(sText)))
                Move (Mid(sText, 1, iLeftPos)) to sArray[SizeOfArray(sArray)]
            Loop
        End
        Else Begin
            Move (Pos(sSplitKey, sText)) to iLeftPos
    
            While (iLeftPos > 0)
                Move True to bAtLeastOneSplit
                Move (Left(sText, iLeftPos - 1)) to sArray[SizeOfArray(sArray)]
                Move (Right(sText, ((Length(sText) - (iLeftPos + (Length(sSplitKey))) )+1))) to sText
                Move (Pos(sSplitKey, sText)) to iLeftPos
            Loop
    
            // Ta med text hger om sista splittecknet
            Move sText to sArray[SizeOfArray(sArray)]
        End
    
        Function_Return sArray
    End_Function

    // Create a string by joining array elements using a separator
    Function JoinArray Global String[] saValues String sSeparator Returns String
        Integer i iLength
        String sRet
        Move "" to sRet
        Move (SizeOfArray(saValues)-1) to iLength
        For i from 0 to iLength
            // First element
            If (i = 0) Begin
                Append sRet saValues[i]
            End
            // Other elements
            Else Begin
                Append sRet sSeparator saValues[i]
            End
        Loop
        Function_Return sRet
    End_Function

    // Convert Integer to a binary value
    // Courtesy of Frank Cheng.
    Function IntToBinary Global Integer i Returns String
        String sResult
        If (i < 0) Function_Return ""
        Move "" to sResult
        Repeat
            Move (String(Mod(i, 2)) + sResult) to sResult
            Move (i / 2) to i
        Until (i = 0)
        Function_Return sResult
    End_Function

    // Courtesy of Frank Cheng.
    // There is another verion (HexToInt) in mStrConv.pkg
    Function HexToInt2 Global String sNum Returns Integer
        Integer iLength iDigit iNum iPower
        Move (Length(sNum)) to iLength
        Move 1 to iPower
        Move 0 to iNum
        While (iLength > 0)
            Move (Ascii(Mid(sNum,1,iLength))) to iDigit
            Subtract (If(iDigit > 57, 55, 48)) from iDigit
            Add (iDigit * iPower) to iNum
            Move (iPower * 16) to iPower
            Decrement iLength
        Loop
        Function_Return iNum
    End_Function

    // Curtesy of Evertjan Dondergoor DAE
    Function SQLDateTimeToDFDateTime String s Returns DateTime
        DateTime dt
        Integer iYear iMonth iDay
        Integer iHour iMinute iSecond

        Move (Mid(s, 4,  1)) to iYear
        Move (Mid(s, 2,  6)) to iMonth
        Move (Mid(s, 2,  9)) to iDay
        Move (Mid(s, 2, 12)) to iHour
        Move (Mid(s, 2, 15)) to iMinute
        Move (Mid(s, 2, 18)) to iSecond

        Move (DateSetYear  (dt, iYear  )) to dt
        Move (DateSetMonth (dt, iMonth )) to dt
        Move (DateSetDay   (dt, iDay   )) to dt
        Move (DateSetHour  (dt, iHour  )) to dt
        Move (DateSetMinute(dt, iMinute)) to dt
        Move (DateSetSecond(dt, iSecond)) to dt

        Function_Return dt
    End_Function

    // Returns True if the "sCheckFieldName" field exists in the passed iFile datbase table.
    // If it doesn't exist, False is returned
    Function IsFieldExisting Integer iFile String sCheckFieldName Returns Boolean
        Integer iNumFields iCount                                      
        String sFieldName
      
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
        Decrement iNumFields
        For iCount from 0 to iNumFields  
            Get_Attribute DF_FIELD_NAME of iFile iCount to sFieldName        
            If ((Uppercase (sFieldName)) = (Uppercase (sCheckFieldName))) Begin
                Function_Return True
            End
        Loop
      
        Function_Return False
    End_Function

// NOTE: Do *not* add any code after this "End_Class"!
//       It will be removed by the Export/Import logic.
End_Class
