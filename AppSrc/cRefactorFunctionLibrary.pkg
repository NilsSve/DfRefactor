Use cBaseRefactorFunctionLibrary.pkg

Class cRefactorFunctionLibrary is a cBaseRefactorFunctionLibrary

    Procedure Construct_Object
        Forward Send Construct_Object
    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
    End_Procedure

    // *** External function package(s) must be included here. ***
    // Use this to add your own special function package.
// Define CS_Use_MyPackage for "UseMyPackage"
    #IFDEF CS_Use_MyPackage
//        #Include MyRefactorFunctions.pkg
    #ENDIF

    // This must be called *once* per source line, *before* any refactor function is called.
    // It calls the Tokenizer function and sets the class property pTokenizer that can then be
    // used by all refactor functions.
    Procedure SetTokenizerProperty String sLine
        tTokenizer TokenizerData
        Get Tokenizer sLine to TokenizerData
        Set pTokenizer to TokenizerData
    End_Procedure

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "Current_Object" to "Self"
    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
        String sStart sStop
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData

        Get pTokenizer to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos = 0) Begin
            Function_Return False
        End
        Move (Left(sLine, (iPos -1))) to sStart
        Move (Mid(sLine, Length(sLine), (iPos + Length(CS_Current_Object)))) to sStop
        Move (sStart + CS_Self + String(sStop)) to sLine

        // Note! We call ourself recursively, if there is more than one "current_object".
        Move (Pos(Lowercase(CS_Current_Object), Lowercase(sLine))) to iPos
        If (iPos <> 0) Begin
            Get ChangeCurrent_ObjectToSelf (&sLine) to bFound
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
        String sText sIndicator sCommand sEndString
        Boolean bFound
        Integer iPos

        Move sLine to sText
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Lowercase(sText)) to sText
        While (bFound = True)
            Move (Pos(Lowercase(CS_DfTrue), sText)) to iPos
            If (iPos > 0) Begin
                Move (Overstrike("||", sText, iPos)) to sText
                Move (Overstrike("||", sLine, iPos)) to sLine
            End
            Move (iPos > 0) to bFound
            Move (Pos(Lowercase(CS_DfFalse), sText)) to iPos
            If (iPos > 0) Begin
                Move (Overstrike("||", sText, iPos)) to sText
                Move (Overstrike("||", sLine, iPos)) to sLine
            End
            If (bFound = False) Begin
                Move (iPos > 0) to bFound
            End
        Loop

        Move (Replaces("||", sLine, "")) to sLine
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes [Found] Reread (and other commnds _except Loop, While, [Select], and If & Begin
    //     to: If (Found) command
    Function ChangeFoundAndFindErrIndicators String ByRef sLine String sParameter Returns Boolean
        String sText sIndicator sCommand sEndString
        Boolean bChanged bFound
        Integer iPos
        tTokenizer TokenizerData
        tBooleanIndicator BooleanIndicator

        Move sLine to sText
        Get IsFoundOrFindErrIndicator sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get Tokenizer sLine to TokenizerData
        Get _ExtractIndicatorContent TokenizerData.sCode to BooleanIndicator
        Move (Lowercase(BooleanIndicator.sExpression) contains Lowercase(CS_Found)) to bFound
        // [Finderr]
        If (bFound = False) Begin
            Move ("(" + String(CS_Found) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression
        End

        Move (Pos(" ", TokenizerData.sCode)) to iPos
        Move (Mid(TokenizerData.sCode, Length(TokenizerData.sCode), (iPos + 1))) to TokenizerData.sCode
        // Must check that it isn't a "Repeat" or "While" or "Loop" command

        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Repeat)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Loop)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_While)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Select)) to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move "" to sEndString
        If (TokenizerData.sOfStatement <> "") Begin
            Move (" " + String(TokenizerData.sOfStatement)) to sEndString
        End
        If (TokenizerData.sToStatement <> "") Begin
            Move (sEndString * String(TokenizerData.sToStatement)) to sEndString
        End
        If (TokenizerData.sEndComment <> "") Begin
            Move (sEndString * TokenizerData.sEndComment) to sEndString
        End

        Move (String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to TokenizerData.sCode
        Move (TokenizerData.sIndentation + String(CS_If) * String(TokenizerData.sCode) * String(sEndString)) to sLine
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes; [Found] Loop --> Loop
    Function ChangeFoundLoopIndicator String ByRef sLine String sParameter Returns Boolean
        tTokenizer TokenizerData
        tBooleanIndicator BooleanIndicator
        String sText
        Boolean bIsLoopStatement bIsRepeatStatement bFound
        Integer iFoundIndicator iPosLoop

        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get IsLoopStatement sLine to bIsLoopStatement
        If (bIsLoopStatement = False) Begin
            Function_Return False
        End

        Get IsRepeatStatement sLine to bIsRepeatStatement
        Get Tokenizer sLine to TokenizerData
        Get _ExtractIndicatorContent TokenizerData.sCode to BooleanIndicator
        If (bIsRepeatStatement = True) Begin
            // We save the start of a Repeat/Loop in a class property, which gets set to False when a Loop statement is found.
            If (BooleanIndicator.bHasBracket = False) Begin
                Set pbInRepeatLoop to True
                Function_Return False
            End
        End

        // If no indicator e.g. "[Found]" before the Loop command, we're done.
        If (BooleanIndicator.bHasBracket = False) Begin
            Set pbInRepeatLoop to False
            Function_Return False
        End

        If (pbInRepeatLoop(Self) = True) Begin
            Move CS_Until to BooleanIndicator.sCode
            Move (String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression)) to TokenizerData.sCode
        End
        Else Begin
            Move CS_Loop to TokenizerData.sCode
        End
        Move (TokenizerData.sIndentation + String(TokenizerData.sCode) + String(TokenizerData.sOfStatement * String(TokenizerData.sToStatement) + String(TokenizerData.sEndComment))) to sLine
        Set pbInRepeatLoop to False

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
    // For the function to do anything, the line needs to contain a "GetAddress" command.
    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
        Boolean bFound
        String sText sToVar sOfVar sCommand
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sText

        // Skip line if it is a comment or blank
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon
        Get _IsLineEndSemiColon sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RetrieveFirstWord sText to sCommand
        If (Lowercase(sCommand) = Lowercase(CS_Function)) Begin
            Function_Return False
        End

        Get Tokenizer sLine to TokenizerData
        Get IsKeywordInLine (CS_GetAddress + "|") TokenizerData.sCode to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        If (TokenizerData.sEndComment <> "") Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.sOfStatement + "))" * CS_To * String(TokenizerData.sToStatement) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + TokenizerData.sOfStatement + "))" * CS_To * String(TokenizerData.sToStatement)) to sLine
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes e.g. "Indicate indicator as True" --> "Move (True) to indicator"
    //              "[Select] Indicate Select as Windowindex Eq Fieldindex"
    Function ChangeIndicateFoundToMoveTrueToFound String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis
        String sText sVariable sExpression sIndicate sChar
        Integer iPos
        tTokenizer TokenizerData

        Move False to bChanged
        Move (Lowercase(sLine)) to sText
        Get _IsCommentLineOrBlank sText to bIsCommentLineOrBlank
        If (bIsCommentLineOrBlank = True) Begin
            Function_Return False
        End

        Move (Ltrim(Lowercase(sText))) to sText
        Move (Pos(Lowercase(CS_Indicate + " "), sText)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End
        Get Tokenizer sLine to TokenizerData
        Move (Pos(" ", TokenizerData.sCode)) to iPos
        Move (Left(TokenizerData.sCode, (iPos -1))) to sIndicate
        If ((Lowercase(sIndicate) + " ") <> (Lowercase(CS_Indicate) + " ")) Begin
            Function_Return False
        End

        Move (Pos(" ", TokenizerData.sCode)) to iPos // Indicate (a < b) as False
        Move (Left(TokenizerData.sCode, (iPos -1))) to sText //   (a < b) as False
        Move (Replace(sText, TokenizerData.sCode, "")) to TokenizerData.sCode
        Move (Trim(TokenizerData.sCode)) to TokenizerData.sCode
        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(TokenizerData.sCode))) to iPos
        Move (Left(TokenizerData.sCode, (iPos -1))) to sExpression // (a < b)
        Move (Replace(sExpression, TokenizerData.sCode, "")) to TokenizerData.sCode //  as False
        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(TokenizerData.sCode))) to iPos
        Move (Mid(TokenizerData.sCode, Length(TokenizerData.sCode), (iPos + Length(CS_As) + 2))) to sVariable
        Move (Left(sVariable, 1)) to sChar
        Move (sChar = "(") to bIsParanthesis
        If (bIsParanthesis = False) Begin
            Move (TokenizerData.sIndentation + CS_Move * "(" + String(sVariable) + ")" * CS_To * String(sExpression) + TokenizerData.sEndComment) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + CS_Move * String(sVariable) * CS_To * String(sExpression) + TokenizerData.sEndComment) to sLine
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes; [Found] Repeat --> While (Found)
    //          [not Seqeof] Repeat --> While (not(Seqeof))
    Function ChangeIndicatorRepeatToWhile String ByRef sLine String sParameter Returns Boolean
        tTokenizer TokenizerData
        tBooleanIndicator BooleanIndicator
        String sChar sText sBoolean sNot sOrgLine
        Boolean bIsRepeatStatement bFound
        Integer iPosIndicator iPosRepeat iPos

        Move sLine to sText
        Move sLine to sOrgLine
        Get IsRepeatStatement sText to bIsRepeatStatement
        If (bIsRepeatStatement = False) Begin
            Function_Return False
        End

        Get Tokenizer sLine to TokenizerData
        Get IsKeywordInLine (CS_Repeat + "|") TokenizerData.sCode to bFound
        Get _ExtractIndicatorContent TokenizerData.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False) Begin
            Function_Return False
        End

        Move (CS_While * BooleanIndicator.sExpression) to TokenizerData.sCode
        Move (TokenizerData.sIndentation + String(TokenizerData.sCode) + String(TokenizerData.sOfStatement * String(TokenizerData.sToStatement) + String(TokenizerData.sEndComment))) to sLine

        Function_Return (sLine <> sOrgLine)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes; E.g. [Found] Begin --> If (Found) Begin
    //               [not Seqeof] Begin --> If (not(Seqeof)) Begin
    Function ChangeIndicatorToIfBegin String ByRef sLine String sParameter Returns Boolean
        tTokenizer TokenizerData
        tBooleanIndicator BooleanIndicator
        String sText sNot sLogical
        Boolean bFound bBegin
        Integer iFoundIndicator iPosBegin iPos

        Move sLine to sText
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get _HasBeginStatement sText to bBegin
        If (bBegin = False) Begin
            Function_Return False
        End

        Get Tokenizer sLine to TokenizerData

        Get _ExtractIndicatorContent TokenizerData.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False) Begin
            Function_Return False
        End
        Move (CS_If * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to TokenizerData.sCode
        If (bBegin = True) Begin
            Move (TokenizerData.sIndentation + String(TokenizerData.sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + String(TokenizerData.sCode) + String(TokenizerData.sOfStatement * CS_To + String(TokenizerData.sToStatement) * String(TokenizerData.sEndComment))) to sLine
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes:
    //     [Select] Indicate Select as Windowindex Eq Fieldindex -->
    //     If (Select) Move (Windowindex = Fieldindex) to Select // Comment
    Function ChangeIndicatorToMoveStateToVariable String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis bStartIndicator bFound bIsIfStatement
        String sText sVariable sExpression sIndicator sChar sOrgLine sIfStatement sCommand
        Integer iPos iStart iEnd
        tTokenizer TokenizerData
        tBooleanIndicator BooleanIndicator

        Move False to bChanged
        Move sLine to sText
        Move sLine to sOrgLine
        Get _IsCommentLineOrBlank sText to bIsCommentLineOrBlank
        If (bIsCommentLineOrBlank = True) Begin
            Function_Return False
        End
        Move (Trim(sText)) to sChar
        If (Left(sChar, 1) = "#") Begin
            Function_Return False
        End
        // While, Repeat, Loop and Until are delt with by other functions.
        Get _HasBeginStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsRepeatStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsLoopStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsUntilStatement sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RetrieveFirstWord sLine to sIfStatement
        Move (Lowercase(sIfStatement) = Lowercase(CS_If)) to bIsIfStatement
        If (bIsIfStatement = True) Begin
            Move "" to sIfStatement
        End

        Get Tokenizer sText to TokenizerData
        Get _ExtractIndicatorContent TokenizerData.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False and TokenizerData.bHasIndicateCommand = False) Begin
            Function_Return False
        End

        // There are other function dealing with loop, while & move statements.
        Get IsRepeatStatement BooleanIndicator.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _HasBeginStatement BooleanIndicator.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsMoveCommand BooleanIndicator.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        If (BooleanIndicator.sCode = "") Begin
            Move TokenizerData.sCode to BooleanIndicator.sCode
        End

        If (Lowercase(BooleanIndicator.sCode) contains Lowercase(CS_Indicate)) Begin
            Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iEnd
            If (iEnd <> 0) Begin
                Move (Pos(Lowercase(CS_Indicate + " "), Lowercase(BooleanIndicator.sCode))) to iStart
                Move (Left(BooleanIndicator.sCode, (iStart + Length(CS_Indicate)))) to sText
                Move (Replace(sText, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
                Move (Pos(Lowercase(CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
                Move (Left(BooleanIndicator.sCode, (iPos - 1))) to sIndicator
                Move (Replace(sIndicator, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
                Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
                Move (Mid(BooleanIndicator.sCode, Length(BooleanIndicator.sCode), (iPos + 1 + Length(CS_As)))) to BooleanIndicator.sCode
                Move (Trim(sIndicator)) to sIndicator
                Move (String(CS_Move) * Trim(BooleanIndicator.sCode) * CS_To * String(sIndicator)) to BooleanIndicator.sCode
                Get IsLegacyOperators BooleanIndicator.sCode to bFound
                If (bFound = True) Begin
                    Move BooleanIndicator.sExpression to sText
                    Get _AddExpressionParenthesis (&sText) to bFound
                    If (bFound = True) Begin
                        Move sText to BooleanIndicator.sExpression
                    End
                End
            End
        End

        If (bIsIfStatement = True) Begin
            Get _RetrieveFirstWord TokenizerData.sCode to sCommand
            If (Lowercase(sCommand) = Lowercase(CS_If)) Begin
                Move (String(TokenizerData.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
            Else Begin
                Move (String(TokenizerData.sIndentation) + String(CS_If) * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
        End
        Else If (BooleanIndicator.sExpression <> "" or BooleanIndicator.sCode <> "") Begin
            If (Left(BooleanIndicator.sExpression, 1) = "(") Begin
                If (TokenizerData.sLineStartIndicator <> "") Begin
                    If (Left(TokenizerData.sLineStartIndicator, 1) <> "(") Begin
                        Move ("(" + String(TokenizerData.sLineStartIndicator) + ")") to TokenizerData.sLineStartIndicator
                    End
                    Move (CS_If * String(TokenizerData.sLineStartIndicator)) to sLine
                    Move BooleanIndicator.sCode to sText
                    Get _AddExpressionParenthesis (&sText) to bFound  // XXXX
                    If (bFound = True) Begin
                        Move sText to BooleanIndicator.sCode
                    End
                    Move (String(sLine) * String(BooleanIndicator.sCode)) to BooleanIndicator.sCode
                    Move "" to BooleanIndicator.sExpression
                End
                Else Begin
                    Move (CS_If * String(BooleanIndicator.sExpression)) to sLine
                    Move (String(TokenizerData.sIndentation) + String(sLine) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
                End
            End
            If (BooleanIndicator.sExpression <> "") Begin
                Move (String(TokenizerData.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
            End
            Else Begin
                Move (String(TokenizerData.sIndentation) + String(BooleanIndicator.sCode)) to sLine
            End
        End

        If (TokenizerData.sOfStatement <> "") Begin
            Move (String(sLine) * CS_Of * String(TokenizerData.sOfStatement)) to sLine
        End
        If (TokenizerData.sToStatement <> "") Begin
            Move (String(sLine) * CS_To * String(TokenizerData.sToStatement)) to sLine
        End
        If (TokenizerData.sEndComment <> "") Begin
            Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
        End
        Function_Return (sLine <> sOrgLine)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: Insert "," In sText At 2 --> Move (Inert(",", sText, 2)) to sText
    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsCommentOrBlank bIsReplace
        String sText sStart sStop sVariableName sPlace sChar
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sText
        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End
        Move (Ltrim(sText)) to sText
        Move (Pos(Lowercase(CS_Insert + " "), Lowercase(sText))) to iPos
        If (iPos < 1) Begin
            Function_Return False
        End

        // Also check that the keyword is not part of a variable name:
        Move (Mid(sText, 1, (iPos -1))) to sChar
        If (sChar <> " " and sChar <> "(") Begin
            Function_Return False
        End

        Get _SingleCommandSyntaxToFunction (&sLine) CS_Insert to bChanged
        Get Tokenizer sLine to TokenizerData
        Move (Replace(TokenizerData.sIndentation, sLine, "")) to sLine
        Send StripConcatenatingSpaces (&sLine)
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Replace("||||", sLine, ", ")) to sLine
        Move (Mid(sLine, Length(sLine), (iPos + 2))) to sStop
        Move (Pos(" ", sStop)) to iPos
        Move (Left(sStop, (iPos -1))) to sVariableName
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_At + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Replace("||||", sLine, ", ")) to sLine

        Move (TokenizerData.sIndentation + String(sLine) * String(sVariableName)) to sLine
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces 'IN' with 'Contains
    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsPosCommand bIsCommentOrBlank bFound
        String sPattern sOrg
        String sMatched sRemain sHost sSub sText sKeyWord sStart
        tRegexMatch[] myReg
        Integer iPos
        tTokenizer TokenizerData

        Move False to bChanged
        Move sLine to sText
        Move sLine to sOrg
        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End

        Get _OverstrikeStrings sText to sText
        Move (Lowercase(sText)) to sText
        Move (Ltrim(sText)) to sText
        // First check if there is a "In" keyword in the source code.
        Move (Lowercase((" " + CS_In + " "))) to sKeyWord
        If (Pos(sKeyWord, sText) = 0) Begin
            Function_Return False
        End

        // Check for "home cocked" commands; in case we do nothing.
        Get Tokenizer sLine to TokenizerData

        // If we are in a "Pos", "Insert" or "Replace" command line, we're done.
        Get IsKeywordInLine (CS_Pos + "|" + CS_Insert + "|" + CS_Replace + "|") TokenizerData.sCode to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        If (TokenizerData.sOfStatement <> "") Begin
            Move (TokenizerData.sCode * CS_Of * String(TokenizerData.sOfStatement)) to sText
        End
        If (TokenizerData.sToStatement <> "") Begin
            Move (TokenizerData.sCode * CS_To * String(TokenizerData.sToStatement)) to sText
        End

        Get _RetrieveFirstWord sText to sStart
        Move (" " + Lowercase(sStart) + " ") to sStart
        Get _FindFirstCommand sStart to iPos
        If (iPos = 0) Begin
            Get _TestCommandFunctions sStart to iPos
        End
        If (iPos = 0) Begin
            Function_Return False
        End

        Move TokenizerData.sCode to sText
        Move (Replaces('`', '(".*"|`.*`|\S+)\s+in\s+(".*"|`.*`|\S+)', "'")) to sPattern
        Get Regex_Match sText sPattern True to myReg
        If (SizeOfArray(myReg)) Begin
            Move myReg[0].Val to sMatched
            Move (Replaces('`', '(".*"|`.*`|\S+)\s+', "'")) to sPattern
            Get Regex_Match sMatched sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sSub
            Move (Trim(Replace(sSub, sMatched, ''))) to sRemain // Remove the subString
            Move (Remove(sRemain,0 ,2)) to sRemain // Remove the 'In'
            Move (Replaces('`', '\s+(".*"|`.*`|\S+)', "'")) to sPattern
            Get Regex_Match sRemain sPattern True to myReg
            Move (Trim(myReg[0].Val)) to sHost

            Move (Replace(sMatched, sText, ("(" + sHost + ' contains ' + sSub + ")"))) to sLine
            If (Length(TokenizerData.sIndentation)) Begin
                Move (TokenizerData.sIndentation + String(sLine)) to sLine
            End
            If (TokenizerData.sOfStatement <> "") Begin
                Move (String(sLine) * String(CS_Of) * String(TokenizerData.sOfStatement)) to sLine
            End
            If (TokenizerData.sToStatement <> "") Begin
                Move (String(sLine) * String(CS_To) * String(TokenizerData.sToStatement)) to sLine
            End
            If (TokenizerData.sEndComment <> "") Begin
                Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
            End
        End

        Function_Return (sLine <> sOrg)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>" for If-Begin lines and While statements.
    // Pass only the code part of a source line.
    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
        String sSource sText sLeftExpression sRightExpression sStart sCommand sFirstChar sLastChar sOrg
        Boolean bFound bChanged
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sText
        Move sLine to sOrg
        // Skip line if it is a comment or blank
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon ?? Should we??
        Get _IsLineEndSemiColon sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsFirstWord sText CS_Find to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsFirstWord sText CS_Send to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsFirstWord sText CS_Constrain to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsLegacyOperators sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        Move (Lowercase(sText)) to sSource

        Move (Pos(" gt ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" >_ ", sText, iPos)) to sText
            Move (Replace(" >_ ", sText, " > ")) to sText
            Move (Pos(" gt ", sText)) to iPos
        Loop

        Move (Pos(" ge ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" >= ", sText, iPos)) to sText
            Move (Pos(" ge ", sText)) to iPos
        Loop

        Move (Pos(" lt ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <_ ", sText, iPos)) to sText
            Move (Replace(" <_ ", sText, " < ")) to sText
            Move (Pos(" lt ", sText)) to iPos
        Loop

        Move (Pos(" le ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <= ", sText, iPos)) to sText
            Move (Pos(" le ", sText)) to iPos
        Loop

        Move (Pos(" eq ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" =_ ", sText, iPos)) to sText
            Move (Replace(" =_ ", sText, " = ")) to sText
            Move (Pos(" eq ", sText)) to iPos
        Loop

        Move (Pos(" ne ", sSource)) to iPos
        While (iPos <> 0)
            Move (Overstrike(" <> ", sText, iPos)) to sText
            Move (Pos(" ne ", sText)) to iPos
        Loop

        Move (String(sText) <> String(sLine)) to bChanged
        If (bChanged = False) Begin
            Function_Return False
        End

        Get Tokenizer sText to TokenizerData
        // For some reason we can get an exception error passing a struct member as
        // a ByRef argument. Just moving to a local variable cures it.
        Move TokenizerData.sCode to sText
        Get _AddExpressionParenthesis (&sText) to bChanged
        If (bChanged = True) Begin
            Move sText to TokenizerData.sCode
        End

        Move (String(TokenizerData.sIndentation + String(TokenizerData.sCode))) to sLine
        If (TokenizerData.sOfStatement <> "") Begin
            Move (String(sLine) * TokenizerData.sOfStatement) to sLine
        End
        If (TokenizerData.sToStatement <> "") Begin
            Move (String(sLine) * String(CS_To) * String(TokenizerData.sToStatement)) to sLine
        End
        If (TokenizerData.sEndComment <> "") Begin
            Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
        End

        Function_Return (sLine <> sOrg)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes "Set Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
    // and     "Set Object_Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
        tTokenizer TokenizerData
        String sCode sState sFirstChar sText
        Boolean bIsComment bIsOfOperator
        Integer iPos

        Get _IsCommentLineOrBlank sLine to bIsComment
        If (bIsComment = True) Begin
            Function_Return False
        End

        Get Tokenizer sLine to TokenizerData
        Move (Trim(sLine)) to sCode
        Move (Lowercase(sCode)) to sCode
        Move (Left(sCode, 1)) to sFirstChar

        // There are two variants of shadow state; Shadow_State and Object_Shadow_State
        Move "et shadow_state " to sText
        Move (Pos(sText, sCode)) to iPos
        If (iPos = 0) Begin
            Move "et object_shadow_state " to sText
            Move (Pos(sText, sCode)) to iPos
        End
        If (iPos = 0) Begin
            Function_Return False
        End

        Move (Pos((" " + Lowercase(CS_To) + " "), sCode)) to iPos
        If (iPos = 0) Begin
            Function_Return False
        End

        Move (Mid(sLine, Length(sLine), (iPos + 3 + Length(TokenizerData.sIndentation)))) to sState // Could also be a variable name (if get statement)
        Move (Replace(TokenizerData.sEndComment, sState, "")) to sState
        Move (" " + Trim(sState)) to sState

        // Set syntax:
        If (sFirstChar = "s") Begin
            If (Lowercase(sState) contains (" " + Lowercase(CS_True))) Begin
                Move (" " + CS_False) to sState
            End
            Else Begin
                If (Lowercase(sState) contains (" " + Lowercase(CS_False))) Begin
                    Move CS_True to sState
                End
                Else Begin
                    If (Lowercase(sState) contains ("(" + Lowercase(CS_Not)) or sState contains ("( " + Lowercase(CS_Not)) or Lowercase(sState) contains (Lowercase(CS_Not + ")")) or Lowercase(sState) contains (Lowercase(CS_Not + " )"))) Begin
                        Move (Replace(CS_Not, sState, "")) to sState
                        Move (Replaces(")", sState, "")) to sState
                        Move (Pos("(", sState)) to iPos
                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
                        Move (Pos("(", sState)) to iPos
                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
                    End
                    Else Begin
                        Move ("(" + CS_Not + "(" + Trim(sState) + "))") to sState
                    End
                End

            End
            If (Length(TokenizerData.sOfStatement)) Begin
                Move (CS_Set * CS_Enabled_State * CS_Of * TokenizerData.sOfStatement * CS_To * String(sState)) to sCode
            End
            Else Begin
                Move (CS_Set * CS_Enabled_State * CS_To * Trim(sState)) to sCode
            End
        End

        // Get Syntax:
        Else If (sFirstChar = "g") Begin
            Move (Lowercase(TokenizerData.sToStatement)) to sText
            Move (Pos(Lowercase(CS_To), sText)) to iPos
            // Remove "To" keyword:
            If (iPos <> 0) Begin
                Move (Mid(TokenizerData.sToStatement, Length(TokenizerData.sToStatement), (iPos + 3))) to TokenizerData.sToStatement
            End
            If (Length(TokenizerData.sOfStatement)) Begin
                Move (CS_Get * CS_Enabled_State * TokenizerData.sOfStatement * CS_To * "(" + CS_Not + "(" + TokenizerData.sToStatement + "))") to sCode
            End
            Else Begin
                Move (CS_Get * CS_Enabled_State * CS_To * "(" + CS_Not + "(" + TokenizerData.sToStatement + "))") to sCode
            End
        End
        If (TokenizerData.sEndComment <> "") Begin
             Move (TokenizerData.sIndentation + String(sCode) * String(TokenizerData.sEndComment)) to sLine
        End
        Else Begin
            Move (TokenizerData.sIndentation + String(sCode)) to sLine
        End

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sText sStart sStop sVariableName sOrg sFirstWord
        Integer iPos
        tTokenizer TokenizerData

        Move sLine to sOrg
        Move sLine to sText
        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get IsKeywordInLine (CS_Replace + "|") sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get Tokenizer sLine to TokenizerData
        // If a "#Replace" command line, we're done.
        Move (Pos(("#"+ CS_Replace), TokenizerData.sCode)) to iPos
        If (iPos <> 0) Begin
            Function_Return False
        End

        Move TokenizerData.sCode to sLine
        Send StripConcatenatingSpaces (&sLine)
        Move (Lowercase(sLine)) to sText

        Get _RetrieveFirstWord sText to sFirstWord
        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
            Get _RemoveFirstWord sLine to sLine
            Get _RemoveFirstWord sText to sText
        End

        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
        Move (Overstrike("||||", sLine, iPos)) to sLine
        Move (Mid(sLine, Length(sLine), (iPos + Length(" " + CS_In + " ")))) to sStop
        Move (Pos(" ", sStop)) to iPos
        Move (Left(sStop, (iPos -1))) to sVariableName
        Move (Replace("||||", sLine, ", ")) to sLine
        Move (Lowercase(sLine)) to sText
        Move (Pos(Lowercase(" " + CS_With + " "), sText)) to iPos
        Move (Overstrike("||||||", sLine, iPos)) to sLine
        Move (Replace("||||||", sLine, ", ")) to sLine

        Move (CS_Move * "(" + CS_Replace + "(" + String(sLine)) to sLine
//        Get Tokenizer sLine to TokenizerData
//        Get _AddExpressionParenthesis (&sLine) to bChanged
        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
            Move (sLine + "))") to sLine
        End

        Move (TokenizerData.sIndentation + String(sLine) * CS_To * String(sVariableName)) to sLine
        If (TokenizerData.sEndComment <> "") Begin
            Move (String(sLine) * String(TokenizerData.sEndComment)) to sLine
        End
        Function_Return (sLine <> sOrg)
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
        String sText
        Boolean bFound
        Integer iPos

        Move (Lowercase(sLine)) to sText
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
        Get IsKeywordInLine (CS_Sysdate4 + "|") sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move (Pos(Lowercase(CS_Sysdate4), sText)) to iPos
        Move (Overstrike("|", sLine, (iPos - 1 + Length(CS_Sysdate4)))) to sLine
        Move (Replace("|", sLine, "")) to sLine
        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_Trim to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bValid bIgnore
        String sTest sClassName sOldStyle sNewStyle
        Integer iPos

        Move False to bChanged
        Move "" to sClassName
        Move (Lowercase(sLine)) to sTest
        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
        Send StripConcatenatingSpaces (&sTest)
        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
        If (Pos(" create u_", sTest)) Begin
            Move (Lowercase(sLine)) to sTest
            Move (Pos("u_", sTest)) to iPos
            Get IsValidClassCharacter sTest iPos to bValid
            While (bValid)
                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
                Increment iPos
                Get IsValidClassCharacter sTest iPos to bValid
            Loop
        End
        If (sClassName <> "") Begin
            Move True to bChanged
            Move sClassName to sOldStyle
            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
            Move ("(RefClass(" + sClassName + "))") to sNewStyle
            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
        End
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Changes: Until [expression] to Until (expression) and the same for the While command.
    Function ChangeUntilAndWhileIndicators String ByRef sLine String sParameter Returns Boolean
        String sText sCommand sNot
        Boolean bFound
        Integer iPos
        tTokenizer TokenizerData
        tBooleanIndicator BooleanIndicator

        Move sLine to sText
        // Skip line if it is a comment or blank
        Get _IsCommentLineOrBlank sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        // Skip line if it contains a semi colon
        Get _IsLineEndSemiColon sText to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Get _HasBeginStatement sText to bFound
        If (bFound = False) Begin
            Get IsUntilStatement sText to bFound
            If (bFound = False) Begin
                Function_Return False
            End
        End
        Get Tokenizer sLine to TokenizerData
        Get _ExtractIndicatorContent TokenizerData.sCode to BooleanIndicator
        If (BooleanIndicator.bHasBracket = False) Begin
            Function_Return False
        End

        Move (TokenizerData.sIndentation + String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression) + TokenizerData.sEndComment) to sLine

        Function_Return True
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
        Function_Return bChanged
    End_Function

    // *** EDITOR FUNCTION ***
    // Pass the whole source file as a string array
    Function EditorDropSelf String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Move False to Err
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorDropSelf)"
            Function_Return 0
        End
        Send RefactorDropSelf of hoEditor
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** EDITOR FUNCTION ***
    // Wrapper functions for the cScintillaEdit editor
    // Note that a full visible instantiation of the cScintillaEdit class
    // should be used for usage, and the phoEditor property for that
    // object _must_ be set to that editor object id.
    //
    Function EditorNormalizeCase String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorNormalizeCase)"
            Function_Return 0
        End
        Send RefactorNormalizeCase of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** EDITOR FUNCTION ***
    Function EditorReIndent String[] ByRef asSourceFile String sParameter Returns Integer
        Handle hoEditor
        Integer iRetval

        Send SaveErrorState
        Get phoEditor to hoEditor
        If (hoEditor = 0) Begin
            Send UserError "phoEditor = 0 (Function: EditorReIndent)"
            Function_Return 0
        End
        Set piTabSize of hoEditor to sParameter
        Send RefactorReIndent of hoEditor
        If (Err = True) Begin
            Move 0 to iRetval
        End
        Else Begin
            Move 1 to iRetval
        End
        Send RestoreErrorState
        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String  sTestLine sTest

        Move False to bChanged
        Move (LTrim(sLine)) to sTestLine
        Move (Lowercase(sTestLine)) to sTestLine
        Get _IsCommentLineOrBlank sTestLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move False to bFound
        // We check both for a space between the key word and the comment _and_
        // comments placed directly after the key word _without_ a space between, aka "end_object//this is a comment"
        //
        // end_class:
        Move (Left(sTestLine, 10)) to sTest
        Move (sTest = Lowercase(CS_EndClass) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 11)) to sTest
            Move (sTest = (Lowercase(CS_EndClass) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_object:
        Move (Left(sTestLine, 11)) to sTest
        Move (sTest = Lowercase(CS_EndObject) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 12)) to sTest
            Move (sTest = (Lowercase(CS_EndObject) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_function:
        Move (Left(sTestLine, 13)) to sTest
        Move (sTest = Lowercase(CS_EndFunction) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 14)) to sTest
            Move (sTest = (Lowercase(CS_EndFunction) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
            Function_Return bChanged
        End

        // end_procedure:
        Move (Left(sTestLine, 14)) to sTest
        Move (sTest = Lowercase(CS_EndProcedure) + " ") to bFound
        If (bFound = False) Begin
            Move (Left(sTestLine, 15)) to sTest
            Move (sTest = (Lowercase(CS_EndProcedure) + CS_CommentSymbol)) to bFound
        End
        If (bFound = True) Begin
            Get _RemoveComments (&sLine) to bChanged
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes local statement if present.
    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bFound
        String sTest
        Integer iPos

        Move sLine to sTest
        Get _IsCommentLineOrBlank sTest to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Move False to bChanged
        Move (LTrim(sLine)) to sTest
        Move (Left(sTest, 6)) to sTest
        Move (Lowercase(sTest)) to sTest
        If (sTest = (Lowercase(CS_Local) + " ")) Begin
            // local must be the first word in the line.
            // Now find the local statement in the line and remove it.
            Move (Lowercase(sLine)) to sTest
            Move (Pos((Lowercase(CS_Local) + " "), sTest)) to iPos
            If (iPos > 0) Begin
                Move (Remove(sLine, iPos, 6)) to sLine
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // *** FULL SOURCE FILE FUNCTION ***
    // Pass the whole source file as a string array.
    // Removes  consecutive empty blank lines if more than piMaxNoOfEmptyLines.
    // Returns the passed string array but with removed duplicated empty lines.
    Function RemoveMultipleBlankLines String[] ByRef asSourceFile String sParameter Returns Integer
        String[] asSourceFileOut
        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines
        String sLine
        Boolean bImageStart bImageEnd bMakeImageTest

        Move False to bImageStart
        Move False to bImageEnd
        Move True  to bMakeImageTest
        Move 0 to iCurrentNoOfEmptyLines
        Move sParameter to iMaxNoOfEmptyLines

        Move (SizeOfArray(asSourceFile)) to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Move (Trim(asSourceFile[iCount])) to sLine

            If (bMakeImageTest = True) Begin
                If (bImageStart = False and bImageEnd = False) Begin
                    Get _IsImagePageStartOrEnd sLine True to bImageStart
                End
            End

            If (bImageStart = False and bImageEnd = False) Begin
                If (sLine = "") Begin
                    Increment iCurrentNoOfEmptyLines
                End
                Else Begin
                    Move 0 to iCurrentNoOfEmptyLines
                End
            End
            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
                Move asSourceFile[iCount] to asSourceFileOut[SizeOfArray(asSourceFileOut)]
            End

            If (bMakeImageTest = True) Begin
                If (bImageStart = True) Begin
                    Get _IsImagePageStartOrEnd sLine False to bImageEnd
                    If (bImageEnd = True) Begin
                        Move False to bImageStart
                        Move False to bImageEnd
                        Move False to bMakeImageTest
                    End
                End
            End
        Loop

        Move (SizeOfArray(asSourceFile) - SizeOfArray(asSourceFileOut)) to iEmptyLines
        Move asSourceFileOut to asSourceFile

        Function_Return iEmptyLines
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Returns True if a legacy IDE (Studio) source code marker is found.
    // This is a "Remove Type Function".
    Function RemoveOldStudioMarkers String sLine Returns Boolean
        Boolean bFound

        Move False to bFound
        Move (Trim(sLine)) to sLine

        Case Begin
            Case (sLine = "//AB-IgnoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-IgnoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-PanelStoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreTopStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreTopEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ClientStoreEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-DDOStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-DDOEnd")
                Move True to bFound
                Case Break

            Case (Left(sLine, 6) = "//AB/ ")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-MenuPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-End")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ToolbarPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ViewStart")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-ViewEnd")
                Move True to bFound
                Case Break

            Case (sLine = "//AB-StatusBarPackage")
                Move True to bFound
                Case Break

            Case (sLine = "//IDE-FileType=ftApplication")
                Move True to bFound
                Case Break

        Case End

        Function_Return bFound
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
        Move False to bWriteLine
        String[] asObjectNames

        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd
        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
        Get pasObjectNames                to asObjectNames

        If (bRegisterAllObjectsEnd = False) Begin
            If (bRegisterAllObjectsStart = False) Begin
                Get IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
                Set pbRegisterAllObjectsStart       to bRegisterAllObjectsStart
            End
            If (bRegisterAllObjectsStart = True) Begin
                Get IsRegisterObjectInArray sLine asObjectNames to bWriteLine
                Move False to bProjectObjectStructureStart
                Set           pbProjectObjectStructureStart to False
            End
            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
                Get IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
            End
            If (bProjectObjectStructureStart = True) Begin
                Get IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
            End
            Get IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
            If (bRegisterAllObjectsEnd = True) Begin
                Send ResetProjectObjectStructureProperties
                // This means that we won't bother with the rest of the file.
                Set pbRegisterAllObjectsEnd to True
            End
        End
        Function_Return bWriteLine
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged
        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // To remove hardcoded MS Sans Serif fonts if present.
    Function RemoveSansSerif String sLine Returns Boolean
        String sTest
        Boolean bWriteLine

        Move False to bWriteLine
        Move (Trim(sLine)) to sTest
        Move (Lowercase(sTest)) to sTest
        Move (Replaces(" ", sTest, ""))  to sTest
        Move (Replaces("'", sTest, "*")) to sTest
        Move (Replaces('"', sTest, "*")) to sTest
        If (sTest contains 'settypefaceto*mssansserif*') Begin
            Move True to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Removes Studio generated comments:
    //               "// fires when the button is clicked"
    //               "//OnChange is called on every changed character
    //               "// Visual DataFlex 14.0 Client Size Adjuster
    //               "// Visual DataFlex 14.0 Migration Utility,"
    //               ...and so on
    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
        String sText sComment
        Boolean bFound bChanged

        Move False to bChanged
        Move sLine to sText
        Get _IsCommentLine sText to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Move "fires when the button is clicked" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "onchange is called on every changed character" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex 14.0 client size adjuster" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "visual dataflex 14.0 migration utility," to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "If you set Current_radio you must set this after the" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "radio objects have been created AND after Notify_select_State has been" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Move "created. i.e. Set in bottom-code at end!!" to sComment
        Get IsStudioGeneratedComment sLine sComment to bFound
        If (bFound = True) Begin
            Move "" to sLine
            Function_Return True
        End

        Function_Return bChanged
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Remove trailing spaces if present.
    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
        Integer iBefore iAfter
        Boolean bChanged

        Move (Length(sLine))     to iBefore
        Move (RTrim(sLine))      to sLine
        Move (Length(sLine))     to iAfter
        Move (iBefore <> iAfter) to bChanged

        Function_Return bChanged
    End_Function

    // *** FULL SOURCE FILE FUNCTION ***
    // Pass the whole source file as a string array
    // Removes all unusad locally defined (in Procedures & Functions) for the
    // passed string array. Returns number of removed unused local variables.
    Function RemoveUnusedLocals String[] ByRef asSourceFile String sParameter Returns Integer
        Handle ho
        Integer iRetval
        Get phoRemoveUnusedLocals to ho
        If (ho = 0) Begin
            Send UserError "phoRemoveUnusedLocals = 0"
            Function_Return 0
        End
        Get MainProcedure of ho asSourceFile to iRetval
//        If (iRetval > 1) Begin
//            Reread SysFile
//                Add iRetval to SysFile.iCountUnusedLocals
//                SaveRecord SysFile
//            Unlock
//        End

        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
    // This would compile but not work well with the ReplaceCalcWithMoveStatement function.
    // ToDo: Reported by: JJ
    //    Procedure Testing
    //        // Before refactor
    //        String moveStr
    //        String s
    //        Move moveStr to s
    //
    //        // After refactor
    //        String moveStr
    //        String s
    //        Move Move to s
    //    End_Procedure
    Function ReplaceCalcWithMoveStatement String ByRef sLine String sParameter Returns Boolean
        Boolean bChanged bIsIn bIsCommentOrBlank
        String sTest sStart sStop
        Integer iPos
        tTokenizer TokenizerData

        Move False to bChanged
        Move sLine to sTest
        Get Tokenizer sLine to TokenizerData
        If (TokenizerData.bLineIsReady = True) Begin
            Function_Return False
        End

        // Check if this is a comment line, in case we do nothing.
        Get _IsCommentLineOrBlank sTest to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End

        Move (Lowercase(sLine)) to sTest
        Get _OverstrikeStrings sTest to sTest
        // Replaces all quotes string contents to "_" so we don't get false positives.

        // Check if line contains one of the keywords and that none of the keywords are within quotes.
        Get IsKeywordInLine "calc|moveint|movenum|movereal|movestr|" sTest to bIsIn
        If (bIsIn = False) Begin
            Function_Return False
        End

        Case Begin
            Case (Pos("calc ", sTest))
                Move (Pos("calc ", sTest))         to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("moveint ", sTest))
                Move (Pos("moveint ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movenum ", sTest))
                Move (Pos("movenum ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movereal ", sTest))
                Move (Pos("movereal ", sTest))     to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break

            Case (Pos("movestr ", sTest))
                Move (Pos("movestr ", sTest))      to iPos
                Move (Left(sLine, (iPos -1)))      to sStart
                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
                Move (sStart + "Move" + sStop)     to sLine
                Move True                          to bChanged
                Case Break
        Case End

        Function_Return bChanged
    End_Function

    // *** REPORT FUNCTION ***
    // Makes no change to the source code.
    Function ReportUnusedSourceFiles String[] ByRef asSourceFiles String sParameter Returns Integer
        Handle ho
        String sFilter
        Integer iRetval
        tRefactorSettings RefactorSettings

        Get phoReportUnusedSourceFiles to ho
        If (ho = 0) Begin
            Function_Return 0
        End

        Get pRefactorSettings to RefactorSettings
        Set psFileFilter  of ho to RefactorSettings.sFileFilter
//        Set pasAllFolders of ho to RefactorSettings.asFolderNames
// ToDo: *** Change interface!!! ***
//        Set pasSourceFiles of ho to asSourceFiles
Function_Return 0

        Send DoProcess    of ho

        Get piNoOfUnusedSourceFiles of ho to iRetval
        Reread SysFile
            Move iRetval to SysFile.iCountUnusedSourceFiles
            SaveRecord SysFile
        Unlock
        Function_Return iRetval
    End_Function

    // *** ALL SOURCE FILES FUNCTION ***
    // Pass the all source files as a string array, including path.
    //  The naming style of datadictionaries over time has not been constant.
    //  The new style is
    //    Object o<tablename>_DD is a c<TableName>Datadictionary
    //  They also have a switch so you can keep on using the legacy style name which is
    //    Object o<tablename>_DD is a <tablename>_Datadictionary
    //
    //  However before VDF12, the
    //    Object <tableName>_DD is a <tablename>_Datadictionary
    //
    //  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
    //  all over the place. Copying old code into new views/dialogs simply breaks and if your
    //  codebase has mixed styles then the compiler will not catch that.
    //  A code nightmare.
    //
    //  This program allows you to switch between the following code styles:
    //  <TableName>_DD  == eDDOldStyle
    //  TO: o<TableName>_DD == eDDStudioStyle
    Function RestylelDDOs String[] ByRef asSourceFile String sParameter Returns Integer
        String sHomePath
        Handle ho
        Integer iRetval iSize iCount
        tRefactorSettings RefactorSettings
        tsSearchResult[] asAllSourceFiles
        String[] asFilesArray

        // ToDo: This needs to be available for the unit tester as well.
        Get phoDDOReStyler to ho
        If (ho = 0) Begin
            Send UserError "phoDDORestyler = 0"
            Function_Return 0
        End

        Get psHomePath of ghoApplication to sHomePath
        Get pRefactorSettings to RefactorSettings
        Get AllSourceFiles of ghoApplication RefactorSettings.asFolderNames RefactorSettings.sFileFilter to asAllSourceFiles

        Set psHomePath of ho to sHomePath
        Set peDDOStyle of ho to RefactorSettings.eDDOStyle
        Move (SizeOfArray(asAllSourceFiles)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asAllSourceFiles[iCount].sFilename to asFilesArray[SizeOfArray(asFilesArray)]
        End
        Set pasAllSourceFiles of ho to asFilesArray

        Get MainDDORestyler of ho to iRetval
        Function_Return iRetval
    End_Function

    // *** LINE-BY-LINE FUNCTION ***
    // The older version's passed parameters; eSplitBy and iTabSize has been made into
    // class properties. This way we can have a uniform calling interface for all functions.
    // The two user selected values can be found in Sysfile.
    // Valid sParameter values;
    //    CI_SplitWithSpaceAndSemicolon
    //    CI_SplitWithSemicolon
    //    CI_SplitAddBeginEndBlock
    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
        Boolean bStop bChanged
        Integer iIndent eSplitBy iTabSize iID
        String  sText

        // ToDo: *** Make this into a class property, set before refactoring starts!
        //           This is not something that is changed during the run of a refactoring process.
        // We need to get a second parameter; the tab-size:
        Move FunctionsA.ID to iID
        Clear FunctionsA
        Move CS_EditorReIndent to FunctionsA.Function_Name
        Find eq FunctionsA by Index.5
        If (Found = False) Begin
            Send UserError ("Could not find function:" * CS_EditorReIndent)
            Function_Return False
        End
        Else Begin
            Move (Trim(FunctionsA.Parameter)) to iTabSize
            // Reset record buffert:
            Move iID to FunctionsA.ID
            Find Eq FunctionsA by Index.1
        End

        Move False to bChanged
        Move sParameter to eSplitBy

        Move (LTrim(sLine))     to sText
        Move (Pos(sText,sLine) - 1) to iIndent
        Move (Left(sText, 3))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = (Lowercase(CS_If) + " ")) Begin
            Get _IsLineEndSemiColonOrBegin sLine to bStop
            If (bStop = False) Begin
                // It's one of those single line if statements, break it up
                Move (Lowercase(sLine)) to sText
                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
            End
        End
        Else Begin
            Move (LTrim(sLine))     to sText
            Move (Left(sText, 5))   to sText
            Move (Lowercase(sText)) to sText
            If (sText = (Lowercase(CS_Else) + " ")) Begin
                Get _IsLineEndSemiColonOrBegin sLine to bStop
                If (bStop = False) Begin
                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
                End
            End
        End
        Function_Return bChanged
    End_Function

// NOTE: Do *not* add any code after this "End_Class"!
//       It will be removed by the Export/Import logic.
End_Class
