Compiling Program: C:\Projects\DF18\DfRefactor\AppSrc\TestBenchRefactorFunctions.src
Memory Available: 2147483646
1>// The Refactor Testing program is aimed at testing small refactoring functions, to make they work exactly as intended.
1>// After those new refactoring functions have been thoroughly tested, they can be implemented in the main DfRefactor program.
1>//
1>Use DFAllEnt.pkg  
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cRefactorApplication.pkg
Including file: cRefactorApplication.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorApplication.pkg)
67438>>>Use cApplication.pkg
67438>>>Use cIniFile.pkg
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
67438>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
67438>>>>>>>Use VDFBase.pkg
67438>>>>>>>
67438>>>>>>>Class cFormatter is an cObject
67439>>>>>>>    
67439>>>>>>>    Procedure Construct_object
67441>>>>>>>        Integer iCh
67441>>>>>>>        Forward Send construct_object
67443>>>>>>>        Property String  psCurrencySymbol
67444>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
67445>>>>>>>        
67445>>>>>>>        Property String  psLeft
67446>>>>>>>        Property String  psright
67447>>>>>>>        Property Integer pbThousandsSep
67448>>>>>>>        Property Integer piPoints
67449>>>>>>>        
67449>>>>>>>        Property String  psCurPosLeft
67450>>>>>>>        Property String  psCurPosright
67451>>>>>>>        Property Integer pbCurPosThousandsSep
67452>>>>>>>        Property Integer piCurPosPoints
67453>>>>>>>        
67453>>>>>>>        Property String  psCurNegLeft
67454>>>>>>>        Property String  psCurNegright
67455>>>>>>>        Property Integer pbCurNegThousandsSep
67456>>>>>>>        Property Integer piCurNegPoints
67457>>>>>>>        
67457>>>>>>>        Property String  psNumPosLeft
67458>>>>>>>        Property String  psNumPosright
67459>>>>>>>        Property Integer pbNumPosThousandsSep
67460>>>>>>>        Property Integer piNumPosPoints
67461>>>>>>>        
67461>>>>>>>        Property String  psNumNegLeft
67462>>>>>>>        Property String  psNumNegright
67463>>>>>>>        Property Integer pbNumNegThousandsSep
67464>>>>>>>        Property Integer piNumNegPoints
67465>>>>>>>        
67465>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
67466>>>>>>>        Send SetFormat  ",#.*"           False // numeric
67467>>>>>>>        
67467>>>>>>>    End_Procedure
67468>>>>>>>    
67468>>>>>>>    // internal
67468>>>>>>>    // parse passed format string and set temporary properties with result
67468>>>>>>>    Procedure ParseFormat String sFmt
67470>>>>>>>        
67470>>>>>>>        String sLeft sRight sDigit
67470>>>>>>>        Integer bSep iPos i iDigits
67470>>>>>>>        
67470>>>>>>>        // replace any literals. A "/" followed by anything.
67470>>>>>>>        // some literals are special. $ . , / #
67470>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
67471>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
67472>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
67473>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
67474>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
67475>>>>>>>        Move (Character(9)) to sDigit
67476>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
67477>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
67478>>>>>>>        
67478>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
67479>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
67482>>>>>>>        
67482>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
67483>>>>>>>        
67483>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
67484>>>>>>>        
67484>>>>>>>        // Move all the special literals back into place before parsing
67484>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
67485>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
67486>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
67487>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
67488>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
67489>>>>>>>        
67489>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
67491>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
67492>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
67494>>>>>>>                Move -2 to iDigits
67495>>>>>>>                Increment i
67496>>>>>>>            End
67496>>>>>>>>
67496>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
67500>>>>>>>                Increment i
67501>>>>>>>            Loop
67502>>>>>>>>
67502>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
67503>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
67506>>>>>>>            //
67506>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
67507>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
67511>>>>>>>                Increment i
67512>>>>>>>            Loop
67513>>>>>>>>
67513>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
67514>>>>>>>        End
67514>>>>>>>>
67514>>>>>>>        Else Begin                             // we have no decinal
67515>>>>>>>            Move 0 to iDigits                  // so points is none
67516>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
67517>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
67519>>>>>>>                Move sFmt to sLeft
67520>>>>>>>                Move ""   to sRight
67521>>>>>>>            End
67521>>>>>>>>
67521>>>>>>>            Else Begin
67522>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
67523>>>>>>>                Move 1 to i
67524>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
67528>>>>>>>                    Increment i
67529>>>>>>>                Loop
67530>>>>>>>>
67530>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
67531>>>>>>>            End
67531>>>>>>>>
67531>>>>>>>        End
67531>>>>>>>>
67531>>>>>>>        // set temporary format properties and exit
67531>>>>>>>        Set pbThousandsSep to bSep
67532>>>>>>>        Set psLeft         to sLeft
67533>>>>>>>        Set psRight        to sRight
67534>>>>>>>        Set piPoints       to iDigits
67535>>>>>>>    End_Procedure
67536>>>>>>>    
67536>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
67536>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
67536>>>>>>>    //
67536>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
67536>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
67538>>>>>>>        String sPos sNeg
67538>>>>>>>        Integer iPos
67538>>>>>>>        
67538>>>>>>>        Move (Pos(";",sFmt)) to iPos
67539>>>>>>>        If iPos Begin
67541>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
67542>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
67543>>>>>>>        End
67543>>>>>>>>
67543>>>>>>>        Else Begin
67544>>>>>>>            Move sFmt         to sPos
67545>>>>>>>            Move ("-" + sFmt) to sNeg
67546>>>>>>>        End
67546>>>>>>>>
67546>>>>>>>        Send ParseFormat sPos
67547>>>>>>>        If bCurrency Begin
67549>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
67550>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
67551>>>>>>>            Set psCurPosRight        to (psRight(Self))
67552>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
67553>>>>>>>        End
67553>>>>>>>>
67553>>>>>>>        Else Begin
67554>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
67555>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
67556>>>>>>>            Set psNumPosRight        to (psRight(Self))
67557>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
67558>>>>>>>        End
67558>>>>>>>>
67558>>>>>>>        
67558>>>>>>>        Send ParseFormat sNeg
67559>>>>>>>        If bCurrency Begin
67561>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
67562>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
67563>>>>>>>            Set psCurNegRight        to (psRight(Self))
67564>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
67565>>>>>>>        End
67565>>>>>>>>
67565>>>>>>>        Else Begin
67566>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
67567>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
67568>>>>>>>            Set psNumNegRight        to (psRight(Self))
67569>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
67570>>>>>>>        End
67570>>>>>>>>
67570>>>>>>>    End_Procedure
67571>>>>>>>    
67571>>>>>>>    // low level formatting. Pass parameters
67571>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
67573>>>>>>>        String  sLeft sRight sNumber sSep sDec
67573>>>>>>>        Integer bIsNegative iDec iLen iCh
67573>>>>>>>        
67573>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
67576>>>>>>>        Move (Character(iCh)) to sDec
67577>>>>>>>        
67577>>>>>>>        Move (abs(nNumber)) to sNumber
67578>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
67579>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
67580>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
67581>>>>>>>        // format for decimal separator
67581>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
67584>>>>>>>        
67584>>>>>>>        // format for thousand sep.
67584>>>>>>>        If bSep Begin
67586>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
67589>>>>>>>            Move (Character(iCh)) to sSep
67590>>>>>>>            Move (Length(sLeft)) to iLen
67591>>>>>>>            While (iLen>3)
67595>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
67596>>>>>>>                Move (iLen-3) to iLen
67597>>>>>>>            Loop
67598>>>>>>>>
67598>>>>>>>        End
67598>>>>>>>>
67598>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
67598>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
67601>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
67602>>>>>>>    End_Function
67603>>>>>>>    
67603>>>>>>>    // Public: Format for currency
67603>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
67605>>>>>>>        String  sLeft sRight
67605>>>>>>>        Integer bSep
67605>>>>>>>        If (nNumber<0) Begin
67607>>>>>>>            Get pbCurNegThousandsSep to bSep
67608>>>>>>>            Get psCurNegLeft         to sLeft
67609>>>>>>>            Get psCurNegRight        to sRight
67610>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
67613>>>>>>>        End
67613>>>>>>>>
67613>>>>>>>        Else Begin
67614>>>>>>>            Get pbCurPosThousandsSep to bSep
67615>>>>>>>            Get psCurPosLeft         to sLeft
67616>>>>>>>            Get psCurPosRight        to sRight
67617>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
67620>>>>>>>        End
67620>>>>>>>>
67620>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
67621>>>>>>>    End_Function
67622>>>>>>>    
67622>>>>>>>    // Public: Format for numeric
67622>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
67624>>>>>>>        String  sLeft sRight
67624>>>>>>>        Integer bSep
67624>>>>>>>        If (nNumber<0) Begin
67626>>>>>>>            Get pbNumNegThousandsSep to bSep
67627>>>>>>>            Get psNumNegLeft         to sLeft
67628>>>>>>>            Get psNumNegRight        to sRight
67629>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
67632>>>>>>>        End
67632>>>>>>>>
67632>>>>>>>        Else Begin
67633>>>>>>>            Get pbNumPosThousandsSep to bSep
67634>>>>>>>            Get psNumPosLeft         to sLeft
67635>>>>>>>            Get psNumPosRight        to sRight
67636>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
67639>>>>>>>        End
67639>>>>>>>>
67639>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
67640>>>>>>>    End_Function
67641>>>>>>>    
67641>>>>>>>    
67641>>>>>>>    // Public: Format passing format string
67641>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
67643>>>>>>>        Integer iPos bIsNeg
67643>>>>>>>        String  sLeft sRight
67643>>>>>>>        Integer iPoints bSep
67643>>>>>>>        Move (nNumber<0) to bIsNeg
67644>>>>>>>        Move (Pos(";",sFmt)) to iPos
67645>>>>>>>        Case Begin
67645>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
67648>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
67652>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
67656>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
67658>>>>>>>        Case End
67658>>>>>>>        Send ParseFormat sFmt
67659>>>>>>>        Get pbThousandsSep to bSep
67660>>>>>>>        Get psLeft         to sLeft
67661>>>>>>>        Get psRight        to sRight
67662>>>>>>>        Get piPoints       to iPoints
67663>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
67664>>>>>>>    End_Function
67665>>>>>>>    
67665>>>>>>>End_Class
67666>>>>>
67666>>>>>Global_Variable Handle ghoFormatter
67666>>>>>Get Create of desktop U_cFormatter to ghoFormatter
67667>>>>>
67667>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
67669>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
67670>>>>>End_Function
67671>>>>>
67671>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
67673>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
67674>>>>>End_Function
67675>>>>>
67675>>>>>Function FormatValue Global Number nNum String sFmt Returns String
67677>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
67678>>>>>End_Function
67679>>>>>
67679>>>>>Procedure SetCurrencyFormat Global String sFmt
67681>>>>>    Send SetFormat of ghoFormatter sFmt True
67682>>>>>End_Procedure
67683>>>>>
67683>>>>>Procedure SetNumberFormat Global String sFmt
67685>>>>>    Send SetFormat of ghoFormatter sFmt False
67686>>>>>End_Procedure
67687>>>>>
67687>>>>>
67687>>>Use vwin32fh.pkg          
Including file: vWin32fh.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vWin32fh.pkg)
67687>>>>>// This code is part of VDF GUIdance
67687>>>>>// Visit us @ http://www.vdf-guidance.com
67687>>>>>// e-Mail us @ info@vdf-guidance.com
67687>>>>>// VDF GUIdance is a mutual project of
67687>>>>>// Frank Vandervelpen - Vandervelpen Systems and
67687>>>>>// Wil van Antwerpen  - Antwise Solutions
67687>>>>>// All software source code should be used <<AS IS>> without any warranty.
67687>>>>>//
67687>>>>>//
67687>>>>>// *** Windows 32bit file handling wrapper class ***
67687>>>>>//
67687>>>>>
67687>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
67687>>>>>//                   This may be painfull for some of you, but it was really needed as it was
67687>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
67687>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
67687>>>>>//
67687>>>>>// The used naming-convention is:
67687>>>>>//     - a prefix of "vWin32_" for every external function declaration
67687>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
67687>>>>>//
67687>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
67687>>>>>// of DataAccess in the future.
67687>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
67687>>>>>//
67687>>>>>// mm-dd-yyyy Author Description
67687>>>>>//
67687>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
67687>>>>>//                   vGetWindowsDirectory
67687>>>>>//
67687>>>>>//                   vGetTempFileName
67687>>>>>//                   vGetTempPath
67687>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
67687>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
67687>>>>>//                   error in your application anyways. Changed this for:
67687>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
67687>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
67687>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
67687>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
67687>>>>>//                   It is renamed too avoid this.
67687>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
67687>>>>>//                   function vSelectedFileName is now just SelectedFileName
67687>>>>>//                   Removed the local keyword in the variable declarations
67687>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
67687>>>>>//                   created file-open dialog
67687>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
67687>>>>>//                   in that it didn't exactly return the correct filename of the file created.
67687>>>>>//                   This has now been taken care of.
67687>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
67687>>>>>//                   These declarations are now included from the vWin32fh header file.
67687>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
67687>>>>>//                   Before today one could always undo the operation, as of now you cannot as
67687>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
67687>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
67687>>>>>//                   One can however restore to the old way of handling by simply calling the
67687>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
67687>>>>>//                   filehandling operations
67687>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
67687>>>>>//                   as well as the StringFromRightOfChar function.
67687>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
67687>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
67687>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
67687>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
67687>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
67687>>>>>//                   extended characters are treated ok too.
67687>>>>>//                   Reported by Flemming from
67687>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
67687>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
67687>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
67687>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
67687>>>>>//                   Added vSelectSavefile function to create a file save dialog
67687>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
67687>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
67687>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
67687>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
67687>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
67687>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
67687>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
67687>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
67687>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
67687>>>>>
67687>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
67687>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\cvFileDialogs.pkg)
67687>>>>>>>//***************************************************************************
67687>>>>>>>//*
67687>>>>>>>//* Class:        cvSaveAsDialog
67687>>>>>>>//* Package Name: cvFileDialogs.pkg
67687>>>>>>>//*
67687>>>>>>>//***************************************************************************
67687>>>>>>>
67687>>>>>>>Use File_dlg.pkg
67687>>>>>>>
67687>>>>>>>// *WvA: 13-01-1999 Created
67687>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
67687>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
67687>>>>>>>// file_name.
67687>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
67688>>>>>>>
67688>>>>>>>    Procedure Construct_Object Integer iImage_Id
67690>>>>>>>        Forward Send Construct_Object iImage_Id
67692>>>>>>>        Set HideReadOnly_State to True
67693>>>>>>>    End_Procedure
67694>>>>>>>
67694>>>>>>>    Function SelectedFileName Returns String
67696>>>>>>>        String sFileName
67696>>>>>>>        Move "" to sFileName
67697>>>>>>>        If (Show_Dialog(Self)) Begin
67699>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
67700>>>>>>>        End
67700>>>>>>>>
67700>>>>>>>        Function_Return sFileName
67701>>>>>>>    End_Function
67702>>>>>>>End_Class
67703>>>>>>>
67703>>>>>>>// *WvA: 13-01-1999 Created
67703>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
67703>>>>>>>// file_name. Returns '' if the user didn't make a selection.
67703>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
67703>>>>>>>//                   file-open dialog
67703>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
67705>>>>>>>    String sSelectedFile
67705>>>>>>>    Integer hoOpenFileDialog
67705>>>>>>>
67705>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
67707>>>>>>>
67707>>>>>>>        Set Dialog_Caption    to sCaptionText
67708>>>>>>>        Set Filter_String     to sSupportedFileTypes
67709>>>>>>>        Set Initial_Folder    to sInitialFolder
67710>>>>>>>
67710>>>>>>>        Move Self       to hoOpenFileDialog
67711>>>>>>>    End_Object
67712>>>>>>>
67712>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
67713>>>>>>>    Send Destroy_Object to hoOpenFileDialog
67714>>>>>>>    Function_Return sSelectedFile
67715>>>>>>>End_Function
67716>>>>>>>
67716>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
67717>>>>>>>
67717>>>>>>>    Procedure Construct_Object
67719>>>>>>>        Forward Send Construct_Object
67721>>>>>>>        Set HideReadOnly_State to True
67722>>>>>>>    End_Procedure
67723>>>>>>>
67723>>>>>>>    Function SelectedFileName Returns String
67725>>>>>>>        String sFileName
67725>>>>>>>        Move "" to sFileName
67726>>>>>>>        If (Show_Dialog(Self)) Begin
67728>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
67729>>>>>>>        End
67729>>>>>>>>
67729>>>>>>>        Function_Return sFileName
67730>>>>>>>    End_Function
67731>>>>>>>
67731>>>>>>>End_Class
67732>>>>>>>
67732>>>>>>>// Added optional default filename as suggested by Nils
67732>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
67734>>>>>>>    String sSelectedFile
67734>>>>>>>    Integer hoDialog
67734>>>>>>>
67734>>>>>>>    Move "" to sSelectedFile
67735>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
67736>>>>>>>    If (hoDialog) Begin
67738>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
67738>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
67739>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
67740>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
67741>>>>>>>        If (Num_Arguments = 4) Begin
67743>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
67744>>>>>>>        End
67744>>>>>>>>
67744>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
67745>>>>>>>        Send Destroy of hoDialog
67746>>>>>>>    End
67746>>>>>>>>
67746>>>>>>>    Function_Return sSelectedFile
67747>>>>>>>End_Function
67748>>>>>Use Seq_chnl.pkg
67748>>>>>
67748>>>>>Use windows.pkg
67748>>>>>Use Dll.pkg
67748>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vwin32fh.h)
67748>>>>>>>//TH-Header
67748>>>>>>>//*****************************************************************************************
67748>>>>>>>// Copyright (c)  2004 KURANT Project
67748>>>>>>>// All rights reserved.
67748>>>>>>>//
67748>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
67748>>>>>>>// $ProjectName : Windows 32 bits file handling
67748>>>>>>>// $Authors     : Wil van Antwerpen
67748>>>>>>>// $Created     : 19.02.2004  19:25
67748>>>>>>>// $Type        : BSD (as in do with it whatever you like)
67748>>>>>>>//
67748>>>>>>>// Contents:
67748>>>>>>>//  This file contains the Windows API external function call definitions and
67748>>>>>>>//  constants as they are used in the vWin32fh package.
67748>>>>>>>//*****************************************************************************************
67748>>>>>>>//TH-RevisionStart
67748>>>>>>>//TH-RevisionEnd
67748>>>>>>>
67748>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
67748>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
67748>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
67748>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
67748>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
67748>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
67748>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
67748>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
67748>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
67748>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
67748>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
67748>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
67748>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
67748>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
67748>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
67748>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
67748>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
67748>>>>>>>
67748>>>>>>>
67748>>>>>>>Define vMax_Path     For |CI260
67748>>>>>>>Define vMinChar      For |CI$80
67748>>>>>>>Define vMaxChar      For |CI$7F
67748>>>>>>>Define vMinShort     For |CI$8000
67748>>>>>>>Define vMaxShort     For |CI$7FFF
67748>>>>>>>Define vMinLong      For |CI$80000000
67748>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
67748>>>>>>>Define vMaxByte      For |CI$FF
67748>>>>>>>Define vMaxWord      For |CI$FFFF
67748>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
67748>>>>>>>
67748>>>>>>>
67748>>>>>>>
67748>>>>>>>// For FindFirstFile
67748>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
67748>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
67748>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
67748>>>>>>>
67748>>>>>>>// The defines below can be used to find out what kind of error has occurred if
67748>>>>>>>// the API-call ShellExecute is used.
67748>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
67748>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
67748>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
67748>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
67748>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
67748>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
67748>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
67748>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
67748>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
67748>>>>>>>Define vSE_ERR_FNF             For |CI0002
67748>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
67748>>>>>>>Define vSE_ERR_OOM             For |CI0008
67748>>>>>>>Define vSE_ERR_PNF             For |CI0003
67748>>>>>>>Define vSE_ERR_SHARE           For |CI0026
67748>>>>>>>
67748>>>>>>>
67748>>>>>>>// C-Structure
67748>>>>>>>//typedef struct _browseinfo {
67748>>>>>>>//    HWND hwndOwner;
67748>>>>>>>//    LPCITEMIDLIST pidlRoot;
67748>>>>>>>//    LPSTR pszDisplayName;
67748>>>>>>>//    LPCSTR lpszTitle;
67748>>>>>>>//    UINT ulFlags;
67748>>>>>>>//    BFFCALLBACK lpfn;
67748>>>>>>>//    LPARAM lParam;
67748>>>>>>>//    int iImage;
67748>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
67748>>>>>>>
67748>>>>>>>//declare C structure struct_browseinfo
67748>>>>>>>//as documented in MSDN under Windows Shell API
67748>>>>>>>Struct tvBrowseInfo
67748>>>>>>>  Handle    hWndOwner
67748>>>>>>>  Pointer   pIDLRoot
67748>>>>>>>  Pointer   pszDisplayName
67748>>>>>>>  Pointer   lpszTitle
67748>>>>>>>  dWord     ulFlags
67748>>>>>>>  Pointer   lpfnCallback
67748>>>>>>>  dWord     lParam
67748>>>>>>>  DWord     iImage
67748>>>>>>>End_Struct // tvBrowseInfo
67748>>>>>>>
67748>>>>>>>// Browsing for directory.
67748>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
67748>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
67748>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
67748>>>>>>>                                            // The callback function can set the status text by
67748>>>>>>>                                            // sending messages to the dialog box.
67748>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
67748>>>>>>>
67748>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
67748>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
67748>>>>>>>
67748>>>>>>>// message from browser
67748>>>>>>>//Define BFFM_INITIALIZED        1
67748>>>>>>>//Define BFFM_SELCHANGED         2
67748>>>>>>>
67748>>>>>>>// messages to browser
67748>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
67748>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
67748>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
67748>>>>>>>
67748>>>>>>>
67748>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
67749>>>>>>>
67749>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
67750>>>>>>>
67750>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
67751>>>>>>>
67751>>>>>>>
67751>>>>>>>
67751>>>>>>>
67751>>>>>>>Struct tvSecurity_attributes
67751>>>>>>>  DWord   nLength
67751>>>>>>>  Pointer lpDescriptor
67751>>>>>>>  Integer bInheritHandle
67751>>>>>>>End_Struct // tvSecurity_attributes
67751>>>>>>>
67751>>>>>>>//nLength:
67751>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
67751>>>>>>>// SECURITY_ATTRIBUTES structure.
67751>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
67751>>>>>>>// value of the nLength member. However, an application should still set it properly.
67751>>>>>>>// That ensures current, future, and cross-platform compatibility.
67751>>>>>>>//
67751>>>>>>>//lpSecurityDescriptor:
67751>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
67751>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
67751>>>>>>>// descriptor of the calling process.
67751>>>>>>>//
67751>>>>>>>//bInheritHandle:
67751>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
67751>>>>>>>// If this member is TRUE, the new process inherits the handle.
67751>>>>>>>
67751>>>>>>>
67751>>>>>>>// BOOL CreateDirectory(
67751>>>>>>>//    LPCTSTR lpPathName,
67751>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
67751>>>>>>>//   );
67751>>>>>>>//
67751>>>>>>>// lpPathName
67751>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
67751>>>>>>>//  to be created.
67751>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
67751>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
67751>>>>>>>// lpSecurityAttributes
67751>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
67751>>>>>>>//  determines whether the returned handle can be inherited by child processes.
67751>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
67751>>>>>>>// Returns:
67751>>>>>>>//  If the function succeeds, the return value is nonzero.
67751>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
67751>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
67752>>>>>>>
67752>>>>>>>
67752>>>>>>>// lpPathName
67752>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
67752>>>>>>>//  to be removed.
67752>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
67752>>>>>>>// Returns:
67752>>>>>>>//  If the function succeeds, the return value is nonzero.
67752>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
67752>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
67753>>>>>>>
67753>>>>>>>
67753>>>>>>>
67753>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
67753>>>>>>>// executable file or a document file.
67753>>>>>>>//
67753>>>>>>>// Operation can be one of the following:
67753>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
67753>>>>>>>//            The file can be an executable file or a document file.
67753>>>>>>>//            The file can be a folder to open.
67753>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
67753>>>>>>>//            The file should be a document file. If the file is an executable file,
67753>>>>>>>//            the function opens the file, as if "open" had been specified.
67753>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
67753>>>>>>>//
67753>>>>>>>// Return Values:
67753>>>>>>>//
67753>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
67753>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
67753>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
67753>>>>>>>//
67753>>>>>>>// The following table lists these error values:
67753>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
67753>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
67753>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
67753>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
67753>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
67753>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
67753>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
67753>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
67753>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
67753>>>>>>>// Public Const SE_ERR_FNF = 2
67753>>>>>>>// Public Const SE_ERR_NOASSOC = 31
67753>>>>>>>// Public Const SE_ERR_OOM = 8
67753>>>>>>>// Public Const SE_ERR_PNF = 3
67753>>>>>>>// Public Const SE_ERR_SHARE = 26
67753>>>>>>>
67753>>>>>>>
67753>>>>>>>
67753>>>>>>>// Code to open the program that is associated with the selected file.
67753>>>>>>>//
67753>>>>>>>// External function call used in Procedure DoStartDocument
67753>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
67754>>>>>>>
67754>>>>>>>
67754>>>>>>>
67754>>>>>>>
67754>>>>>>>Define vFO_MOVE                For |CI$0001
67754>>>>>>>Define vFO_COPY                For |CI$0002
67754>>>>>>>Define vFO_DELETE              For |CI$0003
67754>>>>>>>Define vFO_RENAME              For |CI$0004
67754>>>>>>>
67754>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
67754>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
67754>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
67754>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
67754>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
67754>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
67754>>>>>>>                                          // Must be freed using SHFreeNameMappings
67754>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
67754>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
67754>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
67754>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
67754>>>>>>>
67754>>>>>>>Struct tvShFileOpStruct
67754>>>>>>>  Handle  hWnd
67754>>>>>>>  Integer wFunc
67754>>>>>>>  Pointer pFrom
67754>>>>>>>  Pointer pTo
67754>>>>>>>  Short   fFlags
67754>>>>>>>  Short   fAnyOperationsAborted
67754>>>>>>>  Pointer hNameMappings
67754>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
67754>>>>>>>End_Struct // tvShFileOpStruct
67754>>>>>>>
67754>>>>>>>// hwnd
67754>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
67754>>>>>>>
67754>>>>>>>// wFunc
67754>>>>>>>//   Operation to perform. This member can be one of the following values:
67754>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
67754>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
67754>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
67754>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
67754>>>>>>>
67754>>>>>>>// pFrom
67754>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
67754>>>>>>>//   be null-separated. The list of names must be double null-terminated.
67754>>>>>>>
67754>>>>>>>// pTo
67754>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
67754>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
67754>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
67754>>>>>>>//   double null-terminated.
67754>>>>>>>
67754>>>>>>>// fAnyOperationsAborted
67754>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
67754>>>>>>>//   were completed or FALSE otherwise.
67754>>>>>>>
67754>>>>>>>
67754>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
67754>>>>>>>// This can be a file or a folder.
67754>>>>>>>// With thanks to Andrew S Kaplan
67754>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
67755>>>>>>>
67755>>>>>>>
67755>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
67755>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
67756>>>>>>>
67756>>>>>>>
67756>>>>>>>
67756>>>>>>>// Courtesy Of Vincent Oorsprong
67756>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
67756>>>>>>>//   Pointer lpPathName ;
67756>>>>>>>//   Pointer lpPrefixString ;
67756>>>>>>>//   Integer uUnique ;
67756>>>>>>>//   Pointer lpTempFileName ;
67756>>>>>>>//   Returns Integer
67756>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
67756>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
67757>>>>>>>
67757>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
67758>>>>>>>
67758>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
67759>>>>>>>
67759>>>>>>>// from:
67759>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
67759>>>>>>>//
67759>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
67759>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
67759>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
67759>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
67759>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
67759>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
67759>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
67759>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
67759>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
67759>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
67759>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
67759>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
67759>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
67759>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
67759>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
67759>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
67759>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
67759>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
67759>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
67759>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
67759>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
67759>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
67759>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
67759>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
67759>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
67759>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
67759>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
67759>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
67759>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
67759>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
67759>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
67759>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
67759>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
67759>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
67759>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
67759>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
67759>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
67759>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
67759>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
67759>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
67759>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
67759>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
67759>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
67759>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
67759>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
67759>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
67759>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
67759>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
67759>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
67759>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
67759>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
67759>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
67759>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
67759>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
67759>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
67759>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
67759>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
67759>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
67759>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
67759>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
67759>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
67759>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
67759>>>>>>>
67759>>>>>>>
67759>>>>>>>//HRESULT SHGetFolderPath(
67759>>>>>>>//    HWND hwndOwner,
67759>>>>>>>//    int nFolder,
67759>>>>>>>//    HANDLE hToken,
67759>>>>>>>//    DWORD dwFlags,
67759>>>>>>>//    LPTSTR pszPath
67759>>>>>>>//);
67759>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
67759>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
67759>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
67759>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
67759>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
67759>>>>>>>//
67759>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
67760>>>>>>>
67760>>>>>>>
67760>>>>>>>
67760>>>>>>>Struct tvWin32FindData
67760>>>>>>> Dword            dwFileAttributes
67760>>>>>>> Dword            ftCreationLowDateTime
67760>>>>>>> Dword            ftCreationHighDateTime
67760>>>>>>> dword            ftLastAccessLowDateTime
67760>>>>>>> Dword            ftLastAccessHighDateTime
67760>>>>>>> Dword            ftLastWriteLowDateTime
67760>>>>>>> Dword            ftLastWriteHighDateTime
67760>>>>>>> Dword            nFileSizeHigh
67760>>>>>>> Dword            nFileSizeLow
67760>>>>>>> Dword            dwReserved0
67760>>>>>>> Dword            dwReserved1
67760>>>>>>> UChar[vMax_Path] cFileName
67760>>>>>>> UChar[14]        cAlternateFileName
67760>>>>>>>End_Struct
67760>>>>>>>
67760>>>>>>>// Courtesy Of Vincent Oorsprong
67760>>>>>>>// lpFileName      : address of name of file to search for
67760>>>>>>>// lpFindFileData  : address of returned information
67760>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
67761>>>>>>>
67761>>>>>>>// Courtesy Of Vincent Oorsprong
67761>>>>>>>// hFindFile       : handle of search
67761>>>>>>>// lpFindFileData  : address of structure for data on found file
67761>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
67762>>>>>>>
67762>>>>>>>//
67762>>>>>>>// Unicode equivalents
67762>>>>>>>//
67762>>>>>>>// lpFileName      : address of name of file to search for
67762>>>>>>>// lpFindFileData  : address of returned information
67762>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
67763>>>>>>>
67763>>>>>>>// hFindFile       : handle of search
67763>>>>>>>// lpFindFileData  : address of structure for data on found file
67763>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
67764>>>>>>>
67764>>>>>>>
67764>>>>>>>// Courtesy Of Vincent Oorsprong
67764>>>>>>>//  hFindFile      : file search handle
67764>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
67765>>>>>>>
67765>>>>>>>
67765>>>>>>>
67765>>>>>>>Struct tvFileTime
67765>>>>>>>  DWord dwLowDateTime
67765>>>>>>>  DWord dwHighDateTime
67765>>>>>>>End_Struct
67765>>>>>>>
67765>>>>>>>
67765>>>>>>>Struct tvSystemTime
67765>>>>>>>  UShort wYear
67765>>>>>>>  UShort wMonth
67765>>>>>>>  UShort wDayOfWeek
67765>>>>>>>  UShort wDay
67765>>>>>>>  UShort wHour
67765>>>>>>>  UShort wMinute
67765>>>>>>>  UShort wSecond
67765>>>>>>>  UShort wMilliSeconds
67765>>>>>>>End_Struct
67765>>>>>>>
67765>>>>>>>
67765>>>>>>>// Courtesy Of Vincent Oorsprong
67765>>>>>>>//  lpFileTime     : pointer to file time to convert
67765>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
67765>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
67766>>>>>>>
67766>>>>>>>// Courtesy Of Vincent Oorsprong
67766>>>>>>>// This function formats the time in a picture-string passed
67766>>>>>>>//
67766>>>>>>>// Picture      Meaning
67766>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
67766>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
67766>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
67766>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
67766>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
67766>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
67766>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
67766>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
67766>>>>>>>//    t         One character time marker string, such as A or P
67766>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
67766>>>>>>>//
67766>>>>>>>// For example, to get the time string  "11:29:40 PM"
67766>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
67766>>>>>>>
67766>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
67767>>>>>>>
67767>>>>>>>
67767>>>>>>>// Courtesy Of Vincent Oorsprong
67767>>>>>>>// This function formats the date in a picture-string passed
67767>>>>>>>//
67767>>>>>>>// Picture      Meaning
67767>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
67767>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
67767>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
67767>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
67767>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
67767>>>>>>>//              value associated with the specified locale.
67767>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
67767>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
67767>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
67767>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
67767>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
67767>>>>>>>//              associated with the specified locale.
67767>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
67767>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
67767>>>>>>>//    yyyy      Year represented hy full four digits.
67767>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
67767>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
67767>>>>>>>//              does not have an associated era or period string.
67767>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
67767>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
67767>>>>>>>
67767>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
67768>>>>>>>
67768>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
67768>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
67768>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
67768>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
67768>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
67768>>>>>>>
67768>>>>>>>//  Date Flags for GetDateFormatW.
67768>>>>>>>//
67768>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
67768>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
67768>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
67768>>>>>>>
67768>>>>>>>
67768>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
67769>>>>>>>
67769>>>>>>>
67769>>>>>>>// **WvA: 20-02-2004
67769>>>>>>>// While i was testing the format capabilities i stumbled over a very
67769>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
67769>>>>>>>// incorrectly into an unsigned integer.
67769>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
67769>>>>>>>// It does smell a bit fishy though
67769>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
67769>>>>>>>
67769>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
67769>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
67769>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
67769>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
67769>>>>>>>
67769>>>>>>>// Possible errors that can be returned by the shellformat function
67769>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
67769>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
67769>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
67769>>>>>>>
67769>>>>>>>
67769>>>>>>> // Courtesy Of Steve Walter,
67769>>>>>>> // USA Software, Inc
67769>>>>>>> // Format a disk
67769>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
67769>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
67770>>>>>>>
67770>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
67770>>>>>>>
67770>>>>>>>// SHCreateDirectoryEx
67770>>>>>>>
67770>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
67770>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
67770>>>>>>>//
67770>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
67770>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
67770>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
67770>>>>>>>//
67770>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
67770>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
67770>>>>>>>//        ERROR_CANCELLED.
67770>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
67770>>>>>>>
67770>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
67770>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
67770>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
67770>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
67770>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
67770>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
67770>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
67770>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
67770>>>>>>>
67770>>>>>>>//        int SHCreateDirectoryEx(
67770>>>>>>>//            HWND hwnd,
67770>>>>>>>//            LPCTSTR pszPath,
67770>>>>>>>//            const SECURITY_ATTRIBUTES *psa
67770>>>>>>>//        );
67770>>>>>>>
67770>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
67771>>>>>>>
67771>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
67772>>>>>
67772>>>>>
67772>>>>>//
67772>>>>>// Gets the string from the right of the last sStopChar in sFrom
67772>>>>>// If sStopChar has no occurences in the string an empty string is
67772>>>>>// returned.
67772>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
67774>>>>>    String  sRetVal
67774>>>>>    String  sChar
67774>>>>>    Integer iLength
67774>>>>>    Integer iPos
67774>>>>>    Boolean bStopChar
67774>>>>>    Move "" to sRetval
67775>>>>>    Move (Length(sFrom)) to iLength
67776>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
67778>>>>>        Move iLength   to iPos
67779>>>>>        Move (False)   to bStopChar
67780>>>>>        While Not bStopChar
67784>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
67785>>>>>            Decrement iPos
67786>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
67788>>>>>                Move (True) to bStopChar
67789>>>>>            End
67789>>>>>>
67789>>>>>            Else Begin
67790>>>>>                Move (sChar+sRetVal) to sRetVal
67791>>>>>            End
67791>>>>>>
67791>>>>>        Loop
67792>>>>>>
67792>>>>>    End
67792>>>>>>
67792>>>>>    Function_Return sRetVal
67793>>>>>End_Function
67794>>>>>
67794>>>>>// Pre:  sFileName contains the complete path of the file.
67794>>>>>// Post: returns the complete path of the file.
67794>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
67794>>>>>Function ParseFolderName Global String sFileName Returns String
67796>>>>>    String sFile
67796>>>>>    String sFolderName
67796>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
67796>>>>>
67796>>>>>    Move "" to sFolderName
67797>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
67798>>>>>    If sDirSep In sFileName Begin
67800>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
67801>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
67802>>>>>    End
67802>>>>>>
67802>>>>>    Else If ":" In sFileName Begin
67805>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
67806>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
67807>>>>>    End
67807>>>>>>
67807>>>>>    Function_Return sFolderName
67808>>>>>End_Function
67809>>>>>
67809>>>>>// Pre:  sFileName contains the complete path of the file.
67809>>>>>// post: The returned filename has it's path removed, but will have a extension
67809>>>>>Function ParseFileName Global String sFileName Returns String
67811>>>>>    String sFolderName
67811>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
67811>>>>>
67811>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
67812>>>>>    Get ParseFolderName sFileName to sFolderName
67813>>>>>    If (sFolderName <> "") Begin
67815>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
67816>>>>>    End
67816>>>>>>
67816>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
67817>>>>>    Function_Return sFilename
67818>>>>>End_Function
67819>>>>>
67819>>>>>// Pre:  sFileName may contain the complete path of the file.
67819>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
67819>>>>>//       return "bak" as the extension and not "gif"
67819>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
67819>>>>>//       such as "html" or "java"
67819>>>>>Function ParseFileExtension Global String sFileName Returns String
67821>>>>>    String  sFileExtension
67821>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
67822>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
67823>>>>>    Function_Return sFileExtension
67824>>>>>End_Function
67825>>>>>
67825>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
67825>>>>>
67825>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
67827>>>>>    String sMessage
67827>>>>>    Case Begin
67827>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
67829>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
67830>>>>>            Case Break
67831>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
67834>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
67835>>>>>            Case Break
67836>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
67839>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
67840>>>>>            Case Break
67841>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
67844>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
67845>>>>>            Case Break
67846>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
67849>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
67850>>>>>            Case Break
67851>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
67854>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
67855>>>>>            Case Break
67856>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
67859>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
67860>>>>>            Case Break
67861>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
67864>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
67865>>>>>            Case Break
67866>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
67869>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
67870>>>>>            Case Break
67871>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
67874>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
67875>>>>>            Case Break
67876>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
67879>>>>>            Move CS_DDE_ERR_OOM to sMessage
67880>>>>>            Case Break
67881>>>>>        Case (iErrorID = vSE_ERR_PNF)
67884>>>>>            Move CS_DDE_ERR_PNF to sMessage
67885>>>>>            Case Break
67886>>>>>        Case (iErrorID = vSE_ERR_SHARE)
67889>>>>>            Move CS_DDE_ERR_SHARE to sMessage
67890>>>>>            Case Break
67891>>>>>        Case Else
67891>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
67892>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
67893>>>>>            Case Break
67894>>>>>    Case End
67894>>>>>    Function_Return sMessage
67895>>>>>End_Function
67896>>>>>
67896>>>>>Procedure vDDE_Error_Handler Integer iErrorID
67898>>>>>    String sMessage
67898>>>>>    Get DDE_Error_To_String iErrorID to sMessage
67899>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
67900>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
67901>>>>>End_Procedure
67902>>>>>
67902>>>>>// Does the directory exist? - No = false, Yes = True
67902>>>>>// This also works with UNC path encoding and wildcards
67902>>>>>Function vFolderExists Global String sFolderName Returns Boolean
67904>>>>>    Boolean bFolderExists
67904>>>>>    Boolean bStop
67904>>>>>    String  sFolder sTmp
67904>>>>>    Integer iCh
67904>>>>>
67904>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
67904>>>>>    Move (ToANSI(Trim(sFolderName))) to sFolderName
67905>>>>>    If (sFolderName = "") Begin
67907>>>>>        Function_Return False
67908>>>>>    End
67908>>>>>>
67908>>>>>
67908>>>>>    Move True  to bFolderExists
67909>>>>>    Move False to bStop
67910>>>>>    Move "dir:" to sFolder
67911>>>>>    Append sFolder sFolderName
67912>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
67913>>>>>    Direct_Input channel iCh sFolder
67915>>>>>    Repeat
67915>>>>>>
67915>>>>>        Readln channel iCh sTmp
67917>>>>>        Move (SeqEof) to bStop
67918>>>>>        If (Trim(sTmp)="") Begin
67920>>>>>            Move False to bFolderExists
67921>>>>>        End
67921>>>>>>
67921>>>>>        Else Begin
67922>>>>>            Move True to bFolderExists
67923>>>>>            Move True to bStop
67924>>>>>        End
67924>>>>>>
67924>>>>>    Until (bStop)
67926>>>>>    Close_Input channel iCh
67928>>>>>    Send Seq_Release_Channel iCh
67929>>>>>    Function_Return bFolderExists
67930>>>>>End_Function
67931>>>>>
67931>>>>>// returns folder name if a folder was selected, otherwise returns ""
67931>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
67933>>>>>    String sFolder sTitle sPath
67933>>>>>    Pointer lpItemIdList
67933>>>>>    Integer iFolderSelected iRetval
67933>>>>>    tvBrowseInfo BrowseInfo
67933>>>>>    tvBrowseInfo BrowseInfo
67933>>>>>
67933>>>>>    Move "" to sPath
67934>>>>>    If (sDialogTitle<>"") Begin
67936>>>>>        Move sDialogTitle to sTitle
67937>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
67937>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
67937>>>>>        // These chars are correctly shown if no toansi is used.
67937>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
67937>>>>>        // selected it will always be valid.
67937>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
67938>>>>>    End
67938>>>>>>
67938>>>>>
67938>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
67939>>>>>
67939>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
67939>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
67939>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
67940>>>>>
67940>>>>>    // null 128 chars into var (make space)
67940>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
67941>>>>>
67941>>>>>    // select folder
67941>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
67942>>>>>    // get selected folder name
67942>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
67943>>>>>
67943>>>>>    // release memory resources that are used by the ItemIdList
67943>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
67944>>>>>
67944>>>>>    If (iFolderSelected<>0) Begin
67946>>>>>        Move (CString(sFolder)) to sPath
67947>>>>>    End
67947>>>>>>
67947>>>>>    Function_Return  sPath
67948>>>>>End_Function
67949>>>>>
67949>>>>>// returns 0 if the folder is created.
67949>>>>>//         1 if the API-call returned an error.
67949>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
67951>>>>>    String  sFolder
67951>>>>>    Integer iRetval bFolderCreated
67951>>>>>    tvSecurity_attributes SA
67951>>>>>    tvSecurity_attributes SA
67951>>>>>
67951>>>>>    Move False to bFolderCreated
67952>>>>>
67952>>>>>    // null MAX_PATH chars into var (make space)
67952>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
67953>>>>>
67953>>>>>    If (sNewFolder <> "") Begin
67955>>>>>
67955>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
67956>>>>>        Move  0  to SA.lpDescriptor
67957>>>>>        Move  1  to SA.bInheritHandle
67958>>>>>
67958>>>>>        //
67958>>>>>        Move (sNewFolder+"") to sFolder
67959>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
67960>>>>>    End
67960>>>>>>
67960>>>>>
67960>>>>>    If (bFolderCreated=false) Begin
67962>>>>>        Move 1 to iRetVal
67963>>>>>    End
67963>>>>>>
67963>>>>>    Function_Return iRetVal
67964>>>>>End_Function
67965>>>>>
67965>>>>>// **WvA: 03-02-2002 Function created.
67965>>>>>// With this function one can remove a directory.
67965>>>>>// returns 0 if the folder is removed.
67965>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
67965>>>>>//         2 if the folder did not exist
67965>>>>>//         3 if the sFolder parameter passed is equal to ""
67965>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
67967>>>>>    Boolean bRemoved
67967>>>>>    String  sPath
67967>>>>>    Integer iRetval
67967>>>>>
67967>>>>>    Move 0     to iRetVal
67968>>>>>    Move False to bRemoved
67969>>>>>    Move (Trim(sFolder)) to sFolder
67970>>>>>    If (sFolder="") Begin
67972>>>>>        Move 3 to iRetVal
67973>>>>>    End
67973>>>>>>
67973>>>>>    If (vFolderExists(sFolder)=False) Begin
67975>>>>>        Move 2 to iRetVal
67976>>>>>    End
67976>>>>>>
67976>>>>>    If (iRetVal=0) Begin
67978>>>>>    // null MAX_PATH chars into var (make space)
67978>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
67979>>>>>        //
67979>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
67980>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
67981>>>>>    End
67981>>>>>>
67981>>>>>
67981>>>>>    If (iRetVal=0 And bRemoved=False) Begin
67983>>>>>        Move 1 to iRetVal
67984>>>>>    End
67984>>>>>>
67984>>>>>    Function_Return iRetVal
67985>>>>>End_Function
67986>>>>>
67986>>>>>// This function informs the user that he entered a yet unknown folder and
67986>>>>>// asks if he/she wants to create the folder (Yes/No)
67986>>>>>// Choice: "Yes" - this creates the folder
67986>>>>>//                 if successful, the function returns false
67986>>>>>//                 else it will be true.
67986>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
67986>>>>>//                 For example: to stop a save
67986>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
67986>>>>>// This function returns a non-zero value if the folder isn't created afterwards
67986>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
67988>>>>>    Integer bIsNotValid
67988>>>>>    Integer iUsers_Choice
67988>>>>>    String  sMessage
67988>>>>>
67988>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
67990>>>>>        Move "The folder '" to sMessage
67991>>>>>        Append sMessage sFolderName
67992>>>>>        Append sMessage "' does not yet exist,\n"
67993>>>>>        Append sMessage "Do you want to create it now?"
67994>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
67995>>>>>        Case Begin
67995>>>>>            Case (iUsers_Choice = MBR_Yes)
67997>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
67998>>>>>                If bIsNotValid Begin
68000>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
68001>>>>>                    Append sMessage sFolderName "'.\n\n"
68003>>>>>                    Send Info_Box sMessage "Info"
68004>>>>>                End
68004>>>>>>
68004>>>>>                Case Break
68005>>>>>            Case (iUsers_Choice = MBR_No)
68008>>>>>                Move dfTrue to bIsNotValid // Cancel the save
68009>>>>>                Case Break
68010>>>>>        Case End
68010>>>>>    End
68010>>>>>>
68010>>>>>    Function_Return bIsNotValid
68011>>>>>End_Function
68012>>>>>
68012>>>>>// This will perform an operation on a file (e.g. open) with the application
68012>>>>>// registered in the Windows Registry to open that type of file (via its extension)
68012>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
68012>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
68014>>>>>    Handle  hInstance hWnd
68014>>>>>    // remove any leading/trailing spaces in the string
68014>>>>>    Move (Trim(sDocument)) to sDocument
68015>>>>>    Move (Trim(sPath))     to sPath
68016>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
68016>>>>>    Append sOperation   (Character(0))
68017>>>>>    Append sDocument    (Character(0))
68018>>>>>    Append sParameters  (Character(0))
68019>>>>>    Append sPath        (Character(0))
68020>>>>>
68020>>>>>    Get Window_Handle to hWnd
68021>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
68022>>>>>    If (hInstance <= 32) Begin
68024>>>>>        Send vDDE_Error_Handler hInstance
68025>>>>>    End
68025>>>>>>
68025>>>>>End_Procedure
68026>>>>>
68026>>>>>Class cShellFileOperations is a Array
68027>>>>>
68027>>>>>    Procedure Construct_Object
68029>>>>>        Forward Send Construct_Object
68031>>>>>        Property Integer piDeleteFlags        0
68032>>>>>        Property Integer piCopyFlags          0
68033>>>>>        Property Integer piMoveFlags          0
68034>>>>>        Property Integer piRenameFlags        0
68035>>>>>
68035>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
68036>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
68037>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
68038>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
68039>>>>>    End_Procedure
68040>>>>>
68040>>>>>    // This function uses the shell API to perform a file operation on the
68040>>>>>    // files supplied.
68040>>>>>    //
68040>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
68042>>>>>        Integer  iRetVal
68042>>>>>        Integer  iUserAbort
68042>>>>>        tvShFileOpStruct FOS
68042>>>>>        tvShFileOpStruct FOS
68042>>>>>
68042>>>>>        Move (ToAnsi(sSource)+Character(0)+Character(0))      to sSource
68043>>>>>        Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
68044>>>>>
68044>>>>>        If (eOperation <> vFO_DELETE) Begin
68046>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
68047>>>>>        End
68047>>>>>>
68047>>>>>
68047>>>>>        Move eOperation           to FOS.wFunc
68048>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
68049>>>>>        Move iFlags               to FOS.fFlags
68050>>>>>
68050>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
68051>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
68052>>>>>        If (iUserAbort <> 0) Begin
68054>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
68055>>>>>        End
68055>>>>>>
68055>>>>>        Function_Return (iRetVal)
68056>>>>>    End_Function
68057>>>>>
68057>>>>>    Function sfoDeleteFile String sFileName Returns Integer
68059>>>>>        Integer  iRetVal
68059>>>>>        Integer  iFlags
68059>>>>>
68059>>>>>        Get piDeleteFlags to iFlags
68060>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
68061>>>>>        Function_Return iRetVal
68062>>>>>    End_Function
68063>>>>>
68063>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
68065>>>>>        Integer  iRetVal
68065>>>>>        Integer  iFlags
68065>>>>>
68065>>>>>        Get piCopyFlags to iFlags
68066>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
68067>>>>>        Function_Return iRetVal
68068>>>>>    End_Function
68069>>>>>
68069>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
68071>>>>>        Integer  iRetVal
68071>>>>>        Integer  iFlags
68071>>>>>
68071>>>>>        Get piMoveFlags to iFlags
68072>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
68073>>>>>        Function_Return iRetVal
68074>>>>>    End_Function
68075>>>>>
68075>>>>>    // Rename a file or folder
68075>>>>>    // Returns a nonzero value if the operation failed.
68075>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
68077>>>>>        Integer  iRetVal
68077>>>>>        Integer  iFlags
68077>>>>>
68077>>>>>        Get piRenameFlags to iFlags
68078>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
68079>>>>>        Function_Return iRetVal
68080>>>>>    End_Function
68081>>>>>
68081>>>>>    // Courtesy Of Steve Walter
68081>>>>>    // Requires Windows 2000 and up according to msdn but it was
68081>>>>>    //  in fact available before that as an unpublished API call
68081>>>>>    //  a little google search shows that this was already available
68081>>>>>    //  in windows 95 and NT
68081>>>>>    //
68081>>>>>    // The format is controlled by the dialog interface.
68081>>>>>    // That is, the user must click the OK button To actually Begin the format
68081>>>>>    // the format cannot be started programmatically.
68081>>>>>    // An alternative to this functionality would be to use a controlpanel
68081>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
68081>>>>>    //
68081>>>>>    // hWnd = The windows handle of the object from which the format Function
68081>>>>>    //        is called.
68081>>>>>    // To Get this,
68081>>>>>    //          use:  Get Window_Handle Of <object>
68081>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
68081>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
68081>>>>>    //
68081>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
68081>>>>>    //
68081>>>>>    // iOptions = Format options.
68081>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
68081>>>>>    //  SHFMT_OPT_FULL    = Full Format
68081>>>>>    //  SHFMT_OPT_SYSONLY = System only
68081>>>>>    //  3                 = Full format with system. (unsupported)
68081>>>>>    //
68081>>>>>    // Return Values:
68081>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
68081>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
68081>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
68081>>>>>    //
68081>>>>>    //
68081>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
68081>>>>>    //                seem to work, i must have made a silly mistake
68081>>>>>    //                somewhere.
68081>>>>>    //
68081>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
68083>>>>>        Handle   hWnd
68083>>>>>        Integer  iObj
68083>>>>>        DWord    dwReturnVal
68083>>>>>        Integer iDrive
68083>>>>>
68083>>>>>        Function_Return 1 // STOP HERE
68084>>>>>
68084>>>>>        Move (Trim(sDrive)) to sDrive
68085>>>>>        If ( sDrive <> '' ) Begin
68087>>>>>            If ( sDrive Contains ':' ) Begin
68089>>>>>                Move (Replace(':',sDrive,'')) to sDrive
68090>>>>>            End
68090>>>>>>
68090>>>>>            If (Not( 'AB' Contains sDrive )) Begin
68092>>>>>                Function_Return (SHFMT_NOFORMAT)
68093>>>>>            End
68093>>>>>>
68093>>>>>            If ( sDrive = 'A' ) Begin
68095>>>>>                Move 0 to iDrive
68096>>>>>            End
68096>>>>>>
68096>>>>>            Else If ( sDrive = 'B' ) Begin
68099>>>>>                Move 1 to iDrive
68100>>>>>            End
68100>>>>>>
68100>>>>>            // Window_Handle Of Desktop equals to 0
68100>>>>>
68100>>>>>            Get focus of desktop to iObj
68101>>>>>            If (iObj>desktop) Begin
68103>>>>>                Get Container_Handle of iObj to hWnd
68104>>>>>            End
68104>>>>>>
68104>>>>>            While (hWnd=0 And iObj<>Desktop)
68108>>>>>                Get Parent of iObj to iObj
68109>>>>>                Get Container_Handle of iObj to hWnd
68110>>>>>            Loop
68111>>>>>>
68111>>>>>
68111>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
68111>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
68112>>>>>        End
68112>>>>>>
68112>>>>>        Else Begin
68113>>>>>            Move (SHFMT_ERROR) to dwReturnVal
68114>>>>>        End
68114>>>>>>
68114>>>>>        Function_Return dwReturnVal
68115>>>>>    End_Function
68116>>>>>
68116>>>>>    //Example:
68116>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
68116>>>>>    //                                          mode.
68116>>>>>
68116>>>>>End_Class
68117>>>>>
68117>>>>>Object oShellFileOperations is a cShellFileOperations
68119>>>>>End_Object
68120>>>>>
68120>>>>>// Restore to the old way of working with the shell file operations.
68120>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
68120>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
68120>>>>>Procedure vWin32fhCompatibilityMode
68122>>>>>    Integer hoSFO
68122>>>>>    Integer iFlags
68122>>>>>
68122>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
68123>>>>>    Move (oShellFileOperations(Self)) to hoSFO
68124>>>>>
68124>>>>>    Set piDeleteFlags of hoSFO to iFlags
68125>>>>>    Set piCopyFlags   of hoSFO to iFlags
68126>>>>>    Set piMoveFlags   of hoSFO to iFlags
68127>>>>>    Set piRenameFlags of hoSFO to iFlags
68128>>>>>End_Procedure
68129>>>>>
68129>>>>>// Delete a file or folder
68129>>>>>// Returns a nonzero value if the operation failed.
68129>>>>>Function vDeleteFile Global String sFileName Returns Integer
68131>>>>>    Integer  iRetVal
68131>>>>>
68131>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
68132>>>>>    Function_Return iRetVal
68133>>>>>End_Function
68134>>>>>
68134>>>>>// Copy a file or folder
68134>>>>>// Returns a nonzero value if the operation failed.
68134>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
68136>>>>>    Integer  iRetVal
68136>>>>>
68136>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68137>>>>>    Function_Return iRetVal
68138>>>>>End_Function
68139>>>>>
68139>>>>>// Move a file or folder
68139>>>>>// Returns a nonzero value if the operation failed.
68139>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
68141>>>>>    Integer  iRetVal
68141>>>>>
68141>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68142>>>>>    Function_Return iRetVal
68143>>>>>End_Function
68144>>>>>
68144>>>>>// Rename a file or folder
68144>>>>>// Returns a nonzero value if the operation failed.
68144>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
68146>>>>>    Integer  iRetVal
68146>>>>>
68146>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
68147>>>>>    Function_Return iRetVal
68148>>>>>End_Function
68149>>>>>
68149>>>>>Function vGetWindowsDirectory Returns String
68151>>>>>    String  sDirectory
68151>>>>>    Integer iVoid
68151>>>>>
68151>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
68152>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
68153>>>>>    Function_Return (CString(sDirectory))
68154>>>>>End_Function
68155>>>>>
68155>>>>>Function vGetTempPath Returns String
68157>>>>>    Integer iRetval
68157>>>>>    String  sTempPath
68157>>>>>
68157>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
68158>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
68159>>>>>    Function_Return (Cstring(sTempPath))
68160>>>>>End_Function
68161>>>>>
68161>>>>>// Courtesy of Marco Kuipers
68161>>>>>Function vMakeTempFile Returns String
68163>>>>>    Integer iRetval
68163>>>>>    String  sTempPath
68163>>>>>    String  sTempFileName
68163>>>>>    String  sPrefixString
68163>>>>>
68163>>>>>    Get vGetTempPath to sTempPath
68164>>>>>    If (sTempPath = "") Begin
68166>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
68167>>>>>        If (sTempPath<>"") Begin
68169>>>>>            Move (sTempPath+"\Temp\") to sTempPath
68170>>>>>        End
68170>>>>>>
68170>>>>>    End
68170>>>>>>
68170>>>>>
68170>>>>>    If (sTempPath = "") Begin
68172>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
68172>>>>>    // makes little sense. Leaving this in as it was old behavior.
68172>>>>>        Get_Current_Directory to sTempPath
68173>>>>>    End
68173>>>>>>
68173>>>>>
68173>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
68174>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
68176>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
68177>>>>>>
68177>>>>>    End
68177>>>>>>
68177>>>>>
68177>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
68178>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
68179>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
68180>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
68182>>>>>    //Get ShowLastError to iRetval
68182>>>>>        Move "" to sTempFileName
68183>>>>>    End
68183>>>>>>
68183>>>>>
68183>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
68184>>>>>End_Function
68185>>>>>
68185>>>>>// This function creates a uniquely named temporary file in folder sPath
68185>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
68185>>>>>// Note that you will have to cleanup the tempfile yourself as the function
68185>>>>>// does not take care of that.
68185>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
68187>>>>>    Integer iRetVal
68187>>>>>    String sTempFileName
68187>>>>>
68187>>>>>    Move (ToAnsi(sPath)+Character(0))   to sPath
68188>>>>>    Move (ToAnsi(sPrefix)+Character(0)) to sPrefix
68189>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
68190>>>>>
68190>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
68191>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
68192>>>>>    Function_Return sTempFileName
68193>>>>>End_Function
68194>>>>>
68194>>>>>//
68194>>>>>// Get a specific shell folder for example to get the desktop folder
68194>>>>>// simply call this function and pass it vCSIDL_DESKTOP
68194>>>>>//
68194>>>>>Function vSHGetFolderPath Integer eFolder Returns String
68196>>>>>    String  sFolder
68196>>>>>    Integer iVoid
68196>>>>>    Handle  hWnd
68196>>>>>
68196>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
68197>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68198>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
68199>>>>>    Function_Return (CString(sFolder))
68200>>>>>End_Function
68201>>>>>
68201>>>>>// Courtesy Of Vincent Oorsprong
68201>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
68203>>>>>    String  sFormattedTime sFormattedDate
68203>>>>>    String  sFileDateTime
68203>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
68203>>>>>    tvFileTime   FileTime
68203>>>>>    tvFileTime   FileTime
68203>>>>>    tvSystemTime SystemTime
68203>>>>>    tvSystemTime SystemTime
68203>>>>>
68203>>>>>    Move "" to sFileDateTime
68204>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
68205>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
68206>>>>>
68206>>>>>    Move 0 to SystemTime.wYear
68207>>>>>
68207>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
68208>>>>>    If (iSuccess = 1) Begin
68210>>>>>        Move (ZeroString(255))        to sFormattedTime
68211>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
68212>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
68213>>>>>        Move (ZeroString(255))        to sFormattedDate
68214>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
68215>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
68216>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
68217>>>>>    End
68217>>>>>>
68217>>>>>    Function_Return sFileDateTime
68218>>>>>End_Function
68219>>>>>
68219>>>>>// **WvA:
68219>>>>>// A windows replacement for the standard function FileExists.
68219>>>>>// This version will also return (true) for a file when it is open by an application.
68219>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
68219>>>>>// Example: Get vFilePathExists "C:\config.sy?"
68219>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
68219>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
68221>>>>>    String  sDirSep
68221>>>>>    Handle  hFindFile
68221>>>>>    Integer iVoid
68221>>>>>    tvWin32FindData FindData
68221>>>>>    tvWin32FindData FindData
68221>>>>>
68221>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
68222>>>>>    Move (ToANSI(Trim(sFilePathMask))) to sFilePathMask
68223>>>>>
68223>>>>>    If (Length(sFilePathMask)>0) Begin
68225>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
68225>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68226>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
68230>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
68231>>>>>        Loop
68232>>>>>>
68232>>>>>
68232>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68233>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
68234>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
68235>>>>>    End
68235>>>>>>
68235>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
68236>>>>>End_Function
68237>>>>>
68237>>>>>//
68237>>>>>// WideChar version of the function, do not use, it's an experiment
68237>>>>>//
68237>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
68239>>>>>    Handle  hFindFile
68239>>>>>    Integer iVoid
68239>>>>>    tvWin32FindData FindData
68239>>>>>    tvWin32FindData FindData
68239>>>>>
68239>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
68240>>>>>
68240>>>>>    If (Length(sFilePathMask)>0) Begin
68242>>>>>
68242>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68243>>>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
68244>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
68245>>>>>    End
68245>>>>>>
68245>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
68246>>>>>End_Function
68247>>>>>
68247>>>>>// **WvA
68247>>>>>// Formats a foldername by first trimming it and after that by sticking a
68247>>>>>// directory separator (/\) to the end if it doesn't have one there already.
68247>>>>>// The folder may contain a drive letter or UNC encoding.
68247>>>>>Function vFolderFormat Global String sFolderName Returns String
68249>>>>>    String sDirSep
68249>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
68250>>>>>    Move (Trim(sFolderName)) to sFolderName
68251>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
68253>>>>>        Move (sFolderName+sDirSep) to sFolderName
68254>>>>>    End
68254>>>>>>
68254>>>>>    Function_Return sFolderName
68255>>>>>End_Function
68256>>>>>
68256>>>>>//
68256>>>>>// Returns the amount of files in the folder (if it exists)
68256>>>>>// Returns -1 if folder doesn't exist.
68256>>>>>// The files "." and ".." are not counted.
68256>>>>>//
68256>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
68258>>>>>    Boolean bFound
68258>>>>>    Handle  hFindFile
68258>>>>>    Integer iCount  iVoid
68258>>>>>    Integer iSuccess
68258>>>>>    String  sFileName
68258>>>>>    tvWin32FindData FindData
68258>>>>>    tvWin32FindData FindData
68258>>>>>
68258>>>>>    Move -1 to iCount
68259>>>>>    Get vFolderFormat sFolderName to sFolderName
68260>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
68261>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68262>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
68263>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
68264>>>>>    If (bFound) Begin
68266>>>>>        Move 0 to iCount
68267>>>>>    End
68267>>>>>>
68267>>>>>    While (bFound)
68271>>>>>        Increment iCount
68272>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
68273>>>>>        If (sFileName="." or sFileName="..") Begin
68275>>>>>            Decrement iCount
68276>>>>>        End
68276>>>>>>
68276>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
68277>>>>>        Move (iSuccess<>0) to bFound
68278>>>>>    Loop
68279>>>>>>
68279>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
68280>>>>>    Function_Return iCount
68281>>>>>End_Function
68282>>>>>
68282>>>>>//
68282>>>>>// Gets the parent path of the currently supplied path
68282>>>>>// Returns "" when we are at the root folder.
68282>>>>>//
68282>>>>>Function vParentPath Global String sPath Returns String
68284>>>>>    String sStrip sDirSep
68284>>>>>
68284>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
68285>>>>>    Move (Trim(sPath)) to sPath
68286>>>>>    If (Right(sPath,1) = sDirSep) Begin
68288>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
68289>>>>>    End
68289>>>>>>
68289>>>>>    If (Pos(sDirSep, sPath)) Begin
68291>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
68292>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
68293>>>>>    End
68293>>>>>>
68293>>>>>    Else Begin
68294>>>>>        Move "" to sPath
68295>>>>>    End
68295>>>>>>
68295>>>>>    Function_Return sPath
68296>>>>>End_Function
68297>>>>>
68297>>>>>// Create the folder, including intermediate directories.
68297>>>>>// Don't panic if the folder already exists.
68297>>>>>// Michael Mullan June 2009.
68297>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
68299>>>>>    String  sFolder
68299>>>>>    Integer iRetval iFolderCreated
68299>>>>>    tvSecurity_attributes SA
68299>>>>>    tvSecurity_attributes SA
68299>>>>>
68299>>>>>    Move 0 to iFolderCreated
68300>>>>>
68300>>>>>    // null MAX_PATH chars into var (make space)
68300>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
68301>>>>>    If (sNewFolder <> "") Begin
68303>>>>>
68303>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
68304>>>>>        Move  0  to SA.lpDescriptor
68305>>>>>        Move  1  to SA.bInheritHandle
68306>>>>>
68306>>>>>        //
68306>>>>>        Move (sNewFolder+"") to sFolder
68307>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
68308>>>>>    End
68308>>>>>>
68308>>>>>
68308>>>>>    If (iFolderCreated <> 0) Begin
68310>>>>>        Move 1 to iRetVal
68311>>>>>        Case Begin
68311>>>>>            Case (iFolderCreated = 161)
68313>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
68314>>>>>>
68314>>>>>                Case Break
68315>>>>>            Case (iFolderCreated = 206)
68318>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
68319>>>>>>
68319>>>>>                Case Break
68320>>>>>            Case (iFolderCreated = 3)
68323>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
68324>>>>>>
68324>>>>>                Case Break
68325>>>>>            Case (iFolderCreated = 80)
68328>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
68329>>>>>                Case Break
68330>>>>>            Case (iFolderCreated = 183)
68333>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
68334>>>>>                Case Break
68335>>>>>            Case (iFolderCreated = 1223)
68338>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
68339>>>>>>
68339>>>>>                Case Break
68340>>>>>            Case Else
68340>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
68341>>>>>>
68341>>>>>        Case End
68341>>>>>    End
68341>>>>>>
68341>>>>>    Function_Return iRetVal
68342>>>>>End_Function
68343>>>>>
68343>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
68345>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
68345>>>>>    Integer iFileSize iVoid
68345>>>>>    Handle  hFindFile
68345>>>>>    tvWin32FindData FindData
68345>>>>>    tvWin32FindData FindData
68345>>>>>
68345>>>>>    Move (sFileName+"") to sFileName
68346>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
68347>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
68348>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
68350>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
68351>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
68352>>>>>    End
68352>>>>>>
68352>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
68353>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
68354>>>>>
68354>>>>>    Function_Return iFileSize
68355>>>>>End_Function
68356>>>>>
68356>>>>>//
68356>>>>>// Based on code in Peter Crook's Browse folder workspace
68356>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
68356>>>>>//
68356>>>>>//=============================================================================
68356>>>>>// Verifies that a path is a valid directory.
68356>>>>>//
68356>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
68356>>>>>//
68356>>>>>// Parameters:
68356>>>>>//      sPath - Address of the path to verify.
68356>>>>>//=============================================================================
68356>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
68358>>>>>    Integer iResult
68358>>>>>    Boolean bRetVal
68358>>>>>
68358>>>>>    Move false to bRetVal
68359>>>>>    Move (ToAnsi(sPath) - Character (0)) to sPath
68360>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
68361>>>>>    If (iResult<>0) Begin
68363>>>>>        Move True to bRetVal
68364>>>>>    End
68364>>>>>>
68364>>>>>
68364>>>>>    Function_Return bRetVal
68365>>>>>End_Function
68366>>>>>
68366>>>Use cFilesystem.pkg
Including file: cFilesystem.pkg    (C:\Projects\DF18\DfRefactor\Libraries\cFileSystem\AppSrc\cFilesystem.pkg)
68366>>>>>//************************************************************************
68366>>>>>//*** FileSystem - Binary file operations For VDF15+.
68366>>>>>//************************************************************************
68366>>>>>//*** Based on original package: akefs.pkg
68366>>>>>//*** Version: 4.0
68366>>>>>//*** (C) NordTeam Gruppen, NOVAX A/S
68366>>>>>//***
68366>>>>>//*** Author......: Allan Kim Eriksen
68366>>>>>//*** Created.....: 23/08 2001
68366>>>>>//***
68366>>>>>//*** Rev History.: 31/08 2018 Nils Svedmyr. Added Functions from Akefs.pkg
68366>>>>>//***               to get/set file date/time and procedure SetFileLastWriteTime.
68366>>>>>//***               Refactored functions FileSize & FileDate to only have one Function_Return,
68366>>>>>//***               and changed a couple of While loops to end with a "loop" word instead of "End".
68366>>>>>//***
68366>>>>>//************************************************************************
68366>>>>>// cFilesystem class with functions and procedures to access binary files.
68366>>>>>// Filenumbers are not limited to 10 but only to system resources.
68366>>>>>// Also windows API calls For file copy, file move ect.
68366>>>>>// This class is For vdf 15 and up.
68366>>>>>// This class is not limited to 2 GB but can handle filesizes up $7FFFFFFFFFFFFFFF (9 exabyte)
68366>>>>>
68366>>>>>//************************************************************************
68366>>>>>// Be aware that argument_size has to be larger
68366>>>>>// than the requested amount of bytes read in the buffer for
68366>>>>>// BytesFromBinaryFile.
68366>>>>>//************************************************************************
68366>>>>>
68366>>>>>//************************************************************************
68366>>>>>// Constants used For the external functions.
68366>>>>>//************************************************************************
68366>>>>>// fsCreatefile.
68366>>>>>    Define GENERIC_READ for            |CI$80000000
68366>>>>>    Define GENERIC_WRITE for           |CI$40000000
68366>>>>>    Define GENERIC_RANDOM for          (GENERIC_READ + GENERIC_WRITE)
68366>>>>>    Define CREATE_NEW for              |CI$00000001
68366>>>>>    Define CREATE_ALWAYS for           |CI$00000002
68366>>>>>    Define OPEN_EXISTING for           |CI$00000003
68366>>>>>    Define OPEN_ALWAYS for             |CI$00000004
68366>>>>>    Define TRUNCATE_EXISTING for       |CI$00000005
68366>>>>>
68366>>>>>
68366>>>>>    Define FILE_SHARE_READ for         |CI$1
68366>>>>>    Define FILE_SHARE_WRITE for        |CI$2
68366>>>>>    Define FILE_SHARE_RANDOM for       (FILE_SHARE_READ + FILE_SHARE_WRITE)
68366>>>>>
68366>>>>>// Generel.
68366>>>>>Define FNULL For                   |CI$0
68366>>>>>
68366>>>>>// FormatString.
68366>>>>>
68366>>>>>// SetFilePosition.
68366>>>>>Define FILE_BEGIN For     0
68366>>>>>Define FILE_CURRENT For  1
68366>>>>>Define FILE_END For      2
68366>>>>>Define INVALID_SET_FILE_POINTER For |CI$FFFFFFFF
68366>>>>>
68366>>>>>// FindFile.
68366>>>>>
68366>>>>>Define ERROR_NO_MORE_FILES    For |CI18
68366>>>>>Define ERROR_MOD_NOT_FOUND    For |CI126
68366>>>>>
68366>>>>>
68366>>>>>
68366>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileFlags.
68366>>>>>
68366>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileOS.
68366>>>>>Define VOS_DOS          For |CI$10000
68366>>>>>Define VOS_NT           For |CI$40000
68366>>>>>Define VOS_WINDOWS16    For |CI$00001
68366>>>>>Define VOS_WINDOWS32    For |CI$00004
68366>>>>>Define VOS_OS216        For |CI$20000
68366>>>>>Define VOS_OS232        For |CI$30000
68366>>>>>Define VOS_PM16         For |CI$00002
68366>>>>>Define VOS_PM32         For |CI$00003
68366>>>>>Define VOS_UNKNOWN      For |CI$00000
68366>>>>>
68366>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileType.
68366>>>>>Define VFT_APP          For |CI$01
68366>>>>>Define VFT_DLL          For |CI$02
68366>>>>>Define VFT_DRV          For |CI$03
68366>>>>>Define VFT_FONT         For |CI$04
68366>>>>>Define VFT_STATIC_LIB   For |CI$07
68366>>>>>Define VFT_UNKNOWN      For |CI$00
68366>>>>>Define VFT_VXD          For |CI$05
68366>>>>>
68366>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_DRV.
68366>>>>>Define VFT2_DRV_COMM                For |CI$0A
68366>>>>>Define VFT2_DRV_DISPLAY             For |CI$04
68366>>>>>Define VFT2_DRV_INSTALLABLE         For |CI$08
68366>>>>>Define VFT2_DRV_KEYBOARD            For |CI$02
68366>>>>>Define VFT2_DRV_LANGUAGE            For |CI$03
68366>>>>>Define VFT2_DRV_MOUSE               For |CI$05
68366>>>>>Define VFT2_DRV_NETWORK             For |CI$06
68366>>>>>Define VFT2_DRV_PRINTER             For |CI$01
68366>>>>>Define VFT2_DRV_SOUND               For |CI$09
68366>>>>>Define VFT2_DRV_SYSTEM              For |CI$07
68366>>>>>Define VFT2_DRV_VERSIONED_PRINTER   For |CI$0C
68366>>>>>
68366>>>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_FONT.
68366>>>>>Define VFT2_FONT_RASTER             For |CI$01
68366>>>>>Define VFT2_FONT_TRUETYPE           For |CI$03
68366>>>>>Define VFT2_FONT_VECTOR             For |CI$02
68366>>>>>
68366>>>>>Define VFT2_UNKNOWN                 For |CI$00
68366>>>>>
68366>>>>>Define FS_FILEHANDLEMISSING For "The filehandle does not exists For the current filenumber."
68366>>>>>
68366>>>>>// Filesearch
68366>>>>>Enum_List
68366>>>>>    Define DIRMODE_FILES_ONLY For 1
68366>>>>>    Define DIRMODE_DIRECTORIES_ONLY
68366>>>>>    Define DIRMODE_FILES_AND_DIRECTORIES
68366>>>>>End_Enum_List
68366>>>>>
68366>>>>>//************************************************************************
68366>>>>>// Declarations of external functions.
68366>>>>>// Functions that needs variables For output are made global stings or
68366>>>>>// integers, and can be found on top of the declaration.
68366>>>>>//************************************************************************
68366>>>>>External_Function fsCreatefile "CreateFileA" kernel32.dll ;String sFile ;        //filenameDWord dwDesAccess ;   // access modeDWord dwShare ;       // share modePointer lpSecAtt ;    // SDDWord dwCrDisp ;      // how to createDWord dwFlags ;       // file attributesHandle hTempFile ;    // handle to template filReturns Integer       //Returns handle that can be used to access the object
68367>>>>>
68367>>>>>External_Function fsGetLastError "GetLastError" kernel32.dll Returns Integer
68368>>>>>
68368>>>>>External_Function fsFormatMessage "FormatMessageA" kernel32.dll ;DWord dwFlags ;         // source and processing optionsPointer lpSrc ;         // message sourceDWord dwMsgId ;         // message identifierDWord dwLngId ;         // language identifierPointer lpBuf ;         // message bufferDWord nSize ;           // maximum size of message bufferPointer Arg ;           // array of message insertsReturns Integer
68369>>>>>
68369>>>>>External_Function fsLocalFree "LocalFree" kernel32.dll ;Handle hMem ;   // A handle to the local memory object.Returns Integer
68370>>>>>
68370>>>>>External_Function fsCloseHandle "CloseHandle" kernel32.dll ;Handle hObject ;        // handle to objectReturns Integer
68371>>>>>
68371>>>>>External_Function fsReadFile "ReadFile" kernel32.dll ;Handle hFile ;          // handle to filePointer lpBuffer ;      // data bufferDWord nBytesToRead ;    // number of bytes to readPointer lpBytesRead ;   // number of bytes readPointer lpOverlapped ;  // overlapped bufferReturns Integer
68372>>>>>
68372>>>>>External_Function fsWriteFile "WriteFile" kernel32.dll ;Handle hFile ;              // handle to filePointer lpBuf ;             // data bufferDWord nNumBytesWrt ;        // number of bytes to writePointer lpNumBytesWritten ; // number of bytes writtenPointer lpOverlapped ;      // overlapped bufferReturns Integer
68373>>>>>
68373>>>>>External_Function fsGetFileSizeEx "GetFileSizeEx" kernel32.dll ;Handle hFile ;           // handle to filePointer lpFileSizeHigh ; // A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.Returns Integer
68374>>>>>
68374>>>>>External_Function fsSetFilePointer "SetFilePointer" kernel32.dll ;Handle hFile ;              // handle to fileUInteger lDistanceToMove ;    // The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.Pointer lpDistanceToMoveHigh ;  // A pointer to the high order 32-bits of the signed 64-bit distance to move.DWord dwMoveMethod ;        // The starting point For the file pointer move.Returns UInteger
68375>>>>>
68375>>>>>External_Function fsSetEndOfFile "SetEndOfFile" kernel32.dll ;Handle hFile ;              // handle to the file to have its EOF position moved.Returns Integer             // nonzero if success
68376>>>>>
68376>>>>>External_Function fsDeleteFile "DeleteFileA" Kernel32.Dll ;String  sFileName ;             // Pointer to a null-terminated string that specifies the file to be deleted.Returns Integer
68377>>>>>
68377>>>>>External_Function fsMoveFile "MoveFileA" Kernel32.Dll ;String  sExistingFileName ;     // Pointer to a null-terminated string that names an existing file or directory.String  sNewFileName ;          // Pointer to a null-terminated string that specifies the new name of a file or directory.Returns Integer                 // The new name must Not already exist. A new File may be on A different File system Or drive. A new directory must be on the same drive.
68378>>>>>
68378>>>>>External_Function fsCopyFile "CopyFileA" Kernel32.Dll ;String  sExistingFileName ;     // Pointer to a null-terminated string that specifies the name of an existing file.String  sNewFileName ;          // Pointer to a null-terminated string that specifies the name of the new file.Boolean bFailIfExists ;         // If bFailIfExists is TRUE and the new file specified by lpNewFileName already exists, the function fails.Returns Integer                 // If bFailIfExists is FALSE and the new file already exists, the function overwrites the existing file and succeeds.
68379>>>>>
68379>>>>>External_Function fsFindFirstFile "FindFirstFileA" Kernel32.Dll ;String  sFileName ;             // Pointer to a null-terminated string that specifies a valid directory or path and file name, which can contain wildcard characters (* and ?).Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
68380>>>>>
68380>>>>>External_Function fsFindNextFile "FindNextFileA" Kernel32.Dll ;Handle hFindFile ;              // handle returned by a previous call to the FindFirstFile function.Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
68381>>>>>
68381>>>>>External_Function fsFindClose "FindClose" Kernel32.dll ;Handle hFindFile ;              // File search handle. This handle must have been previously opened by the FindFirstFile function.Returns Integer
68382>>>>>
68382>>>>>External_Function fsGetFileTime "GetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with read accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
68383>>>>>
68383>>>>>External_Function fsSetFileTime "SetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with write accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
68384>>>>>
68384>>>>>External_function fsGetSystemTimeAsFileTime "GetSystemTimeAsFileTime" Kernel32.dll ;Pointer lpSystemTimeAsFileTime ;   // Pointer to a FILETIME structure containing the current system time in filetimme formatReturns Integer
68385>>>>>
68385>>>>>External_Function fsFileTimeToSystemTime "FileTimeToSystemTime" Kernel32.dll ;Pointer lpFiletime ;            // Pointer to a FILETIME structure containing the file time to convert to system date and time format.Pointer lpSystemtime ;          // Pointer to a SYSTEMTIME structure to receive the converted file time.Returns Integer
68386>>>>>
68386>>>>>External_Function fsSystemTimeToTzSpecificLocalTime "SystemTimeToTzSpecificLocalTime" Kernel32.dll ;Pointer lpTimeZone ;            // A pointer to a TIME_ZONE_INFORMATION structure that specifies the time zone of interest.Pointer lpUniversalTime ;       // A pointer to a SYSTEMTIME structure that specifies a time, in UTC.Pointer lpLocalTime ;           // A pointer to a SYSTEMTIME structure that receives the local time.Returns Integer
68387>>>>>
68387>>>>>External_Function fsGetTempFileName "GetTempFileNameA" kernel32.dll ;String  sPathname ;String  sPrefixString ;Integer iUnique ;Pointer sTempFileName ;Returns Integer
68388>>>>>
68388>>>>>External_Function fsGetTempPath "GetTempPathA" Kernel32.Dll ;Integer nBufferLength ;Pointer lpBuffer ;Returns Integer
68389>>>>>
68389>>>>>External_Function fsCreateDirectory "CreateDirectoryA" Kernel32.dll ;String  sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be created.Pointer lpSecAttributes ;       // Pointer to a SECURITY_ATTRIBUTES structure.Returns Integer
68390>>>>>
68390>>>>>External_Function fsRemoveDirectory "RemoveDirectoryA" Kernel32.dll ;String  sDirName ;              // Pointer to a null-terminated string that specifies the path of the directory to be removed.Returns Integer
68391>>>>>
68391>>>>>External_Function fsExtractAssociatedIcon "ExtractAssociatedIconA" shell32.dll ;Handle hInst ;Pointer lpIconPath ;Integer lpiIcon ;Returns Handle
68392>>>>>
68392>>>>>External_Function fsDestroyIcon "DestroyIcon" User32.dll ;Handle hIcon ;Returns Integer
68393>>>>>
68393>>>>>External_Function fsGetFileVersionInfoSize "GetFileVersionInfoSizeA" Version.dll ;String  sFilename ;             // The name of the file of interest. The function uses the search sequence specified by the LoadLibrary function.Pointer lpHandle ;              // A pointer to a variable that the function sets to zero.Returns UInteger
68394>>>>>
68394>>>>>External_Function fsGetFileVersionInfo "GetFileVersionInfoA" Version.dll ;String  sFilename ;             // The name of the file. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.DWord   dwHandle ;              // This parameter is ignored.DWord   dwLen ;                 // The size, in bytes, of the buffer pointed to by the lpData parameter.Pointer lpData ;                // Pointer to a buffer that receives the file-version information.Returns Boolean
68395>>>>>
68395>>>>>External_Function fsVerQueryValue "VerQueryValueA" Version.dll ;Pointer lpBlock ;               // The version-information resource returned by the GetFileVersionInfo function.String  sSubBlock ;             // The version-information value to be retrieved.Pointer lplpBuffer ;            // When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by lpBlock.Pointer lpLen ;                 // When this method returns, contains a pointer to the size of the requested data pointed to by lpBuffer.Returns Boolean
68396>>>>>
68396>>>>>//************************************************************************
68396>>>>>// Structures
68396>>>>>//************************************************************************
68396>>>>>
68396>>>>>// Nils 2018-08-30 Added For the SourceCodeTools project
68396>>>>>// so we don't need to use both Akefs.pkg and this package.
68396>>>>>// A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
68396>>>>>Struct tFileTime
68396>>>>>    DWord dwLowDateTime    // Low-order part of the file time.
68396>>>>>    DWord dwHighDateTime   // High-order part of the file time.
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct structWFD  // Used by FindFirstFile
68396>>>>>    DWord    dwFileAttributes
68396>>>>>    UBigInt  ftCreationDateTime
68396>>>>>    UBigInt  ftLastAccessDateTime
68396>>>>>    UBigInt  ftLastWriteDateTime
68396>>>>>    UInteger nFileSizeHigh
68396>>>>>    UInteger nFileSizeLow
68396>>>>>    DWord    dares
68396>>>>>    DWord    dbres
68396>>>>>    UChar[MAX_PATH] cFileName
68396>>>>>    UChar[14]       cAlternateFileName
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct structSystemTime
68396>>>>>    UShort wYear
68396>>>>>    UShort wMonth
68396>>>>>    UShort wDayOfWeek
68396>>>>>    UShort wDay
68396>>>>>    UShort wHour
68396>>>>>    UShort wMinute
68396>>>>>    UShort wSecond
68396>>>>>    UShort wMillieseconds
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct structFile
68396>>>>>    Handle hFilehandle
68396>>>>>    String sFilename    // Assigned filename in OEM format.
68396>>>>>    Boolean bEndOfFile  // True then the end of the binary file had been read.
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct structFileBufferPointer
68396>>>>>    Integer iBufferPointer
68396>>>>>    Integer iBufferSize
68396>>>>>    BigInt biFromFilePosition
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct tsSearchResult
68396>>>>>    String sFilename
68396>>>>>    String sAlternateFileName   // 8.3 format
68396>>>>>    DateTime dtCreationDateTime
68396>>>>>    DateTime dtLastAccessDateTime
68396>>>>>    DateTime dtLastWriteDateTime
68396>>>>>    BigInt biFileSize
68396>>>>>    Integer iFileAttributes
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct tsVS_FIXEDFILEINFO
68396>>>>>    DWord dwSignature
68396>>>>>    DWord dwStrucVersion
68396>>>>>    DWord dwFileVersionMS
68396>>>>>    DWord dwFileVersionLS
68396>>>>>    DWord dwProductVersionMS
68396>>>>>    DWord dwProductVersionLS
68396>>>>>    DWord dwFileFlagsMask
68396>>>>>    DWord dwFileFlags
68396>>>>>    DWord dwFileOS
68396>>>>>    DWord dwFileType
68396>>>>>    DWord dwFileSubtype
68396>>>>>    //    DWord dwFileDateMS
68396>>>>>    //    DWord dwFileDateLS
68396>>>>>    UBigInt ubiFileDate
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct tsFileVersionInfo
68396>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
68396>>>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
68396>>>>>    Short[] siFileVersion
68396>>>>>    Short[] siProductVersion
68396>>>>>    DateTime dtCreationDateTime
68396>>>>>    String sComments
68396>>>>>    String sCompanyName
68396>>>>>    String sFileDescription
68396>>>>>    String sFileVersion
68396>>>>>    String sInternalName
68396>>>>>    String sLegalCopyright
68396>>>>>    String sLegalTrademarks
68396>>>>>    String sOriginalFilename
68396>>>>>    String sProductName
68396>>>>>    String sProductVersion
68396>>>>>    String sPrivateBuild
68396>>>>>    String sSpecialBuild
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Struct tsLandAndCodePage
68396>>>>>    UShort wLanguage
68396>>>>>    UShort wCodePage
68396>>>>>End_Struct
68396>>>>>
68396>>>>>Register_Function FileErrorText Integer iFilenumber Returns String
68396>>>>>
68396>>>>>//************************************************************************
68396>>>>>// The filesystem class
68396>>>>>//************************************************************************
68396>>>>>Class cFilesystem is a cObject
68397>>>>>
68397>>>>>    Procedure Construct_Object
68399>>>>>        Forward Send Construct_Object
68401>>>>>
68401>>>>>        // True then the end of the binary file had been read - not when $1A (EOF) is met.
68401>>>>>        // Legacy property. Use the BinaryFileEndOfFile function instead.
68401>>>>>        Property Boolean pbEOF False
68402>>>>>
68402>>>>>        // True if any error has occured during fileoprerations.
68402>>>>>        Property Boolean pbError False
68403>>>>>
68403>>>>>        // If errormessages should be called with dataflex error command set this to true
68403>>>>>        Property Boolean pbErrorAsVDFError False
68404>>>>>
68404>>>>>        // Keeps assigned handles and filenames For each filenumber.
68404>>>>>        // private
68404>>>>>        Property structFile[] plsFile
68405>>>>>
68405>>>>>        // Keeps read cached buffers For each filenumer. Used For BinaryReadChcheu
68405>>>>>        // private
68405>>>>>        Property String[] psaCachedBuffer
68406>>>>>
68406>>>>>        // Pointers For cached buffers.
68406>>>>>        // private
68406>>>>>        Property structFileBufferPointer[] plsCachedPointer
68407>>>>>    End_Procedure
68408>>>>>
68408>>>>>    // Returns the next available filenumber For a binary file.
68408>>>>>    Function BinaryFileNextFilenumber Returns Integer
68410>>>>>        structFile[] lsFile
68410>>>>>        structFile[] lsFile
68411>>>>>        Integer iMaxFiles iCurrentFile iNextFileNumber
68411>>>>>        Get plsFile to lsFile
68412>>>>>        Move (SizeOfArray(lsFile)) to iMaxFiles
68413>>>>>        Move -1 to iNextFileNumber
68414>>>>>        Move 0 to iCurrentFile
68415>>>>>        While (iCurrentFile < iMaxFiles and iNextFileNumber = -1)
68419>>>>>            If (lsFile[iCurrentFile].hFilehandle = 0) Begin
68421>>>>>                Move iCurrentFile to iNextFileNumber
68422>>>>>            End
68422>>>>>>
68422>>>>>            Else Begin
68423>>>>>                Increment iCurrentFile
68424>>>>>            End
68424>>>>>>
68424>>>>>        Loop
68425>>>>>>
68425>>>>>        If (iNextFileNumber = -1) Begin
68427>>>>>            Move iMaxFiles to iNextFileNumber
68428>>>>>        End
68428>>>>>>
68428>>>>>        Function_Return iNextFileNumber
68429>>>>>    End_Function
68430>>>>>
68430>>>>>    // Opens a binary file.
68430>>>>>    // If bShared is false or not pharsed the file is opened in exclusive.
68430>>>>>    // If bShared is True the file is opened with both read and write shared mode
68430>>>>>    // If bCreate is True the file is created if it does not exist already.
68430>>>>>    // If bReadOnly is True the file is opened with only read access (and only read shared mode if bShared is also true).
68430>>>>>    // Returns true if the file was opened or created without error.
68430>>>>>    Function BinaryFileOpen Integer iFilenumber String sFilename Boolean bShared Boolean bCreate Boolean bReadOnly Returns Boolean
68432>>>>>        Integer iReturnValue iErrornumber
68432>>>>>        DWord dwSharedMode dwCreateMode dwAccessMode
68432>>>>>        structFile[] lsFile
68432>>>>>        structFile[] lsFile
68433>>>>>        String sFilenameANSI
68433>>>>>        Boolean bOk bFilehandleOK
68433>>>>>        Get plsFile to lsFile
68434>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
68436>>>>>            If (lsFile[iFilenumber].hFilehandle = 0) Begin
68438>>>>>                Move True to bFilehandleOK
68439>>>>>            End
68439>>>>>>
68439>>>>>        End
68439>>>>>>
68439>>>>>        Else Begin
68440>>>>>            Move True to bFilehandleOK
68441>>>>>        End
68441>>>>>>
68441>>>>>        If bFilehandleOK Begin
68443>>>>>            Move sFilename to lsFile[iFilenumber].sFilename
68444>>>>>            Move (ToAnsi(sFilename)) To sFilenameANSI
68445>>>>>            Set pbError to False
68446>>>>>            Move False to bOk
68447>>>>>            Move GENERIC_RANDOM to dwAccessMode
68448>>>>>            Move FNULL to dwSharedMode
68449>>>>>            If (num_arguments > 2) Begin
68451>>>>>                If (bShared = True) Begin
68453>>>>>                    Move FILE_SHARE_RANDOM to dwSharedMode
68454>>>>>                End
68454>>>>>>
68454>>>>>            End
68454>>>>>>
68454>>>>>            Move OPEN_EXISTING to dwCreateMode
68455>>>>>            If (num_arguments > 3) Begin
68457>>>>>                If (bCreate = True) Begin
68459>>>>>                    Move OPEN_ALWAYS to dwCreateMode
68460>>>>>                End
68460>>>>>>
68460>>>>>            End
68460>>>>>>
68460>>>>>            If (num_arguments > 4) Begin
68462>>>>>                If (bReadOnly = True) Begin
68464>>>>>                    Move GENERIC_READ to dwAccessMode
68465>>>>>                    If (bShared = True) Begin
68467>>>>>                        Move FILE_SHARE_READ to dwSharedMode
68468>>>>>                    End
68468>>>>>>
68468>>>>>                End
68468>>>>>>
68468>>>>>            End
68468>>>>>>
68468>>>>>            Append sFilenameANSI (Character(0)) (Character(0))
68470>>>>>            Move (fsCreatefile(sFilenameANSI, dwAccessMode, dwSharedMode, FNULL, dwCreateMode, FILE_ATTRIBUTE_NORMAL, FNULL)) to iReturnValue
68471>>>>>            If (iReturnValue = INVALID_HANDLE_VALUE) Begin
68473>>>>>                Move (fsGetLastError()) to iErrornumber
68474>>>>>                If iErrornumber Begin
68476>>>>>                    Send DoShowError iErrornumber ("File: "+ sFilename)
68477>>>>>                End
68477>>>>>>
68477>>>>>            End
68477>>>>>>
68477>>>>>            Else Begin
68478>>>>>                Move iReturnValue to lsFile[iFilenumber].hFilehandle
68479>>>>>                Move False to lsFile[iFilenumber].bEndOfFile
68480>>>>>                Set plsFile to lsFile
68481>>>>>                Set pbEOF to False
68482>>>>>                Move True to bOk
68483>>>>>            End
68483>>>>>>
68483>>>>>        End
68483>>>>>>
68483>>>>>        Else Begin
68484>>>>>            Send warning_box "The filenumber is already used."
68485>>>>>        End
68485>>>>>>
68485>>>>>        Function_Return bOk
68486>>>>>    End_Function
68487>>>>>
68487>>>>>    // Closing a binary file
68487>>>>>    // Returns true if the file could be closed.
68487>>>>>    Function BinaryFileClose Integer iFilenumber Returns Boolean
68489>>>>>        Integer iRetVal iErrorNumber
68489>>>>>        Handle hHandle
68489>>>>>        structFile[] lsFile
68489>>>>>        structFile[] lsFile
68490>>>>>        structFileBufferPointer[] lsFileBufferPointer
68490>>>>>        structFileBufferPointer[] lsFileBufferPointer
68491>>>>>        String[] saCachedBuffer
68492>>>>>        Boolean bOk
68492>>>>>        Get BinaryFileHandle iFilenumber to hHandle
68493>>>>>        Set pbError to False
68494>>>>>        Move False to bOk
68495>>>>>        If hHandle Begin
68497>>>>>            Move (fsCloseHandle(hHandle)) to iRetVal
68498>>>>>            If (iRetVal = 0) Begin           // Could not close
68500>>>>>                Move (fsGetLastError()) to iErrorNumber
68501>>>>>                If iErrorNumber Begin
68503>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68504>>>>>                End
68504>>>>>>
68504>>>>>            End
68504>>>>>>
68504>>>>>            Else Begin
68505>>>>>                Get plsFile to lsFile
68506>>>>>                Get plsCachedPointer to lsFileBufferPointer
68507>>>>>                Get psaCachedBuffer to saCachedBuffer
68508>>>>>                Move 0 to lsFile[iFilenumber].hFilehandle
68509>>>>>                Move "" to saCachedBuffer[iFilenumber]
68510>>>>>                Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
68511>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].iBufferSize
68512>>>>>                Move 0 to lsFileBufferPointer[iFilenumber].biFromFilePosition
68513>>>>>                Set plsFile to lsFile
68514>>>>>                Set plsCachedPointer to lsFileBufferPointer
68515>>>>>                Set psaCachedBuffer to saCachedBuffer
68516>>>>>                Move True to bOk
68517>>>>>            End
68517>>>>>>
68517>>>>>        End
68517>>>>>>
68517>>>>>        Function_Return bOk
68518>>>>>    End_Function
68519>>>>>
68519>>>>>    // Reading from a binary file.
68519>>>>>    // The data read from the file is placed in sReadBuffer and the function returns the number of bytes read.
68519>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
68519>>>>>    // No errors occures if you try to read past end of file.
68519>>>>>    // To speed up reading process you should read in a block of data at a time (i.e. iNumberOfBytes = 2000) instead of
68519>>>>>    // reading one byte at a time. No errors occures if you try to read past end
68519>>>>>    // of file. Note that iNumberOfBytes must not exceed the argument size.
68519>>>>>    Function BinaryFileRead Integer iFilenumber Integer iNumberOfBytes String ByRef sReadBuffer Returns Integer
68521>>>>>        Handle hFileHandle
68521>>>>>        Integer iBytesRead iMaxBuffer iErrorNumber
68521>>>>>        Boolean bOk
68521>>>>>        structFile[] lsFile
68521>>>>>        structFile[] lsFile
68522>>>>>        Set pbError to False
68523>>>>>        Move 0 to iBytesRead
68524>>>>>        Get_Argument_Size to iMaxBuffer
68525>>>>>        If (iNumberOfBytes > iMaxBuffer) Begin
68527>>>>>            Send warning_box "Blocksize to read exceeds argument size!"
68528>>>>>            Function_Return iBytesRead
68529>>>>>        End
68529>>>>>>
68529>>>>>        If (iNumberOfBytes < 1) Begin
68531>>>>>            Send warning_box "Number of bytes to read can not be less than one."
68532>>>>>            Function_Return iBytesRead
68533>>>>>        End
68533>>>>>>
68533>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68534>>>>>        If hFileHandle Begin
68536>>>>>            Move (ZeroString(iNumberOfBytes)) to sReadBuffer
68537>>>>>            Move (fsReadFile(hFileHandle, AddressOf(sReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
68538>>>>>            If (bOk = False) Begin
68540>>>>>                Move (fsGetLastError()) to iErrorNumber
68541>>>>>                If iErrorNumber Begin
68543>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68544>>>>>                End
68544>>>>>>
68544>>>>>            End
68544>>>>>>
68544>>>>>            Else Begin
68545>>>>>                If (iBytesRead = 0 or iBytesRead <> iNumberOfBytes) Begin
68547>>>>>                    Get plsFile to lsFile
68548>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
68549>>>>>                    Set plsFile to lsFile
68550>>>>>                    Set pbEOF to True
68551>>>>>                    Move (Left(sReadBuffer, iBytesRead)) to sReadBuffer
68552>>>>>                End
68552>>>>>>
68552>>>>>            End
68552>>>>>>
68552>>>>>        End
68552>>>>>>
68552>>>>>        Else Begin
68553>>>>>            Send warning_box FS_FILEHANDLEMISSING
68554>>>>>        End
68554>>>>>>
68554>>>>>        Function_Return iBytesRead
68555>>>>>    End_Function
68556>>>>>
68556>>>>>    // Reading from a binary file until a string of bytes are matched.
68556>>>>>    // The data read from the file is placed in the sReturnBuffer and the function returns the number of bytes read until the match is read including the match.
68556>>>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
68556>>>>>    // The return string buffer would also be empty.
68556>>>>>    // No errors occures if you try to read past end of file.
68556>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
68556>>>>>    Function BinaryFileReadCachedUntilMatch Integer iFilenumber String sMatchString String ByRef sReturnBuffer Boolean ByRef bEndOfFile Returns Integer
68558>>>>>        Handle hFileHandle
68558>>>>>        Integer iBuffersize iMatchPos iLengthMatch
68558>>>>>        String sByte
68558>>>>>        structFile[] lsFile
68558>>>>>        structFile[] lsFile
68559>>>>>        structFileBufferPointer[] lsFileBufferPointer
68559>>>>>        structFileBufferPointer[] lsFileBufferPointer
68560>>>>>        String[] saCachedBuffer
68561>>>>>        Get plsFile to lsFile
68562>>>>>        Move "" to sReturnBuffer
68563>>>>>        Move 1 to iMatchPos
68564>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
68566>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
68567>>>>>            If (hFileHandle <> 0) Begin
68569>>>>>                Move (Length(sMatchString)) to iLengthMatch
68570>>>>>                Get plsCachedPointer to lsFileBufferPointer
68571>>>>>                Get psaCachedBuffer to saCachedBuffer
68572>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
68574>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
68575>>>>>                    Move "" to saCachedBuffer[iFilenumber]
68576>>>>>                End
68576>>>>>>
68576>>>>>                Repeat
68576>>>>>>
68576>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer > lsFileBufferPointer[iFilenumber].iBufferSize) Begin
68578>>>>>                        Get_Argument_Size to iBuffersize
68579>>>>>                        Get BinaryFilePosition iFilenumber to lsFileBufferPointer[iFilenumber].biFromFilePosition
68580>>>>>                        Get BinaryFileRead iFilenumber iBuffersize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer[iFilenumber].iBufferSize
68581>>>>>                        Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
68582>>>>>                        Set psaCachedBuffer to saCachedBuffer
68583>>>>>                    End
68583>>>>>>
68583>>>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer =< lsFileBufferPointer[iFilenumber].iBufferSize) Begin
68585>>>>>                        Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer[iFilenumber].iBufferPointer)) to sByte
68586>>>>>                        Increment lsFileBufferPointer[iFilenumber].iBufferPointer
68587>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
68588>>>>>                        If (sByte = Mid(sMatchString, 1, iMatchPos)) Begin
68590>>>>>                            Increment iMatchPos
68591>>>>>                        End
68591>>>>>>
68591>>>>>                        Else Begin
68592>>>>>                            Move 1 to iMatchPos
68593>>>>>                        End
68593>>>>>>
68593>>>>>                    End
68593>>>>>>
68593>>>>>                Until (iMatchPos > iLengthMatch or lsFileBufferPointer[iFilenumber].iBufferSize = 0)
68595>>>>>                Set plsCachedPointer to lsFileBufferPointer
68596>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
68598>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
68599>>>>>                End
68599>>>>>>
68599>>>>>            End
68599>>>>>>
68599>>>>>            Else Begin
68600>>>>>                Send warning_box FS_FILEHANDLEMISSING
68601>>>>>            End
68601>>>>>>
68601>>>>>        End
68601>>>>>>
68601>>>>>        Function_Return (Length(sReturnBuffer))
68602>>>>>    End_Function
68603>>>>>
68603>>>>>    // Reading from a binary file as CSV file For next text field.
68603>>>>>    // The data read from the file is placed in the sReturnBuffer excluding the separator and the function returns true.
68603>>>>>    // Then the function returns false the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
68603>>>>>    // When the end of row data has been read the bEndOfRow is set true.
68603>>>>>    // The end of row is indicated with sCharEOL. If that is not applied the charactersequence character(13) + character(10) is used.
68603>>>>>    // The return string buffer would also be empty.
68603>>>>>    // No errors occures if you try to read past end of file.
68603>>>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
68603>>>>>    Function BinaryFileReadCachedCSV Integer iFilenumber String sFieldseparator String sTextQualification String ByRef sReturnBuffer Boolean ByRef bEndOfRow Boolean ByRef bEndOfFile String sCharEOL Returns Integer
68605>>>>>        Handle hFileHandle
68605>>>>>        Integer iLengthSeparator iLengthTextQualification iEOLLength iTestLength
68605>>>>>        String sByte sEOL sTestBuffer
68605>>>>>        structFile[] lsFile
68605>>>>>        structFile[] lsFile
68606>>>>>        structFileBufferPointer[] lsFileBufferPointer
68606>>>>>        structFileBufferPointer[] lsFileBufferPointer
68607>>>>>        String[] saCachedBuffer
68608>>>>>        Boolean bInTextFieldMode bTextFieldReady bFieldSeparator bTextQualificator bEscapeTextQualificatorTest bByteOk
68608>>>>>        BigInt biAfterTextQualificator
68608>>>>>        Get plsFile to lsFile
68609>>>>>        If (num_arguments > 6) Begin
68611>>>>>            Move sCharEOL to sEOL
68612>>>>>        End
68612>>>>>>
68612>>>>>        Else Begin
68613>>>>>            Move ((Character(13))+(Character(10))) to sEOL
68614>>>>>        End
68614>>>>>>
68614>>>>>        Move (Length(sEOL)) to iEOLLength
68615>>>>>        Move "" to sReturnBuffer
68616>>>>>        Move "" to sByte
68617>>>>>        Move False to bInTextFieldMode
68618>>>>>        Move False to bTextFieldReady
68619>>>>>        Move False to bEndOfRow
68620>>>>>        Move False to bTextQualificator
68621>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
68623>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
68624>>>>>            If (hFileHandle <> 0) Begin
68626>>>>>                Move (Length(sFieldseparator)) to iLengthSeparator
68627>>>>>                Move (Length(sTextQualification)) to iLengthTextQualification
68628>>>>>                Get plsCachedPointer to lsFileBufferPointer
68629>>>>>                Get psaCachedBuffer to saCachedBuffer
68630>>>>>
68630>>>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
68632>>>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
68633>>>>>                    Move "" to saCachedBuffer[iFilenumber]
68634>>>>>                End
68634>>>>>>
68634>>>>>                Repeat
68634>>>>>>
68634>>>>>                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
68635>>>>>                    If bByteOk Begin
68637>>>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
68638>>>>>                        Move (Right(sReturnBuffer, iLengthSeparator) = sFieldseparator) to bFieldSeparator
68639>>>>>                        If bFieldSeparator Begin
68641>>>>>                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthSeparator))) to sReturnBuffer
68642>>>>>                            Move True to bTextFieldReady
68643>>>>>                            Move False to bEscapeTextQualificatorTest
68644>>>>>                        End
68644>>>>>>
68644>>>>>                        If (not(bTextFieldReady)) Begin
68646>>>>>                            Move (Right(sReturnBuffer, iEOLLength) = sEOL) to bEndOfRow
68647>>>>>                            If bEndOfRow Begin
68649>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iEOLLength))) to sReturnBuffer
68650>>>>>                                Move True to bTextFieldReady
68651>>>>>                            End
68651>>>>>>
68651>>>>>                        End
68651>>>>>>
68651>>>>>                        If (not(bTextFieldReady)) Begin
68653>>>>>                            Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
68654>>>>>                            If bTextQualificator Begin
68656>>>>>                            // Read until end of text field. Place filepointer after text field.
68656>>>>>                                Move True to bInTextFieldMode
68657>>>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
68658>>>>>                                Repeat
68658>>>>>>
68658>>>>>                                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
68659>>>>>                                    If bByteOk Begin
68661>>>>>                                        Move (sReturnBuffer + sByte) to sReturnBuffer
68662>>>>>                                        Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
68663>>>>>                                        If bTextQualificator Begin
68665>>>>>                                        // Either it is the end of the text field or the escape text qualificator has been read.
68665>>>>>                                        // Read ahead to a new buffer to see if the next bytes are the text qualificator.
68665>>>>>                                        // If it is, add the new buffer to the return buffer.
68665>>>>>                                        // If not, restore the filebuffer to this position and mark the text field ended.
68665>>>>>                                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
68666>>>>>                                            Set plsCachedPointer to lsFileBufferPointer
68667>>>>>                                            Get BinaryFileCachedPosition iFilenumber to biAfterTextQualificator
68668>>>>>                                            Move "" to sTestBuffer
68669>>>>>                                            Move 0 to iTestLength
68670>>>>>                                            Move True to bEscapeTextQualificatorTest
68671>>>>>                                            Repeat
68671>>>>>>
68671>>>>>                                                Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
68672>>>>>                                                If bByteOk Begin
68674>>>>>                                                    Move (sTestBuffer + sByte) to sTestBuffer
68675>>>>>                                                    Increment iTestLength
68676>>>>>                                                    If (Left(sTextQualification, iTestLength) = sTestBuffer) Begin
68678>>>>>                                                        If (iTestLength = iLengthTextQualification) Begin
68680>>>>>                                                            Move (sReturnBuffer + sTestBuffer) to sReturnBuffer
68681>>>>>                                                            Move False to bEscapeTextQualificatorTest
68682>>>>>                                                        End
68682>>>>>>
68682>>>>>                                                    End
68682>>>>>>
68682>>>>>                                                    Else Begin
68683>>>>>                                                        Set BinaryFileChachedPosition iFilenumber to biAfterTextQualificator
68684>>>>>                                                        Get plsCachedPointer to lsFileBufferPointer
68685>>>>>                                                        Move False to bEscapeTextQualificatorTest
68686>>>>>                                                        Move False to bInTextFieldMode
68687>>>>>                                                    End
68687>>>>>>
68687>>>>>                                                End
68687>>>>>>
68687>>>>>                                            Until (bEscapeTextQualificatorTest = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
68689>>>>>                                        End
68689>>>>>>
68689>>>>>                                    End
68689>>>>>>
68689>>>>>                                Until (bInTextFieldMode = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
68691>>>>>                            End
68691>>>>>>
68691>>>>>                        End
68691>>>>>>
68691>>>>>                    End
68691>>>>>>
68691>>>>>                Until (bTextFieldReady = True or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
68693>>>>>                Set plsCachedPointer to lsFileBufferPointer
68694>>>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
68696>>>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
68697>>>>>                    If (bEndOfFile = True) Begin
68699>>>>>                        Move True to bTextFieldReady
68700>>>>>                        Move True to bEndOfRow
68701>>>>>                    End
68701>>>>>>
68701>>>>>                End
68701>>>>>>
68701>>>>>            End
68701>>>>>>
68701>>>>>            Else Begin
68702>>>>>                Send warning_box FS_FILEHANDLEMISSING
68703>>>>>            End
68703>>>>>>
68703>>>>>        End
68703>>>>>>
68703>>>>>        Function_Return bTextFieldReady
68704>>>>>    End_Function
68705>>>>>
68705>>>>>    Function NextByteCSV Integer ByRef iFilenumber structFileBufferPointer ByRef lsFileBufferPointer String[] ByRef saCachedBuffer String ByRef sByte Returns String
68707>>>>>        Integer iBufferSize
68707>>>>>        Boolean bOk
68707>>>>>        If (lsFileBufferPointer.iBufferPointer > lsFileBufferPointer.iBufferSize) Begin
68709>>>>>            Get_Argument_Size to iBufferSize
68710>>>>>            Get BinaryFilePosition iFilenumber to lsFileBufferPointer.biFromFilePosition
68711>>>>>            Get BinaryFileRead iFilenumber iBufferSize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer.iBufferSize
68712>>>>>            Move 1 to lsFileBufferPointer.iBufferPointer
68713>>>>>            Set psaCachedBuffer to saCachedBuffer
68714>>>>>        End
68714>>>>>>
68714>>>>>        If (lsFileBufferPointer.iBufferPointer <= lsFileBufferPointer.iBufferSize) Begin
68716>>>>>            Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer.iBufferPointer)) to sByte
68717>>>>>            Increment lsFileBufferPointer.iBufferPointer
68718>>>>>            Move True to bOk
68719>>>>>        End
68719>>>>>>
68719>>>>>        Function_Return bOk
68720>>>>>    End_Function
68721>>>>>
68721>>>>>    // Shortcut to read a binary file as lines from a textfile.
68721>>>>>    // Reads from cached file until sCharEOL are recieved.
68721>>>>>    // Data is returned without the ending sCharEOL
68721>>>>>    // If sCharEOL is not applied the charactersequence character(13) + character(10) is used.
68721>>>>>    // Returns True when the line has been read.
68721>>>>>    Function BinaryFileReadCachedLN Integer iFilenumber String ByRef sLine Boolean ByRef bEndOfFile String sCharEOL Returns Boolean
68723>>>>>        Boolean bEndOfRow
68723>>>>>        Integer iBytesRead iEOLLength
68723>>>>>        String sEOL
68723>>>>>        If (num_arguments > 3) Begin
68725>>>>>            Move sCharEOL to sEOL
68726>>>>>        End
68726>>>>>>
68726>>>>>        Else Begin
68727>>>>>            Move ((Character(13))+(Character(10))) to sEOL
68728>>>>>        End
68728>>>>>>
68728>>>>>        Move (Length(sEOL)) to iEOLLength
68729>>>>>        Get BinaryFileReadCachedUntilMatch iFilenumber sEOL (&sLine) (&bEndOfFile) to iBytesRead
68730>>>>>        If (iBytesRead > 0) Begin
68732>>>>>            If (Right(sLine, iEOLLength) = sEOL) Begin
68734>>>>>                Move (Left(sLine, (Length(sLine) - iEOLLength))) to sLine
68735>>>>>                Move True to bEndOfRow
68736>>>>>            End
68736>>>>>>
68736>>>>>        End
68736>>>>>>
68736>>>>>        Function_Return bEndOfRow
68737>>>>>    End_Function
68738>>>>>
68738>>>>>    // Writing to a binary file.
68738>>>>>    // Returns true if the data was written to the file without error.
68738>>>>>    Function BinaryFileWrite Integer iFilenumber String ByRef sWriteData Returns Boolean
68740>>>>>        Integer iBytesWritten iBytesToWrite iErrorNumber
68740>>>>>        Handle hFileHandle
68740>>>>>        Boolean bOk
68740>>>>>        Set pbError to False
68741>>>>>        Move False to bOk
68742>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68743>>>>>        If hFileHandle Begin
68745>>>>>            Move 0 to iBytesWritten
68746>>>>>            Move (Length(sWriteData)) to iBytesToWrite
68747>>>>>            Move (fsWriteFile(hFileHandle, AddressOf(sWriteData), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
68748>>>>>            If (bOk = False) Begin
68750>>>>>                Move (fsGetLastError()) to iErrorNumber
68751>>>>>                If iErrorNumber Begin
68753>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68754>>>>>                End
68754>>>>>>
68754>>>>>            End
68754>>>>>>
68754>>>>>            If (iBytesToWrite <> iBytesWritten) Begin
68756>>>>>                Send Warning_box "Not all data could be written!"
68757>>>>>                Move False to bOk
68758>>>>>            End
68758>>>>>>
68758>>>>>        End
68758>>>>>>
68758>>>>>        Else Begin
68759>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
68760>>>>>        End
68760>>>>>>
68760>>>>>        Function_Return bOk
68761>>>>>    End_Function
68762>>>>>
68762>>>>>    // Write HEX values to a binary file as bytes.
68762>>>>>    // HEX values in sWriteHEX are first coverted to bytes and then written
68762>>>>>    // to the binary file.
68762>>>>>    // Returns true if the HEX data was written to the file without error.
68762>>>>>    Function BinaryFileWriteHex Integer iFilenumer String ByRef sWriteHex Returns Boolean
68764>>>>>        String sData
68764>>>>>        Integer iLength iCount iByte
68764>>>>>        Boolean bOk
68764>>>>>        Move (Length(sWritehex)) to iLength
68765>>>>>        Move 1 to iCount
68766>>>>>        While (iCount < iLength)
68770>>>>>            Move ("$"+Mid(sWriteHex, 2, iCount)) to iByte
68771>>>>>            Move (iCount + 2) to iCount
68772>>>>>            Move (sData + Character(iByte)) to sData
68773>>>>>        Loop
68774>>>>>>
68774>>>>>        Get BinaryFileWrite iFilenumer (&sData) to bOk
68775>>>>>        Function_Return bOk
68776>>>>>    End_Function
68777>>>>>
68777>>>>>    // Retrives the file size from a binary file.
68777>>>>>    Function BinaryFileSize Integer iFilenumber Returns BigInt
68779>>>>>        BigInt biFilesize
68779>>>>>        Handle hFileHandle
68779>>>>>        Boolean bOk
68779>>>>>        Integer iErrorNumber
68779>>>>>        Set pbError to False
68780>>>>>        Move -1 to biFilesize
68781>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68782>>>>>        If hFileHandle Begin
68784>>>>>        // The LARGE_INTEGER structure has the same structure as a BigInt.
68784>>>>>            Move (fsGetFileSizeEx(hFileHandle, AddressOf(biFilesize))) to bOk
68785>>>>>            If (bOk = -False) Begin
68787>>>>>                Move (fsGetLastError()) to iErrorNumber
68788>>>>>                If iErrorNumber Begin
68790>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68791>>>>>                End
68791>>>>>>
68791>>>>>            End
68791>>>>>>
68791>>>>>        End
68791>>>>>>
68791>>>>>        Else Begin
68792>>>>>            Send warning_box FS_FILEHANDLEMISSING
68793>>>>>        End
68793>>>>>>
68793>>>>>        Function_Return biFilesize
68794>>>>>    End_Function
68795>>>>>
68795>>>>>    // Retrives the file position from a binary file.
68795>>>>>    // Returns -1 if an error occured.
68795>>>>>    Function BinaryFilePosition Integer iFilenumber Returns BigInt
68797>>>>>        BigInt biFilePosition biBigHi
68797>>>>>        Handle hFileHandle
68797>>>>>        Boolean bOk
68797>>>>>        Integer iErrorNumber iLo iHi
68797>>>>>        UInteger iNewPos
68797>>>>>
68797>>>>>        Set pbError to False
68798>>>>>        Move -1 to biFilePosition
68799>>>>>        Move 0 to iHi
68800>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68801>>>>>        If hFileHandle Begin
68803>>>>>            Move (2^32) to biBigHi
68804>>>>>            Move (fsSetFilePointer(hFileHandle, ilo, AddressOf(iHi), FILE_CURRENT)) to iNewPos
68805>>>>>            If (iNewPos = (biBigHi - 1)) Begin
68807>>>>>                Move (fsGetLastError()) to iErrorNumber
68808>>>>>                If iErrorNumber Begin
68810>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68811>>>>>                End
68811>>>>>>
68811>>>>>                Else Begin
68812>>>>>                    Move True to bOk
68813>>>>>                End
68813>>>>>>
68813>>>>>            End
68813>>>>>>
68813>>>>>            Else Begin
68814>>>>>                Move True to bOk
68815>>>>>            End
68815>>>>>>
68815>>>>>            If bOk Begin
68817>>>>>                Move ((iHi * biBigHi) + iNewPos) to biFilePosition
68818>>>>>            End
68818>>>>>>
68818>>>>>        End
68818>>>>>>
68818>>>>>        Else Begin
68819>>>>>            Send warning_box FS_FILEHANDLEMISSING
68820>>>>>        End
68820>>>>>>
68820>>>>>        Function_Return biFilePosition
68821>>>>>    End_Function
68822>>>>>
68822>>>>>    // Sets the file position from a binary file to a new position.
68822>>>>>    Procedure Set BinaryFilePosition Integer iFilenumber BigInt biPosition
68824>>>>>        Handle hFileHandle
68824>>>>>        Integer iHi iErrorNumber
68824>>>>>        UInteger iLo iNewPos
68824>>>>>        Boolean bOk
68824>>>>>        BigInt biFileSize biBigHi
68824>>>>>        structFile[] lsFile
68824>>>>>        structFile[] lsFile
68825>>>>>
68825>>>>>        Set pbError to False
68826>>>>>        Move False to bOk
68827>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68828>>>>>        If hFileHandle Begin
68830>>>>>            Move (2^32) to biBigHi
68831>>>>>            Move (biPosition / biBigHi) to iHi
68832>>>>>            Move (biPosition - (iHi * biBigHi)) to iLo
68833>>>>>            Move (fsSetFilePointer(hFileHandle, iLo, AddressOf(iHi), FILE_BEGIN)) to iNewPos
68834>>>>>            If (iNewPos = (biBigHi - 1)) Begin
68836>>>>>                Move (fsGetLastError()) to iErrorNumber
68837>>>>>                If iErrorNumber Begin
68839>>>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68840>>>>>                End
68840>>>>>>
68840>>>>>                Else Begin
68841>>>>>                    Move True to bOk
68842>>>>>                End
68842>>>>>>
68842>>>>>            End
68842>>>>>>
68842>>>>>            Else Begin
68843>>>>>                Move True to bOk
68844>>>>>            End
68844>>>>>>
68844>>>>>            If bOk Begin
68846>>>>>                Get BinaryFileSize iFilenumber to biFileSize
68847>>>>>                Get plsFile to lsFile
68848>>>>>                If (biFileSize > biPosition) Begin
68850>>>>>                    Move False to lsFile[iFilenumber].bEndOfFile
68851>>>>>                    Set pbEOF to False
68852>>>>>                End
68852>>>>>>
68852>>>>>                Else Begin
68853>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
68854>>>>>                    Set pbEOF to True
68855>>>>>                End
68855>>>>>>
68855>>>>>                Set plsFile to lsFile
68856>>>>>            End
68856>>>>>>
68856>>>>>        End
68856>>>>>>
68856>>>>>        Else Begin
68857>>>>>            Send warning_box FS_FILEHANDLEMISSING
68858>>>>>        End
68858>>>>>>
68858>>>>>        Set pbError to (not(bOk))
68859>>>>>    End_Procedure
68860>>>>>
68860>>>>>    // Returns -1 if an error occured.
68860>>>>>    Function BinaryFileCachedPosition Integer iFileNumber Returns BigInt
68862>>>>>        BigInt biPosition
68862>>>>>        structFileBufferPointer[] lsFileBufferPointer
68862>>>>>        structFileBufferPointer[] lsFileBufferPointer
68863>>>>>        Handle hFileHandle
68863>>>>>        Move -1 to biPosition
68864>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68865>>>>>        If hFileHandle Begin
68867>>>>>            Get plsCachedPointer to lsFileBufferPointer
68868>>>>>            If (iFilenumber < SizeOfArray(lsFileBufferPointer)) Begin
68870>>>>>                If (lsFileBufferPointer[iFileNumber].iBufferSize > 0) Begin
68872>>>>>                    Move (lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferPointer - 1) to biPosition
68873>>>>>                End
68873>>>>>>
68873>>>>>                Else Begin
68874>>>>>                    Get BinaryFilePosition iFileNumber to biPosition
68875>>>>>                End
68875>>>>>>
68875>>>>>            End
68875>>>>>>
68875>>>>>            Else Begin
68876>>>>>                Get BinaryFilePosition iFileNumber to biPosition
68877>>>>>            End
68877>>>>>>
68877>>>>>        End
68877>>>>>>
68877>>>>>        Else Begin
68878>>>>>            Send Warning_Box FS_FILEHANDLEMISSING
68879>>>>>        End
68879>>>>>>
68879>>>>>        Function_Return biPosition
68880>>>>>    End_Function
68881>>>>>
68881>>>>>    // Sets the pointer For the current file cache.
68881>>>>>    Procedure Set BinaryFileChachedPosition Integer iFileNumber BigInt biNewPosition
68883>>>>>        Handle hFileHandle
68883>>>>>        structFileBufferPointer[] lsFileBufferPointer
68883>>>>>        structFileBufferPointer[] lsFileBufferPointer
68884>>>>>        String[] saCachedBuffer
68885>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68886>>>>>        If hFileHandle Begin
68888>>>>>            Get plsCachedPointer to lsFileBufferPointer
68889>>>>>            If (lsFileBufferPointer[iFileNumber].biFromFilePosition > biNewPosition) Begin
68891>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
68892>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
68893>>>>>                Set plsCachedPointer to lsFileBufferPointer
68894>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
68895>>>>>                Get psaCachedBuffer to saCachedBuffer
68896>>>>>                Move "" to saCachedBuffer[iFileNumber]
68897>>>>>                Set psaCachedBuffer to saCachedBuffer
68898>>>>>            End
68898>>>>>>
68898>>>>>            Else If ((lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferSize) < biNewPosition) Begin
68901>>>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
68902>>>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
68903>>>>>                Set plsCachedPointer to lsFileBufferPointer
68904>>>>>                Set BinaryFilePosition iFileNumber to biNewPosition
68905>>>>>                Get psaCachedBuffer to saCachedBuffer
68906>>>>>                Move "" to saCachedBuffer[iFileNumber]
68907>>>>>                Set psaCachedBuffer to saCachedBuffer
68908>>>>>            End
68908>>>>>>
68908>>>>>            Else Begin
68909>>>>>                Move (biNewPosition - lsFileBufferPointer[iFileNumber].biFromFilePosition + 1) to lsFileBufferPointer[iFileNumber].iBufferPointer
68910>>>>>                Set plsCachedPointer to lsFileBufferPointer
68911>>>>>            End
68911>>>>>>
68911>>>>>        End
68911>>>>>>
68911>>>>>        Else Begin
68912>>>>>            Send warning_box FS_FILEHANDLEMISSING
68913>>>>>        End
68913>>>>>>
68913>>>>>    End_Procedure
68914>>>>>
68914>>>>>    // Truncate or extend a binary file to the specified file position
68914>>>>>    // by setting the binary file End Of File position.
68914>>>>>    // If biPosition is -1 the current file position is used as EOF position.
68914>>>>>    Procedure Set BinaryFileEndOfFile Integer iFilenumber BigInt biPosition
68916>>>>>        Handle hFileHandle
68916>>>>>        Boolean bError bOk
68916>>>>>        Integer iErrorNumber
68916>>>>>        structFile[] lsFile
68916>>>>>        structFile[] lsFile
68917>>>>>        Set pbError to False
68918>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68919>>>>>        If hFileHandle Begin
68921>>>>>            If (biPosition > -1) Begin
68923>>>>>                Set BinaryFilePosition iFilenumber to biPosition
68924>>>>>            End
68924>>>>>>
68924>>>>>            Get pbError to bError
68925>>>>>            If (bError = False) Begin
68927>>>>>                Move (fsSetEndOfFile(hFileHandle)) to bOk
68928>>>>>                If (bOk = False) Begin
68930>>>>>                    Move (fsGetLastError()) to iErrorNumber
68931>>>>>                    If iErrorNumber Begin
68933>>>>>                        Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
68934>>>>>                    End
68934>>>>>>
68934>>>>>                End
68934>>>>>>
68934>>>>>                Else Begin
68935>>>>>                    Get plsFile to lsFile
68936>>>>>                    Move True to lsFile[iFilenumber].bEndOfFile
68937>>>>>                    Set plsFile to lsFile
68938>>>>>                    Set pbEOF to True
68939>>>>>                End
68939>>>>>>
68939>>>>>            End
68939>>>>>>
68939>>>>>        End
68939>>>>>>
68939>>>>>        Else Begin
68940>>>>>            Send warning_box FS_FILEHANDLEMISSING
68941>>>>>        End
68941>>>>>>
68941>>>>>        Set pbError to (not(bOk))
68942>>>>>    End_Procedure
68943>>>>>
68943>>>>>    // Returns true if the last read from the binary file had reached the end.
68943>>>>>    Function BinaryFileEndOfFile Integer iFilenumber Returns Boolean
68945>>>>>        structFile[] lsFile
68945>>>>>        structFile[] lsFile
68946>>>>>        Handle hFileHandle
68946>>>>>        Boolean bEndOfFile
68946>>>>>        Move True to bEndOfFile
68947>>>>>        Set pbError to False
68948>>>>>        Get BinaryFileHandle iFilenumber to hFileHandle
68949>>>>>        If hFileHandle Begin
68951>>>>>            Get plsFile to lsFile
68952>>>>>            Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
68953>>>>>        End
68953>>>>>>
68953>>>>>        Else Begin
68954>>>>>            Send warning_box FS_FILEHANDLEMISSING
68955>>>>>        End
68955>>>>>>
68955>>>>>        Function_Return bEndOfFile
68956>>>>>    End_Function
68957>>>>>
68957>>>>>    // Returns the filehandle from the filenumber.
68957>>>>>    // Returns 0 if the filenumber is not used.
68957>>>>>    Function BinaryFileHandle Integer iFilenumber Returns Handle
68959>>>>>        Handle hFileHandle
68959>>>>>        structFile[] lsFile
68959>>>>>        structFile[] lsFile
68960>>>>>        Get plsFile to lsFile
68961>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
68963>>>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
68964>>>>>        End
68964>>>>>>
68964>>>>>        Function_Return hFileHandle
68965>>>>>    End_Function
68966>>>>>
68966>>>>>    // Searches For a file
68966>>>>>    // iMode = DIRMODE_FILES_ONLY (default)
68966>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
68966>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES
68966>>>>>    // Returns True if found
68966>>>>>    Function FileExists String sFilePathMask Integer iFileDirMode Returns Boolean
68968>>>>>        Integer iMode
68968>>>>>        Boolean bFound
68968>>>>>        tsSearchResult[] lsResult
68968>>>>>        tsSearchResult[] lsResult
68969>>>>>        Move False to bFound
68970>>>>>        Set pbError to False
68971>>>>>        If (num_arguments < 2) Begin
68973>>>>>            Move DIRMODE_FILES_ONLY to iMode
68974>>>>>        End
68974>>>>>>
68974>>>>>        Else Begin
68975>>>>>            Move iFileDirMode to iMode
68976>>>>>        End
68976>>>>>>
68976>>>>>        Get FileSearch sFilePathMask iMode True to lsResult
68977>>>>>        If (SizeOfArray(lsResult) > 0) Begin
68979>>>>>            Move True to bFound
68980>>>>>        End
68980>>>>>>
68980>>>>>        Function_Return bFound
68981>>>>>    End_Function
68982>>>>>
68982>>>>>    // Deletes a file.
68982>>>>>    // Returns True if succeeds.
68982>>>>>    Function FileDelete String sFilename Integer iRetryAttempts Returns Boolean
68984>>>>>        Boolean bFound bDeleted
68984>>>>>        Integer iErrorNumber iRetryLeft
68984>>>>>
68984>>>>>        Set pbError to False
68985>>>>>        If (num_arguments > 1) Begin
68987>>>>>            Move iRetryAttempts to iRetryLeft
68988>>>>>        End
68988>>>>>>
68988>>>>>        Else Begin
68989>>>>>            Move 0 to iRetryLeft
68990>>>>>        End
68990>>>>>>
68990>>>>>        Get FileExists sFilename to bFound
68991>>>>>        If bFound Begin
68993>>>>>            Repeat
68993>>>>>>
68993>>>>>                Move (ToAnsi(sFilename)) To sFilename
68994>>>>>                Move (sFilename+(Character(0))) to sFilename
68995>>>>>                Move (fsDeleteFile(sFilename)) to bDeleted
68996>>>>>                If (bDeleted = False) Begin
68998>>>>>                    Decrement iRetryLeft
68999>>>>>                    If (iRetryLeft <= 0) Begin
69001>>>>>                        Move (fsGetLastError()) to iErrorNumber
69002>>>>>                        If iErrorNumber Begin
69004>>>>>                            Send DoShowError iErrorNumber ("Tried to delete file: "+sFilename)
69005>>>>>                        End
69005>>>>>>
69005>>>>>                    End
69005>>>>>>
69005>>>>>                    Else Begin
69006>>>>>                        Sleep 1
69007>>>>>                    End
69007>>>>>>
69007>>>>>                End
69007>>>>>>
69007>>>>>            Until (bDeleted = True or iRetryLeft <= 0)
69009>>>>>        End
69009>>>>>>
69009>>>>>        Function_Return bDeleted
69010>>>>>    End_Function
69011>>>>>
69011>>>>>    // Moves a file or directory.
69011>>>>>    // Returns True if succeeds.
69011>>>>>    Function FileMove String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
69013>>>>>        Boolean bMoved
69013>>>>>        Integer iErrorNumber iRetryLeft
69013>>>>>
69013>>>>>        Set pbError to False
69014>>>>>        If (num_arguments > 2) Begin
69016>>>>>            Move iRetryAttempts to iRetryLeft
69017>>>>>        End
69017>>>>>>
69017>>>>>        Else Begin
69018>>>>>            Move 0 to iRetryLeft
69019>>>>>        End
69019>>>>>>
69019>>>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileName
69020>>>>>        Move (ToAnsi(sNewFileName))      to sNewFileName
69021>>>>>        Move (sExistingFilename+(Character(0))) to sExistingFilename
69022>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
69023>>>>>        Repeat
69023>>>>>>
69023>>>>>            Move (fsMoveFile(sExistingFilename, sNewFileName)) to bMoved
69024>>>>>            If (bMoved = False) Begin
69026>>>>>                Decrement iRetryLeft
69027>>>>>                If (iRetryLeft <= 0) Begin
69029>>>>>                    Move (fsGetLastError()) to iErrorNumber
69030>>>>>                    If iErrorNumber Begin
69032>>>>>                        Send DoShowError iErrorNumber ("Tried to move/rename file: "+sExistingFileName+" to "+sNewFileName)
69033>>>>>                    End
69033>>>>>>
69033>>>>>                End
69033>>>>>>
69033>>>>>                Else Begin
69034>>>>>                    Sleep 1
69035>>>>>                End
69035>>>>>>
69035>>>>>            End
69035>>>>>>
69035>>>>>        Until (bMoved = True or iRetryLeft <= 0)
69037>>>>>        Function_Return bMoved
69038>>>>>    End_Function
69039>>>>>
69039>>>>>    // Copies a file. Overwriting an existing file by default.
69039>>>>>    // Returns True if succeeds.
69039>>>>>    Function FileCopy String sExistingFileName String sNewFileName Boolean bFailIfExists Integer iRetryAttempts Returns Boolean
69041>>>>>        Boolean bCopied
69041>>>>>        Boolean bDoNotOverwrite
69041>>>>>        Integer iErrorNumber iRetryLeft
69041>>>>>        Set pbError to False
69042>>>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileName
69043>>>>>        Move (ToAnsi(sNewFileName))      to sNewFileName
69044>>>>>        Move (sExistingFileName+(Character(0))) to sExistingFileName
69045>>>>>        Move (sNewFileName+(Character(0)))      to sNewFileName
69046>>>>>        If (Num_Arguments > 2) Begin
69048>>>>>            Move bFailIfExists to bDoNotOverwrite
69049>>>>>        End
69049>>>>>>
69049>>>>>        Else Begin
69050>>>>>            Move False to bDoNotOverwrite
69051>>>>>        End
69051>>>>>>
69051>>>>>        If (num_arguments > 3) Begin
69053>>>>>            Move iRetryAttempts to iRetryLeft
69054>>>>>        End
69054>>>>>>
69054>>>>>        Else Begin
69055>>>>>            Move 0 to iRetryLeft
69056>>>>>        End
69056>>>>>>
69056>>>>>        Repeat
69056>>>>>>
69056>>>>>            Move (fsCopyFile(sExistingFileName, sNewFileName, bDoNotOverwrite)) to bCopied
69057>>>>>            If (bCopied = False) Begin
69059>>>>>                Decrement iRetryLeft
69060>>>>>                If (iRetryLeft <= 0) Begin
69062>>>>>                    Move (fsGetLastError()) to iErrorNumber
69063>>>>>                    If iErrorNumber Begin
69065>>>>>                        Send DoShowError iErrorNumber ("Tried to copy file: "+sExistingFileName+" to "+sNewFileName)
69066>>>>>                    End
69066>>>>>>
69066>>>>>                End
69066>>>>>>
69066>>>>>                Else Begin
69067>>>>>                    Sleep 1
69068>>>>>                End
69068>>>>>>
69068>>>>>            End
69068>>>>>>
69068>>>>>        Until (bCopied = True or iRetryLeft <= 0)
69070>>>>>        Function_Return bCopied
69071>>>>>    End_Function
69072>>>>>
69072>>>>>    // Renames a file or directory.
69072>>>>>    // Returns True if succeeds.
69072>>>>>    Function FileRename String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
69074>>>>>        Boolean bRenamed
69074>>>>>        If (num_arguments > 2) Begin
69076>>>>>            Get FileMove sExistingFileName sNewFileName iRetryAttempts to bRenamed
69077>>>>>        End
69077>>>>>>
69077>>>>>        Else Begin
69078>>>>>            Get FileMove sExistingFileName sNewFileName to bRenamed
69079>>>>>        End
69079>>>>>>
69079>>>>>        Function_Return bRenamed
69080>>>>>    End_Function
69081>>>>>
69081>>>>>    // Returns the file size of a file.
69081>>>>>    // Returns -1 if an error occured.
69081>>>>>    Function FileSize String sFilename Returns BigInt
69083>>>>>        tsSearchResult[] lsSearchResult
69083>>>>>        tsSearchResult[] lsSearchResult
69084>>>>>        BigInt iRetval
69084>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
69085>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
69087>>>>>            Move lsSearchResult[0].biFileSize to iRetval
69088>>>>>        End
69088>>>>>>
69088>>>>>        Else Begin
69089>>>>>            Move -1 to iRetval
69090>>>>>        End
69090>>>>>>
69090>>>>>        Function_Return iRetval
69091>>>>>    End_Function
69092>>>>>
69092>>>>>    // Returns the last write date of a file.
69092>>>>>    // Returns 0 if an error occured.
69092>>>>>    Function FileDate String sFilename Returns Date
69094>>>>>        tsSearchResult[] lsSearchResult
69094>>>>>        tsSearchResult[] lsSearchResult
69095>>>>>        Date dDate
69095>>>>>        Move 0 to dDate
69096>>>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
69097>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
69099>>>>>            Move lsSearchResult[0].dtLastWriteDateTime to dDate
69100>>>>>        End
69100>>>>>>
69100>>>>>        Function_Return dDate
69101>>>>>    End_Function
69102>>>>>
69102>>>>>    // Returns the fileversion info.
69102>>>>>    // Returns false if an error occured.
69102>>>>>    Function FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Boolean
69104>>>>>        Boolean bOk
69104>>>>>        Integer iErrorNumber iStatus
69104>>>>>        Get _FileVersion sFilename (&lsFileVersionInfo) to iStatus
69105>>>>>        If (iStatus = -1) Begin
69107>>>>>            Move (fsGetLastError()) to iErrorNumber
69108>>>>>            If iErrorNumber Begin
69110>>>>>                Send DoShowError iErrorNumber ("Tried to get fileversion info from file: "+sFilename)
69111>>>>>            End
69111>>>>>>
69111>>>>>        End
69111>>>>>>
69111>>>>>        Move (iStatus = 0) to bOk
69112>>>>>        Function_Return bOk
69113>>>>>    End_Function
69114>>>>>
69114>>>>>    Function _FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Integer
69116>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
69116>>>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
69116>>>>>        UInteger iBytesNeeded
69116>>>>>        Address aBuffer
69116>>>>>        Boolean bOk
69116>>>>>        String sSubBlock
69116>>>>>        DWord dwBufferLen dwBufferPointer
69116>>>>>        tsLandAndCodePage lsLandAndCodePage
69116>>>>>        tsLandAndCodePage lsLandAndCodePage
69116>>>>>        Move (ToANSI(sFilename)) To sFilename
69117>>>>>        Move (sFilename + (Character(0))) to sFilename
69118>>>>>        Move 0 to iBytesNeeded
69119>>>>>        Move 0 to aBuffer
69120>>>>>        Move 0 to lsFIXEDFILEINFO.dwStrucVersion    // Initialize the variable.
69121>>>>>        Move 0 to lsLandAndCodePage.wCodePage
69122>>>>>        Move (fsGetFileVersionInfoSize(sFilename, 0)) to iBytesNeeded
69123>>>>>        If (iBytesNeeded = 0) Begin
69125>>>>>            Function_Return False
69126>>>>>        End
69126>>>>>>
69126>>>>>        Move False to bOk
69127>>>>>        Move (Alloc(iBytesNeeded)) to aBuffer
69128>>>>>        Move (MemSet(aBuffer, 0, iBytesNeeded)) to bOk
69129>>>>>        Move (fsGetFileVersionInfo(sFilename, 0, iBytesNeeded, aBuffer)) to bOk
69130>>>>>        If (not(bOk)) Begin
69132>>>>>            Move (Free(aBuffer)) to bOk
69133>>>>>            Function_Return -1
69134>>>>>        End
69134>>>>>>
69134>>>>>        Move "\" to sSubBlock
69135>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
69136>>>>>        Move 0 to dwBufferLen
69137>>>>>        Move 0 to dwBufferPointer
69138>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
69139>>>>>        If (not(bOk)) Begin
69141>>>>>            Move (Free(aBuffer)) to bOk
69142>>>>>            Function_Return -1
69143>>>>>        End
69143>>>>>>
69143>>>>>        If (dwBufferLen <> 52) Begin
69145>>>>>            Send warning_box (SFormat("Length of bufferdata For VS_FIXEDFILEINFO struct are not in the expected size.\nLength is %1 and should have been 52.", dwBufferLen))
69146>>>>>            Move (Free(aBuffer)) to bOk
69147>>>>>            Function_Return -2
69148>>>>>        End
69148>>>>>>
69148>>>>>        Move (MemCopy(AddressOf(lsFIXEDFILEINFO), dwBufferPointer, dwBufferLen)) to bOk
69149>>>>>        If (not(bOk)) Begin
69151>>>>>            Move (Free(aBuffer)) to bOk
69152>>>>>            Function_Return -1
69153>>>>>        End
69153>>>>>>
69153>>>>>        Move lsFIXEDFILEINFO to lsFileVersionInfo.lsFIXEDFILEINFO
69154>>>>>        Get ConvertFileTileToLocalDateTime lsFIXEDFILEINFO.ubiFileDate to lsFileVersionInfo.dtCreationDateTime
69155>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[0]
69156>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[1]
69157>>>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[2]
69158>>>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[3]
69159>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[0]
69160>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[1]
69161>>>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[2]
69162>>>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[3]
69163>>>>>        Move "\VarFileInfo\Translation" to sSubBlock
69164>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
69165>>>>>        Move 0 to dwBufferLen
69166>>>>>        Move 0 to dwBufferPointer
69167>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
69168>>>>>        If (not(bOk)) Begin
69170>>>>>            Move (Free(aBuffer)) to bOk
69171>>>>>            Function_Return -1
69172>>>>>        End
69172>>>>>>
69172>>>>>        If (dwBufferLen <> 4) Begin
69174>>>>>            Send warning_box (SFormat("Length of bufferdata For land and codepage numbers are not in the expected size.\nLength is %1 and should have been 4.", dwBufferLen))
69175>>>>>            Move (Free(aBuffer)) to bOk
69176>>>>>            Function_Return -2
69177>>>>>        End
69177>>>>>>
69177>>>>>        Move (MemCopy(AddressOf(lsLandAndCodePage), dwBufferPointer, dwBufferLen)) to bOk
69178>>>>>        Get VerQueryValueStringFileInfo aBuffer "Comments" lsLandAndCodePage to lsFileVersionInfo.sComments
69179>>>>>        Get VerQueryValueStringFileInfo aBuffer "CompanyName" lsLandAndCodePage to lsFileVersionInfo.sCompanyName
69180>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileDescription" lsLandAndCodePage to lsFileVersionInfo.sFileDescription
69181>>>>>        Get VerQueryValueStringFileInfo aBuffer "FileVersion" lsLandAndCodePage to lsFileVersionInfo.sFileVersion
69182>>>>>        Get VerQueryValueStringFileInfo aBuffer "InternalName" lsLandAndCodePage to lsFileVersionInfo.sInternalName
69183>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalCopyright" lsLandAndCodePage to lsFileVersionInfo.sLegalCopyright
69184>>>>>        Get VerQueryValueStringFileInfo aBuffer "LegalTrademarks" lsLandAndCodePage to lsFileVersionInfo.sLegalTrademarks
69185>>>>>        Get VerQueryValueStringFileInfo aBuffer "OriginalFilename" lsLandAndCodePage to lsFileVersionInfo.sOriginalFilename
69186>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductName" lsLandAndCodePage to lsFileVersionInfo.sProductName
69187>>>>>        Get VerQueryValueStringFileInfo aBuffer "ProductVersion" lsLandAndCodePage to lsFileVersionInfo.sProductVersion
69188>>>>>        Get VerQueryValueStringFileInfo aBuffer "PrivateBuild" lsLandAndCodePage to lsFileVersionInfo.sPrivateBuild
69189>>>>>        Get VerQueryValueStringFileInfo aBuffer "SpecialBuild" lsLandAndCodePage to lsFileVersionInfo.sSpecialBuild
69190>>>>>        Move (Free(aBuffer)) to bOk
69191>>>>>        Function_Return 0
69192>>>>>    End_Function
69193>>>>>
69193>>>>>    // Convert an short integer to a 4-character hex string.
69193>>>>>    Function ShortToHex Short siValue Returns String
69195>>>>>        String sHex
69195>>>>>        Move "" to sHex
69196>>>>>        Repeat
69196>>>>>>
69196>>>>>            Move (Mid ("0123456789ABCDEF", 1, ((siValue iand |CI$0F) + 1)) + sHex) to sHex
69197>>>>>            Move (siValue / |CI$10) to siValue
69198>>>>>        Until (siValue = 0)
69200>>>>>        Move (Right("0000" + sHex, 4)) to sHex
69201>>>>>        Function_Return sHex
69202>>>>>    End_Function
69203>>>>>
69203>>>>>    Function VerQueryValueStringFileInfo Address aBuffer String sInfoName tsLandAndCodePage lsLandAndCodePage Returns String
69205>>>>>        String sSubBlock
69205>>>>>        String sValue
69205>>>>>        DWord dwBufferLen dwBufferPointer
69205>>>>>        Boolean bOk
69205>>>>>        Move (SFormat("\StringFileInfo\%1%2\%3", ShortToHex(Self, lsLandAndCodePage.wLanguage), ShortToHex(Self, lsLandAndCodePage.wCodePage), sInfoName)) to sSubBlock
69206>>>>>        Move (sSubBlock + (Character(0))) to sSubBlock
69207>>>>>        Move 0 to dwBufferLen
69208>>>>>        Move 0 to dwBufferPointer
69209>>>>>        Move (fsVerQueryValue(aBuffer, sSubBlock, AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
69210>>>>>        If (not(bOk)) Begin
69212>>>>>            Function_Return ""
69213>>>>>        End
69213>>>>>>
69213>>>>>        Move (ZeroString(dwBufferLen)) to sValue
69214>>>>>        Move (MemCopy(AddressOf(sValue), dwBufferPointer, dwBufferLen)) to bOk
69215>>>>>        Move (ToOEM(CString(sValue))) To sValue
69216>>>>>        Function_Return sValue
69217>>>>>    End_Function
69218>>>>>
69218>>>>>    // Returns the file extention without the leading "."
69218>>>>>    // Example sFile = "x:\text.txt". The function returns "txt".
69218>>>>>    Function FileExtention String sFilename Returns String
69220>>>>>        String sExtention
69220>>>>>        Integer iPos
69220>>>>>        Move (RightPos(".", sFilename)) to iPos
69221>>>>>        If (iPos > 0) Begin
69223>>>>>            Move (Right(sFilename, (Length(sFilename) - iPos))) to sExtention
69224>>>>>            If (sExtention contains "\" or sExtention contains " ") Begin
69226>>>>>                Move "" to sExtention
69227>>>>>            End
69227>>>>>>
69227>>>>>        End
69227>>>>>>
69227>>>>>        Function_Return sExtention
69228>>>>>    End_Function
69229>>>>>
69229>>>>>    // Gets a handle to an icon stored as a resource in a file or an icon
69229>>>>>    // stored in a file's associated executable file.
69229>>>>>    // When the icon handle is no longer needed, close it by using the DestroyFileIcon procedure.
69229>>>>>    Function FileIcon String sFilename Returns Handle
69231>>>>>        Handle hIcon
69231>>>>>        Integer iIcon
69231>>>>>        Address aFilename
69231>>>>>        Move (ToANSI(sFilename)) To sFilename
69232>>>>>        Move (Pad(sFilename, MAX_PATH)) to sFilename
69233>>>>>        Move (AddressOf(sFileName)) To aFileName
69234>>>>>        Move 0 to iIcon
69235>>>>>        Move (fsExtractAssociatedIcon(0, aFilename, AddressOf(iIcon))) to hIcon
69236>>>>>        Function_Return hIcon
69237>>>>>    End_Function
69238>>>>>
69238>>>>>    // Destroy hIcon, created from FileIcon.
69238>>>>>    Procedure DestroyFileIcon Handle hIcon
69240>>>>>        Integer iResult
69240>>>>>        If (hIcon <> 0) Begin
69242>>>>>            Move (fsDestroyIcon(hIcon)) to iResult
69243>>>>>        End
69243>>>>>>
69243>>>>>    End_Procedure
69244>>>>>
69244>>>>>    // Search a directory For the files with normal windows mask-signs
69244>>>>>    // Returns an array of matching files and directories
69244>>>>>    // iMode = DIRMODE_FILES_ONLY
69244>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
69244>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
69244>>>>>    // If bReturnOnlyOne is true only one search result item is returned.
69244>>>>>    // If bReturnOnlyOne is true and no items where found no error is shown.
69244>>>>>    Function FileSearch String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
69246>>>>>        tsSearchResult[] lsSearchResult
69246>>>>>        tsSearchResult[] lsSearchResult
69247>>>>>        Integer iSearchResultCount iMode iErrorNumber
69247>>>>>        structWFD lsFindData
69247>>>>>        structWFD lsFindData
69247>>>>>        Handle hFindFile
69247>>>>>        Boolean bError bStop bFound bOk bOnlyOne
69247>>>>>        BigInt biBigHi
69247>>>>>        Address aFileName
69247>>>>>
69247>>>>>        If (num_arguments < 2) Begin
69249>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
69250>>>>>        End
69250>>>>>>
69250>>>>>        Else Begin
69251>>>>>            Move iFileDirMode to iMode
69252>>>>>        End
69252>>>>>>
69252>>>>>        If (num_arguments < 3) Begin
69254>>>>>            Move False to bOnlyOne
69255>>>>>        End
69255>>>>>>
69255>>>>>        Else Begin
69256>>>>>            Move bReturnOnlyOne to bOnlyOne
69257>>>>>        End
69257>>>>>>
69257>>>>>        Move (ToAnsi(sFilePathMask)) To sFilePathMask
69258>>>>>        Move (sFilePathMask+Character(0)) To sFilePathMask
69259>>>>>        Move 0 To lsFindData.dwFileAttributes   // Initialize lsFindData
69260>>>>>        Move (fsFindFirstFile(sFilePathMask, AddressOf(lsFindData))) to hFindFile
69261>>>>>        If (hFindFile <> INVALID_HANDLE_VALUE) Begin
69263>>>>>            Move False to bError
69264>>>>>            Move False to bStop
69265>>>>>            Move (2^32) to biBigHi
69266>>>>>            Set pbError to bError
69267>>>>>            While (bError = False and bStop = False)
69271>>>>>                Move False to bFound
69272>>>>>                Case Begin
69272>>>>>                    Case (iMode = DIRMODE_FILES_ONLY)
69274>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = 0) Begin
69276>>>>>                            Move True to bFound
69277>>>>>                        End
69277>>>>>>
69277>>>>>                        Case Break
69278>>>>>                    Case (iMode = DIRMODE_DIRECTORIES_ONLY)
69281>>>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = FILE_ATTRIBUTE_DIRECTORY) Begin
69283>>>>>                            Move True to bFound
69284>>>>>                        End
69284>>>>>>
69284>>>>>                        Case Break
69285>>>>>                    Case Else
69285>>>>>                        Move True to bFound
69286>>>>>                        Case Break
69287>>>>>                Case End
69287>>>>>                If bFound Begin
69289>>>>>                    Move (AddressOf(lsFindData.cFileName)) to aFilename
69290>>>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sFilename
69291>>>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sFilename)) to lsSearchResult[iSearchResultCount].sFilename
69292>>>>>                    Move (AddressOf(lsFindData.cAlternateFileName)) to aFilename
69293>>>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sAlternateFileName
69294>>>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sAlternateFileName)) To lsSearchResult[iSearchResultCount].sAlternateFileName
69295>>>>>                    Move lsFindData.dwFileAttributes to lsSearchResult[iSearchResultCount].iFileAttributes
69296>>>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftCreationDateTime to lsSearchResult[iSearchResultCount].dtCreationDateTime
69297>>>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftLastAccessDateTime to lsSearchResult[iSearchResultCount].dtLastAccessDateTime
69298>>>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftLastWriteDateTime to lsSearchResult[iSearchResultCount].dtLastWriteDateTime
69299>>>>>                    Move ((lsFindData.nFileSizeHigh * biBigHi) + lsFindData.nFileSizeLow) to lsSearchResult[iSearchResultCount].biFileSize
69300>>>>>                    Increment iSearchResultCount
69301>>>>>                    If bOnlyOne Begin
69303>>>>>                        Move True to bStop
69304>>>>>                    End
69304>>>>>>
69304>>>>>                End
69304>>>>>>
69304>>>>>                If (bStop = False) Begin
69306>>>>>                    Move (fsFindNextFile(hFindFile, AddressOf(lsFindData))) to bOk
69307>>>>>                End
69307>>>>>>
69307>>>>>                If (bOk = False) Begin
69309>>>>>                    Move True to bStop
69310>>>>>                    If (bOnlyOne = False) Begin
69312>>>>>                        Move (fsGetLastError()) to iErrorNumber
69313>>>>>                        If (iErrorNumber <> ERROR_NO_MORE_FILES and iErrorNumber <> ERROR_MOD_NOT_FOUND and iErrorNumber <> 0) Begin
69315>>>>>                            Send DoShowError iErrorNumber ("Search path: "+sFilePathMask)
69316>>>>>                        End
69316>>>>>>
69316>>>>>                    End
69316>>>>>>
69316>>>>>                End
69316>>>>>>
69316>>>>>                Get pbError to bError
69317>>>>>            Loop
69318>>>>>>
69318>>>>>            Move (fsFindClose(hFindFile)) to bOk
69319>>>>>        End
69319>>>>>>
69319>>>>>        Function_Return lsSearchResult
69320>>>>>    End_Function
69321>>>>>
69321>>>>>    // Search a directory and all subdirectories For the files with normal windows mask-signs.
69321>>>>>    // lsResult[?].sFileName contains full path and filename.
69321>>>>>    // iMode = DIRMODE_FILES_ONLY
69321>>>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
69321>>>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
69321>>>>>    Function FileSearchRecursive String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
69323>>>>>        Integer iMode
69323>>>>>        Boolean bOnlyOne
69323>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
69323>>>>>        tsSearchResult[] lsFinalResult lsSearchResult
69325>>>>>        If (num_arguments < 2) Begin
69327>>>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
69328>>>>>        End
69328>>>>>>
69328>>>>>        Else Begin
69329>>>>>            Move iFileDirMode to iMode
69330>>>>>        End
69330>>>>>>
69330>>>>>        If (num_arguments < 3) Begin
69332>>>>>            Move False to bOnlyOne
69333>>>>>        End
69333>>>>>>
69333>>>>>        Else Begin
69334>>>>>            Move bReturnOnlyOne to bOnlyOne
69335>>>>>        End
69335>>>>>>
69335>>>>>        Get FileSearchRecursivePriv sFilePathMask iMode bOnlyOne (&lsFinalResult) to lsSearchResult
69336>>>>>        Function_Return lsFinalResult
69337>>>>>    End_Function
69338>>>>>
69338>>>>>    // Private
69338>>>>>    Function FileSearchRecursivePriv String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne tsSearchResult[] ByRef lsFinalResult Returns tsSearchResult[]
69340>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
69340>>>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
69342>>>>>        Integer iMax iCnt iLast iFinalMax
69342>>>>>        String sSearchInDir sFileMask
69342>>>>>        Boolean bStop
69342>>>>>        
69342>>>>>        Move False to bStop
69343>>>>>        Move (RightPos("\", sFilePathMask)) to iLast
69344>>>>>        If (iLast > 0) Begin
69346>>>>>            Move (Left(sFilePathMask, iLast - 1)) to sSearchInDir
69347>>>>>            Move (Mid(sFilePathMask, Length(sFilePathMask), iLast + 1)) to sFileMask
69348>>>>>        End
69348>>>>>>
69348>>>>>        Get FileSearch (sSearchInDir + "\*.*") DIRMODE_DIRECTORIES_ONLY to lsSearchResultDir
69349>>>>>        Move (SizeOfArray(lsSearchResultDir)) to iMax
69350>>>>>        Move 0 to iCnt
69351>>>>>        While (iCnt < iMax and bStop = False)
69355>>>>>            If (lsSearchResultDir[iCnt].sFilename <> "." and lsSearchResultDir[iCnt].sFilename <> "..") Begin
69357>>>>>                Get FileSearchRecursivePriv (sSearchInDir + "\" + lsSearchResultDir[iCnt].sFilename + "\" + sFileMask) iFileDirMode bReturnOnlyOne (&lsFinalResult) to lsSearchResult
69358>>>>>            End
69358>>>>>>
69358>>>>>            Increment iCnt
69359>>>>>            If (bReturnOnlyOne = True) Begin
69361>>>>>                If (SizeOfArray(lsFinalResult) > 0) Begin
69363>>>>>                    Move True to bStop
69364>>>>>                End
69364>>>>>>
69364>>>>>            End
69364>>>>>>
69364>>>>>        Loop
69365>>>>>>
69365>>>>>        If (bStop = False) Begin
69367>>>>>            Get FileSearch sFilePathMask iFileDirMode to lsSearchResult
69368>>>>>            Move (SizeOfArray(lsSearchResult)) to iMax
69369>>>>>            Move (SizeOfArray(lsFinalResult)) to iFinalMax
69370>>>>>            Move 0 to iCnt
69371>>>>>            While (iCnt < iMax and bStop = False)
69375>>>>>                Move lsSearchResult[iCnt] to lsFinalResult[iFinalMax]
69376>>>>>                Move (sSearchInDir + "\" + lsSearchResult[iCnt].sFilename) to lsFinalResult[iFinalMax].sFilename
69377>>>>>                Increment iFinalMax
69378>>>>>                Increment iCnt
69379>>>>>                If (bReturnOnlyOne = True) Begin
69381>>>>>                    If (SizeOfArray(lsFinalResult) > 0) Begin
69383>>>>>                        Move True to bStop
69384>>>>>                    End
69384>>>>>>
69384>>>>>                End
69384>>>>>>
69384>>>>>            Loop
69385>>>>>>
69385>>>>>        End
69385>>>>>>
69385>>>>>        Function_Return lsSearchResult
69386>>>>>    End_Function
69387>>>>>
69387>>>>>    // Finds a list of files.
69387>>>>>    // sSearchFiles is a list of files to search For separated by semicolon (;).
69387>>>>>    // sSearchFiles may not contain paths but may contain wildcards.
69387>>>>>    // sSearchPaths may only contain paths.
69387>>>>>    // Returns a string array with the files
69387>>>>>    // Returns only files with full path.
69387>>>>>    // Use:
69387>>>>>    // Get ListOfFiles "path1;path2" "*.txt;*.asc"
69387>>>>>    // This will return all the .txt and .asc files with full path that exists in path1 and path2.
69387>>>>>    Function ListOfFiles String sSearchPaths String sSearchFiles Returns String[]
69389>>>>>        String[] saFileList
69390>>>>>        Integer iFilelistCount iSearchFilesCount iCurSearchFile
69390>>>>>        Integer iSearchPathsCount iCurSearchPath iFilesFound iCurFileFound
69390>>>>>        String sCurSearchFile sCurSearchPath
69390>>>>>        tsSearchResult[] lsSearchResult
69390>>>>>        tsSearchResult[] lsSearchResult
69391>>>>>        Get CountOfFields sSearchPaths to iSearchPathsCount
69392>>>>>        Get CountOfFields sSearchFiles to iSearchFilesCount
69393>>>>>        If (iSearchFilesCount > 0 and iSearchPathsCount > 0) Begin
69395>>>>>            For iCurSearchFile from 1 to iSearchFilesCount
69401>>>>>>
69401>>>>>                Get FieldAtIndex sSearchFiles iCurSearchFile to sCurSearchFile
69402>>>>>                Move (Trim(sCurSearchFile)) to sCurSearchFile
69403>>>>>                If (sCurSearchFile <> "") Begin
69405>>>>>                    For iCurSearchPath from 1 to iSearchPathsCount
69411>>>>>>
69411>>>>>                        Get FieldAtIndex sSearchPaths iCurSearchPath to sCurSearchPath
69412>>>>>                        If (Right(sCurSearchPath, 1) <> "\") Begin
69414>>>>>                            Move (sCurSearchPath + "\") to sCurSearchPath
69415>>>>>                        End
69415>>>>>>
69415>>>>>                        Get FileSearch (sCurSearchPath + sCurSearchFile) DIRMODE_FILES_ONLY to lsSearchResult
69416>>>>>                        Move (SizeOfArray(lsSearchResult)) to iFilesFound
69417>>>>>                        Decrement iFilesFound
69418>>>>>                        For iCurFileFound from 0 to iFilesFound
69424>>>>>>
69424>>>>>                            Move (sCurSearchPath + lsSearchResult[iCurFileFound].sFilename) to saFileList[iFilelistCount]
69425>>>>>                            Increment iFilelistCount
69426>>>>>                        Loop
69427>>>>>>
69427>>>>>                    Loop
69428>>>>>>
69428>>>>>                End
69428>>>>>>
69428>>>>>            Loop
69429>>>>>>
69429>>>>>        End
69429>>>>>>
69429>>>>>        Function_Return saFileList
69430>>>>>    End_Function
69431>>>>>
69431>>>>>    // Get Windows Temp path
69431>>>>>    Function FileTempPath Returns String
69433>>>>>        Integer iRetVal
69433>>>>>        String  sTempPath
69433>>>>>        Move (ZeroString(MAX_PATH)) to sTempPath
69434>>>>>        Move (fsGetTempPath(MAX_PATH, AddressOf(sTempPath))) to iRetVal
69435>>>>>        If (iRetVal > MAX_PATH) Begin
69437>>>>>            Move (ZeroString(iRetval)) to sTempPath
69438>>>>>            Move (fsGetTempPath(iRetVal, AddressOf(sTempPath))) to iRetVal
69439>>>>>        End
69439>>>>>>
69439>>>>>        Move (ToOEM(sTempPath)) To sTempPath
69440>>>>>        Move (CString(sTempPath)) to sTempPath
69441>>>>>        Function_Return sTempPath
69442>>>>>    End_Function
69443>>>>>
69443>>>>>    // Generates a temporary file.
69443>>>>>    // Returns full path and filename or blank if no file could be created.
69443>>>>>    // sPathName is the place where the temporary file is generated. If it is
69443>>>>>    // not argumented the TEMP enviroment variable is used. If that is also not
69443>>>>>    // available the current directory is used.
69443>>>>>    // You can prefix the first 3 letters of the filename with sPrefix.
69443>>>>>    Function FileTempFileName String sPathName String sPrefix Returns String
69445>>>>>        Address aTempFileName
69445>>>>>        String sPathNameTmp sPrefixTmp sTempFileName
69445>>>>>        Boolean bOk
69445>>>>>        Set pbError to False
69446>>>>>        If (num_arguments > 0) Begin
69448>>>>>            Move sPathName to sPathNameTmp
69449>>>>>        End
69449>>>>>>
69449>>>>>        Else Begin
69450>>>>>            Move "" to sPathNameTmp
69451>>>>>        End
69451>>>>>>
69451>>>>>        If (num_arguments > 1) Begin
69453>>>>>            Move sPrefix to sPrefixTmp
69454>>>>>        End
69454>>>>>>
69454>>>>>        Else Begin
69455>>>>>            Move "" to sPrefixTmp
69456>>>>>        End
69456>>>>>>
69456>>>>>        Move (Trim(sPathNameTmp)) to sPathNameTmp
69457>>>>>        If (sPathNameTmp = "") Begin
69459>>>>>            Get FileTempPath to sPathNameTmp
69460>>>>>            If (sPathNameTmp = "") Begin
69462>>>>>                Move "." to sPathNameTmp
69463>>>>>            End
69463>>>>>>
69463>>>>>        End
69463>>>>>>
69463>>>>>        Move (ZeroString(MAX_PATH))     To sTempFilename
69464>>>>>        Move (AddressOf(sTempFileName)) To aTempFileName
69465>>>>>        Move (ToANSI(sPathNameTmp))     to sPathNameTmp
69466>>>>>        Move (ToANSI(sPrefixTmp))       To sPrefixTmp
69467>>>>>        Move (fsGetTempFileName(sPathNameTmp, sPrefixTmp, 0, aTempFileName)) to bOk
69468>>>>>        If bOk Begin
69470>>>>>            Move (ToOEM(sTempFileName)) To sTempFileName
69471>>>>>            Move (CString(sTempFileName)) to sTempFileName
69472>>>>>        End
69472>>>>>>
69472>>>>>        Function_Return sTempFileName
69473>>>>>    End_Function
69474>>>>>
69474>>>>>    // Returns the file path without the filename. Does not return ending directory separator.
69474>>>>>    // Example sFilename = "x:\PathToFile\File.txt". The function returns "x:\PathToFile".
69474>>>>>    Function FilePath String sFilename Returns String
69476>>>>>        String sPathOnly sDirSep
69476>>>>>        Integer iPos
69476>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69477>>>>>        Move (RightPos(sDirSep, sFilename)) to iPos
69478>>>>>        If (iPos > 0) Begin
69480>>>>>            Move (Left(sFilename, iPos - 1)) to sPathOnly
69481>>>>>        End
69481>>>>>>
69481>>>>>        Function_Return sPathOnly
69482>>>>>    End_Function
69483>>>>>    
69483>>>>>    // Creates a new directory.
69483>>>>>    // Returns True if succeeds.
69483>>>>>    Function DirectoryCreate String sDirectoryName Returns Boolean
69485>>>>>        Boolean bFound bOk
69485>>>>>        Integer iErrorNumber
69485>>>>>        Move False to bOk
69486>>>>>        Set pbError to False
69487>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
69488>>>>>        If (not(bFound)) Begin
69490>>>>>            Move (toAnsi(sDirectoryName)) To sDirectoryname
69491>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
69492>>>>>            Move (fsCreateDirectory(sDirectoryname, FNULL)) to bOk
69493>>>>>            If (bOk = False) Begin           // Could not create
69495>>>>>                Move (fsGetLastError()) to iErrorNumber
69496>>>>>                If iErrorNumber Begin
69498>>>>>                    Send DoShowError iErrorNumber ("Tried to create directory: "+sDirectoryname)
69499>>>>>                End
69499>>>>>>
69499>>>>>            End
69499>>>>>>
69499>>>>>        End
69499>>>>>>
69499>>>>>        Function_Return bOk
69500>>>>>    End_Function
69501>>>>>
69501>>>>>    // Creates a new directory and all missing parent directories in the sPath.
69501>>>>>    // If the sPath contains a filename set bPathContainsFileName to true. This will create all the parent directories for the filename. The filename itself will not be created.
69501>>>>>    // If a parent directory already exists it will be skipped.
69501>>>>>    // Requires an absolute path.
69501>>>>>    // Returns true if all the directories could be created or was already created.
69501>>>>>    Function DirectoryCreateEx String sPath Boolean bPathContainsFileName Returns Boolean
69503>>>>>        Boolean bOk bExists bFilePath
69503>>>>>        Integer iPos iDirSepLength
69503>>>>>        String sCurrentPath sDirSep
69503>>>>>        If (num_arguments > 1) Begin
69505>>>>>            Move bPathContainsFileName to bFilePath
69506>>>>>        End
69506>>>>>>
69506>>>>>        If (bFilePath) Begin
69508>>>>>            Get FilePath sPath to sPath
69509>>>>>        End
69509>>>>>>
69509>>>>>        Get RemoveFolderSeperator sPath to sPath
69510>>>>>        Get FileExists sPath DIRMODE_DIRECTORIES_ONLY to bExists
69511>>>>>        If (bExists) Begin
69513>>>>>            Function_Return True
69514>>>>>        End
69514>>>>>>
69514>>>>>        Get AddFolderSeperator sPath to sPath
69515>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69516>>>>>        Move (Length(sDirSep)) to iDirSepLength
69517>>>>>        Move True to bOk
69518>>>>>        // Check for absolute path an skip device or volume.
69518>>>>>        Move (Pos((":" + sDirSep), sPath)) to iPos
69519>>>>>        If (iPos > 0) Begin
69521>>>>>            Increment iPos
69522>>>>>        End
69522>>>>>>
69522>>>>>        Else Begin
69523>>>>>            // UNC path
69523>>>>>            If (Left(sPath, 2) = "\\") Begin
69525>>>>>                // Host name
69525>>>>>                Move (Pos("\", sPath, 3)) to iPos
69526>>>>>                If (iPos > 0) Begin
69528>>>>>                    Increment iPos
69529>>>>>                    // Share name
69529>>>>>                    Move (Pos("\", sPath, iPos)) to iPos
69530>>>>>                    If (iPos > 0) Begin
69532>>>>>                        Increment iPos
69533>>>>>                    End
69533>>>>>>
69533>>>>>                End
69533>>>>>>
69533>>>>>            End
69533>>>>>>
69533>>>>>        End
69533>>>>>>
69533>>>>>        If (iPos = 0) Begin
69535>>>>>            Send warning_box (SFormat("The path %1 is not an absolute path.", sPath))
69536>>>>>            Function_Return False
69537>>>>>        End
69537>>>>>>
69537>>>>>        While (iPos > 0 and bOk)
69541>>>>>            Move (Pos(sDirSep, sPath, iPos + iDirSepLength)) to iPos
69542>>>>>            If (iPos > 0) Begin
69544>>>>>                Move (Left(sPath, (iPos - 1))) to sCurrentPath
69545>>>>>                Get FileExists sCurrentPath DIRMODE_DIRECTORIES_ONLY to bExists
69546>>>>>                If (not(bExists)) Begin
69548>>>>>                    Get DirectoryCreate sCurrentPath to bOk
69549>>>>>                End
69549>>>>>>
69549>>>>>            End
69549>>>>>>
69549>>>>>        Loop
69550>>>>>>
69550>>>>>        Function_Return bOk
69551>>>>>    End_Function
69552>>>>>
69552>>>>>    // Removes an existing empty directory.
69552>>>>>    // Returns True if succeeds.
69552>>>>>    Function DirectoryRemove String sDirectoryName Returns Boolean
69554>>>>>        Boolean bFound bOk
69554>>>>>        Integer iErrorNumber
69554>>>>>        Move False to bOk
69555>>>>>        Set pbError to False
69556>>>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
69557>>>>>        If bFound Begin
69559>>>>>            Move (toAnsi(sDirectoryName)) To sDirectoryname
69560>>>>>            Move (sDirectoryname+(Character(0))) to sDirectoryname
69561>>>>>            Move (fsRemoveDirectory(sDirectoryname)) to bOk
69562>>>>>            If (bOk = False) Begin           // Could not delete
69564>>>>>                Move (fsGetLastError()) to iErrorNumber
69565>>>>>                If iErrorNumber Begin
69567>>>>>                    Send DoShowError iErrorNumber ("Tried to remove directory: "+sDirectoryName)
69568>>>>>                End
69568>>>>>>
69568>>>>>            End
69568>>>>>>
69568>>>>>        End
69568>>>>>>
69568>>>>>        Function_Return bOk
69569>>>>>    End_Function
69570>>>>>
69570>>>>>    // Removes a directory and all its contents.
69570>>>>>    // Returns true on succes.
69570>>>>>    Function DirectoryRemoveRecursive String sDirectoryName Returns Boolean
69572>>>>>        tsSearchResult[] alsSearchResults
69572>>>>>        tsSearchResult[] alsSearchResults
69573>>>>>        Integer iIndex
69573>>>>>        Boolean bOk
69573>>>>>
69573>>>>>        If (Right(sDirectoryName, 1) = "\") Begin
69575>>>>>            Move (Left(sDirectoryName, Length(sDirectoryName) - 1)) to sDirectoryName
69576>>>>>        End
69576>>>>>>
69576>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_DIRECTORIES_ONLY to alsSearchResults
69577>>>>>        For iIndex from 2 to (SizeOfArray(alsSearchResults) - 1)
69583>>>>>>
69583>>>>>            Get DirectoryRemoveRecursive (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
69584>>>>>            If (not(bOk)) Begin
69586>>>>>                Function_Return False
69587>>>>>            End
69587>>>>>>
69587>>>>>        Loop
69588>>>>>>
69588>>>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_FILES_ONLY to alsSearchResults
69589>>>>>        For iIndex from 0 to (SizeOfArray(alsSearchResults) - 1)
69595>>>>>>
69595>>>>>            Get FileDelete (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
69596>>>>>            If (not(bOk)) Begin
69598>>>>>                Function_Return False
69599>>>>>            End
69599>>>>>>
69599>>>>>        Loop
69600>>>>>>
69600>>>>>        Get DirectoryRemove sDirectoryName to bOk
69601>>>>>        Function_Return bOk
69602>>>>>    End_Function
69603>>>>>
69603>>>>>    // Converts the filetime in UTC and returns a datetime in local time.
69603>>>>>    // private
69603>>>>>    Function ConvertFileTileToLocalDateTime UBigInt ubiFileTime Returns DateTime
69605>>>>>        Boolean bOk
69605>>>>>        UBigInt ubiZero
69605>>>>>        structSystemTime lsSystemTime lsLocalTime
69605>>>>>        structSystemTime lsSystemTime lsLocalTime
69605>>>>>        DateTime dtLocalTime
69605>>>>>        Move 0 to lsSystemTime.wDay
69606>>>>>        Move 0 to lsLocalTime.wDay
69607>>>>>        Move 0 to ubiZero
69608>>>>>        If (ubiFileTime <> ubiZero) Begin
69610>>>>>            Move (fsFileTimeToSystemTime(AddressOf(ubiFileTime), AddressOf(lsSystemTime))) to bOk
69611>>>>>            If bOk Begin
69613>>>>>                Move (fsSystemTimeToTzSpecificLocalTime(FNULL, AddressOf(lsSystemTime), AddressOf(lsLocalTime))) to bOk
69614>>>>>                If bOk Begin
69616>>>>>                    Move (DateSetYear(dtLocalTime, lsLocalTime.wYear)) to dtLocalTime
69617>>>>>                    Move (DateSetMonth(dtLocalTime, lsLocalTime.wMonth)) to dtLocalTime
69618>>>>>                    Move (DateSetDay(dtLocalTime, lsLocalTime.wDay)) to dtLocalTime
69619>>>>>                    Move (DateSetHour(dtLocalTime, lsLocalTime.wHour)) to dtLocalTime
69620>>>>>                    Move (DateSetMinute(dtLocalTime, lsLocalTime.wMinute)) to dtLocalTime
69621>>>>>                    Move (DateSetSecond(dtLocalTime, lsLocalTime.wSecond)) to dtLocalTime
69622>>>>>                    Move (DateSetMillisecond(dtLocalTime, lsLocalTime.wMillieseconds)) to dtLocalTime
69623>>>>>                End
69623>>>>>>
69623>>>>>            End
69623>>>>>>
69623>>>>>        End
69623>>>>>>
69623>>>>>        Function_Return dtLocalTime
69624>>>>>    End_Function
69625>>>>>
69625>>>>>    // Returns the filename with full path where the casing is preserved from windows.
69625>>>>>    Function FilePreservedFilename String sFilename Returns String
69627>>>>>        Integer iNumOfDirectories iCurrentDirectory
69627>>>>>        String sPreservedFilename sCurDir sSearchName
69627>>>>>        tsSearchResult[] lsSearchResult
69627>>>>>        tsSearchResult[] lsSearchResult
69628>>>>>
69628>>>>>        Get CountOfFields sFilename "\" to iNumOfDirectories
69629>>>>>        For iCurrentDirectory from 1 to (iNumOfDirectories - 1)
69635>>>>>>
69635>>>>>            Get FieldAtIndex sFilename iCurrentDirectory "\" to sCurDir
69636>>>>>            If (sCurDir <> "") Begin
69638>>>>>                If (Right(sCurDir, 1) <> ":") Begin
69640>>>>>                    Move (sPreservedFilename + sCurDir) to sSearchName
69641>>>>>                    Get FileSearch sSearchName DIRMODE_DIRECTORIES_ONLY to lsSearchResult
69642>>>>>                    If (SizeOfArray(lsSearchResult) > 0) Begin
69644>>>>>                        Move (sPreservedFilename + lsSearchResult[0].sFilename + "\") to sPreservedFilename
69645>>>>>                    End
69645>>>>>>
69645>>>>>                    Else Begin
69646>>>>>                        Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
69647>>>>>                    End
69647>>>>>>
69647>>>>>                End
69647>>>>>>
69647>>>>>                Else Begin
69648>>>>>                    Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
69649>>>>>                End
69649>>>>>>
69649>>>>>            End
69649>>>>>>
69649>>>>>            Else Begin
69650>>>>>                Move (sPreservedFilename + "\") to sPreservedFilename
69651>>>>>            End
69651>>>>>>
69651>>>>>        Loop
69652>>>>>>
69652>>>>>        Get FileSearch sFilename DIRMODE_FILES_AND_DIRECTORIES to lsSearchResult
69653>>>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
69655>>>>>            Move (sPreservedFilename + lsSearchResult[0].sFilename) to sPreservedFilename
69656>>>>>        End
69656>>>>>>
69656>>>>>        Else Begin
69657>>>>>            Function_Return ""
69658>>>>>        End
69658>>>>>>
69658>>>>>        Function_Return sPreservedFilename
69659>>>>>    End_Function
69660>>>>>
69660>>>>>    // Returns the number of fields present in a string of fields seperated by a delimiter.
69660>>>>>    // If sDelimiter is not applied the ";" will be used.
69660>>>>>    Function CountOfFields String sFields String sDelimiter Returns Integer
69662>>>>>        Integer iChar icChar iField
69662>>>>>        String sDlm
69662>>>>>        If (sFields ="") Begin
69664>>>>>            Function_Return 0
69665>>>>>        End
69665>>>>>>
69665>>>>>        If (num_arguments > 1) Begin
69667>>>>>            Move sDelimiter to sDlm
69668>>>>>        End
69668>>>>>>
69668>>>>>        Else Begin
69669>>>>>            Move ";" to sDlm
69670>>>>>        End
69670>>>>>>
69670>>>>>        Move (Length(sFields) -1) to icChar
69671>>>>>        For iChar from 1 to icChar
69677>>>>>>
69677>>>>>            If (Mid(sFields, 1, iChar) = sDlm) Begin
69679>>>>>                Increment iField
69680>>>>>            End
69680>>>>>>
69680>>>>>        Loop
69681>>>>>>
69681>>>>>        Function_Return (iField +1)
69682>>>>>    End_Function
69683>>>>>
69683>>>>>    // Returns a field from a string containing multiple delimited fields.
69683>>>>>    // Index is 1-based.
69683>>>>>    Function FieldAtIndex String sFields Integer iIndex String sDelimiter Returns String
69685>>>>>        Integer iField iPos
69685>>>>>        String sField sDlm
69685>>>>>        If (num_arguments > 2) Begin
69687>>>>>            Move sDelimiter to sDlm
69688>>>>>        End
69688>>>>>>
69688>>>>>        Else Begin
69689>>>>>            Move ";" to sDlm
69690>>>>>        End
69690>>>>>>
69690>>>>>        Move (sFields + sDlm) to sFields
69691>>>>>        For iField from 1 to iIndex
69697>>>>>>
69697>>>>>            Move (Pos(sDlm, sFields)) to iPos
69698>>>>>            If iPos Begin
69700>>>>>                Move (Left(sFields, iPos -1)) to sField
69701>>>>>                Move (Right(sFields, Length(sFields) -iPos)) to sFields
69702>>>>>            End
69702>>>>>>
69702>>>>>            Else Begin
69703>>>>>                Function_Return ""
69704>>>>>            End
69704>>>>>>
69704>>>>>        Loop
69705>>>>>>
69705>>>>>        Function_Return sField
69706>>>>>    End_Function
69707>>>>>
69707>>>>>    // Removes the file extention from the sFile string and returns the extention including "."
69707>>>>>    // Example sFile = "x:\text.txt". The function returns ".txt" and sFile = "x:\text".
69707>>>>>    Function RemoveExtention String ByRef sFilename Returns String
69709>>>>>        String sExtention
69709>>>>>        Integer iLengthExtention
69709>>>>>        Get FileExtention sFilename to sExtention
69710>>>>>        Move (Length(sExtention)) to iLengthExtention
69711>>>>>        If (iLengthExtention > 0) Begin
69713>>>>>            Move (Left(sFilename, (Length(sFilename) - iLengthExtention - 1))) to sFilename
69714>>>>>        End
69714>>>>>>
69714>>>>>        Function_Return sExtention
69715>>>>>    End_Function
69716>>>>>
69716>>>>>    // Add a directory separator if it is not present.
69716>>>>>    // Example sFoldername = "x:\FolderA". The function returns "x:\FolderA\"
69716>>>>>    Function AddFolderSeperator String sFolderName Returns String
69718>>>>>        String sDirSep
69718>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69719>>>>>        Move (Trim(sFolderName)) to sFolderName
69720>>>>>        If (Right(sFolderName, 1) <> sDirSep) Begin
69722>>>>>            Move (sFolderName + sDirSep) to sFolderName
69723>>>>>        End
69723>>>>>>
69723>>>>>        Function_Return sFolderName
69724>>>>>    End_Function
69725>>>>>
69725>>>>>    // Removes a directory separator if it is present.
69725>>>>>    // Example sFoldername = "x:\FolderA\". The function returns "x:\FolderA"
69725>>>>>    Function RemoveFolderSeperator String sFolderName Returns String
69727>>>>>        String sDirSep
69727>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69728>>>>>        Move (Trim(sFolderName)) to sFolderName
69729>>>>>        If (Right(sFolderName, 1) = sDirSep) Begin
69731>>>>>            Move (Left(sFolderName, Length(sFolderName) - 1)) to sFolderName
69732>>>>>        End
69732>>>>>>
69732>>>>>        Function_Return sFolderName
69733>>>>>    End_Function
69734>>>>>
69734>>>>>    Function FileLastWriteTime String sFileName Returns tFileTime
69736>>>>>        DWord dwAccess
69736>>>>>        DWord dwShared
69736>>>>>        DWord dwCreate
69736>>>>>        Handle hFile
69736>>>>>        Integer iRetval iErrorNumber
69736>>>>>        tFileTime ftLastWrite
69736>>>>>        tFileTime ftLastWrite
69736>>>>>        //
69736>>>>>        Append sFilename (Character(0)) (Character(0))
69738>>>>>        Move (GENERIC_READ iOr GENERIC_WRITE) To dwAccess
69739>>>>>        Move FILE_SHARE_RANDOM   To dwShared
69740>>>>>        Move OPEN_EXISTING       To dwCreate
69741>>>>>
69741>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) To hFile
69742>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
69744>>>>>            Move (fsGetLastError()) To iErrorNumber
69745>>>>>            If iErrorNumber Begin
69747>>>>>                Send DoShowError iErrorNumber sFileName
69748>>>>>            End
69748>>>>>>
69748>>>>>            Procedure_Return
69749>>>>>        End
69749>>>>>>
69749>>>>>        Else Begin
69750>>>>>            Move 0 To ftLastWrite.dwLowDateTime
69751>>>>>            Move (fsGetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) To iRetval
69752>>>>>            If (iRetVal = 0) Begin           //Could not close
69754>>>>>                Move (fsGetLastError()) To iErrorNumber
69755>>>>>                If iErrorNumber Begin
69757>>>>>                    Send DoShowError iErrorNumber sFileName
69758>>>>>                End
69758>>>>>>
69758>>>>>            End
69758>>>>>>
69758>>>>>            Move (fsCloseHandle(hFile)) To iRetVal
69759>>>>>            If (iRetVal = 0) Begin           //Could not close
69761>>>>>                Move (fsGetLastError()) To iErrorNumber
69762>>>>>                If iErrorNumber Begin
69764>>>>>                    Send DoShowError iErrorNumber sFileName
69765>>>>>                End
69765>>>>>>
69765>>>>>            End
69765>>>>>>
69765>>>>>        End
69765>>>>>>
69765>>>>>        Function_Return ftLastWrite
69766>>>>>    End_Function
69767>>>>>
69767>>>>>    Function CurrentSystemTimeAsFileTime Returns tFileTime
69769>>>>>        Integer iRetVal
69769>>>>>        Integer iErrorNumber
69769>>>>>        String  sFileName
69769>>>>>        tFileTime ftCurrentTime
69769>>>>>        tFileTime ftCurrentTime
69769>>>>>
69769>>>>>        Move 0 to ftCurrentTime.dwLowDateTime
69770>>>>>        Move (fsGetSystemTimeAsFileTime(AddressOf(ftCurrentTime))) to iRetVal
69771>>>>>        If (iRetVal = 0) Begin
69773>>>>>            Move (fsGetLastError()) to iErrorNumber
69774>>>>>            If iErrorNumber Begin
69776>>>>>                Send DoShowError iErrorNumber sFileName
69777>>>>>            End
69777>>>>>>
69777>>>>>        End
69777>>>>>>
69777>>>>>        Function_Return ftCurrentTime
69778>>>>>    End_Function
69779>>>>>
69779>>>>>    // Nils 2018-08-30 Added this message from Akefs.pkg as we need it For the
69779>>>>>    // SourceCodeTools project
69779>>>>>    Procedure Set FileLastWriteTime String sFileName tFileTime ftLastWrite
69781>>>>>        DWord dwAccess dwShared dwCreate
69781>>>>>        Handle hFile
69781>>>>>        Integer iRetval iErrorNumber
69781>>>>>
69781>>>>>        Append sFilename (Character(0)) (Character(0))
69783>>>>>        Move (GENERIC_READ ior GENERIC_WRITE) to dwAccess
69784>>>>>        Move FILE_SHARE_RANDOM   to dwShared
69785>>>>>        Move OPEN_EXISTING       to dwCreate
69786>>>>>
69786>>>>>        Move (fsCreatefile(sFilename, dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) to hFile
69787>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
69789>>>>>            Move (fsGetLastError()) to iErrorNumber
69790>>>>>            If (iErrorNumber <> 0) Begin
69792>>>>>                Send DoShowError iErrorNumber sFileName
69793>>>>>            End
69793>>>>>>
69793>>>>>            Procedure_Return
69794>>>>>        End
69794>>>>>>
69794>>>>>        Else Begin
69795>>>>>            Move (fsSetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) to iRetval
69796>>>>>            If (iRetVal = 0) Begin           //Could not close
69798>>>>>                Move (fsGetLastError()) to iErrorNumber
69799>>>>>                If (iErrorNumber <> 0) Begin
69801>>>>>                    Send DoShowError iErrorNumber sFileName
69802>>>>>                End
69802>>>>>>
69802>>>>>            End
69802>>>>>>
69802>>>>>            Move (fsCloseHandle(hFile)) to iRetVal
69803>>>>>            If (iRetVal = 0) Begin           //Could not close
69805>>>>>                Move (fsGetLastError()) to iErrorNumber
69806>>>>>                If (iErrorNumber <> 0) Begin
69808>>>>>                    Send DoShowError iErrorNumber sFileName
69809>>>>>                End
69809>>>>>>
69809>>>>>            End
69809>>>>>>
69809>>>>>        End
69809>>>>>>
69809>>>>>    End_Procedure
69810>>>>>
69810>>>>>    // Fetch the error message from the system message table using the default language.
69810>>>>>    // If not in unicode then the variable sAppendErrorText is in ANSI
69810>>>>>    Procedure DoShowError Integer iErrorNumber String sAppendErrorText
69812>>>>>        Pointer lpOut
69812>>>>>        Integer iRetChars iRetVal
69812>>>>>        String sMsg
69812>>>>>        Boolean bOk
69812>>>>>
69812>>>>>        Move 0 to lpOut
69813>>>>>        Move (fsFormatMessage((FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS+FORMAT_MESSAGE_ALLOCATE_BUFFER), FNULL, iErrorNumber, FNULL, AddressOf(lpOut), 0, FNULL)) to iRetChars
69814>>>>>        If (iRetChars > 0) Begin
69816>>>>>            Move (ZeroString(iRetChars)) to sMsg
69817>>>>>            Move (MemCopy(AddressOf(sMsg), lpOut, iRetChars)) to bOk
69818>>>>>            Move (fsLocalFree(lpOut)) to iRetVal
69819>>>>>            Move (ToOEM(sMsg)) To sMsg
69820>>>>>            Move (ToOEM(sAppendErrorText)) To sAppendErrorText
69821>>>>>            If (num_arguments > 0) Begin
69823>>>>>                Move (Trim(sAppendErrorText)) to sAppendErrorText
69824>>>>>                If (sAppendErrorText <> "") Begin
69826>>>>>                    Append sMsg "\n" sAppendErrorText
69828>>>>>                End
69828>>>>>>
69828>>>>>            End
69828>>>>>>
69828>>>>>            Send warning_box sMsg
69829>>>>>        End
69829>>>>>>
69829>>>>>    End_Procedure
69830>>>>>
69830>>>>>    // Shows a warning message to user with OK button and a exclamation icon.
69830>>>>>    // private
69830>>>>>    Procedure Warning_Box String sWngMsg
69832>>>>>        Integer iVoid
69832>>>>>        Boolean bSendVdfError
69832>>>>>        Set pbError to True
69833>>>>>        Get pbErrorAsVDFError to bSendVdfError
69834>>>>>        If (bSendVdfError = False) Begin
69836>>>>>            Get Message_Box sWngMsg "Filesystem Error" MB_OK MB_ICONEXCLAMATION to iVoid
69837>>>>>        End
69837>>>>>>
69837>>>>>        Else Begin
69838>>>>>            Error DFERR_PROGRAM sWngMsg
69839>>>>>>
69839>>>>>        End
69839>>>>>>
69839>>>>>    End_Procedure
69840>>>>>
69840>>>>>    // Fetch the filename from the list of filenames associated with a filenumber.
69840>>>>>    // This function is used For reporting filenames during an error.
69840>>>>>    // private
69840>>>>>    Function FileErrorText Integer iFilenumber Returns String
69842>>>>>        String sErrorText
69842>>>>>        structFile[] lsFile
69842>>>>>        structFile[] lsFile
69843>>>>>        Get plsFile to lsFile
69844>>>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
69846>>>>>            Move ("File: "+lsFile[iFilenumber].sFilename) to sErrorText
69847>>>>>        End
69847>>>>>>
69847>>>>>        Function_Return sErrorText
69848>>>>>    End_Function
69849>>>>>
69849>>>>>End_Class
69850>>>Use RefactorFunctionConstants.inc
Including file: RefactorFunctionConstants.inc    (C:\Projects\DF18\DfRefactor\AppSrc\RefactorFunctionConstants.inc)
69850>>>>>Use Windows.pkg
69850>>>>>Use DFClient.pkg
69850>>>>>Use cFilesystem.pkg
69850>>>>>
69850>>>>>Enum_List
69850>>>>>    Define cx_RegKeyAlreadyExist
69850>>>>>    Define cx_RegKeyCreated
69850>>>>>    Define cx_RegkeyFailed
69850>>>>>    Define cx_RegKeyDFKeyDoesNotExist
69850>>>>>    Define cx_InstalledOkDFUnder16
69850>>>>>End_Enum_List
69850>>>>>
69850>>>>>Enum_List
69850>>>>>    Define CI_LeftExpression
69850>>>>>    Define CI_CommandExpression
69850>>>>>    Define CI_OfExpression
69850>>>>>    Define CI_ToTexpression
69850>>>>>End_Enum_List
69850>>>>>
69850>>>>>Struct tWorkspace
69850>>>>>    String sWorkspace
69850>>>>>    String sWorkspaceFull    
69850>>>>>End_Struct
69850>>>>>
69850>>>>>Struct tRefactorCheckbox
69850>>>>>    Handle hObject
69850>>>>>    Boolean bChecked
69850>>>>>    Boolean bReportFunction
69850>>>>>    Integer iRefactorFunction
69850>>>>>End_Struct
69850>>>>>
69850>>>>>Struct tRefactorSettings
69850>>>>>    Integer iSelectedStandardFunctions  // Are called for each source line.
69850>>>>>    Integer iSelectedRemoveFunctions    // Are called for each source line. May remove the source line. Returns True if line should be removed
69850>>>>>    Integer iSelectedEditorFunctions    // Using the Scintilla Editor. A Full source file is passed.
69850>>>>>    Integer iSelectedReportFunctions    // Makes no source changes. A full source file is passed.
69850>>>>>    Integer iSelectedReportAllFunctions // Makes no source changes. All selected files are passed as a string array (including path).
69850>>>>>    Integer iSelectedOtherFunctions     // A full source file is passed to functions as a string array.
69850>>>>>    Integer iSelectedOtherAllFunctions  // All selected files are passed as a string array (including path).
69850>>>>>    //
69850>>>>>    Integer iSelectedLineByLineFunctions  // Sum of all line-by-line action functions (not full file or report functions).
69850>>>>>    Integer iSelectedFullFileFunctions  // Sum of all functions that should be feed with a string array of _one_ source file.
69850>>>>>    Integer iSelectedAllFilesFunctions  // All functions that should be feed with a string array with all selected files (including path).
69850>>>>>    //
69850>>>>>    Boolean bCountSourceLines           // If we should only count source lines (all other functions will be ignored).
69850>>>>>    Boolean bEditorDropSelf             // Scintilla Editor special function that pops up a dialog before each change(!).
69850>>>>>    //
69850>>>>>    String  sFileFilter                 // File selection filter.
69850>>>>>    String[] asFolderNames              // String array with full path to all selected folders.
69850>>>>>End_Struct                   
69850>>>>>
69850>>>>>Struct tParseObject
69850>>>>>    String sObject
69850>>>>>    String sObjectLabel  // short name
69850>>>>>    String sClass
69850>>>>>    Handle pElement
69850>>>>>End_Struct
69850>>>>>
69850>>>>>Struct tCJComboBoxContent
69850>>>>>    String sText
69850>>>>>    Integer eTheme
69850>>>>>End_Struct
69850>>>>>
69850>>>>>Struct tBackupFiles
69850>>>>>    String sFileName
69850>>>>>    String sPath
69850>>>>>    DateTime dtFileDate
69850>>>>>End_Struct
69850>>>>>
69850>>>>>Struct tCodeComponents
69850>>>>>    String sIndentation
69850>>>>>    String sLineStartIndicator
69850>>>>>    String sLineEndIndicator
69850>>>>>    Boolean bHasIndicateCommand
69850>>>>>    String sLeftCommand
69850>>>>>    String sCode   
69850>>>>>    String sOfStatement   
69850>>>>>    String sToStatement
69850>>>>>    String sRightComment 
69850>>>>>    Boolean bHasEndSemiColon   
69850>>>>>End_Struct 
69850>>>>>
69850>>>>>Struct tBooleanIndicator
69850>>>>>    Boolean bHasBracket  
69850>>>>>    Boolean bHasNot
69850>>>>>    String sExpression
69850>>>>>    String sCode
69850>>>>>End_Struct        
69850>>>>>
69850>>>>>Struct tOperatorsInfo
69850>>>>>    Boolean bIsOperator
69850>>>>>    Boolean bIsLegacy
69850>>>>>    Integer iPos
69850>>>>>    String  sOperator
69850>>>>>End_Struct
69850>>>>>
69850>>>>>    Define clGreenGrey              for (RGB(64, 84, 93))
69850>>>>>    Define clGreenGreyLight         for (RGB(7, 117, 104))
69850>>>>>Define clDarkGreen                  for (RGB(49, 60, 83))
69850>>>>>
69850>>>>>Define CPC_OpenFile                 for 1 // perfcounter on open file
69850>>>>>Define CS_Settings                  for "Settings"
69850>>>>>Define CS_GridFontSize              for "GridFontSize"
69850>>>>>Define CS_StarZenSourceExplorer     for "StarZenSourceExplorer"
69850>>>>>Define CS_FileCompareProgram        for "FileCompareProgram"
69850>>>>>Define CS_ToolbarIconSize           for "ToolbarIconSize"
69850>>>>>Define CS_GridRowBackgroundColor    for "GridRowBackgroundColor"
69850>>>>>Define CS_MaxBlankLineSize          for "MaxBlankLineSize"
69850>>>>>Define CS_SplitByPreference         for "SplitByPreference"
69850>>>>>Define CS_DataFlexVersionText       for "DataFlex Version:"
69850>>>>>Define CS_SelectWorkspaceText       for "Select Workspace:"
69850>>>>>Define CS_CurrentWorkspaceText      for "Current Workspace:"
69850>>>>>Define CS_WorkspacesKey             for "Workspaces"
69850>>>>>Define CS_WorkspacePaths            for "WorkspacePaths"
69850>>>>>Define CS_ConfigFile                for "ConfigFile"
69850>>>>>Define CS_WorkspaceRecentKey        for "Recent"
69850>>>>>Define CS_PropertiesKeyWord         for "Properties"
69850>>>>>Define CS_ThemeKeyWord              for "Theme"
69850>>>>>Define CS_VersionKeyWord            for "Version"
69850>>>>>Define CS_OpenWorkspace             for "Select &Workspace"
69850>>>>>//Define CS_OpenWorkspace             for "Open &Workspace"
69850>>>>>Define CS_CurrentWorkspace          for "Current &Workspace:"
69850>>>>>Define CS_NoActiveWorkspaceText     for ""
69850>>>>>Define CS_SelectWorkspaceFile       for "Select a DataFlex workspace project file (*.sws)"
69850>>>>>Define CS_BrowseSourceFileTxt       for "Select File:"
69850>>>>>Define CS_CurrentSourceFileTxt      for "Current File:"
69850>>>>>Define CS_NoActiveSourceFileText    for "" 
69850>>>>>Define CS_NoWorkspaceSelected       for "- None"
69850>>>>>Define CS_WorkspaceFilterString     for "DataFlex Workspace Files (*.sws)|*.sws|Any file (*.*)|*.*"
69850>>>>>Define CS_OpenFileStdFilter         for "All files *.*|*.*|Programs *.src|*.src|Views *.vw|*.vw|Report Views *.rv|*.rv|Selection Lists *.sl|*.sl|Packages *.pkg|*.pkg"
69850>>>>>Define CS_SourceCodeFilters         for "DataFlex Source *.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu|*.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu"
69850>>>>>Define CS_SourceFileFilters         for "Programs|*.src|Views|*.vw|Dialogs|*.dg|Data Dictionaries|*.dd|Include files|*.inc|Report Views|*.rv|Selection Lists|*.sl|Packages|*.pkg|Business Processes|*.bp|Menus|*.mn|Header Files|*.h|Sture's Files|*.nui;*.utl|Any file|*.*"
69850>>>>>Define CS_CreateBackupFiles         for "CreateBackupFiles"
69850>>>>>Define CS_SummaryLogfileName        for "DFRefactoringLogFile.txt"
69850>>>>>
69850>>>>>Define CS_VarTypes                  for "STRING;INTEGER;NUMBER;DATE;DATETIME;BOOLEAN;HANDLE;REAL;VARIANT;TIMESPAN;ROWID;DECIMAL;BIGINT;REAL;UCHAR;ADDRESS;CHAR;CURRENCY;DWORD;FLOAT;POINTER;SHORT;TIME;UBIGINT;USHORT" // careful, cannot end on a semicolumn as you will introduce variable type equal to ""
69850>>>>>Define CS_VarArrayTypes             for "STRING[];INTEGER[];NUMBER[];DATE[];DATETIME[];BOOLEAN[];HANDLE[];REAL[];VARIANT[];TIMESPAN[];ROWID[];DECIMAL[];BIGINT[];REAL[];UCHAR[];ADDRESS[];CHAR[];CURRENCY[];DWORD[];FLOAT[];POINTER[];SHORT[];TIME[];UBIGINT[];USHORT[];STRING[][];INTEGER[][];NUMBER[][];DATE[][];DATETIME[][];BOOLEAN[][];HANDLE[][];REAL[][];VARIANT[][];TIMESPAN[][];ROWID[][];DECIMAL[][];BIGINT[][];REAL[][];UCHAR[][];ADDRESS[][];CHAR[][];CURRENCY[][];DWORD[][];FLOAT[][];POINTER[][];SHORT[][];TIME[][];UBIGINT[][];USHORT[][]"
69850>>>>>Define CS_ValidLeftCharacters       for ("()[];,&+-*<>= " + Character(9)) // Character 9=tab char //"()[];,.&+-*<>= "
69850>>>>>
69850>>>>>Define CS_UnusedSourceLogFile       for "UnusedSourceFiles.txt"
69850>>>>>Define CS_CommentSymbol             for ("/"+"/")
69850>>>>>Define CS_ImageNameStart            for "/"
69850>>>>>Define CS_ImageNameEnd              for "/*"
69850>>>>>Define CS_StudioToolsPathStart      for "Software\Data Access Worldwide\DataFlex Tools\"
69850>>>>>Define CS_StudioToolsPathEnd        for "\Studio\Preferences\File Extensions"
69850>>>>>Define CS_StudioCodeEditorPath      for "\Studio\Code-Editor"
69850>>>>>Define CS_StudioFontName            for "FontName"
69850>>>>>Define CS_StudioFontSize            for "FontSize"
69850>>>>>Define CS_StudioExpandTabs          for "ExpandTabs"
69850>>>>>Define CS_StudioIndentStyle         for "IndentStyle"
69850>>>>>Define CS_StudioTabSize             for "TabSize"
69850>>>>>Define CS_StudioEditorSettingsStart for "DataFlex Studio"
69850>>>>>Define CS_StudioEditorSettingsEnd   for "Code Editor Settings"
69850>>>>>Define CS_StudioEditorSettingsExtra for "(Will be applied when indenting code)"
69850>>>>>Define CS_IdleText                  for "Idle..."
69850>>>>>Define CS_WorkingText               for "Working..."
69850>>>>>Define CS_ReadyText                 for "Ready!"
69850>>>>>
69850>>>>>Define CS_Default_Dialog_Caption    for "Select a source file"
69850>>>>>Define CS_Folder_Dialog_Caption     for "Select a Filename - Only the foldername will be returned"
69850>>>>>Define CS_Default_Filter_String     for "All Files *.*|*.*|Programs *.src|*.src|Views *.vw|*.vw|Report Views *.rv|*.rv|Selection Lists *.sl|*.sl|Packages *.pkg|*.pkg"
69850>>>>>Define CS_Folder_Filter_String      for "All files|*.*"
69850>>>>>
69850>>>>>Define CS_BackupFolder              for "DFRefactor Backup"
69850>>>>>Define CS_NoFolderList              for (".|..|.svn|.git|.hg|apphtml|data|bitmaps|help|idesrc|programs|.cab|install")
69850>>>>>//Define CS_NoFolderList              for (".|..|.svn|.git|.hg|apphtml|data|bitmaps|help|idesrc|programs|.cab|install" + "|" + CS_BackupFolder)
69850>>>>>Define CS_DefaultSourceFolders      for "appsrc|ddsrc|libraries|pkg"
69850>>>>>Define CS_LF                        for (Character(10))
69850>>>>>Define CS_CR                        for (Character(13))
69850>>>>>Define CS_CRLF                      for (Character(13) + Character(10))
69850>>>>>Define CS_DirSeparator              for (SysConf(SYSCONF_DIR_SEPARATOR))
69850>>>>>Define CI_EOL                       for 2048
69850>>>>>
69850>>>>>
69850>>>>>// Note: the "Visual" will automatically be replace if a more recent DF version is used.
69850>>>>>Define CS_StudioPath                for "Software\Data Access Worldwide\Visual DataFlex Tools\"
69850>>>>>Define CS_StudioPathEnd             for  "\Studio\Preferences\File Extensions"
69850>>>>>Define CS_WebFileExtensions         for ".wo;.html;.asa;.asp;.css;.js"
69850>>>>>Define CS_StdExtensions             for "*.src;*.vw;*.sl;*.dg;*.rv;*.pkg;*.cl;*.wo;*.dd;*.bp;*.inc;*.nui;*.utl;*.mn;*.mnu"
69850>>>>>Define CS_DFAndTemplExt             for "*.src;*.vw;*.sl;*.dg;*.rv;*.bp;*.pkg;*.wo;*.dd;*.inc;*.dfo;*.tpl"
69850>>>>>Define CS_DDDEFExt                  for "*.dd"
69850>>>>>Define CS_PkgIncExt                 for "*.pkg;*.inc;*.mac"
69850>>>>>Define CS_SrcPkgExt                 for "*.src;*.pkg"
69850>>>>>Define CS_AllExt                    for "*.*"
69850>>>>>Define CS_DFExtensionsKey           for "DFExtension"
69850>>>>>
69850>>>>>Define CS_DFCOMProxyClasses         for "DataFlex COM proxy classes generated from"
69850>>>>>Define CS_ProjectObjectStructure    for "Project Object Structure"
69850>>>>>Define CS_RegisterAllObjects        for "Register all objects"
69850>>>>>Define CS_RegisterObject            for "Register_Object "
69850>>>>>
69850>>>>>// Special function names:
69850>>>>>Define CS_CountSourceLines              for "CountSourceLines"
69850>>>>>Define CS_EditorReIndent                for "EditorReIndent"
69850>>>>>Define CS_EditorDropSelf                for "EditorDropSelf"
69850>>>>>Define CS_RemoveProjectObjectStructure  for "RemoveProjectObjectStructure"
69850>>>>>//Define CS_RemoveBlankLines              for "RemoveBlankLines"
69850>>>>>Define CS_UnusedSourceFiles             for "ReportUnusedSourceFiles"
69850>>>>>
69850>>>>>// Refactor Testing program:
69850>>>>>Define CS_Compiler       for "DFComp.exe"
69850>>>>>Define CS_TestProgram    for "CompiledRefactoredCode.src"
69850>>>>>Define CS_TestErrFile    for "CompiledRefactoredCode.err"
69850>>>>>Define CS_CompOptions    for "-e3fv2i0"     
69850>>>>>Define CS_SWSFile        for "DFRefactor19.1.sws"
69850>>>>>Define CS_DFUnitTest     for "DFUnit_TestRunner"
69850>>>>>Define CS_DFRefactor     for "DFRefactor"
69850>>>>>Define CS_LegacyCode     for "LegacyCode.pkg"
69850>>>>>Define CS_RefactoredCode for "RefactoredCode.pkg"
69850>>>>>
69850>>>>>// Refactor Testing program:
69850>>>>>Define CS_Trim           for "Trim"    
69850>>>>>Define CS_Length         for "Length"  
69850>>>>>Define CS_Pos            for "Pos"   
69850>>>>>Define CS_Replace        for "Replace"
69850>>>>>Define CS_In             for "In" 
69850>>>>>Define CS_If             for "If"   
69850>>>>>Define CS_Else           for "Else"
69850>>>>>Define CS_Begin          for "Begin"
69850>>>>>Define CS_With           for "With" 
69850>>>>>Define CS_At             for "At"   
69850>>>>>Define CS_As             for "As"  
69850>>>>>Define CS_To             for "to"
69850>>>>>Define CS_Of             for "of"
69850>>>>>Define CS_ZeroString     for "ZeroString"  
69850>>>>>Define CS_Insert         for "Insert" 
69850>>>>>Define CS_Repeat         for "Repeat"
69850>>>>>Define CS_While          for "While" 
69850>>>>>Define CS_Loop           for "Loop"
69850>>>>>Define CS_Current_Object for "Current_Object"
69850>>>>>Define CS_Self           for "Self"
69850>>>>>Define CS_Move           for "Move"
69850>>>>>Define CS_Indicate       for "Indicate"  
69850>>>>>Define CS_Not            for "Not"
69850>>>>>Define CS_True           for "True"   
69850>>>>>Define CS_False          for "False"
69850>>>>>Define CS_DfTrue         for "DfTrue"
69850>>>>>Define CS_DfFalse        for "DfFalse"
69850>>>>>Define CS_Set            for "Set"
69850>>>>>Define CS_Get            for "Get"
69850>>>>>Define CS_Enabled_State  for "Enabled_State" 
69850>>>>>Define CS_Find           for "Find"   
69850>>>>>Define CS_Send           for "Send"
69850>>>>>Define CS_Found          for "Found"
69850>>>>>Define CS_Finderr        for "Finderr"
69850>>>>>Define CS_Sysdate4       for "Sysdate4"
69850>>>>>Define CS_Constrain      for "Constrain"
69850>>>>>Define CS_Until          for "Until"
69850>>>>>Define CS_Local          for "Local"
69850>>>>>Define CS_GetAddress     for "GetAddress" 
69850>>>>>Define CS_AddressOf      for "AddressOf"
69850>>>>>Define CS_Function       for "Function"
69850>>>>>Define CS_Contains       for "contains"
69850>>>>>Define CS_Select         for "[Select]"
69850>>>>>
69850>>>>>// cRegex Expression Constants:
69850>>>>>//
69850>>>Use DeleteWorkspaceHistory.dg
Including file: DeleteWorkspaceHistory.dg    (C:\Projects\DF18\DfRefactor\AppSrc\DeleteWorkspaceHistory.dg)
69850>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\cRDCModalPanel.pkg)
69850>>>>>>>//****************************************************************************
69850>>>>>>>// $Module type: Class
69850>>>>>>>// $Module name: cRDCModalPanel
69850>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
69850>>>>>>>// Created     : 2014-03-17 @ 12:33
69850>>>>>>>//
69850>>>>>>>// Description :
69850>>>>>>>//
69850>>>>>>>// $Rev History:
69850>>>>>>>//    2014-03-17  Module header created
69850>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
69850>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
69850>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
69850>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
69850>>>>>>>// in the help folder for more details.
69850>>>>>>>//
69850>>>>>>>//****************************************************************************
69850>>>>>>>Use Windows.pkg
69850>>>>>>>Use cCJCommandBarSystem.pkg   
69850>>>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJSkinFramework.pkg)
69850>>>>>>>>>Use windows.pkg
69850>>>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJComSkinFramework.pkg)
69850>>>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.SkinFramework.v18.3.0.ocx
69850>>>>>>>>>>>Use FlexCom20.pkg
69850>>>>>>>>>>>
69850>>>>>>>>>>>// Changes to Imported package
69850>>>>>>>>>>>//     OLEXTPxx to XTPxx
69850>>>>>>>>>>>//     OLExtpxx to xtpxx
69850>>>>>>>>>>>//     OLESkinFramework to SkinFramework
69850>>>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
69850>>>>>>>>>>>//     cCom classes to cCJ
69850>>>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
69850>>>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
69850>>>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
69850>>>>>>>>>>>//     Use statements as noted below (classes moved to these files)
69850>>>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
69850>>>>>>>>>>>
69850>>>>>>>>>>>// These have been extracted from this class and moved into seperate packages
69850>>>>>>>>>>>// because other Codejock classes use these.
69850>>>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
69850>>>>>>>>>>>
69850>>>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
69850>>>>>>>>>>>    Define xtpSkinApplyMetrics for 1
69850>>>>>>>>>>>    Define xtpSkinApplyFrame for 2
69850>>>>>>>>>>>    Define xtpSkinApplyColors for 4
69850>>>>>>>>>>>    Define xtpSkinApplyMenus for 8
69850>>>>>>>>>>>
69850>>>>>>>>>>>// CLSID: {C0DE1830-28D7-4F2C-87A7-7266367B4655}
69850>>>>>>>>>>>// Dispatch interface for SkinFramework Control
69850>>>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
69851>>>>>>>>>>>
69851>>>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
69853>>>>>>>>>>>        SkinFrameworkApplyOptions retVal
69853>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
69854>>>>>>>>>>>        Function_Return retVal
69855>>>>>>>>>>>    End_Function
69856>>>>>>>>>>>
69856>>>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
69858>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
69859>>>>>>>>>>>    End_Procedure
69860>>>>>>>>>>>
69860>>>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
69862>>>>>>>>>>>        Boolean retVal
69862>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
69863>>>>>>>>>>>        Function_Return retVal
69864>>>>>>>>>>>    End_Function
69865>>>>>>>>>>>
69865>>>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
69867>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
69868>>>>>>>>>>>    End_Procedure
69869>>>>>>>>>>>
69869>>>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
69871>>>>>>>>>>>        Boolean retVal
69871>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
69872>>>>>>>>>>>        Function_Return retVal
69873>>>>>>>>>>>    End_Function
69874>>>>>>>>>>>
69874>>>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
69876>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
69877>>>>>>>>>>>    End_Procedure
69878>>>>>>>>>>>
69878>>>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
69880>>>>>>>>>>>        Handle hDispatchDriver
69880>>>>>>>>>>>        Boolean retVal
69880>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69881>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
69882>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
69883>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
69884>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
69885>>>>>>>>>>>        Function_Return retVal
69886>>>>>>>>>>>    End_Function
69887>>>>>>>>>>>
69887>>>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
69889>>>>>>>>>>>        Handle hDispatchDriver
69889>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69890>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
69891>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
69892>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
69893>>>>>>>>>>>    End_Procedure
69894>>>>>>>>>>>
69894>>>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
69896>>>>>>>>>>>        Handle hDispatchDriver
69896>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69897>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
69898>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
69899>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
69900>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
69901>>>>>>>>>>>    End_Procedure
69902>>>>>>>>>>>
69902>>>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
69904>>>>>>>>>>>        Handle hDispatchDriver
69904>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69905>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
69906>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
69907>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
69908>>>>>>>>>>>    End_Procedure
69909>>>>>>>>>>>
69909>>>>>>>>>>>    Procedure ComRemoveAllWindows
69911>>>>>>>>>>>        Handle hDispatchDriver
69911>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69912>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
69913>>>>>>>>>>>    End_Procedure
69914>>>>>>>>>>>
69914>>>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
69916>>>>>>>>>>>        Handle hDispatchDriver
69916>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69917>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
69918>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
69919>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
69920>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
69921>>>>>>>>>>>    End_Procedure
69922>>>>>>>>>>>
69922>>>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
69924>>>>>>>>>>>        Handle hDispatchDriver
69924>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69925>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
69926>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
69927>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
69928>>>>>>>>>>>    End_Procedure
69929>>>>>>>>>>>
69929>>>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
69931>>>>>>>>>>>        Handle hDispatchDriver
69931>>>>>>>>>>>        Variant retVal
69931>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69932>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
69933>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
69934>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
69935>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
69936>>>>>>>>>>>        Function_Return retVal
69937>>>>>>>>>>>    End_Function
69938>>>>>>>>>>>
69938>>>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
69940>>>>>>>>>>>        Handle hDispatchDriver
69940>>>>>>>>>>>        Variant retVal
69940>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69941>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
69942>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
69943>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
69944>>>>>>>>>>>        Function_Return retVal
69945>>>>>>>>>>>    End_Function
69946>>>>>>>>>>>
69946>>>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
69948>>>>>>>>>>>        Handle hDispatchDriver
69948>>>>>>>>>>>        OLE_COLOR retVal
69948>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69949>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
69950>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
69951>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
69952>>>>>>>>>>>        Function_Return retVal
69953>>>>>>>>>>>    End_Function
69954>>>>>>>>>>>
69954>>>>>>>>>>>    Procedure ComExcludeModule String llModuleName
69956>>>>>>>>>>>        Handle hDispatchDriver
69956>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69957>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
69958>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
69959>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
69960>>>>>>>>>>>    End_Procedure
69961>>>>>>>>>>>
69961>>>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
69963>>>>>>>>>>>        Handle hDispatchDriver
69963>>>>>>>>>>>        Variant retVal
69963>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69964>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
69965>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
69966>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
69967>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
69968>>>>>>>>>>>        Function_Return retVal
69969>>>>>>>>>>>    End_Function
69970>>>>>>>>>>>
69970>>>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
69972>>>>>>>>>>>        Handle hDispatchDriver
69972>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69973>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
69974>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
69975>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
69976>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
69977>>>>>>>>>>>    End_Procedure
69978>>>>>>>>>>>
69978>>>>>>>>>>>    Procedure ComAboutBox
69980>>>>>>>>>>>        Handle hDispatchDriver
69980>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
69981>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
69982>>>>>>>>>>>    End_Procedure
69983>>>>>>>>>>>End_Class
69984>>>>>>>>>>>
69984>>>>>>>>>>>// CLSID: {C0DE1830-4463-4030-B324-AC6A8075FEC8}
69984>>>>>>>>>>>// Event interface for SkinFramework Control
69984>>>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
69985>>>>>>>>>>>
69985>>>>>>>>>>>    Procedure RegisterComEvents
69987>>>>>>>>>>>    End_Procedure
69988>>>>>>>>>>>End_Class
69989>>>>>>>>>>>
69989>>>>>>>>>>>// CoClass
69989>>>>>>>>>>>// ProgID: Codejock.SkinFramework.18.3.0
69989>>>>>>>>>>>// CLSID: {C0DE1830-2217-42EE-B1B0-82C890431F17}
69989>>>>>>>>>>>// SkinFramework Control
69989>>>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
69990>>>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
69991>>>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
69992>>>>>>>>>>>
69992>>>>>>>>>>>    Procedure Construct_Object
69994>>>>>>>>>>>        Forward Send Construct_Object
69996>>>>>>>>>>>        Set psProgID to "{C0DE1830-2217-42EE-B1B0-82C890431F17}"
69997>>>>>>>>>>>        Set psEventId to "{C0DE1830-4463-4030-B324-AC6A8075FEC8}"
69998>>>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2018 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v18.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
69999>>>>>>>>>>>        Set peAutoCreate to acAutoCreate
70000>>>>>>>>>>>    End_Procedure
70001>>>>>>>>>>>End_Class
70002>>>>>>>>>>>
70002>>>>>>>>>>>// CLSID: {C0DE1830-CA9A-4AA9-8601-0AB7F551AA3D}
70002>>>>>>>>>>>// SkinFramework Global Settings
70002>>>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
70003>>>>>>>>>>>
70003>>>>>>>>>>>    Function ComLicense Returns String
70005>>>>>>>>>>>        String retVal
70005>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
70006>>>>>>>>>>>        Function_Return retVal
70007>>>>>>>>>>>    End_Function
70008>>>>>>>>>>>
70008>>>>>>>>>>>    Procedure Set ComLicense String value
70010>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
70011>>>>>>>>>>>    End_Procedure
70012>>>>>>>>>>>
70012>>>>>>>>>>>    Function ComTitle Returns String
70014>>>>>>>>>>>        String retVal
70014>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
70015>>>>>>>>>>>        Function_Return retVal
70016>>>>>>>>>>>    End_Function
70017>>>>>>>>>>>
70017>>>>>>>>>>>    Procedure Set ComTitle String value
70019>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
70020>>>>>>>>>>>    End_Procedure
70021>>>>>>>>>>>
70021>>>>>>>>>>>    Function ComVersion Returns String
70023>>>>>>>>>>>        Handle hDispatchDriver
70023>>>>>>>>>>>        String retVal
70023>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70024>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
70025>>>>>>>>>>>        Function_Return retVal
70026>>>>>>>>>>>    End_Function
70027>>>>>>>>>>>
70027>>>>>>>>>>>    Function ComUnicode Returns Boolean
70029>>>>>>>>>>>        Handle hDispatchDriver
70029>>>>>>>>>>>        Boolean retVal
70029>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70030>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
70031>>>>>>>>>>>        Function_Return retVal
70032>>>>>>>>>>>    End_Function
70033>>>>>>>>>>>
70033>>>>>>>>>>>    Function ComOcxPath Returns String
70035>>>>>>>>>>>        Handle hDispatchDriver
70035>>>>>>>>>>>        String retVal
70035>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70036>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
70037>>>>>>>>>>>        Function_Return retVal
70038>>>>>>>>>>>    End_Function
70039>>>>>>>>>>>End_Class
70040>>>>>>>>>>>
70040>>>>>>>>>>>// CoClass
70040>>>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.18.3.0
70040>>>>>>>>>>>// CLSID: {C0DE1830-F744-4373-B38D-29CE83EF0EE5}
70040>>>>>>>>>>>// SkinFramework Global Settings
70040>>>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
70041>>>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
70042>>>>>>>>>>>
70042>>>>>>>>>>>    Procedure Construct_Object
70044>>>>>>>>>>>        Forward Send Construct_Object
70046>>>>>>>>>>>        Set psProgID to "{C0DE1830-F744-4373-B38D-29CE83EF0EE5}"
70047>>>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
70048>>>>>>>>>>>    End_Procedure
70049>>>>>>>>>>>End_Class
70050>>>>>>>>>>>
70050>>>>>>>>>>>// CLSID: {C0DE1830-1038-498E-A936-361F08B4C4AA}
70050>>>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
70051>>>>>>>>>>>
70051>>>>>>>>>>>    Function ComColorScheme Returns String
70053>>>>>>>>>>>        String retVal
70053>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
70054>>>>>>>>>>>        Function_Return retVal
70055>>>>>>>>>>>    End_Function
70056>>>>>>>>>>>
70056>>>>>>>>>>>    Procedure Set ComColorScheme String value
70058>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
70059>>>>>>>>>>>    End_Procedure
70060>>>>>>>>>>>
70060>>>>>>>>>>>    Function ComFontSize Returns String
70062>>>>>>>>>>>        String retVal
70062>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
70063>>>>>>>>>>>        Function_Return retVal
70064>>>>>>>>>>>    End_Function
70065>>>>>>>>>>>
70065>>>>>>>>>>>    Procedure Set ComFontSize String value
70067>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
70068>>>>>>>>>>>    End_Procedure
70069>>>>>>>>>>>
70069>>>>>>>>>>>    Function ComIniFileName Returns String
70071>>>>>>>>>>>        String retVal
70071>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
70072>>>>>>>>>>>        Function_Return retVal
70073>>>>>>>>>>>    End_Function
70074>>>>>>>>>>>
70074>>>>>>>>>>>    Procedure Set ComIniFileName String value
70076>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
70077>>>>>>>>>>>    End_Procedure
70078>>>>>>>>>>>End_Class
70079>>>>>>>>>>>
70079>>>>>>>>>>>// CLSID: {C0DE1830-4834-499E-95B4-30E0C3F43A10}
70079>>>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
70080>>>>>>>>>>>
70080>>>>>>>>>>>    Function ComName Returns String
70082>>>>>>>>>>>        String retVal
70082>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
70083>>>>>>>>>>>        Function_Return retVal
70084>>>>>>>>>>>    End_Function
70085>>>>>>>>>>>
70085>>>>>>>>>>>    Procedure Set ComName String value
70087>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
70088>>>>>>>>>>>    End_Procedure
70089>>>>>>>>>>>
70089>>>>>>>>>>>    Function ComPath Returns String
70091>>>>>>>>>>>        String retVal
70091>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
70092>>>>>>>>>>>        Function_Return retVal
70093>>>>>>>>>>>    End_Function
70094>>>>>>>>>>>
70094>>>>>>>>>>>    Procedure Set ComPath String value
70096>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
70097>>>>>>>>>>>    End_Procedure
70098>>>>>>>>>>>
70098>>>>>>>>>>>    Function ComCount Returns Integer
70100>>>>>>>>>>>        Handle hDispatchDriver
70100>>>>>>>>>>>        Integer retVal
70100>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70101>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
70102>>>>>>>>>>>        Function_Return retVal
70103>>>>>>>>>>>    End_Function
70104>>>>>>>>>>>
70104>>>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
70106>>>>>>>>>>>        Handle hDispatchDriver
70106>>>>>>>>>>>        Variant retVal
70106>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70107>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70108>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70109>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
70110>>>>>>>>>>>        Function_Return retVal
70111>>>>>>>>>>>    End_Function
70112>>>>>>>>>>>
70112>>>>>>>>>>>    Function Com_NewEnum Returns Variant
70114>>>>>>>>>>>        Handle hDispatchDriver
70114>>>>>>>>>>>        Variant retVal
70114>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70115>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
70116>>>>>>>>>>>        Function_Return retVal
70117>>>>>>>>>>>    End_Function
70118>>>>>>>>>>>End_Class
70119>>>>>>>>>>>
70119>>>>>>>>>>>// CLSID: {C0DE1830-FB37-4B08-A2B9-F6F8B253D697}
70119>>>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
70120>>>>>>>>>>>
70120>>>>>>>>>>>    Function ComCount Returns Integer
70122>>>>>>>>>>>        Handle hDispatchDriver
70122>>>>>>>>>>>        Integer retVal
70122>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70123>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
70124>>>>>>>>>>>        Function_Return retVal
70125>>>>>>>>>>>    End_Function
70126>>>>>>>>>>>
70126>>>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
70128>>>>>>>>>>>        Handle hDispatchDriver
70128>>>>>>>>>>>        Variant retVal
70128>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70129>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70130>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70131>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
70132>>>>>>>>>>>        Function_Return retVal
70133>>>>>>>>>>>    End_Function
70134>>>>>>>>>>>
70134>>>>>>>>>>>    Function Com_NewEnum Returns Variant
70136>>>>>>>>>>>        Handle hDispatchDriver
70136>>>>>>>>>>>        Variant retVal
70136>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70137>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
70138>>>>>>>>>>>        Function_Return retVal
70139>>>>>>>>>>>    End_Function
70140>>>>>>>>>>>End_Class
70141>>>>>>>>>>>
70141>>>>>>>>>>>// CLSID: {C0DE1830-C56F-43C0-BCF1-8193B35FE4C4}
70141>>>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
70142>>>>>>>>>>>
70142>>>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
70144>>>>>>>>>>>        Handle hDispatchDriver
70144>>>>>>>>>>>        OLE_COLOR retVal
70144>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
70145>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
70146>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
70147>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
70148>>>>>>>>>>>        Function_Return retVal
70149>>>>>>>>>>>    End_Function
70150>>>>>>>>>>>End_Class
70151>>>>>>>>>Use cApplication.pkg
70151>>>>>>>>>
70151>>>>>>>>>Struct tSkinInformation
70151>>>>>>>>>    String sName     // description of the skin
70151>>>>>>>>>    String sSkinfile // file path. Can be relative or full
70151>>>>>>>>>    String sSkinIni  // section name
70151>>>>>>>>>End_Struct
70151>>>>>>>>>
70151>>>>>>>>>
70151>>>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
70152>>>>>>>>>    
70152>>>>>>>>>    Procedure Construct_Object
70154>>>>>>>>>        Forward Send Construct_Object
70156>>>>>>>>>        
70156>>>>>>>>>        Property String psSkinFile ""
70157>>>>>>>>>        Property String psSkinIni ""
70158>>>>>>>>>        Property Boolean pbLoadPreference False
70159>>>>>>>>>        
70159>>>>>>>>>        Set peAutoCreate to acAutoCreate
70160>>>>>>>>>        
70160>>>>>>>>>        Move Self to ghoSkinFramework
70161>>>>>>>>>    End_Procedure
70162>>>>>>>>>    
70162>>>>>>>>>    // return the default skin path, which is the programs directory.
70162>>>>>>>>>    // This requires an application object.
70162>>>>>>>>>    // If you want to different skin path, override this.
70162>>>>>>>>>    Function SkinPath Returns String
70164>>>>>>>>>        String sPath sPaths
70164>>>>>>>>>        Handle hoWorkspace
70164>>>>>>>>>        If ghoApplication Begin
70166>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
70167>>>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
70168>>>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
70169>>>>>>>>>        End
70169>>>>>>>>>>
70169>>>>>>>>>        Else Begin
70170>>>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
70171>>>>>>>>>>
70171>>>>>>>>>        End
70171>>>>>>>>>>
70171>>>>>>>>>        Function_Return sPath
70172>>>>>>>>>    End_Function
70173>>>>>>>>>    
70173>>>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
70173>>>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
70173>>>>>>>>>    Function SkinQFile Returns String
70175>>>>>>>>>        String sFile sPath sSep
70175>>>>>>>>>        Boolean bQualified
70175>>>>>>>>>        Get psSkinFile to sFile
70176>>>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
70178>>>>>>>>>            Get SkinPath to sPath
70179>>>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
70180>>>>>>>>>            Move (sPath - sSep - sFile) to sFile
70181>>>>>>>>>        End
70181>>>>>>>>>>
70181>>>>>>>>>        Function_Return sFile
70182>>>>>>>>>    End_Function
70183>>>>>>>>>    
70183>>>>>>>>>    // defines the default VDF window class mapping.
70183>>>>>>>>>    Procedure OnAddVDFWindowClasses
70185>>>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
70186>>>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
70187>>>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
70188>>>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
70189>>>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
70190>>>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
70191>>>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
70192>>>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
70193>>>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
70194>>>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
70195>>>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
70196>>>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
70197>>>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
70198>>>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
70199>>>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
70200>>>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
70201>>>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
70202>>>>>>>>>        // External class
70202>>>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
70203>>>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
70204>>>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
70205>>>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
70206>>>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
70207>>>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
70208>>>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
70209>>>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
70210>>>>>>>>>    End_Procedure
70211>>>>>>>>>    
70211>>>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
70211>>>>>>>>>    Procedure OnAddCustomWindowClasses
70213>>>>>>>>>    End_Procedure
70214>>>>>>>>>    
70214>>>>>>>>>    // called when object is created during end_construct_object.
70214>>>>>>>>>    Procedure OnCreate
70216>>>>>>>>>        Integer iOpts
70216>>>>>>>>>        Boolean bUseWindowsFont
70216>>>>>>>>>        Forward Send OnCreate
70218>>>>>>>>>        
70218>>>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
70218>>>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
70218>>>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
70219>>>>>>>>>        If bUseWindowsFont Begin
70221>>>>>>>>>            Get ComApplyOptions to iOpts
70222>>>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
70223>>>>>>>>>        End
70223>>>>>>>>>>
70223>>>>>>>>>        
70223>>>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
70223>>>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
70223>>>>>>>>>        // and this was the suggested workaround.
70223>>>>>>>>>        Set ComAutoApplyNewThreads to False
70224>>>>>>>>>        
70224>>>>>>>>>        Send OnAddVDFWindowClasses
70225>>>>>>>>>        Send OnAddCustomWindowClasses
70226>>>>>>>>>        
70226>>>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
70226>>>>>>>>>        If (pbLoadPreference(Self)) Begin
70228>>>>>>>>>            Send LoadSkinPreference
70229>>>>>>>>>        End
70229>>>>>>>>>>
70229>>>>>>>>>        // if a skin file name exists, we apply the skin.
70229>>>>>>>>>        If (psSkinFile(Self)<>"") Begin
70231>>>>>>>>>            Send ApplySkin
70232>>>>>>>>>        End
70232>>>>>>>>>>
70232>>>>>>>>>    End_Procedure
70233>>>>>>>>>    
70233>>>>>>>>>    // called by framework as part of application exit.
70233>>>>>>>>>    Procedure Broadcast_Notify_Exit_Application
70235>>>>>>>>>        Send Notify_Exit_Application
70236>>>>>>>>>    End_Procedure
70237>>>>>>>>>    
70237>>>>>>>>>    Procedure Notify_Exit_Application
70239>>>>>>>>>        If (pbLoadPreference(Self)) Begin
70241>>>>>>>>>            Send SaveSkinPreference
70242>>>>>>>>>        End
70242>>>>>>>>>>
70242>>>>>>>>>    End_Procedure
70243>>>>>>>>>    
70243>>>>>>>>>    Procedure NotifyPreApplySkin
70245>>>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
70247>>>>>>>>>    End_Procedure
70248>>>>>>>>>    
70248>>>>>>>>>    Procedure NotifyPostApplySkin
70250>>>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
70252>>>>>>>>>    End_Procedure
70253>>>>>>>>>    
70253>>>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
70253>>>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
70253>>>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
70255>>>>>>>>>        tSkinInformation[] Skins
70255>>>>>>>>>        tSkinInformation[] Skins
70256>>>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
70256>>>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
70256>>>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
70256>>>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
70256>>>>>>>>>        Integer iPos iDfltLen
70256>>>>>>>>>        Boolean bUseRelativePath
70256>>>>>>>>>        
70256>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
70257>>>>>>>>>        
70257>>>>>>>>>        Get SkinPath to sDefaultPath
70258>>>>>>>>>        If (sPath="") Begin
70260>>>>>>>>>            Move sDefaultPath to sPath
70261>>>>>>>>>        End
70261>>>>>>>>>>
70261>>>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
70262>>>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
70263>>>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
70264>>>>>>>>>        
70264>>>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
70265>>>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
70267>>>>>>>>>            
70267>>>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
70268>>>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
70269>>>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
70270>>>>>>>>>            
70270>>>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
70271>>>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
70272>>>>>>>>>            
70272>>>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
70278>>>>>>>>>>
70278>>>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
70279>>>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
70280>>>>>>>>>                
70280>>>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
70281>>>>>>>>>                
70281>>>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
70287>>>>>>>>>>
70287>>>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
70288>>>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
70289>>>>>>>>>                    
70289>>>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
70290>>>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
70291>>>>>>>>>                    If bUseRelativePath Begin
70293>>>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
70294>>>>>>>>>                        If iPos Begin
70296>>>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
70297>>>>>>>>>                            While (Left(sSkinFile,1)=sSep)
70301>>>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
70302>>>>>>>>>                            Loop
70303>>>>>>>>>>
70303>>>>>>>>>                        End
70303>>>>>>>>>>
70303>>>>>>>>>                    End
70303>>>>>>>>>>
70303>>>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
70304>>>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
70305>>>>>>>>>                    
70305>>>>>>>>>                    Increment iArrayItem
70306>>>>>>>>>                Loop
70307>>>>>>>>>>
70307>>>>>>>>>            Loop
70308>>>>>>>>>>
70308>>>>>>>>>            
70308>>>>>>>>>            Send Destroy of hSkinDescriptions
70309>>>>>>>>>            Send Destroy of hSkinDescription
70310>>>>>>>>>            Send Destroy of hSkinIniFile
70311>>>>>>>>>            
70311>>>>>>>>>        End
70311>>>>>>>>>>
70311>>>>>>>>>        Function_Return Skins
70312>>>>>>>>>    End_Function
70313>>>>>>>>>    
70313>>>>>>>>>    // Save the skin preference. This requires an application object.
70313>>>>>>>>>    // Only do this if the application object allows it.
70313>>>>>>>>>    // This is called during startup if pbLoadPreference is True
70313>>>>>>>>>    // Suitable for override
70313>>>>>>>>>    Procedure SaveSkinPreference
70315>>>>>>>>>        String sSkin sIni
70315>>>>>>>>>        If ghoApplication Begin
70317>>>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
70319>>>>>>>>>                Get psSkinFile to sSkin
70320>>>>>>>>>                Get psSkinIni to sIni
70321>>>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
70322>>>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
70323>>>>>>>>>            End
70323>>>>>>>>>>
70323>>>>>>>>>        End
70323>>>>>>>>>>
70323>>>>>>>>>        Else Begin
70324>>>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
70325>>>>>>>>>>
70325>>>>>>>>>        End
70325>>>>>>>>>>
70325>>>>>>>>>    End_Procedure
70326>>>>>>>>>    
70326>>>>>>>>>    // Load the skin preference. This requires an application object.
70326>>>>>>>>>    // Only do this if the application object allows it.
70326>>>>>>>>>    // This is called during startup if pbLoadPreference is True
70326>>>>>>>>>    // Suitable for override
70326>>>>>>>>>    Procedure LoadSkinPreference
70328>>>>>>>>>        String sSkin sIni
70328>>>>>>>>>        Boolean bExists
70328>>>>>>>>>        If ghoApplication Begin
70330>>>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
70332>>>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
70333>>>>>>>>>                If bExists Begin
70335>>>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
70336>>>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
70337>>>>>>>>>                    Set psSkinFile to sSkin
70338>>>>>>>>>                    Set psSkinIni to sIni
70339>>>>>>>>>                End
70339>>>>>>>>>>
70339>>>>>>>>>            End
70339>>>>>>>>>>
70339>>>>>>>>>        End
70339>>>>>>>>>>
70339>>>>>>>>>        Else Begin
70340>>>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
70341>>>>>>>>>>
70341>>>>>>>>>        End
70341>>>>>>>>>>
70341>>>>>>>>>    End_Procedure
70342>>>>>>>>>    
70342>>>>>>>>>    // Can be called to apply the current skin.
70342>>>>>>>>>    Procedure ApplySkin
70344>>>>>>>>>        Boolean bOk
70344>>>>>>>>>        String sSkin sIni
70344>>>>>>>>>        If (IsComObjectCreated(Self)) Begin
70346>>>>>>>>>            Get SkinQFile to sSkin
70347>>>>>>>>>            Get psSkinIni to sIni
70348>>>>>>>>>            
70348>>>>>>>>>            Send NotifyPreApplySkin
70349>>>>>>>>>            // when skins are used we don't want to use built in Visual Styles
70349>>>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
70350>>>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
70351>>>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
70353>>>>>>>>>                // if not ok, no skin was appied. Enable visual styles
70353>>>>>>>>>                Send EnableVisualStyles of Desktop True
70354>>>>>>>>>            End
70354>>>>>>>>>>
70354>>>>>>>>>            Send NotifyPostApplySkin
70355>>>>>>>>>        End
70355>>>>>>>>>>
70355>>>>>>>>>    End_Procedure
70356>>>>>>>>>    
70356>>>>>>>>>    
70356>>>>>>>>>End_Class
70357>>>>>>>
70357>>>>>>>Class cRDCModalPanel is a ModalPanel
70358>>>>>>>
70358>>>>>>>    Procedure Construct_Object
70360>>>>>>>        Forward Send Construct_Object
70362>>>>>>>
70362>>>>>>>        Set Maximize_Icon to True
70363>>>>>>>        Set Minimize_Icon to False
70364>>>>>>>        Set Border_Style to Border_Thick
70365>>>>>>>        Set Locate_Mode to Center_On_Parent
70366>>>>>>>
70366>>>>>>>        Property String Private_Icon
70367>>>>>>>        Property Handle phoDialogCommandbar
70368>>>>>>>    End_Procedure
70369>>>>>>>
70369>>>>>>>    Procedure Set Icon String sIcon
70371>>>>>>>        Forward Set Icon to sIcon
70373>>>>>>>        Set Private_Icon to sIcon
70374>>>>>>>    End_Procedure
70375>>>>>>>
70375>>>>>>>    Function Icon Returns String
70377>>>>>>>        String sIcon
70377>>>>>>>        Get Private_Icon to sIcon
70378>>>>>>>        Function_Return sIcon
70379>>>>>>>    End_Function
70380>>>>>>>
70380>>>>>>>    Procedure Page Integer iPageObject
70382>>>>>>>        String sIcon
70382>>>>>>>        Integer hWnd
70382>>>>>>>        
70382>>>>>>>        Forward Send Page iPageObject
70384>>>>>>>        Get Private_Icon to sIcon
70385>>>>>>>        If (sIcon <> "") Begin
70387>>>>>>>            Set Icon to sIcon
70388>>>>>>>        End
70388>>>>>>>>
70388>>>>>>>
70388>>>>>>>        Get Window_Handle to hWnd
70389>>>>>>>
70389>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
70391>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
70392>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
70393>>>>>>>        End
70393>>>>>>>>
70393>>>>>>>    End_Procedure
70394>>>>>>>
70394>>>>>>>    // Put a status bar at the bottom of the panel, which makes
70394>>>>>>>    // status_help work and puts a gripper in the lower right corner.
70394>>>>>>>    Procedure End_Construct_Object
70396>>>>>>>        Integer iStyle iSize iOffset
70396>>>>>>>
70396>>>>>>>        Forward Send End_Construct_Object
70398>>>>>>>
70398>>>>>>>        Get Border_Style to iStyle
70399>>>>>>>        Move 8 to iOffset
70400>>>>>>>        If (iStyle = Border_Thick) Begin
70402>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
70404>>>>>>>                Object oStatusBar is a cCJStatusBar
70406>>>>>>>                    Set phoDialogCommandbar to Self
70407>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
70409>>>>>>>                        Set piId to sbpIDIdlePane
70410>>>>>>>                        Set pbStyleStretch to True
70411>>>>>>>                    End_Object
70412>>>>>>>                End_Object
70413>>>>>>>            End_Object
70414>>>>>>>            Get Size to iSize
70415>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
70416>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
70417>>>>>>>        End
70417>>>>>>>>
70417>>>>>>>
70417>>>>>>>    End_Procedure
70418>>>>>>>
70418>>>>>>>    Procedure Popup
70420>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
70421>>>>>>>        Forward Send Popup
70423>>>>>>>    End_Procedure
70424>>>>>>>
70424>>>>>>>End_Class
70425>>>>>Use cRDCCJSelectionGrid.pkg
Including file: cRDCCJSelectionGrid.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCCJSelectionGrid.pkg)
70425>>>>>>>//****************************************************************************
70425>>>>>>>// $Module type: Package
70425>>>>>>>// $Module name: cRDCCJSelectionGrid.pkg
70425>>>>>>>//
70425>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
70425>>>>>>>// Copyright (c) 2018 RDC Tools International
70425>>>>>>>// E-mail      : support@rdctools.com
70425>>>>>>>// Web-site    : http://www.rdctools.com
70425>>>>>>>//
70425>>>>>>>// Created     : 2018-12-17 @ 08:04 (Military date format - Year-Month-Day)
70425>>>>>>>//
70425>>>>>>>// Note        : Grid class that uses a checkbox column for selecting items.
70425>>>>>>>//
70425>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70425>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70425>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70425>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70425>>>>>>>// in the help folder for more details.
70425>>>>>>>//
70425>>>>>>>//****************************************************************************
70425>>>>>>>Use cCJGrid.pkg
70425>>>>>>>Use cCJGridColumn.pkg
70425>>>>>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridColumnRowIndicator.pkg)
70425>>>>>>>>>Use cCJGridColumn.pkg
70425>>>>>>>>>
70425>>>>>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
70426>>>>>>>>>    
70426>>>>>>>>>    Procedure Construct_Object
70428>>>>>>>>>        Forward Send Construct_Object
70430>>>>>>>>>        
70430>>>>>>>>>        Property Integer piImage 0
70431>>>>>>>>>        
70431>>>>>>>>>        Set psCaption to ""
70432>>>>>>>>>        Set piWidth to 20
70433>>>>>>>>>        Set pbResizable to False
70434>>>>>>>>>        Set pbEditable to False
70435>>>>>>>>>        Set pbFocusable to False
70436>>>>>>>>>        Set pbAllowDrag to False
70437>>>>>>>>>        Set psToolTip to "Row Indicator"
70438>>>>>>>>>    End_Procedure
70439>>>>>>>>>    
70439>>>>>>>>>    Procedure OnCreateColumn
70441>>>>>>>>>        Integer iImage
70441>>>>>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
70443>>>>>>>>>        Set piImage to iImage
70444>>>>>>>>>    End_Procedure
70445>>>>>>>>>    
70445>>>>>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
70447>>>>>>>>>        Integer iImage iFocusedRow
70447>>>>>>>>>        Handle hoDataSource
70447>>>>>>>>>        
70447>>>>>>>>>        Get phoDataSource to hoDataSource
70448>>>>>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
70449>>>>>>>>>        Move -1 to iImage
70450>>>>>>>>>        If (iRow = iFocusedRow) Begin
70452>>>>>>>>>            Get piImage to iImage
70453>>>>>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
70454>>>>>>>>>        End
70454>>>>>>>>>>
70454>>>>>>>>>    End_Procedure
70455>>>>>>>>>    
70455>>>>>>>>>End_Class
70456>>>>>>>Use Cursor.pkg
70456>>>>>>>Use vWin32fh.pkg
70456>>>>>>>
70456>>>>>>>
70456>>>>>>>
70456>>>>>>>Enum_List
70456>>>>>>>    Define cx_Select_All
70456>>>>>>>    Define cx_Select_None
70456>>>>>>>    Define cx_Select_Invert
70456>>>>>>>End_Enum_List
70456>>>>>>>
70456>>>>>>>// Classes used by the cRDCCJSelectionGrid
70456>>>>>>>Class cRDCCJToggleSelectMenuItem is a cCJMenuItem
70457>>>>>>>
70457>>>>>>>    Procedure Construct_Object
70459>>>>>>>        Forward Send Construct_Object
70461>>>>>>>        Set psCaption to "Toggle Current Item"
70462>>>>>>>        Set psImage to "ToggleOn.ico"
70463>>>>>>>        Set psShortcut to "Space-Bar"
70464>>>>>>>    End_Procedure
70465>>>>>>>
70465>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70467>>>>>>>        Forward Send OnExecute vCommandBarControl
70469>>>>>>>        Send ToggleCurrentItem
70470>>>>>>>    End_Procedure
70471>>>>>>>
70471>>>>>>>End_Class
70472>>>>>>>
70472>>>>>>>Class cRDCCJSelectAllMenuItem is a cCJMenuItem
70473>>>>>>>
70473>>>>>>>    Procedure Construct_Object
70475>>>>>>>        Forward Send Construct_Object
70477>>>>>>>        Set pbControlBeginGroup to True
70478>>>>>>>        Set psCaption to "Select All"
70479>>>>>>>        Set psImage to "SelectAll.ico"
70480>>>>>>>        Set psShortcut to "Ctrl+A"
70481>>>>>>>    End_Procedure
70482>>>>>>>
70482>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70484>>>>>>>        Forward Send OnExecute vCommandBarControl
70486>>>>>>>        Set SelectItems to cx_Select_All
70487>>>>>>>    End_Procedure
70488>>>>>>>
70488>>>>>>>End_Class
70489>>>>>>>
70489>>>>>>>Class cRDCCJDeSelectAllMenuItem is a cCJMenuItem
70490>>>>>>>
70490>>>>>>>    Procedure Construct_Object
70492>>>>>>>        Forward Send Construct_Object
70494>>>>>>>        Set psCaption to "Select None"
70495>>>>>>>        Set psImage to "SelectNone.ico"
70496>>>>>>>        Set psShortcut to "Ctrl+N"
70497>>>>>>>    End_Procedure
70498>>>>>>>
70498>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70500>>>>>>>        Forward Send OnExecute vCommandBarControl
70502>>>>>>>        Set SelectItems to cx_Select_None
70503>>>>>>>    End_Procedure
70504>>>>>>>
70504>>>>>>>End_Class
70505>>>>>>>
70505>>>>>>>Class cRDCCJInvertSelectionsMenuItem is a cCJMenuItem
70506>>>>>>>
70506>>>>>>>    Procedure Construct_Object
70508>>>>>>>        Forward Send Construct_Object
70510>>>>>>>        Set psCaption to "Invert Selection"
70511>>>>>>>        Set psImage to "SelectInvert.ico"
70512>>>>>>>        Set psShortcut to "Ctrl+I"
70513>>>>>>>    End_Procedure
70514>>>>>>>
70514>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70516>>>>>>>        Forward Send OnExecute vCommandBarControl
70518>>>>>>>        Set SelectItems to cx_Select_Invert
70519>>>>>>>    End_Procedure
70520>>>>>>>
70520>>>>>>>End_Class
70521>>>>>>>
70521>>>>>>>Class cRDCCJAddFolderMenuItem is a cCJMenuItem
70522>>>>>>>
70522>>>>>>>    Procedure Construct_Object
70524>>>>>>>        Forward Send Construct_Object
70526>>>>>>>        Set psCaption to "Add Folder"
70527>>>>>>>        Set psImage to "AddFolder.ico"
70528>>>>>>>        Set psShortcut to "Ins"
70529>>>>>>>    End_Procedure
70530>>>>>>>
70530>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70532>>>>>>>        Forward Send OnExecute vCommandBarControl
70534>>>>>>>        Send BrowseForFolder
70535>>>>>>>    End_Procedure
70536>>>>>>>
70536>>>>>>>End_Class
70537>>>>>>>
70537>>>>>>>Class cRDCCJRemoveItemMenuItem is a cCJMenuItem
70538>>>>>>>
70538>>>>>>>    Procedure Construct_Object
70540>>>>>>>        Forward Send Construct_Object
70542>>>>>>>        Set psCaption to "Remove From Grid"
70543>>>>>>>        Set psImage to "ActionDelete.ico"
70544>>>>>>>        Set psShortcut to "Del"
70545>>>>>>>    End_Procedure
70546>>>>>>>
70546>>>>>>>    Procedure OnExecute Variant vCommandBarControl
70548>>>>>>>        Forward Send OnExecute vCommandBarControl
70550>>>>>>>        Send Request_Delete
70551>>>>>>>    End_Procedure
70552>>>>>>>
70552>>>>>>>End_Class
70553>>>>>>>
70553>>>>>>>Register_Function pbShowAddFolderMenuItem Returns Boolean
70553>>>>>>>Register_Function pbShowRemoveFolderMenuItem Returns Boolean
70553>>>>>>>Register_Function pbShowInvertSelectionsMenuItem Returns Boolean
70553>>>>>>>
70553>>>>>>>Class cGridContext_mnu is a cCJContextMenu
70554>>>>>>>    Procedure Construct_Object
70556>>>>>>>        Handle hoMenuItem
70556>>>>>>>        Forward Send Construct_Object
70558>>>>>>>
70558>>>>>>>        Get Create (RefClass(cRDCCJToggleSelectMenuItem))      to hoMenuItem
70559>>>>>>>        Get Create (RefClass(cRDCCJSelectAllMenuItem))         to hoMenuItem
70560>>>>>>>        Get Create (RefClass(cRDCCJDeSelectAllMenuItem))       to hoMenuItem
70561>>>>>>>        If (pbShowInvertSelectionsMenuItem(Self) = True) Begin
70563>>>>>>>            Get Create (RefClass(cRDCCJInvertSelectionsMenuItem))  to hoMenuItem
70564>>>>>>>        End
70564>>>>>>>>
70564>>>>>>>        If (pbShowAddFolderMenuItem(Self) = True) Begin
70566>>>>>>>            Get Create (RefClass(cRDCCJAddFolderMenuItem))  to hoMenuItem
70567>>>>>>>            Set pbControlBeginGroup of hoMenuItem to True
70568>>>>>>>        End
70568>>>>>>>>
70568>>>>>>>        If (pbShowRemoveFolderMenuItem(Self) = True) Begin
70570>>>>>>>            Get Create (RefClass(cRDCCJRemoveItemMenuItem))  to hoMenuItem
70571>>>>>>>            If (pbShowAddFolderMenuItem(Self) = False) Begin
70573>>>>>>>                Set pbControlBeginGroup of hoMenuItem to True
70574>>>>>>>            End
70574>>>>>>>>
70574>>>>>>>        End
70574>>>>>>>>
70574>>>>>>>    End_Procedure
70575>>>>>>>
70575>>>>>>>End_Class
70576>>>>>>>
70576>>>>>>>Class cRDCCJSelectionGrid is a cCJGrid
70577>>>>>>>
70577>>>>>>>    Procedure Construct_Object
70579>>>>>>>        Forward Send Construct_Object
70581>>>>>>>
70581>>>>>>>        // This must be set manually in the grid column object for the 'data' column (or one of them):
70581>>>>>>>        Property Handle phoData_Col 0
70582>>>>>>>        Property Handle phoCheckbox_Col 0
70583>>>>>>>
70583>>>>>>>        Property Boolean pbShowAddFolderMenuItem False
70584>>>>>>>        Property Boolean pbShowRemoveFolderMenuItem False   
70585>>>>>>>        Property Boolean pbShowInvertSelectionsMenuItem True
70586>>>>>>>        Property Boolean pbEnableMoveKeys False
70587>>>>>>>
70587>>>>>>>        Set pbRestoreLayout to True
70588>>>>>>>        Set psLayoutSection to (Name(Self) + "_grid")
70589>>>>>>>        Set psNoItemsText to "No data found..."
70590>>>>>>>        Set pbHeaderReorders to True
70591>>>>>>>        Set pbHeaderPrompts to False
70592>>>>>>>        Set pbHeaderTogglesDirection to True
70593>>>>>>>        Set pbSelectionEnable to True
70594>>>>>>>        Set pbAllowInsertRow to False
70595>>>>>>>        Set pbAllowAppendRow to False
70596>>>>>>>        Set pbShowRowFocus to True
70597>>>>>>>        Set pbShowFooter to True
70598>>>>>>>        Set pbMultipleSelection to True
70599>>>>>>>        Set pbHotTracking to True
70600>>>>>>>        Set pbEditOnClick to True
70601>>>>>>>        Set piLayoutBuild to 4
70602>>>>>>>        Set Status_Help to "Select with the spacebar"
70603>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
70604>>>>>>>        Set peAnchors to anAll
70605>>>>>>>        // This makes the ticked checkboxes to appear as bold.
70605>>>>>>>        Set peVisualTheme to xtpReportThemeVisualStudio2012Light
70606>>>>>>>
70606>>>>>>>        On_Key Key_Space      Send ToggleCurrentItem
70607>>>>>>>        On_Key Key_Delete     Send Request_Delete
70608>>>>>>>        On_Key Key_Insert     Send BrowseForFolder
70609>>>>>>>        On_Key Key_Ctrl+Key_A Send SelectAll
70610>>>>>>>        On_Key Key_Ctrl+Key_N Send SelectNone
70611>>>>>>>        On_Key Key_Ctrl+Key_I Send SelectInvert
70612>>>>>>>        On_Key kCancel        Send CancelIfPopupObject
70613>>>>>>>        On_Key Key_Alt+Key_Down_Arrow Send MoveDown
70614>>>>>>>        On_Key Key_Alt+Key_Up_Arrow   Send MoveUp
70615>>>>>>>    End_Procedure
70616>>>>>>>
70616>>>>>>>    Procedure MoveUp
70618>>>>>>>        tDataSourceRow[] TheData
70618>>>>>>>        tDataSourceRow[] TheData
70619>>>>>>>        tDataSourceRow TheRow
70619>>>>>>>        tDataSourceRow TheRow
70619>>>>>>>        Handle hDataSource
70619>>>>>>>        Integer iCurrentRow
70619>>>>>>>
70619>>>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
70621>>>>>>>            Procedure_Return
70622>>>>>>>        End
70622>>>>>>>>
70622>>>>>>>        Get phoDataSource to hDataSource
70623>>>>>>>        Get DataSource of hDataSource to TheData
70624>>>>>>>        Get SelectedRow of hDataSource to iCurrentRow
70625>>>>>>>        If (iCurrentRow > 0) Begin
70627>>>>>>>            Move TheData[iCurrentRow - 1] to TheRow
70628>>>>>>>            Move TheData[iCurrentRow] to TheData[iCurrentRow - 1]
70629>>>>>>>            Move TheRow to TheData[iCurrentRow]
70630>>>>>>>            Send ReInitializeData TheData True
70631>>>>>>>            Send MoveToRow (iCurrentRow - 1)
70632>>>>>>>        End
70632>>>>>>>>
70632>>>>>>>    End_Procedure
70633>>>>>>>
70633>>>>>>>    Procedure MoveDown
70635>>>>>>>        tDataSourceRow[] TheData
70635>>>>>>>        tDataSourceRow[] TheData
70636>>>>>>>        tDataSourceRow TheRow
70636>>>>>>>        tDataSourceRow TheRow
70636>>>>>>>        Handle hDataSource
70636>>>>>>>        Integer iCurrentRow
70636>>>>>>>
70636>>>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
70638>>>>>>>            Procedure_Return
70639>>>>>>>        End
70639>>>>>>>>
70639>>>>>>>        Get phoDataSource to hDataSource
70640>>>>>>>        Get DataSource of hDataSource to TheData
70641>>>>>>>        Get SelectedRow of hDataSource to iCurrentRow
70642>>>>>>>        If ((iCurrentRow + 1) < SizeOfArray(TheData)) Begin
70644>>>>>>>            Move TheData[iCurrentRow] to TheRow
70645>>>>>>>            Move TheData[iCurrentRow + 1] to TheData[iCurrentRow]
70646>>>>>>>            Move TheRow to TheData[iCurrentRow + 1]
70647>>>>>>>            Send ReInitializeData TheData True
70648>>>>>>>            Send MoveToRow (iCurrentRow + 1)
70649>>>>>>>        End
70649>>>>>>>>
70649>>>>>>>    End_Procedure
70650>>>>>>>
70650>>>>>>>    Procedure RefreshSelectionUpdate
70652>>>>>>>    End_Procedure                   
70653>>>>>>>    
70653>>>>>>>    Procedure CancelIfPopupObject
70655>>>>>>>        Boolean bIsInPopupObject
70655>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
70657>>>>>>>        If (bIsInPopupObject = True) Begin
70659>>>>>>>            Send Close_Panel
70660>>>>>>>        End
70660>>>>>>>>
70660>>>>>>>    End_Procedure
70661>>>>>>>
70661>>>>>>>    Procedure End_Construct_Object
70663>>>>>>>        String sColor
70663>>>>>>>        Handle hoContextMenu
70663>>>>>>>        Forward Send End_Construct_Object
70665>>>>>>>
70665>>>>>>>        Object oCheckbox_col is a cCJGridColumn
70667>>>>>>>            Set phoCheckbox_Col to Self
70668>>>>>>>            Set piWidth to 60
70669>>>>>>>            Set pbResizable to False
70670>>>>>>>            Set psCaption to "Select"
70671>>>>>>>            Set psToolTip to "Select an item by using the space bar or click with the mouse."
70672>>>>>>>            Set pbCheckbox to True
70673>>>>>>>            Set peHeaderAlignment to xtpAlignmentCenter
70674>>>>>>>            Set peFooterAlignment to xtpAlignmentCenter
70675>>>>>>>            Set peDataType to Mask_Numeric_Window
70676>>>>>>>        End_Object
70677>>>>>>>
70677>>>>>>>        If (ghoApplication <> 0) Begin
70679>>>>>>>            Get ReadString of ghoApplication CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
70680>>>>>>>        End
70680>>>>>>>>
70680>>>>>>>        If (sColor = "clBlueGreyLight") Begin
70682>>>>>>>            Move "clGreenGrey" to sColor
70683>>>>>>>        End
70683>>>>>>>>
70683>>>>>>>        Set piSelectedRowBackColor to sColor
70684>>>>>>>        Set piHighlightBackColor   to sColor
70685>>>>>>>
70685>>>>>>>        Get Create (RefClass(cGridContext_mnu)) to hoContextMenu
70686>>>>>>>        Set phoContextMenu to hoContextMenu
70687>>>>>>>    End_Procedure
70688>>>>>>>
70688>>>>>>>    Procedure OnCreateGridControl
70690>>>>>>>        Handle hoObject
70690>>>>>>>        Integer iToolTipStyle
70690>>>>>>>        Boolean bIsBalloonStyleSupported
70690>>>>>>>
70690>>>>>>>        Forward Send OnCreateGridControl
70692>>>>>>>
70692>>>>>>>        Get phoToolTipContext to hoObject
70693>>>>>>>        If (hoObject <> 0) Begin
70695>>>>>>>            Move xtpToolTipStandard to iToolTipStyle
70696>>>>>>>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
70696>>>>>>>            // The ComShowTitleAndDescription also requires IE 5.0.
70696>>>>>>>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
70697>>>>>>>            If (bIsBalloonStyleSupported = True) Begin
70699>>>>>>>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
70700>>>>>>>            End
70700>>>>>>>>
70700>>>>>>>            Set ComStyle             of hoObject to iToolTipStyle
70701>>>>>>>            Set ComShowOfficeBorder  of hoObject to True
70702>>>>>>>            Set ComShowShadow        of hoObject to True
70703>>>>>>>            // Set the max width for a tooltip. 250 just seems to be a good
70703>>>>>>>            // compromise. After 250 pixels the text will wrap to the next line automatically.
70703>>>>>>>            Set ComMaxTipWidth       of hoObject to 250 // In pixels
70704>>>>>>>        End
70704>>>>>>>>
70704>>>>>>>        Send DoChangeFontSize
70705>>>>>>>    End_Procedure
70706>>>>>>>
70706>>>>>>>    Procedure AddItem String sDataValue
70708>>>>>>>        Handle hoDataSource
70708>>>>>>>        tDataSourceRow[] TheData
70708>>>>>>>        tDataSourceRow[] TheData
70709>>>>>>>        tsSearchResult[] asFolderArray
70709>>>>>>>        tsSearchResult[] asFolderArray
70710>>>>>>>        Integer iSize iData_Col iCheckbox_Col
70710>>>>>>>
70710>>>>>>>        If (not(IsComObjectCreated(Self))) Begin
70712>>>>>>>            Procedure_Return
70713>>>>>>>        End
70713>>>>>>>>
70713>>>>>>>
70713>>>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
70714>>>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
70715>>>>>>>        Get phoDataSource to hoDataSource
70716>>>>>>>        Get DataSource of hoDataSource to TheData
70717>>>>>>>        Move (SizeOfArray(TheData)) to iSize
70718>>>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
70719>>>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
70720>>>>>>>
70720>>>>>>>        Send ReInitializeData TheData False
70721>>>>>>>        Send MoveToLastRow
70722>>>>>>>    End_Procedure
70723>>>>>>>
70723>>>>>>>    Procedure BrowseForFolder
70725>>>>>>>        String sFolderName
70725>>>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
70726>>>>>>>        If (sFolderName <> "") Begin
70728>>>>>>>            Send AddItem sFolderName
70729>>>>>>>        End
70729>>>>>>>>
70729>>>>>>>    End_Procedure
70730>>>>>>>
70730>>>>>>>    // We don't want columns to be editable. But setting
70730>>>>>>>    // pbEditable = False or pbReadOnly makes it very hard to read,
70730>>>>>>>    // and makes it impossible to select the checkbox column with the mouse.
70730>>>>>>>    // So we disable those columns instead.
70730>>>>>>>    Function CanEditColumn Integer iCol Returns Boolean
70732>>>>>>>        Handle hoCol
70732>>>>>>>        Boolean bRetval
70732>>>>>>>
70732>>>>>>>        Forward Get CanEditColumn iCol to bRetval
70734>>>>>>>
70734>>>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to hoCol
70735>>>>>>>        If (iCol <> hoCol) Begin
70737>>>>>>>            Move False to bRetval
70738>>>>>>>        End
70738>>>>>>>>
70738>>>>>>>        Else Begin
70739>>>>>>>            Move True to bRetval
70740>>>>>>>        End
70740>>>>>>>>
70740>>>>>>>
70740>>>>>>>        Function_Return bRetval
70741>>>>>>>    End_Function
70742>>>>>>>
70742>>>>>>>    Procedure Request_Clear_All
70744>>>>>>>        tDataSourceRow[] EmptyData
70744>>>>>>>        tDataSourceRow[] EmptyData
70745>>>>>>>        Handle hoGrid hoDataSource
70745>>>>>>>
70745>>>>>>>        Move Self  to hoGrid
70746>>>>>>>        If (IsComObjectCreated(hoGrid)) Begin
70748>>>>>>>            Get phoDataSource of hoGrid to hoDataSource
70749>>>>>>>            Send InitializeData of hoGrid EmptyData
70750>>>>>>>            Send DoSetCheckboxFooterText
70751>>>>>>>        End
70751>>>>>>>>
70751>>>>>>>    End_Procedure
70752>>>>>>>
70752>>>>>>>    // Set checkboxes of the first column as selected.
70752>>>>>>>    // iState can be one of the following:
70752>>>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
70752>>>>>>>    Procedure Set SelectItems Integer iState
70754>>>>>>>        Integer iCount iSize iCheckbox_Col
70754>>>>>>>        Boolean bChecked
70754>>>>>>>        Handle hoDataSource hoCheckBox_Col
70754>>>>>>>        tDataSourceRow[] TheData
70754>>>>>>>        tDataSourceRow[] TheData
70755>>>>>>>        
70755>>>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
70756>>>>>>>        If (hoCheckBox_Col = 0) Begin
70758>>>>>>>            Procedure_Return
70759>>>>>>>        End                 
70759>>>>>>>>
70759>>>>>>>        
70759>>>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
70760>>>>>>>        Get phoDataSource               to hoDataSource
70761>>>>>>>        Get DataSource of hoDataSource  to TheData
70762>>>>>>>        Move (SizeOfArray(TheData))     to iSize
70763>>>>>>>        Decrement iSize
70764>>>>>>>        For iCount from 0 to iSize
70770>>>>>>>>
70770>>>>>>>            Case Begin
70770>>>>>>>                Case (iState = cx_Select_All)
70772>>>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
70773>>>>>>>                    Case Break
70774>>>>>>>                Case (iState = cx_Select_None)
70777>>>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
70778>>>>>>>                    Case Break
70779>>>>>>>                Case (iState = cx_Select_Invert)
70782>>>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
70783>>>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
70784>>>>>>>                    Case Break
70785>>>>>>>            Case End
70785>>>>>>>        Loop
70786>>>>>>>>
70786>>>>>>>
70786>>>>>>>        Send ReInitializeData TheData False
70787>>>>>>>        Send DoSetCheckboxFooterText
70788>>>>>>>    End_Procedure
70789>>>>>>>
70789>>>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
70789>>>>>>>    Function SelectedItems Returns String[]
70791>>>>>>>        Integer i iItems iSize iCheckbox_Col iData_Col
70791>>>>>>>        String[] sDataArray
70792>>>>>>>        Handle hoDataSource
70792>>>>>>>        tDataSourceRow[] TheData
70792>>>>>>>        tDataSourceRow[] TheData
70793>>>>>>>        Boolean bChecked
70793>>>>>>>
70793>>>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
70794>>>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
70795>>>>>>>
70795>>>>>>>        Get phoDataSource to hoDataSource
70796>>>>>>>        Get DataSource of hoDataSource to TheData
70797>>>>>>>        Move (SizeOfArray(TheData)) to iItems
70798>>>>>>>        Decrement iItems
70799>>>>>>>
70799>>>>>>>        For i from 0 to iItems
70805>>>>>>>>
70805>>>>>>>            Move TheData[i].sValue[iCheckbox_Col] to bChecked
70806>>>>>>>            If (bChecked = True) Begin
70808>>>>>>>                Move (SizeOfArray(sDataArray)) to iSize
70809>>>>>>>                Move TheData[i].sValue[iData_Col] to sDataArray[iSize]
70810>>>>>>>            End
70810>>>>>>>>
70810>>>>>>>        Loop
70811>>>>>>>>
70811>>>>>>>
70811>>>>>>>        Function_Return sDataArray
70812>>>>>>>    End_Function
70813>>>>>>>
70813>>>>>>>    Procedure SelectAll
70815>>>>>>>        Set SelectItems to cx_Select_All
70816>>>>>>>    End_Procedure
70817>>>>>>>
70817>>>>>>>    Procedure SelectNone
70819>>>>>>>        Set SelectItems to cx_Select_None
70820>>>>>>>    End_Procedure
70821>>>>>>>
70821>>>>>>>    Procedure SelectInvert
70823>>>>>>>        Set SelectItems to cx_Select_Invert
70824>>>>>>>    End_Procedure
70825>>>>>>>
70825>>>>>>>    // Returns number of items.
70825>>>>>>>    Function ItemCount Returns Integer
70827>>>>>>>        Integer iItems
70827>>>>>>>        Handle hoDataSource
70827>>>>>>>        tDataSourceRow[] TheData
70827>>>>>>>        tDataSourceRow[] TheData
70828>>>>>>>
70828>>>>>>>        Get phoDataSource to hoDataSource
70829>>>>>>>        Get DataSource of hoDataSource to TheData
70830>>>>>>>        Move (SizeOfArray(TheData)) to iItems
70831>>>>>>>
70831>>>>>>>        Function_Return iItems
70832>>>>>>>    End_Function
70833>>>>>>>
70833>>>>>>>    // Returns number of checked items.
70833>>>>>>>    Function CheckedItems Returns Integer
70835>>>>>>>        Integer iCount iItems iCheckbox_Col iRetval
70835>>>>>>>        Handle hoDataSource hoCheckbox_Col
70835>>>>>>>        tDataSourceRow[] TheData
70835>>>>>>>        tDataSourceRow[] TheData
70836>>>>>>>        Boolean bChecked
70836>>>>>>>
70836>>>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
70837>>>>>>>        If (hoCheckbox_Col = 0) Begin
70839>>>>>>>            Procedure_Return
70840>>>>>>>        End
70840>>>>>>>>
70840>>>>>>>        Get piColumnId of hoCheckbox_Col to iCheckbox_Col
70841>>>>>>>        Get phoDataSource to hoDataSource
70842>>>>>>>        Get DataSource of hoDataSource to TheData
70843>>>>>>>        Move (SizeOfArray(TheData)) to iItems
70844>>>>>>>        Decrement iItems
70845>>>>>>>
70845>>>>>>>        For iCount from 0 to iItems
70851>>>>>>>>
70851>>>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
70852>>>>>>>            If (bChecked = True) Begin
70854>>>>>>>                Increment iRetval
70855>>>>>>>            End
70855>>>>>>>>
70855>>>>>>>        Loop
70856>>>>>>>>
70856>>>>>>>
70856>>>>>>>        Function_Return iRetval
70857>>>>>>>    End_Function
70858>>>>>>>
70858>>>>>>>    // Toggles the current row on/off (the checkbox)
70858>>>>>>>    Procedure ToggleCurrentItem
70860>>>>>>>        Boolean bChecked
70860>>>>>>>        Integer iCol
70860>>>>>>>        Handle hoCol hoCheckbox_Col
70860>>>>>>>
70860>>>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
70861>>>>>>>        If (hoCheckbox_Col = 0) Begin
70863>>>>>>>            Procedure_Return
70864>>>>>>>        End
70864>>>>>>>>
70864>>>>>>>        Get piColumnId of hoCheckbox_Col to iCol
70865>>>>>>>        Get ColumnObject iCol   to hoCol
70866>>>>>>>        Get SelectedRowValue    of hoCol to bChecked
70867>>>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
70868>>>>>>>        Send Request_Save
70869>>>>>>>        Send DoSetCheckboxFooterText
70870>>>>>>>    End_Procedure
70871>>>>>>>
70871>>>>>>>    Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
70873>>>>>>>        Forward Send OnComMouseUp llButton llShift llx lly
70875>>>>>>>        Send Request_Save
70876>>>>>>>        Send DoSetCheckboxFooterText
70877>>>>>>>    End_Procedure
70878>>>>>>>
70878>>>>>>>    Procedure DoSetCheckboxFooterText
70880>>>>>>>        Integer iCol iSelected iItems
70880>>>>>>>        Handle hoCol hoCheckbox_Col
70880>>>>>>>
70880>>>>>>>        If ((phoData_Col(Self) = 0)) Begin
70882>>>>>>>            Move 1 to iCol
70883>>>>>>>        End
70883>>>>>>>>
70883>>>>>>>        Else Begin
70884>>>>>>>            Get piColumnId of (phoData_Col(Self)) to iCol
70885>>>>>>>        End
70885>>>>>>>>
70885>>>>>>>        Get ItemCount to iItems
70886>>>>>>>        Get ColumnObject iCol to hoCol
70887>>>>>>>        Get CheckedItems to iSelected
70888>>>>>>>        Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))
70889>>>>>>>    End_Procedure
70890>>>>>>>
70890>>>>>>>    Procedure DoChangeFontSize
70892>>>>>>>        Handle hoFont hoPaintManager
70892>>>>>>>        Variant vFont
70892>>>>>>>        String sFont sFontSize
70892>>>>>>>        Boolean bCreated
70892>>>>>>>        Integer iVal
70892>>>>>>>
70892>>>>>>>        Get IsComObjectCreated to bCreated  // When program is started, grid object isn't created yet.
70893>>>>>>>        If (bCreated = False) Begin
70895>>>>>>>            Procedure_Return
70896>>>>>>>        End
70896>>>>>>>>
70896>>>>>>>
70896>>>>>>>        Get phoReportPaintManager to hoPaintManager
70897>>>>>>>        Get Create (RefClass(cComStdFont)) to hoFont  // Create a font object
70898>>>>>>>        Get ComTextFont of hoPaintManager to vFont    // Bind the font object to the Grid's text font
70899>>>>>>>        Set pvComObject of hoFont to vFont            // Connect DataFlex object with com object
70900>>>>>>>
70900>>>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iVal
70901>>>>>>>        Set ComSize of hoFont to iVal
70902>>>>>>>        Send ComRedraw
70903>>>>>>>        Send Destroy to hoFont                        // Destroy the font object (releases memory)
70904>>>>>>>    End_Procedure
70905>>>>>>>
70905>>>>>>>    // Augment to load data to the grid. Is called automatically
70905>>>>>>>    // from procedure Activating
70905>>>>>>>    Procedure LoadData
70907>>>>>>>    End_Procedure
70908>>>>>>>
70908>>>>>>>    // Automatically load data into the grid when activating.
70908>>>>>>>    Procedure Activating
70910>>>>>>>        Send Cursor_Wait of Cursor_Control
70911>>>>>>>        Send LoadData                       
70912>>>>>>>        Send DoChangeFontSize      
70913>>>>>>>        Send Cursor_Ready of Cursor_Control
70914>>>>>>>    End_Procedure
70915>>>>>>>
70915>>>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
70917>>>>>>>        Integer iSize jSize kSize iSup iInf iDef
70917>>>>>>>        Handle hoPaintManager hoFont
70917>>>>>>>        Variant vFont
70917>>>>>>>        
70917>>>>>>>        Move 3 to iInf      //max size
70918>>>>>>>        Move 18 to iSup     //min size
70919>>>>>>>        Move 8 to iDef      //default
70920>>>>>>>        Boolean blimite
70920>>>>>>>        Get phoReportPaintManager to hoPaintManager
70921>>>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
70923>>>>>>>            Procedure_Return
70924>>>>>>>        End
70924>>>>>>>>
70924>>>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
70925>>>>>>>        Get ComTextFont of hoPaintManager to vFont
70926>>>>>>>        Set pvComObject of hoFont to vFont
70927>>>>>>>        If (iDirection = 0) Begin
70929>>>>>>>            Set ComSize of hoFont to iDef
70930>>>>>>>        End
70930>>>>>>>>
70930>>>>>>>        Else Begin
70931>>>>>>>           Get ComSize of hoFont to iSize
70932>>>>>>>           Move iSize to jSize
70933>>>>>>>           Repeat
70933>>>>>>>>
70933>>>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
70934>>>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
70935>>>>>>>                If (not(blimite)) Begin       
70937>>>>>>>                   Set ComSize of hoFont to jSize
70938>>>>>>>                   Get ComSize of hoFont to kSize
70939>>>>>>>                End
70939>>>>>>>>
70939>>>>>>>            Until (iSize <> kSize or blimite)
70941>>>>>>>        End
70941>>>>>>>>
70941>>>>>>>        Send Destroy to hoFont 
70942>>>>>>>        Send ComRedraw  
70943>>>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
70944>>>>>>>    End_Procedure 
70945>>>>>>>
70945>>>>>>>End_Class
70946>>>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
70946>>>>>>>//****************************************************************************
70946>>>>>>>// $Module type: Package
70946>>>>>>>// $Module name: cRDCButtonDPI.pkg
70946>>>>>>>//
70946>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
70946>>>>>>>// Copyright (c) 2013 RDC Tools International
70946>>>>>>>// E-mail      : support@rdctools.com
70946>>>>>>>// Web-site    : http://www.rdctools.com
70946>>>>>>>//
70946>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
70946>>>>>>>//
70946>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70946>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70946>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70946>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70946>>>>>>>// in the help folder for more details.
70946>>>>>>>//
70946>>>>>>>//****************************************************************************
70946>>>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
70946>>>>>>>>>//****************************************************************************
70946>>>>>>>>>// $Module type: Package
70946>>>>>>>>>// $Module name: cRDCButton.pkg
70946>>>>>>>>>//
70946>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
70946>>>>>>>>>// Copyright (c) 2013 RDC Tools International
70946>>>>>>>>>// E-mail      : support@rdctools.com
70946>>>>>>>>>// Web-site    : http://www.rdctools.com
70946>>>>>>>>>//
70946>>>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
70946>>>>>>>>>//
70946>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70946>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70946>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70946>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70946>>>>>>>>>// in the help folder for more details.
70946>>>>>>>>>//
70946>>>>>>>>>//****************************************************************************
70946>>>>>>>>>Use Windows.pkg
70946>>>>>>>>>Use Enclient.pkg
70946>>>>>>>>>Use errornum.inc
70946>>>>>>>>>
70946>>>>>>>>>Class cButtonIdleHandler is a cIdleHandler
70947>>>>>>>>>    Procedure Construct_Object
70949>>>>>>>>>        Forward Send Construct_Object
70951>>>>>>>>>
70951>>>>>>>>>    End_Procedure
70952>>>>>>>>>
70952>>>>>>>>>    Procedure OnIdle
70954>>>>>>>>>        Delegate Send DoUpdate
70956>>>>>>>>>    End_Procedure
70957>>>>>>>>>
70957>>>>>>>>>End_Class
70958>>>>>>>>>
70958>>>>>>>>>Class cRDCButton is a Button
70959>>>>>>>>>
70959>>>>>>>>>    Procedure Construct_Object
70961>>>>>>>>>        Forward Send Construct_Object
70963>>>>>>>>>
70963>>>>>>>>>        Property Boolean pbAutoEnable True
70964>>>>>>>>>
70964>>>>>>>>>        Property Boolean pbEnabled True
70965>>>>>>>>>
70965>>>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
70966>>>>>>>>>
70966>>>>>>>>>        On_Key kCancel Send CancelIfPopupObject
70967>>>>>>>>>    End_Procedure
70968>>>>>>>>>
70968>>>>>>>>>    Procedure CancelIfPopupObject
70970>>>>>>>>>        Boolean bIsInPopupObject
70970>>>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
70972>>>>>>>>>        If (bIsInPopupObject = True) Begin
70974>>>>>>>>>            Send Close_Panel
70975>>>>>>>>>        End
70975>>>>>>>>>>
70975>>>>>>>>>    End_Procedure
70976>>>>>>>>>
70976>>>>>>>>>    Procedure End_Construct_Object
70978>>>>>>>>>        String sTooltip sStatus_Help
70978>>>>>>>>>
70978>>>>>>>>>        Forward Send End_Construct_Object
70980>>>>>>>>>
70980>>>>>>>>>        Get psToolTip   to sTooltip
70981>>>>>>>>>        Get Status_Help to sStatus_Help
70982>>>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
70984>>>>>>>>>            Set psToolTip to sStatus_Help
70985>>>>>>>>>        End
70985>>>>>>>>>>
70985>>>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
70987>>>>>>>>>            Set Status_Help to sToolTip
70988>>>>>>>>>        End
70988>>>>>>>>>>
70988>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
70989>>>>>>>>>    End_Procedure
70990>>>>>>>>>
70990>>>>>>>>>    Procedure DoUpdate
70992>>>>>>>>>        If (pbAutoEnable(Self) = False) Begin
70994>>>>>>>>>            Procedure_Return
70995>>>>>>>>>        End
70995>>>>>>>>>>
70995>>>>>>>>>        Set Enabled_State to (IsEnabled(Self))
70996>>>>>>>>>    End_Procedure
70997>>>>>>>>>
70997>>>>>>>>>    Function IsEnabled Returns Boolean
70999>>>>>>>>>        Boolean bEnabled
70999>>>>>>>>>        Get pbEnabled to bEnabled
71000>>>>>>>>>        Function_Return bEnabled
71001>>>>>>>>>    End_Function
71002>>>>>>>>>
71002>>>>>>>>>    // Enable the idle handler timer when the button is activated
71002>>>>>>>>>    Procedure Activating
71004>>>>>>>>>        Forward Send Activating
71006>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
71007>>>>>>>>>    End_Procedure
71008>>>>>>>>>
71008>>>>>>>>>    // Disable the idle handler when the button is deactivated
71008>>>>>>>>>    Procedure Deactivating
71010>>>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
71011>>>>>>>>>        Forward Send Deactivating
71013>>>>>>>>>    End_Procedure
71014>>>>>>>>>
71014>>>>>>>>>End_Class
71015>>>>>>>
71015>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
71015>>>>>>>Class cRDCButtonDPI is a cRDCButton
71016>>>>>>>    Procedure Construct_Object
71018>>>>>>>        Integer iIconSize
71018>>>>>>>        Forward Send Construct_Object
71020>>>>>>>        Set piImageMarginLeft to 10
71021>>>>>>>    End_Procedure
71022>>>>>>>
71022>>>>>>>    // Returns: DPI setting as an integer.
71022>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
71022>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
71022>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
71022>>>>>>>    Function GetCurrentDPI Returns Integer
71024>>>>>>>        Handle hDC
71024>>>>>>>        Integer iPixelsX
71024>>>>>>>        Move (GetDC(0)) to hDC
71025>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
71026>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
71027>>>>>>>        Function_Return iPixelsX
71028>>>>>>>    End_Function
71029>>>>>>>
71029>>>>>>>    Function GetCorrectIconSize Returns Integer
71031>>>>>>>        Integer iPixelsX iIndex iSize
71031>>>>>>>        Integer[] iaSizes
71032>>>>>>>
71032>>>>>>>        Move 16 to iaSizes[0]
71033>>>>>>>        Move 24 to iaSizes[1]
71034>>>>>>>        Move 32 to iaSizes[2]
71035>>>>>>>        Move 48 to iaSizes[3]
71036>>>>>>>        Move 64 to iaSizes[4]
71037>>>>>>>
71037>>>>>>>        Get piImageSize to iSize  // the "100%" size
71038>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
71039>>>>>>>        Move (0 max iIndex) to iIndex
71040>>>>>>>        Get GetCurrentDPI to iPixelsX
71041>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
71041>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
71041>>>>>>>        // will increment iIndex as many times as we need here.
71041>>>>>>>        Case Begin
71041>>>>>>>            Case (iPixelsX > 144)
71043>>>>>>>                Increment iIndex
71044>>>>>>>            Case (iPixelsX = 144)
71047>>>>>>>                Increment iIndex
71048>>>>>>>            Case (iPixelsX = 120)
71051>>>>>>>                Increment iIndex
71052>>>>>>>        Case End
71052>>>>>>>        Move (iIndex min 4) to iIndex
71053>>>>>>>        Function_Return iaSizes[iIndex]
71054>>>>>>>    End_Function
71055>>>>>>>
71055>>>>>>>    Procedure Set psToolTip String sToolTip
71057>>>>>>>        String sStatusHelp
71057>>>>>>>
71057>>>>>>>        Get Status_Help to sStatusHelp
71058>>>>>>>        If (sStatusHelp = "") Begin
71060>>>>>>>            Set Status_Help to sToolTip
71061>>>>>>>        End
71061>>>>>>>>
71061>>>>>>>
71061>>>>>>>        Forward Set psToolTip to sToolTip
71063>>>>>>>    End_Procedure
71064>>>>>>>
71064>>>>>>>End_Class
71065>>>>>
71065>>>>>Object oDeleteWorkspaceHistory_dg is a cRDCModalPanel
71067>>>>>    Set Label to "Delete Workspace History Items"
71068>>>>>    Set Size to 158 374
71069>>>>>    Set Location to 2 2
71070>>>>>    Set piMinSize to 158 345
71071>>>>>    Set Icon to "RemoveWorkspaceHistory.ico"
71072>>>>>
71072>>>>>    Property String[] pasWorkspaces
71074>>>>>
71074>>>>>    Object oInfo_tb is a TextBox
71076>>>>>        Set Size to 10 100
71077>>>>>        Set Location to 10 29
71078>>>>>        Set Label to "Use the spacebar to select items"
71079>>>>>    End_Object
71080>>>>>
71080>>>>>    Object oWorkspaceHistory_grd is a cRDCCJSelectionGrid
71082>>>>>        Set Size to 109 346
71083>>>>>        Set Location to 22 14
71084>>>>>        Set psNoItemsText to "No Workspace selected yet..."
71085>>>>>
71085>>>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
71087>>>>>            Set piWidth to 25
71088>>>>>        End_Object
71089>>>>>
71089>>>>>        Object oWorkspaceName_col is a cCJGridColumn
71091>>>>>            // This must be here:
71091>>>>>            Set phoData_Col to Self
71092>>>>>
71092>>>>>            Set piWidth to 602
71093>>>>>            Set psCaption to "Workspace Name"
71094>>>>>            Set psToolTip to "Workspace history name"
71095>>>>>            Set pbEditable to False
71096>>>>>        End_Object
71097>>>>>
71097>>>>>        Procedure LoadData
71100>>>>>            String sFolderName
71100>>>>>            Handle hoDataSource
71100>>>>>            tDataSourceRow[] TheData TheDataEmpty
71100>>>>>            tDataSourceRow[] TheData TheDataEmpty
71102>>>>>            tsSearchResult[] asFolderArray
71102>>>>>            tsSearchResult[] asFolderArray
71103>>>>>            Integer iSize iRow iCount iFolderCol iCheckBoxCol
71103>>>>>            String[] asWorkspaces
71104>>>>>
71104>>>>>            If (not(IsComObjectCreated(Self))) Begin
71106>>>>>                Procedure_Return
71107>>>>>            End
71107>>>>>>
71107>>>>>
71107>>>>>            Get pasWorkspaces to asWorkspaces
71108>>>>>            Move (SizeOfArray(asWorkspaces)) to iSize
71109>>>>>            If (iSize = 0) Begin
71111>>>>>                Procedure_Return
71112>>>>>            End
71112>>>>>>
71112>>>>>
71112>>>>>            Move 0 to iCount
71113>>>>>            Decrement iSize
71114>>>>>            Get phoDataSource to hoDataSource
71115>>>>>            Get DataSource of hoDataSource to TheData
71116>>>>>            Move TheDataEmpty to TheData
71117>>>>>            Get piColumnId of (phoData_Col(Self))     to iFolderCol
71118>>>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
71119>>>>>
71119>>>>>            Move 0 to iRow
71120>>>>>            For iCount From 0 to iSize
71126>>>>>>
71126>>>>>                Move asWorkspaces[iCount] to sFolderName
71127>>>>>                Move sFolderName to TheData[iRow].sValue[iFolderCol]
71128>>>>>                Move False to TheData[iRow].sValue[iCheckBoxCol]
71129>>>>>                Increment iRow
71130>>>>>            Loop
71131>>>>>>
71131>>>>>
71131>>>>>            If (iRow <> 0) Begin
71133>>>>>                Send ReInitializeData TheData False
71134>>>>>                Send MoveToFirstRow
71135>>>>>            End
71135>>>>>>
71135>>>>>            Else Begin
71136>>>>>                Send InitializeData TheDataEmpty
71137>>>>>            End
71137>>>>>>
71137>>>>>            Get CheckedItems to iCount
71138>>>>>            Set psFooterText of oWorkspaceName_col  to ("Selected Items:" * String(iCount))
71139>>>>>        End_Procedure
71140>>>>>
71140>>>>>        // We delete selected item(s) in three steps.
71140>>>>>        // 1. Check for selected items and delete them from the grid
71140>>>>>        // 2. Get the remainder of items from the grid to an array string
71140>>>>>        // 3. Delete all current items from the registry and write the new array string.
71140>>>>>        Function DeleteSelectedItems Returns Boolean
71143>>>>>            String[] asWorkspaces
71144>>>>>            Integer iCount iSize iRegistryItems iItem iWorkspaceName_col iCheckbox_Col
71144>>>>>            Handle hoDataSource
71144>>>>>            tDataSourceRow[] TheData NewData
71144>>>>>            tDataSourceRow[] TheData NewData
71146>>>>>            Boolean bChecked
71146>>>>>
71146>>>>>            Move False to Err
71147>>>>>            Get piColumnId of oWorkspaceName_col to iWorkspaceName_col
71148>>>>>            Get piColumnId of oCheckbox_col      to iCheckbox_Col
71149>>>>>            Get phoDataSource to hoDataSource
71150>>>>>            Get DataSource    of hoDataSource to TheData
71151>>>>>            Move (SizeOfArray(TheData)) to iSize
71152>>>>>            Decrement iSize
71153>>>>>            Move 0 to iItem
71154>>>>>
71154>>>>>            // 1. Delete selected grid items
71154>>>>>            For iCount From 0 to iSize
71160>>>>>>
71160>>>>>                Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
71161>>>>>                If (bChecked = False) Begin
71163>>>>>                    Move TheData[iCount] to NewData[iItem]
71164>>>>>                    Increment iItem
71165>>>>>                End
71165>>>>>>
71165>>>>>            Loop
71166>>>>>>
71166>>>>>            Send ReInitializeData NewData False
71167>>>>>            Send MoveToFirstRow
71168>>>>>
71168>>>>>            // 2. Get the grid data again and move items to string array
71168>>>>>            Get DataSource of hoDataSource to TheData
71169>>>>>            Move (SizeOfArray(TheData)) to iSize
71170>>>>>            Decrement iSize
71171>>>>>            Move 0 to iItem
71172>>>>>            For iCount From 0 to iSize
71178>>>>>>
71178>>>>>                Move TheData[iCount].sValue[iWorkspaceName_col] to asWorkspaces[iItem]
71179>>>>>                Increment iItem
71180>>>>>            Loop
71181>>>>>>
71181>>>>>
71181>>>>>            // Get max number of workspaces that can be saved to the registry.
71181>>>>>            Get piWorkspaceItems of ghoApplication to iRegistryItems
71182>>>>>
71182>>>>>            // 3. Delete all current items from the registry and write the new array string, then write the new ones.
71182>>>>>            For iCount From 0 to iRegistryItems
71188>>>>>>
71188>>>>>                Send WriteString of ghoApplication CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) ""
71189>>>>>            Loop
71190>>>>>>
71190>>>>>
71190>>>>>            Move (SizeOfArray(asWorkspaces)) to iSize
71191>>>>>            Decrement iSize
71192>>>>>            For iCount From 0 to iSize
71198>>>>>>
71198>>>>>                Send WriteString of ghoApplication CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) asWorkspaces[iCount]
71199>>>>>            Loop
71200>>>>>>
71200>>>>>
71200>>>>>            Send DoSetCheckboxFooterText
71201>>>>>            Function_Return (Err = False)
71202>>>>>        End_Function
71203>>>>>
71203>>>>>        On_Key Key_Space Send ToggleCurrentItem
71204>>>>>    End_Object
71205>>>>>
71205>>>>>    Object oOK_Btn is a cRDCButtonDPI
71207>>>>>        Set Label to "Delete"
71208>>>>>        Set Location to 137 255
71209>>>>>        Set peAnchors to anBottomRight
71210>>>>>        Set psImage to "ActionDelete.ico"
71211>>>>>
71211>>>>>        Procedure OnClick
71214>>>>>            Integer iCount iRetval
71214>>>>>            Boolean bOK
71214>>>>>
71214>>>>>            Get CheckedItems of oWorkspaceHistory_grd to iCount
71215>>>>>            If (iCount = 0) Begin
71217>>>>>                Send Info_Box "You need to select at least one workspace history item to delete. Please adjust and try again."
71218>>>>>                Procedure_Return
71219>>>>>            End
71219>>>>>>
71219>>>>>
71219>>>>>            Get YesNo_Box ("Are you sure you want to delete" * String(iCount) * "history workspaces from the registry?") to iRetval
71220>>>>>            If (iRetval <> MBR_Yes) Begin
71222>>>>>                Procedure_Return
71223>>>>>            End
71223>>>>>>
71223>>>>>
71223>>>>>            Get DeleteSelectedItems of oWorkspaceHistory_grd to bOK
71224>>>>>            If (bOK = True) Begin
71226>>>>>                Send Info_Box "Selected item(s) successfully deleted from the registry"
71227>>>>>            End
71227>>>>>>
71227>>>>>            Else Begin
71228>>>>>                Send Info_Box "Nope, that didn't work. It did not work to delete the selected item(s)."
71229>>>>>            End
71229>>>>>>
71229>>>>>
71229>>>>>        End_Procedure
71230>>>>>
71230>>>>>        On_Key kCancel Send KeyAction of oCancel_Btn
71231>>>>>    End_Object
71232>>>>>
71232>>>>>    Object oCancel_Btn is a Button
71234>>>>>        Set Label to "Close"
71235>>>>>        Set Location to 137 310
71236>>>>>        Set peAnchors to anBottomRight
71237>>>>>
71237>>>>>        Procedure OnClick
71240>>>>>            Send Close_Panel
71241>>>>>        End_Procedure
71242>>>>>
71242>>>>>        On_Key kCancel Send KeyAction of oCancel_Btn
71243>>>>>    End_Object
71244>>>>>
71244>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
71245>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
71246>>>>>End_Object
71247>>>>>
71247>>>>>Procedure ActivateDeleteWorkspaceHistoryDialog String[] asWorkspaces
71249>>>>>    Handle ho
71249>>>>>    Move (oDeleteWorkspaceHistory_dg(Self)) to ho
71250>>>>>    Set pasWorkspaces of ho to asWorkspaces
71251>>>>>    Send Popup of ho
71252>>>>>End_Procedure
71253>>>
71253>>>Global_Variable Integer ghoFileSystem
71253>>>
71253>>>Class cRefactorApplication is a cApplication
71254>>>    
71254>>>    Procedure Construct_Object
71256>>>        Forward Send Construct_Object
71258>>>
71258>>>        Property String private.psFileCompareApp
71259>>>        Property String private.psStarZenSourceExplorer
71260>>>        Property Integer private.piToolbarIconSize 0
71261>>>        Property String private.psGridRowBackgroundColor 0
71262>>>        Property String private.psSWSFile       ""
71263>>>        Property Boolean private.pbWorkspaceMode True
71264>>>        Property Boolean private.pbShouldBackupFile True
71265>>>        Property Integer private.piActiveView -1
71266>>>        Property Handle private.phoActiveView -1 
71267>>>        
71267>>>        // Used by the DfAbout object to display the compile date & time.
71267>>>        // See also: End_Construct_Object in this class.
71267>>>        Property String psCompileDateAndTime ""
71268>>>        
71268>>>        Property Handle phoEditorView 0
71269>>>        Property Handle phoRefactorView 0
71270>>>        Property Handle phoEditor 0
71271>>>    
71271>>>        Property String psHomePath  ""
71272>>>        Property String psCurrentSourceFileName ""
71273>>>        Property Integer piWorkspaceItems 9 // Zero based
71274>>>    
71274>>>        // For the Scintilla editor
71274>>>        Property String psStartupProgramPath ""
71275>>>        Property String psStartupBitmapPath  ""
71276>>>
71276>>>        Get Create (RefClass(cFilesystem)) to ghoFileSystem
71277>>>                                      
71277>>>        Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_BINARY
71277>>>    End_Procedure
71278>>>
71278>>>    // Note; This logic uses the Include_Resource info above to set the
71278>>>    // ghoApplication property; psCompileDateAndTime that is used by the DfAbout object
71278>>>    // to show the compiled date & time.
71278>>>    // The includeded file CompileHeader.h is generated by the "Before Compilation Process",
71278>>>    // setup in the project properties "Compiler" tab-page. 
71278>>>    Procedure End_Construct_Object
71280>>>        String sCompileTime  
71280>>>        Integer iPos
71280>>>        
71280>>>        Forward Send End_Construct_Object
71282>>>        Direct_Input "resource: res_CompileHeader"
71283>>>        Readln sCompileTime
71284>>>        Move (Pos('"', sCompileTime)) to iPos
71285>>>        If (iPos <> 0) Begin
71287>>>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
71288>>>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
71289>>>            Set psCompileDateAndTime to sCompileTime
71290>>>        End
71290>>>>
71290>>>        Close_Input
71291>>>        
71291>>>        Open SysFile
Including file: SysFile.fd    (C:\Projects\DF18\DfRefactor\DDSrc\SysFile.fd)
71293>>>        Set private.psStarZenSourceExplorer to (Trim(SysFile.PathStarZen)) 
71294>>>    End_Procedure
71295>>>
71295>>>    Function SourceFilePath Returns String
71297>>>        String sFileName sPath
71297>>>
71297>>>        Get psHomePath to sPath
71298>>>        Get psCurrentSourceFileName to sFileName
71299>>>        If (sFileName <> "") Begin
71301>>>            Get ParseFolderName sFileName to sPath
71302>>>        End
71302>>>>
71302>>>        Function_Return sPath
71303>>>    End_Function
71304>>>
71304>>>    Procedure Set piToolbarIconSize Integer iSize
71306>>>        Send WriteDword CS_Settings CS_ToolbarIconSize iSize
71307>>>        Set private.piToolbarIconSize to iSize
71308>>>        Set piToolbarIconSize of ghoCommandBars to iSize
71309>>>    End_Procedure
71310>>>
71310>>>    Function piToolbarIconSize Returns Integer
71312>>>        Integer iSize
71312>>>        Get private.piToolbarIconSize to iSize
71313>>>        If (iSize = 0) Begin
71315>>>            Get ReadDword CS_Settings CS_ToolbarIconSize 24 to iSize
71316>>>            Set private.piToolbarIconSize to iSize
71317>>>        End
71317>>>>
71317>>>        Function_Return iSize
71318>>>    End_Function
71319>>>
71319>>>    Procedure Set psGridRowBackgroundColor String sColor
71321>>>        Set private.psGridRowBackgroundColor to sColor
71322>>>        Send WriteString CS_Settings CS_GridRowBackgroundColor sColor
71323>>>        Broadcast Recursive Set piSelectedRowBackColor of (Client_Id(phoMainPanel(ghoApplication))) to sColor
71325>>>        Broadcast Recursive Set piHighlightBackColor   of (Client_Id(phoMainPanel(ghoApplication))) to sColor
71327>>>    End_Procedure
71328>>>
71328>>>    Function psGridRowBackgroundColor Returns String
71330>>>        String sColor
71330>>>        Get private.psGridRowBackgroundColor to sColor
71331>>>        If (sColor = 0) Begin
71333>>>            Get ReadString CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
71334>>>            If (sColor contains "clBlueGrey") Begin
71336>>>                Move (Replace("clBlueGrey", sColor, "clGreenGrey")) to sColor
71337>>>            End
71337>>>>
71337>>>            Set private.psGridRowBackgroundColor to sColor
71338>>>        End
71338>>>>
71338>>>        Function_Return sColor
71339>>>    End_Function
71340>>>
71340>>>    Procedure Set psFileCompareApp String sProgramName
71342>>>        Send WriteString CS_Settings CS_FileCompareProgram sProgramName
71343>>>        Set private.psFileCompareApp to sProgramName
71344>>>    End_Procedure
71345>>>
71345>>>    Function psFileCompareApp Returns String
71347>>>        String sProgramName
71347>>>        Get private.psFileCompareApp to sProgramName
71348>>>        If (sProgramName = "") Begin
71350>>>            Get ReadString CS_Settings CS_FileCompareProgram "" to sProgramName
71351>>>            Set private.psFileCompareApp to sProgramName
71352>>>        End
71352>>>>
71352>>>        Function_Return sProgramName
71353>>>    End_Function
71354>>>
71354>>>    Procedure Set psStarZenSourceExplorer String sProgramName
71356>>>        Send WriteString CS_Settings CS_StarZenSourceExplorer sProgramName
71357>>>        Set private.psStarZenSourceExplorer to sProgramName
71358>>>    End_Procedure
71359>>>
71359>>>    Function psStarZenSourceExplorer Returns String
71361>>>        String sProgramName
71361>>>        Get private.psStarZenSourceExplorer to sProgramName
71362>>>        If (sProgramName = "") Begin
71364>>>            Get ReadString CS_Settings CS_StarZenSourceExplorer "" to sProgramName
71365>>>            Set private.psStarZenSourceExplorer to sProgramName
71366>>>        End
71366>>>>
71366>>>        Function_Return sProgramName
71367>>>    End_Function
71368>>>
71368>>>    Procedure DisplayPerfCounters
71370>>>    End_Procedure
71371>>>
71371>>>    Function StartPerfCounter Integer eOperation String sComment Returns Integer
71373>>>        Function_Return 0
71374>>>    End_Function
71375>>>
71375>>>    Procedure StopPerfCounter Integer iCounter
71377>>>    End_Procedure
71378>>>
71378>>>    Procedure Set piActiveView Integer iActiveViewID Handle hoActiveView
71380>>>        Set Private.piActiveView  to iActiveViewID
71381>>>        Set Private.phoActiveView to hoActiveView
71382>>>    End_Procedure
71383>>>
71383>>>    Function piActiveView Returns Integer
71385>>>        Function_Return (Private.piActiveView(Self))
71386>>>    End_Function
71387>>>
71387>>>    Function phoActiveView Returns Integer
71389>>>        Function_Return (Private.phoActiveView(Self))
71390>>>    End_Function
71391>>>
71391>>>    Procedure AddWorkSpaceFileToRegistry String sFileName
71393>>>        Integer iCount iSize
71393>>>        String[] sWorkspaces
71394>>>        Boolean bFound
71394>>>
71394>>>        Get piWorkspaceItems to iSize
71395>>>        // Is the selected .sws file new?
71395>>>        For iCount from 0 to iSize
71401>>>>
71401>>>            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) "" to sWorkspaces[iCount]
71402>>>            If (Uppercase(sWorkspaces[iCount]) = Uppercase(sFilename)) Begin
71404>>>                Move True to bFound
71405>>>            End
71405>>>>
71405>>>        Loop
71406>>>>
71406>>>
71406>>>        // If new, save it to the registry. Push it to the top of the stack (LiFo).
71406>>>        If (bFound = False) Begin
71408>>>            Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + "0") sFilename
71409>>>            Decrement iSize
71410>>>            For iCount from 0 to iSize
71416>>>>
71416>>>                If (sWorkspaces[iCount] <> "") Begin
71418>>>                    Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount + 1)) sWorkspaces[iCount]
71419>>>                End
71419>>>>
71419>>>            Loop
71420>>>>
71420>>>        End
71420>>>>
71420>>>    End_Procedure
71421>>>
71421>>>    Function ReadWorkspaceKeysFromRegistry Returns String[]
71423>>>        Integer iCount iSize iItem
71423>>>        String[] asWorkspaces
71424>>>        String sWorkspace
71424>>>
71424>>>        Move 0 to iItem
71425>>>        Get piWorkspaceItems to iSize
71426>>>        For iCount from 0 to iSize
71432>>>>
71432>>>            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) '' to sWorkspace
71433>>>            If (sWorkspace <> "") Begin
71435>>>                Move sWorkspace to asWorkspaces[iItem]
71436>>>                Increment iItem
71437>>>            End
71437>>>>
71437>>>        Loop
71438>>>>
71438>>>        Function_Return asWorkspaces
71439>>>    End_Function
71440>>>
71440>>>    Procedure DeleteWorkSpaceHistoryFromRegistry
71442>>>        String[] asWorkspaces
71443>>>
71443>>>        Get ReadWorkspaceKeysFromRegistry to asWorkspaces
71444>>>        Send ActivateDeleteWorkspaceHistoryDialog of (Client_Id(phoMainPanel(ghoApplication))) asWorkspaces
71445>>>    End_Procedure
71446>>>
71446>>>    // Pass an SWS file with full path.
71446>>>    // Returns the .ws file name of the Programs folder.
71446>>>    Function WsFileNameFromSWSFileName String sSWSFilename Returns String
71448>>>        Handle hoIni
71448>>>        String sWs sWorkspaceFileName
71448>>>
71448>>>        Get Create (RefClass(cIniFile)) to hoIni
71449>>>        Set psFilename of hoIni  to sSWSFilename
71450>>>        Get ReadString of hoIni CS_WorkspacePaths CS_ConfigFile "" to sWs
71451>>>        Send Destroy   of hoIni
71452>>>        Move (Replace(".\", sWs, ExtractFilePath(sSWSFilename))) to sWorkspaceFileName
71453>>>
71453>>>        Function_Return sWorkspaceFileName
71454>>>    End_Function
71455>>>
71455>>>    Procedure ToggleWorkspaceAndFileMode
71457>>>    End_Procedure
71458>>>
71458>>>    Procedure Set pbWorkspaceMode Boolean bState
71460>>>        Set private.pbWorkspaceMode to bState
71461>>>        Send ToggleWorkspaceAndFileMode
71462>>>    End_Procedure
71463>>>
71463>>>    Function pbWorkspaceMode Returns Boolean
71465>>>        Function_Return (private.pbWorkspaceMode(Self))
71466>>>    End_Function
71467>>>
71467>>>    Procedure Set pbShouldBackupFile Boolean bState
71469>>>        Send WriteDword CS_Settings CS_CreateBackupFiles bState
71470>>>        Set private.pbShouldBackupFile to bState
71471>>>    End_Procedure
71472>>>
71472>>>    Function pbShouldBackupFile Returns Boolean
71474>>>        Boolean bState
71474>>>        Get private.pbShouldBackupFile to bState
71475>>>        Function_Return bState
71476>>>    End_Function
71477>>>
71477>>>    // Will create a backup-folder for the passed file, if-and-only-if it doesn't exists.
71477>>>    // Returns the full path to the backup folder.
71477>>>    Function CreateBackupFolder String sFile Returns String
71479>>>        String sPath sHomePath sBackupFolder
71479>>>        Boolean bFolderExists bSuccess
71479>>>        Integer iRetval iPos
71479>>>
71479>>>        Move "" to sPath
71480>>>        Get psHomePath            to sHomePath
71481>>>        If (sFile <> "") Begin
71483>>>        Get ParseFolderName sFile to sPath
71484>>>        Move (Replace(Lowercase(sHomePath), Lowercase(sPath), "")) to sPath // Only want the subfolder structure
71485>>>        Move (Pos(":", sPath)) to iPos
71486>>>        If (iPos > 0) Begin
71488>>>            Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
71489>>>            Move (Pos(CS_DirSeparator, sPath)) to iPos
71490>>>            If (iPos > 0) Begin
71492>>>                Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
71493>>>            End
71493>>>>
71493>>>        End
71493>>>>
71493>>>        End
71493>>>>
71493>>>
71493>>>        Move (sHomePath + CS_BackupFolder + CS_DirSeparator + sPath) to sBackupFolder
71494>>>        Get RemoveFolderSeperator of ghoFileSystem sBackupFolder to sBackupFolder
71495>>>        Get vFolderExists sBackupFolder to bFolderExists
71496>>>        If (bFolderExists = False) Begin
71498>>>            Get DirectoryCreateEx of ghoFileSystem sBackupFolder False to bSuccess
71499>>>            If (bSuccess = False) Begin
71501>>>                Get YesNo_Box ("Warning! The" * String(sHomePath) + "\DFRefactor Backup folder could not be created. You should abort the program now, fix the cause and restart. Abort the program?") to iRetval
71502>>>                If (iRetval = MBR_Yes) Begin
71504>>>                    Send Exit_Application
71505>>>                End
71505>>>>
71505>>>            End
71505>>>>
71505>>>        End
71505>>>>
71505>>>        Get vFolderFormat sBackupFolder to sBackupFolder
71506>>>        Function_Return sBackupFolder
71507>>>    End_Function
71508>>>
71508>>>    Function IsBackupFolder Returns Boolean
71510>>>        String sHomePath sBackupFolder
71510>>>        Boolean bExists
71510>>>
71510>>>        Get psHomePath to sHomePath
71511>>>        Get vFolderFormat sHomePath to sHomePath
71512>>>        Move (sHomePath + CS_BackupFolder) to sBackupFolder
71513>>>        Get vFolderExists sBackupFolder to bExists
71514>>>
71514>>>        Function_Return bExists
71515>>>    End_Function
71516>>>
71516>>>    // Takes a source file name with full path as parameter.
71516>>>    // Returns a name with full path for it's backup file counterpart.
71516>>>    // If the backup folder doesn't exist, it will be created, aka
71516>>>    // the BackupFolder function is used.
71516>>>    Function BackupFileName String sPathFileName Returns String
71518>>>        String sBackupFolder sFileName sBackupFile
71518>>>        Integer iPos
71518>>>
71518>>>        Get CreateBackupFolder sPathFileName   to sBackupFolder
71519>>>        Get vFolderFormat sBackupFolder  to sBackupFolder
71520>>>        Get ParseFileName sPathFileName  to sFileName
71521>>>        Move (Pos(":", sFileName))       to iPos
71522>>>        If (iPos > 0) Begin
71524>>>            Move (Mid(sFileName, CI_EOL, iPos)) to sFileName
71525>>>        End
71525>>>>
71525>>>        Move (sBackupFolder + sFileName) to sBackupFile
71526>>>
71526>>>        Function_Return sBackupFile
71527>>>    End_Function
71528>>>
71528>>>    Function HomeBackupFilePath Returns String
71530>>>        Boolean bExist
71530>>>        String sPath sPathBackup
71530>>>
71530>>>        Get psHomePath to sPath
71531>>>        If (sPath <> "") Begin
71533>>>            Get vFolderFormat sPath to sPath
71534>>>            Move (sPath + CS_BackupFolder) to sPathBackup
71535>>>            Get FileExists of ghoFileSystem sPathBackup DIRMODE_DIRECTORIES_ONLY to bExist
71536>>>            If (bExist) Begin
71538>>>                Move sPathBackup to sPath
71539>>>            End
71539>>>>
71539>>>            Else Begin
71540>>>                Move "" to sPath
71541>>>            End
71541>>>>
71541>>>        End
71541>>>>
71541>>>        Function_Return sPath
71542>>>    End_Function
71543>>>
71543>>>    Function SaveBackupFile String sSourceFile Returns Boolean
71545>>>        Boolean bOK bExists bShouldBackup
71545>>>        String sBackupFile
71545>>>        Date dWriteSource dWriteBackup
71545>>>//        tFileTime ftCurrentTime  
71545>>>        structSystemTime ftCurrentTime
71545>>>        structSystemTime ftCurrentTime
71545>>>
71545>>>        Move True to bShouldBackup
71546>>>        Get BackupFileName sSourceFile to sBackupFile
71547>>>        Get FileExists of ghoFileSystem sBackupFile to bExists
71548>>>        If (bExists = True) Begin
71550>>>            Get FileDate of ghoFileSystem sSourceFile to dWriteSource
71551>>>            Get FileDate of ghoFileSystem sBackupFile to dWriteBackup
71552>>>            Move ((dWriteSource - dWriteBackup) > 2 or (dWriteBackup - dWriteSource) > 2) to bShouldBackup
71553>>>        End
71553>>>>
71553>>>
71553>>>        // If we make a backup copy of the file we change the date & time,
71553>>>        // to present time. This is so we later - if the 'Start Process' button is
71553>>>        // pressed again - decide to _not_ backup the file again iif it has todays,
71553>>>        // or yesterday's date. That way the user can press the "Start Process"
71553>>>        // button several times without the backup file gets overwritten by a
71553>>>        // file that has been changed all ready - keeping the original source file
71553>>>        // intact.
71553>>>        If (bShouldBackup = True) Begin
71555>>>            Get FileCopy of ghoFileSystem sSourceFile sBackupFile False to bOK
71556>>>            Get CurrentSystemTimeAsFileTime of ghoFileSystem to ftCurrentTime
71557>>>            Set FileLastWriteTime of ghoFileSystem to sBackupFile ftCurrentTime
71558>>>            Get FileExists of ghoFileSystem sBackupFile to bExists
71559>>>        End
71559>>>>
71559>>>
71559>>>        Function_Return bExists
71560>>>    End_Function
71561>>>
71561>>>    // Does a backup copy of the current source file exist?
71561>>>    Function IsBackupFile String sCurrentFileName Returns String
71563>>>        String sPath sFile sHomePath sBackupFolder sBackupFile sExt
71563>>>        Boolean bExists
71563>>>        tsSearchResult[] SearchResultArray
71563>>>        tsSearchResult[] SearchResultArray
71564>>>
71564>>>        If (sCurrentFileName = "") Begin
71566>>>            Function_Return ""
71567>>>        End
71567>>>>
71567>>>
71567>>>        Get psHomePath to sHomePath
71568>>>        Get ParseFolderName sCurrentFileName to sPath
71569>>>        Move (sHomePath + CS_BackupFolder) to sBackupFolder
71570>>>        Get vFolderExists sBackupFolder to bExists
71571>>>        If (bExists = False) Begin
71573>>>            Function_Return ""
71574>>>        End
71574>>>>
71574>>>
71574>>>        Move "" to sBackupFile
71575>>>        Get ParseFileName sCurrentFileName to sFile
71576>>>        Get ParseFileExtension sFile to sExt
71577>>>        Move (Replace(sExt, sFile, "")) to sFile
71578>>>        Get vFolderFormat sBackupFolder to sBackupFolder
71579>>>        Move (sBackupFolder + sFile + String("*")) to sFile
71580>>>        Get FileSearchRecursive of ghoFileSystem sFile DIRMODE_FILES_ONLY True to SearchResultArray
71581>>>        If (SizeOfArray(SearchResultArray)) Begin
71583>>>            Move SearchResultArray[0].sFilename to sBackupFile
71584>>>        End
71584>>>>
71584>>>
71584>>>        Function_Return sBackupFile
71585>>>    End_Function
71586>>>
71586>>>    Function AllBackupFolderFiles Returns tsSearchResult[]
71588>>>        Boolean bExists
71588>>>        String sBackupHomeFolder sBackupFolder sHomePath sFileMask sFileName
71588>>>        String[] asNoFolderSearch asBackupFolders
71590>>>        tsSearchResult[] asBackupFilesEmpty asBackupFiles asBackupFilesTotal
71590>>>        tsSearchResult[] asBackupFilesEmpty asBackupFiles asBackupFilesTotal
71593>>>        Integer iFolder iFolders iFile iFiles
71593>>>
71593>>>        Get psHomePath to sHomePath
71594>>>        Get vFolderFormat sHomePath to sHomePath
71595>>>        Move (sHomePath + CS_BackupFolder) to sBackupHomeFolder
71596>>>        Get vFolderExists sBackupHomeFolder to bExists
71597>>>        If (bExists = False) Begin
71599>>>            Function_Return asBackupFilesEmpty
71600>>>        End
71600>>>>
71600>>>
71600>>>        Get NoFolderListAsArray True to asNoFolderSearch
71601>>>        Get RecursiveSearchFolders sBackupHomeFolder asNoFolderSearch to asBackupFolders
71602>>>        Move (SizeOfArray(asBackupFolders)) to iFolders
71603>>>        Decrement iFolders
71604>>>        For iFolder from 0 to iFolders
71610>>>>
71610>>>            Move asBackupFolders[iFolder] to sBackupFolder
71611>>>            Get vFolderFormat sBackupFolder to sBackupFolder
71612>>>            Move (sBackupFolder + "*.*") to sFileMask
71613>>>
71613>>>            // File loop:
71613>>>            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asBackupFiles
71614>>>            // Remove report files created by the DFRefactor tool.
71614>>>            If (SizeOfArray(asBackupFiles)) Begin
71616>>>                If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_SummaryLogfileName) Begin
71618>>>                    Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
71619>>>                    If (SizeOfArray(asBackupFiles)) Begin
71621>>>                        If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_UnusedSourceLogFile) Begin
71623>>>                            Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
71624>>>                        End
71624>>>>
71624>>>                    End
71624>>>>
71624>>>                End
71624>>>>
71624>>>            End
71624>>>>
71624>>>            Move (SizeOfArray(asBackupFiles)) to iFiles
71625>>>            Decrement iFiles
71626>>>            For iFile from 0 to iFiles
71632>>>>
71632>>>                Move asBackupFiles[iFile].sFilename to sFileName
71633>>>                // Store the path in the sAlternateFileName struct item
71633>>>                Move sBackupFolder to asBackupFiles[iFile].sAlternateFileName
71634>>>            Loop
71635>>>>
71635>>>            Move (AppendArray(asBackupFilesTotal, asBackupFiles)) to asBackupFilesTotal
71636>>>        Loop
71637>>>>
71637>>>
71637>>>        Function_Return asBackupFilesTotal
71638>>>    End_Function
71639>>>
71639>>>    Function AllSourceFolders String[] asSelectedFolders Returns String[]
71641>>>        String sHomePath
71641>>>        String[] asNoFolderSearch asSourceFolders asAllSourceFolders
71644>>>        Integer iSize iCount
71644>>>
71644>>>        Get psHomePath to sHomePath
71645>>>        Get vFolderFormat sHomePath to sHomePath
71646>>>
71646>>>        Get NoFolderListAsArray False to asNoFolderSearch
71647>>>        Move (SizeOfArray(asSelectedFolders)) to iSize
71648>>>        Decrement iSize
71649>>>        For iCount from 0 to iSize
71655>>>>
71655>>>            Get RecursiveSearchFolders asSelectedFolders[iCount] asNoFolderSearch to asSourceFolders
71656>>>            Move (AppendArray(asAllSourceFolders, asSourceFolders)) to asAllSourceFolders
71657>>>        Loop
71658>>>>
71658>>>
71658>>>        Function_Return asAllSourceFolders
71659>>>    End_Function
71660>>>
71660>>>    Function AllSourceFiles String[] asSelectedFolders String sFileFilter Returns tsSearchResult[]
71662>>>        Boolean bIsFileInFilter
71662>>>        String sSourceFolder sFileMask sFileName
71662>>>        String[] asAllSourceFolders
71663>>>        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
71663>>>        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
71666>>>        Integer iFolder iFolders iFile iFiles
71666>>>
71666>>>        Move asSelectedFolders to asAllSourceFolders
71667>>>        Move (SizeOfArray(asAllSourceFolders)) to iFolders
71668>>>        Decrement iFolders
71669>>>
71669>>>        // Folder loop:
71669>>>        For iFolder from 0 to iFolders
71675>>>>
71675>>>            Move asAllSourceFolders[iFolder] to sSourceFolder
71676>>>            Get vFolderFormat sSourceFolder to sSourceFolder
71677>>>            Move (sSourceFolder + "*.*") to sFileMask
71678>>>
71678>>>            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asSourceFiles
71679>>>            Move (SizeOfArray(asSourceFiles)) to iFiles
71680>>>            Decrement iFiles
71681>>>
71681>>>            // File loop:
71681>>>            For iFile from 0 to iFiles
71687>>>>
71687>>>                Move asSourceFiles[iFile].sFilename to sFileName
71688>>>                Get IsFileInFilter sFileName sFileFilter to bIsFileInFilter
71689>>>                If (bIsFileInFilter = True) Begin
71691>>>                    // Store the path in the sAlternateFileName struct item
71691>>>                    Move sSourceFolder to asSourceFiles[iFile].sAlternateFileName
71692>>>                End
71692>>>>
71692>>>                Else Begin
71693>>>                    Move (RemoveFromArray(asSourceFiles, iFile)) to asSourceFiles
71694>>>                    Decrement iFile
71695>>>                    Decrement iFiles
71696>>>                End
71696>>>>
71696>>>            Loop
71697>>>>
71697>>>            Move (AppendArray(asSourceFilesTotal, asSourceFiles)) to asSourceFilesTotal
71698>>>        Loop
71699>>>>
71699>>>
71699>>>        Function_Return asSourceFilesTotal
71700>>>    End_Function
71701>>>
71701>>>    Function IsFileInFilter String sFileName String sFileFilter Returns Boolean
71703>>>        Integer iSearchIndex
71703>>>        String sExtension sChar
71703>>>        String[] asFileFilter
71704>>>
71704>>>        Move (Lowercase(sFileName))      to sFileName
71705>>>        Get ParseFileExtension sFileName to sExtension
71706>>>        Move (Left(sExtension, 1))       to sChar
71707>>>        If (sChar <> ".") Begin
71709>>>            Move ("." + String(sExtension)) to sExtension
71710>>>        End
71710>>>>
71710>>>        Move (Lowercase(sFileFilter))         to sFileFilter
71711>>>        Move (Replaces("*", sFileFilter, "")) to sFileFilter
71712>>>        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilter
71713>>>        Move (SearchArray(sExtension, asFileFilter)) to iSearchIndex
71714>>>        Function_Return (iSearchIndex <> -1)
71715>>>    End_Function
71716>>>
71716>>>    Function RecursiveSearchFolders String sSourceFolder String[] asNoFolderList Returns String[]
71718>>>        Boolean bFound
71718>>>        Integer iCount iSize iItem
71718>>>        String sMask sFileName sPrevFolderName sHomePath
71718>>>        tsSearchResult[] asSearchResult
71718>>>        tsSearchResult[] asSearchResult
71719>>>        String[] saSearchFolders
71720>>>
71720>>>        If (not(sSourceFolder contains ":")) Begin
71722>>>            Get psHomePath to sHomePath
71723>>>            Get vFolderFormat sHomePath to sHomePath
71724>>>            Move (sHomePath + sSourceFolder) to sSourceFolder
71725>>>        End
71725>>>>
71725>>>        Get vFolderFormat sSourceFolder to sSourceFolder
71726>>>        Move (sSourceFolder + "*") to sMask
71727>>>
71727>>>        Move 0 to iItem
71728>>>
71728>>>        // Recursive folder search
71728>>>        Get FileSearchRecursive of ghoFileSystem sMask DIRMODE_DIRECTORIES_ONLY False to asSearchResult
71729>>>        Move (SizeOfArray(asSearchResult)) to iSize
71730>>>        Decrement iSize
71731>>>
71731>>>        // Remove folder names from array where we should not search for source files
71731>>>        Move "" to sPrevFolderName
71732>>>        For iCount from 0 to iSize
71738>>>>
71738>>>            Get IsFolderInNoFolderList of ghoApplication asNoFolderList asSearchResult[iCount].sFilename to bFound
71739>>>            If (bFound = False) Begin
71741>>>                If (asSearchResult[iCount].sFilename <> sPrevFolderName) Begin
71743>>>                    Move asSearchResult[iCount].sFilename to saSearchFolders[iItem]
71744>>>                    Increment iItem
71745>>>                End
71745>>>>
71745>>>            End
71745>>>>
71745>>>            Move asSearchResult[iCount].sFilename to sPrevFolderName
71746>>>        Loop
71747>>>>
71747>>>
71747>>>        Move sSourceFolder to saSearchFolders[SizeOfArray(saSearchFolders)]
71748>>>        // Sort the folder array to get the top one first.
71748>>>        Move (SortArray(saSearchFolders)) to saSearchFolders
71749>>>
71749>>>        Function_Return saSearchFolders
71750>>>    End_Function
71751>>>
71751>>>    Procedure ComparePaths String sCompareApp
71753>>>        String sPath sPathBackup
71753>>>
71753>>>        Get psHomePath to sPath
71754>>>        Get HomeBackupFilePath to sPathBackup
71755>>>        If (sPath <> "" and sPathBackup <> "") Begin
71757>>>            Runprogram Background ('"' + sCompareApp + '"') ('"' + sPath + '" "' + sPathBackup + '"')
71758>>>        End
71758>>>>
71758>>>    End_Procedure
71759>>>
71759>>>    Procedure CompareFiles String sCompareApp
71761>>>        Boolean bExist
71761>>>        String sFileName sFile sFileBackup sCurrentFileName
71761>>>
71761>>>        Get psCurrentSourceFileName to sFileName
71762>>>        If (sFileName <> "") Begin
71764>>>            Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bExist
71765>>>            If (bExist) Begin
71767>>>                Get psCurrentSourceFileName to sCurrentFileName
71768>>>                Get IsBackupFile sCurrentFileName to sFileBackup
71769>>>                If (sFileBackup <> "") Begin
71771>>>                    Runprogram Background ('"' + sCompareApp + '"') ('"' + sFileName + '" "' + sFileBackup + '"')
71772>>>                End
71772>>>>
71772>>>                Else Begin
71773>>>                    Send Info_Box ("Cannot find the backup file file" * sFileBackup)
71774>>>                End
71774>>>>
71774>>>            End
71774>>>>
71774>>>            Else Begin
71775>>>                Send Info_Box ("The file in the source file" * sFileName * "\nDoes not exist.")
71776>>>            End
71776>>>>
71776>>>        End
71776>>>>
71776>>>        Else Begin
71777>>>            Send Info_Box "You have to select a file first."
71778>>>        End
71778>>>>
71778>>>    End_Procedure
71779>>>
71779>>>    // Returns the current Studio "File mask" setting as a string. See
71779>>>    Function StudioFileMaskSettings Returns String
71781>>>        Handle hoReg
71781>>>        String sStudioRegPath sRetval sDFVersion
71781>>>        Boolean bExists bOk
71781>>>        Integer iMajorVersion iMinorVersion
71781>>>
71781>>>        Move FMAC_VERSION  to iMajorVersion
71782>>>        Move FMAC_REVISION to iMinorVersion
71783>>>        Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sDFVersion
71784>>>
71784>>>        Get Create (RefClass(cRegistry)) to hoReg
71785>>>        Set pfAccessRights of hoReg to Key_Read
71786>>>
71786>>>        Move CS_StudioToolsPathStart to sStudioRegPath
71787>>>        Move (sStudioRegPath + sDFVersion + CS_StudioToolsPathEnd) to sStudioRegPath
71788>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
71789>>>
71789>>>        // First check if the DF version is installed
71789>>>        Get KeyExists of hoReg sStudioRegPath to bExists
71790>>>        If (bExists = False) Begin
71792>>>            Send Destroy of hoReg
71793>>>            Function_Return cx_RegKeyDFKeyDoesNotExist
71794>>>        End
71794>>>>
71794>>>
71794>>>        Get OpenKey of hoReg sStudioRegPath to bOk
71795>>>        If (bOk = True) Begin
71797>>>            Set pfAccessRights of hoReg to KEY_READ
71798>>>            Get ReadString of hoReg CS_DFExtensionsKey to sRetval
71799>>>        End
71799>>>>
71799>>>
71799>>>        Send CloseKey of hoReg
71800>>>        Send Destroy of hoReg
71801>>>        Function_Return sRetval
71802>>>    End_Function
71803>>>
71803>>>    Function StudioFileExtensions String sDFVersion Returns String
71805>>>        Handle hoReg
71805>>>        String sStudioRegPath  sRetval
71805>>>        Boolean bExists bOk
71805>>>
71805>>>        Get Create (RefClass(cRegistry)) to hoReg
71806>>>        Move CS_StudioPath to sStudioRegPath
71807>>>        If (sDFVersion > "17.1") Begin
71809>>>            Move (Replace("Visual ", sStudioRegPath, "")) to sStudioRegPath
71810>>>        End
71810>>>>
71810>>>        Move (sStudioRegPath + sDFVersion + CS_StudioPathEnd) to sStudioRegPath
71811>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
71812>>>
71812>>>        // First check if the DF version is installed
71812>>>        Get KeyExists of hoReg sStudioRegPath to bExists
71813>>>        If (bExists = False) Begin
71815>>>            Send Destroy of hoReg
71816>>>            Function_Return cx_RegKeyDFKeyDoesNotExist
71817>>>        End
71817>>>>
71817>>>
71817>>>        Get OpenKey of hoReg sStudioRegPath to bOk
71818>>>        If (bOk = True) Begin
71820>>>            Set pfAccessRights of hoReg to KEY_READ
71821>>>            // In the Studio this key is still call "VDF".
71821>>>            Get ReadString of hoReg "VdfExtensions" to sRetval
71822>>>        End
71822>>>>
71822>>>
71822>>>        Send CloseKey of hoReg
71823>>>        Send Destroy of hoReg
71824>>>        Function_Return (Trim(sRetval))
71825>>>    End_Function
71826>>>
71826>>>    Function NoFolderListAsArray Boolean bNoBackupFolder Returns String[]
71828>>>        String sNoFolderList
71828>>>        String[] saNoFolderList
71829>>>
71829>>>        Move CS_NoFolderList to sNoFolderList
71830>>>        If (bNoBackupFolder = False) Begin
71832>>>            Move (sNoFolderList + "|" + CS_BackupFolder) to sNoFolderList
71833>>>        End
71833>>>>
71833>>>        Move (Lowercase(sNoFolderList)) to sNoFolderList
71834>>>        Move (StrSplitToArray(sNoFolderList, "|")) to saNoFolderList
71835>>>        Function_Return saNoFolderList
71836>>>    End_Function
71837>>>
71837>>>    // Returns True if the passed sFolderName exists in the passed string array.
71837>>>    Function IsFolderInNoFolderList String[] saNoFolderList String sFolderName Returns Boolean
71839>>>        Integer iSize iCount iIndex iCurrentFolder
71839>>>        Boolean bOK bFound
71839>>>        String sNoFolder sFolderNameShort
71839>>>        String[] saFolderList
71840>>>
71840>>>        Move False to bOK
71841>>>        Move (SearchArray(".",  saNoFolderList)) to iCurrentFolder
71842>>>        Move (iCurrentFolder <> -1) to bFound
71843>>>        If (bFound = True) Begin
71845>>>            // We need to remove "." from the array to avoid problems with folders containing a "."
71845>>>            Move (RemoveFromArray(saNoFolderList, iCurrentFolder)) to saNoFolderList
71846>>>            // The rightmost folder name:
71846>>>            Get ParseFileName sFolderName to sFolderNameShort
71847>>>            Move (sFolderNameShort = ".." or sFolderNameShort = ".") to bOK // Then we're done
71848>>>        End
71848>>>>
71848>>>
71848>>>        If (bOK = False) Begin
71850>>>            Move (Lowercase(sFolderName)) to sFolderName
71851>>>            Move (StrSplitToArray(sFolderName, CS_DirSeparator)) to saFolderList
71852>>>            Move (Lowercase(sFolderName)) to sFolderName
71853>>>            Move (SizeOfArray(saNoFolderList)) to iSize
71854>>>            Decrement iSize
71855>>>            For iCount from 0 to iSize
71861>>>>
71861>>>                Move (Lowercase(saNoFolderList[iCount])) to sNoFolder
71862>>>                Move (SearchArray(sNoFolder, saFolderList)) to iIndex
71863>>>                If (iIndex <> -1) Begin
71865>>>                    Move True to bOK
71866>>>                End
71866>>>>
71866>>>                If (bOK = True) Break
71869>>>            Loop
71870>>>>
71870>>>        End
71870>>>>
71870>>>
71870>>>        Function_Return bOK
71871>>>    End_Function
71872>>>
71872>>>    Function IsFolderInDefaultsFolderList String sFolderName Returns Boolean
71874>>>        Integer iSize iCount iIndex
71874>>>        Boolean bOK
71874>>>        String sDefaultFolders
71874>>>        String[] saDefaultFolderList saFolderList
71876>>>
71876>>>        Move False to bOK
71877>>>        Move -1 to iIndex
71878>>>
71878>>>        Move CS_DefaultSourceFolders to sDefaultFolders
71879>>>        Move (Lowercase(sDefaultFolders)) to sDefaultFolders
71880>>>        Move (StrSplitToArray(sDefaultFolders, "|")) to saDefaultFolderList
71881>>>
71881>>>        Move (Lowercase(sFolderName)) to sFolderName
71882>>>        Move (StrSplitToArray(sFolderName, "\")) to saFolderList
71883>>>
71883>>>        Move (SizeOfArray(saFolderList)) to iSize
71884>>>        Decrement iSize
71885>>>        For iCount from 0 to iSize
71891>>>>
71891>>>            Move saFolderList[iCount] to sFolderName
71892>>>            Move (SearchArray(sFolderName, saDefaultFolderList)) to iIndex
71893>>>            If (iIndex <> -1) Begin
71895>>>                Move True to bOK
71896>>>            End
71896>>>>
71896>>>            If (bOK = True) Break
71899>>>        Loop
71900>>>>
71900>>>
71900>>>        Function_Return bOK
71901>>>    End_Function
71902>>>
71902>>>End_Class
71903>Use cCJStandardCommandBarSystem.pkg 
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
71903>>>// these are all the packages used in a standard MDI menubar/toolbar system
71903>>>
71903>>>Use cCJCommandBarSystem.pkg
71903>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
71903>>>>>Use Dfpanel.pkg
71903>>>>>Use cCJCommandBarSystem.pkg
71903>>>>>Use LanguageText.pkg
71903>>>>>
71903>>>>>
71903>>>>>Class cCJUndoMenuItem is a cCJMenuItem
71904>>>>>    
71904>>>>>    Procedure Construct_Object
71906>>>>>        Forward Send Construct_Object
71908>>>>>        Set psCaption   to C_$CaptionUndo
71909>>>>>        Set psToolTip to C_$ToolTipUndo
71910>>>>>        Set psDescription to C_$DescUndo
71911>>>>>        Set psImage to "ActionUndo.ico"
71912>>>>>        Set pbActiveUpdate to True
71913>>>>>        Set psCategory to C_$CategoryEdit
71914>>>>>        Set psShortcut to C_$Key_Ctrl_Z
71915>>>>>    End_Procedure
71916>>>>>    
71916>>>>>    Procedure OnExecute Variant vCommandBarControl
71918>>>>>        Send Undo of (focus(Self))
71919>>>>>    End_Procedure
71920>>>>>    
71920>>>>>    Function IsEnabled Returns Boolean
71922>>>>>        Boolean bEnabled
71922>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
71923>>>>>        Function_Return bEnabled
71924>>>>>    End_Function
71925>>>>>    
71925>>>>>End_Class
71926>>>>>
71926>>>>>
71926>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
71927>>>>>    
71927>>>>>    Procedure Construct_Object
71929>>>>>        Forward Send Construct_Object
71931>>>>>        Set psCaption   to C_$CaptionDelete
71932>>>>>        Set psToolTip to C_$ToolTipDelete
71933>>>>>        Set psDescription to C_$DescDelete
71934>>>>>        Set psImage to "actionDelete.ico"
71935>>>>>        Set psShortcut to C_$Key_Delete
71936>>>>>        Set pbActiveUpdate to True
71937>>>>>        Set psCategory to C_$CategoryEdit
71938>>>>>    End_Procedure
71939>>>>>    
71939>>>>>    
71939>>>>>    Procedure OnExecute Variant vCommandBarControl
71941>>>>>        Send Delete of (focus(Self))
71942>>>>>    End_Procedure
71943>>>>>    
71943>>>>>    Function IsEnabled Returns Boolean
71945>>>>>        Boolean bEnabled
71945>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
71946>>>>>        Function_Return bEnabled
71947>>>>>    End_Function
71948>>>>>    
71948>>>>>End_Class
71949>>>>>
71949>>>>>
71949>>>>>Class cCJCutMenuItem is a cCJMenuItem
71950>>>>>    
71950>>>>>    Procedure Construct_Object
71952>>>>>        Forward Send Construct_Object
71954>>>>>        Set psCaption   to C_$CaptionCut
71955>>>>>        Set psToolTip to C_$TooltipCut
71956>>>>>        Set psDescription to C_$DescCut
71957>>>>>        Set psImage to "actionCut.ico"
71958>>>>>        Set psShortcut to C_$Key_Ctrl_X
71959>>>>>        Set pbActiveUpdate to True
71960>>>>>        Set psCategory to C_$CategoryEdit
71961>>>>>    End_Procedure
71962>>>>>    
71962>>>>>    
71962>>>>>    Procedure OnExecute Variant vCommandBarControl
71964>>>>>        Send Cut of (focus(Self))
71965>>>>>    End_Procedure
71966>>>>>    
71966>>>>>    Function IsEnabled Returns Boolean
71968>>>>>        Boolean bEnabled
71968>>>>>        Get CanCut of (Focus(Self)) to bEnabled
71969>>>>>        Function_Return bEnabled
71970>>>>>    End_Function
71971>>>>>    
71971>>>>>End_Class
71972>>>>>
71972>>>>>
71972>>>>>Class cCJCopyMenuItem is a cCJMenuItem
71973>>>>>    
71973>>>>>    Procedure Construct_Object
71975>>>>>        Forward Send Construct_Object
71977>>>>>        Set psCaption   to C_$CaptionCopy
71978>>>>>        Set psToolTip to C_$ToolTipCopy
71979>>>>>        Set psDescription to C_$DescCopy
71980>>>>>        Set psImage to "actionCopy.ico"
71981>>>>>        Set psShortcut to C_$Key_Ctrl_C
71982>>>>>        Set pbActiveUpdate to True
71983>>>>>        Set psCategory to C_$CategoryEdit
71984>>>>>    End_Procedure
71985>>>>>    
71985>>>>>    
71985>>>>>    Procedure OnExecute Variant vCommandBarControl
71987>>>>>        Send Copy of (focus(Self))
71988>>>>>    End_Procedure
71989>>>>>    
71989>>>>>    Function IsEnabled Returns Boolean
71991>>>>>        Boolean bEnabled
71991>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
71992>>>>>        Function_Return bEnabled
71993>>>>>    End_Function
71994>>>>>    
71994>>>>>End_Class
71995>>>>>
71995>>>>>
71995>>>>>Class cCJPasteMenuItem is a cCJMenuItem
71996>>>>>    
71996>>>>>    Procedure Construct_Object
71998>>>>>        Forward Send Construct_Object
72000>>>>>        Set psCaption   to C_$CaptionPaste
72001>>>>>        Set psToolTip to C_$ToolTipPaste
72002>>>>>        Set psDescription to C_$DescPaste
72003>>>>>        Set psImage to "actionPaste.ico"
72004>>>>>        Set pbActiveUpdate to True
72005>>>>>        Set psShortcut to C_$Key_Ctrl_V
72006>>>>>        Set psCategory to C_$CategoryEdit
72007>>>>>    End_Procedure
72008>>>>>    
72008>>>>>    
72008>>>>>    Procedure OnExecute Variant vCommandBarControl
72010>>>>>        Send Paste of (focus(Self))
72011>>>>>    End_Procedure
72012>>>>>    
72012>>>>>    Function IsEnabled Returns Boolean
72014>>>>>        Boolean bEnabled
72014>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
72015>>>>>        Function_Return bEnabled
72016>>>>>    End_Function
72017>>>>>    
72017>>>>>End_Class
72018>>>>>
72018>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
72019>>>>>    
72019>>>>>    Procedure Construct_Object
72021>>>>>        Forward Send Construct_Object
72023>>>>>        Set psCaption   to C_$CaptionSelectAll
72024>>>>>        Set psToolTip to C_$ToolTipSelectAll
72025>>>>>        Set psDescription to C_$DescSelectAll
72026>>>>>        Set pbActiveUpdate to True
72027>>>>>        Set psShortcut to C_$Key_Ctrl_A
72028>>>>>        Set psCategory to C_$CategoryEdit
72029>>>>>    End_Procedure
72030>>>>>    
72030>>>>>    
72030>>>>>    Procedure OnExecute Variant vCommandBarControl
72032>>>>>        Send Select_All of (focus(Self))
72033>>>>>    End_Procedure
72034>>>>>    
72034>>>>>    Function IsEnabled Returns Boolean
72036>>>>>        Boolean bEnabled
72036>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
72037>>>>>        Function_Return bEnabled
72038>>>>>    End_Function
72039>>>>>    
72039>>>>>End_Class
72040>>>>>
72040>>>>>
72040>>>>>Class cCJExitMenuItem is a cCJMenuItem
72041>>>>>    
72041>>>>>    Procedure Construct_Object
72043>>>>>        Forward Send Construct_Object
72045>>>>>        Set psCaption to C_$CaptionExit
72046>>>>>        Set psToolTip to C_$ToolTipExit
72047>>>>>        Set psDescription to C_$ToolTipExit
72048>>>>>        Set psShortcut to C_$Key_Alt_F4
72049>>>>>        Set psCategory to C_$CategoryFile
72050>>>>>    End_Procedure
72051>>>>>    
72051>>>>>    Procedure OnExecute Variant vCommandBarControl
72053>>>>>        Send Exit_Application of Desktop
72054>>>>>    End_Procedure
72055>>>>>    
72055>>>>>End_Class
72056>>>>>
72056>>>>>Class cCJHelpMenuItem is a cCJMenuItem
72057>>>>>    
72057>>>>>    Procedure Construct_Object
72059>>>>>        Forward Send Construct_Object
72061>>>>>        Set psCaption to C_$CaptionHelp
72062>>>>>        Set psDescription to C_$ToolTipHelp
72063>>>>>        Set psToolTip to C_$DescHelp
72064>>>>>        Set psImage to "ActionHelp.ico"
72065>>>>>        Set psShortcut to "F1"
72066>>>>>        Set psCategory to C_$CategoryHelp
72067>>>>>    End_Procedure
72068>>>>>    
72068>>>>>    Procedure OnExecute Variant vCommandBarControl
72070>>>>>        Send Help of (Focus(Self))
72071>>>>>    End_Procedure
72072>>>>>    
72072>>>>>End_Class
72073>>>>>
72073>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
72074>>>>>    
72074>>>>>    Procedure Construct_Object
72076>>>>>        Forward Send Construct_Object
72078>>>>>        Set psCaption to C_$CaptionAddStatusbar
72079>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
72080>>>>>        Set psDescription to  C_$DescAddStatusbar
72081>>>>>        Set psCategory to C_$CategoryWindow
72082>>>>>    End_Procedure
72083>>>>>    
72083>>>>>    Procedure OnExecute Variant vCommandBarControl
72085>>>>>        Handle hoCommandBars hoClientArea
72085>>>>>        Get CommandBarSystemObject to hoCommandBars
72086>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72087>>>>>        If hoClientArea Begin
72089>>>>>            // the clientarea's parent panel has message
72089>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
72090>>>>>        End
72090>>>>>>
72090>>>>>    End_Procedure
72091>>>>>    
72091>>>>>    Function IsChecked Returns Boolean
72093>>>>>        Boolean bOn
72093>>>>>        Handle hoCommandBars hoClientArea
72093>>>>>        Get CommandBarSystemObject to hoCommandBars
72094>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72095>>>>>        If hoClientArea Begin
72097>>>>>            // the clientarea's parent panel has message
72097>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
72098>>>>>        End
72098>>>>>>
72098>>>>>        Function_Return bOn
72099>>>>>    End_Function
72100>>>>>End_Class
72101>>>>>
72101>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
72102>>>>>    
72102>>>>>    Procedure Construct_Object
72104>>>>>        Forward Send Construct_Object
72106>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
72107>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
72108>>>>>        Set psDescription to C_$DescAutoArrangeIcons
72109>>>>>        Set psCategory to C_$CategoryWindow
72110>>>>>    End_Procedure
72111>>>>>    
72111>>>>>    Procedure OnExecute Variant vCommandBarControl
72113>>>>>        Handle hoCommandBars hoClientArea
72113>>>>>        Get CommandBarSystemObject to hoCommandBars
72114>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72115>>>>>        If hoClientArea Begin
72117>>>>>            // the clientarea's parent panel has message
72117>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
72118>>>>>        End
72118>>>>>>
72118>>>>>    End_Procedure
72119>>>>>    
72119>>>>>    Function IsChecked Returns Boolean
72121>>>>>        Boolean bOn
72121>>>>>        Handle hoCommandBars hoClientArea
72121>>>>>        Get CommandBarSystemObject to hoCommandBars
72122>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72123>>>>>        If hoClientArea Begin
72125>>>>>            // the clientarea's parent panel has message
72125>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
72126>>>>>        End
72126>>>>>>
72126>>>>>        Function_Return bOn
72127>>>>>    End_Function
72128>>>>>End_Class
72129>>>>>
72129>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
72130>>>>>    
72130>>>>>    Procedure Construct_Object
72132>>>>>        Forward Send Construct_Object
72134>>>>>        Set psCaption to C_$CaptionRestoreMenus
72135>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
72136>>>>>        Set psDescription to C_$DescRestoreMenus
72137>>>>>        Set psCategory to C_$CategoryWindow
72138>>>>>    End_Procedure
72139>>>>>    
72139>>>>>    Procedure OnExecute Variant vCommandBarControl
72141>>>>>        Handle hoCommandBars
72141>>>>>        Get CommandBarSystemObject to hoCommandBars
72142>>>>>        Send RestoreLayout of hoCommandBars
72143>>>>>    End_Procedure
72144>>>>>    
72144>>>>>End_Class
72145>>>>>
72145>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
72146>>>>>    
72146>>>>>    Procedure Construct_Object
72148>>>>>        Forward Send Construct_Object
72150>>>>>        Set psCaption to C_$CaptionCascade
72151>>>>>        Set psToolTip to C_$ToolTipCascade
72152>>>>>        Set psDescription to  C_$DescCascade
72153>>>>>        Set psImage to "ActionCascade.ico"
72154>>>>>        Set psCategory to C_$CategoryWindow
72155>>>>>    End_Procedure
72156>>>>>    
72156>>>>>    Procedure OnExecute Variant vCommandBarControl
72158>>>>>        Handle hoCommandBars hoClientArea
72158>>>>>        Get CommandBarSystemObject to hoCommandBars
72159>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72160>>>>>        If hoClientArea Begin
72162>>>>>            Send Cascade_Windows of hoClientArea
72163>>>>>        End
72163>>>>>>
72163>>>>>    End_Procedure
72164>>>>>End_Class
72165>>>>>
72165>>>>>Class cCJTileHorizontally is a cCJMenuItem
72166>>>>>    
72166>>>>>    Procedure Construct_Object
72168>>>>>        Forward Send Construct_Object
72170>>>>>        Set psCaption to C_$CaptionTileHorizontally
72171>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
72172>>>>>        Set psDescription to  C_$DescTileHorizontally
72173>>>>>        Set psImage to "ActionTileHorizontally.ico"
72174>>>>>        Set psCategory to C_$CategoryWindow
72175>>>>>    End_Procedure
72176>>>>>    
72176>>>>>    Procedure OnExecute Variant vCommandBarControl
72178>>>>>        Handle hoCommandBars hoClientArea
72178>>>>>        Get CommandBarSystemObject to hoCommandBars
72179>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72180>>>>>        If hoClientArea Begin
72182>>>>>            Send Tile_Windows_Horizontal of hoClientArea
72183>>>>>        End
72183>>>>>>
72183>>>>>    End_Procedure
72184>>>>>End_Class
72185>>>>>
72185>>>>>Class cCJTileVertically is a cCJMenuItem
72186>>>>>    
72186>>>>>    Procedure Construct_Object
72188>>>>>        Forward Send Construct_Object
72190>>>>>        Set psCaption to C_$CaptionTileVertically
72191>>>>>        Set psToolTip to C_$ToolTipTileVertically
72192>>>>>        Set psDescription to  C_$DescTileVertically
72193>>>>>        Set psImage to "ActionTileVertically.ico"
72194>>>>>        Set psCategory to C_$CategoryWindow
72195>>>>>    End_Procedure
72196>>>>>    
72196>>>>>    Procedure OnExecute Variant vCommandBarControl
72198>>>>>        Handle hoCommandBars hoClientArea
72198>>>>>        Get CommandBarSystemObject to hoCommandBars
72199>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72200>>>>>        If hoClientArea Begin
72202>>>>>            Send Tile_Windows_Vertical of hoClientArea
72203>>>>>        End
72203>>>>>>
72203>>>>>    End_Procedure
72204>>>>>End_Class
72205>>>>>
72205>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
72206>>>>>    
72206>>>>>    Procedure Construct_Object
72208>>>>>        Forward Send Construct_Object
72210>>>>>        Set psCaption to C_$CaptionMinimizeWindows
72211>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
72212>>>>>        Set psDescription to  C_$DescMinimizeWindows
72213>>>>>        Set psCategory to C_$CategoryWindow
72214>>>>>    End_Procedure
72215>>>>>    
72215>>>>>    Procedure OnExecute Variant vCommandBarControl
72217>>>>>        Handle hoCommandBars hoClientArea
72217>>>>>        Get CommandBarSystemObject to hoCommandBars
72218>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72219>>>>>        If hoClientArea Begin
72221>>>>>            // the clientarea's parent panel has message
72221>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
72222>>>>>        End
72222>>>>>>
72222>>>>>    End_Procedure
72223>>>>>End_Class
72224>>>>>
72224>>>>>
72224>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
72225>>>>>    
72225>>>>>    Procedure Construct_Object
72227>>>>>        Forward Send Construct_Object
72229>>>>>        Set psCaption to C_$CaptionRestoreWindows
72230>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
72231>>>>>        Set psDescription to  C_$DescRestoreWindows
72232>>>>>        Set psCategory to C_$CategoryWindow
72233>>>>>    End_Procedure
72234>>>>>    
72234>>>>>    Procedure OnExecute Variant vCommandBarControl
72236>>>>>        Handle hoCommandBars hoClientArea
72236>>>>>        Get CommandBarSystemObject to hoCommandBars
72237>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72238>>>>>        If hoClientArea Begin
72240>>>>>            // the clientarea's parent panel has message
72240>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
72241>>>>>        End
72241>>>>>>
72241>>>>>    End_Procedure
72242>>>>>End_Class
72243>>>>>
72243>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
72244>>>>>    
72244>>>>>    Procedure Construct_Object
72246>>>>>        Forward Send Construct_Object
72248>>>>>        Set psCaption to C_$CaptionArrangeIcons
72249>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
72250>>>>>        Set psDescription to  C_$DescArrangeIcons
72251>>>>>        Set psCategory to C_$CategoryWindow
72252>>>>>    End_Procedure
72253>>>>>    
72253>>>>>    Procedure OnExecute Variant vCommandBarControl
72255>>>>>        Handle hoCommandBars hoClientArea
72255>>>>>        Get CommandBarSystemObject to hoCommandBars
72256>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72257>>>>>        If hoClientArea Begin
72259>>>>>            Send Arrange_Icons of hoClientArea
72260>>>>>        End
72260>>>>>>
72260>>>>>    End_Procedure
72261>>>>>    
72261>>>>>End_Class
72262>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
72262>>>>>Use cCJCommandBarSystem.pkg
72262>>>>>Use LanguageText.pkg
72262>>>>>
72262>>>>>// It is expected that if you use this class that you provide an about object that is
72262>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
72262>>>>>// because you may wish to create your own custom about package.
72262>>>>>
72262>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
72263>>>>>
72263>>>>>    Procedure Construct_Object
72265>>>>>        Forward Send Construct_Object
72267>>>>>        Set psCaption to C_$CaptionAbout
72268>>>>>        Set psDescription to C_$ToolTipAbout
72269>>>>>        Set psToolTip to C_$DescAbout
72270>>>>>        Set psImage to "ActionAbout.ico"
72271>>>>>        Set psCategory to C_$CategoryHelp
72272>>>>>    End_Procedure
72273>>>>>    
72273>>>>>    Procedure OnExecute Variant vCommandBarControl
72275>>>>>        Handle hoCommandBars hoClientArea
72275>>>>>        Get CommandBarSystemObject to hoCommandBars
72276>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
72277>>>>>        If hoClientArea Begin
72279>>>>>            Send Activate_About of hoClientArea
72280>>>>>        End
72280>>>>>>
72280>>>>>    End_Procedure
72281>>>>>
72281>>>>>End_Class
72282>>>>>
72282>>>>>
72282>>>Use cCJDeoMenuItemClasses.pkg
72282>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
72282>>>>>Use cCJCommandBarSystem.pkg
72282>>>>>
72282>>>>>Register_Function Client_ID Returns Integer
72282>>>>>
72282>>>>>// only used by cCJMDIWIndowsMenuItem
72282>>>>>Class cCJMDIWindowItem is a cCJMenuItem
72283>>>>>    
72283>>>>>    Procedure Construct_Object
72285>>>>>        Forward Send Construct_Object
72287>>>>>        Property Handle phWindow 0 // object id of view
72288>>>>>        Set pbControlFlagNoMovable to True
72289>>>>>        Set pbActiveUpdate to True
72290>>>>>    End_Procedure
72291>>>>>    
72291>>>>>    Procedure OnExecute Variant vCommandBarControl
72293>>>>>        Handle hWindow
72293>>>>>        Get phWindow to hWindow
72294>>>>>        Send Activate_View of hWindow
72295>>>>>    End_Procedure
72296>>>>>    
72296>>>>>End_Class
72297>>>>>
72297>>>>>
72297>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
72298>>>>>    
72298>>>>>    Procedure Construct_Object
72300>>>>>        Forward Send Construct_Object
72302>>>>>        Property Handle[] phArrayOfWindows
72303>>>>>        Set peControlType to xtpControlPopup
72304>>>>>        Set psCategory to C_$CategoryWindow
72305>>>>>    End_Procedure
72306>>>>>    
72306>>>>>    // This adds MDI windows to the existing menu items.
72306>>>>>    // This removes any existing windows menus and always adds a new set to the end
72306>>>>>    
72306>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
72308>>>>>        Handle  hClientArea hView
72308>>>>>        String  sLabel
72308>>>>>        Integer i iWindows
72308>>>>>        Handle[] hArrayOfWindows
72309>>>>>        Variant vItem
72309>>>>>        
72309>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
72309>>>>>        // also assume that destroying an action removes all menu instances of that action
72309>>>>>        Get phArrayOfWindows to hArrayOfWindows
72310>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
72311>>>>>        For i from 0 to (iWindows-1)
72317>>>>>>
72317>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
72318>>>>>        Loop
72319>>>>>>
72319>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
72320>>>>>        
72320>>>>>        // Add all views to this menu. Create the action and add the item
72320>>>>>        Move 0 to i
72321>>>>>        Get Client_Id to hClientArea // object id of client area
72322>>>>>        If (hClientArea > 0) Begin
72324>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
72325>>>>>            While (hView <> 0)
72329>>>>>                If (Active_State(hView)) Begin
72331>>>>>                    // create the action
72331>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
72332>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
72333>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
72334>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
72335>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
72337>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
72338>>>>>                    End
72338>>>>>>
72338>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
72339>>>>>                    If (i=0) Begin
72341>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
72342>>>>>                    End
72342>>>>>>
72342>>>>>                    // Create a menu item for this action
72342>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
72343>>>>>                    Increment i
72344>>>>>                End
72344>>>>>>
72344>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
72345>>>>>            Loop
72346>>>>>>
72346>>>>>        End
72346>>>>>>
72346>>>>>        
72346>>>>>        Set phArrayOfWindows to hArrayOfWindows
72347>>>>>        
72347>>>>>    End_Procedure
72348>>>>>    
72348>>>>>End_Class
72349>Use cCJCommandBarSystem.pkg
72349>Use gFormatNumbers.pkg
72349>Use vwin32fh.pkg
72349>Use RefactorFunctionConstants.inc
72349>Use cFilesystem.pkg
72349>
72349>Object oHtmlHelp is a cHtmlHelp
72351>    Set pbAlwaysOnTop to False
72352>End_Object
72353>
72353>Get Create (RefClass(cFilesystem)) to ghoFileSystem
72354>
72354>Object oApplication is a cRefactorApplication
72356>    Set psProduct to "Test Bench"
72357>    Set psCompany to "RDC Tools International"
72358>    Set psHelpFile to "DFRefactor.chm"
72359>    Set peHelpType to htHtmlHelp
72360>    
72360>    Property Boolean pbIsRefactoring False
72362>    Property String private.psFileCompareApp   
72364>    Property Handle phoTestView
72366>    Property String psLegacySourceFile    
72368>    Property String psRefactoredSourceFile
72370>    Property Handle phoEditorLegacy
72372>    Property Handle phoEditorRefactored    
72374>    Property Handle phoUseConstraints_cb
72376>    
72376>    // Just a stub message for the Scintilla editor inner workings. 
72376>    Procedure DisplayPerfCounters 
72379>    End_Procedure
72380>
72380>    Function psSWSFile Returns String
72383>        Function_Return (psWorkspaceWSFile(phoWorkspace(ghoApplication)))
72384>    End_Function   
72385>    
72385>    Procedure UpdateSourceFileNameDisplay String sFileName
72388>    End_Procedure
72389>
72389>    Function StartPerfCounter Integer eOperation String sComment Returns Integer
72392>        Function_Return 0
72393>    End_Function
72394>
72394>    Procedure StopPerfCounter Integer iCounter
72397>    End_Procedure
72398>    
72398>    Procedure Set psFileCompareApp String sProgramName
72401>        Send WriteString CS_Settings CS_FileCompareProgram sProgramName
72402>        Set private.psFileCompareApp to sProgramName
72403>    End_Procedure
72404>
72404>    Function psFileCompareApp Returns String
72407>        String sProgramName
72407>        Get private.psFileCompareApp to sProgramName
72408>        If (sProgramName = "") Begin
72410>            Get ReadString CS_Settings CS_FileCompareProgram "" to sProgramName
72411>            Set private.psFileCompareApp to sProgramName
72412>        End
72412>        Function_Return sProgramName
72413>    End_Function
72414>
72414>    Procedure CompareFiles
72417>        Boolean bExist bExist2
72417>        String sCompareApp sLegacyCodeFile sRefactoredCodeFile
72417>
72417>        Get psFileCompareApp to sCompareApp
72418>        File_Exist sCompareApp bExist
72419>        If (bExist = False) Begin
72421>            Send Info_Box "You need to specify the compare program first."
72422>            Procedure_Return
72423>        End
72423>
72423>        Get psCodeFile of (phoEditorLegacy(Self)) to sLegacyCodeFile                          
72424>        File_Exist sLegacyCodeFile bExist
72425>        Get psCodeFile of (phoEditorRefactored(Self)) to sRefactoredCodeFile
72426>        File_Exist sRefactoredCodeFile bExist2
72427>        If (bExist = False or bExist2 = False) Begin
72429>            Send Info_Box "You have to create the legacy and refactored source code files first."
72430>            Procedure_Return
72431>        End
72431>        
72431>        Runprogram Background ('"' + sCompareApp + '"') ('"' + sLegacyCodeFile + '" "' + sRefactoredCodeFile + '"')
72432>    End_Procedure
72433>
72433>    Procedure SaveCodeFiles
72436>        Handle hoEditor
72436>        Boolean bChanged
72436>
72436>        Get phoEditorLegacy to hoEditor
72437>        If (hoEditor) Begin
72439>            Send SaveFile of hoEditor
72440>        End
72440>        
72440>        Get phoEditorRefactored to hoEditor
72441>        If (hoEditor) Begin
72443>            Send SaveFile of hoEditor
72444>        End        
72444>    End_Procedure
72445>
72445>    Procedure CompileRefactoredCode
72448>        String sRefactoredFile sBinPath sHome sAppSrc sCompareApp
72448>        Boolean bExists bIsRefactoring
72448>        Integer iLines     
72448>        Handle ho
72448>        
72448>        Get pbIsRefactoring to bIsRefactoring
72449>        If (bIsRefactoring = True) Begin
72451>            Procedure_Return
72452>        End                 
72452>        
72452>        Get phoEditorRefactored to ho
72453>        Get Line_Count of ho to iLines
72454>        If (iLines <= 1) Begin
72456>            Send Info_Box "You need to press 'Refactor Legacy Code', or short-cut key (Ctrl+R)"
72457>            Procedure_Return
72458>        End
72458>        Get DFBinPath to sBinPath             
72459>        Get vFolderFormat sBinPath to sBinPath
72460>        Get psHome of (phoWorkspace(Self)) to sHome
72461>        Get vFolderFormat sHome to sHome             
72462>        Get psAppSrcPath of (phoWorkspace(Self)) to sAppSrc
72463>        Get vFolderFormat sAppSrc to sAppSrc
72464>        
72464>        Send Execute of (oSave_ToolItem(ghoCommandBars))
72465>        Get psCodeFile of (phoEditorRefactored(Self)) to sRefactoredFile
72466>        Send Cursor_Wait of (Cursor_Control(Self))
72467>        Runprogram Wait ('"' + sBinPath + CS_Compiler + '"' * "-x" + '"' + sHome + CS_SWSFile + '"' * CS_CompOptions * CS_TestProgram)
72468>        
72468>        Send Cursor_Ready of (Cursor_Control(Self))    
72469>        Get FileSize of ghoFileSystem (sAppSrc + CS_TestErrFile) to iLines
72470>        If (iLines > 0) Begin
72472>            Send ActivateErrorDialog of (Client_Id(phoMainPanel(ghoApplication))) (sAppSrc + CS_TestErrFile)
72473>        End  
72473>        Else Begin
72474>            Send Info_Box "The refactored code compiled successfully!"
72475>        End
72475>    End_Procedure                                               
72476>    
72476>    Procedure OpenContainingContainer
72479>        String sPath sFile
72479>        
72479>        Get psLegacySourceFile to sFile
72480>        Get ParseFolderName sFile to sPath
72481>        // We want to have that file to be selected in Windows Explorer
72481>        If (sFile <> "") Begin
72483>            Move ("/select, " + sFile) to sPath
72484>        End
72484>        Send vShellExecute "open" "explorer.exe" sPath ""
72485>    End_Procedure
72486>                
72486>    Object oOpenSourceFileDialog is a OpenDialog
72488>        Set Dialog_Caption to "Select a source file"
72489>
72489>        // Nils: I find these filters to restricted and cumbersome to work with.
72489>        // Wil: Me too
72489>        //Set Filter_String to CS_SourceFileFilters
72489>        Set Filter_String to (CS_SourceCodeFilters+"|All Files (*.*)|*.*")
72490>    End_Object
72491>
72491>    Procedure SelectSourceFile
72494>        Boolean bOpen bReadOnly bExists
72494>        String  sFileName sHomePath sAppSrcPath sInitialFolder
72494>        Handle ho
72494>
72494>        Move (oOpenSourceFileDialog(Self)) to ho
72495>        Get Initial_Folder of ho to sInitialFolder
72496>        If (sInitialFolder = "") Begin
72498>            Get psHomePath to sHomePath
72499>            // If an "AppSrc" folder exists we want to display those source files.
72499>            Get vFolderFormat sHomePath to sAppSrcPath
72500>            Move (sAppSrcPath + "AppSrc") to sAppSrcPath
72501>            Get vFolderExists sAppSrcPath to bExists
72502>            If (bExists = True) Begin
72504>                Move sAppSrcPath to sHomePath
72505>            End
72505>
72505>            Set Initial_Folder of ho to sHomePath
72506>        End
72506>        Get Show_Dialog of ho to bOpen
72507>        If (bOpen = True) Begin
72509>            Get File_Name of ho to sFileName
72510>            // Check if user is opening file as read_only
72510>            Get TickReadOnly_State of ho to bReadOnly
72511>            If (bReadOnly = True) Begin
72513>                Send Info_Box ("Files should not be opened as ReadOnly.") "Warning!"
72514>            End
72514>            Else Begin
72515>                Send Info_Box "Not implemnted"
72516>//                Set pbWorkspaceMode to False
72516>//                Send UpdateSourceFileNameDisplay sFileName
72516>//                Send LoadFile of (phoEditor(Self)) sFileName
72516>//                Send Activate_oEditorView_vw of (Client_Id(phoMainPanel(Self)))
72516>            End
72516>        End
72516>    End_Procedure
72517>
72517>End_Object    
72518>
72518>Object oToolTipController is a cToolTipController
72520>    Move Self to ghoToolTipController
72521>    Set piIcon to TTI_INFO
72522>    Set psTitle to "Info"
72523>    Set piMaxWidth to 250
72524>    Set piDurationPopup to 14000 // 14 seconds, needed for long tooltips.
72525>    Set pbUsePrefix to True
72526>End_Object
72527>
72527>Open SysFile
72529>Register_Object oSysfile_DD
72529>
72529>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
72529>>>Use cCJStandardMenuItemClasses.pkg
72529>>>
72529>>>Object oEditContextMenu is a cCJContextMenu
72531>>>    
72531>>>    Move Self to Default_Form_Floating_Menu_ID
72532>>>    
72532>>>    Object oUndoMenuItem is a cCJUndoMenuItem
72534>>>    End_Object
72535>>>    
72535>>>    Object oCutMenuItem is a cCJCutMenuItem
72537>>>        Set pbControlBeginGroup to True
72538>>>    End_Object
72539>>>    
72539>>>    Object oCopyMenuItem is a cCJCopyMenuItem
72541>>>    End_Object
72542>>>
72542>>>    Object oPasteMenuItem is a cCJPasteMenuItem
72544>>>    End_Object
72545>>>
72545>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
72547>>>    End_Object
72548>>>
72548>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
72550>>>        Set pbControlBeginGroup to True
72551>>>    End_Object
72552>>>
72552>>>End_Object
72553>>>
72553>Use oDEOEditContextMenu.pkg
Including file: oDEOEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu.pkg)
72553>>>Use Windows.pkg
72553>>>Use cCJStandardMenuItemClasses.pkg
72553>>>Use cCJDeoMenuItemClasses.pkg
72553>>>
72553>>>
72553>>>Object oDEOEditContextMenu is a cCJContextMenu
72555>>>    
72555>>>    Move Self to Default_dbFloating_Menu_ID
72556>>>    
72556>>>    Object oUndoMenuItem is a cCJUndoMenuItem
72558>>>    End_Object
72559>>>    
72559>>>    Object oCutMenuItem is a cCJCutMenuItem
72561>>>        Set pbControlBeginGroup to True
72562>>>    End_Object
72563>>>    
72563>>>    Object oCopyMenuItem is a cCJCopyMenuItem
72565>>>    End_Object
72566>>>
72566>>>    Object oPasteMenuItem is a cCJPasteMenuItem
72568>>>    End_Object
72569>>>
72569>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
72571>>>    End_Object
72572>>>
72572>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
72574>>>        Set pbControlBeginGroup to True
72575>>>    End_Object
72576>>>
72576>>>    Object oPromptMenuItem is a cCJPromptMenuItem
72578>>>        Set pbControlBeginGroup to True
72579>>>    End_Object
72580>>>
72580>>>    Object oFindNextMenu is a cCJFindNextMenuItem
72582>>>        Set pbControlBeginGroup to True
72583>>>    End_Object
72584>>>
72584>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
72586>>>    End_Object
72587>>>
72587>>>    Object oClearMenuItem is a cCJClearMenuItem
72589>>>        Set pbControlBeginGroup to True
72590>>>    End_Object
72591>>>
72591>>>    Object oClearAllMenu is a cCJClearAllMenuItem
72593>>>    End_Object
72594>>>
72594>>>    Object oSaveMenu is a cCJSaveMenuItem
72596>>>    End_Object
72597>>>    
72597>>>    Object oDeleteMenu is a cCJDeleteMenuItem
72599>>>    End_Object
72600>>>
72600>>>
72600>>>End_Object
72601>Define xtpThemeNativeWindows10  for 17
72601>
72601>Object oMain is a Panel
72603>    Set Label to ("DFRefactor - " + Uppercase(psProduct(ghoApplication)))
72604>    Set Location to 4 3
72605>    Set Size to 300 633
72606>
72606>    Object oCommandBarSystem is a cCJCommandBarSystem
72608>        Set pbTimerUpdate to True
72609>        Set peVisualTheme to xtpThemeOffice2016Publisher
72610>        Set pbAutoResizeIcons to True
72611>        Set peRestoreLayout to rlSaveRestoreAll
72612>        Set pbTabbedWorkspaces to True
72613>        Set pbLargeIcons to True
72614>        Set piLayoutBuild to 3
72615>
72615>        Procedure OnCreateCommandBars
72618>            Handle hoOptions
72618>            Get OptionsObject to hoOptions      
72619>            Forward Send OnCreateCommandBars
72621>        End_Procedure
72622>
72622>        Object oEditToolBar is a cCJToolbar
72624>            Set psTitle to "Edit Toolbar"
72625>            Set pbCloseable to False
72626>            Set pbEnableAnimation to True
72627>            Set pbShowExpandButton to False
72628>
72628>            Object oCutToolbarItem is a cCJCutMenuItem
72630>            End_Object
72631>
72631>            Object oCopyToolbarItem is a cCJCopyMenuItem
72633>            End_Object
72634>
72634>            Object oPasteToolbarItem is a cCJPasteMenuItem
72636>            End_Object
72637>
72637>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
72639>                Set pbControlBeginGroup to True
72640>            End_Object   
72641>
72641>            Object oToggleWhiteSpaceItm is a cCJMenuItem
72643>                Set pbControlBeginGroup to True
72644>                Set psImage to "ToggleWhiteSpace.ico"
72645>                Set psCaption to "Toggle &White Space"
72646>                Set psToolTip to "Toggle white space (Ctrl+W)"
72647>                Set pbActiveUpdate to True
72648>    
72648>                Procedure OnExecute Variant vCommandBarControl
72651>                    Integer iRetval
72651>                    Boolean bIsWhiteSpace
72651>                    Handle hoEditor
72651>                    
72651>                    Get phoEditorLegacy of ghoApplication to hoEditor
72652>                    Get CM_IsWhitespaceDisplayEnabled of hoEditor to bIsWhiteSpace
72653>                    Get CM_EnableWhitespaceDisplay of hoEditor (not(bIsWhiteSpace)) to iRetval
72654>                    Get phoEditorRefactored of ghoApplication to hoEditor
72655>                    Get CM_EnableWhitespaceDisplay of hoEditor (not(bIsWhiteSpace)) to iRetval
72656>                End_Procedure
72657>                
72657>                Function IsEnabled Returns Boolean
72660>                    Handle hoLegacy hoRefactored
72660>                    Get phoEditorLegacy     of ghoApplication to hoLegacy
72661>                    Get phoEditorRefactored of ghoApplication to hoRefactored
72662>                    Function_Return (Focus(Desktop) = hoLegacy or Focus(Desktop) = hoRefactored)
72663>                End_Function
72664>                
72664>            End_Object    
72665>
72665>            Object oToogleIndentationGuides is a cCJMenuItem
72667>                Set psImage to "ToggleIndentationGuides.ico"
72668>                Set psCaption to "Toggle &Indentation Guides"
72669>                Set psToolTip to "Toggle Indentation Guides (Ctrl+I)"
72670>                Set pbActiveUpdate to True
72671>                
72671>                Procedure OnExecute Variant vCommandBarControl
72674>                    Integer iRetval
72674>                    Boolean bIsWhiteSpace bMode
72674>                    Handle hoEditor
72674>                    
72674>                    Get phoEditorLegacy of ghoApplication to hoEditor
72675>                    Send ToggleIndentationGuides of hoEditor
72676>                    Get phoEditorRefactored of ghoApplication to hoEditor
72677>                    Send ToggleIndentationGuides of hoEditor  
72678>                End_Procedure
72679>    
72679>                Function IsEnabled Returns Boolean
72682>                    Handle hoLegacy hoRefactored
72682>                    Get phoEditorLegacy     of ghoApplication to hoLegacy
72683>                    Get phoEditorRefactored of ghoApplication to hoRefactored
72684>                    Function_Return (Focus(Desktop) = hoLegacy or Focus(Desktop) = hoRefactored)
72685>                End_Function
72686>                
72686>            End_Object    
72687>
72687>            Object oToogleScopeBlocks is a cCJMenuItem
72689>                Set psImage to "ToogleScopeBlocks.ico"
72690>                Set psCaption to "Expand/Collapse Blocks"
72691>                Set psToolTip to "Expand/Collapse Blocks"
72692>                Set pbActiveUpdate to True
72693>                
72693>                Property Boolean pbToggleScopeBlocks True
72695>                
72695>                Procedure OnExecute Variant vCommandBarControl
72698>                    Boolean bMode
72698>                    Handle hoEditor
72698>                    
72698>                    Get phoEditorLegacy of ghoApplication to hoEditor
72699>                    Get pbToggleScopeBlocks to bMode
72700>                    Send ToggleScopeBlocks of hoEditor (not(bMode))
72701>                    Set pbToggleScopeBlocks to (not(bMode))
72702>                End_Procedure
72703>    
72703>                Function IsEnabled Returns Boolean
72706>                    Handle hoLegacy hoRefactored
72706>                    Get phoEditorLegacy     of ghoApplication to hoLegacy
72707>                    Get phoEditorRefactored of ghoApplication to hoRefactored
72708>                    Function_Return (Focus(Desktop) = hoLegacy or Focus(Desktop) = hoRefactored)
72709>                End_Function
72710>                
72710>            End_Object    
72711>
72711>        End_Object            
72712>        
72712>        Object oActions_toolbar is a cCJToolbar
72714>            Set psTitle to "Action Toolbar"
72715>            Set pbCloseable to False
72716>            Set pbEnableAnimation to True
72717>            Set pbShowExpandButton to False
72718>
72718>            Object oRefactor_ToolItem is a cCJMenuItem
72720>                Set pbControlBeginGroup to True
72721>                Set pbActiveUpdate to True
72722>                Set peControlStyle to xtpButtonIconAndCaption 
72723>                Set psCaption to "&Refactor Code"
72724>                Set psToolTip to "Refactor Legacy Code (Alt+R)"
72725>                Set psDescription to "Refactor Legacy Code (Alt+R)" 
72726>                Set psImage to "Start.ico"
72727>                Set psShortcut to "Ctrl+R"   
72728>                Set pbActiveUpdate to True
72729>                
72729>                Procedure OnExecute Variant vCommandBarControl
72732>                    Boolean bUseConstraints
72732>                    Get Checked_State of (phoUseConstraints_cb(ghoApplication)) to bUseConstraints
72733>                    Send RefactoreCode of (phoTestView(ghoApplication)) bUseConstraints
72734>                End_Procedure
72735>
72735>                Function IsEnabled Returns Boolean
72738>                    String sViewName sObjectName
72738>                    Move (Name(phoTestView(ghoApplication))) to sViewName
72739>                    Move (Name(Focus(Desktop))) to sObjectName
72740>                    Function_Return (sObjectName contains sViewName)
72741>                End_Function
72742>
72742>                Procedure OnCreateControl Handle hoObj
72745>                    Set ComDefaultItem of hoObj to True
72746>                End_Procedure
72747>                
72747>            End_Object
72748>
72748>            Object oCompare_MenuItem is a cCJMenuItem
72750>                Set peControlStyle to xtpButtonIconAndCaption 
72751>                Set psCaption to "Co&mpare"
72752>                Set psToolTip to "Co&mpare Diff's Legacy && Refactored (Alt+M)"
72753>                Set psDescription to "Compare file changes after running refactoring function(s) (Alt+M)"
72754>                Set psImage to "Compare.ico"
72755>                Set pbActiveUpdate to True
72756>                Set pbControlBeginGroup to True
72757>
72757>                Procedure OnExecute Variant vCommandBarControl
72760>                    String sCompareApp
72760>                    Send Execute of (oSave_ToolItem(ghoCommandBars))
72761>                    Get psFileCompareApp of ghoApplication to sCompareApp
72762>                    Send CompareFiles of ghoApplication sCompareApp
72763>                End_Procedure
72764>
72764>                Function IsEnabled Returns Boolean
72767>                    Integer iLegacyLines iRefactorLines
72767>                    If (pbIsRefactoring(ghoApplication) = True) Begin
72769>                        Function_Return False
72770>                    End
72770>                    Get SC_LineCount of (phoEditorLegacy(ghoApplication)) to iLegacyLines
72771>                    Get SC_LineCount of (phoEditorRefactored(ghoApplication)) to iRefactorLines
72772>                    Function_Return (iLegacyLines > 1 and iRefactorLines > 1)
72773>                End_Function
72774>
72774>            End_Object
72775>
72775>            Object oCompile_ToolItem is a cCJMenuItem
72777>                Set peControlStyle to xtpButtonIconAndCaption 
72778>                Set pbControlBeginGroup to True
72779>                Set pbActiveUpdate to True
72780>                Set psCaption to "Compile"
72781>                Set psToolTip to "Compile refactored code (F5)"
72782>                Set psDescription to "Compile refactored code (F5)" 
72783>                Set psImage to "CompileProject.ico"
72784>                Set psShortcut to "F5"   
72785>                
72785>                Procedure OnExecute Variant vCommandBarControl
72788>                    Send CompileRefactoredCode of ghoApplication
72789>                End_Procedure
72790>
72790>                Function IsEnabled Returns Boolean
72793>                    Integer iLines
72793>                    If (pbIsRefactoring(ghoApplication) = True) Begin
72795>                        Function_Return False
72796>                    End
72796>                    Get SC_LineCount of (phoEditorRefactored(ghoApplication)) to iLines
72797>                    Function_Return (iLines > 1)
72798>                End_Function
72799>                
72799>            End_Object
72800>
72800>            Object oErrorLog_ToolItem is a cCJMenuItem
72802>                Set peControlStyle to xtpButtonIconAndCaption
72803>                Set pbControlBeginGroup to True
72804>                Set pbActiveUpdate to True
72805>                Set psCaption to "Show &Error Log"
72806>                Set psToolTip to "Show Error log from compilation (Ctrl+E)"
72807>                Set psDescription to "Show Error Log (Ctrl+E)"    
72808>                Set psImage to "CompileProjectErrors.ico"
72809>                Set psShortcut to "Alt+E"
72810>
72810>                Procedure OnExecute Variant vCommandBarControl
72813>                    String sAppSrcPath
72813>                    Boolean bExists
72813>
72813>                    Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sAppSrcPath
72814>                    Get vFolderFormat sAppSrcPath to sAppSrcPath
72815>                    Get vFilePathExists (sAppSrcPath + CS_TestErrFile) to bExists
72816>                    If (bExists = True) Begin
72818>                        Send ActivateErrorDialog of (Client_Id(phoMainPanel(ghoApplication))) (sAppSrcPath + CS_TestErrFile)
72819>                    End
72819>                End_Procedure
72820>
72820>                Function IsEnabled Returns Boolean
72823>                    Boolean bExists
72823>                    String sAppSrcPath
72823>                    Integer iLines
72823>
72823>                    Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sAppSrcPath
72824>                    Get vFolderFormat sAppSrcPath to sAppSrcPath
72825>                    Get vFilePathExists (sAppSrcPath + CS_TestErrFile) to bExists
72826>                    Get SC_LineCount of (phoEditorRefactored(ghoApplication)) to iLines
72827>                    Function_Return (bExists = True and iLines > 1)
72828>                End_Function
72829>
72829>            End_Object
72830>
72830>
72830>        End_Object  
72831>
72831>        Object oFindToolBar is a cCJToolbar
72833>            Set psTitle to "Find Edit Toolbar"
72834>            Set pbDockNextTo to False
72835>            Set pbVisible to False
72836>            
72836>            Object oFindFirstTool is a cCJFindFirstMenuItem
72838>            End_Object
72839>            
72839>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
72841>            End_Object
72842>            
72842>            Object oFindMenuTool is a cCJFindMenuItem
72844>            End_Object
72845>            
72845>            Object oFindNextTool is a cCJFindNextMenuItem
72847>            End_Object
72848>            
72848>            Object oFindLastTool is a cCJFindLastMenuItem
72850>            End_Object
72851>            
72851>            Object oPromptToolItem is a cCJPromptMenuItem
72853>                Set pbControlBeginGroup to True
72854>            End_Object
72855>            
72855>            Object oClearToolItem is a cCJClearMenuItem
72857>                Set peControlStyle to xtpButtonIconAndCaption
72858>            End_Object
72859>            
72859>            Object oSave_ToolItem is a cCJSaveMenuItem
72861>                Set peControlStyle to xtpButtonIconAndCaption
72862>                Set pbControlBeginGroup to True
72863>
72863>                Procedure OnExecute Variant vCommandBarControl
72866>                    Handle ho
72866>                    Get phoTestView of ghoApplication to ho
72867>                    If (Active_State(ho)) Begin
72869>                        Send SaveCodeFiles of ghoApplication 
72870>                    End 
72870>                    Else Begin
72871>                        Send Request_Save of (Focus(Self))
72872>                    End
72872>                End_Procedure
72873>
72873>                Function IsEnabled Returns Boolean 
72876>                    Boolean bIsDEO bHasRecord bChanged bEnabled bHasIndex
72876>                    Handle hoServer
72876>                    Boolean bChangedLegacy bChangedRefactored
72876>
72876>                    Get DEOInformation (&hoServer) (&bHasRecord) (&bChanged) (&bHasIndex) to bIsDeo
72877>                    Get CM_IsModified of (phoEditorLegacy(ghoApplication)) to bChangedLegacy
72878>                    Get CM_IsModified of (phoEditorRefactored(ghoApplication)) to bChangedRefactored
72879>                    
72879>                    Function_Return (bChanged = True or bChangedLegacy = True or bChangedRefactored = True)
72880>                End_Function
72881>                
72881>            End_Object
72882>            
72882>            Object oDeleteToolItem is a cCJDeleteMenuItem
72884>                Set peControlStyle to xtpButtonIconAndCaption
72885>            End_Object
72886>            
72886>        End_Object
72887>
72887>        Object oPrograms_toolbar is a cCJToolbar
72889>            Set psTitle to "Programs Toolbar"
72890>            Set pbCloseable to False
72891>            Set pbEnableAnimation to True
72892>            Set pbShowExpandButton to False
72893>            
72893>//            Object oOpenFolderMenuItem is a cCJMenuItem
72893>//                Set psCaption to CS_BrowseSourceFileTxt
72893>//                Set psToolTip to "Select source file"
72893>//                Set psDescription to "Displays an Open File dialog to select a source file from (Ctrl+O)"
72893>//                Set psImage to "ActionOpen.ico"
72893>//                Set peControlStyle to xtpButtonIconAndCaption
72893>////                Set pbActiveUpdate to True
72893>//                Set pbVisible to False
72893>//                
72893>//                Procedure OnExecute Variant vCommandBarControl
72893>//                    Forward Send OnExecute vCommandBarControl
72893>//                    Send SelectSourceFile of ghoApplication
72893>//                End_Procedure
72893>//
72893>//                Function IsEnabled Returns Boolean
72893>//                    Boolean bState
72893>//                    String sSWSFile
72893>//
72893>//                    Move False to bState
72893>//                    Get psSWSFile of ghoApplication to sSWSFile
72893>//                    Move (sSWSFile <> "") to bState
72893>//
72893>//                    Function_Return bState
72893>//                End_Function
72893>//
72893>//            End_Object
72893>
72893>            Object oOpenContainingFolder_MenuItem is a cCJMenuItem
72895>                Set psImage to "ActionOpenContainingFolder.ico"
72896>                Set psCaption to "Containing Folder"
72897>                Set psToolTip to "Open Containing Folder (Ctrl+O)"
72898>                Set psDescription to "Open Containing Folder"
72899>                Set pbActiveUpdate to True
72900>                Set pbControlBeginGroup to True
72901>
72901>                Procedure OnExecute Variant vCommandBarControl
72904>                    Forward Send OnExecute vCommandBarControl
72906>                    String sPath sFile
72906>
72906>                    Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath
72907>                    Get psLegacySourceFile of ghoApplication to sFile
72908>
72908>                    // We want to have that file to be selected in Windows Explorer
72908>                    If (sFile <> "") Begin
72910>                        Move ("/select, " + sFile) to sPath
72911>                    End
72911>                    Send vShellExecute "open" "explorer.exe" sPath ""
72912>                End_Procedure
72913>
72913>                Function IsEnabled Returns Boolean
72916>                    String sFile 
72916>                    Boolean bExists
72916>                    Get psLegacySourceFile of ghoApplication to sFile 
72917>                    Get vFilePathExists sFile to bExists
72918>                    Function_Return (bExists = True)
72919>                End_Function
72920>
72920>            End_Object
72921>
72921>        End_Object
72922>
72922>        Object oExternalPrograms_toolbar is a cCJToolbar
72924>            Set psTitle to "External Toolbar"
72925>            Set pbCloseable to False
72926>            Set pbEnableAnimation to True
72927>            Set pbShowExpandButton to False
72928>
72928>            Object oUnitTest_MenuItem is a cCJMenuItem
72930>                Set peControlStyle to xtpButtonIconAndCaption
72931>                Set psCaption to "Run &Unit Tests"
72932>                Set psToolTip to "Run Unit Testing program (Alt+U)"
72933>                Set psDescription to "Run Unit Testing program  (Alt+U)"
72934>                Set psImage to "UnitTesting.ico"                        
72935>                Set psShortcut to "Ctrl+U"
72936>                
72936>                Procedure OnExecute Variant vCommandBarControl
72939>                    Boolean bExists
72939>                    String sProgramPath sProgramFile sSourceFile sBinPath sHome
72939>                    
72939>                    Get DFBinPath of ghoApplication to sBinPath             
72940>                    Get vFolderFormat sBinPath to sBinPath
72941>                    Get psHome of (phoWorkspace(ghoApplication)) to sHome
72942>                    Get vFolderFormat sHome to sHome             
72943>                    Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
72944>                    Get vFolderFormat sProgramPath to sProgramPath
72945>                    Move (CS_DFUnitTest + ".src") to sSourceFile
72946>                    Move (Replace(".src", sSourceFile, ".exe")) to sProgramFile
72947>                    Get vFilePathExists (sProgramPath + sProgramFile) to bExists
72948>
72948>                    Runprogram Wait ('"' + sBinPath + CS_Compiler + '"' * "-x" + '"' + sHome + CS_SWSFile + '"' * CS_CompOptions * sSourceFile)
72949>
72949>                    Get vFilePathExists (sProgramPath + sProgramFile) to bExists
72950>                    // If program compilation failed:
72950>                    If (bExists = False) Begin
72952>                        Send Info_Box ("The compilation of the" * (CS_DFUnitTest + ".src program") * "failed and can't be started. Please check it with the Studio.")     
72953>                    End
72953>                    Else Begin
72954>                        Runprogram Wait sProgramFile
72955>                    End
72955>                End_Procedure
72956>            
72956>            End_Object
72957>
72957>            Object oDFRefactor_MenuItem is a cCJMenuItem
72959>                Set peControlStyle to xtpButtonIconAndCaption
72960>                Set psCaption to "Run &DFRefactor"
72961>                Set psToolTip to "Run the main DFRefactor program (Alt+D)"
72962>                Set psDescription to "Run Unit Testing program  (Alt+D)"
72963>                Set psImage to "DFRefactor.ico"                        
72964>                Set psShortcut to "Ctrl+D"
72965>
72965>                // This could be used instead of "OnExecute" to just run the DFRefactor program without recompiling it first:
72965>                Procedure RunDFRefactorProgram
72968>                    Boolean bExists
72968>                    String sProgramPath sProgramFile
72968>                    
72968>                    Move (CS_DFRefactor + ".exe") to sProgramFile
72969>                    Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
72970>                    Get vFolderFormat sProgramPath to sProgramPath
72971>                    Get vFilePathExists (sProgramPath + String(sProgramFile)) to bExists
72972>                    If (bExists = False) Begin
72974>                        Send Info_Box "Can't find the DFRefactor.exe program. Is it compiled?"
72975>                        Procedure_Return
72976>                    End
72976>                    Runprogram Background (sProgramPath + String(sProgramFile))    
72977>                End_Procedure
72978>                
72978>                Procedure OnExecute Variant vCommandBarControl
72981>                    Boolean bExists
72981>                    String sProgramPath sProgramFile sSourceFile sBinPath sHome
72981>                    
72981>                    Get DFBinPath of ghoApplication to sBinPath             
72982>                    Get vFolderFormat sBinPath to sBinPath
72983>                    Get psHome of (phoWorkspace(ghoApplication)) to sHome
72984>                    Get vFolderFormat sHome to sHome             
72985>                    Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
72986>                    Get vFolderFormat sProgramPath to sProgramPath
72987>                    Move (CS_DFRefactor + ".src") to sSourceFile
72988>                    Move (Replace(".src", sSourceFile, ".exe")) to sProgramFile
72989>                    Get vFilePathExists (sProgramPath + sProgramFile) to bExists
72990>
72990>                    Runprogram Wait ('"' + sBinPath + CS_Compiler + '"' * "-x" + '"' + sHome + CS_SWSFile + '"' * CS_CompOptions * sSourceFile)
72991>
72991>                    Get vFilePathExists (sProgramPath + sProgramFile) to bExists
72992>                    // If program compilation failed:
72992>                    If (bExists = False) Begin
72994>                        Send Info_Box ("The compilation of the" * (CS_DFRefactor + ".src program") * "failed and can't be started. Please check it with the Studio.")
72995>                    End
72995>                    Else Begin
72996>                        Runprogram Background sProgramFile
72997>                    End
72997>                End_Procedure
72998>            
72998>            End_Object 
72999>            
72999>            Object oCodeExplorer_ToolbarButton is a cCJMenuItem
73001>                Set peControlStyle to xtpButtonIconAndCaption
73002>                Set psCaption to "DataFlex Source &Explorer"
73003>                Set psToolTip to "DataFlex Source Explorer"
73004>                Set psDescription to "Run Starzen's DataFlex Source Explorer (Alt+E)"
73005>                Set psImage to "DataFlexSourceExplorer.ico"
73006>                Set psShortcut to "Alt+E"
73007>                Set pbActiveUpdate to True
73008>
73008>                Procedure OnExecute Variant vCommandBarControl
73011>                    String sProgram sHome
73011>                    Forward Send OnExecute vCommandBarControl
73013>                    
73013>//                        Move (Trim(SysFile.PathStarZen)) to sProgram  
73013>                    Get private.psStarZenSourceExplorer of ghoApplication to sProgram
73014>//                        Get ReadString of ghoApplication "Settings" "StarZenSourceExplorer" "" to sProgram
73014>                    If (sProgram = "") Begin
73016>                        Send Info_Box "You first need to setup the path to StarZen's Source Code Explorer program with 'Program Settings'"
73017>                        Procedure_Return
73018>                    End
73018>//                        Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sHome
73018>//                        If (sHome <> "") Begin
73018>//                            Move ("-ws" * '"' + sHome + '"') to sHome
73018>//                        End
73018>                    Runprogram Background sProgram //sHome
73019>                End_Procedure
73020>
73020>                Function IsEnabled Returns Boolean
73023>                    String sProgram
73023>                    Get psStarZenSourceExplorer of ghoApplication to sProgram
73024>                    Function_Return (sProgram <> "")
73025>                End_Function
73026>
73026>            End_Object
73027>
73027>        End_Object
73028>
73028>        Object oExit_toolbar is a cCJToolbar
73030>            Set pbCloseable to False
73031>            Set pbEnableAnimation to True
73032>            Set pbShowExpandButton to False
73033>
73033>            Object oAbout_MenuItem is a cCJMenuItem
73035>                Set psCaption to "About"
73036>                Set psToolTip to "About"
73037>                Set psDescription to "About the program"
73038>                Set psImage to "ActionAbout.ico"
73039>                Set pbControlBeginGroup to True
73040>                Procedure OnExecute Variant vCommandBarControl
73043>                    Forward Send OnExecute vCommandBarControl
73045>                    Send Activate_About of (Client_Id(ghoCommandBars))
73046>                End_Procedure
73047>            End_Object
73048>
73048>            Object oHelpMenu is a cCJMenuItem
73050>                Set psToolTip to "Help"
73051>                Set psDescription to "Help about the program (F1)"
73052>                Set psImage to "ActionHelp.ico"
73053>                Set peControlType to xtpControlSplitButtonPopup
73054>
73054>                Object oHelpGitHub is a cCJMenuItem
73056>                    Set psCaption to "GitHub source code repository"
73057>                    Set psToolTip to "Link to GitHub source code repository"
73058>                    Set psDescription to "Github source code"
73059>                    Set psImage to "GitHub.ico"
73060>                    Procedure OnExecute Variant vCommandBarControl
73063>                        Forward Send OnExecute vCommandBarControl 
73065>                        Runprogram Shell Background "https://github.com/NilsSve/DFRefactor.git"
73066>                    End_Procedure
73067>                End_Object
73068>                
73068>                Object oHelpMenuItem is a cCJHelpMenuItem
73070>                    Set psToolTip to "Help"
73071>                    Set psDescription to "Help about the program (F1)"
73072>                End_Object
73073>            End_Object
73074>
73074>            Object oExitMenuItem is a cCJExitMenuItem
73076>                Set psImage to "ActionExit.ico"
73077>                Set psToolTip to "Exit"
73078>                Set psDescription to "Exit the program (Alt+F4)"
73079>                Set pbControlBeginGroup to True
73080>            End_Object
73081>
73081>        End_Object
73082>
73082>        Object oStatusBar is a cCJStatusBar
73084>            Set StatusBar_Id to Self
73085>
73085>            Object oStatusPane1 is a cCJStatusBarPane
73087>                Set piID to sbpIDIdlePane
73088>                Set pbStyleStretch to True
73089>            End_Object
73090>
73090>            Object oStatusPane2 is a cCJStatusBarPane
73092>                Set phoViewPane to Self
73093>                Set pbStyleStretch to True
73094>            End_Object
73095>
73095>            Object oStatusPane3 is a cCJStatusBarPane
73097>//                Set psText to "Current Action:"
73097>            End_Object
73098>
73098>            Object oNumberOfLines_StatusbarPane is a cCJStatusBarPane
73100>                Set psText to "No of Lines:"
73101>            End_Object
73102>
73102>            Object oNumberOfCharacters_StatusbarPane is a cCJStatusBarPane
73104>                Set psText to "Characters:"
73105>            End_Object
73106>
73106>            Procedure Set NumberOfEditorLines String sText
73109>                Move (FormatValue(sText, ",###")) to sText
73110>                Set psText of oNumberOfLines_StatusbarPane to ("No of Lines:" * String(sText))
73111>            End_Procedure
73112>
73112>            Procedure Set NumberOfEditorCharacters String sText
73115>                Move (FormatValue(sText, ",###")) to sText
73116>                Set psText of oNumberOfCharacters_StatusbarPane to ("Characters:" * String(sText))
73117>            End_Procedure
73118>
73118>            Procedure Set ActionText String sText
73121>                Handle hoViewPane
73121>                Get phoViewPane to hoViewPane
73122>                Set psText of hoViewPane to sText
73123>            End_Procedure
73124>
73124>            Procedure Set CurrentActionText String sText
73127>                Handle hoViewPane
73127>                Move (oStatusPane3(Self)) to hoViewPane
73128>                Set psText of hoViewPane to sText
73129>            End_Procedure  
73130>            
73130>        End_Object
73131>        
73131>    End_Object
73132>
73132>    Object oClientArea is a ClientArea  
73134>        Use ScintillaParameters.dg
Including file: ScintillaParameters.dg    (C:\Projects\DF18\DfRefactor\AppSrc\ScintillaParameters.dg)
73134>>>Use cRDCModalPanel.pkg
73134>>>Use cImageList32.pkg
73134>>>Use dfSpnFrm.pkg
73134>>>Use dfLine.pkg
73134>>>Use dfTreeVw.pkg
73134>>>Use Colr_Dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Colr_dlg.pkg)
73134>>>>>Use VDFBase.pkg
73134>>>>>Use DLL.pkg
73134>>>>>Use RGB.pkg
73134>>>>>Use GlobalFunctionsProcedures.pkg
73134>>>>>
73134>>>>>
73134>>>>>External_Function ChooseColor 'ChooseColorA' COMDLG32.dll Pointer lpCC Returns DWord
73135>>>>>
73135>>>>>
73135>>>>>Class ColorDialog is a cObject
73136>>>>>    Procedure Construct_Object
73138>>>>>        Integer iLoop
73138>>>>>        Handle hoCustomColors
73138>>>>>        
73138>>>>>        Forward Send Construct_Object
73140>>>>>        
73140>>>>>        Property Boolean FullOpen_State        True
73141>>>>>        Property Boolean PreventFullOpen_State False
73142>>>>>        Property Boolean SelectedColor_State   True
73143>>>>>        Property Integer SelectedColor         0
73144>>>>>        
73144>>>>>        Property Handle phoCustomColors (Create(Self, U_Array)) // create an array to hold the custom colors
73145>>>>>        
73145>>>>>        // Set all custom colors to white...
73145>>>>>        Get phoCustomColors to hoCustomColors
73146>>>>>        For iLoop from 0 to 15
73152>>>>>>
73152>>>>>            Set Value of hoCustomColors iLoop to clWhite
73153>>>>>        Loop
73154>>>>>>
73154>>>>>        
73154>>>>>    End_Procedure
73155>>>>>    
73155>>>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
73157>>>>>        Set Value of (phoCustomColors(Self)) iItem to rgbColor
73158>>>>>    End_Procedure
73159>>>>>    
73159>>>>>    Function Custom_Color Integer iItem Returns Integer
73161>>>>>        Function_Return (Integer_Value(phoCustomColors(Self), iItem))
73162>>>>>    End_Function
73163>>>>>    
73163>>>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
73165>>>>>        // Copies the custom colors from another ColorDialog instance
73165>>>>>        Integer iColor
73165>>>>>        
73165>>>>>        For iColor from 0 to 15
73171>>>>>>
73171>>>>>            Set Custom_Color iColor to (Value(hoSourceColorDialog, iColor))
73172>>>>>        Loop
73173>>>>>>
73173>>>>>    End_Procedure
73174>>>>>    
73174>>>>>    Function Value Integer iItem Returns String
73176>>>>>        // Provides support for the AssignCustomColors procedure, which requires
73176>>>>>        // that a "Get Value" interface is supported
73176>>>>>        Function_Return (Custom_Color(Self, iItem))
73177>>>>>    End_Function
73178>>>>>    
73178>>>>>    Function OwnerHandle Returns Handle
73180>>>>>        Handle hWnd
73180>>>>>        Handle hoObj
73180>>>>>        Get Focus of desktop to hoObj // start with the focus
73181>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
73182>>>>>        Function_Return hWnd
73183>>>>>    End_Function
73184>>>>>    
73184>>>>>    Function Show_Dialog Returns Boolean
73186>>>>>        //Shows the dialog. Returns True if the OK button was clicked.
73186>>>>>        Handle  hContainer hoCustomColors
73186>>>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
73186>>>>>        Integer rgbColor iFlags iLoop
73186>>>>>        String sCC sColors
73186>>>>>        tWinChooseColor ChseColor
73186>>>>>        tWinChooseColor ChseColor
73186>>>>>        
73186>>>>>        Get OwnerHandle to hContainer
73187>>>>>        
73187>>>>>        Get phoCustomColors to hoCustomColors
73188>>>>>        
73188>>>>>        Move '' to sColors
73189>>>>>        For iLoop from 0 to 15
73195>>>>>>
73195>>>>>            Get Value of hoCustomColors iLoop to rgbColor
73196>>>>>            Move (sColors + DWORDToBytes(rgbColor)) to sColors
73197>>>>>        Loop
73198>>>>>>
73198>>>>>        
73198>>>>>        Get FullOpen_State        to bFullOpen
73199>>>>>        Get PreventFullOpen_State to bNoOpen
73200>>>>>        Get SelectedColor_State   to bSelColor
73201>>>>>        Get SelectedColor         to rgbColor
73202>>>>>        
73202>>>>>        Move 0 to iFlags
73203>>>>>        If bFullOpen ;            Move (iFlags +CC_FULLOPEN)        to iFlags
73206>>>>>        If bNoOpen ;            Move (iFlags +CC_PREVENTFULLOPEN) to iFlags
73209>>>>>        If bSelColor ;            Move (iFlags +CC_RGBINIT)         to iFlags
73212>>>>>        
73212>>>>>        Move (SizeOfType(tWinChooseColor))     to ChseColor.lStructSize
73213>>>>>        Move hContainer           to ChseColor.hWndOWner
73214>>>>>        Move rgbColor             to ChseColor.rgbResult
73215>>>>>        Move (AddressOf(sColors)) to ChseColor.lpCustColors
73216>>>>>        Move iFlags               to ChseColor.flags
73217>>>>>        
73217>>>>>        Move (ChooseColor(AddressOf(ChseColor))) to bSelected
73218>>>>>        
73218>>>>>        If bSelected Begin
73220>>>>>            For iLoop from 0 to 15
73226>>>>>>
73226>>>>>                Move (DeRefDw(AddressOf(sColors), iLoop *4)) to rgbColor
73227>>>>>                Set Value of hoCustomColors iLoop to rgbColor
73228>>>>>            Loop
73229>>>>>>
73229>>>>>            Move ChseColor.rgbResult to rgbColor
73230>>>>>            Set SelectedColor to rgbColor
73231>>>>>        End
73231>>>>>>
73231>>>>>        Function_Return bSelected
73232>>>>>    End_Function
73233>>>>>    
73233>>>>>End_Class
73234>>>>>
73234>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRichEdit.pkg)
73234>>>>>Use Windows.pkg
73234>>>>>Use cEdit_Mixin.pkg
73234>>>>>
73234>>>>>// constants used for RichEdit Properties
73234>>>>>// peAlignment
73234>>>>>Enum_List
73234>>>>>    Define alLeft   for 1
73234>>>>>    Define alRight  for 2
73234>>>>>    Define alCenter for 3
73234>>>>>End_Enum_List
73234>>>>>
73234>>>>>// peBullets
73234>>>>>Enum_List
73234>>>>>    Define buNone
73234>>>>>    Define buBullets
73234>>>>>    Define buArabicNumbers
73234>>>>>    Define buLowerLetters
73234>>>>>    Define buUpperLetters
73234>>>>>    Define buLowerRomans
73234>>>>>    Define buUpperRomans
73234>>>>>End_Enum_List
73234>>>>>
73234>>>>>// peBulletStyle
73234>>>>>Enum_List
73234>>>>>    Define busRightParen   for 0
73234>>>>>    Define busEncloseParen for 256
73234>>>>>    Define busPeriod       for 512
73234>>>>>    Define busNumberOnly   for 768
73234>>>>>    Define busNoDisplay    for 1024
73234>>>>>End_Enum_List
73234>>>>>
73234>>>>>// peLineSpacingType
73234>>>>>Enum_List
73234>>>>>    Define lstSingle
73234>>>>>    Define lstSingleAndOneHalf
73234>>>>>    Define lstDouble
73234>>>>>End_Enum_List
73234>>>>>
73234>>>>>Class cRichEdit is a DFBaseRichEdit
73235>>>>>    
73235>>>>>    Procedure Construct_Object
73237>>>>>        Forward Send Construct_Object
73239>>>>>        Send Define_cEdit_Mixin
73240>>>>>        
73240>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
73241>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
73242>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
73243>>>>>        
73243>>>>>    End_Procedure
73244>>>>>    
73244>>>>>    Import_Class_Protocol cEdit_Mixin
73245>>>>>    
73245>>>>>    Procedure ToggleBold
73247>>>>>        Set pbBold to (not(pbBold(Self)))
73248>>>>>    End_Procedure
73249>>>>>    
73249>>>>>    Procedure ToggleItalics
73251>>>>>        Set pbItalics to (not(pbItalics(Self)))
73252>>>>>    End_Procedure
73253>>>>>    
73253>>>>>    Procedure ToggleUnderline
73255>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
73256>>>>>    End_Procedure
73257>>>>>    
73257>>>>>End_Class
73258>>>>>
73258>>>>>
73258>>>Use oEditorProperties.pkg
Including file: oEditorProperties.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\oEditorProperties.pkg)
73258>>>>>//*****************************************************************************************
73258>>>>>// Copyright (c) 2000 Michael Kurz
73258>>>>>// All rights reserved.
73258>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73258>>>>>//
73258>>>>>// $FileName    : cEditorEdit.Pkg
73258>>>>>// $ProjectName : CODEMAX EDITOR
73258>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73258>>>>>// $Created     : 01-25-2001 @ 19:00
73258>>>>>//
73258>>>>>// Contents:
73258>>>>>//      Properties for Editor, stored in an INI file, based on cEditorProperties.
73258>>>>>//      If you want to use a different config file then have your own version of this
73258>>>>>//      file with a different filename.
73258>>>>>// $Rev History
73258>>>>>//
73258>>>>>//*****************************************************************************************
73258>>>>>
73258>>>>>    // The out of this class created object is stored in this global Var.
73258>>>>>Use cEditorProperties.pkg
Including file: cEditorProperties.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cEditorProperties.pkg)
73258>>>>>>>//*****************************************************************************************
73258>>>>>>>// Copyright (c) 2000 Michael Kurz
73258>>>>>>>// All rights reserved.
73258>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73258>>>>>>>//
73258>>>>>>>// $FileName    : cEditorEdit.Pkg
73258>>>>>>>// $ProjectName : CODEMAX EDITOR
73258>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73258>>>>>>>// $Created     : 01-25-2001 @ 19:00
73258>>>>>>>//
73258>>>>>>>// Contents:
73258>>>>>>>//      Properties for Editor, stored in an INI file, based on cIniHandler.
73258>>>>>>>//
73258>>>>>>>// $Rev History
73258>>>>>>>//
73258>>>>>>>//*****************************************************************************************
73258>>>>>>>
73258>>>>>>>Use cIniManager.pkg                 // Class cIniManager
Including file: cIniManager.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cIniManager.pkg)
73258>>>>>>>>>//*****************************************************************************************
73258>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73258>>>>>>>>>// All rights reserved.
73258>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73258>>>>>>>>>//
73258>>>>>>>>>// $FileName    : cIniManager.pkg
73258>>>>>>>>>// $ProjectName : General shared classes
73258>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73258>>>>>>>>>// $Created     : 12-31-2000 @ 09:00
73258>>>>>>>>>//
73258>>>>>>>>>// Contents:
73258>>>>>>>>>//      Abilities to load and save values to an inifile.
73258>>>>>>>>>//      This Class (cIniProperties) is not just a class it is a solution for a problem I
73258>>>>>>>>>//      had for years.
73258>>>>>>>>>//
73258>>>>>>>>>//      What's the idea?
73258>>>>>>>>>//          Very often if you develop a class you need want it to save properties to
73258>>>>>>>>>//          disk. Then you also need to build a kind of property page to edit these
73258>>>>>>>>>//          Properties ans save if to disk again.
73258>>>>>>>>>//
73258>>>>>>>>>//          With cIniProperties and a set of commands its possible to create a set of
73258>>>>>>>>>//          properties which are save with one call into an inifile to disk.
73258>>>>>>>>>//
73258>>>>>>>>>// $Rev History
73258>>>>>>>>>//
73258>>>>>>>>>//*****************************************************************************************
73258>>>>>>>>>//
73258>>>>>>>>>//
73258>>>>>>>>>//     // Stores the infos which TAPI lines should been monitored.
73258>>>>>>>>>//  Class cTapiHandler_Properties is a cIniProperties
73258>>>>>>>>>//      INI_Begin_Properties "FILENAME.INI"  [INI_COMPUTER | INI_COMPUTER | INI_GLOBAL]
73258>>>>>>>>>//
73258>>>>>>>>>//              // Normal Properties (Single Item)
73258>>>>>>>>>//          INI_Property        piTestInteger                         Public 0
73258>>>>>>>>>//          INI_Property        pnTestNumber                          Public 0
73258>>>>>>>>>//          INI_Property        psTestString                          Public ""
73258>>>>>>>>>//
73258>>>>>>>>>//              // Multi Item Properties
73258>>>>>>>>>//          INI_Property        integer Line                          Public 0  MULTI
73258>>>>>>>>>//          INI_Property.Sub    string  Name                          Public ""
73258>>>>>>>>>//          INI_Property.Sub    string  Monitor                       Public ""
73258>>>>>>>>>//          INI_Property.Sub    string  Standard                      Public ""
73258>>>>>>>>>//      INI_End_Properties
73258>>>>>>>>>//
73258>>>>>>>>>//          // Accessing Single Item Properties (as usual with set and get)
73258>>>>>>>>>//      set piTestInteger           to 10
73258>>>>>>>>>//      set psTestString            to ""
73258>>>>>>>>>//      get piTestString            to sTmp
73258>>>>>>>>>//      move (piTestInteger(Self))  to iTmp
73258>>>>>>>>>//
73258>>>>>>>>>//          // Accessing Multi Item Properties
73258>>>>>>>>>//      set Line        item iNr    to iWert
73258>>>>>>>>>//      set Line.Name   item iNr    to sWert
73258>>>>>>>>>//
73258>>>>>>>>>//          // Number of Items present
73258>>>>>>>>>//      move (Line.Count(Self))     to iCount
73258>>>>>>>>>//          // Deletes a specified Item
73258>>>>>>>>>//      send Line.DeleteItem iNr
73258>>>>>>>>>//
73258>>>>>>>>>//          // Deletes all Line Items.
73258>>>>>>>>>//      send Line.DeleteAllItems
73258>>>>>>>>>//  End_Class
73258>>>>>>>>>
73258>>>>>>>>>// Dependencies:
73258>>>>>>>>>Use Windows.Pkg                 // For external function use.
73258>>>>>>>>>Use DLL.Pkg                     // ...
73258>>>>>>>>>Use cLineParser.Pkg             // Class: cLineParser, for seperating a String in its parts.
Including file: cLinePARSER.PKG    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cLinePARSER.PKG)
73258>>>>>>>>>>>//*****************************************************************************************
73258>>>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73258>>>>>>>>>>>// All rights reserved.
73258>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73258>>>>>>>>>>>//
73258>>>>>>>>>>>// $FileName    : cLineParser.pkg
73258>>>>>>>>>>>// $ProjectName : General shared classes
73258>>>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73258>>>>>>>>>>>// $Created     : 12-31-2000 @ 09:00
73258>>>>>>>>>>>//
73258>>>>>>>>>>>// Contents:
73258>>>>>>>>>>>//      Separates a string to its parts which need to be seperated by a special character.
73258>>>>>>>>>>>//
73258>>>>>>>>>>>// $Rev History
73258>>>>>>>>>>>// 11/09/2005 **WvA Added the possibility to skip parts in the parsing. This allows
73258>>>>>>>>>>>//            us to parse UNC paths correctly while the sep character is set to "\"
73258>>>>>>>>>>>//
73258>>>>>>>>>>>//*****************************************************************************************
73258>>>>>>>>>>>
73258>>>>>>>>>>>// This Class separates a string into his parts. Which need to be
73258>>>>>>>>>>>// seperated by a seperating character (psSepCharacter)
73258>>>>>>>>>>>// As the class is based on an array the parts can be retrieved by
73258>>>>>>>>>>>// "get value item iItem to sPart" and the number of items with a call
73258>>>>>>>>>>>// of "get Item_Count to iCount".
73258>>>>>>>>>>>
73258>>>>>>>>>>>Define CLINEPARSER_COMMAND      For 0
73258>>>>>>>>>>>Define CLINEPARSER_KEYWORD      For 1
73258>>>>>>>>>>>Define CLINEPARSER_COMMENT      For 2
73258>>>>>>>>>>>Define CLINEPARSER_STRING       For 3
73258>>>>>>>>>>>Define CLINEPARSER_EXPRESSION   For 4
73258>>>>>>>>>>>Define CLINEPARSER_INDICATOR    For 5
73258>>>>>>>>>>>
73258>>>>>>>>>>>Class cLineParser is a Array
73259>>>>>>>>>>>
73259>>>>>>>>>>>  // Adding properties and setting default values
73259>>>>>>>>>>>  Procedure Construct_Object
73261>>>>>>>>>>>    Forward Send Construct_Object
73263>>>>>>>>>>>
73263>>>>>>>>>>>    Property String  psSepCharacter                        ","  // Seperating character
73264>>>>>>>>>>>    Property String  psSkipSequence                        ""   // Sometimes we want the parser to skip parsing parts, eg. the unc prefix "\\" when the character is set to "\"
73265>>>>>>>>>>>    Property String  psSwapOutSequence                     "$x$" // (Private) This is used along with psSkipSequence to temporarily swap out parts you want to skip parsing, you would normally not need to change this.
73266>>>>>>>>>>>    Property String  psInputLine                           ""   // Stores the whole last given string. (only for convenience)
73267>>>>>>>>>>>    Property Integer piSkipEmptyParts                      0    // Skips empty parts
73268>>>>>>>>>>>    // Follow the language tokens, ie (Expr), comments, strings etc. recognize as token,
73268>>>>>>>>>>>    Property Integer piLanguageTokens                      False
73269>>>>>>>>>>>    Object oType is an Array
73271>>>>>>>>>>>    End_Object
73272>>>>>>>>>>>  End_Procedure
73273>>>>>>>>>>>
73273>>>>>>>>>>>  // Parses a line in its parts which are seperated by "psSepCharacter".
73273>>>>>>>>>>>  Procedure ParseLine String sLine
73275>>>>>>>>>>>    If (piLanguageTokens(Self)) Begin
73277>>>>>>>>>>>      Set psSepCharacter  To " "
73278>>>>>>>>>>>      Send ParseLineTkn   sLine
73279>>>>>>>>>>>    End
73279>>>>>>>>>>>>
73279>>>>>>>>>>>    Else Begin
73280>>>>>>>>>>>      Send ParseLineStd sLine
73281>>>>>>>>>>>    End
73281>>>>>>>>>>>>
73281>>>>>>>>>>>  End_Procedure
73282>>>>>>>>>>>
73282>>>>>>>>>>>  Procedure Add_Token Integer iType String sToken
73284>>>>>>>>>>>    Set Value Item (Item_Count(Self)) To (Trim(sToken))
73285>>>>>>>>>>>    If ((Item_Count(Self)=1)And(iType<>CLINEPARSER_COMMENT)And(iType<>CLINEPARSER_INDICATOR)) Begin
73287>>>>>>>>>>>      Set Value Of oType Item (Item_Count(Self)-1) To CLINEPARSER_COMMAND
73288>>>>>>>>>>>    End
73288>>>>>>>>>>>>
73288>>>>>>>>>>>    Else Begin
73289>>>>>>>>>>>      Set Value Of oType Item (Item_Count(Self)-1) To iType
73290>>>>>>>>>>>    End
73290>>>>>>>>>>>>
73290>>>>>>>>>>>  End_Procedure
73291>>>>>>>>>>>
73291>>>>>>>>>>>  Function ProcessStrToken String sChar String sLine Integer iCount Returns Integer
73293>>>>>>>>>>>    String sToken sChr
73293>>>>>>>>>>>    Move "" To sToken
73294>>>>>>>>>>>    Move sChar To sChr
73295>>>>>>>>>>>    Move (sToken+sChr) To sToken
73296>>>>>>>>>>>    Move "" To sChr
73297>>>>>>>>>>>    While ((sChr<>sChar)And(iCount<=(Length(sLine))))
73301>>>>>>>>>>>      Increment iCount
73302>>>>>>>>>>>      Move (Mid(sLine,1,iCount)) To sChr
73303>>>>>>>>>>>      Move (sToken+sChr) To sToken
73304>>>>>>>>>>>    Loop
73305>>>>>>>>>>>>
73305>>>>>>>>>>>    If (Trim(sToken)<>"") Begin
73307>>>>>>>>>>>      Send Add_Token CLINEPARSER_STRING (Trim(sToken))
73308>>>>>>>>>>>    End
73308>>>>>>>>>>>>
73308>>>>>>>>>>>    Function_Return iCount
73309>>>>>>>>>>>  End_Function
73310>>>>>>>>>>>
73310>>>>>>>>>>>  Function ProcessBrToken String sCharSt String sCharEn String sLine Integer iCount Returns Integer
73312>>>>>>>>>>>    Integer iBr iStr iChr
73312>>>>>>>>>>>    String sToken sChr
73312>>>>>>>>>>>    Increment iBr // Start
73313>>>>>>>>>>>    Move sCharSt To sToken
73314>>>>>>>>>>>    While ((iBr<>0)And(iCount<=(Length(sLine))))
73318>>>>>>>>>>>      Increment iCount
73319>>>>>>>>>>>      Move (Mid(sLine,1,iCount)) To sChr
73320>>>>>>>>>>>      If (sChr='"') Begin
73322>>>>>>>>>>>        If (iStr) ;          Decrement iStr
73325>>>>>>>>>>>        Else Begin
73326>>>>>>>>>>>          If (Not(iChr)) ;            Increment iStr
73329>>>>>>>>>>>        End
73329>>>>>>>>>>>>
73329>>>>>>>>>>>      End
73329>>>>>>>>>>>>
73329>>>>>>>>>>>      If (sChr="'") Begin
73331>>>>>>>>>>>        If (iChr) ;          Decrement iChr
73334>>>>>>>>>>>        Else Begin
73335>>>>>>>>>>>          If (Not(iStr)) ;            Increment iChr
73338>>>>>>>>>>>        End
73338>>>>>>>>>>>>
73338>>>>>>>>>>>      End
73338>>>>>>>>>>>>
73338>>>>>>>>>>>      If ((Not(iStr))And(Not(iChr))) Begin
73340>>>>>>>>>>>        If (sChr=sCharSt) ;          Increment iBr
73343>>>>>>>>>>>        If (sChr=sCharEn) ;          Decrement iBr
73346>>>>>>>>>>>      End
73346>>>>>>>>>>>>
73346>>>>>>>>>>>      Move (sToken+sChr)  To sToken
73347>>>>>>>>>>>    Loop
73348>>>>>>>>>>>>
73348>>>>>>>>>>>    If (Trim(sToken)<>"") Begin
73350>>>>>>>>>>>      If (sCharSt="[") ;        Send Add_Token CLINEPARSER_INDICATOR  (Trim(sToken))
73353>>>>>>>>>>>      Else ;        Send Add_Token CLINEPARSER_EXPRESSION (Trim(sToken))
73355>>>>>>>>>>>    End
73355>>>>>>>>>>>>
73355>>>>>>>>>>>    Function_Return iCount
73356>>>>>>>>>>>  End_Function
73357>>>>>>>>>>>
73357>>>>>>>>>>>  Procedure ParseLineTkn String sLine
73359>>>>>>>>>>>    Integer iC iBlank iSepL iCount
73359>>>>>>>>>>>    String  sToken sChar sSep sCom sNext sComLine
73359>>>>>>>>>>>    Move ('/'+'/') To sCom
73360>>>>>>>>>>>    Move (psSepCharacter(Self)) To sSep
73361>>>>>>>>>>>    Move (Length(sSep))         To iSepL
73362>>>>>>>>>>>    Send Delete_Data
73363>>>>>>>>>>>    If (sSep=" ") Begin
73365>>>>>>>>>>>      Move 1     To iBlank
73366>>>>>>>>>>>    End
73366>>>>>>>>>>>>
73366>>>>>>>>>>>
73366>>>>>>>>>>>    If (Left(sLine,2)=sCom) Begin
73368>>>>>>>>>>>      Send Add_Token CLINEPARSER_COMMENT (Trim(sLine))
73369>>>>>>>>>>>      Procedure_Return
73370>>>>>>>>>>>    End
73370>>>>>>>>>>>>
73370>>>>>>>>>>>
73370>>>>>>>>>>>    If sCom In sLine Begin
73372>>>>>>>>>>>      Move (Left(sLine, (Pos(sCom, sLine)-1))) To sToken
73373>>>>>>>>>>>      Move (Replace(sToken, sLine, "")) To sLine
73374>>>>>>>>>>>      Move (Trim(sLine))  To sComLine
73375>>>>>>>>>>>      Move sToken         To sLine
73376>>>>>>>>>>>      Move ""             To sToken
73377>>>>>>>>>>>    End
73377>>>>>>>>>>>>
73377>>>>>>>>>>>
73377>>>>>>>>>>>    While (iCount<=(Length(sLine)))
73381>>>>>>>>>>>      Increment iCount
73382>>>>>>>>>>>      Move (Mid(sLine,1,iCount)) To sChar
73383>>>>>>>>>>>      If (sChar='"' Or sChar="'") Begin
73385>>>>>>>>>>>        Get ProcessStrToken sChar sLine iCount To iCount
73386>>>>>>>>>>>        Move "" To sChar
73387>>>>>>>>>>>      End
73387>>>>>>>>>>>>
73387>>>>>>>>>>>      Else If (sChar="(") Begin
73390>>>>>>>>>>>        Get ProcessBrToken  sChar ")" sLine iCount To iCount
73391>>>>>>>>>>>        Move "" To sChar
73392>>>>>>>>>>>      End
73392>>>>>>>>>>>>
73392>>>>>>>>>>>      Else If (sChar="[") Begin
73395>>>>>>>>>>>        Get ProcessBrToken  sChar "]" sLine iCount To iCount
73396>>>>>>>>>>>        Move "" To sChar
73397>>>>>>>>>>>      End
73397>>>>>>>>>>>>
73397>>>>>>>>>>>      Else If (sChar="/") Begin
73400>>>>>>>>>>>        Increment iCount
73401>>>>>>>>>>>        Move (Mid(sLine,1,iCount)) To sNext
73402>>>>>>>>>>>        If (sNext="/") Begin
73404>>>>>>>>>>>          Move (sChar+sNext+Right(sLine, iCount+1)) To sToken
73405>>>>>>>>>>>          If (Trim(sToken)<>"") ;            Send Add_Token CLINEPARSER_COMMENT (Trim(sToken))
73408>>>>>>>>>>>          Move (Length(sLine)+100) To iCount // Cancels parsing
73409>>>>>>>>>>>        End
73409>>>>>>>>>>>>
73409>>>>>>>>>>>        Move "" To sChar
73410>>>>>>>>>>>      End
73410>>>>>>>>>>>>
73410>>>>>>>>>>>      If (sChar=sSep) Begin
73412>>>>>>>>>>>        If (Trim(sToken)<>"") ;          Send Add_Token CLINEPARSER_KEYWORD (Trim(sToken))
73415>>>>>>>>>>>        Move "" To sToken
73416>>>>>>>>>>>      End
73416>>>>>>>>>>>>
73416>>>>>>>>>>>      If (sChar<>"") ;        Move (sToken+sChar) To sToken
73419>>>>>>>>>>>    Loop
73420>>>>>>>>>>>>
73420>>>>>>>>>>>    If (sComLine<>"") ;      Send Add_Token CLINEPARSER_COMMENT (Trim(sComLine))
73423>>>>>>>>>>>  End_Procedure
73424>>>>>>>>>>>
73424>>>>>>>>>>>  Procedure ParseLineStd String sLine
73426>>>>>>>>>>>    Integer iPos iC iBlank iSepL iCount
73426>>>>>>>>>>>    String  sPart sSkip sSwap sOld
73426>>>>>>>>>>>    Boolean bSwapped
73426>>>>>>>>>>>    Move (Length(psSepCharacter(Self)))         To iSepL
73427>>>>>>>>>>>    Send Delete_Data
73428>>>>>>>>>>>    // *WvA: 11/09/2005 Added logic to skip parsing of specific parts.
73428>>>>>>>>>>>    Move (false) To bSwapped
73429>>>>>>>>>>>    Get psSkipSequence    To sSkip
73430>>>>>>>>>>>    Get psSwapOutSequence To sSwap
73431>>>>>>>>>>>    If (sSkip<>"") Begin
73433>>>>>>>>>>>      // temporarily replace our skip sequence with the swapvalue
73433>>>>>>>>>>>      Move sLine To sOld
73434>>>>>>>>>>>      Move (Replaces(sSkip,sLine,sSwap)) To sLine
73435>>>>>>>>>>>      Move (sOld<>sLine) To bSwapped
73436>>>>>>>>>>>    End
73436>>>>>>>>>>>>
73436>>>>>>>>>>>    If (psSepCharacter(Self)) Eq " " ;      Move 1     To iBlank
73439>>>>>>>>>>>    Repeat
73439>>>>>>>>>>>>
73439>>>>>>>>>>>      Increment iCount
73440>>>>>>>>>>>      Move (Pos(psSepCharacter(Self),sLine))  To iPos
73441>>>>>>>>>>>      If iPos Eq 0 ;        Move (Length(sLine))       To iPos
73444>>>>>>>>>>>
73444>>>>>>>>>>>      Move (Left(sLine,iPos+iSepL-1))         To sPart
73445>>>>>>>>>>>      Move (Replace(sPart,sLine,""))          To sLine
73446>>>>>>>>>>>      If (Right(sPart,iSepL)) Eq (psSepCharacter(Self)) ;        Move (Left(sPart,Length(sPart)-iSepL))  To sPart
73449>>>>>>>>>>>      If iBlank ;        Move (LTrim(sLine))               To sLine
73452>>>>>>>>>>>
73452>>>>>>>>>>>      // *WvA: 11/09/2005 Added logic to skip parsing of specific parts.
73452>>>>>>>>>>>      If ((bSwapped) And (Pos(sSwap,sPart)>0)) Begin
73454>>>>>>>>>>>        // Move our skip sequence back in the part just before storing it.
73454>>>>>>>>>>>        Move (Replaces(sSwap,sPart,sSkip)) To sPart
73455>>>>>>>>>>>      End
73455>>>>>>>>>>>>
73455>>>>>>>>>>>      If (Not(piSkipEmptyParts(Self))) ;        Set Value Item (Item_Count(Self)) To sPart
73458>>>>>>>>>>>      Else If (Trim(sPart)) Ne "" ;        Set Value Item (Item_Count(Self)) To sPart
73462>>>>>>>>>>>      If iCount Gt 500 Begin
73464>>>>>>>>>>>        //                Send Info_Box "Failure!"
73464>>>>>>>>>>>        Procedure_Return
73465>>>>>>>>>>>      End
73465>>>>>>>>>>>>
73465>>>>>>>>>>>    Until (sLine Eq "")
73467>>>>>>>>>>>  End_Procedure
73468>>>>>>>>>>>
73468>>>>>>>>>>>  // An easy procedure to init the LineParser.
73468>>>>>>>>>>>  Procedure Init String sSepCharacter Integer iSkipEmptyParts
73470>>>>>>>>>>>    Set psSepCharacter      To sSepCharacter
73471>>>>>>>>>>>    Set piSkipEmptyParts    To iSkipEmptyParts
73472>>>>>>>>>>>  End_Procedure
73473>>>>>>>>>>>End_Class
73474>>>>>>>>>>>
73474>>>>>>>>>>>
73474>>>>>>>>>Use Set.Pkg                     // Class: Set
73474>>>>>>>>>Use mUserAndComputerName.pkg    // Functions to get the User and the ComputerName.
Including file: mUserAndComputerName.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mUserAndComputerName.pkg)
73474>>>>>>>>>>>//*****************************************************************************************
73474>>>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73474>>>>>>>>>>>// All rights reserved.
73474>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73474>>>>>>>>>>>//
73474>>>>>>>>>>>// $FileName    : mUserAndComputerName.pkg
73474>>>>>>>>>>>// $ProjectName : General shared classes
73474>>>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73474>>>>>>>>>>>// $Created     : 12-31-2000 @ 09:00
73474>>>>>>>>>>>//
73474>>>>>>>>>>>// Contents:
73474>>>>>>>>>>>//
73474>>>>>>>>>>>// $Rev History
73474>>>>>>>>>>>//
73474>>>>>>>>>>>//*****************************************************************************************
73474>>>>>>>>>>>Use mPointer.pkg
Including file: mPointer.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mPointer.pkg)
73474>>>>>>>>>>>>>//TH-Header
73474>>>>>>>>>>>>>//*****************************************************************************************
73474>>>>>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73474>>>>>>>>>>>>>// All rights reserved.
73474>>>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73474>>>>>>>>>>>>>//
73474>>>>>>>>>>>>>// $FileName    : mPoiner.Pkg
73474>>>>>>>>>>>>>// $ProjectName : Shared Methods and Commands.
73474>>>>>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73474>>>>>>>>>>>>>// $Created     : 02-01-2001 @ 19:00
73474>>>>>>>>>>>>>//
73474>>>>>>>>>>>>>// Contents:
73474>>>>>>>>>>>>>//      Some useful commands and function when you use WinAPI Stuff or other
73474>>>>>>>>>>>>>//      DLL's which will ver often need pointers.
73474>>>>>>>>>>>>>//
73474>>>>>>>>>>>>>// $Rev History
73474>>>>>>>>>>>>>//
73474>>>>>>>>>>>>>//*****************************************************************************************
73474>>>>>>>>>>>>>
73474>>>>>>>>>>>>>// Implements a C++ Makro.
73474>>>>>>>>>>>>>Function MAKEWPARAM Global Integer iLow Integer iHi Returns Integer
73476>>>>>>>>>>>>>  Function_Return (iLow+(65536*iHI))
73477>>>>>>>>>>>>>End_Function
73478>>>>>>>>>>>>>
73478>>>>>>>>>>>>>// Defines a Variable only if not defined.
73478>>>>>>>>>>>>>// Checks if a string var isnt defined and defines it!
73478>>>>>>>>>>>>>// The same is done for the 2nd Para as a Pointer var.
73478>>>>>>>>>>>>>// Two usages:
73478>>>>>>>>>>>>>//  1.You have a string variable and want to create a pointer which contains its Addres.
73478>>>>>>>>>>>>>//  2.You'd like to String Buffer Init it to a length and Create and fille the Address Pointer
73478>>>>>>>>>>>>>// To avoid compilation errors when already declared. (VDF7+!)
73478>>>>>>>>>>>>>// Is a command that allows to put a string as pointer into a structure
73478>>>>>>>>>>>>>// Usage: PUT_POINTER sName  pName  "String..."  to sBuff at TYPE.FIELD
73478>>>>>>>>>>>
73478>>>>>>>>>>>
73478>>>>>>>>>>>Global_Variable String gsComputerName
73478>>>>>>>>>>>Global_Variable String gsUserName
73478>>>>>>>>>>>
73478>>>>>>>>>>>External_Function GetComputerName "GetComputerNameA" kernel32.dll Pointer lpszName Pointer lpdwcBuffer Returns Integer
73479>>>>>>>>>>>External_Function WNetGetUser1 "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUserName Pointer lpLength Returns Dword
73480>>>>>>>>>>>Function ComputerName For desktop Returns String
73482>>>>>>>>>>>    String  sName sLength sEnv
73482>>>>>>>>>>>    Integer iRetval
73482>>>>>>>>>>>    
73482>>>>>>>>>>>    Move (Repeat (Character (0), 25))                    To sName
73483>>>>>>>>>>>    Move (DwordToBytes (25))                             To sLength
73484>>>>>>>>>>>    Move (GetComputerName(AddressOf(sName), AddressOf(sLength)))   To iRetval
73485>>>>>>>>>>>    Move (cstring(sName))                                To sName
73486>>>>>>>>>>>    If sName Eq "" Move "DEFAULT"                        To sName
73489>>>>>>>>>>>    Move (cstring(sname))                                To gsComputerName
73490>>>>>>>>>>>    Function_Return gsComputerName
73491>>>>>>>>>>>End_Function
73492>>>>>>>>>>>
73492>>>>>>>>>>>Function NetzwerkBenutzer For desktop Returns String
73494>>>>>>>>>>>    String sName sLength
73494>>>>>>>>>>>    Integer iRetval
73494>>>>>>>>>>>
73494>>>>>>>>>>>    Move (Repeat (Character (0), 255))                   To sName
73495>>>>>>>>>>>    Move (DwordToBytes (255))                            To sLength
73496>>>>>>>>>>>    Move (WNetGetUser1 (0, AddressOf(sName), AddressOf(sLength)))   To iRetval
73497>>>>>>>>>>>    If iRetval Eq 0 Move (cstring(sName))                   To sName
73500>>>>>>>>>>>    Else Move "DEFAULT"                                     To sName
73502>>>>>>>>>>>    If sName Eq "" Move "DEFAULT"                           To sName
73505>>>>>>>>>>>    Move sName  To gsUserName
73506>>>>>>>>>>>    Function_Return sName
73507>>>>>>>>>>>End_Function
73508>>>>>>>>>>>
73508>>>>>>>>>>>
73508>>>>>>>>>>>
73508>>>>>>>>>>>Move (NetzwerkBenutzer(Desktop))    To gsUserName
73509>>>>>>>>>>>Move (ComputerName(Desktop))        To gsComputerName
73510>>>>>>>>>>>
73510>>>>>>>>>>>
73510>>>>>>>>>>>// Only for testing purposes...
73510>>>>>>>>>>>
73510>>>>>>>>>>>External_Function GetUserNameEx "GetUserNameExA" Secur32.DLL dword iFormat Pointer pName Integer iSize Returns Integer
73511>>>>>>>>>>>Function DFGetUserNameEx Global Integer iFormat Returns String
73513>>>>>>>>>>>    String  sName
73513>>>>>>>>>>>    String  sDW
73513>>>>>>>>>>>    Integer iRet
73513>>>>>>>>>>>    
73513>>>>>>>>>>>    Move (Repeat(Character(0),1024))            To sName
73514>>>>>>>>>>>    Move (DWordToBytes(1024))                   To sDW
73515>>>>>>>>>>>    Move (GetUserNameEx(iFormat,AddressOf(sName),AddressOf(sDW)))     To iRet
73516>>>>>>>>>>>    Function_Return (CString(sName))
73517>>>>>>>>>>>End_Function
73518>>>>>>>>>>>
73518>>>>>>>>>>>External_Function GetUserName "GetUserNameA" AdvApi32.DLL Pointer pName Integer iSize Returns Integer
73519>>>>>>>>>>>Function DFGetUserName Global Returns String
73521>>>>>>>>>>>    String  sName
73521>>>>>>>>>>>    String  sDW   
73521>>>>>>>>>>>    Integer iRet
73521>>>>>>>>>>>    
73521>>>>>>>>>>>    Move (Repeat(Character(0),1024))            To sName
73522>>>>>>>>>>>    Move (DWordToBytes(1024))                   To sDW
73523>>>>>>>>>>>    Move (GetUserName(AddressOf(sName),AddressOf(sDW))) To iRet
73524>>>>>>>>>>>    Function_Return (CString(sName))
73525>>>>>>>>>>>End_Function
73526>>>>>>>>>
73526>>>>>>>>>// Possible Ini modes:
73526>>>>>>>>>Define Ini_Global           For 0   // IniFilename is used as it is.        -> Global Settings.
73526>>>>>>>>>Define Ini_Computer         For 1   // The Computername is added at the End -> Settings for a special computer on a Networkdrive.
73526>>>>>>>>>Define Ini_User             For 2   // The UserName is added at the End     -> Settings for a special user on a Networkdrive.
73526>>>>>>>>>
73526>>>>>>>>>External_Function GetFocus "GetFocus" user32.dll Returns Integer
73527>>>>>>>>>
73527>>>>>>>>>// #COMMAND: SendEx
73527>>>>>>>>>// Creates Send Commands for all procedures which exist
73527>>>>>>>>>// If you give the command a procedure name "TestProc"
73527>>>>>>>>>// it will create send Test_Proc_1
73527>>>>>>>>>//                send Test_Proc_2
73527>>>>>>>>>//                ...
73527>>>>>>>>>//                send Test_Proc_X
73527>>>>>>>>>// as long as the procedures exist.
73527>>>>>>>>>
73527>>>>>>>>>// #COMMAND: ProcedureEx
73527>>>>>>>>>// Creates a Procedure with an addtional _X if the procedure doesnt exist.
73527>>>>>>>>>
73527>>>>>>>>>
73527>>>>>>>>>
73527>>>>>>>>>  // Has the ability to read an write from and to an IniFile.
73527>>>>>>>>>  // The main advantage of this class is that it stores all lines
73527>>>>>>>>>  // which are not known, so that they arent lost during a save.
73527>>>>>>>>>
73527>>>>>>>>>
73527>>>>>>>>>  Class cIniProperties is a Message
73528>>>>>>>>>    // Sets all Tag values.
73528>>>>>>>>>    Procedure onInit
73530>>>>>>>>>    End_Procedure
73531>>>>>>>>>    // For termination
73531>>>>>>>>>    Procedure INI_AddTagValues
73533>>>>>>>>>    End_Procedure
73534>>>>>>>>>
73534>>>>>>>>>
73534>>>>>>>>>    // Adding properties and setting default values
73534>>>>>>>>>    Procedure Construct_Object
73536>>>>>>>>>      Forward Send Construct_Object
73538>>>>>>>>>      Send Define_cIniProperties
73539>>>>>>>>>    End_Procedure
73540>>>>>>>>>
73540>>>>>>>>>    Procedure Define_cIniProperties
73542>>>>>>>>>
73542>>>>>>>>>      Property String  psSourceFile                   "cConfigManager.Ini" // Name of the inifile.
73543>>>>>>>>>      Property String  psSepCharacter                 ","                  // Seperating character.
73544>>>>>>>>>      Property Boolean pbUseDataPath                  True
73545>>>>>>>>>
73545>>>>>>>>>      // Data can be stored either global, user specific or
73545>>>>>>>>>      // computer specific.
73545>>>>>>>>>      // This is reached by adding ComputerName or UserName
73545>>>>>>>>>      // to the FileName.
73545>>>>>>>>>      Property Integer piLoadSaveMode                        Ini_Global           //[ Ini_User | Ini_Computer | Ini_Global ]
73546>>>>>>>>>
73546>>>>>>>>>      Object oUnusedLines is an Array                 // Storage for all unused (unknown) lines.
73548>>>>>>>>>      End_Object
73549>>>>>>>>>      Object oLineParser is a cLineParser             // Seperates a String into his parts.
73551>>>>>>>>>      End_Object
73552>>>>>>>>>
73552>>>>>>>>>      Object oTags is a Set                           // Known Tags
73554>>>>>>>>>      End_Object
73555>>>>>>>>>      Object oTagTypes is an Array                    // Type of the Tags
73557>>>>>>>>>      End_Object
73558>>>>>>>>>      Object oTagValues is an Array                   // Values for the Tags.
73560>>>>>>>>>      End_Object
73561>>>>>>>>>      Object oTagConnectedObjects is an Array         // ObjectIDs of the connected Obj.
73563>>>>>>>>>      End_Object
73564>>>>>>>>>
73564>>>>>>>>>      Send INI_AddTagValues
73565>>>>>>>>>      Send onInit
73566>>>>>>>>>    End_Procedure
73567>>>>>>>>>
73567>>>>>>>>>    // Connects an Object to a tag.
73567>>>>>>>>>    Procedure ConnectObjectToTag String sTag Integer hoID
73569>>>>>>>>>      Integer iC
73569>>>>>>>>>      Move (Uppercase(sTag))  To sTag
73570>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag  To iC
73571>>>>>>>>>      If iC Ge 0 Begin
73573>>>>>>>>>        Set Value Of (oTagConnectedObjects(Self)) Item iC   To hoID
73574>>>>>>>>>      End
73574>>>>>>>>>>
73574>>>>>>>>>    End_Procedure
73575>>>>>>>>>
73575>>>>>>>>>    Procedure Set ConnectObjectValue Integer hoDest String sValue
73577>>>>>>>>>      If hoDest Begin
73579>>>>>>>>>        If (checkbox_item_state(hoDest,0)) Eq 0 ;          Set Value        Of hoDest Item 0 To sValue
73582>>>>>>>>>        Else ;          Set Select_State Of hoDest Item 0 To sValue
73584>>>>>>>>>      End
73584>>>>>>>>>>
73584>>>>>>>>>    End_Procedure
73585>>>>>>>>>    Function ConnectObjectValue Integer hoDest Returns String
73587>>>>>>>>>      String sRet
73587>>>>>>>>>      If hoDest Begin
73589>>>>>>>>>        If (checkbox_item_state(hoDest,0)) Eq 0 ;          Move (Value(hoDest,0)) To sRet
73592>>>>>>>>>        Else ;          Move (Select_State(hoDest,0)) To sRet
73594>>>>>>>>>      End
73594>>>>>>>>>>
73594>>>>>>>>>      Function_Return sRet
73595>>>>>>>>>    End_Function
73596>>>>>>>>>
73596>>>>>>>>>
73596>>>>>>>>>
73596>>>>>>>>>    // Creates extended source files.
73596>>>>>>>>>    Function SourceFile Integer iMode Returns String
73598>>>>>>>>>      Integer iPos
73598>>>>>>>>>      String  sFile sExt
73598>>>>>>>>>      String  sPath
73598>>>>>>>>>      Get psSourceFile                                           To sFile
73599>>>>>>>>>      If iMode Eq Ini_User     ;        Get NetzwerkBenutzer To sExt
73602>>>>>>>>>      If iMode Eq Ini_Computer ;        Get ComputerName     To sExt
73605>>>>>>>>>
73605>>>>>>>>>      If (Left(Right(sFile,2),1)) Eq "." ;        Move 1                           To iPos
73608>>>>>>>>>      If (Left(Right(sFile,3),1)) Eq "." ;        Move 2                           To iPos
73611>>>>>>>>>      If (Left(Right(sFile,4),1)) Eq "." ;        Move 3                           To iPos
73614>>>>>>>>>      If iPos Gt 0 ;        Move (Insert(sExt,sFile,Length(sFile)-iPos))           To sFile
73617>>>>>>>>>      If (sFile<>"" and pbUseDataPath(Self)) Begin
73619>>>>>>>>>        Get psDataPath Of (phoWorkspace(ghoApplication)) To sPath
73620>>>>>>>>>        Get vFolderFormat sPath To sPath
73621>>>>>>>>>        Move (sPath+sFile) To sFile
73622>>>>>>>>>      End
73622>>>>>>>>>>
73622>>>>>>>>>      Function_Return sFile
73623>>>>>>>>>    End_Function
73624>>>>>>>>>
73624>>>>>>>>>    // Checks if a file exists.
73624>>>>>>>>>    Function INI_DoesFileExist String sFile Returns Integer
73626>>>>>>>>>      Integer iExist
73626>>>>>>>>>      If sFile Eq "" Begin
73628>>>>>>>>>        Function_Return 0
73629>>>>>>>>>      End
73629>>>>>>>>>>
73629>>>>>>>>>      Direct_Input sFile
73630>>>>>>>>>      If (Not(seqeof)) Move 1 To iExist
73633>>>>>>>>>      Close_Input
73634>>>>>>>>>      Function_Return iExist
73635>>>>>>>>>    End_Function
73636>>>>>>>>>
73636>>>>>>>>>    // Tries to find the best ini file.
73636>>>>>>>>>    Function SourceFileForRead Returns String
73638>>>>>>>>>      If (INI_DoesFileExist(Self, SourceFile(Self, piLoadSaveMode(Self)) )) Begin
73640>>>>>>>>>        Function_Return (SourceFile(Self, piLoadSaveMode(Self)))
73641>>>>>>>>>      End
73641>>>>>>>>>>
73641>>>>>>>>>      Function_Return (psSourceFile(Self))
73642>>>>>>>>>    End_Function
73643>>>>>>>>>
73643>>>>>>>>>    // Delivers the file for writing.
73643>>>>>>>>>    Function SourceFileForWrite Returns String
73645>>>>>>>>>      Function_Return (SourceFile(Self, piLoadSaveMode(Self)))
73646>>>>>>>>>    End_Function
73647>>>>>>>>>
73647>>>>>>>>>    // Deletes all items of a Tag, if it is multi!
73647>>>>>>>>>    Procedure DeleteAllItems String sTag
73649>>>>>>>>>      Integer iC iType hoID iC2 hoTmp
73649>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag      To iC
73650>>>>>>>>>      Get Value Of (oTagTypes(Self)) Item iC      To iType
73651>>>>>>>>>      Get Value Of (oTagValues(Self)) Item iC     To hoID
73652>>>>>>>>>      If iType If hoID Begin
73656>>>>>>>>>        For iC2 From 0 To (Item_Count(hoID)-1)
73662>>>>>>>>>>
73662>>>>>>>>>          Get Value Of hoID Item iC2              To hoTmp
73663>>>>>>>>>          If hoTmp ;            Send Destroy_Object                     To hoTmp
73666>>>>>>>>>        End
73667>>>>>>>>>>
73667>>>>>>>>>        Send Delete_Data                        To hoID
73668>>>>>>>>>      End
73668>>>>>>>>>>
73668>>>>>>>>>    End_Procedure
73669>>>>>>>>>
73669>>>>>>>>>    // Deletes one Item of a Tag if it is multi.
73669>>>>>>>>>    Procedure DeleteItem String sTag Integer iNr
73671>>>>>>>>>      Integer iC iType hoID hoTmp
73671>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag      To iC
73672>>>>>>>>>      Get Value Of (oTagTypes(Self)) Item iC      To iType
73673>>>>>>>>>      Get Value Of (oTagValues(Self)) Item iC     To hoID
73674>>>>>>>>>      If iType If hoID Begin
73678>>>>>>>>>        Get Value Of hoID Item iNr              To hoTmp
73679>>>>>>>>>        If hoTmp ;          Send Destroy_Object            To hoTmp
73682>>>>>>>>>        Send Delete_Item                        To hoID  iNr
73683>>>>>>>>>      End
73683>>>>>>>>>>
73683>>>>>>>>>    End_Procedure
73684>>>>>>>>>
73684>>>>>>>>>
73684>>>>>>>>>
73684>>>>>>>>>    // Deletes all values, not the defined tags (with "AddTag").
73684>>>>>>>>>    // Is sent before the data is loaded.
73684>>>>>>>>>    Procedure DoInit
73686>>>>>>>>>      Integer iC iType hoID iC2 hoTmp
73686>>>>>>>>>      For iC From 0 To (Item_Count(oTags(Self))-1)
73692>>>>>>>>>>
73692>>>>>>>>>        Get Value Of (oTagTypes(Self)) Item iC      To iType
73693>>>>>>>>>        Get Value Of (oTagValues(Self)) Item iC     To hoID
73694>>>>>>>>>        If iType Begin
73696>>>>>>>>>          For iC2 From 0 To (Item_Count(hoID)-1)
73702>>>>>>>>>>
73702>>>>>>>>>            Get Value Of hoID Item iC2              To hoTmp
73703>>>>>>>>>            If hoTmp ;              Send Destroy_Object                     To hoTmp
73706>>>>>>>>>          End
73707>>>>>>>>>>
73707>>>>>>>>>          Send Delete_Data                        To hoID
73708>>>>>>>>>        End
73708>>>>>>>>>>
73708>>>>>>>>>        Else ;          Send Delete_Data                       To hoID
73710>>>>>>>>>      End
73711>>>>>>>>>>
73711>>>>>>>>>    End_Procedure
73712>>>>>>>>>
73712>>>>>>>>>    // Adds a iniTag.
73712>>>>>>>>>    // The type can be multi of not. If it is a multi tag
73712>>>>>>>>>    // there can be more than one value with the same tag.
73712>>>>>>>>>    Procedure AddTag String sTag Integer iMulti
73714>>>>>>>>>      Integer iC hoID
73714>>>>>>>>>
73714>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag  To iC
73715>>>>>>>>>      If iC Lt 0 Begin
73717>>>>>>>>>        Object oIniTag is an Array
73719>>>>>>>>>          Move Self       To hoID
73720>>>>>>>>>        End_Object
73721>>>>>>>>>        Get Item_Count  Of (oTags(Self))                To iC
73722>>>>>>>>>        Set Value       Of (oTags(Self))        Item iC To sTag
73723>>>>>>>>>        Set Value       Of (oTagTypes(Self))    Item iC To iMulti
73724>>>>>>>>>        Set Value       Of (oTagValues(Self))   Item iC To hoID
73725>>>>>>>>>      End
73725>>>>>>>>>>
73725>>>>>>>>>    End_Procedure
73726>>>>>>>>>
73726>>>>>>>>>
73726>>>>>>>>>    // Sets the value of a Tag (and a SubTag)
73726>>>>>>>>>    Procedure SetIniValue String sTag Integer iMultiNr Integer iSubTagNr String sValue
73728>>>>>>>>>      Integer iC iType hoID hoID2 hoDest
73728>>>>>>>>>
73728>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag              To iC
73729>>>>>>>>>      If iC Ge 0 Begin
73731>>>>>>>>>        Get Value Of (oTagTypes(Self))              Item iC         To iType
73732>>>>>>>>>        Get Value Of (oTagValues(Self))             Item iC         To hoID
73733>>>>>>>>>        Get Value Of (oTagConnectedObjects(Self))   Item iC         To hoDest
73734>>>>>>>>>        If iType Begin
73736>>>>>>>>>          If iMultiNr Lt 0 Begin
73738>>>>>>>>>            Move (Item_Count(hoID))    To iMultiNr // To add new values
73739>>>>>>>>>          End
73739>>>>>>>>>>
73739>>>>>>>>>          Get Value Of hoID Item iMultiNr             To hoID2
73740>>>>>>>>>          If Not hoID2 Begin
73742>>>>>>>>>            Object oSubs is an Array
73744>>>>>>>>>              Move Self   To hoID2
73745>>>>>>>>>            End_Object
73746>>>>>>>>>            Set Value Of hoID Item iMultiNr         To hoID2
73747>>>>>>>>>          End
73747>>>>>>>>>>
73747>>>>>>>>>          Set Value Of hoID2 Item iSubTagNr           To sValue
73748>>>>>>>>>        End
73748>>>>>>>>>>
73748>>>>>>>>>        Else Begin
73749>>>>>>>>>          If hoDest Begin
73751>>>>>>>>>            Set ConnectObjectValue hoDest     To sValue
73752>>>>>>>>>          End
73752>>>>>>>>>>
73752>>>>>>>>>          Set Value Of hoID Item iSubTagNr            To sValue
73753>>>>>>>>>        End
73753>>>>>>>>>>
73753>>>>>>>>>      End
73753>>>>>>>>>>
73753>>>>>>>>>    End_Procedure
73754>>>>>>>>>
73754>>>>>>>>>
73754>>>>>>>>>    // Adds a value to a tag. If it is a mulit tag
73754>>>>>>>>>    // numerous values are possible, if not only one is stored and
73754>>>>>>>>>    // every call of AddTagValue for the same tag overwrites the existing
73754>>>>>>>>>    // value.
73754>>>>>>>>>    Procedure AddTagValue String sTag String sValue
73756>>>>>>>>>      Send SetIniValue sTag -1 0 sValue
73757>>>>>>>>>    End_Procedure
73758>>>>>>>>>
73758>>>>>>>>>
73758>>>>>>>>>    // Runs a line and returns true if the tag was known and false if not.
73758>>>>>>>>>    // This is called during the loading procedure and if it returns false
73758>>>>>>>>>    // the line is stored in "oUnusedLines".
73758>>>>>>>>>    // Given is the whole read line and an ObjectID of an array which contains
73758>>>>>>>>>    // all parts of the line.
73758>>>>>>>>>    Function DoLine String sLine Integer hoPartsID Returns Integer
73760>>>>>>>>>      Integer iC iC2 iMultiItemNr hoID
73760>>>>>>>>>      Get Find_Element Of (oTags(Self)) (Value(hoPartsID,0))  To iC
73761>>>>>>>>>      Get Value Of (oTagValues(Self)) Item iC                 To hoID
73762>>>>>>>>>      If hoID Begin
73764>>>>>>>>>        Get Item_Count Of hoID                          To iMultiItemNr
73765>>>>>>>>>      End
73765>>>>>>>>>>
73765>>>>>>>>>      If iC Ge 0 Begin
73767>>>>>>>>>        For iC2 From 1 To (Item_Count(hoPartsID)-1)
73773>>>>>>>>>>
73773>>>>>>>>>          Send SetIniValue (Value(hoPartsID,0)) iMultiItemNr (iC2-1) (Value(hoPartsID,iC2))
73774>>>>>>>>>        End
73775>>>>>>>>>>
73775>>>>>>>>>        If (Item_Count(hoPartsID)) Le 1 Begin
73777>>>>>>>>>          Send SetIniValue (Value(hoPartsID,0)) iMultiItemNr 1 ""
73778>>>>>>>>>        End
73778>>>>>>>>>>
73778>>>>>>>>>        Function_Return 1
73779>>>>>>>>>      End
73779>>>>>>>>>>
73779>>>>>>>>>      Function_Return 0
73780>>>>>>>>>    End_Function
73781>>>>>>>>>
73781>>>>>>>>>    // Reads the data out of the inifile.
73781>>>>>>>>>    Procedure LoadIni
73783>>>>>>>>>      String sLine
73783>>>>>>>>>      String sFile
73783>>>>>>>>>      Integer hoParser hoUnused
73783>>>>>>>>>
73783>>>>>>>>>      Move (oUnusedLines(Self))   To hoUnused
73784>>>>>>>>>      Move (oLineParser(Self))    To hoParser
73785>>>>>>>>>
73785>>>>>>>>>      Send DoInit                                 // Clears all values
73786>>>>>>>>>      Send Delete_Data            To hoUnused     // also the unusedlines.
73787>>>>>>>>>
73787>>>>>>>>>      Set psSepCharacter Of hoParser To (psSepCharacter(Self))
73788>>>>>>>>>        
73788>>>>>>>>>      Get SourceFileForRead To sFile
73789>>>>>>>>>
73789>>>>>>>>>      Direct_Input sFile
73790>>>>>>>>>      Repeat
73790>>>>>>>>>>
73790>>>>>>>>>        Readln sLine
73791>>>>>>>>>        If (Not(SeqEof)) Begin
73793>>>>>>>>>          Send ParseLine  To hoParser sLine
73794>>>>>>>>>          If (Not(DoLine(Self,sLine,hoParser))) Begin
73796>>>>>>>>>            Set Value Of hoUnused Item (Item_Count(hoUnused)) To sLine
73797>>>>>>>>>          End
73797>>>>>>>>>>
73797>>>>>>>>>        End
73797>>>>>>>>>>
73797>>>>>>>>>      Until (SeqEof)
73799>>>>>>>>>      Close_Input
73800>>>>>>>>>    End_Procedure
73801>>>>>>>>>
73801>>>>>>>>>    // Saves the data to the inifile.
73801>>>>>>>>>    Procedure SaveIni
73803>>>>>>>>>      Integer iC iC2 iC3 hoID iType hoUnused iCount hoID2 hoDest
73803>>>>>>>>>      String  sTag sSep
73803>>>>>>>>>      String  sFileName
73803>>>>>>>>>      Get psSepCharacter              To sSep
73804>>>>>>>>>      Get Item_Count Of (oTags(Self)) To iCount
73805>>>>>>>>>      Move (oUnusedLines(Self))       To hoUnused
73806>>>>>>>>>
73806>>>>>>>>>      Get SourceFileForWrite To sFileName
73807>>>>>>>>>      Direct_Output sFileName
73808>>>>>>>>>
73808>>>>>>>>>      For iC From 0 To (iCount-1)
73814>>>>>>>>>>
73814>>>>>>>>>        Get Value Of (oTags(Self))                  Item iC To sTag
73815>>>>>>>>>        Get Value Of (oTagTypes(Self))              Item iC To iType
73816>>>>>>>>>        Get Value Of (oTagValues(Self))             Item iC To hoID
73817>>>>>>>>>        Get Value Of (oTagConnectedObjects(Self))   Item iC To hoDest
73818>>>>>>>>>        If iType Begin
73820>>>>>>>>>          For iC2 From 0 To (Item_Count(hoID)-1)
73826>>>>>>>>>>
73826>>>>>>>>>            Get Value Of hoID   Item iC2        To hoID2
73827>>>>>>>>>            If hoID2 Begin
73829>>>>>>>>>              Write sTag
73830>>>>>>>>>              For iC3 From 0 To (Item_Count(hoID2)-1)
73836>>>>>>>>>>
73836>>>>>>>>>                Write sSep (Value(hoID2,iC3))
73838>>>>>>>>>              End
73839>>>>>>>>>>
73839>>>>>>>>>              Writeln
73840>>>>>>>>>            End
73840>>>>>>>>>>
73840>>>>>>>>>            Else Begin
73841>>>>>>>>>              Writeln sTag
73843>>>>>>>>>            End
73843>>>>>>>>>>
73843>>>>>>>>>          End
73844>>>>>>>>>>
73844>>>>>>>>>        End
73844>>>>>>>>>>
73844>>>>>>>>>        Else Begin
73845>>>>>>>>>          If hoDest Begin
73847>>>>>>>>>            Set Value Of hoID Item 0    To (ConnectObjectValue(Self,hoDest))
73848>>>>>>>>>          End
73848>>>>>>>>>>
73848>>>>>>>>>          Write sTag
73849>>>>>>>>>          For iC2 From 0 To (Item_Count(hoID)-1)
73855>>>>>>>>>>
73855>>>>>>>>>            Write sSep (Value(hoID,iC2))
73857>>>>>>>>>          End
73858>>>>>>>>>>
73858>>>>>>>>>          Writeln
73859>>>>>>>>>        End
73859>>>>>>>>>>
73859>>>>>>>>>      End
73860>>>>>>>>>>
73860>>>>>>>>>
73860>>>>>>>>>      For iC From 0 To (Item_Count(hoUnused)-1)
73866>>>>>>>>>>
73866>>>>>>>>>        Writeln (Value(hoUnused,iC))
73868>>>>>>>>>      End
73869>>>>>>>>>>
73869>>>>>>>>>
73869>>>>>>>>>      Close_Output
73870>>>>>>>>>    End_Procedure
73871>>>>>>>>>
73871>>>>>>>>>
73871>>>>>>>>>    // Delivers the value of a given tag.
73871>>>>>>>>>    Function IniValueEx String sTag Integer iMultiNr Integer iSubNr Returns String
73873>>>>>>>>>      Integer iC iType hoID hoDest
73873>>>>>>>>>      String sRetVal
73873>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag   To iC
73874>>>>>>>>>      Get Value Of (oTagTypes(Self))  Item iC  To iType
73875>>>>>>>>>      Get Value Of (oTagValues(Self)) Item iC  To hoID
73876>>>>>>>>>      Get Value Of (oTagConnectedObjects(Self))   Item iC         To hoDest
73877>>>>>>>>>      If iType Begin
73879>>>>>>>>>        If iMultiNr Ge (Item_Count(hoID)) Begin
73881>>>>>>>>>          Move (Item_Count(hoID)-1)  To iMultiNr
73882>>>>>>>>>        End  
73882>>>>>>>>>>
73882>>>>>>>>>        If hoID ;          Get Value Of hoID Item iMultiNr                              To hoID
73885>>>>>>>>>      End
73885>>>>>>>>>>
73885>>>>>>>>>      Else If hoDest If hoID Begin
73890>>>>>>>>>        Set Value Of hoID Item 0 To (ConnectObjectValue(Self,hoDest))
73891>>>>>>>>>      End
73891>>>>>>>>>>
73891>>>>>>>>>
73891>>>>>>>>>      If hoID ;        Move (Value(hoID,iSubNr)) to sRetVal
73894>>>>>>>>>      Else ;        Move "" To sRetVal      
73896>>>>>>>>>      Function_Return sRetVal
73897>>>>>>>>>    End_Function
73898>>>>>>>>>
73898>>>>>>>>>
73898>>>>>>>>>    // Delivers the value of a given tag.
73898>>>>>>>>>    Function IniValue String sTag Integer iNr Returns String
73900>>>>>>>>>      Function_Return (IniValueEx(Self,sTag,iNr,0))
73901>>>>>>>>>    End_Function
73902>>>>>>>>>
73902>>>>>>>>>    // Delivers the number of values of a given tag.
73902>>>>>>>>>    // If it isn't a multi tag 1 is returned.
73902>>>>>>>>>    Function IniValueCount String sTag Returns Integer
73904>>>>>>>>>      Integer iC iType hoID iRetval
73904>>>>>>>>>      Get Find_Element Of (oTags(Self)) sTag  To iC
73905>>>>>>>>>      Get Value Of (oTagTypes(Self)) Item iC  To iType
73906>>>>>>>>>      If iType Begin
73908>>>>>>>>>        Get Value Of (oTagValues(Self)) Item iC To hoID
73909>>>>>>>>>        Move (Item_Count(hoID)) To iRetval
73910>>>>>>>>>      End
73910>>>>>>>>>>
73910>>>>>>>>>      Else Begin
73911>>>>>>>>>        Move 1 To iRetval
73912>>>>>>>>>      End
73912>>>>>>>>>>
73912>>>>>>>>>      Function_Return iRetval
73913>>>>>>>>>    End_Function
73914>>>>>>>>>  End_Class
73915>>>>>>>>>
73915>>>>>>>>>
73915>>>>>>>>>  // Only for compatibility with earlier versions.
73915>>>>>>>>>  // Which I only used myself. :-)
73915>>>>>>>>>  Class cIniManager is a cIniProperties
73916>>>>>>>>>  End_Class
73917>>>>>>>>>
73917>>>>>>>>>  // Need to put this into a seperate command becouse the orginal Procedure and
73917>>>>>>>>>  // Function commands require the !$ to be set to the class name of the current class
73917>>>>>>>>>  // Can be used as the std commands eccexpt that the 1st argument must always be the
73917>>>>>>>>>  // the name of the last global Property = !$
73917>>>>>>>>>
73917>>>>>>>>>  // The top value of the Stack is the ClassName!!
73917>>>>>>>>>  // And every Stack Manipulation is done in a way that this is always the case!
73917>>>>>>>>>
73917>>>>>>>>>
73917>>>>>>>>>
73917>>>>>>>>>
73917>>>>>>>>>  // The top value of the Stack is the ClassName!!
73917>>>>>>>>>
73917>>>>>>>>>  // Saves two values to the Stack: String TagName and Numeric: MultiLine
73917>>>>>>>>>  // The 1st parameter need to be !$ becouse stack has to stay valid!
73917>>>>>>>>>
73917>>>>>>>>>
73917>>>>>>>>>  // Defines a MultiItem Property!
73917>>>>>>>>>
73917>>>>>>>>>  // Defines a Single Item Propery
73917>>>>>>>>>
73917>>>>>>>>>  // Defines a Ini Property whether MULTI Item or Single.
73917>>>>>>>>>
73917>>>>>>>>>  // Defines a sub-property for a multi item property.
73917>>>>>>>>>
73917>>>>>>>>>  // Defines a sub-property for a single item property.
73917>>>>>>>>>
73917>>>>>>>>>  // Defines a subproprty neither to a multi or a single (parent) property.
73917>>>>>>>>>
73917>>>>>>>>>
73917>>>>>>>>>  // For an easier writing of the Class Import.
73917>>>>>>>Use mPointer.pkg
73917>>>>>>>Use mAssignFilesToExecuteable.Pkg   // To Assign extention to this program.
Including file: mAssignFilesToExecuteAble.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mAssignFilesToExecuteAble.pkg)
73917>>>>>>>>>//TH-Header
73917>>>>>>>>>//*****************************************************************************************
73917>>>>>>>>>// Copyright (c) 2001 Michael Kurz
73917>>>>>>>>>// All rights reserved.
73917>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73917>>>>>>>>>//
73917>>>>>>>>>// $FileName    : mAssignFilesToExecuteAble.pkg
73917>>>>>>>>>// $ProjectName : Shared Methods
73917>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73917>>>>>>>>>// $Created     : 04-25-2001 @ 19:00
73917>>>>>>>>>//
73917>>>>>>>>>// Contents:
73917>>>>>>>>>//      Assigns Files (by their extentions) to an executeable
73917>>>>>>>>>//
73917>>>>>>>>>//      -AssignExecutAbleToTAG
73917>>>>>>>>>//      -AssignExecutAbleToTAG_OPEN
73917>>>>>>>>>//      -AssignExecutAbleToTAG_PRINT
73917>>>>>>>>>//      -AssignExtentionToTAG
73917>>>>>>>>>//
73917>>>>>>>>>// $Rev History
73917>>>>>>>>>//
73917>>>>>>>>>//*****************************************************************************************
73917>>>>>>>>>// Usage:
73917>>>>>>>>>//
73917>>>>>>>>>// -1st you have to create a Tag which stands for your executeable and what it is able to do
73917>>>>>>>>>//
73917>>>>>>>>>//      send AssignExecutAbleToTAG_OPEN "MyProgramName" "X:\PathOfMyProgram\...." "X:\TheIcontoShow\IconName.Ico" "Description" ShowExtentions(true|false)
73917>>>>>>>>>//
73917>>>>>>>>>// -Then you need to Assign the file extentions you want to the created TAG:
73917>>>>>>>>>//      send AssignExtentionToTAG ".TXT" "MyProgramName"
73917>>>>>>>>>//
73917>>>>>>>>>// -At least after some Associations for FileTypes have been changed, you need to send:
73917>>>>>>>>>//      send NofityShell_AssocChanged   // Informs the Shell that something has changed in that area.
73917>>>>>>>>>//
73917>>>>>>>>>//
73917>>>>>>>>>// Ready now all files with the Extention .TXT are opened with the program X:\PathofMy...
73917>>>>>>>>>
73917>>>>>>>>>Define SHCNE_RENAMEITEM          For |CI$00000001
73917>>>>>>>>>Define SHCNE_CREATE              For |CI$00000002
73917>>>>>>>>>Define SHCNE_DELETE              For |CI$00000004
73917>>>>>>>>>Define SHCNE_MKDIR               For |CI$00000008
73917>>>>>>>>>Define SHCNE_RMDIR               For |CI$00000010
73917>>>>>>>>>Define SHCNE_MEDIAINSERTED       For |CI$00000020
73917>>>>>>>>>Define SHCNE_MEDIAREMOVED        For |CI$00000040
73917>>>>>>>>>Define SHCNE_DRIVEREMOVED        For |CI$00000080
73917>>>>>>>>>Define SHCNE_DRIVEADD            For |CI$00000100
73917>>>>>>>>>Define SHCNE_NETSHARE            For |CI$00000200
73917>>>>>>>>>Define SHCNE_NETUNSHARE          For |CI$00000400
73917>>>>>>>>>Define SHCNE_ATTRIBUTES          For |CI$00000800
73917>>>>>>>>>Define SHCNE_UPDATEDIR           For |CI$00001000
73917>>>>>>>>>Define SHCNE_UPDATEITEM          For |CI$00002000
73917>>>>>>>>>Define SHCNE_SERVERDISCONNECT    For |CI$00004000
73917>>>>>>>>>Define SHCNE_UPDATEIMAGE         For |CI$00008000
73917>>>>>>>>>Define SHCNE_DRIVEADDGUI         For |CI$00010000
73917>>>>>>>>>Define SHCNE_RENAMEFOLDER        For |CI$00020000
73917>>>>>>>>>Define SHCNE_FREESPACE           For |CI$00040000
73917>>>>>>>>>Define SHCNE_EXTENDED_EVENT      For |CI$04000000
73917>>>>>>>>>Define SHCNE_ASSOCCHANGED        For |CI$08000000
73917>>>>>>>>>Define SHCNE_DISKEVENTS          For |CI$0002381F
73917>>>>>>>>>Define SHCNE_GLOBALEVENTS        For |CI$0C0581E0
73917>>>>>>>>>Define SHCNE_ALLEVENTS           For |CI$7FFFFFFF
73917>>>>>>>>>Define SHCNE_INTERRUPT           For |CI$80000000
73917>>>>>>>>>Define SHCNEE_ORDERCHANGED       For |CI$00000002
73917>>>>>>>>>Define SHCNE_RENAMEITEM          For |CI$00000001
73917>>>>>>>>>Define SHCNE_CREATE              For |CI$00000002
73917>>>>>>>>>Define SHCNE_DELETE              For |CI$00000004
73917>>>>>>>>>Define SHCNE_MKDIR               For |CI$00000008
73917>>>>>>>>>Define SHCNE_RMDIR               For |CI$00000010
73917>>>>>>>>>Define SHCNE_MEDIAINSERTED       For |CI$00000020
73917>>>>>>>>>Define SHCNE_MEDIAREMOVED        For |CI$00000040
73917>>>>>>>>>Define SHCNE_DRIVEREMOVED        For |CI$00000080
73917>>>>>>>>>Define SHCNE_DRIVEADD            For |CI$00000100
73917>>>>>>>>>Define SHCNE_NETSHARE            For |CI$00000200
73917>>>>>>>>>Define SHCNE_NETUNSHARE          For |CI$00000400
73917>>>>>>>>>Define SHCNE_ATTRIBUTES          For |CI$00000800
73917>>>>>>>>>Define SHCNE_UPDATEDIR           For |CI$00001000
73917>>>>>>>>>Define SHCNE_UPDATEITEM          For |CI$00002000
73917>>>>>>>>>Define SHCNE_SERVERDISCONNECT    For |CI$00004000
73917>>>>>>>>>Define SHCNE_UPDATEIMAGE         For |CI$00008000
73917>>>>>>>>>Define SHCNE_DRIVEADDGUI         For |CI$00010000
73917>>>>>>>>>Define SHCNE_RENAMEFOLDER        For |CI$00020000
73917>>>>>>>>>Define SHCNE_FREESPACE           For |CI$00040000
73917>>>>>>>>>Define SHCNE_EXTENDED_EVENT      For |CI$04000000
73917>>>>>>>>>Define SHCNE_ASSOCCHANGED        For |CI$08000000
73917>>>>>>>>>Define SHCNE_DISKEVENTS          For |CI$0002381F
73917>>>>>>>>>Define SHCNE_GLOBALEVENTS        For |CI$0C0581E0
73917>>>>>>>>>Define SHCNE_ALLEVENTS           For |CI$7FFFFFFF
73917>>>>>>>>>Define SHCNE_INTERRUPT           For |CI$80000000
73917>>>>>>>>>Define SHCNEE_ORDERCHANGED       For |CI$00000002
73917>>>>>>>>>
73917>>>>>>>>>
73917>>>>>>>>>// Flags
73917>>>>>>>>>// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
73917>>>>>>>>>Define SHCNF_IDLIST      For |CI$0000        // LPITEMIDLIST
73917>>>>>>>>>Define SHCNF_PATHA       For |CI$0001        // path name
73917>>>>>>>>>Define SHCNF_PRINTERA    For |CI$0002        // printer friendly name
73917>>>>>>>>>Define SHCNF_DWORD       For |CI$0003        // DWORD
73917>>>>>>>>>Define SHCNF_PATHW       For |CI$0005        // path name
73917>>>>>>>>>Define SHCNF_PRINTERW    For |CI$0006        // printer friendly name
73917>>>>>>>>>Define SHCNF_TYPE        For |CI$00FF
73917>>>>>>>>>Define SHCNF_FLUSH       For |CI$1000
73917>>>>>>>>>Define SHCNF_FLUSHNOWAIT For |CI$2000
73917>>>>>>>>>  Define SHCNF_PATH        For SHCNF_PATHA
73917>>>>>>>>>  Define SHCNF_PRINTER     For SHCNF_PRINTERA
73917>>>>>>>>>
73917>>>>>>>>>External_Function SHChangeNotify "SHChangeNotify" Shell32.DLL Integer wEventID Integer uFlags Pointer pItem1 Pointer pItem2 Returns Integer
73918>>>>>>>>>
73918>>>>>>>>>
73918>>>>>>>>>
73918>>>>>>>>>// Creates a ProgrammTag with the commandline to start for the given action.
73918>>>>>>>>>// Open, Print
73918>>>>>>>>>// Also an Icon for Displaying can be assigned.
73918>>>>>>>>>Procedure AssignExecutAbleToTAG Global String sTag String sAction String sPath String sIconPath String sDescription Integer iShowExtention
73920>>>>>>>>>//  Integer iRoot
73920>>>>>>>>>//  String  sBranch c34
73920>>>>>>>>>//  Move (Character(34))                                                        To c34
73920>>>>>>>>>//  get_Registry_Root                                                           To iRoot sBranch
73920>>>>>>>>>//  set_Registry_Root                                                           To HKEY_CLASSES_ROOT sTag
73920>>>>>>>>>//  Set_Foreign_Profile_String (Append("Shell\",sAction))"Command" ""           To (sPath+ " "+c34+"%1"+c34)
73920>>>>>>>>>//  If (sIconPath <> "") Begin
73920>>>>>>>>>//    Set_Foreign_Profile_String "DefaultIcon" "\" ""                             To sIconPath
73920>>>>>>>>>//  End
73920>>>>>>>>>//  If (sDescription <> "") Begin
73920>>>>>>>>>//    Set_Foreign_Profile_String "\" "\" ""                 To sDescription
73920>>>>>>>>>//  End
73920>>>>>>>>>//  If iShowExtention Begin
73920>>>>>>>>>//    Set_Foreign_Profile_String "\" "\" "AlwaysShowExt"    To ""
73920>>>>>>>>>//  End
73920>>>>>>>>>//  Set_Registry_Root                                                   To iRoot sBranch
73920>>>>>>>>>End_Procedure
73921>>>>>>>>>// For creating an Open Tag.
73921>>>>>>>>>Procedure AssignExecutAbleToTAG_OPEN Global String sTag String sPath String sIconPath String sDescription Integer iShowExtention
73923>>>>>>>>>//  Send AssignExecutAbleToTAG sTag "Open" sPath sIconPath sDescription iShowExtention
73923>>>>>>>>>End_Procedure
73924>>>>>>>>>// For creating a Print Tag.
73924>>>>>>>>>Procedure AssignExecutAbleToTAG_PRINT Global String sTag String sPath String sIconPath String sDescription Integer iShowExtention
73926>>>>>>>>>//  Send AssignExecutAbleToTAG sTag "Print" sPath sIconPath sDescription  iShowExtention
73926>>>>>>>>>End_Procedure
73927>>>>>>>>>// Assigns an Exention to a created TAG
73927>>>>>>>>>Procedure AssignExtentionToTAG Global String sExt String sTag
73929>>>>>>>>>//  Integer iRoot
73929>>>>>>>>>//  String  sBranch
73929>>>>>>>>>//  get_Registry_Root                                           To iRoot sBranch
73929>>>>>>>>>//  set_Registry_Root                                           To HKEY_CLASSES_ROOT sExt
73929>>>>>>>>>//  Set_Foreign_Profile_String "\" "\" ""                       To sTag
73929>>>>>>>>>//  set_Registry_Root       To  iRoot sBranch
73929>>>>>>>>>End_Procedure
73930>>>>>>>>>
73930>>>>>>>>>// Need to be sent to inform the System that these things have changed.
73930>>>>>>>>>Procedure NofityShell_AssocChanged Global
73932>>>>>>>>>//  Integer iRet
73932>>>>>>>>>//  Move (SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,0,0))  To iRet
73932>>>>>>>>>End_Procedure
73933>>>>>>>Use mEditorMacros.pkg               // Save and Load Macros.
Including file: mEditorMacros.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mEditorMacros.pkg)
73933>>>>>>>>>//TH-Header
73933>>>>>>>>>//*****************************************************************************************
73933>>>>>>>>>// Copyright (c)  2001 Michael Kurz
73933>>>>>>>>>// All rights reserved.
73933>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73933>>>>>>>>>//
73933>>>>>>>>>// $FileName    : D:\Entwicklung\Codemax\mEditorMacros.pkg
73933>>>>>>>>>// $ProjectName : Codemax
73933>>>>>>>>>// $Author      : Michael Kurz
73933>>>>>>>>>// $Created     : 17.05.2001  10:41
73933>>>>>>>>>//
73933>>>>>>>>>// Contents:
73933>>>>>>>>>//  Loading and saving Macros to Editor.Dat.
73933>>>>>>>>>//
73933>>>>>>>>>//*****************************************************************************************
73933>>>>>>>>>//TH-RevisionStart
73933>>>>>>>>>//TH-RevisionEnd
73933>>>>>>>>>
73933>>>>>>>>>Use vWin32fh.pkg
73933>>>>>>>>>Use mUserAndComputerName.pkg
73933>>>>>>>>>
73933>>>>>>>>>// EDITOR(20) file should not be used anymore (see Tools\TH3Workspace.pkg)
73933>>>>>>>>>//Open Editor
73933>>>>>>>>>
73933>>>>>>>>>// Deletes all Entries in Editor.Dat from a specific user an typ.
73933>>>>>>>>>Procedure Editor_DeleteAll String sUser String sTyp
73936>>>>>>>>>//    Clear Editor
73936>>>>>>>>>//    Move sUser      To Editor.User
73936>>>>>>>>>//    Move sTyp       To Editor.Type
73936>>>>>>>>>//    Repeat
73936>>>>>>>>>//        Find Gt Editor by Index.1
73936>>>>>>>>>//        If Editor.User Ne sUser Indicate found False
73936>>>>>>>>>//        If Editor.Type Ne sTyp  Indicate found False
73936>>>>>>>>>//        [found] Begin
73936>>>>>>>>>//            Lock
73936>>>>>>>>>//                Delete Editor
73936>>>>>>>>>//            Unlock
73936>>>>>>>>>//        End
73936>>>>>>>>>//    Until [Not found]
73936>>>>>>>>>End_Procedure
73937>>>>>>>>>
73937>>>>>>>>>// Saves one Macro to the editor DataBase.
73937>>>>>>>>>Procedure Editor_SaveMacro String sUser Integer iMacro
73940>>>>>>>>>//    Integer iSize
73940>>>>>>>>>//    Move (CMGetMacro(iMacro,0))     To iSize
73940>>>>>>>>>//    If iSize Eq 0 Procedure_Return
73940>>>>>>>>>//    Local_Buffer sBuff pBuff iSize
73940>>>>>>>>>//    Move (CMGetMacro(iMacro,pBuff)) To iSize
73940>>>>>>>>>//    Clear Editor
73940>>>>>>>>>//    Move sUser              To Editor.User
73940>>>>>>>>>//    Move "MACRO"            To Editor.Type
73940>>>>>>>>>//    Move iMacro             To Editor.File
73940>>>>>>>>>//    Lock
73940>>>>>>>>>//        Find Eq Editor by Index.1
73940>>>>>>>>>//        Move iSize          To Editor.Count
73940>>>>>>>>>//        Move sBuff          To Editor.Data
73940>>>>>>>>>//        Saverecord Editor
73940>>>>>>>>>//    Unlock
73940>>>>>>>>>End_Procedure
73941>>>>>>>>>// SAves all 10 possible macros with CodeMax.
73941>>>>>>>>>Procedure Editor_SaveAllMacros String sUser
73944>>>>>>>>>//    Integer iC
73944>>>>>>>>>//    Send Editor_DeleteAll sUser "MACRO"     // Delete all old macros.
73944>>>>>>>>>//    For iC From 0 To 9
73944>>>>>>>>>//        Send Editor_SaveMacro sUser iC
73944>>>>>>>>>//    End
73944>>>>>>>>>End_Procedure
73945>>>>>>>>>
73945>>>>>>>>>Procedure FloatDeleteAllMacros
73948>>>>>>>>>//    Send Editor_DeleteAll gsUserName "MACRO"
73948>>>>>>>>>End_Procedure
73949>>>>>>>>>
73949>>>>>>>>>// Saves one Macro to the editor DataBase.
73949>>>>>>>>>Procedure Editor_LoadMacro String sUser Integer iMacro
73952>>>>>>>>>//    Integer iRet
73952>>>>>>>>>//    Local_Buffer sBuff pBuff
73952>>>>>>>>>//    Clear Editor
73952>>>>>>>>>//    Move sUser              To Editor.User
73952>>>>>>>>>//    Move "MACRO"            To Editor.Type
73952>>>>>>>>>//    Move iMacro             To Editor.File
73952>>>>>>>>>//    Find Eq Editor by Index.1
73952>>>>>>>>>//    [found] Begin
73952>>>>>>>>>//        Move (Left(Editor.Data,Editor.Count))   To sBuff
73952>>>>>>>>>//        GetAddress Of sBuff                     To pBuff
73952>>>>>>>>>//        Move (CMSetMacro(iMacro,pBuff))         To iRet
73952>>>>>>>>>//    End
73952>>>>>>>>>End_Procedure
73953>>>>>>>>>// Tries to load all 10 Macros possible in Codemax.
73953>>>>>>>>>Procedure Editor_LoadAllMacros String sUser
73956>>>>>>>>>//    Integer iC
73956>>>>>>>>>//    For iC From 0 To 9
73956>>>>>>>>>//        Send Editor_LoadMacro sUser iC
73956>>>>>>>>>//    End
73956>>>>>>>>>End_Procedure
73957>>>>>>>>>
73957>>>>>>>Use mFiles.pkg
Including file: MFILES.PKG    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MFILES.PKG)
73957>>>>>>>>>//*****************************************************************************************
73957>>>>>>>>>// Copyright (c) 2000 Michael Kurz
73957>>>>>>>>>// All rights reserved.
73957>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
73957>>>>>>>>>//
73957>>>>>>>>>// $FileName    : mFiles.pkg
73957>>>>>>>>>// $ProjectName : Shared Methods
73957>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
73957>>>>>>>>>// $Created     : 01-25-2001 @ 19:00
73957>>>>>>>>>//
73957>>>>>>>>>// Contents:
73957>>>>>>>>>//      Some useful functions for filehandling.
73957>>>>>>>>>//      -RTrimBackSlah      // Removes all "\" at the end of a path. (String)
73957>>>>>>>>>//      -FileFromPath       // FileName without path from a complete path
73957>>>>>>>>>//      -PathFromPath       // PathName form a complete path without FileName
73957>>>>>>>>>//
73957>>>>>>>>>//
73957>>>>>>>>>// $Rev History
73957>>>>>>>>>//
73957>>>>>>>>>//*****************************************************************************************
73957>>>>>>>>>
73957>>>>>>>>>Use GlobalFunctionsProcedures.pkg
73957>>>>>>>>>External_function DLLCopyFile   "CopyFileA"    kernel32.dll Pointer pQuelle Pointer pZiel Integer bFailIfExists Returns Integer
73958>>>>>>>>>External_Function DLLDeleteFile "DeleteFileA"  kernel32.dll Pointer szSrc Returns Integer
73959>>>>>>>>>External_Function MoveFile      "MoveFileA"    kernel32.dll Pointer pOrig Pointer pRenamed Returns Integer
73960>>>>>>>>>External_Function GetTempPathEf "GetTempPathA" kernel32.dll Integer dwBufferLen Pointer lpBuffer Returns Integer
73961>>>>>>>>>
73961>>>>>>>>>// Removes all "\" characters from the right side of a string...
73961>>>>>>>>>Function RTrimBackSlash Global String sDir Returns String
73963>>>>>>>>>  Move (Trim(sDir))   To sDir
73964>>>>>>>>>  While ((Right(sDir,1)) Eq "\")  // Removes all "\" from the end...
73968>>>>>>>>>    Move (Left(sDir,Length(sDir)-1)) To sDir
73969>>>>>>>>>  End
73970>>>>>>>>>>
73970>>>>>>>>>  Function_Return sDir
73971>>>>>>>>>End_Function
73972>>>>>>>>>
73972>>>>>>>>>// Gives the part of the string that is found after the right most "\"
73972>>>>>>>>>// character.
73972>>>>>>>>>Function FileFromPath Global String sDir Returns String
73974>>>>>>>>>  Move (RTrimBackSlash(sDir)) To sDir // Removes all "\" from the right hand side!
73975>>>>>>>>>  While ((Pos("\",sDir)) Ne 0)        // Remove all path parts...
73979>>>>>>>>>    Move (Right(sDir, Length(sDir)-Pos("\",sDir)))  To sDir
73980>>>>>>>>>  End
73981>>>>>>>>>>
73981>>>>>>>>>  Function_Return sDir
73982>>>>>>>>>End_Function
73983>>>>>>>>>
73983>>>>>>>>>// Complement to FileFromPath: Returns everything except the string that
73983>>>>>>>>>// is found after the right most "\" character.
73983>>>>>>>>>Function PathFromPath Global String sDir Returns String
73985>>>>>>>>>  String sPath sTmp
73985>>>>>>>>>  Move (RTrimBackSlash(sDir)) To sDir // Removes all "\" from the right hand side!
73986>>>>>>>>>  While ((Pos("\",sDir)) Ne 0)        // Removes the file part (must be here or a directory part will be removed!)
73990>>>>>>>>>    Move (Left(sDir,Pos("\",sDir))) To sTmp
73991>>>>>>>>>    Move (Replace(sTmp,sDir,""))    To sDir
73992>>>>>>>>>    Append sPath sTmp
73993>>>>>>>>>  End
73994>>>>>>>>>>
73994>>>>>>>>>  If (Right(sPath,1)) Eq "\" ;    Move (Left(sPath,Length(sPath)-1))   To sPath    // No "\" at the right hand
73997>>>>>>>>>  Function_Return sPath
73998>>>>>>>>>End_Function
73999>>>>>>>>>
73999>>>>>>>>>
73999>>>>>>>>>//***********************************
73999>>>>>>>>>// A few casual string functions
73999>>>>>>>>>//
73999>>>>>>>>>//
73999>>>>>>>>>// Returns the position of a substring in a host string
73999>>>>>>>>>// but not from left but from right!
73999>>>>>>>>>Function PosR Global String sChar String sStr Returns Integer
74001>>>>>>>>>  String sTmp sSubst
74001>>>>>>>>>  Integer iPos
74001>>>>>>>>>  Move (Repeat("@",Length(sChar)))                        To sSubst
74002>>>>>>>>>  If sSubst Eq sChar ;    Move (Repeat(" ",Length(sChar)))     To sSubst
74005>>>>>>>>>  Move sStr                                               To sTmp
74006>>>>>>>>>  While (sTmp Contains sChar)
74010>>>>>>>>>    Move (Pos(sChar,sTmp))                              To iPos
74011>>>>>>>>>    Move (Replace(sChar,sTmp,sSubst))                   To sTmp
74012>>>>>>>>>  End
74013>>>>>>>>>>
74013>>>>>>>>>  If iPos Le 0 ;    Move 0                                     To iPos
74016>>>>>>>>>  Else ;    Move (Length(sStr)-iPos+1)                 To iPos
74018>>>>>>>>>  Function_Return iPos
74019>>>>>>>>>End_Function
74020>>>>>>>>>
74020>>>>>>>>>// Liefert den linken Teil eines Strings der von eine Substring
74020>>>>>>>>>// begrenzt wird! (wenn der String gar nicht enthalten ist wird
74020>>>>>>>>>// der Gesamte String geliefert!
74020>>>>>>>>>Function PartL Global String sChar String sStr Returns String
74022>>>>>>>>>  String sPart
74022>>>>>>>>>
74022>>>>>>>>>  If sChar In sStr ;    Move (Left(sStr,Pos(sChar,sStr)-1)) To sPart
74025>>>>>>>>>  Else ;    Move sStr To sPart
74027>>>>>>>>>  Function_Return sPart
74028>>>>>>>>>End_Function
74029>>>>>>>>>
74029>>>>>>>>>
74029>>>>>>>>>// Liefert den rechten Teil eines Strings der von eine Substring
74029>>>>>>>>>// begrenzt wird! (wenn der String gar nicht enthalten ist wird
74029>>>>>>>>>// der Gesamte String geliefert!
74029>>>>>>>>>Function PartR Global String sChar String sStr Returns String
74031>>>>>>>>>  If sChar In sStr ;    Function_Return (Right(sStr,PosR(sChar,sStr)-1))
74034>>>>>>>>>  Else ;    Function_Return sStr
74036>>>>>>>>>End_Function
74037>>>>>>>>>
74037>>>>>>>>>// Liefert den X-Ten Teil aus einem durch Trennzeichen geteilten String!
74037>>>>>>>>>Function PartX Global Integer iNr String sChar String sStr Returns String
74039>>>>>>>>>  Integer iC
74039>>>>>>>>>  String  sPart
74039>>>>>>>>>  For iC From 1 To iNr
74045>>>>>>>>>>
74045>>>>>>>>>    Move (PartL(sChar,sStr))        To sPart    // Den Linkenteil des Strings holen
74046>>>>>>>>>    Move (Replace(sPart,sStr,""))   To sStr     // Diesen Teil aus dem String entfernen
74047>>>>>>>>>    Move (Replace(sChar,sStr,""))   To sStr     // das Trennzeichen entfernen
74048>>>>>>>>>  Loop
74049>>>>>>>>>>
74049>>>>>>>>>  Function_Return sPart
74050>>>>>>>>>End_Function
74051>>>>>>>>>
74051>>>>>>>>>// CopyFileEx: Copy FirstFile to SecondFile and (optional) gives a MsgBox if copy failed
74051>>>>>>>>>// Added 18.05.01 Bernhard
74051>>>>>>>>>
74051>>>>>>>>>Function CopyFileEx Global String sQuell String sZiel Integer iMeldung Returns Integer
74053>>>>>>>>>  Boolean bOk
74053>>>>>>>>>  Integer iRet
74053>>>>>>>>>  String  sMeldung sDatei
74053>>>>>>>>>  String  sQuellFile sZielFile
74053>>>>>>>>>
74053>>>>>>>>>  Move (Trim(sZiel)) To sZiel
74054>>>>>>>>>  If (Right(sZiel,1)) In "\:" Begin
74056>>>>>>>>>    Move sQuell To sDatei
74057>>>>>>>>>    Repeat
74057>>>>>>>>>>
74057>>>>>>>>>      Move (Replace((Left(sDatei,Pos("\",sDatei))),sDatei,"")) To sDatei
74058>>>>>>>>>    Until (Not(sDatei Contains "\"))
74060>>>>>>>>>    Append sZiel sDatei
74061>>>>>>>>>  End
74061>>>>>>>>>>
74061>>>>>>>>>
74061>>>>>>>>>  Move sQuell To sQuellFile
74062>>>>>>>>>  Move sZiel To sZielFile
74063>>>>>>>>>  Append sQuellFile (Character(0))
74064>>>>>>>>>  Append sZielFile (Character(0))
74065>>>>>>>>>  Move (ToAnsi(sQuellFile)) To sQuellFile
74066>>>>>>>>>  Move (ToAnsi(sZielFile))  To sZielFile
74067>>>>>>>>>
74067>>>>>>>>>  Move (DLLCopyFile(AddressOf(sQuellFile),AddressOf(sZielFile),FALSE)) To iRet
74068>>>>>>>>>  If iRet Eq 0 If iMeldung Begin
74072>>>>>>>>>    Move ("Could not copy File "+sQuell+" to "+ sZiel+".") To sMeldung
74073>>>>>>>>>    Send Info_Box sMeldung
74074>>>>>>>>>    Move FALSE To bOk
74075>>>>>>>>>  End
74075>>>>>>>>>>
74075>>>>>>>>>  Else ;    Move TRUE To bOk
74077>>>>>>>>>  Function_Return bOk
74078>>>>>>>>>End_Function
74079>>>>>>>>>
74079>>>>>>>>>Function DoDeleteFile Global String sFile Returns Integer
74081>>>>>>>>>  Integer iRet
74081>>>>>>>>>  String  sS1
74081>>>>>>>>>  Move sFile         To sS1
74082>>>>>>>>>  Move (ToAnsi(sS1)) To sS1
74083>>>>>>>>>  Move (DLLDeleteFile(AddressOf(sS1)))   To iRet
74084>>>>>>>>>  Function_Return iRet
74085>>>>>>>>>End_Function
74086>>>>>>>>>
74086>>>>>>>>>
74086>>>>>>>>>// Fixed a bug if renaming a file that is not in the current directory
74086>>>>>>>>>// 19.2.02 Bernhard
74086>>>>>>>>>
74086>>>>>>>>>Procedure RenameFileEx Global String sQuell String sZiel Integer iMeldung
74088>>>>>>>>>  Integer iRet
74088>>>>>>>>>  String  sMeldung sQuellPath
74088>>>>>>>>>  String  sQuellFile sZielFile
74088>>>>>>>>>
74088>>>>>>>>>  Move sQuell To sQuellFile
74089>>>>>>>>>  Move sZiel  To sZielFile
74090>>>>>>>>>  If (Pos("\",sZielFile)) Eq 0 Begin
74092>>>>>>>>>    Move (PathFromPath(sQuellFile)) To sQuellPath
74093>>>>>>>>>    Move (sQuellPath + "\" + sZielFile) To sZielFile
74094>>>>>>>>>  End
74094>>>>>>>>>>
74094>>>>>>>>>
74094>>>>>>>>>  Get DoDeleteFile sZielFile To iRet
74095>>>>>>>>>
74095>>>>>>>>>  Append sQuellFile (Character(0))
74096>>>>>>>>>  Append sZielFile (Character(0))
74097>>>>>>>>>  Move (ToAnsi(sQuellFile)) To sQuellFile
74098>>>>>>>>>  Move (ToAnsi(sZielFile))  To sZielFile
74099>>>>>>>>>
74099>>>>>>>>>  Move (MoveFile(AddressOf(sQuellFile),AddressOf(sZielFile))) To iRet
74100>>>>>>>>>  If iRet Eq 0 If iMeldung Begin
74104>>>>>>>>>    Move ("Could not rename File "+sQuell+" to "+ sZiel+".") To sMeldung
74105>>>>>>>>>    Send Info_Box sMeldung
74106>>>>>>>>>  End
74106>>>>>>>>>>
74106>>>>>>>>>End_Procedure
74107>>>>>>>>>
74107>>>>>>>>>// TempDirectory: Returns the Temp-Directory of Windows. If the API-Call fails, the current-directory "." is returned
74107>>>>>>>>>// Added 19.02.02 Bernhard
74107>>>>>>>>>
74107>>>>>>>>>Function TempDirectory Global Returns String
74109>>>>>>>>>  Integer iRet
74109>>>>>>>>>  String  sDir
74109>>>>>>>>>  String  sTempDir
74109>>>>>>>>>
74109>>>>>>>>>  Move "." To sDir
74110>>>>>>>>>  Move (Repeat(Character(0),120)) To sTempDir
74111>>>>>>>>>  Move (GetTempPathEf(120,AddressOf(sTempDir))) To iRet
74112>>>>>>>>>  If iRet Ne 0 Begin
74114>>>>>>>>>    Move (ToOem(sTempDir)) To sTempDir
74115>>>>>>>>>    Move (cString(sTempDir)) To sTempDir
74116>>>>>>>>>    If (Right(sTempDir,1)) Eq "\" ;      Move (Left(sTempDir, ( (Length(sTempDir)) -1 ))) To sTempDir
74119>>>>>>>>>    Move sTempDir To sDir
74120>>>>>>>>>  End
74120>>>>>>>>>>
74120>>>>>>>>>  Function_Return sDir
74121>>>>>>>>>End_Function
74122>>>>>>>>>
74122>>>>>>>Use vWin32fh.pkg
74122>>>>>>>Use cSciCommandHotKeySupport.pkg
Including file: cSciCommandHotKeySupport.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciCommandHotKeySupport.pkg)
74122>>>>>>>>>Use cSciLexer.h
Including file: cSciLexer.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexer.h)
74122>>>>>>>>>>>Use DFAllent.pkg
74122>>>>>>>>>>>Use mStrConv.pkg
Including file: mStrConv.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mStrConv.pkg)
74122>>>>>>>>>>>>>//*****************************************************************************************
74122>>>>>>>>>>>>>// Copyright (c) 2000 Michael Kurz
74122>>>>>>>>>>>>>// All rights reserved.
74122>>>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
74122>>>>>>>>>>>>>//
74122>>>>>>>>>>>>>// $FileName    : mStrConv.Pkg
74122>>>>>>>>>>>>>// $ProjectName : Sahred Methods and Functions
74122>>>>>>>>>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
74122>>>>>>>>>>>>>// $Created     : 01-25-2001 @ 19:00
74122>>>>>>>>>>>>>//
74122>>>>>>>>>>>>>// Contents:
74122>>>>>>>>>>>>>//      Functions for converting strings to a string with its ASCII values and back.
74122>>>>>>>>>>>>>//
74122>>>>>>>>>>>>>//
74122>>>>>>>>>>>>>// $Rev History
74122>>>>>>>>>>>>>//
74122>>>>>>>>>>>>>//*****************************************************************************************
74122>>>>>>>>>>>>>
74122>>>>>>>>>>>>>// Flips a string Left-Right
74122>>>>>>>>>>>>>Function FlipStrLR Global String sStr Returns String
74124>>>>>>>>>>>>>  Integer iC iL
74124>>>>>>>>>>>>>  String  sRet
74124>>>>>>>>>>>>>  Move (Length(sStr)) To iL
74125>>>>>>>>>>>>>  For iC From 1 To iL
74131>>>>>>>>>>>>>>
74131>>>>>>>>>>>>>    Move (Append(Mid(sStr,1,iC),sRet))  To sRet
74132>>>>>>>>>>>>>  Loop
74133>>>>>>>>>>>>>>
74133>>>>>>>>>>>>>  Function_Return sRet
74134>>>>>>>>>>>>>End_Function
74135>>>>>>>>>>>>>
74135>>>>>>>>>>>>>// Converts a String to Ascii Code
74135>>>>>>>>>>>>>Function ConvertBuffToAscii Global String sBuff Returns String
74137>>>>>>>>>>>>>  String  sCh sRet
74137>>>>>>>>>>>>>  Integer iC iLength
74137>>>>>>>>>>>>>  Move (Length(sBuff))    To iLength
74138>>>>>>>>>>>>>  For iC From 1 To iLength
74144>>>>>>>>>>>>>>
74144>>>>>>>>>>>>>    Move (Mid(sBuff,1,iC))              To sCh
74145>>>>>>>>>>>>>    Move (Ascii(sCh))                   To sCh
74146>>>>>>>>>>>>>    Move (Right(Append("000",sCh),3))   To sCh
74147>>>>>>>>>>>>>    Append sRet sCh
74148>>>>>>>>>>>>>  Loop
74149>>>>>>>>>>>>>>
74149>>>>>>>>>>>>>  Function_Return sRet
74150>>>>>>>>>>>>>End_Function
74151>>>>>>>>>>>>>// Converts a String from Ascii back to str.
74151>>>>>>>>>>>>>Function ConvertAsciiToBuff Global String sBuff Returns String
74153>>>>>>>>>>>>>  String  sRet
74153>>>>>>>>>>>>>  Integer iCh iC iLength
74153>>>>>>>>>>>>>  Move (Length(sBuff))    To iLength
74154>>>>>>>>>>>>>  For iC From 1 To iLength
74160>>>>>>>>>>>>>>
74160>>>>>>>>>>>>>    Move (Mid(sBuff,3,iC))              To iCh
74161>>>>>>>>>>>>>    Append sRet (Character(iCh))
74162>>>>>>>>>>>>>    Move (iC+2)                         To iC   // 1+2=3
74163>>>>>>>>>>>>>  Loop
74164>>>>>>>>>>>>>>
74164>>>>>>>>>>>>>  Function_Return sRet
74165>>>>>>>>>>>>>End_Function
74166>>>>>>>>>>>>>
74166>>>>>>>>>>>>>Function ConvertIntegerArrayToAscii Integer[] Data Returns String
74169>>>>>>>>>>>>>  String  sCh sResult
74169>>>>>>>>>>>>>  Integer iC iLength
74169>>>>>>>>>>>>>  Integer iValue
74169>>>>>>>>>>>>>  Integer iLSB iMSB
74169>>>>>>>>>>>>>  UShort  usLSB usMSB
74169>>>>>>>>>>>>>
74169>>>>>>>>>>>>>  Move "" To sResult
74170>>>>>>>>>>>>>  Move (SizeOfArray(Data))    To iLength
74171>>>>>>>>>>>>>  If (iLength>0) Begin
74173>>>>>>>>>>>>>    For iC From 0 To (iLength-1)
74179>>>>>>>>>>>>>>
74179>>>>>>>>>>>>>      Move 0 To usLSB
74180>>>>>>>>>>>>>      Move 0 To usMSB
74181>>>>>>>>>>>>>      Move 0 To iLSB
74182>>>>>>>>>>>>>      Move 0 To iMSB
74183>>>>>>>>>>>>>      Move Data[iC] To iValue
74184>>>>>>>>>>>>>      Move (Low(iValue)) To iLSB
74185>>>>>>>>>>>>>      Move (Hi(iValue))  To iMSB
74186>>>>>>>>>>>>>      // Write out Low data part of integer
74186>>>>>>>>>>>>>      Move (Mod(iLSB,256))    To usLSB
74187>>>>>>>>>>>>>      Move ((iLSB-usLSB)/256) To usMSB
74188>>>>>>>>>>>>>      Move (Right(Append("000",String(usLSB)),3))   To sCh
74189>>>>>>>>>>>>>      Append sResult sCh
74190>>>>>>>>>>>>>      Move (Right(Append("000",String(usMSB)),3))   To sCh
74191>>>>>>>>>>>>>      Append sResult sCh
74192>>>>>>>>>>>>>      // Write out High data part of integer
74192>>>>>>>>>>>>>      Move (Mod(iMSB,256))    To usLSB
74193>>>>>>>>>>>>>      Move ((iMSB-usLSB)/256) To usMSB
74194>>>>>>>>>>>>>      Move (Right(Append("000",String(usLSB)),3))   To sCh
74195>>>>>>>>>>>>>      Append sResult sCh
74196>>>>>>>>>>>>>      Move (Right(Append("000",String(usMSB)),3))   To sCh
74197>>>>>>>>>>>>>      Append sResult sCh
74198>>>>>>>>>>>>>    Loop
74199>>>>>>>>>>>>>>
74199>>>>>>>>>>>>>  End
74199>>>>>>>>>>>>>>
74199>>>>>>>>>>>>>  Function_Return sResult
74200>>>>>>>>>>>>>End_Function
74201>>>>>>>>>>>>>
74201>>>>>>>>>>>>>// The Hammer string format is LSB/MSB in string with 3 characters per digit
74201>>>>>>>>>>>>>// Total is 4 characters per integer value.
74201>>>>>>>>>>>>>// There can be a bogus "000" at the end with which we do nothing.
74201>>>>>>>>>>>>>Function ConvertAsciiToIntegerArray Global String sBuff Returns Integer[]
74203>>>>>>>>>>>>>  Integer iCh iC iLength
74203>>>>>>>>>>>>>  Integer iValue
74203>>>>>>>>>>>>>  Integer iByte
74203>>>>>>>>>>>>>  Integer[] Results
74204>>>>>>>>>>>>>
74204>>>>>>>>>>>>>  Move (ResizeArray(Results,0)) To Results
74205>>>>>>>>>>>>>  Move (Length(sBuff))    To iLength
74206>>>>>>>>>>>>>  Move 0 To iByte
74207>>>>>>>>>>>>>  Move 0 To iValue
74208>>>>>>>>>>>>>  For iC From 1 To iLength
74214>>>>>>>>>>>>>>
74214>>>>>>>>>>>>>    Move (Mid(sBuff,3,iC))              To iCh
74215>>>>>>>>>>>>>    Move (iValue+(iCh*(256^iByte))) To iValue
74216>>>>>>>>>>>>>    Increment iByte
74217>>>>>>>>>>>>>    If (iByte=4) Begin
74219>>>>>>>>>>>>>      Move iValue To Results[SizeOfArray(Results)]
74220>>>>>>>>>>>>>      Move 0 To iByte
74221>>>>>>>>>>>>>      Move 0 To iValue
74222>>>>>>>>>>>>>    End
74222>>>>>>>>>>>>>>
74222>>>>>>>>>>>>>    Move (iC+2)                         To iC   // 1+2=3
74223>>>>>>>>>>>>>  Loop
74224>>>>>>>>>>>>>>
74224>>>>>>>>>>>>>  Function_Return Results
74225>>>>>>>>>>>>>End_Function
74226>>>>>>>>>>>>>
74226>>>>>>>>>>>>>
74226>>>>>>>>>>>>>// Converts one Digit from Decimal to Hex.
74226>>>>>>>>>>>>>Function IntToHexDigit Global Integer iInt Returns String
74228>>>>>>>>>>>>>  If iInt Lt 0 ;    Function_Return 0
74231>>>>>>>>>>>>>  If iInt Lt 10 ;    Function_Return iInt
74234>>>>>>>>>>>>>  If iInt Eq 10 ;    Function_Return "A"
74237>>>>>>>>>>>>>  If iInt Eq 11 ;    Function_Return "B"
74240>>>>>>>>>>>>>  If iInt Eq 12 ;    Function_Return "C"
74243>>>>>>>>>>>>>  If iInt Eq 13 ;    Function_Return "D"
74246>>>>>>>>>>>>>  If iInt Eq 14 ;    Function_Return "E"
74249>>>>>>>>>>>>>  If iInt Eq 15 ;    Function_Return "F"
74252>>>>>>>>>>>>>  Function_Return ""
74253>>>>>>>>>>>>>End_Function
74254>>>>>>>>>>>>>
74254>>>>>>>>>>>>>// Converts one Digit from Decimal to Hex.
74254>>>>>>>>>>>>>Function HexToIntDigit Global String sHEX Returns Integer
74256>>>>>>>>>>>>>  If sHex Eq "F" ;    Function_Return 15
74259>>>>>>>>>>>>>  If sHex Eq "E" ;    Function_Return 14
74262>>>>>>>>>>>>>  If sHex Eq "D" ;    Function_Return 13
74265>>>>>>>>>>>>>  If sHex Eq "C" ;    Function_Return 12
74268>>>>>>>>>>>>>  If sHex Eq "B" ;    Function_Return 11
74271>>>>>>>>>>>>>  If sHex Eq "A" ;    Function_Return 10
74274>>>>>>>>>>>>>  Function_Return sHex
74275>>>>>>>>>>>>>End_Function
74276>>>>>>>>>>>>>
74276>>>>>>>>>>>>>
74276>>>>>>>>>>>>>// Converts a decimal value (0-255)
74276>>>>>>>>>>>>>Function IntToHex Global Integer iInt Returns String
74278>>>>>>>>>>>>>  Integer iL iH
74278>>>>>>>>>>>>>  String  sRet
74278>>>>>>>>>>>>>  Move (iInt/16)      To iH
74279>>>>>>>>>>>>>  Move (Mod(iInt,16)) To iL
74280>>>>>>>>>>>>>  Append sRet (IntToHexDigit(iH)) (IntToHexDigit(iL))
74282>>>>>>>>>>>>>  Function_Return sRet
74283>>>>>>>>>>>>>End_Function
74284>>>>>>>>>>>>>
74284>>>>>>>>>>>>>// Converts a hex value to decimal (0-255)
74284>>>>>>>>>>>>>Function HexToInt Global String sHex Returns Integer
74286>>>>>>>>>>>>>  Function_Return ((HexToIntDigit(Left(sHex,1))*16)+(HexToIntDigit(Right(sHex,1))))
74287>>>>>>>>>>>>>End_Function
74288>>>>>>>>>>>>>
74288>>>>>>>>>>>>>// Converts a character to an Ascii value in Hex
74288>>>>>>>>>>>>>Function AsciiHex Global String sCH Returns String
74290>>>>>>>>>>>>>  Function_Return (IntToHex(Ascii(sCH)))
74291>>>>>>>>>>>>>End_Function
74292>>>>>>>>>>>>>// Converts a ascii hex value to a character.
74292>>>>>>>>>>>>>Function CharacterHex Global String sHex Returns String
74294>>>>>>>>>>>>>  Function_Return (Character(HexToInt(sHex)))
74295>>>>>>>>>>>>>End_Function
74296>>>>>>>>>>>>>
74296>>>>>>>>>>>>>
74296>>>>>>>>>>>>>// Converts a String to Ascii Code
74296>>>>>>>>>>>>>Function ConvertBuffToAsciiHex Global String sBuff Returns String
74298>>>>>>>>>>>>>  String  sCh sRet
74298>>>>>>>>>>>>>  Integer iC iLength
74298>>>>>>>>>>>>>  Move (Length(sBuff))    To iLength
74299>>>>>>>>>>>>>  For iC From 1 To iLength
74305>>>>>>>>>>>>>>
74305>>>>>>>>>>>>>    Move (Mid(sBuff,1,iC))              To sCh
74306>>>>>>>>>>>>>    Move (AsciiHex(sCh))                To sCh
74307>>>>>>>>>>>>>    Append sRet sCh
74308>>>>>>>>>>>>>  Loop
74309>>>>>>>>>>>>>>
74309>>>>>>>>>>>>>  Function_Return sRet
74310>>>>>>>>>>>>>End_Function
74311>>>>>>>>>>>>>// Converts a String from Ascii back to str.
74311>>>>>>>>>>>>>Function ConvertAsciiToBuffHex Global String sBuff Returns String
74313>>>>>>>>>>>>>  String  sCh sRet
74313>>>>>>>>>>>>>  Integer iC iLength
74313>>>>>>>>>>>>>  Move (Length(sBuff))    To iLength
74314>>>>>>>>>>>>>  For iC From 1 To iLength
74320>>>>>>>>>>>>>>
74320>>>>>>>>>>>>>    Move (Mid(sBuff,2,iC))              To sCh
74321>>>>>>>>>>>>>    Append sRet (CharacterHex(sCh))
74322>>>>>>>>>>>>>    Move (iC+1)                         To iC   // 1+1=2
74323>>>>>>>>>>>>>  Loop
74324>>>>>>>>>>>>>>
74324>>>>>>>>>>>>>  Function_Return sRet
74325>>>>>>>>>>>>>End_Function
74326>>>>>>>>>>>>>
74326>>>>>>>>>>>>>// Converts some special characters in a string.
74326>>>>>>>>>>>>>Function fsConvertString Global String sStr Returns String
74328>>>>>>>>>>>>>  String sCR
74328>>>>>>>>>>>>>  Append sCR (Character(13)) (Character(10))
74330>>>>>>>>>>>>>  Move (Replaces("\n",sStr,sCR))              To sStr
74331>>>>>>>>>>>>>  Move (Replaces("\t",sStr,Character(9)))     To sStr
74332>>>>>>>>>>>>>  Move (Replaces("\C34",sStr,Character(34)))  To sStr
74333>>>>>>>>>>>>>  Function_Return sStr
74334>>>>>>>>>>>>>End_Function
74335>>>>>>>>>>>Use mPointer.pkg
74335>>>>>>>>>>>Use tWinStructs.pkg
74335>>>>>>>>>>>Use cScintilla.h
Including file: cScintilla.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cScintilla.h)
74335>>>>>>>>>>>>>//TH-Header
74335>>>>>>>>>>>>>//*****************************************************************************************
74335>>>>>>>>>>>>>// Copyright (c)  2019 Antwise Solutions
74335>>>>>>>>>>>>>// All rights reserved.
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// $FileName    : \Pkg\cScintilla.h
74335>>>>>>>>>>>>>// $ProjectName : TheHammer4
74335>>>>>>>>>>>>>// $Authors     : Wil van Antwerpen
74335>>>>>>>>>>>>>// $Created     : 12.06.2019  22:31
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// Contents:
74335>>>>>>>>>>>>>//   Contains the defines that match the C declarations for the scintilla control that can
74335>>>>>>>>>>>>>//   be found at the scintilla project file scintilla.h
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// This header is licensed under the 2 clause BSD license as to make it as easy as possible to re-use if needed.
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// BSD License content start
74335>>>>>>>>>>>>>// *********************************************************************************************************
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// Copyright (c) 2019, Wil van Antwerpen
74335>>>>>>>>>>>>>// All rights reserved.
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// Redistribution and use in source and binary forms, with or without
74335>>>>>>>>>>>>>// modification, are permitted provided that the following conditions are met:
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// 1. Redistributions of source code must retain the above copyright notice, this
74335>>>>>>>>>>>>>//    list of conditions and the following disclaimer.
74335>>>>>>>>>>>>>// 2. Redistributions in binary form must reproduce the above copyright notice,
74335>>>>>>>>>>>>>//    this list of conditions and the following disclaimer in the documentation
74335>>>>>>>>>>>>>//    and/or other materials provided with the distribution.
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
74335>>>>>>>>>>>>>// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
74335>>>>>>>>>>>>>// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
74335>>>>>>>>>>>>>// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
74335>>>>>>>>>>>>>// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
74335>>>>>>>>>>>>>// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
74335>>>>>>>>>>>>>// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
74335>>>>>>>>>>>>>// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
74335>>>>>>>>>>>>>// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
74335>>>>>>>>>>>>>// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>// The views and conclusions contained in the software and documentation are those
74335>>>>>>>>>>>>>// of the authors and should not be interpreted as representing official policies,
74335>>>>>>>>>>>>>// either expressed or implied, of the VDF-Guidance / Hammer Project.
74335>>>>>>>>>>>>>// *********************************************************************************************************
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>//*****************************************************************************************
74335>>>>>>>>>>>>>//TH-RevisionStart
74335>>>>>>>>>>>>>// ********************
74335>>>>>>>>>>>>>// MODIFICATION SUMMARY
74335>>>>>>>>>>>>>// ********************
74335>>>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
74335>>>>>>>>>>>>>//TH-RevisionEnd
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>// Note that the following defines come from the Scintilla.h file in the scintilla project
74335>>>>>>>>>>>>>// These files are generated from the Scintilla.iface file, so we will have to compare that
74335>>>>>>>>>>>>>// file every time!
74335>>>>>>>>>>>>>Define INVALID_POSITION                        For -1
74335>>>>>>>>>>>>>Define SCI_START                               For 2000
74335>>>>>>>>>>>>>Define SCI_OPTIONAL_START                      For 3000
74335>>>>>>>>>>>>>Define SCI_LEXER_START                         For 4000
74335>>>>>>>>>>>>>Define SCI_ADDTEXT                             For 2001
74335>>>>>>>>>>>>>Define SCI_ADDSTYLEDTEXT                       For 2002
74335>>>>>>>>>>>>>Define SCI_INSERTTEXT                          For 2003
74335>>>>>>>>>>>>>Define SCI_CHANGEINSERTION                     For 2672
74335>>>>>>>>>>>>>Define SCI_CLEARALL                            For 2004
74335>>>>>>>>>>>>>Define SCI_DELETERANGE                         For 2645
74335>>>>>>>>>>>>>Define SCI_CLEARDOCUMENTSTYLE                  For 2005
74335>>>>>>>>>>>>>Define SCI_GETLENGTH                           For 2006
74335>>>>>>>>>>>>>Define SCI_GETCHARAT                           For 2007
74335>>>>>>>>>>>>>Define SCI_GETCURRENTPOS                       For 2008
74335>>>>>>>>>>>>>Define SCI_GETANCHOR                           For 2009
74335>>>>>>>>>>>>>Define SCI_GETSTYLEAT                          For 2010
74335>>>>>>>>>>>>>Define SCI_REDO                                For 2011
74335>>>>>>>>>>>>>Define SCI_SETUNDOCOLLECTION                   For 2012
74335>>>>>>>>>>>>>Define SCI_SELECTALL                           For 2013
74335>>>>>>>>>>>>>Define SCI_SETSAVEPOINT                        For 2014
74335>>>>>>>>>>>>>Define SCI_GETSTYLEDTEXT                       For 2015
74335>>>>>>>>>>>>>Define SCI_CANREDO                             For 2016
74335>>>>>>>>>>>>>Define SCI_MARKERLINEFROMHANDLE                For 2017
74335>>>>>>>>>>>>>Define SCI_MARKERDELETEHANDLE                  For 2018
74335>>>>>>>>>>>>>Define SCI_GETUNDOCOLLECTION                   For 2019
74335>>>>>>>>>>>>>Define SCWS_INVISIBLE                          For 0
74335>>>>>>>>>>>>>Define SCWS_VISIBLEALWAYS                      For 1
74335>>>>>>>>>>>>>Define SCWS_VISIBLEAFTERINDENT                 For 2
74335>>>>>>>>>>>>>Define SCWS_VISIBLEONLYININDENT                For 3
74335>>>>>>>>>>>>>Define SCI_GETVIEWWS                           For 2020
74335>>>>>>>>>>>>>Define SCI_SETVIEWWS                           For 2021
74335>>>>>>>>>>>>>Define SCTD_LONGARROW                          For 0
74335>>>>>>>>>>>>>Define SCTD_STRIKEOUT                          For 1
74335>>>>>>>>>>>>>Define SCI_GETTABDRAWMODE                      For 2698
74335>>>>>>>>>>>>>Define SCI_SETTABDRAWMODE                      For 2699
74335>>>>>>>>>>>>>Define SCI_POSITIONFROMPOINT                   For 2022
74335>>>>>>>>>>>>>Define SCI_POSITIONFROMPOINTCLOSE              For 2023
74335>>>>>>>>>>>>>Define SCI_GOTOLINE                            For 2024
74335>>>>>>>>>>>>>Define SCI_GOTOPOS                             For 2025
74335>>>>>>>>>>>>>Define SCI_SETANCHOR                           For 2026
74335>>>>>>>>>>>>>Define SCI_GETCURLINE                          For 2027
74335>>>>>>>>>>>>>Define SCI_GETENDSTYLED                        For 2028
74335>>>>>>>>>>>>>Define SC_EOL_CRLF                             For 0
74335>>>>>>>>>>>>>Define SC_EOL_CR                               For 1
74335>>>>>>>>>>>>>Define SC_EOL_LF                               For 2
74335>>>>>>>>>>>>>Define SCI_CONVERTEOLS                         For 2029
74335>>>>>>>>>>>>>Define SCI_GETEOLMODE                          For 2030
74335>>>>>>>>>>>>>Define SCI_SETEOLMODE                          For 2031
74335>>>>>>>>>>>>>Define SCI_STARTSTYLING                        For 2032
74335>>>>>>>>>>>>>Define SCI_SETSTYLING                          For 2033
74335>>>>>>>>>>>>>Define SCI_GETBUFFEREDDRAW                     For 2034
74335>>>>>>>>>>>>>Define SCI_SETBUFFEREDDRAW                     For 2035
74335>>>>>>>>>>>>>Define SCI_SETTABWIDTH                         For 2036
74335>>>>>>>>>>>>>Define SCI_GETTABWIDTH                         For 2121
74335>>>>>>>>>>>>>Define SCI_CLEARTABSTOPS                       For 2675
74335>>>>>>>>>>>>>Define SCI_ADDTABSTOP                          For 2676
74335>>>>>>>>>>>>>Define SCI_GETNEXTTABSTOP                      For 2677
74335>>>>>>>>>>>>>Define SC_CP_UTF8                              For 65001
74335>>>>>>>>>>>>>Define SCI_SETCODEPAGE                         For 2037
74335>>>>>>>>>>>>>Define SC_IME_WINDOWED                         For 0
74335>>>>>>>>>>>>>Define SC_IME_INLINE                           For 1
74335>>>>>>>>>>>>>Define SCI_GETIMEINTERACTION                   For 2678
74335>>>>>>>>>>>>>Define SCI_SETIMEINTERACTION                   For 2679
74335>>>>>>>>>>>>>Define MARKER_MAX                              For 31
74335>>>>>>>>>>>>>Define SC_MARK_CIRCLE                          For 0
74335>>>>>>>>>>>>>Define SC_MARK_ROUNDRECT                       For 1
74335>>>>>>>>>>>>>Define SC_MARK_ARROW                           For 2
74335>>>>>>>>>>>>>Define SC_MARK_SMALLRECT                       For 3
74335>>>>>>>>>>>>>Define SC_MARK_SHORTARROW                      For 4
74335>>>>>>>>>>>>>Define SC_MARK_EMPTY                           For 5
74335>>>>>>>>>>>>>Define SC_MARK_ARROWDOWN                       For 6
74335>>>>>>>>>>>>>Define SC_MARK_MINUS                           For 7
74335>>>>>>>>>>>>>Define SC_MARK_PLUS                            For 8
74335>>>>>>>>>>>>>Define SC_MARK_VLINE                           For 9
74335>>>>>>>>>>>>>Define SC_MARK_LCORNER                         For 10
74335>>>>>>>>>>>>>Define SC_MARK_TCORNER                         For 11
74335>>>>>>>>>>>>>Define SC_MARK_BOXPLUS                         For 12
74335>>>>>>>>>>>>>Define SC_MARK_BOXPLUSCONNECTED                For 13
74335>>>>>>>>>>>>>Define SC_MARK_BOXMINUS                        For 14
74335>>>>>>>>>>>>>Define SC_MARK_BOXMINUSCONNECTED               For 15
74335>>>>>>>>>>>>>Define SC_MARK_LCORNERCURVE                    For 16
74335>>>>>>>>>>>>>Define SC_MARK_TCORNERCURVE                    For 17
74335>>>>>>>>>>>>>Define SC_MARK_CIRCLEPLUS                      For 18
74335>>>>>>>>>>>>>Define SC_MARK_CIRCLEPLUSCONNECTED             For 19
74335>>>>>>>>>>>>>Define SC_MARK_CIRCLEMINUS                     For 20
74335>>>>>>>>>>>>>Define SC_MARK_CIRCLEMINUSCONNECTED            For 21
74335>>>>>>>>>>>>>Define SC_MARK_BACKGROUND                      For 22
74335>>>>>>>>>>>>>Define SC_MARK_DOTDOTDOT                       For 23
74335>>>>>>>>>>>>>Define SC_MARK_ARROWS                          For 24
74335>>>>>>>>>>>>>Define SC_MARK_PIXMAP                          For 25
74335>>>>>>>>>>>>>Define SC_MARK_FULLRECT                        For 26
74335>>>>>>>>>>>>>Define SC_MARK_LEFTRECT                        For 27
74335>>>>>>>>>>>>>Define SC_MARK_AVAILABLE                       For 28
74335>>>>>>>>>>>>>Define SC_MARK_UNDERLINE                       For 29
74335>>>>>>>>>>>>>Define SC_MARK_RGBAIMAGE                       For 30
74335>>>>>>>>>>>>>Define SC_MARK_BOOKMARK                        For 31
74335>>>>>>>>>>>>>Define SC_MARK_VERTICALBOOKMARK                For 32
74335>>>>>>>>>>>>>Define SC_MARK_CHARACTER                       For 10000
74335>>>>>>>>>>>>>// Hammer Custom
74335>>>>>>>>>>>>>Define SC_MARKNUM_LINEHIGHLIGHT                For 10
74335>>>>>>>>>>>>>Define SC_MARKNUM_BOOKMARK                     For 11
74335>>>>>>>>>>>>>Define SC_MARKNUM_CHANGEDLINE                  For 12
74335>>>>>>>>>>>>>Define SC_MARKNUM_CHANGEDLINESAVED             For 13
74335>>>>>>>>>>>>>Define SC_MARKNUM_DEBUGBREAKPOINT              For 14
74335>>>>>>>>>>>>>Define SC_MARKNUM_DEBUGCURRENTPOSITION         For 15
74335>>>>>>>>>>>>>// Hammer Custom ends
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDEREND                    For 25
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDEROPENMID                For 26
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDERMIDTAIL                For 27
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDERTAIL                   For 28
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDERSUB                    For 29
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDER                       For 30
74335>>>>>>>>>>>>>Define SC_MARKNUM_FOLDEROPEN                   For 31
74335>>>>>>>>>>>>>Define SC_MASK_FOLDERS                         For |CI$FE000000 // 0xFE000000
74335>>>>>>>>>>>>>// Hammer Custom
74335>>>>>>>>>>>>>Define SC_MASK_MARGIN                          For |CI$01000000 // 0x01000000 - allow symbol 24
74335>>>>>>>>>>>>>Define SC_MASK_BOOKMARK                        For |CI$00000800 // 0x00000800 - allow symbol 11, start counting from right, each bit is 1, starting from symbol 0
74335>>>>>>>>>>>>>Define SC_MASK_CHANGEDLINEUNSAVED              For |CI$00001000 // 0x00001000 - allow symbol 12 only
74335>>>>>>>>>>>>>Define SC_MASK_CHANGEDLINE                     For |CI$00003000 // 0x00003000 - allow symbol 12 and 13
74335>>>>>>>>>>>>>Define SC_MASK_DEBUGBREAKPOINT                 For |CI$00004000 // 0x00008000 - allow symbol 14
74335>>>>>>>>>>>>>Define SC_MASK_DEBUGCURRENTPOSITION            For |CI$00008000 // 0x00004000 - allow symbol 15
74335>>>>>>>>>>>>>Define SC_MASK_STATUS                          For |CI$0000C800 // 0x00000800 - allow symbol 11, 14 and 15
74335>>>>>>>>>>>>>// Hammer Custom ends
74335>>>>>>>>>>>>>Define SCI_MARKERDEFINE                        For 2040
74335>>>>>>>>>>>>>Define SCI_MARKERSETFORE                       For 2041
74335>>>>>>>>>>>>>Define SCI_MARKERSETBACK                       For 2042
74335>>>>>>>>>>>>>Define SCI_MARKERSETBACKSELECTED               For 2292
74335>>>>>>>>>>>>>Define SCI_MARKERENABLEHIGHLIGHT               For 2293
74335>>>>>>>>>>>>>Define SCI_MARKERADD                           For 2043
74335>>>>>>>>>>>>>Define SCI_MARKERDELETE                        For 2044
74335>>>>>>>>>>>>>Define SCI_MARKERDELETEALL                     For 2045
74335>>>>>>>>>>>>>Define SCI_MARKERGET                           For 2046
74335>>>>>>>>>>>>>Define SCI_MARKERNEXT                          For 2047
74335>>>>>>>>>>>>>Define SCI_MARKERPREVIOUS                      For 2048
74335>>>>>>>>>>>>>Define SCI_MARKERDEFINEPIXMAP                  For 2049
74335>>>>>>>>>>>>>Define SCI_MARKERADDSET                        For 2466
74335>>>>>>>>>>>>>Define SCI_MARKERSETALPHA                      For 2476
74335>>>>>>>>>>>>>Define SC_MAX_MARGIN                           For 4
74335>>>>>>>>>>>>>Define SC_MARGIN_SYMBOL                        For 0
74335>>>>>>>>>>>>>Define SC_MARGIN_NUMBER                        For 1
74335>>>>>>>>>>>>>Define SC_MARGIN_BACK                          For 2
74335>>>>>>>>>>>>>Define SC_MARGIN_FORE                          For 3
74335>>>>>>>>>>>>>Define SC_MARGIN_TEXT                          For 4
74335>>>>>>>>>>>>>Define SC_MARGIN_RTEXT                         For 5
74335>>>>>>>>>>>>>Define SC_MARGIN_COLOUR                        For 6
74335>>>>>>>>>>>>>Define SCI_SETMARGINTYPEN                      For 2240
74335>>>>>>>>>>>>>Define SCI_GETMARGINTYPEN                      For 2241
74335>>>>>>>>>>>>>Define SCI_SETMARGINWIDTHN                     For 2242
74335>>>>>>>>>>>>>Define SCI_GETMARGINWIDTHN                     For 2243
74335>>>>>>>>>>>>>Define SCI_SETMARGINMASKN                      For 2244
74335>>>>>>>>>>>>>Define SCI_GETMARGINMASKN                      For 2245
74335>>>>>>>>>>>>>Define SCI_SETMARGINSENSITIVEN                 For 2246
74335>>>>>>>>>>>>>Define SCI_GETMARGINSENSITIVEN                 For 2247
74335>>>>>>>>>>>>>Define SCI_SETMARGINCURSORN                    For 2248
74335>>>>>>>>>>>>>Define SCI_GETMARGINCURSORN                    For 2249
74335>>>>>>>>>>>>>Define SCI_SETMARGINBACKN                      For 2250
74335>>>>>>>>>>>>>Define SCI_GETMARGINBACKN                      For 2251
74335>>>>>>>>>>>>>Define SCI_SETMARGINS                          For 2252
74335>>>>>>>>>>>>>Define SCI_GETMARGINS                          For 2253
74335>>>>>>>>>>>>>Define STYLE_DEFAULT                           For 32
74335>>>>>>>>>>>>>Define STYLE_LINENUMBER                        For 33
74335>>>>>>>>>>>>>Define STYLE_BRACELIGHT                        For 34
74335>>>>>>>>>>>>>Define STYLE_BRACEBAD                          For 35
74335>>>>>>>>>>>>>Define STYLE_CONTROLCHAR                       For 36
74335>>>>>>>>>>>>>Define STYLE_INDENTGUIDE                       For 37
74335>>>>>>>>>>>>>Define STYLE_CALLTIP                           For 38
74335>>>>>>>>>>>>>Define STYLE_FOLDDISPLAYTEXT                   For 39
74335>>>>>>>>>>>>>// Hammer Custom
74335>>>>>>>>>>>>>Define STYLE_AUTOCOMPLETE                      For 40
74335>>>>>>>>>>>>>// Hammer Custom ends
74335>>>>>>>>>>>>>Define STYLE_LASTPREDEFINED                    For 40
74335>>>>>>>>>>>>>Define STYLE_MAX                               For 255
74335>>>>>>>>>>>>>Define SC_CHARSET_ANSI                         For 0
74335>>>>>>>>>>>>>Define SC_CHARSET_DEFAULT                      For 1
74335>>>>>>>>>>>>>Define SC_CHARSET_BALTIC                       For 186
74335>>>>>>>>>>>>>Define SC_CHARSET_CHINESEBIG5                  For 136
74335>>>>>>>>>>>>>Define SC_CHARSET_EASTEUROPE                   For 238
74335>>>>>>>>>>>>>Define SC_CHARSET_GB2312                       For 134
74335>>>>>>>>>>>>>Define SC_CHARSET_GREEK                        For 161
74335>>>>>>>>>>>>>Define SC_CHARSET_HANGUL                       For 129
74335>>>>>>>>>>>>>Define SC_CHARSET_MAC                          For 77
74335>>>>>>>>>>>>>Define SC_CHARSET_OEM                          For 255
74335>>>>>>>>>>>>>Define SC_CHARSET_RUSSIAN                      For 204
74335>>>>>>>>>>>>>Define SC_CHARSET_OEM866                       For 866
74335>>>>>>>>>>>>>Define SC_CHARSET_CYRILLIC                     For 1251
74335>>>>>>>>>>>>>Define SC_CHARSET_SHIFTJIS                     For 128
74335>>>>>>>>>>>>>Define SC_CHARSET_SYMBOL                       For 2
74335>>>>>>>>>>>>>Define SC_CHARSET_TURKISH                      For 162
74335>>>>>>>>>>>>>Define SC_CHARSET_JOHAB                        For 130
74335>>>>>>>>>>>>>Define SC_CHARSET_HEBREW                       For 177
74335>>>>>>>>>>>>>Define SC_CHARSET_ARABIC                       For 178
74335>>>>>>>>>>>>>Define SC_CHARSET_VIETNAMESE                   For 163
74335>>>>>>>>>>>>>Define SC_CHARSET_THAI                         For 222
74335>>>>>>>>>>>>>Define SC_CHARSET_8859_15                      For 1000
74335>>>>>>>>>>>>>Define SCI_STYLECLEARALL                       For 2050
74335>>>>>>>>>>>>>Define SCI_STYLESETFORE                        For 2051
74335>>>>>>>>>>>>>Define SCI_STYLESETBACK                        For 2052
74335>>>>>>>>>>>>>Define SCI_STYLESETBOLD                        For 2053
74335>>>>>>>>>>>>>Define SCI_STYLESETITALIC                      For 2054
74335>>>>>>>>>>>>>Define SCI_STYLESETSIZE                        For 2055
74335>>>>>>>>>>>>>Define SCI_STYLESETFONT                        For 2056
74335>>>>>>>>>>>>>Define SCI_STYLESETEOLFILLED                   For 2057
74335>>>>>>>>>>>>>Define SCI_STYLERESETDEFAULT                   For 2058
74335>>>>>>>>>>>>>Define SCI_STYLESETUNDERLINE                   For 2059
74335>>>>>>>>>>>>>Define SC_CASE_MIXED                           For 0
74335>>>>>>>>>>>>>Define SC_CASE_UPPER                           For 1
74335>>>>>>>>>>>>>Define SC_CASE_LOWER                           For 2
74335>>>>>>>>>>>>>Define SC_CASE_CAMEL                           For 3
74335>>>>>>>>>>>>>Define SCI_STYLEGETFORE                        For 2481
74335>>>>>>>>>>>>>Define SCI_STYLEGETBACK                        For 2482
74335>>>>>>>>>>>>>Define SCI_STYLEGETBOLD                        For 2483
74335>>>>>>>>>>>>>Define SCI_STYLEGETITALIC                      For 2484
74335>>>>>>>>>>>>>Define SCI_STYLEGETSIZE                        For 2485
74335>>>>>>>>>>>>>Define SCI_STYLEGETFONT                        For 2486
74335>>>>>>>>>>>>>Define SCI_STYLEGETEOLFILLED                   For 2487
74335>>>>>>>>>>>>>Define SCI_STYLEGETUNDERLINE                   For 2488
74335>>>>>>>>>>>>>Define SCI_STYLEGETCASE                        For 2489
74335>>>>>>>>>>>>>Define SCI_STYLEGETCHARACTERSET                For 2490
74335>>>>>>>>>>>>>Define SCI_STYLEGETVISIBLE                     For 2491
74335>>>>>>>>>>>>>Define SCI_STYLEGETCHANGEABLE                  For 2492
74335>>>>>>>>>>>>>Define SCI_STYLEGETHOTSPOT                     For 2493
74335>>>>>>>>>>>>>Define SCI_STYLESETCASE                        For 2060
74335>>>>>>>>>>>>>Define SC_FONT_SIZE_MULTIPLIER                 For 100
74335>>>>>>>>>>>>>Define SCI_STYLESETSIZEFRACTIONAL              For 2061
74335>>>>>>>>>>>>>Define SCI_STYLEGETSIZEFRACTIONAL              For 2062
74335>>>>>>>>>>>>>Define SC_WEIGHT_NORMAL                        For 400
74335>>>>>>>>>>>>>Define SC_WEIGHT_SEMIBOLD                      For 600
74335>>>>>>>>>>>>>Define SC_WEIGHT_BOLD                          For 700
74335>>>>>>>>>>>>>Define SCI_STYLESETWEIGHT                      For 2063
74335>>>>>>>>>>>>>Define SCI_STYLEGETWEIGHT                      For 2064
74335>>>>>>>>>>>>>Define SCI_STYLESETCHARACTERSET                For 2066
74335>>>>>>>>>>>>>Define SCI_STYLESETHOTSPOT                     For 2409
74335>>>>>>>>>>>>>Define SCI_SETSELFORE                          For 2067
74335>>>>>>>>>>>>>Define SCI_SETSELBACK                          For 2068
74335>>>>>>>>>>>>>Define SCI_GETSELALPHA                         For 2477
74335>>>>>>>>>>>>>Define SCI_SETSELALPHA                         For 2478
74335>>>>>>>>>>>>>Define SCI_GETSELEOLFILLED                     For 2479
74335>>>>>>>>>>>>>Define SCI_SETSELEOLFILLED                     For 2480
74335>>>>>>>>>>>>>Define SCI_SETCARETFORE                        For 2069
74335>>>>>>>>>>>>>Define SCI_ASSIGNCMDKEY                        For 2070
74335>>>>>>>>>>>>>Define SCI_CLEARCMDKEY                         For 2071
74335>>>>>>>>>>>>>Define SCI_CLEARALLCMDKEYS                     For 2072
74335>>>>>>>>>>>>>Define SCI_SETSTYLINGEX                        For 2073
74335>>>>>>>>>>>>>Define SCI_STYLESETVISIBLE                     For 2074
74335>>>>>>>>>>>>>Define SCI_GETCARETPERIOD                      For 2075
74335>>>>>>>>>>>>>Define SCI_SETCARETPERIOD                      For 2076
74335>>>>>>>>>>>>>Define SCI_SETWORDCHARS                        For 2077
74335>>>>>>>>>>>>>Define SCI_GETWORDCHARS                        For 2646
74335>>>>>>>>>>>>>Define SCI_SETCHARACTERCATEGORYOPTIMIZATION    For 2720
74335>>>>>>>>>>>>>Define SCI_GETCHARACTERCATEGORYOPTIMIZATION    For 2721
74335>>>>>>>>>>>>>Define SCI_BEGINUNDOACTION                     For 2078
74335>>>>>>>>>>>>>Define SCI_ENDUNDOACTION                       For 2079
74335>>>>>>>>>>>>>Define INDIC_PLAIN                             For 0
74335>>>>>>>>>>>>>Define INDIC_SQUIGGLE                          For 1
74335>>>>>>>>>>>>>Define INDIC_TT                                For 2
74335>>>>>>>>>>>>>Define INDIC_DIAGONAL                          For 3
74335>>>>>>>>>>>>>Define INDIC_STRIKE                            For 4
74335>>>>>>>>>>>>>Define INDIC_HIDDEN                            For 5
74335>>>>>>>>>>>>>Define INDIC_BOX                               For 6
74335>>>>>>>>>>>>>Define INDIC_ROUNDBOX                          For 7
74335>>>>>>>>>>>>>Define INDIC_STRAIGHTBOX                       For 8
74335>>>>>>>>>>>>>Define INDIC_DASH                              For 9
74335>>>>>>>>>>>>>Define INDIC_DOTS                              For 10
74335>>>>>>>>>>>>>Define INDIC_SQUIGGLELOW                       For 11
74335>>>>>>>>>>>>>Define INDIC_DOTBOX                            For 12
74335>>>>>>>>>>>>>Define INDIC_SQUIGGLEPIXMAP                    For 13
74335>>>>>>>>>>>>>Define INDIC_COMPOSITIONTHICK                  For 14
74335>>>>>>>>>>>>>Define INDIC_COMPOSITIONTHIN                   For 15
74335>>>>>>>>>>>>>Define INDIC_FULLBOX                           For 16
74335>>>>>>>>>>>>>Define INDIC_TEXTFORE                          For 17
74335>>>>>>>>>>>>>Define INDIC_POINT                             For 18
74335>>>>>>>>>>>>>Define INDIC_POINTCHARACTER                    For 19
74335>>>>>>>>>>>>>Define INDIC_GRADIENT                          For 20
74335>>>>>>>>>>>>>Define INDIC_GRADIENTCENTRE                    For 21
74335>>>>>>>>>>>>>Define INDIC_IME                               For 32
74335>>>>>>>>>>>>>Define INDIC_IME_MAX                           For 35
74335>>>>>>>>>>>>>Define INDIC_MAX                               For 35
74335>>>>>>>>>>>>>Define INDIC_CONTAINER                         For 8
74335>>>>>>>>>>>>>Define INDIC0_MASK                             For |CI$20  // 0x20
74335>>>>>>>>>>>>>Define INDIC1_MASK                             For |CI$40  // 0x40
74335>>>>>>>>>>>>>Define INDIC2_MASK                             For |CI$80  // 0x80
74335>>>>>>>>>>>>>Define INDICS_MASK                             For |CI$E0  // 0xE0
74335>>>>>>>>>>>>>Define SCI_INDICSETSTYLE                       For 2080
74335>>>>>>>>>>>>>Define SCI_INDICGETSTYLE                       For 2081
74335>>>>>>>>>>>>>Define SCI_INDICSETFORE                        For 2082
74335>>>>>>>>>>>>>Define SCI_INDICGETFORE                        For 2083
74335>>>>>>>>>>>>>Define SCI_INDICSETUNDER                       For 2510
74335>>>>>>>>>>>>>Define SCI_INDICGETUNDER                       For 2511
74335>>>>>>>>>>>>>Define SCI_INDICSETHOVERSTYLE                  For 2680
74335>>>>>>>>>>>>>Define SCI_INDICGETHOVERSTYLE                  For 2681
74335>>>>>>>>>>>>>Define SCI_INDICSETHOVERFORE                   For 2682
74335>>>>>>>>>>>>>Define SCI_INDICGETHOVERFORE                   For 2683
74335>>>>>>>>>>>>>Define SC_INDICVALUEBIT                        For |CI$1000000  // 0x1000000
74335>>>>>>>>>>>>>Define SC_INDICVALUEMASK                       For |CI$FFFFFF   // 0xFFFFFF
74335>>>>>>>>>>>>>Define SC_INDICFLAG_VALUEFORE                  For 1
74335>>>>>>>>>>>>>Define SCI_INDICSETFLAGS                       For 2684
74335>>>>>>>>>>>>>Define SCI_INDICGETFLAGS                       For 2685
74335>>>>>>>>>>>>>Define SCI_SETWHITESPACEFORE                   For 2084
74335>>>>>>>>>>>>>Define SCI_SETWHITESPACEBACK                   For 2085
74335>>>>>>>>>>>>>Define SCI_SETWHITESPACESIZE                   For 2086
74335>>>>>>>>>>>>>Define SCI_GETWHITESPACESIZE                   For 2087
74335>>>>>>>>>>>>>Define SCI_SETLINESTATE                        For 2092
74335>>>>>>>>>>>>>Define SCI_GETLINESTATE                        For 2093
74335>>>>>>>>>>>>>Define SCI_GETMAXLINESTATE                     For 2094
74335>>>>>>>>>>>>>Define SCI_GETCARETLINEVISIBLE                 For 2095
74335>>>>>>>>>>>>>Define SCI_SETCARETLINEVISIBLE                 For 2096
74335>>>>>>>>>>>>>Define SCI_GETCARETLINEBACK                    For 2097
74335>>>>>>>>>>>>>Define SCI_SETCARETLINEBACK                    For 2098
74335>>>>>>>>>>>>>Define SCI_GETCARETLINEFRAME                   For 2704
74335>>>>>>>>>>>>>Define SCI_SETCARETLINEFRAME                   For 2705
74335>>>>>>>>>>>>>Define SCI_STYLESETCHANGEABLE                  For 2099
74335>>>>>>>>>>>>>Define SCI_AUTOCSHOW                           For 2100
74335>>>>>>>>>>>>>Define SCI_AUTOCCANCEL                         For 2101
74335>>>>>>>>>>>>>Define SCI_AUTOCACTIVE                         For 2102
74335>>>>>>>>>>>>>Define SCI_AUTOCPOSSTART                       For 2103
74335>>>>>>>>>>>>>Define SCI_AUTOCCOMPLETE                       For 2104
74335>>>>>>>>>>>>>Define SCI_AUTOCSTOPS                          For 2105
74335>>>>>>>>>>>>>Define SCI_AUTOCSETSEPARATOR                   For 2106
74335>>>>>>>>>>>>>Define SCI_AUTOCGETSEPARATOR                   For 2107
74335>>>>>>>>>>>>>Define SCI_AUTOCSELECT                         For 2108
74335>>>>>>>>>>>>>Define SCI_AUTOCSETCANCELATSTART               For 2110
74335>>>>>>>>>>>>>Define SCI_AUTOCGETCANCELATSTART               For 2111
74335>>>>>>>>>>>>>Define SCI_AUTOCSETFILLUPS                     For 2112
74335>>>>>>>>>>>>>Define SCI_AUTOCSETCHOOSESINGLE                For 2113
74335>>>>>>>>>>>>>Define SCI_AUTOCGETCHOOSESINGLE                For 2114
74335>>>>>>>>>>>>>Define SCI_AUTOCSETIGNORECASE                  For 2115
74335>>>>>>>>>>>>>Define SCI_AUTOCGETIGNORECASE                  For 2116
74335>>>>>>>>>>>>>Define SCI_USERLISTSHOW                        For 2117
74335>>>>>>>>>>>>>Define SCI_AUTOCSETAUTOHIDE                    For 2118
74335>>>>>>>>>>>>>Define SCI_AUTOCGETAUTOHIDE                    For 2119
74335>>>>>>>>>>>>>// Hammer Custom
74335>>>>>>>>>>>>>Define SCI_AUTOCUSESTYLE                       For 2120
74335>>>>>>>>>>>>>// Hammer Custom Ends
74335>>>>>>>>>>>>>Define SCI_AUTOCSETDROPRESTOFWORD              For 2270
74335>>>>>>>>>>>>>Define SCI_AUTOCGETDROPRESTOFWORD              For 2271
74335>>>>>>>>>>>>>Define SCI_REGISTERIMAGE                       For 2405
74335>>>>>>>>>>>>>Define SCI_CLEARREGISTEREDIMAGES               For 2408
74335>>>>>>>>>>>>>Define SCI_AUTOCGETTYPESEPARATOR               For 2285
74335>>>>>>>>>>>>>Define SCI_AUTOCSETTYPESEPARATOR               For 2286
74335>>>>>>>>>>>>>Define SCI_AUTOCSETMAXWIDTH                    For 2208
74335>>>>>>>>>>>>>Define SCI_AUTOCGETMAXWIDTH                    For 2209
74335>>>>>>>>>>>>>Define SCI_AUTOCSETMAXHEIGHT                   For 2210
74335>>>>>>>>>>>>>Define SCI_AUTOCGETMAXHEIGHT                   For 2211
74335>>>>>>>>>>>>>Define SCI_SETINDENT                           For 2122
74335>>>>>>>>>>>>>Define SCI_GETINDENT                           For 2123
74335>>>>>>>>>>>>>Define SCI_SETUSETABS                          For 2124
74335>>>>>>>>>>>>>Define SCI_GETUSETABS                          For 2125
74335>>>>>>>>>>>>>Define SCI_SETLINEINDENTATION                  For 2126
74335>>>>>>>>>>>>>Define SCI_GETLINEINDENTATION                  For 2127
74335>>>>>>>>>>>>>Define SCI_GETLINEINDENTPOSITION               For 2128
74335>>>>>>>>>>>>>Define SCI_GETCOLUMN                           For 2129
74335>>>>>>>>>>>>>Define SCI_COUNTCHARACTERS                     For 2633
74335>>>>>>>>>>>>>Define SCI_COUNTCODEUNITS                      For 2715
74335>>>>>>>>>>>>>Define SCI_SETHSCROLLBAR                       For 2130
74335>>>>>>>>>>>>>Define SCI_GETHSCROLLBAR                       For 2131
74335>>>>>>>>>>>>>Define SC_IV_NONE                              For 0
74335>>>>>>>>>>>>>Define SC_IV_REAL                              For 1
74335>>>>>>>>>>>>>Define SC_IV_LOOKFORWARD                       For 2
74335>>>>>>>>>>>>>Define SC_IV_LOOKBOTH                          For 3
74335>>>>>>>>>>>>>Define SCI_SETINDENTATIONGUIDES                For 2132
74335>>>>>>>>>>>>>Define SCI_GETINDENTATIONGUIDES                For 2133
74335>>>>>>>>>>>>>Define SCI_SETHIGHLIGHTGUIDE                   For 2134
74335>>>>>>>>>>>>>Define SCI_GETHIGHLIGHTGUIDE                   For 2135
74335>>>>>>>>>>>>>Define SCI_GETLINEENDPOSITION                  For 2136
74335>>>>>>>>>>>>>Define SCI_GETCODEPAGE                         For 2137
74335>>>>>>>>>>>>>Define SCI_GETCARETFORE                        For 2138
74335>>>>>>>>>>>>>Define SCI_GETREADONLY                         For 2140
74335>>>>>>>>>>>>>Define SCI_SETCURRENTPOS                       For 2141
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONSTART                   For 2142
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONSTART                   For 2143
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONEND                     For 2144
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONEND                     For 2145
74335>>>>>>>>>>>>>Define SCI_SETEMPTYSELECTION                   For 2556
74335>>>>>>>>>>>>>Define SCI_SETPRINTMAGNIFICATION               For 2146
74335>>>>>>>>>>>>>Define SCI_GETPRINTMAGNIFICATION               For 2147
74335>>>>>>>>>>>>>Define SC_PRINT_NORMAL                         For 0
74335>>>>>>>>>>>>>Define SC_PRINT_INVERTLIGHT                    For 1
74335>>>>>>>>>>>>>Define SC_PRINT_BLACKONWHITE                   For 2
74335>>>>>>>>>>>>>Define SC_PRINT_COLOURONWHITE                  For 3
74335>>>>>>>>>>>>>Define SC_PRINT_COLOURONWHITEDEFAULTBG         For 4
74335>>>>>>>>>>>>>Define SC_PRINT_SCREENCOLOURS                  For 5
74335>>>>>>>>>>>>>Define SCI_SETPRINTCOLOURMODE                  For 2148
74335>>>>>>>>>>>>>Define SCI_GETPRINTCOLOURMODE                  For 2149
74335>>>>>>>>>>>>>Define SCFIND_WHOLEWORD                        For |CI$02    // 0x2
74335>>>>>>>>>>>>>Define SCFIND_MATCHCASE                        For |CI$04    // 0x4
74335>>>>>>>>>>>>>Define SCFIND_WORDSTART                        For |CI$00100000 // 0x00100000
74335>>>>>>>>>>>>>Define SCFIND_REGEXP                           For |CI$00200000 // 0x00200000
74335>>>>>>>>>>>>>Define SCFIND_POSIX                            For |CI$00400000 // 0x00400000
74335>>>>>>>>>>>>>Define SCFIND_CXX11REGEX                       For |CI$00800000 // 0x00800000
74335>>>>>>>>>>>>>Define SCI_FINDTEXT                            For 2150
74335>>>>>>>>>>>>>Define SCI_FORMATRANGE                         For 2151
74335>>>>>>>>>>>>>Define SCI_GETFIRSTVISIBLELINE                 For 2152
74335>>>>>>>>>>>>>Define SCI_GETLINE                             For 2153
74335>>>>>>>>>>>>>Define SCI_GETLINECOUNT                        For 2154
74335>>>>>>>>>>>>>Define SCI_SETMARGINLEFT                       For 2155
74335>>>>>>>>>>>>>Define SCI_GETMARGINLEFT                       For 2156
74335>>>>>>>>>>>>>Define SCI_SETMARGINRIGHT                      For 2157
74335>>>>>>>>>>>>>Define SCI_GETMARGINRIGHT                      For 2158
74335>>>>>>>>>>>>>Define SCI_GETMODIFY                           For 2159
74335>>>>>>>>>>>>>Define SCI_SETSEL                              For 2160
74335>>>>>>>>>>>>>Define SCI_GETSELTEXT                          For 2161
74335>>>>>>>>>>>>>Define SCI_GETTEXTRANGE                        For 2162
74335>>>>>>>>>>>>>Define SCI_HIDESELECTION                       For 2163
74335>>>>>>>>>>>>>Define SCI_POINTXFROMPOSITION                  For 2164
74335>>>>>>>>>>>>>Define SCI_POINTYFROMPOSITION                  For 2165
74335>>>>>>>>>>>>>Define SCI_LINEFROMPOSITION                    For 2166
74335>>>>>>>>>>>>>Define SCI_POSITIONFROMLINE                    For 2167
74335>>>>>>>>>>>>>Define SCI_LINESCROLL                          For 2168
74335>>>>>>>>>>>>>Define SCI_SCROLLCARET                         For 2169
74335>>>>>>>>>>>>>Define SCI_SCROLLRANGE                         For 2569
74335>>>>>>>>>>>>>Define SCI_REPLACESEL                          For 2170
74335>>>>>>>>>>>>>Define SCI_SETREADONLY                         For 2171
74335>>>>>>>>>>>>>Define SCI_NULL                                For 2172
74335>>>>>>>>>>>>>Define SCI_CANPASTE                            For 2173
74335>>>>>>>>>>>>>Define SCI_CANUNDO                             For 2174
74335>>>>>>>>>>>>>Define SCI_EMPTYUNDOBUFFER                     For 2175
74335>>>>>>>>>>>>>Define SCI_UNDO                                For 2176
74335>>>>>>>>>>>>>Define SCI_CUT                                 For 2177
74335>>>>>>>>>>>>>Define SCI_COPY                                For 2178
74335>>>>>>>>>>>>>Define SCI_PASTE                               For 2179
74335>>>>>>>>>>>>>Define SCI_CLEAR                               For 2180
74335>>>>>>>>>>>>>Define SCI_SETTEXT                             For 2181
74335>>>>>>>>>>>>>Define SCI_GETTEXT                             For 2182
74335>>>>>>>>>>>>>Define SCI_GETTEXTLENGTH                       For 2183
74335>>>>>>>>>>>>>Define SCI_GETDIRECTFUNCTION                   For 2184
74335>>>>>>>>>>>>>Define SCI_GETDIRECTPOINTER                    For 2185
74335>>>>>>>>>>>>>Define SCI_SETOVERTYPE                         For 2186
74335>>>>>>>>>>>>>Define SCI_GETOVERTYPE                         For 2187
74335>>>>>>>>>>>>>Define SCI_SETCARETWIDTH                       For 2188
74335>>>>>>>>>>>>>Define SCI_GETCARETWIDTH                       For 2189
74335>>>>>>>>>>>>>Define SCI_SETTARGETSTART                      For 2190
74335>>>>>>>>>>>>>Define SCI_GETTARGETSTART                      For 2191
74335>>>>>>>>>>>>>Define SCI_SETTARGETEND                        For 2192
74335>>>>>>>>>>>>>Define SCI_GETTARGETEND                        For 2193
74335>>>>>>>>>>>>>Define SCI_SETTARGETRANGE                      For 2686
74335>>>>>>>>>>>>>Define SCI_GETTARGETTEXT                       For 2687
74335>>>>>>>>>>>>>Define SCI_TARGETFROMSELECTION                 For 2287
74335>>>>>>>>>>>>>Define SCI_TARGETWHOLEDOCUMENT                 For 2690
74335>>>>>>>>>>>>>Define SCI_REPLACETARGET                       For 2194
74335>>>>>>>>>>>>>Define SCI_REPLACETARGETRE                     For 2195
74335>>>>>>>>>>>>>Define SCI_SEARCHINTARGET                      For 2197
74335>>>>>>>>>>>>>Define SCI_SETSEARCHFLAGS                      For 2198
74335>>>>>>>>>>>>>Define SCI_GETSEARCHFLAGS                      For 2199
74335>>>>>>>>>>>>>Define SCI_CALLTIPSHOW                         For 2200
74335>>>>>>>>>>>>>Define SCI_CALLTIPCANCEL                       For 2201
74335>>>>>>>>>>>>>Define SCI_CALLTIPACTIVE                       For 2202
74335>>>>>>>>>>>>>Define SCI_CALLTIPPOSSTART                     For 2203
74335>>>>>>>>>>>>>Define SCI_CALLTIPSETPOSSTART                  For 2214
74335>>>>>>>>>>>>>Define SCI_CALLTIPSETHLT                       For 2204
74335>>>>>>>>>>>>>Define SCI_CALLTIPSETBACK                      For 2205
74335>>>>>>>>>>>>>Define SCI_CALLTIPSETFORE                      For 2206
74335>>>>>>>>>>>>>Define SCI_CALLTIPSETFOREHLT                   For 2207
74335>>>>>>>>>>>>>Define SCI_CALLTIPUSESTYLE                     For 2212
74335>>>>>>>>>>>>>Define SCI_CALLTIPSETPOSITION                  For 2213
74335>>>>>>>>>>>>>Define SCI_VISIBLEFROMDOCLINE                  For 2220
74335>>>>>>>>>>>>>Define SCI_DOCLINEFROMVISIBLE                  For 2221
74335>>>>>>>>>>>>>Define SCI_WRAPCOUNT                           For 2235
74335>>>>>>>>>>>>>Define SC_FOLDLEVELBASE                        For |CI$000400  // $0x400
74335>>>>>>>>>>>>>Define SC_FOLDLEVELWHITEFLAG                   For |CI$001000  // $0x1000
74335>>>>>>>>>>>>>Define SC_FOLDLEVELHEADERFLAG                  For |CI$002000  // $0x2000
74335>>>>>>>>>>>>>Define SC_FOLDLEVELNUMBERMASK                  For |CI$000FFF  // $0x0FFF
74335>>>>>>>>>>>>>Define SCI_SETFOLDLEVEL                        For 2222
74335>>>>>>>>>>>>>Define SCI_GETFOLDLEVEL                        For 2223
74335>>>>>>>>>>>>>Define SCI_GETLASTCHILD                        For 2224
74335>>>>>>>>>>>>>Define SCI_GETFOLDPARENT                       For 2225
74335>>>>>>>>>>>>>Define SCI_SHOWLINES                           For 2226
74335>>>>>>>>>>>>>Define SCI_HIDELINES                           For 2227
74335>>>>>>>>>>>>>Define SCI_GETLINEVISIBLE                      For 2228
74335>>>>>>>>>>>>>Define SCI_GETALLLINESVISIBLE                  For 2236
74335>>>>>>>>>>>>>Define SCI_SETFOLDEXPANDED                     For 2229
74335>>>>>>>>>>>>>Define SCI_GETFOLDEXPANDED                     For 2230
74335>>>>>>>>>>>>>Define SCI_TOGGLEFOLD                          For 2231
74335>>>>>>>>>>>>>Define SCI_TOGGLEFOLDSHOWTEXT                  For 2700
74335>>>>>>>>>>>>>Define SC_FOLDDISPLAYTEXT_HIDDEN               For 0
74335>>>>>>>>>>>>>Define SC_FOLDDISPLAYTEXT_STANDARD             For 1
74335>>>>>>>>>>>>>Define SC_FOLDDISPLAYTEXT_BOXED                For 2
74335>>>>>>>>>>>>>Define SCI_FOLDDISPLAYTEXTSETSTYLE             For 2701
74335>>>>>>>>>>>>>Define SCI_FOLDDISPLAYTEXTGETSTYLE             For 2707
74335>>>>>>>>>>>>>Define SCI_SETDEFAULTFOLDDISPLAYTEXT           For 2722
74335>>>>>>>>>>>>>Define SCI_GETDEFAULTFOLDDISPLAYTEXT           For 2723
74335>>>>>>>>>>>>>Define SC_FOLDACTION_CONTRACT                  For 0
74335>>>>>>>>>>>>>Define SC_FOLDACTION_EXPAND                    For 1
74335>>>>>>>>>>>>>Define SC_FOLDACTION_TOGGLE                    For 2
74335>>>>>>>>>>>>>Define SCI_FOLDLINE                            For 2237
74335>>>>>>>>>>>>>Define SCI_FOLDCHILDREN                        For 2238
74335>>>>>>>>>>>>>Define SCI_EXPANDCHILDREN                      For 2239
74335>>>>>>>>>>>>>Define SCI_FOLDALL                             For 2662
74335>>>>>>>>>>>>>Define SCI_ENSUREVISIBLE                       For 2232
74335>>>>>>>>>>>>>Define SC_AUTOMATICFOLD_SHOW                   For |CI$0001  // $0x0001
74335>>>>>>>>>>>>>Define SC_AUTOMATICFOLD_CLICK                  For |CI$0002  // $0x0002
74335>>>>>>>>>>>>>Define SC_AUTOMATICFOLD_CHANGE                 For |CI$0004  // $0x0004
74335>>>>>>>>>>>>>Define SCI_SETAUTOMATICFOLD                    For 2663
74335>>>>>>>>>>>>>Define SCI_GETAUTOMATICFOLD                    For 2664
74335>>>>>>>>>>>>>Define SC_FOLDFLAG_LINEBEFORE_EXPANDED         For |CI$0002  // $0x0002
74335>>>>>>>>>>>>>Define SC_FOLDFLAG_LINEBEFORE_CONTRACTED       For |CI$0004 // $0x0004
74335>>>>>>>>>>>>>Define SC_FOLDFLAG_LINEAFTER_EXPANDED          For |CI$0008  // $0x0008
74335>>>>>>>>>>>>>Define SC_FOLDFLAG_LINEAFTER_CONTRACTED        For |CI$0010  // $0x0010
74335>>>>>>>>>>>>>Define SC_FOLDFLAG_LEVELNUMBERS                For |CI$0040  // $0x0040
74335>>>>>>>>>>>>>Define SC_FOLDFLAG_LINESTATE                   For |CI$0080  // $0x0080
74335>>>>>>>>>>>>>Define SCI_SETFOLDFLAGS                        For 2233
74335>>>>>>>>>>>>>Define SCI_ENSUREVISIBLEENFORCEPOLICY          For 2234
74335>>>>>>>>>>>>>Define SCI_SETTABINDENTS                       For 2260
74335>>>>>>>>>>>>>Define SCI_GETTABINDENTS                       For 2261
74335>>>>>>>>>>>>>Define SCI_SETBACKSPACEUNINDENTS               For 2262
74335>>>>>>>>>>>>>Define SCI_GETBACKSPACEUNINDENTS               For 2263
74335>>>>>>>>>>>>>Define SC_TIME_FOREVER                         For 10000000
74335>>>>>>>>>>>>>Define SCI_SETMOUSEDWELLTIME                   For 2264
74335>>>>>>>>>>>>>Define SCI_GETMOUSEDWELLTIME                   For 2265
74335>>>>>>>>>>>>>Define SCI_WORDSTARTPOSITION                   For 2266
74335>>>>>>>>>>>>>Define SCI_WORDENDPOSITION                     For 2267
74335>>>>>>>>>>>>>Define SCI_ISRANGEWORD                         For 2691
74335>>>>>>>>>>>>>Define SC_IDLESTYLING_NONE                     For 0
74335>>>>>>>>>>>>>Define SC_IDLESTYLING_TOVISIBLE                For 1
74335>>>>>>>>>>>>>Define SC_IDLESTYLING_AFTERVISIBLE             For 2
74335>>>>>>>>>>>>>Define SC_IDLESTYLING_ALL                      For 3
74335>>>>>>>>>>>>>Define SCI_SETIDLESTYLING                      For 2692
74335>>>>>>>>>>>>>Define SCI_GETIDLESTYLING                      For 2693
74335>>>>>>>>>>>>>Define SC_WRAP_NONE                            For 0
74335>>>>>>>>>>>>>Define SC_WRAP_WORD                            For 1
74335>>>>>>>>>>>>>Define SC_WRAP_CHAR                            For 2
74335>>>>>>>>>>>>>Define SC_WRAP_WHITESPACE                      For 3
74335>>>>>>>>>>>>>Define SCI_SETWRAPMODE                         For 2268
74335>>>>>>>>>>>>>Define SCI_GETWRAPMODE                         For 2269
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAG_NONE                  For |CI$0000  // $0x0000
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAG_END                   For |CI$0001  // $0x0001
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAG_START                 For |CI$0002  // $0x0002
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAG_MARGIN                For |CI$0004  // $0x0004
74335>>>>>>>>>>>>>Define SCI_SETWRAPVISUALFLAGS                  For 2460
74335>>>>>>>>>>>>>Define SCI_GETWRAPVISUALFLAGS                  For 2461
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAGLOC_DEFAULT            For |CI$0000  // $0x0000
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAGLOC_END_BY_TEXT        For |CI$0001  // $0x0001
74335>>>>>>>>>>>>>Define SC_WRAPVISUALFLAGLOC_START_BY_TEXT      For |CI$0002  // $0x0002
74335>>>>>>>>>>>>>Define SCI_SETWRAPVISUALFLAGSLOCATION          For 2462
74335>>>>>>>>>>>>>Define SCI_GETWRAPVISUALFLAGSLOCATION          For 2463
74335>>>>>>>>>>>>>Define SCI_SETWRAPSTARTINDENT                  For 2464
74335>>>>>>>>>>>>>Define SCI_GETWRAPSTARTINDENT                  For 2465
74335>>>>>>>>>>>>>Define SC_WRAPINDENT_FIXED                     For 0
74335>>>>>>>>>>>>>Define SC_WRAPINDENT_SAME                      For 1
74335>>>>>>>>>>>>>Define SC_WRAPINDENT_INDENT                    For 2
74335>>>>>>>>>>>>>Define SC_WRAPINDENT_DEEPINDENT                For 3
74335>>>>>>>>>>>>>Define SCI_SETWRAPINDENTMODE                   For 2472
74335>>>>>>>>>>>>>Define SCI_GETWRAPINDENTMODE                   For 2473
74335>>>>>>>>>>>>>Define SC_CACHE_NONE                           For 0
74335>>>>>>>>>>>>>Define SC_CACHE_CARET                          For 1
74335>>>>>>>>>>>>>Define SC_CACHE_PAGE                           For 2
74335>>>>>>>>>>>>>Define SC_CACHE_DOCUMENT                       For 3
74335>>>>>>>>>>>>>Define SCI_SETLAYOUTCACHE                      For 2272
74335>>>>>>>>>>>>>Define SCI_GETLAYOUTCACHE                      For 2273
74335>>>>>>>>>>>>>Define SCI_SETSCROLLWIDTH                      For 2274
74335>>>>>>>>>>>>>Define SCI_GETSCROLLWIDTH                      For 2275
74335>>>>>>>>>>>>>Define SCI_SETSCROLLWIDTHTRACKING              For 2516
74335>>>>>>>>>>>>>Define SCI_GETSCROLLWIDTHTRACKING              For 2517
74335>>>>>>>>>>>>>Define SCI_TEXTWIDTH                           For 2276
74335>>>>>>>>>>>>>Define SCI_SETENDATLASTLINE                    For 2277
74335>>>>>>>>>>>>>Define SCI_GETENDATLASTLINE                    For 2278
74335>>>>>>>>>>>>>Define SCI_TEXTHEIGHT                          For 2279
74335>>>>>>>>>>>>>Define SCI_SETVSCROLLBAR                       For 2280
74335>>>>>>>>>>>>>Define SCI_GETVSCROLLBAR                       For 2281
74335>>>>>>>>>>>>>Define SCI_APPENDTEXT                          For 2282
74335>>>>>>>>>>>>>Define SC_PHASES_ONE                           For 0
74335>>>>>>>>>>>>>Define SC_PHASES_TWO                           For 1
74335>>>>>>>>>>>>>Define SC_PHASES_MULTIPLE                      For 2
74335>>>>>>>>>>>>>Define SCI_GETPHASESDRAW                       For 2673
74335>>>>>>>>>>>>>Define SCI_SETPHASESDRAW                       For 2674
74335>>>>>>>>>>>>>Define SC_EFF_QUALITY_MASK                     For |CI$0F  // $0xF
74335>>>>>>>>>>>>>Define SC_EFF_QUALITY_DEFAULT                  For 0
74335>>>>>>>>>>>>>Define SC_EFF_QUALITY_NON_ANTIALIASED          For 1
74335>>>>>>>>>>>>>Define SC_EFF_QUALITY_ANTIALIASED              For 2
74335>>>>>>>>>>>>>Define SC_EFF_QUALITY_LCD_OPTIMIZED            For 3
74335>>>>>>>>>>>>>Define SCI_SETFONTQUALITY                      For 2611
74335>>>>>>>>>>>>>Define SCI_GETFONTQUALITY                      For 2612
74335>>>>>>>>>>>>>Define SCI_SETFIRSTVISIBLELINE                 For 2613
74335>>>>>>>>>>>>>Define SC_MULTIPASTE_ONCE                      For 0
74335>>>>>>>>>>>>>Define SC_MULTIPASTE_EACH                      For 1
74335>>>>>>>>>>>>>Define SCI_SETMULTIPASTE                       For 2614
74335>>>>>>>>>>>>>Define SCI_GETMULTIPASTE                       For 2615
74335>>>>>>>>>>>>>Define SCI_GETTAG                              For 2616
74335>>>>>>>>>>>>>Define SCI_LINESJOIN                           For 2288
74335>>>>>>>>>>>>>Define SCI_LINESSPLIT                          For 2289
74335>>>>>>>>>>>>>Define SCI_SETFOLDMARGINCOLOUR                 For 2290
74335>>>>>>>>>>>>>Define SCI_SETFOLDMARGINHICOLOUR               For 2291
74335>>>>>>>>>>>>>Define SC_ACCESSIBILITY_DISABLED               For 0
74335>>>>>>>>>>>>>Define SC_ACCESSIBILITY_ENABLED                For 1
74335>>>>>>>>>>>>>Define SCI_SETACCESSIBILITY                    For 2702
74335>>>>>>>>>>>>>Define SCI_GETACCESSIBILITY                    For 2703
74335>>>>>>>>>>>>>Define SCI_LINEDOWN                            For 2300
74335>>>>>>>>>>>>>Define SCI_LINEDOWNEXTEND                      For 2301
74335>>>>>>>>>>>>>Define SCI_LINEUP                              For 2302
74335>>>>>>>>>>>>>Define SCI_LINEUPEXTEND                        For 2303
74335>>>>>>>>>>>>>Define SCI_CHARLEFT                            For 2304
74335>>>>>>>>>>>>>Define SCI_CHARLEFTEXTEND                      For 2305
74335>>>>>>>>>>>>>Define SCI_CHARRIGHT                           For 2306
74335>>>>>>>>>>>>>Define SCI_CHARRIGHTEXTEND                     For 2307
74335>>>>>>>>>>>>>Define SCI_WORDLEFT                            For 2308
74335>>>>>>>>>>>>>Define SCI_WORDLEFTEXTEND                      For 2309
74335>>>>>>>>>>>>>Define SCI_WORDRIGHT                           For 2310
74335>>>>>>>>>>>>>Define SCI_WORDRIGHTEXTEND                     For 2311
74335>>>>>>>>>>>>>Define SCI_HOME                                For 2312
74335>>>>>>>>>>>>>Define SCI_HOMEEXTEND                          For 2313
74335>>>>>>>>>>>>>Define SCI_LINEEND                             For 2314
74335>>>>>>>>>>>>>Define SCI_LINEENDEXTEND                       For 2315
74335>>>>>>>>>>>>>Define SCI_DOCUMENTSTART                       For 2316
74335>>>>>>>>>>>>>Define SCI_DOCUMENTSTARTEXTEND                 For 2317
74335>>>>>>>>>>>>>Define SCI_DOCUMENTEND                         For 2318
74335>>>>>>>>>>>>>Define SCI_DOCUMENTENDEXTEND                   For 2319
74335>>>>>>>>>>>>>Define SCI_PAGEUP                              For 2320
74335>>>>>>>>>>>>>Define SCI_PAGEUPEXTEND                        For 2321
74335>>>>>>>>>>>>>Define SCI_PAGEDOWN                            For 2322
74335>>>>>>>>>>>>>Define SCI_PAGEDOWNEXTEND                      For 2323
74335>>>>>>>>>>>>>Define SCI_EDITTOGGLEOVERTYPE                  For 2324
74335>>>>>>>>>>>>>Define SCI_CANCEL                              For 2325
74335>>>>>>>>>>>>>Define SCI_DELETEBACK                          For 2326
74335>>>>>>>>>>>>>Define SCI_TAB                                 For 2327
74335>>>>>>>>>>>>>Define SCI_BACKTAB                             For 2328
74335>>>>>>>>>>>>>Define SCI_NEWLINE                             For 2329
74335>>>>>>>>>>>>>Define SCI_FORMFEED                            For 2330
74335>>>>>>>>>>>>>Define SCI_VCHOME                              For 2331
74335>>>>>>>>>>>>>Define SCI_VCHOMEEXTEND                        For 2332
74335>>>>>>>>>>>>>Define SCI_ZOOMIN                              For 2333
74335>>>>>>>>>>>>>Define SCI_ZOOMOUT                             For 2334
74335>>>>>>>>>>>>>Define SCI_DELWORDLEFT                         For 2335
74335>>>>>>>>>>>>>Define SCI_DELWORDRIGHT                        For 2336
74335>>>>>>>>>>>>>Define SCI_DELWORDRIGHTEND                     For 2518
74335>>>>>>>>>>>>>Define SCI_LINECUT                             For 2337
74335>>>>>>>>>>>>>Define SCI_LINEDELETE                          For 2338
74335>>>>>>>>>>>>>Define SCI_LINETRANSPOSE                       For 2339
74335>>>>>>>>>>>>>Define SCI_LINEREVERSE                         For 2354
74335>>>>>>>>>>>>>Define SCI_LINEDUPLICATE                       For 2404
74335>>>>>>>>>>>>>Define SCI_LOWERCASE                           For 2340
74335>>>>>>>>>>>>>Define SCI_UPPERCASE                           For 2341
74335>>>>>>>>>>>>>Define SCI_LINESCROLLDOWN                      For 2342
74335>>>>>>>>>>>>>Define SCI_LINESCROLLUP                        For 2343
74335>>>>>>>>>>>>>Define SCI_DELETEBACKNOTLINE                   For 2344
74335>>>>>>>>>>>>>Define SCI_HOMEDISPLAY                         For 2345
74335>>>>>>>>>>>>>Define SCI_HOMEDISPLAYEXTEND                   For 2346
74335>>>>>>>>>>>>>Define SCI_LINEENDDISPLAY                      For 2347
74335>>>>>>>>>>>>>Define SCI_LINEENDDISPLAYEXTEND                For 2348
74335>>>>>>>>>>>>>Define SCI_HOMEWRAP                            For 2349
74335>>>>>>>>>>>>>Define SCI_HOMEWRAPEXTEND                      For 2450
74335>>>>>>>>>>>>>Define SCI_LINEENDWRAP                         For 2451
74335>>>>>>>>>>>>>Define SCI_LINEENDWRAPEXTEND                   For 2452
74335>>>>>>>>>>>>>Define SCI_VCHOMEWRAP                          For 2453
74335>>>>>>>>>>>>>Define SCI_VCHOMEWRAPEXTEND                    For 2454
74335>>>>>>>>>>>>>Define SCI_LINECOPY                            For 2455
74335>>>>>>>>>>>>>Define SCI_MOVECARETINSIDEVIEW                 For 2401
74335>>>>>>>>>>>>>Define SCI_LINELENGTH                          For 2350
74335>>>>>>>>>>>>>Define SCI_BRACEHIGHLIGHT                      For 2351
74335>>>>>>>>>>>>>Define SCI_BRACEHIGHLIGHTINDICATOR             For 2498
74335>>>>>>>>>>>>>Define SCI_BRACEBADLIGHT                       For 2352
74335>>>>>>>>>>>>>Define SCI_BRACEBADLIGHTINDICATOR              For 2499
74335>>>>>>>>>>>>>Define SCI_BRACEMATCH                          For 2353
74335>>>>>>>>>>>>>Define SCI_GETVIEWEOL                          For 2355
74335>>>>>>>>>>>>>Define SCI_SETVIEWEOL                          For 2356
74335>>>>>>>>>>>>>Define SCI_GETDOCPOINTER                       For 2357
74335>>>>>>>>>>>>>Define SCI_SETDOCPOINTER                       For 2358
74335>>>>>>>>>>>>>Define SCI_SETMODEVENTMASK                     For 2359
74335>>>>>>>>>>>>>Define EDGE_NONE                               For 0
74335>>>>>>>>>>>>>Define EDGE_LINE                               For 1
74335>>>>>>>>>>>>>Define EDGE_BACKGROUND                         For 2
74335>>>>>>>>>>>>>Define EDGE_MULTILINE                          For 3
74335>>>>>>>>>>>>>Define SCI_GETEDGECOLUMN                       For 2360
74335>>>>>>>>>>>>>Define SCI_SETEDGECOLUMN                       For 2361
74335>>>>>>>>>>>>>Define SCI_GETEDGEMODE                         For 2362
74335>>>>>>>>>>>>>Define SCI_SETEDGEMODE                         For 2363
74335>>>>>>>>>>>>>Define SCI_GETEDGECOLOUR                       For 2364
74335>>>>>>>>>>>>>Define SCI_SETEDGECOLOUR                       For 2365
74335>>>>>>>>>>>>>Define SCI_MULTIEDGEADDLINE                    For 2694
74335>>>>>>>>>>>>>Define SCI_MULTIEDGECLEARALL                   For 2695
74335>>>>>>>>>>>>>Define SCI_SEARCHANCHOR                        For 2366
74335>>>>>>>>>>>>>Define SCI_SEARCHNEXT                          For 2367
74335>>>>>>>>>>>>>Define SCI_SEARCHPREV                          For 2368
74335>>>>>>>>>>>>>Define SCI_LINESONSCREEN                       For 2370
74335>>>>>>>>>>>>>Define SC_POPUP_NEVER                          For 0
74335>>>>>>>>>>>>>Define SC_POPUP_ALL                            For 1
74335>>>>>>>>>>>>>Define SC_POPUP_TEXT                           For 2
74335>>>>>>>>>>>>>Define SCI_USEPOPUP                            For 2371
74335>>>>>>>>>>>>>Define SCI_SELECTIONISRECTANGLE                For 2372
74335>>>>>>>>>>>>>Define SCI_SETZOOM                             For 2373
74335>>>>>>>>>>>>>Define SCI_GETZOOM                             For 2374
74335>>>>>>>>>>>>>Define SC_DOCUMENTOPTION_DEFAULT               For 0
74335>>>>>>>>>>>>>Define SC_DOCUMENTOPTION_STYLES_NONE           For |CI$0001  // 0x1
74335>>>>>>>>>>>>>Define SC_DOCUMENTOPTION_TEXT_LARGE            For |CI$0100  // 0x100
74335>>>>>>>>>>>>>Define SCI_CREATEDOCUMENT                      For 2375
74335>>>>>>>>>>>>>Define SCI_ADDREFDOCUMENT                      For 2376
74335>>>>>>>>>>>>>Define SCI_RELEASEDOCUMENT                     For 2377
74335>>>>>>>>>>>>>Define SCI_GETDOCUMENTOPTIONS                  For 2379
74335>>>>>>>>>>>>>Define SCI_GETMODEVENTMASK                     For 2378
74335>>>>>>>>>>>>>Define SCI_SETCOMMANDEVENTS                    For 2717
74335>>>>>>>>>>>>>Define SCI_GETCOMMANDEVENTS                    For 2718
74335>>>>>>>>>>>>>Define SCI_SETFOCUS                            For 2380
74335>>>>>>>>>>>>>Define SCI_GETFOCUS                            For 2381
74335>>>>>>>>>>>>>Define SC_STATUS_OK                            For 0
74335>>>>>>>>>>>>>Define SC_STATUS_FAILURE                       For 1
74335>>>>>>>>>>>>>Define SC_STATUS_BADALLOC                      For 2
74335>>>>>>>>>>>>>Define SC_STATUS_WARN_START                    For 1000
74335>>>>>>>>>>>>>Define SC_STATUS_WARN_REGEX                    For 1001
74335>>>>>>>>>>>>>Define SCI_SETSTATUS                           For 2382
74335>>>>>>>>>>>>>Define SCI_GETSTATUS                           For 2383
74335>>>>>>>>>>>>>Define SCI_SETMOUSEDOWNCAPTURES                For 2384
74335>>>>>>>>>>>>>Define SCI_GETMOUSEDOWNCAPTURES                For 2385
74335>>>>>>>>>>>>>Define SCI_SETMOUSEWHEELCAPTURES               For 2696
74335>>>>>>>>>>>>>Define SCI_GETMOUSEWHEELCAPTURES               For 2697
74335>>>>>>>>>>>>>Define SC_CURSORNORMAL                         For 1
74335>>>>>>>>>>>>>Define SC_CURSORARROW                          For 2
74335>>>>>>>>>>>>>Define SC_CURSORWAIT                           For 4
74335>>>>>>>>>>>>>Define SC_CURSORREVERSEARROW                   For 7
74335>>>>>>>>>>>>>Define SCI_SETCURSOR                           For 2386
74335>>>>>>>>>>>>>Define SCI_GETCURSOR                           For 2387
74335>>>>>>>>>>>>>Define SCI_SETCONTROLCHARSYMBOL                For 2388
74335>>>>>>>>>>>>>Define SCI_GETCONTROLCHARSYMBOL                For 2389
74335>>>>>>>>>>>>>Define SCI_WORDPARTLEFT                        For 2390
74335>>>>>>>>>>>>>Define SCI_WORDPARTLEFTEXTEND                  For 2391
74335>>>>>>>>>>>>>Define SCI_WORDPARTRIGHT                       For 2392
74335>>>>>>>>>>>>>Define SCI_WORDPARTRIGHTEXTEND                 For 2393
74335>>>>>>>>>>>>>Define VISIBLE_SLOP                            For |CI$01  // $0x01
74335>>>>>>>>>>>>>Define VISIBLE_STRICT                          For |CI$04  // $0x04
74335>>>>>>>>>>>>>Define SCI_SETVISIBLEPOLICY                    For 2394
74335>>>>>>>>>>>>>Define SCI_DELLINELEFT                         For 2395
74335>>>>>>>>>>>>>Define SCI_DELLINERIGHT                        For 2396
74335>>>>>>>>>>>>>Define SCI_SETXOFFSET                          For 2397
74335>>>>>>>>>>>>>Define SCI_GETXOFFSET                          For 2398
74335>>>>>>>>>>>>>Define SCI_CHOOSECARETX                        For 2399
74335>>>>>>>>>>>>>Define SCI_GRABFOCUS                           For 2400
74335>>>>>>>>>>>>>Define CARET_SLOP                              For |CI$01  // $0x01
74335>>>>>>>>>>>>>Define CARET_STRICT                            For |CI$04  // $0x04
74335>>>>>>>>>>>>>Define CARET_JUMPS                             For |CI$10  // $0x10
74335>>>>>>>>>>>>>Define CARET_EVEN                              For |CI$08  // $0x08
74335>>>>>>>>>>>>>Define SCI_SETXCARETPOLICY                     For 2402
74335>>>>>>>>>>>>>Define SCI_SETYCARETPOLICY                     For 2403
74335>>>>>>>>>>>>>Define SCI_SETPRINTWRAPMODE                    For 2406
74335>>>>>>>>>>>>>Define SCI_GETPRINTWRAPMODE                    For 2407
74335>>>>>>>>>>>>>Define SCI_SETHOTSPOTACTIVEFORE                For 2410
74335>>>>>>>>>>>>>Define SCI_GETHOTSPOTACTIVEFORE                For 2494
74335>>>>>>>>>>>>>Define SCI_SETHOTSPOTACTIVEBACK                For 2411
74335>>>>>>>>>>>>>Define SCI_GETHOTSPOTACTIVEBACK                For 2495
74335>>>>>>>>>>>>>Define SCI_SETHOTSPOTACTIVEUNDERLINE           For 2412
74335>>>>>>>>>>>>>Define SCI_GETHOTSPOTACTIVEUNDERLINE           For 2496
74335>>>>>>>>>>>>>Define SCI_SETHOTSPOTSINGLELINE                For 2421
74335>>>>>>>>>>>>>Define SCI_GETHOTSPOTSINGLELINE                For 2497
74335>>>>>>>>>>>>>Define SCI_PARADOWN                            For 2413
74335>>>>>>>>>>>>>Define SCI_PARADOWNEXTEND                      For 2414
74335>>>>>>>>>>>>>Define SCI_PARAUP                              For 2415
74335>>>>>>>>>>>>>Define SCI_PARAUPEXTEND                        For 2416
74335>>>>>>>>>>>>>Define SCI_POSITIONBEFORE                      For 2417
74335>>>>>>>>>>>>>Define SCI_POSITIONAFTER                       For 2418
74335>>>>>>>>>>>>>Define SCI_POSITIONRELATIVE                    For 2670
74335>>>>>>>>>>>>>Define SCI_POSITIONRELATIVECODEUNITS           For 2716
74335>>>>>>>>>>>>>Define SCI_COPYRANGE                           For 2419
74335>>>>>>>>>>>>>Define SCI_COPYTEXT                            For 2420
74335>>>>>>>>>>>>>Define SC_SEL_STREAM                           For 0
74335>>>>>>>>>>>>>Define SC_SEL_RECTANGLE                        For 1
74335>>>>>>>>>>>>>Define SC_SEL_LINES                            For 2
74335>>>>>>>>>>>>>Define SC_SEL_THIN                             For 3
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONMODE                    For 2422
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONMODE                    For 2423
74335>>>>>>>>>>>>>Define SCI_GETMOVEEXTENDSSELECTION             For 2706
74335>>>>>>>>>>>>>Define SCI_GETLINESELSTARTPOSITION             For 2424
74335>>>>>>>>>>>>>Define SCI_GETLINESELENDPOSITION               For 2425
74335>>>>>>>>>>>>>Define SCI_LINEDOWNRECTEXTEND                  For 2426
74335>>>>>>>>>>>>>Define SCI_LINEUPRECTEXTEND                    For 2427
74335>>>>>>>>>>>>>Define SCI_CHARLEFTRECTEXTEND                  For 2428
74335>>>>>>>>>>>>>Define SCI_CHARRIGHTRECTEXTEND                 For 2429
74335>>>>>>>>>>>>>Define SCI_HOMERECTEXTEND                      For 2430
74335>>>>>>>>>>>>>Define SCI_VCHOMERECTEXTEND                    For 2431
74335>>>>>>>>>>>>>Define SCI_LINEENDRECTEXTEND                   For 2432
74335>>>>>>>>>>>>>Define SCI_PAGEUPRECTEXTEND                    For 2433
74335>>>>>>>>>>>>>Define SCI_PAGEDOWNRECTEXTEND                  For 2434
74335>>>>>>>>>>>>>Define SCI_STUTTEREDPAGEUP                     For 2435
74335>>>>>>>>>>>>>Define SCI_STUTTEREDPAGEUPEXTEND               For 2436
74335>>>>>>>>>>>>>Define SCI_STUTTEREDPAGEDOWN                   For 2437
74335>>>>>>>>>>>>>Define SCI_STUTTEREDPAGEDOWNEXTEND             For 2438
74335>>>>>>>>>>>>>Define SCI_WORDLEFTEND                         For 2439
74335>>>>>>>>>>>>>Define SCI_WORDLEFTENDEXTEND                   For 2440
74335>>>>>>>>>>>>>Define SCI_WORDRIGHTEND                        For 2441
74335>>>>>>>>>>>>>Define SCI_WORDRIGHTENDEXTEND                  For 2442
74335>>>>>>>>>>>>>Define SCI_SETWHITESPACECHARS                  For 2443
74335>>>>>>>>>>>>>Define SCI_GETWHITESPACECHARS                  For 2647
74335>>>>>>>>>>>>>Define SCI_SETPUNCTUATIONCHARS                 For 2648
74335>>>>>>>>>>>>>Define SCI_GETPUNCTUATIONCHARS                 For 2649
74335>>>>>>>>>>>>>Define SCI_SETCHARSDEFAULT                     For 2444
74335>>>>>>>>>>>>>Define SCI_AUTOCGETCURRENT                     For 2445
74335>>>>>>>>>>>>>Define SCI_AUTOCGETCURRENTTEXT                 For 2610
74335>>>>>>>>>>>>>Define SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE For 0
74335>>>>>>>>>>>>>Define SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE  For 1
74335>>>>>>>>>>>>>Define SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR    For 2634
74335>>>>>>>>>>>>>Define SCI_AUTOCGETCASEINSENSITIVEBEHAVIOUR    For 2635
74335>>>>>>>>>>>>>Define SC_MULTIAUTOC_ONCE                      For 0
74335>>>>>>>>>>>>>Define SC_MULTIAUTOC_EACH                      For 1
74335>>>>>>>>>>>>>Define SCI_AUTOCSETMULTI                       For 2636
74335>>>>>>>>>>>>>Define SCI_AUTOCGETMULTI                       For 2637
74335>>>>>>>>>>>>>Define SC_ORDER_PRESORTED                      For 0
74335>>>>>>>>>>>>>Define SC_ORDER_PERFORMSORT                    For 1
74335>>>>>>>>>>>>>Define SC_ORDER_CUSTOM                         For 2
74335>>>>>>>>>>>>>Define SCI_AUTOCSETORDER                       For 2660
74335>>>>>>>>>>>>>Define SCI_AUTOCGETORDER                       For 2661
74335>>>>>>>>>>>>>Define SCI_ALLOCATE                            For 2446
74335>>>>>>>>>>>>>Define SCI_TARGETASUTF8                        For 2447
74335>>>>>>>>>>>>>Define SCI_SETLENGTHFORENCODE                  For 2448
74335>>>>>>>>>>>>>Define SCI_ENCODEDFROMUTF8                     For 2449
74335>>>>>>>>>>>>>Define SCI_FINDCOLUMN                          For 2456
74335>>>>>>>>>>>>>Define SCI_GETCARETSTICKY                      For 2457
74335>>>>>>>>>>>>>Define SCI_SETCARETSTICKY                      For 2458
74335>>>>>>>>>>>>>Define SC_CARETSTICKY_OFF                      For 0
74335>>>>>>>>>>>>>Define SC_CARETSTICKY_ON                       For 1
74335>>>>>>>>>>>>>Define SC_CARETSTICKY_WHITESPACE               For 2
74335>>>>>>>>>>>>>Define SCI_TOGGLECARETSTICKY                   For 2459
74335>>>>>>>>>>>>>Define SCI_SETPASTECONVERTENDINGS              For 2467
74335>>>>>>>>>>>>>Define SCI_GETPASTECONVERTENDINGS              For 2468
74335>>>>>>>>>>>>>Define SCI_SELECTIONDUPLICATE                  For 2469
74335>>>>>>>>>>>>>Define SC_ALPHA_TRANSPARENT                    For 0
74335>>>>>>>>>>>>>Define SC_ALPHA_OPAQUE                         For 255
74335>>>>>>>>>>>>>Define SC_ALPHA_NOALPHA                        For 256
74335>>>>>>>>>>>>>Define SCI_SETCARETLINEBACKALPHA               For 2470
74335>>>>>>>>>>>>>Define SCI_GETCARETLINEBACKALPHA               For 2471
74335>>>>>>>>>>>>>Define CARETSTYLE_INVISIBLE                    For 0
74335>>>>>>>>>>>>>Define CARETSTYLE_LINE                         For 1
74335>>>>>>>>>>>>>Define CARETSTYLE_BLOCK                        For 2
74335>>>>>>>>>>>>>Define CARETSTYLE_OVERSTRIKE_BAR               For 0
74335>>>>>>>>>>>>>Define CARETSTYLE_OVERSTRIKE_BLOCK             For 16
74335>>>>>>>>>>>>>Define CARETSTYLE_INS_MASK                     For |CI$0F   // 0xF
74335>>>>>>>>>>>>>Define SCI_SETCARETSTYLE                       For 2512
74335>>>>>>>>>>>>>Define SCI_GETCARETSTYLE                       For 2513
74335>>>>>>>>>>>>>Define SCI_SETINDICATORCURRENT                 For 2500
74335>>>>>>>>>>>>>Define SCI_GETINDICATORCURRENT                 For 2501
74335>>>>>>>>>>>>>Define SCI_SETINDICATORVALUE                   For 2502
74335>>>>>>>>>>>>>Define SCI_GETINDICATORVALUE                   For 2503
74335>>>>>>>>>>>>>Define SCI_INDICATORFILLRANGE                  For 2504
74335>>>>>>>>>>>>>Define SCI_INDICATORCLEARRANGE                 For 2505
74335>>>>>>>>>>>>>Define SCI_INDICATORALLONFOR                   For 2506
74335>>>>>>>>>>>>>Define SCI_INDICATORVALUEAT                    For 2507
74335>>>>>>>>>>>>>Define SCI_INDICATORSTART                      For 2508
74335>>>>>>>>>>>>>Define SCI_INDICATOREND                        For 2509
74335>>>>>>>>>>>>>Define SCI_SETPOSITIONCACHE                    For 2514
74335>>>>>>>>>>>>>Define SCI_GETPOSITIONCACHE                    For 2515
74335>>>>>>>>>>>>>Define SCI_COPYALLOWLINE                       For 2519
74335>>>>>>>>>>>>>Define SCI_GETCHARACTERPOINTER                 For 2520
74335>>>>>>>>>>>>>Define SCI_GETRANGEPOINTER                     For 2643
74335>>>>>>>>>>>>>Define SCI_GETGAPPOSITION                      For 2644
74335>>>>>>>>>>>>>Define SCI_INDICSETALPHA                       For 2523
74335>>>>>>>>>>>>>Define SCI_INDICGETALPHA                       For 2524
74335>>>>>>>>>>>>>Define SCI_INDICSETOUTLINEALPHA                For 2558
74335>>>>>>>>>>>>>Define SCI_INDICGETOUTLINEALPHA                For 2559
74335>>>>>>>>>>>>>Define SCI_SETEXTRAASCENT                      For 2525
74335>>>>>>>>>>>>>Define SCI_GETEXTRAASCENT                      For 2526
74335>>>>>>>>>>>>>Define SCI_SETEXTRADESCENT                     For 2527
74335>>>>>>>>>>>>>Define SCI_GETEXTRADESCENT                     For 2528
74335>>>>>>>>>>>>>Define SCI_MARKERSYMBOLDEFINED                 For 2529
74335>>>>>>>>>>>>>Define SCI_MARGINSETTEXT                       For 2530
74335>>>>>>>>>>>>>Define SCI_MARGINGETTEXT                       For 2531
74335>>>>>>>>>>>>>Define SCI_MARGINSETSTYLE                      For 2532
74335>>>>>>>>>>>>>Define SCI_MARGINGETSTYLE                      For 2533
74335>>>>>>>>>>>>>Define SCI_MARGINSETSTYLES                     For 2534
74335>>>>>>>>>>>>>Define SCI_MARGINGETSTYLES                     For 2535
74335>>>>>>>>>>>>>Define SCI_MARGINTEXTCLEARALL                  For 2536
74335>>>>>>>>>>>>>Define SCI_MARGINSETSTYLEOFFSET                For 2537
74335>>>>>>>>>>>>>Define SCI_MARGINGETSTYLEOFFSET                For 2538
74335>>>>>>>>>>>>>Define SC_MARGINOPTION_NONE                    For 0
74335>>>>>>>>>>>>>Define SC_MARGINOPTION_SUBLINESELECT           For 1
74335>>>>>>>>>>>>>Define SCI_SETMARGINOPTIONS                    For 2539
74335>>>>>>>>>>>>>Define SCI_GETMARGINOPTIONS                    For 2557
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONSETTEXT                   For 2540
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONGETTEXT                   For 2541
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONSETSTYLE                  For 2542
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONGETSTYLE                  For 2543
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONSETSTYLES                 For 2544
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONGETSTYLES                 For 2545
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONGETLINES                  For 2546
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONCLEARALL                  For 2547
74335>>>>>>>>>>>>>Define ANNOTATION_HIDDEN                       For 0
74335>>>>>>>>>>>>>Define ANNOTATION_STANDARD                     For 1
74335>>>>>>>>>>>>>Define ANNOTATION_BOXED                        For 2
74335>>>>>>>>>>>>>Define ANNOTATION_INDENTED                     For 3
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONSETVISIBLE                For 2548
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONGETVISIBLE                For 2549
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONSETSTYLEOFFSET            For 2550
74335>>>>>>>>>>>>>Define SCI_ANNOTATIONGETSTYLEOFFSET            For 2551
74335>>>>>>>>>>>>>Define SCI_RELEASEALLEXTENDEDSTYLES            For 2552
74335>>>>>>>>>>>>>Define SCI_ALLOCATEEXTENDEDSTYLES              For 2553
74335>>>>>>>>>>>>>Define UNDO_MAY_COALESCE                       For 1
74335>>>>>>>>>>>>>Define SCI_ADDUNDOACTION                       For 2560
74335>>>>>>>>>>>>>Define SCI_CHARPOSITIONFROMPOINT               For 2561
74335>>>>>>>>>>>>>Define SCI_CHARPOSITIONFROMPOINTCLOSE          For 2562
74335>>>>>>>>>>>>>Define SCI_SETMOUSESELECTIONRECTANGULARSWITCH  For 2668
74335>>>>>>>>>>>>>Define SCI_GETMOUSESELECTIONRECTANGULARSWITCH  For 2669
74335>>>>>>>>>>>>>Define SCI_SETMULTIPLESELECTION                For 2563
74335>>>>>>>>>>>>>Define SCI_GETMULTIPLESELECTION                For 2564
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALSELECTIONTYPING        For 2565
74335>>>>>>>>>>>>>Define SCI_GETADDITIONALSELECTIONTYPING        For 2566
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALCARETSBLINK            For 2567
74335>>>>>>>>>>>>>Define SCI_GETADDITIONALCARETSBLINK            For 2568
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALCARETSVISIBLE          For 2608
74335>>>>>>>>>>>>>Define SCI_GETADDITIONALCARETSVISIBLE          For 2609
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONS                       For 2570
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONEMPTY                   For 2650
74335>>>>>>>>>>>>>Define SCI_CLEARSELECTIONS                     For 2571
74335>>>>>>>>>>>>>Define SCI_SETSELECTION                        For 2572
74335>>>>>>>>>>>>>Define SCI_ADDSELECTION                        For 2573
74335>>>>>>>>>>>>>Define SCI_DROPSELECTIONN                      For 2671
74335>>>>>>>>>>>>>Define SCI_SETMAINSELECTION                    For 2574
74335>>>>>>>>>>>>>Define SCI_GETMAINSELECTION                    For 2575
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONNCARET                  For 2576
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONNCARET                  For 2577
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONNANCHOR                 For 2578
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONNANCHOR                 For 2579
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONNCARETVIRTUALSPACE      For 2580
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONNCARETVIRTUALSPACE      For 2581
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONNANCHORVIRTUALSPACE     For 2582
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONNANCHORVIRTUALSPACE     For 2583
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONNSTART                  For 2584
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONNSTART                  For 2585
74335>>>>>>>>>>>>>Define SCI_SETSELECTIONNEND                    For 2586
74335>>>>>>>>>>>>>Define SCI_GETSELECTIONNEND                    For 2587
74335>>>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONCARET        For 2588
74335>>>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONCARET        For 2589
74335>>>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONANCHOR       For 2590
74335>>>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONANCHOR       For 2591
74335>>>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONCARETVIRTUALSPACE  For 2592
74335>>>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE  For 2593
74335>>>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONANCHORVIRTUALSPACE For 2594
74335>>>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE For 2595
74335>>>>>>>>>>>>>Define SCVS_NONE                               For 0
74335>>>>>>>>>>>>>Define SCVS_RECTANGULARSELECTION               For 1
74335>>>>>>>>>>>>>Define SCVS_USERACCESSIBLE                     For 2
74335>>>>>>>>>>>>>Define SCVS_NOWRAPLINESTART                    For 4
74335>>>>>>>>>>>>>Define SCI_SETVIRTUALSPACEOPTIONS              For 2596
74335>>>>>>>>>>>>>Define SCI_GETVIRTUALSPACEOPTIONS              For 2597
74335>>>>>>>>>>>>>Define SCI_SETRECTANGULARSELECTIONMODIFIER     For 2598
74335>>>>>>>>>>>>>Define SCI_GETRECTANGULARSELECTIONMODIFIER     For 2599
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALSELFORE                For 2600
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALSELBACK                For 2601
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALSELALPHA               For 2602
74335>>>>>>>>>>>>>Define SCI_GETADDITIONALSELALPHA               For 2603
74335>>>>>>>>>>>>>Define SCI_SETADDITIONALCARETFORE              For 2604
74335>>>>>>>>>>>>>Define SCI_GETADDITIONALCARETFORE              For 2605
74335>>>>>>>>>>>>>Define SCI_ROTATESELECTION                     For 2606
74335>>>>>>>>>>>>>Define SCI_SWAPMAINANCHORCARET                 For 2607
74335>>>>>>>>>>>>>Define SCI_MULTIPLESELECTADDNEXT               For 2688
74335>>>>>>>>>>>>>Define SCI_MULTIPLESELECTADDEACH               For 2689
74335>>>>>>>>>>>>>Define SCI_CHANGELEXERSTATE                    For 2617
74335>>>>>>>>>>>>>Define SCI_CONTRACTEDFOLDNEXT                  For 2618
74335>>>>>>>>>>>>>Define SCI_VERTICALCENTRECARET                 For 2619
74335>>>>>>>>>>>>>Define SCI_MOVESELECTEDLINESUP                 For 2620
74335>>>>>>>>>>>>>Define SCI_MOVESELECTEDLINESDOWN               For 2621
74335>>>>>>>>>>>>>Define SCI_SETIDENTIFIER                       For 2622
74335>>>>>>>>>>>>>Define SCI_GETIDENTIFIER                       For 2623
74335>>>>>>>>>>>>>Define SCI_RGBAIMAGESETWIDTH                   For 2624
74335>>>>>>>>>>>>>Define SCI_RGBAIMAGESETHEIGHT                  For 2625
74335>>>>>>>>>>>>>Define SCI_RGBAIMAGESETSCALE                   For 2651
74335>>>>>>>>>>>>>Define SCI_MARKERDEFINERGBAIMAGE               For 2626
74335>>>>>>>>>>>>>Define SCI_REGISTERRGBAIMAGE                   For 2627
74335>>>>>>>>>>>>>Define SCI_SCROLLTOSTART                       For 2628
74335>>>>>>>>>>>>>Define SCI_SCROLLTOEND                         For 2629
74335>>>>>>>>>>>>>Define SC_TECHNOLOGY_DEFAULT                   For 0
74335>>>>>>>>>>>>>Define SC_TECHNOLOGY_DIRECTWRITE               For 1
74335>>>>>>>>>>>>>Define SC_TECHNOLOGY_DIRECTWRITERETAIN         For 2
74335>>>>>>>>>>>>>Define SC_TECHNOLOGY_DIRECTWRITEDC             For 3
74335>>>>>>>>>>>>>Define SCI_SETTECHNOLOGY                       For 2630
74335>>>>>>>>>>>>>Define SCI_GETTECHNOLOGY                       For 2631
74335>>>>>>>>>>>>>Define SCI_CREATELOADER                        For 2632
74335>>>>>>>>>>>>>Define SCI_FINDINDICATORSHOW                   For 2640
74335>>>>>>>>>>>>>Define SCI_FINDINDICATORFLASH                  For 2641
74335>>>>>>>>>>>>>Define SCI_FINDINDICATORHIDE                   For 2642
74335>>>>>>>>>>>>>Define SCI_VCHOMEDISPLAY                       For 2652
74335>>>>>>>>>>>>>Define SCI_VCHOMEDISPLAYEXTEND                 For 2653
74335>>>>>>>>>>>>>Define SCI_GETCARETLINEVISIBLEALWAYS           For 2654
74335>>>>>>>>>>>>>Define SCI_SETCARETLINEVISIBLEALWAYS           For 2655
74335>>>>>>>>>>>>>Define SC_LINE_END_TYPE_DEFAULT                For 0
74335>>>>>>>>>>>>>Define SC_LINE_END_TYPE_UNICODE                For 1
74335>>>>>>>>>>>>>Define SCI_SETLINEENDTYPESALLOWED              For 2656
74335>>>>>>>>>>>>>Define SCI_GETLINEENDTYPESALLOWED              For 2657
74335>>>>>>>>>>>>>Define SCI_GETLINEENDTYPESACTIVE               For 2658
74335>>>>>>>>>>>>>Define SCI_SETREPRESENTATION                   For 2665
74335>>>>>>>>>>>>>Define SCI_GETREPRESENTATION                   For 2666
74335>>>>>>>>>>>>>Define SCI_CLEARREPRESENTATION                 For 2667
74335>>>>>>>>>>>>>Define SCI_STARTRECORD                         For 3001
74335>>>>>>>>>>>>>Define SCI_STOPRECORD                          For 3002
74335>>>>>>>>>>>>>Define SCI_SETLEXER                            For 4001
74335>>>>>>>>>>>>>Define SCI_GETLEXER                            For 4002
74335>>>>>>>>>>>>>Define SCI_COLOURISE                           For 4003
74335>>>>>>>>>>>>>Define SCI_SETPROPERTY                         For 4004
74335>>>>>>>>>>>>>Define KEYWORDSET_MAX                          For 8
74335>>>>>>>>>>>>>Define SCI_SETKEYWORDS                         For 4005
74335>>>>>>>>>>>>>Define SCI_SETLEXERLANGUAGE                    For 4006
74335>>>>>>>>>>>>>Define SCI_LOADLEXERLIBRARY                    For 4007
74335>>>>>>>>>>>>>Define SCI_GETPROPERTY                         For 4008
74335>>>>>>>>>>>>>Define SCI_GETPROPERTYEXPANDED                 For 4009
74335>>>>>>>>>>>>>Define SCI_GETPROPERTYINT                      For 4010
74335>>>>>>>>>>>>>Define SCI_GETLEXERLANGUAGE                    For 4012
74335>>>>>>>>>>>>>Define SCI_PRIVATELEXERCALL                    For 4013
74335>>>>>>>>>>>>>Define SCI_PROPERTYNAMES                       For 4014
74335>>>>>>>>>>>>>Define SC_TYPE_BOOLEAN                         For 0
74335>>>>>>>>>>>>>Define SC_TYPE_INTEGER                         For 1
74335>>>>>>>>>>>>>Define SC_TYPE_STRING                          For 2
74335>>>>>>>>>>>>>Define SCI_PROPERTYTYPE                        For 4015
74335>>>>>>>>>>>>>Define SCI_DESCRIBEPROPERTY                    For 4016
74335>>>>>>>>>>>>>Define SCI_DESCRIBEKEYWORDSETS                 For 4017
74335>>>>>>>>>>>>>Define SCI_GETLINEENDTYPESSUPPORTED            For 4018
74335>>>>>>>>>>>>>Define SCI_ALLOCATESUBSTYLES                   For 4020
74335>>>>>>>>>>>>>Define SCI_GETSUBSTYLESSTART                   For 4021
74335>>>>>>>>>>>>>Define SCI_GETSUBSTYLESLENGTH                  For 4022
74335>>>>>>>>>>>>>Define SCI_GETSTYLEFROMSUBSTYLE                For 4027
74335>>>>>>>>>>>>>Define SCI_GETPRIMARYSTYLEFROMSTYLE            For 4028
74335>>>>>>>>>>>>>Define SCI_FREESUBSTYLES                       For 4023
74335>>>>>>>>>>>>>Define SCI_SETIDENTIFIERS                      For 4024
74335>>>>>>>>>>>>>Define SCI_DISTANCETOSECONDARYSTYLES           For 4025
74335>>>>>>>>>>>>>Define SCI_GETSUBSTYLEBASES                    For 4026
74335>>>>>>>>>>>>>Define SCI_GETNAMEDSTYLES                      For 4029
74335>>>>>>>>>>>>>Define SCI_NAMEOFSTYLE                         For 4030
74335>>>>>>>>>>>>>Define SCI_TAGSOFSTYLE                         For 4031
74335>>>>>>>>>>>>>Define SCI_DESCRIPTIONOFSTYLE                  For 4032
74335>>>>>>>>>>>>>Define SC_MOD_INSERTTEXT                       For |CI$01  // $0x1
74335>>>>>>>>>>>>>Define SC_MOD_DELETETEXT                       For |CI$02  // $0x2
74335>>>>>>>>>>>>>Define SC_MOD_CHANGESTYLE                      For |CI$04  // $0x4
74335>>>>>>>>>>>>>Define SC_MOD_CHANGEFOLD                       For |CI$08  // $0x8
74335>>>>>>>>>>>>>Define SC_PERFORMED_USER                       For |CI$010  // $0x10
74335>>>>>>>>>>>>>Define SC_PERFORMED_UNDO                       For |CI$020  // $0x20
74335>>>>>>>>>>>>>Define SC_PERFORMED_REDO                       For |CI$040  // $0x40
74335>>>>>>>>>>>>>Define SC_MULTISTEPUNDOREDO                    For |CI$080  // $0x80
74335>>>>>>>>>>>>>Define SC_LASTSTEPINUNDOREDO                   For |CI$0100  // $0x100
74335>>>>>>>>>>>>>Define SC_MOD_CHANGEMARKER                     For |CI$0200  // $0x200
74335>>>>>>>>>>>>>Define SC_MOD_BEFOREINSERT                     For |CI$0400  // $0x400
74335>>>>>>>>>>>>>Define SC_MOD_BEFOREDELETE                     For |CI$0800  // $0x800
74335>>>>>>>>>>>>>Define SC_MULTILINEUNDOREDO                    For |CI$01000  // $0x1000
74335>>>>>>>>>>>>>Define SC_STARTACTION                          For |CI$2000  // $0x2000
74335>>>>>>>>>>>>>Define SC_MOD_CHANGEINDICATOR                  For |CI$4000  // $0x4000
74335>>>>>>>>>>>>>Define SC_MOD_CHANGELINESTATE                  For |CI$8000  // $0x8000
74335>>>>>>>>>>>>>Define SC_MOD_CHANGEMARGIN                     For |CI$10000  // $0x10000
74335>>>>>>>>>>>>>Define SC_MOD_CHANGEANNOTATION                 For |CI$20000  //$0x20000
74335>>>>>>>>>>>>>Define SC_MOD_CONTAINER                        For |CI$40000  // $0x40000
74335>>>>>>>>>>>>>Define SC_MOD_LEXERSTATE                       For |CI$80000  // $0x80000
74335>>>>>>>>>>>>>Define SC_MOD_INSERTCHECK                      For |CI$100000  // $0x100000
74335>>>>>>>>>>>>>Define SC_MOD_CHANGETABSTOPS                   For |CI$200000  // $0x200000
74335>>>>>>>>>>>>>Define SC_MODEVENTMASKALL                      For |CI$3FFFFF  // $0x3FFFFF
74335>>>>>>>>>>>>>Define SC_UPDATE_CONTENT                       For |CI$01  // $0x1
74335>>>>>>>>>>>>>Define SC_UPDATE_SELECTION                     For |CI$02  // $0x2
74335>>>>>>>>>>>>>Define SC_UPDATE_V_SCROLL                      For |CI$04  // $0x4
74335>>>>>>>>>>>>>Define SC_UPDATE_H_SCROLL                      For |CI$08  // $0x8
74335>>>>>>>>>>>>>Define SCEN_CHANGE                             For 768
74335>>>>>>>>>>>>>Define SCEN_SETFOCUS                           For 512
74335>>>>>>>>>>>>>Define SCEN_KILLFOCUS                          For 256
74335>>>>>>>>>>>>>Define SCK_DOWN                                For 300
74335>>>>>>>>>>>>>Define SCK_UP                                  For 301
74335>>>>>>>>>>>>>Define SCK_LEFT                                For 302
74335>>>>>>>>>>>>>Define SCK_RIGHT                               For 303
74335>>>>>>>>>>>>>Define SCK_HOME                                For 304
74335>>>>>>>>>>>>>Define SCK_END                                 For 305
74335>>>>>>>>>>>>>Define SCK_PRIOR                               For 306
74335>>>>>>>>>>>>>Define SCK_NEXT                                For 307
74335>>>>>>>>>>>>>Define SCK_DELETE                              For 308
74335>>>>>>>>>>>>>Define SCK_INSERT                              For 309
74335>>>>>>>>>>>>>Define SCK_ESCAPE                              For 7
74335>>>>>>>>>>>>>Define SCK_BACK                                For 8
74335>>>>>>>>>>>>>Define SCK_TAB                                 For 9
74335>>>>>>>>>>>>>Define SCK_RETURN                              For 13
74335>>>>>>>>>>>>>Define SCK_ADD                                 For 310
74335>>>>>>>>>>>>>Define SCK_SUBTRACT                            For 311
74335>>>>>>>>>>>>>Define SCK_DIVIDE                              For 312
74335>>>>>>>>>>>>>Define SCK_WIN                                 For 313
74335>>>>>>>>>>>>>Define SCK_RWIN                                For 314
74335>>>>>>>>>>>>>Define SCK_MENU                                For 315
74335>>>>>>>>>>>>>Define SCMOD_NORM                              For 0
74335>>>>>>>>>>>>>Define SCMOD_SHIFT                             For 1
74335>>>>>>>>>>>>>Define SCMOD_CTRL                              For 2
74335>>>>>>>>>>>>>Define SCMOD_ALT                               For 4
74335>>>>>>>>>>>>>Define SCMOD_SUPER                             For 8
74335>>>>>>>>>>>>>Define SCMOD_META                              For 16
74335>>>>>>>>>>>>>Define SC_AC_FILLUP                            For 1
74335>>>>>>>>>>>>>Define SC_AC_DOUBLECLICK                       For 2
74335>>>>>>>>>>>>>Define SC_AC_TAB                               For 3
74335>>>>>>>>>>>>>Define SC_AC_NEWLINE                           For 4
74335>>>>>>>>>>>>>Define SC_AC_COMMAND                           For 5
74335>>>>>>>>>>>>>Define SCN_STYLENEEDED                         For 2000   // SCN - Notifications
74335>>>>>>>>>>>>>Define SCN_CHARADDED                           For 2001
74335>>>>>>>>>>>>>Define SCN_SAVEPOINTREACHED                    For 2002
74335>>>>>>>>>>>>>Define SCN_SAVEPOINTLEFT                       For 2003
74335>>>>>>>>>>>>>Define SCN_MODIFYATTEMPTRO                     For 2004
74335>>>>>>>>>>>>>Define SCN_KEY                                 For 2005
74335>>>>>>>>>>>>>Define SCN_DOUBLECLICK                         For 2006
74335>>>>>>>>>>>>>Define SCN_UPDATEUI                            For 2007
74335>>>>>>>>>>>>>Define SCN_MODIFIED                            For 2008
74335>>>>>>>>>>>>>Define SCN_MACRORECORD                         For 2009
74335>>>>>>>>>>>>>Define SCN_MARGINCLICK                         For 2010
74335>>>>>>>>>>>>>Define SCN_NEEDSHOWN                           For 2011
74335>>>>>>>>>>>>>Define SCN_PAINTED                             For 2013
74335>>>>>>>>>>>>>Define SCN_USERLISTSELECTION                   For 2014
74335>>>>>>>>>>>>>Define SCN_URIDROPPED                          For 2015
74335>>>>>>>>>>>>>Define SCN_DWELLSTART                          For 2016
74335>>>>>>>>>>>>>Define SCN_DWELLEND                            For 2017
74335>>>>>>>>>>>>>Define SCN_ZOOM                                For 2018
74335>>>>>>>>>>>>>Define SCN_HOTSPOTCLICK                        For 2019
74335>>>>>>>>>>>>>Define SCN_HOTSPOTDOUBLECLICK                  For 2020
74335>>>>>>>>>>>>>Define SCN_CALLTIPCLICK                        For 2021
74335>>>>>>>>>>>>>Define SCN_AUTOCSELECTION                      For 2022
74335>>>>>>>>>>>>>Define SCN_INDICATORCLICK                      For 2023
74335>>>>>>>>>>>>>Define SCN_INDICATORRELEASE                    For 2024
74335>>>>>>>>>>>>>Define SCN_AUTOCCANCELLED                      For 2025
74335>>>>>>>>>>>>>Define SCN_AUTOCCHARDELETED                    For 2026
74335>>>>>>>>>>>>>Define SCN_HOTSPOTRELEASECLICK                 For 2027
74335>>>>>>>>>>>>>Define SCN_FOCUSIN                             For 2028
74335>>>>>>>>>>>>>Define SCN_FOCUSOUT                            For 2029
74335>>>>>>>>>>>>>Define SCN_AUTOCCOMPLETED                      For 2030
74335>>>>>>>>>>>>>Define SCN_MARGINRIGHTCLICK                    For 2031
74335>>>>>>>>>>>>>Define SCN_AUTOCSELECTIONCHANGE                For 2032
74335>>>>>>>>>>>>>Define SC_BIDIRECTIONAL_DISABLED               For 0
74335>>>>>>>>>>>>>Define SC_BIDIRECTIONAL_L2R                    For 1
74335>>>>>>>>>>>>>Define SC_BIDIRECTIONAL_R2L                    For 2
74335>>>>>>>>>>>>>Define SCI_GETBIDIRECTIONAL                    For 2708
74335>>>>>>>>>>>>>Define SCI_SETBIDIRECTIONAL                    For 2709
74335>>>>>>>>>>>>>Define SC_LINECHARACTERINDEX_NONE              For 0
74335>>>>>>>>>>>>>Define SC_LINECHARACTERINDEX_UTF32             For 1
74335>>>>>>>>>>>>>Define SC_LINECHARACTERINDEX_UTF16             For 2
74335>>>>>>>>>>>>>Define SCI_GETLINECHARACTERINDEX               For 2710
74335>>>>>>>>>>>>>Define SCI_ALLOCATELINECHARACTERINDEX          For 2711
74335>>>>>>>>>>>>>Define SCI_RELEASELINECHARACTERINDEX           For 2712
74335>>>>>>>>>>>>>Define SCI_LINEFROMINDEXPOSITION               For 2713
74335>>>>>>>>>>>>>Define SCI_INDEXPOSITIONFROMLINE               For 2714
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>// Basic signed type used throughout interface (see scintilla source Sci_Position.h)
74335>>>>>>>>>>>>>// typedef ptrdiff_t Sci_Position;
74335>>>>>>>>>>>>>Define Sci_Position For Longptr
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>// Unsigned variant used for ILexer::Lex and ILexer::Fold
74335>>>>>>>>>>>>>// typedef size_t Sci_PositionU;
74335>>>>>>>>>>>>>Define Sci_PositionU For ULongptr
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>// For Sci_CharacterRange  which is defined as long to be compatible with Win32 CHARRANGE
74335>>>>>>>>>>>>>// typedef long Sci_PositionCR;
74335>>>>>>>>>>>>>Define Sci_PositionCR For integer
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>//struct Sci_CharacterRange {
74335>>>>>>>>>>>>>//    Sci_PositionCR cpMin;
74335>>>>>>>>>>>>>//    Sci_PositionCR cpMax;
74335>>>>>>>>>>>>>//};
74335>>>>>>>>>>>>>Struct tSci_CharacterRange
74335>>>>>>>>>>>>>  Sci_PositionCR cpMin
74335>>>>>>>>>>>>>  Sci_PositionCR cpMax
74335>>>>>>>>>>>>>End_Struct
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>//struct Sci_TextRange {
74335>>>>>>>>>>>>>//    struct Sci_CharacterRange chrg;
74335>>>>>>>>>>>>>//    char *lpstrText;
74335>>>>>>>>>>>>>//};
74335>>>>>>>>>>>>>Struct tSci_TextRange
74335>>>>>>>>>>>>>  tSci_CharacterRange chrg
74335>>>>>>>>>>>>>  tSci_CharacterRange chrg
74335>>>>>>>>>>>>>  Pointer lpstrText
74335>>>>>>>>>>>>>End_Struct
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>//struct Sci_TextToFind {
74335>>>>>>>>>>>>>//    struct Sci_CharacterRange chrg;     // range to search
74335>>>>>>>>>>>>>//    const char *lpstrText;              // the search pattern (zero terminated)
74335>>>>>>>>>>>>>//    struct Sci_CharacterRange chrgText; // returned as position of matching text
74335>>>>>>>>>>>>>//};
74335>>>>>>>>>>>>>Struct tSci_TextToFind
74335>>>>>>>>>>>>>  tSci_CharacterRange chrg
74335>>>>>>>>>>>>>  tSci_CharacterRange chrg
74335>>>>>>>>>>>>>  Pointer            pszText
74335>>>>>>>>>>>>>  tSci_CharacterRange chrgText
74335>>>>>>>>>>>>>  tSci_CharacterRange chrgText
74335>>>>>>>>>>>>>End_Struct
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>//struct Sci_Rectangle {
74335>>>>>>>>>>>>>//      int left;
74335>>>>>>>>>>>>>//      int top;
74335>>>>>>>>>>>>>//      int right;
74335>>>>>>>>>>>>>//      int bottom;
74335>>>>>>>>>>>>>//};
74335>>>>>>>>>>>>>Struct tSci_Rectangle
74335>>>>>>>>>>>>>  Integer left
74335>>>>>>>>>>>>>  Integer top
74335>>>>>>>>>>>>>  Integer right
74335>>>>>>>>>>>>>  Integer bottom
74335>>>>>>>>>>>>>End_Struct
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>//  Struct Sci_NotifyHeader {
74335>>>>>>>>>>>>>//      /* Compatible with Windows NMHDR.
74335>>>>>>>>>>>>>//       * hwndFrom is really an environment specific window handle or pointer
74335>>>>>>>>>>>>>//       * but most clients of Scintilla.h do not have this type visible. */
74335>>>>>>>>>>>>>//      void *hwndFrom;
74335>>>>>>>>>>>>>//      uptr_t idFrom;
74335>>>>>>>>>>>>>//      unsigned int code;
74335>>>>>>>>>>>>>//  };
74335>>>>>>>>>>>>>Struct tSci_NotifyHeader
74335>>>>>>>>>>>>>  Handle   hwndFrom
74335>>>>>>>>>>>>>  ULongptr idFrom
74335>>>>>>>>>>>>>  UInteger uCode
74335>>>>>>>>>>>>>End_Struct
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>//  Struct SCNotification {
74335>>>>>>>>>>>>>//      Sci_NotifyHeader nmhdr;
74335>>>>>>>>>>>>>//      Sci_Position position;
74335>>>>>>>>>>>>>//      /* SCN_STYLENEEDED, SCN_DOUBLECLICK, SCN_MODIFIED, SCN_MARGINCLICK, */
74335>>>>>>>>>>>>>//      /* SCN_NEEDSHOWN, SCN_DWELLSTART, SCN_DWELLEND, SCN_CALLTIPCLICK, */
74335>>>>>>>>>>>>>//      /* SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK, SCN_HOTSPOTRELEASECLICK, */
74335>>>>>>>>>>>>>//      /* SCN_INDICATORCLICK, SCN_INDICATORRELEASE, */
74335>>>>>>>>>>>>>//      /* SCN_USERLISTSELECTION, SCN_AUTOCSELECTION */
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>//      int ch;
74335>>>>>>>>>>>>>//      /* SCN_CHARADDED, SCN_KEY, SCN_AUTOCCOMPLETED, SCN_AUTOCSELECTION, */
74335>>>>>>>>>>>>>//      /* SCN_USERLISTSELECTION */
74335>>>>>>>>>>>>>//      int modifiers;
74335>>>>>>>>>>>>>//      /* SCN_KEY, SCN_DOUBLECLICK, SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK, */
74335>>>>>>>>>>>>>//      /* SCN_HOTSPOTRELEASECLICK, SCN_INDICATORCLICK, SCN_INDICATORRELEASE, */
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>//      int modificationType;   /* SCN_MODIFIED */
74335>>>>>>>>>>>>>//      const Char *text;
74335>>>>>>>>>>>>>//      /* SCN_MODIFIED, SCN_USERLISTSELECTION, SCN_AUTOCSELECTION, SCN_URIDROPPED */
74335>>>>>>>>>>>>>//
74335>>>>>>>>>>>>>//      Sci_Position length;            /* SCN_MODIFIED */
74335>>>>>>>>>>>>>//      Sci_Position linesAdded;        /* SCN_MODIFIED */
74335>>>>>>>>>>>>>//      int message;    /* SCN_MACRORECORD */
74335>>>>>>>>>>>>>//      uptr_t wParam;  /* SCN_MACRORECORD */
74335>>>>>>>>>>>>>//      sptr_t lParam;  /* SCN_MACRORECORD */
74335>>>>>>>>>>>>>//      Sci_Position line;              /* SCN_MODIFIED */
74335>>>>>>>>>>>>>//      int foldLevelNow;       /* SCN_MODIFIED */
74335>>>>>>>>>>>>>//      int foldLevelPrev;      /* SCN_MODIFIED */
74335>>>>>>>>>>>>>//      int margin;             /* SCN_MARGINCLICK */
74335>>>>>>>>>>>>>//      int listType;   /* SCN_USERLISTSELECTION */
74335>>>>>>>>>>>>>//      int x;                  /* SCN_DWELLSTART, SCN_DWELLEND */
74335>>>>>>>>>>>>>//      int y;          /* SCN_DWELLSTART, SCN_DWELLEND */
74335>>>>>>>>>>>>>//      int token;              /* SCN_MODIFIED with SC_MOD_CONTAINER */
74335>>>>>>>>>>>>>//      Sci_Position annotationLinesAdded;      /* SCN_MODIFIED with SC_MOD_CHANGEANNOTATION */
74335>>>>>>>>>>>>>//      int updated;    /* SCN_UPDATEUI */
74335>>>>>>>>>>>>>//      int listCompletionMethod;
74335>>>>>>>>>>>>>//      /* SCN_AUTOCSELECTION, SCN_AUTOCCOMPLETED, SCN_USERLISTSELECTION, */
74335>>>>>>>>>>>>>//  };
74335>>>>>>>>>>>>>Struct tSCNotification
74335>>>>>>>>>>>>>  tSci_NotifyHeader nmhdr
74335>>>>>>>>>>>>>  tSci_NotifyHeader nmhdr
74335>>>>>>>>>>>>>  Sci_Position      position
74335>>>>>>>>>>>>>  Integer           ch
74335>>>>>>>>>>>>>  Integer           modifiers
74335>>>>>>>>>>>>>  Integer           modificationType
74335>>>>>>>>>>>>>  Address           Text
74335>>>>>>>>>>>>>  Sci_Position      length
74335>>>>>>>>>>>>>  Sci_Position      linesAdded
74335>>>>>>>>>>>>>  Integer           message
74335>>>>>>>>>>>>>  ULongptr          wParam
74335>>>>>>>>>>>>>  Longptr           lParam
74335>>>>>>>>>>>>>  Sci_Position      line
74335>>>>>>>>>>>>>  Integer           foldLevelNow
74335>>>>>>>>>>>>>  Integer           foldLevelPrev
74335>>>>>>>>>>>>>  Integer           margin
74335>>>>>>>>>>>>>  Integer           listType
74335>>>>>>>>>>>>>  Integer           x
74335>>>>>>>>>>>>>  Integer           y
74335>>>>>>>>>>>>>  Integer           token
74335>>>>>>>>>>>>>  Sci_Position      annotationLinesAdded
74335>>>>>>>>>>>>>  Integer           updated
74335>>>>>>>>>>>>>  Integer           listCompletionMethod
74335>>>>>>>>>>>>>  //Integer           characterSource  // not in the current scintilla YET
74335>>>>>>>>>>>>>End_Struct
74335>>>>>>>>>>>
74335>>>>>>>>>>>
74335>>>>>>>>>>>Define CS_CR   For (Character(13))
74335>>>>>>>>>>>Define CS_CRLF For (Character(13)+Character(10))
74335>>>>>>>>>>>Define CS_LF   For (Character(10))
74335>>>>>>>>>>>
74335>>>>>>>>>>>
74335>>>>>>>>>>>Define CMAX_DLL_NAME For SCILEXER32.DLL
74335>>>>>>>>>>>
74335>>>>>>>>>>>
74335>>>>>>>>>>>Define NM_SETFOCUS              For -7
74335>>>>>>>>>>>Define NM_KILLFOCUS             For -8
74335>>>>>>>>>>>
74335>>>>>>>>>>>Define WM_CONTEXTMENU           For |CI$007B // 0x007B
74335>>>>>>>>>>>Define WM_RBUTTONUP             For |CI$0205 // 0x0205
74335>>>>>>>>>>>
74335>>>>>>>>>>>External_Function GetObject          'GetObjectA'           Gdi32.dll   Handle hGdi Integer iSize Pointer pBuff Returns Integer
74336>>>>>>>>>>>External_Function LockWindowUpdate   'LockWindowUpdate'     USer32.dll  Handle hwnd Returns Integer
74337>>>>>>>>>>>External_Function ReplyMessage       'ReplyMessage'         User32.dll  Integer iResult Returns Integer
74338>>>>>>>>>>>
74338>>>>>>>>>>>// File Dropping from e.g WindowsExplorer.
74338>>>>>>>>>>>Define WM_DROPFILES              For |CI$0233
74338>>>>>>>>>>>External_Function DragAcceptFiles    'DragAcceptFiles'      Shell32.dll Handle hwnd Integer iFlag Returns Integer
74339>>>>>>>>>>>External_Function DragQueryFile      'DragQueryFile'        Shell32.dll Handle hDrop Integer iFileIndex Pointer pFileBuff Integer iBuffSize Returns Integer
74340>>>>>>>>>>>External_Function DragFinish         'DragFinish'           Shell32.dll Handle hDrop Returns Integer
74341>>>>>>>>>>>
74341>>>>>>>>>>>// CodeTip Support external Function
74341>>>>>>>>>>>External_Function CT_DestroyWindow   'DestroyWindow'        User32.dll  Handle hWnd Returns Integer
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define RDW_INVALIDATE          For |CI$0001
74342>>>>>>>>>>>Define RDW_INTERNALPAINT       For |CI$0002
74342>>>>>>>>>>>Define RDW_ERASE               For |CI$0004
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define RDW_VALIDATE            For |CI$0008
74342>>>>>>>>>>>Define RDW_NOINTERNALPAINT     For |CI$0010
74342>>>>>>>>>>>Define RDW_NOERASE             For |CI$0020
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define RDW_NOCHILDREN          For |CI$0040
74342>>>>>>>>>>>Define RDW_ALLCHILDREN         For |CI$0080
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define RDW_UPDATENOW           For |CI$0100
74342>>>>>>>>>>>Define RDW_ERASENOW            For |CI$0200
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define RDW_FRAME               For |CI$0400
74342>>>>>>>>>>>Define RDW_NOFRAME             For |CI$0800
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define COLORREF For DWord
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>// Is a command that allows to put a string into a structure
74342>>>>>>>>>>>// Usage: PUT_POINTER sName  pName  "String..."  to sBuff at TYPE.FIELD
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define LF_FACESIZE          For 32
74342>>>>>>>>>>>Define CODEMAXWNDCLASS      For "Scintilla" //"CodeSense" //"CodeMax"
74342>>>>>>>>>>>
74342>>>>>>>>>>>/////////////////////////////////////////////////////////////
74342>>>>>>>>>>>//
74342>>>>>>>>>>>// Constants
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>
74342>>>>>>>>>>>// maximum size (TCHARs) of text to find or replace
74342>>>>>>>>>>>Define CM_MAX_FINDREPL_TEXT          For 100
74342>>>>>>>>>>>// maximum MRU size in find and find/replace dialogs
74342>>>>>>>>>>>Define CM_FIND_REPLACE_MRU_MAX       For 10
74342>>>>>>>>>>>// required buffer size for pszMRUList argument CMSetFindReplaceMRUList() and CMGetFindReplaceMRUList()
74342>>>>>>>>>>>Define CM_FIND_REPLACE_MRU_BUFF_SIZE For ( ( CM_MAX_FINDREPL_TEXT + 1 ) * CM_FIND_REPLACE_MRU_MAX )
74342>>>>>>>>>>>// maximum number of keystroke macros supported by CodeMax
74342>>>>>>>>>>>Define CM_MAX_MACROS                 For 10
74342>>>>>>>>>>>// maximum size of command string returned in pszBuff param of CMGetCommandString() if bDescription is FALSE
74342>>>>>>>>>>>Define CM_MAX_CMD_STRING             For 50
74342>>>>>>>>>>>// maximum size of command string returned in pszBuff param of CMGetCommandString() if bDescription is TRUE
74342>>>>>>>>>>>Define CM_MAX_CMD_DESCRIPTION        For 100
74342>>>>>>>>>>>// maximum size of a language name set with CMRegisterLanguage
74342>>>>>>>>>>>Define CM_MAX_LANGUAGE_NAME          For 30
74342>>>>>>>>>>>// maximum tab size (characters)
74342>>>>>>>>>>>Define CM_MAX_TABSIZE                For 100
74342>>>>>>>>>>>// minimum tab size (characters)
74342>>>>>>>>>>>Define CM_MIN_TABSIZE                For 2
74342>>>>>>>>>>>// left margin width (pixels)
74342>>>>>>>>>>>Define CM_CXLEFTMARGIN               For 24
74342>>>>>>>>>>>// SVN // maximum CodeList tooltip text length
74342>>>>>>>>>>>Define CM_MAX_CODELIST_TIP                       For 128
74342>>>>>>>>>>>
74342>>>>>>>>>>>/////////////////////////////////////////////////////////////
74342>>>>>>>>>>>//
74342>>>>>>>>>>>// CMM_SETLINESTYLE style bits
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>Define CML_OWNERDRAW      For |CI$1      // Parent window should receive CMN_DRAWLINE notifications
74342>>>>>>>>>>>Define CML_NOTIFY_DEL     For |CI$2      // Parent window should receive CMN_DELETELINE notifications
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>/////////////////////////////////////////////////////////////
74342>>>>>>>>>>>//
74342>>>>>>>>>>>// Messages - CMM_xxxxxx
74342>>>>>>>>>>>// As long as they are listed then they have not yet been migrated to scintilla
74342>>>>>>>>>>>// If commented out then it means not in scintilla or it simply works so much different that I have not
74342>>>>>>>>>>>// made up my mind on how-to implement or migrate.
74342>>>>>>>>>>>//
74342>>>>>>>>>>>Define CMM_SETLANGUAGE                For ( WM_USER + 1600 )
74342>>>>>>>>>>>Define CMM_GETLANGUAGE                For ( WM_USER + 1601 )
74342>>>>>>>>>>>//Define CMM_ENABLECOLORSYNTAX          FOR ( WM_USER + 1610 )
74342>>>>>>>>>>>//Define CMM_ISCOLORSYNTAXENABLED       FOR ( WM_USER + 1620 )
74342>>>>>>>>>>>//Define CMM_SETCOLORS                  FOR ( WM_USER + 1630 )
74342>>>>>>>>>>>//Define CMM_GETCOLORS                  FOR ( WM_USER + 1640 )
74342>>>>>>>>>>>Define CMM_ENABLEWHITESPACEDISPLAY    For ( WM_USER + 1800 )
74342>>>>>>>>>>>Define CMM_ISWHITESPACEDISPLAYENABLED For ( WM_USER + 1810 )
74342>>>>>>>>>>>Define CMM_ENABLETABEXPAND            For ( WM_USER + 1811 )
74342>>>>>>>>>>>Define CMM_ISTABEXPANDENABLED         For ( WM_USER + 1812 )
74342>>>>>>>>>>>//Define CMM_ENABLESMOOTHSCROLLING      FOR ( WM_USER + 1820 )
74342>>>>>>>>>>>//Define CMM_ISSMOOTHSCROLLINGENABLED   FOR ( WM_USER + 1830 )
74342>>>>>>>>>>>//Define CMM_ENABLELINETOOLTIPS         FOR ( WM_USER + 1860 )
74342>>>>>>>>>>>//Define CMM_ISLINETOOLTIPSENABLED      FOR ( WM_USER + 1870 )
74342>>>>>>>>>>>Define CMM_ENABLELEFTMARGIN           For ( WM_USER + 1880 )
74342>>>>>>>>>>>Define CMM_ISLEFTMARGINENABLED        For ( WM_USER + 1890 )
74342>>>>>>>>>>>Define CMM_ENABLECOLUMNSEL            For ( WM_USER + 1891 )
74342>>>>>>>>>>>Define CMM_ISCOLUMNSELENABLED         For ( WM_USER + 1892 )
74342>>>>>>>>>>>Define CMM_ENABLEDRAGDROP             For ( WM_USER + 1893 )
74342>>>>>>>>>>>Define CMM_ISDRAGDROPENABLED          For ( WM_USER + 1894 )
74342>>>>>>>>>>>//Define CMM_SETTOPINDEX                FOR ( WM_USER + 1960 )
74342>>>>>>>>>>>//Define CMM_GETTOPINDEX                FOR ( WM_USER + 1970 )
74342>>>>>>>>>>>Define CMM_GETVISIBLELINECOUNT        For ( WM_USER + 1980 )
74342>>>>>>>>>>>Define CMM_HITTEST                    For ( WM_USER + 1990 )
74342>>>>>>>>>>>Define CMM_INSERTFILE                 For ( WM_USER + 2320 )
74342>>>>>>>>>>>Define CMM_INSERTTEXT                 For ( WM_USER + 2330 )
74342>>>>>>>>>>>Define CMM_REPLACETEXT                For ( WM_USER + 2340 )
74342>>>>>>>>>>>Define CMM_GETWORDLENGTH              For ( WM_USER + 2382 )
74342>>>>>>>>>>>Define CMM_GETSEL                     For ( WM_USER + 2420 )
74342>>>>>>>>>>>Define CMM_GETSELFROMPOINT            For ( WM_USER + 2425 )
74342>>>>>>>>>>>Define CMM_SETSEL                     For ( WM_USER + 2430 )
74342>>>>>>>>>>>Define CMM_DELETESEL                  For ( WM_USER + 2440 )
74342>>>>>>>>>>>Define CMM_REPLACESEL                 For ( WM_USER + 2450 )
74342>>>>>>>>>>>Define CMM_SETMODIFIED                For ( WM_USER + 2461 )
74342>>>>>>>>>>>Define CMM_ENABLECRLF                 For ( WM_USER + 2470 )
74342>>>>>>>>>>>Define CMM_ISCRLFENABLED              For ( WM_USER + 2480 )
74342>>>>>>>>>>>//Define CMM_SETFONTOWNERSHIP           FOR ( WM_USER + 2485 )
74342>>>>>>>>>>>//Define CMM_GETFONTOWNERSHIP           FOR ( WM_USER + 2486 )
74342>>>>>>>>>>>Define CMM_EXECUTECMD                 For ( WM_USER + 2700 )
74342>>>>>>>>>>>//Define CMM_SETSPLITTERPOS             FOR ( WM_USER + 2900 )
74342>>>>>>>>>>>//Define CMM_GETSPLITTERPOS             FOR ( WM_USER + 2901 )
74342>>>>>>>>>>>Define CMM_GETVIEWCOUNT               For ( WM_USER + 3600 )
74342>>>>>>>>>>>Define CMM_GETCURRENTVIEW             For ( WM_USER + 3610 )
74342>>>>>>>>>>>//Define CMM_ENABLESPLITTER             FOR ( WM_USER + 3720 )
74342>>>>>>>>>>>//Define CMM_ISSPLITTERENABLED          FOR ( WM_USER + 3730 )
74342>>>>>>>>>>>Define CMM_ISRECORDINGMACRO           For ( WM_USER + 3731 )
74342>>>>>>>>>>>Define CMM_ISPLAYINGMACRO             For ( WM_USER + 3732 )
74342>>>>>>>>>>>Define CMM_ENABLEGLOBALPROPS          For ( WM_USER + 3740 )
74342>>>>>>>>>>>Define CMM_ISGLOBALPROPSENABLED       For ( WM_USER + 3741 )
74342>>>>>>>>>>>Define CMM_SETDLGPARENT               For ( WM_USER + 3750 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>// 2.0
74342>>>>>>>>>>>Define CMM_ENABLESELBOUNDS            For ( WM_USER + 3760 )
74342>>>>>>>>>>>Define CMM_ISSELBOUNDSENABLED         For ( WM_USER + 3770 )
74342>>>>>>>>>>>//Define CMM_SETFONTSTYLES              FOR ( WM_USER + 3780 )
74342>>>>>>>>>>>//Define CMM_GETFONTSTYLES              FOR ( WM_USER + 3790 )
74342>>>>>>>>>>>Define CMM_ENABLEREGEXP               For ( WM_USER + 3800 )
74342>>>>>>>>>>>Define CMM_ISREGEXPENABLED            For ( WM_USER + 3810 )
74342>>>>>>>>>>>Define CMM_SETITEMDATA                For ( WM_USER + 3820 )
74342>>>>>>>>>>>Define CMM_GETITEMDATA                For ( WM_USER + 3830 )
74342>>>>>>>>>>>Define CMM_SETLINESTYLE               For ( WM_USER + 3840 )
74342>>>>>>>>>>>Define CMM_GETLINESTYLE               For ( WM_USER + 3850 )
74342>>>>>>>>>>>Define CMM_SETBOOKMARK                For ( WM_USER + 3860 )
74342>>>>>>>>>>>Define CMM_GETBOOKMARK                For ( WM_USER + 3870 )
74342>>>>>>>>>>>Define CMM_SETALLBOOKMARKS            For ( WM_USER + 3880 )
74342>>>>>>>>>>>Define CMM_GETALLBOOKMARKS            For ( WM_USER + 3890 )
74342>>>>>>>>>>>Define CMM_POSFROMCHAR                For ( WM_USER + 3920 )
74342>>>>>>>>>>>Define CMM_ENABLEHIDESEL              For ( WM_USER + 3930 )
74342>>>>>>>>>>>Define CMM_ISHIDESELENABLED           For ( WM_USER + 3940 )
74342>>>>>>>>>>>Define CMM_ENABLENORMALIZECASE        For ( WM_USER + 3970 )
74342>>>>>>>>>>>Define CMM_ISNORMALIZECASEENABLED     For ( WM_USER + 3980 )
74342>>>>>>>>>>>Define CMM_SETDIVIDER                 For ( WM_USER + 3990 )
74342>>>>>>>>>>>Define CMM_GETDIVIDER                 For ( WM_USER + 4000 )
74342>>>>>>>>>>>Define CMM_SETFINDTEXT                For ( WM_USER + 4030 )
74342>>>>>>>>>>>Define CMM_GETFINDTEXT                For ( WM_USER + 4040 )
74342>>>>>>>>>>>Define CMM_SETREPLACETEXT             For ( WM_USER + 4050 )
74342>>>>>>>>>>>Define CMM_GETREPLACETEXT             For ( WM_USER + 4060 )
74342>>>>>>>>>>>Define CMM_SETIMAGELIST               For ( WM_USER + 4070 )
74342>>>>>>>>>>>Define CMM_GETIMAGELIST               For ( WM_USER + 4080 )
74342>>>>>>>>>>>Define CMM_SETMARGINIMAGES            For ( WM_USER + 4090 )
74342>>>>>>>>>>>Define CMM_GETMARGINIMAGES            For ( WM_USER + 4100 )
74342>>>>>>>>>>>Define CMM_ABOUTBOX                   For ( WM_USER + 4110 )
74342>>>>>>>>>>>Define CMM_PRINT                      For ( WM_USER + 4120 )
74342>>>>>>>>>>>Define CMM_SETCARETPOS                For ( WM_USER + 4130 )
74342>>>>>>>>>>>Define CMM_VIEWCOLTOBUFFERCOL         For ( WM_USER + 4140 )
74342>>>>>>>>>>>Define CMM_BUFFERCOLTOVIEWCOL         For ( WM_USER + 4150 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>// 2.1
74342>>>>>>>>>>>Define CMM_SETBORDERSTYLE             For ( WM_USER + 4160 )
74342>>>>>>>>>>>Define CMM_GETBORDERSTYLE             For ( WM_USER + 4170 )
74342>>>>>>>>>>>// SVN
74342>>>>>>>>>>>Define CMM_SETCURRENTVIEW             For ( WM_USER + 4180 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define CMM_GETCURRENTTOKEN            For ( WM_USER + 5000 )
74342>>>>>>>>>>>Define CMM_UPDATECONTROLPOSITIONS     For ( WM_USER + 5010 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>// Extensions for Oem/Ansi support
74342>>>>>>>>>>>Define CMM_ENABLEOEMCODE              For ( WM_USER + 4300 )
74342>>>>>>>>>>>Define CMM_ISOEMCODEENABLED           For ( WM_USER + 4301 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>/////////////////////////////////////////////////////////////
74342>>>>>>>>>>>//
74342>>>>>>>>>>>// Edit commands
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define CMD_FIRST                       For 100
74342>>>>>>>>>>>Define CMD_WORDUPPERCASE               For ( CMD_FIRST + 0 )
74342>>>>>>>>>>>Define CMD_WORDTRANSPOSE               For ( CMD_FIRST + 1 )
74342>>>>>>>>>>>Define CMD_WORDRIGHTEXTEND             For ( CMD_FIRST + 2 )
74342>>>>>>>>>>>Define CMD_WORDRIGHT                   For ( CMD_FIRST + 3 )
74342>>>>>>>>>>>Define CMD_WORDENDRIGHT                For ( CMD_FIRST + 4 )
74342>>>>>>>>>>>Define CMD_WORDENDRIGHTEXTEND          For ( CMD_FIRST + 5 )
74342>>>>>>>>>>>Define CMD_WORDLOWERCASE               For ( CMD_FIRST + 6 )
74342>>>>>>>>>>>Define CMD_WORDLEFTEXTEND              For ( CMD_FIRST + 7 )
74342>>>>>>>>>>>Define CMD_WORDLEFT                    For ( CMD_FIRST + 8 )
74342>>>>>>>>>>>Define CMD_WORDENDLEFT                 For ( CMD_FIRST + 9 )
74342>>>>>>>>>>>Define CMD_WORDENDLEFTEXTEND           For ( CMD_FIRST + 10 )
74342>>>>>>>>>>>Define CMD_WORDDELETETOSTART           For ( CMD_FIRST + 11 )
74342>>>>>>>>>>>Define CMD_WORDDELETETOEND             For ( CMD_FIRST + 12 )
74342>>>>>>>>>>>Define CMD_WORDCAPITALIZE              For ( CMD_FIRST + 13 )
74342>>>>>>>>>>>Define CMD_WINDOWSTART                 For ( CMD_FIRST + 14 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLUP              For ( CMD_FIRST + 15 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLTOTOP           For ( CMD_FIRST + 16 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLTOCENTER        For ( CMD_FIRST + 17 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLTOBOTTOM        For ( CMD_FIRST + 18 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLRIGHT           For ( CMD_FIRST + 19 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLLEFT            For ( CMD_FIRST + 20 )
74342>>>>>>>>>>>Define CMD_WINDOWSCROLLDOWN            For ( CMD_FIRST + 21 )
74342>>>>>>>>>>>Define CMD_WINDOWRIGHTEDGE             For ( CMD_FIRST + 22 )
74342>>>>>>>>>>>Define CMD_WINDOWLEFTEDGE              For ( CMD_FIRST + 23 )
74342>>>>>>>>>>>Define CMD_WINDOWEND                   For ( CMD_FIRST + 24 )
74342>>>>>>>>>>>Define CMD_UPPERCASESELECTION          For ( CMD_FIRST + 25 )
74342>>>>>>>>>>>Define CMD_UNTABIFYSELECTION           For ( CMD_FIRST + 26 )
74342>>>>>>>>>>>Define CMD_UNINDENTSELECTION           For ( CMD_FIRST + 27 )
74342>>>>>>>>>>>Define CMD_UNDOCHANGES                 For ( CMD_FIRST + 28 )
74342>>>>>>>>>>>Define CMD_UNDO                        For ( CMD_FIRST + 29 )
74342>>>>>>>>>>>Define CMD_TABIFYSELECTION             For ( CMD_FIRST + 30 )
74342>>>>>>>>>>>Define CMD_SENTENCERIGHT               For ( CMD_FIRST + 31 )
74342>>>>>>>>>>>Define CMD_SENTENCELEFT                For ( CMD_FIRST + 32 )
74342>>>>>>>>>>>Define CMD_SENTENCECUT                 For ( CMD_FIRST + 33 )
74342>>>>>>>>>>>Define CMD_SELECTSWAPANCHOR            For ( CMD_FIRST + 34 )
74342>>>>>>>>>>>Define CMD_SELECTPARA                  For ( CMD_FIRST + 35 )
74342>>>>>>>>>>>Define CMD_SELECTLINE                  For ( CMD_FIRST + 36 )
74342>>>>>>>>>>>Define CMD_SELECTALL                   For ( CMD_FIRST + 37 )
74342>>>>>>>>>>>Define CMD_REDOCHANGES                 For ( CMD_FIRST + 38 )
74342>>>>>>>>>>>Define CMD_REDO                        For ( CMD_FIRST + 39 )
74342>>>>>>>>>>>Define CMD_PASTE                       For ( CMD_FIRST + 40 )
74342>>>>>>>>>>>Define CMD_PARAUP                      For ( CMD_FIRST + 41 )
74342>>>>>>>>>>>Define CMD_PARADOWN                    For ( CMD_FIRST + 42 )
74342>>>>>>>>>>>Define CMD_PAGEUPEXTEND                For ( CMD_FIRST + 43 )
74342>>>>>>>>>>>Define CMD_PAGEUP                      For ( CMD_FIRST + 44 )
74342>>>>>>>>>>>Define CMD_PAGEDOWNEXTEND              For ( CMD_FIRST + 45 )
74342>>>>>>>>>>>Define CMD_PAGEDOWN                    For ( CMD_FIRST + 46 )
74342>>>>>>>>>>>Define CMD_LOWERCASESELECTION          For ( CMD_FIRST + 47 )
74342>>>>>>>>>>>Define CMD_LINEUPEXTEND                For ( CMD_FIRST + 48 )
74342>>>>>>>>>>>Define CMD_LINEUP                      For ( CMD_FIRST + 49 )
74342>>>>>>>>>>>Define CMD_LINETRANSPOSE               For ( CMD_FIRST + 50 )
74342>>>>>>>>>>>Define CMD_LINESTART                   For ( CMD_FIRST + 51 )
74342>>>>>>>>>>>Define CMD_LINEOPENBELOW               For ( CMD_FIRST + 52 )
74342>>>>>>>>>>>Define CMD_LINEOPENABOVE               For ( CMD_FIRST + 53 )
74342>>>>>>>>>>>Define CMD_LINEENDEXTEND               For ( CMD_FIRST + 54 )
74342>>>>>>>>>>>Define CMD_LINEEND                     For ( CMD_FIRST + 55 )
74342>>>>>>>>>>>Define CMD_LINEDOWNEXTEND              For ( CMD_FIRST + 56 )
74342>>>>>>>>>>>Define CMD_LINEDOWN                    For ( CMD_FIRST + 57 )
74342>>>>>>>>>>>Define CMD_LINEDELETETOSTART           For ( CMD_FIRST + 58 )
74342>>>>>>>>>>>Define CMD_LINEDELETETOEND             For ( CMD_FIRST + 59 )
74342>>>>>>>>>>>Define CMD_LINEDELETE                  For ( CMD_FIRST + 60 )
74342>>>>>>>>>>>Define CMD_LINECUT                     For ( CMD_FIRST + 61 )
74342>>>>>>>>>>>Define CMD_INDENTTOPREV                For ( CMD_FIRST + 62 )
74342>>>>>>>>>>>Define CMD_INDENTSELECTION             For ( CMD_FIRST + 63 )
74342>>>>>>>>>>>Define CMD_HOMEEXTEND                  For ( CMD_FIRST + 64 )
74342>>>>>>>>>>>Define CMD_HOME                        For ( CMD_FIRST + 65 )
74342>>>>>>>>>>>Define CMD_GOTOMATCHBRACE              For ( CMD_FIRST + 66 )
74342>>>>>>>>>>>Define CMD_GOTOINDENTATION             For ( CMD_FIRST + 67 )
74342>>>>>>>>>>>Define CMD_GOTOLINE                    For ( CMD_FIRST + 68 )
74342>>>>>>>>>>>Define CMD_FINDREPLACE                 For ( CMD_FIRST + 69 )
74342>>>>>>>>>>>Define CMD_REPLACE                     For ( CMD_FIRST + 70 )
74342>>>>>>>>>>>Define CMD_REPLACEALLINBUFFER          For ( CMD_FIRST + 71 )
74342>>>>>>>>>>>Define CMD_REPLACEALLINSELECTION       For ( CMD_FIRST + 72 )
74342>>>>>>>>>>>Define CMD_FINDPREVWORD                For ( CMD_FIRST + 73 )
74342>>>>>>>>>>>Define CMD_FINDPREV                    For ( CMD_FIRST + 74 )
74342>>>>>>>>>>>Define CMD_FINDNEXTWORD                For ( CMD_FIRST + 75 )
74342>>>>>>>>>>>Define CMD_FINDNEXT                    For ( CMD_FIRST + 76 )
74342>>>>>>>>>>>Define CMD_FINDMARKALL                 For ( CMD_FIRST + 77 )
74342>>>>>>>>>>>Define CMD_FIND                        For ( CMD_FIRST + 78 )
74342>>>>>>>>>>>Define CMD_SETFINDTEXT                 For ( CMD_FIRST + 79 )
74342>>>>>>>>>>>Define CMD_SETREPLACETEXT              For ( CMD_FIRST + 80 )
74342>>>>>>>>>>>Define CMD_TOGGLEPRESERVECASE          For ( CMD_FIRST + 81 )
74342>>>>>>>>>>>Define CMD_TOGGLEWHOLEWORD             For ( CMD_FIRST + 82 )
74342>>>>>>>>>>>Define CMD_TOGGLECASESENSITIVE         For ( CMD_FIRST + 83 )
74342>>>>>>>>>>>Define CMD_END                         For ( CMD_FIRST + 84 )
74342>>>>>>>>>>>Define CMD_TOGGLEWHITESPACEDISPLAY     For ( CMD_FIRST + 85 )
74342>>>>>>>>>>>Define CMD_TOGGLEOVERTYPE              For ( CMD_FIRST + 86 )
74342>>>>>>>>>>>Define CMD_SETREPEATCOUNT              For ( CMD_FIRST + 87 )
74342>>>>>>>>>>>Define CMD_DOCUMENTSTARTEXTEND         For ( CMD_FIRST + 88 )
74342>>>>>>>>>>>Define CMD_DOCUMENTSTART               For ( CMD_FIRST + 89 )
74342>>>>>>>>>>>Define CMD_DOCUMENTENDEXTEND           For ( CMD_FIRST + 90 )
74342>>>>>>>>>>>Define CMD_DOCUMENTEND                 For ( CMD_FIRST + 91 )
74342>>>>>>>>>>>Define CMD_DELETEHORIZONTALSPACE       For ( CMD_FIRST + 92 )
74342>>>>>>>>>>>Define CMD_DELETEBLANKLINES            For ( CMD_FIRST + 93 )
74342>>>>>>>>>>>Define CMD_DELETEBACK                  For ( CMD_FIRST + 94 )
74342>>>>>>>>>>>Define CMD_DELETE                      For ( CMD_FIRST + 95 )
74342>>>>>>>>>>>Define CMD_CUTSELECTION                For ( CMD_FIRST + 96 )
74342>>>>>>>>>>>Define CMD_CUT                         For ( CMD_FIRST + 97 )
74342>>>>>>>>>>>Define CMD_COPY                        For ( CMD_FIRST + 98 )
74342>>>>>>>>>>>Define CMD_CHARTRANSPOSE               For ( CMD_FIRST + 99 )
74342>>>>>>>>>>>Define CMD_CHARRIGHTEXTEND             For ( CMD_FIRST + 100 )
74342>>>>>>>>>>>Define CMD_CHARRIGHT                   For ( CMD_FIRST + 101 )
74342>>>>>>>>>>>Define CMD_CHARLEFTEXTEND              For ( CMD_FIRST + 102 )
74342>>>>>>>>>>>Define CMD_CHARLEFT                    For ( CMD_FIRST + 103 )
74342>>>>>>>>>>>Define CMD_BOOKMARKTOGGLE              For ( CMD_FIRST + 104 )
74342>>>>>>>>>>>Define CMD_BOOKMARKPREV                For ( CMD_FIRST + 105 )
74342>>>>>>>>>>>Define CMD_BOOKMARKNEXT                For ( CMD_FIRST + 106 )
74342>>>>>>>>>>>Define CMD_BOOKMARKCLEARALL            For ( CMD_FIRST + 107 )
74342>>>>>>>>>>>Define CMD_BOOKMARKJUMPTOFIRST         For ( CMD_FIRST + 108 )
74342>>>>>>>>>>>Define CMD_BOOKMARKJUMPTOLAST          For ( CMD_FIRST + 109 )
74342>>>>>>>>>>>Define CMD_APPENDNEXTCUT               For ( CMD_FIRST + 110 )
74342>>>>>>>>>>>Define CMD_INSERTCHAR                  For ( CMD_FIRST + 111 )
74342>>>>>>>>>>>Define CMD_NEWLINE                     For ( CMD_FIRST + 112 )
74342>>>>>>>>>>>Define CMD_RECORDMACRO                 For ( CMD_FIRST + 113 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO1                  For ( CMD_FIRST + 114 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO2                  For ( CMD_FIRST + 115 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO3                  For ( CMD_FIRST + 116 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO4                  For ( CMD_FIRST + 117 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO5                  For ( CMD_FIRST + 118 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO6                  For ( CMD_FIRST + 119 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO7                  For ( CMD_FIRST + 120 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO8                  For ( CMD_FIRST + 121 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO9                  For ( CMD_FIRST + 122 )
74342>>>>>>>>>>>Define CMD_PLAYMACRO10                 For ( CMD_FIRST + 123 )
74342>>>>>>>>>>>Define CMD_PROPERTIES                  For ( CMD_FIRST + 124 )
74342>>>>>>>>>>>Define CMD_BEGINUNDO                   For ( CMD_FIRST + 125 )
74342>>>>>>>>>>>Define CMD_ENDUNDO                     For ( CMD_FIRST + 126 )
74342>>>>>>>>>>>Define CMD_RESERVED3                   For ( CMD_FIRST + 127 )  // internal use only
74342>>>>>>>>>>>// 2.0
74342>>>>>>>>>>>Define CMD_TOGGLEREGEXP                For ( CMD_FIRST + 128 )
74342>>>>>>>>>>>Define CMD_CLEARSELECTION              For ( CMD_FIRST + 129 )
74342>>>>>>>>>>>Define CMD_REGEXPON                    For ( CMD_FIRST + 130 )
74342>>>>>>>>>>>Define CMD_REGEXPOFF                   For ( CMD_FIRST + 131 )
74342>>>>>>>>>>>Define CMD_WHOLEWORDON                 For ( CMD_FIRST + 132 )
74342>>>>>>>>>>>Define CMD_WHOLEWORDOFF                For ( CMD_FIRST + 133 )
74342>>>>>>>>>>>Define CMD_PRESERVECASEON              For ( CMD_FIRST + 134 )
74342>>>>>>>>>>>Define CMD_PRESERVECASEOFF             For ( CMD_FIRST + 135 )
74342>>>>>>>>>>>Define CMD_CASESENSITIVEON             For ( CMD_FIRST + 136 )
74342>>>>>>>>>>>Define CMD_CASESENSITIVEOFF            For ( CMD_FIRST + 137 )
74342>>>>>>>>>>>Define CMD_WHITESPACEDISPLAYON         For ( CMD_FIRST + 138 )
74342>>>>>>>>>>>Define CMD_WHITESPACEDISPLAYOFF        For ( CMD_FIRST + 139 )
74342>>>>>>>>>>>Define CMD_OVERTYPEON                  For ( CMD_FIRST + 140 )
74342>>>>>>>>>>>Define CMD_OVERTYPEOFF                 For ( CMD_FIRST + 141 )
74342>>>>>>>>>>>// SVN
74342>>>>>>>>>>>//Define CMD_LAST                        For ( CMD_FIRST + 141 )
74342>>>>>>>>>>>// 2.1
74342>>>>>>>>>>>Define CMD_CODELIST                    For ( CMD_FIRST + 142 )
74342>>>>>>>>>>>Define CMD_CODETIP                     For ( CMD_FIRST + 143 )
74342>>>>>>>>>>>Define CMD_LAST                        For ( CMD_FIRST + 143 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>// all register commands must be at or higher than CMD_USER_BASE
74342>>>>>>>>>>>Define CMD_USER_BASE                   For ( CMD_FIRST + 900 )
74342>>>>>>>>>>>
74342>>>>>>>>>>>Define CMDERR_FAILURE     For 1     // general failure
74342>>>>>>>>>>>Define CMDERR_INPUT       For 2     // bad input
74342>>>>>>>>>>>Define CMDERR_SELECTION   For 3     // bad selection
74342>>>>>>>>>>>Define CMDERR_NOTFOUND    For 4     // data not found
74342>>>>>>>>>>>Define CMDERR_EMPTYBUF    For 5     // buffer is empty
74342>>>>>>>>>>>Define CMDERR_READONLY    For 6     // buffer is read-only
74342>>>>>>>>>>>
74342>>>>>>>>>>>////////////////////////////////////////////////////////////////////////////////////////
74342>>>>>>>>>>>//
74342>>>>>>>>>>>// Language Support for CMM_SETLANGUAGE, RegisterLanguage(), and UnregisterLanguage()
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>
74342>>>>>>>>>>>// stock languages
74342>>>>>>>>>>>Define CMLANG_CPP         For "C/C++"
74342>>>>>>>>>>>Define CMLANG_PASCAL      For "Pascal"
74342>>>>>>>>>>>Define CMLANG_BASIC       For "Basic"
74342>>>>>>>>>>>Define CMLANG_SQL         For "SQL"
74342>>>>>>>>>>>Define CMLANG_JAVA        For "Java"
74342>>>>>>>>>>>Define CMLANG_HTML        For "HTML"
74342>>>>>>>>>>>Define CMLANG_XML         For "XML"
74342>>>>>>>>>>>
74342>>>>>>>>>>>//// language styles
74342>>>>>>>>>>>//Define CMLS_PROCEDURAL    FOR 0
74342>>>>>>>>>>>//Define CMLS_SGML          FOR 1
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//TYPE CM_LANGUAGE
74342>>>>>>>>>>>//    Field CM_LANGUAGE.dwStyle                             as Dword    // One of the CMLS_ values DWORD
74342>>>>>>>>>>>//    Field CM_LANGUAGE.bIsCaseSensitive                    as Integer  // TRUE if keywords are case sensitive BOOL
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszKeywords                         as Pointer  // The keywords delimited by '\n' LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszOperators                        as Pointer  // The operators delimited by '\n' LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszSingleLineComments               as Pointer  // The single line comment tokens (e.g. "//") LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszMultiLineComments1               as Pointer  // The multiline comment start tokens (e.g. "/*\n{\n(*") LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszMultiLineComments2               as Pointer  // The multiline comment end tokens (e.g. "*/\n}\n*)") LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszScopeKeywords1                   as Pointer  // The scoping start tokens (e.g. "{\nbegin") LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszScopeKeywords2                   as Pointer  // The multiline comment end tokens (e.g. "}\nend") LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszStringDelims                     as Pointer  // The string literal delimiters (e.g. "\"\n'") -- also includes character literals LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.chEscape                            as Char 1   // The escape character TCHAR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.chTerminator                        as Char 1   // The statement terminator char (usually ';') TCHAR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszTagElementNames                  as Pointer  // Tag-based element names delimited by '\n' LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszTagAttributeNames                as Pointer  // Tag-based attribute names delimited by '\n' LPCTSTR
74342>>>>>>>>>>>//    Field CM_LANGUAGE.pszTagEntities                      as Pointer  // Tag-based entities delimited by '\n' LPCTSTR
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//// Color settings for CMM_GETCOLORS and CMM_SETCOLORS
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Note:  Use CLR_INVALID on background colors to specify transparent
74342>>>>>>>>>>>////        (text) or appropriate control panel setting
74342>>>>>>>>>>>//TYPE CM_COLORS
74342>>>>>>>>>>>//    Field CM_COLORS.crWindow                            as COLORREF // window background color
74342>>>>>>>>>>>//    Field CM_COLORS.crLeftMargin                        as COLORREF // left margin background color
74342>>>>>>>>>>>//    Field CM_COLORS.crBookmark                          as COLORREF // bookmark foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crBookmarkBk                        as COLORREF // bookmark background color
74342>>>>>>>>>>>//    Field CM_COLORS.crText                              as COLORREF // plain text foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crTextBk                            as COLORREF // plain text background color
74342>>>>>>>>>>>//    Field CM_COLORS.crNumber                            as COLORREF // numeric literal foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crNumberBk                          as COLORREF // numeric literal background color
74342>>>>>>>>>>>//    Field CM_COLORS.crKeyword                           as COLORREF // keyword foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crKeywordBk                         as COLORREF // keyword background color
74342>>>>>>>>>>>//    Field CM_COLORS.crOperator                          as COLORREF // operator foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crOperatorBk                        as COLORREF // operator background color
74342>>>>>>>>>>>//    Field CM_COLORS.crScopeKeyword                      as COLORREF // scope keyword foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crScopeKeywordBk                    as COLORREF // scope keyword background color
74342>>>>>>>>>>>//    Field CM_COLORS.crComment                           as COLORREF // comment foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crCommentBk                         as COLORREF // comment background color
74342>>>>>>>>>>>//    Field CM_COLORS.crString                            as COLORREF // string foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crStringBk                          as COLORREF // string background color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagText                           as COLORREF // plain tag text foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagTextBk                         as COLORREF // plain tag text background color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagEntity                         as COLORREF // tag entity foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagEntityBk                       as COLORREF // tag entity background color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagElementName                    as COLORREF // tag element name foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagElementNameBk                  as COLORREF // tag element name background color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagAttributeName                  as COLORREF // tag attribute name foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crTagAttributeNameBk                as COLORREF // tag attribute name background color
74342>>>>>>>>>>>//    Field CM_COLORS.crLineNumber                        as COLORREF // line number foreground color
74342>>>>>>>>>>>//    Field CM_COLORS.crLineNumberBk                      as COLORREF // line number background color
74342>>>>>>>>>>>//    Field CM_COLORS.crHDividerLines                     as COLORREF // line number separate line color
74342>>>>>>>>>>>//    Field CM_COLORS.crVDividerLines                     as COLORREF // left margin separate line color
74342>>>>>>>>>>>//    Field CM_COLORS.crHighlightedLine                   as COLORREF // highlighted line color
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Font style settings for CMM_GETFONTSTYLES and CMM_SETFONTSTYLES
74342>>>>>>>>>>>//// each byte value is one of the CM_FONT_XXX values listed below
74342>>>>>>>>>>>//// this declaration
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//TYPE CM_FONTSTYLES
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byText                              as Char 1   // plain text font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byNumber                            as Char 1   // numeric literal font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byKeyword                           as Char 1   // keyword font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byOperator                          as Char 1   // operator font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byScopeKeyword                      as Char 1   // scope keyword font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byComment                           as Char 1   // comment font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byString                            as Char 1   // string font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byTagText                           as Char 1   // plain tag text font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byTagEntity                         as Char 1   // tag entity font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byTagElementName                    as Char 1   // tag element name font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byTagAttributeName                  as Char 1   // tag attribute name font style BYTE
74342>>>>>>>>>>>//    Field CM_FONTSTYLES.byLineNumber                        as Char 1   // line number font style BYTE
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Font style options used in CM_FONTSTYLES
74342>>>>>>>>>>>////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//Define CM_FONT_NORMAL     For 0   // normal weight
74342>>>>>>>>>>>//Define CM_FONT_BOLD       For 1   // bold weight
74342>>>>>>>>>>>//Define CM_FONT_ITALIC     For 2   // normal weight, italic
74342>>>>>>>>>>>//Define CM_FONT_BOLDITALIC For 3   // bold weight, italic
74342>>>>>>>>>>>//Define CM_FONT_UNDERLINE  For 4   // normal weight, underline
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>// AutoIndent options
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>Define CM_INDENT_OFF        For  0    // auto-indent off -- new line begins at column 0
74342>>>>>>>>>>>Define CM_INDENT_SCOPE      For  1    // NOT SUPPORTED
74342>>>>>>>>>>>Define CM_INDENT_PREVLINE   For  2    // new line has identical indentation of previous line
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Print option flags used with CMM_PRINT
74342>>>>>>>>>>>////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//Define CM_PRINT_PROMPTDLG    For |CI$000   // display the print common dialog
74342>>>>>>>>>>>//Define CM_PRINT_DEFAULTPRN   For |CI$001   // use default printer (no print dialog displayed)
74342>>>>>>>>>>>//Define CM_PRINT_HDC          For |CI$002   // use HDC provided
74342>>>>>>>>>>>//Define CM_PRINT_RICHFONTS    For |CI$004   // use bold, italics, underline, etc. when appropriate
74342>>>>>>>>>>>//Define CM_PRINT_COLOR        For |CI$008   // print in color
74342>>>>>>>>>>>//Define CM_PRINT_PAGENUMS     For |CI$010   // print 'page # of #' at the bottom of the page
74342>>>>>>>>>>>//Define CM_PRINT_DATETIME     For |CI$020   // print date and time at top of the page
74342>>>>>>>>>>>//Define CM_PRINT_BORDERTHIN   For |CI$040   // surround text with a thin border
74342>>>>>>>>>>>//Define CM_PRINT_BORDERTHICK  For |CI$080   // surround text with a thick border
74342>>>>>>>>>>>//Define CM_PRINT_BORDERDOUBLE For |CI$100   // surround text with two thin borders
74342>>>>>>>>>>>//Define CM_PRINT_SELECTION    For |CI$200   // print the selection rather than entire edit contents
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Border option flags used with CMM_GETBORDERSTYLE and CMM_SETBORDERSTYLE.
74342>>>>>>>>>>>//// Note: this values may be or'd together to achieve different effects.
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//Define CM_BORDER_NONE        For |CI$0  // no border
74342>>>>>>>>>>>//Define CM_BORDER_THIN        For |CI$1  // 1-pixel border
74342>>>>>>>>>>>//Define CM_BORDER_CLIENT      For |CI$2  // client edge (WS_EX_CLIENTEDGE)
74342>>>>>>>>>>>//Define CM_BORDER_STATIC      For |CI$4  // static edge (WS_EX_STATICEDGE)
74342>>>>>>>>>>>//Define CM_BORDER_MODAL       For |CI$8  // modal edge (WS_EX_DLGMODALFRAME)
74342>>>>>>>>>>>//Define CM_BORDER_CORRAL      For (CM_BORDER_MODAL Ior CM_BORDER_CLIENT)
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Text position indicators
74342>>>>>>>>>>>////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//Type CM_POSITION
74342>>>>>>>>>>>//  Field CM_POSITION.nLine                as Integer  // zero-based line number int
74342>>>>>>>>>>>//  Field CM_POSITION.nCol                 as Integer  // zero-based *buffer* column number int
74342>>>>>>>>>>>//End_Type
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//// Erzeugt einen String und eine Pointer variable, wenn diese noch nicht definiert sind!
74342>>>>>>>>>>>//// Fueltt mit Line und Col und holt die Addresse in the Pointer
74342>>>>>>>>>>>//#COMMAND Local_CM_POSITION R R "LINE=" R "COL=" R
74342>>>>>>>>>>>//    DEFINE_STR_PTR !1 !2
74342>>>>>>>>>>>//    ZeroType CM_POSITION  To !1         // as a little insurance
74342>>>>>>>>>>>//    Put !4 To !1 At CM_POSITION.nLine   // Set Line
74342>>>>>>>>>>>//    Put !6 To !1 At CM_POSITION.nCol    // Set Column
74342>>>>>>>>>>>//    GetAddress Of !1 To !2
74342>>>>>>>>>>>//#ENDCOMMAND
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//    // Erzeugt einen String und eine Pointer variable, wenn diese noch nicht definiert sind!
74342>>>>>>>>>>>//    // Fueltt mit Line und Col und holt die Addresse in the Pointer
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//TYPE CM_RANGE
74342>>>>>>>>>>>//    Field CM_RANGE.posStart             as Char CM_POSITION_SIZE    // the anchor CM_POSITION
74342>>>>>>>>>>>//    Field CM_RANGE.posEnd               as Char CM_POSITION_SIZE    // the extension (if same as anchor, selection is empty) CM_POSITION
74342>>>>>>>>>>>//    Field CM_RANGE.bColumnSel           as Integer                  // TRUE if is a column selection, FALSE if paragragh selection BOOL
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//#COMMAND Local_CM_RANGE R R "START=" R  R "END=" R R
74342>>>>>>>>>>>//    DEFINE_STR_PTR !1 !2
74342>>>>>>>>>>>//    Zerotype CM_RANGE   to !1
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//    Local_CM_POSITION sPosStart psPosStart LINE= !4 COL= !5   // Create a String with the StartPosition
74342>>>>>>>>>>>//    Local_CM_POSITION sPosEnd   psPosEnd   LINE= !7 COL= !8   // Create a String with the EndPosition
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//    PUT_STRING sPosStart to !1 AT CM_RANGE.posStart           // Set Start Position
74342>>>>>>>>>>>//    PUT_STRING sPosEnd   to !1 AT CM_RANGE.posEnd             // Set End Position
74342>>>>>>>>>>>//
74342>>>>>>>>>>>//    GetAddress Of !1     to !2                                // Get the Address of the created Structure
74342>>>>>>>>>>>//#ENDCOMMAND
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// Hot key descriptor
74342>>>>>>>>>>>////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//TYPE CM_HOTKEY
74342>>>>>>>>>>>//    Field CM_HOTKEY.byModifiers1         as Integer //Char 1   // 1st keystroke's modifiers (combination of HOTKEYF_ALT, HOTKEYF_SHIFT, HOTKEYF_CONTROL) BYTE
74342>>>>>>>>>>>//    Field CM_HOTKEY.nVirtKey1            as Integer  // 1st keystroke's virtkey (e.g. Ctrl + 'A') UINT
74342>>>>>>>>>>>//    Field CM_HOTKEY.byModifiers2         as Integer //Char 1   // 2nd keystroke's modifiers (combination of HOTKEYF_ALT, HOTKEYF_SHIFT, HOTKEYF_CONTROL) BYTE
74342>>>>>>>>>>>//    Field CM_HOTKEY.nVirtKey2            as Integer  // 2nd keystroke's virtkey (e.g. Ctrl + 'A') UINT
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>
74342>>>>>>>>>>>//
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// CMN_CMDFAILURE notification data passed to parent window
74342>>>>>>>>>>>////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//TYPE CM_CMDFAILUREDATA
74342>>>>>>>>>>>//    Field CM_CMDFAILUREDATA.hdr                  as Char NMHDR_SIZE // standard notification data NMHDR
74342>>>>>>>>>>>//    Field CM_CMDFAILUREDATA.wCmd                 as WORD            // CMD_XXX command that failed WORD
74342>>>>>>>>>>>//    Field CM_CMDFAILUREDATA.dwErr                as Dword           // CMDERR_XXX failure code DWORD
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>
74342>>>>>>>>>>>
74342>>>>>>>>>>>///////////////////////////////////////////////////////////////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>//// CMN_KEYDOWN, CMN_KEYUP, CMN_KEYPRESS notification
74342>>>>>>>>>>>//// data passed to parent window
74342>>>>>>>>>>>////
74342>>>>>>>>>>>////
74342>>>>>>>>>>>Define CM_KEY_NOEXT      For |CI$0
74342>>>>>>>>>>>Define CM_KEY_SHIFT      For |CI$1
74342>>>>>>>>>>>Define CM_KEY_CTRL       For |CI$2
74342>>>>>>>>>>>Define CM_KEY_ALT        For |CI$4
74342>>>>>>>>>>>//TYPE CM_KEYDATA
74342>>>>>>>>>>>//    Field CM_KEYDATA.hdr                  as Char NMHDR_SIZE    // standard notification data NMHDR
74342>>>>>>>>>>>//    Field CM_KEYDATA.nKeyCode             as Integer            // virtkey if CMN_KEYUP or CMN_KEYDOWN.  Ascii code if CMN_KEYPRESS int
74342>>>>>>>>>>>//    Field CM_KEYDATA.nKeyModifier         as Integer            // bitfield of: CM_KEY_SHIFT, CM_KEY_CTRL, and/or CM_KEY_ALT int
74342>>>>>>>>>>>//END_TYPE
74342>>>>>>>>>>>
74342>>>>>>>>>>>// Just converts the ID to the name.
74342>>>>>>>>>>>Function CMKeymodifierIDToName Global Integer iModifier Returns String
74344>>>>>>>>>>>  String sRet
74344>>>>>>>>>>>  If (iModifier Iand CM_KEY_SHIFT) ;    Append sRet (If(sRet Eq "","","+")) "Shift"
74348>>>>>>>>>>>  If (iModifier Iand CM_KEY_CTRL) ;    Append sRet (If(sRet Eq "","","+")) "Ctrl"
74352>>>>>>>>>>>  If (iModifier Iand CM_KEY_ALT) ;    Append sRet (If(sRet Eq "","","+")) "Alt"
74356>>>>>>>>>>>  Function_Return sRet
74357>>>>>>>>>>>End_Function
74358>>>>>>>>>>>
74358>>>>>>>>>>>///////////////////////////////////////////////////////////////
74358>>>>>>>>>>>////
74358>>>>>>>>>>>//// CMN_MOUSEDOWN, CMN_MOUSEUP, CMN_MOUSEPRESS notification
74358>>>>>>>>>>>//// data passed to parent window
74358>>>>>>>>>>>////
74358>>>>>>>>>>>////
74358>>>>>>>>>>>//Define CM_BTN_LEFT      For |CI$1
74358>>>>>>>>>>>//Define CM_BTN_RIGHT     For |CI$2
74358>>>>>>>>>>>//Define CM_BTN_MIDDLE    For |CI$4
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//TYPE CM_MOUSEDATA
74358>>>>>>>>>>>//    Field CM_MOUSEDATA.hdr                  as Char NMHDR_SIZE  // standard notification data NMHDR
74358>>>>>>>>>>>//    Field CM_MOUSEDATA.pt                   as Char tPOINT_SIZE // position of mouse (client coordinates) POINT
74358>>>>>>>>>>>//    Field CM_MOUSEDATA.nButton              as Integer  // bitfield of: CM_BTN_LEFT, CM_BTN_RIGHT, and/or CM_BTN_MIDDLE int
74358>>>>>>>>>>>//    Field CM_MOUSEDATA.nKeyModifier         as Integer  // bitfield of: CM_KEY_SHIFT, CM_KEY_CTRL, and/or CM_KEY_ALT int
74358>>>>>>>>>>>//END_TYPE
74358>>>>>>>>>>>//
74358>>>>>>>>>>>///////////////////////////////////////////////////////////////
74358>>>>>>>>>>>////
74358>>>>>>>>>>>//// CMN_FINDWRAPPED notification data passed to parent window
74358>>>>>>>>>>>////
74358>>>>>>>>>>>////
74358>>>>>>>>>>>//TYPE CM_FINDWRAPPEDDATA
74358>>>>>>>>>>>//    Field CM_FINDWRAPPEDDATA.hdr                  as Char NMHDR_SIZE // standard notification data NMHDR
74358>>>>>>>>>>>//    Field CM_FINDWRAPPEDDATA.wCmd                 as WORD     // the command being executed WORD
74358>>>>>>>>>>>//    Field CM_FINDWRAPPEDDATA.bForward             as Integer  // TRUE if wrapped while searching forward, FALSE if searching backward BOOL
74358>>>>>>>>>>>//END_TYPE
74358>>>>>>>>>>>
74358>>>>>>>>>>>///////////////////////////////////////////////////////////////
74358>>>>>>>>>>>////
74358>>>>>>>>>>>//// Tooltip window styles specified as return value from
74358>>>>>>>>>>>//// CMN_CODETIP notifications
74358>>>>>>>>>>>////
74358>>>>>>>>>>>//Define CM_TIPSTYLE_NONE                                   For 0       // don't display a tooltip
74358>>>>>>>>>>>//Define CM_TIPSTYLE_NORMAL                               For 1 // standard tooltip window
74358>>>>>>>>>>>//Define CM_TIPSTYLE_HIGHLIGHT                  for 2   // tooltip with text highlighting
74358>>>>>>>>>>>//Define CM_TIPSTYLE_FUNCHIGHLIGHT      for 3   // tooltip with function highlighting
74358>>>>>>>>>>>//Define CM_TIPSTYLE_MULTIFUNC                  for 4   // highlighting for multiple functions
74358>>>>>>>>>>>
74358>>>>>>>>>>>Define C_TIPTYPE_UNDEFINED        For 0
74358>>>>>>>>>>>Define C_TIPTYPE_EXPRESSION       For 1
74358>>>>>>>>>>>Define C_TIPTYPE_FUNCTION         For 2
74358>>>>>>>>>>>Define C_TIPTYPE_PROCEDURE        For 3
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//// -----------------------------------------------------------------------------------------
74358>>>>>>>>>>>//// END - SVN
74358>>>>>>>>>>>//
74358>>>>>>>>>>>
74358>>>>>>>>>>>/////////////////////////////////////////////////////////////
74358>>>>>>>>>>>//
74358>>>>>>>>>>>// data passed to CMM_SETLINENUMBERING
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//
74358>>>>>>>>>>>Define CM_BINARY            For 2  // not supported
74358>>>>>>>>>>>Define CM_OCTAL             For 8  // not supported
74358>>>>>>>>>>>Define CM_DECIMAL           For 10
74358>>>>>>>>>>>Define CM_HEXADECIMAL       For 16 // not supported
74358>>>>>>>>>>>
74358>>>>>>>>>>>
74358>>>>>>>>>>>/////////////////////////////////////////////////////////////
74358>>>>>>>>>>>//
74358>>>>>>>>>>>// Error codes
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//typedef LRESULT CME_CODE;
74358>>>>>>>>>>>
74358>>>>>>>>>>>Define CME_SUCCESS        For 1        // function or method completed successfully
74358>>>>>>>>>>>Define CME_FAILURE        For 0        // function or method did not complete because of an error
74358>>>>>>>>>>>Define CME_BADARGUMENT    For -1       // function or method did not complete because an invalid argument was passed in
74358>>>>>>>>>>>
74358>>>>>>>>>>>/////////////////////////////////////////////////////////////
74358>>>>>>>>>>>//
74358>>>>>>>>>>>// CMM_HITTEST return codes
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//
74358>>>>>>>>>>>
74358>>>>>>>>>>>Define CM_NOWHERE        For 0        // Not over the CodeMax control
74358>>>>>>>>>>>Define CM_HSPLITTER      For 1        // Over the horizontal splitter bar
74358>>>>>>>>>>>Define CM_VSPLITTER      For 2        // Over the vertical splitter bar
74358>>>>>>>>>>>Define CM_HVSPLITTER     For 3        // Over the intersection of the horizontal and vertical splitter bar
74358>>>>>>>>>>>Define CM_EDITSPACE      For 4        // Over the buffer contents (code)
74358>>>>>>>>>>>Define CM_HSCROLLBAR     For 5        // Over the horizontal scrollbar
74358>>>>>>>>>>>Define CM_VSCROLLBAR     For 6        // Over the vertical scrollbar
74358>>>>>>>>>>>Define CM_SIZEBOX        For 7        // Over the sizebox visible when both scrollbars are visible
74358>>>>>>>>>>>Define CM_LEFTMARGIN     For 8        // Over the left margin area
74358>>>>>>>>>>>
74358>>>>>>>>>>>
74358>>>>>>>>>>>/////////////////////////////////////////////////////////////
74358>>>>>>>>>>>//
74358>>>>>>>>>>>// CMM_GETCURRENTTOKEN return codes
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//
74358>>>>>>>>>>>
74358>>>>>>>>>>>Define CM_TOKENTYPE_KEYWORD                                     For |CI$1 // 0x01
74358>>>>>>>>>>>Define CM_TOKENTYPE_OPERATOR                            For |CI$2 //0x02
74358>>>>>>>>>>>Define CM_TOKENTYPE_STRING                                      For |CI$3 //0x03
74358>>>>>>>>>>>Define CM_TOKENTYPE_SINGLELINECOMMENT           For |CI$4 //0x04
74358>>>>>>>>>>>Define CM_TOKENTYPE_MULTILINECOMMENT            For |CI$5 //0x05
74358>>>>>>>>>>>Define CM_TOKENTYPE_NUMBER                                      For |CI$6 //0x06
74358>>>>>>>>>>>Define CM_TOKENTYPE_SCOPEBEGIN                          For |CI$7 //0x07
74358>>>>>>>>>>>Define CM_TOKENTYPE_SCOPEEND                            For |CI$8 //0x08
74358>>>>>>>>>>>Define CM_TOKENTYPE_TEXT                                        For |CI$FF //0xff
74358>>>>>>>>>>>Define CM_TOKENTYPE_LAST                    For |CI$FFFFFFFF
74358>>>>>>>>>>>Define CM_TOKENTYPE_UNKNOWN                                     For (CM_TOKENTYPE_LAST-1) //(DWORD)-1
74358>>>>>>>>>>>
74358>>>>>>>>>>>
74358>>>>>>>>>>>/////////////////////////////////////////////////////////////
74358>>>>>>>>>>>//
74358>>>>>>>>>>>// Exported functions
74358>>>>>>>>>>>//
74358>>>>>>>>>>>//
74358>>>>>>>>>>>
74358>>>>>>>>>>>Define SCLEX_NULL                       For 1
74358>>>>>>>>>>>Define SCLEX_PYTHON                     For 2
74358>>>>>>>>>>>Define SCLEX_CPP                        For 3
74358>>>>>>>>>>>Define SCLEX_HTML                       For 4
74358>>>>>>>>>>>Define SCLEX_XML                        For 5
74358>>>>>>>>>>>Define SCLEX_PERL                       For 6
74358>>>>>>>>>>>Define SCLEX_SQL                        For 7
74358>>>>>>>>>>>Define SCLEX_VB                         For 8
74358>>>>>>>>>>>Define SCLEX_PROPERTIES                 For 9
74358>>>>>>>>>>>Define SCLEX_PASCAL                     For 18
74358>>>>>>>>>>>Define SCLEX_PHPSCRIPT                  For 69
74358>>>>>>>>>>>Define SCLEX_DATAFLEX                   For 129
74358>>>>>>>>>>>
74358>>>>>>>>>>>Define SCE_NOTUSED                      For -1
74358>>>>>>>>>>>
74358>>>>>>>>>>>// Text
74358>>>>>>>>>>>Define SCE_TEXT_DEFAULT                 For 0
74358>>>>>>>>>>>
74358>>>>>>>>>>>// DataFlex
74358>>>>>>>>>>>Define SCE_DF_DEFAULT                   For 0
74358>>>>>>>>>>>Define SCE_DF_IDENTIFIER                For 1
74358>>>>>>>>>>>Define SCE_DF_METATAG                   For 2
74358>>>>>>>>>>>Define SCE_DF_IMAGE                     For 3
74358>>>>>>>>>>>Define SCE_DF_COMMENTLINE               For 4
74358>>>>>>>>>>>Define SCE_DF_PREPROCESSOR              For 5
74358>>>>>>>>>>>Define SCE_DF_PREPROCESSOR2             For 6
74358>>>>>>>>>>>Define SCE_DF_NUMBER                    For 7
74358>>>>>>>>>>>Define SCE_DF_HEXNUMBER                 For 8
74358>>>>>>>>>>>Define SCE_DF_WORD                      For 9
74358>>>>>>>>>>>Define SCE_DF_STRING                    For 10
74358>>>>>>>>>>>Define SCE_DF_STRINGEOL                 For 11
74358>>>>>>>>>>>Define SCE_DF_SCOPEWORD                 For 12
74358>>>>>>>>>>>Define SCE_DF_OPERATOR                  For 13
74358>>>>>>>>>>>Define SCE_DF_ICODE                     For 14
74358>>>>>>>>>>>
74358>>>>>>>>>>>// C/C++
74358>>>>>>>>>>>Define SCE_C_DEFAULT                    For 0
74358>>>>>>>>>>>Define SCE_C_COMMENT                    For 1
74358>>>>>>>>>>>Define SCE_C_COMMENTLINE                For 2
74358>>>>>>>>>>>Define SCE_C_COMMENTDOC                 For 3
74358>>>>>>>>>>>Define SCE_C_NUMBER                     For 4
74358>>>>>>>>>>>Define SCE_C_WORD                       For 5
74358>>>>>>>>>>>Define SCE_C_STRING                     For 6
74358>>>>>>>>>>>Define SCE_C_CHARACTER                  For 7
74358>>>>>>>>>>>Define SCE_C_UUID                       For 8
74358>>>>>>>>>>>Define SCE_C_PREPROCESSOR               For 9
74358>>>>>>>>>>>Define SCE_C_OPERATOR                   For 10
74358>>>>>>>>>>>Define SCE_C_IDENTIFIER                 For 11
74358>>>>>>>>>>>Define SCE_C_STRINGEOL                  For 12
74358>>>>>>>>>>>Define SCE_C_VERBATIM                   For 13
74358>>>>>>>>>>>Define SCE_C_REGEX                      For 14
74358>>>>>>>>>>>Define SCE_C_COMMENTLINEDOC             For 15
74358>>>>>>>>>>>Define SCE_C_WORD2                      For 16
74358>>>>>>>>>>>Define SCE_C_COMMENTDOCKEYWORD          For 17
74358>>>>>>>>>>>Define SCE_C_COMMENTDOCKEYWORDERROR     For 18
74358>>>>>>>>>>>Define SCE_C_GLOBALCLASS                For 19
74358>>>>>>>>>>>Define SCE_C_STRINGRAW                  For 20
74358>>>>>>>>>>>Define SCE_C_TRIPLEVERBATIM             For 21
74358>>>>>>>>>>>Define SCE_C_HASHQUOTEDSTRING           For 22
74358>>>>>>>>>>>Define SCE_C_PREPROCESSORCOMMENT        For 23
74358>>>>>>>>>>>Define SCE_C_PREPROCESSORCOMMENTDOC     For 24
74358>>>>>>>>>>>Define SCE_C_USERLITERAL                For 25
74358>>>>>>>>>>>Define SCE_C_TASKMARKER                 For 26
74358>>>>>>>>>>>Define SCE_C_ESCAPESEQUENCE             For 27
74358>>>>>>>>>>>
74358>>>>>>>>>>>// Pascal
74358>>>>>>>>>>>Define SCE_PAS_DEFAULT                  For 0
74358>>>>>>>>>>>Define SCE_PAS_IDENTIFIER               For 1
74358>>>>>>>>>>>Define SCE_PAS_COMMENT                  For 2
74358>>>>>>>>>>>Define SCE_PAS_COMMENT2                 For 3
74358>>>>>>>>>>>Define SCE_PAS_COMMENTLINE              For 4
74358>>>>>>>>>>>Define SCE_PAS_PREPROCESSOR             For 5
74358>>>>>>>>>>>Define SCE_PAS_PREPROCESSOR2            For 6
74358>>>>>>>>>>>Define SCE_PAS_NUMBER                   For 7
74358>>>>>>>>>>>Define SCE_PAS_HEXNUMBER                For 8
74358>>>>>>>>>>>Define SCE_PAS_WORD                     For 9
74358>>>>>>>>>>>Define SCE_PAS_STRING                   For 10
74358>>>>>>>>>>>Define SCE_PAS_STRINGEOL                For 11
74358>>>>>>>>>>>Define SCE_PAS_CHARACTER                For 12
74358>>>>>>>>>>>Define SCE_PAS_OPERATOR                 For 13
74358>>>>>>>>>>>Define SCE_PAS_ASM                      For 14
74358>>>>>>>>>>>
74358>>>>>>>>>>>// Html/XML/PHP
74358>>>>>>>>>>>Define SCE_H_DEFAULT                    For 0
74358>>>>>>>>>>>Define SCE_H_TAG                        For 1
74358>>>>>>>>>>>Define SCE_H_TAGUNKNOWN                 For 2
74358>>>>>>>>>>>Define SCE_H_ATTRIBUTE                  For 3
74358>>>>>>>>>>>Define SCE_H_ATTRIBUTEUNKNOWN           For 4
74358>>>>>>>>>>>Define SCE_H_NUMBER                     For 5
74358>>>>>>>>>>>Define SCE_H_DOUBLESTRING               For 6
74358>>>>>>>>>>>Define SCE_H_SINGLESTRING               For 7
74358>>>>>>>>>>>Define SCE_H_OTHER                      For 8
74358>>>>>>>>>>>Define SCE_H_COMMENT                    For 9
74358>>>>>>>>>>>Define SCE_H_ENTITY                     For 10
74358>>>>>>>>>>>Define SCE_H_TAGEND                     For 11
74358>>>>>>>>>>>Define SCE_H_XMLSTART                   For 12
74358>>>>>>>>>>>Define SCE_H_XMLEND                     For 13
74358>>>>>>>>>>>Define SCE_H_SCRIPT                     For 14
74358>>>>>>>>>>>Define SCE_H_ASP                        For 15
74358>>>>>>>>>>>Define SCE_H_ASPAT                      For 16
74358>>>>>>>>>>>Define SCE_H_CDATA                      For 17
74358>>>>>>>>>>>Define SCE_H_QUESTION                   For 18
74358>>>>>>>>>>>Define SCE_H_VALUE                      For 19
74358>>>>>>>>>>>Define SCE_H_XCCOMMENT                  For 20
74358>>>>>>>>>>>Define SCE_H_SGML_DEFAULT               For 21
74358>>>>>>>>>>>Define SCE_H_SGML_COMMAND               For 22
74358>>>>>>>>>>>Define SCE_H_SGML_1ST_PARAM             For 23
74358>>>>>>>>>>>Define SCE_H_SGML_DOUBLESTRING          For 24
74358>>>>>>>>>>>Define SCE_H_SGML_SIMPLESTRING          For 25
74358>>>>>>>>>>>Define SCE_H_SGML_ERROR                 For 26
74358>>>>>>>>>>>Define SCE_H_SGML_SPECIAL               For 27
74358>>>>>>>>>>>Define SCE_H_SGML_ENTITY                For 28
74358>>>>>>>>>>>Define SCE_H_SGML_COMMENT               For 29
74358>>>>>>>>>>>Define SCE_H_SGML_1ST_PARAM_COMMENT     For 30
74358>>>>>>>>>>>Define SCE_H_SGML_BLOCK_DEFAULT         For 31
74358>>>>>>>>>>>Define SCE_HJ_START                     For 40
74358>>>>>>>>>>>Define SCE_HJ_DEFAULT                   For 41
74358>>>>>>>>>>>Define SCE_HJ_COMMENT                   For 42
74358>>>>>>>>>>>Define SCE_HJ_COMMENTLINE               For 43
74358>>>>>>>>>>>Define SCE_HJ_COMMENTDOC                For 44
74358>>>>>>>>>>>Define SCE_HJ_NUMBER                    For 45
74358>>>>>>>>>>>Define SCE_HJ_WORD                      For 46
74358>>>>>>>>>>>Define SCE_HJ_KEYWORD                   For 47
74358>>>>>>>>>>>Define SCE_HJ_DOUBLESTRING              For 48
74358>>>>>>>>>>>Define SCE_HJ_SINGLESTRING              For 49
74358>>>>>>>>>>>Define SCE_HJ_SYMBOLS                   For 50
74358>>>>>>>>>>>Define SCE_HJ_STRINGEOL                 For 51
74358>>>>>>>>>>>Define SCE_HJ_REGEX                     For 52
74358>>>>>>>>>>>Define SCE_HJA_START                    For 55
74358>>>>>>>>>>>Define SCE_HJA_DEFAULT                  For 56
74358>>>>>>>>>>>Define SCE_HJA_COMMENT                  For 57
74358>>>>>>>>>>>Define SCE_HJA_COMMENTLINE              For 58
74358>>>>>>>>>>>Define SCE_HJA_COMMENTDOC               For 59
74358>>>>>>>>>>>Define SCE_HJA_NUMBER                   For 60
74358>>>>>>>>>>>Define SCE_HJA_WORD                     For 61
74358>>>>>>>>>>>Define SCE_HJA_KEYWORD                  For 62
74358>>>>>>>>>>>Define SCE_HJA_DOUBLESTRING             For 63
74358>>>>>>>>>>>Define SCE_HJA_SINGLESTRING             For 64
74358>>>>>>>>>>>Define SCE_HJA_SYMBOLS                  For 65
74358>>>>>>>>>>>Define SCE_HJA_STRINGEOL                For 66
74358>>>>>>>>>>>Define SCE_HJA_REGEX                    For 67
74358>>>>>>>>>>>Define SCE_HB_START                     For 70
74358>>>>>>>>>>>Define SCE_HB_DEFAULT                   For 71
74358>>>>>>>>>>>Define SCE_HB_COMMENTLINE               For 72
74358>>>>>>>>>>>Define SCE_HB_NUMBER                    For 73
74358>>>>>>>>>>>Define SCE_HB_WORD                      For 74
74358>>>>>>>>>>>Define SCE_HB_STRING                    For 75
74358>>>>>>>>>>>Define SCE_HB_IDENTIFIER                For 76
74358>>>>>>>>>>>Define SCE_HB_STRINGEOL                 For 77
74358>>>>>>>>>>>Define SCE_HBA_START                    For 80
74358>>>>>>>>>>>Define SCE_HBA_DEFAULT                  For 81
74358>>>>>>>>>>>Define SCE_HBA_COMMENTLINE              For 82
74358>>>>>>>>>>>Define SCE_HBA_NUMBER                   For 83
74358>>>>>>>>>>>Define SCE_HBA_WORD                     For 84
74358>>>>>>>>>>>Define SCE_HBA_STRING                   For 85
74358>>>>>>>>>>>Define SCE_HBA_IDENTIFIER               For 86
74358>>>>>>>>>>>Define SCE_HBA_STRINGEOL                For 87
74358>>>>>>>>>>>Define SCE_HP_START                     For 90
74358>>>>>>>>>>>Define SCE_HP_DEFAULT                   For 91
74358>>>>>>>>>>>Define SCE_HP_COMMENTLINE               For 92
74358>>>>>>>>>>>Define SCE_HP_NUMBER                    For 93
74358>>>>>>>>>>>Define SCE_HP_STRING                    For 94
74358>>>>>>>>>>>Define SCE_HP_CHARACTER                 For 95
74358>>>>>>>>>>>Define SCE_HP_WORD                      For 96
74358>>>>>>>>>>>Define SCE_HP_TRIPLE                    For 97
74358>>>>>>>>>>>Define SCE_HP_TRIPLEDOUBLE              For 98
74358>>>>>>>>>>>Define SCE_HP_CLASSNAME                 For 99
74358>>>>>>>>>>>Define SCE_HP_DEFNAME                   For 100
74358>>>>>>>>>>>Define SCE_HP_OPERATOR                  For 101
74358>>>>>>>>>>>Define SCE_HP_IDENTIFIER                For 102
74358>>>>>>>>>>>Define SCE_HPHP_COMPLEX_VARIABLE        For 104
74358>>>>>>>>>>>Define SCE_HPA_START                    For 105
74358>>>>>>>>>>>Define SCE_HPA_DEFAULT                  For 106
74358>>>>>>>>>>>Define SCE_HPA_COMMENTLINE              For 107
74358>>>>>>>>>>>Define SCE_HPA_NUMBER                   For 108
74358>>>>>>>>>>>Define SCE_HPA_STRING                   For 109
74358>>>>>>>>>>>Define SCE_HPA_CHARACTER                For 110
74358>>>>>>>>>>>Define SCE_HPA_WORD                     For 111
74358>>>>>>>>>>>Define SCE_HPA_TRIPLE                   For 112
74358>>>>>>>>>>>Define SCE_HPA_TRIPLEDOUBLE             For 113
74358>>>>>>>>>>>Define SCE_HPA_CLASSNAME                For 114
74358>>>>>>>>>>>Define SCE_HPA_DEFNAME                  For 115
74358>>>>>>>>>>>Define SCE_HPA_OPERATOR                 For 116
74358>>>>>>>>>>>Define SCE_HPA_IDENTIFIER               For 117
74358>>>>>>>>>>>Define SCE_HPHP_DEFAULT                 For 118
74358>>>>>>>>>>>Define SCE_HPHP_HSTRING                 For 119
74358>>>>>>>>>>>Define SCE_HPHP_SIMPLESTRING            For 120
74358>>>>>>>>>>>Define SCE_HPHP_WORD                    For 121
74358>>>>>>>>>>>Define SCE_HPHP_NUMBER                  For 122
74358>>>>>>>>>>>Define SCE_HPHP_VARIABLE                For 123
74358>>>>>>>>>>>Define SCE_HPHP_COMMENT                 For 124
74358>>>>>>>>>>>Define SCE_HPHP_COMMENTLINE             For 125
74358>>>>>>>>>>>Define SCE_HPHP_HSTRING_VARIABLE        For 126
74358>>>>>>>>>>>Define SCE_HPHP_OPERATOR                For 127
74358>>>>>>>>>>>
74358>>>>>>>>>>>// SQL
74358>>>>>>>>>>>Define SCE_SQL_DEFAULT                  For 0
74358>>>>>>>>>>>Define SCE_SQL_COMMENT                  For 1
74358>>>>>>>>>>>Define SCE_SQL_COMMENTLINE              For 2
74358>>>>>>>>>>>Define SCE_SQL_COMMENTDOC               For 3
74358>>>>>>>>>>>Define SCE_SQL_NUMBER                   For 4
74358>>>>>>>>>>>Define SCE_SQL_WORD                     For 5
74358>>>>>>>>>>>Define SCE_SQL_STRING                   For 6
74358>>>>>>>>>>>Define SCE_SQL_CHARACTER                For 7
74358>>>>>>>>>>>Define SCE_SQL_SQLPLUS                  For 8
74358>>>>>>>>>>>Define SCE_SQL_SQLPLUS_PROMPT           For 9
74358>>>>>>>>>>>Define SCE_SQL_OPERATOR                 For 10
74358>>>>>>>>>>>Define SCE_SQL_IDENTIFIER               For 11
74358>>>>>>>>>>>Define SCE_SQL_SQLPLUS_COMMENT          For 13
74358>>>>>>>>>>>Define SCE_SQL_COMMENTLINEDOC           For 15
74358>>>>>>>>>>>Define SCE_SQL_WORD2                    For 16
74358>>>>>>>>>>>Define SCE_SQL_COMMENTDOCKEYWORD        For 17
74358>>>>>>>>>>>Define SCE_SQL_COMMENTDOCKEYWORDERROR   For 18
74358>>>>>>>>>>>Define SCE_SQL_USER1                    For 19
74358>>>>>>>>>>>Define SCE_SQL_USER2                    For 20
74358>>>>>>>>>>>Define SCE_SQL_USER3                    For 21
74358>>>>>>>>>>>Define SCE_SQL_USER4                    For 22
74358>>>>>>>>>>>Define SCE_SQL_QUOTEDIDENTIFIER         For 23
74358>>>>>>>>>>>Define SCE_SQL_QOPERATOR                For 24
74358>>>>>>>>>>>
74358>>>>>>>>>>>// Properties
74358>>>>>>>>>>>Define SCE_PROPS_DEFAULT                For 0
74358>>>>>>>>>>>Define SCE_PROPS_COMMENT                For 1
74358>>>>>>>>>>>Define SCE_PROPS_SECTION                For 2
74358>>>>>>>>>>>Define SCE_PROPS_ASSIGNMENT             For 3
74358>>>>>>>>>>>Define SCE_PROPS_DEFVAL                 For 4
74358>>>>>>>>>>>Define SCE_PROPS_KEY                    For 5
74358>>>>>>>>>>>
74358>>>>>>>>>>>
74358>>>>>>>>>>>//Define MARGIN_SCRIPT_FOLD_INDEX For 1 // don't use this strange code word for "code folder margin" use below constants
74358>>>>>>>>>>>Define MARGIN_STATUS       For 0  // bookmarks, breakpoints, debug line pointer
74358>>>>>>>>>>>Define MARGIN_CHANGED_LINE For 1
74358>>>>>>>>>>>Define MARGIN_LINE_NUMBERS For 2
74358>>>>>>>>>>>Define MARGIN_CODE_FOLDING For 3
74358>>>>>>>>>>>
74358>>>>>>>>>>>
74358>>>>>>>>>>>Procedure DevTest String sMethod
74361>>>>>>>>>>>  //Send Info_box sMethod "DevTest"
74361>>>>>>>>>>>End_Procedure
74362>>>>>>>>>>>
74362>>>>>>>>>>>Function CMSetFindReplaceMRUList Global Pointer pszMRUList Integer bFind Returns Integer
74364>>>>>>>>>>>  Send DevTest "CMSetFindReplaceMRUList"
74365>>>>>>>>>>>  Function_Return 0
74366>>>>>>>>>>>End_Function
74367>>>>>>>>>>>Function CMGetFindReplaceMRUList Global Pointer pszMRUList Integer bFind Returns Integer
74369>>>>>>>>>>>  Send DevTest "CMGetFindReplaceMRUList"
74370>>>>>>>>>>>  Function_Return 0
74371>>>>>>>>>>>End_Function
74372>>>>>>>>>>>Function CMRegisterLanguage Global Pointer pszName Pointer pLang Returns Integer
74374>>>>>>>>>>>  Send DevTest "CMRegisterLanguage"
74375>>>>>>>>>>>  Function_Return 0
74376>>>>>>>>>>>End_Function
74377>>>>>>>>>>>Function CMUnregisterLanguage Global Pointer pszName Returns Integer
74379>>>>>>>>>>>  Send DevTest "CMUnregisterLanguage"
74380>>>>>>>>>>>  Function_Return 0
74381>>>>>>>>>>>End_Function
74382>>>>>>>>>>>Function CMGetMacro Global Integer nMacro Pointer pMacroBuff   Returns Integer
74384>>>>>>>>>>>  Send DevTest "CMGetMacro"
74385>>>>>>>>>>>  Function_Return 0
74386>>>>>>>>>>>End_Function
74387>>>>>>>>>>>Function CMSetMacro Global Integer nMacro Pointer pMacroBuff  Returns Integer
74389>>>>>>>>>>>  Send DevTest "CMSetMacro"
74390>>>>>>>>>>>  Function_Return 0
74391>>>>>>>>>>>End_Function
74392>>>>>>>>>>>
74392>>>>>>>>>>>// 2.0
74392>>>>>>>>>>>Function CMUnregisterAllLanguages Global  Returns Integer
74394>>>>>>>>>>>  Send DevTest "CMUnregisterAllLanguages"
74395>>>>>>>>>>>  Function_Return 0
74396>>>>>>>>>>>End_Function
74397>>>>>>>>>>>Function CMGetLanguageDef Global Pointer pszName Pointer pLang   Returns Integer
74399>>>>>>>>>>>  Send DevTest "CMGetLanguageDef"
74400>>>>>>>>>>>  Function_Return 0
74401>>>>>>>>>>>End_Function
74402>>>>>>>>>>>
74402>>>>>>>>>>>
74402>>>>>>>>>>>// Possible values for piFindWrapMode
74402>>>>>>>>>>>Define FindWrapMode_NoWrap      For 1
74402>>>>>>>>>>>Define FindWrapMode_NoWrapMsg   For 2
74402>>>>>>>>>>>Define FindWrapMode_WrapSilent  For 3
74402>>>>>>>>>>>Define FindWrapMode_WrapAsk     For 4
74402>>>>>>>>>>>
74402>>>>>>>>>>>
74402>>>>>>>>>Use mWinAPIGetKeyNameText.pkg   // Get a name for a virual keycode.
Including file: mWinAPIGetKeyNameText.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\mWinAPIGetKeyNameText.pkg)
74402>>>>>>>>>>>//TH-Header
74402>>>>>>>>>>>//*****************************************************************************************
74402>>>>>>>>>>>// Copyright (c)  2001 Michael Kurz
74402>>>>>>>>>>>// All rights reserved.
74402>>>>>>>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
74402>>>>>>>>>>>//
74402>>>>>>>>>>>// $FileName    : mWinAPIGetKeyNameText.pkg
74402>>>>>>>>>>>// $ProjectName : Shared Methods
74402>>>>>>>>>>>// $Author      : Michael Kurz
74402>>>>>>>>>>>// $Created     : 01.05.2001  20:02
74402>>>>>>>>>>>//
74402>>>>>>>>>>>// Contents:
74402>>>>>>>>>>>//  -WinAPIGetKeyNameText integer iVirtualKeyCode returns string
74402>>>>>>>>>>>//
74402>>>>>>>>>>>//  Gets the name of a VK key code.
74402>>>>>>>>>>>//*****************************************************************************************
74402>>>>>>>>>>>//TH-RevisionStart
74402>>>>>>>>>>>//TH-RevisionEnd
74402>>>>>>>>>>>
74402>>>>>>>>>>>
74402>>>>>>>>>>>  External_Function GetKeyNameText "GetKeyNameTextA" User32.dll UInteger iKey Pointer pBuff Integer iSize Returns Integer
74403>>>>>>>>>>>
74403>>>>>>>>>>>// Retrieves the name of a key. (Virtual KeyCode)
74403>>>>>>>>>>>Function WinAPIGetKeyNameText Global Integer iKey Returns String
74405>>>>>>>>>>>  Integer iRet
74405>>>>>>>>>>>  String  sBuff
74405>>>>>>>>>>>  
74405>>>>>>>>>>>  Move (Repeat(Character(0),1024))  To sBuff
74406>>>>>>>>>>>  Move (MapVirtualKey(iKey,0))      To iKey
74407>>>>>>>>>>>  Move (iKey*65536)                 To iKey
74408>>>>>>>>>>>  Move (GetKeyNameText(iKey,AddressOf(sBuff),1024))  To iRet
74409>>>>>>>>>>>  If iRet Eq 0 ;    Move "" To sBuff
74412>>>>>>>>>>>  Else ;    Move (Cstring(sBuff)) To sBuff
74414>>>>>>>>>>>  Function_Return sBuff
74415>>>>>>>>>>>End_Function
74416>>>>>>>>>>>
74416>>>>>>>>>>>
74416>>>>>>>>>Use cSciLexerSupport.pkg
Including file: cSciLexerSupport.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexerSupport.pkg)
74416>>>>>>>>>>>//TH-Header
74416>>>>>>>>>>>//*****************************************************************************************
74416>>>>>>>>>>>// Copyright (c)  2018 Your Company Name
74416>>>>>>>>>>>// All rights reserved.
74416>>>>>>>>>>>//
74416>>>>>>>>>>>// $FileName    : SourceCodeTools\AppSrc\cSciLexerSupport.pkg
74416>>>>>>>>>>>// $ProjectName : DFRefactor
74416>>>>>>>>>>>// $Authors     :
74416>>>>>>>>>>>// $Created     : 28.07.2018  23:59
74416>>>>>>>>>>>//
74416>>>>>>>>>>>// Contents:
74416>>>>>>>>>>>//  Support module for the sciLexer control to use the sciLexer control outside of
74416>>>>>>>>>>>//  The Hammer project.
74416>>>>>>>>>>>//
74416>>>>>>>>>>>//*****************************************************************************************
74416>>>>>>>>>>>//TH-RevisionStart
74416>>>>>>>>>>>// ********************
74416>>>>>>>>>>>// MODIFICATION SUMMARY
74416>>>>>>>>>>>// ********************
74416>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
74416>>>>>>>>>>>//TH-RevisionEnd
74416>>>>>>>>>>>
74416>>>>>>>>>>>// No Code here for the Hammer itself
74416>>>>>>>>>Use TH3Workspace.pkg
Including file: TH3Workspace.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\TH3Workspace.pkg)
74416>>>>>>>>>>>// TH3Workspace.pkg
74416>>>>>>>>>>>// By Sergey V. Natarov
74416>>>>>>>>>>>// Created: 11/03/2017
74416>>>>>>>>>>>// This file defines TH3 Workspace (HWS extension)
74416>>>>>>>>>>>// HWS includes information about The Hammer Workspace
74416>>>>>>>>>>>// It is based on the Project workspace, but can be amended
74416>>>>>>>>>>>// by Developer
74416>>>>>>>>>>>
74416>>>>>>>>>>>Use TH3Workspace.h
Including file: TH3Workspace.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\TH3Workspace.h)
74416>>>>>>>>>>>>>// TH3Workspace.h
74416>>>>>>>>>>>>>// on 12/03/2017 by Sergey V. Natarov
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Use RegistryAPI.pkg
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Global_Variable Integer ghoToolsPane
74416>>>>>>>>>>>>>Global_Variable Integer ghoOutputPane
74416>>>>>>>>>>>>>Global_Variable Integer ghoOutputDialog
74416>>>>>>>>>>>>>Global_Variable Integer ghoEditorPopupMenu
74416>>>>>>>>>>>>>Global_Variable Integer ghoCurrentFileTab
74416>>>>>>>>>>>>>Global_Variable Integer ghoWorkspaceFilesTree
74416>>>>>>>>>>>>>  Global_Variable Integer ghoWorkSpaceHandlerEx
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Global_Variable Integer ghoCompilerInfo
74416>>>>>>>>>>>>>Global_Variable Integer ghoBuildMenu
74416>>>>>>>>>>>>>Global_Variable String gsTransferWSFile
74416>>>>>>>>>>>>>Global_Variable String gsTransferDDFile
74416>>>>>>>>>>>>>Global_Variable String[] gILanguage
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>// The Hammer File Types
74416>>>>>>>>>>>>>Define KPH_FILE_EDITABLE For 0
74416>>>>>>>>>>>>>Define KPH_FILE_MENU     For 1
74416>>>>>>>>>>>>>Define KPH_FILE_FOLDER   For 2
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Struct tTHSource
74416>>>>>>>>>>>>>    String  sFile
74416>>>>>>>>>>>>>    String  sBookmarks
74416>>>>>>>>>>>>>    Integer iBookmarkCount
74416>>>>>>>>>>>>>    Integer iCursorLine
74416>>>>>>>>>>>>>    Integer iCursorColumn
74416>>>>>>>>>>>>>End_Struct
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Struct tTHWorkspace
74416>>>>>>>>>>>>>    String   sName
74416>>>>>>>>>>>>>    String   sSchema
74416>>>>>>>>>>>>>    Integer  iShowPaths
74416>>>>>>>>>>>>>    String   sFullName
74416>>>>>>>>>>>>>    String   sStudio
74416>>>>>>>>>>>>>    String   sCompiler
74416>>>>>>>>>>>>>    String   sDBEditor
74416>>>>>>>>>>>>>    String   sDBViewer
74416>>>>>>>>>>>>>    String   sFFText
74416>>>>>>>>>>>>>    String   sFFTypes
74416>>>>>>>>>>>>>    String   sFFPath
74416>>>>>>>>>>>>>    Integer  iFFMatchWord
74416>>>>>>>>>>>>>    Integer  iFFMatchCase
74416>>>>>>>>>>>>>    Integer  iFFSubFolders
74416>>>>>>>>>>>>>    Integer  iFFShowAll
74416>>>>>>>>>>>>>    Integer  iFFExcludeComments
74416>>>>>>>>>>>>>    Integer  iFFRegExp
74416>>>>>>>>>>>>>    String[] saFiles
74416>>>>>>>>>>>>>    String[] saFileDesc
74416>>>>>>>>>>>>>    String[] saFolders
74416>>>>>>>>>>>>>    String[] saExclude
74416>>>>>>>>>>>>>    String[] saOpened
74416>>>>>>>>>>>>>    tTHSource[] taSources
74416>>>>>>>>>>>>>    tTHSource[] taSources
74416>>>>>>>>>>>>>End_Struct
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Struct tTHCompiler
74416>>>>>>>>>>>>>    String sVersion
74416>>>>>>>>>>>>>    String sProgID
74416>>>>>>>>>>>>>    String sEventId
74416>>>>>>>>>>>>>    Handle hoCompiler
74416>>>>>>>>>>>>>End_Struct
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>// Language Definition
74416>>>>>>>>>>>>>Struct tTHLanguage
74416>>>>>>>>>>>>>    String      sName
74416>>>>>>>>>>>>>    Integer     iProcedural
74416>>>>>>>>>>>>>    Integer     iCaseSensitive
74416>>>>>>>>>>>>>    String      sLineComments
74416>>>>>>>>>>>>>    String      sStringDelimiter
74416>>>>>>>>>>>>>    String      sMultiLineCommentStart
74416>>>>>>>>>>>>>    String      sMultiLineCommentStop
74416>>>>>>>>>>>>>    String      sEscapeChar
74416>>>>>>>>>>>>>    String      sLineTerminationChar
74416>>>>>>>>>>>>>    String      sMetaStart
74416>>>>>>>>>>>>>    String      sMetaStop
74416>>>>>>>>>>>>>    String[]    saScopeStart
74416>>>>>>>>>>>>>    String[]    saScopeStop
74416>>>>>>>>>>>>>    String[]    saKeywords
74416>>>>>>>>>>>>>    String[]    saOperators
74416>>>>>>>>>>>>>    String[]    saTags
74416>>>>>>>>>>>>>    String[]    saEntities
74416>>>>>>>>>>>>>    String[]    saAttributes
74416>>>>>>>>>>>>>End_Struct
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Struct tDFDefaultClasses
74416>>>>>>>>>>>>>    String sCategory
74416>>>>>>>>>>>>>    String sClass
74416>>>>>>>>>>>>>    String sFile
74416>>>>>>>>>>>>>End_Struct
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Define TH_SCHEMA_DATAFLEX   for "DataFlex"
74416>>>>>>>>>>>>>Define TH_SCHEMA_DELPHI     for "Delphi"
74416>>>>>>>>>>>>>Define TH_SCHEMA_CCPP       for "C/C++"
74416>>>>>>>>>>>>>Define TH_SCHEMA_PYTHON     for "Python"
74416>>>>>>>>>>>>>Define TH_SCHEMA_WEB        for "Web"
74416>>>>>>>>>>>>>Define TH_SCHEMA_OTHER      for "Other"
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>
74416>>>>>>>>>>>>>Function UCharToSHORT Global UChar[] Buffer Returns Integer
74418>>>>>>>>>>>>>    Integer in1 in2
74418>>>>>>>>>>>>>    
74418>>>>>>>>>>>>>    Move 0 To in1
74419>>>>>>>>>>>>>    If (SizeOfArray(Buffer)=2) Begin
74421>>>>>>>>>>>>>      Move Buffer[0] To in1
74422>>>>>>>>>>>>>      Move Buffer[1] To in2
74423>>>>>>>>>>>>>      Move ( in1 + (in2*256) ) to in1
74424>>>>>>>>>>>>>      If (in2 > 127) ;          Move (in1 - 65536) to in1
74427>>>>>>>>>>>>>    End
74427>>>>>>>>>>>>>>
74427>>>>>>>>>>>>>    Function_Return in1
74428>>>>>>>>>>>>>End_Function
74429>>>>>>>>>>>>>
74429>>>>>>>>>>>>>
74429>>>>>>>>>>>>>Function UCharToDWORD Global UChar[] Buffer Returns Integer
74431>>>>>>>>>>>>>    Integer in1 in2 in3 in4
74431>>>>>>>>>>>>>    
74431>>>>>>>>>>>>>    Move 0 To in1
74432>>>>>>>>>>>>>    If (SizeOfArray(Buffer)=4) Begin
74434>>>>>>>>>>>>>      Move Buffer[0] To in1
74435>>>>>>>>>>>>>      Move Buffer[1] To in2
74436>>>>>>>>>>>>>      Move Buffer[2] To in3
74437>>>>>>>>>>>>>      Move Buffer[3] To in4
74438>>>>>>>>>>>>>      Move (in1 + (in2*256) + (in3*65536) + (in4*16777216)) to in1
74439>>>>>>>>>>>>>    End
74439>>>>>>>>>>>>>>
74439>>>>>>>>>>>>>    Function_Return in1
74440>>>>>>>>>>>>>End_Function
74441>>>>>>>>>>>>>
74441>>>>>>>>>>>>>Function DWORDtoUChar Global Integer aDWORD Returns UChar[]
74443>>>>>>>>>>>>>    UChar[] data
74444>>>>>>>>>>>>>    Move (low(aDWORD) iand 255) To data[0]
74445>>>>>>>>>>>>>    Move (low(aDWORD) / 256)    To data[1]
74446>>>>>>>>>>>>>    Move (hi(aDWORD) iand 255)  To data[2]
74447>>>>>>>>>>>>>    Move (hi(aDWORD) / 256)     To data[3]
74448>>>>>>>>>>>>>    Function_Return data
74449>>>>>>>>>>>>>End_Function
74450>>>>>>>>>>>>>
74450>>>>>>>>>>>>>Function SHORTtoUChar Global Integer aSHORT Returns UChar[]
74452>>>>>>>>>>>>>    UChar[] data
74453>>>>>>>>>>>>>    Move ( aSHORT iand 255) To data[0]
74454>>>>>>>>>>>>>    Move ( aSHORT / 256)    To data[1]
74455>>>>>>>>>>>>>    Function_Return data
74456>>>>>>>>>>>>>End_Function
74457>>>>>>>>>>>>>
74457>>>>>>>>>>>>>// Upto 256 chars
74457>>>>>>>>>>>>>Function WSReadStr1 Returns String
74460>>>>>>>>>>>>>    String  sValue
74460>>>>>>>>>>>>>    UChar   ucSize
74460>>>>>>>>>>>>>    Integer iSize
74460>>>>>>>>>>>>>    Read_Block ucSize 1
74461>>>>>>>>>>>>>    Move ucSize to iSize
74462>>>>>>>>>>>>>    If iSize ;        Read_Block sValue iSize
74465>>>>>>>>>>>>>    Function_Return sValue
74466>>>>>>>>>>>>>End_Function
74467>>>>>>>>>>>>>
74467>>>>>>>>>>>>>// Upto 65356 chars
74467>>>>>>>>>>>>>Function WSReadStr2 Returns String
74470>>>>>>>>>>>>>    String  sValue
74470>>>>>>>>>>>>>    UChar[] ucaSize
74471>>>>>>>>>>>>>    Integer iSize
74471>>>>>>>>>>>>>    Read_Block ucaSize 2
74472>>>>>>>>>>>>>    Move (UCharToSHORT(ucaSize)) to iSize
74473>>>>>>>>>>>>>    If iSize ;        Read_Block sValue iSize
74476>>>>>>>>>>>>>    Function_Return sValue
74477>>>>>>>>>>>>>End_Function
74478>>>>>>>>>>>>>
74478>>>>>>>>>>>>>// Upto 2G chars
74478>>>>>>>>>>>>>Function WSReadStr4 Returns String
74481>>>>>>>>>>>>>    String  sValue
74481>>>>>>>>>>>>>    UChar[] ucaSize
74482>>>>>>>>>>>>>    Integer iSize
74482>>>>>>>>>>>>>    Read_Block ucaSize 4
74483>>>>>>>>>>>>>    Move (UCharToDWORD(ucaSize)) to iSize
74484>>>>>>>>>>>>>    If iSize ;        Read_Block sValue iSize
74487>>>>>>>>>>>>>    Function_Return sValue
74488>>>>>>>>>>>>>End_Function
74489>>>>>>>>>>>>>
74489>>>>>>>>>>>>>// 0..256
74489>>>>>>>>>>>>>Function WSReadInt1 Returns Integer
74492>>>>>>>>>>>>>    UChar      ucValue
74492>>>>>>>>>>>>>    Read_Block  ucValue 1
74493>>>>>>>>>>>>>    Function_Return ucValue
74494>>>>>>>>>>>>>End_Function
74495>>>>>>>>>>>>>
74495>>>>>>>>>>>>>// 0..65536
74495>>>>>>>>>>>>>Function WSReadInt2 Returns Integer
74498>>>>>>>>>>>>>    UChar[]     ucaValue
74499>>>>>>>>>>>>>    Read_Block  ucaValue 2
74500>>>>>>>>>>>>>    Function_Return (UCharToSHORT(ucaValue))
74501>>>>>>>>>>>>>End_Function
74502>>>>>>>>>>>>>
74502>>>>>>>>>>>>>// 0..2G
74502>>>>>>>>>>>>>Function WSReadInt4 Returns Integer
74505>>>>>>>>>>>>>    UChar[]     ucaValue
74506>>>>>>>>>>>>>    Read_Block  ucaValue 4
74507>>>>>>>>>>>>>    Function_Return (UCharToDWORD(ucaValue))
74508>>>>>>>>>>>>>End_Function
74509>>>>>>>>>>>>>
74509>>>>>>>>>>>>>Procedure WSWriteStr1 String sValue
74512>>>>>>>>>>>>>    UChar ucLen
74512>>>>>>>>>>>>>    Move (Length(sValue)) To ucLen
74513>>>>>>>>>>>>>    Write ucLen
74514>>>>>>>>>>>>>    Write sValue
74515>>>>>>>>>>>>>End_Procedure
74516>>>>>>>>>>>>>
74516>>>>>>>>>>>>>Procedure WSWriteStr2 String sValue
74519>>>>>>>>>>>>>    Write (SHORTtoUChar(Length(sValue)))
74520>>>>>>>>>>>>>    Write sValue
74521>>>>>>>>>>>>>End_Procedure
74522>>>>>>>>>>>>>
74522>>>>>>>>>>>>>Procedure WSWriteStr4 String sValue
74525>>>>>>>>>>>>>    Write (DWordtoUChar(Length(sValue)))
74526>>>>>>>>>>>>>    Write sValue
74527>>>>>>>>>>>>>End_Procedure
74528>>>>>>>>>>>>>
74528>>>>>>>>>>>>>Function CheckType String sFile Returns Integer
74531>>>>>>>>>>>>>    String sTemp sTmp
74531>>>>>>>>>>>>>    Integer iPos
74531>>>>>>>>>>>>>    Integer iType
74531>>>>>>>>>>>>>
74531>>>>>>>>>>>>>    Move KPH_FILE_EDITABLE To iType
74532>>>>>>>>>>>>>    Move sFile To sTemp
74533>>>>>>>>>>>>>    While (Pos("\",sTemp)<>0)
74537>>>>>>>>>>>>>        Move (Pos("\",sTemp)) To iPos
74538>>>>>>>>>>>>>        Move (Left(sTemp,iPos)) To sTmp
74539>>>>>>>>>>>>>        Move (Replace(sTmp,sTemp,"")) To sTemp
74540>>>>>>>>>>>>>    Loop
74541>>>>>>>>>>>>>>
74541>>>>>>>>>>>>>    Move (Pos(".",sTemp)) To iPos
74542>>>>>>>>>>>>>    If (iPos=0) Begin
74544>>>>>>>>>>>>>        Move KPH_FILE_FOLDER To iType
74545>>>>>>>>>>>>>    End  
74545>>>>>>>>>>>>>>
74545>>>>>>>>>>>>>    Function_Return iType
74546>>>>>>>>>>>>>End_Function
74547>>>>>>>>>>>>>
74547>>>>>>>>>>>Use THColorer.h
Including file: THColorer.h    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\THColorer.h)
74547>>>>>>>>>>>>>// THColorer.pkg
74547>>>>>>>>>>>>>// This is header package for TheHammer 3.0 Code Colorer
74547>>>>>>>>>>>>>// by Sergey V. Natarov
74547>>>>>>>>>>>>>
74547>>>>>>>>>>>>>Use Font_dlg.pkg
Including file: Font_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Font_dlg.pkg)
74547>>>>>>>>>>>>>>>Use VDFBase.pkg
74547>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
74547>>>>>>>>>>>>>>>Use tWinStructs.pkg
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Flags
74547>>>>>>>>>>>>>>>// The following flags are for Windows '95 only.
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Orginal FontTypes constants
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Character sets
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Output precision
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Clipping precision
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Output quality
74547>>>>>>>>>>>>>>>// The following output quality's are for Windows '95 only
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Pitch
74547>>>>>>>>>>>>>>>// The following pitch is for Window '95 only
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Font family
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>// Font type
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>
74547>>>>>>>>>>>>>>>External_Function ChooseFont "ChooseFontA" COMDLG32.DLL ;    Pointer lpChooseFont Returns Integer
74548>>>>>>>>>>>>>>>
74548>>>>>>>>>>>>>>>Class FontDialog is a cObject
74549>>>>>>>>>>>>>>>    Procedure Construct_Object
74551>>>>>>>>>>>>>>>        Forward Send Construct_Object
74553>>>>>>>>>>>>>>>        
74553>>>>>>>>>>>>>>>        // Old interface property's
74553>>>>>>>>>>>>>>>        Property Integer FontTypes 0
74554>>>>>>>>>>>>>>>        // ChooseFont property's
74554>>>>>>>>>>>>>>>        Property Integer FontPointSize 0
74555>>>>>>>>>>>>>>>        Property Integer ScreenFonts_State True // False
74556>>>>>>>>>>>>>>>        Property Integer ShowHelp_State False
74557>>>>>>>>>>>>>>>        Property Integer Effects_State True // False
74558>>>>>>>>>>>>>>>        Property Integer NoVectorFonts_State False
74559>>>>>>>>>>>>>>>        Property Integer NoOEMFonts_State False
74560>>>>>>>>>>>>>>>        Property Integer NoSimulations_State False
74561>>>>>>>>>>>>>>>        Property Integer FixedPitchOnly_State False
74562>>>>>>>>>>>>>>>        Property Integer ForceFontExist_State True // False
74563>>>>>>>>>>>>>>>        Property Integer ScalableOnly_State False
74564>>>>>>>>>>>>>>>        Property Integer TTOnly_State False
74565>>>>>>>>>>>>>>>        Property Integer NoFaceSel_State False
74566>>>>>>>>>>>>>>>        Property Integer NoStyleSel_State False
74567>>>>>>>>>>>>>>>        Property Integer NoSizeSel_State False
74568>>>>>>>>>>>>>>>        Property Integer SelectScript_State False
74569>>>>>>>>>>>>>>>        Property Integer NoScriptSel_State False
74570>>>>>>>>>>>>>>>        Property Integer NoVertFonts_State False
74571>>>>>>>>>>>>>>>        Property Integer ScriptsOnly_State False
74572>>>>>>>>>>>>>>>        Property Integer ANSIOnly_State False
74573>>>>>>>>>>>>>>>        Property Integer FontRGBColors 0
74574>>>>>>>>>>>>>>>        Property Integer FontType 0
74575>>>>>>>>>>>>>>>        Property Integer FontSizeMin 1
74576>>>>>>>>>>>>>>>        Property Integer FontSizeMax 9999
74577>>>>>>>>>>>>>>>        // LogFont property's
74577>>>>>>>>>>>>>>>        Property Integer FontHeight -1    // see comments below
74578>>>>>>>>>>>>>>>        Property Integer FontWidth -1     // see comments below
74579>>>>>>>>>>>>>>>        Property Integer FontEscapement 0
74580>>>>>>>>>>>>>>>        Property Integer FontOrientation 0
74581>>>>>>>>>>>>>>>        Property Integer FontWeight -1    // see comments below
74582>>>>>>>>>>>>>>>        Property Integer FontItalic -1    // see comments below
74583>>>>>>>>>>>>>>>        Property Integer FontUnderline -1 // see comments below
74584>>>>>>>>>>>>>>>        Property Integer FontStrikeOut 0
74585>>>>>>>>>>>>>>>        Property Integer FontCharSet 0
74586>>>>>>>>>>>>>>>        Property Integer FontOutPrecision 0
74587>>>>>>>>>>>>>>>        Property Integer FontClipPrecision 0
74588>>>>>>>>>>>>>>>        Property Integer FontQuality 0
74589>>>>>>>>>>>>>>>        Property Integer FontPitch 0
74590>>>>>>>>>>>>>>>        Property Integer FontFamily 0
74591>>>>>>>>>>>>>>>        Property String  FaceName "EMPTY"  // see comments below
74592>>>>>>>>>>>>>>>        
74592>>>>>>>>>>>>>>>        // Set Focus_Mode To NonFocusable
74592>>>>>>>>>>>>>>>    End_Procedure
74593>>>>>>>>>>>>>>>    
74593>>>>>>>>>>>>>>>    Function OwnerHandle Returns Handle
74595>>>>>>>>>>>>>>>        Handle hWnd
74595>>>>>>>>>>>>>>>        Handle hoObj
74595>>>>>>>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
74596>>>>>>>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
74597>>>>>>>>>>>>>>>        Function_Return hWnd
74598>>>>>>>>>>>>>>>    End_Function
74599>>>>>>>>>>>>>>>    
74599>>>>>>>>>>>>>>>    Function FontDialog Returns Integer
74601>>>>>>>>>>>>>>>        Integer iResult iPitchAndFamily iFlags
74601>>>>>>>>>>>>>>>        String sResult
74601>>>>>>>>>>>>>>>        String sFaceName
74601>>>>>>>>>>>>>>>        Handle hOwner
74601>>>>>>>>>>>>>>>        tWinChooseFont ChseFont
74601>>>>>>>>>>>>>>>        tWinChooseFont ChseFont
74601>>>>>>>>>>>>>>>        tWinLogFont LogicalFont
74601>>>>>>>>>>>>>>>        tWinLogFont LogicalFont
74601>>>>>>>>>>>>>>>        
74601>>>>>>>>>>>>>>>        //Delegate Get Container_Handle To hOwner
74601>>>>>>>>>>>>>>>        Get OwnerHandle to hOwner
74602>>>>>>>>>>>>>>>        // Some property's default to -1 because we want to determine if the user
74602>>>>>>>>>>>>>>>        // changed these properties. If he changed the property's we will take their
74602>>>>>>>>>>>>>>>        // value and pass it on to the function. If the user didn't change the
74602>>>>>>>>>>>>>>>        // properties we will retrieve them from the DFWindow class.
74602>>>>>>>>>>>>>>>        // DF19.1: Changed TYPE into STRUCT, which means that -1 cannot be assigned to a UChar member.
74602>>>>>>>>>>>>>>>        Integer iVal
74602>>>>>>>>>>>>>>>        If (FontItalic(Self) = -1) Begin
74604>>>>>>>>>>>>>>>            Move (FontItalics(Self)) to iVal
74605>>>>>>>>>>>>>>>            If (iVal = -1) ;                Set FontItalic to 255
74608>>>>>>>>>>>>>>>            Else ;                Set FontItalic to iVal
74610>>>>>>>>>>>>>>>        End
74610>>>>>>>>>>>>>>>>
74610>>>>>>>>>>>>>>>        If (FontUnderline(Self) = -1) ;            Set FontUnderline to 255
74613>>>>>>>>>>>>>>>        If (FontWeight(Self) = -1) ;            Set FontWeight to 255
74616>>>>>>>>>>>>>>>        If (FontHeight(Self) = -1) Begin
74618>>>>>>>>>>>>>>>            Move (Hi(FontSize(Self))) to iVal
74619>>>>>>>>>>>>>>>            If (iVal = -1) ;                Set FontHeight to 255
74622>>>>>>>>>>>>>>>            Else ;                Set FontHeight to iVal
74624>>>>>>>>>>>>>>>        End
74624>>>>>>>>>>>>>>>>
74624>>>>>>>>>>>>>>>        If (FontWidth(Self) = -1) Begin
74626>>>>>>>>>>>>>>>            Move (Low(FontSize(Self))) to iVal
74627>>>>>>>>>>>>>>>            If (iVal = -1) ;                Set FontWidth to 255
74630>>>>>>>>>>>>>>>            Else ;                Set FontWidth to iVal
74632>>>>>>>>>>>>>>>        End
74632>>>>>>>>>>>>>>>>
74632>>>>>>>>>>>>>>>        If (FaceName(Self) = "EMPTY") ;            Set FaceName to (TypeFace(Self))
74635>>>>>>>>>>>>>>>        
74635>>>>>>>>>>>>>>>        Move (FontHeight(Self)) to LogicalFont.lfHeight
74636>>>>>>>>>>>>>>>        Move (FontWidth(Self)) to LogicalFont.lfWidth
74637>>>>>>>>>>>>>>>        Move (FontEscapement(Self)) to LogicalFont.lfEscapement
74638>>>>>>>>>>>>>>>        Move (FontOrientation(Self)) to LogicalFont.lfOrientation
74639>>>>>>>>>>>>>>>        Move (FontWeight(Self))    to LogicalFont.lfWeight
74640>>>>>>>>>>>>>>>        Move (FontItalic(Self))    to LogicalFont.lfItalic
74641>>>>>>>>>>>>>>>        Move (FontUnderline(Self)) to LogicalFont.lfUnderline
74642>>>>>>>>>>>>>>>        Move (FontStrikeOut(Self)) to LogicalFont.lfStrikeOut
74643>>>>>>>>>>>>>>>        Move (FontCharSet(Self))   to LogicalFont.lfCharSet
74644>>>>>>>>>>>>>>>        Move (FontOutPrecision(Self)) to LogicalFont.lfOutPrecision
74645>>>>>>>>>>>>>>>        Move (FontClipPrecision(Self)) to LogicalFont.lfClipPrecision
74646>>>>>>>>>>>>>>>        Move (FontQuality(Self)) to LogicalFont.lfQuality
74647>>>>>>>>>>>>>>>
74647>>>>>>>>>>>>>>>        // Family is an integer using bits 5-7 (has values 0,16,32,48,64 and 80), 
74647>>>>>>>>>>>>>>>        // and Pitch uses bits 1-4 (values 0,1,2,8). They can be simply added using IOR to get the PitchAndFamily.
74647>>>>>>>>>>>>>>>        Move (FontFamily(Self) ior FontPitch(Self)) to LogicalFont.lfPitchAndFamily
74648>>>>>>>>>>>>>>>
74648>>>>>>>>>>>>>>>        Get FaceName to sFaceName
74649>>>>>>>>>>>>>>>        Move (Left(sFaceName,LF_FACESIZE)) to sFaceName
74650>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(LogicalFont.lfFaceName), AddressOf(sfaceName), Length(sfaceName))) to iResult
74651>>>>>>>>>>>>>>>        
74651>>>>>>>>>>>>>>>        Move (SizeOfType(tWinChooseFont)) to ChseFont.lStructSize
74652>>>>>>>>>>>>>>>        Move hOwner to ChseFont.hwndOwner
74653>>>>>>>>>>>>>>>        Move (AddressOf(LogicalFont)) to ChseFont.lpLogFont
74654>>>>>>>>>>>>>>>        // The original FONT_DLG.PKG (by Stuart) always sets the CF_LIMITSIZE, CF_SCREENFONT and
74654>>>>>>>>>>>>>>>        // CF_INITTOLOGFONTSTRUCT flags. We will do the same...
74654>>>>>>>>>>>>>>>        // This defeats the use of CF_SCREENFONTS and CF_LIMITSIZE !
74654>>>>>>>>>>>>>>>        Move (CF_LIMITSIZE+CF_INITTOLOGFONTSTRUCT+CF_SCREENFONTS+FontTypes(Self)) to iFlags
74655>>>>>>>>>>>>>>>        If (ShowHelp_State(Self)) ;            Move (iFlags+CF_SHOWHELP) to iFlags
74658>>>>>>>>>>>>>>>        If (Effects_State(Self)) ;            Move (iFlags+CF_EFFECTS) to iFlags
74661>>>>>>>>>>>>>>>        If (NoOEMFonts_State(Self)) ;            Move (iFlags+CF_NOOEMFONTS) to iFlags
74664>>>>>>>>>>>>>>>        If (ForceFontExist_State(Self)) ;            Move (iFlags+CF_FORCEFONTEXIST) to iFlags
74667>>>>>>>>>>>>>>>        If (NoFaceSel_State(Self)) ;            Move (iFlags+CF_NOFACESEL) to iFlags
74670>>>>>>>>>>>>>>>        If (NoStyleSel_State(Self)) ;            Move (iFlags+CF_NOSTYLESEL) to iFlags
74673>>>>>>>>>>>>>>>        If (NoSizeSel_State(Self)) ;            Move (iFlags+CF_NOSIZESEL) to iFlags
74676>>>>>>>>>>>>>>>        If (SelectScript_State(Self)) ;            Move (iFlags+CF_SELECTSCRIPT) to iFlags
74679>>>>>>>>>>>>>>>        If (NoScriptSel_State(Self)) ;            Move (iFlags+CF_NOSCRIPTSEL) to iFlags
74682>>>>>>>>>>>>>>>        If (NoVertFonts_State(Self)) ;            Move (iFlags+CF_NOVERTFONTS) to iFlags
74685>>>>>>>>>>>>>>>        If (ScriptsOnly_State(Self)) ;            Move (iFlags+CF_SCRIPTSONLY) to iFlags
74688>>>>>>>>>>>>>>>        If (not(FontTypes(Self))) Begin
74690>>>>>>>>>>>>>>>            If (ANSIOnly_State(Self)) ;                Move (iFlags+CF_ANSIONLY) to iFlags
74693>>>>>>>>>>>>>>>            If (NoVectorFonts_State(Self)) ;                Move (iFlags+CF_NOVECTORFONTS) to iFlags
74696>>>>>>>>>>>>>>>            If (NoSimulations_State(Self)) ;                Move (iFlags+CF_NOSIMULATIONS) to iFlags
74699>>>>>>>>>>>>>>>            If (FixedPitchOnly_State(Self)) ;                Move (iFlags+CF_FIXEDPITCHONLY) to iFlags
74702>>>>>>>>>>>>>>>            If (ScalableOnly_State(Self)) ;                Move (iFlags+CF_SCALABLEONLY) to iFlags
74705>>>>>>>>>>>>>>>            If (TTOnly_State(Self)) ;                Move (iFlags+CF_TTONLY) to iFlags
74708>>>>>>>>>>>>>>>        End
74708>>>>>>>>>>>>>>>>
74708>>>>>>>>>>>>>>>        Move iFlags to ChseFont.Flags
74709>>>>>>>>>>>>>>>        Move (FontPointSize(Self)) to ChseFont.iPointSize
74710>>>>>>>>>>>>>>>        Move (FontRGBColors(Self)) to ChseFont.rgbColors
74711>>>>>>>>>>>>>>>        Move (FontType(Self)) to ChseFont.nFontType
74712>>>>>>>>>>>>>>>        Move (FontSizeMin(Self)) to ChseFont.nSizeMin
74713>>>>>>>>>>>>>>>        Move (FontSizeMax(Self)) to ChseFont.nSizeMax
74714>>>>>>>>>>>>>>>        
74714>>>>>>>>>>>>>>>        Move (ChooseFont(AddressOf(ChseFont))) to iResult
74715>>>>>>>>>>>>>>>        If not iResult ;            Function_Return iResult
74718>>>>>>>>>>>>>>>        Move LogicalFont.lfHeight to iResult
74719>>>>>>>>>>>>>>>        Set FontHeight to iResult
74720>>>>>>>>>>>>>>>        Move LogicalFont.lfWidth to iResult
74721>>>>>>>>>>>>>>>        Set FontWidth to iResult
74722>>>>>>>>>>>>>>>        Move LogicalFont.lfEscapement to iResult
74723>>>>>>>>>>>>>>>        Set FontEscapement to iResult
74724>>>>>>>>>>>>>>>        Move LogicalFont.lfOrientation to iResult
74725>>>>>>>>>>>>>>>        Set FontOrientation to iResult
74726>>>>>>>>>>>>>>>        Move LogicalFont.lfWeight to iResult
74727>>>>>>>>>>>>>>>        Set FontWeight to iResult
74728>>>>>>>>>>>>>>>        Move LogicalFont.lfItalic to iResult
74729>>>>>>>>>>>>>>>        Set FontItalic to iResult
74730>>>>>>>>>>>>>>>        Move LogicalFont.lfUnderline to iResult
74731>>>>>>>>>>>>>>>        Set FontUnderline to iResult
74732>>>>>>>>>>>>>>>        Move LogicalFont.lfStrikeOut to iResult
74733>>>>>>>>>>>>>>>        Set FontStrikeOut to iResult
74734>>>>>>>>>>>>>>>        Move LogicalFont.lfCharSet to iResult
74735>>>>>>>>>>>>>>>        Set FontCharSet to iResult
74736>>>>>>>>>>>>>>>        Move LogicalFont.lfOutPrecision to iResult
74737>>>>>>>>>>>>>>>        Set FontOutPrecision to iResult
74738>>>>>>>>>>>>>>>        Move LogicalFont.lfClipPrecision to iResult
74739>>>>>>>>>>>>>>>        Set FontClipPrecision to iResult
74740>>>>>>>>>>>>>>>        Move LogicalFont.lfQuality to iResult
74741>>>>>>>>>>>>>>>        Set FontQuality to iResult
74742>>>>>>>>>>>>>>>        Move LogicalFont.lfPitchAndFamily to iPitchAndFamily
74743>>>>>>>>>>>>>>>
74743>>>>>>>>>>>>>>>        Move (ZeroString(LF_FACESIZE)) to sResult
74744>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sResult), AddressOf(LogicalFont.lfFaceName), LF_FACESIZE)) to iResult
74745>>>>>>>>>>>>>>>        Set FaceName to sResult
74746>>>>>>>>>>>>>>>
74746>>>>>>>>>>>>>>>        // https://docs.microsoft.com/en-us/previous-versions/windows/desktop/bb322837(v=vs.85)
74746>>>>>>>>>>>>>>>        // Pitch is the lower 4 bits and can have values 0,1,2, and 8. 
74746>>>>>>>>>>>>>>>        // Family is the higher 4 bits and can have values: 0,16,32,48,64 and 80.
74746>>>>>>>>>>>>>>>        // The correct function for getting them is IAND
74746>>>>>>>>>>>>>>>        Set FontPitch to (Integer (iPitchAndFamily iand |CI$0F))
74747>>>>>>>>>>>>>>>        Set FontFamily to (Integer (iPitchAndFamily iand |CI$F0))
74748>>>>>>>>>>>>>>>
74748>>>>>>>>>>>>>>>        Move ChseFont.iPointSize to iResult
74749>>>>>>>>>>>>>>>        Set FontPointSize to iResult
74750>>>>>>>>>>>>>>>        Move ChseFont.rgbColors to iResult
74751>>>>>>>>>>>>>>>        Set FontRGBColors to iResult
74752>>>>>>>>>>>>>>>        Move ChseFont.nFontType to iResult
74753>>>>>>>>>>>>>>>        Set FontType to iResult
74754>>>>>>>>>>>>>>>        Move ChseFont.nSizeMin to iResult
74755>>>>>>>>>>>>>>>        Set FontSizeMin to iResult
74756>>>>>>>>>>>>>>>        Move ChseFont.nSizeMax to iResult
74757>>>>>>>>>>>>>>>        Set FontSizeMax to iResult
74758>>>>>>>>>>>>>>>        Function_Return True
74759>>>>>>>>>>>>>>>    End_Function
74760>>>>>>>>>>>>>>>    
74760>>>>>>>>>>>>>>>    
74760>>>>>>>>>>>>>>>    Procedure Set ShowEffects_State Integer iState
74762>>>>>>>>>>>>>>>        Set Effects_State to iState
74763>>>>>>>>>>>>>>>    End_Procedure
74764>>>>>>>>>>>>>>>    
74764>>>>>>>>>>>>>>>    Function ShowEffects Returns Integer
74766>>>>>>>>>>>>>>>        Function_Return (Effects_State(Self))
74767>>>>>>>>>>>>>>>    End_Function
74768>>>>>>>>>>>>>>>    
74768>>>>>>>>>>>>>>>    Procedure Set InitialFont_State Integer iState
74770>>>>>>>>>>>>>>>        Set NoFaceSel_State to (not(iState))
74771>>>>>>>>>>>>>>>    End_Procedure
74772>>>>>>>>>>>>>>>    
74772>>>>>>>>>>>>>>>    Function InitialFontState Returns Integer
74774>>>>>>>>>>>>>>>        Function_Return (not(NoFaceSel_State(Self)))
74775>>>>>>>>>>>>>>>    End_Function
74776>>>>>>>>>>>>>>>    
74776>>>>>>>>>>>>>>>    Procedure Set InitialSize_State Integer iState
74778>>>>>>>>>>>>>>>        Set NoSizeSel_State to (not(iState))
74779>>>>>>>>>>>>>>>    End_Procedure
74780>>>>>>>>>>>>>>>    
74780>>>>>>>>>>>>>>>    Function InitialSize_State Returns Integer
74782>>>>>>>>>>>>>>>        Function_Return (not(NoSizeSel_State(Self)))
74783>>>>>>>>>>>>>>>    End_Function
74784>>>>>>>>>>>>>>>    
74784>>>>>>>>>>>>>>>    Procedure Set InitialStyle_State Integer iState
74786>>>>>>>>>>>>>>>        Set NoStyleSel_State to (not(iState))
74787>>>>>>>>>>>>>>>    End_Procedure
74788>>>>>>>>>>>>>>>    
74788>>>>>>>>>>>>>>>    Function InitialStyle_State Returns Integer
74790>>>>>>>>>>>>>>>        Function_Return (not(NoStyleSel_State(Self)))
74791>>>>>>>>>>>>>>>    End_Function
74792>>>>>>>>>>>>>>>    
74792>>>>>>>>>>>>>>>    Procedure Set FontExists_State Integer iState
74794>>>>>>>>>>>>>>>        Set ForceFontExist_State to iState
74795>>>>>>>>>>>>>>>    End_Procedure
74796>>>>>>>>>>>>>>>    
74796>>>>>>>>>>>>>>>    Function FontExists_State Returns Integer
74798>>>>>>>>>>>>>>>        Function_Return (ForceFontExist_State(Self))
74799>>>>>>>>>>>>>>>    End_Function
74800>>>>>>>>>>>>>>>    
74800>>>>>>>>>>>>>>>    Procedure Set FontMinSize Integer iSize
74802>>>>>>>>>>>>>>>        Set FontSizeMin to iSize
74803>>>>>>>>>>>>>>>    End_Procedure
74804>>>>>>>>>>>>>>>    
74804>>>>>>>>>>>>>>>    Function FontMinSize Returns Integer
74806>>>>>>>>>>>>>>>        Function_Return (FontSizeMin(Self))
74807>>>>>>>>>>>>>>>    End_Function
74808>>>>>>>>>>>>>>>    
74808>>>>>>>>>>>>>>>    Procedure Set FontMaxSize Integer iSize
74810>>>>>>>>>>>>>>>        Set FontSizeMax to iSize
74811>>>>>>>>>>>>>>>    End_Procedure
74812>>>>>>>>>>>>>>>    
74812>>>>>>>>>>>>>>>    Function FontMaxSize Returns Integer
74814>>>>>>>>>>>>>>>        Function_Return (FontSizeMax(Self))
74815>>>>>>>>>>>>>>>    End_Function
74816>>>>>>>>>>>>>>>    
74816>>>>>>>>>>>>>>>    Procedure Set FontColor Integer iColor
74818>>>>>>>>>>>>>>>        Set FontRGBColors to iColor
74819>>>>>>>>>>>>>>>    End_Procedure
74820>>>>>>>>>>>>>>>    
74820>>>>>>>>>>>>>>>    Function FontColor Returns Integer
74822>>>>>>>>>>>>>>>        Function_Return (FontRGBColors(Self))
74823>>>>>>>>>>>>>>>    End_Function
74824>>>>>>>>>>>>>>>    
74824>>>>>>>>>>>>>>>    Function Show_Dialog Returns Integer
74826>>>>>>>>>>>>>>>        Function_Return (FontDialog(Self))
74827>>>>>>>>>>>>>>>    End_Function
74828>>>>>>>>>>>>>>>    
74828>>>>>>>>>>>>>>>End_Class
74829>>>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// *** COLORS ***
74829>>>>>>>>>>>>>// _WindowColr_ _LftMrgnClr_ _BookmarkCl_ _BookmarkBg_ _TextColorX_ _TextBackgr_ _NumberColr_ _NumberBkGr_ _KeywordsCl_ _KeywordsBg_ _OperatorCl_ _OperatorBg_ _ScopeKwClr_ _ScopeKwBkg_ _CommentClr_ _CommentBkg_ _StringColr_ _StringBkgr_ _TagTextClr_ _TagTextBkg_ _TagEntyClr_ _TagEntyBkg_ _TagElemClr_ _TagElemBkg_ _TagAttrClr_ _TagAttrBkg_ _LineNrColr_ _LineNrBkgr_ _HrDivLinCl_ _VrDivLinCl_ _HiLtLineCl_
74829>>>>>>>>>>>>>// 255255255000 192192192000 255255255255 255255255255 000000000000 255255255000 255000255000 255255255000 000000255000 255255255000 255000000000 255255255000 000000255000 255255255000 000128000000 255255255000 128128128000 255255255000 000128128000 255255255255 255000000000 255255255255 000000255000 255255255255 128000000000 255255255255 255255255000 128128128000 255255255255 192192192000 192192192000 000
74829>>>>>>>>>>>>>//      1            2             3           4             5           6             7            8            9           10            11          12            13          14           15           16            17          18           19          20            21            22           23         24            25           26           27           28          29            30          31
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// *** FONTS *** (PSFONTSTYLES)
74829>>>>>>>>>>>>>//      Nr       Sc Ct    TT En    At
74829>>>>>>>>>>>>>//   _  _  _  _  _  _  _  _  _  _  _  _
74829>>>>>>>>>>>>>// 000000000000000002000001000001000000000
74829>>>>>>>>>>>>>//   _     -  -        -        -     -
74829>>>>>>>>>>>>>//   Tx    Kw Op       St       El    Ln
74829>>>>>>>>>>>>>//   1  2  3  4  5  6  7  8  9 10 11 12
74829>>>>>>>>>>>>>//          1         2         3
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Normal           = 0
74829>>>>>>>>>>>>>// Bold             = 1
74829>>>>>>>>>>>>>// Italics          = 2
74829>>>>>>>>>>>>>// Bold + Italics   = 3
74829>>>>>>>>>>>>>// Underline        = 4
74829>>>>>>>>>>>>>// B+U              = 5
74829>>>>>>>>>>>>>// I+U              = 6
74829>>>>>>>>>>>>>// B+I+U            = 7
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// CodeMax: 31 elements as 3sRGBA + 3 zeroes
74829>>>>>>>>>>>>>Define CM_COLORS_STRSIZE for (31*12 + 3)
74829>>>>>>>>>>>>>// Scintilla: 37 elements as 3sRGBA + 3 zeroes
74829>>>>>>>>>>>>>Define SC_COLORS_STRSIZE for (42*12 + 3)
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Define Default white schema:
74829>>>>>>>>>>>>>Define TH_DEFSCHEMA_WHITE_STR   for "Default (White)"
74829>>>>>>>>>>>>>Define TH_DEFSCHEMA_BLACK_STR   for "Default (Black)"
74829>>>>>>>>>>>>>Define TH_DEFSCHEMA_BLUE_STR    for "Default (Blue)"
74829>>>>>>>>>>>>>Define TH_DEFSCHEMA_LIME_STR    for "Default (Lime)"
74829>>>>>>>>>>>>>Define TH_DEFSCHEMA_SERENE_STR  for "Default (Serene)"
74829>>>>>>>>>>>>>Define TH_DEFSCHEMA_SAHARA_STR  for "Default (Sahara)"
74829>>>>>>>>>>>>>Define TH_COLORSCHEMA_WHITE     for "255255255255220225240000255255255255255255255255000000000000255255255000255000255000255255255000000000255000255255255000255000000000255255255000000000255000255255255000000128000000255255255000128128128000255255255000000128128000255255255255255000000000255255255255000000255000255255255255128000000000255255255255105105105000190200225000255255255255192192192000220225240000128128128000255215215000000000000000200225255000255255000000255035035000000128128000255255255000170195240000215107000000255255255000000"
74829>>>>>>>>>>>>>Define TH_COLORSCHEMA_BLACK     for "025025025000120120120000255255255255255255255255255255255000025025025000255185255000025025025000140215240000025025025000255108108000025025025000140215240000025025025000187255187000025025025000192192192000025025025000045255255000255255255255255000000000255255255255128128255000255255255255255147147000255255255255192192192000080080080000255255255255192192192000105105105000090090090000255215215000000000000000200225255000255255000000255000000000202255255000025025025000000000170000255190120000025025025000000"
74829>>>>>>>>>>>>>Define TH_COLORSCHEMA_BLUE      for "000000128000000000128000255255255255255255255255255255255000000000128000255070255000000000128000115205235000000000128000255066066000000000128000115205235000000000128000147255147000000000128000190190190000000000128000000164164000255255255255255000000000255255255255166166255000255255255255255176176000255255255255255255255000000000128000255255255255192192192000000128128000090090090000255215215000000000000000200225255000255255000000255035035000179179000000000000128000000128128000255190120000000000128000000"
74829>>>>>>>>>>>>>Define TH_COLORSCHEMA_LIME      for "049060083000069082104000255255255255255255255255255255255000049060083000255138021000049060083000156255000000049060083000249255013000049060083000156255000000049060083000255098255000049060083000180180180000049060083000000189095000255255255255255000000000255255255255171087255000255255255255255072164000255255255255096114145000028038060000255255255255192192192000028038060000070070070000253193220000255026026000049060083000255255000000255035035000000240240000049060083000001001001000255194034000049060083000000"
74829>>>>>>>>>>>>>Define TH_COLORSCHEMA_SERENE    for "025025025000120120120000255255255255255255255255255255255000025025025000255185255000025025025000140215240000025025025000255108108000025025025000140215240000025025025000187255187000025025025000255255000000025025025000000174174000255255255255255000000000255255255255180104255000255255255255128128255000255255255255192192192000080080080000255255255255192192192000105105105000090090090000255215215000000000000000200225255000255255000000255000000000202255255000025025025000000000170000255190120000025025025000000,000000000000001000000001000001000000000000000000000000"
74829>>>>>>>>>>>>>Define TH_COLORSCHEMA_SAHARA    for "255255187000220225240000255255255255255255187000000000000000255255187000255000255000255255187000000000255000255255187000255000000000255255187000000000255000255255187000000128000000255255187000255000128000255255187000000128128000255255187000255000000000255255187000000000255000255255187000128000000000255255187000105105105000190200225000255255255255192192192000220225240000128128128000255215215000000000000000200225255000255255000000255035035000000128128000255255187000170195240000215107000000255255187000000,000000000000000000000000000000000000000000000001000000"
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Font Styles
74829>>>>>>>>>>>>>Define THFS_NORMAL      for 0
74829>>>>>>>>>>>>>Define THFS_BOLD        for 1
74829>>>>>>>>>>>>>Define THFS_ITALICS     for 2
74829>>>>>>>>>>>>>Define THFS_UNDERLINE   for 4
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Editor Colors
74829>>>>>>>>>>>>>Enum_List
74829>>>>>>>>>>>>>    Define EC_WINDOW            // 00
74829>>>>>>>>>>>>>    Define EC_LEFTMARGIN        // 01
74829>>>>>>>>>>>>>    Define EC_BOOKMARK          // 02
74829>>>>>>>>>>>>>    Define EC_TEXT              // 03
74829>>>>>>>>>>>>>    Define EC_NUMBERS           // 04
74829>>>>>>>>>>>>>    Define EC_KEYWORDS          // 05
74829>>>>>>>>>>>>>    Define EC_OPERATORS         // 06
74829>>>>>>>>>>>>>    Define EC_SCOPEKWORDS       // 07
74829>>>>>>>>>>>>>    Define EC_COMMENTS          // 08
74829>>>>>>>>>>>>>    Define EC_STRINGS           // 09
74829>>>>>>>>>>>>>    Define EC_TAGTEXT           // 10
74829>>>>>>>>>>>>>    Define EC_TAGENTITIES       // 11
74829>>>>>>>>>>>>>    Define EC_TAGELEMENT        // 12
74829>>>>>>>>>>>>>    Define EC_TAGATTRIBUTE      // 13
74829>>>>>>>>>>>>>    Define EC_LINENUMBERS       // 14
74829>>>>>>>>>>>>>    Define EC_HDIVLINES         // 15
74829>>>>>>>>>>>>>    Define EC_VDIVLINES         // 16
74829>>>>>>>>>>>>>    Define EC_HLIGHTEDLINE      // 17
74829>>>>>>>>>>>>>    // Scintilla Only
74829>>>>>>>>>>>>>    Define EC_STRINGTYPING      // 18
74829>>>>>>>>>>>>>    Define EC_BRACEHLIGHT       // 19
74829>>>>>>>>>>>>>    Define EC_UNMATCHEDBRACE    // 20
74829>>>>>>>>>>>>>    Define EC_METATAGS          // 21
74829>>>>>>>>>>>>>    Define EC_SELECTION         // 22
74829>>>>>>>>>>>>>    Define EC_PREPROCESSOR      // 23
74829>>>>>>>>>>>>>End_Enum_List
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Struct tColorer
74829>>>>>>>>>>>>>    String  sName       // Color element
74829>>>>>>>>>>>>>    Integer iForeOff    // Front Color Required
74829>>>>>>>>>>>>>    Integer iBackOff    // Back Color Required
74829>>>>>>>>>>>>>    Integer iFont       // Font Allowed
74829>>>>>>>>>>>>>    Integer iStyle      // Font Style
74829>>>>>>>>>>>>>    Integer iCM         // CodeMax Support
74829>>>>>>>>>>>>>    Integer iForeC      // Actual Text Color
74829>>>>>>>>>>>>>    Integer iBackC      // Actual Background Color
74829>>>>>>>>>>>>>    Integer iBold       // Font Bold
74829>>>>>>>>>>>>>    Integer iItalics    // Font Italics
74829>>>>>>>>>>>>>    Integer iUnderline  // Font Underline
74829>>>>>>>>>>>>>End_Struct
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Charset
74829>>>>>>>>>>>>>// Commented out defines are already defined in Font_dlg package
74829>>>>>>>>>>>>>//Define ANSI_CHARSET             for 0
74829>>>>>>>>>>>>>//Define DEFAULT_CHARSET          for 1
74829>>>>>>>>>>>>>//Define SYMBOL_CHARSET           for 2
74829>>>>>>>>>>>>>//Define SHIFTJIS_CHARSET         for 128
74829>>>>>>>>>>>>>Define HANGEUL_CHARSET          for 129
74829>>>>>>>>>>>>>//Define HANGUL_CHARSET           for 129
74829>>>>>>>>>>>>>//Define GB2312_CHARSET           for 134
74829>>>>>>>>>>>>>//Define CHINESEBIG5_CHARSET      for 136
74829>>>>>>>>>>>>>//Define OEM_CHARSET              for 255
74829>>>>>>>>>>>>>Define JOHAB_CHARSET            for 130
74829>>>>>>>>>>>>>Define HEBREW_CHARSET           for 177
74829>>>>>>>>>>>>>Define ARABIC_CHARSET           for 178
74829>>>>>>>>>>>>>Define GREEK_CHARSET            for 161
74829>>>>>>>>>>>>>Define TURKISH_CHARSET          for 162
74829>>>>>>>>>>>>>Define VIETNAMESE_CHARSET       for 163
74829>>>>>>>>>>>>>Define THAI_CHARSET             for 222
74829>>>>>>>>>>>>>Define EASTEUROPE_CHARSET       for 238
74829>>>>>>>>>>>>>Define RUSSIAN_CHARSET          for 204
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Define MAC_CHARSET              for 77
74829>>>>>>>>>>>>>Define BALTIC_CHARSET           for 186
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>tColorer[] gtColorer
74829>>>>>>>>>>>>>tColorer[] gtColorer
74829>>>>>>>>>>>Use Flexml.pkg
Including file: Flexml.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Flexml.pkg)
74829>>>>>>>>>>>>>Use VdfBase.pkg
74829>>>>>>>>>>>>>Use LanguageText.pkg
74829>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Used to designate that a handle is a handle to an Xml Dom object. This
74829>>>>>>>>>>>>>// is used/required by server web-services but could be used elsewhere .
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Types of Nodes
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// classes and methods defined in fmac
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function transformNode Handle infcXSLNode Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// XML function & procedure registration
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Procedure Set XmlInterface Handle iHandle
74829>>>>>>>>>>>>>Register_Function XmlInterface Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// NODE Properties
74829>>>>>>>>>>>>>Register_Function phAttributes Returns Handle
74829>>>>>>>>>>>>>Register_Function psBaseName Returns String
74829>>>>>>>>>>>>>Register_Function phChildNodes Returns Handle
74829>>>>>>>>>>>>>Register_Function phDefinition Returns Handle
74829>>>>>>>>>>>>>Register_Function phFirstChild Returns Handle
74829>>>>>>>>>>>>>Register_Function phLastChild Returns Handle
74829>>>>>>>>>>>>>Register_Function phNextSibling Returns Handle
74829>>>>>>>>>>>>>Register_Function psNameSpaceURI Returns String
74829>>>>>>>>>>>>>Register_Function psNodeName Returns String
74829>>>>>>>>>>>>>Register_Function piNodeType Returns Integer
74829>>>>>>>>>>>>>Register_Function psNodeTypeString Returns String
74829>>>>>>>>>>>>>Register_Function phOwnerDocument Returns Handle
74829>>>>>>>>>>>>>Register_Function phParentNode Returns Handle
74829>>>>>>>>>>>>>Register_Function pbParsed Returns Integer
74829>>>>>>>>>>>>>Register_Function psPrefix Returns String
74829>>>>>>>>>>>>>Register_Function phPreviousSibling Returns Handle
74829>>>>>>>>>>>>>Register_Function pbSpecified Returns Integer
74829>>>>>>>>>>>>>Register_Function psText Returns String
74829>>>>>>>>>>>>>Register_Procedure Set psText String sText
74829>>>>>>>>>>>>>Register_Function psXML Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Node Read write properties
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Procedure Set psDataType String sTypeName
74829>>>>>>>>>>>>>Register_Function psDataType Returns String
74829>>>>>>>>>>>>>Register_Procedure Set pvNodeTypedValue Integer iType Integer iAddress
74829>>>>>>>>>>>>>Register_Function pvNodeTypedValue Integer iType Returns Integer  // address of data
74829>>>>>>>>>>>>>Register_Procedure Set psNodeValue String sValue
74829>>>>>>>>>>>>>Register_Function psNodeValue Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Node Methods
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function AppendChild Handle iChildInfc Returns Handle
74829>>>>>>>>>>>>>Register_Function CloneInfcNode Handle bRecurse Returns Handle
74829>>>>>>>>>>>>>Register_Function HasChildNodes Returns Integer
74829>>>>>>>>>>>>>Register_Function InsertBefore Handle infcNodeToInsert Handle iWhere Returns Handle
74829>>>>>>>>>>>>>Register_Function RemoveChild Handle iChildToRemove Returns Handle
74829>>>>>>>>>>>>>Register_Function ReplaceChild Handle iNewChild Handle iChildToReplace Returns Handle
74829>>>>>>>>>>>>>Register_Function SelectNodes String selectstring Returns Handle
74829>>>>>>>>>>>>>Register_Function SelectSingleNode String selectstring Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Node Collections
74829>>>>>>>>>>>>>// READONLY PROPERTIES
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function phItem Integer iItem Returns Handle
74829>>>>>>>>>>>>>Register_Function phElementItem Integer iItem Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function piLength Returns Integer
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function NamedItem String sName Returns Handle
74829>>>>>>>>>>>>>Register_Function QualifiedItem String sBaseName String sNameSpace Returns Handle
74829>>>>>>>>>>>>>Register_Function RemoveNamedItem String sName Returns Handle
74829>>>>>>>>>>>>>Register_Function RemoveQualifiedItem String sBaseName String sNameSpace Returns Handle
74829>>>>>>>>>>>>>Register_Function SetNamedItem Handle iInterface Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// XML DOM Document
74829>>>>>>>>>>>>>// Read only properties
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function phDocType Returns Handle
74829>>>>>>>>>>>>>Register_Function phImplementation Returns Handle
74829>>>>>>>>>>>>>Register_Function phParseError Returns Handle
74829>>>>>>>>>>>>>Register_Function piReadyState Returns Integer
74829>>>>>>>>>>>>>Register_Function psURL Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Read Write Properties
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Procedure Set pbAsync Integer bValue
74829>>>>>>>>>>>>>Register_Function pbAsync Returns Integer
74829>>>>>>>>>>>>>Register_Procedure Set phDocumentElement Handle iElement
74829>>>>>>>>>>>>>Register_Function phDocumentElement Returns Handle
74829>>>>>>>>>>>>>Register_Procedure Set pbPreserveWhiteSpace Integer bValue
74829>>>>>>>>>>>>>Register_Function pbPreserveWhiteSpace Returns Integer
74829>>>>>>>>>>>>>Register_Procedure Set pbResolveExternals Integer bValue
74829>>>>>>>>>>>>>Register_Function pbResolveExternals Returns Integer
74829>>>>>>>>>>>>>Register_Procedure Set pbValidateOnParse Integer bValue
74829>>>>>>>>>>>>>Register_Function pbValidateOnParse Returns Integer
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Events
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Methods
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function Abort Returns Integer
74829>>>>>>>>>>>>>Register_Function ElementsByTagName String sTagName Returns Handle
74829>>>>>>>>>>>>>Register_Function LoadDocument String sURLName Returns Integer
74829>>>>>>>>>>>>>Register_Function LoadXML String sXMLText Returns Integer
74829>>>>>>>>>>>>>Register_Function NodeFromID String sNodeName Returns Handle
74829>>>>>>>>>>>>>Register_Function SaveDocument String sURLName Returns Integer
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Parse Error
74829>>>>>>>>>>>>>// Read Only Properties
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function piErrorCode Returns Integer
74829>>>>>>>>>>>>>Register_Function piFilePos Returns Integer
74829>>>>>>>>>>>>>Register_Function piLine Returns Integer
74829>>>>>>>>>>>>>Register_Function piLinePos Returns Integer
74829>>>>>>>>>>>>>Register_Function psReason Returns String
74829>>>>>>>>>>>>>Register_Function psSrcText Returns String
74829>>>>>>>>>>>>>Register_Function psURL Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// DOM Implementation
74829>>>>>>>>>>>>>// Method
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function HasFeature String sSystem String sFeature Returns Integer
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Methods
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function substringData Integer iOffset Integer iCount Returns String
74829>>>>>>>>>>>>>Register_Function appendData String sData Returns Handle
74829>>>>>>>>>>>>>Register_Function insertData Integer iOffset String sData Returns Handle
74829>>>>>>>>>>>>>Register_Function deleteData Integer iOffset Integer iCount Returns Handle
74829>>>>>>>>>>>>>Register_Function replaceData Integer iOffset Integer iCount String sData Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Attributes
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function psName Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Elements
74829>>>>>>>>>>>>>// Read Only properties
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function psTagName Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// Methods
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Procedure Set attributeValue String sName String sValue
74829>>>>>>>>>>>>>Register_Function attributeValue String sName Returns String
74829>>>>>>>>>>>>>Register_Function removeAttribute String sName Returns Handle
74829>>>>>>>>>>>>>Register_Function attributeNode String sName Returns Handle
74829>>>>>>>>>>>>>Register_Procedure Set attributeNode Handle iNode Returns Handle
74829>>>>>>>>>>>>>Register_Function removeAttributeNode Handle iNode Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// DOM Text
74829>>>>>>>>>>>>>// Methods
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function splitText Integer iOffset Returns Integer
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// DOM Processing Instruction
74829>>>>>>>>>>>>>// Read Only Properties
74829>>>>>>>>>>>>>Register_Function psTarget Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// DOM Document Type
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function phEntities Returns Handle
74829>>>>>>>>>>>>>Register_Function phNotations Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// DOM Notations
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function psPublicID Returns String
74829>>>>>>>>>>>>>Register_Function psSystemID Returns String
74829>>>>>>>>>>>>>Register_Function psNotationName Returns String
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// create nodes
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function createAttribute String sName Returns Handle
74829>>>>>>>>>>>>>Register_Function createCDataSection String sValue Returns Handle
74829>>>>>>>>>>>>>Register_Function createComment String sValue Returns Handle
74829>>>>>>>>>>>>>Register_Function createDocumentFragment Returns Handle
74829>>>>>>>>>>>>>Register_Function createElement String sTagName Returns Handle
74829>>>>>>>>>>>>>Register_Function createEntityReference String sEntityName Returns Handle
74829>>>>>>>>>>>>>Register_Function createNode Integer iNodeType String sName String sNameSpace Returns Handle
74829>>>>>>>>>>>>>Register_Function createProcessingInstruction String sTarget String sData Returns Handle
74829>>>>>>>>>>>>>Register_Function createTextNode String sData Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>Register_Function ChangeNodeType Integer iTypeOfNode Integer bSetInterface Returns Handle
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>//          Part 1:  Base Document Logic Specialized For Templates
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>//
74829>>>>>>>>>>>>>//  XML Collections
74829>>>>>>>>>>>>>//
74829>>>>>>>>>>>>>//  Collection mixin has common functions to both node lists and named node maps
74829>>>>>>>>>>>>>//
74829>>>>>>>>>>>>>
74829>>>>>>>>>>>>>// This provides functions required of all XMLDOM objects.
74829>>>>>>>>>>>>>//
74829>>>>>>>>>>>>>Class cXMLDOMMixin is a Mixin
74830>>>>>>>>>>>>>    
74830>>>>>>>>>>>>>    // Create an XML object of passed class Id and bind passed interface. returns
74830>>>>>>>>>>>>>    // the object handle. All dynamic XML object can be created using this syntax
74830>>>>>>>>>>>>>    
74830>>>>>>>>>>>>>    Function CreateXMLObject Integer iClassId Handle hinfXMLInterface Returns Handle
74832>>>>>>>>>>>>>        Handle hoId hoDocument
74832>>>>>>>>>>>>>        // We will always create objects at the DOMDocument level.
74832>>>>>>>>>>>>>        Get DocumentObject to hoDocument
74833>>>>>>>>>>>>>        If (hoDocument=0) Begin  // this should never happen.
74835>>>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR C_$XmlFailedNoDocObject
74836>>>>>>>>>>>>>>
74836>>>>>>>>>>>>>            Function_Return 0
74837>>>>>>>>>>>>>        End
74837>>>>>>>>>>>>>>
74837>>>>>>>>>>>>>        If hinfXMLInterface Begin
74839>>>>>>>>>>>>>            Get Create of hoDocument iClassId to hoID
74840>>>>>>>>>>>>>            Set XMLInterface of hoID to hinfXMLInterface
74841>>>>>>>>>>>>>        End
74841>>>>>>>>>>>>>>
74841>>>>>>>>>>>>>        Function_Return hoID
74842>>>>>>>>>>>>>    End_Function
74843>>>>>>>>>>>>>    
74843>>>>>>>>>>>>>    // create an XML Node object based on the interface type.
74843>>>>>>>>>>>>>    // this will convert the interface to the proper type and will create
74843>>>>>>>>>>>>>    // an appropriate DF object.
74843>>>>>>>>>>>>>    // This requires that a DocumentObject exists
74843>>>>>>>>>>>>>    
74843>>>>>>>>>>>>>    Function CreateXMLNode Handle hinfc Returns Handle
74845>>>>>>>>>>>>>        Integer iType iClassId
74845>>>>>>>>>>>>>        Handle  hoDocument hoNode
74845>>>>>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
74845>>>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
74846>>>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
74847>>>>>>>>>>>>>        If (hinfc=0) Begin
74849>>>>>>>>>>>>>            // this should not happen and we would need to know about this.
74849>>>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
74850>>>>>>>>>>>>>>
74850>>>>>>>>>>>>>            Function_Return 0
74851>>>>>>>>>>>>>        End
74851>>>>>>>>>>>>>>
74851>>>>>>>>>>>>>        Get DocumentObject to hoDocument
74852>>>>>>>>>>>>>        // you can augment your class IDs in a single place.
74852>>>>>>>>>>>>>        Get NodeClassId of hoDocument iType to iClassId
74853>>>>>>>>>>>>>        Get CreateXMLObject of hoDocument iClassId hinfc to hoNode
74854>>>>>>>>>>>>>        
74854>>>>>>>>>>>>>        Function_Return hoNode
74855>>>>>>>>>>>>>    End_Function
74856>>>>>>>>>>>>>    
74856>>>>>>>>>>>>>    
74856>>>>>>>>>>>>>    // Change object's class. This let's you change the class id of an object
74856>>>>>>>>>>>>>    // on an object by object basis. This would let you create nodes (e.g. elements)
74856>>>>>>>>>>>>>    // that have a custom interface for each node type. Normally, this would be sent
74856>>>>>>>>>>>>>    // after a node has been created using one of the default classes
74856>>>>>>>>>>>>>    Function ChangeNodeClass Handle hoNode Integer iClassID Returns Handle
74858>>>>>>>>>>>>>        Integer iType
74858>>>>>>>>>>>>>        Handle  hinfcNew
74858>>>>>>>>>>>>>        Get piNodeType of hoNode to iType
74859>>>>>>>>>>>>>        Get ChangeNodeType of hoNode iType False to hInfcNew
74860>>>>>>>>>>>>>        Send Destroy to hoNode // destroy object and old infc handle.
74861>>>>>>>>>>>>>        Get CreateXMLObject iClassId hinfcNew to hoNode
74862>>>>>>>>>>>>>        Function_Return hoNode
74863>>>>>>>>>>>>>    End_Function
74864>>>>>>>>>>>>>    
74864>>>>>>>>>>>>>End_Class
74865>>>>>>>>>>>>>
74865>>>>>>>>>>>>>
74865>>>>>>>>>>>>>Class cXMLDOMCollectionMixin is a Mixin
74866>>>>>>>>>>>>>    
74866>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
74867>>>>>>>>>>>>>    
74867>>>>>>>>>>>>>    //  Returns number of items in the collection
74867>>>>>>>>>>>>>    //
74867>>>>>>>>>>>>>    Function NodeListLength Returns Integer
74869>>>>>>>>>>>>>        Integer iLength
74869>>>>>>>>>>>>>        Get piLength to iLength
74870>>>>>>>>>>>>>        Function_Return iLength
74871>>>>>>>>>>>>>    End_Function
74872>>>>>>>>>>>>>    
74872>>>>>>>>>>>>>    // Returns an XML node object for pass item
74872>>>>>>>>>>>>>    //
74872>>>>>>>>>>>>>    Function CollectionNode Integer I Returns Handle
74874>>>>>>>>>>>>>        Handle hoNewNode
74874>>>>>>>>>>>>>        Handle infcItem
74874>>>>>>>>>>>>>        Get phItem i to infcItem
74875>>>>>>>>>>>>>        If (infcItem) ;            Get CreateXMLNode infcItem to hoNewNode
74878>>>>>>>>>>>>>        Function_Return hoNewNode
74879>>>>>>>>>>>>>    End_Function
74880>>>>>>>>>>>>>    
74880>>>>>>>>>>>>>    
74880>>>>>>>>>>>>>End_Class
74881>>>>>>>>>>>>>
74881>>>>>>>>>>>>>// Simple declarations of collections.
74881>>>>>>>>>>>>>
74881>>>>>>>>>>>>>Class cXMLDOMNodeList is a BaseXmlDomNodeList
74882>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
74883>>>>>>>>>>>>>End_Class
74884>>>>>>>>>>>>>
74884>>>>>>>>>>>>>Class cXMLDOMNamedNodeMap is a BaseXmlDomNamedNodeMap
74885>>>>>>>>>>>>>    
74885>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
74886>>>>>>>>>>>>>    
74886>>>>>>>>>>>>>    // returns a node attribute that matches passed name, zero if none
74886>>>>>>>>>>>>>    Function NamedNode String sName Returns Handle
74888>>>>>>>>>>>>>        Handle hoNewNode
74888>>>>>>>>>>>>>        Handle infcItem
74888>>>>>>>>>>>>>        Get NamedItem sName to infcItem
74889>>>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74892>>>>>>>>>>>>>        Function_Return hoNewNode
74893>>>>>>>>>>>>>    End_Function
74894>>>>>>>>>>>>>    
74894>>>>>>>>>>>>>    // Adds or changes a node attribute
74894>>>>>>>>>>>>>    // This should return the passed object Id which is now bound to the attribute. If an error, returns 0
74894>>>>>>>>>>>>>    Function SetNamedNode Handle hoNode Returns Handle
74896>>>>>>>>>>>>>        Handle hinfcNode hinfcItem
74896>>>>>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode // node of passed attribute
74897>>>>>>>>>>>>>        Get SetNamedItem hinfcNode to hinfcItem
74898>>>>>>>>>>>>>        If hinfcItem ;            Set XMLInterface of hoNode to hinfcItem
74901>>>>>>>>>>>>>        Else ;            Move 0 to hoNode // zero indicates error
74903>>>>>>>>>>>>>        Function_Return hoNode
74904>>>>>>>>>>>>>    End_Function
74905>>>>>>>>>>>>>    
74905>>>>>>>>>>>>>    // removes named attribute, Returns handle of removed node or zero if not found.
74905>>>>>>>>>>>>>    // Note that returned object must be disposed of or moved somewhere else.
74905>>>>>>>>>>>>>    Function RemoveNamedNode String sName Returns Handle
74907>>>>>>>>>>>>>        Handle hoNewNode
74907>>>>>>>>>>>>>        Handle infcItem
74907>>>>>>>>>>>>>        Get RemoveNamedItem sName to infcItem
74908>>>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74911>>>>>>>>>>>>>        Function_Return hoNewNode
74912>>>>>>>>>>>>>    End_Function
74913>>>>>>>>>>>>>    
74913>>>>>>>>>>>>>    Function QualifiedNode String sNameSpace String sBaseName Returns Handle
74915>>>>>>>>>>>>>        Handle hoNewNode
74915>>>>>>>>>>>>>        Handle infcItem
74915>>>>>>>>>>>>>        Get QualifiedItem  sBaseName sNameSpace  to infcItem
74916>>>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74919>>>>>>>>>>>>>        Function_Return hoNewNode
74920>>>>>>>>>>>>>    End_Function
74921>>>>>>>>>>>>>    
74921>>>>>>>>>>>>>    Function RemoveQualifiedNode String sNameSpace String sBaseName Returns Handle
74923>>>>>>>>>>>>>        Handle hoNewNode
74923>>>>>>>>>>>>>        Handle infcItem
74923>>>>>>>>>>>>>        Get RemoveQualifiedItem sBaseName sNameSpace to infcItem
74924>>>>>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
74927>>>>>>>>>>>>>        Function_Return hoNewNode
74928>>>>>>>>>>>>>    End_Function
74929>>>>>>>>>>>>>    
74929>>>>>>>>>>>>>End_Class
74930>>>>>>>>>>>>>
74930>>>>>>>>>>>>>
74930>>>>>>>>>>>>>
74930>>>>>>>>>>>>>// Mixin for nodes.
74930>>>>>>>>>>>>>//
74930>>>>>>>>>>>>>//  First the declaration of functions that have no object references.
74930>>>>>>>>>>>>>//
74930>>>>>>>>>>>>>
74930>>>>>>>>>>>>>
74930>>>>>>>>>>>>>Class cXMLDOMNodeMixin is a Mixin
74931>>>>>>>>>>>>>    
74931>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
74932>>>>>>>>>>>>>    
74932>>>>>>>>>>>>>    //  Append Node to the end of list. Returns passed Object handle if Ok, 0 if error
74932>>>>>>>>>>>>>    
74932>>>>>>>>>>>>>    Function AppendNode Handle hoNode Returns Handle
74934>>>>>>>>>>>>>        Handle hinfcNode
74934>>>>>>>>>>>>>        Handle infcReturned
74934>>>>>>>>>>>>>        // Get COM Interface to call Append child.
74934>>>>>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode
74935>>>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74938>>>>>>>>>>>>>        Get AppendChild hinfcNode to infcReturned
74939>>>>>>>>>>>>>        // Interface returned is stored in DataFlex object.
74939>>>>>>>>>>>>>        If (infcReturned=0) ;            Function_Return 0
74942>>>>>>>>>>>>>        Set XMLInterface of hoNode to infcReturned
74943>>>>>>>>>>>>>        Function_Return hoNode
74944>>>>>>>>>>>>>    End_Function
74945>>>>>>>>>>>>>    
74945>>>>>>>>>>>>>    //  Insert NewNode before Node. Returns passed newnode Object handle if Ok, 0 if error
74945>>>>>>>>>>>>>    
74945>>>>>>>>>>>>>    Function InsertBeforeNode Handle hoNewNode Handle hoNode Returns Handle
74947>>>>>>>>>>>>>        Handle hinfcNewNode hinfcNode hoRefNode infcReturned
74947>>>>>>>>>>>>>        Integer iType
74947>>>>>>>>>>>>>        // DOM says if no refnode argument passed or it is 0, append to end
74947>>>>>>>>>>>>>        If (Num_Arguments=1) ;            Move 0 to hoRefNode
74950>>>>>>>>>>>>>        Else ;            Move hoNode to hoRefNode
74952>>>>>>>>>>>>>        Get XMLInterface of hoNewNode to hinfcNewNode
74953>>>>>>>>>>>>>        If (hinfcNewNode=0) ;            Function_Return 0
74956>>>>>>>>>>>>>        If hoRefNode Begin
74958>>>>>>>>>>>>>            Get XMLInterface of hoRefNode to hinfcNode
74959>>>>>>>>>>>>>            If (hinfcNode=0) ;                Function_Return 0
74962>>>>>>>>>>>>>        End
74962>>>>>>>>>>>>>>
74962>>>>>>>>>>>>>        Get InsertBefore hinfcNewNode hinfcNode to infcReturned
74963>>>>>>>>>>>>>        If (infcReturned=0) ;            Function_Return 0
74966>>>>>>>>>>>>>        // Interface returned is stored in DataFlex object.
74966>>>>>>>>>>>>>        Set XMLInterface of hoNewNode to infcReturned
74967>>>>>>>>>>>>>        Function_Return hoNewNode
74968>>>>>>>>>>>>>    End_Function
74969>>>>>>>>>>>>>    
74969>>>>>>>>>>>>>    //  Remove Node. Returns object Id of removed node, zero if error
74969>>>>>>>>>>>>>    //  Important: The node is not destroyed! This lets you move it elsewhere if you want
74969>>>>>>>>>>>>>    
74969>>>>>>>>>>>>>    Function RemoveNode Handle hoNode Returns Handle
74971>>>>>>>>>>>>>        Handle hInfcNode
74971>>>>>>>>>>>>>        Get XMLInterface of hoNode to hInfcNode
74972>>>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74975>>>>>>>>>>>>>        Get RemoveChild hInfcNode to hinfcNode
74976>>>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74979>>>>>>>>>>>>>        Set XMLInterface of hoNode to hinfcNode
74980>>>>>>>>>>>>>        Function_Return hoNode
74981>>>>>>>>>>>>>    End_Function
74982>>>>>>>>>>>>>    
74982>>>>>>>>>>>>>    //  Replace Node. Returns object Id of replaced node, zero if error
74982>>>>>>>>>>>>>    //  Important: The replaced node is not destroyed! This lets you move it elsewhere if you want
74982>>>>>>>>>>>>>    
74982>>>>>>>>>>>>>    Function ReplaceNode Handle hoNewNode Handle hoNodeToReplace Returns Handle
74984>>>>>>>>>>>>>        Handle hInfcNewNode hinfcNodetoReplace hinfcNode
74984>>>>>>>>>>>>>        Get XMLInterface of hoNewNode       to hInfcNewNode
74985>>>>>>>>>>>>>        Get XMLInterface of hoNodetoReplace to hInfcNodetoreplace
74986>>>>>>>>>>>>>        If (hinfcNewNode=0 or hInfcNodeToReplace=0) ;            Function_Return 0
74989>>>>>>>>>>>>>        Get ReplaceChild hInfcNewNode hinfcNodeToReplace to hinfcNode
74990>>>>>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
74993>>>>>>>>>>>>>        Set XMLInterface of hoNodetoReplace to hinfcNode
74994>>>>>>>>>>>>>        Function_Return hoNodetoReplace
74995>>>>>>>>>>>>>    End_Function
74996>>>>>>>>>>>>>    
74996>>>>>>>>>>>>>    // Remove the named node. Returns handle to removed node. You must destroy
74996>>>>>>>>>>>>>    // or move this removed object as needed
74996>>>>>>>>>>>>>    
74996>>>>>>>>>>>>>    Function RemoveNamedNode String sQueryString Returns Handle
74998>>>>>>>>>>>>>        Handle hoNode
74998>>>>>>>>>>>>>        Handle hInfcTemplate hinfcNode
74998>>>>>>>>>>>>>        Integer iRet
74998>>>>>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcTemplate
74999>>>>>>>>>>>>>        If (hinfcTemplate) Begin
75001>>>>>>>>>>>>>            // Remove child returns an interface to the disassociated node.
75001>>>>>>>>>>>>>            // It should be disposed by setting it to an object and then calling destroy
75001>>>>>>>>>>>>>            Get RemoveChild hInfcTemplate to hInfcNode
75002>>>>>>>>>>>>>            // Even if hInfcTemplate and hInfcNode are the same their reference count will be incremented.
75002>>>>>>>>>>>>>            // Therefore we must destroy one the interfaces which will decrement the reference count thus
75002>>>>>>>>>>>>>            // avoding a memory leak
75002>>>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, DESTROY_XML_INTERFACE, hInfcTemplate, 0, 0, 0, 0)) to iRet
75003>>>>>>>>>>>>>            If hInfcNode ;                Get CreateXMLNode hinfcNode to hoNode
75006>>>>>>>>>>>>>        End
75006>>>>>>>>>>>>>>
75006>>>>>>>>>>>>>        Function_Return hoNode
75007>>>>>>>>>>>>>    End_Function
75008>>>>>>>>>>>>>    
75008>>>>>>>>>>>>>    // This function creates a clone of the passed Node. if bRecurse all child nodes are also
75008>>>>>>>>>>>>>    // cloned. The object Id of the new clone object is returned.
75008>>>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
75008>>>>>>>>>>>>>    // the node to the XML Document.
75008>>>>>>>>>>>>>    
75008>>>>>>>>>>>>>    Function CloneNode Integer bRecurse Returns Handle
75010>>>>>>>>>>>>>        Handle hoNewNode
75010>>>>>>>>>>>>>        Handle hinfcNewNode
75010>>>>>>>>>>>>>        Get CloneInfcNode (If(bRecurse,-1,0)) to hinfcNewNode
75011>>>>>>>>>>>>>        If hinfcNewNode ;            Get CreateXMLNode hinfcNewNode to hoNewNode
75014>>>>>>>>>>>>>        Function_Return hoNewNode
75015>>>>>>>>>>>>>    End_Function
75016>>>>>>>>>>>>>    
75016>>>>>>>>>>>>>    //  Create a collection of all nodes. returns handle of a cXMLDomNodeList
75016>>>>>>>>>>>>>    
75016>>>>>>>>>>>>>    Function ChildNodes Returns Handle
75018>>>>>>>>>>>>>        Handle infcNodeList
75018>>>>>>>>>>>>>        Handle hoNodeList
75018>>>>>>>>>>>>>        Get phChildNodes to infcNodeList
75019>>>>>>>>>>>>>        If (infcNodeList) ;            Get CreateXMLObject U_cXMLDOMNodeList infcNodeList to hoNodeList
75022>>>>>>>>>>>>>        Function_Return hoNodeList
75023>>>>>>>>>>>>>    End_Function
75024>>>>>>>>>>>>>    
75024>>>>>>>>>>>>>    //  Create a collection of all attributes. returns handle of a cXMLDomNodeMapList
75024>>>>>>>>>>>>>    
75024>>>>>>>>>>>>>    Function AttributeNodes Returns Handle
75026>>>>>>>>>>>>>        Handle hoCollectionId   // Object to hold collection
75026>>>>>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
75026>>>>>>>>>>>>>        Get phAttributes to hinfcAttributes
75027>>>>>>>>>>>>>        If (hinfcAttributes) ;            Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcAttributes to hoCollectionId
75030>>>>>>>>>>>>>        Function_Return hoCollectionId
75031>>>>>>>>>>>>>    End_Function
75032>>>>>>>>>>>>>    
75032>>>>>>>>>>>>>    //  Create a collection of all attributes for the temporary attribute node object.
75032>>>>>>>>>>>>>    //  Using this saves a small amount of time creating and destroying this object but
75032>>>>>>>>>>>>>    //  it must be used with care. This binding is temporary!
75032>>>>>>>>>>>>>    Function TempAttributeNodes Returns Handle
75034>>>>>>>>>>>>>        Handle hoCollectionId hoDocument
75034>>>>>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
75034>>>>>>>>>>>>>        Get phAttributes to hinfcAttributes
75035>>>>>>>>>>>>>        If (hinfcAttributes) Begin
75037>>>>>>>>>>>>>            Get DocumentObject to hoDocument
75038>>>>>>>>>>>>>            Get phoTempDomNodeMap of hoDocument to hoCollectionId
75039>>>>>>>>>>>>>            Set XMLInterface of hoCollectionId to hinfcAttributes
75040>>>>>>>>>>>>>        End
75040>>>>>>>>>>>>>>
75040>>>>>>>>>>>>>        Function_Return hoCollectionId
75041>>>>>>>>>>>>>    End_Function
75042>>>>>>>>>>>>>    
75042>>>>>>>>>>>>>    
75042>>>>>>>>>>>>>    // Returns a collection of just elements
75042>>>>>>>>>>>>>    
75042>>>>>>>>>>>>>    Function ElementNodes String sQueryString Returns Handle
75044>>>>>>>>>>>>>        Handle hoNodeList
75044>>>>>>>>>>>>>        Handle hinfcNodeList
75044>>>>>>>>>>>>>        Get ElementsByTagName sQueryString to hinfcNodeList
75045>>>>>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
75048>>>>>>>>>>>>>        Function_Return hoNodeList
75049>>>>>>>>>>>>>    End_Function
75050>>>>>>>>>>>>>    
75050>>>>>>>>>>>>>    
75050>>>>>>>>>>>>>    
75050>>>>>>>>>>>>>    // Return object handle for query.
75050>>>>>>>>>>>>>    
75050>>>>>>>>>>>>>    Function FindNode String sQueryString Returns Handle
75052>>>>>>>>>>>>>        Handle hoNode
75052>>>>>>>>>>>>>        Handle hinfcNode
75052>>>>>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcNode
75053>>>>>>>>>>>>>        If (hinfcNode <> 0) ;            Get CreateXMLNode hInfcNode to hoNode
75056>>>>>>>>>>>>>        Function_Return hoNode
75057>>>>>>>>>>>>>    End_Function
75058>>>>>>>>>>>>>    
75058>>>>>>>>>>>>>    // Return object handle for a collection node.
75058>>>>>>>>>>>>>    
75058>>>>>>>>>>>>>    
75058>>>>>>>>>>>>>    Function FindNodeList String sQueryString Returns Handle
75060>>>>>>>>>>>>>        Handle hoNodeList
75060>>>>>>>>>>>>>        Handle hinfcNodeList
75060>>>>>>>>>>>>>        Get SelectNodes sQueryString to hinfcNodeList
75061>>>>>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
75064>>>>>>>>>>>>>        Function_Return hoNodeList
75065>>>>>>>>>>>>>    End_Function
75066>>>>>>>>>>>>>    
75066>>>>>>>>>>>>>    // The CreatexxxxxNode messages creates an node object for the type specified. Both
75066>>>>>>>>>>>>>    // the interface and the object or of the correct type (i.e. element, comment)
75066>>>>>>>>>>>>>    // These all return an object handle which can be used to place the object via
75066>>>>>>>>>>>>>    // appendNode or InsertBeforeNode
75066>>>>>>>>>>>>>    
75066>>>>>>>>>>>>>    // This function creates a child element, returning a dataflex object.
75066>>>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
75066>>>>>>>>>>>>>    // the element to the XML Document.
75066>>>>>>>>>>>>>    
75066>>>>>>>>>>>>>    Function CreateElementNode String sTagName String sValue Returns Handle
75068>>>>>>>>>>>>>        Handle hoNewElement
75068>>>>>>>>>>>>>        Handle hoDocumentObject
75068>>>>>>>>>>>>>        Handle infcNewElement
75068>>>>>>>>>>>>>        Integer iClassId
75068>>>>>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
75068>>>>>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
75068>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75069>>>>>>>>>>>>>        Get createElement of hoDocumentObject sTagName to infcNewElement
75070>>>>>>>>>>>>>        If infcNewElement Begin // if there was an error, no infc handle would be returned
75072>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ELEMENT to iClassId
75073>>>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewElement to hoNewElement
75074>>>>>>>>>>>>>            If hoNewElement ; // very unlikely this will be zero                Set psText of hoNewElement to sValue
75077>>>>>>>>>>>>>        End
75077>>>>>>>>>>>>>>
75077>>>>>>>>>>>>>        Function_Return hoNewElement
75078>>>>>>>>>>>>>    End_Function
75079>>>>>>>>>>>>>    
75079>>>>>>>>>>>>>    // This function creates an attribute in a document. Attributes are _NOT_ children of an element.
75079>>>>>>>>>>>>>    // A DataFlex object is returned. An attribute can be added to an xml document using
75079>>>>>>>>>>>>>    // get AddAttributeNode.
75079>>>>>>>>>>>>>    
75079>>>>>>>>>>>>>    Function CreateAttributeNode String sName String sValue Returns Handle
75081>>>>>>>>>>>>>        Handle hoNewAttribute
75081>>>>>>>>>>>>>        Handle hoDocumentObject
75081>>>>>>>>>>>>>        Handle infcNewAttribute
75081>>>>>>>>>>>>>        Integer iClassId
75081>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75082>>>>>>>>>>>>>        // Create an Attribute in the document and assign its interface to the new DF object.
75082>>>>>>>>>>>>>        Get createAttribute of hoDocumentObject sName to infcNewAttribute
75083>>>>>>>>>>>>>        If infcNewAttribute Begin // if there was an error, no infc handle would be returned
75085>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ATTRIBUTE to iClassId
75086>>>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewAttribute to hoNewAttribute
75087>>>>>>>>>>>>>            // Set the value of the attribute.
75087>>>>>>>>>>>>>            If hoNewAttribute ; // very unlikely this will be 0                Set psText of hoNewAttribute to sValue
75090>>>>>>>>>>>>>        End
75090>>>>>>>>>>>>>>
75090>>>>>>>>>>>>>        Function_Return hoNewAttribute
75091>>>>>>>>>>>>>    End_Function
75092>>>>>>>>>>>>>    
75092>>>>>>>>>>>>>    // This function creates a child comment, returning a dataflex object.
75092>>>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
75092>>>>>>>>>>>>>    // the comment to the XML Document.
75092>>>>>>>>>>>>>    
75092>>>>>>>>>>>>>    Function CreateChildComment String sValue Returns Handle
75094>>>>>>>>>>>>>        Handle hoNewComment
75094>>>>>>>>>>>>>        Handle hoDocumentObject
75094>>>>>>>>>>>>>        Handle infcNewComment
75094>>>>>>>>>>>>>        Integer iClassID
75094>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75095>>>>>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
75095>>>>>>>>>>>>>        Get createComment of hoDocumentObject sValue to infcNewComment
75096>>>>>>>>>>>>>        If infcNewComment Begin // if there was an error, no infc handle would be returned
75098>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_COMMENT to iClassId
75099>>>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewComment to hoNewComment
75100>>>>>>>>>>>>>            If hoNewComment ; // very unlikely this will be 0                Set psText of hoNewComment to sValue
75103>>>>>>>>>>>>>        End
75103>>>>>>>>>>>>>>
75103>>>>>>>>>>>>>        Function_Return hoNewComment
75104>>>>>>>>>>>>>    End_Function
75105>>>>>>>>>>>>>    
75105>>>>>>>>>>>>>    // This function creates a child processing instruction, returning a dataflex object.
75105>>>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
75105>>>>>>>>>>>>>    // the processing instruction to the XML Document.
75105>>>>>>>>>>>>>    
75105>>>>>>>>>>>>>    Function CreateChildProcessingInstruction String sTarget String sValue Returns Handle
75107>>>>>>>>>>>>>        Handle hoNewProcessingInstruction
75107>>>>>>>>>>>>>        Handle hoDocumentObject
75107>>>>>>>>>>>>>        Handle infcNewProcessingInstruction
75107>>>>>>>>>>>>>        Integer iClassID
75107>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75108>>>>>>>>>>>>>        // Create an ProcessingInstruction in the document and assign its interface to the new DF object.
75108>>>>>>>>>>>>>        Get createProcessingInstruction of hoDocumentObject sTarget sValue to infcNewProcessingInstruction
75109>>>>>>>>>>>>>        If infcNewProcessingInstruction  Begin // if there was an error, no infc handle would be returned
75111>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_PROCESSING_INSTRUCTION to iClassId
75112>>>>>>>>>>>>>            Get CreateXMLObject iClassID infcNewProcessingInstruction to hoNewProcessingInstruction
75113>>>>>>>>>>>>>        End
75113>>>>>>>>>>>>>>
75113>>>>>>>>>>>>>        Function_Return hoNewProcessingInstruction
75114>>>>>>>>>>>>>    End_Function
75115>>>>>>>>>>>>>    
75115>>>>>>>>>>>>>    // This function creates a child text node, returning a dataflex object.
75115>>>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
75115>>>>>>>>>>>>>    // the text node to the XML Document.
75115>>>>>>>>>>>>>    
75115>>>>>>>>>>>>>    Function CreateChildTextNode String sValue Returns Handle
75117>>>>>>>>>>>>>        Handle hoNewTextNode
75117>>>>>>>>>>>>>        Handle hoDocumentObject
75117>>>>>>>>>>>>>        Handle infcNewTextNode
75117>>>>>>>>>>>>>        Integer iClassID
75117>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75118>>>>>>>>>>>>>        // Create an TextNode in the document and assign its interface to the new DF object.
75118>>>>>>>>>>>>>        Get createTextNode of hoDocumentObject sValue to infcNewTextNode
75119>>>>>>>>>>>>>        If infcNewTextNode Begin // if there was an error, no infc handle would be returned
75121>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_TEXT to iClassId
75122>>>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewTextNode to hoNewTextNode
75123>>>>>>>>>>>>>        End
75123>>>>>>>>>>>>>>
75123>>>>>>>>>>>>>        Function_Return hoNewTextNode
75124>>>>>>>>>>>>>    End_Function
75125>>>>>>>>>>>>>    
75125>>>>>>>>>>>>>    // This function creates a cdata text node, returning a dataflex object.
75125>>>>>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
75125>>>>>>>>>>>>>    // the cdata node to the XML Document.
75125>>>>>>>>>>>>>    
75125>>>>>>>>>>>>>    Function CreateCDATASectionNode String sValue Returns Handle
75127>>>>>>>>>>>>>        Handle hoNewNode
75127>>>>>>>>>>>>>        Handle hoDocumentObject
75127>>>>>>>>>>>>>        Handle infcNewNode
75127>>>>>>>>>>>>>        Integer iClassId
75127>>>>>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
75127>>>>>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
75127>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75128>>>>>>>>>>>>>        Get createCDATASection of hoDocumentObject sValue to infcNewNode
75129>>>>>>>>>>>>>        If infcNewNode Begin
75131>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_CDATA_SECTION to iClassId
75132>>>>>>>>>>>>>            Get CreateXMLObject iClassId infcNewNode to hoNewNode
75133>>>>>>>>>>>>>        End
75133>>>>>>>>>>>>>>
75133>>>>>>>>>>>>>        Function_Return hoNewNode
75134>>>>>>>>>>>>>    End_Function
75135>>>>>>>>>>>>>    
75135>>>>>>>>>>>>>    // Create a document fragment.  Document fragments can be used to house nodes temporarily. When
75135>>>>>>>>>>>>>    // You append or insert a document fragment (appendNode InsertBeforeNode) child nodes are appended
75135>>>>>>>>>>>>>    // to the destination object and not the fragment node itself. This is useful!
75135>>>>>>>>>>>>>    
75135>>>>>>>>>>>>>    Function CreateDocumentFragmentNode Returns Handle
75137>>>>>>>>>>>>>        Handle hoNew
75137>>>>>>>>>>>>>        Handle hoDocumentObject
75137>>>>>>>>>>>>>        Handle infcNew
75137>>>>>>>>>>>>>        Integer iClassID
75137>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75138>>>>>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
75138>>>>>>>>>>>>>        Get createDocumentFragment of hoDocumentObject to infcNew
75139>>>>>>>>>>>>>        If infcNew Begin // if there was an error, no infc handle would be returned
75141>>>>>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_DOCUMENT_FRAGMENT to iClassId
75142>>>>>>>>>>>>>            Get CreateXMLObject iClassId infcNew to hoNew
75143>>>>>>>>>>>>>        End
75143>>>>>>>>>>>>>>
75143>>>>>>>>>>>>>        Function_Return hoNew
75144>>>>>>>>>>>>>    End_Function
75145>>>>>>>>>>>>>    
75145>>>>>>>>>>>>>    //  Create a Node of any passed Type (e.g. Node_element). Normally you don't need this as there are
75145>>>>>>>>>>>>>    //  specific messages to do this for each node type. Node that this lets you pass namespaces as a separate
75145>>>>>>>>>>>>>    //  parameter. With all of the other messages (e.g. createElementNode) you pass namespaces as prefixed to
75145>>>>>>>>>>>>>    // the tagname (e.g. Get CreateElementNode "MyNameSpace:MyTag" "MyValue" to hoEle)
75145>>>>>>>>>>>>>    
75145>>>>>>>>>>>>>    Function CreateChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
75147>>>>>>>>>>>>>        Handle hoNewNode hoDocumentObject
75147>>>>>>>>>>>>>        Handle infcNewNode
75147>>>>>>>>>>>>>        Integer iClassid iType
75147>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75148>>>>>>>>>>>>>        Get NodeClassId iNodeType to iClassId
75149>>>>>>>>>>>>>        If (iClassId<>0) Begin
75151>>>>>>>>>>>>>            // Create a node in the document and assign its interface to the new DF object.
75151>>>>>>>>>>>>>            Get createNode of hoDocumentObject iNodeType sTagName sNameSpace to infcNewNode
75152>>>>>>>>>>>>>            // this is required to force the interface type to be correct.
75152>>>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, infcNewNode, 0, 0, 0, 0)) to iType
75153>>>>>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, infcNewNode, iType, 1, 0, 0)) to infcNewNode
75154>>>>>>>>>>>>>            
75154>>>>>>>>>>>>>            If infcNewNode ;                Get CreateXMLObject iClassId infcNewNode to hoNewNode
75157>>>>>>>>>>>>>        End
75157>>>>>>>>>>>>>>
75157>>>>>>>>>>>>>        Function_Return hoNewNode
75158>>>>>>>>>>>>>    End_Function
75159>>>>>>>>>>>>>    
75159>>>>>>>>>>>>>    
75159>>>>>>>>>>>>>    
75159>>>>>>>>>>>>>    // The Addxxxxx messages create a new node and appends it to the list. When used as a function,
75159>>>>>>>>>>>>>    // the object handle is returned and must be disposed of later by the programmer.
75159>>>>>>>>>>>>>    // When used as a procedure, the object is destroyed--it just does it and is done.
75159>>>>>>>>>>>>>    
75159>>>>>>>>>>>>>    Function AddElement String sTagName String sValue Returns Handle
75161>>>>>>>>>>>>>        Handle hoNewElement
75161>>>>>>>>>>>>>        Get CreateElementNode sTagName sValue to hoNewElement
75162>>>>>>>>>>>>>        If hoNewElement ;            Get AppendNode hoNewElement to hoNewElement
75165>>>>>>>>>>>>>        Function_Return hoNewElement
75166>>>>>>>>>>>>>    End_Function
75167>>>>>>>>>>>>>    
75167>>>>>>>>>>>>>    Procedure AddElement String sTagName String sValue
75169>>>>>>>>>>>>>        Handle hoNewElement
75169>>>>>>>>>>>>>        Get AddElement sTagName sValue to hoNewElement
75170>>>>>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
75173>>>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElement"))
75175>>>>>>>>>>>>>    End_Procedure
75176>>>>>>>>>>>>>    
75176>>>>>>>>>>>>>    // this returns the object, This is often needed
75176>>>>>>>>>>>>>    Function CreateElementNodeNS String sNameSpace String sTagName String sValue Returns Handle
75178>>>>>>>>>>>>>        Handle hoNewElement
75178>>>>>>>>>>>>>        Get CreateChildNode NODE_ELEMENT sTagName sNameSpace to hoNewElement
75179>>>>>>>>>>>>>        If (hoNewElement and sValue<>"") ;            Set psText of hoNewElement to sValue
75182>>>>>>>>>>>>>        Function_Return hoNewElement
75183>>>>>>>>>>>>>    End_Function
75184>>>>>>>>>>>>>    
75184>>>>>>>>>>>>>    
75184>>>>>>>>>>>>>    // this returns the object, This is often needed
75184>>>>>>>>>>>>>    Function AddElementNS String sNameSpace String sTagName String sValue Returns Handle
75186>>>>>>>>>>>>>        Handle hoNewElement
75186>>>>>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName sValue to hoNewElement
75187>>>>>>>>>>>>>        If hoNewElement Begin
75189>>>>>>>>>>>>>            Get AppendNode hoNewElement to hoNewElement
75190>>>>>>>>>>>>>        End
75190>>>>>>>>>>>>>>
75190>>>>>>>>>>>>>        Function_Return hoNewElement
75191>>>>>>>>>>>>>    End_Function
75192>>>>>>>>>>>>>    
75192>>>>>>>>>>>>>    Procedure AddElementNS String sNameSpace String sTagName String sValue
75194>>>>>>>>>>>>>        Handle hoNewElement
75194>>>>>>>>>>>>>        Get AddElementNS sNameSpace sTagName sValue to hoNewElement
75195>>>>>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
75198>>>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElementNS"))
75200>>>>>>>>>>>>>    End_Procedure
75201>>>>>>>>>>>>>    
75201>>>>>>>>>>>>>    Function AddAttributeNode Handle hoNode Returns Handle
75203>>>>>>>>>>>>>        Handle hInfc
75203>>>>>>>>>>>>>        Get Set_AttributeNode (XmlInterface(hoNode)) to hInfc
75204>>>>>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Set XmlInterface of hoNode to hInfc
75207>>>>>>>>>>>>>        Function_Return hoNode
75208>>>>>>>>>>>>>    End_Function
75209>>>>>>>>>>>>>    
75209>>>>>>>>>>>>>    Function AttributeValueNode String sName Returns Handle
75211>>>>>>>>>>>>>        Handle hInfc
75211>>>>>>>>>>>>>        Handle hoNode
75211>>>>>>>>>>>>>        Get AttributeNode sName to hInfc
75212>>>>>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Get CreateXMLNode hInfc to hoNode
75215>>>>>>>>>>>>>        Function_Return hoNode
75216>>>>>>>>>>>>>    End_Function
75217>>>>>>>>>>>>>    
75217>>>>>>>>>>>>>    Function AttributeValueNodeNS String sNameSpace String sBaseName Returns Handle
75219>>>>>>>>>>>>>        Handle hoAttrs hoAttr
75219>>>>>>>>>>>>>        String sValue
75219>>>>>>>>>>>>>        Get TempAttributeNodes to hoAttrs
75220>>>>>>>>>>>>>        If hoAttrs Begin
75222>>>>>>>>>>>>>            Get QualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
75223>>>>>>>>>>>>>            Set XMLInterface of hoAttrs to 0
75224>>>>>>>>>>>>>        End
75224>>>>>>>>>>>>>>
75224>>>>>>>>>>>>>        Function_Return hoAttr
75225>>>>>>>>>>>>>    End_Function
75226>>>>>>>>>>>>>    
75226>>>>>>>>>>>>>    
75226>>>>>>>>>>>>>    Function CreateAttributeNodeNS String sNameSpace String sName String sValue Returns Handle
75228>>>>>>>>>>>>>        Handle hoNewAttribute
75228>>>>>>>>>>>>>        Get CreateChildNode NODE_ATTRIBUTE sName sNameSpace to hoNewAttribute
75229>>>>>>>>>>>>>        If hoNewAttribute ;            Set psText of hoNewAttribute to sValue
75232>>>>>>>>>>>>>        Function_Return hoNewAttribute
75233>>>>>>>>>>>>>    End_Function
75234>>>>>>>>>>>>>    
75234>>>>>>>>>>>>>    Procedure AddAttributeNS String sNameSpace String sName String sValue
75236>>>>>>>>>>>>>        Handle hoNode
75236>>>>>>>>>>>>>        Get CreateAttributeNodeNS sNameSpace sName sValue to hoNode
75237>>>>>>>>>>>>>        If hoNode Begin
75239>>>>>>>>>>>>>            Get AddAttributeNode hoNode to hoNode
75240>>>>>>>>>>>>>            If hoNode ;                Send Destroy of hoNode
75243>>>>>>>>>>>>>        End
75243>>>>>>>>>>>>>>
75243>>>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddAttributeNS"))
75245>>>>>>>>>>>>>    End_Procedure
75246>>>>>>>>>>>>>    
75246>>>>>>>>>>>>>    
75246>>>>>>>>>>>>>    // This function encapsulates creation and addition of attributes to a node.
75246>>>>>>>>>>>>>    // should only work with element class
75246>>>>>>>>>>>>>    Procedure AddAttribute String sName String sValue
75248>>>>>>>>>>>>>        Set AttributeValue sName to sValue
75249>>>>>>>>>>>>>    End_Procedure
75250>>>>>>>>>>>>>    
75250>>>>>>>>>>>>>    // This function encapsulates creation and addition of comments to a node.
75250>>>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
75250>>>>>>>>>>>>>    
75250>>>>>>>>>>>>>    Procedure AddChildComment String sValue
75252>>>>>>>>>>>>>        Handle hoNewNode
75252>>>>>>>>>>>>>        Get createChildComment sValue to hoNewNode
75253>>>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildComment"))
75256>>>>>>>>>>>>>        Else Begin
75257>>>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
75258>>>>>>>>>>>>>            Send Destroy to hoNewNode
75259>>>>>>>>>>>>>        End
75259>>>>>>>>>>>>>>
75259>>>>>>>>>>>>>    End_Procedure
75260>>>>>>>>>>>>>    
75260>>>>>>>>>>>>>    // This function encapsulates creation and addition of processing instructions to a node.
75260>>>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
75260>>>>>>>>>>>>>    
75260>>>>>>>>>>>>>    Procedure AddChildProcessingInstruction String sTarget String sValue
75262>>>>>>>>>>>>>        Handle hoNewNode
75262>>>>>>>>>>>>>        Get createChildProcessingInstruction sTarget sValue to hoNewNode
75263>>>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildProcessingInstruction"))
75266>>>>>>>>>>>>>        Else Begin
75267>>>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
75268>>>>>>>>>>>>>            Send Destroy to hoNewNode
75269>>>>>>>>>>>>>        End
75269>>>>>>>>>>>>>>
75269>>>>>>>>>>>>>    End_Procedure
75270>>>>>>>>>>>>>    
75270>>>>>>>>>>>>>    
75270>>>>>>>>>>>>>    // This function encapsulates creation and addition of text nodes to a node.
75270>>>>>>>>>>>>>    // The return value is a Boolean that is currently unused.
75270>>>>>>>>>>>>>    
75270>>>>>>>>>>>>>    Procedure AddChildTextNode String sValue
75272>>>>>>>>>>>>>        Handle hoNewNode
75272>>>>>>>>>>>>>        Get createChildTextNode sValue to hoNewNode
75273>>>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildTextNode"))
75276>>>>>>>>>>>>>        Else Begin
75277>>>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
75278>>>>>>>>>>>>>            Send Destroy to hoNewNode
75279>>>>>>>>>>>>>        End
75279>>>>>>>>>>>>>>
75279>>>>>>>>>>>>>    End_Procedure
75280>>>>>>>>>>>>>    
75280>>>>>>>>>>>>>    // This procedure encapsulates creation and addition of cdata text nodes to a node.
75280>>>>>>>>>>>>>    Procedure AddCDataSection String sValue
75282>>>>>>>>>>>>>        Handle hoNewNode
75282>>>>>>>>>>>>>        Get CreateCDATASectionNode sValue to hoNewNode
75283>>>>>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddCDataSection"))
75286>>>>>>>>>>>>>        Else Begin
75287>>>>>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
75288>>>>>>>>>>>>>            Send Destroy to hoNewNode
75289>>>>>>>>>>>>>        End
75289>>>>>>>>>>>>>>
75289>>>>>>>>>>>>>    End_Procedure
75290>>>>>>>>>>>>>    
75290>>>>>>>>>>>>>    
75290>>>>>>>>>>>>>    Function AddChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
75292>>>>>>>>>>>>>        Handle hoNewNode
75292>>>>>>>>>>>>>        Handle hoDocumentObject
75292>>>>>>>>>>>>>        Get DocumentObject to hoDocumentObject
75293>>>>>>>>>>>>>        Get createChildNode of hoDocumentObject iNodeType sTagName sNamespace to hoNewNode
75294>>>>>>>>>>>>>        If hoNewNode ;            Get AppendNode hoNewNode to hoNewNode
75297>>>>>>>>>>>>>        Function_Return hoNewNode
75298>>>>>>>>>>>>>    End_Function
75299>>>>>>>>>>>>>    
75299>>>>>>>>>>>>>    // don't use the runtime/msxml version of this. Instead just return the
75299>>>>>>>>>>>>>    // first text from the first child node. This is much faster
75299>>>>>>>>>>>>>    Function psText Returns String
75301>>>>>>>>>>>>>        Handle hText
75301>>>>>>>>>>>>>        String sValue
75301>>>>>>>>>>>>>        Get phFirstChild to hText
75302>>>>>>>>>>>>>        Get InfcNodeValue hText to sValue
75303>>>>>>>>>>>>>        Function_Return sValue
75304>>>>>>>>>>>>>    End_Function
75305>>>>>>>>>>>>>    
75305>>>>>>>>>>>>>    // Use this to call the internal Text property. This returns all text for all child
75305>>>>>>>>>>>>>    // node. You rarely would want to do this. The is uses the msxml psText which can
75305>>>>>>>>>>>>>    // get slow with very large files. If for some reason you need all of the child node's
75305>>>>>>>>>>>>>    // text and the file is large, you might want to consider doing this process manually.
75305>>>>>>>>>>>>>    Function AllChildNodesText Returns String
75307>>>>>>>>>>>>>        String sValue
75307>>>>>>>>>>>>>        Forward Get psText to sValue
75309>>>>>>>>>>>>>        Function_Return sValue
75310>>>>>>>>>>>>>    End_Function
75311>>>>>>>>>>>>>    
75311>>>>>>>>>>>>>    // return the interface NodeValue without having to create a
75311>>>>>>>>>>>>>    // new object. This also disposes the hInfc interface
75311>>>>>>>>>>>>>    Function InfcNodeValue Handle hInfc Returns String
75313>>>>>>>>>>>>>        Handle hoDocument hoTempNode
75313>>>>>>>>>>>>>        String sValue
75313>>>>>>>>>>>>>        If (hinfc) Begin
75315>>>>>>>>>>>>>            Get DocumentObject to hoDocument
75316>>>>>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
75317>>>>>>>>>>>>>            Set XMLInterface of hoTempNode to hInfc
75318>>>>>>>>>>>>>            Get psNodeValue of hoTempNode to sValue
75319>>>>>>>>>>>>>            // This disposes of hInfc which was passed in. After
75319>>>>>>>>>>>>>            // calling this you can no longer use it (which is good).
75319>>>>>>>>>>>>>            Set XMLInterface of hoTempNode to 0
75320>>>>>>>>>>>>>        End
75320>>>>>>>>>>>>>>
75320>>>>>>>>>>>>>        Function_Return sValue
75321>>>>>>>>>>>>>    End_Function
75322>>>>>>>>>>>>>    
75322>>>>>>>>>>>>>    // ChildNodeValue is used to get the "value" of an element. This is useful when the element
75322>>>>>>>>>>>>>    // only has a single value (similar to an attribute).
75322>>>>>>>>>>>>>    
75322>>>>>>>>>>>>>    Function ChildNodeValue String sTagName Returns String
75324>>>>>>>>>>>>>        Handle hoTempNode hoDocument
75324>>>>>>>>>>>>>        Handle hinfcTempNode
75324>>>>>>>>>>>>>        String sRetVal
75324>>>>>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
75325>>>>>>>>>>>>>        If (hinfcTempNode <> 0) Begin
75327>>>>>>>>>>>>>            Get DocumentObject to hoDocument
75328>>>>>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
75329>>>>>>>>>>>>>            Set XMLInterface of hoTempNode to hinfcTempNode
75330>>>>>>>>>>>>>            Get phFirstChild of hoTempNode to hinfcTempNode
75331>>>>>>>>>>>>>            Set XMLInterface of hoTempNode to 0
75332>>>>>>>>>>>>>            If hinfcTempNode Begin
75334>>>>>>>>>>>>>                Get InfcNodeValue hinfcTempNode to sRetVal
75335>>>>>>>>>>>>>            End
75335>>>>>>>>>>>>>>
75335>>>>>>>>>>>>>        End
75335>>>>>>>>>>>>>>
75335>>>>>>>>>>>>>        Function_Return sRetVal
75336>>>>>>>>>>>>>    End_Function
75337>>>>>>>>>>>>>    
75337>>>>>>>>>>>>>    // This simple function allows a parent to change the text of one of its elements.
75337>>>>>>>>>>>>>    // This actually occurs quite a bit, because (as stated above) lowest level
75337>>>>>>>>>>>>>    // elements are frequently used as properties.
75337>>>>>>>>>>>>>    //
75337>>>>>>>>>>>>>    Procedure SetChildNodeValue String sTagName String sValue
75339>>>>>>>>>>>>>        Handle hoTempNode
75339>>>>>>>>>>>>>        Handle hinfcTempNode
75339>>>>>>>>>>>>>        // Search for the node that matches.
75339>>>>>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
75340>>>>>>>>>>>>>        // If no match is found, add a new element with the tag.
75340>>>>>>>>>>>>>        If (hinfcTempNode = 0) ;            Send AddElement sTagName sValue
75343>>>>>>>>>>>>>        Else Begin
75344>>>>>>>>>>>>>            Get CreateXMLObject U_BaseXMLDOMNode hinfcTempNode to hoTempNode
75345>>>>>>>>>>>>>            If hoTempNode Begin
75347>>>>>>>>>>>>>                // Set the text of the element.
75347>>>>>>>>>>>>>                Set psText of hoTempNode to sValue
75348>>>>>>>>>>>>>                Send Destroy to hoTempNode
75349>>>>>>>>>>>>>            End
75349>>>>>>>>>>>>>>
75349>>>>>>>>>>>>>            Else ;                Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_SetChildNodeValue"))
75351>>>>>>>>>>>>>        End
75351>>>>>>>>>>>>>>
75351>>>>>>>>>>>>>    End_Procedure
75352>>>>>>>>>>>>>    
75352>>>>>>>>>>>>>    // These messages are used to allow you to travese through a nodes.
75352>>>>>>>>>>>>>    
75352>>>>>>>>>>>>>    Function FirstChild Returns Handle
75354>>>>>>>>>>>>>        Handle hoChild
75354>>>>>>>>>>>>>        Handle hinfcChild
75354>>>>>>>>>>>>>        Get phFirstChild  to hinfcChild
75355>>>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75358>>>>>>>>>>>>>        Function_Return hoChild
75359>>>>>>>>>>>>>    End_Function
75360>>>>>>>>>>>>>    
75360>>>>>>>>>>>>>    Function NextSibling Returns Handle
75362>>>>>>>>>>>>>        Handle hoChild
75362>>>>>>>>>>>>>        Handle hinfcChild
75362>>>>>>>>>>>>>        Get phNextSibling  to hinfcChild
75363>>>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75366>>>>>>>>>>>>>        Function_Return hoChild
75367>>>>>>>>>>>>>    End_Function
75368>>>>>>>>>>>>>    
75368>>>>>>>>>>>>>    Function PreviousSibling Returns Handle
75370>>>>>>>>>>>>>        Handle hoChild
75370>>>>>>>>>>>>>        Handle hinfcChild
75370>>>>>>>>>>>>>        Get phPreviousSibling  to hinfcChild
75371>>>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75374>>>>>>>>>>>>>        Function_Return hoChild
75375>>>>>>>>>>>>>    End_Function
75376>>>>>>>>>>>>>    
75376>>>>>>>>>>>>>    Function LastChild Returns Handle
75378>>>>>>>>>>>>>        Handle hoChild
75378>>>>>>>>>>>>>        Handle hinfcChild
75378>>>>>>>>>>>>>        Get phLastChild  to hinfcChild
75379>>>>>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
75382>>>>>>>>>>>>>        Function_Return hoChild
75383>>>>>>>>>>>>>    End_Function
75384>>>>>>>>>>>>>    
75384>>>>>>>>>>>>>    // return an object that is the parent of the current node
75384>>>>>>>>>>>>>    Function ParentNode Returns Handle
75386>>>>>>>>>>>>>        Handle hoId
75386>>>>>>>>>>>>>        Handle hinfcXMLInterface
75386>>>>>>>>>>>>>        Get phParentNode to hinfcXMLInterface
75387>>>>>>>>>>>>>        If (hinfcXMLInterface) ;            Get CreateXmlNode hinfcXMLInterface to hoID
75390>>>>>>>>>>>>>        Function_Return hoID
75391>>>>>>>>>>>>>    End_Function
75392>>>>>>>>>>>>>    
75392>>>>>>>>>>>>>    // Same as NextSibling except it uses or destroys the current node
75392>>>>>>>>>>>>>    //
75392>>>>>>>>>>>>>    // optimized version does not destroy/create object unless it needs to.
75392>>>>>>>>>>>>>    // if the next node is the same node type we will resuse this object
75392>>>>>>>>>>>>>    // else this object is destroyed
75392>>>>>>>>>>>>>    Function NextNode Returns Handle
75394>>>>>>>>>>>>>        Handle hoNode hoDocument
75394>>>>>>>>>>>>>        Handle hInfc
75394>>>>>>>>>>>>>        Get phNextSibling to hInfc
75395>>>>>>>>>>>>>        If hInfc Begin
75397>>>>>>>>>>>>>            Get DocumentObject to hoDocument
75398>>>>>>>>>>>>>            Move Self to hoNode
75399>>>>>>>>>>>>>            Send BindXMLInfc of hoDocument hInfc (&hoNode)
75400>>>>>>>>>>>>>        End
75400>>>>>>>>>>>>>>
75400>>>>>>>>>>>>>        Else Begin
75401>>>>>>>>>>>>>            Send Destroy
75402>>>>>>>>>>>>>            Move 0 to hoNode
75403>>>>>>>>>>>>>        End
75403>>>>>>>>>>>>>>
75403>>>>>>>>>>>>>        Function_Return hoNode
75404>>>>>>>>>>>>>    End_Function
75405>>>>>>>>>>>>>    
75405>>>>>>>>>>>>>    
75405>>>>>>>>>>>>>    // Enumerate through all nodes.
75405>>>>>>>>>>>>>    
75405>>>>>>>>>>>>>    Procedure EnumerateNodes Integer iMsg Handle hoReceiver String sVal1 String sVal2
75407>>>>>>>>>>>>>        Integer i iLen
75407>>>>>>>>>>>>>        Handle hoNode
75407>>>>>>>>>>>>>        Handle hoNodeCollection
75407>>>>>>>>>>>>>        Get ChildNodes to hoNodeCollection
75408>>>>>>>>>>>>>        If (hoNodeCollection <> 0) Begin
75410>>>>>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
75411>>>>>>>>>>>>>            Decrement iLen
75412>>>>>>>>>>>>>            For i from 0 to iLen
75418>>>>>>>>>>>>>>
75418>>>>>>>>>>>>>                // For each record, process its fields.
75418>>>>>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
75419>>>>>>>>>>>>>                Send iMsg of hoReceiver hoNode sVal1 sVal2
75420>>>>>>>>>>>>>                Send Destroy of hoNode
75421>>>>>>>>>>>>>            Loop
75422>>>>>>>>>>>>>>
75422>>>>>>>>>>>>>            Send Destroy of hoNodeCollection
75423>>>>>>>>>>>>>        End
75423>>>>>>>>>>>>>>
75423>>>>>>>>>>>>>    End_Procedure
75424>>>>>>>>>>>>>    
75424>>>>>>>>>>>>>    // Enumerate through all elements.
75424>>>>>>>>>>>>>    
75424>>>>>>>>>>>>>    Procedure EnumerateElements Integer iMsg Handle hoReceiver String sVal1 String sVal2
75426>>>>>>>>>>>>>        Integer i iLen
75426>>>>>>>>>>>>>        Handle hoNode
75426>>>>>>>>>>>>>        Handle hoNodeCollection
75426>>>>>>>>>>>>>        Get ChildNodes to hoNodeCollection
75427>>>>>>>>>>>>>        If (hoNodeCollection <> 0) Begin
75429>>>>>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
75430>>>>>>>>>>>>>            Decrement iLen
75431>>>>>>>>>>>>>            For i from 0 to iLen
75437>>>>>>>>>>>>>>
75437>>>>>>>>>>>>>                // For each record, process its fields.
75437>>>>>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
75438>>>>>>>>>>>>>                If (piNodeType(hoNode)=NODE_ELEMENT) ;                    Send iMsg of hoReceiver hoNode sVal1 sVal2
75441>>>>>>>>>>>>>                Send Destroy of hoNode
75442>>>>>>>>>>>>>            Loop
75443>>>>>>>>>>>>>>
75443>>>>>>>>>>>>>            Send Destroy of hoNodeCollection
75444>>>>>>>>>>>>>        End
75444>>>>>>>>>>>>>>
75444>>>>>>>>>>>>>    End_Procedure
75445>>>>>>>>>>>>>    
75445>>>>>>>>>>>>>    
75445>>>>>>>>>>>>>    // enumerate through all attributes. There is no recurse here because attributes will not
75445>>>>>>>>>>>>>    // contain attributes.
75445>>>>>>>>>>>>>    
75445>>>>>>>>>>>>>    Procedure EnumerateAttributes Integer iMsg Handle hoReceiver String sSomeValue
75447>>>>>>>>>>>>>        Integer i iLen
75447>>>>>>>>>>>>>        Handle hoNode
75447>>>>>>>>>>>>>        Handle hoNodeMapCollection
75447>>>>>>>>>>>>>        // we don't use tempattributenodes because we don't know what the enum message will do.
75447>>>>>>>>>>>>>        Get AttributeNodes to hoNodeMapCollection
75448>>>>>>>>>>>>>        If (hoNodeMapCollection <> 0) Begin
75450>>>>>>>>>>>>>            Get NodeListLength of hoNodeMapCollection to iLen
75451>>>>>>>>>>>>>            Decrement iLen
75452>>>>>>>>>>>>>            For i from 0 to iLen
75458>>>>>>>>>>>>>>
75458>>>>>>>>>>>>>                // For each record, process its fields.
75458>>>>>>>>>>>>>                Get CollectionNode of hoNodeMapCollection i to hoNode
75459>>>>>>>>>>>>>                Send iMsg of hoReceiver hoNode sSomeValue
75460>>>>>>>>>>>>>                Send Destroy of hoNode
75461>>>>>>>>>>>>>            Loop
75462>>>>>>>>>>>>>>
75462>>>>>>>>>>>>>            Send Destroy of hoNodeMapCollection
75463>>>>>>>>>>>>>        End
75463>>>>>>>>>>>>>>
75463>>>>>>>>>>>>>    End_Procedure
75464>>>>>>>>>>>>>    
75464>>>>>>>>>>>>>    
75464>>>>>>>>>>>>>    Function XSLTransformation Handle hoXSLDocument Returns String
75466>>>>>>>>>>>>>        Handle infcXSLStartAt
75466>>>>>>>>>>>>>        String sBuffer
75466>>>>>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
75466>>>>>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
75467>>>>>>>>>>>>>        Get TransformNode infcXSLStartAt to sBuffer
75468>>>>>>>>>>>>>        Function_Return sBuffer
75469>>>>>>>>>>>>>    End_Function
75470>>>>>>>>>>>>>    
75470>>>>>>>>>>>>>    // This allows for transformations not limited to the size of the string buffer
75470>>>>>>>>>>>>>    //
75470>>>>>>>>>>>>>    // Note that it is up to the programmer to dispose of the memory allocated at pBuffer
75470>>>>>>>>>>>>>    // by using the free(pBuffer) function
75470>>>>>>>>>>>>>    //
75470>>>>>>>>>>>>>    Function XSLTransformationToAddress Handle hoXSLDocument Returns Address
75472>>>>>>>>>>>>>        Handle infcXSLStartAt
75472>>>>>>>>>>>>>        Address pBuffer
75472>>>>>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
75472>>>>>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
75473>>>>>>>>>>>>>        Get TransformNodeToAddress infcXSLStartAt to pBuffer
75474>>>>>>>>>>>>>        Function_Return pBuffer
75475>>>>>>>>>>>>>    End_Function
75476>>>>>>>>>>>>>    
75476>>>>>>>>>>>>>    
75476>>>>>>>>>>>>>    // extract base name from string. e.g.: ns:name --> name
75476>>>>>>>>>>>>>    //
75476>>>>>>>>>>>>>    Function BaseNameFromQName String sName Returns String
75478>>>>>>>>>>>>>        Integer iPos
75478>>>>>>>>>>>>>        Move (Pos(":",sName)) to iPos
75479>>>>>>>>>>>>>        If iPos Begin
75481>>>>>>>>>>>>>            Move (remove(sName,1,iPos)) to sName
75482>>>>>>>>>>>>>        End
75482>>>>>>>>>>>>>>
75482>>>>>>>>>>>>>        Function_Return sName
75483>>>>>>>>>>>>>    End_Function
75484>>>>>>>>>>>>>    
75484>>>>>>>>>>>>>    // extract prefix name from string. e.g.: ns:name --> ns
75484>>>>>>>>>>>>>    //
75484>>>>>>>>>>>>>    Function PrefixNameFromQName String sName Returns String
75486>>>>>>>>>>>>>        String sPreFix
75486>>>>>>>>>>>>>        Integer iPos
75486>>>>>>>>>>>>>        Move (Pos(":",sName)) to iPos
75487>>>>>>>>>>>>>        If iPos Begin
75489>>>>>>>>>>>>>            Move (Left(sName,iPos-1)) to sPreFix
75490>>>>>>>>>>>>>        End
75490>>>>>>>>>>>>>>
75490>>>>>>>>>>>>>        Function_Return sPreFix
75491>>>>>>>>>>>>>    End_Function
75492>>>>>>>>>>>>>    
75492>>>>>>>>>>>>>    
75492>>>>>>>>>>>>>    // Returns true if node is element and namespace and base name match
75492>>>>>>>>>>>>>    //
75492>>>>>>>>>>>>>    Function IsElementNS String sNamespaceURI String sBaseName Returns Boolean
75494>>>>>>>>>>>>>        Function_Return (piNodeType(Self)=NODE_ELEMENT and ;            psNameSpaceURI(Self)=sNamespaceURI and ;            psBaseName(Self)=sBaseName )
75495>>>>>>>>>>>>>    End_Function
75496>>>>>>>>>>>>>    
75496>>>>>>>>>>>>>    // Returns node of first occurence of child node matching namespace and base name
75496>>>>>>>>>>>>>    //
75496>>>>>>>>>>>>>    Function ChildElementNS String sNameSpaceURI String sBaseName Returns Handle
75498>>>>>>>>>>>>>        Handle hoNode
75498>>>>>>>>>>>>>        Get FirstChild to hoNode
75499>>>>>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
75503>>>>>>>>>>>>>            Get NextNode of hoNode to hoNode
75504>>>>>>>>>>>>>        Loop
75505>>>>>>>>>>>>>>
75505>>>>>>>>>>>>>        Function_Return hoNode
75506>>>>>>>>>>>>>    End_Function
75507>>>>>>>>>>>>>    
75507>>>>>>>>>>>>>    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
75509>>>>>>>>>>>>>        Handle hoNode
75509>>>>>>>>>>>>>        // NextNode may return the same object or it may destroy the object and
75509>>>>>>>>>>>>>        // return nothing or a different object
75509>>>>>>>>>>>>>        Get NextNode to hoNode
75510>>>>>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
75514>>>>>>>>>>>>>            // use of hoNode is required. This can be different than self
75514>>>>>>>>>>>>>            Get NextNode of hoNode to hoNode
75515>>>>>>>>>>>>>        Loop
75516>>>>>>>>>>>>>>
75516>>>>>>>>>>>>>        
75516>>>>>>>>>>>>>        Function_Return hoNode
75517>>>>>>>>>>>>>    End_Function
75518>>>>>>>>>>>>>    
75518>>>>>>>>>>>>>    
75518>>>>>>>>>>>>>    // Returns value (string) first occurence of child node matching namespace and base name
75518>>>>>>>>>>>>>    //
75518>>>>>>>>>>>>>    Function ChildElementValueNS String sNameSpaceURI String sBaseName Returns String
75520>>>>>>>>>>>>>        Handle hoNext
75520>>>>>>>>>>>>>        String sText
75520>>>>>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNext
75521>>>>>>>>>>>>>        If hoNext Begin
75523>>>>>>>>>>>>>            Get psText of hoNext to sText
75524>>>>>>>>>>>>>            Send destroy of hoNext
75525>>>>>>>>>>>>>        End
75525>>>>>>>>>>>>>>
75525>>>>>>>>>>>>>        Function_Return sText
75526>>>>>>>>>>>>>    End_Function
75527>>>>>>>>>>>>>    
75527>>>>>>>>>>>>>    Procedure SetChildElementValueNS String sNameSpaceURI String sBaseName String sValue
75529>>>>>>>>>>>>>        Handle hoNode
75529>>>>>>>>>>>>>        Handle hinfcTempNode
75529>>>>>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNode
75530>>>>>>>>>>>>>        If (hoNode=0) Begin
75532>>>>>>>>>>>>>            Send AddElementNS sNameSpaceURI sBaseName sValue
75533>>>>>>>>>>>>>        End
75533>>>>>>>>>>>>>>
75533>>>>>>>>>>>>>        Else Begin
75534>>>>>>>>>>>>>            Set psText of hoNode to sValue
75535>>>>>>>>>>>>>            Send destroy of hoNode
75536>>>>>>>>>>>>>        End
75536>>>>>>>>>>>>>>
75536>>>>>>>>>>>>>    End_Procedure
75537>>>>>>>>>>>>>    
75537>>>>>>>>>>>>>    // pass a prefix and try to finds its NameSpaceURI. Start at current node and work up to parent.
75537>>>>>>>>>>>>>    // This can be useful when a qualified name is found in an attribute value
75537>>>>>>>>>>>>>    //
75537>>>>>>>>>>>>>    Function PrefixToNamespaceURI String sPrefix Returns String
75539>>>>>>>>>>>>>        Handle hoNode
75539>>>>>>>>>>>>>        Integer i iNodes
75539>>>>>>>>>>>>>        Handle hoNodes hoParentNode hoAttNode
75539>>>>>>>>>>>>>        Boolean bDone bParent
75539>>>>>>>>>>>>>        String sAttPrefix sName sNameSpace
75539>>>>>>>>>>>>>        
75539>>>>>>>>>>>>>        Move Self to hoNode
75540>>>>>>>>>>>>>        While not bDone
75544>>>>>>>>>>>>>            Get TempAttributeNodes of hoNode to hoNodes
75545>>>>>>>>>>>>>            If (hoNodes <> 0) Begin
75547>>>>>>>>>>>>>                Get NodeListLength of hoNodes to iNodes
75548>>>>>>>>>>>>>                For i from 0 to (iNodes-1)
75554>>>>>>>>>>>>>>
75554>>>>>>>>>>>>>                    // For each record, process its fields.
75554>>>>>>>>>>>>>                    Get CollectionNode of hoNodes i to hoAttNode
75555>>>>>>>>>>>>>                    Get psPrefix of hoAttNode to sAttPrefix
75556>>>>>>>>>>>>>                    Get psBaseName of hoAttNode to sName
75557>>>>>>>>>>>>>                    // with legacy msxml, xmlns="foo" returns psPrefix="xmlns" and pbBaseName=""
75557>>>>>>>>>>>>>                    // with newer msxml, xmlns="foo" returns psPrefix="" and pbBaseName="xmlns"
75557>>>>>>>>>>>>>                    // We handle both cases here.
75557>>>>>>>>>>>>>                    
75557>>>>>>>>>>>>>                    If ( (sAttPrefix="xmlns" and sName=sPrefix) or ; // if a normal xmlns:xx="foo" match (sPrefix="xx") or a legacy xmlns="foo" match (sPrefix="")                        (sPrefix="" and sAttPrefix="" and sName="xmlns") ) Begin // special test for newer msxml xmlns="foo" match (sPrefix="")
75559>>>>>>>>>>>>>                        
75559>>>>>>>>>>>>>                        Get Value of hoAttNode to sNameSpace
75560>>>>>>>>>>>>>                        Move True to bDone
75561>>>>>>>>>>>>>                        Move (iNodes-1) to i
75562>>>>>>>>>>>>>                        
75562>>>>>>>>>>>>>                    End
75562>>>>>>>>>>>>>>
75562>>>>>>>>>>>>>                    
75562>>>>>>>>>>>>>                    Send Destroy of hoAttNode
75563>>>>>>>>>>>>>                Loop
75564>>>>>>>>>>>>>>
75564>>>>>>>>>>>>>                Set XMLInterface of hoNodes to 0
75565>>>>>>>>>>>>>            End
75565>>>>>>>>>>>>>>
75565>>>>>>>>>>>>>            
75565>>>>>>>>>>>>>            Get ParentNode of hoNode to hoParentNode
75566>>>>>>>>>>>>>            If bParent ;                Send destroy of hoNode
75569>>>>>>>>>>>>>            If not bDone Begin
75571>>>>>>>>>>>>>                If not hoParentNode ;                    Move True to bDone
75574>>>>>>>>>>>>>                Else Begin
75575>>>>>>>>>>>>>                    Move True to bParent
75576>>>>>>>>>>>>>                    Move hoParentNode to hoNode
75577>>>>>>>>>>>>>                End
75577>>>>>>>>>>>>>>
75577>>>>>>>>>>>>>            End
75577>>>>>>>>>>>>>>
75577>>>>>>>>>>>>>        Loop
75578>>>>>>>>>>>>>>
75578>>>>>>>>>>>>>        Function_Return sNameSpace
75579>>>>>>>>>>>>>    End_Function
75580>>>>>>>>>>>>>    
75580>>>>>>>>>>>>>    
75580>>>>>>>>>>>>>    
75580>>>>>>>>>>>>>End_Class
75581>>>>>>>>>>>>>
75581>>>>>>>>>>>>>// Set up basic inheritance for specialized forms of XML classes.
75581>>>>>>>>>>>>>// This needs to be done so we can make objects of these types.
75581>>>>>>>>>>>>>
75581>>>>>>>>>>>>>Class cXMLDOMElement is a BaseXmlDomElement
75582>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75583>>>>>>>>>>>>>    
75583>>>>>>>>>>>>>    // Should use AddAttributeValue...does same thing
75583>>>>>>>>>>>>>    Procedure SetAttributeValue String sName String sValue
75585>>>>>>>>>>>>>        Send AddAttribute sName sValue
75586>>>>>>>>>>>>>    End_Procedure
75587>>>>>>>>>>>>>    
75587>>>>>>>>>>>>>    // Note: Get_AttributeValue already there
75587>>>>>>>>>>>>>    
75587>>>>>>>>>>>>>    Procedure RemoveAttribute String sName
75589>>>>>>>>>>>>>        Integer iVal
75589>>>>>>>>>>>>>        Get RemoveAttribute sName to iVal
75590>>>>>>>>>>>>>    End_Procedure
75591>>>>>>>>>>>>>    
75591>>>>>>>>>>>>>    Function AttributeValueNS String sNameSpace String sBaseName Returns String
75593>>>>>>>>>>>>>        String sValue
75593>>>>>>>>>>>>>        Handle hinfcItem
75593>>>>>>>>>>>>>        Handle hoDoc hoTempAttributeNodes hoNode
75593>>>>>>>>>>>>>        Integer hinfcAttributes
75593>>>>>>>>>>>>>        
75593>>>>>>>>>>>>>        Get TempAttributeNodes to hoTempAttributeNodes
75594>>>>>>>>>>>>>        Get QualifiedItem of hoTempAttributeNodes sBaseName sNameSpace  to hinfcItem
75595>>>>>>>>>>>>>        Set XMLInterface of hoTempAttributeNodes to 0
75596>>>>>>>>>>>>>        If hinfcItem Begin
75598>>>>>>>>>>>>>            Get DocumentObject to hoDoc
75599>>>>>>>>>>>>>            Get phoTempDomNode of hoDoc to hoNode
75600>>>>>>>>>>>>>            Set XMLInterface of hoNode to hinfcItem
75601>>>>>>>>>>>>>            Get psNodeValue of hoNode to sValue
75602>>>>>>>>>>>>>            Set XMLInterface of hoNode to 0
75603>>>>>>>>>>>>>        End
75603>>>>>>>>>>>>>>
75603>>>>>>>>>>>>>        Function_Return sValue
75604>>>>>>>>>>>>>    End_Function
75605>>>>>>>>>>>>>    
75605>>>>>>>>>>>>>    Procedure RemoveAttributeNS String sNameSpace String sBaseName
75607>>>>>>>>>>>>>        Handle hoAttrs hoAttr
75607>>>>>>>>>>>>>        String sValue
75607>>>>>>>>>>>>>        Get TempAttributeNodes to hoAttrs
75608>>>>>>>>>>>>>        If hoAttrs Begin
75610>>>>>>>>>>>>>            Get RemoveQualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
75611>>>>>>>>>>>>>            Set XMLInterface of hoAttrs to 0
75612>>>>>>>>>>>>>            If hoAttr ;                Send destroy of hoAttr
75615>>>>>>>>>>>>>        End
75615>>>>>>>>>>>>>>
75615>>>>>>>>>>>>>    End_Procedure
75616>>>>>>>>>>>>>    
75616>>>>>>>>>>>>>End_Class
75617>>>>>>>>>>>>>
75617>>>>>>>>>>>>>Class cXMLDOMNode is a BaseXmlDomNode
75618>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75619>>>>>>>>>>>>>End_Class
75620>>>>>>>>>>>>>
75620>>>>>>>>>>>>>Class cXMLDOMAttribute is a BaseXmlDomAttribute
75621>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75622>>>>>>>>>>>>>End_Class
75623>>>>>>>>>>>>>
75623>>>>>>>>>>>>>Class cXMLDOMComment is a BaseXmlDomComment
75624>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75625>>>>>>>>>>>>>End_Class
75626>>>>>>>>>>>>>
75626>>>>>>>>>>>>>Class cXMLDOMProcessingInstruction is a BaseXmlDomProcessingInstruction
75627>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75628>>>>>>>>>>>>>End_Class
75629>>>>>>>>>>>>>
75629>>>>>>>>>>>>>Class cXMLDOMTextNode is a BaseXmlDomTextNode
75630>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75631>>>>>>>>>>>>>End_Class
75632>>>>>>>>>>>>>
75632>>>>>>>>>>>>>Class cXMLDOMCDATASection is a BaseXmlDomCDATASection
75633>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75634>>>>>>>>>>>>>End_Class
75635>>>>>>>>>>>>>
75635>>>>>>>>>>>>>Class cXMLDOMDocumentType is a BaseXmlDomDocumentType
75636>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75637>>>>>>>>>>>>>    
75637>>>>>>>>>>>>>End_Class
75638>>>>>>>>>>>>>
75638>>>>>>>>>>>>>Class cXMLDOMNotation is a BaseXmlDomNotation
75639>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75640>>>>>>>>>>>>>End_Class
75641>>>>>>>>>>>>>
75641>>>>>>>>>>>>>Class cXMLDOMEntity is a BaseXmlDomEntity
75642>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75643>>>>>>>>>>>>>End_Class
75644>>>>>>>>>>>>>
75644>>>>>>>>>>>>>Class cXMLDOMEntityReference is a BaseXmlDomEntityReference
75645>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75646>>>>>>>>>>>>>End_Class
75647>>>>>>>>>>>>>
75647>>>>>>>>>>>>>Class cXMLDOMDocumentFragment is a BaseXmlDomDocumentFragment
75648>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75649>>>>>>>>>>>>>End_Class
75650>>>>>>>>>>>>>
75650>>>>>>>>>>>>>
75650>>>>>>>>>>>>>Class cXMLDOMParseError is a BaseXMLDomParseError
75651>>>>>>>>>>>>>    // returns an error sub-object as a sibling of this error object
75651>>>>>>>>>>>>>    Function ErrorItemNode Integer iItem Returns Handle
75653>>>>>>>>>>>>>        Handle hoParseErrorNode hoParent
75653>>>>>>>>>>>>>        Handle hParseErrorIntf
75653>>>>>>>>>>>>>        Get ErrorItem iItem to hParseErrorIntf
75654>>>>>>>>>>>>>        If (hParseErrorIntf) Begin
75656>>>>>>>>>>>>>            // add to parent in case developer destroys the current object
75656>>>>>>>>>>>>>            Get Parent to hoParent
75657>>>>>>>>>>>>>            Get Create of hoParent U_cXMLDOMParseError to hoParseErrorNode
75658>>>>>>>>>>>>>            Set XmlInterface of hoParseErrorNode to hParseErrorIntf
75659>>>>>>>>>>>>>        End
75659>>>>>>>>>>>>>>
75659>>>>>>>>>>>>>        Function_Return hoParseErrorNode
75660>>>>>>>>>>>>>    End_Function
75661>>>>>>>>>>>>>End_Class
75662>>>>>>>>>>>>>
75662>>>>>>>>>>>>>// Base document class with Base functions.
75662>>>>>>>>>>>>>
75662>>>>>>>>>>>>>Class cXMLDOMDocument is an BaseXmlDomDocument
75663>>>>>>>>>>>>>    
75663>>>>>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
75664>>>>>>>>>>>>>    
75664>>>>>>>>>>>>>    Procedure Construct_Object
75666>>>>>>>>>>>>>        Handle hInfc
75666>>>>>>>>>>>>>        Forward Send Construct_Object
75668>>>>>>>>>>>>>        Property String psDocumentName ""
75669>>>>>>>>>>>>>        Property Integer phPrivateDocumentElement 0
75670>>>>>>>>>>>>>        Property Handle phoTempDomNode (Create(Self,U_cXMLDomNode))
75671>>>>>>>>>>>>>        Property Handle phoTempDomNodeMap (Create(Self,U_cXMLDOMNamedNodeMap))
75672>>>>>>>>>>>>>        
75672>>>>>>>>>>>>>        // added in 15.1. If no COM pointer, msxml6 is most likely not installed. This will
75672>>>>>>>>>>>>>        // raise an unhandled error, which could be augmented to do something else.
75672>>>>>>>>>>>>>        Get XmlInterface to hInfc
75673>>>>>>>>>>>>>        If (hInfc=0) Begin
75675>>>>>>>>>>>>>            Send ErrorCreatingXMLObject
75676>>>>>>>>>>>>>        End
75676>>>>>>>>>>>>>>
75676>>>>>>>>>>>>>        
75676>>>>>>>>>>>>>        // as of 18.0 pbAsync now defaults to False. In most cases, this is what you want
75676>>>>>>>>>>>>>        Set pbAsync to False
75677>>>>>>>>>>>>>    End_Procedure
75678>>>>>>>>>>>>>    
75678>>>>>>>>>>>>>    // returns the classId for the passed NodeType. This is a good augmentation point. All nodes
75678>>>>>>>>>>>>>    // within an xml document come here to get a class. So, if you want to augment and return a
75678>>>>>>>>>>>>>    // different class, just check the node type and return whatever -- else forward
75678>>>>>>>>>>>>>    
75678>>>>>>>>>>>>>    Function NodeClassId Integer iType Returns Integer
75680>>>>>>>>>>>>>        Integer iClassId
75680>>>>>>>>>>>>>        Case Begin
75680>>>>>>>>>>>>>            Case (iType=NODE_ELEMENT) ;                Move U_cXMLDOMElement      to iClassId
75683>>>>>>>>>>>>>            Case (iType=NODE_ATTRIBUTE) ;                Move U_cXMLDOMAttribute    to iClassId
75687>>>>>>>>>>>>>            Case (iType=NODE_TEXT) ;                Move U_cXMLDOMTextNode     to iClassId
75691>>>>>>>>>>>>>            Case (iType=NODE_CDATA_SECTION) ;                Move U_cXMLDOMCDATASection to iClassId
75695>>>>>>>>>>>>>            Case (iType=NODE_ENTITY_REFERENCE) ;                Move U_cXMLDOMEntityReference to iClassId
75699>>>>>>>>>>>>>            Case (iType=NODE_ENTITY) ;                Move U_cXMLDOMEntity       to iClassId
75703>>>>>>>>>>>>>            Case (iType=NODE_PROCESSING_INSTRUCTION) ;                Move U_cXMLDOMProcessingInstruction to iClassId
75707>>>>>>>>>>>>>            Case (iType=NODE_COMMENT) ;                Move U_cXMLDOMComment      to iClassId
75711>>>>>>>>>>>>>            Case (iType=NODE_DOCUMENT) ;                Move U_cXMLDOMDocument     to iClassId
75715>>>>>>>>>>>>>            Case (iType=NODE_DOCUMENT_TYPE) ;                Move U_cXMLDOMDocumentType to iClassId
75719>>>>>>>>>>>>>            Case (iType=NODE_DOCUMENT_FRAGMENT) ;                Move U_cXMLDOMDocumentFragment to iClassId
75723>>>>>>>>>>>>>            Case (iType=NODE_NOTATION) ;                Move U_cXMLDOMNotation     to iClassId
75727>>>>>>>>>>>>>            Case (iType=0) ;                Move 0                     to iClassId // this is an error!!
75731>>>>>>>>>>>>>            Case Else ;                Move U_cXMLDOMNode         to iClassId
75733>>>>>>>>>>>>>        Case End
75733>>>>>>>>>>>>>        Function_Return iClassId
75734>>>>>>>>>>>>>    End_Function
75735>>>>>>>>>>>>>    
75735>>>>>>>>>>>>>    // Load an XML Document. The name of the document is stored in a property
75735>>>>>>>>>>>>>    // that must be set for this function to work correctly.
75735>>>>>>>>>>>>>    
75735>>>>>>>>>>>>>    Function LoadXMLDocument Returns Integer
75737>>>>>>>>>>>>>        String sDocumentName
75737>>>>>>>>>>>>>        Integer bRetVal
75737>>>>>>>>>>>>>        Get psDocumentName to sDocumentName
75738>>>>>>>>>>>>>        Get LoadDocument sDocumentName to bRetVal
75739>>>>>>>>>>>>>        If (bRetVal = 0);            Function_Return True
75742>>>>>>>>>>>>>        Else;            Function_Return False
75744>>>>>>>>>>>>>    End_Function
75745>>>>>>>>>>>>>    
75745>>>>>>>>>>>>>    Function SaveXMLDocument Returns Integer
75747>>>>>>>>>>>>>        String sDocumentName
75747>>>>>>>>>>>>>        Integer bRetVal
75747>>>>>>>>>>>>>        Get psDocumentName to sDocumentName
75748>>>>>>>>>>>>>        Get SaveDocument sDocumentName to bRetVal
75749>>>>>>>>>>>>>        Function_Return bRetVal
75750>>>>>>>>>>>>>    End_Function
75751>>>>>>>>>>>>>    
75751>>>>>>>>>>>>>    // Load an XML from a string. This aguments the C message to ret 1 if Ok and 0 if error.
75751>>>>>>>>>>>>>    //
75751>>>>>>>>>>>>>    Function LoadXML String sXML Returns Integer
75753>>>>>>>>>>>>>        Integer bRetVal
75753>>>>>>>>>>>>>        // for some reason the parser will not work properly with embedded double quotes.
75753>>>>>>>>>>>>>        // Change all " to ' in document.
75753>>>>>>>>>>>>>        //Move (replaces('"',sXML,"'")) to sXML  // removed this. Bad Idea.
75753>>>>>>>>>>>>>        Forward Get LoadXml sXML to bRetVal
75755>>>>>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
75758>>>>>>>>>>>>>        Else;            Function_Return False
75760>>>>>>>>>>>>>    End_Function
75761>>>>>>>>>>>>>    
75761>>>>>>>>>>>>>    // Load an XML string from an address. This aguments the C message to ret 1 if Ok and 0 if error.
75761>>>>>>>>>>>>>    //
75761>>>>>>>>>>>>>    Function LoadXMLFromAddress Address pXML Returns Integer
75763>>>>>>>>>>>>>        Integer bRetVal
75763>>>>>>>>>>>>>        Forward Get LoadXmlFromAddress pXML to bRetVal
75765>>>>>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
75768>>>>>>>>>>>>>        Else;            Function_Return False
75770>>>>>>>>>>>>>    End_Function
75771>>>>>>>>>>>>>    
75771>>>>>>>>>>>>>    
75771>>>>>>>>>>>>>    // Allow Nodes and Node node lists to get the parent document.
75771>>>>>>>>>>>>>    
75771>>>>>>>>>>>>>    Function DocumentObject Returns Handle
75773>>>>>>>>>>>>>        Function_Return Self
75774>>>>>>>>>>>>>    End_Function
75775>>>>>>>>>>>>>    
75775>>>>>>>>>>>>>    // Access to the root node allows for searches and iterations.
75775>>>>>>>>>>>>>    // The root node is a cNode.
75775>>>>>>>>>>>>>    
75775>>>>>>>>>>>>>    Function DocumentElement Returns Handle
75777>>>>>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
75777>>>>>>>>>>>>>        Handle infcNode   // XML Element Interface
75777>>>>>>>>>>>>>        Get phDocumentElement to infcNode
75778>>>>>>>>>>>>>        If infcNode Begin
75780>>>>>>>>>>>>>            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
75781>>>>>>>>>>>>>            Set phPrivateDocumentElement to hNewNode // we no longer use this at all
75782>>>>>>>>>>>>>        End
75782>>>>>>>>>>>>>>
75782>>>>>>>>>>>>>        Function_Return hNewNode
75783>>>>>>>>>>>>>    End_Function
75784>>>>>>>>>>>>>    
75784>>>>>>>>>>>>>    //  CreateRootNode is used to set up the first element in a document.
75784>>>>>>>>>>>>>    //  It should only be used when creating new files.
75784>>>>>>>>>>>>>    
75784>>>>>>>>>>>>>    Function CreateDocumentElement String sTagName Returns Handle
75786>>>>>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
75786>>>>>>>>>>>>>        Handle infcNode   // XML Element Interface
75786>>>>>>>>>>>>>        // Call XML to create an element in the document.
75786>>>>>>>>>>>>>        Get CreateElement sTagName to infcNode
75787>>>>>>>>>>>>>        // Tie the element interface to the DataFlex object.
75787>>>>>>>>>>>>>        If infcNode ;            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
75790>>>>>>>>>>>>>        // Call XML to set the root element of the document.
75790>>>>>>>>>>>>>        Set phDocumentElement to infcNode
75791>>>>>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
75792>>>>>>>>>>>>>        Function_Return hNewNode
75793>>>>>>>>>>>>>    End_Function
75794>>>>>>>>>>>>>    
75794>>>>>>>>>>>>>    Function CreateDocumentElementNS String sNamespace String sTagName Returns Handle
75796>>>>>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
75796>>>>>>>>>>>>>        Handle infcNode iType  // XML Element Interface
75796>>>>>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName "" to hNewNode
75797>>>>>>>>>>>>>        Get XmlInterface of hNewNode to infcNode
75798>>>>>>>>>>>>>        Set phDocumentElement to infcNode
75799>>>>>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
75800>>>>>>>>>>>>>        Function_Return hNewNode
75801>>>>>>>>>>>>>    End_Function
75802>>>>>>>>>>>>>    
75802>>>>>>>>>>>>>    
75802>>>>>>>>>>>>>    
75802>>>>>>>>>>>>>    // return the DocType as a document-type object. Returns 0 if no dtd
75802>>>>>>>>>>>>>    // Access to information from the doc type object is limited. Use get psXML
75802>>>>>>>>>>>>>    Function DocTypeNode Returns Handle
75804>>>>>>>>>>>>>        Handle hinfcDocType hoDocType
75804>>>>>>>>>>>>>        Get phDocType to hinfcDocType
75805>>>>>>>>>>>>>        If hinfcDocType ;            Get CreateXMLObject U_cXMLDOMDocumentType hinfcDocType to hoDocType
75808>>>>>>>>>>>>>        Function_Return hoDocType
75809>>>>>>>>>>>>>    End_Function
75810>>>>>>>>>>>>>    
75810>>>>>>>>>>>>>    Function phXMLErrorObject Returns Handle
75812>>>>>>>>>>>>>        Handle hoParseErrorObject
75812>>>>>>>>>>>>>        Handle hInfcParseError
75812>>>>>>>>>>>>>        Get phParseError to hInfcParseError
75813>>>>>>>>>>>>>        If hInfcParseError ;            Get CreateXMLObject U_cXMLDOMParseError hinfcParseError to hoParseErrorObject
75816>>>>>>>>>>>>>        Function_Return hoParseErrorObject
75817>>>>>>>>>>>>>    End_Function
75818>>>>>>>>>>>>>    
75818>>>>>>>>>>>>>    //  The following procedure is meant to be overridden by one provided by the developer.
75818>>>>>>>>>>>>>    
75818>>>>>>>>>>>>>    Procedure BasicParseErrorReport
75820>>>>>>>>>>>>>        String sProblem
75820>>>>>>>>>>>>>        String sLinePosition
75820>>>>>>>>>>>>>        String sDescr
75820>>>>>>>>>>>>>        String sReason
75820>>>>>>>>>>>>>        String sSource
75820>>>>>>>>>>>>>        Handle hoParseErrorObject
75820>>>>>>>>>>>>>        Get phXMLErrorObject to hoParseErrorObject
75821>>>>>>>>>>>>>        If hoParseErrorObject Begin
75823>>>>>>>>>>>>>            Move (SFormat(C_$CannotLoad, psDocumentName(Self)) + "."+character(13)+character(10)) to sProblem
75824>>>>>>>>>>>>>            Move (SFormat(C_$ParsingError, piLine(hoParseErrorObject), piLinePos(hoParseErrorObject))) to sLinePosition
75825>>>>>>>>>>>>>            Move (sLinePosition +character(13)+character(10)) to sLinePosition
75826>>>>>>>>>>>>>            
75826>>>>>>>>>>>>>            Move (C_$Reason + ":" * (psReason(hoParseErrorObject))  +character(13)+character(10)) to sReason
75827>>>>>>>>>>>>>            Move (C_$Source + ":" * (psSrcText(hoParseErrorObject))) to sSource
75828>>>>>>>>>>>>>            Move (sProblem + sLinePosition + sReason + sSource) to sDescr
75829>>>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR sDescr
75830>>>>>>>>>>>>>>
75830>>>>>>>>>>>>>            Send Destroy of hoParseErrorObject
75831>>>>>>>>>>>>>        End
75831>>>>>>>>>>>>>>
75831>>>>>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR C_$NotCreatedParseObject
75833>>>>>>>>>>>>>    End_Procedure
75834>>>>>>>>>>>>>    
75834>>>>>>>>>>>>>    // bind an xml interface node to the passed XML object. If the
75834>>>>>>>>>>>>>    // object type is of the wrong type, we will destroy it and recreate it
75834>>>>>>>>>>>>>    // which is why hoNode is passed byRef.
75834>>>>>>>>>>>>>    // to use this you'd have to use the lower level private messages to get the
75834>>>>>>>>>>>>>    // xml interface handles and then bind them to an object. Just like in COM you could
75834>>>>>>>>>>>>>    // bind these to the same object, which might save some parsing time. This is made private
75834>>>>>>>>>>>>>    // because the time savings would probably be small and would not justify the extra
75834>>>>>>>>>>>>>    // complexity.
75834>>>>>>>>>>>>>    // It is a programming error to pass this a zero handle.
75834>>>>>>>>>>>>>    Procedure BindXMLInfc Handle hInfc Handle ByRef hoNode
75836>>>>>>>>>>>>>        Integer iType iClassId iType2
75836>>>>>>>>>>>>>        Get piNodeType of hoNode to iType2 // type of the DF XML object
75837>>>>>>>>>>>>>        
75837>>>>>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
75837>>>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
75838>>>>>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
75839>>>>>>>>>>>>>        If (hinfc=0) Begin
75841>>>>>>>>>>>>>            // this should not happen and we would need to know about this.
75841>>>>>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
75842>>>>>>>>>>>>>>
75842>>>>>>>>>>>>>            Procedure_Return 0
75843>>>>>>>>>>>>>        End
75843>>>>>>>>>>>>>>
75843>>>>>>>>>>>>>        // if the type is the same we can reuse the current object and binding it to the interface pointer
75843>>>>>>>>>>>>>        If (iType=iType2) Begin
75845>>>>>>>>>>>>>            // resuse Self and return
75845>>>>>>>>>>>>>            Set XMLInterface of hoNode to hInfc
75846>>>>>>>>>>>>>        End
75846>>>>>>>>>>>>>>
75846>>>>>>>>>>>>>        // if diffrent type, destroy the existing object and recreate it
75846>>>>>>>>>>>>>        Else Begin
75847>>>>>>>>>>>>>            Send Destroy of hoNode
75848>>>>>>>>>>>>>            Get NodeClassId iType to iClassId
75849>>>>>>>>>>>>>            Get CreateXMLObject iClassId hInfc to hoNode
75850>>>>>>>>>>>>>        End
75850>>>>>>>>>>>>>>
75850>>>>>>>>>>>>>    End_Procedure
75851>>>>>>>>>>>>>    
75851>>>>>>>>>>>>>    Function ValidateDocument Returns Handle
75853>>>>>>>>>>>>>        Handle hParseErrorIntf hoParseError
75853>>>>>>>>>>>>>        Forward Get ValidateDocument to hParseErrorIntf
75855>>>>>>>>>>>>>        If hParseErrorIntf Begin
75857>>>>>>>>>>>>>            Get CreateXMLObject U_cXMLDOMParseError hParseErrorIntf to hoParseError
75858>>>>>>>>>>>>>        End
75858>>>>>>>>>>>>>>
75858>>>>>>>>>>>>>        Function_Return hoParseError
75859>>>>>>>>>>>>>    End_Function
75860>>>>>>>>>>>>>    
75860>>>>>>>>>>>>>    Function AddExternalSchemaDocument String sSchema Handle hoSchema Returns Boolean
75862>>>>>>>>>>>>>        Handle hInfc
75862>>>>>>>>>>>>>        Boolean bOk
75862>>>>>>>>>>>>>        Get XmlInterface of hoSchema to hInfc
75863>>>>>>>>>>>>>        Forward Get AddExternalSchemaDocument sSchema hInfc to bOk
75865>>>>>>>>>>>>>        Function_Return (not(bOk))
75866>>>>>>>>>>>>>    End_Function
75867>>>>>>>>>>>>>    
75867>>>>>>>>>>>>>    Function AddExternalSchemaFile String sSchema String sFile Returns Boolean
75869>>>>>>>>>>>>>        Boolean bOk
75869>>>>>>>>>>>>>        Forward Get AddExternalSchemaFile sSchema sFile to bOk
75871>>>>>>>>>>>>>        Function_Return (not(bOk))
75872>>>>>>>>>>>>>    End_Function
75873>>>>>>>>>>>>>    
75873>>>>>>>>>>>>>    Procedure Set psSelectionNamespaces String sNamespaces
75875>>>>>>>>>>>>>        Set psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
75876>>>>>>>>>>>>>    End_Procedure
75877>>>>>>>>>>>>>    
75877>>>>>>>>>>>>>    Function psSelectionNamespaces Returns String
75879>>>>>>>>>>>>>        String  sNamespaces
75879>>>>>>>>>>>>>        Get psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
75880>>>>>>>>>>>>>        Function_Return sNamespaces
75881>>>>>>>>>>>>>    End_Function
75882>>>>>>>>>>>>>    
75882>>>>>>>>>>>>>    Procedure Set pbMultipleErrorMessages Boolean bMultipleErrors
75884>>>>>>>>>>>>>        Set pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
75885>>>>>>>>>>>>>    End_Procedure
75886>>>>>>>>>>>>>    
75886>>>>>>>>>>>>>    Function pbMultipleErrorMessages Returns Boolean
75888>>>>>>>>>>>>>        Boolean bMultipleErrors
75888>>>>>>>>>>>>>        Get pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
75889>>>>>>>>>>>>>        Function_Return bMultipleErrors
75890>>>>>>>>>>>>>    End_Function
75891>>>>>>>>>>>>>    
75891>>>>>>>>>>>>>    Procedure ErrorCreatingXMLObject
75893>>>>>>>>>>>>>        Error DFERR_XML_INTERNAL_ERROR "Could not create XML COM object. MSXML6 may not be properly installed and registered."
75894>>>>>>>>>>>>>>
75894>>>>>>>>>>>>>    End_Procedure
75895>>>>>>>>>>>>>    
75895>>>>>>>>>>>>>    // returns the last parse error. If 0, you know everything parsed. This can be
75895>>>>>>>>>>>>>    // used along wit pbReadyState to load XML documents in async mode.
75895>>>>>>>>>>>>>    Function LastParseError Returns Integer
75897>>>>>>>>>>>>>        Integer iErr
75897>>>>>>>>>>>>>        Handle hoParseErrorReport
75897>>>>>>>>>>>>>        Get phXMLErrorObject to hoParseErrorReport
75898>>>>>>>>>>>>>        Get piErrorCode of hoParseErrorReport to iErr
75899>>>>>>>>>>>>>        Send Destroy of hoParseErrorReport
75900>>>>>>>>>>>>>        Function_Return iErr
75901>>>>>>>>>>>>>    End_Function
75902>>>>>>>>>>>>>    
75902>>>>>>>>>>>>>    
75902>>>>>>>>>>>>>End_Class
75903>>>>>>>>>>>
75903>>>>>>>>>>>//Declare_Datafile ASDB
75903>>>>>>>>>>>//Declare_Datafile SYSFILE
75903>>>>>>>>>>>//Declare_Datafile VDFCLS
75903>>>>>>>>>>>//Declare_Datafile VDFPRNT
75903>>>>>>>>>>>//Declare_Datafile VDFPROP
75903>>>>>>>>>>>
75903>>>>>>>>>>>
75903>>>>>>>>>>>// 2001-01-09 -RvdW
75903>>>>>>>>>>>//#Replace CURRENT$WORKSPACE   "Hammer"
75903>>>>>>>>>>>
75903>>>>>>>>>>>// 2001-01-09 -RvdW
75903>>>>>>>>>>>//Use cApplicationEx.pkg
75903>>>>>>>>>>>//Use Startup.pkg
75903>>>>>>>>>>>//Object Splash_Screen is a SplashScreenPanel
75903>>>>>>>>>>>//    Set Bitmap to "LOGO.BMP"
75903>>>>>>>>>>>//    Send Activate
75903>>>>>>>>>>>//End_Object
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//Object oApplication is a cApplicationEx
75903>>>>>>>>>>>//    Property Integer piWrkSpcNewFile                False
75903>>>>>>>>>>>//    Property Integer piWrkSpcSetVersion             False
75903>>>>>>>>>>>//    Property Integer piWrkSpcRegister               False
75903>>>>>>>>>>>//    Property String  psWrkSpcOpenFileName           ""
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Set piCmdLineSupport    to True                 // Use it for CommandLine Parameters.
75903>>>>>>>>>>>//    Set psCompany           to CTH_Project_Name
75903>>>>>>>>>>>//    Set psProduct           to CTH_Programm_Name
75903>>>>>>>>>>>//    Set psVersion           to CTH_Version_No
75903>>>>>>>>>>>//    Set peHelpType          to htHtmlHelp
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    //@ RRS: Addded DF19 cConnection support
75903>>>>>>>>>>>//    Object oConnectionManager is a cConnectionManager
75903>>>>>>>>>>>//      // Set pbAutoConnect to False
75903>>>>>>>>>>>//    End_Object
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//        // Propeties to store some global flags.
75903>>>>>>>>>>>//    Object oWrkSpcOpenFileNames is an Array
75903>>>>>>>>>>>//    End_Object
75903>>>>>>>>>>>//        // Sends the given Message to the given Object with all given
75903>>>>>>>>>>>//        // Parameters.
75903>>>>>>>>>>>//    Procedure WrkSpcDoForAllFiles Integer iMsg Integer hoDest
75903>>>>>>>>>>>//        Integer hoID iC
75903>>>>>>>>>>>//        String  sFile
75903>>>>>>>>>>>//        Move (oWrkSpcOpenFileNames(Self)) to hoID
75903>>>>>>>>>>>//        For iC from 0 to (Item_Count(hoID)-1)
75903>>>>>>>>>>>//            Get value of hoID item iC   to sFile
75903>>>>>>>>>>>//            If sFile Ne "" If iMsg If hoDest Begin
75903>>>>>>>>>>>//                Send iMsg to hoDest sFile
75903>>>>>>>>>>>//            End
75903>>>>>>>>>>>//        Loop
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//        // Procedure which are called when the CommandLineParameters are received.
75903>>>>>>>>>>>//    Procedure WrkSpcRegister
75903>>>>>>>>>>>//      Set piWrkSpcRegister    to True
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Procedure WrkSpcOpenFile String sFile
75903>>>>>>>>>>>//        Integer iArg
75903>>>>>>>>>>>//        String  sArg
75903>>>>>>>>>>>//        Set psWrkSpcOpenFileName    to sFile
75903>>>>>>>>>>>//        Send Delete_Data            to (oWrkSpcOpenFileNames(Self))
75903>>>>>>>>>>>//        For iArg from 1 to NUM_Arguments
75903>>>>>>>>>>>//            Move iArg&   to sArg
75903>>>>>>>>>>>//            If (Trim(sArg)) Ne "" Begin
75903>>>>>>>>>>>//                Set value of (oWrkSpcOpenFileNames(Self)) item (Item_Count(oWrkSpcOpenFileNames(Self))) to sArg
75903>>>>>>>>>>>//            End
75903>>>>>>>>>>>//        Loop
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Procedure WrkSpcNewFile
75903>>>>>>>>>>>//        Set piWrkSpcNewFile         to True
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Procedure WrkSpcSetVersion
75903>>>>>>>>>>>//        Set piWrkSpcSetVersion      to True
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//        // Commands which should been handled from the CmdLine:
75903>>>>>>>>>>>//    Send RegisterCommand "-REGISTER"    Msg_WrkSpcRegister      0 "Associates all VDF Filetypes to the Hammer."
75903>>>>>>>>>>>//    Send RegisterCommand "-OPEN"        Msg_WrkSpcOpenFile      0 "Opens the given file."
75903>>>>>>>>>>>//    Send SetDefaultCommand              // -OPEN is the default Command.
75903>>>>>>>>>>>//    Send RegisterCommand "-NEW"         Msg_WrkSpcNewFile       0 "Opens a empty file view."
75903>>>>>>>>>>>//    Send RegisterCommand "-SETVERSION"  Msg_WrkSpcSetVersion    0 "Opens the Version/ Workspace dialog on startup"
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Procedure OnCreate
75903>>>>>>>>>>>//        Send DoOpenWorkspace (CURRENT$WORKSPACE)
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Procedure OpenTH3DB Integer iFileNum
75903>>>>>>>>>>>////      Boolean bOpened
75903>>>>>>>>>>>////      String  sFileName
75903>>>>>>>>>>>////      String  sTH3DataPath
75903>>>>>>>>>>>////      tTH3DB[] TH3DB
75903>>>>>>>>>>>////
75903>>>>>>>>>>>////      Get pTH3DB to TH3DB
75903>>>>>>>>>>>////      Get psDataPath of (phoWorkspace(Self)) to sTH3DataPath
75903>>>>>>>>>>>////      Get vFolderFormat sTH3DataPath to sTH3DataPath
75903>>>>>>>>>>>////      Get_Attribute DF_FILE_OPENED of iFileNum to bOpened
75903>>>>>>>>>>>////      If (bOpened) Begin
75903>>>>>>>>>>>////        Get_Attribute DF_FILE_PHYSICAL_NAME of iFileNum to sFileName
75903>>>>>>>>>>>////        Get ParseFileName sFileName to sFileName // we want no path
75903>>>>>>>>>>>////      End
75903>>>>>>>>>>>////      Case Begin
75903>>>>>>>>>>>////        Case (iFileNum=ASDB.File_Number)
75903>>>>>>>>>>>////          If (Uppercase(sFileName)<>"ASDB") Begin
75903>>>>>>>>>>>////            If (bOpened) Close iFileNum
75903>>>>>>>>>>>////            Open (sTH3DataPath+"ASDB") as ASDB
75903>>>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////          Else Begin
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////        Case Break
75903>>>>>>>>>>>////        Case (iFileNum=SYSFILE.File_Number)
75903>>>>>>>>>>>////          If (Uppercase(sFileName)<>"SYSFILE") Begin
75903>>>>>>>>>>>////            If (bOpened) Close iFileNum
75903>>>>>>>>>>>////            Open (sTH3DataPath+"SYSFILE") as SYSFILE
75903>>>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////          Else Begin
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////        Case Break
75903>>>>>>>>>>>////        Case (iFileNum=VDFCLS.File_Number)
75903>>>>>>>>>>>////          If (Uppercase(sFileName)<>"VDFCLS") Begin
75903>>>>>>>>>>>////            If (bOpened) Close iFileNum
75903>>>>>>>>>>>////            Open (sTH3DataPath+"VDFCLS") as VDFCLS
75903>>>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////          Else Begin
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////        Case Break
75903>>>>>>>>>>>////        Case (iFileNum=VDFPRNT.File_Number)
75903>>>>>>>>>>>////          If (Uppercase(sFileName)<>"VDFCLS") Begin
75903>>>>>>>>>>>////            If (bOpened) Close iFileNum
75903>>>>>>>>>>>////            Open (sTH3DataPath+"VDFCLS") as VDFPRNT
75903>>>>>>>>>>>////            Set_Attribute DF_FILE_ALIAS Of VDFPRNT.File_number To DF_FILE_IS_ALIAS
75903>>>>>>>>>>>////            Set_Attribute DF_FILE_ALIAS Of VDFCLS.File_number  To DF_FILE_IS_MASTER
75903>>>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////          Else Begin
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////        Case Break
75903>>>>>>>>>>>////        Case (iFileNum=VDFPROP.File_Number)
75903>>>>>>>>>>>////          If (Uppercase(sFileName)<>"VDFPROP") Begin
75903>>>>>>>>>>>////            If (bOpened) Close iFileNum
75903>>>>>>>>>>>////            Open (sTH3DataPath+"VDFPROP") as VDFPROP
75903>>>>>>>>>>>////            Move True    To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////          Else Begin
75903>>>>>>>>>>>////            Move bOpened To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>////            Move False   To TH3DB[iFileNum].bReOpen
75903>>>>>>>>>>>////          End
75903>>>>>>>>>>>////        Case Break
75903>>>>>>>>>>>////      Case End
75903>>>>>>>>>>>////      Set pTH3DB to TH3DB
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//    Procedure CloseTH3DB Integer iFileNum
75903>>>>>>>>>>>//      Integer iSize
75903>>>>>>>>>>>//      tTH3DB[] TH3DB
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//      Get pTH3DB to TH3DB
75903>>>>>>>>>>>//      Move (SizeOfArray(TH3DB)-1) To iSize
75903>>>>>>>>>>>//      If (iFileNum>=iSize) Begin
75903>>>>>>>>>>>//        If (TH3DB[iFileNum].bIsOpen) Begin
75903>>>>>>>>>>>//          Close iFileNum
75903>>>>>>>>>>>//          Move False To TH3DB[iFileNum].bIsOpen
75903>>>>>>>>>>>//        End
75903>>>>>>>>>>>//        If (TH3DB[iFileNum].bReOpen) Begin
75903>>>>>>>>>>>//          Open iFileNum // reopens file that current filelist points to.
75903>>>>>>>>>>>//        End
75903>>>>>>>>>>>//        Set pTH3DB to TH3DB
75903>>>>>>>>>>>//      End
75903>>>>>>>>>>>//    End_Procedure
75903>>>>>>>>>>>//
75903>>>>>>>>>>>//End_Object // oApplication
75903>>>>>>>>>>>
75903>>>>>>>>>>>Function THWinRegClassesRootValue String sBranch String sKey Returns String
75906>>>>>>>>>>>//    Handle hCurrentRoot
75906>>>>>>>>>>>//    String sCurrentPath
75906>>>>>>>>>>>//    String sRetVal sValue
75906>>>>>>>>>>>//    UInteger hKey
75906>>>>>>>>>>>//    Integer iSize iError hRootKey
75906>>>>>>>>>>>//
75906>>>>>>>>>>>//#IF (!@ >= 200)
75906>>>>>>>>>>>//    WString wsBranch
75906>>>>>>>>>>>//    WString wsValue
75906>>>>>>>>>>>//    
75906>>>>>>>>>>>//    Move (sBranch+Character(0)) To wsBranch
75906>>>>>>>>>>>//    Get_Registry_Root To hCurrentRoot sCurrentPath
75906>>>>>>>>>>>//    Move 0 To hKey
75906>>>>>>>>>>>//    Move (RegOpenKeyEx(HKEY_CLASSES_ROOT, wsBranch, 0, KEY_READ, AddressOf(hKey))) to iError
75906>>>>>>>>>>>//    If (hKey<>0) Begin
75906>>>>>>>>>>>//        Move 200 to iSize
75906>>>>>>>>>>>//        Move (ZeroString(iSize)) to wsValue
75906>>>>>>>>>>>//        Move (RegQueryValueEx(hKey, sKey, 0, 0, AddressOf(wsValue), AddressOf(iSize))) To iError
75906>>>>>>>>>>>//        Move (CString(wsValue)) to sRetVal
75906>>>>>>>>>>>//        Move (RegCloseKey(hKey)) to iError
75906>>>>>>>>>>>//    End
75906>>>>>>>>>>>//    Set_Registry_Root to hCurrentRoot sCurrentPath
75906>>>>>>>>>>>//#ELSE
75906>>>>>>>>>>>//    Get_Registry_Root To hCurrentRoot sCurrentPath
75906>>>>>>>>>>>//    Move 0 To hKey
75906>>>>>>>>>>>//    Move (RegOpenKeyEx(HKEY_CLASSES_ROOT, ToAnsi(sBranch), 0, KEY_READ, AddressOf(hKey))) to iError
75906>>>>>>>>>>>//    If (hKey<>0) Begin
75906>>>>>>>>>>>//        Move 100 to iSize
75906>>>>>>>>>>>//        Move (ZeroString(iSize)) to sValue
75906>>>>>>>>>>>//        Move (RegQueryValueEx(hKey, sKey, 0, 0, AddressOf(sValue), AddressOf(iSize))) to iError
75906>>>>>>>>>>>//        Move (CString(sValue)) to sRetVal
75906>>>>>>>>>>>//        Move (RegCloseKey(hKey)) to iError
75906>>>>>>>>>>>//    End
75906>>>>>>>>>>>//    Set_Registry_Root to hCurrentRoot sCurrentPath
75906>>>>>>>>>>>//#ENDIF
75906>>>>>>>>>>>//
75906>>>>>>>>>>>//    Function_Return sRetVal
75906>>>>>>>>>>>End_Function
75907>>>>>>>>>>>
75907>>>>>>>>>>>// Provided as a list of Event IDs (but seems like not required)
75907>>>>>>>>>>>Function THCompilerEventID String sVersion Returns String
75910>>>>>>>>>>>    If (sVersion="12.0") Function_Return "{E4C3F246-8F3B-49C6-88E9-3BE282B6990A}"
75913>>>>>>>>>>>    If (sVersion="12.1") Function_Return "{6621490D-0725-44D0-ACF5-86B42A4718F9}"
75916>>>>>>>>>>>    If (sVersion="14.0") Function_Return "{72F51D9A-D76E-474F-8ACE-3276FD7E9D61}"
75919>>>>>>>>>>>    If (sVersion="14.1") Function_Return "{B4F4CE77-4CCB-4B64-9297-7A83484EAD0F}"
75922>>>>>>>>>>>    If (sVersion="15.0") Function_Return "{2C4E9D67-AB48-4F73-8BF2-A837723F150B}"
75925>>>>>>>>>>>    If (sVersion="15.1") Function_Return "{01367077-9E13-458E-B393-936C8DBF6BD2}"
75928>>>>>>>>>>>    If (sVersion="16.0") Function_Return "{765949AB-411F-47B6-9DC8-CC2934DD6C93}"
75931>>>>>>>>>>>    If (sVersion="16.1") Function_Return "{7EF7BDFC-193D-4852-BD42-8F29D8E13558}"
75934>>>>>>>>>>>    If (sVersion="17.0") Function_Return "{DAA0B8DD-A193-4B44-89A4-0FD195158897}"
75937>>>>>>>>>>>    If (sVersion="17.1") Function_Return "{05A055A7-F12E-4B10-A878-0CB4B1B91AF4}"
75940>>>>>>>>>>>    If (sVersion="18.0") Function_Return "{D2508C70-B95A-4B3A-86C5-C043DE93A1CD}"
75943>>>>>>>>>>>    If (sVersion="18.1") Function_Return "{A218E494-0D49-4FBC-B883-54C8312AB504}"
75946>>>>>>>>>>>    If (sVersion="18.2") Function_Return "{3788BA01-C926-4B82-A3BD-936E67E00C54}"
75949>>>>>>>>>>>    If (sVersion="19.0") Function_Return "{2C22F54E-164C-4B28-A089-5357B54A2371}"
75952>>>>>>>>>>>    If (sVersion="19.1") Function_Return ""
75955>>>>>>>>>>>    Function_Return ""
75956>>>>>>>>>>>End_Function
75957>>>>>>>>>>>
75957>>>>>>>>>>>Procedure THEnumerateBuiltInCompilers
75960>>>>>>>>>>>//    Integer iVersion iVersionStart iVersionStop iSubVersion iSubVersions iCompiler
75960>>>>>>>>>>>//    String  sCompiler sVersion sResult sProgID sEventID
75960>>>>>>>>>>>//    tTHCompiler[] THCompilers
75960>>>>>>>>>>>//
75960>>>>>>>>>>>//    Move 12 to iVersionStart
75960>>>>>>>>>>>//    Move 25 to iVersionStop
75960>>>>>>>>>>>//    Move  3 to iSubVersions
75960>>>>>>>>>>>//    Get pTHCompilers of ghoApplication To THCompilers
75960>>>>>>>>>>>//    For iVersion from iVersionStart to iVersionStop
75960>>>>>>>>>>>//        For iSubVersion from 0 to iSubVersions
75960>>>>>>>>>>>//            Move (String(iVersion)+"."+String(iSubVersion)) to sVersion
75960>>>>>>>>>>>//            Move ("vdfcompctl.VDFCompiler."+sVersion) to sCompiler
75960>>>>>>>>>>>//            Move (THWinRegClassesRootValue(Self, sCompiler, "")) to sResult
75960>>>>>>>>>>>//            If (Uppercase(sResult)="VDFCOMPILER OBJECT") Begin
75960>>>>>>>>>>>//                // Looks like it works perfectly without Event ID
75960>>>>>>>>>>>////                Get  THCompilerEventID sVersion     to sEventID
75960>>>>>>>>>>>////                If (sEventID<>"") Begin
75960>>>>>>>>>>>//                    Move (SizeOfArray(THCompilers))                         to iCompiler
75960>>>>>>>>>>>//                    Move sVersion                                           to THCompilers[iCompiler].sVersion
75960>>>>>>>>>>>//                    Get  THWinRegClassesRootValue (sCompiler+"\CLSID") ""   to sProgID
75960>>>>>>>>>>>//                    Move sProgID                                            to THCompilers[iCompiler].sProgID
75960>>>>>>>>>>>//                    Move sEventID                                           to THCompilers[iCompiler].sEventId
75960>>>>>>>>>>>////                End // EventID
75960>>>>>>>>>>>//            End // Compiler Object
75960>>>>>>>>>>>//        Loop
75960>>>>>>>>>>>//    Loop
75960>>>>>>>>>>>//    Set pTHCompilers of ghoApplication To THCompilers
75960>>>>>>>>>>>End_Procedure
75961>>>>>>>>>>>//Send THEnumerateBuiltInCompilers
75961>>>>>>>>>>>
75961>>>>>>>>>>>Function THFindBuiltInCompiler String sVersion Returns Integer
75964>>>>>>>>>>>//    tTHCompiler ltTHCompiler
75964>>>>>>>>>>>//    tTHCompiler[] THCompilers
75964>>>>>>>>>>>//    Move sVersion To ltTHCompiler.sVersion
75964>>>>>>>>>>>//    Get pTHCompilers of ghoApplication To THCompilers
75964>>>>>>>>>>>//    Function_Return (SearchArray(ltTHCompiler, THCompilers))
75964>>>>>>>>>>>End_Function
75965>>>>>>>>>>>
75965>>>>>>>>>>>Function THFindWorkspaceFile String sPath String sType Returns String
75968>>>>>>>>>>>//    String sWSFile
75968>>>>>>>>>>>//    Direct_Input ("DIR:"+sPath+"*."+sType)
75968>>>>>>>>>>>//    While (not(SeqEof))
75968>>>>>>>>>>>//        Readln sWSFile
75968>>>>>>>>>>>//        If (sWSFile<>"") Break
75968>>>>>>>>>>>//    Loop
75968>>>>>>>>>>>//    Close_Input
75968>>>>>>>>>>>//    Function_Return sWSFile
75968>>>>>>>>>>>End_Function
75969>>>>>>>>>>>
75969>>>>>>>>>>>Function THNewWorkspaceName String sPath Returns String
75972>>>>>>>>>>>//    String sWSFile
75972>>>>>>>>>>>//    Number nVersion
75972>>>>>>>>>>>//    // Try to find DataFlex Workspace
75972>>>>>>>>>>>//    Get THFindWorkspaceFile sPath "SWS" to sWSFile
75972>>>>>>>>>>>//    If (sWSFile<>"") Move (Left(sWSFile, Length(sWSFile)-3)) to sWSFile
75972>>>>>>>>>>>//    Else Begin
75972>>>>>>>>>>>//      Get fnCurrentVdfVersion of ghoWorkspaceHandlerEx to nVersion
75972>>>>>>>>>>>//      If (nVersion<80) Begin  // VDF7 and earlier didn't use SWS files
75972>>>>>>>>>>>//        Get CurrentWorkspaceTag of ghoWorkSpaceHandlerEx to sWSFile
75972>>>>>>>>>>>//        If (sWSFile<>"") Move (sWSFile+".") To sWSFile
75972>>>>>>>>>>>//      End
75972>>>>>>>>>>>//      Else Move "Project." to sWSFile
75972>>>>>>>>>>>//    End
75972>>>>>>>>>>>//    //
75972>>>>>>>>>>>//    If (sWSFile<>"") Move (sWSFile+"hws") To sWSFile
75972>>>>>>>>>>>//    Function_Return sWSFile
75972>>>>>>>>>>>End_Function
75973>>>>>>>>>>>
75973>>>>>>>>>>>Function THWorkspaceName String sPath Integer ByRef bNew Integer ByRef iType Returns String
75976>>>>>>>>>>>//    String sWSFile
75976>>>>>>>>>>>//    Direct_Input ("DIR:"+sPath+'*.hws')
75976>>>>>>>>>>>//    While (not(SeqEof))
75976>>>>>>>>>>>//        Readln sWSFile
75976>>>>>>>>>>>//        If (sWSFile<>"") Break
75976>>>>>>>>>>>//    Loop
75976>>>>>>>>>>>//    Close_Input
75976>>>>>>>>>>>//    If (sWSFile="") Begin
75976>>>>>>>>>>>//        Get THNewWorkspaceName sPath to sWSFile
75976>>>>>>>>>>>//        If (sWSFile="") Move "Project.hws" to sWSFile
75976>>>>>>>>>>>//        Else Move 1 to iType // DataFlex Workspace
75976>>>>>>>>>>>//        Move 1 to bNew
75976>>>>>>>>>>>//    End
75976>>>>>>>>>>>//    Function_Return sWSFile
75976>>>>>>>>>>>End_Function
75977>>>>>>>>>>>
75977>>>>>>>>>>>// *** Load Language from Studio 12+ (Used by THParameters Dialog)
75977>>>>>>>>>>>// Loading from the Current Workspace Version
75977>>>>>>>>>>>Procedure LoadLanguageTokens String sLanguage String sElement Handle hoTokens Integer iList tTHLanguage ByRef ltTHLanguage
75980>>>>>>>>>>>    Handle hoToken
75980>>>>>>>>>>>    String sToken sStrings
75980>>>>>>>>>>>    Integer iScopeStart iScopeStop iKeyword iOperator
75980>>>>>>>>>>>    Move (Uppercase(sLanguage)) to sLanguage
75981>>>>>>>>>>>    Get FirstChild of hoTokens to hoToken
75982>>>>>>>>>>>    While (hoToken <> 0)
75986>>>>>>>>>>>        Get psText of hoToken "" "" to sToken
75987>>>>>>>>>>>        //
75987>>>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saKeywords))     to iKeyword
75988>>>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saScopeStart))   to iScopeStart
75989>>>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saScopeStop))    to iScopeStop
75990>>>>>>>>>>>        Move (SizeOfArray(ltTHLanguage.saOperators))    to iOperator
75991>>>>>>>>>>>        //
75991>>>>>>>>>>>        If ((sElement="BLOCKCOMMENTS")and(iList=0)) Move sToken to ltTHLanguage.sMultiLineCommentStart
75994>>>>>>>>>>>        If ((sElement="BLOCKCOMMENTS")and(iList=1)) Move sToken to ltTHLanguage.sMultiLineCommentStop
75997>>>>>>>>>>>        If ((sElement="1001")and(iList=0)) Move sToken to ltTHLanguage.sMetaStart
76000>>>>>>>>>>>        If ((sElement="1001")and(iList=1)) Move sToken to ltTHLanguage.sMetaStop
76003>>>>>>>>>>>        If (sElement="LINECOMMENTS") Move sToken to ltTHLanguage.sLineComments
76006>>>>>>>>>>>        If (sElement="1002") Move sToken to ltTHLanguage.saKeywords[iKeyword] // Use|#Include
76009>>>>>>>>>>>        If ((sElement="DEFINITIONBLOCKS")and(iList=0)) Move sToken to ltTHLanguage.saScopeStart[iScopeStart]
76012>>>>>>>>>>>        If ((sElement="DEFINITIONBLOCKS")and(iList=1)) Move sToken to ltTHLanguage.saScopeStop[iScopeStop]
76015>>>>>>>>>>>        If ((sElement="SCOPEKEYWORDS")and(iList=0)) Move sToken to ltTHLanguage.saScopeStart[iScopeStart]
76018>>>>>>>>>>>        If ((sElement="SCOPEKEYWORDS")and(iList=1)) Move sToken to ltTHLanguage.saScopeStop[iScopeStop]
76021>>>>>>>>>>>        If (sElement="KEYWORDS") Move sToken to ltTHLanguage.saKeywords[iKeyword]
76024>>>>>>>>>>>        If (sElement="OPERATORS") Begin
76026>>>>>>>>>>>            Move (Replace("&lt;&gt;", sToken, "<>")) to sToken
76027>>>>>>>>>>>            Move (Replace("&lt;", sToken, "<")) to sToken
76028>>>>>>>>>>>            Move (Replace("&gt;", sToken, ">")) to sToken
76029>>>>>>>>>>>            Move (Replace("&amp;", sToken, "&")) to sToken
76030>>>>>>>>>>>            Move sToken to ltTHLanguage.saOperators[iOperator]
76031>>>>>>>>>>>        End
76031>>>>>>>>>>>>
76031>>>>>>>>>>>        If ((sElement="RESOURCEBLOCK")and(iList=0)) Move sToken to ltTHLanguage.saScopeStart[iScopeStart]
76034>>>>>>>>>>>        If ((sElement="RESOURCEBLOCK")and(iList=1)) Move sToken to ltTHLanguage.saScopeStop[iScopeStop]
76037>>>>>>>>>>>        If ((sElement="STRINGS")and(iList=0)) Begin
76039>>>>>>>>>>>            Move ltTHLanguage.sStringDelimiter to sStrings
76040>>>>>>>>>>>            If (sStrings="") Move sToken to sStrings
76043>>>>>>>>>>>            Else Move (sStrings+"\n"+sToken) to sStrings
76045>>>>>>>>>>>            Move sStrings to ltTHLanguage.sStringDelimiter
76046>>>>>>>>>>>        End
76046>>>>>>>>>>>>
76046>>>>>>>>>>>        //
76046>>>>>>>>>>>        Get NextNode of hoToken to hoToken
76047>>>>>>>>>>>    Loop
76048>>>>>>>>>>>>
76048>>>>>>>>>>>    Send Destroy to hoTokens
76049>>>>>>>>>>>End_Procedure
76050>>>>>>>>>>>Function LoadLanguage String sLanguage Returns tTHLanguage
76053>>>>>>>>>>>//    tTHLanguage ltTHLanguage
76053>>>>>>>>>>>//    String      sVdfConfig
76053>>>>>>>>>>>//    String      sPath
76053>>>>>>>>>>>//    String      sFile
76053>>>>>>>>>>>//    String      sValue
76053>>>>>>>>>>>//    Integer     bOK
76053>>>>>>>>>>>//    Handle      hoXML
76053>>>>>>>>>>>//    Handle      hoRoot
76053>>>>>>>>>>>//    Handle      hoTokenSet
76053>>>>>>>>>>>//    Handle      hoTokens
76053>>>>>>>>>>>//    If ((Uppercase(sLanguage)="VDF")or(sLanguage=""))   Move "DataFlex" to sLanguage
76053>>>>>>>>>>>//    If (Uppercase(sLanguage) contains "SQL")            Move "SQL" to sLanguage
76053>>>>>>>>>>>//    Get psVdfRootDir    of ghoWorkSpaceHandlerEx to sVdfConfig
76053>>>>>>>>>>>//    Get PathAtIndex     of (phoWorkspace(ghoApplication)) sVdfConfig 1 to sPath
76053>>>>>>>>>>>//    Move (sPath+"\Lib\"+sLanguage+".lng") to sFile
76053>>>>>>>>>>>//    Get Create (RefClass(cXMLDOMDocument)) to hoXML
76053>>>>>>>>>>>//    If (hoXML) Begin
76053>>>>>>>>>>>//        Set psDocumentName  of hoXML to sFile
76053>>>>>>>>>>>//        Get LoadXMLDocument of hoXML to bOK
76053>>>>>>>>>>>//        If (bOK) Begin
76053>>>>>>>>>>>//            Get DocumentElement of hoXML to hoRoot // Language
76053>>>>>>>>>>>//            If (hoRoot) Begin
76053>>>>>>>>>>>//                Move 1 to ltTHLanguage.iProcedural
76053>>>>>>>>>>>//                Get AttributeValueNS of hoRoot "" "name" to ltTHLanguage.sName
76053>>>>>>>>>>>//                Get AttributeValueNS of hoRoot "" "casesensitive" to sValue
76053>>>>>>>>>>>//                If (Uppercase(sValue)<>"NO") Move 1 to ltTHLanguage.iCaseSensitive
76053>>>>>>>>>>>//                Get FirstChild of hoRoot to hoTokenSet
76053>>>>>>>>>>>//                If hoTokenSet Begin
76053>>>>>>>>>>>//                    While (hoTokenSet<>0)
76053>>>>>>>>>>>//                        Get AttributeValueNS of hoTokenSet "" "id" to sValue
76053>>>>>>>>>>>//                        Move (Uppercase(sValue)) to sValue
76053>>>>>>>>>>>//                        // Token List 1
76053>>>>>>>>>>>//                        Get ChildElementNS of hoTokenSet "" "tokens"   to hoTokens
76053>>>>>>>>>>>//                        If hoTokens ;
76053>>>>>>>>>>>//                            Send LoadLanguageTokens sLanguage sValue hoTokens 0 (&ltTHLanguage)
76053>>>>>>>>>>>//                        // Token List 2
76053>>>>>>>>>>>//                        Get ChildElementNS of hoTokenSet "" "tokens2"  to hoTokens
76053>>>>>>>>>>>//                        If hoTokens ;
76053>>>>>>>>>>>//                            Send LoadLanguageTokens sLanguage sValue hoTokens 1 (&ltTHLanguage)
76053>>>>>>>>>>>//                        //
76053>>>>>>>>>>>//                        Get NextNode of hoTokenSet to hoTokenSet
76053>>>>>>>>>>>//                    Loop // hoTokenSet
76053>>>>>>>>>>>//                End
76053>>>>>>>>>>>//                Send Destroy to hoRoot
76053>>>>>>>>>>>//            End // hoRoot
76053>>>>>>>>>>>//        End // LoadXMLDocument OK
76053>>>>>>>>>>>//        Send Destroy of hoXML
76053>>>>>>>>>>>//    End // hoXML
76053>>>>>>>>>>>//    Function_Return ltTHLanguage
76053>>>>>>>>>>>End_Function
76054>>>>>>>>>>>
76054>>>>>>>>>>>Procedure THWorkspaceDataFlexDefaults String sHome
76057>>>>>>>>>>>//    Integer iExt
76057>>>>>>>>>>>//    tTHWorkspace THWorkspace
76057>>>>>>>>>>>//    // General
76057>>>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
76057>>>>>>>>>>>//    Move "DataFlex"                     to THWorkspace.sSchema
76057>>>>>>>>>>>//    Get CurrentWorkSpaceDescription ;
76057>>>>>>>>>>>//        of ghoWorkSpaceHandlerEx        to THWorkspace.sName
76057>>>>>>>>>>>//    // Folders
76057>>>>>>>>>>>//    Move sHome                          to THWorkspace.saFolders[0]
76057>>>>>>>>>>>//    // Files
76057>>>>>>>>>>>//    Move "SRC"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Project (Program)"   to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "PKG"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Package"             to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "INC"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Include File"                 to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "DD"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Data Dictionary"              to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "MN"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Menu (obsolete)"     to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "H"                            to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Header"                       to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "BP"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Business Process"    to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "UTL"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Sture's Utility"              to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "DG"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Dialog"              to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "SL"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Selection List"      to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "VW"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex View"                to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "RV"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Report View"         to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "WO"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Web Object"          to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "HTM"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "HyperText Markup Language"    to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "HTML"                         to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "HyperText Markup Language"    to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "ASP"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Active Server Page"           to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "JS"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "JavaScript"                   to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "WS"                           to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Workspace"           to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "SWS"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "DataFlex Studio Workspace"    to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "INI"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Configuration File"           to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "CSS"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Cascading Style Sheet"        to THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Increment iExt
76057>>>>>>>>>>>//    Move "INT"                          to THWorkspace.saFiles[iExt]
76057>>>>>>>>>>>//    Move "Database Intermediate File"   To THWorkspace.saFileDesc[iExt]
76057>>>>>>>>>>>//    Set pTHWorkspace of ghoApplication To THWorkspace
76057>>>>>>>>>>>End_Procedure
76058>>>>>>>>>>>
76058>>>>>>>>>>>Function THWorkspaceHome Returns String
76061>>>>>>>>>>>//    String sHome sPath
76061>>>>>>>>>>>//    String sWsFile sWSHome
76061>>>>>>>>>>>//    Number nVersion
76061>>>>>>>>>>>//    Get fnCurrentVdfVersion  of ghoWorkSpaceHandlerEx to nVersion
76061>>>>>>>>>>>//    If (nVersion>=120) Begin
76061>>>>>>>>>>>//      Get CurrentHomePath of ghoWorkSpaceHandlerEx to sWSHome // usually a relative path such as "." or "..\"
76061>>>>>>>>>>>//      Get CurrentWSFile   of ghoWorkSpaceHandlerEx to sWsFile
76061>>>>>>>>>>>//      Get ParseFolderName sWsFile to sPath
76061>>>>>>>>>>>//      Get ConvertRelativePath of ghoWorkSpaceHandlerEx sWSHome "."  sPath To sHome
76061>>>>>>>>>>>//    End
76061>>>>>>>>>>>//    Else Begin
76061>>>>>>>>>>>//      Get PrimaryProgramPath   of ghoWorkSpaceHandlerEx   to sPath
76061>>>>>>>>>>>//      Get vParentPath sPath To sHome
76061>>>>>>>>>>>//    End
76061>>>>>>>>>>>//    Function_Return sHome
76061>>>>>>>>>>>End_Function
76062>>>>>>>>>>>
76062>>>>>>>>>>>Procedure THDoReadWorkspace String sWSFile
76065>>>>>>>>>>>//    Boolean  bExists
76065>>>>>>>>>>>//    Integer  bNew iType
76065>>>>>>>>>>>//    Integer  iFFOptions
76065>>>>>>>>>>>//    String   sFile sHome sDescription sFolder
76065>>>>>>>>>>>//    Handle   hoWorkspace
76065>>>>>>>>>>>//    //
76065>>>>>>>>>>>//    String sVersion sSize sTmp
76065>>>>>>>>>>>//    Integer iFolder iFolders iFile iFiles iExclude iExcludes
76065>>>>>>>>>>>//    Integer iSize
76065>>>>>>>>>>>//    tTHWorkspace THWorkspace  EmptyTHWorkspace
76065>>>>>>>>>>>//    //
76065>>>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
76065>>>>>>>>>>>//    If (num_arguments>0) Move sWSFile to sFile
76065>>>>>>>>>>>//    If (sFile="") Begin
76065>>>>>>>>>>>//        // Assume it is DataFlex Project by Default
76065>>>>>>>>>>>//        Get THWorkspaceHome to sHome
76065>>>>>>>>>>>//    End
76065>>>>>>>>>>>//    Get vFolderFormat sHome To sHome
76065>>>>>>>>>>>//    Get THWorkspaceName sHome (&bNew) (&iType) to sFile
76065>>>>>>>>>>>//    // 1. Clear Repository
76065>>>>>>>>>>>//    Move EmptyTHWorkspace to THWorkspace
76065>>>>>>>>>>>//    // 2. Set Workspace (HWS) File
76065>>>>>>>>>>>//    Move (sHome+sFile) to THWorkspace.sFullName
76065>>>>>>>>>>>//    // 3. Read Options or Create HWS Template (if New)
76065>>>>>>>>>>>//    If (bNew) Begin
76065>>>>>>>>>>>//        Move 1 to THWorkspace.iShowPaths
76065>>>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
76065>>>>>>>>>>>//        If (iType=1) Begin
76065>>>>>>>>>>>//            // DataFlex Defaults
76065>>>>>>>>>>>//            Send THWorkspaceDataFlexDefaults sHome
76065>>>>>>>>>>>//        End
76065>>>>>>>>>>>//        Send THDoWriteWorkspace
76065>>>>>>>>>>>//    End
76065>>>>>>>>>>>//    Else Begin
76065>>>>>>>>>>>//        // Read HWS file if found
76065>>>>>>>>>>>//        Direct_Input ("Binary:"*sHome+sFile)
76065>>>>>>>>>>>//        // Header
76065>>>>>>>>>>>//        Readln sVersion
76065>>>>>>>>>>>//        Move (Left(sVersion, 7)) to sVersion
76065>>>>>>>>>>>//        If (Left(sVersion, 3)<>"HWS") Begin
76065>>>>>>>>>>>//            Close_Input
76065>>>>>>>>>>>//            Send UserError ("File"*sHome+sFile*"is not a valid Hammer .hws file. Falling back to defaults.")
76065>>>>>>>>>>>//            Move 1 to THWorkspace.iShowPaths
76065>>>>>>>>>>>//            Set pTHWorkspace of ghoApplication To THWorkspace
76065>>>>>>>>>>>//            If (iType=1) Begin
76065>>>>>>>>>>>//                // DataFlex Defaults
76065>>>>>>>>>>>//                Send THWorkspaceDataFlexDefaults sHome
76065>>>>>>>>>>>//            End
76065>>>>>>>>>>>//            Procedure_Return // Not a HWS file
76065>>>>>>>>>>>//        End
76065>>>>>>>>>>>//        // General
76065>>>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sName
76065>>>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sSchema
76065>>>>>>>>>>>//        Get WSReadInt1      to THWorkspace.iShowPaths
76065>>>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sStudio
76065>>>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sCompiler
76065>>>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sDBEditor
76065>>>>>>>>>>>//        Get WSReadStr2      to THWorkspace.sDBViewer
76065>>>>>>>>>>>//        // Folders
76065>>>>>>>>>>>//        Get WSReadInt2      to iFolders
76065>>>>>>>>>>>//        For iFolder from 0  to (iFolders-1)
76065>>>>>>>>>>>//            Get WSReadStr2  to sFolder
76065>>>>>>>>>>>//            If (iFolder=0) Begin // Check that our home folder hasn't changed
76065>>>>>>>>>>>//              //Get vFolderExists sFolder to bExists  <-- Can't use this one as it depends on DIR: and thus opens its own channel and mucks this up completely
76065>>>>>>>>>>>//              Get vFilePathExists (sFolder+"*") to bExists
76065>>>>>>>>>>>//              If (bExists=false) Begin
76065>>>>>>>>>>>//                Move "" To sFolder
76065>>>>>>>>>>>//              End
76065>>>>>>>>>>>//            End
76065>>>>>>>>>>>//            Move sFolder To THWorkspace.saFolders[iFolder]
76065>>>>>>>>>>>//        Loop
76065>>>>>>>>>>>//        If (SizeOfArray(THWorkspace.saFolders)=0 Or THWorkspace.saFolders[0]="") Begin
76065>>>>>>>>>>>//                                                  // if the user renames the folder then the logic can no longer find our home path
76065>>>>>>>>>>>//          Move sHome To THWorkspace.saFolders[0]  // Put the home path of our workspace in there
76065>>>>>>>>>>>//        End
76065>>>>>>>>>>>//        // Files
76065>>>>>>>>>>>//        Get WSReadInt2      to iFiles
76065>>>>>>>>>>>//        For iFile from 0    to (iFiles-1)
76065>>>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saFiles[iFile]
76065>>>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saFileDesc[iFile]
76065>>>>>>>>>>>//        Loop
76065>>>>>>>>>>>//        // Excludes
76065>>>>>>>>>>>//        Get WSReadInt2      to iExcludes
76065>>>>>>>>>>>//        For iExclude from 0 to (iExcludes-1)
76065>>>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saExclude[iExclude]
76065>>>>>>>>>>>//        Loop
76065>>>>>>>>>>>//        // Sources
76065>>>>>>>>>>>//        Get WSReadInt2      to iFiles
76065>>>>>>>>>>>//        For iFile from 0    to (iFiles-1)
76065>>>>>>>>>>>//            Get WSReadStr2  to THWorkspace.taSources[iFile].sFile
76065>>>>>>>>>>>//            Get WSReadStr4  to THWorkspace.taSources[iFile].sBookmarks
76065>>>>>>>>>>>//            Get WSReadInt2  to THWorkspace.taSources[iFile].iBookmarkCount
76065>>>>>>>>>>>//            Get WSReadInt2  to THWorkspace.taSources[iFile].iCursorColumn
76065>>>>>>>>>>>//            Get WSReadInt2  to THWorkspace.taSources[iFile].iCursorLine
76065>>>>>>>>>>>//        Loop
76065>>>>>>>>>>>//        // Find in Files
76065>>>>>>>>>>>//        Get WSReadStr2  to THWorkspace.sFFText
76065>>>>>>>>>>>//        Get WSReadStr2  to THWorkspace.sFFTypes
76065>>>>>>>>>>>//        Get WSReadStr2  to THWorkspace.sFFPath
76065>>>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFMatchWord
76065>>>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFMatchCase
76065>>>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFSubFolders
76065>>>>>>>>>>>//        Get WSReadInt1  To iFFOptions  // encoding the iFFShowAll and iFFExcludeComments into the same byte so
76065>>>>>>>>>>>//                                       // that I do not have to handle the versioning nightmare it will create otherwise.
76065>>>>>>>>>>>//        If (iFFOptions iAnd 1) Move 1 To THWorkspace.iFFShowAll
76065>>>>>>>>>>>//        If (iFFOptions iAnd 2) Move 1 To THWorkspace.iFFExcludeComments
76065>>>>>>>>>>>//        Get WSReadInt1  to THWorkspace.iFFRegExp
76065>>>>>>>>>>>//        // Opened Files
76065>>>>>>>>>>>//        Get WSReadInt2      to iFiles
76065>>>>>>>>>>>//        For iFile from 0    to (iFiles-1)
76065>>>>>>>>>>>//            Get WSReadStr2  to THWorkspace.saOpened[iFile]
76065>>>>>>>>>>>//        Loop
76065>>>>>>>>>>>//        Close_Input
76065>>>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
76065>>>>>>>>>>>//    End
76065>>>>>>>>>>>End_Procedure
76066>>>>>>>>>>>
76066>>>>>>>>>>>//
76066>>>>>>>>>>>// During debugging I see bookmark/cursor position items in the taSources
76066>>>>>>>>>>>// arrays without a filename. Not sure why that can happen, but we don't want
76066>>>>>>>>>>>// to keep those as at has no value then.
76066>>>>>>>>>>>//
76066>>>>>>>>>>>Procedure RemoveEmptyBookmarkSources tTHSource[] ByRef taSources
76069>>>>>>>>>>>//  Integer iFile
76069>>>>>>>>>>>//  Integer iFiles
76069>>>>>>>>>>>//  String  sFile
76069>>>>>>>>>>>//  
76069>>>>>>>>>>>//  Move (SizeOfArray(taSources)) to iFiles
76069>>>>>>>>>>>//  Move (iFiles-1) To iFile
76069>>>>>>>>>>>//  While (iFile>0)
76069>>>>>>>>>>>//    Move (trim(taSources[iFile].sFile)) to sFile
76069>>>>>>>>>>>//    If (sFile="") Begin
76069>>>>>>>>>>>//      Move (RemoveFromArray(taSources,iFile)) To taSources
76069>>>>>>>>>>>//    End
76069>>>>>>>>>>>//    Decrement iFile
76069>>>>>>>>>>>//  Loop
76069>>>>>>>>>>>End_Procedure
76070>>>>>>>>>>>
76070>>>>>>>>>>>Procedure THDoWriteWorkspace
76073>>>>>>>>>>>//    Integer iFolder iFolders iFile iFiles iExclude iExcludes
76073>>>>>>>>>>>//    Integer iFFOptions
76073>>>>>>>>>>>//    String  sFile
76073>>>>>>>>>>>//    tTHWorkspace THWorkspace
76073>>>>>>>>>>>//    Get pTHWorkspace of ghoApplication To  THWorkspace
76073>>>>>>>>>>>//    Send RemoveEmptyBookmarkSources (&THWorkspace.taSources)
76073>>>>>>>>>>>//    Move THWorkspace.sFullName To sFile
76073>>>>>>>>>>>//    Direct_Output sFile
76073>>>>>>>>>>>//        // Header
76073>>>>>>>>>>>//        Writeln "HWS0301, (C) 2018, KURANT Project"
76073>>>>>>>>>>>//        //
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sName
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sSchema
76073>>>>>>>>>>>//        Write (Character(THWorkspace.iShowPaths))
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sStudio
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sCompiler
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sDBEditor
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sDBViewer
76073>>>>>>>>>>>//        // Folders
76073>>>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saFolders)) to iFolders
76073>>>>>>>>>>>//        Write (SHORTtoUChar(iFolders))
76073>>>>>>>>>>>//        For iFolder from 0 to (iFolders-1)
76073>>>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saFolders[iFolder]
76073>>>>>>>>>>>//        Loop
76073>>>>>>>>>>>//        // Files
76073>>>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saFiles)) to iFiles
76073>>>>>>>>>>>//        Write (SHORTtoUChar(iFiles))
76073>>>>>>>>>>>//        For iFile from 0 to (iFiles-1)
76073>>>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saFiles[iFile]
76073>>>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saFileDesc[iFile]
76073>>>>>>>>>>>//        Loop
76073>>>>>>>>>>>//        // Excludes
76073>>>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saExclude)) to iExcludes
76073>>>>>>>>>>>//        Write (SHORTtoUChar(iExcludes))
76073>>>>>>>>>>>//        For iExclude from 0 to (iExcludes-1)
76073>>>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saExclude[iExclude]
76073>>>>>>>>>>>//        Loop
76073>>>>>>>>>>>//        // File Information
76073>>>>>>>>>>>//        Move (SizeOfArray(THWorkspace.taSources)) to iFiles
76073>>>>>>>>>>>//        Write (SHORTtoUChar(iFiles))
76073>>>>>>>>>>>//        For iFile from 0 to (iFiles-1)
76073>>>>>>>>>>>//            Send WSWriteStr2 THWorkspace.taSources[iFile].sFile
76073>>>>>>>>>>>//            Send WSWriteStr4 THWorkspace.taSources[iFile].sBookmarks
76073>>>>>>>>>>>//            Write (SHORTtoUChar(THWorkspace.taSources[iFile].iBookmarkCount))
76073>>>>>>>>>>>//            Write (SHORTtoUChar(THWorkspace.taSources[iFile].iCursorColumn))
76073>>>>>>>>>>>//            Write (SHORTtoUChar(THWorkspace.taSources[iFile].iCursorLine))
76073>>>>>>>>>>>//        Loop
76073>>>>>>>>>>>//        // Find in Files
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sFFText
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sFFTypes
76073>>>>>>>>>>>//        Send WSWriteStr2 THWorkspace.sFFPath
76073>>>>>>>>>>>//        Write (Character(THWorkspace.iFFMatchWord)) // 0|1
76073>>>>>>>>>>>//        Write (Character(THWorkspace.iFFMatchCase))
76073>>>>>>>>>>>//        Write (Character(THWorkspace.iFFSubFolders))
76073>>>>>>>>>>>//        Move 0 To iFFOptions
76073>>>>>>>>>>>//        If (THWorkspace.iFFShowAll)         Move 1 To iFFOptions
76073>>>>>>>>>>>//        If (THWorkspace.iFFExcludeComments) Move (iFFOptions iOr 2) To iFFOptions
76073>>>>>>>>>>>//        Write (Character(iFFOptions))
76073>>>>>>>>>>>//        Write (Character(THWorkspace.iFFRegExp))
76073>>>>>>>>>>>//        // Opened Files
76073>>>>>>>>>>>//        Move (SizeOfArray(THWorkspace.saOpened)) to iFiles
76073>>>>>>>>>>>//        Write (SHORTtoUChar(iFiles))
76073>>>>>>>>>>>//        For iFile from 0 to (iFiles-1)
76073>>>>>>>>>>>//            Send WSWriteStr2 THWorkspace.saOpened[iFile]
76073>>>>>>>>>>>//        Loop
76073>>>>>>>>>>>//    Close_Output
76073>>>>>>>>>>>End_Procedure
76074>>>>>>>>>>>
76074>>>>>>>>>>>// This Procedure should no longer be neccessary.
76074>>>>>>>>>>>// MK 27.06.2001 21:41
76074>>>>>>>>>>>// This Procedure still required as TH3 loses standard DF packages visibility
76074>>>>>>>>>>>// SN 29.03.2017 13:12
76074>>>>>>>>>>>Procedure AddToOpenPath String ByRef sOpenPath String ByRef sPath
76077>>>>>>>>>>>    String sTmp
76077>>>>>>>>>>>    If (sPath="") Procedure_Return
76080>>>>>>>>>>>    If ((Pos(';', sPath)=0) and (Uppercase(sOpenPath) contains Uppercase(sPath))) Procedure_Return
76083>>>>>>>>>>>    If (Pos(';', sPath)=0) Begin
76085>>>>>>>>>>>        Move (sOpenPath+";"+sPath) to sOpenPath
76086>>>>>>>>>>>        Procedure_Return
76087>>>>>>>>>>>    End
76087>>>>>>>>>>>>
76087>>>>>>>>>>>    While (Pos(';', sPath))
76091>>>>>>>>>>>        Move (Left(sPath, Pos(';', sPath))) to sTmp
76092>>>>>>>>>>>        Move (Replace(sTmp, sPath, "")) to sPath
76093>>>>>>>>>>>        If (sTmp<>".;") ;            Move (Replace(';', sTmp, "")) to sTmp
76096>>>>>>>>>>>        If (not(Uppercase(sOpenPath) contains Uppercase(sTmp))) Begin
76098>>>>>>>>>>>            If (sTmp=".;") ;                Move (Replace(';', sTmp, "")) to sTmp
76101>>>>>>>>>>>            Move (sOpenPath +';'+sTmp) to sOpenPath
76102>>>>>>>>>>>        End
76102>>>>>>>>>>>>
76102>>>>>>>>>>>    Loop
76103>>>>>>>>>>>>
76103>>>>>>>>>>>    If (sPath<>"") Begin
76105>>>>>>>>>>>        If (not(Uppercase(sOpenPath) contains Uppercase(sPath))) ;            Move (sOpenPath + ";" + sPath) to sOpenPath
76108>>>>>>>>>>>    End
76108>>>>>>>>>>>>
76108>>>>>>>>>>>End_Procedure
76109>>>>>>>>>>>
76109>>>>>>>>>>>Procedure IncludeMakePath
76112>>>>>>>>>>>    String sMake sMake2 sOpenPath
76112>>>>>>>>>>>    Get_Attribute DF_OPEN_PATH          to sOpenPath
76115>>>>>>>>>>>    Get_Profile_String "DFCOMP" ;                       "MakePath"       to sMake
76118>>>>>>>>>>>    Send AddToOpenPath (&sOpenPath) (&sMake)
76119>>>>>>>>>>>    Get_Profile_String "WorkSpaces" ;                       "SystemMakePath" to sMake2
76122>>>>>>>>>>>    Send AddToOpenPath (&sOpenPath) (&sMake2)
76123>>>>>>>>>>>    Set_Attribute DF_OPEN_PATH          to sOpenPath
76126>>>>>>>>>>>End_Procedure
76127>>>>>>>>>>>Send IncludeMakePath
76128>>>>>>>>>>>
76128>>>>>>>>>>>Procedure THRegisterDFClass tDFDefaultClasses[] ByRef ltDFClasses String sCategory String sClass String sPackage
76131>>>>>>>>>>>    Integer iCount
76131>>>>>>>>>>>    Move (SizeOfArray(ltDFClasses)) to iCount
76132>>>>>>>>>>>    Move sCategory  to ltDFClasses[iCount].sCategory
76133>>>>>>>>>>>    Move sClass     to ltDFClasses[iCount].sClass
76134>>>>>>>>>>>    Move sPackage   to ltDFClasses[iCount].sFile
76135>>>>>>>>>>>End_Procedure
76136>>>>>>>>>>>Procedure LoadDefaultClasses tDFDefaultClasses[] ByRef ltDFClasses
76139>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "DataDictionary"          "DataDictionary"        "DataDict.pkg"
76140>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbForm"                  "dbForm"                "DFEntry.pkg"
76141>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbEdit"                  "cDbTextEdit"           "cDbTextEdit.pkg"
76142>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbCombo"                 "dbComboForm"           "DfCEntry.pkg"
76143>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbCheckBox"              "dbCheckBox"            "DFEnChk.pkg"
76144>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbSpinForm"              "dbSpinForm"            "DFSpnEnt.pkg"
76145>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbGrid"                  "dbGrid"                "DfTable.pkg"
76146>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbList"                  "dbList"                "DFSelLst.pkg"
76147>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbTabDialog"             "dbTabDialog"           "DfTabDlg.pkg"
76148>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbTabPage"               "dbTabPage"             "DfTabDlg.pkg"
76149>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbView"                  "dbView"                "DFClient.pkg"
76150>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "dbModalPanel"            "dbModalPanel"          "DFClient.pkg"
76151>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "ReportView"              "ReportView"            "DFRptVw.pkg"
76152>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWinReport2"             "cWinReport2"           "cWinReport2.pkg"
76153>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Button"                  "Button"                "Windows.pkg"
76154>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Radio"                   "Radio"                 "Windows.pkg"
76155>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Form"                    "Form"                  "Windows.pkg"
76156>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Group"                   "Group"                 "Windows.pkg"
76157>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "RadioGroup"              "RadioGroup"            "Windows.pkg"
76158>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "Menubar/toolbar System"  "cCJCommandBarSystem"   "cCJStandardCommandBarSystem.pkg"
76159>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "MenuItem"                "cCJMenuItem"           "cCJCommandBarSystem.pkg"
76160>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cDbCJGrid"               "cDbCJGrid"             "cDbCJGrid.pkg"
76161>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cDbCJGridColumn"         "cDbCJGridColumn"       "cDbCJGridColumn.pkg"
76162>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cDbCJGridPromptList"     "cDbCJGridPromptList"   "cDbCJGridPromptList.pkg"
76163>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebButton"              "cWebButton"            "cWebButton.pkg"
76164>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebCheckBox"            "cWebCheckBox"          "cWebCheckBox.pkg"
76165>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebCombo"               "cWebCombo"             "cWebCombo.pkg"
76166>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebEdit"                "cWebEdit"              "cWebEdit.pkg"
76167>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebForm"                "cWebForm"              "cWebForm.pkg"
76168>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebGrid"                "cWebGrid"              "cWebGrid.pkg"
76169>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebColumn"              "cWebColumn"            "cWebColumn.pkg"
76170>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebColumnCheckBox"      "cWebColumnCheckBox"    "cWebColumnCheckBox.pkg"
76171>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebColumnCombo"         "cWebColumnCombo"       "cWebColumnCombo.pkg"
76172>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebMenuItem"            "cWebMenuItem"          "cWebMenuItem.pkg"
76173>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebMenuItemLoadView"    "cWebMenuItemLoadView"  "cWebMenuItemLoadView.pkg"
76174>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebModalDialog"         "cWebModalDialog"       "cWebModalDialog.pkg"
76175>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebPanel"               "cWebPanel"             "cWebPanel.pkg"
76176>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebPromptList"          "cWebPromptList"        "cWebPromptList.pkg"
76177>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebTabContainer"        "cWebTabContainer"      "cWebTabContainer.pkg"
76178>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebTabPage"             "cWebTabPage"           "cWebTabPage.pkg"
76179>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "cWebView"                "cWebView"              "cWebView.pkg"
76180>>>>>>>>>>>    Send THRegisterDFClass (&ltDFClasses) "WebBusinessProcess"      "cWebBusinessProcess"   "cWebBusinessProcess.pkg"
76181>>>>>>>>>>>End_Procedure
76182>>>>>>>>>>>
76182>>>>>>>>>>>// Source File
76182>>>>>>>>>>>Function THWS_FindFile String sFile Returns Integer
76185>>>>>>>>>>>//    tTHSource ltaSource
76185>>>>>>>>>>>//    tTHWorkspace THWorkspace
76185>>>>>>>>>>>//    Move (Uppercase(sFile)) To ltaSource.sFile
76185>>>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
76185>>>>>>>>>>>//    Function_Return (SearchArray(ltaSource, THWorkspace.taSources))
76185>>>>>>>>>>>End_Function
76186>>>>>>>>>>>Function THWS_FileIndex String sFile Returns Integer
76189>>>>>>>>>>>//    tTHSource ltaSource
76189>>>>>>>>>>>//    tTHWorkspace THWorkspace
76189>>>>>>>>>>>//    Integer iFile
76189>>>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
76189>>>>>>>>>>>//    Move sFile                                                to ltaSource.sFile
76189>>>>>>>>>>>//    Move (SearchArray(ltaSource, THWorkspace.taSources))      to iFile
76189>>>>>>>>>>>//    If (iFile=-1) Move (SizeOfArray(THWorkspace.taSources))   to iFile
76189>>>>>>>>>>>//    Function_Return iFile
76189>>>>>>>>>>>End_Function
76190>>>>>>>>>>>Procedure THWS_SaveBookmarks String sFile String sBookmarks Integer iCount
76193>>>>>>>>>>>//    Integer iFile
76193>>>>>>>>>>>//    tTHWorkspace THWorkspace
76193>>>>>>>>>>>//    If ((iCount=0) and (sBookmarks<>"")) ;
76193>>>>>>>>>>>//        Move (Length(sBookmarks)/12)    to iCount
76193>>>>>>>>>>>//    Move (Uppercase(Trim(sFile)))       to sFile
76193>>>>>>>>>>>//    Get THWS_FileIndex sFile            To iFile
76193>>>>>>>>>>>//    Get pTHWorkspace  of ghoApplication To THWorkspace
76193>>>>>>>>>>>//    Move sFile                          to THWorkspace.taSources[iFile].sFile
76193>>>>>>>>>>>//    Move sBookmarks                     to THWorkspace.taSources[iFile].sBookmarks
76193>>>>>>>>>>>//    Move iCount                         To THWorkspace.taSources[iFile].iBookmarkCount
76193>>>>>>>>>>>//    Set pTHWorkspace  of ghoApplication To THWorkspace
76193>>>>>>>>>>>End_Procedure
76194>>>>>>>>>>>Procedure THWS_SaveCursorPosition String sFile Integer iLine Integer iColumn
76197>>>>>>>>>>>//    Integer iFile
76197>>>>>>>>>>>//    tTHWorkspace THWorkspace
76197>>>>>>>>>>>//    Move (Uppercase(Trim(sFile)))       to sFile
76197>>>>>>>>>>>//    Get THWS_FileIndex sFile            To iFile
76197>>>>>>>>>>>//    Get pTHWorkspace  of ghoApplication To THWorkspace
76197>>>>>>>>>>>//    Move sFile                          to THWorkspace.taSources[iFile].sFile
76197>>>>>>>>>>>//    Move iLine                          to THWorkspace.taSources[iFile].iCursorLine
76197>>>>>>>>>>>//    Move iColumn                        To THWorkspace.taSources[iFile].iCursorColumn
76197>>>>>>>>>>>//    Set pTHWorkspace  of ghoApplication To THWorkspace
76197>>>>>>>>>>>End_Procedure
76198>>>>>>>>>>>
76198>>>>>>>>>>>// Opened files
76198>>>>>>>>>>>Procedure THWS_SaveOpened String sFile Handle hoEditor
76201>>>>>>>>>>>//    tTHWorkspace THWorkspace
76201>>>>>>>>>>>//    If (hoEditor<>0) Begin
76201>>>>>>>>>>>//      // also save bookmarks and CursorPositions
76201>>>>>>>>>>>//      Send SaveBookMarks  of hoEditor sFile
76201>>>>>>>>>>>//      Send SaveCurrentPos of hoEditor sFile
76201>>>>>>>>>>>//    End
76201>>>>>>>>>>>//    Get pTHWorkspace Of ghoApplication To THWorkspace
76201>>>>>>>>>>>//    If (SearchArray(sFile, THWorkspace.saOpened)<0) Begin
76201>>>>>>>>>>>//        Move sFile   To THWorkspace.saOpened[SizeOfArray(THWorkspace.saOpened)]
76201>>>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
76201>>>>>>>>>>>//        Send THDoWriteWorkspace
76201>>>>>>>>>>>//    End
76201>>>>>>>>>>>End_Procedure
76202>>>>>>>>>>>Procedure THWS_DeleteOpened String sFile
76205>>>>>>>>>>>//    Integer iFile
76205>>>>>>>>>>>//    tTHWorkspace THWorkspace
76205>>>>>>>>>>>//    Get pTHWorkspace of ghoApplication To THWorkspace
76205>>>>>>>>>>>//    Move (SearchArray(sFile, THWorkspace.saOpened)) to iFile
76205>>>>>>>>>>>//    If (iFile>=0) Begin
76205>>>>>>>>>>>//        Move (RemoveFromArray(THWorkspace.saOpened, iFile)) To THWorkspace.saOpened
76205>>>>>>>>>>>//        Set pTHWorkspace of ghoApplication To THWorkspace
76205>>>>>>>>>>>//        Send THDoWriteWorkspace
76205>>>>>>>>>>>//    End
76205>>>>>>>>>>>End_Procedure
76206>>>>>>>>>>>
76206>>>>>>>>>>>Function _T Global String sText Integer iIndex Returns String
76208>>>>>>>>>>>    Function_Return sText
76209>>>>>>>>>>>End_Function
76210>>>>>>>>>>>
76210>>>>>>>>>
76210>>>>>>>>>// Already declared in winuser
76210>>>>>>>>>//// BOOL WINAPI GetKeyboardState(
76210>>>>>>>>>////  _Out_ PBYTE lpKeyState
76210>>>>>>>>>//// );
76210>>>>>>>>>//External_Function GetKeyboardState "GetKeyBoardState" User32.dll Pointer lpKeyState Returns Integer
76210>>>>>>>>>
76210>>>>>>>>>Define KS_KeyDown For |CI$80
76210>>>>>>>>>
76210>>>>>>>>>//
76210>>>>>>>>>// A shortcut is defined as both a dataflex code that can be used in an On_Key as well as the windows
76210>>>>>>>>>// virtual Key code which is stored per key and thus has to be in an array.
76210>>>>>>>>>// eg. ctrl+F3 = dataflex integer 5138, but also VK_Ctrl+VK_F3
76210>>>>>>>>>// where 5138 is the integer representation of Key_Ctrl+Key_F3 which is equivalent to 5138 in our example.
76210>>>>>>>>>//
76210>>>>>>>>>Struct tShortCut
76210>>>>>>>>>  Integer   iDFKey
76210>>>>>>>>>  Integer[] VKcode
76210>>>>>>>>>End_Struct
76210>>>>>>>>>
76210>>>>>>>>>
76210>>>>>>>>>Struct tSciCommandHotKey
76210>>>>>>>>>  Integer iCmd
76210>>>>>>>>>  String  sName
76210>>>>>>>>>  String  sDescription
76210>>>>>>>>>  tShortCut HotKey
76210>>>>>>>>>  tShortCut HotKey
76210>>>>>>>>>  tShortCut HotKey2
76210>>>>>>>>>  tShortCut HotKey2
76210>>>>>>>>>End_Struct
76210>>>>>>>>>
76210>>>>>>>>>Class cSciCommandHotKeys is a cObject
76211>>>>>>>>>  Procedure Construct_Object
76213>>>>>>>>>    Property tSciCommandHotKey[] pCommands
76214>>>>>>>>>  End_Procedure
76215>>>>>>>>>
76215>>>>>>>>>  Procedure RegisterCommand Integer iCmd String sName String sDesc
76217>>>>>>>>>    tSciCommandHotKey Command
76217>>>>>>>>>    tSciCommandHotKey Command
76217>>>>>>>>>    tSciCommandHotKey[] Commands
76217>>>>>>>>>    tSciCommandHotKey[] Commands
76218>>>>>>>>>    Get pCommands To Commands
76219>>>>>>>>>    Move iCmd  To Command.iCmd
76220>>>>>>>>>    Move sName To Command.sName
76221>>>>>>>>>    Move sDesc To Command.sDescription
76222>>>>>>>>>    Move Command To Commands[SizeOfArray(Commands)]
76223>>>>>>>>>    Set pCommands To Commands
76224>>>>>>>>>  End_Procedure
76225>>>>>>>>>
76225>>>>>>>>>  Function FindCommand Integer iCmd Returns tSciCommandHotKey
76227>>>>>>>>>    Integer iItem
76227>>>>>>>>>    Integer iCount
76227>>>>>>>>>    tSciCommandHotKey Command
76227>>>>>>>>>    tSciCommandHotKey Command
76227>>>>>>>>>    tSciCommandHotKey[] Commands
76227>>>>>>>>>    tSciCommandHotKey[] Commands
76228>>>>>>>>>
76228>>>>>>>>>    Move -1 To Command.iCmd
76229>>>>>>>>>    Get pCommands To Commands
76230>>>>>>>>>    Move (SizeOfArray(Commands)) To iCount
76231>>>>>>>>>    For iItem From 0 To (iCount-1)
76237>>>>>>>>>>
76237>>>>>>>>>      If (iCmd=Commands[iItem].iCmd) Begin
76239>>>>>>>>>        Move Commands[iItem] To Command
76240>>>>>>>>>        Move iCount To iItem
76241>>>>>>>>>      End
76241>>>>>>>>>>
76241>>>>>>>>>    Loop
76242>>>>>>>>>>
76242>>>>>>>>>    Function_Return Command
76243>>>>>>>>>  End_Function
76244>>>>>>>>>
76244>>>>>>>>>
76244>>>>>>>>>  Function FindCommandIndex Integer iCmd Returns Integer
76246>>>>>>>>>    Integer iItem
76246>>>>>>>>>    Integer iIndex
76246>>>>>>>>>    Integer iCount
76246>>>>>>>>>    tSciCommandHotKey[] Commands
76246>>>>>>>>>    tSciCommandHotKey[] Commands
76247>>>>>>>>>
76247>>>>>>>>>    Move -1 To iIndex
76248>>>>>>>>>    Get pCommands To Commands
76249>>>>>>>>>    Move (SizeOfArray(Commands)) To iCount
76250>>>>>>>>>    For iItem From 0 To (iCount-1)
76256>>>>>>>>>>
76256>>>>>>>>>      If (iCmd=Commands[iItem].iCmd) Begin
76258>>>>>>>>>        Move iItem To iIndex
76259>>>>>>>>>        Move iCount To iItem
76260>>>>>>>>>      End
76260>>>>>>>>>>
76260>>>>>>>>>    Loop
76261>>>>>>>>>>
76261>>>>>>>>>    Function_Return iIndex
76262>>>>>>>>>  End_Function
76263>>>>>>>>>
76263>>>>>>>>>  Function CommandHasHotKey tSciCommandHotKey Command Returns Boolean
76265>>>>>>>>>    Boolean bHasHotKey
76265>>>>>>>>>
76265>>>>>>>>>    Move False To bHasHotKey
76266>>>>>>>>>    If (SizeOfArray(Command.HotKey.VKcode)>0 or SizeOfArray(Command.HotKey2.VKcode)>0) Begin
76268>>>>>>>>>      Move True To bHasHotKey
76269>>>>>>>>>    End
76269>>>>>>>>>>
76269>>>>>>>>>    Function_Return bHasHotKey
76270>>>>>>>>>  End_Function
76271>>>>>>>>>
76271>>>>>>>>>  //
76271>>>>>>>>>  // Searches the current command to see if a shortcut has already been assigned elsewhere
76271>>>>>>>>>  // Returns the command if it has or Command.iCmd with -1 if it hasn't
76271>>>>>>>>>  //
76271>>>>>>>>>  Function ShortCutIsAssignedTo tShortCut ShortCut Returns tSciCommandHotKey
76273>>>>>>>>>    Integer iItem
76273>>>>>>>>>    Integer iCount
76273>>>>>>>>>    tSciCommandHotKey Command
76273>>>>>>>>>    tSciCommandHotKey Command
76273>>>>>>>>>    tSciCommandHotKey[] Commands
76273>>>>>>>>>    tSciCommandHotKey[] Commands
76274>>>>>>>>>
76274>>>>>>>>>    Move -1 To Command.iCmd
76275>>>>>>>>>    Get pCommands To Commands
76276>>>>>>>>>    Move (SizeOfArray(Commands)) To iCount
76277>>>>>>>>>    For iItem From 0 To (iCount-1)
76283>>>>>>>>>>
76283>>>>>>>>>      If (ShortCut.iDFKey=Commands[iItem].HotKey.iDFKey or ShortCut.iDFKey=Commands[iItem].HotKey2.iDFKey) Begin
76285>>>>>>>>>        Move Commands[iItem] To Command
76286>>>>>>>>>        Move iCount To iItem
76287>>>>>>>>>      End
76287>>>>>>>>>>
76287>>>>>>>>>    Loop
76288>>>>>>>>>>
76288>>>>>>>>>    Function_Return Command
76289>>>>>>>>>  End_Function
76290>>>>>>>>>
76290>>>>>>>>>  //
76290>>>>>>>>>  // Assigns a keyboard shortcut to the selected command. If a shortcut already exists
76290>>>>>>>>>  // then it will assign a 2nd shortcut. We can never have more as 2 shortcuts for one command.
76290>>>>>>>>>  //
76290>>>>>>>>>  Procedure AssignShortCutToCmd Integer iCmd tShortCut ShortCut
76292>>>>>>>>>    Boolean bHasHotKey
76292>>>>>>>>>    Integer iItem
76292>>>>>>>>>    String  sMsg
76292>>>>>>>>>    tSciCommandHotKey  Assigned
76292>>>>>>>>>    tSciCommandHotKey  Assigned
76292>>>>>>>>>    tSciCommandHotKey[] Commands
76292>>>>>>>>>    tSciCommandHotKey[] Commands
76293>>>>>>>>>
76293>>>>>>>>>    Get FindCommandIndex iCmd To iItem
76294>>>>>>>>>    If (iItem>-1) Begin
76296>>>>>>>>>      Get ShortCutIsAssignedTo ShortCut To Assigned
76297>>>>>>>>>      If (Assigned.iCmd=-1) Begin
76299>>>>>>>>>        Get pCommands To Commands
76300>>>>>>>>>        Get CommandHasHotKey Commands[iItem] To bHasHotKey
76301>>>>>>>>>        If (bHasHotKey=False) Begin
76303>>>>>>>>>          Move ShortCut To Commands[iItem].HotKey
76304>>>>>>>>>        End
76304>>>>>>>>>>
76304>>>>>>>>>        Else Begin
76305>>>>>>>>>          Move ShortCut To Commands[iItem].HotKey2
76306>>>>>>>>>        End
76306>>>>>>>>>>
76306>>>>>>>>>        Set pCommands To Commands
76307>>>>>>>>>      End
76307>>>>>>>>>>
76307>>>>>>>>>      Else Begin
76308>>>>>>>>>        Send Info_Box ("Already assigned to "+Assigned.sName+"\nYou have to remove it there first.")
76309>>>>>>>>>      End
76309>>>>>>>>>>
76309>>>>>>>>>    End
76309>>>>>>>>>>
76309>>>>>>>>>  End_Procedure
76310>>>>>>>>>
76310>>>>>>>>>  //
76310>>>>>>>>>  // Removes all associated keyboard shortcuts from the command
76310>>>>>>>>>  //
76310>>>>>>>>>  Procedure RemoveShortCutFromCmd Integer iCmd
76312>>>>>>>>>    Integer iItem
76312>>>>>>>>>    tShortCut EmptyShortCut
76312>>>>>>>>>    tShortCut EmptyShortCut
76312>>>>>>>>>    tSciCommandHotKey[] Commands
76312>>>>>>>>>    tSciCommandHotKey[] Commands
76313>>>>>>>>>
76313>>>>>>>>>    Get FindCommandIndex iCmd To iItem
76314>>>>>>>>>    If (iItem>-1) Begin
76316>>>>>>>>>      Get pCommands To Commands
76317>>>>>>>>>      Move EmptyShortCut To Commands[iItem].HotKey
76318>>>>>>>>>      Move EmptyShortCut To Commands[iItem].HotKey2
76319>>>>>>>>>      Set pCommands To Commands
76320>>>>>>>>>    End
76320>>>>>>>>>>
76320>>>>>>>>>  End_Procedure
76321>>>>>>>>>
76321>>>>>>>>>  //
76321>>>>>>>>>  // For sorting on the cmd.Name part in the structure
76321>>>>>>>>>  //
76321>>>>>>>>>  Function CompareCommands tSciCommandHotKey Cmd1 tSciCommandHotKey Cmd2 Returns Integer
76323>>>>>>>>>    String sName1
76323>>>>>>>>>    String sName2
76323>>>>>>>>>
76323>>>>>>>>>    Move (uppercase(Cmd1.sName)) To sName1
76324>>>>>>>>>    Move (Uppercase(Cmd2.sName)) To sName2
76325>>>>>>>>>    If (sName1 > sName2) ;      Function_Return (GT)
76328>>>>>>>>>    Else If (sName1 < sName2) ;      Function_Return (LT)
76332>>>>>>>>>    Function_Return (EQ)
76333>>>>>>>>>  End_Function
76334>>>>>>>>>
76334>>>>>>>>>  Procedure SortByCommandName
76336>>>>>>>>>    tSciCommandHotKey[] Commands
76336>>>>>>>>>    tSciCommandHotKey[] Commands
76337>>>>>>>>>    tSciCommandHotKey[] SortedCommands
76337>>>>>>>>>    tSciCommandHotKey[] SortedCommands
76338>>>>>>>>>
76338>>>>>>>>>    Get pCommands To Commands
76339>>>>>>>>>    Move (SortArray(Commands, Self, RefFunc(CompareCommands))) To SortedCommands
76340>>>>>>>>>    Set pCommands To SortedCommands
76341>>>>>>>>>  End_Procedure
76342>>>>>>>>>
76342>>>>>>>>>
76342>>>>>>>>>  Function MapVKtoString Integer iVK Returns String
76344>>>>>>>>>    String  sKey
76344>>>>>>>>>
76344>>>>>>>>>    If (iVK>=48 and iVK<=57) Begin
76346>>>>>>>>>      // VK_0 thru VK_9 are the same as ASCII '0' thru '9'
76346>>>>>>>>>      Move (Character(iVK)) To sKey
76347>>>>>>>>>    End
76347>>>>>>>>>>
76347>>>>>>>>>    Else If (iVK>=65 and iVK<=90) Begin
76350>>>>>>>>>      // VK_A thru VK_Z are the same as ASCII 'A' thru 'Z'
76350>>>>>>>>>      Move (Character(iVK)) To sKey
76351>>>>>>>>>    End
76351>>>>>>>>>>
76351>>>>>>>>>    Else Begin
76352>>>>>>>>>      Case Begin
76352>>>>>>>>>        Case (iVK=VK_LBUTTON)
76354>>>>>>>>>          Move "LBUTTON" To sKey
76355>>>>>>>>>          Case Break
76356>>>>>>>>>        Case (iVK=VK_RBUTTON)
76359>>>>>>>>>          Move "RBUTTON" To sKey
76360>>>>>>>>>          Case Break
76361>>>>>>>>>        Case (iVK=VK_CANCEL)
76364>>>>>>>>>          Move "CANCEL" To sKey
76365>>>>>>>>>          Case Break
76366>>>>>>>>>        Case (iVK=VK_MBUTTON)
76369>>>>>>>>>          Move "MBUTTON" To sKey
76370>>>>>>>>>          Case Break
76371>>>>>>>>>        Case (iVK=VK_BACK)
76374>>>>>>>>>          Move "Backspace" To sKey
76375>>>>>>>>>          Case Break
76376>>>>>>>>>        Case (iVK=VK_TAB)
76379>>>>>>>>>          Move "Tab" To sKey
76380>>>>>>>>>          Case Break
76381>>>>>>>>>        Case (iVK=VK_CLEAR)
76384>>>>>>>>>          Move "CLEAR" To sKey
76385>>>>>>>>>          Case Break
76386>>>>>>>>>        Case (iVK=VK_RETURN)
76389>>>>>>>>>          Move "Enter" To sKey
76390>>>>>>>>>          Case Break
76391>>>>>>>>>        Case (iVK=VK_SHIFT)
76394>>>>>>>>>          Move "Shift" To sKey
76395>>>>>>>>>          Case Break
76396>>>>>>>>>        Case (iVK=VK_CONTROL)
76399>>>>>>>>>          Move "Ctrl" To sKey
76400>>>>>>>>>          Case Break
76401>>>>>>>>>        Case (iVK=VK_MENU)
76404>>>>>>>>>          Move "Alt" To sKey
76405>>>>>>>>>          Case Break
76406>>>>>>>>>        Case (iVK=VK_PAUSE)
76409>>>>>>>>>          Move "PAUSE" To sKey
76410>>>>>>>>>          Case Break
76411>>>>>>>>>        Case (iVK=VK_CAPITAL)
76414>>>>>>>>>          Move "CAPITAL" To sKey
76415>>>>>>>>>          Case Break
76416>>>>>>>>>        Case (iVK=VK_ESCAPE)
76419>>>>>>>>>          Move "Escape" To sKey
76420>>>>>>>>>          Case Break
76421>>>>>>>>>        Case (iVK=VK_SPACE)
76424>>>>>>>>>          Move "Space" To sKey
76425>>>>>>>>>          Case Break
76426>>>>>>>>>        Case (iVK=VK_PRIOR)
76429>>>>>>>>>          Move "Page Up" To sKey
76430>>>>>>>>>          Case Break
76431>>>>>>>>>        Case (iVK=VK_NEXT)
76434>>>>>>>>>          Move "Page Down" To sKey
76435>>>>>>>>>          Case Break
76436>>>>>>>>>        Case (iVK=VK_END)
76439>>>>>>>>>          Move "End" To sKey
76440>>>>>>>>>          Case Break
76441>>>>>>>>>        Case (iVK=VK_HOME)
76444>>>>>>>>>          Move "Home" To sKey
76445>>>>>>>>>          Case Break
76446>>>>>>>>>        Case (iVK=VK_LEFT)
76449>>>>>>>>>          Move "Left" To sKey
76450>>>>>>>>>          Case Break
76451>>>>>>>>>        Case (iVK=VK_UP)
76454>>>>>>>>>          Move "Up" To sKey
76455>>>>>>>>>          Case Break
76456>>>>>>>>>        Case (iVK=VK_RIGHT)
76459>>>>>>>>>          Move "Right" To sKey
76460>>>>>>>>>          Case Break
76461>>>>>>>>>        Case (iVK=VK_DOWN)
76464>>>>>>>>>          Move "Down" To sKey
76465>>>>>>>>>          Case Break
76466>>>>>>>>>        Case (iVK=VK_SELECT)
76469>>>>>>>>>          Move "SELECT" To sKey
76470>>>>>>>>>          Case Break
76471>>>>>>>>>        Case (iVK=VK_PRINT)
76474>>>>>>>>>          Move "PRINT" To sKey
76475>>>>>>>>>          Case Break
76476>>>>>>>>>        Case (iVK=VK_EXECUTE)
76479>>>>>>>>>          Move "EXECUTE" To sKey
76480>>>>>>>>>          Case Break
76481>>>>>>>>>        Case (iVK=VK_SNAPSHOT)
76484>>>>>>>>>          Move "SNAPSHOT" To sKey
76485>>>>>>>>>          Case Break
76486>>>>>>>>>        Case (iVK=VK_INSERT)
76489>>>>>>>>>          Move "Insert" To sKey
76490>>>>>>>>>          Case Break
76491>>>>>>>>>        Case (iVK=VK_DELETE)
76494>>>>>>>>>          Move "Delete" To sKey
76495>>>>>>>>>          Case Break
76496>>>>>>>>>        Case (iVK=VK_HELP)
76499>>>>>>>>>          Move "Help" To sKey
76500>>>>>>>>>          Case Break
76501>>>>>>>>>        Case (iVK=VK_LWIN)
76504>>>>>>>>>          Move "LWIN" To sKey
76505>>>>>>>>>          Case Break
76506>>>>>>>>>        Case (iVK=VK_RWIN)
76509>>>>>>>>>          Move "RWIN" To sKey
76510>>>>>>>>>          Case Break
76511>>>>>>>>>        Case (iVK=VK_APPS)
76514>>>>>>>>>          Move "APPS" To sKey
76515>>>>>>>>>          Case Break
76516>>>>>>>>>        Case (iVK=VK_NUMPAD0)
76519>>>>>>>>>          Move "NUMPAD0" To sKey
76520>>>>>>>>>          Case Break
76521>>>>>>>>>        Case (iVK=VK_NUMPAD1)
76524>>>>>>>>>          Move "NUMPAD1" To sKey
76525>>>>>>>>>          Case Break
76526>>>>>>>>>        Case (iVK=VK_NUMPAD2)
76529>>>>>>>>>          Move "NUMPAD2" To sKey
76530>>>>>>>>>          Case Break
76531>>>>>>>>>        Case (iVK=VK_NUMPAD3)
76534>>>>>>>>>          Move "NUMPAD3" To sKey
76535>>>>>>>>>          Case Break
76536>>>>>>>>>        Case (iVK=VK_NUMPAD4)
76539>>>>>>>>>          Move "NUMPAD4" To sKey
76540>>>>>>>>>          Case Break
76541>>>>>>>>>        Case (iVK=VK_NUMPAD5)
76544>>>>>>>>>          Move "NUMPAD5" To sKey
76545>>>>>>>>>          Case Break
76546>>>>>>>>>        Case (iVK=VK_NUMPAD6)
76549>>>>>>>>>          Move "NUMPAD6" To sKey
76550>>>>>>>>>          Case Break
76551>>>>>>>>>        Case (iVK=VK_NUMPAD7)
76554>>>>>>>>>          Move "NUMPAD7" To sKey
76555>>>>>>>>>          Case Break
76556>>>>>>>>>        Case (iVK=VK_NUMPAD8)
76559>>>>>>>>>          Move "NUMPAD8" To sKey
76560>>>>>>>>>          Case Break
76561>>>>>>>>>        Case (iVK=VK_NUMPAD9)
76564>>>>>>>>>          Move "NUMPAD9" To sKey
76565>>>>>>>>>          Case Break
76566>>>>>>>>>        Case (iVK=VK_MULTIPLY)
76569>>>>>>>>>          Move "MULTIPLY" To sKey
76570>>>>>>>>>          Case Break
76571>>>>>>>>>        Case (iVK=VK_ADD)
76574>>>>>>>>>          Move "ADD" To sKey
76575>>>>>>>>>          Case Break
76576>>>>>>>>>        Case (iVK=VK_SEPARATOR)
76579>>>>>>>>>          Move "SEPARATOR" To sKey
76580>>>>>>>>>          Case Break
76581>>>>>>>>>        Case (iVK=VK_SUBTRACT)
76584>>>>>>>>>          Move "SUBTRACT" To sKey
76585>>>>>>>>>          Case Break
76586>>>>>>>>>        Case (iVK=VK_DECIMAL)
76589>>>>>>>>>          Move "DECIMAL" To sKey
76590>>>>>>>>>          Case Break
76591>>>>>>>>>        Case (iVK=VK_DIVIDE)
76594>>>>>>>>>          Move "DIVIDE" To sKey
76595>>>>>>>>>          Case Break
76596>>>>>>>>>        Case (iVK=VK_F1)
76599>>>>>>>>>          Move "F1" To sKey
76600>>>>>>>>>          Case Break
76601>>>>>>>>>        Case (iVK=VK_F2)
76604>>>>>>>>>          Move "F2" To sKey
76605>>>>>>>>>          Case Break
76606>>>>>>>>>        Case (iVK=VK_F3)
76609>>>>>>>>>          Move "F3" To sKey
76610>>>>>>>>>          Case Break
76611>>>>>>>>>        Case (iVK=VK_F4)
76614>>>>>>>>>          Move "F4" To sKey
76615>>>>>>>>>          Case Break
76616>>>>>>>>>        Case (iVK=VK_F5)
76619>>>>>>>>>          Move "F5" To sKey
76620>>>>>>>>>          Case Break
76621>>>>>>>>>        Case (iVK=VK_F6)
76624>>>>>>>>>          Move "F6" To sKey
76625>>>>>>>>>          Case Break
76626>>>>>>>>>        Case (iVK=VK_F7)
76629>>>>>>>>>          Move "F7" To sKey
76630>>>>>>>>>          Case Break
76631>>>>>>>>>        Case (iVK=VK_F8)
76634>>>>>>>>>          Move "F8" To sKey
76635>>>>>>>>>          Case Break
76636>>>>>>>>>        Case (iVK=VK_F9)
76639>>>>>>>>>          Move "F9" To sKey
76640>>>>>>>>>          Case Break
76641>>>>>>>>>        Case (iVK=VK_F10)
76644>>>>>>>>>          Move "F10" To sKey
76645>>>>>>>>>          Case Break
76646>>>>>>>>>        Case (iVK=VK_F11)
76649>>>>>>>>>          Move "F11" To sKey
76650>>>>>>>>>          Case Break
76651>>>>>>>>>        Case (iVK=VK_F12)
76654>>>>>>>>>          Move "F12" To sKey
76655>>>>>>>>>          Case Break
76656>>>>>>>>>        Case (iVK=VK_F13)
76659>>>>>>>>>          Move "F13" To sKey
76660>>>>>>>>>          Case Break
76661>>>>>>>>>        Case (iVK=VK_F14)
76664>>>>>>>>>          Move "F14" To sKey
76665>>>>>>>>>          Case Break
76666>>>>>>>>>        Case (iVK=VK_F15)
76669>>>>>>>>>          Move "F15" To sKey
76670>>>>>>>>>          Case Break
76671>>>>>>>>>        Case (iVK=VK_F16)
76674>>>>>>>>>          Move "F16" To sKey
76675>>>>>>>>>          Case Break
76676>>>>>>>>>        Case (iVK=VK_F17)
76679>>>>>>>>>          Move "F17" To sKey
76680>>>>>>>>>          Case Break
76681>>>>>>>>>        Case (iVK=VK_F18)
76684>>>>>>>>>          Move "F18" To sKey
76685>>>>>>>>>          Case Break
76686>>>>>>>>>        Case (iVK=VK_F19)
76689>>>>>>>>>          Move "F19" To sKey
76690>>>>>>>>>          Case Break
76691>>>>>>>>>        Case (iVK=VK_F20)
76694>>>>>>>>>          Move "F20" To sKey
76695>>>>>>>>>          Case Break
76696>>>>>>>>>        Case (iVK=VK_F21)
76699>>>>>>>>>          Move "F21" To sKey
76700>>>>>>>>>          Case Break
76701>>>>>>>>>        Case (iVK=VK_F22)
76704>>>>>>>>>          Move "F22" To sKey
76705>>>>>>>>>          Case Break
76706>>>>>>>>>        Case (iVK=VK_F23)
76709>>>>>>>>>          Move "F23" To sKey
76710>>>>>>>>>          Case Break
76711>>>>>>>>>        Case (iVK=VK_F24)
76714>>>>>>>>>          Move "F24" To sKey
76715>>>>>>>>>          Case Break
76716>>>>>>>>>        Case (iVK=VK_NUMLOCK)
76719>>>>>>>>>          Move "NUMLOCK" To sKey
76720>>>>>>>>>          Case Break
76721>>>>>>>>>        Case (iVK=VK_SCROLL)
76724>>>>>>>>>          Move "SCROLL" To sKey
76725>>>>>>>>>          Case Break
76726>>>>>>>>>        Case (iVK=VK_LSHIFT)
76729>>>>>>>>>          Move "LSHIFT" To sKey
76730>>>>>>>>>          Case Break
76731>>>>>>>>>        Case (iVK=VK_RSHIFT)
76734>>>>>>>>>          Move "RSHIFT" To sKey
76735>>>>>>>>>          Case Break
76736>>>>>>>>>        Case (iVK=VK_LCONTROL)
76739>>>>>>>>>          Move "LCONTROL" To sKey
76740>>>>>>>>>          Case Break
76741>>>>>>>>>        Case (iVK=VK_RCONTROL)
76744>>>>>>>>>          Move "RCONTROL" To sKey
76745>>>>>>>>>          Case Break
76746>>>>>>>>>        Case (iVK=VK_LMENU)
76749>>>>>>>>>          Move "LMENU" To sKey
76750>>>>>>>>>          Case Break
76751>>>>>>>>>        Case (iVK=VK_RMENU)
76754>>>>>>>>>          Move "RMENU" To sKey
76755>>>>>>>>>          Case Break
76756>>>>>>>>>        Case (iVK=VK_PROCESSKEY)
76759>>>>>>>>>          Move "PROCESSKEY" To sKey
76760>>>>>>>>>          Case Break
76761>>>>>>>>>        Case (iVK=VK_ATTN)
76764>>>>>>>>>          Move "ATTN" To sKey
76765>>>>>>>>>          Case Break
76766>>>>>>>>>        Case (iVK=VK_CRSEL)
76769>>>>>>>>>          Move "CRSEL" To sKey
76770>>>>>>>>>          Case Break
76771>>>>>>>>>        Case (iVK=VK_EXSEL)
76774>>>>>>>>>          Move "EXSEL" To sKey
76775>>>>>>>>>          Case Break
76776>>>>>>>>>        Case (iVK=VK_EREOF)
76779>>>>>>>>>          Move "EREOF" To sKey
76780>>>>>>>>>          Case Break
76781>>>>>>>>>        Case (iVK=VK_PLAY)
76784>>>>>>>>>          Move "PLAY" To sKey
76785>>>>>>>>>          Case Break
76786>>>>>>>>>        Case (iVK=VK_ZOOM)
76789>>>>>>>>>          Move "ZOOM" To sKey
76790>>>>>>>>>          Case Break
76791>>>>>>>>>        Case (iVK=VK_NONAME)
76794>>>>>>>>>          Move "NONAME" To sKey
76795>>>>>>>>>          Case Break
76796>>>>>>>>>        Case (iVK=VK_PA1)
76799>>>>>>>>>          Move "PA1" To sKey
76800>>>>>>>>>          Case Break
76801>>>>>>>>>        Case (iVK=VK_OEM_CLEAR)
76804>>>>>>>>>          Move "OEM_CLEAR" To sKey
76805>>>>>>>>>          Case Break
76806>>>>>>>>>        Case Else
76806>>>>>>>>>          // Hello undocumented DF command, welcome to the pleasure dome
76806>>>>>>>>>          //MAP_VK_TO_UNSHIFTED_CHAR iVK to iKey
76806>>>>>>>>>          //Move (Character(iKey)) To sKey
76806>>>>>>>>>          // The above works, but perhaps it is better to rely on something we can support
76806>>>>>>>>>          Move (WinAPIGetKeyNameText(iVK))  To sKey
76807>>>>>>>>>      Case End
76807>>>>>>>>>    End
76807>>>>>>>>>>
76807>>>>>>>>>    Function_Return sKey
76808>>>>>>>>>  End_Function
76809>>>>>>>>>
76809>>>>>>>>>  //
76809>>>>>>>>>  // Juggles the order of the keys in the array a bit so that they end up looking more natural
76809>>>>>>>>>  // to the end user. Eg. Ctrl+Alt+Enter looks a lot better as Enter+Alt+Ctrl
76809>>>>>>>>>  // After this the order is left to right Ctrl+Alt+Shift ->> everything else
76809>>>>>>>>>  Function NaturalOrderKeys Integer[] Keys Returns Integer[]
76811>>>>>>>>>    Integer iKey
76811>>>>>>>>>
76811>>>>>>>>>    // Move Shift in front position
76811>>>>>>>>>    Move (SearchArray(VK_SHIFT,Keys)) To iKey
76812>>>>>>>>>    If (iKey>-1) Begin
76814>>>>>>>>>      Move (RemoveFromArray(Keys,iKey)) To Keys
76815>>>>>>>>>      Move (InsertInArray(Keys,0,VK_SHIFT)) To Keys
76816>>>>>>>>>    End
76816>>>>>>>>>>
76816>>>>>>>>>    // Move Alt in front position
76816>>>>>>>>>    Move (SearchArray(VK_MENU,Keys)) To iKey
76817>>>>>>>>>    If (iKey>-1) Begin
76819>>>>>>>>>      Move (RemoveFromArray(Keys,iKey)) To Keys
76820>>>>>>>>>      Move (InsertInArray(Keys,0,VK_MENU)) To Keys
76821>>>>>>>>>    End
76821>>>>>>>>>>
76821>>>>>>>>>    // Move Ctrl in front position if it exists as "Ctrl+Enter" looks better as "Enter+Ctrl"
76821>>>>>>>>>    Move (SearchArray(VK_CONTROL,Keys)) To iKey
76822>>>>>>>>>    If (iKey>-1) Begin
76824>>>>>>>>>      Move (RemoveFromArray(Keys,iKey)) To Keys
76825>>>>>>>>>      Move (InsertInArray(Keys,0,VK_CONTROL)) To Keys
76826>>>>>>>>>    End
76826>>>>>>>>>>
76826>>>>>>>>>    Function_Return Keys
76827>>>>>>>>>  End_Function
76828>>>>>>>>>
76828>>>>>>>>>
76828>>>>>>>>>  Function ReadKeyboardState Returns Integer[]
76830>>>>>>>>>    Boolean   bFiltered // filter left/right alt/ctrl/shift keys as we don't want to see those
76830>>>>>>>>>    Integer   iSuccess
76830>>>>>>>>>    Integer   iKey
76830>>>>>>>>>    Integer[] Keys
76831>>>>>>>>>    UChar[256] KeyState
76832>>>>>>>>>
76832>>>>>>>>>    Move True To bFiltered
76833>>>>>>>>>    Move (ResizeArray(Keys,0)) To Keys
76834>>>>>>>>>    Move (GetKeyboardState(AddressOf(KeyState))) To iSuccess
76835>>>>>>>>>    If (iSuccess) Begin
76837>>>>>>>>>      For iKey From 0 To 255
76843>>>>>>>>>>
76843>>>>>>>>>        If ((KeyState[iKey] iAnd KS_KeyDown) = KS_KeyDown) Begin
76845>>>>>>>>>          If (bFiltered) Begin
76847>>>>>>>>>            If (iKey <> VK_LSHIFT and iKey <> VK_LCONTROL and iKey <> VK_LMENU and iKey <> VK_RSHIFT and iKey <> VK_RCONTROL and iKey <> VK_RMENU ) Begin
76849>>>>>>>>>              Move iKey To Keys[SizeOfArray(Keys)]
76850>>>>>>>>>            End
76850>>>>>>>>>>
76850>>>>>>>>>          End
76850>>>>>>>>>>
76850>>>>>>>>>          Else Begin
76851>>>>>>>>>            Move iKey To Keys[SizeOfArray(Keys)]
76852>>>>>>>>>          End
76852>>>>>>>>>>
76852>>>>>>>>>        End
76852>>>>>>>>>>
76852>>>>>>>>>      Loop
76853>>>>>>>>>>
76853>>>>>>>>>    End
76853>>>>>>>>>>
76853>>>>>>>>>    Function_Return Keys
76854>>>>>>>>>  End_Function
76855>>>>>>>>>
76855>>>>>>>>>  Function KeysToString Integer[] Keys Returns String
76857>>>>>>>>>    Integer iKey
76857>>>>>>>>>    Integer iCount
76857>>>>>>>>>    String  sKey
76857>>>>>>>>>    String  sShortCut
76857>>>>>>>>>
76857>>>>>>>>>    Move "" To sShortCut
76858>>>>>>>>>    Move (SizeOfArray(Keys)) To iCount
76859>>>>>>>>>    If (iCount>0) Begin
76861>>>>>>>>>      Get NaturalOrderKeys Keys To Keys
76862>>>>>>>>>      For iKey From 0 To (iCount-1)
76868>>>>>>>>>>
76868>>>>>>>>>        Get MapVKtoString Keys[iKey] To sKey
76869>>>>>>>>>        If (iKey=0) ;          Move sKey To sShortCut
76872>>>>>>>>>        Else ;          Move (sShortCut * "+" * sKey) To sShortCut
76874>>>>>>>>>      Loop
76875>>>>>>>>>>
76875>>>>>>>>>    End
76875>>>>>>>>>>
76875>>>>>>>>>    Function_Return sShortCut
76876>>>>>>>>>  End_Function
76877>>>>>>>>>
76877>>>>>>>>>  Function CommandHotKeyString tSciCommandHotKey Command Returns String
76879>>>>>>>>>    String sShortCut
76879>>>>>>>>>    String sShortCut2
76879>>>>>>>>>
76879>>>>>>>>>    Get KeysToString Command.HotKey.VKcode  To sShortCut
76880>>>>>>>>>    Get KeysToString Command.HotKey2.VKcode To sShortCut2
76881>>>>>>>>>    If (sShortCut2<>"") Begin
76883>>>>>>>>>      Move (sShortCut + ", " + sShortCut2) To sShortCut
76884>>>>>>>>>    End
76884>>>>>>>>>>
76884>>>>>>>>>    Function_Return sShortCut
76885>>>>>>>>>  End_Function
76886>>>>>>>>>
76886>>>>>>>>>  Procedure ClearAllShortCutKeyDefinitions
76888>>>>>>>>>    Integer iItem
76888>>>>>>>>>    Integer iCmdCount
76888>>>>>>>>>    tShortCut EmptyHotKey
76888>>>>>>>>>    tShortCut EmptyHotKey
76888>>>>>>>>>    tSciCommandHotKey Command
76888>>>>>>>>>    tSciCommandHotKey Command
76888>>>>>>>>>    tSciCommandHotKey[] Commands
76888>>>>>>>>>    tSciCommandHotKey[] Commands
76889>>>>>>>>>
76889>>>>>>>>>    Get pCommands To Commands
76890>>>>>>>>>    Move (SizeOfArray(Commands)) To iCmdCount
76891>>>>>>>>>    For iItem From 0 To (iCmdCount-1)
76897>>>>>>>>>>
76897>>>>>>>>>      Move Commands[iItem] To Command
76898>>>>>>>>>      Move EmptyHotKey To Command.HotKey
76899>>>>>>>>>      Move EmptyHotKey To Command.HotKey2
76900>>>>>>>>>      Move Command To Commands[iItem]
76901>>>>>>>>>    Loop
76902>>>>>>>>>>
76902>>>>>>>>>    Set pCommands To Commands
76903>>>>>>>>>  End_Procedure
76904>>>>>>>>>
76904>>>>>>>>>  //
76904>>>>>>>>>  // Returns a serialized version of all the current shortcut definitions for the available commands
76904>>>>>>>>>  // format is <CmdShortcut1>,<CmdShortcut2>,<CmdShortcut3>,..
76904>>>>>>>>>  // Where <CmdShortcut1> = <iCmd,iDfKeyCode1,VKCode(s):iDfKeyCode2,VKCode2(s)>
76904>>>>>>>>>  //
76904>>>>>>>>>  // If a command has no defined shortcut, then the command is not in the list
76904>>>>>>>>>  Function ShortCutKeyDefinitions Returns String
76906>>>>>>>>>    Boolean bHasHotKey
76906>>>>>>>>>    Integer iItem
76906>>>>>>>>>    Integer iKey
76906>>>>>>>>>    Integer iKeyCount
76906>>>>>>>>>    Integer iCmdCount
76906>>>>>>>>>    String  sHotKey
76906>>>>>>>>>    String  sDefinitions
76906>>>>>>>>>    tShortCut HotKey
76906>>>>>>>>>    tShortCut HotKey
76906>>>>>>>>>    tSciCommandHotKey Command
76906>>>>>>>>>    tSciCommandHotKey Command
76906>>>>>>>>>    tSciCommandHotKey[] Commands
76906>>>>>>>>>    tSciCommandHotKey[] Commands
76907>>>>>>>>>
76907>>>>>>>>>    Move "" To sDefinitions
76908>>>>>>>>>    Get pCommands To Commands
76909>>>>>>>>>    Move (SizeOfArray(Commands)) To iCmdCount
76910>>>>>>>>>    For iItem From 0 To (iCmdCount-1)
76916>>>>>>>>>>
76916>>>>>>>>>      Move Commands[iItem] To Command
76917>>>>>>>>>      Get CommandHasHotKey Command To bHasHotKey
76918>>>>>>>>>      If (bHasHotKey) Begin
76920>>>>>>>>>        Move Command.HotKey To HotKey
76921>>>>>>>>>        Move ("<"+Trim(Command.iCmd)+"|"+Trim(HotKey.iDFKey)) To sHotKey
76922>>>>>>>>>        Move (SizeOfArray(HotKey.VKcode)) To iKeyCount
76923>>>>>>>>>        For iKey From 0 To (iKeyCount-1)
76929>>>>>>>>>>
76929>>>>>>>>>          Move (sHotKey+'|'+Trim(HotKey.VKcode[iKey])) To sHotKey
76930>>>>>>>>>        Loop
76931>>>>>>>>>>
76931>>>>>>>>>        Move Command.HotKey2 To HotKey
76932>>>>>>>>>        If (SizeOfArray(HotKey.VKcode)>0) Begin
76934>>>>>>>>>          // there's a second hotkey defined
76934>>>>>>>>>          Move (sHotKey+":"+Trim(HotKey.iDFKey)) To sHotKey
76935>>>>>>>>>          Move (SizeOfArray(HotKey.VKcode)) To iKeyCount
76936>>>>>>>>>          For iKey From 0 To (iKeyCount-1)
76942>>>>>>>>>>
76942>>>>>>>>>            Move (sHotKey+'|'+Trim(HotKey.VKcode[iKey])) To sHotKey
76943>>>>>>>>>          Loop
76944>>>>>>>>>>
76944>>>>>>>>>        End
76944>>>>>>>>>>
76944>>>>>>>>>        Move (sHotKey+">") To sHotKey
76945>>>>>>>>>        If (sDefinitions="") ;          Move sHotKey To sDefinitions
76948>>>>>>>>>        Else ;          Move (sDefinitions+sHotKey) To sDefinitions
76950>>>>>>>>>      End
76950>>>>>>>>>>
76950>>>>>>>>>    Loop
76951>>>>>>>>>>
76951>>>>>>>>>    Function_Return sDefinitions
76952>>>>>>>>>  End_Function
76953>>>>>>>>>
76953>>>>>>>>>  //
76953>>>>>>>>>  // Deserialize vkKeys passed in a string as "nnn|nnn|nnn" to an integer array with vkKey items
76953>>>>>>>>>  //
76953>>>>>>>>>  Function DeserializeVkKeys String sVkKeys Returns Integer[]
76955>>>>>>>>>    Integer iPos
76955>>>>>>>>>    String  sVkKey
76955>>>>>>>>>    Integer[] vkKeys
76956>>>>>>>>>
76956>>>>>>>>>    Move "" To sVkKey
76957>>>>>>>>>    Move (ResizeArray(vkKeys,0))  To vkKeys
76958>>>>>>>>>    While (Pos("|",sVkKeys))
76962>>>>>>>>>      Move (Pos("|",sVkKeys)) To iPos
76963>>>>>>>>>      Move (Left(sVkKeys,iPos-1)) To sVkKey
76964>>>>>>>>>      Move (Replace(sVkKey+"|",sVkKeys,"")) To sVkKeys
76965>>>>>>>>>      Move (Cast(sVkKey,Integer)) To vkKeys[SizeOfArray(vkKeys)]
76966>>>>>>>>>    Loop
76967>>>>>>>>>>
76967>>>>>>>>>    If (sVkKeys<>"") Begin
76969>>>>>>>>>      Move (Cast(sVkKeys,Integer)) To vkKeys[SizeOfArray(vkKeys)]
76970>>>>>>>>>    End
76970>>>>>>>>>>
76970>>>>>>>>>    Function_Return vkKeys
76971>>>>>>>>>  End_Function
76972>>>>>>>>>
76972>>>>>>>>>  //
76972>>>>>>>>>  // Reads the above defined shortcut serialization format from sDefinitions and assigns it to our command list.
76972>>>>>>>>>  //
76972>>>>>>>>>  Procedure Set ShortCutKeyDefinitions String sDefinitions
76974>>>>>>>>>    Integer iItem
76974>>>>>>>>>    Integer iPos
76974>>>>>>>>>    Integer iCmd
76974>>>>>>>>>    Integer iDfkey iDfKey2
76974>>>>>>>>>    Integer[] vkKeys vkKeys2
76976>>>>>>>>>    String  sHotKey
76976>>>>>>>>>    String  sCmd
76976>>>>>>>>>    String  sDfKey sDfKey2
76976>>>>>>>>>    String  sVkKeys sVkKey
76976>>>>>>>>>    tSciCommandHotKey Command
76976>>>>>>>>>    tSciCommandHotKey Command
76976>>>>>>>>>    tSciCommandHotKey[] Commands
76976>>>>>>>>>    tSciCommandHotKey[] Commands
76977>>>>>>>>>
76977>>>>>>>>>    Send ClearAllShortCutKeyDefinitions
76978>>>>>>>>>    Get pCommands To Commands
76979>>>>>>>>>    While (Pos("<",sDefinitions)>0)
76983>>>>>>>>>      Move "" To sHotKey
76984>>>>>>>>>      Move (Pos(">",sDefinitions)) To iPos
76985>>>>>>>>>      If (iPos>0) Begin
76987>>>>>>>>>        Move (Left(sDefinitions,iPos)) To sHotKey // HotKey definition for 1 command
76988>>>>>>>>>        Move (Replace(sHotKey,sDefinitions,"")) To sDefinitions
76989>>>>>>>>>      End
76989>>>>>>>>>>
76989>>>>>>>>>      Else ;        Move "" To sDefinitions
76991>>>>>>>>>
76991>>>>>>>>>      Move (Replace("<",sHotKey,"")) To sHotKey
76992>>>>>>>>>      Move (Replace(">",sHotKey,"")) To sHotKey
76993>>>>>>>>>      If (sHotKey<>"") Begin
76995>>>>>>>>>        Move "" To sCmd            // first initialize all variables we use for parsing
76996>>>>>>>>>        Move "" To sDfKey
76997>>>>>>>>>        Move "" To sDfKey2
76998>>>>>>>>>        Move "" To sVkKeys
76999>>>>>>>>>        Move 0  To iCmd
77000>>>>>>>>>        Move 0  To iDfkey
77001>>>>>>>>>        Move 0  To iDfKey2
77002>>>>>>>>>        Move (ResizeArray(vkKeys,0))  To vkKeys
77003>>>>>>>>>        Move (ResizeArray(vkKeys2,0)) To vkKeys2
77004>>>>>>>>>
77004>>>>>>>>>        Move (Pos("|",sHotKey)) To iPos
77005>>>>>>>>>        If (iPos>0) Begin
77007>>>>>>>>>          Move (Left(sHotKey,iPos-1)) To sCmd
77008>>>>>>>>>          Move (Replace(sCmd+"|",sHotKey,"")) To sHotKey
77009>>>>>>>>>          Move (Pos("|",sHotKey)) To iPos
77010>>>>>>>>>          If (iPos>0) Begin
77012>>>>>>>>>            Move (Left(sHotKey,iPos-1)) To sDfkey
77013>>>>>>>>>            Move (Replace(sDfKey+"|",sHotKey,"")) To sHotKey
77014>>>>>>>>>            Move (Pos(":",sHotKey)) To iPos
77015>>>>>>>>>            If (iPos>0) Begin
77017>>>>>>>>>              Move (Left(sHotKey,iPos-1)) To sVkKeys
77018>>>>>>>>>              Move (Replace(sVkKeys+":",sHotKey,"")) To sHotKey
77019>>>>>>>>>            End
77019>>>>>>>>>>
77019>>>>>>>>>            Else Begin
77020>>>>>>>>>              Move sHotKey To sVkKeys
77021>>>>>>>>>              Move "" To sHotKey
77022>>>>>>>>>            End
77022>>>>>>>>>>
77022>>>>>>>>>          End
77022>>>>>>>>>>
77022>>>>>>>>>          Else ;            Move "" To sHotKey
77024>>>>>>>>>        End
77024>>>>>>>>>>
77024>>>>>>>>>        Else ;          Move "" To sHotKey
77026>>>>>>>>>        If (sVkKeys<>"") Begin
77028>>>>>>>>>          Get DeserializeVkKeys sVkKeys To vkKeys
77029>>>>>>>>>        End
77029>>>>>>>>>>
77029>>>>>>>>>        If (sHotKey<>"") Begin
77031>>>>>>>>>          // there's a 2nd hotkey in here
77031>>>>>>>>>          Move (Pos("|",sHotKey)) To iPos
77032>>>>>>>>>          If (iPos>0) Begin
77034>>>>>>>>>            Move (Left(sHotKey,iPos-1)) To sDfkey2
77035>>>>>>>>>            Move (Replace(sDfKey2+"|",sHotKey,"")) To sHotKey
77036>>>>>>>>>            Move sHotKey To sVkKeys
77037>>>>>>>>>            Get DeserializeVkKeys sVkKeys To vkKeys2
77038>>>>>>>>>          End
77038>>>>>>>>>>
77038>>>>>>>>>        End
77038>>>>>>>>>>
77038>>>>>>>>>        Move (Cast(sCmd,Integer))    To iCmd
77039>>>>>>>>>        Move 0 To iItem
77040>>>>>>>>>        If (iCmd<>0) Begin
77042>>>>>>>>>          Get FindCommandIndex iCmd To iItem
77043>>>>>>>>>        End
77043>>>>>>>>>>
77043>>>>>>>>>        If (iItem>-1) Begin
77045>>>>>>>>>          Move Commands[iItem] To Command
77046>>>>>>>>>          Move (Cast(sDfKey,Integer))  To iDfkey
77047>>>>>>>>>
77047>>>>>>>>>          Move iDfkey To Command.HotKey.iDFKey
77048>>>>>>>>>          Move vkKeys To Command.HotKey.VKcode
77049>>>>>>>>>          If (sDfKey2<>"") Begin
77051>>>>>>>>>            Move (Cast(sDfKey2,Integer)) To iDfKey2
77052>>>>>>>>>            Move iDfkey2 To Command.HotKey2.iDFKey
77053>>>>>>>>>            Move vkKeys2 To Command.HotKey2.VKcode
77054>>>>>>>>>          End
77054>>>>>>>>>>
77054>>>>>>>>>          Move Command To Commands[iItem]
77055>>>>>>>>>        End
77055>>>>>>>>>>
77055>>>>>>>>>      End
77055>>>>>>>>>>
77055>>>>>>>>>    Loop
77056>>>>>>>>>>
77056>>>>>>>>>
77056>>>>>>>>>    Set pCommands To Commands
77057>>>>>>>>>  End_Procedure
77058>>>>>>>>>
77058>>>>>>>>>  // If no definition has been found then we need to set some defaults
77058>>>>>>>>>  // Below are our defaults (You can create defaults by copy&paste from the config ini file)
77058>>>>>>>>>  Function DefaultDefinitions Returns String
77060>>>>>>>>>    String sShortCuts
77060>>>>>>>>>
77060>>>>>>>>>    Move "<206|299|17|40><205|298|17|38><204|279|13|17><1025|270|118><1024|269|116><203|260|37><202|5127|16|37><201|261|39><200|5128|16|39><242|7174|16|17|40><243|2080|17|32><198|2147|17|67><197|2168|17|88><196|2679|17|18|87>" To sShortCuts
77061>>>>>>>>>    Move (sShortCuts+"<195|277|46><194|278|8:5123|8|16><191|301|17|35><190|7178|16|17|35><189|300|17|36><188|7177|16|17|36><1005|312|17|115><1007|2158|17|78><1001|2159|17|79><1004|2163|17|83><1002|265|113><1003|6161|17|113><178|2150|17|70>") To sShortCuts
77062>>>>>>>>>    Move (sShortCuts+"<1010|3142|16|17|70><176|281|114><175|6162|17|114><174|5138|16|114><173|7186|16|17|114><169|6674|17|18|114><168|2151|17|71><166|2141|17|221><165|294|36><164|5129|16|36><163|296|9>") To sShortCuts
77063>>>>>>>>>    Move (sShortCuts+"<1064|2664|17|18|72><161|2169|17|89><157|273|40><156|5126|16|40><155|295|35><154|5130|16|35><153|3150|16|17|78><149|272|38><148|5125|16|38><1050|4615|18|37><1057|559|18|191><1051|4614|18|40><1052|4616|18|39>") To sShortCuts
77064>>>>>>>>>    Move (sShortCuts+"<147|2156|17|76><146|291|34><145|5132|16|34><144|290|33><143|5131|16|33><140|2166|17|86><224|4609|13|18><213|3154|16|17|82><1079|3155|16|17|83><137|2145|17|65><136|6679|17|18|119><134|3160|16|17|88>") To sShortCuts
77065>>>>>>>>>    Move (sShortCuts+"<1011|2167|17|87><133|2667|17|18|75><132|6663|17|18|37><131|6664|17|18|39><187|2162|17|82><130|3156|16|17|84><1060|609|18|65><186|276|45><185|2676|17|18|84><1062|2152|17|72><129|2170|17|90><127|262|9|16>") To sShortCuts
77066>>>>>>>>>    Move (sShortCuts+"<126|3104|16|17|32><125|2165|17|85><1043|6146|9|17><1044|7170|9|16|17><120|292|17|33><119|293|17|34><1040|268|18|112><1042|6166|17|118><112|6158|17|46><111|297|8|17><108|302|17|37><107|7175|16|17|37><103|303|17|39>") To sShortCuts
77067>>>>>>>>>    Move (sShortCuts+"<102|7176|16|17|39>") To sShortCuts
77068>>>>>>>>>    Function_Return sShortCuts
77069>>>>>>>>>  End_Function
77070>>>>>>>>>
77070>>>>>>>>>  Function HasVkKey Integer[] VKcode Integer vk Returns Boolean
77072>>>>>>>>>    Boolean bHasKey
77072>>>>>>>>>    Integer iKey
77072>>>>>>>>>    Integer iCount
77072>>>>>>>>>
77072>>>>>>>>>    Move False To bHasKey
77073>>>>>>>>>    Move (SizeOfArray(VKcode)) To iCount
77074>>>>>>>>>    For iKey From 0 To (iCount-1)
77080>>>>>>>>>>
77080>>>>>>>>>      If (VKcode[iKey]=vk) Begin
77082>>>>>>>>>        Move True To bHasKey
77083>>>>>>>>>        Move iCount To iKey
77084>>>>>>>>>      End
77084>>>>>>>>>>
77084>>>>>>>>>    Loop
77085>>>>>>>>>>
77085>>>>>>>>>    Function_Return bHasKey
77086>>>>>>>>>  End_Function
77087>>>>>>>>>
77087>>>>>>>>>  //
77087>>>>>>>>>  // If a hotkey has alt then it has that annoying bell sound unless you handle it.
77087>>>>>>>>>  // Here's the code to detect that.
77087>>>>>>>>>  // Pre: only call this if the command actually has a hotkey assigned.
77087>>>>>>>>>  //
77087>>>>>>>>>  Function HotKeyHasAlt Integer iCmd Returns Boolean
77089>>>>>>>>>    Boolean bAlt
77089>>>>>>>>>    tSciCommandHotKey Command
77089>>>>>>>>>    tSciCommandHotKey Command
77089>>>>>>>>>
77089>>>>>>>>>    Move False To bAlt
77090>>>>>>>>>    Get FindCommand Of oSciCommandHotKeys iCmd To Command
77091>>>>>>>>>    If (Command.iCmd=iCmd) Begin
77093>>>>>>>>>      Get HasVkKey Of oSciCommandHotKeys Command.HotKey.VKcode VK_MENU To bAlt
77094>>>>>>>>>      If (bAlt=False) Begin
77096>>>>>>>>>        Get HasVkKey Of oSciCommandHotKeys Command.HotKey2.VKcode VK_MENU To bAlt
77097>>>>>>>>>      End
77097>>>>>>>>>>
77097>>>>>>>>>    End
77097>>>>>>>>>>
77097>>>>>>>>>    Function_Return bAlt
77098>>>>>>>>>  End_Function
77099>>>>>>>>>
77099>>>>>>>>>
77099>>>>>>>>>  //
77099>>>>>>>>>  // On_Key shortcut definitions are so much fun. You can't just pass them the DataFlex value as retrieved from procedure Key
77099>>>>>>>>>  // You'll have to do some math on them to return back the correct integer value that the On_Key wants in order
77099>>>>>>>>>  // to have it work correctly.
77099>>>>>>>>>  // You also cannot use expressions (see forum: https://support.dataaccess.com/Forums/showthread.php?60684-Dynamic-Keyboard-shortcut-brain-teaser )
77099>>>>>>>>>  // In this function we will try to figure out what it takes.
77099>>>>>>>>>  //
77099>>>>>>>>>  // For the moment it is still pretty much a riddle, here's what testing shows:
77099>>>>>>>>>  //
77099>>>>>>>>>  //  iDfKey < 605       ==> iOnKey = iDfKey
77099>>>>>>>>>  //  iDfKey 2139..2141  ==> iOnKey = iDfKey (ctrl+[ and ctrl+])
77099>>>>>>>>>  //  iDfKey 605..3141   ==> iOnKey = iDfKey-32
77099>>>>>>>>>  //  iDfKey 3142..4609  ==> iOnKey = iDfKey
77099>>>>>>>>>  //  iDfKey > 4609 ==> if ctrl/alt/shift subtract $1000 then subtract value for each modifier key
77099>>>>>>>>>  //                    add back new value for each modifier key and add offset
77099>>>>>>>>>  //  iDfKey >= 6672 ==> iOnKey = iDfKey
77099>>>>>>>>>  //
77099>>>>>>>>>  Function DataFlexOnKey tShortCut HotKey Returns Integer
77101>>>>>>>>>    Boolean bAlt bShift bCtrl
77101>>>>>>>>>    Integer iOnKey
77101>>>>>>>>>    Integer iDfKey
77101>>>>>>>>>    Integer iDfOffset
77101>>>>>>>>>
77101>>>>>>>>>    Move HotKey.iDFKey To iDfKey
77102>>>>>>>>>    //
77102>>>>>>>>>    Move iDFKey To iOnKey
77103>>>>>>>>>    Move 32     To iDfOffset
77104>>>>>>>>>    If (iDfKey>2138 and iDfKey<2142) ;      Move 0 To iDfOffset
77107>>>>>>>>>    If (iDfkey>605 and iDfKey<3142) ;      Move (iDfKey-iDfOffset) To iOnkey
77110>>>>>>>>>    Else If (iDfkey>4609 and iDfkey<6672) Begin
77113>>>>>>>>>      Get HasVkKey HotKey.VKcode VK_MENU    To bAlt
77114>>>>>>>>>      Get HasVkKey HotKey.VKcode VK_SHIFT   To bShift
77115>>>>>>>>>      Get HasVkKey HotKey.VKcode VK_CONTROL To bCtrl
77116>>>>>>>>>
77116>>>>>>>>>      If (bAlt or bShift or bCtrl) Begin
77118>>>>>>>>>        Move |CI$1000 To iDfOffset
77119>>>>>>>>>        If (bAlt) ;          Move (iDfOffset+|CI$0200) To iDfOffset
77122>>>>>>>>>        If (bShift) ;          Move (iDfOffset+|CI$0400) To iDfOffset
77125>>>>>>>>>        If (bCtrl) ;          Move (iDfOffset+|CI$0800) To iDfOffset
77128>>>>>>>>>        If (iDfOffset=|CI$1200 or iDfOffset=|CI$1400 or iDfOffset=|CI$1800) Begin
77130>>>>>>>>>          // only 1 modifier key was pressed, offset goes back to 0, iDfKey=iOnKey
77130>>>>>>>>>          Move 0 To iDfOffset
77131>>>>>>>>>        End
77131>>>>>>>>>>
77131>>>>>>>>>        If (iDfOffset<>0) Begin
77133>>>>>>>>>          Move |CI$EF8 To iDfOffset
77134>>>>>>>>>          Move (iDfKey-iDfOffset) To iOnKey
77135>>>>>>>>>        End
77135>>>>>>>>>>
77135>>>>>>>>>      End
77135>>>>>>>>>>
77135>>>>>>>>>
77135>>>>>>>>>    End
77135>>>>>>>>>>
77135>>>>>>>>>
77135>>>>>>>>>    Function_Return iOnKey
77136>>>>>>>>>  End_Function
77137>>>>>>>>>
77137>>>>>>>>>End_Class
77138>>>>>>>>>
77138>>>>>>>>>Object oSciCommandHotKeys is a cSciCommandHotKeys
77140>>>>>>>>>End_Object
77141>>>>>>>>>
77141>>>>>>>>>Procedure CMRegisterCommand Global Integer iCmd String sName String sDesc
77143>>>>>>>>>  Send RegisterCommand Of oSciCommandHotKeys iCmd sName sDesc
77144>>>>>>>>>End_Procedure
77145>>>>>>>>>
77145>>>>>>>>>// Used for declaring a Userdefined Command which can be accesed from within
77145>>>>>>>>>// our editing control.
77145>>>>>>>>>
77145>>>>>>>>>Procedure RegisterInternalCommand Global Integer iCmd String sName String sDesc
77147>>>>>>>>>  Send RegisterCommand Of oSciCommandHotKeys iCmd sName sDesc
77148>>>>>>>>>End_Procedure
77149>>>>>>>>>
77149>>>>>>>>>//
77149>>>>>>>>>// Need to register all our internal commands so that we have a similar set as with
77149>>>>>>>>>// codemax. The below text is pretty much a copy of what codemax has.
77149>>>>>>>>>//
77149>>>>>>>>>Procedure RegisterAllInternalCommands
77152>>>>>>>>>  tSciCommandHotKey[] ltCommands
77152>>>>>>>>>  tSciCommandHotKey[] ltCommands
77153>>>>>>>>>  Set pCommands Of oSciCommandHotKeys To ltCommands
77154>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDUPPERCASE               "WordUpperCase"             (_T("Makes the current word uppercase", 1100))
77155>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDTRANSPOSE               "WordTranspose"             (_T("Swaps the current and previous words", 1101))
77156>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDRIGHTEXTEND             "WordRightExtend"           (_T("Extends the selection forward to the start of the next word", 1102))
77157>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDRIGHT                   "WordRight"                 (_T("Moves forward to the start of the next word", 1103))
77158>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDRIGHT                "WordEndRight"              (_T("Moves forward to the end of the next word", 1104))
77159>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDRIGHTEXTEND          "WordEndRightExtend"        (_T("Extends the selection forward to the end of the next word", 1105))
77160>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDLOWERCASE               "WordLowerCase"             (_T("Makes the current word lowercase", 1106))
77161>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDLEFTEXTEND              "WordLeftExtend"            (_T("Extends the selection backward to the start of the previous word", 1107))
77162>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDLEFT                    "WordLeft"                  (_T("Moves backward to the start of the previous word", 1108))
77163>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDLEFT                 "WordEndLeft"               (_T("Moves backward to the end of the previous word", 1109))
77164>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDENDLEFTEXTEND           "WordEndLeftExtend"         (_T("Extends the selection backward to the end of the previous word", 1110))
77165>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDDELETETOSTART           "WordDeleteToStart"         (_T("Deletes a word to the left", 1111))
77166>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDDELETETOEND             "WordDeleteToEnd"           (_T("Deletes a word to the right", 1112))
77167>>>>>>>>>  Send RegisterInternalCommand  CMD_WORDCAPITALIZE              "WordCapitalize"            (_T("Makes the first character uppercase", 1113))
77168>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSTART                 "WindowStart"               (_T("Moves to the top of the text window", 1114))
77169>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLUP              "WindowScrollUp"            (_T("Scrolls the file contents up one line", 1115))
77170>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLTOTOP           "WindowScrollToTop"         (_T("Scrolls the line to the top of the window", 1116))
77171>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLTOCENTER        "WindowScrollToCenter"      (_T("Scrolls the line to the center of the window", 1117))
77172>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLTOBOTTOM        "WindowScrollToBottom"      (_T("Scrolls the line to the bottom of the window", 1118))
77173>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLRIGHT           "WindowScrollRight"         (_T("Scrolls the window to the right", 1119))
77174>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLLEFT            "WindowScrollLeft"          (_T("Scrolls the window to the left", 1120))
77175>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWSCROLLDOWN            "WindowScrollDown"          (_T("Scrolls the file contents down one line", 1121))
77176>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWRIGHTEDGE             "WindowRightEdge"           (_T("Moves to the right edge of the text window", 1122))
77177>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWLEFTEDGE              "WindowLeftEdge"            (_T("Moves to the left edge of the text window", 1123))
77178>>>>>>>>>  Send RegisterInternalCommand  CMD_WINDOWEND                   "WindowEnd"                 (_T("Moves to the bottom of the text window", 1124))
77179>>>>>>>>>  Send RegisterInternalCommand  CMD_UPPERCASESELECTION          "UpperCaseSelection"        (_T("Makes the selection all uppercase", 1125))
77180>>>>>>>>>  Send RegisterInternalCommand  CMD_UNTABIFYSELECTION           "UntabifySelection"         (_T("Replaces tabs with spaces in the selection", 1126))
77181>>>>>>>>>  Send RegisterInternalCommand  CMD_UNINDENTSELECTION           "UnindentSelection"         (_T("Indents the selected text left one stop", 1127))
77182>>>>>>>>>  Send RegisterInternalCommand  CMD_UNDOCHANGES                 "UndoChanges"               (_T("Undo's the last action, ignoring movement commands", 1128))
77183>>>>>>>>>  Send RegisterInternalCommand  CMD_UNDO                        "Undo"                      (_T("Undo the last action", 1129))
77184>>>>>>>>>  Send RegisterInternalCommand  CMD_TABIFYSELECTION             "TabifySelection"           (_T("Replaces spaces with tabs in the selection", 1130))
77185>>>>>>>>>  Send RegisterInternalCommand  CMD_SENTENCERIGHT               "SentenceRight"             (_T("Moves to the beginning of the next sentence", 1131))
77186>>>>>>>>>  Send RegisterInternalCommand  CMD_SENTENCELEFT                "SentenceLeft"              (_T("Moves to the beginning of the previous sentence", 1132))
77187>>>>>>>>>  Send RegisterInternalCommand  CMD_SENTENCECUT                 "SentenceCut"               (_T("Deletes the remainder of the sentence", 1133))
77188>>>>>>>>>  Send RegisterInternalCommand  CMD_SELECTSWAPANCHOR            "SelectSwapAnchor"          (_T("Swaps the anchor and the cursor in a selection", 1134))
77189>>>>>>>>>  Send RegisterInternalCommand  CMD_SELECTPARA                  "SelectPara"                (_T("Selects the current paragraph", 1135))
77190>>>>>>>>>  Send RegisterInternalCommand  CMD_SELECTLINE                  "SelectLine"                (_T("Selects lines of text", 1136))
77191>>>>>>>>>  Send RegisterInternalCommand  CMD_SELECTALL                   "SelectAll"                 (_T("Selects the entire document", 1137))
77192>>>>>>>>>  Send RegisterInternalCommand  CMD_REDOCHANGES                 "RedoChanges"               (_T("Redoes the last action, ignoring movement commands", 1138))
77193>>>>>>>>>  Send RegisterInternalCommand  CMD_REDO                        "Redo"                      (_T("Redoes the previously undone action", 1139))
77194>>>>>>>>>  Send RegisterInternalCommand  CMD_PASTE                       "Paste"                     (_T("Inserts the clipboard contents at the insertion point", 1140))
77195>>>>>>>>>  Send RegisterInternalCommand  CMD_PARAUP                      "ParaUp"                    (_T("Moves to the beginning of the previous paragraph", 1141))
77196>>>>>>>>>  Send RegisterInternalCommand  CMD_PARADOWN                    "ParaDown"                  (_T("Moves to the beginning of the next paragraph", 1142))
77197>>>>>>>>>  Send RegisterInternalCommand  CMD_PAGEUPEXTEND                "PageUpExtend"              (_T("Extends the selection up one page", 1143))
77198>>>>>>>>>  Send RegisterInternalCommand  CMD_PAGEUP                      "PageUp"                    (_T("Moves the cursor up one page", 1144))
77199>>>>>>>>>  Send RegisterInternalCommand  CMD_PAGEDOWNEXTEND              "PageDownExtend"            (_T("Extends the selection down one page", 1145))
77200>>>>>>>>>  Send RegisterInternalCommand  CMD_PAGEDOWN                    "PageDown"                  (_T("Moves the cursor down one page", 1146))
77201>>>>>>>>>  Send RegisterInternalCommand  CMD_LOWERCASESELECTION          "LowerCaseSelection"        (_T("Makes the selection all lowercase", 1147))
77202>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEUPEXTEND                "LineUpExtend"              (_T("Extends the selection up one line", 1148))
77203>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEUP                      "LineUp"                    (_T("Moves the cursor up one line", 1149))
77204>>>>>>>>>  Send RegisterInternalCommand  CMD_LINETRANSPOSE               "LineTranspose"             (_T("Swaps current and previous lines", 1150))
77205>>>>>>>>>  Send RegisterInternalCommand  CMD_LINESTART                   "LineStart"                 (_T("Moves to the start of the current line", 1151))
77206>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEOPENBELOW               "LineOpenBelow"             (_T("Opens a new line below the cursor", 1152))
77207>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEOPENABOVE               "LineOpenAbove"             (_T("Opens a new line above the cursor", 1153))
77208>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEENDEXTEND               "LineEndExtend"             (_T("Extends the selection to the end of the current line", 1154))
77209>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEEND                     "LineEnd"                   (_T("Moves the cursor to the end of the current line", 1155))
77210>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEDOWNEXTEND              "LineDownExtend"            (_T("Extends the selection down one line", 1156))
77211>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEDOWN                    "LineDown"                  (_T("Moves the cursor down one line", 1157))
77212>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEDELETETOSTART           "LineDeleteToStart"         (_T("Deletes to the beginning of the current line", 1158))
77213>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEDELETETOEND             "LineDeleteToEnd"           (_T("Deletes to the end of the current line", 1159))
77214>>>>>>>>>  Send RegisterInternalCommand  CMD_LINEDELETE                  "LineDelete"                (_T("Deletes the selected line", 1160))
77215>>>>>>>>>  Send RegisterInternalCommand  CMD_LINECUT                     "LineCut"                   (_T("Deletes the selected line and places the text on the clipboard", 1161))
77216>>>>>>>>>  Send RegisterInternalCommand  CMD_INDENTTOPREV                "IndentToPrev"              (_T("Indents to the position of the next text on the previous line", 1162))
77217>>>>>>>>>  Send RegisterInternalCommand  CMD_INDENTSELECTION             "IndentSelection"           (_T("Indents to the selected text right one stop", 1163))
77218>>>>>>>>>  Send RegisterInternalCommand  CMD_HOMEEXTEND                  "HomeExtend"                (_T("Extends the selection to either the start of the current line or the start of the text on that line", 1164))
77219>>>>>>>>>  Send RegisterInternalCommand  CMD_HOME                        "Home"                      (_T("Moves to either the start of the current line or the start of the text on that line", 1165))
77220>>>>>>>>>  Send RegisterInternalCommand  CMD_GOTOMATCHBRACE              "GoToMatchBrace"            (_T("Finds the matching brace", 1166))
77221>>>>>>>>>  Send RegisterInternalCommand  CMD_GOTOINDENTATION             "GoToIndentation"           (_T("Moves to the end of the indentation", 1167))
77222>>>>>>>>>  Send RegisterInternalCommand  CMD_GOTOLINE                    "GoToLine"                  (_T("Moves to a user-specified line", 1168))
77223>>>>>>>>>  Send RegisterInternalCommand  CMD_FINDREPLACE                 "FindReplace"               (_T("Displays the Find & Replace dialog box", 1169))
77224>>>>>>>>>  Send RegisterInternalCommand  CMD_REPLACE                     "Replace"                   (_T("Replaces the first occurrence of the find text after the current position with the replace text", 1170))
77225>>>>>>>>>  Send RegisterInternalCommand  CMD_REPLACEALLINBUFFER          "ReplaceAllInBuffer"        (_T("Replaces the find text with the replace text in the entire buffer", 1171))
77226>>>>>>>>>  Send RegisterInternalCommand  CMD_REPLACEALLINSELECTION       "ReplaceAllInSelection"     (_T("Replaces the find text with the replace text in the selection", 1172))
77227>>>>>>>>>  Send RegisterInternalCommand  CMD_FINDPREVWORD                "FindPrevWord"              (_T("Finds the previous occurrence of the selected word", 1173))
77228>>>>>>>>>  Send RegisterInternalCommand  CMD_FINDPREV                    "FindPrev"                  (_T("Finds the previous occurrence of the specified text", 1174))
77229>>>>>>>>>  Send RegisterInternalCommand  CMD_FINDNEXTWORD                "FindNextWord"              (_T("Finds the next occurrence of the selected word", 1175))
77230>>>>>>>>>  Send RegisterInternalCommand  CMD_FINDNEXT                    "FindNext"                  (_T("Finds the next occurrence of the specified text", 1176))
77231>>>>>>>>>  Send RegisterInternalCommand  CMD_FINDMARKALL                 "FindMarkAll"               (_T("Finds the specified text and sets a bookmark at the specified locations", 1177))
77232>>>>>>>>>  Send RegisterInternalCommand  CMD_FIND                        "Find"                      (_T("Finds the specified text", 1178))
77233>>>>>>>>>  Send RegisterInternalCommand  CMD_SETFINDTEXT                 "SetFindKeyWord"            (_T("Sets the text to search for in subsequent find commands", 1179))
77234>>>>>>>>>  Send RegisterInternalCommand  CMD_SETREPLACETEXT              "SetReplaceKeyWord"         (_T("Sets the text to substitute for the find text in subsequent find & replace commands", 1180))
77235>>>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEPRESERVECASE          "TogglePreserveCase"        (_T("Toggles intelligent case preservation when replacing text", 1181))
77236>>>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEWHOLEWORD             "ToggleWholeWord"           (_T("Toggles whole word searching on and off", 1182))
77237>>>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLECASESENSITIVE         "ToggleCaseSensitive"       (_T("Toggles case sensitive searching on and off", 1183))
77238>>>>>>>>>  Send RegisterInternalCommand  CMD_END                         "End"                       (_T("Moves to the end of the current line, bottom of the text window, or end of the file", 1184))
77239>>>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEWHITESPACEDISPLAY     "ToggleWhiteSpaceDisplay"   (_T("Shows or hides whitespace indicators", 1185))
77240>>>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEOVERTYPE              "ToggleOvertype"            (_T("Toggles between inserting and replacing text", 1186))
77241>>>>>>>>>  Send RegisterInternalCommand  CMD_SETREPEATCOUNT              "SetRepeatCount"            (_T("Sets the repeat count for the next command", 1187))
77242>>>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTSTARTEXTEND         "DocumentStartExtend"       (_T("Extends the selection to the beginning of the file", 1188))
77243>>>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTSTART               "DocumentStart"             (_T("Moves to the beginning of the file", 1189))
77244>>>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTENDEXTEND           "DocumentEndExtend"         (_T("Extends the selection to the end of the file", 1190))
77245>>>>>>>>>  Send RegisterInternalCommand  CMD_DOCUMENTEND                 "DocumentEnd"               (_T("Moves to the end of the file", 1191))
77246>>>>>>>>>  Send RegisterInternalCommand  CMD_DELETEHORIZONTALSPACE       "DeleteHorizontalSpace"     (_T("Deletes the spaces and the tabs around the cursor", 1192))
77247>>>>>>>>>  Send RegisterInternalCommand  CMD_DELETEBLANKLINES            "DeleteBlankLines"          (_T("Delete the blank lines adjacent to the cursor", 1193))
77248>>>>>>>>>  Send RegisterInternalCommand  CMD_DELETEBACK                  "DeleteBack"                (_T("Deletes the selection or, if there is no selection, the character to the left of the cursor", 1194))
77249>>>>>>>>>  Send RegisterInternalCommand  CMD_DELETE                      "Delete"                    (_T("Deletes the selection", 1195))
77250>>>>>>>>>  Send RegisterInternalCommand  CMD_CUTSELECTION                "CutSelection"              (_T("Cuts the selection and puts it on the clipboard", 1196))
77251>>>>>>>>>  Send RegisterInternalCommand  CMD_CUT                         "Cut"                       (_T("Cuts the selection and puts it on the clipboard", 1197))
77252>>>>>>>>>  Send RegisterInternalCommand  CMD_COPY                        "Copy"                      (_T("Copies the selection to the clipboard", 1198))
77253>>>>>>>>>  Send RegisterInternalCommand  CMD_CHARTRANSPOSE               "CharTranspose"             (_T("Swap characters around the insertion point", 1199))
77254>>>>>>>>>  Send RegisterInternalCommand  CMD_CHARRIGHTEXTEND             "CharRightExtend"           (_T("Extends the selection one character to the right", 1200))
77255>>>>>>>>>  Send RegisterInternalCommand  CMD_CHARRIGHT                   "CharRight"                 (_T("Moves the cursor one character to the right", 1201))
77256>>>>>>>>>  Send RegisterInternalCommand  CMD_CHARLEFTEXTEND              "CharLeftExtend"            (_T("Extends the selection one character to the left", 1202))
77257>>>>>>>>>  Send RegisterInternalCommand  CMD_CHARLEFT                    "CharLeft"                  (_T("Moves the cursor one character to the left", 1203))
77258>>>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKTOGGLE              "BookmarkToggle"            (_T("Toggles a bookmark for the current line on and off", 1204))
77259>>>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKPREV                "BookmarkPrev"              (_T("Moves to the line containing the previous bookmark", 1205))
77260>>>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKNEXT                "BookmarkNext"              (_T("Moves to the line containing the next bookmark", 1206))
77261>>>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKCLEARALL            "BookmarkClearAll"          (_T("Clears all bookmarks in the window", 1207))
77262>>>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKJUMPTOFIRST         "BookmarkJumpToFirst"       (_T("Moves to the first line containing a bookmark", 1208))
77263>>>>>>>>>  Send RegisterInternalCommand  CMD_BOOKMARKJUMPTOLAST          "BookmarkJumpToLast"        (_T("Moves to the last line containing a bookmark", 1209))
77264>>>>>>>>>  Send RegisterInternalCommand  CMD_APPENDNEXTCUT               "AppendNextCut"             (_T("Appends the next cut text to end of clipboard", 1210))
77265>>>>>>>>>  Send RegisterInternalCommand  CMD_INSERTCHAR                  "InsertChar"                (_T("Inserts a character at the current location", 1211))
77266>>>>>>>>>  Send RegisterInternalCommand  CMD_NEWLINE                     "NewLine"                   (_T("Inserts a new-line character at the current location", 1212))
77267>>>>>>>>>  Send RegisterInternalCommand  CMD_RECORDMACRO                 "RecordMacro"               (_T("Begins/ends keystroke macro recording", 1213))
77268>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO1                  "PlayMacro1"                (_T("Plays keystroke macro 1", 1214))
77269>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO2                  "PlayMacro2"                (_T("Plays keystroke macro 2", 1215))
77270>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO3                  "PlayMacro3"                (_T("Plays keystroke macro 3", 1216))
77271>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO4                  "PlayMacro4"                (_T("Plays keystroke macro 4", 1217))
77272>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO5                  "Playmacro5"                (_T("Plays keystroke macro 5", 1218))
77273>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO6                  "Playmacro6"                (_T("Plays keystroke macro 6", 1219))
77274>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO7                  "Playmacro7"                (_T("Plays keystroke macro 7", 1220))
77275>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO8                  "Playmacro8"                (_T("Plays keystroke macro 8", 1221))
77276>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO9                  "Playmacro9"                (_T("Plays keystroke macro 9", 1222))
77277>>>>>>>>>  Send RegisterInternalCommand  CMD_PLAYMACRO10                 "Playmacro10"               (_T("Plays keystroke macro 10", 1223))
77278>>>>>>>>>  Send RegisterInternalCommand  CMD_PROPERTIES                  "Properties"                (_T("Displays the properties dialog", 1224))
77279>>>>>>>>>  Send RegisterInternalCommand  CMD_BEGINUNDO                   "BeginUndo"                 (_T("Starts an undo transaction", 1225))
77280>>>>>>>>>  Send RegisterInternalCommand  CMD_ENDUNDO                     "EndUndo"                   (_T("Ends an undo transaction", 1226))
77281>>>>>>>>>  //Send RegisterInternalCommand  CMD_RESERVED3                   "" ""  // internal use only (1227)
77281>>>>>>>>>
77281>>>>>>>>>  Send RegisterInternalCommand  CMD_TOGGLEREGEXP                "ToggleRegExp"              (_T("Toggles regular expression searching on and off", 1228))
77282>>>>>>>>>  Send RegisterInternalCommand  CMD_CLEARSELECTION              "ClearSelection"            (_T("Empties the selection", 1229))
77283>>>>>>>>>  Send RegisterInternalCommand  CMD_REGEXPON                    "RegExpOn"                  (_T("Turns on regular expression searching", 1230))
77284>>>>>>>>>  Send RegisterInternalCommand  CMD_REGEXPOFF                   "RegExpOff"                 (_T("Turns off regular expression searching", 1231))
77285>>>>>>>>>  Send RegisterInternalCommand  CMD_WHOLEWORDON                 "WholeWordOn"               (_T("Turns on whole word searching", 1232))
77286>>>>>>>>>  Send RegisterInternalCommand  CMD_WHOLEWORDOFF                "WholeWordOff"              (_T("Turns off whole word searching", 1233))
77287>>>>>>>>>  Send RegisterInternalCommand  CMD_PRESERVECASEON              "PreserveCaseOn"            (_T("Turns on case preservation when replacing text", 1234))
77288>>>>>>>>>  Send RegisterInternalCommand  CMD_PRESERVECASEOFF             "PreserveCaseOff"           (_T("Turns off case preservation when replacing text", 1235))
77289>>>>>>>>>  Send RegisterInternalCommand  CMD_CASESENSITIVEON             "CaseSensitiveOn"           (_T("Turns on case sensitive searching", 1236))
77290>>>>>>>>>  Send RegisterInternalCommand  CMD_CASESENSITIVEOFF            "CaseSensitiveOff"          (_T("Turns off case sensitive searching", 1237))
77291>>>>>>>>>  Send RegisterInternalCommand  CMD_WHITESPACEDISPLAYON         "WhiteSpaceDisplayOn"       (_T("Turns on white space display", 1238))
77292>>>>>>>>>  Send RegisterInternalCommand  CMD_WHITESPACEDISPLAYOFF        "WhiteSpaceDisplayOff"      (_T("Turns off white space display", 1239))
77293>>>>>>>>>  Send RegisterInternalCommand  CMD_OVERTYPEON                  "OvertypeOn"                (_T("Turns on overtype mode", 1240))
77294>>>>>>>>>  Send RegisterInternalCommand  CMD_OVERTYPEOFF                 "OvertypeOff"               (_T("Turns off overtype mode", 1241))
77295>>>>>>>>>  Send RegisterInternalCommand  CMD_CODELIST                    "CodeList"                  (_T("Activates the code list control", 1242))
77296>>>>>>>>>  Send RegisterInternalCommand  CMD_CODETIP                     "CodeTip"                   (_T("Activates the code tip control", 1243))
77297>>>>>>>>>  //Send RegisterInternalCommand  CMD_LAST                        "" ""
77297>>>>>>>>>End_Procedure
77298>>>>>>>>>
77298>>>>>>>>>// Registers commands for CodeMax so that these function can be accessed in macros and keyAssignments
77298>>>>>>>>>// This does only the registration! Connecting these commands to the actual code needs to be
77298>>>>>>>>>// done in the DefinePredefinedHotkeys of cEditorHotKey_Mixin
77298>>>>>>>>>Procedure RegisterExtraCommands
77301>>>>>>>>>
77301>>>>>>>>>  // File Menu. 1-9
77301>>>>>>>>>  CMDeclareCommand CMD_FileOpenFile               1 "FileOpenFile"            "Opens a file"
77302>>>>>>>>>  CMDeclareCommand CMD_FileSaveFile               2 "FileSaveFile"            "Saves the file"
77303>>>>>>>>>  CMDeclareCommand CMD_FileSaveFileAs             3 "FileSaveFileAs"          "Save file as..."
77304>>>>>>>>>  CMDeclareCommand CMD_FileSaveAll                4 "FileSaveAll"             "Saves all opened files"
77305>>>>>>>>>  CMDeclareCommand CMD_FileCloseFile              5 "FileCloseFile"           "Closes the file"
77306>>>>>>>>>  CMDeclareCommand CMD_FileCloseAllFiles          6 "FileCloseAllFiles"       "Closes all files"
77307>>>>>>>>>  CMDeclareCommand CMD_FileNewFile                7 "FileNewFile"             "Create a new file"
77308>>>>>>>>>
77308>>>>>>>>>  // Options Menu 10-19
77308>>>>>>>>>  CMDeclareCommand CMD_FindInFiles                10 "FindInFiles"            "Search the text in multiple files"
77309>>>>>>>>>  CMDeclareCommand CMD_SelectWorkSpace            11 "SelectWorkSpace"       "Select another workspace to work in"
77310>>>>>>>>>
77310>>>>>>>>>  // Build Menu 20-29
77310>>>>>>>>>  CMDeclareCommand CMD_BuildRun                   20 "BuildRun"                "Compiles and runs the main program (or current file if is '.SRC')"
77311>>>>>>>>>  CMDeclareCommand CMD_BuildRunCurrent            21 "BuildRunCurrent"         "Compiles and runs the current file"
77312>>>>>>>>>  CMDeclareCommand CMD_BuildCompileCurrent        22 "BuildCompile"            "Compiles the current file"
77313>>>>>>>>>  CMDeclareCommand CMD_BuildPreCompile            23 "BuildPrecompile"         "PreCompiles the current file"
77314>>>>>>>>>  CMDeclareCommand CMD_BuildExecute               24 "BuildExecute"            "Starts the main program (or current file if it is '.SRC') without compiling"
77315>>>>>>>>>  CMDeclareCommand CMD_BuildDebugRun              25 "BuildDebugRun"           "ReCompiles with debug info and starts the main program"
77316>>>>>>>>>  CMDeclareCommand CMD_BuildDebugRunCurrent       26 "BuildDebugRunCurrent"    "ReCompiles with debug info and starts the current program"
77317>>>>>>>>>
77317>>>>>>>>>  // Window Menu. 40-49
77317>>>>>>>>>  CMDeclareCommand CMD_WindowSwitchToCodeView     40 "WindowSwitchToCodeView"   "Activates the codeview window"
77318>>>>>>>>>  CMDeclareCommand CMD_WindowSwitchToErrorView    41 "WindowSwitchToErrorView"  "Activates the error window"
77319>>>>>>>>>  CMDeclareCommand CMD_WindowSyncCodeView         42 "WindowSyncCodeView"       "Synchronizes the CodeView with cursorposition"
77320>>>>>>>>>  CMDeclareCommand CMD_WindowNextView             43 "WindowNextView"           "Activates the next view"
77321>>>>>>>>>  CMDeclareCommand CMD_WindowPreviousView         44 "WindowPreviousView"       "Activates the privious view"
77322>>>>>>>>>
77322>>>>>>>>>  // Lists 50-59
77322>>>>>>>>>  CMDeclareCommand CMD_ListCreator                50 "ListCreator"              "Activates the Creator list"
77323>>>>>>>>>  CMDeclareCommand CMD_ListObjects                51 "ListObjects"              "Activates the Object List"
77324>>>>>>>>>  CMDeclareCommand CMD_ListVars                   52 "ListVariables"            "Activates the Variables List"
77325>>>>>>>>>  CMDeclareCommand CMD_ListKeys                   53 "ListKeys"                 "Activates the Keys List"
77326>>>>>>>>>  CMDeclareCommand CMD_ListProcedures             54 "ListProcedures"           "Activates the Procedures List (Overwriting)"
77327>>>>>>>>>  CMDeclareCommand CMD_ListFunctions              55 "ListFunctions"            "Activates the Functions List (Overwriting)"
77328>>>>>>>>>  CMDeclareCommand CMD_ListClasses                56 "ListClasses"              "Activates the Classes List"
77329>>>>>>>>>  CMDeclareCommand CMD_ListIDETags                57 "ListIDETags"              "Activates the List with IDE tags"
77330>>>>>>>>>
77330>>>>>>>>>
77330>>>>>>>>>  // Mixed. 60-69
77330>>>>>>>>>  CMDeclareCommand CMD_ToggleComment              60 "ToggleComment"              "Toggled the current line comment"
77331>>>>>>>>>  CMDeclareCommand CMD_ToolsInsertHeaderGlobal    61 "ToolsInsertHeaderGlobal"    "Inserts a header into the current file (global)"
77332>>>>>>>>>  CMDeclareCommand CMD_ToolsInsertHeaderUser      62 "ToolsInsertHeaderUser"      "Inserts a header into the current file (userspecific)"
77333>>>>>>>>>  CMDeclareCommand CMD_OpenFileUnderCursor        63 "OpenFileUnderCursor"        "Tries to open the file under the current cursorposition"
77334>>>>>>>>>  CMDeclareCommand CMD_InsertRevisionMark         64 "InsertRevisionMark"         "Inserts a Revisionmark"
77335>>>>>>>>>  CMDeclareCommand CMD_InsertColor                65 "InsertColor"                "Inserts a RGB Color value"
77336>>>>>>>>>
77336>>>>>>>>>  // Convertion 70-79
77336>>>>>>>>>  CMDeclareCommand CMD_ConvertOnItemToAddItem   70 "ConvertOnItemToAddItem"       "Converts On_Item block to send Add_Item and back"
77337>>>>>>>>>  CMDeclareCommand CMD_ConvertCStructToVDF      71 "ConvertCStructToVDF"          "Converts a C structure to VDF syntax"
77338>>>>>>>>>  CMDeclareCommand CMD_ConvertCDllCallToVDF     72 "ConvertCDllCallToVDF"         "Converts a C Dll call to VDF syntax"
77339>>>>>>>>>  CMDeclareCommand CMD_ConvertVDFTypeToHandler  73 "ConvertVDFTypeToHandler"      "Converts a VDF TYPE structure to a Handler class"
77340>>>>>>>>>
77340>>>>>>>>>  CMDeclareCommand CMD_MarkScopeBlock           74 "MarkScopeBlock"               "Marks the current Scope Begin/End block for the current Line"
77341>>>>>>>>>
77341>>>>>>>>>  // v3.0 by SVN
77341>>>>>>>>>  CMDeclareCommand CMD_MOVELINEUP               75 "MoveLineUp"                   "Moves selected editor's code line up"
77342>>>>>>>>>  CMDeclareCommand CMD_MOVELINEDOWN             76 "MoveLineDown"                 "Moves selected editor's code line down"
77343>>>>>>>>>  CMDeclareCommand CMD_DUPLICATESELECTION       77 "DuplicateSelection"           "Duplicates selection or code line"
77344>>>>>>>>>
77344>>>>>>>>>  // by WvA
77344>>>>>>>>>  CMDeclareCommand CMD_DEBUGPERFCOUNTERS        78 "Performance counters"         "Displays some statistics using performance counters (used for debugging purposes)"
77345>>>>>>>>>  CMDeclareCommand CMD_REFACTORDROPSELF         79 "Refactor Drop Self"           "Refactor option to clean up Self references that are not required in recent code"
77346>>>>>>>>>  CMDeclareCommand CMD_REFACTOROBJECTNEIGHBORHOOD 80 "Refactor Object Neighborhood" "Refactor option to clean up nested object references that are not required anymore due to object neighborhood logic"
77347>>>>>>>>>  CMDeclareCommand CMD_REFACTORREINDENT         81 "Refactor Re-Indent"           "Refactor option to remove all existing indentation in the current file and replace it with your preferred indentation settings"
77348>>>>>>>>>  CMDeclareCommand CMD_GOTOFIRSTINDENTMISMATCH  82 "GoTo First Indent Mismatch"   "Will try to locate the first line that mismatches the current indentation rules."
77349>>>>>>>>>  CMDeclareCommand CMD_REFACTORMETHODEXTRACT    83 "Method extract"               "Extract the selected lines of code for method extraction"
77350>>>>>>>>>End_Procedure
77351>>>>>>>>>
77351>>>>>>>>>Send RegisterAllInternalCommands
77352>>>>>>>>>Send RegisterExtraCommands
77353>>>>>>>>>
77353>>>>>>>>>// CMGetHotKeys is replaced by function ShortCutKeyDefinitions
77353>>>>>>>>>Function CMGetHotkeys Global Returns String
77355>>>>>>>>>  String sHotKeys
77355>>>>>>>>>
77355>>>>>>>>>  Get ShortCutKeyDefinitions Of oSciCommandHotKeys To sHotKeys
77356>>>>>>>>>  Function_Return sHotKeys
77357>>>>>>>>>End_Function
77358>>>>>>>>>
77358>>>>>>>>>Function CMSetHotkeys Global String sHotKeys Returns Integer
77360>>>>>>>>>  If (sHotKeys="") Begin
77362>>>>>>>>>    Get DefaultDefinitions Of oSciCommandHotKeys To sHotKeys
77363>>>>>>>>>  End
77363>>>>>>>>>>
77363>>>>>>>>>  Set ShortCutKeyDefinitions Of oSciCommandHotKeys To sHotKeys
77364>>>>>>>>>  Function_Return 1
77365>>>>>>>>>End_Function
77366>>>>>>>>>
77366>>>>>>>>>// Not used in The Hammer
77366>>>>>>>>>//Function CMResetDefaultHotKeys global  Returns Integer
77366>>>>>>>>>//  send DevTest "CMResetDefaultHotKeys"
77366>>>>>>>>>//  function_return 0
77366>>>>>>>>>//End_Function
77366>>>>>>>>>Function CMGetHotKeysForCmd Global Integer wCmd Pointer pHotKeys  Returns Integer
77368>>>>>>>>>  Send DevTest "CMGetHotKeysForCmd"
77369>>>>>>>>>  Function_Return 0
77370>>>>>>>>>End_Function
77371>>>>>>>>>
77371>>>>>>>>>//
77371>>>>>>>>>// Is there a hotkey defined for the following command? If so then return
77371>>>>>>>>>// the hotkey as a string
77371>>>>>>>>>//
77371>>>>>>>>>Function CMCommandToHotKeyStr Integer iCmd Returns String
77374>>>>>>>>>  String sRet
77374>>>>>>>>>  tSciCommandHotKey Command
77374>>>>>>>>>  tSciCommandHotKey Command
77374>>>>>>>>>
77374>>>>>>>>>  Move "" To sRet
77375>>>>>>>>>  Get FindCommand Of oSciCommandHotKeys iCmd To Command
77376>>>>>>>>>  If (Command.iCmd>-1 and Command.iCmd=iCmd) Begin
77378>>>>>>>>>    Get CommandHotKeyString Of oSciCommandHotKeys Command To sRet
77379>>>>>>>>>  End
77379>>>>>>>>>>
77379>>>>>>>>>  Move (ToOem(sRet)) to sRet
77380>>>>>>>>>  Function_Return sRet
77381>>>>>>>>>End_Function
77382>>>>>>>>>
77382>>>>>>>>>// ToDo:
77382>>>>>>>>>// Gets the keys assigned to a value.
77382>>>>>>>>>// LOW: Virt key
77382>>>>>>>>>//  HI: Modifier (Combination of CM_KEY_ALT,CM_KEY_CONTROL,CM_KEY_SHIFT)
77382>>>>>>>>>Function CMGetKeyForCommand Integer iCmd Integer iNr Returns Integer
77385>>>>>>>>>  //String  sHotkey
77385>>>>>>>>>  //Integer iRet iModifier1 iVirtKey1 iKeys
77385>>>>>>>>>  //Move (CMGetHotKeysForCmd(iCmd,0))   to iKeys                 // Get the Number of hotkeys assigned!
77385>>>>>>>>>  //If iNr Lt 0 Function_Return iKeys                            // If item lt 0 returns the number of keys.
77385>>>>>>>>>  //If iKeys Eq 0 Function_Return 0                              // If not keys are assigned break.
77385>>>>>>>>>  //    // Get the keyvalues...
77385>>>>>>>>>  //Local_Buffer sHotKeys pHotKeys (CM_HOTKEY_SIZE*iKeys+10)                        // Reserver the necc. amount of memory to get all Hotkeys assigned to the cmd.
77385>>>>>>>>>  //Move (CMGetHotKeysForCmd(iCmd,pHotKeys))                    to iRet         // Gets the assigned hotkeys.
77385>>>>>>>>>  //Move (Mid(sHotkeys,CM_HOTKEY_SIZE,(CM_HOTKEY_SIZE*iNr)+1))  to sHotkey      // Get the selected key.
77385>>>>>>>>>  //Getbuff From sHotKey at CM_HOTKEY.byModifiers1              to iModifier1   // Get the Ext key.
77385>>>>>>>>>  //Getbuff From sHotKey at CM_HOTKEY.nVirtKey1                 to iVirtKey1    // Get the VK key.
77385>>>>>>>>>  //Function_Return (MAKEWPARAM(iModifier1,iVirtkey1))
77385>>>>>>>>>End_Function
77386>>>>>>>>>
77386>>>>>>>>>
77386>>>>>>>>>// The following functions are Not used in the hammer
77386>>>>>>>>>//Function CMRegisterHotKey global Pointer pHotKey Integer wCmd   Returns Integer
77386>>>>>>>>>//  send DevTest "CMRegisterHotKey"
77386>>>>>>>>>//  function_return 0
77386>>>>>>>>>//End_Function
77386>>>>>>>>>//Function CMUnregisterHotKey global Pointer pHotKey   Returns Integer
77386>>>>>>>>>//  send DevTest "CMUnregisterHotKey"
77386>>>>>>>>>//  function_return 0
77386>>>>>>>>>//End_Function
77386>>>>>>>>>//Function CMGetCommandString global Integer wCmd Integer bDescription Pointer pszBuff Integer nBuffLen   Returns Integer
77386>>>>>>>>>//  send DevTest "CMGetCommandString"
77386>>>>>>>>>//  function_return 0
77386>>>>>>>>>//End_Function
77386>>>>>>>
77386>>>>>>>
77386>>>>>>>Global_Variable Integer ghoEditorProperties
77386>>>>>>>
77386>>>>>>>    // Stores all Parameter which should been saved to disk.
77386>>>>>>>
77386>>>>>>>    // Added Property piSaveLocal to speed-up the saving of a file on a network drive
77386>>>>>>>    // 19.02.02 Bernhard
77386>>>>>>>    // INI_GLOBAL
77386>>>>>>>Class cEditorProperties Is a cIniProperties
77387>>>>>>>    INI_Begin_Properties "CODEMAXEDIT.INI" INI_USER
77392>>>>>>>        INI_Property        String  psFileTypes                 Public ""
77400>>>>>>>        INI_Property        Integer piLineNumbering             Public False
77408>>>>>>>        INI_Property        Integer pbLeftMargin                Public False
77416>>>>>>>        INI_Property        String  psColors                    Public ""
77424>>>>>>>        INI_Property        String  psReadOnlyColors            Public ""
77432>>>>>>>        // By WvA 20170417 - Scintilla hot keys
77432>>>>>>>        INI_Property        String  psEditorHotKeys             Public ""
77440>>>>>>>        INI_Property        Integer piRecentFilesLimit          Public 0
77448>>>>>>>        INI_Property        String  psRecentFiles               Public "" MULTI
77468>>>>>>>        // By SVN 22-03-2017
77468>>>>>>>        INI_Property        Integer piRecentWSLimit             Public 15
77476>>>>>>>        INI_Property        String  psRecentWorkspaces          Public "" MULTI
77496>>>>>>>        INI_Property.Sub    String  sDescription                Public ""
77504>>>>>>>        INI_Property.Sub    String  sVersion                    Public ""
77512>>>>>>>        //
77512>>>>>>>        INI_Property        Integer piViewMode                  Public 0
77520>>>>>>>        INI_Property        Integer piViewSize.Y                Public 0
77528>>>>>>>        INI_Property        Integer piViewSize.X                Public 0
77536>>>>>>>        INI_Property        Integer pbColorSyntax               Public 0
77544>>>>>>>        INI_Property        String  psLanguage                  Public ""
77552>>>>>>>        INI_Property        Integer pbScrollBarH                Public 0
77560>>>>>>>        INI_Property        Integer pbScrollBarV                Public 0
77568>>>>>>>        INI_Property        Integer pbSplitterH                 Public 0
77576>>>>>>>        INI_Property        Integer pbSplitterV                 Public 0
77584>>>>>>>        INI_Property        Integer pbSmoothScrolling           Public 0
77592>>>>>>>        INI_Property        Integer pbLineToolTips              Public 0
77600>>>>>>>        INI_Property        Integer pbDragDrop                  Public 0
77608>>>>>>>        INI_Property        Integer pbColumnSel                 Public 0
77616>>>>>>>        INI_Property        Integer piUndoLimit                 Public 0
77624>>>>>>>        INI_Property        Integer piAutoIndentMode            Public 0
77632>>>>>>>        INI_Property        Integer piTabSize                   Public 0
77640>>>>>>>        INI_Property        Integer pbTabExpand                 Public 0
77648>>>>>>>        INI_Property        Integer pbNormalizeCase             Public 0
77656>>>>>>>        INI_Property        Integer pbCloseOutputPaneOnEscape   Public 0 // close output pane when pressing Escape key
77664>>>>>>>        INI_Property        Integer pbTrimEOLOnSave             Public 0 // trim line endings on save
77672>>>>>>>        INI_Property        Integer pbFileSaveBackup            Public True // create a .bak file on save
77680>>>>>>>        INI_Property        Integer pbOemToAnsi                 Public True // do an OEM to ANSI conversion on load and save
77688>>>>>>>        INI_Property        Integer pbUtf8Support               Public False // support Utf8 load/save
77696>>>>>>>        INI_Property        Integer pbMethodSuffixComment       Public False // automatically add a comment behind the method end
77704>>>>>>>        INI_Property        Integer pbPreserveCase              Public 0
77712>>>>>>>        INI_Property        Integer pbSelBounds                 Public 0
77720>>>>>>>        INI_Property        Integer pbWholeWord                 Public 0
77728>>>>>>>        INI_Property        Integer pbCaseSensitive             Public 0
77736>>>>>>>        INI_Property        String  psFont                      Public ""
77744>>>>>>>        INI_Property        String  psLanguages                 Public "" MULTI
77764>>>>>>>        INI_Property.Sub    Integer dwStyle                     Public 0
77772>>>>>>>        INI_Property.Sub    Integer bIsCaseSensitive            Public 0
77780>>>>>>>        INI_Property.Sub    String  szKeywords                  Public ""
77788>>>>>>>        INI_Property.Sub    String  szOperators                 Public ""
77796>>>>>>>        INI_Property.Sub    String  szSingleLineComments        Public ""
77804>>>>>>>        INI_Property.Sub    String  szMultiLineComments1        Public ""
77812>>>>>>>        INI_Property.Sub    String  szMultiLineComments2        Public ""
77820>>>>>>>        INI_Property.Sub    String  szScopeKeywords1            Public ""
77828>>>>>>>        INI_Property.Sub    String  szScopeKeywords2            Public ""
77836>>>>>>>        INI_Property.Sub    String  szStringDelims              Public ""
77844>>>>>>>        INI_Property.Sub    String  chEscape                    Public ""
77852>>>>>>>        INI_Property.Sub    String  chTerminator                Public ""
77860>>>>>>>        INI_Property.Sub    String  pszTagElementNames          Public ""
77868>>>>>>>        INI_Property.Sub    String  pszTagAttributeNames        Public ""
77876>>>>>>>        INI_Property.Sub    String  pszTagEntities              Public ""
77884>>>>>>>        INI_Property        String  psFontStyles                Public ""
77892>>>>>>>        INI_Property        Integer piUseWorkSpace              Public 0
77900>>>>>>>        INI_Property        Integer pbCompileAutoSave           Public 0
77908>>>>>>>        INI_Property        String  psCompiler                  Public ""
77916>>>>>>>        INI_Property        String  psCompiler.CompOptions      Public ""
77924>>>>>>>        INI_Property        String  psCompiler.PreCompOptions   Public ""
77932>>>>>>>        INI_Property        String  psDebugger                  Public ""
77940>>>>>>>        INI_Property        Integer piCompiler4Debug            Public ""
77948>>>>>>>        INI_Property        String  psDebugCompiler             Public ""
77956>>>>>>>        INI_Property        Integer piCompileShowErrorMsg       Public 0
77964>>>>>>>        INI_Property        String  psStartUpPath               Public ""
77972>>>>>>>        INI_Property        Integer piSaveLocal                 Public False
77980>>>>>>>        INI_Property        Integer piErrorListHeight           Public 0
77988>>>>>>>        INI_Property        Integer pbErrorListVisible          Public 0
77996>>>>>>>        INI_Property        Integer piCodeViewWidth             Public 0
78004>>>>>>>        INI_Property        Integer pbCodeViewVisible           Public 0
78012>>>>>>>        INI_Property        String  psVDFRegistryVersion        Public ""
78020>>>>>>>        // SVN 21-03-2017
78020>>>>>>>        INI_Property        Integer pbToolsPaneVisible          Public True
78028>>>>>>>        INI_Property        Integer pbOutputPaneVisible         Public False
78036>>>>>>>        //
78036>>>>>>>        // ** SVN 07/04-2017 -- TH3 New Tokens INI file
78036>>>>>>>        INI_Property        String  psTokensIniFile             Public "tokens.ini"
78044>>>>>>>        INI_Property        String  psCodeTipIniFile            Public ""
78052>>>>>>>        INI_Property        Integer pbUseCodeTips               Public True
78060>>>>>>>        INI_Property        Integer pbCodeTipAutoPopup          Public True
78068>>>>>>>        INI_Property        String  pbCodeListUseBitmaps        Public True
78076>>>>>>>        INI_Property        Integer pbShowClasses               Public True
78084>>>>>>>        INI_Property        Integer pbShowObjects               Public True
78092>>>>>>>        INI_Property        Integer pbShowMethods               Public True
78100>>>>>>>        INI_Property        Integer pbShowKeys                  Public True
78108>>>>>>>        INI_Property        Integer pbShowFields                Public True
78116>>>>>>>        INI_Property        Integer pbShowIndexes               Public True
78124>>>>>>>        INI_Property        Integer pbShowVariables             Public True
78132>>>>>>>        INI_Property        Integer pbShowIDETags               Public True
78140>>>>>>>        // ** SVN 07/04-2017 -- TH3 New CodeLists Auto Popup
78140>>>>>>>        INI_Property        Integer pbShowStructures            Public True
78148>>>>>>>        INI_Property        Integer pbShowCommands              Public True
78156>>>>>>>        INI_Property        Integer pbShowTypes                 Public True
78164>>>>>>>        INI_Property        Integer pbShowAttributes            Public True
78172>>>>>>>        INI_Property        Integer pbShowSourceFiles           Public True
78180>>>>>>>        INI_Property        String  psIDEPath                   Public ""
78188>>>>>>>        INI_Property        String  psDBBPath                   Public ""
78196>>>>>>>        INI_Property        String  psDBEPath                   Public ""
78204>>>>>>>        INI_Property        String  psMergePath                 Public ""
78212>>>>>>>        INI_Property        String  psVCSPath                   Public ""
78220>>>>>>>        INI_Property        String  psRptPath                   Public ""
78228>>>>>>>        INI_Property        String  psDbcPath                   Public ""
78236>>>>>>>        INI_Property        String  psDbuPath                   Public ""
78244>>>>>>>        INI_Property        String  psCodeArtPath               Public ""
78252>>>>>>>        INI_Property        String  psCodeSpyPath               Public ""
78260>>>>>>>        INI_Property        String  psCodePubPath               Public ""
78268>>>>>>>        INI_Property        String  psMenuPath                  Public ""
78276>>>>>>>        // ** SVN -- CodeArt
78276>>>>>>>        INI_Property        Integer pbCodeArtInsertErrors       Public False
78284>>>>>>>        INI_Property        Integer pbCodeArtInsertDateTime     Public False
78292>>>>>>>        INI_Property        Integer pbCodeArtInsertComments     Public True
78300>>>>>>>        // ** SVN -- CodePub
78300>>>>>>>        INI_Property        String  psCodePubHeaderFile         Public ""
78308>>>>>>>        INI_Property        String  psCodePubFooterFile         Public ""
78316>>>>>>>        //
78316>>>>>>>        //
78316>>>>>>>        INI_Property        String  psDfrun                     Public ""
78324>>>>>>>        INI_Property        String  psLangAssign                Public "" MULTI
78344>>>>>>>        INI_Property.Sub    String  Ext                         Public ""
78352>>>>>>>        INI_Property.Sub    String  Language                    Public ""
78360>>>>>>>
78360>>>>>>>        // BP -- Character translation
78360>>>>>>>        INI_Property        String  psCharTranslation           Public ""
78368>>>>>>>
78368>>>>>>>        // BP -- Watch Compiler Messages during Compile
78368>>>>>>>        INI_Property        Integer piWatchCompiler             Public 0
78376>>>>>>>        INI_Property        Integer piDisplayWatchAutomatic     Public 0
78384>>>>>>>        INI_Property        Integer piDebugAlways               Public 0
78392>>>>>>>        // By SVN -- 14-04-2017 Window
78392>>>>>>>        // By SVN -- 14-04-2017 Skinning
78392>>>>>>>        INI_Property        Integer piUseSkins                  Public 0
78400>>>>>>>        INI_Property        String  psCurrentSkinFile           Public ""
78408>>>>>>>        INI_Property        String  psCurrentSkinIni            Public ""
78416>>>>>>>        // Tabs
78416>>>>>>>        INI_Property        String  psFileTabsLocation          Public "Bottom"
78424>>>>>>>        INI_Property        String  psFileTabsAppearance        Public ""
78432>>>>>>>        INI_Property        String  psFileTabsColor             Public ""
78440>>>>>>>        INI_Property        Integer pbFileTabsMultiRow          Public False
78448>>>>>>>        // Color Schemas (By SVN)
78448>>>>>>>        INI_Property        String  psColorSchema               Public ""
78456>>>>>>>        INI_Property        String  psColorSchemas              Public "" MULTI
78476>>>>>>>        INI_Property.Sub    Integer psSchemaColors              Public ""
78484>>>>>>>        INI_Property.Sub    Integer psSchemaFontStyles          Public ""
78492>>>>>>>        INI_Property        String  psFontFace                  Public ""
78500>>>>>>>        // Custom Utility (By SVN on 27-04-2017)
78500>>>>>>>        INI_Property        String  psCustomMenuUtilities       Public "" MULTI // Code Maintenance...
78520>>>>>>>        INI_Property.Sub    Integer psUtilityType               Public "" // DATABASE, SOURCE, TOOLS
78528>>>>>>>        INI_Property.Sub    Integer psUtilityOrder              Public "" // 0, 1, 2, ...
78536>>>>>>>        INI_Property.Sub    Integer psUtilityCommand            Public "" // C:\...\Bin\... .exe %1 etc
78544>>>>>>>        //
78544>>>>>>>        INI_Property        String  psSignAppPath               Public ""
78552>>>>>>>        INI_Property        Integer pbExtCompilerOnly           Public 0
78560>>>>>>>        INI_Property        Integer pbShowMatchingBraces        Public True
78568>>>>>>>        INI_Property        Integer pbShowIndentGuides          Public True
78576>>>>>>>        INI_Property        Integer pbSelectWholeLine           Public True
78584>>>>>>>        INI_Property        String  psLastEditedFile            Public ""
78592>>>>>>>        // Interface Language
78592>>>>>>>        INI_Property        String  psInterfaceLanguage         Public ""
78600>>>>>>>        //
78600>>>>>>>    INI_End_Properties
78725>>>>>>>
78725>>>>>>>        // Delivers the language for
78725>>>>>>>    Function LanguageForFile String sFile Returns String
78727>>>>>>>        Integer iCount iItem
78727>>>>>>>        String  sExt sLangExt sLang
78727>>>>>>>
78727>>>>>>>        Move (CString(sFile)) To sFile // Not sure if we need to do this?
78728>>>>>>>        Get ParseFileExtension sFile To sExt
78729>>>>>>>        Get psLangAssign.Count  To iCount
78730>>>>>>>        For iItem From 0 To (iCount-1)
78736>>>>>>>>
78736>>>>>>>            Get psLangAssign.Ext item iItem    To sLangExt
78737>>>>>>>            Move (CString(sLangExt))           To sLangExt
78738>>>>>>>            Move (Replaces("*",sLangExt,""))   To sLangExt // If user enters "*.html" in language detection than it will never match the actual file extension
78739>>>>>>>            Move (Replaces(".",sLangExt,""))   To sLangExt // same for .html
78740>>>>>>>            Move (Trim(Uppercase(sExt)))       To sExt
78741>>>>>>>            Move (Trim(Uppercase(sLangExt)))   To sLangExt
78742>>>>>>>            If (sExt = sLangExt) Begin
78744>>>>>>>                Get psLangAssign.Language Item iItem    To sLang
78745>>>>>>>                Function_Return sLang
78746>>>>>>>            End
78746>>>>>>>>
78746>>>>>>>        End
78747>>>>>>>>
78747>>>>>>>        Function_Return (psLanguage(Self))
78748>>>>>>>    End_Function
78749>>>>>>>
78749>>>>>>>
78749>>>>>>>    // Adds a Entry to the RecentFiles List, previous it tests
78749>>>>>>>    // if the same file is already in the list and removes it.
78749>>>>>>>    // By SVN on 22-03-2017
78749>>>>>>>    Procedure AddRecentWorkspace String sWorkspace String sName String sVersion
78751>>>>>>>        Integer iCount iC iLimit
78751>>>>>>>        Move (Trim(sWorkspace))                 to sWorkspace
78752>>>>>>>        Move (psRecentWorkspaces.Count(Self))   to iCount
78753>>>>>>>        For iC from 0 to (iCount-1)
78759>>>>>>>>
78759>>>>>>>            If (Uppercase(psRecentWorkspaces(Self,iC)) = Uppercase(sWorkspace)) Begin
78761>>>>>>>                Send psRecentWorkspaces.DeleteItem iC
78762>>>>>>>                Move iCount to iC
78763>>>>>>>            End
78763>>>>>>>>
78763>>>>>>>        End
78764>>>>>>>>
78764>>>>>>>        Move (psRecentWorkspaces.Count(Self))           to iCount
78765>>>>>>>        Set psRecentWorkspaces              item iCount to sWorkspace
78766>>>>>>>        Set psRecentWorkspaces.sDescription item iCount to sName
78767>>>>>>>        Set psRecentWorkspaces.sVersion     item iCount to sVersion
78768>>>>>>>
78768>>>>>>>        // Limit to the max RecentFileList length
78768>>>>>>>        Move (psRecentWorkspaces.Count(Self))    to iCount
78769>>>>>>>        Move (piRecentWSLimit(Self))     to iLimit
78770>>>>>>>        For iC from 0 to (iCount-1-iLimit)
78776>>>>>>>>
78776>>>>>>>            Send psRecentWorkspaces.DeleteItem iC
78777>>>>>>>        End
78778>>>>>>>>
78778>>>>>>>    End_Procedure
78779>>>>>>>
78779>>>>>>>    // Adds a Entry to the RecentFiles List, previous it tests
78779>>>>>>>    // if the same file is already in the list and removes it.
78779>>>>>>>    Procedure AddRecentFile String sFile
78781>>>>>>>        Integer iCount iC iLimit
78781>>>>>>>        Move (Trim(sFile))                  to sFile
78782>>>>>>>        Move (psRecentFiles.Count(Self))    to iCount
78783>>>>>>>        For iC from 0 to (iCount-1)
78789>>>>>>>>
78789>>>>>>>            If (Uppercase(psRecentFiles(Self,iC))) Eq (Uppercase(sFile)) Begin
78791>>>>>>>                Send psRecentFiles.DeleteItem iC
78792>>>>>>>                Move iCount to iC
78793>>>>>>>            End
78793>>>>>>>>
78793>>>>>>>        End
78794>>>>>>>>
78794>>>>>>>        Move (psRecentFiles.Count(Self))    to iCount
78795>>>>>>>        Set psRecentFiles item iCount       to sFile
78796>>>>>>>
78796>>>>>>>        // Limit to the max RecentFileList length
78796>>>>>>>        Move (psRecentFiles.Count(Self))    to iCount
78797>>>>>>>        Move (piRecentFilesLimit(Self))     to iLimit
78798>>>>>>>        For iC from 0 to (iCount-1-iLimit)
78804>>>>>>>>
78804>>>>>>>            Send psRecentFiles.DeleteItem iC
78805>>>>>>>        Loop
78806>>>>>>>>
78806>>>>>>>    End_Procedure
78807>>>>>>>
78807>>>>>>>        // Finds a language by Name...
78807>>>>>>>    Function FindLanguage String sName Returns Integer
78809>>>>>>>        Integer iC iCount
78809>>>>>>>        String  sStr
78809>>>>>>>        Move (Trim(sName))          to sName
78810>>>>>>>        Get psLanguages.Count       to iCount
78811>>>>>>>        For iC from 0 to (iCount-1)
78817>>>>>>>>
78817>>>>>>>            Get psLanguages item iC  to sStr
78818>>>>>>>            If (sStr = sName) Begin
78820>>>>>>>                Function_Return iC
78821>>>>>>>            End
78821>>>>>>>>
78821>>>>>>>        End
78822>>>>>>>>
78822>>>>>>>        Function_Return -1
78823>>>>>>>    End_Function
78824>>>>>>>
78824>>>>>>>    Procedure DeleteLanguage String sName
78826>>>>>>>        Integer iCount iC
78826>>>>>>>        Move (Uppercase(Trim(sName)))       to sName
78827>>>>>>>        Move (psLanguages.Count(Self))   to iCount
78828>>>>>>>        For iC from 0 to (iCount-1)
78834>>>>>>>>
78834>>>>>>>            If (Uppercase(psLanguages(Self,iC))=sName) Begin
78836>>>>>>>                Send psLanguages.DeleteItem iC
78837>>>>>>>                Move iCount to iC
78838>>>>>>>            End
78838>>>>>>>>
78838>>>>>>>        Loop
78839>>>>>>>>
78839>>>>>>>    End_Procedure
78840>>>>>>>
78840>>>>>>>    // Finds a color schema by Name...
78840>>>>>>>    Function FindColorSchema String sName Returns Integer
78842>>>>>>>        Integer iC iCount
78842>>>>>>>        String  sStr
78842>>>>>>>        Move (Trim(sName))          to sName
78843>>>>>>>        Get psColorSchemas.Count       to iCount
78844>>>>>>>        For iC from 0 to (iCount-1)
78850>>>>>>>>
78850>>>>>>>            Get psColorSchemas item iC  to sStr
78851>>>>>>>            If (sStr = sName) Begin
78853>>>>>>>                Function_Return iC
78854>>>>>>>            End
78854>>>>>>>>
78854>>>>>>>        Loop
78855>>>>>>>>
78855>>>>>>>        Function_Return -1
78856>>>>>>>    End_Function
78857>>>>>>>
78857>>>>>>>    Procedure DeleteColorSchema String sName
78859>>>>>>>        Integer iCount iC
78859>>>>>>>        Move (Uppercase(Trim(sName)))       to sName
78860>>>>>>>        Move (psColorSchemas.Count(Self))   to iCount
78861>>>>>>>        For iC from 0 to (iCount-1)
78867>>>>>>>>
78867>>>>>>>            If (Uppercase(psColorSchemas(Self,iC))=sName) Begin
78869>>>>>>>                Send psColorSchemas.DeleteItem iC
78870>>>>>>>                Move iCount to iC
78871>>>>>>>            End
78871>>>>>>>>
78871>>>>>>>        Loop
78872>>>>>>>>
78872>>>>>>>    End_Procedure
78873>>>>>>>
78873>>>>>>>        // Registers the language with the given item nr.
78873>>>>>>>        // (for Highlighting)
78873>>>>>>>    Procedure RegisterLanguage Integer iC
78875>>>>>>>      // codemax only!
78875>>>>>>>    End_Procedure
78876>>>>>>>        // Does a RegisterLanguage for every language.
78876>>>>>>>        // (so all Languages are registerd <g>)
78876>>>>>>>    Procedure RegisterAllLanguages
78878>>>>>>>        Integer iC iCount
78878>>>>>>>        Get psLanguages.Count To iCount
78879>>>>>>>        For iC From 0 To (iCount-1)
78885>>>>>>>>
78885>>>>>>>            Send RegisterLanguage iC
78886>>>>>>>        End
78887>>>>>>>>
78887>>>>>>>    End_Procedure
78888>>>>>>>
78888>>>>>>>        // Overwritten to
78888>>>>>>>    Procedure LoadIni
78890>>>>>>>        Integer iRet
78890>>>>>>>        String  sStartupPath
78890>>>>>>>        Forward Send LoadIni
78892>>>>>>>
78892>>>>>>>        Get CMSetHotkeys (psEditorHotKeys(Self))  To iRet       // Sets the Hotkeys.
78893>>>>>>>        Send RegisterAllLanguages                               // Registers all Languages for Highlighting
78894>>>>>>>        // **WvA: 05-03-03, Changed to eliminate a "RAW file Error"
78894>>>>>>>        Get psStartUpPath To sStartUpPath
78895>>>>>>>
78895>>>>>>>        If sStartUpPath Ne "" Begin
78897>>>>>>>          Send DoChangeCurrentFolder sStartUpPath
78898>>>>>>>        End
78898>>>>>>>>
78898>>>>>>>
78898>>>>>>>        Send Editor_LoadAllMacros gsUserName
78899>>>>>>>    End_Procedure
78900>>>>>>>
78900>>>>>>>    Procedure SaveIni
78902>>>>>>>        Forward Send SaveIni
78904>>>>>>>        Send Editor_SaveAllMacros gsUserName
78905>>>>>>>    End_Procedure
78906>>>>>>>End_Class
78907>>>>>>>
78907>>>>>>>// This method will change the current windowsfolder for a given directory
78907>>>>>>>//
78907>>>>>>>// Just blindly checking the current folder using the Set_Directory command
78907>>>>>>>// evokes a cryptic "RAW-file error"
78907>>>>>>>//
78907>>>>>>>Procedure DoChangeCurrentFolder Global String sFolder
78909>>>>>>>  String sMessage
78909>>>>>>>  String sHome
78909>>>>>>>  If (vFolderExists(sFolder)) Begin
78911>>>>>>>    Set_Directory sFolder       // Sets the current workfolder
78912>>>>>>>  End
78912>>>>>>>>
78912>>>>>>>  Else Begin
78913>>>>>>>    Get psHome of (phoWorkspace(ghoApplication)) to sHome
78914>>>>>>>    If (sFolder<>"<undefined>") Begin // don't tell anything on first startup, just change the startup folder
78916>>>>>>>      // Cannot have a translation here as this is before the array gets populated, so you'll get error 4509.
78916>>>>>>>      //#IFDEF TH_TRANSLATION
78916>>>>>>>      //Move gILanguage[1592] to sMessage
78916>>>>>>>      //#ELSE
78916>>>>>>>      Move ("The program tried to set the following folder as your current directory.\n\n") to sMessage
78917>>>>>>>      Move (sMessage+"Folder: '%1'\n\n") to sMessage
78918>>>>>>>      Move (sMessage+"This folder does not appear to exist on your system.\n\n") to sMessage
78919>>>>>>>      Move (sMessage+"Changing current directory to '%2' instead.") to sMessage
78920>>>>>>>      //#ENDIF
78920>>>>>>>      Move (Replace("%1", sMessage, sFolder)) to sMessage
78921>>>>>>>      Move (Replace("%2", sMessage, sHome))   to sMessage
78922>>>>>>>      Send Info_Box sMessage (_T("Problem", 1593))
78923>>>>>>>    End
78923>>>>>>>>
78923>>>>>>>    Set_Directory sHome
78924>>>>>>>  End
78924>>>>>>>>
78924>>>>>>>End_Procedure
78925>>>>>Object oEditorProperties Is a cEditorProperties
78927>>>>>    Move Self to ghoEditorProperties
78928>>>>>    Set piLoadSaveMode to Ini_Global
78929>>>>>    Set psSourceFile to "ScintillaEdit.ini"
78930>>>>>End_Object
78931>>>>>
78931>>>>>Send LoadIni to ghoEditorProperties      // Loads the IniDate
78932>>>>>//Send Register_Color_Elements //of ghoEditorProperties
78932>>>Use THColorer.pkg
Including file: THColorer.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\THColorer.pkg)
78932>>>>>// THColorer.pkg
78932>>>>>// This is TheHammer 3.0 Code Colorer
78932>>>>>// by Sergey V. Natarov
78932>>>>>
78932>>>>>// *** COLORS ***
78932>>>>>// _WindowColr_ _LftMrgnClr_ _BookmarkCl_ _BookmarkBg_ _TextColorX_ _TextBackgr_ _NumberColr_ _NumberBkGr_ _KeywordsCl_ _KeywordsBg_ _OperatorCl_ _OperatorBg_ _ScopeKwClr_ _ScopeKwBkg_ _CommentClr_ _CommentBkg_ _StringColr_ _StringBkgr_ _TagTextClr_ _TagTextBkg_ _TagEntyClr_ _TagEntyBkg_ _TagElemClr_ _TagElemBkg_ _TagAttrClr_ _TagAttrBkg_ _LineNrColr_ _LineNrBkgr_ _HrDivLinCl_ _VrDivLinCl_ _HiLtLineCl_
78932>>>>>// 255255255000 192192192000 255255255255 255255255255 000000000000 255255255000 255000255000 255255255000 000000255000 255255255000 255000000000 255255255000 000000255000 255255255000 000128000000 255255255000 128128128000 255255255000 000128128000 255255255255 255000000000 255255255255 000000255000 255255255255 128000000000 255255255255 255255255000 128128128000 255255255255 192192192000 192192192000 000
78932>>>>>//      1            2             3           4             5           6             7            8            9           10            11          12            13          14           15           16            17          18           19          20            21            22           23         24            25           26           27           28          29            30          31
78932>>>>>
78932>>>>>// *** FONTS *** (PSFONTSTYLES)
78932>>>>>//      Nr       Sc Ct    TT En    At
78932>>>>>//   _  _  _  _  _  _  _  _  _  _  _  _
78932>>>>>// 000000000000000002000001000001000000000
78932>>>>>//   _     -  -        -        -     -
78932>>>>>//   Tx    Kw Op       St       El    Ln
78932>>>>>//   1  2  3  4  5  6  7  8  9 10 11 12
78932>>>>>//          1         2         3
78932>>>>>
78932>>>>>
78932>>>>>// Normal           = 0
78932>>>>>// Bold             = 1
78932>>>>>// Italics          = 2
78932>>>>>// Bold + Italics   = 3
78932>>>>>// Underline        = 4
78932>>>>>// B+U              = 5
78932>>>>>// I+U              = 6
78932>>>>>// B+I+U            = 7
78932>>>>>
78932>>>>>Use cRichEdit.pkg
78932>>>>>Use THColorer.h
78932>>>>>
78932>>>>>Procedure Add_Color_Element Integer iIndex String sName Integer iFront Integer iBack Integer iFont Integer iStyle Integer iCM
78935>>>>>    // iIndex = Element Index
78935>>>>>    // Name of the Element
78935>>>>>    Move sName  to gtColorer[iIndex].sName
78936>>>>>    // Front Color OffSet *at the color line (if any)
78936>>>>>    Move iFront to gtColorer[iIndex].iForeOff
78937>>>>>    // Background Color OffSet *at the color line (if any)
78937>>>>>    Move iBack  to gtColorer[iIndex].iBackOff
78938>>>>>    // Font attributes allowed
78938>>>>>    Move iFont  to gtColorer[iIndex].iFont
78939>>>>>    // Font Style
78939>>>>>    Move iStyle to gtColorer[iIndex].iStyle
78940>>>>>    // CodeMax Support
78940>>>>>    Move iCM    to gtColorer[iIndex].iCM
78941>>>>>End_Procedure
78942>>>>>
78942>>>>>Function RGBColorFromString String sColorStr Returns Integer
78945>>>>>    Integer iRed iGreen iBlue
78945>>>>>    If (Length(sColorStr)<>12) Begin
78947>>>>>        Function_Return 0
78948>>>>>    End
78948>>>>>>
78948>>>>>    If (sColorStr="255255255255") Begin
78950>>>>>        Function_Return -1 // Default color
78951>>>>>    End
78951>>>>>>
78951>>>>>    // 1  4  7
78951>>>>>    // RRRGGGBBBAAA
78951>>>>>    Move (Mid(sColorStr, 3, 1)) to iRed
78952>>>>>    Move (Mid(sColorStr, 3, 4)) to iGreen
78953>>>>>    Move (Mid(sColorStr, 3, 7)) to iBlue
78954>>>>>    Function_Return (RGB(iRed, iGreen, iBlue))
78955>>>>>End_Function
78956>>>>>
78956>>>>>Function RGBStringFromRGB String iRed String iGreen String iBlue Returns String
78959>>>>>    String sColorStr
78959>>>>>    Move (sColorStr+Right(("000"+iRed), 3))   to sColorStr
78960>>>>>    Move (sColorStr+Right(("000"+iGreen), 3)) to sColorStr
78961>>>>>    Move (sColorStr+Right(("000"+iBlue), 3))  to sColorStr
78962>>>>>    Move (sColorStr+"000") to sColorStr
78963>>>>>    // Returns string as RRRGGGBBBAAA (128128128000)
78963>>>>>    Function_Return sColorStr
78964>>>>>End_Function
78965>>>>>
78965>>>>>Procedure SetColorerCurrentStyles String sColors String sFontStyle
78968>>>>>    Integer iItem iItems iColor iFont
78968>>>>>    String  sColorStr sFontStr
78968>>>>>    //
78968>>>>>    If (sColors="") ;        Get psColors        of ghoEditorProperties to sColors
78971>>>>>    If (sFontStyle="") ;        Get psFontStyles    of ghoEditorProperties to sFontStyle
78974>>>>>    //
78974>>>>>    Move (SizeOfArray(gtColorer)) to iItems
78975>>>>>    For iItem from 0 to (iItems-1)
78981>>>>>>
78981>>>>>        If (gtColorer[iItem].iForeOff) Begin
78983>>>>>            Move (Mid(sColors, 12, ((gtColorer[iItem].iForeOff-1)*12)+1)) to sColorStr
78984>>>>>            Get RGBColorFromString sColorStr to iColor
78985>>>>>            Move iColor to gtColorer[iItem].iForeC
78986>>>>>        End
78986>>>>>>
78986>>>>>        If (gtColorer[iItem].iBackOff) Begin
78988>>>>>            Move (Mid(sColors, 12, ((gtColorer[iItem].iBackOff-1)*12)+1)) to sColorStr
78989>>>>>            Get RGBColorFromString sColorStr to iColor
78990>>>>>            Move iColor to gtColorer[iItem].iBackC
78991>>>>>        End
78991>>>>>>
78991>>>>>        If (gtColorer[iItem].iFont) Begin
78993>>>>>            Move (Mid(sFontStyle, 3, ((gtColorer[iItem].iStyle-1)*3)+1)) to sFontStr
78994>>>>>            Move sFontStr to iFont
78995>>>>>            Move ((iFont iand THFS_BOLD     )<>0)   to gtColorer[iItem].iBold
78996>>>>>            Move ((iFont iand THFS_ITALICS  )<>0)   to gtColorer[iItem].iItalics
78997>>>>>            Move ((iFont iand THFS_UNDERLINE)<>0)   to gtColorer[iItem].iUnderline
78998>>>>>        End
78998>>>>>>
78998>>>>>    Loop
78999>>>>>>
78999>>>>>End_Procedure
79000>>>>>
79000>>>>>Procedure Register_Color_Elements
79003>>>>>    tColorer[] ltColorer
79003>>>>>    tColorer[] ltColorer
79004>>>>>    Move ltColorer to gtColorer
79005>>>>>    //                      Index               Name                         Tran   Fr  Bk  Fnt  Stl  CM
79005>>>>>    Send Add_Color_Element  EC_WINDOW           (_T("Window"               , 1063))  1   0   0    0   1
79006>>>>>    Send Add_Color_Element  EC_LEFTMARGIN       (_T("Left Margin"          , 1064))  2   0   0    0   1
79007>>>>>    Send Add_Color_Element  EC_BOOKMARK         (_T("Bookmarks"            , 1065))  3   4   0    0   1
79008>>>>>    Send Add_Color_Element  EC_TEXT             (_T("Text"                 , 1066))  5   6   1    1   1
79009>>>>>    Send Add_Color_Element  EC_NUMBERS          (_T("Numbers"              , 1067))  7   8   1    2   1
79010>>>>>    Send Add_Color_Element  EC_KEYWORDS         (_T("Keywords"             , 1068))  9  10   1    3   1
79011>>>>>    Send Add_Color_Element  EC_OPERATORS        (_T("Operators"            , 1069)) 11  12   1    4   1
79012>>>>>    Send Add_Color_Element  EC_SCOPEKWORDS      (_T("Scope Keywords"       , 1070)) 13  14   1    5   1
79013>>>>>    Send Add_Color_Element  EC_COMMENTS         (_T("Comments"             , 1071)) 15  16   1    6   1
79014>>>>>    Send Add_Color_Element  EC_STRINGS          (_T("String"               , 1072)) 17  18   1    7   1
79015>>>>>    Send Add_Color_Element  EC_TAGTEXT          (_T("Tag Text"             , 1073)) 19  20   1    8   1
79016>>>>>    Send Add_Color_Element  EC_TAGENTITIES      (_T("Tag Entities"         , 1074)) 21  22   1    9   1
79017>>>>>    Send Add_Color_Element  EC_TAGELEMENT       (_T("Tag Element Names"    , 1075)) 23  24   1   10   1
79018>>>>>    Send Add_Color_Element  EC_TAGATTRIBUTE     (_T("Tag Attributes"       , 1076)) 25  26   1   11   1
79019>>>>>    Send Add_Color_Element  EC_LINENUMBERS      (_T("Line Numbers"         , 1077)) 27  28   1   12   1
79020>>>>>    Send Add_Color_Element  EC_HDIVLINES        (_T("Horz Divider Lines"   , 1078)) 29   0   0    0   1
79021>>>>>    Send Add_Color_Element  EC_VDIVLINES        (_T("Vert Divider Lines"   , 1079)) 30   0   0    0   1
79022>>>>>    Send Add_Color_Element  EC_HLIGHTEDLINE     (_T("Highlighted Line"     , 1080)) 31   0   0    0   1
79023>>>>>    // Scintilla extras (Not supported by CodeMax, see CM column)
79023>>>>>    Send Add_Color_Element  EC_STRINGTYPING     (_T("String Typing"        , 1081)) 32  33   1   13   0
79024>>>>>    Send Add_Color_Element  EC_BRACEHLIGHT      (_T("Brace Highlight"      , 1082)) 34  35   1   14   0
79025>>>>>    Send Add_Color_Element  EC_UNMATCHEDBRACE   (_T("Unmatched Brace"      , 1083)) 36  37   1   15   0
79026>>>>>    Send Add_Color_Element  EC_METATAGS         (_T("Meta Tags"            , 1084)) 38  39   1   16   0
79027>>>>>    Send Add_Color_Element  EC_SELECTION        (_T("Selection"            , 1085)) 40   0   0    0   0
79028>>>>>    Send Add_Color_Element  EC_PREPROCESSOR     (_T("Pre-processor (Macro)", 1086)) 41  42   1   17   0
79029>>>>>    // Load current options
79029>>>>>    Send SetColorerCurrentStyles "" ""
79030>>>>>End_Procedure
79031>>>>>Send Register_Color_Elements
79032>>>>>
79032>>>>>Function CurrentColors Returns String
79035>>>>>    String[SC_COLORS_STRSIZE] sNewColors
79036>>>>>    Integer iElement iElements
79036>>>>>    String  sColorStr sColors
79036>>>>>    Integer iClr
79036>>>>>    Move (SizeOfArray(gtColorer)) to iElements
79037>>>>>    For iElement from 0 to (iElements-1)
79043>>>>>>
79043>>>>>        If (gtColorer[iElement].iForeOff) Begin
79045>>>>>            Move gtColorer[iElement].iForeC to iClr
79046>>>>>            If (iClr=-1) Begin
79048>>>>>                Move "255255255255" to sColorStr
79049>>>>>            End
79049>>>>>>
79049>>>>>            Else Begin
79050>>>>>                Get RGBStringFromRGB (R_From_RGB(iClr)) (G_From_RGB(iClr)) (B_From_RGB(iClr)) to sColorStr
79051>>>>>            End
79051>>>>>>
79051>>>>>            Move sColorStr to sNewColors[gtColorer[iElement].iForeOff-1]
79052>>>>>        End
79052>>>>>>
79052>>>>>        If (gtColorer[iElement].iBackOff) Begin
79054>>>>>            Move gtColorer[iElement].iBackC to iClr
79055>>>>>            If (iClr=-1) Begin
79057>>>>>                Move "255255255255" to sColorStr
79058>>>>>            End
79058>>>>>>
79058>>>>>            Else Begin
79059>>>>>                Get RGBStringFromRGB (R_From_RGB(iClr)) (G_From_RGB(iClr)) (B_From_RGB(iClr)) to sColorStr
79060>>>>>            End
79060>>>>>>
79060>>>>>            Move sColorStr to sNewColors[gtColorer[iElement].iBackOff-1]
79061>>>>>        End
79061>>>>>>
79061>>>>>    Loop
79062>>>>>>
79062>>>>>    //
79062>>>>>    Move "" to sColors
79063>>>>>    For iElement from 0 to (SizeOfArray(sNewColors)-1)
79069>>>>>>
79069>>>>>        Move (sColors + sNewColors[iElement]) to sColors
79070>>>>>    Loop
79071>>>>>>
79071>>>>>    Move (sColors+"000") to sColors
79072>>>>>    Function_Return sColors
79073>>>>>End_Function
79074>>>>>
79074>>>>>Function CurrentFontStyles Returns String
79077>>>>>    String[17] sFontStyle
79078>>>>>    Integer iElement iElements
79078>>>>>    String  sFontStr sFontStyles
79078>>>>>    Integer iFont
79078>>>>>    Move (SizeOfArray(gtColorer)) to iElements
79079>>>>>    For iElement from 0 to (iElements-1)
79085>>>>>>
79085>>>>>        If (gtColorer[iElement].iFont) Begin
79087>>>>>            Move (gtColorer[iElement].iBold+gtColorer[iElement].iItalics+gtColorer[iElement].iUnderline) to sFontStr
79088>>>>>            Move (Right('000'+sFontStr, 3)) to sFontStr
79089>>>>>            Move sFontStr to sFontStyle[gtColorer[iElement].iStyle-1]
79090>>>>>        End
79090>>>>>>
79090>>>>>    Loop
79091>>>>>>
79091>>>>>    //
79091>>>>>    Move "" to sFontStyles
79092>>>>>    For iElement from 0 to (SizeOfArray(sFontStyle)-1)
79098>>>>>>
79098>>>>>        Move (sFontStyles + sFontStyle[iElement]) to sFontStyles
79099>>>>>    Loop
79100>>>>>>
79100>>>>>    Move (sFontStyles+"000") to sFontStyles
79101>>>>>    Function_Return sFontStyles
79102>>>>>End_Function
79103>>>>>
79103>>>>>Class cEditorPreview is a cRichEdit
79104>>>>>    Procedure Construct_Object
79106>>>>>        Forward Send Construct_Object
79108>>>>>        Set Border_Style to Border_None
79109>>>>>        Set psTypeFace   to "Courier New"
79110>>>>>        Set piFontSize      to (10*20)
79111>>>>>        Set Read_Only_State to True
79112>>>>>    End_Procedure
79113>>>>>    
79113>>>>>    Procedure ChangeFontStyle String sFont Integer iFontSize
79115>>>>>        Send HideSelection True
79116>>>>>        Send Select_All    
79117>>>>>        Set psTypeFace      to sFont
79118>>>>>        Set piFontSize      to (iFontSize*20)
79119>>>>>        Send SetSel        0 0 // remove selection
79120>>>>>        Send HideSelection False
79121>>>>>    End_Procedure
79122>>>>>    
79122>>>>>    Procedure AddElement Integer iElement String sElement
79124>>>>>        Set TextColor       to  gtColorer[iElement].iForeC
79125>>>>>        Set TextBackColor   to  gtColorer[iElement].iBackC
79126>>>>>        Set pbBold          to  gtColorer[iElement].iBold
79127>>>>>        Set pbItalics       to  gtColorer[iElement].iItalics
79128>>>>>        Set pbUnderline     to  gtColorer[iElement].iUnderline
79129>>>>>        Send AppendText         sElement
79130>>>>>    End_Procedure
79131>>>>>    Procedure AddComment String sComment
79133>>>>>        Send AddElement EC_COMMENTS sComment
79134>>>>>    End_Procedure
79135>>>>>    Procedure AddScopeKeyword String sKeyword
79137>>>>>        Send AddElement EC_SCOPEKWORDS sKeyword
79138>>>>>    End_Procedure
79139>>>>>    Procedure AddKeyword String sKeyword
79141>>>>>        Send AddElement EC_KEYWORDS sKeyword
79142>>>>>    End_Procedure
79143>>>>>    Procedure AddText String sText
79145>>>>>        Send AddElement EC_TEXT sText
79146>>>>>    End_Procedure
79147>>>>>    Procedure AddNumber String sNumber
79149>>>>>        Send AddElement EC_NUMBERS sNumber
79150>>>>>    End_Procedure
79151>>>>>    Procedure AddOperator String sOperator
79153>>>>>        Send AddElement EC_OPERATORS sOperator
79154>>>>>    End_Procedure
79155>>>>>    Procedure AddString String sString
79157>>>>>        Send AddElement EC_STRINGS sString
79158>>>>>    End_Procedure
79159>>>>>    Procedure AddStringTyping String sString
79161>>>>>        Send AddElement EC_STRINGTYPING sString
79162>>>>>    End_Procedure
79163>>>>>    Procedure AddBraceHLight String sBraces
79165>>>>>        Send AddElement EC_BRACEHLIGHT sBraces
79166>>>>>    End_Procedure
79167>>>>>    Procedure AddUnmatchedBrace String sBraces
79169>>>>>        Send AddElement EC_UNMATCHEDBRACE sBraces
79170>>>>>    End_Procedure
79171>>>>>    Procedure AddPreProcessor String sMacro
79173>>>>>        Send AddElement EC_PREPROCESSOR sMacro
79174>>>>>    End_Procedure
79175>>>>>    Procedure AddSpacing String sSpaces
79177>>>>>        Set TextColor       to  gtColorer[EC_TEXT].iForeC
79178>>>>>        Set TextBackColor   to  gtColorer[EC_TEXT].iBackC
79179>>>>>        Set pbBold          to  0
79180>>>>>        Set pbItalics       to  0
79181>>>>>        Set pbUnderline     to  0
79182>>>>>        Send AppendText         sSpaces
79183>>>>>    End_Procedure
79184>>>>>    Procedure AddMetaTag String sMeta
79186>>>>>        Send AddElement EC_METATAGS sMeta
79187>>>>>    End_Procedure
79188>>>>>End_Class
79189>>>>>
79189>>>Use THDialog.pkg
Including file: THDialog.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\THDialog.pkg)
79189>>>>>// THDialog.pkg
79189>>>>>// By Sergey V. Natarov, Wil van Antwerpen
79189>>>>>//
79189>>>>>Use Windows.pkg
79189>>>>>Use Dfspnfrm.pkg
79189>>>>>Use Colr_dlg.pkg
79189>>>>>
79189>>>>>Define FindUp   for 0
79189>>>>>Define FindDown for 1
79189>>>>>
79189>>>>>Define ReplaceSelection for 0
79189>>>>>Define ReplaceBuffer    for 1
79189>>>>>
79189>>>>>// *** Find & Replace
79189>>>>>Struct tFindReplaceOptions
79189>>>>>  String  sSearchText
79189>>>>>  String  sReplaceText // +R
79189>>>>>  Boolean bWordMatch
79189>>>>>  Boolean bMatchCase
79189>>>>>  Boolean bRegExp
79189>>>>>  Boolean bPreserveCase // +R
79189>>>>>  Integer eFindOptions  // *R = eDirection -> eFindOptions
79189>>>>>  Boolean bDocumentStart
79189>>>>>  Boolean bStartFind
79189>>>>>  Boolean bMarkAll
79189>>>>>  Boolean bReplace      // +R
79189>>>>>  Boolean bReplaceAll   // +R
79189>>>>>  Boolean bCancel
79189>>>>>End_Struct
79189>>>>>
79189>>>>>Class cFindCheckBox is a CheckBox
79190>>>>>
79190>>>>>  Procedure doToggle
79192>>>>>    Boolean bState
79192>>>>>
79192>>>>>    Send DispatchHotkey  // no ringing bell on pressing your shortcut key please, that drives me nuts
79193>>>>>    Send Activate
79194>>>>>    Get Checked_State to bState
79195>>>>>    Set Checked_State to (not(bState))
79196>>>>>  End_Procedure
79197>>>>>End_Class
79198>>>>>
79198>>>>>Class cFindForm is a Form
79199>>>>>  Procedure Activate returns integer
79201>>>>>    Integer iRetVal
79201>>>>>    Send DispatchHotkey  // no ringing bell on pressing your shortcut key please, that drives me nuts
79202>>>>>    forward Get msg_activate to iRetVal
79204>>>>>    Procedure_Return iRetVal
79205>>>>>  End_Procedure
79206>>>>>End_Class
79207>>>>>
79207>>>>>Class cFindComboForm Is a ComboForm
79208>>>>>  Procedure Construct_Object
79210>>>>>    Forward Send Construct_Object
79212>>>>>    Set Combo_Sort_State To False
79213>>>>>    Property String[] pSearchStrings
79214>>>>>  End_Procedure
79215>>>>>
79215>>>>>  Procedure Activate returns integer
79217>>>>>    Integer iRetVal
79217>>>>>    Send DispatchHotkey  // no ringing bell on pressing your shortcut key please, that drives me nuts
79218>>>>>    forward Get msg_activate to iRetVal
79220>>>>>    Procedure_Return iRetVal
79221>>>>>  End_Procedure
79222>>>>>
79222>>>>>  Procedure Combo_Fill_List
79224>>>>>    Integer  iItem
79224>>>>>    Integer  iCount
79224>>>>>    String[] SearchStrings
79225>>>>>
79225>>>>>    Get pSearchStrings To SearchStrings
79226>>>>>    Move (SizeOfArray(SearchStrings)) To iCount
79227>>>>>    If (iCount>0) Begin
79229>>>>>      Send Combo_Delete_Data
79230>>>>>      For iItem From 0 To (iCount-1)
79236>>>>>>
79236>>>>>         Send Combo_Add_Item SearchStrings[iItem]
79237>>>>>      Loop
79238>>>>>>
79238>>>>>      Set Value To SearchStrings[0]
79239>>>>>    End
79239>>>>>>
79239>>>>>  End_Procedure
79240>>>>>
79240>>>>>  Procedure AddSearchString String sValue
79242>>>>>    Integer  iIndex
79242>>>>>    String[] SearchStrings
79243>>>>>
79243>>>>>    If (sValue<>"") Begin
79245>>>>>      Get pSearchStrings To SearchStrings
79246>>>>>      Move (SearchArray(sValue,SearchStrings,Desktop,(RefFunc(DFSTRICMP)))) To iIndex
79247>>>>>      If (iIndex>-1) Begin
79249>>>>>        Move (RemoveFromArray(SearchStrings,iIndex)) To SearchStrings // it will be moved up to the first position
79250>>>>>      End
79250>>>>>>
79250>>>>>      Move (InsertInArray(SearchStrings,0,sValue)) To SearchStrings
79251>>>>>      Set pSearchStrings To SearchStrings
79252>>>>>    End
79252>>>>>>
79252>>>>>  End_Procedure
79253>>>>>
79253>>>>>  Procedure Set SearchValue String sValue
79255>>>>>
79255>>>>>    If (sValue<>"") Begin
79257>>>>>      Send AddSearchString sValue
79258>>>>>      Send Combo_Fill_List
79259>>>>>    End
79259>>>>>>
79259>>>>>  End_Procedure
79260>>>>>
79260>>>>>End_Class
79261>>>>>
79261>>>>>
79261>>>>>// *** TH Parameters
79261>>>>>
79261>>>>>Register_Procedure  Request_SaveAllEntries
79261>>>>>Register_Procedure  NotifyChange
79261>>>>>Register_Object     oStatusHelp
79261>>>>>Register_Object     oOpenDialog
79261>>>>>
79261>>>>>Class cNotifierCheckBox is a CheckBox
79262>>>>>    Procedure Construct_Object
79264>>>>>        Forward Send Construct_Object
79266>>>>>        On_Key key_F2 Send Request_SaveAllEntries
79267>>>>>        On_Key kCancel Send Close_Panel
79268>>>>>    End_Procedure
79269>>>>>    Procedure onChange
79271>>>>>        Delegate Send NotifyChange
79273>>>>>    End_Procedure
79274>>>>>    Procedure Set Status_Help String sHelp
79276>>>>>        String sToolTipText
79276>>>>>        Forward Set Status_Help to sHelp
79278>>>>>        Get psToolTip to sToolTipText
79279>>>>>        If (sToolTipText = "") Begin
79281>>>>>            Set psToolTip to sHelp
79282>>>>>        End
79282>>>>>>
79282>>>>>    End_Procedure
79283>>>>>End_Class
79284>>>>>
79284>>>>>Class cNotifierForm is a Form
79285>>>>>    Procedure Construct_Object
79287>>>>>        Forward Send Construct_Object
79289>>>>>        Set Label_Col_Offset to 2
79290>>>>>        Set Label_Justification_Mode to JMode_Right
79291>>>>>        On_Key key_F2 Send Request_SaveAllEntries
79292>>>>>        On_Key kCancel Send Close_Panel
79293>>>>>    End_Procedure
79294>>>>>    Procedure onChange
79296>>>>>        Delegate Send NotifyChange
79298>>>>>    End_Procedure
79299>>>>>    Procedure Set Status_Help String sHelp
79301>>>>>        String sToolTipText
79301>>>>>        Forward Set Status_Help to sHelp
79303>>>>>        Get psToolTip to sToolTipText
79304>>>>>        If (sToolTipText = "") Begin
79306>>>>>            Set psToolTip to sHelp
79307>>>>>        End
79307>>>>>>
79307>>>>>    End_Procedure
79308>>>>>End_Class
79309>>>>>
79309>>>>>Class cNotifierSpinForm is a Spinform
79310>>>>>    Procedure Construct_Object
79312>>>>>        Forward Send Construct_Object
79314>>>>>        Set Label_Col_Offset to 2
79315>>>>>        Set Label_Justification_Mode to JMode_Right
79316>>>>>        On_Key key_F2 Send Request_SaveAllEntries
79317>>>>>        On_Key kCancel Send Close_Panel
79318>>>>>    End_Procedure
79319>>>>>    Procedure onChange
79321>>>>>        Delegate Send NotifyChange
79323>>>>>    End_Procedure
79324>>>>>    Procedure Set Status_Help String sHelp
79326>>>>>        String sToolTipText
79326>>>>>        Forward Set Status_Help to sHelp
79328>>>>>        Get psToolTip to sToolTipText
79329>>>>>        If (sToolTipText = "") Begin
79331>>>>>            Set psToolTip to sHelp
79332>>>>>        End
79332>>>>>>
79332>>>>>    End_Procedure
79333>>>>>End_Class
79334>>>>>
79334>>>>>Class cNotifierComboForm is a ComboForm
79335>>>>>    Procedure Construct_Object
79337>>>>>        Forward Send Construct_Object
79339>>>>>        Set Label_Col_Offset to 2
79340>>>>>        Set Label_Justification_Mode to JMode_Right
79341>>>>>        On_Key key_F2 Send Request_SaveAllEntries
79342>>>>>        On_Key kCancel Send Close_Panel
79343>>>>>    End_Procedure
79344>>>>>    Procedure onChange
79346>>>>>        Delegate Send NotifyChange
79348>>>>>    End_Procedure
79349>>>>>    Procedure Set Status_Help String sHelp
79351>>>>>        String sToolTipText
79351>>>>>        Forward Set Status_Help to sHelp
79353>>>>>        Get psToolTip to sToolTipText
79354>>>>>        If (sToolTipText = "") Begin
79356>>>>>            Set psToolTip to sHelp
79357>>>>>        End
79357>>>>>>
79357>>>>>    End_Procedure
79358>>>>>End_Class
79359>>>>>
79359>>>>>Class cColorPicker is a Container3D
79360>>>>>    Procedure Construct_Object
79362>>>>>        Forward Send Construct_Object
79364>>>>>        Set Size to 10 90
79365>>>>>        Set Location to 9 7
79366>>>>>        Set Border_Style to Border_Normal
79367>>>>>        Set Color to clWhite
79368>>>>>    End_Procedure
79369>>>>>    Procedure Mouse_Down Integer i1
79371>>>>>        Handle  hoDlg
79371>>>>>        Integer bOk iColor
79371>>>>>        Get Color to iColor
79372>>>>>        Object oColorDlg is a ColorDialog
79374>>>>>            Set SelectedColor   to iColor
79375>>>>>            Set Custom_Color 0  to iColor
79376>>>>>            Get Object_Id       to hoDlg
79377>>>>>        End_Object
79378>>>>>        Get Show_Dialog of hoDlg to bOK
79379>>>>>        If bOK Begin
79381>>>>>            Get SelectedColor of hoDlg to iColor
79382>>>>>            Set Color to iColor
79383>>>>>            Delegate Send OnColorChange
79385>>>>>        End
79385>>>>>>
79385>>>>>        Send Destroy to hoDlg
79386>>>>>        Forward Send Mouse_Down i1
79388>>>>>    End_Procedure
79389>>>>>End_Class
79390>>>>>
79390>>>>>Class cColorBox is a Container3d
79391>>>>>    Procedure Construct_Object
79393>>>>>        Forward Send Construct_Object
79395>>>>>        Property Integer piColorerIndex
79396>>>>>        Set Size to 22 105
79397>>>>>        Set Border_Style to Border_Normal
79398>>>>>        Set Color to clWhite
79399>>>>>        Object oLabel is a TextBox
79401>>>>>            Set Auto_Size_State to False
79402>>>>>            Set Size to 15 106
79403>>>>>            Set Location to 0 0
79404>>>>>            Set Label to "Color"
79405>>>>>            Set Justification_Mode to JMode_Center
79406>>>>>            Set Transparent_State to True
79407>>>>>        End_Object
79408>>>>>        Object oColorPicker is a cColorPicker
79410>>>>>        End_Object
79411>>>>>    End_Procedure
79412>>>>>    Procedure OnColorChange
79414>>>>>    End_Procedure
79415>>>>>    Procedure Set Label String sLabel
79417>>>>>        Set Label of (oLabel(Self)) to sLabel
79418>>>>>    End_Procedure
79419>>>>>    Function Label Returns String
79421>>>>>        Function_Return (Label(oLabel(Self)))
79422>>>>>    End_Function
79423>>>>>    Procedure Set SlectedColor Integer iRGBColor
79425>>>>>        If (iRGBColor=-1) Begin
79427>>>>>            Move clWhite to iRGBColor
79428>>>>>        End
79428>>>>>>
79428>>>>>        Set Color of (oColorPicker(Self)) to iRGBColor
79429>>>>>    End_Procedure
79430>>>>>    Function SelectedColor Returns Integer
79432>>>>>        Function_Return (Color(oColorPicker(Self)))
79433>>>>>    End_Function
79434>>>>>End_Class
79435>>>Use Font_dlg.pkg
79435>>>Use cImageList32.pkg
79435>>>Use cTextEdit.pkg
79435>>>Use cSCNotifierCheckBox.pkg
Including file: cSCNotifierCheckBox.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cSCNotifierCheckBox.pkg)
79435>>>>>Use cRDCCheckbox.pkg
Including file: cRDCCheckbox.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCCheckbox.pkg)
79435>>>>>>>//****************************************************************************
79435>>>>>>>// $Module type: Package
79435>>>>>>>// $Module name: cRDCCheckbox.pkg
79435>>>>>>>//
79435>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
79435>>>>>>>// Copyright (c) 2016 RDC Tools International
79435>>>>>>>// E-mail      : support@rdctools.com
79435>>>>>>>// Web-site    : http://www.rdctools.com
79435>>>>>>>//
79435>>>>>>>// Created     : 2016-01-05 @ 19:04 (Military date format - Year-Month-Day)
79435>>>>>>>//
79435>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
79435>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
79435>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
79435>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
79435>>>>>>>// in the help folder for more details.
79435>>>>>>>//
79435>>>>>>>//****************************************************************************
79435>>>>>>>Use Windows.pkg
79435>>>>>>>
79435>>>>>>>// Used by the "Page" message below to show
79435>>>>>>>// a rectangle around ComboForm and Checkbox objects.
79435>>>>>>>Define WM_CHANGEUISTATE For |CI$0127
79435>>>>>>>Define WM_UPDATEUISTATE For |CI$0128
79435>>>>>>>Define WM_QUERYUISTATE  For |CI$0129
79435>>>>>>>Define UIS_SET          For 1
79435>>>>>>>Define UIS_CLEAR        For 2
79435>>>>>>>Define UIS_INITIALIZE   For 3
79435>>>>>>>Define UISF_HIDEFOCUS   For |CI$1
79435>>>>>>>Define UISF_HIDEACCEL   For |CI$2
79435>>>>>>>Define UISF_ACTIVE      For |CI$4
79435>>>>>>>
79435>>>>>>>Register_Function private.phoCheckBox Returns Handle
79435>>>>>>>
79435>>>>>>>Class _CheckBoxTextBox is a TextBox
79436>>>>>>>
79436>>>>>>>    Procedure Mouse_Down integer iWindowNumber integer iPosition
79438>>>>>>>        Handle hoParent
79438>>>>>>>        Get private.phoCheckBox to hoParent
79439>>>>>>>        Forward Send Mouse_Down iWindowNumber iPosition
79441>>>>>>>        If (hoParent <> 0) Begin
79443>>>>>>>            Send DoToggle of hoParent
79444>>>>>>>        End
79444>>>>>>>>
79444>>>>>>>    End_Procedure
79445>>>>>>>End_Class
79446>>>>>>>
79446>>>>>>>Register_Procedure OnChangeEvent
79446>>>>>>>Register_Procedure Set private.Checked_State
79446>>>>>>>Register_Function private.Checked_State Returns Boolean
79446>>>>>>>Class _NewCheckBox is a CheckBox
79447>>>>>>>
79447>>>>>>>    Procedure DoToggle
79449>>>>>>>        Boolean bChecked
79449>>>>>>>        Get Checked_State to bChecked
79450>>>>>>>        Set Checked_State to (not(bChecked))
79451>>>>>>>    End_Procedure
79452>>>>>>>
79452>>>>>>>    Procedure OnChange
79454>>>>>>>        Boolean bState
79454>>>>>>>        Handle hoCheckBox
79454>>>>>>>
79454>>>>>>>        Forward Send OnChange
79456>>>>>>>        Get private.phoCheckBox to hoCheckBox
79457>>>>>>>        Get Checked_State to bState
79458>>>>>>>        Set private.Checked_State to bState
79459>>>>>>>        If (Desktop <> Self and hoCheckBox <> 0) Begin
79461>>>>>>>            Send OnChangeEvent
79462>>>>>>>        End
79462>>>>>>>>
79462>>>>>>>    End_Procedure
79463>>>>>>>
79463>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
79463>>>>>>>    // The bug being that the focus rectangle doesn't show.
79463>>>>>>>    Procedure Page Integer iPageObject
79465>>>>>>>        Handle hWnd
79465>>>>>>>        Integer iRet iState
79465>>>>>>>
79465>>>>>>>        Forward Send Page iPageObject
79467>>>>>>>
79467>>>>>>>        If (iPageObject) Begin
79469>>>>>>>            Get Window_Handle to hWnd
79470>>>>>>>            If (hWnd) Begin
79472>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
79473>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
79475>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
79476>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
79477>>>>>>>                End
79477>>>>>>>>
79477>>>>>>>            End
79477>>>>>>>>
79477>>>>>>>        End
79477>>>>>>>>
79477>>>>>>>    End_Procedure
79478>>>>>>>
79478>>>>>>>End_Class
79479>>>>>>>
79479>>>>>>>// Intermediate class - don't use.
79479>>>>>>>Class _cCheckBoxContainer is a Container
79480>>>>>>>
79480>>>>>>>    Register_Object oInfo_tb
79480>>>>>>>
79480>>>>>>>    Procedure Construct_Object
79482>>>>>>>        Forward Send Construct_Object
79484>>>>>>>
79484>>>>>>>        Property String private.psImage
79485>>>>>>>        Property String private.psLabel
79486>>>>>>>        Property String private.psToolTip
79487>>>>>>>        Property Boolean private.Checked_State
79488>>>>>>>        Property Boolean private.Auto_Size_State True
79489>>>>>>>        Property Integer private.iHeight
79490>>>>>>>        Property Integer private.iWidth
79491>>>>>>>        Property Integer private.iRowPos
79492>>>>>>>        Property Integer private.iColPos
79493>>>>>>>        Property Handle private.phoCheckBox
79494>>>>>>>        Property Integer private.peAnchors
79495>>>>>>>
79495>>>>>>>        Property Boolean pbCreateInfoItem True
79496>>>>>>>
79496>>>>>>>        Set Border_Style to Border_None
79497>>>>>>>    End_Procedure
79498>>>>>>>
79498>>>>>>>    Procedure End_Construct_Object
79500>>>>>>>        Handle hoCheckBox
79500>>>>>>>        Integer iRowPos iColPos iSize
79500>>>>>>>        String sLabel sToolTip
79500>>>>>>>        Boolean bCreateInfoItem
79500>>>>>>>
79500>>>>>>>        Forward Send End_Construct_Object
79502>>>>>>>
79502>>>>>>>        Get pbCreateInfoItem to bCreateInfoItem
79503>>>>>>>        Get CreateNamed (RefClass(_NewCheckBox)) "oRDCCheckboxChild" to hoCheckBox
79504>>>>>>>        Set private.phoCheckBox to hoCheckBox
79505>>>>>>>        Set Auto_Size_State of hoCheckBox to (private.Auto_Size_State(Self))
79506>>>>>>>        Get private.psLabel to sLabel
79507>>>>>>>        Set Label of hoCheckBox to sLabel
79508>>>>>>>        Send Autosize of hoCheckBox sLabel
79509>>>>>>>        Set Checked_State of hoCheckBox to (private.Checked_State(Self))
79510>>>>>>>        Get Size of hoCheckBox to iSize
79511>>>>>>>
79511>>>>>>>        Set Location of hoCheckBox to (private.iRowPos(Self)) (private.iColPos(Self))
79512>>>>>>>        Get private.iRowPos to iRowPos
79513>>>>>>>        Get private.iColPos to iColPos
79514>>>>>>>        Get private.psToolTip to sToolTip
79515>>>>>>>        Set Status_Help of hoCheckBox to sToolTip
79516>>>>>>>
79516>>>>>>>        If (bCreateInfoItem = True and sToolTip <> "") Begin
79518>>>>>>>            Object oInfo_tb is a TextBox
79520>>>>>>>                Set Size to 10 10
79521>>>>>>>                Set Location to iRowPos (Low(iSize) + iColPos)
79522>>>>>>>                Set psToolTip to sToolTip
79523>>>>>>>                Set Bitmap to "ActionAbout.bmp"
79524>>>>>>>            End_Object
79525>>>>>>>        End
79525>>>>>>>>
79525>>>>>>>        Else Begin
79526>>>>>>>            Set psToolTip of hoCheckBox to sToolTip
79527>>>>>>>        End
79527>>>>>>>>
79527>>>>>>>
79527>>>>>>>    End_Procedure
79528>>>>>>>
79528>>>>>>>    Procedure OnChangeEvent
79530>>>>>>>    End_Procedure
79531>>>>>>>
79531>>>>>>>    Procedure Set Location Integer iRowPos Integer iColPos
79533>>>>>>>        Forward Set Location to iRowPos iColPos
79535>>>>>>>        If (iRowPos <> 0 and iColPos <> 0) Begin
79537>>>>>>>            Set private.iRowPos to iRowPos
79538>>>>>>>            Set private.iColPos to iColPos
79539>>>>>>>        End
79539>>>>>>>>
79539>>>>>>>    End_Procedure
79540>>>>>>>
79540>>>>>>>    Procedure Set psImage String sImage
79542>>>>>>>        Set private.psImage to sImage
79543>>>>>>>    End_Procedure
79544>>>>>>>
79544>>>>>>>    Function psImage Returns String
79546>>>>>>>        Function_Return (private.psImage(Self))
79547>>>>>>>    End_Function
79548>>>>>>>
79548>>>>>>>    // We support both the "Set Label" & "Set psLabel" interface.
79548>>>>>>>    Procedure Set psLabel String sLabel
79550>>>>>>>        Set private.psLabel to sLabel
79551>>>>>>>    End_Procedure
79552>>>>>>>
79552>>>>>>>    Function psLabel Returns String
79554>>>>>>>        Function_Return (private.psLabel(Self))
79555>>>>>>>    End_Function
79556>>>>>>>
79556>>>>>>>    Procedure Set Label String sLabel
79558>>>>>>>        Set psLabel to sLabel
79559>>>>>>>    End_Procedure
79560>>>>>>>
79560>>>>>>>    Function Label Returns String
79562>>>>>>>        Function_Return (private.psLabel(Self))
79563>>>>>>>    End_Function
79564>>>>>>>
79564>>>>>>>    Procedure Set Checked_State Boolean bState
79566>>>>>>>        Handle hoCheckBox
79566>>>>>>>        Set private.Checked_State to bState
79567>>>>>>>        Get private.phoCheckBox to hoCheckBox
79568>>>>>>>        If (hoCheckBox <> 0) Begin
79570>>>>>>>            Set Checked_State of hoCheckBox to bState
79571>>>>>>>        End
79571>>>>>>>>
79571>>>>>>>    End_Procedure
79572>>>>>>>
79572>>>>>>>    Function Checked_State Returns Boolean
79574>>>>>>>        Function_Return (private.Checked_State(Self))
79575>>>>>>>    End_Function
79576>>>>>>>
79576>>>>>>>    Procedure Set Auto_Size_State Boolean bState
79578>>>>>>>        Set private.Auto_Size_State to bState
79579>>>>>>>    End_Procedure
79580>>>>>>>
79580>>>>>>>    Function Auto_Size_State Returns Boolean
79582>>>>>>>        Function_Return (private.Auto_Size_State(Self))
79583>>>>>>>    End_Function
79584>>>>>>>
79584>>>>>>>    Procedure Set peAnchors Integer eAnchorMode
79586>>>>>>>        Forward Set peAnchors to eAnchorMode
79588>>>>>>>        Set private.peAnchors to eAnchorMode
79589>>>>>>>    End_Procedure
79590>>>>>>>
79590>>>>>>>    Function peAnchors Returns Integer
79592>>>>>>>        Function_Return (private.peAnchors(Self))
79593>>>>>>>    End_Function
79594>>>>>>>    Procedure Set psToolTip String sToolTip
79596>>>>>>>        Set private.psToolTip to sToolTip
79597>>>>>>>    End_Procedure
79598>>>>>>>
79598>>>>>>>    Function psToolTip Returns String
79600>>>>>>>        Function_Return (private.psToolTip(Self))
79601>>>>>>>    End_Function
79602>>>>>>>
79602>>>>>>>End_Class
79603>>>>>>>
79603>>>>>>>Class cRDCCheckBox is a _cCheckBoxContainer
79604>>>>>>>    Procedure Construct_Object
79606>>>>>>>        Forward Send Construct_Object
79608>>>>>>>        On_Key kSwitch Send Switch_Next_Area
79609>>>>>>>    End_Procedure
79610>>>>>>>
79610>>>>>>>    Procedure Set Checked_State Boolean bState
79612>>>>>>>        Forward Set Checked_State to bState
79614>>>>>>>    End_Procedure
79615>>>>>>>
79615>>>>>>>    Function Checked_State Returns Boolean
79617>>>>>>>        Function_Return (private.Checked_State(Self))
79618>>>>>>>    End_Function
79619>>>>>>>
79619>>>>>>>    Procedure Set Label String sLabel
79621>>>>>>>        Set psLabel to sLabel
79622>>>>>>>    End_Procedure
79623>>>>>>>
79623>>>>>>>    Function Label Returns String
79625>>>>>>>        Function_Return (private.psLabel(Self))
79626>>>>>>>    End_Function
79627>>>>>>>
79627>>>>>>>    Procedure Set psToolTip String sToolTip
79629>>>>>>>        String sStatusHelp
79629>>>>>>>
79629>>>>>>>        Get Status_Help to sStatusHelp
79630>>>>>>>        If (sStatusHelp = "") Begin
79632>>>>>>>            Set Status_Help to sToolTip
79633>>>>>>>        End
79633>>>>>>>>
79633>>>>>>>
79633>>>>>>>        Forward Set psToolTip to sToolTip
79635>>>>>>>    End_Procedure
79636>>>>>>>
79636>>>>>>>End_Class
79637>>>>>
79637>>>>>Class cSCNotifierCheckBox is a cRDCCheckbox
79638>>>>>
79638>>>>>    Procedure Construct_Object
79640>>>>>        Forward Send Construct_Object
79642>>>>>
79642>>>>>        On_Key key_F2 Send Request_SaveAllEntries
79643>>>>>        On_Key kCancel Send Close_Panel
79644>>>>>
79644>>>>>    End_Procedure
79645>>>>>
79645>>>>>    Procedure OnChange
79647>>>>>        Delegate Send NotifyChange
79649>>>>>    End_Procedure
79650>>>>>
79650>>>>>End_Class
79651>>>Use cSCWsGrid.pkg
Including file: cSCWsGrid.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cSCWsGrid.pkg)
79651>>>>>Use Windows.pkg
79651>>>>>
79651>>>>>Register_Procedure mRemoveLine
79651>>>>>Register_Procedure mInsertLine
79651>>>>>
79651>>>>>// Language Definition
79651>>>>>Struct tSCLanguage
79651>>>>>    String   sName
79651>>>>>    Integer  iProcedural
79651>>>>>    Integer  iCaseSensitive
79651>>>>>    String   sLineComments
79651>>>>>    String   sStringDelimiter
79651>>>>>    String   sMultiLineCommentStart
79651>>>>>    String   sMultiLineCommentStop
79651>>>>>    String   sEscapeChar
79651>>>>>    String   sLineTerminationChar
79651>>>>>    String   sMetaStart
79651>>>>>    String   sMetaStop
79651>>>>>    String[] saScopeStart
79651>>>>>    String[] saScopeStop
79651>>>>>    String[] saKeywords
79651>>>>>    String[] saOperators
79651>>>>>    String[] saTags
79651>>>>>    String[] saEntities
79651>>>>>    String[] saAttributes
79651>>>>>End_Struct
79651>>>>>
79651>>>>>Class cSCWsGrid is a Grid
79652>>>>>    Procedure Construct_Object
79654>>>>>        Forward Send Construct_Object
79656>>>>>
79656>>>>>        Set Size to 115 233
79657>>>>>        Set Location to 11 7
79658>>>>>        //        Set CurrentCellColor     to (RGB(39,150,216))
79658>>>>>        //        Set CurrentCellTextColor to clWhite
79658>>>>>        //        Set CurrentRowColor      to (RGB(39,150,216))
79658>>>>>        //        Set CurrentRowTextColor  to clWhite
79658>>>>>        Set Resize_Column_State to False
79659>>>>>        Set Highlight_Row_State to True
79660>>>>>        Set GridLine_Mode to Grid_Visible_Horz
79661>>>>>        Set Select_Mode to No_Select
79662>>>>>
79662>>>>>        On_Key Key_Delete Send mRemoveLine
79663>>>>>        On_Key Key_Insert Send mInsertLine
79664>>>>>        On_Key Key_Enter  Send Next
79665>>>>>    End_Procedure
79666>>>>>
79666>>>>>    Procedure DoFillGrid
79668>>>>>    End_Procedure
79669>>>>>
79669>>>>>    Function Base_Row_Item Integer iItem Returns Integer
79671>>>>>        Function_Return (iItem - Mod(iItem, Low(Matrix_Size(Self))))
79672>>>>>    End_Function
79673>>>>>
79673>>>>>End_Class
79674>>>Use cRDCHeaderGroup.pkg
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
79674>>>>>//****************************************************************************
79674>>>>>// $Module type: Package
79674>>>>>// $Module name: cRDCHeaderGroup.pkg
79674>>>>>//
79674>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
79674>>>>>// Copyright (c) 2017 RDC Tools International
79674>>>>>// E-mail      : support@rdctools.com
79674>>>>>// Web-site    : http://www.rdctools.com
79674>>>>>//
79674>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
79674>>>>>//
79674>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
79674>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
79674>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
79674>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
79674>>>>>// in the help folder for more details.
79674>>>>>//
79674>>>>>//****************************************************************************
79674>>>>>Use Windows.pkg
79674>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLinkButton.pkg)
79674>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
79674>>>>>>>// older versions you will just get a regular great big button.
79674>>>>>>>
79674>>>>>>>Use Windows.pkg
79674>>>>>>>Use CharTranslate.pkg
79674>>>>>>>
79674>>>>>>>Class cCommandLinkButton is a Button
79675>>>>>>>    
79675>>>>>>>    Procedure Construct_Object
79677>>>>>>>        Forward Send Construct_Object
79679>>>>>>>        Property String psPrivateNote
79680>>>>>>>    End_Procedure
79681>>>>>>>    
79681>>>>>>>    Procedure Set psNote String sNote
79683>>>>>>>        Boolean bSupported
79683>>>>>>>        Set psPrivateNote to sNote
79684>>>>>>>        Get IsExControlSupported to bSupported
79685>>>>>>>        If bSupported Begin
79687>>>>>>>            Send SetWinNote
79688>>>>>>>        End
79688>>>>>>>>
79688>>>>>>>    End_Procedure
79689>>>>>>>    
79689>>>>>>>    Procedure SetWinNote
79691>>>>>>>        String sNote
79691>>>>>>>        Handle hWnd
79691>>>>>>>        Integer i
79691>>>>>>>        Address aVar
79691>>>>>>>        Get Form_Window_Handle 0 to hWnd
79692>>>>>>>        If hWnd Begin
79694>>>>>>>            Get psNote to sNote
79695>>>>>>>            Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
79696>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
79697>>>>>>>            Move (Free(aVar)) to i
79698>>>>>>>        End
79698>>>>>>>>
79698>>>>>>>    End_Procedure
79699>>>>>>>    
79699>>>>>>>    
79699>>>>>>>    Function psNote Returns String
79701>>>>>>>        Function_Return (psPrivateNote(Self))
79702>>>>>>>    End_Function
79703>>>>>>>    
79703>>>>>>>    
79703>>>>>>>    Procedure Page Integer iState
79705>>>>>>>        Integer i hWnd
79705>>>>>>>        Boolean bSupported
79705>>>>>>>        Get IsExControlSupported to bSupported
79706>>>>>>>        If (iState=1 and bSupported) Begin
79708>>>>>>>            Get form_style i to i
79709>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
79710>>>>>>>            Forward Send Page iState
79712>>>>>>>            Send SetWinNote
79713>>>>>>>        End
79713>>>>>>>>
79713>>>>>>>        Else Begin
79714>>>>>>>            Forward Send Page iState
79716>>>>>>>        End
79716>>>>>>>>
79716>>>>>>>    End_Procedure
79717>>>>>>>    
79717>>>>>>>End_Class
79718>>>>>
79718>>>>>
79718>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
79719>>>>>    Procedure Construct_Object
79721>>>>>        Forward Send Construct_Object
79723>>>>>
79723>>>>>        Set Size to 18 19
79724>>>>>        Set Focus_Mode to NonFocusable
79725>>>>>        Set peImageAlign to Button_ImageList_Align_Top
79726>>>>>        Set pbAutoResizeIcons to True
79727>>>>>    End_Procedure
79728>>>>>
79728>>>>>    Procedure OnClick
79730>>>>>        Broadcast Send Prompt of (Parent(Self))
79732>>>>>    End_Procedure
79733>>>>>
79733>>>>>    Procedure Set Bitmap String sBitmapName
79735>>>>>        Forward Set psImage to sBitmapName
79737>>>>>    End_Procedure
79738>>>>>
79738>>>>>    Procedure End_Construct_Object
79740>>>>>        Set pbShield to False
79741>>>>>        Forward Send End_Construct_Object
79743>>>>>    End_Procedure
79744>>>>>
79744>>>>>End_Class
79745>>>>>
79745>>>>>// Intermediate class - don't use.
79745>>>>>Class _cRDCHeaderGroup is a Container3d
79746>>>>>
79746>>>>>    Procedure Construct_Object
79748>>>>>        Forward Send Construct_Object
79750>>>>>
79750>>>>>        Property String private.psImage
79751>>>>>        Property String private.psLabel
79752>>>>>
79752>>>>>    End_Procedure
79753>>>>>
79753>>>>>    Procedure Set psImage String sImage
79755>>>>>        Set private.psImage to sImage
79756>>>>>    End_Procedure
79757>>>>>
79757>>>>>    Function psImage Returns String
79759>>>>>        Function_Return (private.psImage(Self))
79760>>>>>    End_Function
79761>>>>>
79761>>>>>    Procedure Set psLabel String sLabel
79763>>>>>        Set private.psLabel to sLabel
79764>>>>>    End_Procedure
79765>>>>>
79765>>>>>    Function psLabel Returns String
79767>>>>>        Function_Return (private.psLabel(Self))
79768>>>>>    End_Function
79769>>>>>
79769>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
79769>>>>>    Procedure Set Label String sLabel
79771>>>>>        Set psLabel to sLabel
79772>>>>>    End_Procedure
79773>>>>>
79773>>>>>    Function Label Returns String
79775>>>>>        Function_Return (private.psLabel(Self))
79776>>>>>    End_Function
79777>>>>>
79777>>>>>End_Class
79778>>>>>
79778>>>>>Register_Procedure NavigatePrevious
79778>>>>>Register_Procedure NavigateNext
79778>>>>>
79778>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
79779>>>>>
79779>>>>>    Procedure Construct_Object
79781>>>>>        Forward Send Construct_Object
79783>>>>>
79783>>>>>        Set peAnchors to anTopLeftRight
79784>>>>>        Set pbAcceptDropFiles to True
79785>>>>>        Set Border_Style to Border_Normal
79786>>>>>
79786>>>>>        Property Integer private.piColorOrg
79787>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
79788>>>>>        Property String private.psToolTip ""
79789>>>>>
79789>>>>>        Property Integer piImageColOffset 4
79790>>>>>        Property Integer piImageRowOffset -1
79791>>>>>        Property String psNote ""
79792>>>>>        Property Boolean pbLargeImageSize True
79793>>>>>        Property Integer private.piLargeImageSize 24
79794>>>>>        Property Integer private.piSmallImageSize 16
79795>>>>>        Property Boolean pbUseHotspotColor False
79796>>>>>        Property Integer piHeaderHotspotColor clAqua
79797>>>>>        Property String private.psLabel ""
79798>>>>>        Property Integer piLabelColor clGreenGrey
79799>>>>>        Property Boolean pbLabelFontItalics False
79800>>>>>        Property Integer piLabelLargeFontHeight 12
79801>>>>>        Property Integer piLabelSmallFontHeight 10
79802>>>>>        Property Boolean pbUseLargeFontHeight False
79803>>>>>
79803>>>>>        Property Integer piLabelFontPointWeight fw_Bold
79804>>>>>        Property Integer piLabelColOffset 28
79805>>>>>        Property Integer piLabelRowOffset 4
79806>>>>>        Property Boolean pbCreateTooltipItem True
79807>>>>>
79807>>>>>        Set pbAcceptDropFiles to True
79808>>>>>
79808>>>>>        Send Define_ToolTip_Support_Mixin
79809>>>>>
79809>>>>>        // For the Studio to render the header image
79809>>>>>        Set Bitmap to "Default32x32.bmp"
79810>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
79810>>>>>        // to render some text in the header when in design mode?
79810>>>>>        Set Label to "HEADER TEXT"
79811>>>>>
79811>>>>>        On_Key kLeftArrow  Send NavigatePrevious
79812>>>>>        On_Key kUpArrow    Send NavigatePrevious
79813>>>>>        On_Key kRightArrow Send NavigateNext
79814>>>>>        On_Key kDownArrow  Send NavigateNext
79815>>>>>        On_Key kSwitch     Send Switch_Next_Area
79816>>>>>    End_Procedure
79817>>>>>
79817>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
79818>>>>>
79818>>>>>    Procedure Set psImage String sImage
79820>>>>>        Set Bitmap to ""
79821>>>>>        Forward Set psImage to sImage
79823>>>>>    End_Procedure
79824>>>>>
79824>>>>>    Function psImage Returns String
79826>>>>>        Function_Return (psImage(Self))
79827>>>>>    End_Function
79828>>>>>
79828>>>>>    Procedure Set Label String sLabel
79830>>>>>        Forward Set psLabel to sLabel
79832>>>>>    End_Procedure
79833>>>>>
79833>>>>>    Procedure Set psToolTip String sToolTip
79835>>>>>        Set private.psToolTip to sToolTip
79836>>>>>    End_Procedure
79837>>>>>
79837>>>>>    Function psToolTip Returns String
79839>>>>>        Function_Return (private.psToolTip(Self))
79840>>>>>    End_Function
79841>>>>>
79841>>>>>    Procedure End_Construct_Object
79843>>>>>        String sNote sLabel
79843>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
79843>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
79843>>>>>
79843>>>>>        Forward Send End_Construct_Object
79845>>>>>
79845>>>>>        Get piLabelColOffset to iLabelColOffset
79846>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
79847>>>>>        If (bUseLargeFontHeight = True) Begin
79849>>>>>            Get piLabelLargeFontHeight to iFontHeight
79850>>>>>            Move 8 to iLabelRowOffset
79851>>>>>        End
79851>>>>>>
79851>>>>>        Else Begin
79852>>>>>            Get piLabelSmallFontHeight to iFontHeight
79853>>>>>            Move 6 to iLabelRowOffset
79854>>>>>        End
79854>>>>>>
79854>>>>>
79854>>>>>        Get pbLargeImageSize to bLargeImageSize
79855>>>>>        If (bLargeImageSize = True) Begin
79857>>>>>            Get private.piLargeImageSize to iImageSize
79858>>>>>        End
79858>>>>>>
79858>>>>>        Else Begin
79859>>>>>            Get private.piSmallImageSize to iImageSize
79860>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
79861>>>>>        End
79861>>>>>>
79861>>>>>
79861>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
79863>>>>>            Set piImageSize to iImageSize
79864>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
79865>>>>>            Set psImage to (private.psImage(Self))
79866>>>>>            Set peImageAlign to Button_ImageList_Align_Center
79867>>>>>            Set psToolTip to (private.psToolTip(Self))
79868>>>>>        End_Object
79869>>>>>
79869>>>>>        Object oHeaderGroupInfo_tb is a TextBox
79871>>>>>            Set Size to 12 100
79872>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
79873>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
79874>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
79875>>>>>            Set FontPointHeight to iFontHeight
79876>>>>>            Set Label to (private.psLabel(Self))
79877>>>>>            Set TextColor to (piLabelColor(Self))
79878>>>>>            Set psToolTip to (private.psToolTip(Self))
79879>>>>>            Get Size to iSize
79880>>>>>        End_Object
79881>>>>>
79881>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
79881>>>>>        // How can it be improved?
79881>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
79882>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
79884>>>>>            Get private.psLabel to sLabel
79885>>>>>            Get Text_Extent sLabel to iTextOffset
79886>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
79887>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
79889>>>>>                Set Size to 10 10
79890>>>>>                If (bUseLargeFontHeight = True) Begin
79892>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
79892>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
79893>>>>>                End
79893>>>>>>
79893>>>>>                Else Begin
79894>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
79894>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
79895>>>>>                End
79895>>>>>>
79895>>>>>                Set psToolTip to (private.psToolTip(Self))
79896>>>>>                Set Bitmap to "ActionAbout.bmp"
79897>>>>>            End_Object
79898>>>>>        End
79898>>>>>>
79898>>>>>
79898>>>>>        Get psNote to sNote
79899>>>>>        If (Trim(sNote) <> "") Begin
79901>>>>>            Object oHeaderGroupNote_tb is a TextBox
79903>>>>>                Set Size to 12 100
79904>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
79905>>>>>                Set Label to ("-" * String(sNote))
79906>>>>>                Set TextColor to (piLabelColor(Self))
79907>>>>>                Set FontPointHeight to 9
79908>>>>>                Set psToolTip to (private.psToolTip(Self))
79909>>>>>            End_Object
79910>>>>>        End
79910>>>>>>
79910>>>>>
79910>>>>>    End_Procedure
79911>>>>>
79911>>>>>    Function Popup_State Returns Boolean
79913>>>>>        Boolean bIsPopup
79913>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
79914>>>>>        Function_Return bIsPopup
79915>>>>>    End_Function
79916>>>>>
79916>>>>>    Procedure OnEnterArea Handle hoFrom
79918>>>>>        Integer iColor
79918>>>>>        Forward Send OnEnterArea hoFrom
79920>>>>>        // Not ideal, but works most of the time.
79920>>>>>        //       When navigating to i.e a popup we don't want
79920>>>>>        //       the coloring to appear. Else there will be 2
79920>>>>>        //       cRDCHeaderGroup's with the highlight color...
79920>>>>>        // Is there a better way?
79920>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
79922>>>>>            Procedure_Return
79923>>>>>        End
79923>>>>>>
79923>>>>>        If (pbUseHotspotColor(Self) = True) Begin
79925>>>>>            Get Color to iColor
79926>>>>>            Set private.piColorOrg to iColor
79927>>>>>            Get piHeaderHotspotColor to iColor
79928>>>>>            Set Color to iColor
79929>>>>>            Broadcast Recursive Set Color to iColor
79931>>>>>        End
79931>>>>>>
79931>>>>>    End_Procedure
79932>>>>>
79932>>>>>    Procedure OnExitArea Handle hoFrom
79934>>>>>        Integer iColor
79934>>>>>        Forward Send OnExitArea hoFrom
79936>>>>>        If (pbUseHotspotColor(Self) = True) Begin
79938>>>>>            Get private.piColorOrg to iColor
79939>>>>>            Set Color to iColor
79940>>>>>            Broadcast Recursive Set Color to iColor
79942>>>>>        End
79942>>>>>>
79942>>>>>    End_Procedure
79943>>>>>
79943>>>>>    // Public access message to change the group header text color at runtime.
79943>>>>>    Procedure Set Label_Color Integer iColor
79945>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
79946>>>>>    End_Procedure
79947>>>>>
79947>>>>>    Procedure NavigatePrevious
79949>>>>>        Integer iMulti ivoid iLastErr
79949>>>>>        Handle hWnd
79949>>>>>        Boolean bErr
79949>>>>>
79949>>>>>        Move Err to bErr
79950>>>>>        Move LastErr to iLastErr
79951>>>>>
79951>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
79952>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
79953>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
79954>>>>>        If (Err) Begin
79956>>>>>            Move bErr to Err
79957>>>>>            Move iLastErr to LastErr
79958>>>>>            Procedure_Return
79959>>>>>        End
79959>>>>>>
79959>>>>>
79959>>>>>        Move bErr to Err
79960>>>>>        Move iLastErr to LastErr
79961>>>>>        If (iMulti = Multi_Select) Begin
79963>>>>>            Send Previous
79964>>>>>        End
79964>>>>>>
79964>>>>>        Else Begin
79965>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
79966>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
79967>>>>>        End
79967>>>>>>
79967>>>>>    End_Procedure
79968>>>>>
79968>>>>>    Procedure NavigateNext
79970>>>>>        Integer iMulti iVoid iLastErr
79970>>>>>        Handle hWnd
79970>>>>>        Boolean bErr
79970>>>>>
79970>>>>>        Move Err to bErr
79971>>>>>        Move LastErr to iLastErr
79972>>>>>
79972>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
79973>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
79974>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
79975>>>>>        If (Err) Begin
79977>>>>>            Move bErr to Err
79978>>>>>            Move iLastErr to LastErr
79979>>>>>            Procedure_Return
79980>>>>>        End
79980>>>>>>
79980>>>>>
79980>>>>>        Move bErr to Err
79981>>>>>        Move iLastErr to LastErr
79982>>>>>        If (iMulti = Multi_Select) Begin
79984>>>>>            Send Next
79985>>>>>        End
79985>>>>>>
79985>>>>>        Else Begin
79986>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
79987>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
79988>>>>>        End
79988>>>>>>
79988>>>>>
79988>>>>>    End_Procedure
79989>>>>>
79989>>>>>    Procedure Enable_Window Integer iState
79991>>>>>        Handle hWnd
79991>>>>>        Get Window_Handle to hWnd
79992>>>>>        If hWnd Begin
79994>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
79995>>>>>        End
79995>>>>>>
79995>>>>>    End_Procedure
79996>>>>>
79996>>>>>    Procedure Page_Object Integer iState
79998>>>>>        Handle hWnd
79998>>>>>        Get Window_Handle to hWnd
79999>>>>>        Forward Send Page_Object iState
80001>>>>>        If (hWnd = 0 and iState) Begin
80003>>>>>            Send Shadow_Display
80004>>>>>        End
80004>>>>>>
80004>>>>>    End_Procedure
80005>>>>>
80005>>>>>    Procedure Shadow_Display
80007>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
80008>>>>>    End_Procedure
80009>>>>>
80009>>>>>    Function Explicit_Shadow_State Returns Boolean
80011>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
80012>>>>>    End_Function
80013>>>>>
80013>>>>>    // For some reason we need to augment this event to allow
80013>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
80013>>>>>    // happen.
80013>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
80015>>>>>        Delegate Send OnFileDropped sFilename bLast
80017>>>>>    End_Procedure
80018>>>>>
80018>>>>>End_Class
80019>>>>>
80019>>>>>// We don't want the broadcast of setting color to set the background
80019>>>>>// color for forms that are within a cRDCHeaderGroup object.
80019>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
80019>>>>>// behave as it always has. But if you don't like this; just comment
80019>>>>>// it out.
80019>>>>>//Procedure Set Color for Form Integer eColor
80019>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
80019>>>>>//    Integer iLastErr
80019>>>>>//
80019>>>>>//    Move Err to bErr
80019>>>>>//    Move LastErr to iLastErr
80019>>>>>//
80019>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80019>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
80019>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80019>>>>>//    Move bErr to Err
80019>>>>>//    Move iLastErr to LastErr
80019>>>>>//    If (bIsHeaderGroup = False) Begin
80019>>>>>//        Forward Set Color to eColor
80019>>>>>//    End
80019>>>>>//End_Procedure
80019>>>Use cRDCButtonDPI.pkg
80019>>>Use RefactorFunctionConstants.inc
80019>>>Use Windows.pkg
80019>>>
80019>>>Struct tFontSpecs
80019>>>    String sFontName
80019>>>    Integer iSize
80019>>>    Integer iCharSet
80019>>>End_Struct
80019>>>
80019>>>Function ScintillaFontAsStruct Global String sFace Returns tFontSpecs
80021>>>    Integer iSize iCharSet
80021>>>    String sFont sFontSz sCharSet
80021>>>    tFontSpecs FontSpecs
80021>>>    tFontSpecs FontSpecs
80021>>>
80021>>>    If (sFace = "") Begin
80023>>>        Move "11pt; 0; Courier New"             to sFace
80024>>>    End
80024>>>>
80024>>>    Move (Left(sFace, Pos(';', sFace)))         to sFontSz
80025>>>    Move (Trim(Replace(sFontSz, sFace, "")))    to sFace
80026>>>    Move (Replaces(' ', sFontSz, ""))           to sFontSz
80027>>>    Move (Left(sFontSz, Length(sFontSz)-3))     to FontSpecs.iSize
80028>>>    Move (Left(sFace, Pos(';', sFace)))         to sCharSet
80029>>>    Move (Trim(Replace(sCharSet, sFace, "")))   to FontSpecs.sFontName
80030>>>    Move (Left(sCharSet, Length(sCharSet)-1))   to FontSpecs.iCharSet
80031>>>
80031>>>    Function_Return FontSpecs
80032>>>End_Function
80033>>>
80033>>>Function ScintillaEditorFontFormat Global tFontSpecs FontSpecs Returns String
80035>>>    Function_Return (String(FontSpecs.iSize) + "pt;" * String(FontSpecs.iCharSet) + ";" * FontSpecs.sFontName)
80036>>>End_Function
80037>>>
80037>>>Function ScintillaReadableFontFormat Global String sFace Returns String
80039>>>    tFontSpecs FontSpecs
80039>>>    tFontSpecs FontSpecs
80039>>>    Get ScintillaFontAsStruct sFace to FontSpecs
80040>>>    Function_Return (FontSpecs.sFontName + "," * String(FontSpecs.iSize) + "pt")
80041>>>End_Function
80042>>>
80042>>>Object oScintillaParameters_dg is a cRDCModalPanel
80044>>>    Set Size to 258 447
80045>>>    Set Label to "Editor Settings"
80046>>>    Set piMinSize to 238 439
80047>>>    Set Location to 2 2
80048>>>    Set Icon to "EditorSettings.ico"
80049>>>
80049>>>    Object oImages_lst is a cImageList32
80051>>>        Set piMaxImages to 4
80052>>>        Procedure OnCreate
80055>>>            Integer iItem
80055>>>            Get AddIcon "Colors.ico"            to iItem
80056>>>            Get AddIcon "KeyWords.ico"          to iItem
80057>>>            Get AddIcon "Keyboard.ico"          to iItem
80058>>>            Get AddIcon "SettingsEditor.ico"    to iItem
80059>>>        End_Procedure
80060>>>    End_Object
80061>>>
80061>>>    Object oEditorTabDialog is a TabDialog
80063>>>        Set Size to 228 441
80064>>>        Set Location to 4 3
80065>>>        Set phoImageList to oImages_lst
80066>>>        Set peAnchors to anAll
80067>>>
80067>>>        Object oFontsPage is a TabPage
80069>>>            Set Label to "Color/Font"
80070>>>            Set piImageIndex to 0
80071>>>
80071>>>            Object oColorsGroup is a cRDCHeaderGroup
80073>>>                Set Size to 206 428
80074>>>                Set Location to 5 4
80075>>>                Set Label to "Colors and Font"
80076>>>                Set psImage to "Colors.ico"
80077>>>                Set peAnchors to anAll
80078>>>
80078>>>                Object oCategory is a TreeView
80080>>>                    Set Size to 153 106
80081>>>                    Set Location to 46 7
80082>>>                    Set pbFullRowSelect to True
80083>>>                    Set piTextColor to clBlack
80084>>>                    Set pbExplorerStyle to True
80085>>>                    Set peAnchors to anTopBottomLeft
80086>>>
80086>>>                    // Initializes colorer and populates the Tree
80086>>>                    Procedure OnCreateTree
80089>>>                        Handle  hItem
80089>>>                        Integer iItem iItems
80089>>>
80089>>>                        Move (SizeOfArray(gtColorer)) to iItems
80090>>>                        For iItem From 0 to (iItems-1)
80096>>>>
80096>>>                            Get AddTreeItem gtColorer[iItem].sName 0 iItem 0 0 to hItem
80097>>>                        Loop
80098>>>>
80098>>>                        Set Visible_State of oColor         to False
80099>>>                        Set Visible_State of oBackground    to False
80100>>>                    End_Procedure
80101>>>
80101>>>                    Procedure OnItemChanged Handle hItem Handle hItemOld
80104>>>                        Integer iIndex
80104>>>                        String  sLabel
80104>>>
80104>>>                        // Collect Item Data of the selected Colorer Item
80104>>>                        Get ItemData  hItem to iIndex
80105>>>                        Get ItemLabel hItem to sLabel
80106>>>
80106>>>                        // Manage color pickers
80106>>>                        Set Visible_State of oColor         to gtColorer[iIndex].iForeOff
80107>>>                        Set Visible_State of oBackground    to gtColorer[iIndex].iBackOff
80108>>>                        Set Visible_State of oFontBold      to gtColorer[iIndex].iBackOff
80109>>>                        Set Visible_State of oFontItalics   to gtColorer[iIndex].iBackOff
80110>>>                        Set Visible_State of oFontUnderline to gtColorer[iIndex].iBackOff
80111>>>
80111>>>                        // Show the current color if applicable
80111>>>                        Set piColorerIndex of oColor        to iIndex
80112>>>                        Set piColorerIndex of oBackground   to iIndex
80113>>>                        If (gtColorer[iIndex].iForeOff) ;                        Set SlectedColor of oColor      to gtColorer[iIndex].iForeC
80116>>>                        If (gtColorer[iIndex].iBackOff) ;                        Set SlectedColor of oBackground to gtColorer[iIndex].iBackC
80119>>>
80119>>>                        // Font flags
80119>>>                        Set piColorerIndex of oFontBold      to iIndex
80120>>>                        Set piColorerIndex of oFontItalics   to iIndex
80121>>>                        Set piColorerIndex of oFontUnderline to iIndex
80122>>>                        Set Checked_State  of oFontBold      to gtColorer[iIndex].iBold
80123>>>                        Set Checked_State  of oFontItalics   to gtColorer[iIndex].iItalics
80124>>>                        Set Checked_State  of oFontUnderline to gtColorer[iIndex].iUnderline
80125>>>
80125>>>                        // Notify color picker about current colorer element
80125>>>                        Send mGeneratePreview
80126>>>                    End_Procedure
80127>>>
80127>>>                    On_Key Key_Up_Arrow Send Up
80128>>>                    On_Key Key_Down_Arrow Send Down
80129>>>                End_Object
80130>>>
80130>>>                Object oColor is a cColorBox
80132>>>                    Set Size to 22 105
80133>>>                    Set Location to 47 120
80134>>>                    Set Label to "Color"
80135>>>                    Procedure OnColorChange
80138>>>                        Integer iColor
80138>>>                        Get SelectedColor to iColor
80139>>>                        Move iColor to gtColorer[piColorerIndex(Self)].iForeC
80140>>>                        Send mGeneratePreview
80141>>>                        Delegate Send NotifyChange
80143>>>                    End_Procedure
80144>>>                End_Object
80145>>>
80145>>>                Object oBackground is a cColorBox
80147>>>                    Set Size to 22 105
80148>>>                    Set Location to 72 120
80149>>>                    Set Label to "Background"
80150>>>                    Procedure OnColorChange
80153>>>                        Integer iColor
80153>>>                        Get SelectedColor to iColor
80154>>>                        Move iColor to gtColorer[piColorerIndex(Self)].iBackC
80155>>>                        Send mGeneratePreview
80156>>>                        Delegate Send NotifyChange
80158>>>                    End_Procedure
80159>>>                End_Object
80160>>>
80160>>>                Object oFontBold is a CheckBox
80162>>>                    Property Integer piColorerIndex
80164>>>                    Set Size to 10 50
80165>>>                    Set Location to 107 151
80166>>>                    Set Label to "Bold"
80167>>>                    Set FontWeight to fw_Bold
80168>>>                    Set Visible_State to False
80169>>>                    Procedure OnChange
80172>>>                        If (Focus(Desktop)=Self) Begin
80174>>>                            Get Checked_State to gtColorer[piColorerIndex(Self)].iBold
80175>>>                            Send mGeneratePreview
80176>>>                            Delegate Send NotifyChange
80178>>>                        End
80178>>>>
80178>>>                    End_Procedure
80179>>>                End_Object
80180>>>
80180>>>                Object oFontItalics is a CheckBox
80182>>>                    Property Integer piColorerIndex
80184>>>                    Set Size to 10 50
80185>>>                    Set Location to 118 151
80186>>>                    Set Label to "Italics"
80187>>>                    Set FontItalics to True
80188>>>                    Set Visible_State to False
80189>>>                    Procedure OnChange
80192>>>                        If (Focus(Desktop)=Self) Begin
80194>>>                            Get Checked_State to gtColorer[piColorerIndex(Self)].iItalics
80195>>>                            Send mGeneratePreview
80196>>>                            Delegate Send NotifyChange
80198>>>                        End
80198>>>>
80198>>>                    End_Procedure
80199>>>                End_Object
80200>>>
80200>>>                Object oFontUnderline is a CheckBox
80202>>>                    Property Integer piColorerIndex
80204>>>                    Set Size to 10 50
80205>>>                    Set Location to 129 151
80206>>>                    Set Label to "Underline"
80207>>>                    Set FontUnderline to True
80208>>>                    Set Visible_State to False
80209>>>                    Procedure OnChange
80212>>>                        If (Focus(Desktop)=Self) Begin
80214>>>                            Get Checked_State to gtColorer[piColorerIndex(Self)].iUnderline
80215>>>                            Send mGeneratePreview
80216>>>                            Delegate Send NotifyChange
80218>>>                        End
80218>>>>
80218>>>                    End_Procedure
80219>>>                End_Object
80220>>>
80220>>>                Object oPreview is a Container3d
80222>>>                    Set Size to 157 190
80223>>>                    Set Location to 46 232
80224>>>                    Set Border_Style to Border_ClientEdge
80225>>>                    Set Color to clWhite
80226>>>                    Set peAnchors to anAll
80227>>>
80227>>>                    Object oLeftMarginPreview is a Container3d
80229>>>                        Set Size to 156 14
80230>>>                        Set Location to 0 0
80231>>>                        Set Border_Style to Border_None
80232>>>                        Set peAnchors to anAll
80233>>>                    End_Object
80234>>>
80234>>>                    Object oNumbersPreview is a TextBox
80236>>>                        Set Auto_Size_State to False
80237>>>                        Set Size to 179 12
80238>>>                        Set Location to 0 14
80239>>>                        Set Label to ("01"+Character(10)+"02"+Character(10)+"03"+Character(10)+"04"+Character(10)+"05"+ ;                        Character(10)+"06"+Character(10)+"07"+Character(10)+"08"+Character(10)+"09"+ ;                        Character(10)+"10"+Character(10)+"11"+Character(10)+"12"+Character(10)+"13"+ ;                        Character(10)+"14"+Character(10)+"15"+Character(10)+"16"+Character(10)+"17"+ ;                        Character(10)+"18"+Character(10)+"19")
80240>>>                        Set FontWeight to fw_Bold
80241>>>                        Set Color to clDkGray
80242>>>                        Set TextColor to clWhite
80243>>>                        Set Justification_Mode to JMode_Center
80244>>>                        Set Typeface to "Courier New"
80245>>>                        Set peAnchors to anTopBottomLeft
80246>>>                    End_Object
80247>>>
80247>>>                    Object oEditorPreview is a cEditorPreview
80249>>>                        Set Size to 162 158
80250>>>                        Set Location to 0 29
80251>>>                        Set peAnchors to anAll
80252>>>                    End_Object
80253>>>
80253>>>                End_Object
80254>>>
80254>>>                Procedure mGeneratePreview
80257>>>                    Integer iForeColor iOriFore iSize
80257>>>                    String sFont
80257>>>                    tFontSpecs FontSpecs
80257>>>                    tFontSpecs FontSpecs
80257>>>
80257>>>                    Set Dynamic_Update_State of oEditorPreview to False
80258>>>                    Send Delete_Data to oEditorPreview
80259>>>
80259>>>                    // General Appearance
80259>>>                    Move gtColorer[EC_WINDOW].iForeC  to iForeColor
80260>>>                    If (iForeColor<0) Begin
80262>>>                        Move clWhite to iForeColor
80263>>>                    End
80263>>>>
80263>>>                    Set Color of oEditorPreview to iForeColor
80264>>>                    Set Color of oPreview to iForeColor
80265>>>
80265>>>                    // Left Marging
80265>>>                    Set Color               of oLeftMarginPreview   to gtColorer[EC_LEFTMARGIN].iForeC
80266>>>
80266>>>                    // Line Numbers
80266>>>                    Set TextColor           of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iForeC //iForeColor
80267>>>                    Set Color               of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iBackC //iBackColor
80268>>>                    Set FontWeight          of oNumbersPreview      to (gtColorer[EC_LINENUMBERS].iBold * 800)
80269>>>                    Set FontItalics         of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iItalics
80270>>>                    Set FontUnderline       of oNumbersPreview      to gtColorer[EC_LINENUMBERS].iUnderline
80271>>>
80271>>>                    // Font
80271>>>                    Get psEditorFont of oFontFace to sFont
80272>>>                    Get ScintillaFontAsStruct sFont to FontSpecs
80273>>>                    Move FontSpecs.sFontName to sFont
80274>>>                    Move ((FontSpecs.iSize - 2) * 20) to iSize
80275>>>                    Set psTypeFace          of oEditorPreview to sFont
80276>>>                    Set piFontSize          of oEditorPreview to iSize
80277>>>
80277>>>                    // Elements
80277>>>                    Get TextColor           of oEditorPreview to iOriFore
80278>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Pre-processor/Macro", 1055))
80279>>>                    Send AppendTextLn       to oEditorPreview ""
80280>>>                    Send AddPreProcessor    to oEditorPreview "#COMMAND _DEBUG"
80281>>>                    Send AppendTextLn       to oEditorPreview ""
80282>>>                    Send AddPreProcessor    to oEditorPreview "#ENDCOMMAND"
80283>>>                    Send AppendTextLn       to oEditorPreview ""
80284>>>                    Send AppendTextLn       to oEditorPreview ""
80285>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Metatags, Keywords, Strings", 1056))
80286>>>                    Send AppendTextLn       to oEditorPreview ""
80287>>>                    Send AddMetaTag         to oEditorPreview ('{Description="'+ _T("Meta tag", 1057) +'"}')
80288>>>                    Send AppendTextLn       to oEditorPreview ""
80289>>>                    Send AddScopeKeyword    to oEditorPreview "Function"
80290>>>                    Send AddSpacing         to oEditorPreview " "
80291>>>                    Send AddText            to oEditorPreview "mFoo"
80292>>>                    Send AddText            to oEditorPreview " "
80293>>>                    Send AddKeyword         to oEditorPreview "Returns String"
80294>>>                    Send AppendTextLn       to oEditorPreview ""
80295>>>                    Send AddSpacing         to oEditorPreview "    "
80296>>>                    Send AddKeyword         to oEditorPreview "String"
80297>>>                    Send AddSpacing         to oEditorPreview " "
80298>>>                    Send AddText            to oEditorPreview "sRetVal"
80299>>>                    Send AppendTextLn       to oEditorPreview ""
80300>>>                    Send AddSpacing         to oEditorPreview "    "
80301>>>                    Send AddKeyword         to oEditorPreview "Move"
80302>>>                    Send AddSpacing         to oEditorPreview " "
80303>>>                    Send AddText            to oEditorPreview "("
80304>>>                    Send AddString          to oEditorPreview ('"'+_T("Hello", 1058)+'"')
80305>>>                    Send AddSpacing         to oEditorPreview " "
80306>>>                    Send AddOperator        to oEditorPreview "*"
80307>>>                    Send AddSpacing         to oEditorPreview " "
80308>>>                    Send AddString          to oEditorPreview ('"'+_T("World!", 1059)+'"')
80309>>>                    Send AddText            to oEditorPreview ")"
80310>>>                    Send AddSpacing         to oEditorPreview " "
80311>>>                    Send AddOperator        to oEditorPreview ";"
80312>>>                    Send AppendTextLn       to oEditorPreview ""
80313>>>                    Send AddSpacing         to oEditorPreview "        "
80314>>>                    Send AddKeyword         to oEditorPreview "to"
80315>>>                    Send AddSpacing         to oEditorPreview " "
80316>>>                    Send AddText            to oEditorPreview "sRetVal"
80317>>>                    Send AppendTextLn       to oEditorPreview ""
80318>>>                    Send AddSpacing         to oEditorPreview "    "
80319>>>                    Send AddKeyword         to oEditorPreview "Function_Return"
80320>>>                    Send AddSpacing         to oEditorPreview " "
80321>>>                    Send AddText            to oEditorPreview "sRetVal"
80322>>>                    Send AppendTextLn       to oEditorPreview ""
80323>>>                    Send AddScopeKeyword    to oEditorPreview "End_Function"
80324>>>                    Send AddSpacing         to oEditorPreview " "
80325>>>                    Send AddComment         to oEditorPreview "// mFoo"
80326>>>                    Send AppendTextLn       to oEditorPreview ""
80327>>>                    Send AppendTextLn       to oEditorPreview ""
80328>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Numbers & Braces", 1060))
80329>>>                    Send AppendTextLn       to oEditorPreview ""
80330>>>                    Send AddKeyword         to oEditorPreview "Number"
80331>>>                    Send AddSpacing         to oEditorPreview " "
80332>>>                    Send AddText            to oEditorPreview "nVal"
80333>>>                    Send AppendTextLn       to oEditorPreview ""
80334>>>                    Send AddKeyword         to oEditorPreview "Move"
80335>>>                    Send AddSpacing         to oEditorPreview " "
80336>>>                    Send AddBraceHLight     to oEditorPreview "("
80337>>>                    Send AddNumber          to oEditorPreview '1.23'
80338>>>                    Send AddSpacing         to oEditorPreview " "
80339>>>                    Send AddOperator        to oEditorPreview "+"
80340>>>                    Send AddSpacing         to oEditorPreview " "
80341>>>                    Send AddText            to oEditorPreview "("
80342>>>                    Send AddNumber          to oEditorPreview '12'
80343>>>                    Send AddSpacing         to oEditorPreview " "
80344>>>                    Send AddOperator        to oEditorPreview "*"
80345>>>                    Send AddSpacing         to oEditorPreview " "
80346>>>                    Send AddNumber          to oEditorPreview '$02'
80347>>>                    Send AddText            to oEditorPreview ")"
80348>>>                    Send AddBraceHLight     to oEditorPreview ")"
80349>>>                    Send AddUnmatchedBrace  to oEditorPreview ")"
80350>>>                    Send AddSpacing         to oEditorPreview " "
80351>>>                    Send AddKeyword         to oEditorPreview "to"
80352>>>                    Send AddSpacing         to oEditorPreview " "
80353>>>                    Send AddText            to oEditorPreview "nVal"
80354>>>
80354>>>                    Send AppendTextLn       to oEditorPreview ""
80355>>>                    Send AppendTextLn       to oEditorPreview ""
80356>>>                    Send AddComment         to oEditorPreview (CS_CommentSymbol * _T("Typing String", 1061))
80357>>>                    Send AppendTextLn       to oEditorPreview ""
80358>>>                    Send AddKeyword         to oEditorPreview "Move"
80359>>>                    Send AddSpacing         to oEditorPreview " "
80360>>>                    Send AddStringTyping    to oEditorPreview ('"'+_T("Typing new String", 1062))
80361>>>                    Send AppendTextLn       to oEditorPreview ""
80362>>>
80362>>>                    Set TextColor   of oEditorPreview to iOriFore
80363>>>                    Set Enabled_State of oSave to False
80364>>>                    Send ChangeFontStyle     of oEditorPreview sFont FontSpecs.iSize
80365>>>                    Set Dynamic_Update_State of oEditorPreview to True
80366>>>                    Send Beginning_of_Data   of oEditorPreview
80367>>>                    // Make the line numbers line up with the new font
80367>>>                    Set Typeface        of oNumbersPreview to sFont
80368>>>                    Set FontPointHeight of oNumbersPreview to FontSpecs.iSize
80369>>>                End_Procedure
80370>>>
80370>>>                Object oSchemaSelect is a ComboForm
80372>>>                    Set Size to 13 106
80373>>>                    Set Location to 30 7
80374>>>                    Set Label to "Color Theme:"
80375>>>                    Set Label_Col_Offset to 0
80376>>>                    Set Label_Justification_Mode to JMode_Top
80377>>>                    Set Label_Row_Offset to 1
80378>>>
80378>>>                    Procedure Combo_Fill_List
80381>>>                        String  sCur
80381>>>
80381>>>                        // Defauls Schemas
80381>>>                        Send Combo_Add_Item TH_DEFSCHEMA_WHITE_STR
80382>>>                        Send Combo_Add_Item TH_DEFSCHEMA_BLACK_STR
80383>>>                        Send Combo_Add_Item TH_DEFSCHEMA_BLUE_STR
80384>>>                        Send Combo_Add_Item TH_DEFSCHEMA_LIME_STR
80385>>>                        Send Combo_Add_Item TH_DEFSCHEMA_SERENE_STR
80386>>>                        Send Combo_Add_Item TH_DEFSCHEMA_SAHARA_STR
80387>>>
80387>>>                        Get psColorSchema of ghoEditorProperties to sCur
80388>>>                        If (sCur = "") Begin
80390>>>                            Move TH_DEFSCHEMA_WHITE_STR to sCur
80391>>>                            Set psColorSchema of ghoEditorProperties to sCur
80392>>>                        End
80392>>>>
80392>>>
80392>>>                        Set Value to sCur
80393>>>                        Set Entry_State to False
80394>>>                    End_Procedure
80395>>>
80395>>>                    Procedure OnChange
80398>>>                        Boolean bDefaultSchema
80398>>>                        String sName sSchema sFontStyles
80398>>>                        Integer iC iPos
80398>>>
80398>>>                        If (Focus(Desktop) = Self) Begin
80400>>>                            Move True to bDefaultSchema
80401>>>                            Get Value Item 0 to sName
80402>>>                            Move TH_COLORSCHEMA_WHITE to sSchema
80403>>>                            Get psFontStyles of ghoEditorProperties to sFontStyles
80404>>>                            If (sName = TH_DEFSCHEMA_BLACK_STR) Begin
80406>>>                                Move TH_COLORSCHEMA_BLACK to sSchema
80407>>>                            End
80407>>>>
80407>>>                            Else If (sName = TH_DEFSCHEMA_BLUE_STR) Begin
80410>>>                                Move TH_COLORSCHEMA_BLUE to sSchema
80411>>>                            End
80411>>>>
80411>>>                            Else If (sName = TH_DEFSCHEMA_LIME_STR) Begin
80414>>>                                Move TH_COLORSCHEMA_LIME to sSchema
80415>>>                            End
80415>>>>
80415>>>                            Else If (sName=TH_DEFSCHEMA_SERENE_STR) Begin
80418>>>                                Move TH_COLORSCHEMA_SERENE   to sSchema
80419>>>                            End
80419>>>>
80419>>>                            Else If (sName=TH_DEFSCHEMA_SAHARA_STR) Begin
80422>>>                                Move TH_COLORSCHEMA_SAHARA   to sSchema
80423>>>                            End
80423>>>>
80423>>>                            Else If (sName <> TH_DEFSCHEMA_WHITE_STR) Begin
80426>>>                                Move False to bDefaultSchema
80427>>>                                Get FindColorSchema of ghoEditorProperties sName to iC
80428>>>                                If (iC >= 0) Begin
80430>>>                                    Get psColorSchemas.psSchemaColors       of ghoEditorProperties Item iC to sSchema
80431>>>                                    Get psColorSchemas.psSchemaFontStyles   of ghoEditorProperties Item iC to sFontStyles
80432>>>                                End
80432>>>>
80432>>>                            End
80432>>>>
80432>>>                            If (bDefaultSchema) Begin
80434>>>                                Move (Pos(",", sSchema)) to iPos
80435>>>                                If (iPos>0) Begin
80437>>>                                    Move (Right(sSchema, Length(sSchema) - iPos)) to sFontStyles
80438>>>                                    Move (Left(sSchema, (iPos - 1))) to sSchema
80439>>>                                End
80439>>>>
80439>>>                                Else Begin
80440>>>                                // use the default font style if not defined.
80440>>>                                    Move (Repeat('0', 3 * 16) + "000") to sFontStyles
80441>>>                                End
80441>>>>
80441>>>                            End
80441>>>>
80441>>>
80441>>>                            Send SetColorerCurrentStyles sSchema sFontStyles
80442>>>                            Send mGeneratePreview to oColorsGroup
80443>>>
80443>>>                            Delegate Send NotifyChange
80445>>>                        End
80445>>>>
80445>>>                    End_Procedure
80446>>>
80446>>>                    On_Key Key_F2  Send SaveEntries
80447>>>                    On_Key kCancel Send Close_Panel
80448>>>                End_Object
80449>>>
80449>>>                Object oFontFace is a Form
80451>>>                    Set Size to 13 105
80452>>>                    Set Location to 30 120
80453>>>                    Set Label_Col_Offset to 0
80454>>>                    Set Label_Justification_Mode to JMode_Top
80455>>>                    Set Prompt_Button_Mode to PB_PromptOn
80456>>>                    Set Label to "Font:"
80457>>>                    Set Label_Row_Offset to 1
80458>>>
80458>>>                    // The editor font, size & type is saved as a string with
80458>>>                    // the format: "11pt; 0; Consolas" in the .ini file. This is
80458>>>                    // also the format used to populate the popup font selection dialog.
80458>>>                    // However, we like to present the font as "Consolas, 11pt".
80458>>>                    Property String private.psEditorFont ""
80460>>>
80460>>>                    Procedure Set psEditorFont String sFont
80463>>>                        String sFontText
80463>>>                        Set private.psEditorFont to sFont
80464>>>                        Get ScintillaReadableFontFormat sFont to sFontText
80465>>>                        Set Value to sFontText
80466>>>                    End_Procedure
80467>>>
80467>>>                    Function psEditorFont Returns String
80470>>>                        Function_Return (private.psEditorFont(Self))
80471>>>                    End_Function
80472>>>
80472>>>                    Procedure Key Integer iKey Returns Integer
80475>>>                        Integer iRetVal
80475>>>                        // Left, Right, Shft+Left, Shift+Right, Home, End, Shft+Home, Shft+End
80475>>>                        If ((iKey=260)or(iKey=261)or(iKey=5127)or(iKey=5128)or ;                        (iKey=294)or(iKey=295)or(iKey=5129)or(iKey=5130) ) ;                        Forward Get Msg_Key iKey to iRetVal
80479>>>                        Procedure_Return iRetVal
80480>>>                    End_Procedure
80481>>>
80481>>>                    Function CanPaste Returns Boolean
80484>>>                        Function_Return False
80485>>>                    End_Function
80486>>>                    Function CanCut Returns Boolean
80489>>>                        Function_Return False
80490>>>                    End_Function
80491>>>                    Function CanDelete Returns Boolean
80494>>>                        Function_Return False
80495>>>                    End_Function
80496>>>                    Function CanUndo Returns Boolean
80499>>>                        Function_Return False
80500>>>                    End_Function
80501>>>                    Procedure Paste Integer Arg1 Integer Arg2 Integer Arg3
80504>>>                    End_Procedure
80505>>>                    Procedure Cut Integer Arg1 Integer Arg2 Integer Arg3
80508>>>                    End_Procedure
80509>>>                    Procedure Delete
80512>>>                    End_Procedure
80513>>>                    Procedure Undo
80516>>>                    End_Procedure
80517>>>
80517>>>                    Procedure Prompt
80520>>>                        Handle hoFontDlg
80520>>>                        Integer iOK
80520>>>                        tFontSpecs FontSpecs
80520>>>                        tFontSpecs FontSpecs
80520>>>                        String sFace sSize sCharSet sFontText
80520>>>
80520>>>                        Get psEditorFont to sFace
80521>>>                        Get ScintillaFontAsStruct sFace to FontSpecs
80522>>>                        Get Create (RefClass(FontDialog)) to hoFontDlg
80523>>>
80523>>>                        Set FixedPitchOnly_State    of hoFontDlg to True
80524>>>                        Set FaceName                of hoFontDlg to FontSpecs.sFontName
80525>>>                        Set FontPointSize           of hoFontDlg to (FontSpecs.iSize * 10)
80526>>>                        Set FontCharSet             of hoFontDlg to FontSpecs.iCharSet
80527>>>                        Set FontItalic              of hoFontDlg to False
80528>>>                        Set FontUnderline           of hoFontDlg to False
80529>>>                        Set FontWeight              of hoFontDlg to FW_REGULAR
80530>>>                        Set FontType                of hoFontDlg to REGULAR_FONTTYPE
80531>>>                        Get FontDialog              of hoFontDlg to iOK
80532>>>                        If (iOk) Begin
80534>>>                            Move "" to FontSpecs.sFontName
80535>>>                            Move 0  to FontSpecs.iSize
80536>>>                            Move 0  to FontSpecs.iCharSet
80537>>>                            // Note: We _must_ trim the FaceName, FontPointSize & FontCharSet, else we can't append anything to the string.
80537>>>                            // Perhaps the functions does not make a proper DataFlex string ending?
80537>>>                            Get FaceName                of hoFontDlg to sFace
80538>>>                            Move (CString(sFace))       to FontSpecs.sFontName
80539>>>                            Get FontPointSize           of hoFontDlg to sSize
80540>>>                            Move (CString(sSize))       to sSize
80541>>>                            If (sSize = "") Begin
80543>>>                                Move 110    to sSize
80544>>>                            End
80544>>>>
80544>>>                            Move (sSize / 10)           to FontSpecs.iSize
80545>>>                            Get FontCharSet             of hoFontDlg to sCharSet
80546>>>                            Move (CString(sCharSet))    to FontSpecs.iCharSet
80547>>>                            Append sFontText FontSpecs.sFontName ", " (String(FontSpecs.iSize)) "pt"
80551>>>
80551>>>                            Set Value                   to sFontText
80552>>>                            Get ScintillaEditorFontFormat FontSpecs to sFace
80553>>>                            Set psEditorFont            to sFace
80554>>>                            Send mGeneratePreview
80555>>>                            Delegate Send NotifyChange
80557>>>                        End
80557>>>>
80557>>>                        Send Destroy                    to hoFontDlg
80558>>>                    End_Procedure
80559>>>
80559>>>                End_Object
80560>>>
80560>>>                Object oColorSelectionInfo_tb is a TextBox
80562>>>                    Set Auto_Size_State to False
80563>>>                    Set Size to 24 105
80564>>>                    Set Location to 150 120
80565>>>                    Set Label to "Click on a color above to select a new color from the popup dialog"
80566>>>                    Set Justification_Mode to JMode_Left
80567>>>                    Set FontItalics to True
80568>>>                End_Object
80569>>>
80569>>>            End_Object
80570>>>
80570>>>        End_Object
80571>>>
80571>>>        Object oLanguagePage is a TabPage
80573>>>            Set Label to "Language"
80574>>>            Set piImageIndex to 1
80575>>>
80575>>>            Object oLanguageGroup is a cRDCHeaderGroup
80577>>>                Set Size to 206 428
80578>>>                Set Location to 5 4
80579>>>                Set psImage to "KeyWords.ico"
80580>>>                Set Label to "Keywords and Operators"
80581>>>                Set psNote to "Used by Editor when the 'Adjust Upper/Lowercase' refactor function is selected"
80582>>>                Set peAnchors to anAll
80583>>>
80583>>>                Object oScopes is a cSCWsGrid
80585>>>                    Set Size to 137 180
80586>>>                    Set Location to 35 6
80587>>>                    Set Line_Width to 2 0
80588>>>                    Set GridLine_Mode to Grid_Visible_None
80589>>>
80589>>>                    Set Form_Width 0 to 85
80590>>>                    Set Header_Label 0 to "Scope Start"
80591>>>                    Set Status_Help Item 0 to "Scope keyword start"
80592>>>
80592>>>                    Set Form_Width 1 to 85
80593>>>                    Set Header_Label 1 to "Scope End"
80594>>>                    Set Status_Help Item 1 to "Scope keyword stop"
80595>>>
80595>>>                    Property String psSepCharacter "\n"
80597>>>
80597>>>                    Set peAnchors to anTopBottom
80598>>>
80598>>>                    Procedure OnChange Integer iItem
80601>>>                        Integer iScopes
80601>>>                        Delegate Send NotifyChange
80603>>>                        Get Item_Count to iScopes
80604>>>                        Set Label of oScopesInfo_tb to ("Scopes:" * String(iScopes / 2))
80605>>>                    End_Procedure
80606>>>
80606>>>                    Procedure Add_New_Line String sStart String sStop Integer iColor
80609>>>                        Send Add_Item Msg_None sStart
80610>>>                        If (iColor) Begin
80612>>>                            Set ItemTextColor (Item_Count(Self) - 1) to iColor
80613>>>                        End
80613>>>>
80613>>>                        Send Add_Item Msg_None sStop
80614>>>                        If (iColor) Begin
80616>>>                            Set ItemTextColor (Item_Count(Self) - 1) to iColor
80617>>>                        End
80617>>>>
80617>>>                    End_Procedure
80618>>>
80618>>>                    Procedure mInsertLine
80621>>>                        Send Add_New_Line "" "" clRed
80622>>>                        Send OnChange 0
80623>>>                        Send End_of_Data
80624>>>                    End_Procedure
80625>>>
80625>>>                    Procedure mRemoveLine
80628>>>                        Integer iRowBase
80628>>>                        If (Item_Count(Self) = 0) Begin
80630>>>                            Procedure_Return
80631>>>                        End
80631>>>>
80631>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
80632>>>                        Send Delete_Item (iRowBase + 1)
80633>>>                        Send Delete_Item iRowBase
80634>>>                        Send OnChange 0
80635>>>                    End_Procedure
80636>>>
80636>>>                    Procedure mMoveDown
80639>>>                        Integer iCount iRowBase
80639>>>                        String  sStart sStop
80639>>>
80639>>>                        Get Item_Count to iCount
80640>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
80641>>>                        Get Value Item iRowBase to sStart
80642>>>                        Get Value Item (iRowBase + 1) to sStop
80643>>>                        If (sStart = "") Begin
80645>>>                            Set Current_Item to iRowBase
80646>>>                        End
80646>>>>
80646>>>                        Else If (sStop = "") Begin
80649>>>                            Set Current_Item to (iRowBase + 1)
80650>>>                        End
80650>>>>
80650>>>                        Else Begin
80651>>>                            If (iRowBase = (iCount - 2)) Begin
80653>>>                                Send mInsertLine
80654>>>                                Set Current_Item to (iRowBase + 2)
80655>>>                            End
80655>>>>
80655>>>                            Send Down
80656>>>                            Set Current_Item to (iRowBase + 2)
80657>>>                        End
80657>>>>
80657>>>                    End_Procedure
80658>>>
80658>>>                    Procedure mMoveUp
80661>>>                        Integer iRowBase
80661>>>                        String  sStart sStop
80661>>>
80661>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
80662>>>                        Get Value Item iRowBase to sStart
80663>>>                        Get Value Item (iRowBase + 1) to sStop
80664>>>                        If (sStart = "" and sStop = "") Begin
80666>>>                            Send mRemoveLine
80667>>>                        End
80667>>>>
80667>>>                        Else If (sStart = "" or sStop = "") Begin
80670>>>                            Send Stop_Box (_T("Scope 'Start' and 'Stop' keywords must be specified!", 1455)) (_T("Problem", 1474))
80671>>>                        End
80671>>>>
80671>>>                        Else Begin
80672>>>                            Send Up
80673>>>                        End
80673>>>>
80673>>>                    End_Procedure
80674>>>
80674>>>                    Function GetValue Integer iColumn Returns String
80677>>>                        Integer iC iColumns
80677>>>                        String  sRet sSep
80677>>>
80677>>>                        Move (Low(Matrix_Size(Self))) to iColumns
80678>>>                        Get psSepCharacter to sSep
80679>>>                        If (sSep = "") Begin
80681>>>                            Move "\n" to sSep
80682>>>                        End
80682>>>>
80682>>>                        For iC From 0 to (Item_Count(Self) - 1)
80688>>>>
80688>>>                            If (Value(Self, iC + iColumn) <> "") Begin
80690>>>                                If (sRet <> "") Begin
80692>>>                                    Move (sRet + sSep) to sRet
80693>>>                                End
80693>>>>
80693>>>                                Move (sRet + Value(Self, iC + iColumn)) to sRet
80694>>>                            End
80694>>>>
80694>>>                            Move (iC + iColumns - 1) to iC
80695>>>                        Loop
80696>>>>
80696>>>                        Function_Return sRet
80697>>>                    End_Function
80698>>>
80698>>>                    Procedure DoLoad tSCLanguage ByRef ltSCLanguage
80701>>>                        Integer iScope iScopes
80701>>>                        Send Delete_Data
80702>>>                        Move (SizeOfArray(ltSCLanguage.saScopeStart)) to iScopes
80703>>>                        For iScope From 0 to (iScopes -1)
80709>>>>
80709>>>                            Send Add_New_Line ltSCLanguage.saScopeStart[iScope] ltSCLanguage.saScopeStop[iScope] 0
80710>>>                        Loop
80711>>>>
80711>>>                        Set Label of oScopesInfo_tb to ("Scopes:" * String(iScopes))
80712>>>                    End_Procedure
80713>>>
80713>>>                    On_Key key_F2       Send Request_SaveAllEntries
80714>>>                    On_Key kCancel      Send Close_Panel
80715>>>                    On_Key kDownArrow   Send mMoveDown
80716>>>                    On_Key kUpArrow     Send mMoveUp
80717>>>                    On_Key Key_Tab      Send mMoveDown
80718>>>                End_Object
80719>>>
80719>>>                Object oScopesInfo_tb is a TextBox
80721>>>                    Set Auto_Size_State to False
80722>>>                    Set Size to 9 50
80723>>>                    Set Location to 174 6
80724>>>                    Set Label to "Scopes:"
80725>>>                    Set peAnchors to anBottomLeft
80726>>>                End_Object
80727>>>
80727>>>                Object oAddScope is a cRDCButtonDPI
80729>>>                    Set Size to 15 50
80730>>>                    Set Location to 185 7
80731>>>                    Set Label to "Add"
80732>>>                    Set psImage to "ActionAdd.ico"
80733>>>                    Set peAnchors to anBottomLeft
80734>>>                    Procedure OnClick
80737>>>                        Send mInsertLine to oScopes
80738>>>                    End_Procedure
80739>>>                End_Object
80740>>>
80740>>>                Object oRemoveScope is a cRDCButtonDPI
80742>>>                    Set Size to 15 50
80743>>>                    Set Location to 185 60
80744>>>                    Set Label to "Remove"
80745>>>                    Set psImage to "Remove.ico"
80746>>>                    Set peAnchors to anBottomLeft
80747>>>                    Procedure OnClick
80750>>>                        Send mRemoveLine to oScopes
80751>>>                    End_Procedure
80752>>>                End_Object
80753>>>
80753>>>                Object oLineControl2 is a LineControl
80755>>>                    Set Size to 164 3
80756>>>                    Set Location to 36 190
80757>>>                    Set Horizontal_State to False
80758>>>                    Set peAnchors to anTopBottom
80759>>>                End_Object
80760>>>
80760>>>                Object oKeywords is a cSCWsGrid
80762>>>                    Set Size to 137 112
80763>>>                    Set Location to 35 195
80764>>>                    Set Header_Label 0 to "Keyword"
80765>>>                    Set Status_Help Item 0 to "List of the available keywords"
80766>>>                    Set Line_Width to 1 0
80767>>>                    Set Form_Width 0 to 101
80768>>>                    Set GridLine_Mode to Grid_Visible_None
80769>>>                    Set peAnchors to anTopBottom
80770>>>
80770>>>                    Property String  psSepCharacter "\n"
80772>>>
80772>>>                    Procedure mMoveUp
80775>>>                        Integer iItem
80775>>>                        String sValue
80775>>>                        Get Current_Item to iItem
80776>>>                        Get Value Item iItem to sValue
80777>>>                        If ((iItem=Item_Count(Self) -1) and sValue = "") Begin
80779>>>                            Send mRemoveLine
80780>>>                        End
80780>>>>
80780>>>                        Else Begin
80781>>>                            Send Up
80782>>>                        End
80782>>>>
80782>>>                    End_Procedure
80783>>>
80783>>>                    Procedure mMoveDown
80786>>>                        Integer iItem
80786>>>                        String sValue
80786>>>                        Get Current_Item to iItem
80787>>>                        Get Value Item iItem to sValue
80788>>>                        If (sValue <> "") Begin
80790>>>                            If (iItem=Item_Count(Self) -1) Begin
80792>>>                                Send Add_New_Line "" 0
80793>>>                            End
80793>>>>
80793>>>                            Send Down
80794>>>                        End
80794>>>>
80794>>>                    End_Procedure
80795>>>
80795>>>                    Procedure OnChange Integer iItem  
80798>>>                        Integer iKeywords
80798>>>                        Delegate Send NotifyChange
80800>>>                        Get Item_Count to iKeywords
80801>>>                        Set Label of oKeywordsInfo_tb to ("Keywords:" * String(iKeywords))
80802>>>                    End_Procedure
80803>>>
80803>>>                    Procedure Add_New_Line String sKeyword Integer iColor
80806>>>                        Send Add_Item Msg_None sKeyword
80807>>>                        If (iColor) Begin
80809>>>                            Set ItemTextColor (Item_Count(Self) -1) to iColor
80810>>>                        End
80810>>>>
80810>>>                    End_Procedure
80811>>>
80811>>>                    Procedure mInsertLine
80814>>>                        Send Add_New_Line "" clRed
80815>>>                        Send onChange 0
80816>>>                        Send End_of_Data
80817>>>                    End_Procedure
80818>>>
80818>>>                    Procedure mRemoveLine
80821>>>                        Integer iRowBase
80821>>>                        If (Item_Count(Self) = 0) Begin
80823>>>                            Procedure_Return
80824>>>                        End
80824>>>>
80824>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
80825>>>                        Send Delete_Item iRowBase
80826>>>                        Send OnChange 0
80827>>>                    End_Procedure
80828>>>
80828>>>                    Function GetValue Integer iColumn Returns String
80831>>>                        Integer iC iColumns
80831>>>                        String  sRet sSep
80831>>>                        Move (Low(Matrix_Size(Self))) to iColumns
80832>>>                        Get psSepCharacter to sSep
80833>>>                        If (sSep = "") Begin
80835>>>                            Move "\n" to sSep
80836>>>                        End
80836>>>>
80836>>>                        For iC From 0 to (Item_Count(Self) -1)
80842>>>>
80842>>>                            If (Value(Self, iC + iColumn) <> "") Begin
80844>>>                                If (sRet <> "") Begin
80846>>>                                    Move (sRet + sSep) to sRet
80847>>>                                End
80847>>>>
80847>>>                                Move (sRet + Value(Self, iC + iColumn)) to sRet
80848>>>                            End
80848>>>>
80848>>>                            Move (iC + iColumns - 1) to iC
80849>>>                        Loop
80850>>>>
80850>>>                        Function_Return sRet
80851>>>                    End_Function
80852>>>
80852>>>                    Procedure DoLoad tSCLanguage ByRef ltSCLanguage
80855>>>                        Integer iKeyword iKeywords
80855>>>
80855>>>                        Send Delete_Data
80856>>>                        Move (SortArray(ltSCLanguage.saKeywords)) to ltSCLanguage.saKeywords
80857>>>                        Move (SizeOfArray(ltSCLanguage.saKeywords)) to iKeywords
80858>>>                        For iKeyword From 0 to (iKeywords - 1)
80864>>>>
80864>>>                            Send Add_New_Line ltSCLanguage.saKeywords[iKeyword] 0
80865>>>                        Loop
80866>>>>
80866>>>                        Set Label of oKeywordsInfo_tb to ("Keywords:" * String(iKeywords))
80867>>>                    End_Procedure
80868>>>
80868>>>                    On_Key Key_F2       Send Request_SaveAllEntries
80869>>>                    On_Key kCancel      Send Close_Panel
80870>>>                    On_Key kUpArrow     Send mMoveUp
80871>>>                    On_Key kDownArrow   Send mMoveDown
80872>>>                    On_Key Key_Tab      Send mMoveDown
80873>>>                End_Object
80874>>>
80874>>>                Object oKeywordsInfo_tb is a TextBox
80876>>>                    Set Auto_Size_State to False
80877>>>                    Set Size to 9 50
80878>>>                    Set Location to 174 195
80879>>>                    Set Label to "Keywords:"
80880>>>                    Set peAnchors to anBottomLeft
80881>>>                End_Object
80882>>>
80882>>>                Object oAddKeyword is a cRDCButtonDPI
80884>>>                    Set Size to 15 50
80885>>>                    Set Location to 185 195
80886>>>                    Set Label to "Add"
80887>>>                    Set psImage to "ActionAdd.ico"
80888>>>                    Set peAnchors to anBottomLeft
80889>>>                    Procedure OnClick
80892>>>                        Send mInsertLine to oKeywords
80893>>>                    End_Procedure
80894>>>                End_Object
80895>>>
80895>>>                Object oRemoveKeyword is a cRDCButtonDPI
80897>>>                    Set Size to 15 50
80898>>>                    Set Location to 185 248
80899>>>                    Set Label to "Remove"
80900>>>                    Set psImage to "Remove.ico"
80901>>>                    Set peAnchors to anBottomLeft
80902>>>                    Procedure OnClick
80905>>>                        Send mRemoveLine to oKeywords
80906>>>                    End_Procedure
80907>>>                End_Object
80908>>>
80908>>>                Object oLineControl2 is a LineControl
80910>>>                    Set Size to 164 3
80911>>>                    Set Location to 36 311
80912>>>                    Set Horizontal_State to False
80913>>>                    Set peAnchors to anTopBottom
80914>>>                End_Object
80915>>>
80915>>>                Object oOperators is a cSCWsGrid
80917>>>                    Set Size to 137 107
80918>>>                    Set Location to 35 316
80919>>>                    Set Header_Label 0 to "Operator"
80920>>>                    Set Status_Help Item 0 to "List of the available operators"
80921>>>                    Set Line_Width to 1 0
80922>>>                    Set Form_Width 0 to 96
80923>>>                    Set GridLine_Mode to Grid_Visible_None
80924>>>                    Set peAnchors to anTopBottom
80925>>>
80925>>>                    Property String psSepCharacter "\n"
80927>>>
80927>>>                    Procedure mMoveUp
80930>>>                        Integer iItem
80930>>>                        String sValue
80930>>>                        Get Current_Item to iItem
80931>>>                        Get Value Item iItem to sValue
80932>>>                        If ((iItem = Item_Count(Self) -1) and sValue = "") Begin
80934>>>                            Send mRemoveLine
80935>>>                        End
80935>>>>
80935>>>                        Else Begin
80936>>>                            Send Up
80937>>>                        End
80937>>>>
80937>>>                    End_Procedure
80938>>>
80938>>>                    Procedure mMoveDown
80941>>>                        Integer iItem
80941>>>                        String sValue
80941>>>                        Get Current_Item to iItem
80942>>>                        Get Value Item iItem to sValue
80943>>>                        If (sValue <> "") Begin
80945>>>                            If (iItem = Item_Count(Self) -1) Begin
80947>>>                                Send Add_New_Line "" 0
80948>>>                            End
80948>>>>
80948>>>                            Send Down
80949>>>                        End
80949>>>>
80949>>>                    End_Procedure
80950>>>
80950>>>                    Procedure OnChange Integer iItem
80953>>>                        Integer iOperators
80953>>>                        Delegate Send NotifyChange
80955>>>                        Get Item_Count to iOperators
80956>>>                        Set Label of oOperatorsInfo_tb to ("Operators:" * String(iOperators))
80957>>>                    End_Procedure
80958>>>
80958>>>                    Procedure Add_New_Line String sOperator Integer iColor
80961>>>                        Send Add_Item Msg_None sOperator
80962>>>                        If (iColor) Begin
80964>>>                            Set ItemTextColor (Item_Count(Self) -1) to iColor
80965>>>                        End
80965>>>>
80965>>>                    End_Procedure
80966>>>
80966>>>                    Procedure mInsertLine
80969>>>                        Send Add_New_Line "" clRed
80970>>>                        Send onChange 0
80971>>>                        Send End_of_Data
80972>>>                    End_Procedure
80973>>>
80973>>>                    Procedure mRemoveLine
80976>>>                        Integer iRowBase
80976>>>                        If (Item_Count(Self) = 0) Begin
80978>>>                            Procedure_Return
80979>>>                        End
80979>>>>
80979>>>                        Get Base_Row_Item (Current_Item(Self)) to iRowBase
80980>>>                        Send Delete_Item iRowBase
80981>>>                        Send OnChange 0
80982>>>                    End_Procedure
80983>>>
80983>>>                    Function GetValue Integer iColumn Returns String
80986>>>                        Integer iC iColumns
80986>>>                        String  sRet sSep
80986>>>
80986>>>                        Move (Low(Matrix_Size(Self))) to iColumns
80987>>>                        Get psSepCharacter to sSep
80988>>>                        If (sSep = "") Begin
80990>>>                            Move "\n" to sSep
80991>>>                        End
80991>>>>
80991>>>                        For iC From 0 to (Item_Count(Self) -1)
80997>>>>
80997>>>                            If (Value(Self, iC + iColumn) <> "") Begin
80999>>>                                If (sRet <> "") Begin
81001>>>                                    Move (sRet + sSep) to sRet
81002>>>                                End
81002>>>>
81002>>>                                Move (sRet + Value(Self, iC + iColumn)) to sRet
81003>>>                            End
81003>>>>
81003>>>                            Move (iC + iColumns - 1) to iC
81004>>>                        Loop
81005>>>>
81005>>>                        Function_Return sRet
81006>>>                    End_Function
81007>>>
81007>>>                    Procedure DoLoad tSCLanguage ByRef ltSCLanguage
81010>>>                        Integer iOperator iOperators
81010>>>                        Send Delete_Data
81011>>>                        Move (SortArray(ltSCLanguage.saOperators)) to ltSCLanguage.saOperators
81012>>>                        Move (SizeOfArray(ltSCLanguage.saOperators)) to iOperators
81013>>>                        For iOperator From 0 to (iOperators -1)
81019>>>>
81019>>>                            Send Add_New_Line ltSCLanguage.saOperators[iOperator] 0
81020>>>                        Loop
81021>>>>
81021>>>                        Set Label of oOperatorsInfo_tb to ("Operators:" * String(iOperators))
81022>>>                    End_Procedure
81023>>>
81023>>>                    On_Key key_F2       Send Request_SaveAllEntries
81024>>>                    On_Key kCancel      Send Close_Panel
81025>>>                    On_Key kUpArrow     Send mMoveUp
81026>>>                    On_Key kDownArrow   Send mMoveDown
81027>>>                    On_Key Key_Tab      Send mMoveDown
81028>>>                End_Object
81029>>>
81029>>>                Object oOperatorsInfo_tb is a TextBox
81031>>>                    Set Auto_Size_State to False
81032>>>                    Set Size to 9 50
81033>>>                    Set Location to 174 316
81034>>>                    Set Label to "Operators:"
81035>>>                    Set peAnchors to anBottomLeft
81036>>>                End_Object
81037>>>
81037>>>                Object oAddOperator is a cRDCButtonDPI
81039>>>                    Set Size to 15 50
81040>>>                    Set Location to 185 316
81041>>>                    Set Label to "Add"
81042>>>                    Set psImage to "ActionAdd.ico"
81043>>>                    Set peAnchors to anBottomLeft
81044>>>                    Procedure OnClick
81047>>>                        Send mInsertLine to oOperators
81048>>>                    End_Procedure
81049>>>                End_Object
81050>>>
81050>>>                Object oRemoveOperator is a cRDCButtonDPI
81052>>>                    Set Size to 15 50
81053>>>                    Set Location to 185 369
81054>>>                    Set Label to "Remove"
81055>>>                    Set psImage to "Remove.ico"
81056>>>                    Set peAnchors to anBottomLeft
81057>>>                    Procedure OnClick
81060>>>                        Send mRemoveLine to oOperators
81061>>>                    End_Procedure
81062>>>                End_Object
81063>>>
81063>>>                // Fill lists
81063>>>                Procedure End_Construct_Object
81066>>>                    String sLanguage
81066>>>                    Integer iC
81066>>>
81066>>>                    Forward Send End_Construct_Object
81068>>>                    Move "VDF" to sLanguage
81069>>>                    Get FindLanguage of ghoEditorProperties sLanguage to iC
81070>>>                    If (iC >= 0) Begin
81072>>>                        Send LoadEntries iC
81073>>>                    End
81073>>>>
81073>>>                    Else Begin
81074>>>                        Send ClearEntries
81075>>>                    End
81075>>>>
81075>>>
81075>>>                End_Procedure
81076>>>
81076>>>                Procedure LoadEntries Integer iC
81079>>>                    tSCLanguage tSCLanguage
81079>>>                    tSCLanguage tSCLanguage
81079>>>
81079>>>                    Get psLanguages.dwStyle                 of ghoEditorProperties iC to tSCLanguage.iProcedural
81080>>>                    Get psLanguages.bIsCaseSensitive        of ghoEditorProperties iC to tSCLanguage.iCaseSensitive
81081>>>                    Get psLanguages.szStringDelims          of ghoEditorProperties iC to tSCLanguage.sStringDelimiter
81082>>>                    Get psLanguages.chEscape                of ghoEditorProperties iC to tSCLanguage.sEscapeChar
81083>>>                    Get psLanguages.chTerminator            of ghoEditorProperties iC to tSCLanguage.sLineTerminationChar
81084>>>                    Get psLanguages.szSingleLineComments    of ghoEditorProperties iC to tSCLanguage.sLineComments
81085>>>                    Get psLanguages.szMultiLineComments1    of ghoEditorProperties iC to tSCLanguage.sMultiLineCommentStart
81086>>>                    Get psLanguages.szMultiLineComments2    of ghoEditorProperties iC to tSCLanguage.sMultiLineCommentStop
81087>>>
81087>>>                    Send LoadElementString (psLanguages.szScopeKeywords1(ghoEditorProperties,iC))       "\n" (&tSCLanguage.saScopeStart)
81088>>>                    Send LoadElementString (psLanguages.szScopeKeywords2(ghoEditorProperties,iC))       "\n" (&tSCLanguage.saScopeStop)
81089>>>                    Send LoadElementString (psLanguages.szKeywords(ghoEditorProperties,iC))             "\n" (&tSCLanguage.saKeywords)
81090>>>                    Send LoadElementString (psLanguages.szOperators(ghoEditorProperties,iC))            "\n" (&tSCLanguage.saOperators)
81091>>>
81091>>>                    Send LoadElementString (psLanguages.pszTagElementNames(ghoEditorProperties,iC))     "\n" (&tSCLanguage.saTags)
81092>>>                    Send LoadElementString (psLanguages.pszTagAttributeNames(ghoEditorProperties,iC))   "\n" (&tSCLanguage.saAttributes)
81093>>>                    Send LoadElementString (psLanguages.pszTagEntities(ghoEditorProperties,iC))         "\n" (&tSCLanguage.saEntities)
81094>>>
81094>>>                    Send DoLoad to oScopes      (&tSCLanguage)
81095>>>                    Send DoLoad to oKeywords    (&tSCLanguage)
81096>>>                    Send DoLoad to oOperators   (&tSCLanguage)
81097>>>                End_Procedure
81098>>>
81098>>>                Procedure SaveEntries
81101>>>                    Integer iC
81101>>>                    String  sName
81101>>>
81101>>>                    Move "VDF" to sName
81102>>>                    Get FindLanguage                 of ghoEditorProperties sName   to iC
81103>>>                    If (iC < 0) Begin
81105>>>                        Get psLanguages.Count       of ghoEditorProperties         to iC
81106>>>                    End
81106>>>>
81106>>>                    Set psLanguages                  of ghoEditorProperties Item iC to sName
81107>>>
81107>>>                    Set psLanguages.szScopeKeywords1 of ghoEditorProperties Item iC to (GetValue(oScopes(Self), 0))
81108>>>                    Set psLanguages.szScopeKeywords2 of ghoEditorProperties Item iC to (GetValue(oScopes(Self), 1))
81109>>>                    Set psLanguages.szKeywords       of ghoEditorProperties Item iC to (GetValue(oKeywords(Self), 0))
81110>>>                    Set psLanguages.szOperators      of ghoEditorProperties Item iC to (GetValue(oOperators(Self), 0))
81111>>>
81111>>>                    Send RegisterLanguage to ghoEditorProperties iC
81112>>>                End_Procedure
81113>>>
81113>>>                Procedure ClearEntries
81116>>>                    Send Delete_Data    to oScopes
81117>>>                    Send Delete_Data    to oKeywords
81118>>>                    Send Delete_Data    to oOperators
81119>>>                End_Procedure
81120>>>
81120>>>                Procedure LoadElementString String sElement String sSeparator String[] ByRef saElements
81123>>>                    Integer iC iItem
81123>>>                    Handle hoParser
81123>>>
81123>>>                    Get Create (RefClass(cLineParser)) to hoParser
81124>>>                    Set psSepCharacter of hoParser to sSeparator
81125>>>                    Send ParseLine     to hoParser sElement
81126>>>                    For iC From 0 to (Item_Count(hoParser) -1)
81132>>>>
81132>>>                        Move (SizeOfArray(saElements)) to iItem
81133>>>                        Get Value of hoParser Item iC to saElements[iItem]
81134>>>                    Loop
81135>>>>
81135>>>                    Send Destroy_Object to hoParser
81136>>>                End_Procedure
81137>>>
81137>>>            End_Object
81138>>>
81138>>>        End_Object
81139>>>
81139>>>        Object oKeyboardPage is a TabPage
81141>>>            Set Label to "Keyboard"
81142>>>            Set piImageIndex to 2
81143>>>
81143>>>            Object oHotKeysGroup is a cRDCHeaderGroup
81145>>>                Set Size to 206 428
81146>>>                Set Location to 5 4
81147>>>                Set peAnchors to anAll
81148>>>                Set psImage to "Keyboard.ico"
81149>>>                Set Label to "Keyboard Key Assignments"
81150>>>                Set psNote to "Assign keyboard shortcuts to commands"
81151>>>
81151>>>                Property Integer piCurrentCommand 0 // command we can customize
81153>>>
81153>>>                Object oCommands is a TreeView
81155>>>                    Set Size to 143 126
81156>>>                    Set Location to 53 10
81157>>>                    Set Label_Justification_Mode to JMode_Top
81158>>>                    Set Label_Col_Offset to 2
81159>>>                    Set pbFullRowSelect to True
81160>>>                    Set piTextColor to clBlack
81161>>>                    Set pbExplorerStyle to True
81162>>>
81162>>>                    Property String psCurrentLanguage ""
81164>>>
81164>>>                    Set peAnchors to anTopBottom
81165>>>
81165>>>                    Procedure DoBuildList String sFilter
81168>>>                        Handle hItem
81168>>>                        Integer iItem
81168>>>                        Integer iCount
81168>>>                        tSciCommandHotKey[] ltCommands
81168>>>                        tSciCommandHotKey[] ltCommands
81169>>>
81169>>>                        Set Dynamic_Update_State to False
81170>>>                        Send ClearAll
81171>>>                        Move (Trim(Uppercase(sFilter))) to sFilter
81172>>>                        Send SortByCommandName of oSciCommandHotKeys
81173>>>                        Get pCommands of oSciCommandHotKeys to ltCommands
81174>>>                        Move (SizeOfArray(ltCommands)) to iCount
81175>>>                        For iItem From 0 to (iCount-1)
81181>>>>
81181>>>                            If ((sFilter="")or(Uppercase(ltCommands[iItem].sName) contains sFilter)) ;                            Get AddTreeItem ltCommands[iItem].sName 0 ltCommands[iItem].iCmd 0 0 to hItem
81184>>>                        Loop
81185>>>>
81185>>>                        Set Dynamic_Update_State to True
81186>>>                    End_Procedure
81187>>>
81187>>>                    Procedure OnCreateTree
81190>>>                        Send DoBuildList ""
81191>>>                    End_Procedure
81192>>>
81192>>>                    Procedure OnItemChanged Handle hItem Handle hItemOld
81195>>>                        Integer iCmd
81195>>>                        Get ItemData hItem to iCmd
81196>>>                        Set piCurrentCommand to iCmd
81197>>>                        Send DisplayCommandDetails
81198>>>                        Send ClearKey of oNewKey
81199>>>                    End_Procedure
81200>>>
81200>>>                    On_Key Key_Up_Arrow Send Up
81201>>>                    On_Key Key_Down_Arrow Send Down
81202>>>                End_Object
81203>>>
81203>>>                Object oCurrentShortcut is a Form
81205>>>                    Set Size to 13 200
81206>>>                    Set Location to 53 146
81207>>>                    Set Label to "Current Shortcut:"
81208>>>                    Set Label_Justification_Mode to JMode_Top
81209>>>                    Set Label_Col_Offset to 0
81210>>>                    Set Enabled_State to False
81211>>>                    Set Label_Row_Offset to 1
81212>>>                End_Object
81213>>>
81213>>>                Object oNewKey is a Form
81215>>>                    Set Size to 13 200
81216>>>                    Set Location to 91 146
81217>>>                    Set Label to "New Key Assignment:"
81218>>>                    Set Label_Justification_Mode to JMode_Top
81219>>>                    Set Label_Col_Offset to 0
81220>>>                    Set psToolTip to "Type your key assignment in this field"
81221>>>                    Set Label_Row_Offset to  1
81222>>>
81222>>>                    Property tShortCut pNewShortCut
81224>>>
81224>>>                    Procedure Key Integer iKeyValue Returns Integer
81227>>>                        Integer iRetval
81227>>>                        String  sShortCut
81227>>>                        Integer[] Keys
81228>>>                        tShortCut NewShortCut
81228>>>                        tShortCut NewShortCut
81228>>>                        Move "" to sShortCut
81229>>>                        Get ReadKeyboardState   of oSciCommandHotKeys to Keys
81230>>>                        Get KeysToString        of oSciCommandHotKeys Keys to sShortCut
81231>>>                        Set Value               of oNewShortcut to sShortCut
81232>>>                        Move iKeyValue          to NewShortCut.iDFKey
81233>>>                        Move Keys               to NewShortCut.VKcode
81234>>>                        Set pNewShortCut        to NewShortCut
81235>>>                        Send DispatchAnyKey
81236>>>                        Procedure_Return iRetVal
81237>>>                    End_Procedure
81238>>>
81238>>>                    Procedure ClearKey
81241>>>                        tShortCut EmptyShortCut
81241>>>                        tShortCut EmptyShortCut
81241>>>                        Set Value to ""
81242>>>                        Set Value of oNewShortCut to ""
81243>>>                        Set pNewShortCut to EmptyShortCut
81244>>>                    End_Procedure
81245>>>
81245>>>                    On_Key Key_F1            Send Default_Key
81246>>>                    On_Key Key_F4            Send Default_Key
81247>>>                    On_Key Key_F6            Send Default_Key
81248>>>                    On_Key Key_F10           Send Default_Key  // <-- clear does not work but not forwarding msg_key helps :)
81249>>>                    On_Key Key_Shift+Key_F4  Send Default_Key
81250>>>                    On_Key Key_Shift+Key_F5  Send Default_Key
81251>>>                    On_Key Key_Shift+Key_F6  Send Default_Key
81252>>>                    On_Key Key_Shift+Key_F10 Send Default_Key
81253>>>                    On_Key Key_Ctrl+Key_F4   Send Default_Key
81254>>>                    On_Key Key_Ctrl+Key_F6   Send Default_Key
81255>>>                    On_Key Key_Alt+Key_F4    Send Default_Key
81256>>>                    On_Key Key_Alt+Key_F6    Send Default_Key
81257>>>                    On_Key Key_Alt+Key_C     Send Default_Key
81258>>>                    On_Key Key_Alt+Key_O     Send Default_Key
81259>>>                    On_Key kEnter            Send Default_Key
81260>>>                    On_Key kNext_Item        Send Default_Key
81261>>>                    On_Key kPrevious_Item    Send Default_Key
81262>>>                    On_Key Key_Ctrl+Key_Tab  Send Default_Key
81263>>>                End_Object
81264>>>
81264>>>                Object oNewShortcut is a Form
81266>>>                    Set Size to 13 200
81267>>>                    Set Location to 120 146
81268>>>                    Set Label to "New Shortcut:"
81269>>>                    Set Label_Justification_Mode to JMode_Top
81270>>>                    Set Label_Col_Offset to 0
81271>>>                    Set Enabled_State to False
81272>>>                    Set Label_Row_Offset to 1
81273>>>                End_Object
81274>>>
81274>>>                Object oAssign is a cRDCButtonDPI
81276>>>                    Set Location to 90 359
81277>>>                    Set Label to "Assign"
81278>>>                    Set psImage to "Assign.ico"
81279>>>                    Procedure OnClick
81282>>>                        Integer iCmd
81282>>>                        tShortCut ShortCut
81282>>>                        tShortCut ShortCut
81282>>>                        Get piCurrentCommand to iCmd
81283>>>                        Get pNewShortCut of oNewKey to ShortCut
81284>>>                        If (iCmd<>0 and SizeOfArray(ShortCut.VKcode)>0) Begin
81286>>>                            Send AssignShortCutToCmd of oSciCommandHotKeys iCmd ShortCut
81287>>>                            Send DisplayCommandDetails
81288>>>                            Send Activate to oNewKey
81289>>>                            Delegate Send NotifyChange
81291>>>                        End
81291>>>>
81291>>>                    End_Procedure
81292>>>                End_Object
81293>>>
81293>>>                Object oRemove is a cRDCButtonDPI
81295>>>                    Set Location to 107 359
81296>>>                    Set Label to "Remove"
81297>>>                    Set psImage to "Remove.ico"
81298>>>                    Procedure OnClick
81301>>>                        Integer iCmd
81301>>>                        Get piCurrentCommand to iCmd
81302>>>                        If (iCmd<>0) Begin
81304>>>                            Send RemoveShortCutFromCmd of oSciCommandHotKeys iCmd
81305>>>                            Send DisplayCommandDetails
81306>>>                            Send Activate to oNewKey
81307>>>                            Delegate Send NotifyChange
81309>>>                        End
81309>>>>
81309>>>                    End_Procedure
81310>>>                End_Object
81311>>>
81311>>>                Object oCommandHelpTb is a cTextEdit
81313>>>                    Set Size to 40 200
81314>>>                    Set Location to 155 146
81315>>>                    Set Enabled_State to False
81316>>>                    Set Label to "Description:"
81317>>>                    Set peAnchors to anTopBottom
81318>>>                End_Object
81319>>>
81319>>>                Object oSearch is a Form
81321>>>                    Set Size to 11 126
81322>>>                    Set Location to 41 10
81323>>>                    Set Label to "Command:"
81324>>>                    Set Label_Col_Offset to 0
81325>>>                    Set Label_Row_Offset to 1
81326>>>                    Set Label_Justification_Mode to JMode_Top
81327>>>
81327>>>                    Procedure OnChange
81330>>>                        String sValue
81330>>>                        Get Value to sValue
81331>>>                        Set Color to clWindow
81332>>>                        If (sValue <> "") Begin
81334>>>                            Set Color to (RGB(255,200,200))
81335>>>                        End
81335>>>>
81335>>>                        Send DoBuildList to oCommands sValue
81336>>>                    End_Procedure
81337>>>
81337>>>                    On_Key Key_Down_Arrow Send Activate to oCommands
81338>>>                    On_Key Key_Tab        Send Activate to oCommands
81339>>>                End_Object
81340>>>
81340>>>                Procedure DisplayCommandDetails
81343>>>                    Boolean bHasHotKey
81343>>>                    Integer iCmd
81343>>>                    String  sDescription
81343>>>                    String  sShortCut
81343>>>                    tSciCommandHotKey Command
81343>>>                    tSciCommandHotKey Command
81343>>>
81343>>>                    Move "" to sDescription
81344>>>                    Send Delete_Data of oCommandHelpTb
81345>>>                    Set Value of oCurrentShortcut to ""
81346>>>
81346>>>                    Get piCurrentCommand to iCmd
81347>>>                    If (iCmd <> 0) Begin
81349>>>                        Get FindCommand of oSciCommandHotKeys iCmd to Command
81350>>>                        If (Command.iCmd = iCmd) Begin
81352>>>                            Send AppendTextLn of oCommandHelpTb Command.sDescription
81353>>>                        End
81353>>>>
81353>>>                        Get CommandHasHotKey of oSciCommandHotKeys Command to bHasHotKey
81354>>>                        If (bHasHotKey) Begin
81356>>>                            Get CommandHotKeyString of oSciCommandHotKeys Command to sShortCut
81357>>>                            Set Value of oCurrentShortCut to sShortCut
81358>>>                        End
81358>>>>
81358>>>                    End
81358>>>>
81358>>>                End_Procedure
81359>>>
81359>>>            End_Object
81360>>>
81360>>>        End_Object
81361>>>
81361>>>        Object oOptionsPage is a TabPage
81363>>>            Set Label to "Misc"
81364>>>            Set piImageIndex to 3
81365>>>
81365>>>            Object oOptionsGrp is a cRDCHeaderGroup
81367>>>                Set Size to 206 428
81368>>>                Set Location to 5 4
81369>>>                Set peAnchors to anAll
81370>>>                Set Label to "Other Editor Settings"
81371>>>                Set psNote to "Miscellaneous editor settings"
81372>>>                Set psImage to "SettingsEditor.ico"
81373>>>
81373>>>                Object oLineNumbers is a cSCNotifierCheckBox
81375>>>                    Set Size to 10 50
81376>>>                    Set Location to 37 28
81377>>>                    Set Label to "Show line numbers"
81378>>>                    Set psToolTip to "Show line numbers in the leftmost column of the editor"
81379>>>                End_Object
81380>>>
81380>>>                Object oScopeMargin is a cSCNotifierCheckBox
81382>>>                    Set Size to 10 50
81383>>>                    Set Location to 48 28
81384>>>                    Set Label to "Show scope blocks margin"
81385>>>                    Set psToolTip to "Show scope blocks margin in the editor"
81386>>>                End_Object
81387>>>
81387>>>                Object oIndent is a cSCNotifierCheckBox
81389>>>                    Set Size to 10 50
81390>>>                    Set Location to 59 28
81391>>>                    Set Label to "Auto indent"
81392>>>                    Set psToolTip to "Apply auto indentation to inserted code"
81393>>>                End_Object
81394>>>
81394>>>                Object oGuides is a cSCNotifierCheckBox
81396>>>                    Set Size to 10 50
81397>>>                    Set Location to 70 28
81398>>>                    Set Label to "Show indentation guides"
81399>>>                    Set psToolTip to "Connect indentations with vertical lines to easier see which indentations belongs together"
81400>>>                End_Object
81401>>>
81401>>>                Object oSelect is a cSCNotifierCheckBox
81403>>>                    Set Size to 10 50
81404>>>                    Set Location to 81 28
81405>>>                    Set Label to "Highlight whole line on selection"
81406>>>                    Set psToolTip to "Highlight the whole line when selected"
81407>>>                End_Object
81408>>>
81408>>>                Object oTabs is a cSCNotifierCheckBox
81410>>>                    Set Size to 10 50
81411>>>                    Set Location to 93 28
81412>>>                    Set Label to "Convert tabs to spaces"
81413>>>                    Set psToolTip to "Change tab character to spaces when indenting code"
81414>>>                End_Object
81415>>>
81415>>>                Object oAdjustCase is a cSCNotifierCheckBox
81417>>>                    Set Size to 10 50
81418>>>                    Set Location to 104 28
81419>>>                    Set Label to "Adjust text case of typed keywords"
81420>>>                    Set psToolTip to "Automatically adjust the casing of key words as they are typed"
81421>>>                End_Object
81422>>>
81422>>>                Object oTrimEOLonSave is a cSCNotifierCheckBox
81424>>>                    Set Size to 10 50
81425>>>                    Set Location to 115 28
81426>>>                    Set Label to "Trim EOL on save"
81427>>>                    Set psToolTip to "Remove and trailing line spaces when the file is saved"
81428>>>                End_Object
81429>>>
81429>>>                Object oBraces is a cSCNotifierCheckBox
81431>>>                    Set Size to 10 50
81432>>>                    Set Location to 126 28
81433>>>                    Set Label to "Show matching braces"
81434>>>                    Set psToolTip to "Highlight matching braces"
81435>>>                End_Object
81436>>>
81436>>>                Object oTabSize is a cNotifierSpinForm
81438>>>                    Set Size to 13 30
81439>>>                    Set Location to 37 225
81440>>>                    Set Status_Help to "Number of spaces to replace TAB character"
81441>>>                    Set psToolTip to "The number of spaces to use when indenting code"
81442>>>                    Set Label to "Tab size:"
81443>>>                End_Object
81444>>>
81444>>>            End_Object
81445>>>
81445>>>        End_Object
81446>>>
81446>>>    End_Object
81447>>>
81447>>>    Procedure SaveEntries
81450>>>        Integer iC
81450>>>        String  sHotKey
81450>>>        String  sColors
81450>>>        String  sFontFace
81450>>>        String  sFontStyles
81450>>>        String  sSchemaName
81450>>>
81450>>>        Get psColors of ghoEditorProperties to sColors
81451>>>        // Re-format to support Scintilla
81451>>>        If (Length(sColors)=CM_COLORS_STRSIZE) ;        Move (sColors + Repeat('0', SC_COLORS_STRSIZE-CM_COLORS_STRSIZE)) to sColors
81454>>>        Get CurrentColors           to sColors
81455>>>        Get CurrentFontStyles       to sFontStyles
81456>>>        Get Value of oSchemaSelect  to sSchemaName
81457>>>        If (sSchemaName<>"") Begin
81459>>>            If ((sSchemaName<>TH_DEFSCHEMA_BLACK_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_WHITE_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_BLUE_STR)  and ;            (sSchemaName<>TH_DEFSCHEMA_SERENE_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_SAHARA_STR) and ;            (sSchemaName<>TH_DEFSCHEMA_LIME_STR)) Begin
81461>>>                Get FindColorSchema of ghoEditorProperties sSchemaName to iC
81462>>>                If (iC<0) Begin
81464>>>                    Get psColorSchemas.Count           of ghoEditorProperties to iC
81465>>>                End
81465>>>>
81465>>>                Set psColorSchemas                     of ghoEditorProperties Item iC  to sSchemaName
81466>>>                Set psColorSchemas.psSchemaColors      of ghoEditorProperties Item iC  to sColors
81467>>>                Set psColorSchemas.psSchemaFontStyles  of ghoEditorProperties Item iC  to sFontStyles
81468>>>            End
81468>>>>
81468>>>            Set psColorSchema  of ghoEditorProperties  to sSchemaName
81469>>>            Set psColors       of ghoEditorProperties  to sColors
81470>>>            Set psFontStyles   of ghoEditorProperties  to sFontStyles
81471>>>        End
81471>>>>
81471>>>
81471>>>        // Font
81471>>>        Get psEditorFont of oFontFace   to sFontFace
81472>>>        If (sFontFace = "") Begin
81474>>>            Move "11pt; 0; Courier New" to sFontFace
81475>>>        End
81475>>>>
81475>>>        Set psFontFace             of ghoEditorProperties to sFontFace
81476>>>
81476>>>        Set piLineNumbering        of ghoEditorProperties to (Checked_State(oLineNumbers(Self)))
81477>>>        Set pbLeftMargin           of ghoEditorProperties to (Checked_State(oScopeMargin(Self)))
81478>>>        Set piAutoIndentMode       of ghoEditorProperties to (Checked_State(oIndent(Self)))
81479>>>        Set pbShowMatchingBraces   of ghoEditorProperties to (Checked_State(oBraces(Self)))
81480>>>        Set pbShowIndentGuides     of ghoEditorProperties to (Checked_State(oGuides(Self)))
81481>>>        Set pbSelectWholeLine      of ghoEditorProperties to (Checked_State(oSelect(Self)))
81482>>>        Set pbTabExpand            of ghoEditorProperties to (Checked_State(oTabs(Self)))
81483>>>        Set piTabSize              of ghoEditorProperties to (Value(oTabSize(Self),0))
81484>>>        Set pbNormalizeCase        of ghoEditorProperties to (Checked_State(oAdjustCase(Self)))
81485>>>        Set pbTrimEOLOnSave        of ghoEditorProperties to (Checked_State(oTrimEOLonSave(Self)))
81486>>>
81486>>>        Get ShortCutKeyDefinitions of oSciCommandHotKeys  to sHotKey
81487>>>        Set psEditorHotKeys        of ghoEditorProperties to sHotKey
81488>>>
81488>>>    End_Procedure
81489>>>
81489>>>    Procedure LoadEntries
81492>>>        String sFontFace
81492>>>
81492>>>        Get psFontFace of ghoEditorProperties to sFontFace
81493>>>        If (sFontFace="") Begin
81495>>>            Move "11pt; 0; Courier New"       to sFontFace
81496>>>        End
81496>>>>
81496>>>        Set psEditorFont   of oFontFace       to sFontFace
81497>>>
81497>>>        Set Value          of oTabSize        to (piTabSize(ghoEditorProperties))
81498>>>        Set Checked_State  of oLineNumbers    to (piLineNumbering(ghoEditorProperties))
81499>>>        Set Checked_State  of oScopeMargin    to (pbLeftMargin(ghoEditorProperties))
81500>>>        Set Checked_State  of oIndent         to (piAutoIndentMode(ghoEditorProperties))
81501>>>        Set Checked_State  of oBraces         to (pbShowMatchingBraces(ghoEditorProperties))
81502>>>        Set Checked_State  of oGuides         to (pbShowIndentGuides(ghoEditorProperties))
81503>>>        Set Checked_State  of oSelect         to (pbSelectWholeLine(ghoEditorProperties))
81504>>>        Set Checked_State  of oTabs           to (pbTabExpand(ghoEditorProperties))
81505>>>        Set Checked_State  of oAdjustCase     to (pbNormalizeCase(ghoEditorProperties))
81506>>>        Set Checked_State  of oTrimEOLonSave  to (pbTrimEOLOnSave(ghoEditorProperties))
81507>>>
81507>>>    End_Procedure
81508>>>
81508>>>    Procedure NotifyChange
81511>>>        Set Enabled_State of oSave to True
81512>>>    End_Procedure
81513>>>
81513>>>    Procedure Request_SaveAllEntries
81516>>>        If (Enabled_State(oSave(Self))) Begin
81518>>>            Send SaveAllEntries
81519>>>        End
81519>>>>
81519>>>    End_Procedure
81520>>>
81520>>>    Procedure ApplyToEditor
81523>>>        Handle hClientArea hView
81523>>>        Get Client_Id to hClientArea
81524>>>        Get Next_Mdi_Dialog of hClientArea True to hView // find first view
81525>>>        While (hView <> 0)
81529>>>            If (Active_State(hView)) Begin
81531>>>                // create the action
81531>>>                Broadcast Send SetAdjustments     to hView
81533>>>                Broadcast Send ApplyEditorOptions to hView
81535>>>                Broadcast Send OnPropsChange      to hView
81537>>>            End
81537>>>>
81537>>>            Get Next_Mdi_Dialog of hClientArea False to hView // find next
81538>>>        Loop
81539>>>>
81539>>>    End_Procedure
81540>>>
81540>>>    Procedure SaveAllEntries
81543>>>        Send SaveEntries of oFontsPage
81544>>>        Send SaveEntries of oOptionsPage
81545>>>        Send SaveEntries of oLanguageGroup
81546>>>        Send SaveEntries of oKeyboardPage
81547>>>        Send SaveEntries
81548>>>        Send SaveIni to ghoEditorProperties
81549>>>
81549>>>        If (Focus(Desktop) = oSave(Self)) Begin
81551>>>            Send Activate to oClose
81552>>>        End
81552>>>>
81552>>>        Send ApplyToEditor
81553>>>        Set Enabled_State of oSave to False
81554>>>    End_Procedure
81555>>>
81555>>>    Object oSave is a cRDCButtonDPI
81557>>>        Set Label to "Save"
81558>>>        Set Location to 236 340
81559>>>        Set peAnchors to anBottomRight
81560>>>        Set Enabled_State to False
81561>>>        Set psImage to "ActionSaveRecord.ico"
81562>>>        Procedure OnClick
81565>>>            Send SaveAllEntries
81566>>>        End_Procedure
81567>>>    End_Object
81568>>>
81568>>>    Object oClose is a cRDCButtonDPI
81570>>>        Set Label to "Close"
81571>>>        Set Location to 236 393
81572>>>        Set peAnchors to anBottomRight
81573>>>        Procedure OnClick
81576>>>            Send Close_Panel
81577>>>        End_Procedure
81578>>>    End_Object
81579>>>
81579>>>    Procedure Popup
81582>>>        Send LoadEntries
81583>>>        Set Enabled_State of oSave to False
81584>>>        Forward Send Popup
81586>>>    End_Procedure
81587>>>
81587>>>    On_Key Key_Alt+Key_O Send KeyAction of oSave
81588>>>    On_Key Key_Alt+Key_C Send KeyAction of oClose
81589>>>    On_Key Key_Escape    Send KeyAction of oClose
81590>>>End_Object
81591>        Use RefactorTestingFunctionTable.vw
Including file: RefactorTestingFunctionTable.vw    (C:\Projects\DF18\DfRefactor\AppSrc\RefactorTestingFunctionTable.vw)
81591>>>Use Windows.pkg
81591>>>Use cDbSplitterContainer.pkg
Including file: cDbSplitterContainer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cDbSplitterContainer.pkg)
81591>>>>>Use Windows.Pkg
81591>>>>>Use Dfclient.pkg
81591>>>>>Use cSplitterContainerMixin.pkg
Including file: cSplitterContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cSplitterContainerMixin.pkg)
81591>>>>>>>// contains mixin support for SplitterContainer and SplitterContainerChild classes. This is required
81591>>>>>>>// because we support the non-db (cSplitterContainer / cSplitterContainerChild) and the
81591>>>>>>>// db ( cDbSplitterContainer / cDbSplitterContainerChild) classes/
81591>>>>>>>
81591>>>>>>>Use Windows.Pkg
81591>>>>>>>Use cSplitter.pkg
Including file: cSplitter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cSplitter.pkg)
81591>>>>>>>>>Use Windows.pkg
81591>>>>>>>>>
81591>>>>>>>>>Define R2_BLACK       for |CI1   //  0
81591>>>>>>>>>Define R2_NOTMERGEPEN for |CI2   // DPon
81591>>>>>>>>>Define R2_MASKNOTPEN  for |CI3   // DPna
81591>>>>>>>>>Define R2_NOTCOPYPEN  for |CI4   // PN
81591>>>>>>>>>Define R2_MASKPENNOT  for |CI5   // PDna
81591>>>>>>>>>Define R2_NOT         for |CI6   // Dn
81591>>>>>>>>>Define R2_XORPEN      for |CI7   // DPx
81591>>>>>>>>>Define R2_NOTMASKPEN  for |CI8   // DPan
81591>>>>>>>>>Define R2_MASKPEN     for |CI9   // DPa
81591>>>>>>>>>Define R2_NOTXORPEN   for |CI10  // DPxn
81591>>>>>>>>>Define R2_NOP         for |CI11  // D
81591>>>>>>>>>Define R2_MERGENOTPEN for |CI12  // DPno
81591>>>>>>>>>Define R2_COPYPEN     for |CI13  // P
81591>>>>>>>>>Define R2_MERGEPENNOT for |CI14  // PDno
81591>>>>>>>>>Define R2_MERGEPEN    for |CI15  // DPo
81591>>>>>>>>>Define R2_WHITE       for |CI16  //  1
81591>>>>>>>>>Define R2_LAST        for |CI16
81591>>>>>>>>>
81591>>>>>>>>>Class cAbstractSplitter is a DFBaseControl
81592>>>>>>>>>    
81592>>>>>>>>>    
81592>>>>>>>>>    Procedure Construct_Object
81594>>>>>>>>>        Forward Send Construct_Object
81596>>>>>>>>>        
81596>>>>>>>>>        Property Boolean pbSplitVertical False
81597>>>>>>>>>        Property Integer piMinLocation 20
81598>>>>>>>>>        Property Integer piMaxLocation 20
81599>>>>>>>>>        Property Integer piLastLocation 0
81600>>>>>>>>>        Property Integer piMinTrack
81601>>>>>>>>>        Property Integer piMaxTrack
81602>>>>>>>>>        
81602>>>>>>>>>        Set Color to clBtnFace
81603>>>>>>>>>        Set Skip_state to True              // this tells switch/switch back to not try to give this the focus
81604>>>>>>>>>        Set Focus_Mode to NonFocusable      // is paged as part of client activation but never gets the focus
81605>>>>>>>>>        
81605>>>>>>>>>        // class name and external messages must be defined in the sub-class
81605>>>>>>>>>    End_Procedure
81606>>>>>>>>>    
81606>>>>>>>>>    Procedure DrawDrag Integer iPos
81608>>>>>>>>>        Integer iLastY iLastX
81608>>>>>>>>>        Integer yScreen xScreen x y
81608>>>>>>>>>        Integer iVoid xy cx cy
81608>>>>>>>>>        Handle hDC hBrush hBrushOld hPen hPenOld hWnd
81608>>>>>>>>>        Pointer lpPoint
81608>>>>>>>>>        tWinPoint APoint
81608>>>>>>>>>        tWinPoint APoint
81608>>>>>>>>>        Boolean bVertical
81608>>>>>>>>>        
81608>>>>>>>>>        Get pbSplitVertical to bVertical
81609>>>>>>>>>        
81609>>>>>>>>>        Get GuiLocation to xy
81610>>>>>>>>>        Move (Hi(xy))  to APoint.y
81611>>>>>>>>>        Move (Low(xy)) to APoint.x
81612>>>>>>>>>        Move (AddressOf(APoint)) to lpPoint
81613>>>>>>>>>        Delegate Get Window_Handle to hWnd              // Get the parent container's window handle
81615>>>>>>>>>        Move (ClientToScreen(hWnd, lpPoint)) to iVoid
81616>>>>>>>>>        
81616>>>>>>>>>        If bVertical Begin
81618>>>>>>>>>            Move (Hi(GuiSize(Self))) to cy
81619>>>>>>>>>            Get piLastLocation to iLastX
81620>>>>>>>>>            Move iPos to x
81621>>>>>>>>>            Move APoint.y to y
81622>>>>>>>>>            Move APoint.x to xScreen
81623>>>>>>>>>            
81623>>>>>>>>>            Move (x + xScreen) to x
81624>>>>>>>>>        End
81624>>>>>>>>>>
81624>>>>>>>>>        Else Begin
81625>>>>>>>>>            Move (low(GuiSize(Self))) to cx
81626>>>>>>>>>            Get piLastLocation to iLastY
81627>>>>>>>>>            Move iPos to y
81628>>>>>>>>>            Move APoint.x to x
81629>>>>>>>>>            Move APoint.y to yScreen
81630>>>>>>>>>            
81630>>>>>>>>>            Move (y + yScreen) to y
81631>>>>>>>>>        End
81631>>>>>>>>>>
81631>>>>>>>>>        
81631>>>>>>>>>        Move (GetDC(0)) to hDC
81632>>>>>>>>>        
81632>>>>>>>>>        Move (CreatePen(PS_SOLID, 1, clGray)) to hPen
81633>>>>>>>>>        Move (GetStockObject(GRAY_BRUSH)) to hBrush
81634>>>>>>>>>        Move (SelectObject(hDC, hPen))  to hPenOld
81635>>>>>>>>>        Move (SelectObject(hDC, hBrush)) to hBrushOld
81636>>>>>>>>>        Move (SetROP2(hDC, R2_NOTXORPEN)) to iVoid
81637>>>>>>>>>        
81637>>>>>>>>>        If bVertical Begin
81639>>>>>>>>>            If (iLastX <> 65536) Begin
81641>>>>>>>>>                Move (Rectangle(hDC, iLastX, y+1, iLastX+4, y+cy)) to iVoid // erase last line
81642>>>>>>>>>            End
81642>>>>>>>>>>
81642>>>>>>>>>            Move (Rectangle(hDC, x, y+1, x+4, y+cy)) to iVoid
81643>>>>>>>>>        End
81643>>>>>>>>>>
81643>>>>>>>>>        Else Begin
81644>>>>>>>>>            If (iLastY <> 65536) Begin
81646>>>>>>>>>                Move (Rectangle(hDC, x+1, iLastY, x+cx, iLastY+4)) to iVoid // erase last line
81647>>>>>>>>>            End
81647>>>>>>>>>>
81647>>>>>>>>>            Move (Rectangle(hDC, x+1, y, x+cx, y+4)) to iVoid
81648>>>>>>>>>        End
81648>>>>>>>>>>
81648>>>>>>>>>        
81648>>>>>>>>>        Move (SelectObject(hDC, hPenOld)) to iVoid
81649>>>>>>>>>        Move (SelectObject(hDC, hBrushOld)) to iVoid
81650>>>>>>>>>        Move (DeleteObject(hPen)) to iVoid
81651>>>>>>>>>        Move (ReleaseDC(0, hDC)) to iVoid
81652>>>>>>>>>        
81652>>>>>>>>>        Set piLastLocation to (If(bVertical,x, y))
81653>>>>>>>>>    End_Procedure
81654>>>>>>>>>    
81654>>>>>>>>>    
81654>>>>>>>>>    Procedure WMSG_OnMouseDown Integer wParam Integer lParam
81656>>>>>>>>>        Integer y cxy cy cyParent
81656>>>>>>>>>        Integer x cx cxParent
81656>>>>>>>>>        Boolean bVertical
81656>>>>>>>>>        Integer iMin iMax
81656>>>>>>>>>        
81656>>>>>>>>>        Get pbSplitVertical to bVertical
81657>>>>>>>>>        Send Set_Mouse_Capture
81658>>>>>>>>>        
81658>>>>>>>>>        Get piMinLocation to iMin
81659>>>>>>>>>        Get piMaxLocation to iMax
81660>>>>>>>>>        
81660>>>>>>>>>        Get GuiLocation to cx
81661>>>>>>>>>        Delegate Get GuiSize to cxy
81663>>>>>>>>>        If bVertical Begin
81665>>>>>>>>>            Move (Low(lParam)) to x
81666>>>>>>>>>            Move (Low(cx)) to cx
81667>>>>>>>>>            Move (Low(cxy)) to cxParent
81668>>>>>>>>>        End
81668>>>>>>>>>>
81668>>>>>>>>>        Else Begin
81669>>>>>>>>>            Move (Hi(lParam)) to x
81670>>>>>>>>>            Move (Hi(cx)) to cx
81671>>>>>>>>>            Move (Hi(cxy)) to cxParent
81672>>>>>>>>>        End
81672>>>>>>>>>>
81672>>>>>>>>>        Move (Cast(x,Short)) to x
81673>>>>>>>>>        
81673>>>>>>>>>        // these are delta tracking positions from the current splitter location
81673>>>>>>>>>        Set piMinTrack to ( iMin -cx )
81674>>>>>>>>>        Set piMaxTrack to ( cxParent - iMax - cx )
81675>>>>>>>>>        
81675>>>>>>>>>        Set piLastLocation to 65536
81676>>>>>>>>>        Send DrawDrag x
81677>>>>>>>>>    End_Procedure
81678>>>>>>>>>    
81678>>>>>>>>>    Function AdjustTrackPos Integer iTrack Returns Integer
81680>>>>>>>>>        Boolean bVertical
81680>>>>>>>>>        Integer iSz iMax iMin
81680>>>>>>>>>        
81680>>>>>>>>>        Get pbSplitVertical to bVertical
81681>>>>>>>>>        Delegate Get GuiClientSize to iSz
81683>>>>>>>>>        If bVertical Begin
81685>>>>>>>>>            Move (Low(iSz)) to iSz
81686>>>>>>>>>        End
81686>>>>>>>>>>
81686>>>>>>>>>        Else Begin
81687>>>>>>>>>            Move (hi(iSz)) to iSz
81688>>>>>>>>>        End
81688>>>>>>>>>>
81688>>>>>>>>>        Move (Cast(iTrack,Short)) to iTrack
81689>>>>>>>>>        
81689>>>>>>>>>        Get piMinTrack to iMin
81690>>>>>>>>>        Get piMaxTrack to iMax
81691>>>>>>>>>        Move (iMin max iTrack) to iTrack
81692>>>>>>>>>        Move (iMax min iTrack) to iTrack
81693>>>>>>>>>        Function_Return iTrack
81694>>>>>>>>>    End_Function
81695>>>>>>>>>    
81695>>>>>>>>>    
81695>>>>>>>>>    // reposition and resize all the objects..
81695>>>>>>>>>    Procedure WMSG_OnMouseUp Integer wParam Integer lParam
81697>>>>>>>>>        Integer iTrack
81697>>>>>>>>>        Boolean bVertical
81697>>>>>>>>>        
81697>>>>>>>>>        Get pbSplitVertical to bVertical
81698>>>>>>>>>        
81698>>>>>>>>>        Send Release_Mouse_Capture
81699>>>>>>>>>        
81699>>>>>>>>>        If bVertical Begin
81701>>>>>>>>>            Move (Low(lParam)) to iTrack
81702>>>>>>>>>        End
81702>>>>>>>>>>
81702>>>>>>>>>        Else Begin
81703>>>>>>>>>            Move (Hi(lParam)) to iTrack
81704>>>>>>>>>        End
81704>>>>>>>>>>
81704>>>>>>>>>        Get AdjustTrackPos iTrack to iTrack
81705>>>>>>>>>        Set piLastLocation to 65536
81706>>>>>>>>>        Send DrawDrag iTrack
81707>>>>>>>>>        
81707>>>>>>>>>        Send MoveSplitter iTrack
81708>>>>>>>>>        
81708>>>>>>>>>    End_Procedure
81709>>>>>>>>>    
81709>>>>>>>>>    Procedure MoveSplitter Integer iTrack
81711>>>>>>>>>        // normally we just ask the parent to handle this for us.
81711>>>>>>>>>        Delegate Send MoveSplitter iTrack
81713>>>>>>>>>    End_Procedure
81714>>>>>>>>>    
81714>>>>>>>>>    Procedure WMSG_OnMouseMove Integer wParam Integer lParam
81716>>>>>>>>>        Integer iTrack
81716>>>>>>>>>        Boolean bVertical
81716>>>>>>>>>        
81716>>>>>>>>>        
81716>>>>>>>>>        If (wParam iand MK_LBUTTON) Begin
81718>>>>>>>>>            
81718>>>>>>>>>            Get pbSplitVertical to bVertical
81719>>>>>>>>>            
81719>>>>>>>>>            If bVertical Begin
81721>>>>>>>>>                Move (Low(lParam)) to iTrack
81722>>>>>>>>>            End
81722>>>>>>>>>>
81722>>>>>>>>>            Else Begin
81723>>>>>>>>>                Move (Hi(lParam)) to iTrack
81724>>>>>>>>>            End
81724>>>>>>>>>>
81724>>>>>>>>>            Get AdjustTrackPos iTrack to iTrack
81725>>>>>>>>>            Send DrawDrag iTrack
81726>>>>>>>>>        End
81726>>>>>>>>>>
81726>>>>>>>>>    End_Procedure
81727>>>>>>>>>    
81727>>>>>>>>>    
81727>>>>>>>>>    // Determines which cursor shape should be displayed.
81727>>>>>>>>>    Procedure SetCursor
81729>>>>>>>>>        Integer iVoid
81729>>>>>>>>>        Handle  hWnd hLib hCursor retval
81729>>>>>>>>>        String sCursor
81729>>>>>>>>>        Boolean bVertical
81729>>>>>>>>>        Get pbSplitVertical to bVertical
81730>>>>>>>>>        Get Window_Handle to hWnd
81731>>>>>>>>>        Move (LoadLibrary("ComCtl32.dll")) to hLib
81732>>>>>>>>>        Move (If(bVertical,"#107","#135")) to sCursor
81733>>>>>>>>>        Move (LoadCursor(hLib, addressof(sCursor))) to hCursor    // splitter cursor
81734>>>>>>>>>        Move (SetClassLongPtr(hWnd, GCL_HCURSOR, hCursor )) to retval
81735>>>>>>>>>        Move (FreeLibrary(hLib)) to iVoid
81736>>>>>>>>>    End_Procedure
81737>>>>>>>>>    
81737>>>>>>>>>    Procedure Page Integer iState
81739>>>>>>>>>        Forward Send Page iState
81741>>>>>>>>>        If (iState =1) ;            Send SetCursor
81744>>>>>>>>>    End_Procedure
81745>>>>>>>>>    
81745>>>>>>>>>End_Class
81746>>>>>>>>>
81746>>>>>>>>>// we need different external classes or horizontal and vertical because
81746>>>>>>>>>// we are changing a class property in SetCursor
81746>>>>>>>>>
81746>>>>>>>>>Class cVerticalSplitter is a cAbstractSplitter
81747>>>>>>>>>    Procedure Construct_Object
81749>>>>>>>>>        Forward Send Construct_Object
81751>>>>>>>>>        Set pbSplitVertical to True
81752>>>>>>>>>        
81752>>>>>>>>>        Set External_Class_Name "DFVerticalSplitter" to "Static"
81753>>>>>>>>>        
81753>>>>>>>>>        Set External_Message WM_LBUTTONDOWN to msg_WMSG_OnMouseDown
81754>>>>>>>>>        Set External_Message WM_LBUTTONUP   to msg_WMSG_OnMouseUp
81755>>>>>>>>>        Set External_Message WM_MOUSEMOVE   to msg_WMSG_OnMouseMove
81756>>>>>>>>>        Set Window_Style to SS_NOTIFY True
81757>>>>>>>>>    End_Procedure
81758>>>>>>>>>    
81758>>>>>>>>>End_Class
81759>>>>>>>>>
81759>>>>>>>>>Class cHorizontalSplitter is a cAbstractSplitter
81760>>>>>>>>>    Procedure Construct_Object
81762>>>>>>>>>        Forward Send Construct_Object
81764>>>>>>>>>        Set pbSplitVertical to False
81765>>>>>>>>>        
81765>>>>>>>>>        Set External_Class_Name "DFHorizontalSplitter" to "Static"
81766>>>>>>>>>        
81766>>>>>>>>>        Set External_Message WM_LBUTTONDOWN to msg_WMSG_OnMouseDown
81767>>>>>>>>>        Set External_Message WM_LBUTTONUP   to msg_WMSG_OnMouseUp
81768>>>>>>>>>        Set External_Message WM_MOUSEMOVE   to msg_WMSG_OnMouseMove
81769>>>>>>>>>        Set Window_Style to SS_NOTIFY True
81770>>>>>>>>>    End_Procedure
81771>>>>>>>>>    
81771>>>>>>>>>End_Class
81772>>>>>>>>>
81772>>>>>>>
81772>>>>>>>Enum_List
81772>>>>>>>    Define fpFixFirstPanel      // Top panel height remains fixed on resize
81772>>>>>>>    Define fpFixLastPanel   // Bottom panel height remains fixed on resize
81772>>>>>>>End_Enum_List
81772>>>>>>>
81772>>>>>>>Define C_SplitterWidth for 3
81772>>>>>>>
81772>>>>>>>
81772>>>>>>>Class cSplitterContainerMixin is a Mixin
81773>>>>>>>    
81773>>>>>>>    Procedure Define_cSplitterContainerMixin
81775>>>>>>>        
81775>>>>>>>        // Split vertical or horizontal
81775>>>>>>>        Property Boolean pbSplitVertical True
81776>>>>>>>        
81776>>>>>>>        // determines which panel's height remains fixed during parent resize events
81776>>>>>>>        Property Integer peFixedPanel fpFixFirstPanel
81777>>>>>>>        
81777>>>>>>>        Property Integer piSplitterColor clBtnFace
81778>>>>>>>        
81778>>>>>>>        // these are normally maintained by the class
81778>>>>>>>        Property Handle phoFirstPanel 0
81779>>>>>>>        Property Handle phoLastPanel 0
81780>>>>>>>        Property Handle phoSplitter 0
81781>>>>>>>        
81781>>>>>>>        Property Integer piPrivateSplitterLocation 0
81782>>>>>>>        Property Integer piPrivateMinSplitterLocation 20
81783>>>>>>>        Property Integer piPrivateMaxSplitterLocation 20
81784>>>>>>>        
81784>>>>>>>        Set Border_Style to Border_None
81785>>>>>>>        
81785>>>>>>>    End_Procedure
81786>>>>>>>    
81786>>>>>>>    Procedure Set piMinSplitterLocation Integer iLocation
81788>>>>>>>        Handle hoSplitter
81788>>>>>>>        Boolean bVert
81788>>>>>>>        Set piPrivateMinSplitterLocation to iLocation
81789>>>>>>>        // if splitter exists update the splitter with Gui Units
81789>>>>>>>        Get phoSplitter to hoSplitter
81790>>>>>>>        If hoSplitter Begin
81792>>>>>>>            Get pbSplitVertical to bVert
81793>>>>>>>            Get DialogToGui iLocation iLocation to iLocation
81794>>>>>>>            Set piMinLocation of hoSplitter to (If(bVert,Low(iLocation),Hi(iLocation)))
81795>>>>>>>        End
81795>>>>>>>>
81795>>>>>>>    End_Procedure
81796>>>>>>>    
81796>>>>>>>    Function piMinSplitterLocation Returns Integer
81798>>>>>>>        Integer iLocation
81798>>>>>>>        Get piPrivateMinSplitterLocation to iLocation
81799>>>>>>>        Function_Return iLocation
81800>>>>>>>    End_Function
81801>>>>>>>    
81801>>>>>>>    Procedure Set piMaxSplitterLocation Integer iLocation
81803>>>>>>>        Handle hoSplitter
81803>>>>>>>        Boolean bVert
81803>>>>>>>        Set piPrivateMaxSplitterLocation to iLocation
81804>>>>>>>        // if splitter exists update the splitter with Gui Units
81804>>>>>>>        Get phoSplitter to hoSplitter
81805>>>>>>>        If hoSplitter Begin
81807>>>>>>>            Get pbSplitVertical to bVert
81808>>>>>>>            Get DialogToGui iLocation iLocation to iLocation
81809>>>>>>>            Set piMaxLocation of hoSplitter to (If(bVert,Low(iLocation),Hi(iLocation)))
81810>>>>>>>        End
81810>>>>>>>>
81810>>>>>>>    End_Procedure
81811>>>>>>>    
81811>>>>>>>    Function piMaxSplitterLocation Returns Integer
81813>>>>>>>        Integer iLocation
81813>>>>>>>        Get piPrivateMaxSplitterLocation to iLocation
81814>>>>>>>        Function_Return iLocation
81815>>>>>>>    End_Function
81816>>>>>>>    
81816>>>>>>>    Procedure Set piGuiSplitterLocation Integer iPos
81818>>>>>>>        Handle hWnd
81818>>>>>>>        Get Window_Handle to hWnd
81819>>>>>>>        If hWnd Begin
81821>>>>>>>            Get SizeSplitterComponents iPos to iPos
81822>>>>>>>        End
81822>>>>>>>>
81822>>>>>>>        Set piPrivateSplitterLocation to iPos
81823>>>>>>>    End_Procedure
81824>>>>>>>    
81824>>>>>>>    Function piGuiSplitterLocation Returns Integer
81826>>>>>>>        Integer iPos
81826>>>>>>>        Get piPrivateSplitterLocation to iPos
81827>>>>>>>        Function_Return iPos
81828>>>>>>>    End_Function
81829>>>>>>>    
81829>>>>>>>    Procedure Set piSplitterLocation Integer iPos
81831>>>>>>>        Boolean bVert
81831>>>>>>>        Get pbSplitVertical to bVert
81832>>>>>>>        Get DialogToGui iPos iPos to iPos
81833>>>>>>>        Set piGuiSplitterLocation to (If(bVert, low(iPos), Hi(iPos)))
81834>>>>>>>    End_Procedure
81835>>>>>>>    
81835>>>>>>>    Function piSplitterLocation Returns Integer
81837>>>>>>>        Integer iPos
81837>>>>>>>        Boolean bVert
81837>>>>>>>        // we will get the gui units and convert to dialog
81837>>>>>>>        Get piPrivateSplitterLocation to iPos
81838>>>>>>>        Get pbSplitVertical to bVert
81839>>>>>>>        Get GuiToDialog iPos iPos to iPos
81840>>>>>>>        Function_Return (If(bVert, low(iPos), Hi(iPos)))
81841>>>>>>>    End_Function
81842>>>>>>>    
81842>>>>>>>    // create the appropriate splitter for the object. This could be augmented
81842>>>>>>>    // to return a different object class
81842>>>>>>>    Function CreateSplitter Returns Handle
81844>>>>>>>        Boolean bVertical
81844>>>>>>>        Handle hoSplitter
81844>>>>>>>        
81844>>>>>>>        Get pbSplitVertical to bVertical
81845>>>>>>>        
81845>>>>>>>        If bVertical Begin
81847>>>>>>>            Get Create U_cVerticalSplitter to hoSplitter
81848>>>>>>>        End
81848>>>>>>>>
81848>>>>>>>        Else Begin
81849>>>>>>>            Get Create U_cHorizontalSplitter to hoSplitter
81850>>>>>>>        End
81850>>>>>>>>
81850>>>>>>>        
81850>>>>>>>        Function_Return hoSplitter
81851>>>>>>>    End_Function
81852>>>>>>>    
81852>>>>>>>    // augmented to test that all components are bound properly and
81852>>>>>>>    // to set the initial sizes
81852>>>>>>>    Procedure Page Integer iPageObject
81854>>>>>>>        Handle hoSplitter hoFirst hoLast
81854>>>>>>>        Integer iColor iClientSize
81854>>>>>>>        Boolean bVertical
81854>>>>>>>        Integer iLoc
81854>>>>>>>        Integer iVal
81854>>>>>>>        
81854>>>>>>>        Forward Send Page iPageObject
81856>>>>>>>        
81856>>>>>>>        If iPageObject Begin
81858>>>>>>>            
81858>>>>>>>            // make the container the size of the parent clientarea
81858>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
81858>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
81858>>>>>>>            // makes anchors work properly with unpaged tab-pages
81858>>>>>>>            Delegate Get GetContainerClientSize to iClientSize
81860>>>>>>>            Set GuiSize to (Hi(iClientSize)) (Low(iClientSize))
81861>>>>>>>            Set GuiLocation to 0 0
81862>>>>>>>            Send Adjust_Logicals
81863>>>>>>>            
81863>>>>>>>            // destroy existing splitter and create a new one
81863>>>>>>>            Get phoSplitter to hoSplitter
81864>>>>>>>            If (hoSplitter) Begin
81866>>>>>>>                Send Destroy of hoSplitter
81867>>>>>>>            End
81867>>>>>>>>
81867>>>>>>>            Get CreateSplitter to hoSplitter
81868>>>>>>>            Set phoSplitter to hoSplitter
81869>>>>>>>            Get phoFirstPanel to hoFirst
81870>>>>>>>            Get phoLastPanel to hoLast
81871>>>>>>>            If (hoSplitter=0 or hoFirst=0 or hoLast=0) Begin
81873>>>>>>>                Error DFERR_OPERATOR "Splitter container is missing a child splitter or container component"
81874>>>>>>>>
81874>>>>>>>                Procedure_Return
81875>>>>>>>            End
81875>>>>>>>>
81875>>>>>>>            
81875>>>>>>>            // set various splitter propertues directly in splitter
81875>>>>>>>            Get piSplitterColor to iColor
81876>>>>>>>            Set Color of hoSplitter to iColor
81877>>>>>>>            Get pbSplitVertical to bVertical
81878>>>>>>>            Set pbSplitVertical of hoSplitter to bVertical
81879>>>>>>>            // Once phoSplitter is set, reseting these will update the splitter as needed
81879>>>>>>>            Get piMinSplitterLocation to iVal
81880>>>>>>>            Set piMinSplitterLocation to iVal
81881>>>>>>>            Get piMaxSplitterLocation to iVal
81882>>>>>>>            Set piMaxSplitterLocation to iVal
81883>>>>>>>            
81883>>>>>>>            // this will force a resize
81883>>>>>>>            Get piGuiSplitterLocation to iLoc
81884>>>>>>>            Set piGuiSplitterLocation to iLoc
81885>>>>>>>        End
81885>>>>>>>>
81885>>>>>>>        
81885>>>>>>>    End_Procedure
81886>>>>>>>    
81886>>>>>>>    // called everytime the parent is resized
81886>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
81888>>>>>>>        If (Window_Handle(Self)) Begin
81890>>>>>>>            Send ResizeSplitterContainer
81891>>>>>>>        End
81891>>>>>>>>
81891>>>>>>>    End_Procedure
81892>>>>>>>    
81892>>>>>>>    // parent has been resized. Adjust everything.
81892>>>>>>>    Procedure ResizeSplitterContainer
81894>>>>>>>        Integer iClientSize
81894>>>>>>>        Handle  hoFirstPanel hoLastPanel
81894>>>>>>>        Integer cxy cxClient cyClient
81894>>>>>>>        Boolean bVertical
81894>>>>>>>        Integer iFirstSize
81894>>>>>>>        Integer eFixedPanel
81894>>>>>>>        
81894>>>>>>>        // make the container the size of the parent clientarea
81894>>>>>>>        Delegate Get GuiClientSize to iClientSize
81896>>>>>>>        Move (Hi(iClientSize))  to cyClient
81897>>>>>>>        Move (Low(iClientSize)) to cxClient
81898>>>>>>>        Set GuiSize to cyClient cxClient
81899>>>>>>>        Set GuiLocation to 0 0
81900>>>>>>>        
81900>>>>>>>        // resize child objects by determining the size of the first child container
81900>>>>>>>        Get pbSplitVertical to bVertical
81901>>>>>>>        Get peFixedPanel to eFixedPanel
81902>>>>>>>        If (eFixedPanel = fpFixFirstPanel) Begin
81904>>>>>>>            // Resize the panels keeping the size of the first panel fixed
81904>>>>>>>            Get phoFirstPanel to hoFirstPanel
81905>>>>>>>            Get GuiSize of hoFirstPanel to cxy
81906>>>>>>>            If bVertical Begin
81908>>>>>>>                Move (Low(cxy)) to iFirstSize
81909>>>>>>>            End
81909>>>>>>>>
81909>>>>>>>            Else Begin
81910>>>>>>>                Move (Hi(cxy)) to iFirstSize
81911>>>>>>>            End
81911>>>>>>>>
81911>>>>>>>        End
81911>>>>>>>>
81911>>>>>>>        Else Begin
81912>>>>>>>            // Resize the panels keeping the size of the last panel fixed
81912>>>>>>>            Get pholastPanel to hoLastPanel
81913>>>>>>>            Get GuiSize of hoLastPanel to cxy
81914>>>>>>>            If bVertical Begin
81916>>>>>>>                Move (cxClient - low(cxy) - C_SplitterWidth) to iFirstSize
81917>>>>>>>            End
81917>>>>>>>>
81917>>>>>>>            Else Begin
81918>>>>>>>                Move (cyClient - Hi(cxy) - C_SplitterWidth) to iFirstSize
81919>>>>>>>            End
81919>>>>>>>>
81919>>>>>>>        End
81919>>>>>>>>
81919>>>>>>>        Set piGuiSplitterLocation to iFirstSize
81920>>>>>>>    End_Procedure
81921>>>>>>>    
81921>>>>>>>    // set size of all child objects passing the GUI size of the first child panel
81921>>>>>>>    Function SizeSplitterComponents Integer iFirstSize Returns Integer
81923>>>>>>>        Handle  hoFirstPanel hoLastPanel hoSplitter
81923>>>>>>>        Integer cyFirstPanel cyLastPanel
81923>>>>>>>        Integer cxFirstPanel cxLastPanel
81923>>>>>>>        Integer cxy cxClient cyClient
81923>>>>>>>        Integer iMin iMax
81923>>>>>>>        Boolean bVertical
81923>>>>>>>        
81923>>>>>>>        Get phoFirstPanel    to hoFirstPanel
81924>>>>>>>        Get phoLastPanel to hoLastPanel
81925>>>>>>>        Get phoSplitter    to hoSplitter
81926>>>>>>>        Get pbSplitVertical to bVertical
81927>>>>>>>        Get GuiClientSize to cxy
81928>>>>>>>        Move (Hi(cxy))  to cyClient
81929>>>>>>>        Move (Low(cxy)) to cxClient
81930>>>>>>>        
81930>>>>>>>        Get piMinSplitterLocation to iMin
81931>>>>>>>        Get piMaxSplitterLocation to iMax
81932>>>>>>>        Get DialogToGui iMin iMin to iMin
81933>>>>>>>        Move (If(bVertical,Low(iMin),Hi(iMin))) to iMin
81934>>>>>>>        Get DialogToGui iMax iMax to iMax
81935>>>>>>>        Move (If(bVertical,Low(iMax),Hi(iMax))) to iMax
81936>>>>>>>        
81936>>>>>>>        If (iFirstSize=0) Begin
81938>>>>>>>            Move (If(bVertical, cxClient, cyClient)/2) to iFirstSize
81939>>>>>>>        End
81939>>>>>>>>
81939>>>>>>>        
81939>>>>>>>        Move (iFirstSize max iMin) to iFirstSize
81940>>>>>>>        Move (iFirstSize min (If(bVertical, cxClient, cyClient) - iMax)) to iFirstSize
81941>>>>>>>        
81941>>>>>>>        If bVertical Begin
81943>>>>>>>            Move iFirstSize to cxFirstPanel
81944>>>>>>>            
81944>>>>>>>            // position the splitter
81944>>>>>>>            Set GuiLocation of hoSplitter to 0 cxFirstPanel
81945>>>>>>>            Set GuiSize     of hoSplitter to cyClient C_SplitterWidth
81946>>>>>>>            
81946>>>>>>>            // position the left panel
81946>>>>>>>            Set GuiLocation of hoFirstPanel to 0 0
81947>>>>>>>            Set GuiSize     of hoFirstPanel to  cyClient cxFirstPanel
81948>>>>>>>            
81948>>>>>>>            // position the right panel
81948>>>>>>>            Set GuiLocation of hoLastPanel to 0 (cxFirstPanel + C_SplitterWidth)
81949>>>>>>>            Set GuiSize     of hoLastPanel to cyClient (cxClient - cxFirstPanel - C_SplitterWidth)
81950>>>>>>>            Move cxFirstPanel to iFirstSize
81951>>>>>>>        End
81951>>>>>>>>
81951>>>>>>>        Else Begin
81952>>>>>>>            Move iFirstSize to cyFirstPanel
81953>>>>>>>            
81953>>>>>>>            // position the splitter
81953>>>>>>>            Set GuiLocation of hoSplitter to cyFirstPanel 0
81954>>>>>>>            Set GuiSize     of hoSplitter to C_SplitterWidth cxClient
81955>>>>>>>            
81955>>>>>>>            // position the top panel
81955>>>>>>>            Set GuiLocation of hoFirstPanel to 0 0
81956>>>>>>>            Set GuiSize     of hoFirstPanel to cyFirstPanel cxClient
81957>>>>>>>            
81957>>>>>>>            // position the bottom panel
81957>>>>>>>            Set GuiLocation of hoLastPanel to (cyFirstPanel + C_SplitterWidth) 0
81958>>>>>>>            Set GuiSize     of hoLastPanel to (cyClient - cyFirstPanel - C_SplitterWidth) cxClient
81959>>>>>>>            Move cyFirstPanel to iFirstSize
81960>>>>>>>        End
81960>>>>>>>>
81960>>>>>>>        
81960>>>>>>>        Function_Return iFirstSize
81961>>>>>>>    End_Function
81962>>>>>>>    
81962>>>>>>>    // move splitter by passed GUI units. Usually called by splitter control
81962>>>>>>>    Procedure MoveSplitter Integer iGuiTrack
81964>>>>>>>        Integer cxy
81964>>>>>>>        Integer iFirstSize
81964>>>>>>>        Handle hoFirstPanel
81964>>>>>>>        Boolean bVertical
81964>>>>>>>        
81964>>>>>>>        Get pbSplitVertical to bVertical
81965>>>>>>>        
81965>>>>>>>        Get phoFirstPanel to hoFirstPanel
81966>>>>>>>        Get GuiSize of hoFirstPanel to cxy
81967>>>>>>>        If bVertical Begin
81969>>>>>>>            Move (Low(cxy) + iGuiTrack) to iFirstSize
81970>>>>>>>        End
81970>>>>>>>>
81970>>>>>>>        Else Begin
81971>>>>>>>            Move (Hi(cxy) + iGuiTrack) to iFirstSize
81972>>>>>>>        End
81972>>>>>>>>
81972>>>>>>>        
81972>>>>>>>        Set piGuiSplitterLocation to iFirstSize
81973>>>>>>>    End_Procedure
81974>>>>>>>    
81974>>>>>>>End_Class
81975>>>>>>>
81975>>>>>>>
81975>>>>>>>Class cSplitterContainerChildMixin is a Mixin
81976>>>>>>>    
81976>>>>>>>    Procedure Define_cSplitterContainerChildMixin
81978>>>>>>>        Handle hoObj
81978>>>>>>>        
81978>>>>>>>        // by default we use object order to determine which is the first panel and
81978>>>>>>>        // which is the second panel. This class is only valid within a SplitterContainer and
81978>>>>>>>        // an error will be raised here if this is not the case
81978>>>>>>>        Delegate Get phoFirstPanel to hoObj
81980>>>>>>>        If (hoObj=0) Begin
81982>>>>>>>            Delegate Set phoFirstPanel to Self
81984>>>>>>>        End
81984>>>>>>>>
81984>>>>>>>        Else Begin
81985>>>>>>>            Delegate Set phoLastPanel to Self
81987>>>>>>>        End
81987>>>>>>>>
81987>>>>>>>    End_Procedure
81988>>>>>>>    
81988>>>>>>>End_Class
81989>>>>>
81989>>>>>
81989>>>>>
81989>>>>>Class cDbSplitterContainer is a dbContainer3d
81990>>>>>    Import_Class_Protocol cSplitterContainerMixin
81991>>>>>    Procedure Construct_Object
81993>>>>>        Forward Send Construct_Object
81995>>>>>        Send Define_cSplitterContainerMixin
81996>>>>>    End_Procedure
81997>>>>>End_Class
81998>>>>>
81998>>>>>
81998>>>>>Class cDbSplitterContainerChild is a dbContainer3d
81999>>>>>    Import_Class_Protocol cSplitterContainerChildMixin
82000>>>>>    Procedure Construct_Object
82002>>>>>        Forward Send Construct_Object
82004>>>>>        Send Define_cSplitterContainerChildMixin
82005>>>>>        Set Border_Style to Border_Normal
82006>>>>>    End_Procedure
82007>>>>>End_Class
82008>>>>>
82008>>>Use Dfenrad.pkg
82008>>>Use File_dlg.pkg
82008>>>Use seq_chnl.pkg
82008>>>
82008>>>Use cRefactorDbView.pkg
Including file: cRefactorDbView.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorDbView.pkg)
82008>>>>>// Nils 2018-08-21
82008>>>>>// Various source code refactoring functions/procedures
82008>>>>>// for the DFRefactor project.
82008>>>>>// Was lifted from the CleanMarkers.vw  business process object (oBPO)
82008>>>>>// to here to make it easier to replace/add to this logic.
82008>>>>>// Wil 2018-09-03
82008>>>>>// Moved code into a dbView subclass instead.
82008>>>>>//
82008>>>>>Use Dfclient.pkg
82008>>>>>Use StatFLog.pkg
Including file: StatFLog.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\StatFLog.pkg)
82008>>>>>>>// This is a prototype status log file that can be used for adding status
82008>>>>>>>// log entries. If you are going to use this you MUST create a database
82008>>>>>>>// file named StatLog with, at least,  the following fields:
82008>>>>>>>//      Statlog.Date        date        date of status log entry
82008>>>>>>>//      Statlog.Time        String (5)  Time of entry in HH:MM format
82008>>>>>>>//      StatLog.Description String (??) Log text. We suggest length of
82008>>>>>>>//                                      at least 40.
82008>>>>>>>// You may add your own fields to this to store other types of information
82008>>>>>>>// such as user-id, status type, etc.
82008>>>>>>>//
82008>>>>>>>// Public Interface:
82008>>>>>>>//      Send Log_Status String sText
82008>>>>>>>//              Creates a log entry. Passes string Text.
82008>>>>>>>//      Send Log_Clear
82008>>>>>>>//              Clears the status log datafile.
82008>>>>>>>//
82008>>>>>>>//      Procedure OnNewRecord
82008>>>>>>>//              This is called each time a new record is ready to be
82008>>>>>>>//              written. All data is in the buffer (date, time, text).
82008>>>>>>>//              You can make any additional changes to the buffer. This is
82008>>>>>>>//              handy if you have additional fields.
82008>>>>>>>//
82008>>>>>>>// IMPORTANT NOTE: This is not meant to be a complete solution. Developers
82008>>>>>>>// are encouraged to create their own class (or sub-class) and data file
82008>>>>>>>// for logging information. The only public interface that must be adhered to
82008>>>>>>>// is send Log_Status and send Log_Clear. If you augment log_status you may
82008>>>>>>>// even choose to change the number of parameters and type of information
82008>>>>>>>// passed to the object.
82008>>>>>>>Use VDFBase.pkg
82008>>>>>>>
82008>>>>>>>Class StatusDbLog is a cObject
82009>>>>>>>    
82009>>>>>>>    Procedure Construct_Object
82011>>>>>>>        Forward Send Construct_Object
82013>>>>>>>        Open StatLog // Open the data-file. This MUST exist or error
Including file: StatLog.fd    (C:\Projects\DF18\DfRefactor\DDSrc\StatLog.fd)
82015>>>>>>>    End_Procedure
82016>>>>>>>    
82016>>>>>>>    // Clear the log file - Public message
82016>>>>>>>    Procedure Log_Clear
82018>>>>>>>        ZeroFile StatLog
82019>>>>>>>    End_Procedure
82020>>>>>>>    
82020>>>>>>>    // Private: converts integers Hour and Minutes into "HH:MM" string
82020>>>>>>>    Function TimeString Integer iHr Integer iMn Returns String
82022>>>>>>>        Function_Return (right("0"+String(iHr),2) + ":" + right("0"+String(iMn),2))
82023>>>>>>>    End_Function
82024>>>>>>>    
82024>>>>>>>    // write a log status record. Pass Text to write
82024>>>>>>>    Procedure Log_Status String Txt
82026>>>>>>>        Integer Hr Mn
82026>>>>>>>        Date    Dt
82026>>>>>>>        Integer OldError                 // we must trap errors that occur
82026>>>>>>>        Move Error_Object_ID to OldError       // within this object, often errors
82027>>>>>>>        Move Self to Error_Object_Id // are logged - causing recursion
82028>>>>>>>        Sysdate Dt Hr Mn
82031>>>>>>>        Clear StatLog
82032>>>>>>>        Move Dt to StatLog.Date
82033>>>>>>>        Move (TimeString(Self,hr,Mn)) to StatLog.Time
82034>>>>>>>        Move Txt to StatLog.Description
82035>>>>>>>        Send OnNewRecord // User hook to customize
82036>>>>>>>        SaveRecord StatLog
82037>>>>>>>        Move OldError to Error_Object_Id
82038>>>>>>>    End_Procedure
82039>>>>>>>    
82039>>>>>>>    // For Augmentation Only. This is called when a new record is about
82039>>>>>>>    // to be saved. You can make any changes, set new field values, etc.
82039>>>>>>>    Procedure OnNewRecord
82041>>>>>>>    End_Procedure
82042>>>>>>>    
82042>>>>>>>    // When errors occur within object, they are directed here.
82042>>>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String ErrMsg
82044>>>>>>>        //Forward send Error_Report iErrNum iErrLine ErrMsg
82044>>>>>>>        Send Error_report of desktop iErrNum iErrLine ErrMsg
82045>>>>>>>    End_Procedure
82046>>>>>>>    
82046>>>>>>>End_Class
82047>>>>>>>
82047>>>>>>>// expected usage
82047>>>>>>>//Object Status_Log is a StatusdbLog
82047>>>>>>>//End_Object
82047>>>>>Use RefactorFunctionConstants.inc
82047>>>>>Use cRegex.pkg
Including file: cRegex.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRegex.pkg)
82047>>>>>>>// cRegex class v1.03:
82047>>>>>>>// By Erik Svensson, posted on eriksven.com in March 2013
82047>>>>>>>// License: LGPLv3 - GNU LESSER GENERAL PUBLIC LICENSE Version 3 - http://www.gnu.org/licenses/lgpl.txt
82047>>>>>>>
82047>>>>>>>Define cREGEX_INCLUDED for 1
82047>>>>>>>
82047>>>>>>>// Visual DataFlex COM proxy classes generated from C:\Windows\system32\vbscript.dll\2
82047>>>>>>>Use FlexCom20.pkg
82047>>>>>>>
82047>>>>>>>Struct tRegexMatch
82047>>>>>>>    String Val
82047>>>>>>>    Integer FirstIndex
82047>>>>>>>    Integer Length
82047>>>>>>>End_Struct
82047>>>>>>>
82047>>>>>>>// CLSID: {3F4DACA0-160D-11D2-A8E9-00104B365C9F}
82047>>>>>>>Class cComIRegularExpressions is a Mixin
82048>>>>>>>
82048>>>>>>>    Function ComPattern Returns String
82050>>>>>>>        Handle hDispatchDriver
82050>>>>>>>        String retVal
82050>>>>>>>        Get phDispatchDriver to hDispatchDriver
82051>>>>>>>        Get InvokeComMethod of hDispatchDriver 10001 OLE_VT_BSTR to retVal
82052>>>>>>>        Function_Return retVal
82053>>>>>>>    End_Function
82054>>>>>>>
82054>>>>>>>    Procedure Set ComPattern String value
82056>>>>>>>        Handle hDispatchDriver
82056>>>>>>>        Get phDispatchDriver to hDispatchDriver
82057>>>>>>>        Send PrepareParams to hDispatchDriver 1
82058>>>>>>>        Set ComProperty of hDispatchDriver 10001 OLE_VT_BSTR to value
82059>>>>>>>    End_Procedure
82060>>>>>>>
82060>>>>>>>    Function ComIgnoreCase Returns Boolean
82062>>>>>>>        Handle hDispatchDriver
82062>>>>>>>        Boolean retVal
82062>>>>>>>        Get phDispatchDriver to hDispatchDriver
82063>>>>>>>        Get InvokeComMethod of hDispatchDriver 10002 OLE_VT_BOOL to retVal
82064>>>>>>>        Function_Return retVal
82065>>>>>>>    End_Function
82066>>>>>>>
82066>>>>>>>    Procedure Set ComIgnoreCase Boolean value
82068>>>>>>>        Handle hDispatchDriver
82068>>>>>>>        Get phDispatchDriver to hDispatchDriver
82069>>>>>>>        Send PrepareParams to hDispatchDriver 1
82070>>>>>>>        Set ComProperty of hDispatchDriver 10002 OLE_VT_BOOL to value
82071>>>>>>>    End_Procedure
82072>>>>>>>
82072>>>>>>>    Function ComGlobal Returns Boolean
82074>>>>>>>        Handle hDispatchDriver
82074>>>>>>>        Boolean retVal
82074>>>>>>>        Get phDispatchDriver to hDispatchDriver
82075>>>>>>>        Get InvokeComMethod of hDispatchDriver 10003 OLE_VT_BOOL to retVal
82076>>>>>>>        Function_Return retVal
82077>>>>>>>    End_Function
82078>>>>>>>
82078>>>>>>>    Procedure Set ComGlobal Boolean value
82080>>>>>>>        Handle hDispatchDriver
82080>>>>>>>        Get phDispatchDriver to hDispatchDriver
82081>>>>>>>        Send PrepareParams to hDispatchDriver 1
82082>>>>>>>        Set ComProperty of hDispatchDriver 10003 OLE_VT_BOOL to value
82083>>>>>>>    End_Procedure
82084>>>>>>>
82084>>>>>>>    Function ComExecute String llsourceString Returns Variant
82086>>>>>>>        Handle hDispatchDriver
82086>>>>>>>        Variant retVal
82086>>>>>>>        Get phDispatchDriver to hDispatchDriver
82087>>>>>>>        Send PrepareParams to hDispatchDriver 1
82088>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llsourceString
82089>>>>>>>        Get InvokeComMethod of hDispatchDriver 10004 OLE_VT_DISPATCH to retVal
82090>>>>>>>        Function_Return retVal
82091>>>>>>>    End_Function
82092>>>>>>>
82092>>>>>>>    Function ComTest String llsourceString Returns Boolean
82094>>>>>>>        Handle hDispatchDriver
82094>>>>>>>        Boolean retVal
82094>>>>>>>        Get phDispatchDriver to hDispatchDriver
82095>>>>>>>        Send PrepareParams to hDispatchDriver 1
82096>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llsourceString
82097>>>>>>>        Get InvokeComMethod of hDispatchDriver 10005 OLE_VT_BOOL to retVal
82098>>>>>>>        Function_Return retVal
82099>>>>>>>    End_Function
82100>>>>>>>
82100>>>>>>>    Function ComReplace String llsourceString String llreplaceString Returns String
82102>>>>>>>        Handle hDispatchDriver
82102>>>>>>>        String retVal
82102>>>>>>>        Get phDispatchDriver to hDispatchDriver
82103>>>>>>>        Send PrepareParams to hDispatchDriver 2
82104>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llsourceString
82105>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llreplaceString
82106>>>>>>>        Get InvokeComMethod of hDispatchDriver 10006 OLE_VT_BSTR to retVal
82107>>>>>>>        Function_Return retVal
82108>>>>>>>    End_Function
82109>>>>>>>End_Class
82110>>>>>>>
82110>>>>>>>// CoClass
82110>>>>>>>// ProgID: VBScript.RegExp
82110>>>>>>>// CLSID: {3F4DACA4-160D-11D2-A8E9-00104B365C9F}
82110>>>>>>>Class cComRegularExpressions is a cComAutomationObject
82111>>>>>>>    Import_Class_Protocol cComIRegularExpressions
82112>>>>>>>
82112>>>>>>>    Procedure Construct_Object
82114>>>>>>>        Forward Send Construct_Object
82116>>>>>>>        Set psProgID to "{3F4DACA4-160D-11D2-A8E9-00104B365C9F}"
82117>>>>>>>        Set peAutoCreate to acNoAutoCreate
82118>>>>>>>    End_Procedure
82119>>>>>>>End_Class
82120>>>>>>>
82120>>>>>>>// CLSID: {3F4DACA1-160D-11D2-A8E9-00104B365C9F}
82120>>>>>>>Class cComIRegExMatch is a Mixin
82121>>>>>>>
82121>>>>>>>    Function ComValue Returns String
82123>>>>>>>        Handle hDispatchDriver
82123>>>>>>>        String retVal
82123>>>>>>>        Get phDispatchDriver to hDispatchDriver
82124>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_BSTR to retVal
82125>>>>>>>        Function_Return retVal
82126>>>>>>>    End_Function
82127>>>>>>>
82127>>>>>>>    Function ComFirstIndex Returns Integer
82129>>>>>>>        Handle hDispatchDriver
82129>>>>>>>        Integer retVal
82129>>>>>>>        Get phDispatchDriver to hDispatchDriver
82130>>>>>>>        Get InvokeComMethod of hDispatchDriver 10001 OLE_VT_I4 to retVal
82131>>>>>>>        Function_Return retVal
82132>>>>>>>    End_Function
82133>>>>>>>
82133>>>>>>>    Function ComLength Returns Integer
82135>>>>>>>        Handle hDispatchDriver
82135>>>>>>>        Integer retVal
82135>>>>>>>        Get phDispatchDriver to hDispatchDriver
82136>>>>>>>        Get InvokeComMethod of hDispatchDriver 10002 OLE_VT_I4 to retVal
82137>>>>>>>        Function_Return retVal
82138>>>>>>>    End_Function
82139>>>>>>>End_Class
82140>>>>>>>
82140>>>>>>>// CoClass
82140>>>>>>>// CLSID: {3F4DACA5-160D-11D2-A8E9-00104B365C9F}
82140>>>>>>>Class cComRegExMatch is a cComAutomationObject
82141>>>>>>>    Import_Class_Protocol cComIRegExMatch
82142>>>>>>>
82142>>>>>>>    Procedure Construct_Object
82144>>>>>>>        Forward Send Construct_Object
82146>>>>>>>        Set peAutoCreate to acNoAutoCreate
82147>>>>>>>    End_Procedure
82148>>>>>>>End_Class
82149>>>>>>>
82149>>>>>>>// CLSID: {3F4DACA2-160D-11D2-A8E9-00104B365C9F}
82149>>>>>>>Class cComIRegExMatchCollection is a Mixin
82150>>>>>>>
82150>>>>>>>    Function ComItem Integer llindex Returns Variant
82152>>>>>>>        Handle hDispatchDriver
82152>>>>>>>        Variant retVal
82152>>>>>>>        Get phDispatchDriver to hDispatchDriver
82153>>>>>>>        Send PrepareParams to hDispatchDriver 1
82154>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llindex
82155>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
82156>>>>>>>        Function_Return retVal
82157>>>>>>>    End_Function
82158>>>>>>>
82158>>>>>>>    Function ComCount Returns Integer
82160>>>>>>>        Handle hDispatchDriver
82160>>>>>>>        Integer retVal
82160>>>>>>>        Get phDispatchDriver to hDispatchDriver
82161>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
82162>>>>>>>        Function_Return retVal
82163>>>>>>>    End_Function
82164>>>>>>>
82164>>>>>>>    Function Com_NewEnum Returns Variant
82166>>>>>>>        Handle hDispatchDriver
82166>>>>>>>        Variant retVal
82166>>>>>>>        Get phDispatchDriver to hDispatchDriver
82167>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
82168>>>>>>>        Function_Return retVal
82169>>>>>>>    End_Function
82170>>>>>>>End_Class
82171>>>>>>>
82171>>>>>>>// CoClass
82171>>>>>>>// CLSID: {3F4DACA6-160D-11D2-A8E9-00104B365C9F}
82171>>>>>>>Class cComRegExMatchCollection is a cComAutomationObject
82172>>>>>>>    Import_Class_Protocol cComIRegExMatchCollection
82173>>>>>>>
82173>>>>>>>    Procedure Construct_Object
82175>>>>>>>        Forward Send Construct_Object
82177>>>>>>>        Set peAutoCreate to acNoAutoCreate
82178>>>>>>>    End_Procedure
82179>>>>>>>End_Class
82180>>>>>>>
82180>>>>>>>//Wrapper
82180>>>>>>>Class cRegularExpressions is a cObject
82181>>>>>>>
82181>>>>>>>    Procedure Construct_Object
82183>>>>>>>        Handle hoRegExp
82183>>>>>>>
82183>>>>>>>        Forward Send Construct_Object
82185>>>>>>>
82185>>>>>>>        Property String  psPattern ""
82186>>>>>>>        Property Boolean pbIgnoreCase False
82187>>>>>>>        Property Handle  phRegex 0
82188>>>>>>>        Property Boolean pbGlobalFind False
82189>>>>>>>
82189>>>>>>>        Get Create (RefClass(cComRegularExpressions)) to hoRegExp
82190>>>>>>>        Send CreateComObject of hoRegExp
82191>>>>>>>
82191>>>>>>>        Set phRegex to hoRegExp
82192>>>>>>>
82192>>>>>>>    End_Procedure
82193>>>>>>>
82193>>>>>>>    Procedure Set Pattern String sPattern
82195>>>>>>>        Set psPattern to sPattern
82196>>>>>>>        Set ComPattern of (phRegex(Self)) to sPattern
82197>>>>>>>    End_Procedure
82198>>>>>>>
82198>>>>>>>    Procedure Set IgnoreCase Boolean bVal
82200>>>>>>>        Set ComIgnoreCase of (phRegex(Self)) to bVal
82201>>>>>>>    End_Procedure
82202>>>>>>>
82202>>>>>>>    Procedure Set GlobalFind Boolean bVal
82204>>>>>>>        Set ComGlobal of (phRegex(Self)) to bVal
82205>>>>>>>    End_Procedure
82206>>>>>>>
82206>>>>>>>    Function Test String sSource Returns Boolean
82208>>>>>>>        Function_Return (ComTest(phRegex(Self),sSource))
82209>>>>>>>    End_Function
82210>>>>>>>
82210>>>>>>>    Function StringReplace String sSource String sWith Returns String
82212>>>>>>>        Function_Return (ComReplace(phRegex(Self),sSource,sWith))
82213>>>>>>>    End_Function
82214>>>>>>>
82214>>>>>>>End_Class
82215>>>>>>>
82215>>>>>>>// Global functions
82215>>>>>>>Function Regex_Replace Global String sSource String sReplaceWith String sPattern Boolean bIgnoreCase Returns String
82217>>>>>>>    Handle hRegEx
82217>>>>>>>    String sRetVal
82217>>>>>>>
82217>>>>>>>    Get Create (RefClass(cRegularExpressions)) to hRegEx
82218>>>>>>>    If (hRegEx > 0) Begin
82220>>>>>>>        If (num_arguments = 4) Begin
82222>>>>>>>            Set IgnoreCase of hRegEx to bIgnoreCase
82223>>>>>>>        End
82223>>>>>>>>
82223>>>>>>>        Set Pattern of hRegEx to sPattern
82224>>>>>>>        Set GlobalFind of hRegEx to True
82225>>>>>>>        Get StringReplace of hRegEx sSource sReplaceWith to sRetVal
82226>>>>>>>        Send Destroy of hRegEx
82227>>>>>>>    End
82227>>>>>>>>
82227>>>>>>>    Else Begin
82228>>>>>>>        Error DFERR_PROGRAM "Cound not instantiate cRegex class"
82229>>>>>>>>
82229>>>>>>>    End
82229>>>>>>>>
82229>>>>>>>
82229>>>>>>>    Function_Return sRetVal
82230>>>>>>>
82230>>>>>>>End_Function
82231>>>>>>>
82231>>>>>>>Function Regex_IsMatch Global String sInput String sPattern Boolean bIgnoreCase Returns Boolean
82233>>>>>>>    Handle hRegEx
82233>>>>>>>    Boolean bIsMatch
82233>>>>>>>
82233>>>>>>>    Get Create (RefClass(cRegularExpressions)) to hRegEx
82234>>>>>>>    If (hRegEx > 0) Begin
82236>>>>>>>        If (num_arguments = 3) Begin
82238>>>>>>>            Set IgnoreCase of hRegEx to bIgnoreCase
82239>>>>>>>        End
82239>>>>>>>>
82239>>>>>>>        Set Pattern of hRegEx to sPattern
82240>>>>>>>        Set GlobalFind of hRegEx to True
82241>>>>>>>        Get Test of hRegEx (Trim(sInput)) to bIsMatch
82242>>>>>>>        Send Destroy of hRegEx
82243>>>>>>>    End
82243>>>>>>>>
82243>>>>>>>    Else Begin
82244>>>>>>>        Error DFERR_PROGRAM "Cound not instantiate cRegex class"
82245>>>>>>>>
82245>>>>>>>    End
82245>>>>>>>>
82245>>>>>>>
82245>>>>>>>    Function_Return bIsMatch
82246>>>>>>>
82246>>>>>>>End_Function
82247>>>>>>>
82247>>>>>>>Function Regex_Match Global String sInput String sPattern Boolean bIgnoreCase Returns tRegexMatch[]
82249>>>>>>>    Variant vMatchCollection vMatch
82249>>>>>>>    Integer iItems iItem
82249>>>>>>>    Handle hMatchCollection hRegEx hMatch
82249>>>>>>>    tRegexMatch match null
82249>>>>>>>    tRegexMatch match null
82249>>>>>>>    tRegexMatch[] matchArr
82249>>>>>>>    tRegexMatch[] matchArr
82250>>>>>>>
82250>>>>>>>    Get Create (RefClass(cRegularExpressions)) to hRegEx
82251>>>>>>>
82251>>>>>>>    If (hRegEx > 0) Begin
82253>>>>>>>        If (num_arguments = 3) Begin
82255>>>>>>>            Set IgnoreCase of hRegEx to bIgnoreCase
82256>>>>>>>        End
82256>>>>>>>>
82256>>>>>>>        Set Pattern of hRegEx to sPattern
82257>>>>>>>        Set GlobalFind of hRegEx to True
82258>>>>>>>        Get Create (RefClass(cComRegExMatchCollection)) to hMatchCollection
82259>>>>>>>        Get ComExecute of (phRegex(hRegEx)) sInput to vMatchCollection
82260>>>>>>>        If (not(IsNullComObject(vMatchCollection))) Begin
82262>>>>>>>            Set pvComObject of hMatchCollection to vMatchCollection
82263>>>>>>>            Get ComCount of hMatchCollection to iItems
82264>>>>>>>            For iItem from 1 to iItems
82270>>>>>>>>
82270>>>>>>>                Get Create (RefClass(cComRegExMatch)) to hMatch
82271>>>>>>>                Get ComItem of hMatchCollection (iItem-1) to vMatch
82272>>>>>>>                Set pvComObject of hMatch to vMatch
82273>>>>>>>                Get ComValue of hMatch to match.Val
82274>>>>>>>                Get ComFirstIndex of hMatch to match.FirstIndex
82275>>>>>>>                Get ComLength of hMatch to match.Length
82276>>>>>>>                Move match to matchArr[SizeOfArray(matchArr)]
82277>>>>>>>                Send Destroy of hMatch
82278>>>>>>>            Loop
82279>>>>>>>>
82279>>>>>>>        End
82279>>>>>>>>
82279>>>>>>>        Else Begin
82280>>>>>>>            Error DFERR_COM_OBJECT_METHOD_INVOCATION_ERROR "Invalid regex pattern"
82281>>>>>>>>
82281>>>>>>>        End
82281>>>>>>>>
82281>>>>>>>        Send Destroy of hMatchCollection
82282>>>>>>>        Send Destroy of hRegEx
82283>>>>>>>    End
82283>>>>>>>>
82283>>>>>>>    Else Begin
82284>>>>>>>        Error DFERR_PROGRAM "Cound not instantiate cRegex class"
82285>>>>>>>>
82285>>>>>>>    End
82285>>>>>>>>
82285>>>>>>>
82285>>>>>>>    Function_Return matchArr
82286>>>>>>>
82286>>>>>>>End_Function
82287>>>>>Use cRemoveUnusedLocals.pkg                  
Including file: cRemoveUnusedLocals.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRemoveUnusedLocals.pkg)
82287>>>>>>>//------------------------------------------------------------->
82287>>>>>>>// ReportUnusedLocals.pkg
82287>>>>>>>//      R.Worsley 3/09/2008
82287>>>>>>>//      Locate any unused local variables
82287>>>>>>>//      Conditions:
82287>>>>>>>//          Variables declared in the method line are not checked
82287>>>>>>>//          Read notes below on StringTokenizer
82287>>>>>>>//          Will work with the old "Local" as a descriptor
82287>>>>>>>//          Variables can be declared anywhere in the method
82287>>>>>>>//
82287>>>>>>>//      If used as a class in an another application, there are
82287>>>>>>>//      a couple of properties that can be set to automate the
82287>>>>>>>//      input and output file names.  See the property descriptions
82287>>>>>>>//      in class cReportUnusedLocals
82287>>>>>>>//
82287>>>>>>>//------------------------------------------------------------>
82287>>>>>>>//  04/08/2008 RLW  - Make into a class so the process can be
82287>>>>>>>//                   incorporated into other applications
82287>>>>>>>//  04/12/2008 RLW  - Change read/write registry process
82287>>>>>>>//  04/12/2008 RLW  - Fix so that wrapped variables on the function
82287>>>>>>>//                   or procedure line won't show odd results
82287>>>>>>>//  06/22/2008 RLW  - Add missing Seq_Release_Channel calls
82287>>>>>>>//  06/30/2018 Nils - Changed to use registry functions of the cApplication class.
82287>>>>>>>//  10/26/2018 Nils - Rewrote to use a struct instead of multi-dimensional array,
82287>>>>>>>//                    and to actually remove unused local variables (!), not just create a report.
82287>>>>>>>//  11/03/2018 Nils - Rewrote most of the logic to make it more robust. Removed the StringTokenizer
82287>>>>>>>//                    code to instead use the build in StrSplitToArray function.
82287>>>>>>>//  09/09/2021 Nils - Merged all generalized functions with the cRefactorFunctionLibrary class.
82287>>>>>>>//                    Also moved most constant declarations to SourceCode.inc
82287>>>>>>>//------------------------------------------------------------->
82287>>>>>>>Use cApplication.pkg
82287>>>>>>>Use Batchdd.pkg
82287>>>>>>>
82287>>>>>>>Global_Variable Handle ghoRefactorFunctionLibrary
82287>>>>>>>
82287>>>>>>>Use cRefactorFunctionLibrary.pkg
Including file: cRefactorFunctionLibrary.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cRefactorFunctionLibrary.pkg)
82287>>>>>>>>>Use UI
82287>>>>>>>>>Use RefactorFunctionConstants.inc
82287>>>>>>>>>Use cScintillaRefactorEditor.pkg
Including file: cScintillaRefactorEditor.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cScintillaRefactorEditor.pkg)
82287>>>>>>>>>>>Use cScintillaEdit.pkg
Including file: cScintillaEdit.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cScintillaEdit.pkg)
82287>>>>>>>>>>>>>Use cSciLexerSupport.pkg
82287>>>>>>>>>>>>>Use cSciLexerRefactor.pkg
Including file: cSciLexerRefactor.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexerRefactor.pkg)
82287>>>>>>>>>>>>>>>//TH-Header
82287>>>>>>>>>>>>>>>//*****************************************************************************************
82287>>>>>>>>>>>>>>>// Copyright (c)  2018 VDF-Guidance
82287>>>>>>>>>>>>>>>// All rights reserved.
82287>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>// $FileName    : cSciLexerRefactor.pkg
82287>>>>>>>>>>>>>>>// $ProjectName : TheHammer3
82287>>>>>>>>>>>>>>>// $Authors     :
82287>>>>>>>>>>>>>>>// $Created     : 02.09.2018  00:16
82287>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>// Contents:
82287>>>>>>>>>>>>>>>//  Additional class to move the refactoring logic into a subclass
82287>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>//*****************************************************************************************
82287>>>>>>>>>>>>>>>//TH-RevisionStart
82287>>>>>>>>>>>>>>>// ********************
82287>>>>>>>>>>>>>>>// MODIFICATION SUMMARY
82287>>>>>>>>>>>>>>>// ********************
82287>>>>>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
82287>>>>>>>>>>>>>>>//TH-RevisionEnd
82287>>>>>>>>>>>>>>>
82287>>>>>>>>>>>>>>>Use cSciLexer.pkg
Including file: cSciLexer.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexer.pkg)
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// File: cSciLexer.pkg
82287>>>>>>>>>>>>>>>>>// Author: Wil van Antwerpen
82287>>>>>>>>>>>>>>>>>// Date: March 2017
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// The scintilla control is made accessible here via the cSciLexer class and it's implementation has been designed to
82287>>>>>>>>>>>>>>>>>// be almost a drop-in replacement for the codemax control that was previously the control used for editing by the Hammer.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// As development on codemax has ceased years ago and we need to go forward, scintilla ended up being the best match.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// Note that the intention is to phase out codemax and that the backwards compatibility is likely to fade over time as
82287>>>>>>>>>>>>>>>>>// new scintilla only feature(s) will make it into the product.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// This is only designed this way to make the transition period from codemax to scintilla as smooth as can be.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// Codemax compatible methods are prefixed by CM_
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// Documentation for the scintilla control can be found here:
82287>>>>>>>>>>>>>>>>>// http://www.scintilla.org/ScintillaDoc.html
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// This wrapper is licensed under the 2 clause BSD license as to make it as easy as possible to re-use if needed.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// BSD License content start
82287>>>>>>>>>>>>>>>>>// *********************************************************************************************************
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// Copyright (c) 2017, Wil van Antwerpen
82287>>>>>>>>>>>>>>>>>// All rights reserved.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// Redistribution and use in source and binary forms, with or without
82287>>>>>>>>>>>>>>>>>// modification, are permitted provided that the following conditions are met:
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// 1. Redistributions of source code must retain the above copyright notice, this
82287>>>>>>>>>>>>>>>>>//    list of conditions and the following disclaimer.
82287>>>>>>>>>>>>>>>>>// 2. Redistributions in binary form must reproduce the above copyright notice,
82287>>>>>>>>>>>>>>>>>//    this list of conditions and the following disclaimer in the documentation
82287>>>>>>>>>>>>>>>>>//    and/or other materials provided with the distribution.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
82287>>>>>>>>>>>>>>>>>// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
82287>>>>>>>>>>>>>>>>>// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
82287>>>>>>>>>>>>>>>>>// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
82287>>>>>>>>>>>>>>>>>// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
82287>>>>>>>>>>>>>>>>>// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
82287>>>>>>>>>>>>>>>>>// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
82287>>>>>>>>>>>>>>>>>// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
82287>>>>>>>>>>>>>>>>>// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
82287>>>>>>>>>>>>>>>>>// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
82287>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>// The views and conclusions contained in the software and documentation are those
82287>>>>>>>>>>>>>>>>>// of the authors and should not be interpreted as representing official policies,
82287>>>>>>>>>>>>>>>>>// either expressed or implied, of the VDF-Guidance / Hammer Project.
82287>>>>>>>>>>>>>>>>>// *********************************************************************************************************
82287>>>>>>>>>>>>>>>>>
82287>>>>>>>>>>>>>>>>>
82287>>>>>>>>>>>>>>>>>Use cWinFunc.pkg
Including file: cWinFunc.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cWinFunc.pkg)
82287>>>>>>>>>>>>>>>>>>>//***************************************************************************
82287>>>>>>>>>>>>>>>>>>>// binary.pkg
82287>>>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>>>// Copyright (c) 1999-2001 Out of the Box Consulting, Inc.
82287>>>>>>>>>>>>>>>>>>>// All rights reserved.
82287>>>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>>>//***************************************************************************
82287>>>>>>>>>>>>>>>>>>>//  Description:
82287>>>>>>>>>>>>>>>>>>>//      This is a collection of functions/procedures to aid in binary
82287>>>>>>>>>>>>>>>>>>>//      operations.
82287>>>>>>>>>>>>>>>>>>>//
82287>>>>>>>>>>>>>>>>>>>//  Author: Oliver T. Nelson, Sture Anderson
82287>>>>>>>>>>>>>>>>>>>//***************************************************************************
82287>>>>>>>>>>>>>>>>>>>
82287>>>>>>>>>>>>>>>>>>>Function lshift Global Integer iVal Integer iPositions Returns Integer
82289>>>>>>>>>>>>>>>>>>>    Integer i
82289>>>>>>>>>>>>>>>>>>>    BigInt bVal
82289>>>>>>>>>>>>>>>>>>>    For i From 1 To iPositions
82295>>>>>>>>>>>>>>>>>>>>
82295>>>>>>>>>>>>>>>>>>>        Move (iVal * 2) To bVal
82296>>>>>>>>>>>>>>>>>>>        If (bVal >= 2147483648) ;            Move (bVal - 2147483648) To iVal
82299>>>>>>>>>>>>>>>>>>>        Else ;            Move bVal To iVal
82301>>>>>>>>>>>>>>>>>>>    Loop
82302>>>>>>>>>>>>>>>>>>>>
82302>>>>>>>>>>>>>>>>>>>    Function_Return iVal
82303>>>>>>>>>>>>>>>>>>>End_Function
82304>>>>>>>>>>>>>>>>>>>
82304>>>>>>>>>>>>>>>>>>>Function rshift Global Integer iVal Integer iPositions Returns Integer
82306>>>>>>>>>>>>>>>>>>>    Function_Return (iVal / (2^iPositions))
82307>>>>>>>>>>>>>>>>>>>End_Function
82308>>>>>>>>>>>>>>>>>>>
82308>>>>>>>>>>>>>>>>>>>Function rshiftabs Global Integer iVal Integer iPositions Returns Integer
82310>>>>>>>>>>>>>>>>>>>    UInteger iCnt
82310>>>>>>>>>>>>>>>>>>>    Number nVal
82310>>>>>>>>>>>>>>>>>>>
82310>>>>>>>>>>>>>>>>>>>    If (iVal < 0) Begin
82312>>>>>>>>>>>>>>>>>>>        Move (Number(iVal) + Number(4294967296)) To nVal
82313>>>>>>>>>>>>>>>>>>>        Move (nVal / (2^iPositions)) To iVal
82314>>>>>>>>>>>>>>>>>>>    End
82314>>>>>>>>>>>>>>>>>>>>
82314>>>>>>>>>>>>>>>>>>>    Else Begin
82315>>>>>>>>>>>>>>>>>>>        Move (iVal / (2^iPositions)) To iVal
82316>>>>>>>>>>>>>>>>>>>    End
82316>>>>>>>>>>>>>>>>>>>>
82316>>>>>>>>>>>>>>>>>>>    Function_Return iVal
82317>>>>>>>>>>>>>>>>>>>End_Function
82318>>>>>>>>>>>>>>>>>>>
82318>>>>>>>>>>>>>>>>>>>Function rol Global Integer iVal Integer iCnt Returns Integer
82320>>>>>>>>>>>>>>>>>>>    Function_Return (lshift(iVal, iCnt) Ior rshiftabs(iVal, (32 - iCnt)))
82321>>>>>>>>>>>>>>>>>>>End_Function
82322>>>>>>>>>>>>>>>>>>>
82322>>>>>>>>>>>>>>>>>>>Function inot Global Integer iValue Returns Integer
82324>>>>>>>>>>>>>>>>>>>    Function_Return ( (iValue * -1) - 1)
82325>>>>>>>>>>>>>>>>>>>End_Function
82326>>>>>>>>>>>>>>>>>>>
82326>>>>>>>>>>>>>>>>>>>Function xor Global Integer i1 Integer i2 Returns Integer
82328>>>>>>>>>>>>>>>>>>>    Function_Return ( (i1 Ior i2) - (i1 Iand i2) )
82329>>>>>>>>>>>>>>>>>>>End_Function
82330>>>>>>>>>>>>>>>>>>>
82330>>>>>>>>>>>>>>>>>>>// **WvA: 27-07-2004 Check added is already declared in VDFQuery strings.nui
82330>>>>>>>>>>>>>>>>>>>Function ByteToHex Global Integer byte# Returns String
82332>>>>>>>>>>>>>>>>>>>    Function_Return (Mid("0123456789ABCDEF",1,byte#/16+1)+Mid("0123456789ABCDEF",1,(byte# Iand 15)+1))
82333>>>>>>>>>>>>>>>>>>>End_Function
82334>>>>>>>>>>>>>>>>>>>
82334>>>>>>>>>>>>>>>>>>>Function WordToByte Global Integer wI  Returns String
82336>>>>>>>>>>>>>>>>>>>    Function_Return (Character(wI Iand 255)+Character(wI/256))
82337>>>>>>>>>>>>>>>>>>>End_Function
82338>>>>>>>>>>>>>>>>>>>
82338>>>>>>>>>>>>>>>>>>>Function WordToHex Global Integer wI  Returns String
82340>>>>>>>>>>>>>>>>>>>    Function_Return (ByteToHex(Character(wI Iand 255))+ByteToHex(Character(wI/256)))
82341>>>>>>>>>>>>>>>>>>>End_Function
82342>>>>>>>>>>>>>>>>>>>
82342>>>>>>>>>>>>>>>>>>>Function DwordToHex Global Integer aDWord Returns String
82344>>>>>>>>>>>>>>>>>>>    Function_Return ( ByteToHex(hi(aDWORD)/256)  +  ByteToHex(hi(aDWORD) Iand 255)  +  ByteToHex(low(aDWORD)/256)  +  ByteToHex(low(aDWORD) Iand 255)  )
82345>>>>>>>>>>>>>>>>>>>End_Function
82346>>>>>>>>>>>>>>>>>>>
82346>>>>>>>>>>>>>>>>>>>
82346>>>>>>>>>>>>>>>>>>>// Do NOT use, use UCharArrayToString instead
82346>>>>>>>>>>>>>>>>>>>Function Ptr2Str Pointer lpsDataPointer Returns String
82349>>>>>>>>>>>>>>>>>>>    String sResult sCharacter
82349>>>>>>>>>>>>>>>>>>>    Integer iVoid
82349>>>>>>>>>>>>>>>>>>>
82349>>>>>>>>>>>>>>>>>>>    If (lpsDataPointer <> 0) Begin
82351>>>>>>>>>>>>>>>>>>>        Move (ZeroString(1)) To sCharacter
82352>>>>>>>>>>>>>>>>>>>        Move (CopyMemory (AddressOf(sCharacter), lpsDataPointer, 1)) To iVoid
82353>>>>>>>>>>>>>>>>>>>        While (Ascii (sCharacter) <> 0)
82357>>>>>>>>>>>>>>>>>>>            Move (sResult + sCharacter) To sResult
82358>>>>>>>>>>>>>>>>>>>            Increment lpsDataPointer
82359>>>>>>>>>>>>>>>>>>>            Move (CopyMemory (AddressOf(sCharacter), lpsDataPointer, 1)) To iVoid
82360>>>>>>>>>>>>>>>>>>>        Loop
82361>>>>>>>>>>>>>>>>>>>>
82361>>>>>>>>>>>>>>>>>>>    End
82361>>>>>>>>>>>>>>>>>>>>
82361>>>>>>>>>>>>>>>>>>>    Function_Return sResult
82362>>>>>>>>>>>>>>>>>>>End_Function
82363>>>>>>>>>>>>>>>>>>>
82363>>>>>>>>>>>>>>>>>Use seq_chnl.pkg
82363>>>>>>>>>>>>>>>>>Use cSciLexer.h
82363>>>>>>>>>>>>>>>>>Use cSciCommandHotKeySupport.pkg
82363>>>>>>>>>>>>>>>>>Use cNormalizeCase.pkg
Including file: cNormalizeCase.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cNormalizeCase.pkg)
82363>>>>>>>>>>>>>>>>>>>//TH-Header
82363>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
82363>>>>>>>>>>>>>>>>>>>// Copyright (c)  2017 The Kurant project
82363>>>>>>>>>>>>>>>>>>>// All rights reserved.
82363>>>>>>>>>>>>>>>>>>>//
82363>>>>>>>>>>>>>>>>>>>// $FileName    : .\Hammer\Pkg\cNormalizeCase.pkg
82363>>>>>>>>>>>>>>>>>>>// $ProjectName : TheHammer3
82363>>>>>>>>>>>>>>>>>>>// $Authors     : Wil van Antwerpen
82363>>>>>>>>>>>>>>>>>>>// $Created     : 07.06.2017  13:30
82363>>>>>>>>>>>>>>>>>>>//
82363>>>>>>>>>>>>>>>>>>>// Contents:
82363>>>>>>>>>>>>>>>>>>>//  Contains the logic to be able to store the keywords and scopewords of a language so
82363>>>>>>>>>>>>>>>>>>>//  that this can be used to adjust the casing to the preferred casing as is defined in
82363>>>>>>>>>>>>>>>>>>>//  the language configuration.
82363>>>>>>>>>>>>>>>>>>>//
82363>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
82363>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
82363>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
82363>>>>>>>>>>>>>>>>>>>
82363>>>>>>>>>>>>>>>>>>>
82363>>>>>>>>>>>>>>>>>>>Struct tWordCaseAdjust
82363>>>>>>>>>>>>>>>>>>>  Integer  iLanguage
82363>>>>>>>>>>>>>>>>>>>  String[] KeyWords
82363>>>>>>>>>>>>>>>>>>>  String[] ScopeWords
82363>>>>>>>>>>>>>>>>>>>End_Struct
82363>>>>>>>>>>>>>>>>>>>
82363>>>>>>>>>>>>>>>>>>>Class cNormalizeCase is a cObject
82364>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
82366>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
82368>>>>>>>>>>>>>>>>>>>    Property tWordCaseAdjust[] pTextAdjust
82369>>>>>>>>>>>>>>>>>>>  End_Procedure
82370>>>>>>>>>>>>>>>>>>>
82370>>>>>>>>>>>>>>>>>>>  Function WordsToArray String sWords Returns String[]
82372>>>>>>>>>>>>>>>>>>>    Integer iPos
82372>>>>>>>>>>>>>>>>>>>    String  sNewWord
82372>>>>>>>>>>>>>>>>>>>    String[] Words
82373>>>>>>>>>>>>>>>>>>>
82373>>>>>>>>>>>>>>>>>>>    While (sWords<>"")
82377>>>>>>>>>>>>>>>>>>>      Move (Pos(" ",sWords)) To iPos
82378>>>>>>>>>>>>>>>>>>>      If (iPos>0) Begin
82380>>>>>>>>>>>>>>>>>>>        Move (Left(sWords,iPos-1)) To sNewWord
82381>>>>>>>>>>>>>>>>>>>        Move sNewWord To Words[SizeOfArray(Words)]
82382>>>>>>>>>>>>>>>>>>>        Move (Replace(sNewWord+" ",sWords,"")) To sWords
82383>>>>>>>>>>>>>>>>>>>      End
82383>>>>>>>>>>>>>>>>>>>>
82383>>>>>>>>>>>>>>>>>>>      Else Begin
82384>>>>>>>>>>>>>>>>>>>        Move sWords To Words[SizeOfArray(Words)]
82385>>>>>>>>>>>>>>>>>>>        Move "" To sWords
82386>>>>>>>>>>>>>>>>>>>      End
82386>>>>>>>>>>>>>>>>>>>>
82386>>>>>>>>>>>>>>>>>>>    Loop
82387>>>>>>>>>>>>>>>>>>>>
82387>>>>>>>>>>>>>>>>>>>    Function_Return Words
82388>>>>>>>>>>>>>>>>>>>  End_Function
82389>>>>>>>>>>>>>>>>>>>
82389>>>>>>>>>>>>>>>>>>>  Procedure AddKeywords Integer iLanguage String sKeyWords
82391>>>>>>>>>>>>>>>>>>>    Boolean bInitialized
82391>>>>>>>>>>>>>>>>>>>    Integer iItem
82391>>>>>>>>>>>>>>>>>>>    String[] Words
82392>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82392>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82393>>>>>>>>>>>>>>>>>>>
82393>>>>>>>>>>>>>>>>>>>    Move False To bInitialized
82394>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
82395>>>>>>>>>>>>>>>>>>>    Get WordsToArray sKeyWords To Words
82396>>>>>>>>>>>>>>>>>>>    Get InitializedLanguage iLanguage To bInitialized
82397>>>>>>>>>>>>>>>>>>>    If (bInitialized=False) Begin
82399>>>>>>>>>>>>>>>>>>>      Move (SizeOfArray(TextAdjusts)) To iItem
82400>>>>>>>>>>>>>>>>>>>      Move iLanguage To TextAdjusts[iItem].iLanguage
82401>>>>>>>>>>>>>>>>>>>      Move Words To TextAdjusts[iItem].KeyWords
82402>>>>>>>>>>>>>>>>>>>    End
82402>>>>>>>>>>>>>>>>>>>>
82402>>>>>>>>>>>>>>>>>>>    Else Begin
82403>>>>>>>>>>>>>>>>>>>      Get LanguageItem iLanguage To iItem
82404>>>>>>>>>>>>>>>>>>>      Move (AppendArray(Words,TextAdjusts[iItem].KeyWords)) To TextAdjusts[iItem].KeyWords
82405>>>>>>>>>>>>>>>>>>>    End
82405>>>>>>>>>>>>>>>>>>>>
82405>>>>>>>>>>>>>>>>>>>    Move (SortArray(TextAdjusts[iItem].KeyWords, Desktop, (RefFunc(DFSTRICMP)))) To TextAdjusts[iItem].KeyWords
82406>>>>>>>>>>>>>>>>>>>    Set pTextAdjust To TextAdjusts
82407>>>>>>>>>>>>>>>>>>>  End_Procedure
82408>>>>>>>>>>>>>>>>>>>
82408>>>>>>>>>>>>>>>>>>>  Procedure AddScopewords Integer iLanguage String sScopeWords
82410>>>>>>>>>>>>>>>>>>>    Boolean bInitialized
82410>>>>>>>>>>>>>>>>>>>    Integer iItem
82410>>>>>>>>>>>>>>>>>>>    String[] Words
82411>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82411>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82412>>>>>>>>>>>>>>>>>>>
82412>>>>>>>>>>>>>>>>>>>    Move False To bInitialized
82413>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
82414>>>>>>>>>>>>>>>>>>>    Get WordsToArray sScopeWords To Words
82415>>>>>>>>>>>>>>>>>>>    Get InitializedLanguage iLanguage To bInitialized
82416>>>>>>>>>>>>>>>>>>>    If (bInitialized=False) Begin
82418>>>>>>>>>>>>>>>>>>>      Move (SizeOfArray(TextAdjusts)) To iItem
82419>>>>>>>>>>>>>>>>>>>      Move iLanguage To TextAdjusts[iItem].iLanguage
82420>>>>>>>>>>>>>>>>>>>      Move Words To TextAdjusts[iItem].ScopeWords
82421>>>>>>>>>>>>>>>>>>>    End
82421>>>>>>>>>>>>>>>>>>>>
82421>>>>>>>>>>>>>>>>>>>    Else Begin
82422>>>>>>>>>>>>>>>>>>>      Get LanguageItem iLanguage To iItem
82423>>>>>>>>>>>>>>>>>>>      Move (AppendArray(Words,TextAdjusts[iItem].ScopeWords)) To TextAdjusts[iItem].ScopeWords
82424>>>>>>>>>>>>>>>>>>>    End
82424>>>>>>>>>>>>>>>>>>>>
82424>>>>>>>>>>>>>>>>>>>    Move (SortArray(TextAdjusts[iItem].ScopeWords, Desktop, (RefFunc(DFSTRICMP)))) To TextAdjusts[iItem].ScopeWords
82425>>>>>>>>>>>>>>>>>>>    Set pTextAdjust To TextAdjusts
82426>>>>>>>>>>>>>>>>>>>  End_Procedure
82427>>>>>>>>>>>>>>>>>>>
82427>>>>>>>>>>>>>>>>>>>  Function FindKeyWord Integer iLanguage String sKeyWord Returns String
82429>>>>>>>>>>>>>>>>>>>    Integer iItem
82429>>>>>>>>>>>>>>>>>>>    Integer iSearchIndex
82429>>>>>>>>>>>>>>>>>>>    String  sWord
82429>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82429>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82430>>>>>>>>>>>>>>>>>>>
82430>>>>>>>>>>>>>>>>>>>    Get LanguageItem iLanguage To iItem
82431>>>>>>>>>>>>>>>>>>>    If (iItem>-1) Begin
82433>>>>>>>>>>>>>>>>>>>      Get pTextAdjust To TextAdjusts
82434>>>>>>>>>>>>>>>>>>>      Move (BinarySearchArray(sKeyWord, TextAdjusts[iItem].KeyWords, Desktop, (RefFunc(DFSTRICMP)))) To iSearchIndex
82435>>>>>>>>>>>>>>>>>>>      If (iSearchIndex>-1) Begin
82437>>>>>>>>>>>>>>>>>>>        Move TextAdjusts[iItem].KeyWords[iSearchIndex] To sWord
82438>>>>>>>>>>>>>>>>>>>      End
82438>>>>>>>>>>>>>>>>>>>>
82438>>>>>>>>>>>>>>>>>>>      Else ;        Move sKeyWord To sWord
82440>>>>>>>>>>>>>>>>>>>    End
82440>>>>>>>>>>>>>>>>>>>>
82440>>>>>>>>>>>>>>>>>>>    Else ;      Move sKeyWord To sWord // not found, return word unchanged
82442>>>>>>>>>>>>>>>>>>>    Function_Return sWord
82443>>>>>>>>>>>>>>>>>>>  End_Function
82444>>>>>>>>>>>>>>>>>>>
82444>>>>>>>>>>>>>>>>>>>  Function FindScopeWord Integer iLanguage String sScopeWord Returns String
82446>>>>>>>>>>>>>>>>>>>    Integer iItem
82446>>>>>>>>>>>>>>>>>>>    Integer iSearchIndex
82446>>>>>>>>>>>>>>>>>>>    String  sWord
82446>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82446>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82447>>>>>>>>>>>>>>>>>>>
82447>>>>>>>>>>>>>>>>>>>    Get LanguageItem iLanguage To iItem
82448>>>>>>>>>>>>>>>>>>>    If (iItem>-1) Begin
82450>>>>>>>>>>>>>>>>>>>      Get pTextAdjust To TextAdjusts
82451>>>>>>>>>>>>>>>>>>>      Move (BinarySearchArray(sScopeWord, TextAdjusts[iItem].ScopeWords, Desktop, (RefFunc(DFSTRICMP)))) To iSearchIndex
82452>>>>>>>>>>>>>>>>>>>      If (iSearchIndex>-1) Begin
82454>>>>>>>>>>>>>>>>>>>        Move TextAdjusts[iItem].ScopeWords[iSearchIndex] To sWord
82455>>>>>>>>>>>>>>>>>>>      End
82455>>>>>>>>>>>>>>>>>>>>
82455>>>>>>>>>>>>>>>>>>>      Else ;        Move sScopeWord To sWord
82457>>>>>>>>>>>>>>>>>>>    End
82457>>>>>>>>>>>>>>>>>>>>
82457>>>>>>>>>>>>>>>>>>>    Else ;      Move sScopeWord To sWord // not found, return word unchanged
82459>>>>>>>>>>>>>>>>>>>    Function_Return sWord
82460>>>>>>>>>>>>>>>>>>>  End_Function
82461>>>>>>>>>>>>>>>>>>>
82461>>>>>>>>>>>>>>>>>>>  Function LanguageItem Integer iLanguage Returns Integer
82463>>>>>>>>>>>>>>>>>>>    Integer iItem iCount iFound
82463>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82463>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82464>>>>>>>>>>>>>>>>>>>
82464>>>>>>>>>>>>>>>>>>>    Move -1 To iFound
82465>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
82466>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(TextAdjusts)) To iCount
82467>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
82469>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
82475>>>>>>>>>>>>>>>>>>>>
82475>>>>>>>>>>>>>>>>>>>        If (TextAdjusts[iItem].iLanguage=iLanguage) Begin
82477>>>>>>>>>>>>>>>>>>>          Move iItem To iFound
82478>>>>>>>>>>>>>>>>>>>          Move iCount To iItem
82479>>>>>>>>>>>>>>>>>>>        End
82479>>>>>>>>>>>>>>>>>>>>
82479>>>>>>>>>>>>>>>>>>>      Loop
82480>>>>>>>>>>>>>>>>>>>>
82480>>>>>>>>>>>>>>>>>>>    End
82480>>>>>>>>>>>>>>>>>>>>
82480>>>>>>>>>>>>>>>>>>>    Function_Return iFound
82481>>>>>>>>>>>>>>>>>>>  End_Function
82482>>>>>>>>>>>>>>>>>>>
82482>>>>>>>>>>>>>>>>>>>  Function InitializedLanguage Integer iLanguage Returns Boolean
82484>>>>>>>>>>>>>>>>>>>    Boolean bInitialized
82484>>>>>>>>>>>>>>>>>>>    Integer iItem iCount
82484>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82484>>>>>>>>>>>>>>>>>>>    tWordCaseAdjust[] TextAdjusts
82485>>>>>>>>>>>>>>>>>>>
82485>>>>>>>>>>>>>>>>>>>    Move False To bInitialized
82486>>>>>>>>>>>>>>>>>>>    Get pTextAdjust To TextAdjusts
82487>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(TextAdjusts)) To iCount
82488>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
82490>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
82496>>>>>>>>>>>>>>>>>>>>
82496>>>>>>>>>>>>>>>>>>>        If (TextAdjusts[iItem].iLanguage=iLanguage) Begin
82498>>>>>>>>>>>>>>>>>>>          Move True To bInitialized
82499>>>>>>>>>>>>>>>>>>>          Move iCount To iItem
82500>>>>>>>>>>>>>>>>>>>        End
82500>>>>>>>>>>>>>>>>>>>>
82500>>>>>>>>>>>>>>>>>>>      Loop
82501>>>>>>>>>>>>>>>>>>>>
82501>>>>>>>>>>>>>>>>>>>    End
82501>>>>>>>>>>>>>>>>>>>>
82501>>>>>>>>>>>>>>>>>>>    Function_Return bInitialized
82502>>>>>>>>>>>>>>>>>>>  End_Function
82503>>>>>>>>>>>>>>>>>>>End_Class
82504>>>>>>>>>>>>>>>>>>>
82504>>>>>>>>>>>>>>>>>>>Object oNormalizeCase is a cNormalizeCase
82506>>>>>>>>>>>>>>>>>>>End_Object
82507>>>>>>>>>>>>>>>>>>>
82507>>>>>>>>>>>>>>>>>Use cSciLexerLanguageMixin.pkg
Including file: cSciLexerLanguageMixin.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciLexerLanguageMixin.pkg)
82507>>>>>>>>>>>>>>>>>>>//TH-Header
82507>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
82507>>>>>>>>>>>>>>>>>>>// Copyright (c)  2017 The Kurant project
82507>>>>>>>>>>>>>>>>>>>// All rights reserved.
82507>>>>>>>>>>>>>>>>>>>//
82507>>>>>>>>>>>>>>>>>>>// $FileName    : Pkg\cSciLexerLanguageMixin.pkg
82507>>>>>>>>>>>>>>>>>>>// $ProjectName : TheHammer3
82507>>>>>>>>>>>>>>>>>>>// $Authors     : wil
82507>>>>>>>>>>>>>>>>>>>// $Created     : 07.16.2017  01:11
82507>>>>>>>>>>>>>>>>>>>//
82507>>>>>>>>>>>>>>>>>>>// Contents:
82507>>>>>>>>>>>>>>>>>>>// A mixin class to help support multiple languages from within the hammer 3.
82507>>>>>>>>>>>>>>>>>>>// Not all of the languages that are in this mixin class are already supported, the supported ones
82507>>>>>>>>>>>>>>>>>>>// can be found in the LexerColorStyles function.
82507>>>>>>>>>>>>>>>>>>>//
82507>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
82507>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
82507>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
82507>>>>>>>>>>>>>>>>>>>Use cSciLexer.h
82507>>>>>>>>>>>>>>>>>>>
82507>>>>>>>>>>>>>>>>>>>Class cSciLexerLanguageMixin is a Mixin
82508>>>>>>>>>>>>>>>>>>>
82508>>>>>>>>>>>>>>>>>>>  Procedure Define_cSciLexerLanguageMixin
82510>>>>>>>>>>>>>>>>>>>  End_Procedure
82511>>>>>>>>>>>>>>>>>>>
82511>>>>>>>>>>>>>>>>>>>  Function SCKeywords String sKeyWords Returns String
82513>>>>>>>>>>>>>>>>>>>    Function_Return (Trim(Replaces("\n", sKeywords, " ")))
82514>>>>>>>>>>>>>>>>>>>  End_Function
82515>>>>>>>>>>>>>>>>>>>
82515>>>>>>>>>>>>>>>>>>>  Function ScintillaLexerForLanguage String sLanguage Returns String
82517>>>>>>>>>>>>>>>>>>>    String sLexer
82517>>>>>>>>>>>>>>>>>>>    Move (Lowercase(Trim(sLanguage))) To sLanguage
82518>>>>>>>>>>>>>>>>>>>    Case Begin
82518>>>>>>>>>>>>>>>>>>>      Case (sLanguage="vdf")
82520>>>>>>>>>>>>>>>>>>>        Move "dataflex" To sLexer
82521>>>>>>>>>>>>>>>>>>>        Case Break
82522>>>>>>>>>>>>>>>>>>>      Case (sLanguage="assembler a68k")
82525>>>>>>>>>>>>>>>>>>>        Move "a68k" To sLexer
82526>>>>>>>>>>>>>>>>>>>        Case Break
82527>>>>>>>>>>>>>>>>>>>      Case (sLanguage="abaqus") // ABAQUX
82530>>>>>>>>>>>>>>>>>>>        Move "abaqus" To sLexer
82531>>>>>>>>>>>>>>>>>>>        Case Break
82532>>>>>>>>>>>>>>>>>>>      Case (sLanguage="ada 95") // ada 95
82535>>>>>>>>>>>>>>>>>>>        Move "ada" To sLexer
82536>>>>>>>>>>>>>>>>>>>        Case Break
82537>>>>>>>>>>>>>>>>>>>      Case (sLanguage="apdl") // APDL
82540>>>>>>>>>>>>>>>>>>>        Move "apdl" To sLexer
82541>>>>>>>>>>>>>>>>>>>        Case Break
82542>>>>>>>>>>>>>>>>>>>      Case (sLanguage="assembler masm") // assembler MASM
82545>>>>>>>>>>>>>>>>>>>        Move "asm" To sLexer            // has a 2nd lexer?
82546>>>>>>>>>>>>>>>>>>>        Case Break
82547>>>>>>>>>>>>>>>>>>>      Case (sLanguage="asn.1")  // Lexer for ASN.1
82550>>>>>>>>>>>>>>>>>>>        Move "asn1" To sLexer
82551>>>>>>>>>>>>>>>>>>>        Case Break
82552>>>>>>>>>>>>>>>>>>>      Case (sLanguage="autoit3") // Lexer for AutoIt3
82555>>>>>>>>>>>>>>>>>>>        Move "au3" To sLexer
82556>>>>>>>>>>>>>>>>>>>        Case Break
82557>>>>>>>>>>>>>>>>>>>      Case (sLanguage="avenue") // Lexer for Avenue
82560>>>>>>>>>>>>>>>>>>>        Move "ave" To sLexer
82561>>>>>>>>>>>>>>>>>>>        Case Break
82562>>>>>>>>>>>>>>>>>>>      Case (sLanguage="avisynth") // Lexer for AviSynth.
82565>>>>>>>>>>>>>>>>>>>        Move "avs" To sLexer
82566>>>>>>>>>>>>>>>>>>>        Case Break
82567>>>>>>>>>>>>>>>>>>>      Case (sLanguage="baan") // Lexer for Baan.
82570>>>>>>>>>>>>>>>>>>>        Move "baan" To sLexer
82571>>>>>>>>>>>>>>>>>>>        Case Break
82572>>>>>>>>>>>>>>>>>>>      Case (sLanguage="bash") // Lexer for Bash.
82575>>>>>>>>>>>>>>>>>>>        Move "bash" To sLexer
82576>>>>>>>>>>>>>>>>>>>        Case Break
82577>>>>>>>>>>>>>>>>>>>      Case (sLanguage="blitz basic")  // Lexer for BlitzBasic and PureBasic.
82580>>>>>>>>>>>>>>>>>>>        Move "blitzbasic" To sLexer
82581>>>>>>>>>>>>>>>>>>>        Case Break
82582>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pure basic")
82585>>>>>>>>>>>>>>>>>>>        Move "purebasic" To sLexer
82586>>>>>>>>>>>>>>>>>>>        Case Break
82587>>>>>>>>>>>>>>>>>>>      Case (sLanguage="free basic")
82590>>>>>>>>>>>>>>>>>>>        Move "freebasic" To sLexer
82591>>>>>>>>>>>>>>>>>>>        Case Break
82592>>>>>>>>>>>>>>>>>>>      Case (sLanguage="batch files")  // Lexer for batch files.
82595>>>>>>>>>>>>>>>>>>>        Move "batch" To sLexer
82596>>>>>>>>>>>>>>>>>>>        Case Break
82597>>>>>>>>>>>>>>>>>>>      Case (sLanguage="bibtex")  // General BibTeX coloring scheme.
82600>>>>>>>>>>>>>>>>>>>        Move "bib" To sLexer
82601>>>>>>>>>>>>>>>>>>>        Case Break
82602>>>>>>>>>>>>>>>>>>>      Case (sLanguage="bullant") // lexer for Bullant
82605>>>>>>>>>>>>>>>>>>>        Move "bullant" To sLexer
82606>>>>>>>>>>>>>>>>>>>        Case Break
82607>>>>>>>>>>>>>>>>>>>      Case (sLanguage="objective caml") // Lexer for Objective Caml
82610>>>>>>>>>>>>>>>>>>>        Move "caml" To sLexer
82611>>>>>>>>>>>>>>>>>>>        Case Break
82612>>>>>>>>>>>>>>>>>>>      Case (sLanguage="clarion") // Case Sensitive Clarion Language Lexer
82615>>>>>>>>>>>>>>>>>>>        Move "clarion" To sLexer
82616>>>>>>>>>>>>>>>>>>>        Case Break
82617>>>>>>>>>>>>>>>>>>>      Case (sLanguage="clarion case insensitive") // Case Insensitive Clarion Language Lexer
82620>>>>>>>>>>>>>>>>>>>        Move "clarionnocase" To sLexer
82621>>>>>>>>>>>>>>>>>>>        Case Break
82622>>>>>>>>>>>>>>>>>>>      Case (sLanguage="cmake") // Lexer for Cmake
82625>>>>>>>>>>>>>>>>>>>        Move "cmake" To sLexer
82626>>>>>>>>>>>>>>>>>>>        Case Break
82627>>>>>>>>>>>>>>>>>>>      Case (sLanguage="cobol") // Lexer for COBOL
82630>>>>>>>>>>>>>>>>>>>        Move "COBOL" To sLexer
82631>>>>>>>>>>>>>>>>>>>        Case Break
82632>>>>>>>>>>>>>>>>>>>      Case (sLanguage="coffeescript") // Lexer for CoffeeScript.
82635>>>>>>>>>>>>>>>>>>>        Move "coffeescript" To sLexer
82636>>>>>>>>>>>>>>>>>>>        Case Break
82637>>>>>>>>>>>>>>>>>>>      Case (sLanguage="apache configuration files") // Lexer for Apache Configuration Files.
82640>>>>>>>>>>>>>>>>>>>        Move "conf" To sLexer
82641>>>>>>>>>>>>>>>>>>>        Case Break
82642>>>>>>>>>>>>>>>>>>>      Case (sLanguage="c/c++") // Lexer for C++, C, Java, and JavaScript.
82645>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
82646>>>>>>>>>>>>>>>>>>>        Case Break
82647>>>>>>>>>>>>>>>>>>>      Case (sLanguage="java") // Lexer for C++, C, Java, and JavaScript.
82650>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
82651>>>>>>>>>>>>>>>>>>>        Case Break
82652>>>>>>>>>>>>>>>>>>>      Case (sLanguage="javascript") // Lexer for C++, C, Java, and JavaScript.
82655>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
82656>>>>>>>>>>>>>>>>>>>        Case Break
82657>>>>>>>>>>>>>>>>>>>      Case (sLanguage="csharp") // Lexer for C++, C, Java, and JavaScript.
82660>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
82661>>>>>>>>>>>>>>>>>>>        Case Break
82662>>>>>>>>>>>>>>>>>>>      Case (sLanguage="go") // Lexer for C++, C, Java, and JavaScript.
82665>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
82666>>>>>>>>>>>>>>>>>>>        Case Break
82667>>>>>>>>>>>>>>>>>>>      Case (sLanguage="swift") // Lexer for C++, C, Java, and JavaScript.
82670>>>>>>>>>>>>>>>>>>>        Move "cpp" To sLexer
82671>>>>>>>>>>>>>>>>>>>        Case Break
82672>>>>>>>>>>>>>>>>>>>      Case (sLanguage="c/c++ case insensitive") // Lexer for C++, C, Java, and JavaScript case insensitive
82675>>>>>>>>>>>>>>>>>>>        Move "cppnocase" To sLexer
82676>>>>>>>>>>>>>>>>>>>        Case Break
82677>>>>>>>>>>>>>>>>>>>      Case (sLanguage="nncron files") //Lexer to use with extended crontab files used by Windows scheduler/event monitor/automation manager nnCron.
82680>>>>>>>>>>>>>>>>>>>        Move "nncrontab" To sLexer
82681>>>>>>>>>>>>>>>>>>>        Case Break
82682>>>>>>>>>>>>>>>>>>>      Case (sLanguage="csound") //Lexer for Csound (Orchestra & Score)
82685>>>>>>>>>>>>>>>>>>>        Move "csound" To sLexer
82686>>>>>>>>>>>>>>>>>>>        Case Break
82687>>>>>>>>>>>>>>>>>>>      Case (sLanguage="css") // Lexer for Cascading Style Sheets
82690>>>>>>>>>>>>>>>>>>>        Move "css" To sLexer
82691>>>>>>>>>>>>>>>>>>>        Case Break
82692>>>>>>>>>>>>>>>>>>>      Case (sLanguage="d") // Lexer for D.
82695>>>>>>>>>>>>>>>>>>>        Move "d" To sLexer
82696>>>>>>>>>>>>>>>>>>>        Case Break
82697>>>>>>>>>>>>>>>>>>>      Case (sLanguage="diff results")  // Lexer for diff results.
82700>>>>>>>>>>>>>>>>>>>        Move "diff" To sLexer
82701>>>>>>>>>>>>>>>>>>>        Case Break
82702>>>>>>>>>>>>>>>>>>>      Case (sLanguage="msc nastran dmap") // Lexer for MSC Nastran DMAP.
82705>>>>>>>>>>>>>>>>>>>        Move "DMAP" To sLexer
82706>>>>>>>>>>>>>>>>>>>        Case Break
82707>>>>>>>>>>>>>>>>>>>      Case (sLanguage="dmis") // Lexer for DMIS.
82710>>>>>>>>>>>>>>>>>>>        Move "DMIS" To sLexer
82711>>>>>>>>>>>>>>>>>>>        Case Break
82712>>>>>>>>>>>>>>>>>>>      Case (sLanguage="ecl") // Lexer for ECL.
82715>>>>>>>>>>>>>>>>>>>        Move "ecl" To sLexer
82716>>>>>>>>>>>>>>>>>>>        Case Break
82717>>>>>>>>>>>>>>>>>>>      Case (sLanguage="edifact") // EDIFACT
82720>>>>>>>>>>>>>>>>>>>        Move "edifact" To sLexer
82721>>>>>>>>>>>>>>>>>>>        Case Break
82722>>>>>>>>>>>>>>>>>>>      Case (sLanguage="eiffel") // Lexer for Eiffel.
82725>>>>>>>>>>>>>>>>>>>        Move "eiffel" To sLexer
82726>>>>>>>>>>>>>>>>>>>        Case Break
82727>>>>>>>>>>>>>>>>>>>      Case (sLanguage="erlang") // Lexer for Erlang.
82730>>>>>>>>>>>>>>>>>>>        Move "erlang" To sLexer
82731>>>>>>>>>>>>>>>>>>>        Case Break
82732>>>>>>>>>>>>>>>>>>>      Case (sLanguage="error lists") //Lexer for error lists. Used for the output pane in SciTE.
82735>>>>>>>>>>>>>>>>>>>        Move "errorlist" To sLexer
82736>>>>>>>>>>>>>>>>>>>        Case Break
82737>>>>>>>>>>>>>>>>>>>      Case (sLanguage="escript") // Lexer for ESCRIPT
82740>>>>>>>>>>>>>>>>>>>        Move "escript" To sLexer
82741>>>>>>>>>>>>>>>>>>>        Case Break
82742>>>>>>>>>>>>>>>>>>>      Case (sLanguage="harbour and flagship") // Lexer for Harbour and FlagShip.
82745>>>>>>>>>>>>>>>>>>>        Move "flagship" To sLexer             // (Syntactically compatible to other xBase dialects, like Clipper, dBase, Clip, FoxPro etc.)
82746>>>>>>>>>>>>>>>>>>>        Case Break
82747>>>>>>>>>>>>>>>>>>>      Case (sLanguage="forth") // Lexer for FORTH
82750>>>>>>>>>>>>>>>>>>>        Move "forth" To sLexer
82751>>>>>>>>>>>>>>>>>>>        Case Break
82752>>>>>>>>>>>>>>>>>>>      Case (sLanguage="fortran") // Lexer for Fortran.
82755>>>>>>>>>>>>>>>>>>>        Move "fortran" To sLexer
82756>>>>>>>>>>>>>>>>>>>        Case Break
82757>>>>>>>>>>>>>>>>>>>      Case (sLanguage="fortran 77")
82760>>>>>>>>>>>>>>>>>>>        Move "f77" To sLexer
82761>>>>>>>>>>>>>>>>>>>        Case Break
82762>>>>>>>>>>>>>>>>>>>      Case (sLanguage="gap") // Lexer for the GAP language. (The GAP System for Computational Discrete Algebra)
82765>>>>>>>>>>>>>>>>>>>        Move "gap" To sLexer
82766>>>>>>>>>>>>>>>>>>>        Case Break
82767>>>>>>>>>>>>>>>>>>>      Case (sLanguage="gui4cli") // This is the Lexer for Gui4Cli
82770>>>>>>>>>>>>>>>>>>>        Move "gui4cli" To sLexer
82771>>>>>>>>>>>>>>>>>>>        Case Break
82772>>>>>>>>>>>>>>>>>>>      Case (sLanguage="haskell") //A haskell lexer for the scintilla code control.
82775>>>>>>>>>>>>>>>>>>>        Move "haskell" To sLexer
82776>>>>>>>>>>>>>>>>>>>        Case Break
82777>>>>>>>>>>>>>>>>>>>      Case (sLanguage="literate haskell")
82780>>>>>>>>>>>>>>>>>>>        Move "literatehaskell" To sLexer
82781>>>>>>>>>>>>>>>>>>>        Case Break
82782>>>>>>>>>>>>>>>>>>>      Case (sLanguage="hex s-record") //Lexers for Motorola S-Record, Intel HEX and Tektronix extended HEX.
82785>>>>>>>>>>>>>>>>>>>        Move "srec" To sLexer
82786>>>>>>>>>>>>>>>>>>>        Case Break
82787>>>>>>>>>>>>>>>>>>>      Case (sLanguage="hex intel")
82790>>>>>>>>>>>>>>>>>>>        Move "ihex" To sLexer
82791>>>>>>>>>>>>>>>>>>>        Case Break
82792>>>>>>>>>>>>>>>>>>>      Case (sLanguage="hex tektronix")
82795>>>>>>>>>>>>>>>>>>>        Move "tehex" To sLexer
82796>>>>>>>>>>>>>>>>>>>        Case Break
82797>>>>>>>>>>>>>>>>>>>      Case (sLanguage="html") // Lexer for HTML.
82800>>>>>>>>>>>>>>>>>>>        Move "hypertext" To sLexer
82801>>>>>>>>>>>>>>>>>>>        Case Break
82802>>>>>>>>>>>>>>>>>>>      Case (sLanguage="xml")
82805>>>>>>>>>>>>>>>>>>>        Move "xml" To sLexer
82806>>>>>>>>>>>>>>>>>>>        Case Break
82807>>>>>>>>>>>>>>>>>>>      Case (sLanguage="php")
82810>>>>>>>>>>>>>>>>>>>        Move "phpscript" To sLexer
82811>>>>>>>>>>>>>>>>>>>        Case Break
82812>>>>>>>>>>>>>>>>>>>      Case (sLanguage="inno setup script") // Lexer for Inno Setup scripts.
82815>>>>>>>>>>>>>>>>>>>        Move "inno" To sLexer
82816>>>>>>>>>>>>>>>>>>>        Case Break
82817>>>>>>>>>>>>>>>>>>>      Case (sLanguage="json") //brief Lexer for JSON and JSON-LD formats
82820>>>>>>>>>>>>>>>>>>>        Move "json" To sLexer
82821>>>>>>>>>>>>>>>>>>>        Case Break
82822>>>>>>>>>>>>>>>>>>>      Case (sLanguage="kix script")  // Lexer for KIX-Scripts.
82825>>>>>>>>>>>>>>>>>>>        Move "kix" To sLexer
82826>>>>>>>>>>>>>>>>>>>        Case Break
82827>>>>>>>>>>>>>>>>>>>      Case (sLanguage="kvirc script") // Lexer for KVIrc script.
82830>>>>>>>>>>>>>>>>>>>        Move "kvirc" To sLexer
82831>>>>>>>>>>>>>>>>>>>        Case Break
82832>>>>>>>>>>>>>>>>>>>      Case (sLanguage="latex") // Lexer for LaTeX2e.
82835>>>>>>>>>>>>>>>>>>>        Move "latex" To sLexer
82836>>>>>>>>>>>>>>>>>>>        Case Break
82837>>>>>>>>>>>>>>>>>>>      Case (sLanguage="lisp") // Lexer for Lisp.
82840>>>>>>>>>>>>>>>>>>>        Move "lisp" To sLexer
82841>>>>>>>>>>>>>>>>>>>        Case Break
82842>>>>>>>>>>>>>>>>>>>      Case (sLanguage="basser lout") // Lexer for the Basser Lout (>= version 3) typesetting language
82845>>>>>>>>>>>>>>>>>>>        Move "lout" To sLexer
82846>>>>>>>>>>>>>>>>>>>        Case Break
82847>>>>>>>>>>>>>>>>>>>      Case (sLanguage="lua") // Lexer for Lua language.
82850>>>>>>>>>>>>>>>>>>>        Move "lua" To sLexer
82851>>>>>>>>>>>>>>>>>>>        Case Break
82852>>>>>>>>>>>>>>>>>>>      Case (sLanguage="magiksf") // Lexer for GE(r) Smallworld(tm) MagikSF
82855>>>>>>>>>>>>>>>>>>>        Move "magiksf" To sLexer
82856>>>>>>>>>>>>>>>>>>>        Case Break
82857>>>>>>>>>>>>>>>>>>>      Case (sLanguage="make file") // Lexer for make files.
82860>>>>>>>>>>>>>>>>>>>        Move "makefile" To sLexer
82861>>>>>>>>>>>>>>>>>>>        Case Break
82862>>>>>>>>>>>>>>>>>>>      Case (sLanguage="markdown") // A simple Markdown lexer for scintilla.
82865>>>>>>>>>>>>>>>>>>>        Move "markdown" To sLexer
82866>>>>>>>>>>>>>>>>>>>        Case Break
82867>>>>>>>>>>>>>>>>>>>      Case (sLanguage="matlab") // Lexer for Matlab.
82870>>>>>>>>>>>>>>>>>>>        Move "matlab" To sLexer
82871>>>>>>>>>>>>>>>>>>>        Case Break
82872>>>>>>>>>>>>>>>>>>>      Case (sLanguage="octave")
82875>>>>>>>>>>>>>>>>>>>        Move "octave" To sLexer
82876>>>>>>>>>>>>>>>>>>>        Case Break
82877>>>>>>>>>>>>>>>>>>>      Case (sLanguage="metapost") // general context conformant metapost coloring scheme
82880>>>>>>>>>>>>>>>>>>>        Move "metapost" To sLexer
82881>>>>>>>>>>>>>>>>>>>        Case Break
82882>>>>>>>>>>>>>>>>>>>      Case (sLanguage="mmix assembler") // Lexer for MMIX Assembler Language.
82885>>>>>>>>>>>>>>>>>>>        Move "mmixal" To sLexer
82886>>>>>>>>>>>>>>>>>>>        Case Break
82887>>>>>>>>>>>>>>>>>>>      Case (sLanguage="modula") // brief Lexer for Modula-2/3 documents.
82890>>>>>>>>>>>>>>>>>>>        Move "modula" To sLexer
82891>>>>>>>>>>>>>>>>>>>        Case Break
82892>>>>>>>>>>>>>>>>>>>      Case (sLanguage="lot") // Lexer for MPT specific files. Based on LexOthers.cxx
82895>>>>>>>>>>>>>>>>>>>        Move "lot" To sLexer //LOT = the text log file created by the MPT application while running a test program
82896>>>>>>>>>>>>>>>>>>>        Case Break
82897>>>>>>>>>>>>>>>>>>>      Case (sLanguage="mssql") // Lexer for MSSQL.
82900>>>>>>>>>>>>>>>>>>>        Move "mssql" To sLexer
82901>>>>>>>>>>>>>>>>>>>        Case Break
82902>>>>>>>>>>>>>>>>>>>      Case (sLanguage="mysql") // Lexer for MySQL
82905>>>>>>>>>>>>>>>>>>>        Move "mysql" To sLexer
82906>>>>>>>>>>>>>>>>>>>        Case Break
82907>>>>>>>>>>>>>>>>>>>      Case (sLanguage="nimrod") // Lexer for Nimrod.
82910>>>>>>>>>>>>>>>>>>>        Move "nimrod" To sLexer
82911>>>>>>>>>>>>>>>>>>>        Case Break
82912>>>>>>>>>>>>>>>>>>>      Case (sLanguage="nsis") // Lexer for NSIS
82915>>>>>>>>>>>>>>>>>>>        Move "nsis" To sLexer
82916>>>>>>>>>>>>>>>>>>>        Case Break
82917>>>>>>>>>>>>>>>>>>>      Case (sLanguage="text") // Lexer for no language. Used for plain text and unrecognized files.
82920>>>>>>>>>>>>>>>>>>>        Move "null" To sLexer
82921>>>>>>>>>>>>>>>>>>>        Case Break
82922>>>>>>>>>>>>>>>>>>>      Case (sLanguage="opal") // Lexer for OPAL (functional language similar to Haskell)
82925>>>>>>>>>>>>>>>>>>>        Move "opal" To sLexer
82926>>>>>>>>>>>>>>>>>>>        Case Break
82927>>>>>>>>>>>>>>>>>>>      Case (sLanguage="oscript") // Lexer for OScript sources; ocx files and/or OSpace dumps.
82930>>>>>>>>>>>>>>>>>>>        Move "oscript" To sLexer
82931>>>>>>>>>>>>>>>>>>>        Case Break
82932>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pascal") // Lexer for Pascal.
82935>>>>>>>>>>>>>>>>>>>        Move "pascal" To sLexer
82936>>>>>>>>>>>>>>>>>>>        Case Break
82937>>>>>>>>>>>>>>>>>>>      Case (sLanguage="powerbasic") // Lexer for PowerBasic
82940>>>>>>>>>>>>>>>>>>>        Move "powerbasic" To sLexer
82941>>>>>>>>>>>>>>>>>>>        Case Break
82942>>>>>>>>>>>>>>>>>>>      Case (sLanguage="perl") // Lexer for Perl
82945>>>>>>>>>>>>>>>>>>>        Move "perl" To sLexer
82946>>>>>>>>>>>>>>>>>>>        Case Break
82947>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pl/m") //
82950>>>>>>>>>>>>>>>>>>>        Move "PL/M" To sLexer
82951>>>>>>>>>>>>>>>>>>>        Case Break
82952>>>>>>>>>>>>>>>>>>>      Case (sLanguage="po files") // Lexer for GetText Translation (PO) files.
82955>>>>>>>>>>>>>>>>>>>        Move "po" To sLexer
82956>>>>>>>>>>>>>>>>>>>        Case Break
82957>>>>>>>>>>>>>>>>>>>      Case (sLanguage="pov-ray sdl") // Lexer for POV-Ray SDL (Persistance of Vision Raytracer, Scene Description Language).
82960>>>>>>>>>>>>>>>>>>>        Move "pov" To sLexer
82961>>>>>>>>>>>>>>>>>>>        Case Break
82962>>>>>>>>>>>>>>>>>>>      Case (sLanguage="powerpro") // PowerPro lexer
82965>>>>>>>>>>>>>>>>>>>        Move "powerpro" To sLexer
82966>>>>>>>>>>>>>>>>>>>        Case Break
82967>>>>>>>>>>>>>>>>>>>      Case (sLanguage="powershell") // Lexer for PowerShell scripts.
82970>>>>>>>>>>>>>>>>>>>        Move "powershell" To sLexer
82971>>>>>>>>>>>>>>>>>>>        Case Break
82972>>>>>>>>>>>>>>>>>>>      Case (sLanguage="progress") //Lexer for Progress 4GL.
82975>>>>>>>>>>>>>>>>>>>        Move "abl" To sLexer
82976>>>>>>>>>>>>>>>>>>>        Case Break
82977>>>>>>>>>>>>>>>>>>>      Case (sLanguage="properties file" or sLanguage="ini") // Lexer for properties files.
82980>>>>>>>>>>>>>>>>>>>        Move "props" To sLexer
82981>>>>>>>>>>>>>>>>>>>        Case Break
82982>>>>>>>>>>>>>>>>>>>      Case (sLanguage="postscript") // Lexer for PostScript
82985>>>>>>>>>>>>>>>>>>>        Move "ps" To sLexer
82986>>>>>>>>>>>>>>>>>>>        Case Break
82987>>>>>>>>>>>>>>>>>>>      Case (sLanguage="python") // Lexer for Python.
82990>>>>>>>>>>>>>>>>>>>        Move "python" To sLexer
82991>>>>>>>>>>>>>>>>>>>        Case Break
82992>>>>>>>>>>>>>>>>>>>      Case (sLanguage="r") // Lexer for R, S, SPlus Statistics Program (Heavily derived from CPP Lexer).
82995>>>>>>>>>>>>>>>>>>>        Move "r" To sLexer
82996>>>>>>>>>>>>>>>>>>>        Case Break
82997>>>>>>>>>>>>>>>>>>>      Case (sLanguage="rebol") // Lexer for REBOL.
83000>>>>>>>>>>>>>>>>>>>        Move "rebol" To sLexer
83001>>>>>>>>>>>>>>>>>>>        Case Break
83002>>>>>>>>>>>>>>>>>>>      Case (sLanguage="windows registry") // brief Lexer for Windows registration files(.reg)
83005>>>>>>>>>>>>>>>>>>>        Move "registry" To sLexer
83006>>>>>>>>>>>>>>>>>>>        Case Break
83007>>>>>>>>>>>>>>>>>>>      Case (sLanguage="ruby") // Lexer for Ruby.
83010>>>>>>>>>>>>>>>>>>>        Move "ruby" To sLexer
83011>>>>>>>>>>>>>>>>>>>        Case Break
83012>>>>>>>>>>>>>>>>>>>      Case (sLanguage="rust") // Lexer for Rust.
83015>>>>>>>>>>>>>>>>>>>        Move "rust" To sLexer
83016>>>>>>>>>>>>>>>>>>>        Case Break
83017>>>>>>>>>>>>>>>>>>>      Case (sLanguage="scriptol") // Lexer for Scriptol.
83020>>>>>>>>>>>>>>>>>>>        Move "scriptol" To sLexer
83021>>>>>>>>>>>>>>>>>>>        Case Break
83022>>>>>>>>>>>>>>>>>>>      Case (sLanguage="smalltalk") // Lexer for Smalltalk language.
83025>>>>>>>>>>>>>>>>>>>        Move "smalltalk" To sLexer
83026>>>>>>>>>>>>>>>>>>>        Case Break
83027>>>>>>>>>>>>>>>>>>>      Case (sLanguage="sml") // Lexer for SML.
83030>>>>>>>>>>>>>>>>>>>        Move "SML" To sLexer
83031>>>>>>>>>>>>>>>>>>>        Case Break
83032>>>>>>>>>>>>>>>>>>>      Case (sLanguage="sorcus installation file") // Lexer for SORCUS installation files
83035>>>>>>>>>>>>>>>>>>>        Move "sorcins" To sLexer
83036>>>>>>>>>>>>>>>>>>>        Case Break
83037>>>>>>>>>>>>>>>>>>>      Case (sLanguage="specman") // Lexer for Specman E language.
83040>>>>>>>>>>>>>>>>>>>        Move "specman" To sLexer
83041>>>>>>>>>>>>>>>>>>>        Case Break
83042>>>>>>>>>>>>>>>>>>>      Case (sLanguage="spice") // Lexer for Spice
83045>>>>>>>>>>>>>>>>>>>        Move "spice" To sLexer
83046>>>>>>>>>>>>>>>>>>>        Case Break
83047>>>>>>>>>>>>>>>>>>>      Case (sLanguage="sql") // Lexer for SQL, including PL/SQL and SQL*Plus.
83050>>>>>>>>>>>>>>>>>>>        Move "sql" To sLexer
83051>>>>>>>>>>>>>>>>>>>        Case Break
83052>>>>>>>>>>>>>>>>>>>      Case (sLanguage="structured text") // Lexer for Structured Text language.
83055>>>>>>>>>>>>>>>>>>>        Move "fcST" To sLexer
83056>>>>>>>>>>>>>>>>>>>        Case Break
83057>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tacl") // Lexer for TAL
83060>>>>>>>>>>>>>>>>>>>        Move "TACL" To sLexer
83061>>>>>>>>>>>>>>>>>>>        Case Break
83062>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tads3") // Lexer for TADS3.
83065>>>>>>>>>>>>>>>>>>>        Move "tads3" To sLexer
83066>>>>>>>>>>>>>>>>>>>        Case Break
83067>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tal") // Lexer for TAL
83070>>>>>>>>>>>>>>>>>>>        Move "TAL" To sLexer
83071>>>>>>>>>>>>>>>>>>>        Case Break
83072>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tcl") // Lexer for TCL language.
83075>>>>>>>>>>>>>>>>>>>        Move "tcl" To sLexer
83076>>>>>>>>>>>>>>>>>>>        Case Break
83077>>>>>>>>>>>>>>>>>>>      Case (sLanguage="take command") // Lexer for Take Command / TCC batch scripts (.bat, .btm, .cmd).
83080>>>>>>>>>>>>>>>>>>>        Move "tcmd" To sLexer
83081>>>>>>>>>>>>>>>>>>>        Case Break
83082>>>>>>>>>>>>>>>>>>>      Case (sLanguage="tex coloring scheme") // File: LexTeX.cxx - general context conformant tex coloring scheme
83085>>>>>>>>>>>>>>>>>>>        Move "tex" To sLexer
83086>>>>>>>>>>>>>>>>>>>        Case Break
83087>>>>>>>>>>>>>>>>>>>      Case (sLanguage="txt2tags") // A simple Txt2tags lexer for scintilla.
83090>>>>>>>>>>>>>>>>>>>        Move "txt2tags" To sLexer
83091>>>>>>>>>>>>>>>>>>>        Case Break
83092>>>>>>>>>>>>>>>>>>>      Case (sLanguage="visual basic") // Lexer for Visual Basic and VBScript.
83095>>>>>>>>>>>>>>>>>>>        Move "vb" To sLexer
83096>>>>>>>>>>>>>>>>>>>        Case Break
83097>>>>>>>>>>>>>>>>>>>      Case (sLanguage="basic") // using vb as a default for just "basic"
83100>>>>>>>>>>>>>>>>>>>        Move "vb" To sLexer
83101>>>>>>>>>>>>>>>>>>>        Case Break
83102>>>>>>>>>>>>>>>>>>>      Case (sLanguage="vbscript")
83105>>>>>>>>>>>>>>>>>>>        Move "vbscript" To sLexer
83106>>>>>>>>>>>>>>>>>>>        Case Break
83107>>>>>>>>>>>>>>>>>>>      Case (sLanguage="verilog") // Lexer for Verilog.
83110>>>>>>>>>>>>>>>>>>>        Move "verilog" To sLexer
83111>>>>>>>>>>>>>>>>>>>        Case Break
83112>>>>>>>>>>>>>>>>>>>      Case (sLanguage="vhdl") // Lexer for VHDL
83115>>>>>>>>>>>>>>>>>>>        Move "vhdl" To sLexer
83116>>>>>>>>>>>>>>>>>>>        Case Break
83117>>>>>>>>>>>>>>>>>>>      Case (sLanguage="visual prolog") // Lexer for Visual Prolog.
83120>>>>>>>>>>>>>>>>>>>        Move "visualprolog" To sLexer
83121>>>>>>>>>>>>>>>>>>>        Case Break
83122>>>>>>>>>>>>>>>>>>>      Case (sLanguage="yaml") // Lexer for YAML.
83125>>>>>>>>>>>>>>>>>>>        Move "yaml" To sLexer
83126>>>>>>>>>>>>>>>>>>>        Case Break
83127>>>>>>>>>>>>>>>>>>>      Case Else
83127>>>>>>>>>>>>>>>>>>>        Move "dataflex" To sLexer
83128>>>>>>>>>>>>>>>>>>>    Case End
83128>>>>>>>>>>>>>>>>>>>
83128>>>>>>>>>>>>>>>>>>>    Function_Return sLexer
83129>>>>>>>>>>>>>>>>>>>  End_Function
83130>>>>>>>>>>>>>>>>>>>
83130>>>>>>>>>>>>>>>>>>>
83130>>>>>>>>>>>>>>>>>>>  Function LanguageForScintillaLexer String sLexer Returns String
83132>>>>>>>>>>>>>>>>>>>    String sLanguage
83132>>>>>>>>>>>>>>>>>>>    Move (Lowercase(Trim(sLexer))) To sLexer
83133>>>>>>>>>>>>>>>>>>>    Case Begin
83133>>>>>>>>>>>>>>>>>>>      Case (sLexer="dataflex")
83135>>>>>>>>>>>>>>>>>>>        Move "VDF" To sLanguage
83136>>>>>>>>>>>>>>>>>>>        Case Break
83137>>>>>>>>>>>>>>>>>>>        //Case (sLexer="assembler a68k")
83137>>>>>>>>>>>>>>>>>>>        //  Move "a68k" to sLexer
83137>>>>>>>>>>>>>>>>>>>        //  Case Break
83137>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="abaqus") // ABAQUS
83137>>>>>>>>>>>>>>>>>>>        //  Move "abaqus" to sLexer
83137>>>>>>>>>>>>>>>>>>>        //  Case Break
83137>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="ada 95") // ada 95
83137>>>>>>>>>>>>>>>>>>>        //  Move "ada" to sLexer
83137>>>>>>>>>>>>>>>>>>>        //  Case Break
83137>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="apdl") // APDL
83137>>>>>>>>>>>>>>>>>>>        //  Move "apdl" to sLexer
83137>>>>>>>>>>>>>>>>>>>        //  Case Break
83137>>>>>>>>>>>>>>>>>>>      Case (sLexer="asm") //
83140>>>>>>>>>>>>>>>>>>>        Move "assembler MASM" To sLanguage
83141>>>>>>>>>>>>>>>>>>>        Case Break
83142>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="asn.1")  // Lexer for ASN.1
83142>>>>>>>>>>>>>>>>>>>        //  Move "asn1" to sLexer
83142>>>>>>>>>>>>>>>>>>>        //  Case Break
83142>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="autoit3") // Lexer for AutoIt3
83142>>>>>>>>>>>>>>>>>>>        //  Move "au3" to sLexer
83142>>>>>>>>>>>>>>>>>>>        //  Case Break
83142>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="avenue") // Lexer for Avenue
83142>>>>>>>>>>>>>>>>>>>        //  Move "ave" to sLexer
83142>>>>>>>>>>>>>>>>>>>        //  Case Break
83142>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="avisynth") // Lexer for AviSynth.
83142>>>>>>>>>>>>>>>>>>>        //  Move "avs" to sLexer
83142>>>>>>>>>>>>>>>>>>>        //  Case Break
83142>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="baan") // Lexer for Baan.
83142>>>>>>>>>>>>>>>>>>>        //  Move "baan" to sLexer
83142>>>>>>>>>>>>>>>>>>>        //  Case Break
83142>>>>>>>>>>>>>>>>>>>      Case (sLexer="bash") // Lexer for Bash.
83145>>>>>>>>>>>>>>>>>>>        Move "Bash" To sLanguage
83146>>>>>>>>>>>>>>>>>>>        Case Break
83147>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="blitz basic")  // Lexer for BlitzBasic and PureBasic.
83147>>>>>>>>>>>>>>>>>>>        //  Move "blitzbasic" to sLexer
83147>>>>>>>>>>>>>>>>>>>        //  Case Break
83147>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="pure basic")
83147>>>>>>>>>>>>>>>>>>>        //  Move "purebasic" to sLexer
83147>>>>>>>>>>>>>>>>>>>        //  Case Break
83147>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="free basic")
83147>>>>>>>>>>>>>>>>>>>        //  Move "freebasic" to sLexer
83147>>>>>>>>>>>>>>>>>>>        //  Case Break
83147>>>>>>>>>>>>>>>>>>>      Case (sLexer="batch")  // Lexer for batch files.
83150>>>>>>>>>>>>>>>>>>>        Move "Batch files" To sLanguage
83151>>>>>>>>>>>>>>>>>>>        Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="bibtex")  // General BibTeX coloring scheme.
83152>>>>>>>>>>>>>>>>>>>        //  Move "bib" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="bullant") // lexer for Bullant
83152>>>>>>>>>>>>>>>>>>>        //  Move "bullant" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="objective caml") // Lexer for Objective Caml
83152>>>>>>>>>>>>>>>>>>>        //  Move "caml" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="clarion") // Case Sensitive Clarion Language Lexer
83152>>>>>>>>>>>>>>>>>>>        //  Move "clarion" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="clarion case insensitive") // Case Insensitive Clarion Language Lexer
83152>>>>>>>>>>>>>>>>>>>        //  Move "clarionnocase" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="cmake") // Lexer for Cmake
83152>>>>>>>>>>>>>>>>>>>        //  Move "cmake" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="cobol") // Lexer for COBOL
83152>>>>>>>>>>>>>>>>>>>        //  Move "COBOL" to sLexer
83152>>>>>>>>>>>>>>>>>>>        //  Case Break
83152>>>>>>>>>>>>>>>>>>>      Case (sLexer="coffeescript") // Lexer for CoffeeScript.
83155>>>>>>>>>>>>>>>>>>>        Move "CoffeeScript" To sLanguage
83156>>>>>>>>>>>>>>>>>>>        Case Break
83157>>>>>>>>>>>>>>>>>>>      Case (sLexer="conf") // Lexer for Apache Configuration Files.
83160>>>>>>>>>>>>>>>>>>>        Move "Apache Configuration Files" To sLanguage
83161>>>>>>>>>>>>>>>>>>>        Case Break
83162>>>>>>>>>>>>>>>>>>>      Case (sLexer="cpp") // Lexer for C++, C, Java, and JavaScript.
83165>>>>>>>>>>>>>>>>>>>        Move "C/C++" To sLanguage
83166>>>>>>>>>>>>>>>>>>>        Case Break
83167>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="java") // Lexer for C++, C, Java, and JavaScript.
83167>>>>>>>>>>>>>>>>>>>        //  Move "cpp" to sLexer
83167>>>>>>>>>>>>>>>>>>>        //  Case Break
83167>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="javascript") // Lexer for C++, C, Java, and JavaScript.
83167>>>>>>>>>>>>>>>>>>>        //  Move "cpp" to sLexer
83167>>>>>>>>>>>>>>>>>>>        //  Case Break
83167>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="c/c++ case insensitive") // Lexer for C++, C, Java, and JavaScript case insensitive
83167>>>>>>>>>>>>>>>>>>>        //  Move "cppnocase" to sLexer
83167>>>>>>>>>>>>>>>>>>>        //  Case Break
83167>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="nncron files") //Lexer to use with extended crontab files used by Windows scheduler/event monitor/automation manager nnCron.
83167>>>>>>>>>>>>>>>>>>>        //  Move "nncrontab" to sLexer
83167>>>>>>>>>>>>>>>>>>>        //  Case Break
83167>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="csound") //Lexer for Csound (Orchestra & Score)
83167>>>>>>>>>>>>>>>>>>>        //  Move "csound" to sLexer
83167>>>>>>>>>>>>>>>>>>>        //  Case Break
83167>>>>>>>>>>>>>>>>>>>      Case (sLexer="css") // Lexer for Cascading Style Sheets
83170>>>>>>>>>>>>>>>>>>>        Move "CSS" To sLanguage
83171>>>>>>>>>>>>>>>>>>>        Case Break
83172>>>>>>>>>>>>>>>>>>>      Case (sLexer="d") // Lexer for D.
83175>>>>>>>>>>>>>>>>>>>        Move "D" To sLanguage
83176>>>>>>>>>>>>>>>>>>>        Case Break
83177>>>>>>>>>>>>>>>>>>>      Case (sLexer="diff")  // Lexer for diff results.
83180>>>>>>>>>>>>>>>>>>>        Move "diff results" To sLanguage
83181>>>>>>>>>>>>>>>>>>>        Case Break
83182>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="msc nastran dmap") // Lexer for MSC Nastran DMAP.
83182>>>>>>>>>>>>>>>>>>>        //  Move "DMAP" to sLexer
83182>>>>>>>>>>>>>>>>>>>        //  Case Break
83182>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="dmis") // Lexer for DMIS.
83182>>>>>>>>>>>>>>>>>>>        //  Move "DMIS" to sLexer
83182>>>>>>>>>>>>>>>>>>>        //  Case Break
83182>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="ecl") // Lexer for ECL.
83182>>>>>>>>>>>>>>>>>>>        //  Move "ecl" to sLexer
83182>>>>>>>>>>>>>>>>>>>        //  Case Break
83182>>>>>>>>>>>>>>>>>>>      Case (sLexer="edifact") // EDIFACT
83185>>>>>>>>>>>>>>>>>>>        Move "EDIFACT" To sLanguage
83186>>>>>>>>>>>>>>>>>>>        Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="eiffel") // Lexer for Eiffel.
83187>>>>>>>>>>>>>>>>>>>        //  Move "eiffel" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="erlang") // Lexer for Erlang.
83187>>>>>>>>>>>>>>>>>>>        //  Move "erlang" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="error lists") //Lexer for error lists. Used for the output pane in SciTE.
83187>>>>>>>>>>>>>>>>>>>        //  Move "errorlist" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="escript") // Lexer for ESCRIPT
83187>>>>>>>>>>>>>>>>>>>        //  Move "escript" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="harbour and flagship") // Lexer for Harbour and FlagShip.
83187>>>>>>>>>>>>>>>>>>>        //  Move "flagship" to sLexer             // (Syntactically compatible to other xBase dialects, like Clipper, dBase, Clip, FoxPro etc.)
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="forth") // Lexer for FORTH
83187>>>>>>>>>>>>>>>>>>>        //  Move "forth" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="fortran") // Lexer for Fortran.
83187>>>>>>>>>>>>>>>>>>>        //  Move "fortran" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="fortran 77")
83187>>>>>>>>>>>>>>>>>>>        //  Move "f77" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="gap") // Lexer for the GAP language. (The GAP System for Computational Discrete Algebra)
83187>>>>>>>>>>>>>>>>>>>        //  Move "gap" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="gui4cli") // This is the Lexer for Gui4Cli
83187>>>>>>>>>>>>>>>>>>>        //  Move "gui4cli" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="haskell") //A haskell lexer for the scintilla code control.
83187>>>>>>>>>>>>>>>>>>>        //  Move "haskell" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="literate haskell")
83187>>>>>>>>>>>>>>>>>>>        //  Move "literatehaskell" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="hex s-record") //Lexers for Motorola S-Record, Intel HEX and Tektronix extended HEX.
83187>>>>>>>>>>>>>>>>>>>        //  Move "srec" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="hex intel")
83187>>>>>>>>>>>>>>>>>>>        //  Move "ihex" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="hex tektronix")
83187>>>>>>>>>>>>>>>>>>>        //  Move "tehex" to sLexer
83187>>>>>>>>>>>>>>>>>>>        //  Case Break
83187>>>>>>>>>>>>>>>>>>>      Case (sLexer="hypertext") // Lexer for HTML.
83190>>>>>>>>>>>>>>>>>>>        Move "HTML" To sLanguage
83191>>>>>>>>>>>>>>>>>>>        Case Break
83192>>>>>>>>>>>>>>>>>>>      Case (sLexer="xml")
83195>>>>>>>>>>>>>>>>>>>        Move "XML" To sLanguage
83196>>>>>>>>>>>>>>>>>>>        Case Break
83197>>>>>>>>>>>>>>>>>>>      Case (sLexer="phpscript")
83200>>>>>>>>>>>>>>>>>>>        Move "PHP" To sLanguage
83201>>>>>>>>>>>>>>>>>>>        Case Break
83202>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="inno setup script") // Lexer for Inno Setup scripts.
83202>>>>>>>>>>>>>>>>>>>        //  Move "inno" to sLexer
83202>>>>>>>>>>>>>>>>>>>        //  Case Break
83202>>>>>>>>>>>>>>>>>>>      Case (sLexer="json") //brief Lexer for JSON and JSON-LD formats
83205>>>>>>>>>>>>>>>>>>>        Move "JSON" To sLanguage
83206>>>>>>>>>>>>>>>>>>>        Case Break
83207>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="kix script")  // Lexer for KIX-Scripts.
83207>>>>>>>>>>>>>>>>>>>        //  Move "kix" to sLexer
83207>>>>>>>>>>>>>>>>>>>        //  Case Break
83207>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="kvirc script") // Lexer for KVIrc script.
83207>>>>>>>>>>>>>>>>>>>        //  Move "kvirc" to sLexer
83207>>>>>>>>>>>>>>>>>>>        //  Case Break
83207>>>>>>>>>>>>>>>>>>>      Case (sLexer="latex") // Lexer for LaTeX2e.
83210>>>>>>>>>>>>>>>>>>>        Move "LaTeX" To sLanguage
83211>>>>>>>>>>>>>>>>>>>        Case Break
83212>>>>>>>>>>>>>>>>>>>      Case (sLexer="lisp") // Lexer for Lisp.
83215>>>>>>>>>>>>>>>>>>>        Move "Lisp" To sLanguage
83216>>>>>>>>>>>>>>>>>>>        Case Break
83217>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="basser lout") // Lexer for the Basser Lout (>= version 3) typesetting language
83217>>>>>>>>>>>>>>>>>>>        //  Move "lout" to sLexer
83217>>>>>>>>>>>>>>>>>>>        //  Case Break
83217>>>>>>>>>>>>>>>>>>>      Case (sLexer="lua") // Lexer for Lua language.
83220>>>>>>>>>>>>>>>>>>>        Move "Lua" To sLanguage
83221>>>>>>>>>>>>>>>>>>>        Case Break
83222>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="magiksf") // Lexer for GE(r) Smallworld(tm) MagikSF
83222>>>>>>>>>>>>>>>>>>>        //  Move "magiksf" to sLexer
83222>>>>>>>>>>>>>>>>>>>        //  Case Break
83222>>>>>>>>>>>>>>>>>>>      Case (sLexer="makefile") // Lexer for make files.
83225>>>>>>>>>>>>>>>>>>>        Move "make file" To sLanguage
83226>>>>>>>>>>>>>>>>>>>        Case Break
83227>>>>>>>>>>>>>>>>>>>      Case (sLexer="markdown") // A simple Markdown lexer for scintilla.
83230>>>>>>>>>>>>>>>>>>>        Move "Markdown" To sLanguage
83231>>>>>>>>>>>>>>>>>>>        Case Break
83232>>>>>>>>>>>>>>>>>>>      Case (sLexer="matlab") // Lexer for Matlab.
83235>>>>>>>>>>>>>>>>>>>        Move "Matlab" To sLanguage
83236>>>>>>>>>>>>>>>>>>>        Case Break
83237>>>>>>>>>>>>>>>>>>>      Case (sLexer="octave")
83240>>>>>>>>>>>>>>>>>>>        Move "Octave" To sLanguage
83241>>>>>>>>>>>>>>>>>>>        Case Break
83242>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="metapost") // general context conformant metapost coloring scheme
83242>>>>>>>>>>>>>>>>>>>        //  Move "metapost" to sLexer
83242>>>>>>>>>>>>>>>>>>>        //  Case Break
83242>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="mmix assembler") // Lexer for MMIX Assembler Language.
83242>>>>>>>>>>>>>>>>>>>        //  Move "mmixal" to sLexer
83242>>>>>>>>>>>>>>>>>>>        //  Case Break
83242>>>>>>>>>>>>>>>>>>>      Case (sLexer="modula") // brief Lexer for Modula-2/3 documents.
83245>>>>>>>>>>>>>>>>>>>        Move "Modula" To sLanguage
83246>>>>>>>>>>>>>>>>>>>        Case Break
83247>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="lot") // Lexer for MPT specific files. Based on LexOthers.cxx
83247>>>>>>>>>>>>>>>>>>>        //  Move "lot" to sLexer //LOT = the text log file created by the MPT application while running a test program
83247>>>>>>>>>>>>>>>>>>>        //  Case Break
83247>>>>>>>>>>>>>>>>>>>      Case (sLexer="mssql") // Lexer for MSSQL.
83250>>>>>>>>>>>>>>>>>>>        Move "MSSQL" To sLanguage
83251>>>>>>>>>>>>>>>>>>>        Case Break
83252>>>>>>>>>>>>>>>>>>>      Case (sLexer="mysql") // Lexer for MySQL
83255>>>>>>>>>>>>>>>>>>>        Move "MySQL" To sLanguage
83256>>>>>>>>>>>>>>>>>>>        Case Break
83257>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="nimrod") // Lexer for Nimrod.
83257>>>>>>>>>>>>>>>>>>>        //  Move "nimrod" to sLexer
83257>>>>>>>>>>>>>>>>>>>        //  Case Break
83257>>>>>>>>>>>>>>>>>>>      Case (sLexer="nsis") // Lexer for NSIS
83260>>>>>>>>>>>>>>>>>>>        Move "NSIS" To sLanguage
83261>>>>>>>>>>>>>>>>>>>        Case Break
83262>>>>>>>>>>>>>>>>>>>      Case (sLexer="null") // Lexer for no language. Used for plain text and unrecognized files.
83265>>>>>>>>>>>>>>>>>>>        Move "Text" To sLanguage
83266>>>>>>>>>>>>>>>>>>>        Case Break
83267>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="opal") // Lexer for OPAL (functional language similar to Haskell)
83267>>>>>>>>>>>>>>>>>>>        //  Move "opal" to sLexer
83267>>>>>>>>>>>>>>>>>>>        //  Case Break
83267>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="oscript") // Lexer for OScript sources; ocx files and/or OSpace dumps.
83267>>>>>>>>>>>>>>>>>>>        //  Move "oscript" to sLexer
83267>>>>>>>>>>>>>>>>>>>        //  Case Break
83267>>>>>>>>>>>>>>>>>>>      Case (sLexer="pascal") // Lexer for Pascal.
83270>>>>>>>>>>>>>>>>>>>        Move "Pascal" To sLanguage
83271>>>>>>>>>>>>>>>>>>>        Case Break
83272>>>>>>>>>>>>>>>>>>>      Case (sLexer="powerbasic") // Lexer for PowerBasic
83275>>>>>>>>>>>>>>>>>>>        Move "PowerBasic" To sLanguage
83276>>>>>>>>>>>>>>>>>>>        Case Break
83277>>>>>>>>>>>>>>>>>>>      Case (sLexer="perl") // Lexer for Perl
83280>>>>>>>>>>>>>>>>>>>        Move "Perl" To sLanguage
83281>>>>>>>>>>>>>>>>>>>        Case Break
83282>>>>>>>>>>>>>>>>>>>      Case (sLexer="pl/m") //
83285>>>>>>>>>>>>>>>>>>>        Move "PL/M" To sLanguage
83286>>>>>>>>>>>>>>>>>>>        Case Break
83287>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="po files") // Lexer for GetText Translation (PO) files.
83287>>>>>>>>>>>>>>>>>>>        //  Move "po" to sLexer
83287>>>>>>>>>>>>>>>>>>>        //  Case Break
83287>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="pov-ray sdl") // Lexer for POV-Ray SDL (Persistance of Vision Raytracer, Scene Description Language).
83287>>>>>>>>>>>>>>>>>>>        //  Move "pov" to sLexer
83287>>>>>>>>>>>>>>>>>>>        //  Case Break
83287>>>>>>>>>>>>>>>>>>>      Case (sLexer="powerpro") // PowerPro lexer
83290>>>>>>>>>>>>>>>>>>>        Move "PowerPro" To sLanguage
83291>>>>>>>>>>>>>>>>>>>        Case Break
83292>>>>>>>>>>>>>>>>>>>      Case (sLexer="powershell") // Lexer for PowerShell scripts.
83295>>>>>>>>>>>>>>>>>>>        Move "PowerShell" To sLanguage
83296>>>>>>>>>>>>>>>>>>>        Case Break
83297>>>>>>>>>>>>>>>>>>>      Case (sLexer="abl") //Lexer for Progress 4GL.
83300>>>>>>>>>>>>>>>>>>>        Move "Progress" To sLanguage
83301>>>>>>>>>>>>>>>>>>>        Case Break
83302>>>>>>>>>>>>>>>>>>>      Case (sLexer="props") // Lexer for properties files.
83305>>>>>>>>>>>>>>>>>>>        Move "properties file" To sLanguage
83306>>>>>>>>>>>>>>>>>>>        Case Break
83307>>>>>>>>>>>>>>>>>>>      Case (sLexer="ps") // Lexer for PostScript
83310>>>>>>>>>>>>>>>>>>>        Move "PostScript" To sLanguage
83311>>>>>>>>>>>>>>>>>>>        Case Break
83312>>>>>>>>>>>>>>>>>>>      Case (sLexer="python") // Lexer for Python.
83315>>>>>>>>>>>>>>>>>>>        Move "Python" To sLanguage
83316>>>>>>>>>>>>>>>>>>>        Case Break
83317>>>>>>>>>>>>>>>>>>>      Case (sLexer="r") // Lexer for R, S, SPlus Statistics Program (Heavily derived from CPP Lexer).
83320>>>>>>>>>>>>>>>>>>>        Move "R" To sLanguage
83321>>>>>>>>>>>>>>>>>>>        Case Break
83322>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="rebol") // Lexer for REBOL.
83322>>>>>>>>>>>>>>>>>>>        //  Move "rebol" to sLexer
83322>>>>>>>>>>>>>>>>>>>        //  Case Break
83322>>>>>>>>>>>>>>>>>>>      Case (sLexer="registry") // brief Lexer for Windows registration files(.reg)
83325>>>>>>>>>>>>>>>>>>>        Move "Windows Registry" To sLanguage
83326>>>>>>>>>>>>>>>>>>>        Case Break
83327>>>>>>>>>>>>>>>>>>>      Case (sLexer="ruby") // Lexer for Ruby.
83330>>>>>>>>>>>>>>>>>>>        Move "Ruby" To sLanguage
83331>>>>>>>>>>>>>>>>>>>        Case Break
83332>>>>>>>>>>>>>>>>>>>      Case (sLexer="rust") // Lexer for Rust.
83335>>>>>>>>>>>>>>>>>>>        Move "Rust" To sLanguage
83336>>>>>>>>>>>>>>>>>>>        Case Break
83337>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="scriptol") // Lexer for Scriptol.
83337>>>>>>>>>>>>>>>>>>>        //  Move "scriptol" to sLexer
83337>>>>>>>>>>>>>>>>>>>        //  Case Break
83337>>>>>>>>>>>>>>>>>>>      Case (sLexer="smalltalk") // Lexer for Smalltalk language.
83340>>>>>>>>>>>>>>>>>>>        Move "Smalltalk" To sLanguage
83341>>>>>>>>>>>>>>>>>>>        Case Break
83342>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="sml") // Lexer for SML.
83342>>>>>>>>>>>>>>>>>>>        //  Move "SML" to sLexer
83342>>>>>>>>>>>>>>>>>>>        //  Case Break
83342>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="sorcus installation file") // Lexer for SORCUS installation files
83342>>>>>>>>>>>>>>>>>>>        //  Move "sorcins" to sLexer
83342>>>>>>>>>>>>>>>>>>>        //  Case Break
83342>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="specman") // Lexer for Specman E language.
83342>>>>>>>>>>>>>>>>>>>        //  Move "specman" to sLexer
83342>>>>>>>>>>>>>>>>>>>        //  Case Break
83342>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="spice") // Lexer for Spice
83342>>>>>>>>>>>>>>>>>>>        //  Move "spice" to sLexer
83342>>>>>>>>>>>>>>>>>>>        //  Case Break
83342>>>>>>>>>>>>>>>>>>>      Case (sLexer="sql") // Lexer for SQL, including PL/SQL and SQL*Plus.
83345>>>>>>>>>>>>>>>>>>>        Move "SQL" To sLanguage
83346>>>>>>>>>>>>>>>>>>>        Case Break
83347>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="structured text") // Lexer for Structured Text language.
83347>>>>>>>>>>>>>>>>>>>        //  Move "fcST" to sLexer
83347>>>>>>>>>>>>>>>>>>>        //  Case Break
83347>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tacl") // Lexer for TAL
83347>>>>>>>>>>>>>>>>>>>        //  Move "TACL" to sLexer
83347>>>>>>>>>>>>>>>>>>>        //  Case Break
83347>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tads3") // Lexer for TADS3.
83347>>>>>>>>>>>>>>>>>>>        //  Move "tads3" to sLexer
83347>>>>>>>>>>>>>>>>>>>        //  Case Break
83347>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tal") // Lexer for TAL
83347>>>>>>>>>>>>>>>>>>>        //  Move "TAL" to sLexer
83347>>>>>>>>>>>>>>>>>>>        //  Case Break
83347>>>>>>>>>>>>>>>>>>>      Case (sLexer="tcl") // Lexer for TCL language.
83350>>>>>>>>>>>>>>>>>>>        Move "TCL" To sLanguage
83351>>>>>>>>>>>>>>>>>>>        Case Break
83352>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="take command") // Lexer for Take Command / TCC batch scripts (.bat, .btm, .cmd).
83352>>>>>>>>>>>>>>>>>>>        //  Move "tcmd" to sLexer
83352>>>>>>>>>>>>>>>>>>>        //  Case Break
83352>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="tex coloring scheme") // File: LexTeX.cxx - general context conformant tex coloring scheme
83352>>>>>>>>>>>>>>>>>>>        //  Move "tex" to sLexer
83352>>>>>>>>>>>>>>>>>>>        //  Case Break
83352>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="txt2tags") // A simple Txt2tags lexer for scintilla.
83352>>>>>>>>>>>>>>>>>>>        //  Move "txt2tags" to sLexer
83352>>>>>>>>>>>>>>>>>>>        //  Case Break
83352>>>>>>>>>>>>>>>>>>>      Case (sLexer="vb") // Lexer for Visual Basic and VBScript.
83355>>>>>>>>>>>>>>>>>>>        Move "Visual Basic" To sLanguage
83356>>>>>>>>>>>>>>>>>>>        Case Break
83357>>>>>>>>>>>>>>>>>>>        //Case (sLanguage="basic") // using vb as a default for just "basic"
83357>>>>>>>>>>>>>>>>>>>        //  Move "vb" to sLexer
83357>>>>>>>>>>>>>>>>>>>        //  Case Break
83357>>>>>>>>>>>>>>>>>>>      Case (sLexer="vbscript")
83360>>>>>>>>>>>>>>>>>>>        Move "VBScript" To sLanguage
83361>>>>>>>>>>>>>>>>>>>        Case Break
83362>>>>>>>>>>>>>>>>>>>      Case (sLexer="verilog") // Lexer for Verilog.
83365>>>>>>>>>>>>>>>>>>>        Move "Verilog" To sLanguage
83366>>>>>>>>>>>>>>>>>>>        Case Break
83367>>>>>>>>>>>>>>>>>>>      Case (sLexer="vhdl") // Lexer for VHDL
83370>>>>>>>>>>>>>>>>>>>        Move "VHDL" To sLanguage
83371>>>>>>>>>>>>>>>>>>>        Case Break
83372>>>>>>>>>>>>>>>>>>>      Case (sLexer="visualprolog") // Lexer for Visual Prolog.
83375>>>>>>>>>>>>>>>>>>>        Move "Visual Prolog" To sLanguage
83376>>>>>>>>>>>>>>>>>>>        Case Break
83377>>>>>>>>>>>>>>>>>>>      Case (sLexer="yaml") // Lexer for YAML.
83380>>>>>>>>>>>>>>>>>>>        Move "YAML" To sLanguage
83381>>>>>>>>>>>>>>>>>>>        Case Break
83382>>>>>>>>>>>>>>>>>>>      Case Else
83382>>>>>>>>>>>>>>>>>>>        Move "DataFlex" To sLanguage
83383>>>>>>>>>>>>>>>>>>>    Case End
83383>>>>>>>>>>>>>>>>>>>
83383>>>>>>>>>>>>>>>>>>>    Function_Return sLanguage
83384>>>>>>>>>>>>>>>>>>>  End_Function // LanguageForScintillaLexer
83385>>>>>>>>>>>>>>>>>>>
83385>>>>>>>>>>>>>>>>>>>
83385>>>>>>>>>>>>>>>>>>>  //
83385>>>>>>>>>>>>>>>>>>>  //
83385>>>>>>>>>>>>>>>>>>>  Procedure SetAppearance Integer iStyle Integer iColorIndex
83387>>>>>>>>>>>>>>>>>>>    Integer iBackColor
83387>>>>>>>>>>>>>>>>>>>
83387>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFORE   iStyle gtColorer[iColorIndex].iForeC
83388>>>>>>>>>>>>>>>>>>>    Move gtColorer[iColorIndex].iBackC To iBackColor
83389>>>>>>>>>>>>>>>>>>>    If (iBackColor=-1) Begin // use background color of window
83391>>>>>>>>>>>>>>>>>>>      Get piWindowColor To iBackColor
83392>>>>>>>>>>>>>>>>>>>      If (iBackColor<0) Begin
83394>>>>>>>>>>>>>>>>>>>        Move clWhite To iBackColor
83395>>>>>>>>>>>>>>>>>>>      End
83395>>>>>>>>>>>>>>>>>>>>
83395>>>>>>>>>>>>>>>>>>>    End
83395>>>>>>>>>>>>>>>>>>>>
83395>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK   iStyle iBackColor
83396>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBOLD   iStyle gtColorer[iColorIndex].iBold
83397>>>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETITALIC iStyle gtColorer[iColorIndex].iItalics
83398>>>>>>>>>>>>>>>>>>>  End_Procedure
83399>>>>>>>>>>>>>>>>>>>
83399>>>>>>>>>>>>>>>>>>>
83399>>>>>>>>>>>>>>>>>>>  //
83399>>>>>>>>>>>>>>>>>>>  // Map the color style per defined language
83399>>>>>>>>>>>>>>>>>>>  //
83399>>>>>>>>>>>>>>>>>>>  Procedure SetAppearanceForLanguage Integer iLexer
83401>>>>>>>>>>>>>>>>>>>
83401>>>>>>>>>>>>>>>>>>>    If (iLexer=SCLEX_NULL) Begin
83403>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_TEXT_DEFAULT       EC_TEXT
83404>>>>>>>>>>>>>>>>>>>    End
83404>>>>>>>>>>>>>>>>>>>>
83404>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_DATAFLEX) Begin
83407>>>>>>>>>>>>>>>>>>>      //
83407>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_DEFAULT       EC_TEXT
83408>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_IDENTIFIER    EC_TEXT             // // # Identifiers (style.dataflex.1=)
83409>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_METATAG       EC_METATAGS         // # Comment: { ... } (style.dataflex.2=$(colour.code.comment.box),$(font.code.comment.box))
83410>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_IMAGE         EC_COMMENTS         // # Comment: (* ... *) (style.dataflex.3=$(colour.code.comment.box),$(font.code.comment.box))
83411>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_COMMENTLINE   EC_COMMENTS         // # Line Comment: // ... (style.dataflex.4=$(colour.code.comment.line),$(font.code.comment.line))
83412>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_PREPROCESSOR  EC_PREPROCESSOR     // # Preprocessor (Macro/Commands): #MACRO/#ENDMACRO
83413>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_PREPROCESSOR2 EC_PREPROCESSOR     // # Preprocessor: (*$ ... *) (style.dataflex.6=$(colour.preproc))
83414>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_NUMBER        EC_NUMBERS          // # Number (style.dataflex.7=$(colour.Number))
83415>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_HEXNUMBER     EC_NUMBERS          // # Hex Number (style.dataflex.8=$(colour.Number))
83416>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_WORD          EC_KEYWORDS         // # Keyword (style.dataflex.9=$(colour.keyword) // Basic keywords)
83417>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_STRING        EC_STRINGS          // # String (style.dataflex.10=$(colour.String))
83418>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_STRINGEOL     EC_STRINGTYPING     // # End of line where String is not closed (style.dataflex.11=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled)
83419>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_SCOPEWORD     EC_SCOPEKWORDS      // # Scope keyword (style.dataflex.12=$(colour.keyword),bold)
83420>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_OPERATOR      EC_OPERATORS        // # Operators (style.dataflex.13=$(colour.operator),bold)
83421>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_DF_ICODE         EC_NUMBERS          // # ICode (style.dataflex.14=$(colour.Number))
83422>>>>>>>>>>>>>>>>>>>    End
83422>>>>>>>>>>>>>>>>>>>>
83422>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_CPP) Begin
83425>>>>>>>>>>>>>>>>>>>      //
83425>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_DEFAULT                EC_TEXT
83426>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_IDENTIFIER             EC_TEXT
83427>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTDOC             EC_METATAGS
83428>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENT                EC_COMMENTS
83429>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTLINE            EC_COMMENTS
83430>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_PREPROCESSOR           EC_PREPROCESSOR
83431>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_GLOBALCLASS            EC_PREPROCESSOR
83432>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_NUMBER                 EC_NUMBERS
83433>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_CHARACTER              EC_NUMBERS
83434>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_WORD                   EC_KEYWORDS
83435>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_STRING                 EC_STRINGS
83436>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_STRINGEOL              EC_STRINGTYPING
83437>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_WORD2                  EC_SCOPEKWORDS
83438>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_OPERATOR               EC_OPERATORS
83439>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_UUID                   EC_STRINGS
83440>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_VERBATIM               EC_TEXT
83441>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_REGEX                  EC_OPERATORS
83442>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTLINEDOC         EC_METATAGS
83443>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTDOCKEYWORD      EC_METATAGS
83444>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_COMMENTDOCKEYWORDERROR EC_STRINGTYPING
83445>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_STRINGRAW              EC_STRINGS
83446>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_TRIPLEVERBATIM         EC_COMMENTS
83447>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_HASHQUOTEDSTRING       EC_STRINGS
83448>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_PREPROCESSORCOMMENT    EC_METATAGS
83449>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_PREPROCESSORCOMMENTDOC EC_METATAGS
83450>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_USERLITERAL            EC_STRINGS
83451>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_TASKMARKER             EC_BRACEHLIGHT
83452>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_C_ESCAPESEQUENCE         EC_STRINGS
83453>>>>>>>>>>>>>>>>>>>
83453>>>>>>>>>>>>>>>>>>>    End
83453>>>>>>>>>>>>>>>>>>>>
83453>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_PASCAL) Begin
83456>>>>>>>>>>>>>>>>>>>      //
83456>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_DEFAULT        EC_TEXT
83457>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_IDENTIFIER     EC_TEXT
83458>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_COMMENT2       EC_METATAGS
83459>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_COMMENT        EC_COMMENTS
83460>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_COMMENTLINE    EC_COMMENTS
83461>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_PREPROCESSOR   EC_PREPROCESSOR
83462>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_PREPROCESSOR2  EC_PREPROCESSOR
83463>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_NUMBER         EC_NUMBERS
83464>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_HEXNUMBER      EC_NUMBERS
83465>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_WORD           EC_KEYWORDS
83466>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_STRING         EC_STRINGS
83467>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_STRINGEOL      EC_STRINGTYPING
83468>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_OPERATOR       EC_OPERATORS
83469>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_CHARACTER      EC_STRINGS
83470>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PAS_ASM            EC_BOOKMARK
83471>>>>>>>>>>>>>>>>>>>    End
83471>>>>>>>>>>>>>>>>>>>>
83471>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_HTML or iLexer=SCLEX_XML or iLexer=SCLEX_PHPSCRIPT) Begin
83474>>>>>>>>>>>>>>>>>>>      //
83474>>>>>>>>>>>>>>>>>>>      Set LexerProperty "fold.html" To "1"
83475>>>>>>>>>>>>>>>>>>>      //
83475>>>>>>>>>>>>>>>>>>>      // Has over 100 styles as it supports markup for embedded scripting etc..
83475>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_DEFAULT           EC_TEXT
83476>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_TAG               EC_TAGELEMENT
83477>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_TAGUNKNOWN        EC_KEYWORDS
83478>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ATTRIBUTE         EC_TAGATTRIBUTE
83479>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ATTRIBUTEUNKNOWN  EC_OPERATORS
83480>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_NUMBER            EC_NUMBERS
83481>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_DOUBLESTRING      EC_STRINGS
83482>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SINGLESTRING      EC_STRINGS
83483>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_OTHER             EC_TEXT
83484>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_COMMENT           EC_COMMENTS
83485>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ENTITY            EC_TAGENTITIES
83486>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_TAGEND            EC_TAGELEMENT    // XML style tag ends '/>'
83487>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_XMLSTART          EC_SCOPEKWORDS   // XML identifier start '<?'
83488>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_XMLEND            EC_SCOPEKWORDS   // XML identifier end '?>'
83489>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SCRIPT            EC_METATAGS      // SCRIPT
83490>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ASP               EC_KEYWORDS      // ASP <% ... %>
83491>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_ASPAT             EC_KEYWORDS      // ASP <% ... %>
83492>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_CDATA             EC_STRINGS       // CDATA
83493>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_QUESTION          EC_STRINGTYPING  // PHP
83494>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_VALUE             EC_NUMBERS       // Unquoted values
83495>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_XCCOMMENT         EC_COMMENTS      // JSP Comment <%-- ... --%>
83496>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_DEFAULT      EC_TEXT          // SGML tags <! ... >
83497>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_COMMAND      EC_PREPROCESSOR
83498>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_1ST_PARAM    EC_SCOPEKWORDS
83499>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_DOUBLESTRING EC_STRINGS
83500>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_SIMPLESTRING EC_STRINGS
83501>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_ERROR        EC_STRINGTYPING
83502>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_SPECIAL      EC_UNMATCHEDBRACE
83503>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_ENTITY       EC_TAGENTITIES
83504>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_COMMENT      EC_COMMENTS
83505>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_1ST_PARAM_COMMENT EC_METATAGS
83506>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_H_SGML_BLOCK_DEFAULT EC_TEXT
83507>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_START            EC_TEXT          // Embedded Javascript, JS Start - allows eol filled background to not start on same line as SCRIPT tag
83508>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_DEFAULT          EC_TEXT          //
83509>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_COMMENT          EC_COMMENTS
83510>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_COMMENTLINE      EC_COMMENTS
83511>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_COMMENTDOC       EC_METATAGS
83512>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_NUMBER           EC_NUMBERS
83513>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_WORD             EC_SCOPEKWORDS
83514>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_KEYWORD          EC_KEYWORDS
83515>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_DOUBLESTRING     EC_STRINGS
83516>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_SINGLESTRING     EC_STRINGS
83517>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_SYMBOLS          EC_PREPROCESSOR
83518>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_STRINGEOL        EC_STRINGTYPING
83519>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJ_REGEX            EC_OPERATORS
83520>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_START           EC_TEXT          // ASP Javascript
83521>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_DEFAULT         EC_TEXT
83522>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_COMMENT         EC_COMMENTS
83523>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_COMMENTLINE     EC_COMMENTS
83524>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_COMMENTDOC      EC_METATAGS
83525>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_NUMBER          EC_NUMBERS
83526>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_WORD            EC_SCOPEKWORDS
83527>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_KEYWORD         EC_KEYWORDS
83528>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_DOUBLESTRING    EC_STRINGS
83529>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_SINGLESTRING    EC_STRINGS
83530>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_SYMBOLS         EC_PREPROCESSOR
83531>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_STRINGEOL       EC_STRINGTYPING
83532>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HJA_REGEX           EC_OPERATORS
83533>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_START            EC_TEXT          // Embedded VBS
83534>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_DEFAULT          EC_TEXT
83535>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_COMMENTLINE      EC_COMMENTS
83536>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_NUMBER           EC_NUMBERS
83537>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_WORD             EC_SCOPEKWORDS
83538>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_STRING           EC_STRINGS
83539>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_IDENTIFIER       EC_KEYWORDS
83540>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HB_STRINGEOL        EC_STRINGTYPING
83541>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_START           EC_TEXT          // ASP VBS
83542>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_DEFAULT         EC_TEXT
83543>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_COMMENTLINE     EC_COMMENTS
83544>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_NUMBER          EC_NUMBERS
83545>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_WORD            EC_SCOPEKWORDS
83546>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_STRING          EC_STRINGS
83547>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_IDENTIFIER      EC_KEYWORDS
83548>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HBA_STRINGEOL       EC_STRINGTYPING
83549>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_START            EC_TEXT          // Embedded Python
83550>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_DEFAULT          EC_TEXT
83551>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_COMMENTLINE      EC_COMMENTS
83552>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_NUMBER           EC_NUMBERS
83553>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_STRING           EC_STRINGS
83554>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_CHARACTER        EC_STRINGS
83555>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_WORD             EC_SCOPEKWORDS
83556>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_TRIPLE           EC_PREPROCESSOR
83557>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_TRIPLEDOUBLE     EC_PREPROCESSOR
83558>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_CLASSNAME        EC_METATAGS
83559>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_DEFNAME          EC_METATAGS
83560>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_OPERATOR         EC_OPERATORS
83561>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HP_IDENTIFIER       EC_KEYWORDS
83562>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_COMPLEX_VARIABLE   EC_TAGENTITIES // PHP complex variable
83563>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_START           EC_TEXT          // ASP Python
83564>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_DEFAULT         EC_TEXT
83565>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_COMMENTLINE     EC_COMMENTS
83566>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_NUMBER          EC_NUMBERS
83567>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_STRING          EC_STRINGS
83568>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_CHARACTER       EC_STRINGS
83569>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_WORD            EC_SCOPEKWORDS
83570>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_TRIPLE          EC_PREPROCESSOR
83571>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_TRIPLEDOUBLE    EC_PREPROCESSOR
83572>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_CLASSNAME       EC_METATAGS
83573>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_DEFNAME         EC_METATAGS
83574>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_OPERATOR        EC_OPERATORS
83575>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPA_IDENTIFIER      EC_KEYWORDS
83576>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_DEFAULT        EC_TEXT          // PHP
83577>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_HSTRING        EC_STRINGS
83578>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_SIMPLESTRING   EC_STRINGS
83579>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_WORD           EC_SCOPEKWORDS
83580>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_NUMBER         EC_NUMBERS
83581>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_VARIABLE       EC_TAGENTITIES
83582>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_COMMENT        EC_COMMENTS
83583>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_COMMENTLINE    EC_COMMENTS
83584>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_HSTRING_VARIABLE  EC_TAGELEMENT
83585>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_HPHP_OPERATOR       EC_OPERATORS
83586>>>>>>>>>>>>>>>>>>>    End
83586>>>>>>>>>>>>>>>>>>>>
83586>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_SQL) Begin
83589>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_DEFAULT         EC_TEXT
83590>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENT         EC_COMMENTS
83591>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTLINE     EC_COMMENTS
83592>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTDOC      EC_METATAGS
83593>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_NUMBER          EC_NUMBERS
83594>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_WORD            EC_KEYWORDS
83595>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_STRING          EC_STRINGS
83596>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_CHARACTER       EC_STRINGS
83597>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_SQLPLUS         EC_TAGTEXT
83598>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_SQLPLUS_PROMPT  EC_TAGENTITIES
83599>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_OPERATOR        EC_OPERATORS
83600>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_IDENTIFIER      EC_TEXT
83601>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_SQLPLUS_COMMENT EC_COMMENTS
83602>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTLINEDOC  EC_METATAGS
83603>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_WORD2           EC_SCOPEKWORDS
83604>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTDOCKEYWORD  EC_METATAGS
83605>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_COMMENTDOCKEYWORDERROR   EC_STRINGTYPING
83606>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER1           EC_TAGENTITIES
83607>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER2           EC_TAGELEMENT
83608>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER3           EC_TAGATTRIBUTE
83609>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_USER4           EC_TAGTEXT
83610>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_QUOTEDIDENTIFIER  EC_TEXT
83611>>>>>>>>>>>>>>>>>>>      Send SetAppearance  SCE_SQL_QOPERATOR       EC_TEXT
83612>>>>>>>>>>>>>>>>>>>    End
83612>>>>>>>>>>>>>>>>>>>>
83612>>>>>>>>>>>>>>>>>>>
83612>>>>>>>>>>>>>>>>>>>    If (iLexer=SCLEX_PROPERTIES) Begin
83614>>>>>>>>>>>>>>>>>>>      //
83614>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_DEFAULT    EC_TEXT
83615>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_SECTION    EC_METATAGS
83616>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_COMMENT    EC_COMMENTS
83617>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_KEY        EC_KEYWORDS
83618>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_DEFVAL     EC_STRINGS
83619>>>>>>>>>>>>>>>>>>>      Send SetAppearance   SCE_PROPS_ASSIGNMENT EC_OPERATORS
83620>>>>>>>>>>>>>>>>>>>    End
83620>>>>>>>>>>>>>>>>>>>>
83620>>>>>>>>>>>>>>>>>>>    Else If (iLexer=SCLEX_VB) Begin
83623>>>>>>>>>>>>>>>>>>>
83623>>>>>>>>>>>>>>>>>>>    End
83623>>>>>>>>>>>>>>>>>>>>
83623>>>>>>>>>>>>>>>>>>>
83623>>>>>>>>>>>>>>>>>>>  End_Procedure
83624>>>>>>>>>>>>>>>>>>>
83624>>>>>>>>>>>>>>>>>>>End_Class
83625>>>>>>>>>>>>>>>>>>>
83625>>>>>>>>>>>>>>>>>Use cSciCodelist.pkg
Including file: cSciCodelist.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cSciCodelist.pkg)
83625>>>>>>>>>>>>>>>>>>>//TH-Header
83625>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
83625>>>>>>>>>>>>>>>>>>>// Copyright (c)  2003 Bernhard Ponemayr
83625>>>>>>>>>>>>>>>>>>>// All rights reserved.
83625>>>>>>>>>>>>>>>>>>>//
83625>>>>>>>>>>>>>>>>>>>// $FileName    : .\hammer\Pkg\cSciCodelist.pkg
83625>>>>>>>>>>>>>>>>>>>// $ProjectName : Listview API
83625>>>>>>>>>>>>>>>>>>>// $Author      : Bernhard Ponemayr
83625>>>>>>>>>>>>>>>>>>>// $Created     : 20.01.2003  16:07
83625>>>>>>>>>>>>>>>>>>>//
83625>>>>>>>>>>>>>>>>>>>// Contents: Abstraction class for the Autocomplete functionality in scintilla control to
83625>>>>>>>>>>>>>>>>>>>// work similar as the codemax codesense control that is to be found in cCodelist.pkg
83625>>>>>>>>>>>>>>>>>>>//
83625>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
83625>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
83625>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
83625>>>>>>>>>>>>>>>>>>>
83625>>>>>>>>>>>>>>>>>>>Define LVS_SORTASCENDING       For |CI$0010
83625>>>>>>>>>>>>>>>>>>>Define LVS_EX_TRACKSELECT      For |CI$00000008
83625>>>>>>>>>>>>>>>>>>>Define LVS_EX_ONECLICKACTIVATE For |CI$00000040
83625>>>>>>>>>>>>>>>>>>>
83625>>>>>>>>>>>>>>>>>>>Struct tCodeList
83625>>>>>>>>>>>>>>>>>>>  String  sSortValue  // used for sorting/searching the case insensitive variant that DF claims works, doesn't work
83625>>>>>>>>>>>>>>>>>>>  String  sValue
83625>>>>>>>>>>>>>>>>>>>  Integer iRef
83625>>>>>>>>>>>>>>>>>>>  String  sBitmap
83625>>>>>>>>>>>>>>>>>>>  Integer iInsertOrder   // Set as item number in the original inserting order before sorting!
83625>>>>>>>>>>>>>>>>>>>End_Struct // tCodeList
83625>>>>>>>>>>>>>>>>>>>
83625>>>>>>>>>>>>>>>>>>>
83625>>>>>>>>>>>>>>>>>>>Class cSciCodelist is a Array
83626>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
83628>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
83630>>>>>>>>>>>>>>>>>>>    Property Handle  phoCodelist    0    // not used
83631>>>>>>>>>>>>>>>>>>>    Property Integer pbUseBitmaps   TRUE // not used (need xpm images)
83632>>>>>>>>>>>>>>>>>>>    Property Integer piRefValue     0    // The ref value contains additional info such as a record id or status about a variable
83633>>>>>>>>>>>>>>>>>>>    Property Handle  phLastUsedFont 0    // not used
83634>>>>>>>>>>>>>>>>>>>    Property Integer piCurrent      -1   // The current item (aka, the one just selected)
83635>>>>>>>>>>>>>>>>>>>    Property tCodeList[] pCodeList
83636>>>>>>>>>>>>>>>>>>>
83636>>>>>>>>>>>>>>>>>>>  End_Procedure
83637>>>>>>>>>>>>>>>>>>>
83637>>>>>>>>>>>>>>>>>>>  Procedure Codelist_Connect Handle hCodelist Integer bUseBitmaps
83639>>>>>>>>>>>>>>>>>>>    Set phoCodelist To hCodelist // not used
83640>>>>>>>>>>>>>>>>>>>    Set piCurrent   To -1
83641>>>>>>>>>>>>>>>>>>>    If ( bUseBitmaps ) Begin
83643>>>>>>>>>>>>>>>>>>>      Set pbUseBitmaps To TRUE
83644>>>>>>>>>>>>>>>>>>>    End
83644>>>>>>>>>>>>>>>>>>>>
83644>>>>>>>>>>>>>>>>>>>    Else Begin
83645>>>>>>>>>>>>>>>>>>>      Set pbUseBitmaps To FALSE
83646>>>>>>>>>>>>>>>>>>>    End
83646>>>>>>>>>>>>>>>>>>>>
83646>>>>>>>>>>>>>>>>>>>  End_Procedure
83647>>>>>>>>>>>>>>>>>>>
83647>>>>>>>>>>>>>>>>>>>  Procedure Codelist_Disconnect
83649>>>>>>>>>>>>>>>>>>>    Send Codelist_delete_data               // Remove all Items from list
83650>>>>>>>>>>>>>>>>>>>    Set phoCodelist To 0
83651>>>>>>>>>>>>>>>>>>>  End_Procedure
83652>>>>>>>>>>>>>>>>>>>
83652>>>>>>>>>>>>>>>>>>>  //
83652>>>>>>>>>>>>>>>>>>>  // While it is called "add_item" in the original code it is actually inserting the data
83652>>>>>>>>>>>>>>>>>>>  // at the bottom. As that's slow, we will reverse the array before sorting.
83652>>>>>>>>>>>>>>>>>>>  //
83652>>>>>>>>>>>>>>>>>>>  Function Codelist_Add_Item String sText String sBitmap Integer iRefValue Returns Integer
83654>>>>>>>>>>>>>>>>>>>    Integer   iCount
83654>>>>>>>>>>>>>>>>>>>    Integer   iRet
83654>>>>>>>>>>>>>>>>>>>    tCodeList CodeItem
83654>>>>>>>>>>>>>>>>>>>    tCodeList CodeItem
83654>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83654>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83655>>>>>>>>>>>>>>>>>>>
83655>>>>>>>>>>>>>>>>>>>    Move 0 To iRet
83656>>>>>>>>>>>>>>>>>>>    If (sText<>"") Begin
83658>>>>>>>>>>>>>>>>>>>      Get pCodeList To CodeList
83659>>>>>>>>>>>>>>>>>>>      Move (SizeOfArray(CodeList)) To iCount
83660>>>>>>>>>>>>>>>>>>>      Move (lowercase(sText)) To CodeItem.sSortValue
83661>>>>>>>>>>>>>>>>>>>      Move sText              To CodeItem.sValue
83662>>>>>>>>>>>>>>>>>>>      Move sBitmap            To CodeItem.sBitmap
83663>>>>>>>>>>>>>>>>>>>      Move iRefValue          To CodeItem.iRef
83664>>>>>>>>>>>>>>>>>>>      //Move (InsertInArray(CodeList,0,CodeItem)) To CodeList
83664>>>>>>>>>>>>>>>>>>>      Move CodeItem To CodeList[iCount]
83665>>>>>>>>>>>>>>>>>>>      Set pCodeList To CodeList
83666>>>>>>>>>>>>>>>>>>>    End
83666>>>>>>>>>>>>>>>>>>>>
83666>>>>>>>>>>>>>>>>>>>    Function_Return iRet
83667>>>>>>>>>>>>>>>>>>>  End_Function
83668>>>>>>>>>>>>>>>>>>>
83668>>>>>>>>>>>>>>>>>>>  Procedure Codelist_delete_data
83670>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83670>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83671>>>>>>>>>>>>>>>>>>>
83671>>>>>>>>>>>>>>>>>>>    Move (ResizeArray(CodeList,0)) To CodeList
83672>>>>>>>>>>>>>>>>>>>    Set pCodeList To CodeList
83673>>>>>>>>>>>>>>>>>>>  End_Procedure
83674>>>>>>>>>>>>>>>>>>>
83674>>>>>>>>>>>>>>>>>>>  Function Codelist_value Integer iItem Returns String
83676>>>>>>>>>>>>>>>>>>>    Integer iRefVal
83676>>>>>>>>>>>>>>>>>>>    String sText
83676>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83676>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83677>>>>>>>>>>>>>>>>>>>
83677>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
83678>>>>>>>>>>>>>>>>>>>    If (iItem < SizeOfArray(CodeList) and iItem<>-1) Begin
83680>>>>>>>>>>>>>>>>>>>      Move CodeList[iItem].sValue To sText
83681>>>>>>>>>>>>>>>>>>>      Move CodeList[iItem].iRef   To iRefVal
83682>>>>>>>>>>>>>>>>>>>    End
83682>>>>>>>>>>>>>>>>>>>>
83682>>>>>>>>>>>>>>>>>>>    Set piRefValue To iRefVal
83683>>>>>>>>>>>>>>>>>>>    Function_Return sText
83684>>>>>>>>>>>>>>>>>>>  End_Function
83685>>>>>>>>>>>>>>>>>>>
83685>>>>>>>>>>>>>>>>>>>  Function Codelist_bitmap Integer iItem Returns String
83687>>>>>>>>>>>>>>>>>>>    String sBitmap
83687>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83687>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83688>>>>>>>>>>>>>>>>>>>
83688>>>>>>>>>>>>>>>>>>>    Move "" To sBitmap
83689>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
83690>>>>>>>>>>>>>>>>>>>    If (iItem < SizeOfArray(CodeList) and iItem<>-1) Begin
83692>>>>>>>>>>>>>>>>>>>      Move CodeList[iItem].sBitmap To sBitmap
83693>>>>>>>>>>>>>>>>>>>    End
83693>>>>>>>>>>>>>>>>>>>>
83693>>>>>>>>>>>>>>>>>>>    If (sBitmap<>"") Begin
83695>>>>>>>>>>>>>>>>>>>      Get_File_Path sBitmap To sBitmap
83696>>>>>>>>>>>>>>>>>>>    End
83696>>>>>>>>>>>>>>>>>>>>
83696>>>>>>>>>>>>>>>>>>>    Function_Return sBitmap
83697>>>>>>>>>>>>>>>>>>>  End_Function
83698>>>>>>>>>>>>>>>>>>>
83698>>>>>>>>>>>>>>>>>>>  //
83698>>>>>>>>>>>>>>>>>>>  // This item number is used to refer to the ORIGINAL item id in the object that supplied the data
83698>>>>>>>>>>>>>>>>>>>  // it should not be used to retrieve the data of this array as you'll end up getting different data.
83698>>>>>>>>>>>>>>>>>>>  // Capiche?
83698>>>>>>>>>>>>>>>>>>>  //
83698>>>>>>>>>>>>>>>>>>>  Function Codelist_current_item Returns Integer
83700>>>>>>>>>>>>>>>>>>>    Integer iCurrent
83700>>>>>>>>>>>>>>>>>>>    Integer iItem
83700>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83700>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83701>>>>>>>>>>>>>>>>>>>
83701>>>>>>>>>>>>>>>>>>>    Move -1 To iItem
83702>>>>>>>>>>>>>>>>>>>    Get piCurrent To iCurrent
83703>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
83704>>>>>>>>>>>>>>>>>>>    If (iCurrent<>-1 and iCurrent < SizeOfArray(CodeList)) Begin
83706>>>>>>>>>>>>>>>>>>>      Move CodeList[iCurrent].iInsertOrder To iItem
83707>>>>>>>>>>>>>>>>>>>    End
83707>>>>>>>>>>>>>>>>>>>>
83707>>>>>>>>>>>>>>>>>>>    Function_Return iItem
83708>>>>>>>>>>>>>>>>>>>  End_Function
83709>>>>>>>>>>>>>>>>>>>
83709>>>>>>>>>>>>>>>>>>>  Function Codelist_find_item String sItem Returns Integer
83711>>>>>>>>>>>>>>>>>>>    Integer   iItem
83711>>>>>>>>>>>>>>>>>>>    tCodeList SearchCode
83711>>>>>>>>>>>>>>>>>>>    tCodeList SearchCode
83711>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83711>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83712>>>>>>>>>>>>>>>>>>>
83712>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
83713>>>>>>>>>>>>>>>>>>>    //Move (SearchArray(sItem, CodeList, Desktop, (RefFunc(DFSTRICMP)))) to iItem
83713>>>>>>>>>>>>>>>>>>>    Move (Lowercase(sItem)) To SearchCode.sSortValue
83714>>>>>>>>>>>>>>>>>>>    Move (SearchArray(SearchCode,CodeList)) To iItem
83715>>>>>>>>>>>>>>>>>>>    Set piCurrent To iItem
83716>>>>>>>>>>>>>>>>>>>    Function_Return iItem
83717>>>>>>>>>>>>>>>>>>>  End_Function
83718>>>>>>>>>>>>>>>>>>>
83718>>>>>>>>>>>>>>>>>>>  //
83718>>>>>>>>>>>>>>>>>>>  // Add index numbers to the array
83718>>>>>>>>>>>>>>>>>>>  //
83718>>>>>>>>>>>>>>>>>>>  Procedure LabelArray tCodeList[] ByRef CodeList
83720>>>>>>>>>>>>>>>>>>>    Integer iItem
83720>>>>>>>>>>>>>>>>>>>    Integer iCount
83720>>>>>>>>>>>>>>>>>>>
83720>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(CodeList)) To iCount
83721>>>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
83723>>>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
83729>>>>>>>>>>>>>>>>>>>>
83729>>>>>>>>>>>>>>>>>>>        Move iItem To CodeList[iItem].iInsertOrder
83730>>>>>>>>>>>>>>>>>>>      Loop
83731>>>>>>>>>>>>>>>>>>>>
83731>>>>>>>>>>>>>>>>>>>    End
83731>>>>>>>>>>>>>>>>>>>>
83731>>>>>>>>>>>>>>>>>>>  End_Procedure
83732>>>>>>>>>>>>>>>>>>>
83732>>>>>>>>>>>>>>>>>>>  // Does a few things:
83732>>>>>>>>>>>>>>>>>>>  // - Will first reverse the array as our items have been added instead of inserted like in the original code
83732>>>>>>>>>>>>>>>>>>>  // - Then it will add index numbers so that we can return original references
83732>>>>>>>>>>>>>>>>>>>  // - After which we will sort the list, this might not be needed, but it is a precaution for if somebody
83732>>>>>>>>>>>>>>>>>>>  //   made an error while inserting data in a non ascending order.
83732>>>>>>>>>>>>>>>>>>>  //
83732>>>>>>>>>>>>>>>>>>>  Procedure SortAscending
83734>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83734>>>>>>>>>>>>>>>>>>>    tCodeList[] CodeList
83735>>>>>>>>>>>>>>>>>>>
83735>>>>>>>>>>>>>>>>>>>    Get pCodeList To CodeList
83736>>>>>>>>>>>>>>>>>>>    Move (ReverseArray(CodeList)) To CodeList
83737>>>>>>>>>>>>>>>>>>>    Send LabelArray (&CodeList)
83738>>>>>>>>>>>>>>>>>>>    //Move (SortArray(CodeList, Desktop, (RefFunc(DFSTRICMP)))) to CodeList
83738>>>>>>>>>>>>>>>>>>>    Move (SortArray(CodeList)) To CodeList
83739>>>>>>>>>>>>>>>>>>>    Set pCodeList To CodeList
83740>>>>>>>>>>>>>>>>>>>  End_Procedure
83741>>>>>>>>>>>>>>>>>>>
83741>>>>>>>>>>>>>>>>>>>  Procedure Set Codelist_style Integer iStyle
83743>>>>>>>>>>>>>>>>>>>  End_Procedure
83744>>>>>>>>>>>>>>>>>>>
83744>>>>>>>>>>>>>>>>>>>  Procedure Set Codelist_font Integer hFont
83746>>>>>>>>>>>>>>>>>>>  End_Procedure
83747>>>>>>>>>>>>>>>>>>>
83747>>>>>>>>>>>>>>>>>>>  //
83747>>>>>>>>>>>>>>>>>>>  // We don't use this in scintilla, instead we show the autocomplete list
83747>>>>>>>>>>>>>>>>>>>  // and pass the word to select.
83747>>>>>>>>>>>>>>>>>>>  //
83747>>>>>>>>>>>>>>>>>>>  //Function Codelist_SelectClosestItem String sText Returns Integer
83747>>>>>>>>>>>>>>>>>>>  //    Function_Return iItem
83747>>>>>>>>>>>>>>>>>>>  //End_Function
83747>>>>>>>>>>>>>>>>>>>
83747>>>>>>>>>>>>>>>>>>>  Function Codelist_Item_count Returns Integer
83749>>>>>>>>>>>>>>>>>>>    Integer iCount
83749>>>>>>>>>>>>>>>>>>>
83749>>>>>>>>>>>>>>>>>>>    Move (SizeOfArray(pCodeList(Self))) To iCount
83750>>>>>>>>>>>>>>>>>>>    Function_Return iCount
83751>>>>>>>>>>>>>>>>>>>  End_Function
83752>>>>>>>>>>>>>>>>>>>
83752>>>>>>>>>>>>>>>>>>>  //
83752>>>>>>>>>>>>>>>>>>>  // ToDo: Codelist_Beginning_Of_Data
83752>>>>>>>>>>>>>>>>>>>  //
83752>>>>>>>>>>>>>>>>>>>  Procedure Codelist_Beginning_Of_Data
83754>>>>>>>>>>>>>>>>>>>    //String sVal sLvItem
83754>>>>>>>>>>>>>>>>>>>    //Pointer pVal pLvItem
83754>>>>>>>>>>>>>>>>>>>    //Integer iRet iItem
83754>>>>>>>>>>>>>>>>>>>    //If (phoCodelist(self)) Eq 0 Procedure_Return
83754>>>>>>>>>>>>>>>>>>>
83754>>>>>>>>>>>>>>>>>>>    //zerotype LVITEM to sLvItem
83754>>>>>>>>>>>>>>>>>>>    //getaddress Of sLvItem to pLvItem
83754>>>>>>>>>>>>>>>>>>>    //
83754>>>>>>>>>>>>>>>>>>>    //put LVIF_STATE to sLvItem at LVITEM.mask
83754>>>>>>>>>>>>>>>>>>>    //put 0 to sLvItem at LVITEM.iItem
83754>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.state
83754>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.stateMask
83754>>>>>>>>>>>>>>>>>>>    //
83754>>>>>>>>>>>>>>>>>>>    //Move (ListView_SetItemState(phoCodelist(self),0,pLvItem)) to iRet
83754>>>>>>>>>>>>>>>>>>>    //If (Not(iRet)) Procedure_Return
83754>>>>>>>>>>>>>>>>>>>    //Move (ListView_EnsureVisible(phoCodelist(self),0,FALSE)) to iRet
83754>>>>>>>>>>>>>>>>>>>  End_Procedure
83755>>>>>>>>>>>>>>>>>>>
83755>>>>>>>>>>>>>>>>>>>  //
83755>>>>>>>>>>>>>>>>>>>  // ToDo: Codelist_End_Of_Data
83755>>>>>>>>>>>>>>>>>>>  //
83755>>>>>>>>>>>>>>>>>>>  Procedure Codelist_End_Of_Data
83757>>>>>>>>>>>>>>>>>>>    //String sVal sLvItem
83757>>>>>>>>>>>>>>>>>>>    //Pointer pVal pLvItem
83757>>>>>>>>>>>>>>>>>>>    //Integer iRet iItem
83757>>>>>>>>>>>>>>>>>>>    //If (phoCodelist(self)) Eq 0 Procedure_Return
83757>>>>>>>>>>>>>>>>>>>
83757>>>>>>>>>>>>>>>>>>>    //zerotype LVITEM to sLvItem
83757>>>>>>>>>>>>>>>>>>>    //getaddress Of sLvItem to pLvItem
83757>>>>>>>>>>>>>>>>>>>    //
83757>>>>>>>>>>>>>>>>>>>    //put LVIF_STATE to sLvItem at LVITEM.mask
83757>>>>>>>>>>>>>>>>>>>    ////Move (Listview_GetItemCount(phoCodelist(self))) to iItem
83757>>>>>>>>>>>>>>>>>>>    //Get Item_Count to iItem
83757>>>>>>>>>>>>>>>>>>>    //If iItem Eq -1 Procedure_Return
83757>>>>>>>>>>>>>>>>>>>    //Move (iItem-1) to iItem
83757>>>>>>>>>>>>>>>>>>>    //put iItem to sLvItem at LVITEM.iItem
83757>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.state
83757>>>>>>>>>>>>>>>>>>>    //put (LVIS_SELECTED Ior LVIS_FOCUSED) to sLvItem at LVITEM.stateMask
83757>>>>>>>>>>>>>>>>>>>    //
83757>>>>>>>>>>>>>>>>>>>    //Move (ListView_SetItemState(phoCodelist(self),iItem,pLvItem)) to iRet
83757>>>>>>>>>>>>>>>>>>>    //If (Not(iRet)) Procedure_Return
83757>>>>>>>>>>>>>>>>>>>    //Move (ListView_EnsureVisible(phoCodelist(self),iItem,FALSE)) to iRet
83757>>>>>>>>>>>>>>>>>>>  End_Procedure
83758>>>>>>>>>>>>>>>>>>>
83758>>>>>>>>>>>>>>>>>>>End_Class
83759>>>>>>>>>>>>>>>>>>>
83759>>>>>>>>>>>>>>>>>>>// BP CodeList Support
83759>>>>>>>>>>>>>>>>>>>// this object is just for testing the codelist functions
83759>>>>>>>>>>>>>>>>>>>// SVN
83759>>>>>>>>>>>>>>>>>>>Global_Variable Integer ghoCodeList
83759>>>>>>>>>>>>>>>>>>>Object oCodelist is a cSciCodelist
83761>>>>>>>>>>>>>>>>>>>  Object oClassDataCache is an Array
83763>>>>>>>>>>>>>>>>>>>  End_Object
83764>>>>>>>>>>>>>>>>>>>  Property Integer piListReason     0
83766>>>>>>>>>>>>>>>>>>>  Property Integer piSourceObject   0
83768>>>>>>>>>>>>>>>>>>>  Property Integer piSourceLine     0
83770>>>>>>>>>>>>>>>>>>>  Property String  psSourceLine     ""
83772>>>>>>>>>>>>>>>>>>>  Property String  psSourceRefVal   ""
83774>>>>>>>>>>>>>>>>>>>  Move self To ghoCodeList
83775>>>>>>>>>>>>>>>>>>>
83775>>>>>>>>>>>>>>>>>>>  Function Codelist_Add_CachedItem String sText String sBitmap Integer iRefValue Returns Integer
83778>>>>>>>>>>>>>>>>>>>    String  sArrayValue
83778>>>>>>>>>>>>>>>>>>>    Integer iRet
83778>>>>>>>>>>>>>>>>>>>
83778>>>>>>>>>>>>>>>>>>>    Move ( sText + "\new\" + (String(iRefValue)) + "\new\" ) To sArrayValue
83779>>>>>>>>>>>>>>>>>>>
83779>>>>>>>>>>>>>>>>>>>    If ( (pbUseBitmaps(self)) And (sBitmap Eq "") ) Begin
83781>>>>>>>>>>>>>>>>>>>      Move "default.bmp" To sBitmap
83782>>>>>>>>>>>>>>>>>>>    End
83782>>>>>>>>>>>>>>>>>>>>
83782>>>>>>>>>>>>>>>>>>>    If sBitmap Ne "" Begin
83784>>>>>>>>>>>>>>>>>>>      Move (sArrayValue + (String(sBitmap)) ) To sArrayValue
83785>>>>>>>>>>>>>>>>>>>    End
83785>>>>>>>>>>>>>>>>>>>>
83785>>>>>>>>>>>>>>>>>>>    Else Begin
83786>>>>>>>>>>>>>>>>>>>      Move (sArrayValue + "-1") To sArrayValue
83787>>>>>>>>>>>>>>>>>>>    End
83787>>>>>>>>>>>>>>>>>>>>
83787>>>>>>>>>>>>>>>>>>>    Move (sArrayValue + "\new\" ) To sArrayValue
83788>>>>>>>>>>>>>>>>>>>
83788>>>>>>>>>>>>>>>>>>>    Set Value Of oClassDataCache Item (item_count(oClassDataCache(self))) To sArrayValue
83789>>>>>>>>>>>>>>>>>>>
83789>>>>>>>>>>>>>>>>>>>    Set Value Item (CodeList_Item_Count(Self)) To sText
83790>>>>>>>>>>>>>>>>>>>    Function_Return iRet
83791>>>>>>>>>>>>>>>>>>>  End_Function
83792>>>>>>>>>>>>>>>>>>>
83792>>>>>>>>>>>>>>>>>>>  Procedure FillCodelistFromCache
83795>>>>>>>>>>>>>>>>>>>    Integer iItem iRet
83795>>>>>>>>>>>>>>>>>>>    String sText sRefValue sBitmap sLine
83795>>>>>>>>>>>>>>>>>>>
83795>>>>>>>>>>>>>>>>>>>    For iItem From 0 To ( (item_count(oClassDataCache(self))) -1)
83801>>>>>>>>>>>>>>>>>>>>
83801>>>>>>>>>>>>>>>>>>>      Get Value Of oClassDataCache Item iItem To sLine
83802>>>>>>>>>>>>>>>>>>>      Move (Left(sLine,((Pos("\new\",sLine))+4))) To sText
83803>>>>>>>>>>>>>>>>>>>      Move (Replace(sText,sLine,"")) To sLine
83804>>>>>>>>>>>>>>>>>>>      Move (Replace("\new\",sText,"")) To sText
83805>>>>>>>>>>>>>>>>>>>
83805>>>>>>>>>>>>>>>>>>>      Move (Left(sLine,((Pos("\new\",sLine))+4))) To sRefValue
83806>>>>>>>>>>>>>>>>>>>      Move (Replace(sRefValue,sLine,"")) To sBitmap
83807>>>>>>>>>>>>>>>>>>>      Move (Replace("\new\",sRefValue,"")) To sRefValue
83808>>>>>>>>>>>>>>>>>>>      Move (Replace("\new\",sBitmap,"")) To sBitmap
83809>>>>>>>>>>>>>>>>>>>
83809>>>>>>>>>>>>>>>>>>>      Get Codelist_Add_Item sText sBitmap sRefValue To iRet
83810>>>>>>>>>>>>>>>>>>>    Loop
83811>>>>>>>>>>>>>>>>>>>>
83811>>>>>>>>>>>>>>>>>>>  End_Procedure
83812>>>>>>>>>>>>>>>>>>>
83812>>>>>>>>>>>>>>>>>>>End_Object
83813>>>>>>>>>>>>>>>>>>>// BP
83813>>>>>>>>>>>>>>>>>>>
83813>>>>>>>>>>>>>>>>>Use DllHandler.pkg
Including file: DLLHandler.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\DLLHandler.pkg)
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//  File DllHandler.pkg
83813>>>>>>>>>>>>>>>>>>>//  Author: Wil van Antwerpen
83813>>>>>>>>>>>>>>>>>>>//  Company: Antwise Solutions
83813>>>>>>>>>>>>>>>>>>>//  License: LGPL
83813>>>>>>>>>>>>>>>>>>>//  Date: March 2, 2003
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>// This class helps you to manage the loading and unloading of DLLs in the address space
83813>>>>>>>>>>>>>>>>>>>// of our application.
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>// When you include this package into your application it will first create the class
83813>>>>>>>>>>>>>>>>>>>// and afterwards also create an object called oDllHandler
83813>>>>>>>>>>>>>>>>>>>// This object is automatically initialized and will try to set the psDllLoadPath property
83813>>>>>>>>>>>>>>>>>>>// with the workspace programs folder from the current application.
83813>>>>>>>>>>>>>>>>>>>// If no workspace is known, the current windows directory is taken instead and stored in
83813>>>>>>>>>>>>>>>>>>>// the psDllLoadPath property
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>// If a windows error occurs, the exact error is retrieved with the GetLastError function
83813>>>>>>>>>>>>>>>>>>>// and the code from that is stored in the piWindowsLastError property.
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>// Benefits of using this class are:
83813>>>>>>>>>>>>>>>>>>>//   - Easy loading a of DLL from the current programs workspace by calling the doLoadLibrary method
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//   - If a DLL is not found during runtime your application will by default show a
83813>>>>>>>>>>>>>>>>>>>//   message in the UI to the user which DLL from which path is missing and abort the program.
83813>>>>>>>>>>>>>>>>>>>//   This is desirable for most windows applications where DLLs are missing.
83813>>>>>>>>>>>>>>>>>>>//   Without this you get a runtime error each time the function is called and it usually
83813>>>>>>>>>>>>>>>>>>>//   results in a neverending number of warnings.
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//   This behaviour can be switched off by setting the pbErrorAbort method to false.
83813>>>>>>>>>>>>>>>>>>>//   In that case it is expected that the developer properly handles the event.
83813>>>>>>>>>>>>>>>>>>>//   You would need this for example in WebApps where the userinterface is the clients browser
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//   - Unloading of a DLL from the programs address space (hardly tested, but it seems to work fine)
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>//  o ToDo Extend the DoLoadLibrary method to also check on VersionInfo
83813>>>>>>>>>>>>>>>>>>>//=========================================================================================
83813>>>>>>>>>>>>>>>>>>>//  03-02-2003 **WvA First Draft
83813>>>>>>>>>>>>>>>>>>>//
83813>>>>>>>>>>>>>>>>>>>
83813>>>>>>>>>>>>>>>>>>>Use vWin32fh.pkg
83813>>>>>>>>>>>>>>>>>>>Use Set.pkg
83813>>>>>>>>>>>>>>>>>>>
83813>>>>>>>>>>>>>>>>>>>Define CS_ERRMISSINGDLLLINE1   For "There are essential components missing for the program to function properly.\n"
83813>>>>>>>>>>>>>>>>>>>Define CS_ERRMISSINGDLLLINE2   For "\nThe program was unable to load the module:\n "
83813>>>>>>>>>>>>>>>>>>>Define CS_ERRMISSINGDLLCAPTION For "Program Halted"
83813>>>>>>>>>>>>>>>>>>>
83813>>>>>>>>>>>>>>>>>>>Class cDllHandler is a DfObject
83814>>>>>>>>>>>>>>>>>>>  Procedure Construct_Object
83816>>>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
83818>>>>>>>>>>>>>>>>>>>    Property String  psDllLoadPath                  ""    // The default library path from where Dlls will be loaded
83819>>>>>>>>>>>>>>>>>>>    Property Integer pbErrorAbort                   True  // If true and a DLL fails to load then the application is aborted when using the doLoadLibrary method
83820>>>>>>>>>>>>>>>>>>>    Property Integer pbErrorReport                  True  // If true and a DLL fails, the error is displayed to the end-user by using a stop_box
83821>>>>>>>>>>>>>>>>>>>    Property Integer piLastWindowsError             0     // Holds the Windows Error from GetLastError
83822>>>>>>>>>>>>>>>>>>>
83822>>>>>>>>>>>>>>>>>>>    Object oModuleHandles is a Array
83824>>>>>>>>>>>>>>>>>>>    End_Object
83825>>>>>>>>>>>>>>>>>>>
83825>>>>>>>>>>>>>>>>>>>    Object oModuleNames is a Set
83827>>>>>>>>>>>>>>>>>>>    End_Object
83828>>>>>>>>>>>>>>>>>>>
83828>>>>>>>>>>>>>>>>>>>    Send Init   // Sets the DLlLoadpath
83829>>>>>>>>>>>>>>>>>>>  End_Procedure
83830>>>>>>>>>>>>>>>>>>>
83830>>>>>>>>>>>>>>>>>>>  Procedure Set ModuleHandle Integer iModule Integer hModule
83832>>>>>>>>>>>>>>>>>>>    Set Value Of oModuleHandles Item iModule To hModule
83833>>>>>>>>>>>>>>>>>>>  End_Procedure
83834>>>>>>>>>>>>>>>>>>>
83834>>>>>>>>>>>>>>>>>>>  //
83834>>>>>>>>>>>>>>>>>>>  // If sPath is "" then the programsfolder of the current workspace will be the first
83834>>>>>>>>>>>>>>>>>>>  // path which is searched
83834>>>>>>>>>>>>>>>>>>>  //
83834>>>>>>>>>>>>>>>>>>>  // Returns 0 if loading the dll was succesful
83834>>>>>>>>>>>>>>>>>>>  // Precondition:
83834>>>>>>>>>>>>>>>>>>>  //   If a path is passed in sPath, then it must always end with a "\"
83834>>>>>>>>>>>>>>>>>>>  //   You must always supply a Dllname
83834>>>>>>>>>>>>>>>>>>>  Function DllLoadLibrary String sPath String sFile Returns Integer
83836>>>>>>>>>>>>>>>>>>>    Handle  hModule 
83836>>>>>>>>>>>>>>>>>>>    Integer iModule
83836>>>>>>>>>>>>>>>>>>>    Integer iFailed iErr iFound
83836>>>>>>>>>>>>>>>>>>>    String  sModule 
83836>>>>>>>>>>>>>>>>>>>    Boolean bExists
83836>>>>>>>>>>>>>>>>>>>    
83836>>>>>>>>>>>>>>>>>>>    Move 0 To iFailed
83837>>>>>>>>>>>>>>>>>>>    Move 0 To hModule
83838>>>>>>>>>>>>>>>>>>>    Move (Uppercase(sFile)) To sFile
83839>>>>>>>>>>>>>>>>>>>    If sPath Eq "" Begin
83841>>>>>>>>>>>>>>>>>>>      Get psDllLoadPath To sPath
83842>>>>>>>>>>>>>>>>>>>      Get vFolderFormat sPath To sPath
83843>>>>>>>>>>>>>>>>>>>    End
83843>>>>>>>>>>>>>>>>>>>>
83843>>>>>>>>>>>>>>>>>>>    Get vFilePathExists (sPath+sFile) to bExists
83844>>>>>>>>>>>>>>>>>>>    If (bExists = True) Begin
83846>>>>>>>>>>>>>>>>>>>      Move (sPath+sFile+Character(0)) to sModule
83847>>>>>>>>>>>>>>>>>>>      Get Find_Element Of oModuleNames sFile To iModule
83848>>>>>>>>>>>>>>>>>>>      If iModule Ne -1 Begin
83850>>>>>>>>>>>>>>>>>>>        Get Value Item iModule To hModule
83851>>>>>>>>>>>>>>>>>>>        If hModule Eq 0 Begin
83853>>>>>>>>>>>>>>>>>>>          Move (LoadLibrary(sModule)) to hModule
83854>>>>>>>>>>>>>>>>>>>          If hModule Ne 0 Begin
83856>>>>>>>>>>>>>>>>>>>            Set Value Of oModuleHandles Item iModule To hModule
83857>>>>>>>>>>>>>>>>>>>          End
83857>>>>>>>>>>>>>>>>>>>>
83857>>>>>>>>>>>>>>>>>>>          Else Begin
83858>>>>>>>>>>>>>>>>>>>            // An error occured during the actual unloading by windows
83858>>>>>>>>>>>>>>>>>>>            // Get extended error information, call GetLastError.
83858>>>>>>>>>>>>>>>>>>>            Move 3 To iFailed
83859>>>>>>>>>>>>>>>>>>>            Move (GetLastError()) To iErr
83860>>>>>>>>>>>>>>>>>>>            Set piLastWindowsError To iErr
83861>>>>>>>>>>>>>>>>>>>          End
83861>>>>>>>>>>>>>>>>>>>>
83861>>>>>>>>>>>>>>>>>>>        End
83861>>>>>>>>>>>>>>>>>>>>
83861>>>>>>>>>>>>>>>>>>>      End
83861>>>>>>>>>>>>>>>>>>>>
83861>>>>>>>>>>>>>>>>>>>      Else Begin
83862>>>>>>>>>>>>>>>>>>>        Move (LoadLibrary(sModule)) to hModule
83863>>>>>>>>>>>>>>>>>>>        If hModule Ne 0 Begin
83865>>>>>>>>>>>>>>>>>>>          Send Add_Item hModule sFile
83866>>>>>>>>>>>>>>>>>>>        End
83866>>>>>>>>>>>>>>>>>>>>
83866>>>>>>>>>>>>>>>>>>>        Else Begin
83867>>>>>>>>>>>>>>>>>>>          // An error occured during the actual unloading by windows
83867>>>>>>>>>>>>>>>>>>>          // Get extended error information, call GetLastError.
83867>>>>>>>>>>>>>>>>>>>          Move 3 To iFailed
83868>>>>>>>>>>>>>>>>>>>          Move (GetLastError()) To iErr
83869>>>>>>>>>>>>>>>>>>>          Set piLastWindowsError To iErr
83870>>>>>>>>>>>>>>>>>>>        End
83870>>>>>>>>>>>>>>>>>>>>
83870>>>>>>>>>>>>>>>>>>>      End
83870>>>>>>>>>>>>>>>>>>>>
83870>>>>>>>>>>>>>>>>>>>    End
83870>>>>>>>>>>>>>>>>>>>>
83870>>>>>>>>>>>>>>>>>>>    Else Begin
83871>>>>>>>>>>>>>>>>>>>      Move 1 To iFailed // The file was not found
83872>>>>>>>>>>>>>>>>>>>    End
83872>>>>>>>>>>>>>>>>>>>>
83872>>>>>>>>>>>>>>>>>>>    Function_Return iFailed
83873>>>>>>>>>>>>>>>>>>>  End_Function
83874>>>>>>>>>>>>>>>>>>>
83874>>>>>>>>>>>>>>>>>>>  // Tries to load the DLL passed as sModuleName
83874>>>>>>>>>>>>>>>>>>>  // If pbErrorAbort is set the program is aborted and a message is displayed to
83874>>>>>>>>>>>>>>>>>>>  // the user.
83874>>>>>>>>>>>>>>>>>>>  // Calls DllLoadLibrary to actually load the DLL
83874>>>>>>>>>>>>>>>>>>>  //
83874>>>>>>>>>>>>>>>>>>>  // Does not return a value
83874>>>>>>>>>>>>>>>>>>>  Procedure doLoadLibrary String sModuleName
83876>>>>>>>>>>>>>>>>>>>    Integer iError bAbort bReport
83876>>>>>>>>>>>>>>>>>>>    String  sMessage sPath
83876>>>>>>>>>>>>>>>>>>>    Move 0 To iError
83877>>>>>>>>>>>>>>>>>>>    Get DllLoadLibrary "" sModuleName To iError
83878>>>>>>>>>>>>>>>>>>>    If (iError <> 0) Begin
83880>>>>>>>>>>>>>>>>>>>      Get pbErrorAbort  To bAbort
83881>>>>>>>>>>>>>>>>>>>      Get pbErrorReport To bReport
83882>>>>>>>>>>>>>>>>>>>      If (bReport) Begin
83884>>>>>>>>>>>>>>>>>>>        Get psDllLoadPath to sPath
83885>>>>>>>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
83886>>>>>>>>>>>>>>>>>>>        Move CS_ERRMISSINGDLLLINE1 To sMessage
83887>>>>>>>>>>>>>>>>>>>        Move (sMessage+CS_ERRMISSINGDLLLINE2) To sMessage
83888>>>>>>>>>>>>>>>>>>>        Move (sMessage+sPath+sModuleName+"\n\n") To sMessage
83889>>>>>>>>>>>>>>>>>>>        Send Stop_Box sMessage CS_ERRMISSINGDLLCAPTION
83890>>>>>>>>>>>>>>>>>>>      End
83890>>>>>>>>>>>>>>>>>>>>
83890>>>>>>>>>>>>>>>>>>>      If (bAbort) Begin
83892>>>>>>>>>>>>>>>>>>>        Abort
83893>>>>>>>>>>>>>>>>>>>>
83893>>>>>>>>>>>>>>>>>>>      End
83893>>>>>>>>>>>>>>>>>>>>
83893>>>>>>>>>>>>>>>>>>>    End
83893>>>>>>>>>>>>>>>>>>>>
83893>>>>>>>>>>>>>>>>>>>  End_Procedure
83894>>>>>>>>>>>>>>>>>>>
83894>>>>>>>>>>>>>>>>>>>  // Internal, do not use
83894>>>>>>>>>>>>>>>>>>>  //
83894>>>>>>>>>>>>>>>>>>>  // Precondition:
83894>>>>>>>>>>>>>>>>>>>  //  sFile must be UPPERCASEd
83894>>>>>>>>>>>>>>>>>>>  //  hModule must contain the windows module handle of the library that was mapped
83894>>>>>>>>>>>>>>>>>>>  //    into our address space
83894>>>>>>>>>>>>>>>>>>>  Procedure Add_Item Integer hModule Integer sFile
83896>>>>>>>>>>>>>>>>>>>    Integer iModule
83896>>>>>>>>>>>>>>>>>>>    Get Item_Count Of oModuleNames To iModule
83897>>>>>>>>>>>>>>>>>>>    Set Value Of oModuleNames Item iModule To sFile
83898>>>>>>>>>>>>>>>>>>>    Set ModuleHandle Item iModule To hModule
83899>>>>>>>>>>>>>>>>>>>  End_Procedure
83900>>>>>>>>>>>>>>>>>>>
83900>>>>>>>>>>>>>>>>>>>  // Clear the DLL handler
83900>>>>>>>>>>>>>>>>>>>  Procedure Delete_Data
83902>>>>>>>>>>>>>>>>>>>    Integer hModuleHandles
83902>>>>>>>>>>>>>>>>>>>    Integer hModuleNames
83902>>>>>>>>>>>>>>>>>>>    Move (oModuleHandles(Self)) To hModuleHandles
83903>>>>>>>>>>>>>>>>>>>    If hModuleHandles Ne 0 Begin
83905>>>>>>>>>>>>>>>>>>>      Send Delete_Data To hModuleHandles
83906>>>>>>>>>>>>>>>>>>>    End
83906>>>>>>>>>>>>>>>>>>>>
83906>>>>>>>>>>>>>>>>>>>    Move (oModuleNames(Self)) To hModuleNames
83907>>>>>>>>>>>>>>>>>>>    If hModuleNames Ne 0 Begin
83909>>>>>>>>>>>>>>>>>>>      Send Delete_Data To hModuleNames
83910>>>>>>>>>>>>>>>>>>>    End
83910>>>>>>>>>>>>>>>>>>>>
83910>>>>>>>>>>>>>>>>>>>    Forward Send Delete_Data
83912>>>>>>>>>>>>>>>>>>>  End_Procedure
83913>>>>>>>>>>>>>>>>>>>
83913>>>>>>>>>>>>>>>>>>>  // Returns the total nr of DLL files that are still loaded in memory
83913>>>>>>>>>>>>>>>>>>>  // Succesfully unloaded DLLs do not count.
83913>>>>>>>>>>>>>>>>>>>  //
83913>>>>>>>>>>>>>>>>>>>  // Precondition:
83913>>>>>>>>>>>>>>>>>>>  //  Only modules loaded by the DllLoadLibrary function count
83913>>>>>>>>>>>>>>>>>>>  Function LoadCount Returns Integer
83915>>>>>>>>>>>>>>>>>>>    Integer iModule iCount iLoaded
83915>>>>>>>>>>>>>>>>>>>    Integer hModule hModuleHandles
83915>>>>>>>>>>>>>>>>>>>    Move 0 To iLoaded
83916>>>>>>>>>>>>>>>>>>>    Move (oModuleHandles(Self)) To hModuleHandles
83917>>>>>>>>>>>>>>>>>>>    Move (Item_Count(hModuleHandles)-1) To iCount
83918>>>>>>>>>>>>>>>>>>>    For iModule From 0 To iCount
83924>>>>>>>>>>>>>>>>>>>>
83924>>>>>>>>>>>>>>>>>>>      Get Value Of hModuleHandles Item iModule To hModule
83925>>>>>>>>>>>>>>>>>>>      If (hModule <> 0) Begin
83927>>>>>>>>>>>>>>>>>>>        Increment iLoaded
83928>>>>>>>>>>>>>>>>>>>      End
83928>>>>>>>>>>>>>>>>>>>>
83928>>>>>>>>>>>>>>>>>>>    Loop
83929>>>>>>>>>>>>>>>>>>>>
83929>>>>>>>>>>>>>>>>>>>    Function_Return iLoaded
83930>>>>>>>>>>>>>>>>>>>  End_Function
83931>>>>>>>>>>>>>>>>>>>
83931>>>>>>>>>>>>>>>>>>>  // Get the total nr of modules that have been loaded using the
83931>>>>>>>>>>>>>>>>>>>  Function ItemCount Returns Integer
83933>>>>>>>>>>>>>>>>>>>    Function_Return (Item_Count(oModuleNames(Self)))
83934>>>>>>>>>>>>>>>>>>>  End_Function
83935>>>>>>>>>>>>>>>>>>>
83935>>>>>>>>>>>>>>>>>>>  // VDF syntax compatibility
83935>>>>>>>>>>>>>>>>>>>  Function Item_Count Returns Integer
83937>>>>>>>>>>>>>>>>>>>    Function_Return (ItemCount(Self))
83938>>>>>>>>>>>>>>>>>>>  End_Function
83939>>>>>>>>>>>>>>>>>>>
83939>>>>>>>>>>>>>>>>>>>  // Unload a Dllfile from memory
83939>>>>>>>>>>>>>>>>>>>  //
83939>>>>>>>>>>>>>>>>>>>  // sFile is the filename which was used to Load the library using the
83939>>>>>>>>>>>>>>>>>>>  //  DllLoadLibrary function from this class.
83939>>>>>>>>>>>>>>>>>>>  //
83939>>>>>>>>>>>>>>>>>>>  // Returns the following values:
83939>>>>>>>>>>>>>>>>>>>  // (False) if unloading of the dynamic Link library was succesful
83939>>>>>>>>>>>>>>>>>>>  // 1 if the DLL was not loaded in memory by the DllLoadLibrary function
83939>>>>>>>>>>>>>>>>>>>  // 2 if the DLL was already unloaded
83939>>>>>>>>>>>>>>>>>>>  // 3 An error occured during the actual unloading by windows
83939>>>>>>>>>>>>>>>>>>>  Function DllUnloadLibrary String sFile Returns Integer
83941>>>>>>>>>>>>>>>>>>>    Integer iFailed iErr
83941>>>>>>>>>>>>>>>>>>>    Integer iModule
83941>>>>>>>>>>>>>>>>>>>    Integer hModule hModuleHandles
83941>>>>>>>>>>>>>>>>>>>    Move 0 To iFailed
83942>>>>>>>>>>>>>>>>>>>    Move (UpperCase(sFile)) To sFile
83943>>>>>>>>>>>>>>>>>>>    Get Find_Element Of oModuleNames sFile To iModule
83944>>>>>>>>>>>>>>>>>>>    If iModule Ne -1 Begin
83946>>>>>>>>>>>>>>>>>>>      Move (oModuleHandles(Self)) To hModuleHandles
83947>>>>>>>>>>>>>>>>>>>      Get Value Of hModuleHandles Item iModule To hModule
83948>>>>>>>>>>>>>>>>>>>      If hModule Ne 0 Begin
83950>>>>>>>>>>>>>>>>>>>        //   Free ee Nelson Mandela  - oh yeah oh yeah...
83950>>>>>>>>>>>>>>>>>>>        Move (FreeLibrary(hModule)) To iErr
83951>>>>>>>>>>>>>>>>>>>        If iErr Ne 0 Begin  // If the function succeeds, the return value is nonzero.
83953>>>>>>>>>>>>>>>>>>>          Set Value Of hModuleHandles Item iModule To 0
83954>>>>>>>>>>>>>>>>>>>        End
83954>>>>>>>>>>>>>>>>>>>>
83954>>>>>>>>>>>>>>>>>>>        Else Begin
83955>>>>>>>>>>>>>>>>>>>          // An error occured during the actual unloading by windows
83955>>>>>>>>>>>>>>>>>>>          // Get extended error information, call GetLastError.
83955>>>>>>>>>>>>>>>>>>>          Move 3 To iFailed
83956>>>>>>>>>>>>>>>>>>>          Move (GetLastError()) To iErr
83957>>>>>>>>>>>>>>>>>>>          Set piLastWindowsError To iErr
83958>>>>>>>>>>>>>>>>>>>        End
83958>>>>>>>>>>>>>>>>>>>>
83958>>>>>>>>>>>>>>>>>>>      End
83958>>>>>>>>>>>>>>>>>>>>
83958>>>>>>>>>>>>>>>>>>>      Else Begin
83959>>>>>>>>>>>>>>>>>>>        Move 2 To iFailed // The DLL was already unloaded
83960>>>>>>>>>>>>>>>>>>>      End
83960>>>>>>>>>>>>>>>>>>>>
83960>>>>>>>>>>>>>>>>>>>    End
83960>>>>>>>>>>>>>>>>>>>>
83960>>>>>>>>>>>>>>>>>>>    Else Begin
83961>>>>>>>>>>>>>>>>>>>      Move 1 To iFailed // The DLL was not loaded in memory by the DllLoadLibrary function
83962>>>>>>>>>>>>>>>>>>>    End
83962>>>>>>>>>>>>>>>>>>>>
83962>>>>>>>>>>>>>>>>>>>    Function_Return iFailed
83963>>>>>>>>>>>>>>>>>>>  End_Function
83964>>>>>>>>>>>>>>>>>>>
83964>>>>>>>>>>>>>>>>>>>  Procedure Init
83966>>>>>>>>>>>>>>>>>>>    String  sPath
83966>>>>>>>>>>>>>>>>>>>
83966>>>>>>>>>>>>>>>>>>>    If sPath Eq "" Begin
83968>>>>>>>>>>>>>>>>>>>      Get_Current_Directory To sPath
83969>>>>>>>>>>>>>>>>>>>    End
83969>>>>>>>>>>>>>>>>>>>>
83969>>>>>>>>>>>>>>>>>>>    Move (vFolderFormat(sPath)) To sPath
83970>>>>>>>>>>>>>>>>>>>    Set psDllLoadPath To sPath
83971>>>>>>>>>>>>>>>>>>>  End_Procedure
83972>>>>>>>>>>>>>>>>>>>
83972>>>>>>>>>>>>>>>>>>>End_Class
83973>>>>>>>>>>>>>>>>>>>
83973>>>>>>>>>>>>>>>>>>>Object oDllHandler is a cDllHandler
83975>>>>>>>>>>>>>>>>>>>End_Object
83976>>>>>>>>>>>>>>>>>>>
83976>>>>>>>>>>>>>>>>>Use THDialog.pkg
83976>>>>>>>>>>>>>>>>>Use Tools\Find.dg
Including file: Tools\Find.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\Tools\Find.dg)
83976>>>>>>>>>>>>>>>>>>>Use Windows.pkg
83976>>>>>>>>>>>>>>>>>>>Use MessageQueueHelpers.pkg
Including file: MessageQueueHelpers.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MessageQueueHelpers.pkg)
83976>>>>>>>>>>>>>>>>>>>>>//TH-Header
83976>>>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
83976>>>>>>>>>>>>>>>>>>>>>// Copyright (c)  2018 Your Company Name
83976>>>>>>>>>>>>>>>>>>>>>// All rights reserved.
83976>>>>>>>>>>>>>>>>>>>>>//
83976>>>>>>>>>>>>>>>>>>>>>// $FileName    : MessageQueueHelpers.pkg
83976>>>>>>>>>>>>>>>>>>>>>// $ProjectName : The Hammer 3
83976>>>>>>>>>>>>>>>>>>>>>// $Authors     :
83976>>>>>>>>>>>>>>>>>>>>>// $Created     : 02.08.2018  11:54
83976>>>>>>>>>>>>>>>>>>>>>//
83976>>>>>>>>>>>>>>>>>>>>>// Contents:
83976>>>>>>>>>>>>>>>>>>>>>//   Used for dispatching keys from the message queue.
83976>>>>>>>>>>>>>>>>>>>>>//
83976>>>>>>>>>>>>>>>>>>>>>//*****************************************************************************************
83976>>>>>>>>>>>>>>>>>>>>>//TH-RevisionStart
83976>>>>>>>>>>>>>>>>>>>>>// ********************
83976>>>>>>>>>>>>>>>>>>>>>// MODIFICATION SUMMARY
83976>>>>>>>>>>>>>>>>>>>>>// ********************
83976>>>>>>>>>>>>>>>>>>>>>// ####### DD/MM/YYYY  WHO COMMENT
83976>>>>>>>>>>>>>>>>>>>>>//TH-RevisionEnd
83976>>>>>>>>>>>>>>>>>>>>>
83976>>>>>>>>>>>>>>>>>>>>>
83976>>>>>>>>>>>>>>>>>>>>>Define WM_HOTKEY For |CI$0312  //  0x0312
83976>>>>>>>>>>>>>>>>>>>>>Define PM_REMOVE For 1
83976>>>>>>>>>>>>>>>>>>>>>
83976>>>>>>>>>>>>>>>>>>>>>
83976>>>>>>>>>>>>>>>>>>>>>// dll-function and msg-type needed for removing posted messages from the message queue
83976>>>>>>>>>>>>>>>>>>>>>// 28.1.2003 BP
83976>>>>>>>>>>>>>>>>>>>>>Struct tMSG
83976>>>>>>>>>>>>>>>>>>>>>  Handle   hwnd     //as Handle
83976>>>>>>>>>>>>>>>>>>>>>  Integer  message  //as Integer
83976>>>>>>>>>>>>>>>>>>>>>  Longptr  wParam   //as WPARAM
83976>>>>>>>>>>>>>>>>>>>>>  Longptr  lParam   //as LPARAM
83976>>>>>>>>>>>>>>>>>>>>>  DWord    Time     //as DWord
83976>>>>>>>>>>>>>>>>>>>>>  DWord    ptX      //as DWord
83976>>>>>>>>>>>>>>>>>>>>>  DWord    ptY      //as DWord
83976>>>>>>>>>>>>>>>>>>>>>  DWORD    lPrivate
83976>>>>>>>>>>>>>>>>>>>>>End_Struct
83976>>>>>>>>>>>>>>>>>>>>>
83976>>>>>>>>>>>>>>>>>>>>>External_Function TranslateMessage "TranslateMessage" user32.dll Pointer pMsg Returns Integer
83977>>>>>>>>>>>>>>>>>>>>>External_Function PeekMessage      "PeekMessageA"     user32.dll Pointer pMsg Handle hWnd Integer iMin Integer iMax Integer iRemove Returns Integer
83978>>>>>>>>>>>>>>>>>>>>>External_Function DispatchMessage  "DispatchMessageA" user32.dll Pointer pMsg Returns Integer
83979>>>>>>>>>>>>>>>>>>>>>
83979>>>>>>>>>>>>>>>>>>>>>//
83979>>>>>>>>>>>>>>>>>>>>>// Dispatches the next message in the queue if it is a hotkey
83979>>>>>>>>>>>>>>>>>>>>>// (a key that combined with the alt-keyboard key)
83979>>>>>>>>>>>>>>>>>>>>>//
83979>>>>>>>>>>>>>>>>>>>>>Procedure DispatchHotkey
83982>>>>>>>>>>>>>>>>>>>>>  Integer iPendingMessage
83982>>>>>>>>>>>>>>>>>>>>>  Integer iVoid iTranslated
83982>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83982>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83982>>>>>>>>>>>>>>>>>>>>>
83982>>>>>>>>>>>>>>>>>>>>>  Move 0 To WinMsg.ptX
83983>>>>>>>>>>>>>>>>>>>>>  If (PeekMessage(AddressOf(WinMsg), 0, 0, 0, PM_REMOVE)) Begin
83985>>>>>>>>>>>>>>>>>>>>>    Move WinMsg.message To iPendingMessage
83986>>>>>>>>>>>>>>>>>>>>>    If (iPendingMessage = WM_HOTKEY) Begin
83988>>>>>>>>>>>>>>>>>>>>>      Move (TranslateMessage(AddressOf(WinMsg))) To iTranslated
83989>>>>>>>>>>>>>>>>>>>>>      If (iTranslated) Begin
83991>>>>>>>>>>>>>>>>>>>>>        Move (DispatchMessage(AddressOf(WinMsg)))  To iVoid
83992>>>>>>>>>>>>>>>>>>>>>      End
83992>>>>>>>>>>>>>>>>>>>>>>
83992>>>>>>>>>>>>>>>>>>>>>    End
83992>>>>>>>>>>>>>>>>>>>>>>
83992>>>>>>>>>>>>>>>>>>>>>  End
83992>>>>>>>>>>>>>>>>>>>>>>
83992>>>>>>>>>>>>>>>>>>>>>End_Procedure
83993>>>>>>>>>>>>>>>>>>>>>
83993>>>>>>>>>>>>>>>>>>>>>//
83993>>>>>>>>>>>>>>>>>>>>>// Dispatches ANY key press from the loop, not just one, but all of them
83993>>>>>>>>>>>>>>>>>>>>>//
83993>>>>>>>>>>>>>>>>>>>>>Procedure DispatchAnyKey
83996>>>>>>>>>>>>>>>>>>>>>  Integer iPendingMessage
83996>>>>>>>>>>>>>>>>>>>>>  Integer iVoid iTranslated
83996>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83996>>>>>>>>>>>>>>>>>>>>>  tMSG    WinMsg
83996>>>>>>>>>>>>>>>>>>>>>
83996>>>>>>>>>>>>>>>>>>>>>  Move 0 To WinMsg.ptX
83997>>>>>>>>>>>>>>>>>>>>>  If (PeekMessage(AddressOf(WinMsg), 0, 0, 0, PM_REMOVE)) Begin
83999>>>>>>>>>>>>>>>>>>>>>    Move WinMsg.message To iPendingMessage
84000>>>>>>>>>>>>>>>>>>>>>    If (iPendingMessage = WM_HOTKEY or iPendingMessage = WM_KEYDOWN or iPendingMessage = WM_KEYUP) Begin
84002>>>>>>>>>>>>>>>>>>>>>      Move (TranslateMessage(AddressOf(WinMsg))) To iTranslated
84003>>>>>>>>>>>>>>>>>>>>>      If (iTranslated) Begin
84005>>>>>>>>>>>>>>>>>>>>>        Move (DispatchMessage(AddressOf(WinMsg)))  To iVoid
84006>>>>>>>>>>>>>>>>>>>>>      End
84006>>>>>>>>>>>>>>>>>>>>>>
84006>>>>>>>>>>>>>>>>>>>>>    End
84006>>>>>>>>>>>>>>>>>>>>>>
84006>>>>>>>>>>>>>>>>>>>>>  End
84006>>>>>>>>>>>>>>>>>>>>>>
84006>>>>>>>>>>>>>>>>>>>>>End_Procedure
84007>>>>>>>>>>>>>>>>>>>>>
84007>>>>>>>>>>>>>>>>>>>Use THDialog.pkg
84007>>>>>>>>>>>>>>>>>>>
84007>>>>>>>>>>>>>>>>>>>Object oFindDialog is a ModalPanel
84009>>>>>>>>>>>>>>>>>>>    Set Size to 75 270
84010>>>>>>>>>>>>>>>>>>>    Set Label to "Find"
84011>>>>>>>>>>>>>>>>>>>    Set piMinSize to 75 270
84012>>>>>>>>>>>>>>>>>>>    Set Location to 44 47
84013>>>>>>>>>>>>>>>>>>>    Set Border_Style to Border_Thick
84014>>>>>>>>>>>>>>>>>>>    //Set Locate_Mode to POPUP_LOCATE -- locate mode isn't smart enough
84014>>>>>>>>>>>>>>>>>>>    Property Boolean pbStartFind
84016>>>>>>>>>>>>>>>>>>>    Property Boolean pbMarkAll
84018>>>>>>>>>>>>>>>>>>>
84018>>>>>>>>>>>>>>>>>>>    Set peAnchors to anAll
84019>>>>>>>>>>>>>>>>>>>    Set piMaxSize to 75 8000
84020>>>>>>>>>>>>>>>>>>>
84020>>>>>>>>>>>>>>>>>>>    Object oSearchFm is a cFindComboForm
84022>>>>>>>>>>>>>>>>>>>        Set Size to 13 160
84023>>>>>>>>>>>>>>>>>>>        Set Location to 10 45
84024>>>>>>>>>>>>>>>>>>>        Set Label to "W&hat:"
84025>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
84026>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
84027>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
84028>>>>>>>>>>>>>>>>>>>    End_Object
84029>>>>>>>>>>>>>>>>>>>
84029>>>>>>>>>>>>>>>>>>>    Object oWordMatchCb is a cFindCheckBox
84031>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84032>>>>>>>>>>>>>>>>>>>        Set Location to 26 45
84033>>>>>>>>>>>>>>>>>>>        Set Label to "Match &whole word only"
84034>>>>>>>>>>>>>>>>>>>    End_Object
84035>>>>>>>>>>>>>>>>>>>
84035>>>>>>>>>>>>>>>>>>>    Object oMatchCaseCb is a cFindCheckBox
84037>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84038>>>>>>>>>>>>>>>>>>>        Set Location to 37 45
84039>>>>>>>>>>>>>>>>>>>        Set Label to "Match &case"
84040>>>>>>>>>>>>>>>>>>>    End_Object
84041>>>>>>>>>>>>>>>>>>>
84041>>>>>>>>>>>>>>>>>>>    Object oRegExCb is a cFindCheckBox
84043>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84044>>>>>>>>>>>>>>>>>>>        Set Location to 48 45
84045>>>>>>>>>>>>>>>>>>>        Set Label to "Regular &expression"
84046>>>>>>>>>>>>>>>>>>>    End_Object
84047>>>>>>>>>>>>>>>>>>>
84047>>>>>>>>>>>>>>>>>>>    Object oDocumentStartCb is a cFindCheckBox
84049>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84050>>>>>>>>>>>>>>>>>>>        Set Location to 59 45
84051>>>>>>>>>>>>>>>>>>>        Set Label to "Start at first &line"
84052>>>>>>>>>>>>>>>>>>>    End_Object
84053>>>>>>>>>>>>>>>>>>>
84053>>>>>>>>>>>>>>>>>>>    Object oDirectionGrp is a RadioGroup
84055>>>>>>>>>>>>>>>>>>>        Set Size to 45 65
84056>>>>>>>>>>>>>>>>>>>        Set Location to 24 140
84057>>>>>>>>>>>>>>>>>>>        Set Label to "Direction"
84058>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
84059>>>>>>>>>>>>>>>>>>>
84059>>>>>>>>>>>>>>>>>>>        Object oUpRadio is a Radio
84061>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
84062>>>>>>>>>>>>>>>>>>>            Set Location to 14 10
84063>>>>>>>>>>>>>>>>>>>            Set Label to "&Up"
84064>>>>>>>>>>>>>>>>>>>        End_Object
84065>>>>>>>>>>>>>>>>>>>
84065>>>>>>>>>>>>>>>>>>>        Object oDownRadio is a Radio
84067>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
84068>>>>>>>>>>>>>>>>>>>            Set Location to 26 10
84069>>>>>>>>>>>>>>>>>>>            Set Label to "&Down"
84070>>>>>>>>>>>>>>>>>>>        End_Object
84071>>>>>>>>>>>>>>>>>>>    End_Object
84072>>>>>>>>>>>>>>>>>>>
84072>>>>>>>>>>>>>>>>>>>    Object oFindBtn is a Button
84074>>>>>>>>>>>>>>>>>>>        Set Label to "&Find"
84075>>>>>>>>>>>>>>>>>>>        Set Location to 10 215
84076>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84077>>>>>>>>>>>>>>>>>>>        Set Default_State to True
84078>>>>>>>>>>>>>>>>>>>
84078>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84081>>>>>>>>>>>>>>>>>>>            String sValue
84081>>>>>>>>>>>>>>>>>>>            Get Value of oSearchFm to sValue          // if the user types or changes the search string we should
84082>>>>>>>>>>>>>>>>>>>            Send AddSearchString of oSearchFm sValue  // store it in the array for next time.
84083>>>>>>>>>>>>>>>>>>>            Set pbStartFind to True
84084>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84085>>>>>>>>>>>>>>>>>>>        End_Procedure
84086>>>>>>>>>>>>>>>>>>>    End_Object
84087>>>>>>>>>>>>>>>>>>>
84087>>>>>>>>>>>>>>>>>>>    Object oMarkAllBtn is a Button
84089>>>>>>>>>>>>>>>>>>>        Set Location to 26 215
84090>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84091>>>>>>>>>>>>>>>>>>>        Set Label to "&Mark All"
84092>>>>>>>>>>>>>>>>>>>
84092>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84095>>>>>>>>>>>>>>>>>>>            Set pbStartFind to True
84096>>>>>>>>>>>>>>>>>>>            Set pbMarkAll   to True
84097>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84098>>>>>>>>>>>>>>>>>>>        End_Procedure
84099>>>>>>>>>>>>>>>>>>>    End_Object
84100>>>>>>>>>>>>>>>>>>>
84100>>>>>>>>>>>>>>>>>>>    Object oCancelBtn is a Button
84102>>>>>>>>>>>>>>>>>>>        Set Label    to "Cancel"
84103>>>>>>>>>>>>>>>>>>>        Set Location to 42 215
84104>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84105>>>>>>>>>>>>>>>>>>>
84105>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84108>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84109>>>>>>>>>>>>>>>>>>>        End_Procedure
84110>>>>>>>>>>>>>>>>>>>
84110>>>>>>>>>>>>>>>>>>>    End_Object
84111>>>>>>>>>>>>>>>>>>>
84111>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_H Send Activate  of oSearchFm
84112>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_W Send doToggle  of oWordMatchCb
84113>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_C Send doToggle  of oMatchCaseCb
84114>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_E Send doToggle  of oRegExCb
84115>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_L Send doToggle  of oDocumentStartCb
84116>>>>>>>>>>>>>>>>>>>    //On_Key Key_Alt+Key_U Send Activate  of oUpRadio
84116>>>>>>>>>>>>>>>>>>>    //On_Key Key_Alt+Key_D Send Activate  of oDownRadio
84116>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_F Send KeyAction of oFindBtn
84117>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_M Send KeyAction of oMarkAllBtn
84118>>>>>>>>>>>>>>>>>>>    On_Key kCancel       Send KeyAction of oCancelBtn
84119>>>>>>>>>>>>>>>>>>>
84119>>>>>>>>>>>>>>>>>>>    Procedure SettingsToOptions tFindReplaceOptions ByRef Options
84122>>>>>>>>>>>>>>>>>>>        Get Value         of oSearchFm        to Options.sSearchText
84123>>>>>>>>>>>>>>>>>>>        Move ""                               to Options.sReplaceText
84124>>>>>>>>>>>>>>>>>>>        Get Checked_State of oWordMatchCb     to Options.bWordMatch
84125>>>>>>>>>>>>>>>>>>>        Get Checked_State of oMatchCaseCb     to Options.bMatchCase
84126>>>>>>>>>>>>>>>>>>>        Get Checked_State of oRegExCb         to Options.bRegExp
84127>>>>>>>>>>>>>>>>>>>        Get Checked_State of oDocumentStartCb to Options.bDocumentStart
84128>>>>>>>>>>>>>>>>>>>        Get Current_Radio of oDirectionGrp    to Options.eFindOptions
84129>>>>>>>>>>>>>>>>>>>        Get pbMarkAll                         to Options.bMarkAll
84130>>>>>>>>>>>>>>>>>>>    End_Procedure
84131>>>>>>>>>>>>>>>>>>>
84131>>>>>>>>>>>>>>>>>>>    Procedure RequestDetails tFindReplaceOptions ByRef Options
84134>>>>>>>>>>>>>>>>>>>        Boolean bStartFind
84134>>>>>>>>>>>>>>>>>>>
84134>>>>>>>>>>>>>>>>>>>        Set pbStartFind to False
84135>>>>>>>>>>>>>>>>>>>        Set pbMarkAll   to False
84136>>>>>>>>>>>>>>>>>>>        Set SearchValue   of oSearchFm        to Options.sSearchText
84137>>>>>>>>>>>>>>>>>>>        Set Checked_State of oWordMatchCb     to Options.bWordMatch
84138>>>>>>>>>>>>>>>>>>>        Set Checked_State of oMatchCaseCb     to Options.bMatchCase
84139>>>>>>>>>>>>>>>>>>>        Set Checked_State of oRegExCb         to Options.bRegExp
84140>>>>>>>>>>>>>>>>>>>        Set Checked_State of oDocumentStartCb to Options.bDocumentStart
84141>>>>>>>>>>>>>>>>>>>        Set Current_Radio of oDirectionGrp    to Options.eFindOptions
84142>>>>>>>>>>>>>>>>>>>        Send Popup
84143>>>>>>>>>>>>>>>>>>>        Send SettingsToOptions (&Options)
84144>>>>>>>>>>>>>>>>>>>        Get pbStartFind to bStartFind
84145>>>>>>>>>>>>>>>>>>>        If (bStartFind) Begin
84147>>>>>>>>>>>>>>>>>>>            Move True to Options.bStartFind
84148>>>>>>>>>>>>>>>>>>>        End
84148>>>>>>>>>>>>>>>>>>>>
84148>>>>>>>>>>>>>>>>>>>    End_Procedure
84149>>>>>>>>>>>>>>>>>>>
84149>>>>>>>>>>>>>>>>>>>
84149>>>>>>>>>>>>>>>>>>>    Procedure Activating
84152>>>>>>>>>>>>>>>>>>>        Forward Send Activating
84154>>>>>>>>>>>>>>>>>>>    End_Procedure
84155>>>>>>>>>>>>>>>>>>>
84155>>>>>>>>>>>>>>>>>>>End_Object
84156>>>>>>>>>>>>>>>>>>>
84156>>>>>>>>>>>>>>>>>Use Tools\Replace.dg
Including file: Tools\Replace.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\Tools\Replace.dg)
84156>>>>>>>>>>>>>>>>>>>Use Windows.pkg
84156>>>>>>>>>>>>>>>>>>>Use MessageQueueHelpers.pkg
84156>>>>>>>>>>>>>>>>>>>Use THDialog.pkg
84156>>>>>>>>>>>>>>>>>>>
84156>>>>>>>>>>>>>>>>>>>Object oReplaceDialog is a ModalPanel
84158>>>>>>>>>>>>>>>>>>>    Set Label to "Find & Replace"
84159>>>>>>>>>>>>>>>>>>>    Set Size to 98 300
84160>>>>>>>>>>>>>>>>>>>    Set piMinSize to 95 300
84161>>>>>>>>>>>>>>>>>>>    Set Location to 44 47
84162>>>>>>>>>>>>>>>>>>>    Set Border_Style to Border_Thick
84163>>>>>>>>>>>>>>>>>>>    //Set Locate_Mode to POPUP_LOCATE -- locate mode isn't smart enough
84163>>>>>>>>>>>>>>>>>>>    Property Boolean pbReplaceAll
84165>>>>>>>>>>>>>>>>>>>    Property Boolean pbFindFirst
84167>>>>>>>>>>>>>>>>>>>    Property Handle  phoInvokingObject
84169>>>>>>>>>>>>>>>>>>>
84169>>>>>>>>>>>>>>>>>>>    Set peAnchors to anAll
84170>>>>>>>>>>>>>>>>>>>    Set piMaxSize to 100 8000
84171>>>>>>>>>>>>>>>>>>>
84171>>>>>>>>>>>>>>>>>>>    Object oFindFm is a cFindComboForm
84173>>>>>>>>>>>>>>>>>>>        Set Size to 13 185
84174>>>>>>>>>>>>>>>>>>>        Set Location to 10 55
84175>>>>>>>>>>>>>>>>>>>        Set Label to "&Find:"
84176>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
84177>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
84178>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
84179>>>>>>>>>>>>>>>>>>>    End_Object
84180>>>>>>>>>>>>>>>>>>>
84180>>>>>>>>>>>>>>>>>>>    Object oReplaceFm is a cFindComboForm
84182>>>>>>>>>>>>>>>>>>>        Set Size to 13 185
84183>>>>>>>>>>>>>>>>>>>        Set Location to 26 55
84184>>>>>>>>>>>>>>>>>>>        Set Label to "Re&place with:"
84185>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
84186>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
84187>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
84188>>>>>>>>>>>>>>>>>>>    End_Object
84189>>>>>>>>>>>>>>>>>>>
84189>>>>>>>>>>>>>>>>>>>    Object oWordMatchCb is a cFindCheckBox
84191>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84192>>>>>>>>>>>>>>>>>>>        Set Location to 46 55
84193>>>>>>>>>>>>>>>>>>>        Set Label to "Match &whole word only"
84194>>>>>>>>>>>>>>>>>>>    End_Object
84195>>>>>>>>>>>>>>>>>>>
84195>>>>>>>>>>>>>>>>>>>    Object oMatchCaseCb is a cFindCheckBox
84197>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84198>>>>>>>>>>>>>>>>>>>        Set Location to 57 55
84199>>>>>>>>>>>>>>>>>>>        Set Label to "Match &case"
84200>>>>>>>>>>>>>>>>>>>    End_Object
84201>>>>>>>>>>>>>>>>>>>
84201>>>>>>>>>>>>>>>>>>>    Object oRegExCb is a cFindCheckBox
84203>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84204>>>>>>>>>>>>>>>>>>>        Set Location to 68 55
84205>>>>>>>>>>>>>>>>>>>        Set Label to "Regular &expression"
84206>>>>>>>>>>>>>>>>>>>    End_Object
84207>>>>>>>>>>>>>>>>>>>
84207>>>>>>>>>>>>>>>>>>>    Object oCaseCb is a cFindCheckBox
84209>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84210>>>>>>>>>>>>>>>>>>>        Set Location to 79 55
84211>>>>>>>>>>>>>>>>>>>        Set Label to "Preser&ve case"
84212>>>>>>>>>>>>>>>>>>>    End_Object
84213>>>>>>>>>>>>>>>>>>>
84213>>>>>>>>>>>>>>>>>>>    Object oDocumentStartCb is a cFindCheckBox
84215>>>>>>>>>>>>>>>>>>>        Set Size to 10 50
84216>>>>>>>>>>>>>>>>>>>        Set Location to 80 55
84217>>>>>>>>>>>>>>>>>>>        Set Label to "Start at first &line"
84218>>>>>>>>>>>>>>>>>>>    End_Object
84219>>>>>>>>>>>>>>>>>>>
84219>>>>>>>>>>>>>>>>>>>    Object oReplaceGrp is a RadioGroup
84221>>>>>>>>>>>>>>>>>>>        Set Size to 42 85
84222>>>>>>>>>>>>>>>>>>>        Set Location to 46 155
84223>>>>>>>>>>>>>>>>>>>        Set Label to "Replace in"
84224>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopLeftRight
84225>>>>>>>>>>>>>>>>>>>
84225>>>>>>>>>>>>>>>>>>>        Object oRplSelection is a Radio
84227>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
84228>>>>>>>>>>>>>>>>>>>            Set Location to 14 10
84229>>>>>>>>>>>>>>>>>>>            Set Label to "&Selection"
84230>>>>>>>>>>>>>>>>>>>        End_Object
84231>>>>>>>>>>>>>>>>>>>
84231>>>>>>>>>>>>>>>>>>>        Object oRplBuffer is a Radio
84233>>>>>>>>>>>>>>>>>>>            Set Size to 10 50
84234>>>>>>>>>>>>>>>>>>>            Set Location to 26 10
84235>>>>>>>>>>>>>>>>>>>            Set Label to "Entire &Buffer"
84236>>>>>>>>>>>>>>>>>>>        End_Object
84237>>>>>>>>>>>>>>>>>>>    End_Object
84238>>>>>>>>>>>>>>>>>>>
84238>>>>>>>>>>>>>>>>>>>    Object oFindBtn is a Button
84240>>>>>>>>>>>>>>>>>>>        Set Label to "Find &Next"
84241>>>>>>>>>>>>>>>>>>>        Set Location to 10 245
84242>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84243>>>>>>>>>>>>>>>>>>>        Set Default_State to True
84244>>>>>>>>>>>>>>>>>>>
84244>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84247>>>>>>>>>>>>>>>>>>>            Handle  hoInvokingObject
84247>>>>>>>>>>>>>>>>>>>            Integer iFlags
84247>>>>>>>>>>>>>>>>>>>            String  sSearchText
84247>>>>>>>>>>>>>>>>>>>            tFindReplaceOptions ReplaceOptions
84247>>>>>>>>>>>>>>>>>>>            tFindReplaceOptions ReplaceOptions
84247>>>>>>>>>>>>>>>>>>>
84247>>>>>>>>>>>>>>>>>>>            Get phoInvokingObject to hoInvokingObject
84248>>>>>>>>>>>>>>>>>>>            If hoInvokingObject Begin
84250>>>>>>>>>>>>>>>>>>>                Send SettingsToOptions (&ReplaceOptions)
84251>>>>>>>>>>>>>>>>>>>                Get SetSearchOptions of hoInvokingObject ReplaceOptions to iFlags
84252>>>>>>>>>>>>>>>>>>>                Get Value of oFindFm to sSearchText
84253>>>>>>>>>>>>>>>>>>>                Send AddSearchString of oFindFm sSearchText  // make sure the search value is saved in the array
84254>>>>>>>>>>>>>>>>>>>                Set psSearchText of hoInvokingObject to sSearchText
84255>>>>>>>>>>>>>>>>>>>                If (ReplaceOptions.bDocumentStart=True and pbFindFirst(Self)=false) Begin
84257>>>>>>>>>>>>>>>>>>>                    Set pbFindFirst to True
84258>>>>>>>>>>>>>>>>>>>                    Send FindFirst to hoInvokingObject
84259>>>>>>>>>>>>>>>>>>>                End
84259>>>>>>>>>>>>>>>>>>>>
84259>>>>>>>>>>>>>>>>>>>                Else Begin
84260>>>>>>>>>>>>>>>>>>>                    Send FindNext to hoInvokingObject
84261>>>>>>>>>>>>>>>>>>>                End
84261>>>>>>>>>>>>>>>>>>>>
84261>>>>>>>>>>>>>>>>>>>            End
84261>>>>>>>>>>>>>>>>>>>>
84261>>>>>>>>>>>>>>>>>>>        End_Procedure
84262>>>>>>>>>>>>>>>>>>>    End_Object
84263>>>>>>>>>>>>>>>>>>>
84263>>>>>>>>>>>>>>>>>>>    Object oReplaceBtn is a Button
84265>>>>>>>>>>>>>>>>>>>        Set Location to 26 245
84266>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84267>>>>>>>>>>>>>>>>>>>        Set Label to "&Replace"
84268>>>>>>>>>>>>>>>>>>>
84268>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84271>>>>>>>>>>>>>>>>>>>            Handle hoInvokingObject
84271>>>>>>>>>>>>>>>>>>>            String sSearchText
84271>>>>>>>>>>>>>>>>>>>            String sReplaceWith
84271>>>>>>>>>>>>>>>>>>>            Get phoInvokingObject to hoInvokingObject
84272>>>>>>>>>>>>>>>>>>>            If hoInvokingObject Begin
84274>>>>>>>>>>>>>>>>>>>                Get Value of oFindFm to sSearchText
84275>>>>>>>>>>>>>>>>>>>                Get Value of oReplaceFm to sReplaceWith
84276>>>>>>>>>>>>>>>>>>>                Send AddSearchString of oReplaceFm sReplaceWith // save the replace string in the array for later use if wanted
84277>>>>>>>>>>>>>>>>>>>                Set psSearchText of hoInvokingObject to sSearchText
84278>>>>>>>>>>>>>>>>>>>                Send ReplaceText of hoInvokingObject sReplaceWith
84279>>>>>>>>>>>>>>>>>>>                Send FindNext to hoInvokingObject
84280>>>>>>>>>>>>>>>>>>>            End
84280>>>>>>>>>>>>>>>>>>>>
84280>>>>>>>>>>>>>>>>>>>        End_Procedure
84281>>>>>>>>>>>>>>>>>>>    End_Object
84282>>>>>>>>>>>>>>>>>>>
84282>>>>>>>>>>>>>>>>>>>    Object oReplaceAllBtn is a Button
84284>>>>>>>>>>>>>>>>>>>        Set Location to 42 245
84285>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84286>>>>>>>>>>>>>>>>>>>        Set Label to "Replace &All"
84287>>>>>>>>>>>>>>>>>>>
84287>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84290>>>>>>>>>>>>>>>>>>>            Set pbReplaceAll to True
84291>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84292>>>>>>>>>>>>>>>>>>>        End_Procedure
84293>>>>>>>>>>>>>>>>>>>    End_Object
84294>>>>>>>>>>>>>>>>>>>
84294>>>>>>>>>>>>>>>>>>>    Object oCancelBtn is a Button
84296>>>>>>>>>>>>>>>>>>>        Set Label to "&Cancel"
84297>>>>>>>>>>>>>>>>>>>        Set Location to 58 245
84298>>>>>>>>>>>>>>>>>>>        Set peAnchors to anTopRight
84299>>>>>>>>>>>>>>>>>>>
84299>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84302>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84303>>>>>>>>>>>>>>>>>>>        End_Procedure
84304>>>>>>>>>>>>>>>>>>>
84304>>>>>>>>>>>>>>>>>>>    End_Object
84305>>>>>>>>>>>>>>>>>>>
84305>>>>>>>>>>>>>>>>>>>    Procedure doFind
84308>>>>>>>>>>>>>>>>>>>        Send DispatchHotkey
84309>>>>>>>>>>>>>>>>>>>        Send KeyAction of oFindBtn
84310>>>>>>>>>>>>>>>>>>>    End_Procedure
84311>>>>>>>>>>>>>>>>>>>
84311>>>>>>>>>>>>>>>>>>>    Procedure doReplace
84314>>>>>>>>>>>>>>>>>>>        Send DispatchHotkey
84315>>>>>>>>>>>>>>>>>>>        Send KeyAction of oReplaceBtn
84316>>>>>>>>>>>>>>>>>>>    End_Procedure
84317>>>>>>>>>>>>>>>>>>>
84317>>>>>>>>>>>>>>>>>>>    Procedure doReplaceAll
84320>>>>>>>>>>>>>>>>>>>        Send DispatchHotkey
84321>>>>>>>>>>>>>>>>>>>        Send KeyAction of oReplaceAllBtn
84322>>>>>>>>>>>>>>>>>>>    End_Procedure
84323>>>>>>>>>>>>>>>>>>>
84323>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_F Send Activate  of oFindFm
84324>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_P Send Activate  of oReplaceFm
84325>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_W Send doToggle  of oWordMatchCb
84326>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_C Send doToggle  of oMatchCaseCb
84327>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_E Send doToggle  of oRegExCb
84328>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_L Send doToggle  of oDocumentStartCb
84329>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_N Send doFind
84330>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_R Send doReplace
84331>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_A Send doReplaceAll
84332>>>>>>>>>>>>>>>>>>>    On_Key kCancel       Send KeyAction of oCancelBtn
84333>>>>>>>>>>>>>>>>>>>
84333>>>>>>>>>>>>>>>>>>>    Procedure SettingsToOptions tFindReplaceOptions ByRef Options
84336>>>>>>>>>>>>>>>>>>>        Get Value           of oFindFm          to Options.sSearchText
84337>>>>>>>>>>>>>>>>>>>        Get Value           of oReplaceFm       to Options.sReplaceText
84338>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oWordMatchCb     to Options.bWordMatch
84339>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oMatchCaseCb     to Options.bMatchCase
84340>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oRegExCb         to Options.bRegExp
84341>>>>>>>>>>>>>>>>>>>        Get Checked_State   of oDocumentStartCb to Options.bDocumentStart
84342>>>>>>>>>>>>>>>>>>>        Get Current_Radio   of oReplaceGrp      to Options.eFindOptions
84343>>>>>>>>>>>>>>>>>>>        Move False                              to Options.bMarkAll
84344>>>>>>>>>>>>>>>>>>>    End_Procedure
84345>>>>>>>>>>>>>>>>>>>
84345>>>>>>>>>>>>>>>>>>>    Procedure RequestDetails tFindReplaceOptions ByRef Options Handle hoInvokingObject
84348>>>>>>>>>>>>>>>>>>>        Boolean bReplaceAll
84348>>>>>>>>>>>>>>>>>>>        If (hoInvokingObject=0) Begin
84350>>>>>>>>>>>>>>>>>>>            Procedure_Return
84351>>>>>>>>>>>>>>>>>>>        End
84351>>>>>>>>>>>>>>>>>>>>
84351>>>>>>>>>>>>>>>>>>>        Set phoInvokingObject                   to hoInvokingObject
84352>>>>>>>>>>>>>>>>>>>        //
84352>>>>>>>>>>>>>>>>>>>        Set pbReplaceAll                        to False
84353>>>>>>>>>>>>>>>>>>>        Set pbFindFirst                         to False
84354>>>>>>>>>>>>>>>>>>>        Move False                              to Options.bReplaceAll
84355>>>>>>>>>>>>>>>>>>>        Set SearchValue     of oFindFm          to Options.sSearchText
84356>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oWordMatchCb     to Options.bWordMatch
84357>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oMatchCaseCb     to Options.bMatchCase
84358>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oRegExCb         to Options.bRegExp
84359>>>>>>>>>>>>>>>>>>>        Set Checked_State   of oDocumentStartCb to Options.bDocumentStart
84360>>>>>>>>>>>>>>>>>>>        Send Popup
84361>>>>>>>>>>>>>>>>>>>        Send SettingsToOptions (&Options)
84362>>>>>>>>>>>>>>>>>>>        Get pbReplaceAll to bReplaceAll
84363>>>>>>>>>>>>>>>>>>>        If (bReplaceAll) Begin
84365>>>>>>>>>>>>>>>>>>>            Move True                             to Options.bReplaceAll
84366>>>>>>>>>>>>>>>>>>>        End
84366>>>>>>>>>>>>>>>>>>>>
84366>>>>>>>>>>>>>>>>>>>    End_Procedure
84367>>>>>>>>>>>>>>>>>>>
84367>>>>>>>>>>>>>>>>>>>
84367>>>>>>>>>>>>>>>>>>>    Procedure Activating
84370>>>>>>>>>>>>>>>>>>>        Forward Send Activating
84372>>>>>>>>>>>>>>>>>>>    End_Procedure
84373>>>>>>>>>>>>>>>>>>>
84373>>>>>>>>>>>>>>>>>>>End_Object
84374>>>>>>>>>>>>>>>>>>>
84374>>>>>>>>>>>>>>>>>Use Tools\Goto.dg
Including file: Tools\Goto.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\Tools\Goto.dg)
84374>>>>>>>>>>>>>>>>>>>Use Windows.pkg
84374>>>>>>>>>>>>>>>>>>>Use MessageQueueHelpers.pkg
84374>>>>>>>>>>>>>>>>>>>Use THDialog.pkg
84374>>>>>>>>>>>>>>>>>>>
84374>>>>>>>>>>>>>>>>>>>Object oGotoDialog is a ModalPanel
84376>>>>>>>>>>>>>>>>>>>    Set Size to 50 138
84377>>>>>>>>>>>>>>>>>>>    Set Label to "Go To Line"
84378>>>>>>>>>>>>>>>>>>>    Set piMinSize to 50 138
84379>>>>>>>>>>>>>>>>>>>    Set Location to 44 47
84380>>>>>>>>>>>>>>>>>>>    //Set Locate_Mode to POPUP_LOCATE -- locate mode isn't smart enough
84380>>>>>>>>>>>>>>>>>>>    Property Boolean pbCancel
84382>>>>>>>>>>>>>>>>>>>
84382>>>>>>>>>>>>>>>>>>>    Set peAnchors to anAll
84383>>>>>>>>>>>>>>>>>>>    Set piMaxSize to 50 138
84384>>>>>>>>>>>>>>>>>>>    Set Border_Style to Border_Thick
84385>>>>>>>>>>>>>>>>>>>
84385>>>>>>>>>>>>>>>>>>>    Object oLineFm is a cFindForm
84387>>>>>>>>>>>>>>>>>>>        Set Size to 13 30
84388>>>>>>>>>>>>>>>>>>>        Set Location to 10 43
84389>>>>>>>>>>>>>>>>>>>        Set Label to "&Line:"
84390>>>>>>>>>>>>>>>>>>>        Set Label_Col_Offset to 2
84391>>>>>>>>>>>>>>>>>>>        Set Label_Justification_Mode to JMode_Right
84392>>>>>>>>>>>>>>>>>>>        Set Form_Justification_Mode to Form_EditRight
84393>>>>>>>>>>>>>>>>>>>    End_Object
84394>>>>>>>>>>>>>>>>>>>
84394>>>>>>>>>>>>>>>>>>>    Object oOKBtn is a Button
84396>>>>>>>>>>>>>>>>>>>        Set Label to "&OK"
84397>>>>>>>>>>>>>>>>>>>        Set Location to 10 80
84398>>>>>>>>>>>>>>>>>>>        Set Default_State to True
84399>>>>>>>>>>>>>>>>>>>
84399>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84402>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84403>>>>>>>>>>>>>>>>>>>        End_Procedure
84404>>>>>>>>>>>>>>>>>>>    End_Object
84405>>>>>>>>>>>>>>>>>>>
84405>>>>>>>>>>>>>>>>>>>    Object oCancelBtn is a Button
84407>>>>>>>>>>>>>>>>>>>        Set Label    to "Cancel"
84408>>>>>>>>>>>>>>>>>>>        Set Location to 26 80
84409>>>>>>>>>>>>>>>>>>>
84409>>>>>>>>>>>>>>>>>>>        Procedure OnClick
84412>>>>>>>>>>>>>>>>>>>            Set pbCancel to True
84413>>>>>>>>>>>>>>>>>>>            Send Close_Panel
84414>>>>>>>>>>>>>>>>>>>        End_Procedure
84415>>>>>>>>>>>>>>>>>>>
84415>>>>>>>>>>>>>>>>>>>    End_Object
84416>>>>>>>>>>>>>>>>>>>
84416>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_L Send Activate  of oLineFm
84417>>>>>>>>>>>>>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOKBtn
84418>>>>>>>>>>>>>>>>>>>    On_Key kCancel       Send KeyAction of oCancelBtn
84419>>>>>>>>>>>>>>>>>>>
84419>>>>>>>>>>>>>>>>>>>    Procedure RequestDetails Integer ByRef iLine
84422>>>>>>>>>>>>>>>>>>>        Boolean bCancel
84422>>>>>>>>>>>>>>>>>>>        Set pbCancel    to False
84423>>>>>>>>>>>>>>>>>>>        Set Value       of oLineFm  to ""
84424>>>>>>>>>>>>>>>>>>>        Send Popup
84425>>>>>>>>>>>>>>>>>>>        Get pbCancel to bCancel
84426>>>>>>>>>>>>>>>>>>>        If (not(bCancel)) Begin
84428>>>>>>>>>>>>>>>>>>>            Get Value   of oLineFm  to iLine
84429>>>>>>>>>>>>>>>>>>>            Decrement iLine
84430>>>>>>>>>>>>>>>>>>>            If (iLine<0) Begin
84432>>>>>>>>>>>>>>>>>>>                Move 0 to iLine
84433>>>>>>>>>>>>>>>>>>>            End
84433>>>>>>>>>>>>>>>>>>>>
84433>>>>>>>>>>>>>>>>>>>        End
84433>>>>>>>>>>>>>>>>>>>>
84433>>>>>>>>>>>>>>>>>>>        Else Begin
84434>>>>>>>>>>>>>>>>>>>            Move -1 to iLine
84435>>>>>>>>>>>>>>>>>>>        End
84435>>>>>>>>>>>>>>>>>>>>
84435>>>>>>>>>>>>>>>>>>>    End_Procedure
84436>>>>>>>>>>>>>>>>>>>
84436>>>>>>>>>>>>>>>>>>>
84436>>>>>>>>>>>>>>>>>>>    Procedure Activating
84439>>>>>>>>>>>>>>>>>>>        Forward Send Activating
84441>>>>>>>>>>>>>>>>>>>    End_Procedure
84442>>>>>>>>>>>>>>>>>>>
84442>>>>>>>>>>>>>>>>>>>End_Object
84443>>>>>>>>>>>>>>>>>>>
84443>>>>>>>>>>>>>>>>>
84443>>>>>>>>>>>>>>>>>Define SCIMAGE_DLL For SCIMAGE32.DLL
84443>>>>>>>>>>>>>>>>>
84443>>>>>>>>>>>>>>>>>//
84443>>>>>>>>>>>>>>>>>//function specific for scintilla, create xpm icons
84443>>>>>>>>>>>>>>>>>//
84443>>>>>>>>>>>>>>>>>External_Function SciEditorIconXpm      "SciEditorIconXpm"      SCIMAGE_DLL Integer iIcon Returns Pointer
84444>>>>>>>>>>>>>>>>>External_Function SciLoadImageAsRGBA    "SciLoadImageAsRGBA"    SCIMAGE_DLL Pointer pFileName Pointer pImage Pointer pWidth Pointer pHeight Returns integer
84445>>>>>>>>>>>>>>>>>External_Function SciFreeRGBAImage      "SciFreeRGBAImage"      SCIMAGE_DLL Pointer pImage Returns integer
84446>>>>>>>>>>>>>>>>>
84446>>>>>>>>>>>>>>>>>
84446>>>>>>>>>>>>>>>>>
84446>>>>>>>>>>>>>>>>>Class cSciLexer is a DFControl // cUIObject  cObject
84447>>>>>>>>>>>>>>>>>
84447>>>>>>>>>>>>>>>>>  Import_Class_Protocol cSciLexerLanguageMixin
84448>>>>>>>>>>>>>>>>>
84448>>>>>>>>>>>>>>>>>  Register_Procedure OnWmSetFocus
84448>>>>>>>>>>>>>>>>>  Register_Procedure OnWmKillFocus
84448>>>>>>>>>>>>>>>>>  Register_Procedure OnWmPaint
84448>>>>>>>>>>>>>>>>>  Register_Procedure DoKeyReturn
84448>>>>>>>>>>>>>>>>>  Register_Procedure DoFileDropping
84448>>>>>>>>>>>>>>>>>  Register_Procedure onWmContextMenu
84448>>>>>>>>>>>>>>>>>
84448>>>>>>>>>>>>>>>>>
84448>>>>>>>>>>>>>>>>>
84448>>>>>>>>>>>>>>>>>  Procedure Construct_Object
84450>>>>>>>>>>>>>>>>>    // the scintilla DLL to load is in the programs folder, preload it
84450>>>>>>>>>>>>>>>>>    Set psDllLoadPath of oDllHandler to (psProgramPath(phoWorkspace(ghoApplication)))
84451>>>>>>>>>>>>>>>>>    Send doLoadLibrary Of oDllHandler "SciLexer32.dll"
84452>>>>>>>>>>>>>>>>>
84452>>>>>>>>>>>>>>>>>    Forward Send Construct_Object
84454>>>>>>>>>>>>>>>>>    Set External_Class_Name "cScintillaEditor"  to CODEMAXWNDCLASS
84455>>>>>>>>>>>>>>>>>    Set External_Message WM_SETFOCUS            to msg_OnWmSetFocus
84456>>>>>>>>>>>>>>>>>    Set External_Message WM_KILLFOCUS           to msg_OnWmKillFocus
84457>>>>>>>>>>>>>>>>>    Set External_Message WM_PAINT               to msg_OnWmPaint
84458>>>>>>>>>>>>>>>>>    Set External_Message WM_DROPFILES           to msg_DoFileDropping
84459>>>>>>>>>>>>>>>>>    Set External_Message WM_RBUTTONUP           to msg_onWmContextMenu
84460>>>>>>>>>>>>>>>>>    //Set External_Message WM_KEYDOWN             to msg_onWmKeyDown  <<-- does not work
84460>>>>>>>>>>>>>>>>>
84460>>>>>>>>>>>>>>>>>
84460>>>>>>>>>>>>>>>>>
84460>>>>>>>>>>>>>>>>>    //
84460>>>>>>>>>>>>>>>>>    // Put any NEW properties HERE
84460>>>>>>>>>>>>>>>>>    Property String  psFileName              ""
84461>>>>>>>>>>>>>>>>>    Property Number  pnFileTimeStamp         0
84462>>>>>>>>>>>>>>>>>
84462>>>>>>>>>>>>>>>>>
84462>>>>>>>>>>>>>>>>>    // These Properties are filled by CM_GetSel
84462>>>>>>>>>>>>>>>>>    Property Integer piSelStartLine          0
84463>>>>>>>>>>>>>>>>>    Property Integer piSelStartCol           0
84464>>>>>>>>>>>>>>>>>    Property Integer piSelEndLine            0
84465>>>>>>>>>>>>>>>>>    Property Integer piSelEndCol             0
84466>>>>>>>>>>>>>>>>>
84466>>>>>>>>>>>>>>>>>    // Used to insert a self defined popup menu.
84466>>>>>>>>>>>>>>>>>    Property Integer Floating_Menu_Object    0
84467>>>>>>>>>>>>>>>>>
84467>>>>>>>>>>>>>>>>>    // These colors are stored in separate properties for easy access.
84467>>>>>>>>>>>>>>>>>    Property Integer piWindowColor                           0  // Set during CM_GetColor / CM_SetColor
84468>>>>>>>>>>>>>>>>>    Property Integer piTextColor                                     0  // ...
84469>>>>>>>>>>>>>>>>>
84469>>>>>>>>>>>>>>>>>    Property Integer peAutoIndentMode        CM_INDENT_PREVLINE
84470>>>>>>>>>>>>>>>>>    Property Boolean pbShowMatchingBraces    True
84471>>>>>>>>>>>>>>>>>    Property Boolean pbBraceHighLightState   False   // keeps track of brace highlight state so we can turn it off just one time instead of on each navigational action
84472>>>>>>>>>>>>>>>>>    Property String  psEOLChar               CS_CRLF // default End Of Line character to use
84473>>>>>>>>>>>>>>>>>    Property Handle  phMarkerLineHighLight   0       // scintilla marker handle that keeps track of the highlighted line
84474>>>>>>>>>>>>>>>>>    Property String  piMarginLineNumberDigits 3      // character width of the line number margin (counts the digits)
84475>>>>>>>>>>>>>>>>>    Property String[] psClearKeyBindings             // array that holds keyboard shortcut's that have to be cleared
84476>>>>>>>>>>>>>>>>>    Property String  psSearchText            ""      // text to use in a search
84477>>>>>>>>>>>>>>>>>    Property Boolean pbFindDocumentStart     False   // start search from begin of document, this property remembers the state of the checkbox
84478>>>>>>>>>>>>>>>>>    Property String  psLineOnEnter           ""      // content of the line when the cursor enters it (for line_changed_tracking)
84479>>>>>>>>>>>>>>>>>    //
84479>>>>>>>>>>>>>>>>>    //
84479>>>>>>>>>>>>>>>>>    // These properties used with CodeTip (SVN)
84479>>>>>>>>>>>>>>>>>    Property Integer phoCodeTipHandler           0
84480>>>>>>>>>>>>>>>>>    Property Integer pbCodetipRequest           False
84481>>>>>>>>>>>>>>>>>    Property Boolean pbQuickInfo                True // QuickInfo, tooltips that have info about your source structure
84482>>>>>>>>>>>>>>>>>    Property Integer piQuickInfoTime            1000 // default dwell time of the mouse before quickinfo triggers
84483>>>>>>>>>>>>>>>>>    Property Integer piCodeTipStyle              0   // not used for scintilla
84484>>>>>>>>>>>>>>>>>    Property Integer piCodeTipHighlightedStart  -1   // not used in scintilla, we set it directly
84485>>>>>>>>>>>>>>>>>    Property Integer piCodeTipHighlightedEnd    -1   // not used in scintilla, we set it directly
84486>>>>>>>>>>>>>>>>>    Property Integer piCodeTipArgument          -1   // denotes the current argument number that we are editing
84487>>>>>>>>>>>>>>>>>    Property Integer piCodeTipCurrLine          -1
84488>>>>>>>>>>>>>>>>>    Property String  psCodeTipCurrent           ""   // contains the actual tip string to display
84489>>>>>>>>>>>>>>>>>    Property Integer piCodeTipType              C_TIPTYPE_UNDEFINED
84490>>>>>>>>>>>>>>>>>    Property Boolean pbHadTipBeforeAutocomplete False// if codetip before autocomplete then please restore tip after the autocomplete is from the screen
84491>>>>>>>>>>>>>>>>>
84491>>>>>>>>>>>>>>>>>    Property Boolean pbIsCodelistActive         False
84492>>>>>>>>>>>>>>>>>
84492>>>>>>>>>>>>>>>>>    Property Boolean pbFileLoading              False // Set to true while loading file (for ex. in CM_Openfile)
84493>>>>>>>>>>>>>>>>>    Property Boolean pbBlockSelectActive        False // Set to true when in block select mode
84494>>>>>>>>>>>>>>>>>    Property Integer piBlockSelectAnchorPos     0
84495>>>>>>>>>>>>>>>>>    Property Integer piBlockSelectCaretPos      0
84496>>>>>>>>>>>>>>>>>    Property Boolean pbBlockSelectBackspace     False // Bug fix, backspace in a block select drops the block select state even while still visible
84497>>>>>>>>>>>>>>>>>    Property Boolean pbNormalizeCase            True  // Adjust scope/key word text case on enter
84498>>>>>>>>>>>>>>>>>    Property Integer piLinesToScrollAfterGoto   5     // Number of lines to scroll after you locate a line with a goto line
84499>>>>>>>>>>>>>>>>>    Property Integer piUndoRedoStartLine        0     // If an undo/redo actions starts, after the operation is done, we might be at a different line
84500>>>>>>>>>>>>>>>>>
84500>>>>>>>>>>>>>>>>>
84500>>>>>>>>>>>>>>>>>    // ****************************************************************************
84500>>>>>>>>>>>>>>>>>    // properties below are from old codemax, the might be removed if not needed or
84500>>>>>>>>>>>>>>>>>    // moved up if they can stay.
84500>>>>>>>>>>>>>>>>>    //
84500>>>>>>>>>>>>>>>>>    Property Integer phoIniHandler         Self
84501>>>>>>>>>>>>>>>>>
84501>>>>>>>>>>>>>>>>>    Property Integer piDragAcceptFilesState        True
84502>>>>>>>>>>>>>>>>>
84502>>>>>>>>>>>>>>>>>    // These Properties are filled by CM_PosFromChar.
84502>>>>>>>>>>>>>>>>>    Property Integer piPosStartX           0
84503>>>>>>>>>>>>>>>>>    Property Integer piPosStartY           0
84504>>>>>>>>>>>>>>>>>    Property Integer piPosEndX             0
84505>>>>>>>>>>>>>>>>>    Property Integer piPosEndY             0
84506>>>>>>>>>>>>>>>>>    // Thes Properties are filled by FillCurrentPosition
84506>>>>>>>>>>>>>>>>>    Property Integer piAbsPosXStart        0
84507>>>>>>>>>>>>>>>>>    Property Integer piAbsPosYStart        0
84508>>>>>>>>>>>>>>>>>    Property Integer piAbsPosXEnd          0
84509>>>>>>>>>>>>>>>>>    Property Integer piAbsPosYEnd          0
84510>>>>>>>>>>>>>>>>>    // Is used to do some actions when the find is done.
84510>>>>>>>>>>>>>>>>>    Property Integer piFindWrapMode        FindWrapMode_NoWrapMsg
84511>>>>>>>>>>>>>>>>>    // Is ised to Block keys.
84511>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysNo                   (Repeat("0",255))
84512>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysAlt                  (Repeat("0",255))
84513>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysShift                (Repeat("0",255))
84514>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysCtrl                 (Repeat("0",255))
84515>>>>>>>>>>>>>>>>>    // Is used to Block keys but only once.
84515>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysNoOnce               (Repeat("0",255))
84516>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysAltOnce              (Repeat("0",255))
84517>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysShiftOnce            (Repeat("0",255))
84518>>>>>>>>>>>>>>>>>    Property String  psBlockedKeysCtrlOnce             (Repeat("0",255))
84519>>>>>>>>>>>>>>>>>    // Used with CMM_GetAllBookMarks.
84519>>>>>>>>>>>>>>>>>    Property Integer piBookMarkCnt         0
84520>>>>>>>>>>>>>>>>>    // To use with Absolute_GUIOrigin -> Overwrite it to force SelectionLists
84520>>>>>>>>>>>>>>>>>    // to popup relative to the cursor position.
84520>>>>>>>>>>>>>>>>>    Property Integer piDontOverwriteGUIOrigin          False
84521>>>>>>>>>>>>>>>>>    Property Integer piGUIOriginOffsetY                0
84522>>>>>>>>>>>>>>>>>    Property Integer piGUIOriginOffsetX                0
84523>>>>>>>>>>>>>>>>>    //
84523>>>>>>>>>>>>>>>>>    // These properties used with CodeList (SVN)
84523>>>>>>>>>>>>>>>>>    Property Integer phoCodeListHandler                0
84524>>>>>>>>>>>>>>>>>    Property Boolean pbAnsiMode                        True    // If true translate text to ANSI on open and back to OEM on save
84525>>>>>>>>>>>>>>>>>    
84525>>>>>>>>>>>>>>>>>    Property Boolean pbReindentStudioCommentOut        False   // If true, do not reindent comment lines starting at line 0, to keep studio comment out feature via ctrl+/
84526>>>>>>>>>>>>>>>>>    //
84526>>>>>>>>>>>>>>>>>    // I want to have a client border as default
84526>>>>>>>>>>>>>>>>>    Set Border_Style         to Border_ClientEdge
84527>>>>>>>>>>>>>>>>>    // Simulate these keys because they are overwritten by the DFControl.
84527>>>>>>>>>>>>>>>>>    On_Key key_Tab           Send Default_Key
84528>>>>>>>>>>>>>>>>>    On_Key Key_Shift+key_Tab Send Default_Key
84529>>>>>>>>>>>>>>>>>    On_Key kEnter            Send DoKeyReturn
84530>>>>>>>>>>>>>>>>>
84530>>>>>>>>>>>>>>>>>
84530>>>>>>>>>>>>>>>>>    Property Integer piRedrawState          True
84531>>>>>>>>>>>>>>>>>
84531>>>>>>>>>>>>>>>>>    Send Define_cSciLexerLanguageMixin
84532>>>>>>>>>>>>>>>>>  End_Procedure
84533>>>>>>>>>>>>>>>>>
84533>>>>>>>>>>>>>>>>>  Procedure End_Construct_Object
84535>>>>>>>>>>>>>>>>>    Forward Send End_Construct_Object
84537>>>>>>>>>>>>>>>>>
84537>>>>>>>>>>>>>>>>>  End_Procedure
84538>>>>>>>>>>>>>>>>>
84538>>>>>>>>>>>>>>>>>  Function SciLoadImageErrorText Integer iError Returns String
84540>>>>>>>>>>>>>>>>>    String  sErrorText
84540>>>>>>>>>>>>>>>>>
84540>>>>>>>>>>>>>>>>>    //ZeroString 300 to sErrorText
84540>>>>>>>>>>>>>>>>>    //Move (SciLoadImageErrorText(iError,AddressOf(sErrorText))) To iVoid
84540>>>>>>>>>>>>>>>>>    Move ("SciLoadImageAsRGBA, error "+trim(iError)) to sErrorText
84541>>>>>>>>>>>>>>>>>    Function_Return (CString(sErrorText))
84542>>>>>>>>>>>>>>>>>  End_Function
84543>>>>>>>>>>>>>>>>>
84543>>>>>>>>>>>>>>>>>
84543>>>>>>>>>>>>>>>>>  // Allows dropping files from Windows.
84543>>>>>>>>>>>>>>>>>  Procedure DoFileDropping Longptr wParam Longptr lParam
84545>>>>>>>>>>>>>>>>>    Handle  hDrop
84545>>>>>>>>>>>>>>>>>    Integer iCount iSize iC iRet
84545>>>>>>>>>>>>>>>>>    String  sFile
84545>>>>>>>>>>>>>>>>>    
84545>>>>>>>>>>>>>>>>>    Move wParam             to hDrop
84546>>>>>>>>>>>>>>>>>    Move (DragQueryFile(hDrop,|CI$FFFFFFFF,0,0))    to iCount
84547>>>>>>>>>>>>>>>>>    For iC from 0 to (iCount-1)
84553>>>>>>>>>>>>>>>>>>
84553>>>>>>>>>>>>>>>>>      Move (DragQueryFile(hDrop,iC,0,0))          to iSize
84554>>>>>>>>>>>>>>>>>      Move (Repeat(Character(0),iSize+1))         to sFile
84555>>>>>>>>>>>>>>>>>      Move (DragQueryFile(hDrop,iC,AddressOf(sFile),iSize+1))    to iRet
84556>>>>>>>>>>>>>>>>>      If iRet Begin
84558>>>>>>>>>>>>>>>>>        Move (CString(sFile))                   to sFile
84559>>>>>>>>>>>>>>>>>        Send onFileDropped sFile
84560>>>>>>>>>>>>>>>>>      End
84560>>>>>>>>>>>>>>>>>>
84560>>>>>>>>>>>>>>>>>    Loop
84561>>>>>>>>>>>>>>>>>>
84561>>>>>>>>>>>>>>>>>    Move (DragFinish(hDrop))                        to iRet
84562>>>>>>>>>>>>>>>>>  End_Procedure
84563>>>>>>>>>>>>>>>>>  Procedure OnFileDropped String sFile
84565>>>>>>>>>>>>>>>>>  End_Procedure
84566>>>>>>>>>>>>>>>>>
84566>>>>>>>>>>>>>>>>>  Procedure onWmContextMenu Longptr wParam Longptr lParam
84568>>>>>>>>>>>>>>>>>    Send DoRightClick wParam
84569>>>>>>>>>>>>>>>>>  End_Procedure
84570>>>>>>>>>>>>>>>>>
84570>>>>>>>>>>>>>>>>>  // This popups the SelectionList reltive to the cursor position
84570>>>>>>>>>>>>>>>>>  Function Absolute_GUIOrigin Returns Integer
84572>>>>>>>>>>>>>>>>>    Integer iX iY iRet
84572>>>>>>>>>>>>>>>>>    Forward Get Absolute_GUIOrigin  to iRet
84574>>>>>>>>>>>>>>>>>    If (piDontOverwriteGUIOrigin(Self)) Begin
84576>>>>>>>>>>>>>>>>>      Function_Return iRet
84577>>>>>>>>>>>>>>>>>    End
84577>>>>>>>>>>>>>>>>>>
84577>>>>>>>>>>>>>>>>>    Move (Hi(iRet))                                                 to iY
84578>>>>>>>>>>>>>>>>>    Move (Low(iRet))                                                to iX
84579>>>>>>>>>>>>>>>>>    Get  CM_GetSel False                                            to iRet
84580>>>>>>>>>>>>>>>>>    Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
84581>>>>>>>>>>>>>>>>>    Move (iY+piPosEndY(Self))                                       to iY
84582>>>>>>>>>>>>>>>>>    Move (iX+piPosEndX(Self))                                       to iX
84583>>>>>>>>>>>>>>>>>    Move (iY+piGUIOriginOffsetY(Self))                              to iY
84584>>>>>>>>>>>>>>>>>    Move (iX+piGUIOriginOffsetX(Self))                              to iX
84585>>>>>>>>>>>>>>>>>    Function_Return (MAKEWPARAM(iX,iY))
84586>>>>>>>>>>>>>>>>>  End_Function
84587>>>>>>>>>>>>>>>>>
84587>>>>>>>>>>>>>>>>>  // So the real GUIOrigin is always available too.
84587>>>>>>>>>>>>>>>>>  Function Absolute_GUIOriginEx Returns Integer
84589>>>>>>>>>>>>>>>>>    Integer iRet iOld
84589>>>>>>>>>>>>>>>>>    Get piDontOverwriteGUIOrigin    to iOld
84590>>>>>>>>>>>>>>>>>    Set piDontOverwriteGUIOrigin    to True
84591>>>>>>>>>>>>>>>>>    Get Absolute_GUIOrigin          to iRet
84592>>>>>>>>>>>>>>>>>    Set piDontOverwriteGUIOrigin    to iOld
84593>>>>>>>>>>>>>>>>>    Function_Return iRet
84594>>>>>>>>>>>>>>>>>  End_Function
84595>>>>>>>>>>>>>>>>>
84595>>>>>>>>>>>>>>>>>  // Implementing Dyn.Update.State with using WM_SETREDRAW
84595>>>>>>>>>>>>>>>>>  Procedure Set Dynamic_Update_State1 Integer iFlag
84597>>>>>>>>>>>>>>>>>    Integer iRet
84597>>>>>>>>>>>>>>>>>    If (window_handle(Self)) Eq 0 Begin
84599>>>>>>>>>>>>>>>>>      Procedure_Return
84600>>>>>>>>>>>>>>>>>    End
84600>>>>>>>>>>>>>>>>>>
84600>>>>>>>>>>>>>>>>>    Set piRedrawState   to iFlag
84601>>>>>>>>>>>>>>>>>    Move (SendMessage(Window_Handle(Self),WM_SETREDRAW,iFlag,0))            to iRet
84602>>>>>>>>>>>>>>>>>    If iFlag Begin
84604>>>>>>>>>>>>>>>>>      Move (RedrawWindow(Window_Handle(Self),0,0,RDW_INVALIDATE))    to iRet
84605>>>>>>>>>>>>>>>>>    End
84605>>>>>>>>>>>>>>>>>>
84605>>>>>>>>>>>>>>>>>  End_Procedure
84606>>>>>>>>>>>>>>>>>
84606>>>>>>>>>>>>>>>>>  Function Dynamic_Update_State1 Returns Integer
84608>>>>>>>>>>>>>>>>>    Function_Return (piRedrawState(Self))
84609>>>>>>>>>>>>>>>>>  End_Function
84610>>>>>>>>>>>>>>>>>
84610>>>>>>>>>>>>>>>>>  Procedure OnWmPaint
84612>>>>>>>>>>>>>>>>>  End_Procedure
84613>>>>>>>>>>>>>>>>>
84613>>>>>>>>>>>>>>>>>
84613>>>>>>>>>>>>>>>>>  Function CreateIndentation Integer iIndent Integer iTabSize Boolean bInsertSpaces Returns String
84615>>>>>>>>>>>>>>>>>    String sIndent
84615>>>>>>>>>>>>>>>>>
84615>>>>>>>>>>>>>>>>>    Move "" to sIndent
84616>>>>>>>>>>>>>>>>>    If (bInsertSpaces=False) Begin
84618>>>>>>>>>>>>>>>>>      While (iIndent>=iTabSize)
84622>>>>>>>>>>>>>>>>>        Move (sIndent+"\t") to sIndent
84623>>>>>>>>>>>>>>>>>        Move (iIndent-iTabSize) to iIndent
84624>>>>>>>>>>>>>>>>>      Loop
84625>>>>>>>>>>>>>>>>>>
84625>>>>>>>>>>>>>>>>>      Move (Replaces("\t",sIndent,Character(9))) to sIndent
84626>>>>>>>>>>>>>>>>>      While (iIndent>0)
84630>>>>>>>>>>>>>>>>>        Move (sIndent+" ") to sIndent
84631>>>>>>>>>>>>>>>>>        Decrement iIndent
84632>>>>>>>>>>>>>>>>>      Loop
84633>>>>>>>>>>>>>>>>>>
84633>>>>>>>>>>>>>>>>>    End
84633>>>>>>>>>>>>>>>>>>
84633>>>>>>>>>>>>>>>>>    Else Begin
84634>>>>>>>>>>>>>>>>>      Move (Repeat(" ",iIndent)) To sIndent
84635>>>>>>>>>>>>>>>>>    End
84635>>>>>>>>>>>>>>>>>>
84635>>>>>>>>>>>>>>>>>    Function_Return sIndent
84636>>>>>>>>>>>>>>>>>  End_Function
84637>>>>>>>>>>>>>>>>>
84637>>>>>>>>>>>>>>>>>  Function DefaultTabIndent Returns String
84639>>>>>>>>>>>>>>>>>    Boolean bUseTabs
84639>>>>>>>>>>>>>>>>>    Integer iTabSize
84639>>>>>>>>>>>>>>>>>    String  sIndent
84639>>>>>>>>>>>>>>>>>
84639>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH to iTabSize
84640>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS  to bUseTabs
84641>>>>>>>>>>>>>>>>>    Get CreateIndentation iTabSize iTabSize (not(bUseTabs)) To sIndent
84642>>>>>>>>>>>>>>>>>    Function_Return sIndent
84643>>>>>>>>>>>>>>>>>  End_Function
84644>>>>>>>>>>>>>>>>>
84644>>>>>>>>>>>>>>>>>  // Creates an Indent String while obeying the current settings
84644>>>>>>>>>>>>>>>>>  //
84644>>>>>>>>>>>>>>>>>  Function IndentString Integer iIndentWanted Returns String
84646>>>>>>>>>>>>>>>>>    Boolean bUseTabs
84646>>>>>>>>>>>>>>>>>    Integer iTabSize
84646>>>>>>>>>>>>>>>>>    String  sIndent
84646>>>>>>>>>>>>>>>>>
84646>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH to iTabSize
84647>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS  to bUseTabs
84648>>>>>>>>>>>>>>>>>    Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) To sIndent
84649>>>>>>>>>>>>>>>>>    Function_Return sIndent
84650>>>>>>>>>>>>>>>>>  End_Function
84651>>>>>>>>>>>>>>>>>
84651>>>>>>>>>>>>>>>>>  Function IndentStringForLine Integer iLine Returns String
84653>>>>>>>>>>>>>>>>>    Integer iIndent
84653>>>>>>>>>>>>>>>>>    String  sIndent
84653>>>>>>>>>>>>>>>>>
84653>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINEINDENTATION iLine to iIndent
84654>>>>>>>>>>>>>>>>>    Get IndentString iIndent To sIndent
84655>>>>>>>>>>>>>>>>>    Function_Return sIndent
84656>>>>>>>>>>>>>>>>>  End_Function
84657>>>>>>>>>>>>>>>>>
84657>>>>>>>>>>>>>>>>>  //
84657>>>>>>>>>>>>>>>>>  // iLine is the new line we are on and iIndentWanted is the indentation from the previous
84657>>>>>>>>>>>>>>>>>  // line. We will insert the wanted indentation and then place the cursor at the end of
84657>>>>>>>>>>>>>>>>>  // the line.
84657>>>>>>>>>>>>>>>>>  //
84657>>>>>>>>>>>>>>>>>  Procedure IndentAsPreviousLine Integer iLine Integer iIndentWanted
84659>>>>>>>>>>>>>>>>>    Integer iPos
84659>>>>>>>>>>>>>>>>>    Integer iLen
84659>>>>>>>>>>>>>>>>>    String  sIndent
84659>>>>>>>>>>>>>>>>>
84659>>>>>>>>>>>>>>>>>    Get IndentString iIndentWanted to sIndent
84660>>>>>>>>>>>>>>>>>    Move (Length(sIndent)) To iLen
84661>>>>>>>>>>>>>>>>>    Move (sIndent+Character(0)) to sIndent
84662>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE iLine to iPos
84663>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETTARGETRANGE iPos iPos
84664>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sIndent))
84665>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETSEL -1 (iPos+iLen) // position the cursor to the new line indentation point and remove the selection
84666>>>>>>>>>>>>>>>>>  End_Procedure
84667>>>>>>>>>>>>>>>>>
84667>>>>>>>>>>>>>>>>>  Procedure DoKeyReturn
84669>>>>>>>>>>>>>>>>>    Boolean bNormalizeCase
84669>>>>>>>>>>>>>>>>>    Integer iLine
84669>>>>>>>>>>>>>>>>>    Integer iIndent
84669>>>>>>>>>>>>>>>>>    Integer iPos
84669>>>>>>>>>>>>>>>>>    Integer iCol
84669>>>>>>>>>>>>>>>>>    Integer iTabSize
84669>>>>>>>>>>>>>>>>>    Integer iFoldLevel iNextFoldLevel
84669>>>>>>>>>>>>>>>>>    Integer eMode
84669>>>>>>>>>>>>>>>>>
84669>>>>>>>>>>>>>>>>>    Get pbNormalizeCase to bNormalizeCase
84670>>>>>>>>>>>>>>>>>    If (bNormalizeCase) Begin
84672>>>>>>>>>>>>>>>>>      Send doNormalizeCase
84673>>>>>>>>>>>>>>>>>    End
84673>>>>>>>>>>>>>>>>>>
84673>>>>>>>>>>>>>>>>>    If (pbIsCodelistActive(Self)) Begin
84675>>>>>>>>>>>>>>>>>      // We're in a autocomplete list, don't send enter, send TAB instead
84675>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_TAB
84676>>>>>>>>>>>>>>>>>    End
84676>>>>>>>>>>>>>>>>>>
84676>>>>>>>>>>>>>>>>>    Else Begin
84677>>>>>>>>>>>>>>>>>      Get peAutoIndentMode to eMode
84678>>>>>>>>>>>>>>>>>      Set psLineOnEnter    to ""
84679>>>>>>>>>>>>>>>>>      If (eMode=CM_INDENT_PREVLINE) Begin
84681>>>>>>>>>>>>>>>>>        Get  Current_Item To iLine
84682>>>>>>>>>>>>>>>>>        Get LineFoldLevel iLine To iFoldLevel
84683>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_BEGINUNDOACTION
84684>>>>>>>>>>>>>>>>>        Get  EditorMessage SCI_GETLINEINDENTATION iLine 0 to iIndent
84685>>>>>>>>>>>>>>>>>        Get  EditorMessage SCI_GETCURRENTPOS 0 0 To iPos
84686>>>>>>>>>>>>>>>>>        Get  EditorMessage SCI_GETCOLUMN  iPos 0 to iCol
84687>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_NEWLINE
84688>>>>>>>>>>>>>>>>>        Get LineFoldLevel (iLine+1) To iNextFoldLevel
84689>>>>>>>>>>>>>>>>>        If (iNextFoldLevel>iFoldLevel) Begin
84691>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETTABWIDTH 0 0 to iTabSize
84692>>>>>>>>>>>>>>>>>          Move (iTabSize+iIndent) To iIndent // we're just after a new scope, so indent 1 extra position
84693>>>>>>>>>>>>>>>>>        End
84693>>>>>>>>>>>>>>>>>>
84693>>>>>>>>>>>>>>>>>        If (iCol>=iIndent) Begin
84695>>>>>>>>>>>>>>>>>          Send IndentAsPreviousLine (iLine+1) iIndent
84696>>>>>>>>>>>>>>>>>        End
84696>>>>>>>>>>>>>>>>>>
84696>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_ENDUNDOACTION
84697>>>>>>>>>>>>>>>>>      End
84697>>>>>>>>>>>>>>>>>>
84697>>>>>>>>>>>>>>>>>      Else Begin
84698>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_NEWLINE
84699>>>>>>>>>>>>>>>>>      End
84699>>>>>>>>>>>>>>>>>>
84699>>>>>>>>>>>>>>>>>    End
84699>>>>>>>>>>>>>>>>>>
84699>>>>>>>>>>>>>>>>>  End_Procedure
84700>>>>>>>>>>>>>>>>>  
84700>>>>>>>>>>>>>>>>>  // To ensure that the Object with the WinFocus also owns the DF focus.
84700>>>>>>>>>>>>>>>>>  Procedure OnWmSetFocus
84702>>>>>>>>>>>>>>>>>    Send Activate
84703>>>>>>>>>>>>>>>>>  End_Procedure
84704>>>>>>>>>>>>>>>>>  
84704>>>>>>>>>>>>>>>>>  Procedure OnWmKillFocus
84706>>>>>>>>>>>>>>>>>  End_Procedure
84707>>>>>>>>>>>>>>>>>
84707>>>>>>>>>>>>>>>>>
84707>>>>>>>>>>>>>>>>>  Procedure EditorMessage Handle uMsg Longptr wParam Longptr lParam
84709>>>>>>>>>>>>>>>>>    Handle  hWnd
84709>>>>>>>>>>>>>>>>>    Integer iRet
84709>>>>>>>>>>>>>>>>>
84709>>>>>>>>>>>>>>>>>    Get Window_Handle to hWnd
84710>>>>>>>>>>>>>>>>>    If (hWnd) Begin
84712>>>>>>>>>>>>>>>>>      If num_arguments Eq 3 Begin
84714>>>>>>>>>>>>>>>>>        Move (SendMessage(hWnd,uMsg,wParam,lParam)) to iRet
84715>>>>>>>>>>>>>>>>>      End
84715>>>>>>>>>>>>>>>>>>
84715>>>>>>>>>>>>>>>>>      Else If num_arguments eq 2 Begin
84718>>>>>>>>>>>>>>>>>        Move (SendMessage(hWnd,uMsg,wParam,0)) to iRet
84719>>>>>>>>>>>>>>>>>      End
84719>>>>>>>>>>>>>>>>>>
84719>>>>>>>>>>>>>>>>>      Else If num_arguments eq 1 Begin
84722>>>>>>>>>>>>>>>>>        Move (SendMessage(hWnd,uMsg,0,0)) to iRet
84723>>>>>>>>>>>>>>>>>      End
84723>>>>>>>>>>>>>>>>>>
84723>>>>>>>>>>>>>>>>>    End
84723>>>>>>>>>>>>>>>>>>
84723>>>>>>>>>>>>>>>>>  End_Procedure
84724>>>>>>>>>>>>>>>>>  
84724>>>>>>>>>>>>>>>>>  Procedure EditorError String sMessage
84726>>>>>>>>>>>>>>>>>    String sStack
84726>>>>>>>>>>>>>>>>>    
84726>>>>>>>>>>>>>>>>>    CallStackDump sStack
84727>>>>>>>>>>>>>>>>>    Error DfErr_Program (sMessage+"\n"+sStack)
84728>>>>>>>>>>>>>>>>>>
84728>>>>>>>>>>>>>>>>>  End_Procedure
84729>>>>>>>>>>>>>>>>>
84729>>>>>>>>>>>>>>>>>  Function EditorMessage Handle uMsg Longptr wParam Longptr lParam Returns Longptr
84731>>>>>>>>>>>>>>>>>    Handle  hWnd
84731>>>>>>>>>>>>>>>>>    Longptr iRet
84731>>>>>>>>>>>>>>>>>
84731>>>>>>>>>>>>>>>>>    Move 0 To iRet
84732>>>>>>>>>>>>>>>>>    Get Window_Handle to hWnd
84733>>>>>>>>>>>>>>>>>    If (hWnd) Begin
84735>>>>>>>>>>>>>>>>>      Case Begin
84735>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 0)
84737>>>>>>>>>>>>>>>>>          Send EditorError "Programmer error, get editormessage without a parameter."
84738>>>>>>>>>>>>>>>>>          Case Break
84739>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 1)
84742>>>>>>>>>>>>>>>>>          Move (SendMessage(hWnd,uMsg,0,0)) To iRet
84743>>>>>>>>>>>>>>>>>          Case Break
84744>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 2)
84747>>>>>>>>>>>>>>>>>          Move (SendMessage(hWnd,uMsg,wParam,0)) To iRet
84748>>>>>>>>>>>>>>>>>          Case Break
84749>>>>>>>>>>>>>>>>>        Case (Num_Arguments = 3)
84752>>>>>>>>>>>>>>>>>          Move (SendMessage(hWnd,uMsg,wParam,lParam)) To iRet
84753>>>>>>>>>>>>>>>>>          Case Break
84754>>>>>>>>>>>>>>>>>      Case End
84754>>>>>>>>>>>>>>>>>    End
84754>>>>>>>>>>>>>>>>>>
84754>>>>>>>>>>>>>>>>>    Function_Return iRet
84755>>>>>>>>>>>>>>>>>  End_Function
84756>>>>>>>>>>>>>>>>>
84756>>>>>>>>>>>>>>>>>  Procedure EditorMessageString Handle uMsg String ByRef sName String ByRef sValue
84758>>>>>>>>>>>>>>>>>    Handle  hWnd
84758>>>>>>>>>>>>>>>>>    Integer iRet
84758>>>>>>>>>>>>>>>>>
84758>>>>>>>>>>>>>>>>>    Get Window_Handle to hWnd
84759>>>>>>>>>>>>>>>>>    If (hWnd) Begin
84761>>>>>>>>>>>>>>>>>      Move (sName+ Character(0)) to sName
84762>>>>>>>>>>>>>>>>>      Move (sValue+Character(0)) to sValue
84763>>>>>>>>>>>>>>>>>      Move (SendMessage(hWnd,uMsg,AddressOf(sName),AddressOf(sValue))) to iRet
84764>>>>>>>>>>>>>>>>>    End
84764>>>>>>>>>>>>>>>>>>
84764>>>>>>>>>>>>>>>>>  End_Procedure
84765>>>>>>>>>>>>>>>>>
84765>>>>>>>>>>>>>>>>>  // By SVN - Apply Colorer
84765>>>>>>>>>>>>>>>>>  Procedure DefaultFontStyles
84767>>>>>>>>>>>>>>>>>    Integer iLexer
84767>>>>>>>>>>>>>>>>>    Integer iBackColor
84767>>>>>>>>>>>>>>>>>    String  sFont
84767>>>>>>>>>>>>>>>>>
84767>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLECLEARALL
84768>>>>>>>>>>>>>>>>>    // We have setup a default font for all, now set the specific fonts.
84768>>>>>>>>>>>>>>>>>    //
84768>>>>>>>>>>>>>>>>>    Set piTextColor   to gtColorer[EC_TEXT].iForeC //iTextColor
84769>>>>>>>>>>>>>>>>>    Set piWindowColor to gtColorer[EC_WINDOW].iForeC //iBackColor
84770>>>>>>>>>>>>>>>>>    // Caret
84770>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETCARETFORE       gtColorer[EC_TEXT].iForeC
84771>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETCARETWIDTH      3
84772>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_SETCARETSTYLE      CARETSTYLE_BLOCK // Good for overwrite mode (Default is Underline)
84772>>>>>>>>>>>>>>>>>    // Selection
84772>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_SETSELFORE True (Rgb($FF, $FF, $FF)) // Will overwrite selection highlighting
84772>>>>>>>>>>>>>>>>>    Move gtColorer[EC_WINDOW].iForeC to iBackColor
84773>>>>>>>>>>>>>>>>>    If (iBackColor<0) Begin
84775>>>>>>>>>>>>>>>>>      Move clWhite to iBackColor
84776>>>>>>>>>>>>>>>>>    End
84776>>>>>>>>>>>>>>>>>>
84776>>>>>>>>>>>>>>>>>    // *** Lets check either Selection color is set and if not, then allocate default selection
84776>>>>>>>>>>>>>>>>>    // Probably not the best algorithm, but we may improve at some stage if required ***
84776>>>>>>>>>>>>>>>>>    If (gtColorer[EC_SELECTION].iForeC<=0) Begin
84778>>>>>>>>>>>>>>>>>      If (iBackColor < (RGB($FF, $FF, $FF)/2-10000)) ;        Send EditorMessage SCI_SETSELBACK True (Rgb($00, $00, $AA)) // Set darker
84781>>>>>>>>>>>>>>>>>      Else ;        Send EditorMessage SCI_SETSELBACK True (RGB(170,195,240))   // Set lighter
84783>>>>>>>>>>>>>>>>>    End
84783>>>>>>>>>>>>>>>>>>
84783>>>>>>>>>>>>>>>>>    Else ;      Send EditorMessage SCI_SETSELBACK True gtColorer[EC_SELECTION].iForeC   // Set as per options
84785>>>>>>>>>>>>>>>>>    // # White space
84785>>>>>>>>>>>>>>>>>    // style.dataflex.0=fore:#808080
84785>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFORE STYLE_DEFAULT gtColorer[EC_TEXT].iForeC
84786>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK STYLE_DEFAULT iBackColor
84787>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK 0             iBackColor
84788>>>>>>>>>>>>>>>>>    // Retrieve lexer type for current window (eg. language) and apply the appearance for the language set.
84788>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLEXER to iLexer
84789>>>>>>>>>>>>>>>>>    Send SetAppearanceForLanguage iLexer
84790>>>>>>>>>>>>>>>>>    Send SetAppearance  STYLE_BRACELIGHT     EC_BRACEHLIGHT      // Colors for matching braces
84791>>>>>>>>>>>>>>>>>    Send SetAppearance  STYLE_BRACEBAD       EC_UNMATCHEDBRACE   // Colors for an unmatched brace (bracebad)
84792>>>>>>>>>>>>>>>>>    Send SetAppearance  STYLE_LINENUMBER     EC_LINENUMBERS      // Line Numbers Margin
84793>>>>>>>>>>>>>>>>>    Send EditorMessage  SCI_STYLESETSIZE     STYLE_LINENUMBER 10 // Set font size
84794>>>>>>>>>>>>>>>>>    //
84794>>>>>>>>>>>>>>>>>    // Colors for codetip tooltip
84794>>>>>>>>>>>>>>>>>    // font style to use for call tip
84794>>>>>>>>>>>>>>>>>    Move ("Segoe UI"+Character(0)) to sFont
84795>>>>>>>>>>>>>>>>>    //      Move ("Verdana"+Character(0)) to sFont
84795>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFONT STYLE_CALLTIP   (AddressOf(sFont))
84796>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETSIZE STYLE_CALLTIP   9
84797>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETBACK STYLE_CALLTIP   (rgb($FF,$FF,$E1))
84798>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFORE STYLE_CALLTIP   (rgb($00,$00,$00)) // Code tooltip text color
84799>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPSETFOREHLT            (rgb($00,$00,$00)) // Code tooltip parameters color
84800>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPUSESTYLE 10 // tabs are filtered out of calltips, but we need to call this to have scintilla use our defined colors.
84801>>>>>>>>>>>>>>>>>    //
84801>>>>>>>>>>>>>>>>>    // tell the control we want to use our own font style for autocomplete
84801>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_AUTOCUSESTYLE
84802>>>>>>>>>>>>>>>>>    // font style to use for autocomplete (codelist)
84802>>>>>>>>>>>>>>>>>    //      Move ("DejaVu Sans Mono"+Character(0)) to sFont
84802>>>>>>>>>>>>>>>>>    Move ("Segoe UI"+Character(0)) to sFont
84803>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETFONT STYLE_AUTOCOMPLETE (AddressOf(sFont))
84804>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_STYLESETSIZE STYLE_AUTOCOMPLETE 10
84805>>>>>>>>>>>>>>>>>    // Status is bookmarks, debug pointer and breakpoints
84805>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINBACKN MARGIN_STATUS       gtColorer[EC_LEFTMARGIN].iForeC
84806>>>>>>>>>>>>>>>>>    // Changed line
84806>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINBACKN MARGIN_CHANGED_LINE gtColorer[EC_LEFTMARGIN].iForeC
84807>>>>>>>>>>>>>>>>>  End_Procedure
84808>>>>>>>>>>>>>>>>>
84808>>>>>>>>>>>>>>>>>  Procedure Set LexerProperty String sName String sValue
84810>>>>>>>>>>>>>>>>>    Send EditorMessageString SCI_SETPROPERTY (&sName) (&sValue)
84811>>>>>>>>>>>>>>>>>  End_Procedure
84812>>>>>>>>>>>>>>>>>
84812>>>>>>>>>>>>>>>>>  Procedure SetLexer
84814>>>>>>>>>>>>>>>>>  End_Procedure
84815>>>>>>>>>>>>>>>>>
84815>>>>>>>>>>>>>>>>>  Procedure SetDefaultFoldingStyle
84817>>>>>>>>>>>>>>>>>    Integer iFore
84817>>>>>>>>>>>>>>>>>    Integer iBack
84817>>>>>>>>>>>>>>>>>    Pointer pExpandIconXpm
84817>>>>>>>>>>>>>>>>>    Pointer pCollapseIconXpm
84817>>>>>>>>>>>>>>>>>    Pointer pBookmarkIconXpm
84817>>>>>>>>>>>>>>>>>    Pointer pChangedLineIconXpm
84817>>>>>>>>>>>>>>>>>    Pointer pSavedLineIconXpm
84817>>>>>>>>>>>>>>>>>    //
84817>>>>>>>>>>>>>>>>>    //line.margin.width=4
84817>>>>>>>>>>>>>>>>>    //margin.width=$(scale 16)
84817>>>>>>>>>>>>>>>>>    //fold.margin.width=$(scale 14)
84817>>>>>>>>>>>>>>>>>    Set LexerProperty "line.margin.width" to "4"
84818>>>>>>>>>>>>>>>>>    //Set LexerProperty "margin.width"      to "$(scale 16)"
84818>>>>>>>>>>>>>>>>>    //Set LexerProperty "fold.margin.width" to "$(scale 14)"
84818>>>>>>>>>>>>>>>>>    Set LexerProperty "margin.width"      to "16"
84819>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.margin.width" to "14"
84820>>>>>>>>>>>>>>>>>    //
84820>>>>>>>>>>>>>>>>>    // set folding defaults (can be changed if you want different behavior)
84820>>>>>>>>>>>>>>>>>    //
84820>>>>>>>>>>>>>>>>>    Set LexerProperty "fold"              to "1"
84821>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.compact"      to "1"
84822>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.flags"        to "1"
84823>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.comment"      to "1"
84824>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.preprocessor" to "1"
84825>>>>>>>>>>>>>>>>>    Set LexerProperty "fold.dataflex.compilerlist" To "0"  // fold PRN files (is set to true when you open a prn/prp file)
84826>>>>>>>>>>>>>>>>>    //
84826>>>>>>>>>>>>>>>>>    // Now resize all the margins to zero
84826>>>>>>>>>>>>>>>>>    // (This will be done in a RecalcLineMargin method...)
84826>>>>>>>>>>>>>>>>>    //
84826>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 0
84827>>>>>>>>>>>>>>>>>    //
84827>>>>>>>>>>>>>>>>>    // Then Set the margin type and margin mask and resize it...
84827>>>>>>>>>>>>>>>>>    //      Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
84827>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING SC_MARGIN_SYMBOL
84828>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CODE_FOLDING SC_MASK_FOLDERS
84829>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 20
84830>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETFOLDMARGINCOLOUR    True gtColorer[EC_LINENUMBERS].iBackC
84831>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETFOLDMARGINHICOLOUR  True gtColorer[EC_LEFTMARGIN].iForeC
84832>>>>>>>>>>>>>>>>>    //
84832>>>>>>>>>>>>>>>>>    // Needs marker defines
84832>>>>>>>>>>>>>>>>>    Move (RGB($00,$00,$00)) to iBack
84833>>>>>>>>>>>>>>>>>    Move (RGB($bb,$bb,$bb)) to iFore
84834>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDEROPEN    SC_ALPHA_TRANSPARENT
84834>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(0)) To pExpandIconXpm       // get xpm icon from parser DLL
84835>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(1)) To pCollapseIconXpm     // These icons are created by hand by Sergey!
84836>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(2)) To pBookmarkIconXpm
84837>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(3)) To pChangedLineIconXpm
84838>>>>>>>>>>>>>>>>>    Move (SciEditorIconXpm(4)) To pSavedLineIconXpm
84839>>>>>>>>>>>>>>>>>
84839>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPEN    iBack
84840>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPEN    iFore
84841>>>>>>>>>>>>>>>>>    If (pCollapseIconXpm<>0) Begin
84843>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPEN pCollapseIconXpm
84844>>>>>>>>>>>>>>>>>    End
84844>>>>>>>>>>>>>>>>>>
84844>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPEN    SC_MARK_CIRCLEMINUS
84844>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDER        SC_ALPHA_TRANSPARENT
84844>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDER        iBack
84845>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDER        iFore
84846>>>>>>>>>>>>>>>>>    If (pExpandIconXpm<>0) Begin
84848>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDER    pExpandIconXpm
84849>>>>>>>>>>>>>>>>>    End
84849>>>>>>>>>>>>>>>>>>
84849>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERSUB     iBack
84849>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERSUB     iFore
84849>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERSUB     SC_MARK_EMPTY //SC_MARK_VLINE       //SC_MARK_EMPTY
84850>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERTAIL    iBack
84850>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERTAIL    iFore
84850>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERTAIL    SC_MARK_EMPTY //SC_MARK_LCORNERCURVE
84851>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEREND     iBack
84852>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEREND     iFore
84853>>>>>>>>>>>>>>>>>    If (pExpandIconXpm<>0) Begin
84855>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEREND    pExpandIconXpm
84856>>>>>>>>>>>>>>>>>    End
84856>>>>>>>>>>>>>>>>>>
84856>>>>>>>>>>>>>>>>>    ///Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEREND     SC_MARK_EMPTY //SC_MARK_CIRCLEPLUSCONNECTED
84856>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPENMID iBack
84857>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPENMID iFore
84858>>>>>>>>>>>>>>>>>    If (pCollapseIconXpm<>0) Begin
84860>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPENMID pCollapseIconXpm
84861>>>>>>>>>>>>>>>>>    End
84861>>>>>>>>>>>>>>>>>>
84861>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPENMID SC_MARK_EMPTY //SC_MARK_CIRCLEMINUSCONNECTED
84861>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERMIDTAIL iBack
84861>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERMIDTAIL iFore
84861>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERMIDTAIL SC_MARK_EMPTY //SC_MARK_TCORNERCURVE
84862>>>>>>>>>>>>>>>>>    //
84862>>>>>>>>>>>>>>>>>    //
84862>>>>>>>>>>>>>>>>>    // SendEditor(SCI_SETFOLDFLAGS, 16, 0); // 16       Draw line below if not expanded
84862>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETFOLDFLAGS 16 0
84863>>>>>>>>>>>>>>>>>    //
84863>>>>>>>>>>>>>>>>>    // Tell scintilla we want to be notified about mouse clicks in the codefolding margin
84863>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_CODE_FOLDING 1
84864>>>>>>>>>>>>>>>>>    //
84864>>>>>>>>>>>>>>>>>    // Tell scintilla we want to be notified about mouse clicks in the status margin
84864>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_STATUS 1
84865>>>>>>>>>>>>>>>>>    //
84865>>>>>>>>>>>>>>>>>    // for marker 10 define a background color instead of the marker symbol
84865>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_LINEHIGHLIGHT SC_MARK_BACKGROUND
84866>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_LINEHIGHLIGHT gtColorer[EC_HLIGHTEDLINE].iForeC //(rgb($DE,$DE,$EF))
84867>>>>>>>>>>>>>>>>>    //
84867>>>>>>>>>>>>>>>>>    // for marker 11 connect it to sergey's bookmark symbol
84867>>>>>>>>>>>>>>>>>    //
84867>>>>>>>>>>>>>>>>>    If (pBookmarkIconXpm<>0) Begin
84869>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_BOOKMARK pBookmarkIconXpm
84870>>>>>>>>>>>>>>>>>    End
84870>>>>>>>>>>>>>>>>>>
84870>>>>>>>>>>>>>>>>>    Else Begin // fall back on default
84871>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_BOOKMARK  SC_MARK_BOOKMARK
84872>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_BOOKMARK  (rgb($DE,$00,$00))
84873>>>>>>>>>>>>>>>>>    End
84873>>>>>>>>>>>>>>>>>>
84873>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_MARKERSETFORE SC_MARKNUM_BOOKMARK  (rgb($EE,$00,$00))
84873>>>>>>>>>>>>>>>>>    //
84873>>>>>>>>>>>>>>>>>    // for marker 12 and 13 connect it to the changedline icon
84873>>>>>>>>>>>>>>>>>    If (pChangedLineIconXpm<>0) Begin
84875>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINE pChangedLineIconXpm
84876>>>>>>>>>>>>>>>>>    End
84876>>>>>>>>>>>>>>>>>>
84876>>>>>>>>>>>>>>>>>    Else Begin
84877>>>>>>>>>>>>>>>>>      // We're using the SC_MARK_FULLRECT instead as we can set the color and width
84877>>>>>>>>>>>>>>>>>      // dynamically.
84877>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINE SC_MARK_FULLRECT
84878>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINE  (rgb($FF,$F2,$00)) // yellow
84879>>>>>>>>>>>>>>>>>    End
84879>>>>>>>>>>>>>>>>>>
84879>>>>>>>>>>>>>>>>>
84879>>>>>>>>>>>>>>>>>    If (pSavedLineIconXpm<>0) Begin
84881>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINESAVED pSavedLineIconXpm
84882>>>>>>>>>>>>>>>>>    End
84882>>>>>>>>>>>>>>>>>>
84882>>>>>>>>>>>>>>>>>    Else Begin
84883>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINESAVED SC_MARK_FULLRECT
84884>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINESAVED  (rgb($00,$FF,$00)) // green
84885>>>>>>>>>>>>>>>>>    End
84885>>>>>>>>>>>>>>>>>>
84885>>>>>>>>>>>>>>>>>    // for marker 14 set the debug breakpoint marker
84885>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_DEBUGBREAKPOINT SC_MARK_CIRCLE
84886>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_DEBUGBREAKPOINT (rgb($FE,$00,$00)) // red
84887>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_DEBUGBREAKPOINT iBack
84888>>>>>>>>>>>>>>>>>    // for marker 15 set the debug current position pointer
84888>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_DEBUGCURRENTPOSITION SC_MARK_SHORTARROW
84889>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_DEBUGCURRENTPOSITION (rgb($00,$FE,$00)) // green
84890>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_DEBUGCURRENTPOSITION iBack
84891>>>>>>>>>>>>>>>>>  End_Procedure
84892>>>>>>>>>>>>>>>>>
84892>>>>>>>>>>>>>>>>>  Procedure SetDefaultWordStyle
84894>>>>>>>>>>>>>>>>>    //
84894>>>>>>>>>>>>>>>>>    // Use the default sets of word and whitespace characters. This sets whitespace to space, tab and
84894>>>>>>>>>>>>>>>>>    // other characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
84894>>>>>>>>>>>>>>>>>    //
84894>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETCHARSDEFAULT
84895>>>>>>>>>>>>>>>>>  End_Procedure
84896>>>>>>>>>>>>>>>>>
84896>>>>>>>>>>>>>>>>>  // Should try to destroy the font object.
84896>>>>>>>>>>>>>>>>>  Procedure Destroy_Object
84898>>>>>>>>>>>>>>>>>    Forward Send Destroy_Object
84900>>>>>>>>>>>>>>>>>    //Move (CMUnregisterControl()) to iRet
84900>>>>>>>>>>>>>>>>>  End_Procedure
84901>>>>>>>>>>>>>>>>>
84901>>>>>>>>>>>>>>>>>  Procedure ApplyEditorOptions
84903>>>>>>>>>>>>>>>>>    Send SetLexer
84904>>>>>>>>>>>>>>>>>    Send DefaultFontStyles
84905>>>>>>>>>>>>>>>>>    Send SetDefaultFoldingStyle
84906>>>>>>>>>>>>>>>>>    Send SetDefaultWordStyle
84907>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_USEPOPUP        SC_POPUP_NEVER  // Don't use the embedded popup menu, send WM_CONTEXTMENU to parent window
84908>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMODEVENTMASK SC_MODEVENTMASKALL // show ALL events in SCN_MODIFIED
84909>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_LINE_NUMBERS SC_MARGIN_NUMBER // margin 0 is for line numbers
84910>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_STATUS       (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
84911>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_STATUS       16
84912>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_STATUS       SC_MASK_STATUS
84913>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CHANGED_LINE (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
84914>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CHANGED_LINE 3
84915>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CHANGED_LINE SC_MASK_CHANGEDLINE
84916>>>>>>>>>>>>>>>>>    //
84916>>>>>>>>>>>>>>>>>    Send ClearRegisteredKeyBindings
84917>>>>>>>>>>>>>>>>>    If (pbQuickInfo(Self)) Begin
84919>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMOUSEDWELLTIME (piQuickInfoTime(Self))
84920>>>>>>>>>>>>>>>>>    End
84920>>>>>>>>>>>>>>>>>>
84920>>>>>>>>>>>>>>>>>  End_Procedure
84921>>>>>>>>>>>>>>>>>
84921>>>>>>>>>>>>>>>>>  // Used to create the window...
84921>>>>>>>>>>>>>>>>>  Procedure Page_Object Integer iFlag
84923>>>>>>>>>>>>>>>>>    Integer iRet
84923>>>>>>>>>>>>>>>>>    Handle  hWnd
84923>>>>>>>>>>>>>>>>>    Forward Send Page_Object iFlag
84925>>>>>>>>>>>>>>>>>    If iFlag begin
84927>>>>>>>>>>>>>>>>>      If (piDragAcceptFilesState(Self)) Begin // Allow Dragging files into it.
84929>>>>>>>>>>>>>>>>>        Move (DragAcceptFiles(Window_Handle(Self),True)) to iRet
84930>>>>>>>>>>>>>>>>>      End
84930>>>>>>>>>>>>>>>>>>
84930>>>>>>>>>>>>>>>>>      Get Window_Handle to hWnd
84931>>>>>>>>>>>>>>>>>      If (hWnd<>0) Begin
84933>>>>>>>>>>>>>>>>>        Send SetAdjustments
84934>>>>>>>>>>>>>>>>>        Send ApplyEditorOptions
84935>>>>>>>>>>>>>>>>>        Send onPaged
84936>>>>>>>>>>>>>>>>>      End
84936>>>>>>>>>>>>>>>>>>
84936>>>>>>>>>>>>>>>>>    End
84936>>>>>>>>>>>>>>>>>>
84936>>>>>>>>>>>>>>>>>  End_Procedure
84937>>>>>>>>>>>>>>>>>
84937>>>>>>>>>>>>>>>>>  // Procedures for overwriting. (sent by page after Object is paged.)
84937>>>>>>>>>>>>>>>>>  Procedure SetAdjustments
84939>>>>>>>>>>>>>>>>>  End_Procedure
84940>>>>>>>>>>>>>>>>>  Procedure onPaged
84942>>>>>>>>>>>>>>>>>    // some temp code to find out defaults (to be removed)
84942>>>>>>>>>>>>>>>>>    //Integer i iCount iWidth
84942>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_GETMARGINS to iCount
84942>>>>>>>>>>>>>>>>>    //For i from 0 to (iCount-1)
84942>>>>>>>>>>>>>>>>>    //  Get EditorMessage SCI_GETMARGINWIDTHN i to iWidth
84942>>>>>>>>>>>>>>>>>    //Loop
84942>>>>>>>>>>>>>>>>>  End_Procedure
84943>>>>>>>>>>>>>>>>>
84943>>>>>>>>>>>>>>>>>  // Procedures for overwriting. (sent by copy and cut functions)
84943>>>>>>>>>>>>>>>>>  // 28.1.2003 BP
84943>>>>>>>>>>>>>>>>>  Procedure onBeforePaste
84945>>>>>>>>>>>>>>>>>  End_Procedure
84946>>>>>>>>>>>>>>>>>  Procedure onAfterPaste
84948>>>>>>>>>>>>>>>>>  End_Procedure
84949>>>>>>>>>>>>>>>>>  Procedure onBeforeCut
84951>>>>>>>>>>>>>>>>>  End_Procedure
84952>>>>>>>>>>>>>>>>>  Procedure onAfterCut
84954>>>>>>>>>>>>>>>>>  End_Procedure
84955>>>>>>>>>>>>>>>>>
84955>>>>>>>>>>>>>>>>>
84955>>>>>>>>>>>>>>>>>  //____CODEMAX_NATIVE_METHODs...___________________________________________________
84955>>>>>>>>>>>>>>>>>
84955>>>>>>>>>>>>>>>>>
84955>>>>>>>>>>>>>>>>>  //
84955>>>>>>>>>>>>>>>>>  //
84955>>>>>>>>>>>>>>>>>  Function CM_SetLanguage String sLanguage Returns Integer
84957>>>>>>>>>>>>>>>>>    String sLexer
84957>>>>>>>>>>>>>>>>>
84957>>>>>>>>>>>>>>>>>    Get ScintillaLexerForLanguage sLanguage to sLexer
84958>>>>>>>>>>>>>>>>>    Move (sLexer+Character(0)) to sLexer
84959>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETLEXERLANGUAGE 0 (AddressOf(sLexer))
84960>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
84961>>>>>>>>>>>>>>>>>  End_Function
84962>>>>>>>>>>>>>>>>>
84962>>>>>>>>>>>>>>>>>  //
84962>>>>>>>>>>>>>>>>>  //
84962>>>>>>>>>>>>>>>>>  Function CM_GetLanguage Returns String
84964>>>>>>>>>>>>>>>>>    Integer iRet
84964>>>>>>>>>>>>>>>>>    String  sName
84964>>>>>>>>>>>>>>>>>    String  sLexer
84964>>>>>>>>>>>>>>>>>    String  sFileName
84964>>>>>>>>>>>>>>>>>
84964>>>>>>>>>>>>>>>>>    Get psFileName to sFileName
84965>>>>>>>>>>>>>>>>>    Move (ZeroString(250)) to sLexer
84966>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLEXERLANGUAGE 0 (AddressOf(sLexer)) to iRet
84967>>>>>>>>>>>>>>>>>    //Move "VDF" To szName
84967>>>>>>>>>>>>>>>>>    If (sLexer="cpp") Begin // cpp lexer hosts a number of languages
84969>>>>>>>>>>>>>>>>>      // use our filename extension logic instead
84969>>>>>>>>>>>>>>>>>      Get LanguageForFile of (phoIniHandler(Self)) sFileName  To sName
84970>>>>>>>>>>>>>>>>>    End
84970>>>>>>>>>>>>>>>>>>
84970>>>>>>>>>>>>>>>>>    If (sName="") Begin
84972>>>>>>>>>>>>>>>>>      Get LanguageForScintillaLexer sLexer to sName
84973>>>>>>>>>>>>>>>>>    End
84973>>>>>>>>>>>>>>>>>>
84973>>>>>>>>>>>>>>>>>    Function_Return sName
84974>>>>>>>>>>>>>>>>>  End_Function
84975>>>>>>>>>>>>>>>>>
84975>>>>>>>>>>>>>>>>>  Function CM_EnableColorSyntax Integer bEnable Returns Integer
84977>>>>>>>>>>>>>>>>>    //        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLORSYNTAX,  ( bEnable ), 0 ) )
84977>>>>>>>>>>>>>>>>>    Function_Return 0
84978>>>>>>>>>>>>>>>>>  End_Function
84979>>>>>>>>>>>>>>>>>
84979>>>>>>>>>>>>>>>>>  Function CM_IsColorSyntaxEnabled Returns Integer
84981>>>>>>>>>>>>>>>>>    //        Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLORSYNTAXENABLED, 0, 0 ) )
84981>>>>>>>>>>>>>>>>>    Function_Return 0
84982>>>>>>>>>>>>>>>>>  End_Function
84983>>>>>>>>>>>>>>>>>
84983>>>>>>>>>>>>>>>>>  Procedure onPreOpenFile String sFile
84985>>>>>>>>>>>>>>>>>  End_Procedure
84986>>>>>>>>>>>>>>>>>  Procedure onPostOpenFile String sFile
84988>>>>>>>>>>>>>>>>>  End_Procedure
84989>>>>>>>>>>>>>>>>>
84989>>>>>>>>>>>>>>>>>
84989>>>>>>>>>>>>>>>>>
84989>>>>>>>>>>>>>>>>>  Function CM_OpenFile String szFileName Returns Integer
84991>>>>>>>>>>>>>>>>>    Boolean bIsCRLF
84991>>>>>>>>>>>>>>>>>    Integer iChannel
84991>>>>>>>>>>>>>>>>>    Integer iResult
84991>>>>>>>>>>>>>>>>>    Integer iVoid
84991>>>>>>>>>>>>>>>>>    Integer iArgSize
84991>>>>>>>>>>>>>>>>>    Integer iNewArgSize
84991>>>>>>>>>>>>>>>>>    Integer iPerf
84991>>>>>>>>>>>>>>>>>    Integer iFileExists
84991>>>>>>>>>>>>>>>>>    String  sLine
84991>>>>>>>>>>>>>>>>>    String  sTextData
84991>>>>>>>>>>>>>>>>>    Address aTextData
84991>>>>>>>>>>>>>>>>>    UChar[] TextData
84992>>>>>>>>>>>>>>>>>
84992>>>>>>>>>>>>>>>>>    Send Cursor_Wait of Cursor_Control
84993>>>>>>>>>>>>>>>>>
84993>>>>>>>>>>>>>>>>>    Get StartPerfCounter of ghoApplication CPC_OpenFile szFileName to iPerf
84994>>>>>>>>>>>>>>>>>
84994>>>>>>>>>>>>>>>>>    Get vFilePathExists szFileName to iFileExists
84995>>>>>>>>>>>>>>>>>    If (iFileExists<>0) Begin
84997>>>>>>>>>>>>>>>>>
84997>>>>>>>>>>>>>>>>>      Set pbFileLoading to True
84998>>>>>>>>>>>>>>>>>      Send onPreOpenFile szFileName
84999>>>>>>>>>>>>>>>>>
84999>>>>>>>>>>>>>>>>>      Move True To bIsCRLF  // default, we are on windows
85000>>>>>>>>>>>>>>>>>      Get Seq_New_Channel to iChannel
85001>>>>>>>>>>>>>>>>>      If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85003>>>>>>>>>>>>>>>>>        Send Info_Box "No Channel Available for reading from a new file" "Error"
85004>>>>>>>>>>>>>>>>>        function_return CME_FAILURE
85005>>>>>>>>>>>>>>>>>      End
85005>>>>>>>>>>>>>>>>>>
85005>>>>>>>>>>>>>>>>>      // Need to use binary read mode if we want to preserve tab characters and not have automatic tab replacement
85005>>>>>>>>>>>>>>>>>      // First we look at the line ending of the first line for how the document is likely to be formatted.
85005>>>>>>>>>>>>>>>>>      Direct_Input channel iChannel ("binary:"+szFileName)
85007>>>>>>>>>>>>>>>>>      Readln Channel iChannel sLine
85009>>>>>>>>>>>>>>>>>      Close_Input Channel iChannel
85011>>>>>>>>>>>>>>>>>      // As we read in binary mode, the readln reads until it sees a LF, the LF is dropped from the line we
85011>>>>>>>>>>>>>>>>>      // read.
85011>>>>>>>>>>>>>>>>>      If (sLine<>"") Begin
85013>>>>>>>>>>>>>>>>>        If (Pos(CS_CR,sLine)>0) Begin  // if last char at line is CR then strip it
85015>>>>>>>>>>>>>>>>>          If (Right(sLine,1)=CS_CR) Begin
85017>>>>>>>>>>>>>>>>>            Move True To bIsCRLF
85018>>>>>>>>>>>>>>>>>          End
85018>>>>>>>>>>>>>>>>>>
85018>>>>>>>>>>>>>>>>>        End
85018>>>>>>>>>>>>>>>>>>
85018>>>>>>>>>>>>>>>>>        Else Begin
85019>>>>>>>>>>>>>>>>>          Move False To bIsCRLF
85020>>>>>>>>>>>>>>>>>        End
85020>>>>>>>>>>>>>>>>>>
85020>>>>>>>>>>>>>>>>>        Get CM_EnableCRLF bIsCRLF to iVoid
85021>>>>>>>>>>>>>>>>>      End
85021>>>>>>>>>>>>>>>>>>
85021>>>>>>>>>>>>>>>>>
85021>>>>>>>>>>>>>>>>>      //
85021>>>>>>>>>>>>>>>>>      Direct_Input channel iChannel ("binary:"+szFileName)
85023>>>>>>>>>>>>>>>>>      Read_Block Channel iChannel TextData -1
85025>>>>>>>>>>>>>>>>>      Close_Input channel iChannel
85027>>>>>>>>>>>>>>>>>
85027>>>>>>>>>>>>>>>>>      Move 0 To TextData[SizeOfArray(TextData)]  // add a zero at the end
85028>>>>>>>>>>>>>>>>>      If (pbAnsiMode(Self)) Begin
85030>>>>>>>>>>>>>>>>>        // move to a string so we can ToANSI the contents THEN move it back to the uchar array
85030>>>>>>>>>>>>>>>>>CompilerWarnings Off  // One of the few areas where you want ToANSI regardless of DF version
85030>>>>>>>>>>>>>>>>>        Get_Argument_Size to iArgSize
85031>>>>>>>>>>>>>>>>>        Move (SizeOfArray(TextData)+10) To iNewArgSize
85032>>>>>>>>>>>>>>>>>        If (iNewArgSize>iArgSize) Begin
85034>>>>>>>>>>>>>>>>>          Set_Argument_Size iNewArgSize
85035>>>>>>>>>>>>>>>>>>
85035>>>>>>>>>>>>>>>>>        End
85035>>>>>>>>>>>>>>>>>>
85035>>>>>>>>>>>>>>>>>        Move (UCharArrayToString(TextData,SizeOfArray(TextData))) To sTextData
85036>>>>>>>>>>>>>>>>>        Move (ToANSI(sTextData)) To sTextData
85037>>>>>>>>>>>>>>>>>        Move (StringToUCharArray(sTextData)) To TextData
85038>>>>>>>>>>>>>>>>>        Move "" To sTextData
85039>>>>>>>>>>>>>>>>>        If (iNewArgSize>iArgSize) Begin
85041>>>>>>>>>>>>>>>>>          Set_Argument_Size iArgSize
85042>>>>>>>>>>>>>>>>>>
85042>>>>>>>>>>>>>>>>>        End
85042>>>>>>>>>>>>>>>>>>
85042>>>>>>>>>>>>>>>>>CompilerWarnings On
85042>>>>>>>>>>>>>>>>>      End
85042>>>>>>>>>>>>>>>>>>
85042>>>>>>>>>>>>>>>>>      Move (AddressOf(TextData)) To aTextData
85043>>>>>>>>>>>>>>>>>      Send Seq_Release_Channel iChannel
85044>>>>>>>>>>>>>>>>>
85044>>>>>>>>>>>>>>>>>      // SCI_SETTEXT(<unused>, const char *text)
85044>>>>>>>>>>>>>>>>>      If (aTextData<>0) Begin
85046>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETTEXT 0 aTextData
85047>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_EMPTYUNDOBUFFER
85048>>>>>>>>>>>>>>>>>      End
85048>>>>>>>>>>>>>>>>>>
85048>>>>>>>>>>>>>>>>>      Move CME_SUCCESS to iResult
85049>>>>>>>>>>>>>>>>>
85049>>>>>>>>>>>>>>>>>      Send onPostOpenFile szFileName
85050>>>>>>>>>>>>>>>>>      Set pbFileLoading to False
85051>>>>>>>>>>>>>>>>>    End
85051>>>>>>>>>>>>>>>>>>
85051>>>>>>>>>>>>>>>>>    Else Begin
85052>>>>>>>>>>>>>>>>>      Error DfErr_Operator ("File"*szFileName*"cannot be found.")
85053>>>>>>>>>>>>>>>>>>
85053>>>>>>>>>>>>>>>>>    End
85053>>>>>>>>>>>>>>>>>>
85053>>>>>>>>>>>>>>>>>
85053>>>>>>>>>>>>>>>>>    Send StopPerfCounter of ghoApplication iPerf
85054>>>>>>>>>>>>>>>>>
85054>>>>>>>>>>>>>>>>>    Send Cursor_Ready of Cursor_Control
85055>>>>>>>>>>>>>>>>>
85055>>>>>>>>>>>>>>>>>    Function_Return iResult
85056>>>>>>>>>>>>>>>>>  End_Function
85057>>>>>>>>>>>>>>>>>
85057>>>>>>>>>>>>>>>>>  Function CM_InsertText String szText Integer iLine Integer iCol Returns Integer
85059>>>>>>>>>>>>>>>>>    Integer iStartPos
85059>>>>>>>>>>>>>>>>>    Integer iRet
85059>>>>>>>>>>>>>>>>>    String  sBuffer
85059>>>>>>>>>>>>>>>>>    //
85059>>>>>>>>>>>>>>>>>    Move (szText+Character(0)) To sBuffer
85060>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
85061>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_INSERTTEXT iStartPos (AddressOf(sBuffer)) to iRet
85062>>>>>>>>>>>>>>>>>    Move CME_SUCCESS To iRet
85063>>>>>>>>>>>>>>>>>    Function_Return iRet
85064>>>>>>>>>>>>>>>>>  End_Function
85065>>>>>>>>>>>>>>>>>
85065>>>>>>>>>>>>>>>>>  // **WvA 23-07-2003 Modified to fix a crash
85065>>>>>>>>>>>>>>>>>  // Quickly changing workspaces caused the window_handle to
85065>>>>>>>>>>>>>>>>>  // be zero. Sending a message to a window with address 0 is fatal.
85065>>>>>>>>>>>>>>>>>  Function CM_SetText String szText Returns Integer
85067>>>>>>>>>>>>>>>>>    Integer hoWnd iRetVal
85067>>>>>>>>>>>>>>>>>    String  sBuffer
85067>>>>>>>>>>>>>>>>>    Get Window_Handle to hoWnd
85068>>>>>>>>>>>>>>>>>    If (hoWnd) Begin
85070>>>>>>>>>>>>>>>>>      Move (szText+Character(0)) To sBuffer
85071>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_SETTEXT 0 (AddressOf(sBuffer)) to iRetVal
85072>>>>>>>>>>>>>>>>>      Move CME_SUCCESS To iRetVal
85073>>>>>>>>>>>>>>>>>    End
85073>>>>>>>>>>>>>>>>>>
85073>>>>>>>>>>>>>>>>>    Else Begin
85074>>>>>>>>>>>>>>>>>      Send Info_Box "Windows handle is ZXRO"
85075>>>>>>>>>>>>>>>>>      Move CME_FAILURE to iRetVal
85076>>>>>>>>>>>>>>>>>    End
85076>>>>>>>>>>>>>>>>>>
85076>>>>>>>>>>>>>>>>>    Function_Return iRetVal
85077>>>>>>>>>>>>>>>>>  End_Function
85078>>>>>>>>>>>>>>>>>
85078>>>>>>>>>>>>>>>>>  Function CM_EnableWhitespaceDisplay Integer bEnable Returns Integer
85080>>>>>>>>>>>>>>>>>    Integer iRet
85080>>>>>>>>>>>>>>>>>    Integer eStyle
85080>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85082>>>>>>>>>>>>>>>>>      Move SCWS_VISIBLEALWAYS To eStyle
85083>>>>>>>>>>>>>>>>>    End
85083>>>>>>>>>>>>>>>>>>
85083>>>>>>>>>>>>>>>>>    Else Begin
85084>>>>>>>>>>>>>>>>>      Move SCWS_INVISIBLE To eStyle
85085>>>>>>>>>>>>>>>>>    End
85085>>>>>>>>>>>>>>>>>>
85085>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETVIEWWS eStyle to iRet
85086>>>>>>>>>>>>>>>>>    Set DisplayEOLCharacters to eStyle
85087>>>>>>>>>>>>>>>>>    Function_Return iRet
85088>>>>>>>>>>>>>>>>>  End_Function
85089>>>>>>>>>>>>>>>>>
85089>>>>>>>>>>>>>>>>>  Function CM_IsWhitespaceDisplayEnabled Returns Integer
85091>>>>>>>>>>>>>>>>>    Boolean bEnabled
85091>>>>>>>>>>>>>>>>>    Integer eStyle
85091>>>>>>>>>>>>>>>>>
85091>>>>>>>>>>>>>>>>>    Move False to bEnabled
85092>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETVIEWWS to eStyle
85093>>>>>>>>>>>>>>>>>    If (eStyle<>SCWS_INVISIBLE) Begin
85095>>>>>>>>>>>>>>>>>      Move True To bEnabled
85096>>>>>>>>>>>>>>>>>    End
85096>>>>>>>>>>>>>>>>>>
85096>>>>>>>>>>>>>>>>>    Function_Return bEnabled
85097>>>>>>>>>>>>>>>>>  End_Function
85098>>>>>>>>>>>>>>>>>
85098>>>>>>>>>>>>>>>>>  Procedure ShowIndentationGuides
85100>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
85101>>>>>>>>>>>>>>>>>  End_Procedure
85102>>>>>>>>>>>>>>>>>  Function CM_IsIndentationGuidesEnabled Returns Integer
85104>>>>>>>>>>>>>>>>>    Integer eStyle
85104>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETINDENTATIONGUIDES to eStyle
85105>>>>>>>>>>>>>>>>>    Function_Return eStyle
85106>>>>>>>>>>>>>>>>>  End_Function
85107>>>>>>>>>>>>>>>>>  Procedure ToggleIndentationGuides
85109>>>>>>>>>>>>>>>>>    Integer eStyle
85109>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETINDENTATIONGUIDES to eStyle
85110>>>>>>>>>>>>>>>>>    If (eStyle) ;      Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_NONE
85113>>>>>>>>>>>>>>>>>    Else ;      Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
85115>>>>>>>>>>>>>>>>>  End_Procedure
85116>>>>>>>>>>>>>>>>>    
85116>>>>>>>>>>>>>>>>>  Procedure ToggleScopeBlocks Integer iMode
85118>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_FOLDALL iMode
85119>>>>>>>>>>>>>>>>>  End_Procedure
85120>>>>>>>>>>>>>>>>>    
85120>>>>>>>>>>>>>>>>>  Function LineHasFoldPoint Integer iLine Returns Boolean
85122>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
85122>>>>>>>>>>>>>>>>>    Integer uFoldLevel
85122>>>>>>>>>>>>>>>>>      
85122>>>>>>>>>>>>>>>>>    Move False To bFoldPoint
85123>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel
85124>>>>>>>>>>>>>>>>>    Move ((uFoldLevel iAnd SC_FOLDLEVELHEADERFLAG)=SC_FOLDLEVELHEADERFLAG) To bFoldPoint
85125>>>>>>>>>>>>>>>>>    Function_Return bFoldPoint
85126>>>>>>>>>>>>>>>>>  End_Function
85127>>>>>>>>>>>>>>>>>    
85127>>>>>>>>>>>>>>>>>  Procedure CodeFoldOnScope String sScope Integer eMode
85129>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
85129>>>>>>>>>>>>>>>>>    Integer iCurrentLine
85129>>>>>>>>>>>>>>>>>    Integer iLine
85129>>>>>>>>>>>>>>>>>    Integer iLineCount
85129>>>>>>>>>>>>>>>>>    Integer iScopeLength
85129>>>>>>>>>>>>>>>>>    String  sLine
85129>>>>>>>>>>>>>>>>>        
85129>>>>>>>>>>>>>>>>>    Get CurrentLine To iCurrentLine
85130>>>>>>>>>>>>>>>>>    Move (Length(sScope)) to iScopeLength
85131>>>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
85132>>>>>>>>>>>>>>>>>    Move (iLineCount-1) To iLine
85133>>>>>>>>>>>>>>>>>    While (iLine>0)
85137>>>>>>>>>>>>>>>>>      If ((iLineCount-1)>iLine) Begin
85139>>>>>>>>>>>>>>>>>        Send GotoLine (iLine+1) // the line has to be visible in order to be able to get the fold level
85140>>>>>>>>>>>>>>>>>      End
85140>>>>>>>>>>>>>>>>>>
85140>>>>>>>>>>>>>>>>>      Get LineHasFoldPoint iLine To bFoldPoint
85141>>>>>>>>>>>>>>>>>      If (bFoldPoint) Begin
85143>>>>>>>>>>>>>>>>>        Get Value Item iLine To sLine
85144>>>>>>>>>>>>>>>>>        Move (lowercase(ltrim(sLine))) To sLine
85145>>>>>>>>>>>>>>>>>        If (Left(sLine,iScopeLength)=sScope) Begin
85147>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_FOLDLINE iLine eMode
85148>>>>>>>>>>>>>>>>>          //Send EditorMessage SCI_SETFOLDEXPANDED iLine (Not(bFold))
85148>>>>>>>>>>>>>>>>>        End
85148>>>>>>>>>>>>>>>>>>
85148>>>>>>>>>>>>>>>>>      End
85148>>>>>>>>>>>>>>>>>>
85148>>>>>>>>>>>>>>>>>      Decrement iLine
85149>>>>>>>>>>>>>>>>>    Loop
85150>>>>>>>>>>>>>>>>>>
85150>>>>>>>>>>>>>>>>>    If (iCurrentLine<iLineCount) Begin
85152>>>>>>>>>>>>>>>>>      Send GotoLine iCurrentLine
85153>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_ENSUREVISIBLE iCurrentLine
85154>>>>>>>>>>>>>>>>>    End
85154>>>>>>>>>>>>>>>>>>
85154>>>>>>>>>>>>>>>>>  End_Procedure
85155>>>>>>>>>>>>>>>>>    
85155>>>>>>>>>>>>>>>>>  Procedure CodeCollapseProcedures
85157>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "procedure " SC_FOLDACTION_CONTRACT
85158>>>>>>>>>>>>>>>>>  End_Procedure
85159>>>>>>>>>>>>>>>>>    
85159>>>>>>>>>>>>>>>>>  Procedure CodeExpandProcedures
85161>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "procedure " SC_FOLDACTION_EXPAND
85162>>>>>>>>>>>>>>>>>  End_Procedure
85163>>>>>>>>>>>>>>>>>    
85163>>>>>>>>>>>>>>>>>  Procedure CodeCollapseFunctions
85165>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "function " SC_FOLDACTION_CONTRACT
85166>>>>>>>>>>>>>>>>>  End_Procedure
85167>>>>>>>>>>>>>>>>>    
85167>>>>>>>>>>>>>>>>>  Procedure CodeExpandFunctions
85169>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "function " SC_FOLDACTION_EXPAND
85170>>>>>>>>>>>>>>>>>  End_Procedure
85171>>>>>>>>>>>>>>>>>    
85171>>>>>>>>>>>>>>>>>  Procedure CodeCollapseObjects
85173>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "object " SC_FOLDACTION_CONTRACT
85174>>>>>>>>>>>>>>>>>  End_Procedure
85175>>>>>>>>>>>>>>>>>    
85175>>>>>>>>>>>>>>>>>  Procedure CodeExpandObjects
85177>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "object " SC_FOLDACTION_EXPAND
85178>>>>>>>>>>>>>>>>>  End_Procedure
85179>>>>>>>>>>>>>>>>>    
85179>>>>>>>>>>>>>>>>>  Procedure CodeCollapseClasses
85181>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "class " SC_FOLDACTION_CONTRACT
85182>>>>>>>>>>>>>>>>>  End_Procedure
85183>>>>>>>>>>>>>>>>>    
85183>>>>>>>>>>>>>>>>>  Procedure CodeExpandClasses
85185>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "class " SC_FOLDACTION_EXPAND
85186>>>>>>>>>>>>>>>>>  End_Procedure
85187>>>>>>>>>>>>>>>>>    
85187>>>>>>>>>>>>>>>>>  Procedure CodeCollapseLineComments
85189>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "//" SC_FOLDACTION_CONTRACT
85190>>>>>>>>>>>>>>>>>  End_Procedure
85191>>>>>>>>>>>>>>>>>    
85191>>>>>>>>>>>>>>>>>  Procedure CodeExpandLineComments
85193>>>>>>>>>>>>>>>>>    Send CodeFoldOnScope "//" SC_FOLDACTION_EXPAND
85194>>>>>>>>>>>>>>>>>  End_Procedure
85195>>>>>>>>>>>>>>>>>
85195>>>>>>>>>>>>>>>>>  Procedure SelectTillEndOfLine Integer iMode
85197>>>>>>>>>>>>>>>>>    Integer iVirtualSpace
85197>>>>>>>>>>>>>>>>>    Boolean bBlockEdit
85197>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETSELEOLFILLED iMode
85198>>>>>>>>>>>>>>>>>    Move SCVS_NONE to iVirtualSpace
85199>>>>>>>>>>>>>>>>>    Move False     to bBlockEdit
85200>>>>>>>>>>>>>>>>>    If (iMode) Begin
85202>>>>>>>>>>>>>>>>>      Move (SCVS_RECTANGULARSELECTION+SCVS_USERACCESSIBLE) to iVirtualSpace
85203>>>>>>>>>>>>>>>>>      Move True To bBlockEdit
85204>>>>>>>>>>>>>>>>>    End
85204>>>>>>>>>>>>>>>>>>
85204>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETVIRTUALSPACEOPTIONS iVirtualSpace
85205>>>>>>>>>>>>>>>>>    // This supposedly supports blockedit as in codemax, but it is extremely buggy, let's roll it ourself.
85205>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETADDITIONALSELECTIONTYPING bBlockEdit
85206>>>>>>>>>>>>>>>>>  End_Procedure
85207>>>>>>>>>>>>>>>>>
85207>>>>>>>>>>>>>>>>>  Function CM_EnableTabExpand Integer bEnable  Returns Integer
85209>>>>>>>>>>>>>>>>>    Integer iRet
85209>>>>>>>>>>>>>>>>>    // bEnable = tabs change into spaces
85209>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETUSETABS (not(bEnable)) to iRet
85210>>>>>>>>>>>>>>>>>    Function_Return iRet
85211>>>>>>>>>>>>>>>>>  End_Function
85212>>>>>>>>>>>>>>>>>  Function CM_IsTabExpandEnabled Returns Integer
85214>>>>>>>>>>>>>>>>>    Boolean bUseTabs
85214>>>>>>>>>>>>>>>>>
85214>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS to bUseTabs
85215>>>>>>>>>>>>>>>>>    Function_Return (not(bUseTabs))
85216>>>>>>>>>>>>>>>>>  End_Function
85217>>>>>>>>>>>>>>>>>
85217>>>>>>>>>>>>>>>>>  Function CM_SetTabSize Integer iTabSize Returns Integer
85219>>>>>>>>>>>>>>>>>
85219>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETTABWIDTH iTabSize
85220>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85221>>>>>>>>>>>>>>>>>  End_Function
85222>>>>>>>>>>>>>>>>>
85222>>>>>>>>>>>>>>>>>  Function CM_GetTabSize Returns Integer
85224>>>>>>>>>>>>>>>>>    Integer iSize
85224>>>>>>>>>>>>>>>>>
85224>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH To iSize
85225>>>>>>>>>>>>>>>>>    Function_Return iSize
85226>>>>>>>>>>>>>>>>>  End_Function
85227>>>>>>>>>>>>>>>>>
85227>>>>>>>>>>>>>>>>>  Function CM_SetReadOnly Integer bReadOnly Returns Integer
85229>>>>>>>>>>>>>>>>>
85229>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETREADONLY bReadOnly
85230>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85231>>>>>>>>>>>>>>>>>  End_Function
85232>>>>>>>>>>>>>>>>>
85232>>>>>>>>>>>>>>>>>  Procedure Set Enabled_State Boolean bEnabled
85234>>>>>>>>>>>>>>>>>    Integer iRet
85234>>>>>>>>>>>>>>>>>    Get CM_SetReadOnly (not(bEnabled)) to iRet
85235>>>>>>>>>>>>>>>>>  End_Procedure
85236>>>>>>>>>>>>>>>>>
85236>>>>>>>>>>>>>>>>>  Function CM_IsReadOnly Returns Integer
85238>>>>>>>>>>>>>>>>>    Boolean bReadOnly
85238>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETREADONLY To bReadOnly
85239>>>>>>>>>>>>>>>>>    Function_Return bReadOnly
85240>>>>>>>>>>>>>>>>>  End_Function
85241>>>>>>>>>>>>>>>>>
85241>>>>>>>>>>>>>>>>>  // Does not exist in scintilla
85241>>>>>>>>>>>>>>>>>  //
85241>>>>>>>>>>>>>>>>>  // Line tooltips are:
85241>>>>>>>>>>>>>>>>>  // enable or disable the display of a tooltip window showing the topmost visible line number while scrolling with the vertical scrollbar
85241>>>>>>>>>>>>>>>>>  //    Function CM_EnableLineToolTips Integer bEnable Returns Integer
85241>>>>>>>>>>>>>>>>>  //    Function CM_IsLineToolTipsEnabled Returns Integer
85241>>>>>>>>>>>>>>>>>
85241>>>>>>>>>>>>>>>>>  // codemax: CMM_ENABLELEFTMARGIN
85241>>>>>>>>>>>>>>>>>  // show or hide the left margin display area. The left margin area is used for line selection and the display of bookmarks.
85241>>>>>>>>>>>>>>>>>  // scintilla has 5 margins, by default only margin 1 is set to 20 pixels, we keep it simple for now and
85241>>>>>>>>>>>>>>>>>  // pretend we only have 1 margin. (MARGIN_CODE_FOLDING=1)
85241>>>>>>>>>>>>>>>>>  Function CM_EnableLeftMargin Integer bEnable Returns Integer
85243>>>>>>>>>>>>>>>>>    Integer iWidth
85243>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85245>>>>>>>>>>>>>>>>>      Move 20 To iWidth
85246>>>>>>>>>>>>>>>>>    End
85246>>>>>>>>>>>>>>>>>>
85246>>>>>>>>>>>>>>>>>    Else Begin
85247>>>>>>>>>>>>>>>>>      Move 0 To iWidth
85248>>>>>>>>>>>>>>>>>    End
85248>>>>>>>>>>>>>>>>>>
85248>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING iWidth
85249>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85250>>>>>>>>>>>>>>>>>  End_Function
85251>>>>>>>>>>>>>>>>>  Function CM_IsLeftMarginEnabled Returns Integer
85253>>>>>>>>>>>>>>>>>    Integer iWidth
85253>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_CODE_FOLDING to iWidth
85254>>>>>>>>>>>>>>>>>    Function_Return (iWidth<>0)
85255>>>>>>>>>>>>>>>>>  End_Function
85256>>>>>>>>>>>>>>>>>
85256>>>>>>>>>>>>>>>>>  Procedure Set DisplayEOLCharacters Boolean bEnabled
85258>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETVIEWEOL   bEnabled               // show end of line characters
85259>>>>>>>>>>>>>>>>>  End_Procedure
85260>>>>>>>>>>>>>>>>>
85260>>>>>>>>>>>>>>>>>  Function DisplayEOLCharacters Returns Boolean
85262>>>>>>>>>>>>>>>>>    Boolean bEnabled
85262>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETVIEWEOL to bEnabled
85263>>>>>>>>>>>>>>>>>    Function_Return bEnabled
85264>>>>>>>>>>>>>>>>>  End_Function
85265>>>>>>>>>>>>>>>>>
85265>>>>>>>>>>>>>>>>>  Procedure WriteBlock Integer iChannel Address aTextData Integer iPosition Integer iBlockSize
85267>>>>>>>>>>>>>>>>>    Boolean bOk
85267>>>>>>>>>>>>>>>>>    String  sBlock
85267>>>>>>>>>>>>>>>>>
85267>>>>>>>>>>>>>>>>>    Move ""   To sBlock
85268>>>>>>>>>>>>>>>>>    Move (ZeroString(iBlockSize)) To sBlock
85269>>>>>>>>>>>>>>>>>    Move (memcopy(AddressOf(sBlock), aTextData+iPosition, iBlockSize)) To bOk
85270>>>>>>>>>>>>>>>>>    If (pbAnsiMode(Self)) Begin
85272>>>>>>>>>>>>>>>>>CompilerWarnings Off  // One of the few areas where you want ToANSI regardless of DF version
85272>>>>>>>>>>>>>>>>>      // By SVN on 23/05/2017 -- National Languages support
85272>>>>>>>>>>>>>>>>>      Write Channel iChannel (ToOEM(sBlock))
85274>>>>>>>>>>>>>>>>>CompilerWarnings On
85274>>>>>>>>>>>>>>>>>    End
85274>>>>>>>>>>>>>>>>>>
85274>>>>>>>>>>>>>>>>>    Else Begin
85275>>>>>>>>>>>>>>>>>      Write Channel iChannel sBlock
85277>>>>>>>>>>>>>>>>>    End
85277>>>>>>>>>>>>>>>>>>
85277>>>>>>>>>>>>>>>>>  End_Procedure
85278>>>>>>>>>>>>>>>>>
85278>>>>>>>>>>>>>>>>>  // An application sends CMM_SAVEFILE to save the buffer contents to a specific file.
85278>>>>>>>>>>>>>>>>>  // bClearUndo
85278>>>>>>>>>>>>>>>>>  // If TRUE, the undo buffer is cleared if the file is successfully saved.
85278>>>>>>>>>>>>>>>>>  // If FALSE, the undo buffer is untouched and the user can undo past the last file save operation.
85278>>>>>>>>>>>>>>>>>  //CME_SUCCESS=1
85278>>>>>>>>>>>>>>>>>  Function CM_SaveFile String szFileName Integer bClearUndo  Returns Integer
85280>>>>>>>>>>>>>>>>>    Integer iBlockSize
85280>>>>>>>>>>>>>>>>>    Integer iChannel
85280>>>>>>>>>>>>>>>>>    Integer iPosition
85280>>>>>>>>>>>>>>>>>    Integer iResult
85280>>>>>>>>>>>>>>>>>    Address aTextData
85280>>>>>>>>>>>>>>>>>    Integer iTextLength
85280>>>>>>>>>>>>>>>>>
85280>>>>>>>>>>>>>>>>>    Send Cursor_Wait of Cursor_Control
85281>>>>>>>>>>>>>>>>>    Move 0    To iPosition
85282>>>>>>>>>>>>>>>>>    Move 1024 To iBlockSize
85283>>>>>>>>>>>>>>>>>    Move True To bClearUndo // looks like this was ignored by codemax and always true
85284>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETREADONLY 1
85285>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCHARACTERPOINTER to aTextData
85286>>>>>>>>>>>>>>>>>    Move (CStringLength(aTextData)) To iTextLength
85287>>>>>>>>>>>>>>>>>    If (iTextLength>=0) Begin
85289>>>>>>>>>>>>>>>>>
85289>>>>>>>>>>>>>>>>>      Get Seq_New_Channel to iChannel
85290>>>>>>>>>>>>>>>>>      If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85292>>>>>>>>>>>>>>>>>        Send Info_Box "No Channel Available for saving file" "Error"
85293>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETREADONLY 0
85294>>>>>>>>>>>>>>>>>        function_return CME_FAILURE
85295>>>>>>>>>>>>>>>>>      End
85295>>>>>>>>>>>>>>>>>>
85295>>>>>>>>>>>>>>>>>
85295>>>>>>>>>>>>>>>>>      Direct_Output channel iChannel szFileName
85297>>>>>>>>>>>>>>>>>      While ((iPosition+iBlockSize)<iTextLength)
85301>>>>>>>>>>>>>>>>>        Send WriteBlock iChannel aTextData iPosition iBlockSize
85302>>>>>>>>>>>>>>>>>
85302>>>>>>>>>>>>>>>>>        Move (iPosition+iBlockSize) To iPosition
85303>>>>>>>>>>>>>>>>>      Loop
85304>>>>>>>>>>>>>>>>>>
85304>>>>>>>>>>>>>>>>>      If (iPosition<iTextLength) Begin
85306>>>>>>>>>>>>>>>>>        Send WriteBlock iChannel aTextData iPosition (iTextLength-iPosition)
85307>>>>>>>>>>>>>>>>>      End
85307>>>>>>>>>>>>>>>>>>
85307>>>>>>>>>>>>>>>>>      Close_Output Channel iChannel
85309>>>>>>>>>>>>>>>>>      Send Seq_Release_Channel iChannel
85310>>>>>>>>>>>>>>>>>
85310>>>>>>>>>>>>>>>>>      If (bClearUndo) Begin
85312>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSAVEPOINT
85313>>>>>>>>>>>>>>>>>      End
85313>>>>>>>>>>>>>>>>>>
85313>>>>>>>>>>>>>>>>>
85313>>>>>>>>>>>>>>>>>      Move CME_SUCCESS To iResult
85314>>>>>>>>>>>>>>>>>    End
85314>>>>>>>>>>>>>>>>>>
85314>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETREADONLY 0
85315>>>>>>>>>>>>>>>>>    Send Cursor_Ready of Cursor_Control
85316>>>>>>>>>>>>>>>>>    Function_Return iResult
85317>>>>>>>>>>>>>>>>>  End_Function
85318>>>>>>>>>>>>>>>>>
85318>>>>>>>>>>>>>>>>>  // This returns the number of lines in the document.
85318>>>>>>>>>>>>>>>>>  // An empty document contains 1 line.
85318>>>>>>>>>>>>>>>>>  // A document holding only an end of line sequence has 2 lines.
85318>>>>>>>>>>>>>>>>>  Function SC_LineCount Returns Integer
85320>>>>>>>>>>>>>>>>>    Integer iLineCount
85320>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINECOUNT to iLineCount
85321>>>>>>>>>>>>>>>>>    Function_Return iLineCount
85322>>>>>>>>>>>>>>>>>  End_Function
85323>>>>>>>>>>>>>>>>>
85323>>>>>>>>>>>>>>>>>  // An application sends CMM_GETLINELENGTH to determine the length of a specific line in the edit buffer
85323>>>>>>>>>>>>>>>>>  // nLine
85323>>>>>>>>>>>>>>>>>  // The zero-based index of the line to retrieve the length of.
85323>>>>>>>>>>>>>>>>>  // bLogical
85323>>>>>>>>>>>>>>>>>  // TRUE to return the number of logical characters. FALSE to return the number of bytes (or double-bytes if Unicode version used).
85323>>>>>>>>>>>>>>>>>  // SCI_LINELENGTH returns bytes, we ignore bLogical
85323>>>>>>>>>>>>>>>>>  Function CM_GetLineLength Integer iLine Integer bLogical Returns Integer
85325>>>>>>>>>>>>>>>>>    Integer iLineLength
85325>>>>>>>>>>>>>>>>>    Integer iEOLPos
85325>>>>>>>>>>>>>>>>>    Integer iStartPos
85325>>>>>>>>>>>>>>>>>    // SCI_LINELENGTH also counts the EOL characters, not always handy
85325>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_LINELENGTH iLine to iLineLength
85325>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINEENDPOSITION iLine to iEOLPos
85326>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iStartPos
85327>>>>>>>>>>>>>>>>>    Move (iEOLPos-iStartPos) To iLineLength
85328>>>>>>>>>>>>>>>>>    Function_Return iLineLength
85329>>>>>>>>>>>>>>>>>  End_Function
85330>>>>>>>>>>>>>>>>>
85330>>>>>>>>>>>>>>>>>  // An application sends CMM_GETLINE to retrieve the text on a specific line.
85330>>>>>>>>>>>>>>>>>  // nLine - The zero-based line number of the line text to retrieve. nLine must be the index of a valid line number.
85330>>>>>>>>>>>>>>>>>  // The number of lines in the buffer can be determined with CMM_GETLINECOUNT.
85330>>>>>>>>>>>>>>>>>  // pszBuff - A pointer to a TCHAR buffer where to receive the line text.
85330>>>>>>>>>>>>>>>>>  // The necessary buffer size can be determined by first sending CMM_GETLINELENGTH. pszBuff must not be NULL.
85330>>>>>>>>>>>>>>>>>  Function CM_GetLine Integer iLine Returns String
85332>>>>>>>>>>>>>>>>>    Integer iEOLPos
85332>>>>>>>>>>>>>>>>>    Integer iStartPos
85332>>>>>>>>>>>>>>>>>    Integer iLineLength
85332>>>>>>>>>>>>>>>>>    Integer iRet
85332>>>>>>>>>>>>>>>>>    String  sBuffer
85332>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
85332>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
85332>>>>>>>>>>>>>>>>>
85332>>>>>>>>>>>>>>>>>    // Can't use sci_linelength and sci_getline as we need the text without EOL characters
85332>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_LINELENGTH iLine to iLineLength
85332>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) to iRet
85332>>>>>>>>>>>>>>>>>    Move "" To sBuffer
85333>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iStartPos
85334>>>>>>>>>>>>>>>>>    If (iStartPos>-1) Begin
85336>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETLINEENDPOSITION iLine to iEOLPos
85337>>>>>>>>>>>>>>>>>      Move (iEOLPos-iStartPos) To iLineLength
85338>>>>>>>>>>>>>>>>>      If (iLineLength<>0) Begin
85340>>>>>>>>>>>>>>>>>        Move iStartPos To Sel.chrg.cpMin
85341>>>>>>>>>>>>>>>>>        Move iEOLPos   To Sel.chrg.cpMax
85342>>>>>>>>>>>>>>>>>        Move (ZeroString(iLineLength+1)) To sBuffer
85343>>>>>>>>>>>>>>>>>        Move (AddressOf(sBuffer)) To Sel.lpstrText
85344>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
85345>>>>>>>>>>>>>>>>>        Move (CString(sBuffer)) To sBuffer
85346>>>>>>>>>>>>>>>>>      End
85346>>>>>>>>>>>>>>>>>>
85346>>>>>>>>>>>>>>>>>    End
85346>>>>>>>>>>>>>>>>>>
85346>>>>>>>>>>>>>>>>>    Function_Return sBuffer
85347>>>>>>>>>>>>>>>>>  End_Function
85348>>>>>>>>>>>>>>>>>
85348>>>>>>>>>>>>>>>>>  //
85348>>>>>>>>>>>>>>>>>  // This gets the complete line including the EOL character(s) of that line
85348>>>>>>>>>>>>>>>>>  //
85348>>>>>>>>>>>>>>>>>  Function SC_GetLine Integer iLine Returns String
85350>>>>>>>>>>>>>>>>>    Integer iLineLength
85350>>>>>>>>>>>>>>>>>    Integer iRet
85350>>>>>>>>>>>>>>>>>    String  sLine
85350>>>>>>>>>>>>>>>>>    String  szText
85350>>>>>>>>>>>>>>>>>
85350>>>>>>>>>>>>>>>>>    Move "" to szText
85351>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
85352>>>>>>>>>>>>>>>>>    Move (ZeroString(iLineLength)) To szText
85353>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) To iRet
85354>>>>>>>>>>>>>>>>>    Move (CString(szText)) To sLine
85355>>>>>>>>>>>>>>>>>    Function_Return sLine
85356>>>>>>>>>>>>>>>>>  End_Function
85357>>>>>>>>>>>>>>>>>
85357>>>>>>>>>>>>>>>>>  //
85357>>>>>>>>>>>>>>>>>  // An application sends CMM_GETWORDLENGTH to calculate the length of the word at a specific position in the buffer.
85357>>>>>>>>>>>>>>>>>  // pPos
85357>>>>>>>>>>>>>>>>>  // Pointer to a CM_POSITION structure that contains the buffer position of the word to be retrieved.
85357>>>>>>>>>>>>>>>>>  // If NULL, the current caret position is used.
85357>>>>>>>>>>>>>>>>>  // The hammer ONLY uses it internally in CM_GetWord, so we discard it and add it directly to
85357>>>>>>>>>>>>>>>>>  // CM_GetWord.
85357>>>>>>>>>>>>>>>>>  //Function CM_GetWordLength Integer pPos Integer bLogical Returns Integer
85357>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETWORDLENGTH,  ( pPos ), ( bLogical ) ) )
85357>>>>>>>>>>>>>>>>>  //End_Function
85357>>>>>>>>>>>>>>>>>
85357>>>>>>>>>>>>>>>>>  // An application sends CMM_GETWORD to retrieve the word at a specific position in the buffer.
85357>>>>>>>>>>>>>>>>>  Function CM_GetWord Integer iLine Integer iCol Returns String
85359>>>>>>>>>>>>>>>>>    Integer iPos
85359>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
85359>>>>>>>>>>>>>>>>>    Integer iRet iSize
85359>>>>>>>>>>>>>>>>>    String  sBuffer
85359>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
85359>>>>>>>>>>>>>>>>>    tSci_TextRange Sel
85359>>>>>>>>>>>>>>>>>
85359>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
85360>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_WORDSTARTPOSITION iPos True to iStartPos
85361>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_WORDENDPOSITION   iPos True to iEndPos
85362>>>>>>>>>>>>>>>>>    If (iStartPos>=0 and iStartPos<>iEndPos) Begin
85364>>>>>>>>>>>>>>>>>      Move iStartPos To Sel.chrg.cpMin
85365>>>>>>>>>>>>>>>>>      Move iEndPos   To Sel.chrg.cpMax
85366>>>>>>>>>>>>>>>>>      Move ((iEndPos-iStartPos)+2) To iSize
85367>>>>>>>>>>>>>>>>>      Move (ZeroString(iSize)) To sBuffer
85368>>>>>>>>>>>>>>>>>      Move (AddressOf(sBuffer)) To Sel.lpstrText
85369>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
85370>>>>>>>>>>>>>>>>>      Move (CString(sBuffer)) To sBuffer
85371>>>>>>>>>>>>>>>>>    End
85371>>>>>>>>>>>>>>>>>>
85371>>>>>>>>>>>>>>>>>    Else Begin
85372>>>>>>>>>>>>>>>>>      Move "" To sBuffer
85373>>>>>>>>>>>>>>>>>    End
85373>>>>>>>>>>>>>>>>>>
85373>>>>>>>>>>>>>>>>>    Function_Return sBuffer
85374>>>>>>>>>>>>>>>>>  End_Function
85375>>>>>>>>>>>>>>>>>  // Gets the current word in a code max way.
85375>>>>>>>>>>>>>>>>>  Function CM_GetCurrentWord Returns String
85377>>>>>>>>>>>>>>>>>    String  sWord
85377>>>>>>>>>>>>>>>>>    Integer iRet
85377>>>>>>>>>>>>>>>>>    Get CM_GetSel False                                         to iRet
85378>>>>>>>>>>>>>>>>>    Get CM_GetWord (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
85379>>>>>>>>>>>>>>>>>    Function_Return sWord
85380>>>>>>>>>>>>>>>>>  End_Function
85381>>>>>>>>>>>>>>>>>
85381>>>>>>>>>>>>>>>>>  // Selfmade word getter, which doesnt stop the word on a "."
85381>>>>>>>>>>>>>>>>>  // So its easy to use it for getting a file under cursor.
85381>>>>>>>>>>>>>>>>>  Function CM_GetWordIncludingDot Integer iLine Integer iCol Returns String
85383>>>>>>>>>>>>>>>>>    Integer iStart iEnd iLen iC
85383>>>>>>>>>>>>>>>>>    String sLine
85383>>>>>>>>>>>>>>>>>    Get value item iLine    to sLine
85384>>>>>>>>>>>>>>>>>    Move (Length(sLine))    to iLen
85385>>>>>>>>>>>>>>>>>    For iEnd from (iCol+1) to iLen
85391>>>>>>>>>>>>>>>>>>
85391>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iEnd)) Eq " " Break
85394>>>>>>>>>>>>>>>>>    Loop
85395>>>>>>>>>>>>>>>>>>
85395>>>>>>>>>>>>>>>>>    For iC from 1 to iCol
85401>>>>>>>>>>>>>>>>>>
85401>>>>>>>>>>>>>>>>>      Move (iCol-iC+1)            to iStart
85402>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iStart)) Eq " " Break
85405>>>>>>>>>>>>>>>>>    Loop
85406>>>>>>>>>>>>>>>>>>
85406>>>>>>>>>>>>>>>>>    Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
85407>>>>>>>>>>>>>>>>>  End_Function
85408>>>>>>>>>>>>>>>>>  // Gets the current word under the cursor, but does not stop at a dot (.)
85408>>>>>>>>>>>>>>>>>  // only a space character ends the word.
85408>>>>>>>>>>>>>>>>>  Function CM_GetCurrentWordIncludingDot Returns String
85410>>>>>>>>>>>>>>>>>    String  sWord
85410>>>>>>>>>>>>>>>>>    Integer iRet
85410>>>>>>>>>>>>>>>>>    Get CM_GetSel False                                         to iRet
85411>>>>>>>>>>>>>>>>>    Get CM_GetWordIncludingDot (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
85412>>>>>>>>>>>>>>>>>    Function_Return sWord
85413>>>>>>>>>>>>>>>>>  End_Function
85414>>>>>>>>>>>>>>>>>
85414>>>>>>>>>>>>>>>>>  //
85414>>>>>>>>>>>>>>>>>  // Gets the whole variable as a word.
85414>>>>>>>>>>>>>>>>>  //
85414>>>>>>>>>>>>>>>>>  // Tried using CM_GetWordIncludingDot, but that function also includes () characters as part of the
85414>>>>>>>>>>>>>>>>>  // word and that's a problem. We really only want the variable "as a word".
85414>>>>>>>>>>>>>>>>>  //
85414>>>>>>>>>>>>>>>>>  Function WordVariable Integer iLine Integer iPos Returns String
85416>>>>>>>>>>>>>>>>>    Integer iWordCharLength
85416>>>>>>>>>>>>>>>>>    Integer iVoid
85416>>>>>>>>>>>>>>>>>    String  sDefaultWordChars // default characters that are part of a word
85416>>>>>>>>>>>>>>>>>    String  sWordChars
85416>>>>>>>>>>>>>>>>>    String  sWord
85416>>>>>>>>>>>>>>>>>
85416>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETWORDCHARS To iWordCharLength
85417>>>>>>>>>>>>>>>>>    Move (ZeroString(iWordCharLength)) To sDefaultWordChars
85418>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETWORDCHARS 0 (AddressOf(sDefaultWordChars)) To iVoid
85419>>>>>>>>>>>>>>>>>    Move (sDefaultWordChars+".") To sWordChars
85420>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETWORDCHARS 0 (AddressOf(sWordChars))
85421>>>>>>>>>>>>>>>>>    Get CM_GetWord iLine iPos to sWord
85422>>>>>>>>>>>>>>>>>    // restore default
85422>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETWORDCHARS 0 (AddressOf(sDefaultWordChars))
85423>>>>>>>>>>>>>>>>>    Function_Return sWord
85424>>>>>>>>>>>>>>>>>  End_Function
85425>>>>>>>>>>>>>>>>>
85425>>>>>>>>>>>>>>>>>  // **WvA; Really, why? WHY is this here?
85425>>>>>>>>>>>>>>>>>  //@RRS Selfmade word getter, which find the word from where the cursor is
85425>>>>>>>>>>>>>>>>>  Function CM_GetWord3 Integer iLine Integer iCol Returns String
85427>>>>>>>>>>>>>>>>>    Integer iStart iEnd iLen iC
85427>>>>>>>>>>>>>>>>>    String sLine
85427>>>>>>>>>>>>>>>>>
85427>>>>>>>>>>>>>>>>>    Get value item iLine    to sLine
85428>>>>>>>>>>>>>>>>>    Move (Length(sLine))    to iLen
85429>>>>>>>>>>>>>>>>>
85429>>>>>>>>>>>>>>>>>    Move iCol to iEnd
85430>>>>>>>>>>>>>>>>>    For iC from 1 to iCol
85436>>>>>>>>>>>>>>>>>>
85436>>>>>>>>>>>>>>>>>      Move (iCol-iC+1) to iStart
85437>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iStart)) Eq " " Break
85440>>>>>>>>>>>>>>>>>    Loop
85441>>>>>>>>>>>>>>>>>>
85441>>>>>>>>>>>>>>>>>    Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
85442>>>>>>>>>>>>>>>>>  End_Function
85443>>>>>>>>>>>>>>>>>
85443>>>>>>>>>>>>>>>>>
85443>>>>>>>>>>>>>>>>>  // **WvA; Again, why? WHY is this here, what is wrong with GetCurrentWord itself?
85443>>>>>>>>>>>>>>>>>  //@RRS Gets the current word in selfmade way.
85443>>>>>>>>>>>>>>>>>  Function CM_GetCurrentWord3 Returns String
85445>>>>>>>>>>>>>>>>>    String  sWord
85445>>>>>>>>>>>>>>>>>    Integer iRet
85445>>>>>>>>>>>>>>>>>    Get CM_GetSel False                                        to iRet
85446>>>>>>>>>>>>>>>>>    Get CM_GetWord3 (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
85447>>>>>>>>>>>>>>>>>    Function_Return sWord
85448>>>>>>>>>>>>>>>>>  End_Function
85449>>>>>>>>>>>>>>>>>
85449>>>>>>>>>>>>>>>>>  //@ RRS New Procedure Used by isReasonForFieldList
85449>>>>>>>>>>>>>>>>>  Procedure AdjustFileNameCase String sNew
85451>>>>>>>>>>>>>>>>>    String  sWord sTmp sLine
85451>>>>>>>>>>>>>>>>>    Integer iRet iLine iCol iColStart
85451>>>>>>>>>>>>>>>>>    Integer iStart iEnd iLen iC iPos iTmp
85451>>>>>>>>>>>>>>>>>
85451>>>>>>>>>>>>>>>>>    Move (piSelEndLine(Self))  to iLine
85452>>>>>>>>>>>>>>>>>    Move (piSelEndCol(Self))   to iCol
85453>>>>>>>>>>>>>>>>>
85453>>>>>>>>>>>>>>>>>    Get value item iLine to sLine
85454>>>>>>>>>>>>>>>>>    Move (Length(sLine)) to iLen
85455>>>>>>>>>>>>>>>>>
85455>>>>>>>>>>>>>>>>>    For iEnd from iCol to iLen
85461>>>>>>>>>>>>>>>>>>
85461>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iEnd)) Eq " " Break
85464>>>>>>>>>>>>>>>>>    Loop
85465>>>>>>>>>>>>>>>>>>
85465>>>>>>>>>>>>>>>>>    For iC from 1 to iCol
85471>>>>>>>>>>>>>>>>>>
85471>>>>>>>>>>>>>>>>>      Move (iCol-iC+1)            to iStart
85472>>>>>>>>>>>>>>>>>      If (Mid(sLine,1,iStart)) Eq " " Break
85475>>>>>>>>>>>>>>>>>    Loop
85476>>>>>>>>>>>>>>>>>>
85476>>>>>>>>>>>>>>>>>    Move sLine to sTmp
85477>>>>>>>>>>>>>>>>>    Repeat
85477>>>>>>>>>>>>>>>>>>
85477>>>>>>>>>>>>>>>>>      Move (Pos(Uppercase(sNew),Uppercase(sTmp))) to iTmp
85478>>>>>>>>>>>>>>>>>      If (iTmp) Begin
85480>>>>>>>>>>>>>>>>>        Move (Remove(sTmp,1,iTmp)) to sTmp
85481>>>>>>>>>>>>>>>>>        Move (iTmp+iPos) to iPos
85482>>>>>>>>>>>>>>>>>      End
85482>>>>>>>>>>>>>>>>>>
85482>>>>>>>>>>>>>>>>>    Until ((iPos>=iStart) or (iTmp=0))
85484>>>>>>>>>>>>>>>>>    //@if (iPos>=iStart) Move iPos to iStart
85484>>>>>>>>>>>>>>>>>    If (iPos) ;      Move iPos to iStart
85487>>>>>>>>>>>>>>>>>    Move (Overstrike(sNew,sLine,iStart)) to sLine
85488>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
85489>>>>>>>>>>>>>>>>>    Get CM_DeleteLine iLine to iRet
85490>>>>>>>>>>>>>>>>>    Get CM_InsertLine iLine sLine to iRet
85491>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
85492>>>>>>>>>>>>>>>>>    // our selection just got removed, put back the cursor where we expect it
85492>>>>>>>>>>>>>>>>>    Get CM_SetSel iLine iCol iLine iCol False to iRet
85493>>>>>>>>>>>>>>>>>  End_Procedure
85494>>>>>>>>>>>>>>>>>
85494>>>>>>>>>>>>>>>>>
85494>>>>>>>>>>>>>>>>>  // An application sends the CMM_ADDTEXT message to add the specified text to the end of the edit buffer.
85494>>>>>>>>>>>>>>>>>  //
85494>>>>>>>>>>>>>>>>>  Function CM_AddText String szText Returns Integer
85496>>>>>>>>>>>>>>>>>    Integer iRet
85496>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_APPENDTEXT (Length(szText)) (AddressOf(szText)) to iRet
85497>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85498>>>>>>>>>>>>>>>>>  End_Function
85499>>>>>>>>>>>>>>>>>
85499>>>>>>>>>>>>>>>>>  //
85499>>>>>>>>>>>>>>>>>  // An application sends CMM_DELETELINE to delete a line from the buffer.
85499>>>>>>>>>>>>>>>>>  //
85499>>>>>>>>>>>>>>>>>  Function CM_DeleteLine Integer iLine  Returns Integer
85501>>>>>>>>>>>>>>>>>    Integer iCol
85501>>>>>>>>>>>>>>>>>    Integer iStartPos
85501>>>>>>>>>>>>>>>>>    Integer iLineLength
85501>>>>>>>>>>>>>>>>>    Integer iRet
85501>>>>>>>>>>>>>>>>>
85501>>>>>>>>>>>>>>>>>    Move 0 To iCol
85502>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
85503>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH  iLine                 to iLineLength
85504>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_DELETERANGE iStartPos iLinelength to iRet
85505>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85506>>>>>>>>>>>>>>>>>  End_Function
85507>>>>>>>>>>>>>>>>>
85507>>>>>>>>>>>>>>>>>  //
85507>>>>>>>>>>>>>>>>>  // An application sends CMM_INSERTLINE to insert a line of text into the edit buffer.
85507>>>>>>>>>>>>>>>>>  // iLine
85507>>>>>>>>>>>>>>>>>  // The zero-based index of the line to insert before.
85507>>>>>>>>>>>>>>>>>  // pszText
85507>>>>>>>>>>>>>>>>>  // The text of the line to insert. This text should not contain any carriage returns or linefeeds.
85507>>>>>>>>>>>>>>>>>  //
85507>>>>>>>>>>>>>>>>>  Function CM_InsertLine Integer iLine String szText Returns Integer
85509>>>>>>>>>>>>>>>>>    Integer iCol
85509>>>>>>>>>>>>>>>>>    Integer iStartPos
85509>>>>>>>>>>>>>>>>>    Integer iRet
85509>>>>>>>>>>>>>>>>>    String  sEOLChar
85509>>>>>>>>>>>>>>>>>
85509>>>>>>>>>>>>>>>>>    Move 0 To iCol
85510>>>>>>>>>>>>>>>>>    Get psEOLChar to sEOLChar
85511>>>>>>>>>>>>>>>>>    Move (CString(szText)+sEOLChar+Character(0)) To szText
85512>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
85513>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_INSERTTEXT iStartPos  (AddressOf(sztext)) to iRet
85514>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85515>>>>>>>>>>>>>>>>>  End_Function
85516>>>>>>>>>>>>>>>>>
85516>>>>>>>>>>>>>>>>>  // Gets the active selection and fills it into the properties.
85516>>>>>>>>>>>>>>>>>  // Normalized: True=StartPosition always before EndPosition
85516>>>>>>>>>>>>>>>>>  // CMM_GETSEL
85516>>>>>>>>>>>>>>>>>  Function CM_GetSel Integer bNormalized Returns Integer
85518>>>>>>>>>>>>>>>>>    Integer iRet iLine iCol
85518>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
85518>>>>>>>>>>>>>>>>>
85518>>>>>>>>>>>>>>>>>    // With Scintilla we ignore the bNormalized option as it returns the start position as
85518>>>>>>>>>>>>>>>>>    // smaller anyways.
85518>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONSTART to iStartPos
85519>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEND   to iEndPos
85520>>>>>>>>>>>>>>>>>
85520>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iStartPos to iLine
85521>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iStartPos to iCol
85522>>>>>>>>>>>>>>>>>    Set piSelStartLine  to iLine
85523>>>>>>>>>>>>>>>>>    Set piSelStartCol   to iCol
85524>>>>>>>>>>>>>>>>>    If (iStartPos<>iEndPos) Begin
85526>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iEndPos   to iLine
85527>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCOLUMN        iEndPos   to iCol
85528>>>>>>>>>>>>>>>>>    End
85528>>>>>>>>>>>>>>>>>>
85528>>>>>>>>>>>>>>>>>    Set piSelEndLine  to iLine
85529>>>>>>>>>>>>>>>>>    Set piSelEndCol   to iCol
85530>>>>>>>>>>>>>>>>>    Move CME_SUCCESS To iRet
85531>>>>>>>>>>>>>>>>>    Function_Return iRet
85532>>>>>>>>>>>>>>>>>  End_Function
85533>>>>>>>>>>>>>>>>>
85533>>>>>>>>>>>>>>>>>  //
85533>>>>>>>>>>>>>>>>>  // This returns the current line for the current cursor position.
85533>>>>>>>>>>>>>>>>>  // Beware that the first line is line 0 and not line 1.
85533>>>>>>>>>>>>>>>>>  //
85533>>>>>>>>>>>>>>>>>  Function CurrentLine Returns Integer
85535>>>>>>>>>>>>>>>>>    Integer iPos
85535>>>>>>>>>>>>>>>>>    Integer iLine
85535>>>>>>>>>>>>>>>>>
85535>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS To iPos
85536>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
85537>>>>>>>>>>>>>>>>>    Function_Return iLine
85538>>>>>>>>>>>>>>>>>  End_Function
85539>>>>>>>>>>>>>>>>>
85539>>>>>>>>>>>>>>>>>  Function CurrentColumn Returns Integer
85541>>>>>>>>>>>>>>>>>    Integer iPos
85541>>>>>>>>>>>>>>>>>    Integer iCol
85541>>>>>>>>>>>>>>>>>
85541>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS to iPos
85542>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN     iPos to iCol
85543>>>>>>>>>>>>>>>>>    Function_Return iCol
85544>>>>>>>>>>>>>>>>>  End_Function
85545>>>>>>>>>>>>>>>>>
85545>>>>>>>>>>>>>>>>>  Function CursorPosition Returns Integer
85547>>>>>>>>>>>>>>>>>    Integer iSel iY iX iRet
85547>>>>>>>>>>>>>>>>>    Get CM_GetSel True to iSel
85548>>>>>>>>>>>>>>>>>    Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
85549>>>>>>>>>>>>>>>>>    Move (piPosEndY(Self))                                       to iY
85550>>>>>>>>>>>>>>>>>    Move (piPosEndX(Self))                                       to iX
85551>>>>>>>>>>>>>>>>>
85551>>>>>>>>>>>>>>>>>    Function_Return (MAKEWPARAM(iX, iY))
85552>>>>>>>>>>>>>>>>>  End_Function
85553>>>>>>>>>>>>>>>>>
85553>>>>>>>>>>>>>>>>>  // CMM_SETSEL
85553>>>>>>>>>>>>>>>>>  // bMakeVisible
85553>>>>>>>>>>>>>>>>>  // If TRUE, the selection will be scrolled into view. If FALSE, the window contents will not be scrolled.
85553>>>>>>>>>>>>>>>>>  Function CM_SetSel Integer iStartLine Integer iStartCol Integer iEndLine Integer iEndCol  Integer bMakeVisible Returns Integer
85555>>>>>>>>>>>>>>>>>    Integer iStartPos
85555>>>>>>>>>>>>>>>>>    Integer iEndPos
85555>>>>>>>>>>>>>>>>>    Integer iRet
85555>>>>>>>>>>>>>>>>>
85555>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iStartLine iStartCol to iStartPos
85556>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iEndLine   iEndCol   to iEndPos
85557>>>>>>>>>>>>>>>>>    If (bMakeVisible) Begin
85559>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSEL iStartPos iEndPos
85560>>>>>>>>>>>>>>>>>    End
85560>>>>>>>>>>>>>>>>>>
85560>>>>>>>>>>>>>>>>>    Else Begin
85561>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETEMPTYSELECTION iEndPos  // set caret at end pos to start with and empty previous selections
85562>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONSTART iStartPos
85563>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONEND   iEndPos
85564>>>>>>>>>>>>>>>>>    End
85564>>>>>>>>>>>>>>>>>>
85564>>>>>>>>>>>>>>>>>
85564>>>>>>>>>>>>>>>>>    Move CME_SUCCESS To iRet
85565>>>>>>>>>>>>>>>>>    Function_Return iRet
85566>>>>>>>>>>>>>>>>>  End_Function
85567>>>>>>>>>>>>>>>>>
85567>>>>>>>>>>>>>>>>>  // An application sends CMM_DELETESEL to delete the currently selected text from the buffer.
85567>>>>>>>>>>>>>>>>>  Function CM_DeleteSel Returns Integer
85569>>>>>>>>>>>>>>>>>    Integer iRet
85569>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
85569>>>>>>>>>>>>>>>>>    Integer iLength
85569>>>>>>>>>>>>>>>>>
85569>>>>>>>>>>>>>>>>>    Move CME_FAILURE To iRet
85570>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONSTART to iStartPos
85571>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEND   to iEndPos
85572>>>>>>>>>>>>>>>>>    Move (iEndPos-iStartPos) To iLength
85573>>>>>>>>>>>>>>>>>    If (iLength>0) Begin
85575>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_DELETERANGE iStartPos iLength
85576>>>>>>>>>>>>>>>>>      Move CME_SUCCESS To iRet
85577>>>>>>>>>>>>>>>>>    End
85577>>>>>>>>>>>>>>>>>>
85577>>>>>>>>>>>>>>>>>    Function_Return iRet
85578>>>>>>>>>>>>>>>>>  End_Function
85579>>>>>>>>>>>>>>>>>
85579>>>>>>>>>>>>>>>>>  // An application sends CMM_REPLACESEL to replace the current buffer selection with a body of text
85579>>>>>>>>>>>>>>>>>  Function CM_ReplaceSel String szText  Returns Integer
85581>>>>>>>>>>>>>>>>>    Move (szText+Character(0)) To szText
85582>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_REPLACESEL 0 (AddressOf(szText))
85583>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85584>>>>>>>>>>>>>>>>>  End_Function
85585>>>>>>>>>>>>>>>>>
85585>>>>>>>>>>>>>>>>>  //
85585>>>>>>>>>>>>>>>>>  // ToDo: CM_ExecuteCmd
85585>>>>>>>>>>>>>>>>>  //
85585>>>>>>>>>>>>>>>>>  Function CM_ExecuteCmd Integer wCmd Integer dwCmdData Returns Integer
85587>>>>>>>>>>>>>>>>>    Integer iSCICmd
85587>>>>>>>>>>>>>>>>>    Integer iLine
85587>>>>>>>>>>>>>>>>>    Integer iVoid
85587>>>>>>>>>>>>>>>>>
85587>>>>>>>>>>>>>>>>>    Move 0 To iSCICmd
85588>>>>>>>>>>>>>>>>>    Case Begin
85588>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_SELECTLINE)
85590>>>>>>>>>>>>>>>>>        Get piSelEndLine to iLine
85591>>>>>>>>>>>>>>>>>        Get CM_SelectLine iLine True to iVoid
85592>>>>>>>>>>>>>>>>>        Case Break
85593>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_LINEDELETE)
85596>>>>>>>>>>>>>>>>>        Get piSelEndLine to iLine
85597>>>>>>>>>>>>>>>>>        Get CM_DeleteLine iLine to iVoid
85598>>>>>>>>>>>>>>>>>        Case Break
85599>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_Find)
85602>>>>>>>>>>>>>>>>>        Send Find
85603>>>>>>>>>>>>>>>>>        Case Break
85604>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_FindNext)
85607>>>>>>>>>>>>>>>>>        Send FindNext
85608>>>>>>>>>>>>>>>>>        Case Break
85609>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_FINDPREV)
85612>>>>>>>>>>>>>>>>>        Send FindPrevious
85613>>>>>>>>>>>>>>>>>        Case Break
85614>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_FindReplace)
85617>>>>>>>>>>>>>>>>>        // ToDo: CMD_FindReplace
85617>>>>>>>>>>>>>>>>>        Case Break
85618>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_UPPERCASESELECTION)
85621>>>>>>>>>>>>>>>>>        Send SC_UppercaseSelection
85622>>>>>>>>>>>>>>>>>        Case Break
85623>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_LOWERCASESELECTION)
85626>>>>>>>>>>>>>>>>>        Send SC_LowercaseSelection
85627>>>>>>>>>>>>>>>>>        Case Break
85628>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKTOGGLE)
85631>>>>>>>>>>>>>>>>>        Send BookmarkToggle
85632>>>>>>>>>>>>>>>>>        Case Break
85633>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKCLEARALL)
85636>>>>>>>>>>>>>>>>>        Send BookmarkClearAll
85637>>>>>>>>>>>>>>>>>        Case Break
85638>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKJUMPTOFIRST)
85641>>>>>>>>>>>>>>>>>        Send BookmarkJumpToFirst
85642>>>>>>>>>>>>>>>>>        Case Break
85643>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKJUMPTOLAST)
85646>>>>>>>>>>>>>>>>>        Send BookmarkJumpToLast
85647>>>>>>>>>>>>>>>>>        Case Break
85648>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKNEXT)
85651>>>>>>>>>>>>>>>>>        Send BookmarkNext
85652>>>>>>>>>>>>>>>>>        Case Break
85653>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_BOOKMARKPREV)
85656>>>>>>>>>>>>>>>>>        Send BookmarkPrevious
85657>>>>>>>>>>>>>>>>>        Case Break
85658>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_GOTOINDENTATION)
85661>>>>>>>>>>>>>>>>>        Case Break
85662>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_GOTOMATCHBRACE)
85665>>>>>>>>>>>>>>>>>        Send GotomatchBrace
85666>>>>>>>>>>>>>>>>>        Case Break
85667>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_RECORDMACRO)
85670>>>>>>>>>>>>>>>>>        Case Break
85671>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO1)
85674>>>>>>>>>>>>>>>>>        Case Break
85675>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO2)
85678>>>>>>>>>>>>>>>>>        Case Break
85679>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO3)
85682>>>>>>>>>>>>>>>>>        Case Break
85683>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO4)
85686>>>>>>>>>>>>>>>>>        Case Break
85687>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO5)
85690>>>>>>>>>>>>>>>>>        Case Break
85691>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO6)
85694>>>>>>>>>>>>>>>>>        Case Break
85695>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO7)
85698>>>>>>>>>>>>>>>>>        Case Break
85699>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO8)
85702>>>>>>>>>>>>>>>>>        Case Break
85703>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO9)
85706>>>>>>>>>>>>>>>>>        Case Break
85707>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_PLAYMACRO10)
85710>>>>>>>>>>>>>>>>>        Case Break
85711>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_CODETIP)
85714>>>>>>>>>>>>>>>>>        Get Msg_DoCodeTip to iVoid
85715>>>>>>>>>>>>>>>>>        Case Break
85716>>>>>>>>>>>>>>>>>      Case (wCmd=CMD_CODELIST)
85719>>>>>>>>>>>>>>>>>        Get Msg_DoCodeList 0 to iVoid
85720>>>>>>>>>>>>>>>>>        Case Break
85721>>>>>>>>>>>>>>>>>    Case End
85721>>>>>>>>>>>>>>>>>    If (iSCICmd) Begin
85723>>>>>>>>>>>>>>>>>      Send EditorMessage iSCICmd
85724>>>>>>>>>>>>>>>>>    End
85724>>>>>>>>>>>>>>>>>>
85724>>>>>>>>>>>>>>>>>    //  Function_Return (SendMessage(Window_Handle(Self), CMM_EXECUTECMD,  ( wCmd ), ( dwCmdData ) ) )
85724>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85725>>>>>>>>>>>>>>>>>  End_Function
85726>>>>>>>>>>>>>>>>>
85726>>>>>>>>>>>>>>>>>  //
85726>>>>>>>>>>>>>>>>>  // ToDo: Currently no support for splitter screen
85726>>>>>>>>>>>>>>>>>  //
85726>>>>>>>>>>>>>>>>>  //    Function CM_SetSplitterPos Integer bHorz  Integer nPos Returns Integer
85726>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_SETSPLITTERPOS,  ( bHorz ), ( nPos ) ) )
85726>>>>>>>>>>>>>>>>>  //    End_Function
85726>>>>>>>>>>>>>>>>>  //    Function CM_GetSplitterPos Integer bHorz Returns Integer
85726>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_GETSPLITTERPOS,  ( bHorz ), 0 ) )
85726>>>>>>>>>>>>>>>>>  //    End_Function
85726>>>>>>>>>>>>>>>>>
85726>>>>>>>>>>>>>>>>>  //
85726>>>>>>>>>>>>>>>>>  // An application sends CMM_SETAUTOINDENTMODE to set the current auto-indent mode.
85726>>>>>>>>>>>>>>>>>  // The auto-indent mode determines how a new line is indented when ENTER is pressed
85726>>>>>>>>>>>>>>>>>  //
85726>>>>>>>>>>>>>>>>>  Function CM_SetAutoIndentMode Integer eMode Returns Integer
85728>>>>>>>>>>>>>>>>>    If (eMode=CM_INDENT_SCOPE) Begin
85730>>>>>>>>>>>>>>>>>      Move CM_INDENT_PREVLINE to eMode
85731>>>>>>>>>>>>>>>>>    End
85731>>>>>>>>>>>>>>>>>>
85731>>>>>>>>>>>>>>>>>    Set peAutoIndentMode to eMode
85732>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85733>>>>>>>>>>>>>>>>>  End_Function
85734>>>>>>>>>>>>>>>>>  //
85734>>>>>>>>>>>>>>>>>  // CMM_GETAUTOINDENTMODE
85734>>>>>>>>>>>>>>>>>  // An application sends CMM_GETAUTOINDENTMODE to determine the current auto-indent mode. The auto-indent mode determines how
85734>>>>>>>>>>>>>>>>>  // a new line is indented when ENTER is pressed.
85734>>>>>>>>>>>>>>>>>  //
85734>>>>>>>>>>>>>>>>>  // CM_INDENT_OFF - No indentation occurs. The next line begins at column zero (0).
85734>>>>>>>>>>>>>>>>>  // CM_INDENT_SCOPE - Language-specific scoping is used to determine the correct indentation level for the next line.
85734>>>>>>>>>>>>>>>>>  //                   This setting parses the buffer contents, looking backward for scope keywords until the start of
85734>>>>>>>>>>>>>>>>>  //                   the current scope is encountered. Once found, the indentation is copied to the next line.
85734>>>>>>>>>>>>>>>>>  //                   If no language is set, CM_INDENT_PREVLINE is used.
85734>>>>>>>>>>>>>>>>>  // CM_INDENT_PREVLINE - Indentation is copied from the previous line.
85734>>>>>>>>>>>>>>>>>  // The default setting is CM_INDENT_PREVLINE.
85734>>>>>>>>>>>>>>>>>  // CM_INDENT_SCOPE is not supported for Scintilla now
85734>>>>>>>>>>>>>>>>>  Function CM_GetAutoIndentMode Returns Integer
85736>>>>>>>>>>>>>>>>>    Integer eMode
85736>>>>>>>>>>>>>>>>>
85736>>>>>>>>>>>>>>>>>    Get peAutoIndentMode to eMode
85737>>>>>>>>>>>>>>>>>    Function_Return eMode
85738>>>>>>>>>>>>>>>>>  End_Function
85739>>>>>>>>>>>>>>>>>  Function CM_CanUndo Returns Integer
85741>>>>>>>>>>>>>>>>>    Integer iRet
85741>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CANUNDO to iRet
85742>>>>>>>>>>>>>>>>>    Function_Return iRet
85743>>>>>>>>>>>>>>>>>  End_Function
85744>>>>>>>>>>>>>>>>>  Function CM_CanRedo Returns Integer
85746>>>>>>>>>>>>>>>>>    Integer iRet
85746>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CANREDO to iRet
85747>>>>>>>>>>>>>>>>>    Function_Return iRet
85748>>>>>>>>>>>>>>>>>  End_Function
85749>>>>>>>>>>>>>>>>>  Function CM_Redo Returns Integer
85751>>>>>>>>>>>>>>>>>    Integer iRet
85751>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_REDO to iRet
85752>>>>>>>>>>>>>>>>>    Function_Return iRet
85753>>>>>>>>>>>>>>>>>  End_Function
85754>>>>>>>>>>>>>>>>>  Function CM_Undo Returns Integer
85756>>>>>>>>>>>>>>>>>    Integer iRet
85756>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_UNDO to iRet
85757>>>>>>>>>>>>>>>>>    Function_Return iRet
85758>>>>>>>>>>>>>>>>>  End_Function
85759>>>>>>>>>>>>>>>>>  Function CM_ClearUndoBuffer Returns Integer
85761>>>>>>>>>>>>>>>>>    Integer iRet
85761>>>>>>>>>>>>>>>>>    // This command tells Scintilla to forget any saved undo or redo history.
85761>>>>>>>>>>>>>>>>>    // It also sets the save point to the start of the undo buffer, so the document will appear to be unmodified.
85761>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_EMPTYUNDOBUFFER to iRet
85762>>>>>>>>>>>>>>>>>    Function_Return iRet
85763>>>>>>>>>>>>>>>>>  End_Function
85764>>>>>>>>>>>>>>>>>  Function CM_CanCut Returns Integer
85766>>>>>>>>>>>>>>>>>    Integer iRet
85766>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEMPTY to iRet
85767>>>>>>>>>>>>>>>>>    Function_Return (iRet=0)
85768>>>>>>>>>>>>>>>>>  End_Function
85769>>>>>>>>>>>>>>>>>  Function CM_CanCopy Returns Integer
85771>>>>>>>>>>>>>>>>>    Integer iRet
85771>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSELECTIONEMPTY to iRet
85772>>>>>>>>>>>>>>>>>    Function_Return (iRet=0)
85773>>>>>>>>>>>>>>>>>  End_Function
85774>>>>>>>>>>>>>>>>>  Function CM_CanPaste Returns Integer
85776>>>>>>>>>>>>>>>>>    Integer iRet
85776>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CANPASTE to iRet
85777>>>>>>>>>>>>>>>>>    Function_Return iRet
85778>>>>>>>>>>>>>>>>>  End_Function
85779>>>>>>>>>>>>>>>>>  Function CM_Cut Returns Integer
85781>>>>>>>>>>>>>>>>>    Integer iRet
85781>>>>>>>>>>>>>>>>>    Send OnBeforeCut
85782>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CUT to iRet
85783>>>>>>>>>>>>>>>>>    Send OnAfterCut
85784>>>>>>>>>>>>>>>>>    Function_Return iRet
85785>>>>>>>>>>>>>>>>>  End_Function
85786>>>>>>>>>>>>>>>>>  Function CM_Copy Returns Integer
85788>>>>>>>>>>>>>>>>>    Integer iRet
85788>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_COPY to iRet
85789>>>>>>>>>>>>>>>>>    Function_Return iRet
85790>>>>>>>>>>>>>>>>>  End_Function
85791>>>>>>>>>>>>>>>>>  Function CM_Paste Returns Integer
85793>>>>>>>>>>>>>>>>>    Integer iRet
85793>>>>>>>>>>>>>>>>>    Send OnBeforePaste
85794>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_PASTE to iRet
85795>>>>>>>>>>>>>>>>>    Send OnAfterPaste
85796>>>>>>>>>>>>>>>>>    Function_Return iRet
85797>>>>>>>>>>>>>>>>>  End_Function
85798>>>>>>>>>>>>>>>>>  Function CM_IsRecordingMacro Returns Integer
85800>>>>>>>>>>>>>>>>>    // Not sure if the function is for starting to record.
85800>>>>>>>>>>>>>>>>>    //Integer iRet
85800>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_STARTRECORD to iRet
85800>>>>>>>>>>>>>>>>>    //Function_Return iRet
85800>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISRECORDINGMACRO, 0, 0 ) )
85801>>>>>>>>>>>>>>>>>  End_Function
85802>>>>>>>>>>>>>>>>>  Function CM_IsPlayingMacro Returns Integer
85804>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPLAYINGMACRO, 0, 0 ) )
85805>>>>>>>>>>>>>>>>>  End_Function
85806>>>>>>>>>>>>>>>>>  //
85806>>>>>>>>>>>>>>>>>  // There is no undo limit in scintilla, the amount of free memory is the limit.
85806>>>>>>>>>>>>>>>>>  //
85806>>>>>>>>>>>>>>>>>  //    Function CM_SetUndoLimit Integer nLimit Returns Integer
85806>>>>>>>>>>>>>>>>>  //    Function CM_GetUndoLimit Returns Integer
85806>>>>>>>>>>>>>>>>>
85806>>>>>>>>>>>>>>>>>  Procedure ToggleLineChanged
85808>>>>>>>>>>>>>>>>>    Integer iLine
85808>>>>>>>>>>>>>>>>>
85808>>>>>>>>>>>>>>>>>    Get Current_Line to iLine
85809>>>>>>>>>>>>>>>>>    Send LineChangedMark iLine
85810>>>>>>>>>>>>>>>>>  End_Procedure
85811>>>>>>>>>>>>>>>>>
85811>>>>>>>>>>>>>>>>>  Function CM_IsModified Returns Integer
85813>>>>>>>>>>>>>>>>>    Integer iRet
85813>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMODIFY to iRet
85814>>>>>>>>>>>>>>>>>    Function_Return iRet
85815>>>>>>>>>>>>>>>>>  End_Function
85816>>>>>>>>>>>>>>>>>  //
85816>>>>>>>>>>>>>>>>>  // Does not seem to exist in Scintilla
85816>>>>>>>>>>>>>>>>>  //
85816>>>>>>>>>>>>>>>>>  //    Function CM_SetModified Integer bModified Returns Integer
85816>>>>>>>>>>>>>>>>>
85816>>>>>>>>>>>>>>>>>  Function CM_EnableOvertype Integer bEnable Returns Integer
85818>>>>>>>>>>>>>>>>>    Integer iRet
85818>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETOVERTYPE bEnable to iRet
85819>>>>>>>>>>>>>>>>>    Function_Return iRet
85820>>>>>>>>>>>>>>>>>  End_Function
85821>>>>>>>>>>>>>>>>>  Function CM_IsOvertypeEnabled Returns Integer
85823>>>>>>>>>>>>>>>>>    Integer iRet
85823>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETOVERTYPE to iRet
85824>>>>>>>>>>>>>>>>>    Function_Return iRet
85825>>>>>>>>>>>>>>>>>  End_Function
85826>>>>>>>>>>>>>>>>>  Function CM_EnableCaseSensitive Integer bEnable Returns Integer
85828>>>>>>>>>>>>>>>>>    Integer iFlags
85828>>>>>>>>>>>>>>>>>    Integer iRet
85828>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85829>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85831>>>>>>>>>>>>>>>>>      //
85831>>>>>>>>>>>>>>>>>      Move (iFlags iOr SCFIND_MATCHCASE) To iFlags
85832>>>>>>>>>>>>>>>>>    End
85832>>>>>>>>>>>>>>>>>>
85832>>>>>>>>>>>>>>>>>    Else Begin
85833>>>>>>>>>>>>>>>>>      Move (iFlags iAnd (iNot(SCFIND_MATCHCASE))) To iFlags
85834>>>>>>>>>>>>>>>>>    End
85834>>>>>>>>>>>>>>>>>>
85834>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet
85835>>>>>>>>>>>>>>>>>    Function_Return iRet
85836>>>>>>>>>>>>>>>>>  End_Function
85837>>>>>>>>>>>>>>>>>  Function CM_IsCaseSensitiveEnabled Returns Integer
85839>>>>>>>>>>>>>>>>>    Integer iFlags
85839>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85840>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_MATCHCASE) To iFlags
85841>>>>>>>>>>>>>>>>>    Function_Return (iFlags<>0)
85842>>>>>>>>>>>>>>>>>  End_Function
85843>>>>>>>>>>>>>>>>>
85843>>>>>>>>>>>>>>>>>  // Weird codemax feature, not in scintilla
85843>>>>>>>>>>>>>>>>>  // If TRUE, subsequent Find/Replace operations will format the Replace text such that it follows
85843>>>>>>>>>>>>>>>>>  // the same case pattern of the Find text:
85843>>>>>>>>>>>>>>>>>  //Function CM_EnablePreserveCase Integer bEnable Returns Integer
85843>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEPRESERVECASE,  ( bEnable ), 0 ) )
85843>>>>>>>>>>>>>>>>>  //End_Function
85843>>>>>>>>>>>>>>>>>  //Function CM_IsPreserveCaseEnabled Returns Integer
85843>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPRESERVECASEENABLED, 0, 0 ) )
85843>>>>>>>>>>>>>>>>>  //End_Function
85843>>>>>>>>>>>>>>>>>
85843>>>>>>>>>>>>>>>>>  // An application sends CMM_ENABLEWHOLEWORD to enable or disable whole word searching during a find or find and replace operation
85843>>>>>>>>>>>>>>>>>  Function CM_EnableWholeWord Integer bEnable Returns Integer
85845>>>>>>>>>>>>>>>>>    Integer iFlags
85845>>>>>>>>>>>>>>>>>    Integer iRet
85845>>>>>>>>>>>>>>>>>    //
85845>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85846>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85848>>>>>>>>>>>>>>>>>      //
85848>>>>>>>>>>>>>>>>>      Move (iFlags iOr SCFIND_WHOLEWORD) To iFlags
85849>>>>>>>>>>>>>>>>>    End
85849>>>>>>>>>>>>>>>>>>
85849>>>>>>>>>>>>>>>>>    Else Begin
85850>>>>>>>>>>>>>>>>>      Move (iFlags iAnd (iNot(SCFIND_WHOLEWORD))) To iFlags
85851>>>>>>>>>>>>>>>>>    End
85851>>>>>>>>>>>>>>>>>>
85851>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet
85852>>>>>>>>>>>>>>>>>    Function_Return iRet
85853>>>>>>>>>>>>>>>>>  End_Function
85854>>>>>>>>>>>>>>>>>  Function CM_IsWholeWordEnabled Returns Integer
85856>>>>>>>>>>>>>>>>>    Integer iFlags
85856>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85857>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_WHOLEWORD) To iFlags
85858>>>>>>>>>>>>>>>>>    Function_Return (iFlags<>0)
85859>>>>>>>>>>>>>>>>>  End_Function
85860>>>>>>>>>>>>>>>>>
85860>>>>>>>>>>>>>>>>>
85860>>>>>>>>>>>>>>>>>  Function CM_EnableRegExp Integer bEnable Returns Integer
85862>>>>>>>>>>>>>>>>>    Integer iFlags
85862>>>>>>>>>>>>>>>>>    Integer iRet
85862>>>>>>>>>>>>>>>>>    //
85862>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
85863>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85865>>>>>>>>>>>>>>>>>      //
85865>>>>>>>>>>>>>>>>>      Move (iFlags iOr SCFIND_REGEXP) To iFlags
85866>>>>>>>>>>>>>>>>>    End
85866>>>>>>>>>>>>>>>>>>
85866>>>>>>>>>>>>>>>>>    Else Begin
85867>>>>>>>>>>>>>>>>>      Move (iFlags iAnd (iNot(SCFIND_REGEXP))) To iFlags
85868>>>>>>>>>>>>>>>>>    End
85868>>>>>>>>>>>>>>>>>>
85868>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETSEARCHFLAGS iFlags to iRet // CMM_ENABLEREGEXP
85869>>>>>>>>>>>>>>>>>    Function_Return iRet
85870>>>>>>>>>>>>>>>>>  End_Function
85871>>>>>>>>>>>>>>>>>
85871>>>>>>>>>>>>>>>>>  Function CM_IsRegExpEnabled Returns Integer
85873>>>>>>>>>>>>>>>>>    Integer iFlags
85873>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags // CMM_ISREGEXPENABLED
85874>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_REGEXP) To iFlags
85875>>>>>>>>>>>>>>>>>    Function_Return (iFlags<>0)
85876>>>>>>>>>>>>>>>>>  End_Function
85877>>>>>>>>>>>>>>>>>
85877>>>>>>>>>>>>>>>>>  // An application sends CMM_SETTOPINDEX to set the topmost visible line in a specific view.
85877>>>>>>>>>>>>>>>>>  // This might be the same as SCI_SETFIRSTVISIBLELINE(int displayLine) but not completely clear to me now.
85877>>>>>>>>>>>>>>>>>  //Function CM_SetTopIndex Integer nView Integer nLine Returns Integer
85877>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_SETTOPINDEX,  ( nView ), ( nLine ) ) )
85877>>>>>>>>>>>>>>>>>  //End_Function
85877>>>>>>>>>>>>>>>>>  //Function CM_GetTopIndex Integer nView Returns Integer
85877>>>>>>>>>>>>>>>>>  //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETTOPINDEX,  ( nView ), 0 ) )
85877>>>>>>>>>>>>>>>>>  //End_Function
85877>>>>>>>>>>>>>>>>>
85877>>>>>>>>>>>>>>>>>  // SCI_LINESONSCREEN
85877>>>>>>>>>>>>>>>>>  Function CM_GetVisibleLineCount Integer nView Integer bFullyVisible Returns Integer
85879>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETVISIBLELINECOUNT,  ( nView ), ( bFullyVisible ) ) )
85880>>>>>>>>>>>>>>>>>  End_Function
85881>>>>>>>>>>>>>>>>>
85881>>>>>>>>>>>>>>>>>  // An application sends CMM_ENABLECRLF to enable or disable the inclusion of carriage returns when
85881>>>>>>>>>>>>>>>>>  // multiple lines of text are retrieved from the edit buffer
85881>>>>>>>>>>>>>>>>>  // bEnable - If TRUE, multiple lines of text retrieved from the edit buffer are delimited by a
85881>>>>>>>>>>>>>>>>>  //  carriage return (\r) and a linefeed (\n). If FALSE, lines are delimited by only a linefeed (\n).
85881>>>>>>>>>>>>>>>>>  //  The default setting is TRUE.
85881>>>>>>>>>>>>>>>>>  Function CM_EnableCRLF Integer bEnable Returns Integer
85883>>>>>>>>>>>>>>>>>    Integer eMode
85883>>>>>>>>>>>>>>>>>
85883>>>>>>>>>>>>>>>>>    If (bEnable) Begin
85885>>>>>>>>>>>>>>>>>      Move SC_EOL_CRLF to eMode
85886>>>>>>>>>>>>>>>>>      Set psEOLChar    to CS_CRLF
85887>>>>>>>>>>>>>>>>>    End
85887>>>>>>>>>>>>>>>>>>
85887>>>>>>>>>>>>>>>>>    Else Begin
85888>>>>>>>>>>>>>>>>>      Move SC_EOL_LF   To eMode
85889>>>>>>>>>>>>>>>>>      Set psEOLChar    to CS_LF
85890>>>>>>>>>>>>>>>>>    End
85890>>>>>>>>>>>>>>>>>>
85890>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETEOLMODE eMode
85891>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85892>>>>>>>>>>>>>>>>>  End_Function
85893>>>>>>>>>>>>>>>>>
85893>>>>>>>>>>>>>>>>>  // The return value is TRUE if multiple lines of text retrieved from the edit buffer are delimited by
85893>>>>>>>>>>>>>>>>>  // a carriage return (\r) and a linefeed (\n). The return value is FALSE if lines are delimited by
85893>>>>>>>>>>>>>>>>>  // only a linefeed (\n). The default setting is TRUE.
85893>>>>>>>>>>>>>>>>>  Function CM_IsCRLFEnabled Returns Boolean
85895>>>>>>>>>>>>>>>>>    Integer eMode
85895>>>>>>>>>>>>>>>>>    Boolean bEnabled
85895>>>>>>>>>>>>>>>>>    Move False to bEnabled
85896>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETEOLMODE to eMode
85897>>>>>>>>>>>>>>>>>    If (eMode=SC_EOL_CRLF) Begin
85899>>>>>>>>>>>>>>>>>      Move True to bEnabled
85900>>>>>>>>>>>>>>>>>    End
85900>>>>>>>>>>>>>>>>>>
85900>>>>>>>>>>>>>>>>>    Function_Return True
85901>>>>>>>>>>>>>>>>>  End_Function
85902>>>>>>>>>>>>>>>>>
85902>>>>>>>>>>>>>>>>>  Function CM_GetCurrentView Returns Integer
85904>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTVIEW, 0, 0 ) )
85905>>>>>>>>>>>>>>>>>  End_Function
85906>>>>>>>>>>>>>>>>>  // SVN
85906>>>>>>>>>>>>>>>>>  Function CM_SetCurrentView Integer nLine Returns Integer
85908>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETCURRENTVIEW, nLine, 0 ) )
85909>>>>>>>>>>>>>>>>>  End_Function
85910>>>>>>>>>>>>>>>>>  // SVN
85910>>>>>>>>>>>>>>>>>  Function CM_GetViewCount Returns Integer
85912>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETVIEWCOUNT, 0, 0 ) )
85913>>>>>>>>>>>>>>>>>  End_Function
85914>>>>>>>>>>>>>>>>>  Function CM_ShowScrollBar Integer bHorz  Integer bShow Returns Integer
85916>>>>>>>>>>>>>>>>>    Integer iRet
85916>>>>>>>>>>>>>>>>>    If (bHorz) Begin
85918>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETHSCROLLBAR bShow
85919>>>>>>>>>>>>>>>>>    End
85919>>>>>>>>>>>>>>>>>>
85919>>>>>>>>>>>>>>>>>    Else Begin
85920>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETVSCROLLBAR bShow
85921>>>>>>>>>>>>>>>>>    End
85921>>>>>>>>>>>>>>>>>>
85921>>>>>>>>>>>>>>>>>    Function_Return iRet
85922>>>>>>>>>>>>>>>>>  End_Function
85923>>>>>>>>>>>>>>>>>  Function CM_HasScrollBar Integer bHorz Returns Integer
85925>>>>>>>>>>>>>>>>>    Integer iRet
85925>>>>>>>>>>>>>>>>>    If (bHorz) Begin
85927>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETHSCROLLBAR to iRet
85928>>>>>>>>>>>>>>>>>    End
85928>>>>>>>>>>>>>>>>>>
85928>>>>>>>>>>>>>>>>>    Else Begin
85929>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETVSCROLLBAR to iRet
85930>>>>>>>>>>>>>>>>>    End
85930>>>>>>>>>>>>>>>>>>
85930>>>>>>>>>>>>>>>>>    Function_Return iRet
85931>>>>>>>>>>>>>>>>>  End_Function
85932>>>>>>>>>>>>>>>>>
85932>>>>>>>>>>>>>>>>>  Function CM_GetSelFromPoint Integer xClient Integer yClient Returns Integer
85934>>>>>>>>>>>>>>>>>    Integer iLine iCol
85934>>>>>>>>>>>>>>>>>    Integer iPos
85934>>>>>>>>>>>>>>>>>
85934>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMPOINT xClient yClient to iPos
85935>>>>>>>>>>>>>>>>>    If (iPos>-1) Begin
85937>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
85938>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCOLUMN        iPos to iCol
85939>>>>>>>>>>>>>>>>>
85939>>>>>>>>>>>>>>>>>      Set piSelStartLine                              to iLine
85940>>>>>>>>>>>>>>>>>      Set piSelStartCol                               to iCol
85941>>>>>>>>>>>>>>>>>      Set piSelEndLine                                to iLine
85942>>>>>>>>>>>>>>>>>      Set piSelEndCol                                 to iCol
85943>>>>>>>>>>>>>>>>>    End
85943>>>>>>>>>>>>>>>>>>
85943>>>>>>>>>>>>>>>>>    Function_Return iPos
85944>>>>>>>>>>>>>>>>>  End_Function
85945>>>>>>>>>>>>>>>>>
85945>>>>>>>>>>>>>>>>>  Procedure SC_LineCut
85947>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_LINECUT
85948>>>>>>>>>>>>>>>>>  End_Procedure
85949>>>>>>>>>>>>>>>>>
85949>>>>>>>>>>>>>>>>>  Procedure SC_UppercaseSelection
85951>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_UPPERCASE
85952>>>>>>>>>>>>>>>>>  End_Procedure
85953>>>>>>>>>>>>>>>>>
85953>>>>>>>>>>>>>>>>>  Procedure SC_LowercaseSelection
85955>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_LOWERCASE
85956>>>>>>>>>>>>>>>>>  End_Procedure
85957>>>>>>>>>>>>>>>>>
85957>>>>>>>>>>>>>>>>>  // An application sends CMM_SELECTLINE to select a line of text in the edit buffer
85957>>>>>>>>>>>>>>>>>  // bMakeVisible
85957>>>>>>>>>>>>>>>>>  // If TRUE, the line will be scrolled into view if necessary. If FALSE, the line will never be scrolled.
85957>>>>>>>>>>>>>>>>>  //
85957>>>>>>>>>>>>>>>>>  Function CM_SelectLine Integer iLine Integer bMakeVisible Returns Integer
85959>>>>>>>>>>>>>>>>>    Integer iAnchor
85959>>>>>>>>>>>>>>>>>    Integer iCaret
85959>>>>>>>>>>>>>>>>>    Integer iRet
85959>>>>>>>>>>>>>>>>>
85959>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE   iLine to iAnchor
85960>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETLINEENDPOSITION iline to iCaret
85961>>>>>>>>>>>>>>>>>    If (bMakeVisible) Begin
85963>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_SETSEL iAnchor iCaret to iRet
85964>>>>>>>>>>>>>>>>>    End
85964>>>>>>>>>>>>>>>>>>
85964>>>>>>>>>>>>>>>>>    Else Begin
85965>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONSTART iAnchor
85966>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONEND   iCaret
85967>>>>>>>>>>>>>>>>>    End
85967>>>>>>>>>>>>>>>>>>
85967>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
85968>>>>>>>>>>>>>>>>>  End_Function
85969>>>>>>>>>>>>>>>>>  Function CM_HitTest Integer xClient Integer yClient Returns Integer
85971>>>>>>>>>>>>>>>>>    Integer iPos
85971>>>>>>>>>>>>>>>>>    Integer iRet
85971>>>>>>>>>>>>>>>>>
85971>>>>>>>>>>>>>>>>>    Move CM_NOWHERE to iRet
85972>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CHARPOSITIONFROMPOINT xClient yClient to iPos
85973>>>>>>>>>>>>>>>>>    If (iPos>-1) Begin
85975>>>>>>>>>>>>>>>>>      Move CM_EDITSPACE To iRet
85976>>>>>>>>>>>>>>>>>    End
85976>>>>>>>>>>>>>>>>>>
85976>>>>>>>>>>>>>>>>>    Function_Return (65536*iRet)
85977>>>>>>>>>>>>>>>>>  End_Function
85978>>>>>>>>>>>>>>>>>  Function CM_EnableDragDrop Integer bEnable Returns Integer
85980>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEDRAGDROP,  ( bEnable ), 0 ) )
85981>>>>>>>>>>>>>>>>>  End_Function
85982>>>>>>>>>>>>>>>>>  Function CM_IsDragDropEnabled Returns Integer
85984>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISDRAGDROPENABLED, 0, 0 ) )
85985>>>>>>>>>>>>>>>>>  End_Function
85986>>>>>>>>>>>>>>>>>
85986>>>>>>>>>>>>>>>>>  //
85986>>>>>>>>>>>>>>>>>  // ToDo: Currently no support for splitter screen
85986>>>>>>>>>>>>>>>>>  //
85986>>>>>>>>>>>>>>>>>  //    Function CM_EnableSplitter Integer bHorz Integer bEnable Returns Integer
85986>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESPLITTER,  ( bHorz ), ( bEnable ) ) )
85986>>>>>>>>>>>>>>>>>  //    End_Function
85986>>>>>>>>>>>>>>>>>  //    Function CM_IsSplitterEnabled Integer bHorz Returns Integer
85986>>>>>>>>>>>>>>>>>  //        Function_Return (SendMessage(Window_Handle(Self), CMM_ISSPLITTERENABLED,  ( bHorz ), 0 ) )
85986>>>>>>>>>>>>>>>>>  //    End_Function
85986>>>>>>>>>>>>>>>>>  Function CM_EnableColumnSel Integer bEnable Returns Integer
85988>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLUMNSEL,  ( bEnable ), 0 ) )
85989>>>>>>>>>>>>>>>>>  End_Function
85990>>>>>>>>>>>>>>>>>  Function CM_IsColumnSelEnabled Returns Integer
85992>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLUMNSELENABLED, 0, 0 ) )
85993>>>>>>>>>>>>>>>>>  End_Function
85994>>>>>>>>>>>>>>>>>  Function CM_EnableGlobalProps Integer bEnable Returns Integer
85996>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEGLOBALPROPS,  ( bEnable ), 0 ) )
85997>>>>>>>>>>>>>>>>>  End_Function
85998>>>>>>>>>>>>>>>>>  Function CM_IsGlobalPropsEnabled Returns Integer
86000>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISGLOBALPROPSENABLED, 0, 0 ) )
86001>>>>>>>>>>>>>>>>>  End_Function
86002>>>>>>>>>>>>>>>>>  Function CM_SetDlgParent Integer hWndParent Returns Integer
86004>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETDLGPARENT,  ( hWndParent ), 0 ) )
86005>>>>>>>>>>>>>>>>>  End_Function
86006>>>>>>>>>>>>>>>>>  Function CM_EnableSelBounds Integer bEnable Returns Integer
86008>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESELBOUNDS,  ( bEnable ), 0 ) )
86009>>>>>>>>>>>>>>>>>  End_Function
86010>>>>>>>>>>>>>>>>>  Function CM_IsSelBoundsEnabled Returns Integer
86012>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISSELBOUNDSENABLED, 0, 0 ) )
86013>>>>>>>>>>>>>>>>>  End_Function
86014>>>>>>>>>>>>>>>>>
86014>>>>>>>>>>>>>>>>>  Function CM_SetLineStyle Integer nLine Integer dwStyle Returns Integer
86016>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETLINESTYLE,  ( nLine ), ( dwStyle ) ) )
86017>>>>>>>>>>>>>>>>>  End_Function
86018>>>>>>>>>>>>>>>>>  Function CM_GetLineStyle Integer nLine Returns Integer
86020>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETLINESTYLE,  ( nLine ), 0 ) )
86021>>>>>>>>>>>>>>>>>  End_Function
86022>>>>>>>>>>>>>>>>>  Procedure LineChangedMark Integer iLine
86024>>>>>>>>>>>>>>>>>    Boolean  bChanged
86024>>>>>>>>>>>>>>>>>    Handle   hMarkers
86024>>>>>>>>>>>>>>>>>    Handle   hChangedMark
86024>>>>>>>>>>>>>>>>>
86024>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERGET iLine to hMarkers
86025>>>>>>>>>>>>>>>>>    If ((hMarkers iAnd SC_MASK_CHANGEDLINEUNSAVED)=0) Begin
86027>>>>>>>>>>>>>>>>>      Get CM_IsModified to bChanged
86028>>>>>>>>>>>>>>>>>      If (bChanged) Begin
86030>>>>>>>>>>>>>>>>>        If (hMarkers iAnd SC_MASK_CHANGEDLINE) Begin
86032>>>>>>>>>>>>>>>>>          // There is a saved change line marker. We have to remove it or we won't see our current changed line mark
86032>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINESAVED
86033>>>>>>>>>>>>>>>>>        End
86033>>>>>>>>>>>>>>>>>>
86033>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_CHANGEDLINE to hChangedMark
86034>>>>>>>>>>>>>>>>>      End
86034>>>>>>>>>>>>>>>>>>
86034>>>>>>>>>>>>>>>>>    End
86034>>>>>>>>>>>>>>>>>>
86034>>>>>>>>>>>>>>>>>    Else Begin  // if the line has marker we need to check if the user brought the line back to original state so
86035>>>>>>>>>>>>>>>>>      // that we can remove the line. This code needs to be fast, so we start by comparing length.
86035>>>>>>>>>>>>>>>>>      If (Length(CM_GetLine(Self,iLine))=Length(psLineOnEnter(Self))) Begin
86037>>>>>>>>>>>>>>>>>        If (CM_GetLine(Self,iLine)=psLineOnEnter(Self)) Begin // again we want speed, so don't copy to local variables
86039>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
86040>>>>>>>>>>>>>>>>>        End
86040>>>>>>>>>>>>>>>>>>
86040>>>>>>>>>>>>>>>>>      End
86040>>>>>>>>>>>>>>>>>>
86040>>>>>>>>>>>>>>>>>    End
86040>>>>>>>>>>>>>>>>>>
86040>>>>>>>>>>>>>>>>>  End_Procedure
86041>>>>>>>>>>>>>>>>>
86041>>>>>>>>>>>>>>>>>  //
86041>>>>>>>>>>>>>>>>>  // Enumerates through all of the Changed Line markers in the document and sets them as saved
86041>>>>>>>>>>>>>>>>>  // changed line markers
86041>>>>>>>>>>>>>>>>>  //
86041>>>>>>>>>>>>>>>>>  Procedure MarkChangedLinesAsSaved
86043>>>>>>>>>>>>>>>>>    Integer iLine
86043>>>>>>>>>>>>>>>>>    Handle  hMark
86043>>>>>>>>>>>>>>>>>
86043>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_CHANGEDLINEUNSAVED to iLine
86044>>>>>>>>>>>>>>>>>    While (iLine>-1)
86048>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
86049>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_MARKERADD    iLine SC_MARKNUM_CHANGEDLINESAVED   to hMark
86050>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_MARKERNEXT  (iLine+1) SC_MASK_CHANGEDLINEUNSAVED to iLine
86051>>>>>>>>>>>>>>>>>    Loop
86052>>>>>>>>>>>>>>>>>>
86052>>>>>>>>>>>>>>>>>  End_Procedure
86053>>>>>>>>>>>>>>>>>
86053>>>>>>>>>>>>>>>>>  Function CM_SetBookmark Integer nLine Integer bEnable Returns Integer
86055>>>>>>>>>>>>>>>>>    Handle   hMarkers
86055>>>>>>>>>>>>>>>>>    Handle   hBookMark
86055>>>>>>>>>>>>>>>>>
86055>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERGET nLine to hMarkers
86056>>>>>>>>>>>>>>>>>    If (bEnable) Begin
86058>>>>>>>>>>>>>>>>>      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)=false) Begin
86060>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_MARKERADD nLine SC_MARKNUM_BOOKMARK to hBookMark
86061>>>>>>>>>>>>>>>>>      End
86061>>>>>>>>>>>>>>>>>>
86061>>>>>>>>>>>>>>>>>    End
86061>>>>>>>>>>>>>>>>>>
86061>>>>>>>>>>>>>>>>>    Else Begin
86062>>>>>>>>>>>>>>>>>      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
86064>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_MARKERDELETE nLine SC_MARKNUM_BOOKMARK
86065>>>>>>>>>>>>>>>>>      End
86065>>>>>>>>>>>>>>>>>>
86065>>>>>>>>>>>>>>>>>    End
86065>>>>>>>>>>>>>>>>>>
86065>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86066>>>>>>>>>>>>>>>>>  End_Function
86067>>>>>>>>>>>>>>>>>  Function CM_GetBookmark Integer nLine Returns Integer
86069>>>>>>>>>>>>>>>>>    Boolean bHasBookMark
86069>>>>>>>>>>>>>>>>>    Handle hMarkers
86069>>>>>>>>>>>>>>>>>
86069>>>>>>>>>>>>>>>>>    Move False to bHasBookMark
86070>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERGET nLine to hMarkers
86071>>>>>>>>>>>>>>>>>    If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
86073>>>>>>>>>>>>>>>>>      Move True To bHasBookMark
86074>>>>>>>>>>>>>>>>>    End
86074>>>>>>>>>>>>>>>>>>
86074>>>>>>>>>>>>>>>>>    Function_Return bHasBookMark
86075>>>>>>>>>>>>>>>>>  End_Function
86076>>>>>>>>>>>>>>>>>
86076>>>>>>>>>>>>>>>>>  Procedure BookmarkToggle
86078>>>>>>>>>>>>>>>>>    Boolean bHasBookmark
86078>>>>>>>>>>>>>>>>>    Integer iLine
86078>>>>>>>>>>>>>>>>>    Integer iVoid
86078>>>>>>>>>>>>>>>>>
86078>>>>>>>>>>>>>>>>>    Get Current_Line to iLine
86079>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
86081>>>>>>>>>>>>>>>>>      Get CM_GetBookmark iLine to bHasBookmark
86082>>>>>>>>>>>>>>>>>      Get CM_SetBookmark iLine (not(bHasBookmark)) to iVoid
86083>>>>>>>>>>>>>>>>>    End
86083>>>>>>>>>>>>>>>>>>
86083>>>>>>>>>>>>>>>>>  End_Procedure
86084>>>>>>>>>>>>>>>>>
86084>>>>>>>>>>>>>>>>>  Procedure BookmarkNext
86086>>>>>>>>>>>>>>>>>    Integer iLine
86086>>>>>>>>>>>>>>>>>    Integer iLineStart
86086>>>>>>>>>>>>>>>>>    Get Current_Line to iLineStart
86087>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT (iLineStart+1) SC_MASK_BOOKMARK to iLine
86088>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
86090>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
86091>>>>>>>>>>>>>>>>>    End
86091>>>>>>>>>>>>>>>>>>
86091>>>>>>>>>>>>>>>>>  End_Procedure
86092>>>>>>>>>>>>>>>>>
86092>>>>>>>>>>>>>>>>>  Procedure BookmarkPrevious
86094>>>>>>>>>>>>>>>>>    Integer iLine
86094>>>>>>>>>>>>>>>>>    Integer iLineStart
86094>>>>>>>>>>>>>>>>>    Get Current_Line to iLineStart
86095>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERPREVIOUS (iLineStart-1) SC_MASK_BOOKMARK to iLine
86096>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
86098>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
86099>>>>>>>>>>>>>>>>>    End
86099>>>>>>>>>>>>>>>>>>
86099>>>>>>>>>>>>>>>>>  End_Procedure
86100>>>>>>>>>>>>>>>>>
86100>>>>>>>>>>>>>>>>>  Procedure BookmarkJumpToFirst
86102>>>>>>>>>>>>>>>>>    Integer iLine
86102>>>>>>>>>>>>>>>>>    Integer iLineStart
86102>>>>>>>>>>>>>>>>>
86102>>>>>>>>>>>>>>>>>    Move 0 to iLineStart
86103>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT iLineStart SC_MASK_BOOKMARK to iLine
86104>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
86106>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
86107>>>>>>>>>>>>>>>>>    End
86107>>>>>>>>>>>>>>>>>>
86107>>>>>>>>>>>>>>>>>  End_Procedure
86108>>>>>>>>>>>>>>>>>
86108>>>>>>>>>>>>>>>>>  Procedure BookmarkJumpToLast
86110>>>>>>>>>>>>>>>>>    Integer iLine
86110>>>>>>>>>>>>>>>>>    Integer iLineStart
86110>>>>>>>>>>>>>>>>>
86110>>>>>>>>>>>>>>>>>    Get SC_LineCount to iLineStart
86111>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERPREVIOUS iLineStart SC_MASK_BOOKMARK to iLine
86112>>>>>>>>>>>>>>>>>    If (iLine>-1) Begin
86114>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOLINE iLine
86115>>>>>>>>>>>>>>>>>    End
86115>>>>>>>>>>>>>>>>>>
86115>>>>>>>>>>>>>>>>>  End_Procedure
86116>>>>>>>>>>>>>>>>>
86116>>>>>>>>>>>>>>>>>  Procedure BookmarkClearAll
86118>>>>>>>>>>>>>>>>>    Integer iLine
86118>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
86119>>>>>>>>>>>>>>>>>    While (iLine>-1)
86123>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_BOOKMARK
86124>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
86125>>>>>>>>>>>>>>>>>    Loop
86126>>>>>>>>>>>>>>>>>>
86126>>>>>>>>>>>>>>>>>  End_Procedure
86127>>>>>>>>>>>>>>>>>
86127>>>>>>>>>>>>>>>>>  Function CM_SetAllBookmarks Integer iCountNotUsed String sData Returns Integer
86129>>>>>>>>>>>>>>>>>    Integer   iCount
86129>>>>>>>>>>>>>>>>>    Integer   iItem
86129>>>>>>>>>>>>>>>>>    Integer   iLine
86129>>>>>>>>>>>>>>>>>    Integer   iVoid
86129>>>>>>>>>>>>>>>>>    Integer[] Bookmarks
86130>>>>>>>>>>>>>>>>>
86130>>>>>>>>>>>>>>>>>    Move (ConvertAsciiToIntegerArray(sData)) To Bookmarks
86131>>>>>>>>>>>>>>>>>    Move (SizeOfArray(Bookmarks)) To iCount
86132>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
86134>>>>>>>>>>>>>>>>>      For iItem From 0 To (iCount-1)
86140>>>>>>>>>>>>>>>>>>
86140>>>>>>>>>>>>>>>>>        Move Bookmarks[iItem] To iLine
86141>>>>>>>>>>>>>>>>>        If (iLine>0) Begin
86143>>>>>>>>>>>>>>>>>          Get CM_SetBookmark iLine True to iVoid
86144>>>>>>>>>>>>>>>>>        End
86144>>>>>>>>>>>>>>>>>>
86144>>>>>>>>>>>>>>>>>      Loop
86145>>>>>>>>>>>>>>>>>>
86145>>>>>>>>>>>>>>>>>    End
86145>>>>>>>>>>>>>>>>>>
86145>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86146>>>>>>>>>>>>>>>>>  End_Function
86147>>>>>>>>>>>>>>>>>
86147>>>>>>>>>>>>>>>>>  Function SC_AllBookmarksToIntegerArray Returns Integer[]
86149>>>>>>>>>>>>>>>>>    Integer iLine
86149>>>>>>>>>>>>>>>>>    Integer[] Bookmarks
86150>>>>>>>>>>>>>>>>>
86150>>>>>>>>>>>>>>>>>    Move (ResizeArray(Bookmarks,0)) To Bookmarks
86151>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
86152>>>>>>>>>>>>>>>>>    While (iLine>-1)
86156>>>>>>>>>>>>>>>>>      Move iLine To Bookmarks[SizeOfArray(Bookmarks)]
86157>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
86158>>>>>>>>>>>>>>>>>    Loop
86159>>>>>>>>>>>>>>>>>>
86159>>>>>>>>>>>>>>>>>    Function_Return Bookmarks
86160>>>>>>>>>>>>>>>>>  End_Function
86161>>>>>>>>>>>>>>>>>
86161>>>>>>>>>>>>>>>>>  Function CM_GetAllBookmarks Returns String
86163>>>>>>>>>>>>>>>>>    String sData
86163>>>>>>>>>>>>>>>>>    Integer[] Bookmarks
86164>>>>>>>>>>>>>>>>>
86164>>>>>>>>>>>>>>>>>    Get SC_AllBookmarksToIntegerArray to Bookmarks
86165>>>>>>>>>>>>>>>>>    Get ConvertIntegerArrayToAscii Bookmarks to sData
86166>>>>>>>>>>>>>>>>>    Function_Return sData
86167>>>>>>>>>>>>>>>>>  End_Function
86168>>>>>>>>>>>>>>>>>
86168>>>>>>>>>>>>>>>>>  //
86168>>>>>>>>>>>>>>>>>  // We're only offering On/Off, the iStart and iMode options are ignored.
86168>>>>>>>>>>>>>>>>>  //
86168>>>>>>>>>>>>>>>>>  Function CM_SetLineNumbering Integer bEnable Integer iStart Integer iMode Returns Integer
86170>>>>>>>>>>>>>>>>>    Integer iMarginWidth
86170>>>>>>>>>>>>>>>>>    Integer iDigits
86170>>>>>>>>>>>>>>>>>    Integer iLineCount
86170>>>>>>>>>>>>>>>>>    String  sMaxLine
86170>>>>>>>>>>>>>>>>>
86170>>>>>>>>>>>>>>>>>    If (bEnable) Begin
86172>>>>>>>>>>>>>>>>>      // figure out the width we need based on max line count
86172>>>>>>>>>>>>>>>>>      Get SC_LineCount to iLineCount
86173>>>>>>>>>>>>>>>>>      If (iLineCount>999) Begin
86175>>>>>>>>>>>>>>>>>        Move (Length(Trim(iLineCount))) To iDigits
86176>>>>>>>>>>>>>>>>>        Move ("_"+repeat("9",iDigits)+Character(0)) To sMaxLine
86177>>>>>>>>>>>>>>>>>      End
86177>>>>>>>>>>>>>>>>>>
86177>>>>>>>>>>>>>>>>>      Else Begin  // so if it is called at that time then hardwire a fixed width
86178>>>>>>>>>>>>>>>>>        Move 3 To iDigits // we don't count the "_" offset, this is our default, we don't get lower as 3
86179>>>>>>>>>>>>>>>>>        Move ("_999"+Character(0)) To sMaxLine
86180>>>>>>>>>>>>>>>>>      End
86180>>>>>>>>>>>>>>>>>>
86180>>>>>>>>>>>>>>>>>      Set piMarginLineNumberDigits to iDigits
86181>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_TEXTWIDTH STYLE_LINENUMBER (AddressOf(sMaxLine)) to iMarginWidth
86182>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS iMarginWidth
86183>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMARGINMASKN  MARGIN_LINE_NUMBERS SC_MASK_MARGIN
86184>>>>>>>>>>>>>>>>>    End
86184>>>>>>>>>>>>>>>>>>
86184>>>>>>>>>>>>>>>>>    Else Begin
86185>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS 0
86186>>>>>>>>>>>>>>>>>    End
86186>>>>>>>>>>>>>>>>>>
86186>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86187>>>>>>>>>>>>>>>>>  End_Function
86188>>>>>>>>>>>>>>>>>  //
86188>>>>>>>>>>>>>>>>>  // Returns 0 if not enabled or CM_DECIMAL if it is
86188>>>>>>>>>>>>>>>>>  //
86188>>>>>>>>>>>>>>>>>  Function CM_GetLineNumbering Returns Integer
86190>>>>>>>>>>>>>>>>>    Integer iRet iWidth
86190>>>>>>>>>>>>>>>>>
86190>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS to iWidth
86191>>>>>>>>>>>>>>>>>    If (iWidth>0) Begin
86193>>>>>>>>>>>>>>>>>      Move CM_DECIMAL To iRet
86194>>>>>>>>>>>>>>>>>    End
86194>>>>>>>>>>>>>>>>>>
86194>>>>>>>>>>>>>>>>>    Else Begin
86195>>>>>>>>>>>>>>>>>      Move 0 To iRet
86196>>>>>>>>>>>>>>>>>    End
86196>>>>>>>>>>>>>>>>>>
86196>>>>>>>>>>>>>>>>>    Function_Return iRet
86197>>>>>>>>>>>>>>>>>  End_Function
86198>>>>>>>>>>>>>>>>>  Function CM_PosFromChar Integer iLine Integer iCol Returns Integer
86200>>>>>>>>>>>>>>>>>    Integer iX iY iPos
86200>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
86201>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POINTXFROMPOSITION 0 iPos to iX
86202>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POINTYFROMPOSITION 0 iPos to iY
86203>>>>>>>>>>>>>>>>>    Set piPosStartX                     to iX
86204>>>>>>>>>>>>>>>>>    Set piPosStartY                     to iY
86205>>>>>>>>>>>>>>>>>    Set piPosEndX                       to iX
86206>>>>>>>>>>>>>>>>>    Set piPosEndY                       to iY
86207>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86208>>>>>>>>>>>>>>>>>  End_Function
86209>>>>>>>>>>>>>>>>>  Function CM_EnableHideSel Integer bEnable Returns Integer
86211>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEHIDESEL,  ( bEnable ), 0 ) )
86212>>>>>>>>>>>>>>>>>  End_Function
86213>>>>>>>>>>>>>>>>>  Function CM_IsHideSelEnabled Returns Integer
86215>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_ISHIDESELENABLED, 0, 0 ) )
86216>>>>>>>>>>>>>>>>>  End_Function
86217>>>>>>>>>>>>>>>>>
86217>>>>>>>>>>>>>>>>>  //
86217>>>>>>>>>>>>>>>>>  // If a line is already highlighted then this will remove the highlight
86217>>>>>>>>>>>>>>>>>  //
86217>>>>>>>>>>>>>>>>>  Procedure ResetHighlightedLine
86219>>>>>>>>>>>>>>>>>    Handle  hMarker
86219>>>>>>>>>>>>>>>>>    Integer iLine
86219>>>>>>>>>>>>>>>>>    // Is there already a highlighted line? If so first delete the highlight on that line
86219>>>>>>>>>>>>>>>>>    Get phMarkerLineHighLight to hMarker
86220>>>>>>>>>>>>>>>>>    If (hMarker<>0) Begin
86222>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
86223>>>>>>>>>>>>>>>>>      If (iLine>-1) Begin
86225>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_LINEHIGHLIGHT
86226>>>>>>>>>>>>>>>>>      End
86226>>>>>>>>>>>>>>>>>>
86226>>>>>>>>>>>>>>>>>      Set phMarkerLineHighLight to 0
86227>>>>>>>>>>>>>>>>>    End
86227>>>>>>>>>>>>>>>>>>
86227>>>>>>>>>>>>>>>>>  End_Procedure
86228>>>>>>>>>>>>>>>>>
86228>>>>>>>>>>>>>>>>>  Function CM_SetHighlightedLine Integer iLine Returns Integer
86230>>>>>>>>>>>>>>>>>    Handle  hMarker
86230>>>>>>>>>>>>>>>>>
86230>>>>>>>>>>>>>>>>>    If (iLine>0) Begin
86232>>>>>>>>>>>>>>>>>      Send ResetHighlightedLine
86233>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_LINEHIGHLIGHT to hMarker
86234>>>>>>>>>>>>>>>>>      Set phMarkerLineHighLight to hMarker
86235>>>>>>>>>>>>>>>>>    End
86235>>>>>>>>>>>>>>>>>>
86235>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86236>>>>>>>>>>>>>>>>>  End_Function
86237>>>>>>>>>>>>>>>>>  //
86237>>>>>>>>>>>>>>>>>  // An application sends CMM_GETHIGHLIGHTEDLINE to retrieve the index of the currently highlighted line.
86237>>>>>>>>>>>>>>>>>  // The highlighted line can be used for marking the currently executing line when used in a debugger
86237>>>>>>>>>>>>>>>>>  // application
86237>>>>>>>>>>>>>>>>>  // Return Values
86237>>>>>>>>>>>>>>>>>  // The zero-based index of the line that is currently highlighted.
86237>>>>>>>>>>>>>>>>>  // If no line is highlighted, the return value is -1.
86237>>>>>>>>>>>>>>>>>  Function CM_GetHighlightedLine Returns Integer
86239>>>>>>>>>>>>>>>>>    Handle  hMarker
86239>>>>>>>>>>>>>>>>>    Integer iLine
86239>>>>>>>>>>>>>>>>>
86239>>>>>>>>>>>>>>>>>    Move -1 To iLine
86240>>>>>>>>>>>>>>>>>    Get phMarkerLineHighLight to hMarker
86241>>>>>>>>>>>>>>>>>    If (hMarker<>0) Begin
86243>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
86244>>>>>>>>>>>>>>>>>    End
86244>>>>>>>>>>>>>>>>>>
86244>>>>>>>>>>>>>>>>>    Function_Return iLine
86245>>>>>>>>>>>>>>>>>  End_Function
86246>>>>>>>>>>>>>>>>>  Function CM_EnableNormalizeCase Integer bEnable Returns Integer
86248>>>>>>>>>>>>>>>>>    Set pbNormalizeCase to bEnable
86249>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86250>>>>>>>>>>>>>>>>>  End_Function
86251>>>>>>>>>>>>>>>>>  Function CM_IsNormalizeCaseEnabled Returns Integer
86253>>>>>>>>>>>>>>>>>    Boolean bNormalized
86253>>>>>>>>>>>>>>>>>    Get pbNormalizeCase to bNormalized
86254>>>>>>>>>>>>>>>>>    Function_Return bNormalized
86255>>>>>>>>>>>>>>>>>  End_Function
86256>>>>>>>>>>>>>>>>>  Function CM_SetDivider Integer nLine Integer bEnable Returns Integer
86258>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETDIVIDER,  ( nLine ), ( bEnable ) ) )
86259>>>>>>>>>>>>>>>>>  End_Function
86260>>>>>>>>>>>>>>>>>  Function CM_GetDivider Integer nLine Returns Integer
86262>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETDIVIDER,  ( nLine ), 0 ) )
86263>>>>>>>>>>>>>>>>>  End_Function
86264>>>>>>>>>>>>>>>>>
86264>>>>>>>>>>>>>>>>>  //
86264>>>>>>>>>>>>>>>>>  // An application sends CMM_ENABLEOVERTYPECARET to control the size of the text caret when in overtype mode.
86264>>>>>>>>>>>>>>>>>  Function CM_EnableOvertypeCaret Integer bEnable Returns Integer
86266>>>>>>>>>>>>>>>>>    Integer iRet
86266>>>>>>>>>>>>>>>>>    Integer eCaretStyle
86266>>>>>>>>>>>>>>>>>    //
86266>>>>>>>>>>>>>>>>>    If (bEnable) Begin
86268>>>>>>>>>>>>>>>>>      Move CARETSTYLE_BLOCK To eCaretStyle
86269>>>>>>>>>>>>>>>>>    End
86269>>>>>>>>>>>>>>>>>>
86269>>>>>>>>>>>>>>>>>    Else Begin
86270>>>>>>>>>>>>>>>>>      Move CARETSTYLE_LINE  To eCaretStyle
86271>>>>>>>>>>>>>>>>>    End
86271>>>>>>>>>>>>>>>>>>
86271>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETCARETSTYLE eCaretStyle to iRet
86272>>>>>>>>>>>>>>>>>    Function_Return iRet
86273>>>>>>>>>>>>>>>>>  End_Function
86274>>>>>>>>>>>>>>>>>  Function CM_IsOvertypeCaretEnabled Returns Integer
86276>>>>>>>>>>>>>>>>>    Boolean bEnabled
86276>>>>>>>>>>>>>>>>>    Integer eCaretStyle
86276>>>>>>>>>>>>>>>>>    //
86276>>>>>>>>>>>>>>>>>    Move False to bEnabled
86277>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SETCARETSTYLE to eCaretStyle  // CMM_ISOVERTYPECARETENABLED
86278>>>>>>>>>>>>>>>>>    If (eCaretStyle=CARETSTYLE_BLOCK) Begin
86280>>>>>>>>>>>>>>>>>      Move True To bEnabled
86281>>>>>>>>>>>>>>>>>    End
86281>>>>>>>>>>>>>>>>>>
86281>>>>>>>>>>>>>>>>>    Function_Return bEnabled
86282>>>>>>>>>>>>>>>>>  End_Function
86283>>>>>>>>>>>>>>>>>  // An application sends CMM_SETFINDTEXT to change the text used in the most current search operation.
86283>>>>>>>>>>>>>>>>>  Function CM_SetFindText String szText  Returns Integer
86285>>>>>>>>>>>>>>>>>    Move (CString(szText)) To szText
86286>>>>>>>>>>>>>>>>>    Set psSearchText to szText
86287>>>>>>>>>>>>>>>>>    Function_Return CME_SUCCESS
86288>>>>>>>>>>>>>>>>>  End_Function
86289>>>>>>>>>>>>>>>>>  Function CM_GetFindText Returns String
86291>>>>>>>>>>>>>>>>>    String szText
86291>>>>>>>>>>>>>>>>>    Get psSearchText to szText
86292>>>>>>>>>>>>>>>>>    Move (szText+Character(0)) to szText // check if it makes sense to make this a zero terminated string
86293>>>>>>>>>>>>>>>>>    Function_Return szText
86294>>>>>>>>>>>>>>>>>  End_Function
86295>>>>>>>>>>>>>>>>>
86295>>>>>>>>>>>>>>>>>  Function CM_Print Handle hDC Integer dwFlags Returns Integer
86297>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_PRINT,  ( hDC ), ( dwFlags ) ) )
86298>>>>>>>>>>>>>>>>>  End_Function
86299>>>>>>>>>>>>>>>>>  Function CM_SetCaretPos Integer nLine Integer nCol Returns Integer
86301>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETCARETPOS,  ( nLine ), ( nCol ) ) )
86302>>>>>>>>>>>>>>>>>  End_Function
86303>>>>>>>>>>>>>>>>>  Function CM_ViewColToBufferCol Integer nLine Integer nViewCol  Returns Integer
86305>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_VIEWCOLTOBUFFERCOL,  ( nLine ), ( nViewCol ) ) )
86306>>>>>>>>>>>>>>>>>  End_Function
86307>>>>>>>>>>>>>>>>>  Function CM_BufferColToViewCol Integer nLine Integer nBufferCol Returns Integer
86309>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_BUFFERCOLTOVIEWCOL,  ( nLine ), ( nBufferCol ) ) )
86310>>>>>>>>>>>>>>>>>  End_Function
86311>>>>>>>>>>>>>>>>>  Function CM_SetBorderStyle Integer dwStyle Returns Integer
86313>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_SETBORDERSTYLE,  ( dwStyle ), 0 ) )
86314>>>>>>>>>>>>>>>>>  End_Function
86315>>>>>>>>>>>>>>>>>  Function CM_GetBorderStyle Returns Integer
86317>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETBORDERSTYLE, 0, 0 ) )
86318>>>>>>>>>>>>>>>>>  End_Function
86319>>>>>>>>>>>>>>>>>  // SVN
86319>>>>>>>>>>>>>>>>>  Function CM_GetCurrentToken Returns Integer
86321>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTTOKEN, 0, 0 ) )
86322>>>>>>>>>>>>>>>>>  End_Function
86323>>>>>>>>>>>>>>>>>  Function CM_UpdateControlPositions Returns Integer
86325>>>>>>>>>>>>>>>>>    Function_Return (SendMessage(Window_Handle(Self), CMM_UPDATECONTROLPOSITIONS, 0, 0 ) )
86326>>>>>>>>>>>>>>>>>  End_Function
86327>>>>>>>>>>>>>>>>>  // SVN
86327>>>>>>>>>>>>>>>>>
86327>>>>>>>>>>>>>>>>>  //_ADDITION_METHODS_for_an_easier_use.._________________
86327>>>>>>>>>>>>>>>>>
86327>>>>>>>>>>>>>>>>>
86327>>>>>>>>>>>>>>>>>  // ToDo: Out of Scope - Splitting window support in scintilla is not as natural. It can be done
86327>>>>>>>>>>>>>>>>>  // but for the moment I consider it out of scope. The documentation has this to say about it:
86327>>>>>>>>>>>>>>>>>  //
86327>>>>>>>>>>>>>>>>>  // The system is arranged in this way so that you can work with many documents in a single Scintilla
86327>>>>>>>>>>>>>>>>>  // window and so you can display a single document in multiple windows (for use with splitter windows).
86327>>>>>>>>>>>>>>>>>  //
86327>>>>>>>>>>>>>>>>>  //        // Tiling windows...
86327>>>>>>>>>>>>>>>>>  //    Procedure SplitWindowHorizontal
86327>>>>>>>>>>>>>>>>>  //        Integer iRet iPos
86327>>>>>>>>>>>>>>>>>  //        Move (CM_GetSplitterPos(Self,True))         to iPos
86327>>>>>>>>>>>>>>>>>  //        If iPos Eq 0 Move (Low(GuiSize(Self)))      to iPos
86327>>>>>>>>>>>>>>>>>  //        Else         Move 0                         to iPos
86327>>>>>>>>>>>>>>>>>  //        Move (iPos/2)                               to iPos
86327>>>>>>>>>>>>>>>>>  //        Move (CM_SetSplitterPos(Self,True,iPos))    to iRet
86327>>>>>>>>>>>>>>>>>  //    End_Procedure
86327>>>>>>>>>>>>>>>>>  //    Function isSplittedHorizonztal Returns Integer
86327>>>>>>>>>>>>>>>>>  //        Function_Return (CM_GetSplitterPos(Self,True) Ne 0)
86327>>>>>>>>>>>>>>>>>  //    End_Function
86327>>>>>>>>>>>>>>>>>  //    Procedure SplitWindowVertical
86327>>>>>>>>>>>>>>>>>  //        Integer iRet iPos
86327>>>>>>>>>>>>>>>>>  //        Move (CM_GetSplitterPos(Self,False))        to iPos
86327>>>>>>>>>>>>>>>>>  //        If iPos Eq 0 Move (Hi(GuiSize(Self)))       to iPos
86327>>>>>>>>>>>>>>>>>  //        Else         Move 0                         to iPos
86327>>>>>>>>>>>>>>>>>  //        Move (iPos/2)                               to iPos
86327>>>>>>>>>>>>>>>>>  //        Move (CM_SetSplitterPos(Self,False,iPos))   to iRet
86327>>>>>>>>>>>>>>>>>  //    End_Procedure
86327>>>>>>>>>>>>>>>>>  //    Function isSplittedVertical Returns Integer
86327>>>>>>>>>>>>>>>>>  //        Function_Return (CM_GetSplitterPos(Self,False) Ne 0)
86327>>>>>>>>>>>>>>>>>  //    End_Function
86327>>>>>>>>>>>>>>>>>  //        // Is a special usage for the splitter window.
86327>>>>>>>>>>>>>>>>>  //        // gren werden immer angepasst!
86327>>>>>>>>>>>>>>>>>  //    Procedure DuplicateWindow
86327>>>>>>>>>>>>>>>>>  //        If not (isSplittedHorizonztal(Self))     Send SplitWindowHorizontal
86327>>>>>>>>>>>>>>>>>  //        Else If not (isSplittedVertical(Self))   Send SplitWindowVertical
86327>>>>>>>>>>>>>>>>>  //    End_Procedure
86327>>>>>>>>>>>>>>>>>  //        // If all 4 sub windows are used. no more is possible.
86327>>>>>>>>>>>>>>>>>  //    Function isDuplicatePossible Returns Integer
86327>>>>>>>>>>>>>>>>>  //        If (isSplittedHorizonztal(Self)) If (isSplittedVertical(Self)) Function_Return 0
86327>>>>>>>>>>>>>>>>>  //        Function_Return 1
86327>>>>>>>>>>>>>>>>>  //    End_Function
86327>>>>>>>>>>>>>>>>>  //        // Check if some of the splitters are set.
86327>>>>>>>>>>>>>>>>>  //    Function isWindowDuplicated Returns Integer
86327>>>>>>>>>>>>>>>>>  //        If (isSplittedHorizonztal(Self)) Function_Return 1
86327>>>>>>>>>>>>>>>>>  //        If (isSplittedVertical(Self))    Function_Return 1
86327>>>>>>>>>>>>>>>>>  //        Function_Return 0
86327>>>>>>>>>>>>>>>>>  //    End_Function
86327>>>>>>>>>>>>>>>>>
86327>>>>>>>>>>>>>>>>>  // Removes all Splitter windows and
86327>>>>>>>>>>>>>>>>>  Procedure CloseWindow
86329>>>>>>>>>>>>>>>>>    //        If (isSplittedVertical(Self))           Send SplitWindowVertical
86329>>>>>>>>>>>>>>>>>    //        Else If (isSplittedHorizonztal(Self))   Send SplitWindowHorizontal
86329>>>>>>>>>>>>>>>>>  End_Procedure
86330>>>>>>>>>>>>>>>>>  // Select All
86330>>>>>>>>>>>>>>>>>  Procedure SelectAll
86332>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SELECTALL
86333>>>>>>>>>>>>>>>>>  End_Procedure
86334>>>>>>>>>>>>>>>>>
86334>>>>>>>>>>>>>>>>>  // Select this line...
86334>>>>>>>>>>>>>>>>>  Procedure SelectLine
86336>>>>>>>>>>>>>>>>>    Integer iRet
86336>>>>>>>>>>>>>>>>>    Get CM_ExecuteCmd CMD_SELECTLINE 0 to iRet
86337>>>>>>>>>>>>>>>>>  End_Procedure
86338>>>>>>>>>>>>>>>>>  // Deletes this line...
86338>>>>>>>>>>>>>>>>>  Procedure DeleteLine
86340>>>>>>>>>>>>>>>>>    Integer iRet
86340>>>>>>>>>>>>>>>>>    Get CM_ExecuteCmd CMD_LINEDELETE 0 to iRet
86341>>>>>>>>>>>>>>>>>  End_Procedure
86342>>>>>>>>>>>>>>>>>
86342>>>>>>>>>>>>>>>>>
86342>>>>>>>>>>>>>>>>>
86342>>>>>>>>>>>>>>>>>  Procedure MoveLineUp
86344>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MOVESELECTEDLINESUP
86345>>>>>>>>>>>>>>>>>  End_Procedure
86346>>>>>>>>>>>>>>>>>
86346>>>>>>>>>>>>>>>>>  Procedure MoveLineDown
86348>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_MOVESELECTEDLINESDOWN
86349>>>>>>>>>>>>>>>>>  End_Procedure
86350>>>>>>>>>>>>>>>>>
86350>>>>>>>>>>>>>>>>>  Procedure DuplicateSelection
86352>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SELECTIONDUPLICATE
86353>>>>>>>>>>>>>>>>>  End_Procedure
86354>>>>>>>>>>>>>>>>>
86354>>>>>>>>>>>>>>>>>  Function SetSearchOptions tFindReplaceOptions FindOptions Returns Integer
86356>>>>>>>>>>>>>>>>>    Integer iFlags
86356>>>>>>>>>>>>>>>>>
86356>>>>>>>>>>>>>>>>>    Move 0 to iFlags
86357>>>>>>>>>>>>>>>>>    Move (If(FindOptions.bWordMatch,iFlags iOr SCFIND_WHOLEWORD,iFlags)) To iFlags
86358>>>>>>>>>>>>>>>>>    Move (If(FindOptions.bMatchCase,iFlags iOr SCFIND_MATCHCASE,iFlags)) To iFlags
86359>>>>>>>>>>>>>>>>>    Move (If(FindOptions.bRegExp   ,iFlags iOr SCFIND_REGEXP   ,iFlags)) To iFlags
86360>>>>>>>>>>>>>>>>>    Set pbFindDocumentStart To FindOptions.bDocumentStart
86361>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_SETSEARCHFLAGS iFlags
86362>>>>>>>>>>>>>>>>>    Function_Return iFlags
86363>>>>>>>>>>>>>>>>>  End_Function
86364>>>>>>>>>>>>>>>>>
86364>>>>>>>>>>>>>>>>>  Function CurrentSearchOptions String sSearchText Returns tFindReplaceOptions
86366>>>>>>>>>>>>>>>>>    Integer iFlags
86366>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
86366>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
86366>>>>>>>>>>>>>>>>>
86366>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
86367>>>>>>>>>>>>>>>>>    Move sSearchText                    To FindOptions.sSearchText
86368>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_WHOLEWORD) To FindOptions.bWordMatch
86369>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_MATCHCASE) To FindOptions.bMatchCase
86370>>>>>>>>>>>>>>>>>    Move (iFlags iAnd SCFIND_REGEXP)    To FindOptions.bRegExp
86371>>>>>>>>>>>>>>>>>    Get pbFindDocumentStart To FindOptions.bDocumentStart
86372>>>>>>>>>>>>>>>>>    Function_Return FindOptions
86373>>>>>>>>>>>>>>>>>  End_Function
86374>>>>>>>>>>>>>>>>>
86374>>>>>>>>>>>>>>>>>
86374>>>>>>>>>>>>>>>>>  // Find...
86374>>>>>>>>>>>>>>>>>  Procedure Find
86376>>>>>>>>>>>>>>>>>    Integer iFlags
86376>>>>>>>>>>>>>>>>>    Integer iCaretPos
86376>>>>>>>>>>>>>>>>>    Integer iPos
86376>>>>>>>>>>>>>>>>>    Integer iLen
86376>>>>>>>>>>>>>>>>>    Integer iLine
86376>>>>>>>>>>>>>>>>>    Integer iVoid
86376>>>>>>>>>>>>>>>>>    String  sSearchText
86376>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
86376>>>>>>>>>>>>>>>>>    tFindReplaceOptions FindOptions
86376>>>>>>>>>>>>>>>>>
86376>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
86377>>>>>>>>>>>>>>>>>    //
86377>>>>>>>>>>>>>>>>>    Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
86378>>>>>>>>>>>>>>>>>    Get CurrentSearchOptions sSearchText to FindOptions
86379>>>>>>>>>>>>>>>>>    Move FindDown         To FindOptions.eFindOptions // search down by default
86380>>>>>>>>>>>>>>>>>    Send RequestDetails of oFindDialog (&FindOptions)
86381>>>>>>>>>>>>>>>>>    If (FindOptions.bStartFind) Begin
86383>>>>>>>>>>>>>>>>>      // First update any changed search flags
86383>>>>>>>>>>>>>>>>>      Get SetSearchOptions FindOptions to iFlags
86384>>>>>>>>>>>>>>>>>      Move FindOptions.sSearchText To sSearchText
86385>>>>>>>>>>>>>>>>>      Set psSearchText to sSearchText
86386>>>>>>>>>>>>>>>>>      Move (Length(sSearchText)) To iLen
86387>>>>>>>>>>>>>>>>>      If (iLen>0) Begin
86389>>>>>>>>>>>>>>>>>        If (FindOptions.bDocumentStart=False) Begin
86391>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETCURRENTPOS To iCaretPos
86392>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETTARGETSTART iCaretPos
86393>>>>>>>>>>>>>>>>>        End
86393>>>>>>>>>>>>>>>>>>
86393>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
86394>>>>>>>>>>>>>>>>>        If (iPos > -1) Begin
86396>>>>>>>>>>>>>>>>>          If (FindOptions.bMarkAll=false) Begin
86398>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
86399>>>>>>>>>>>>>>>>>          End
86399>>>>>>>>>>>>>>>>>>
86399>>>>>>>>>>>>>>>>>          Else Begin  // Mark All logic
86400>>>>>>>>>>>>>>>>>            Move iPos To iCaretPos
86401>>>>>>>>>>>>>>>>>            While (iPos>-1)
86405>>>>>>>>>>>>>>>>>              // set bookmark for found position
86405>>>>>>>>>>>>>>>>>              Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
86406>>>>>>>>>>>>>>>>>              Get CM_SetBookmark iLine True to iVoid
86407>>>>>>>>>>>>>>>>>              // find next
86407>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
86408>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_SEARCHANCHOR
86409>>>>>>>>>>>>>>>>>              Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
86410>>>>>>>>>>>>>>>>>            Loop
86411>>>>>>>>>>>>>>>>>>
86411>>>>>>>>>>>>>>>>>            If (iCaretPos>-1) Begin
86413>>>>>>>>>>>>>>>>>              // select first found
86413>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
86414>>>>>>>>>>>>>>>>>            End
86414>>>>>>>>>>>>>>>>>>
86414>>>>>>>>>>>>>>>>>          End
86414>>>>>>>>>>>>>>>>>>
86414>>>>>>>>>>>>>>>>>        End
86414>>>>>>>>>>>>>>>>>>
86414>>>>>>>>>>>>>>>>>      End
86414>>>>>>>>>>>>>>>>>>
86414>>>>>>>>>>>>>>>>>    End
86414>>>>>>>>>>>>>>>>>>
86414>>>>>>>>>>>>>>>>>
86414>>>>>>>>>>>>>>>>>    //
86414>>>>>>>>>>>>>>>>>    // There's an alternative interface that works like this, not seeing why this would be more
86414>>>>>>>>>>>>>>>>>    // convenient.
86414>>>>>>>>>>>>>>>>>    //
86414>>>>>>>>>>>>>>>>>    //Integer iStartPos
86414>>>>>>>>>>>>>>>>>    //Integer iEndPos
86414>>>>>>>>>>>>>>>>>    //Sci_TextToFind ft
86414>>>>>>>>>>>>>>>>>    //
86414>>>>>>>>>>>>>>>>>    //Move 0 To iStartPos
86414>>>>>>>>>>>>>>>>>    //Move 100 to iEndPos
86414>>>>>>>>>>>>>>>>>    //Move iStartPos To ft.chrg.cpMin
86414>>>>>>>>>>>>>>>>>    //Move iEndPos   To ft.chrg.cpMax
86414>>>>>>>>>>>>>>>>>    //Move (sSearchText+Character(0)) To sSearchText
86414>>>>>>>>>>>>>>>>>    //Move (AddressOf(sSearchText)) To ft.pszText
86414>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_GETSEARCHFLAGS to iFlags
86414>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_FINDTEXT iFlags (AddressOf(ft)) to iRet
86414>>>>>>>>>>>>>>>>>    //If (iRet > -1) Begin
86414>>>>>>>>>>>>>>>>>    //  Send none
86414>>>>>>>>>>>>>>>>>    //End
86414>>>>>>>>>>>>>>>>>  End_Procedure
86415>>>>>>>>>>>>>>>>>
86415>>>>>>>>>>>>>>>>>  // Find First
86415>>>>>>>>>>>>>>>>>  Procedure FindFirst
86417>>>>>>>>>>>>>>>>>    Integer iCaretPos
86417>>>>>>>>>>>>>>>>>    Integer iLen
86417>>>>>>>>>>>>>>>>>    Integer iPos
86417>>>>>>>>>>>>>>>>>    String  sSearchText
86417>>>>>>>>>>>>>>>>>
86417>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
86418>>>>>>>>>>>>>>>>>
86418>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
86419>>>>>>>>>>>>>>>>>    Move (Length(sSearchText)) To iLen
86420>>>>>>>>>>>>>>>>>    If (iLen>0) Begin
86422>>>>>>>>>>>>>>>>>      Move (sSearchText+character(0)) To sSearchText
86423>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETCURRENTPOS to iCaretPos
86424>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETTARGETSTART 0
86425>>>>>>>>>>>>>>>>>
86425>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
86426>>>>>>>>>>>>>>>>>      If (iPos>-1) Begin
86428>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
86429>>>>>>>>>>>>>>>>>      End
86429>>>>>>>>>>>>>>>>>>
86429>>>>>>>>>>>>>>>>>      Else Begin
86430>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
86431>>>>>>>>>>>>>>>>>        Set Status_Help to (_T("Find Next: No more occurrences have been found.",1606))
86432>>>>>>>>>>>>>>>>>        Send Request_Status_Help True
86433>>>>>>>>>>>>>>>>>      End
86433>>>>>>>>>>>>>>>>>>
86433>>>>>>>>>>>>>>>>>    End
86433>>>>>>>>>>>>>>>>>>
86433>>>>>>>>>>>>>>>>>  End_Procedure
86434>>>>>>>>>>>>>>>>>
86434>>>>>>>>>>>>>>>>>  // Find next
86434>>>>>>>>>>>>>>>>>  Procedure FindNext
86436>>>>>>>>>>>>>>>>>    Integer iCaretPos
86436>>>>>>>>>>>>>>>>>    Integer iFlags
86436>>>>>>>>>>>>>>>>>    Integer iLen
86436>>>>>>>>>>>>>>>>>    Integer iPos
86436>>>>>>>>>>>>>>>>>    Integer iStartPos
86436>>>>>>>>>>>>>>>>>    String  sSearchText
86436>>>>>>>>>>>>>>>>>
86436>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
86437>>>>>>>>>>>>>>>>>    Move (Length(sSearchText)) To iLen
86438>>>>>>>>>>>>>>>>>    If (iLen>0) Begin
86440>>>>>>>>>>>>>>>>>      Move (sSearchText+character(0)) To sSearchText
86441>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iCaretPos
86442>>>>>>>>>>>>>>>>>      Move (iCaretPos+iLen) To iStartPos
86443>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETCURRENTPOS iStartPos
86444>>>>>>>>>>>>>>>>>
86444>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SEARCHANCHOR
86445>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
86446>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
86447>>>>>>>>>>>>>>>>>      If (iPos>-1) Begin
86449>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
86450>>>>>>>>>>>>>>>>>      End
86450>>>>>>>>>>>>>>>>>>
86450>>>>>>>>>>>>>>>>>      Else Begin
86451>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
86452>>>>>>>>>>>>>>>>>        Set Status_Help to (_T("Find Next: No more occurrences have been found.",1606))
86453>>>>>>>>>>>>>>>>>        Send Request_Status_Help True
86454>>>>>>>>>>>>>>>>>      End
86454>>>>>>>>>>>>>>>>>>
86454>>>>>>>>>>>>>>>>>    End
86454>>>>>>>>>>>>>>>>>>
86454>>>>>>>>>>>>>>>>>  End_Procedure
86455>>>>>>>>>>>>>>>>>
86455>>>>>>>>>>>>>>>>>  Procedure FindPrevious
86457>>>>>>>>>>>>>>>>>    Integer iFlags
86457>>>>>>>>>>>>>>>>>    Integer iLen
86457>>>>>>>>>>>>>>>>>    Integer iPos
86457>>>>>>>>>>>>>>>>>    String  sSearchText
86457>>>>>>>>>>>>>>>>>
86457>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
86458>>>>>>>>>>>>>>>>>    Move (Length(sSearchText)) To iLen
86459>>>>>>>>>>>>>>>>>    If (iLen>0) Begin
86461>>>>>>>>>>>>>>>>>      Move (sSearchText+character(0)) To sSearchText
86462>>>>>>>>>>>>>>>>>
86462>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SEARCHANCHOR
86463>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
86464>>>>>>>>>>>>>>>>>      Get  EditorMessage SCI_SEARCHPREV iFlags (AddressOf(sSearchText)) to iPos
86465>>>>>>>>>>>>>>>>>      If (iPos>-1) Begin
86467>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
86468>>>>>>>>>>>>>>>>>      End
86468>>>>>>>>>>>>>>>>>>
86468>>>>>>>>>>>>>>>>>      Else Begin
86469>>>>>>>>>>>>>>>>>        Set Status_Help to (_T("Find Previous: No more occurrences have been found.",1607))
86470>>>>>>>>>>>>>>>>>        Send Request_Status_Help True
86471>>>>>>>>>>>>>>>>>      End
86471>>>>>>>>>>>>>>>>>>
86471>>>>>>>>>>>>>>>>>    End
86471>>>>>>>>>>>>>>>>>>
86471>>>>>>>>>>>>>>>>>  End_Procedure
86472>>>>>>>>>>>>>>>>>
86472>>>>>>>>>>>>>>>>>  Procedure Replace
86474>>>>>>>>>>>>>>>>>    Integer iCaretPos
86474>>>>>>>>>>>>>>>>>    Integer iPos
86474>>>>>>>>>>>>>>>>>    Integer iStartPos
86474>>>>>>>>>>>>>>>>>    Integer iLen
86474>>>>>>>>>>>>>>>>>    Integer iFlags
86474>>>>>>>>>>>>>>>>>    String  sSearchText
86474>>>>>>>>>>>>>>>>>    tFindReplaceOptions ReplaceOptions
86474>>>>>>>>>>>>>>>>>    tFindReplaceOptions ReplaceOptions
86474>>>>>>>>>>>>>>>>>
86474>>>>>>>>>>>>>>>>>    Move 0 To iCaretPos
86475>>>>>>>>>>>>>>>>>    Move 0 To iStartPos
86476>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_TARGETWHOLEDOCUMENT
86477>>>>>>>>>>>>>>>>>    //
86477>>>>>>>>>>>>>>>>>    Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
86478>>>>>>>>>>>>>>>>>    Get CurrentSearchOptions sSearchText to ReplaceOptions
86479>>>>>>>>>>>>>>>>>
86479>>>>>>>>>>>>>>>>>    Send RequestDetails of oReplaceDialog (&ReplaceOptions) (Object_Id(Self))
86480>>>>>>>>>>>>>>>>>    If (ReplaceOptions.bReplaceAll) Begin
86482>>>>>>>>>>>>>>>>>      // First update any changed search flags
86482>>>>>>>>>>>>>>>>>      Get SetSearchOptions ReplaceOptions to iFlags
86483>>>>>>>>>>>>>>>>>      Move ReplaceOptions.sSearchText To sSearchText
86484>>>>>>>>>>>>>>>>>      Set psSearchText to sSearchText
86485>>>>>>>>>>>>>>>>>      Move (Length(sSearchText)) To iLen
86486>>>>>>>>>>>>>>>>>      If (iLen>0) Begin
86488>>>>>>>>>>>>>>>>>        Move 0 To iStartPos
86489>>>>>>>>>>>>>>>>>        If (ReplaceOptions.bDocumentStart=False) Begin
86491>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETCURRENTPOS To iCaretPos
86492>>>>>>>>>>>>>>>>>          Move iCaretPos To iStartPos
86493>>>>>>>>>>>>>>>>>        End
86493>>>>>>>>>>>>>>>>>>
86493>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_SETTARGETSTART iStartPos
86494>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
86495>>>>>>>>>>>>>>>>>        If (iPos > -1) Begin
86497>>>>>>>>>>>>>>>>>          Move iPos To iCaretPos
86498>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_BEGINUNDOACTION
86499>>>>>>>>>>>>>>>>>          While (iPos>-1)
86503>>>>>>>>>>>>>>>>>            // select found text then replace it
86503>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
86504>>>>>>>>>>>>>>>>>            Send ReplaceText ReplaceOptions.sReplaceText
86505>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETSEL (iPos+iLen) (iPos+iLen) // remove selection
86506>>>>>>>>>>>>>>>>>            // find next
86506>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
86507>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_SEARCHANCHOR
86508>>>>>>>>>>>>>>>>>            Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
86509>>>>>>>>>>>>>>>>>          Loop
86510>>>>>>>>>>>>>>>>>>
86510>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_ENDUNDOACTION
86511>>>>>>>>>>>>>>>>>          // select first replaced
86511>>>>>>>>>>>>>>>>>          Move (Length(ReplaceOptions.sReplaceText)) To iLen
86512>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
86513>>>>>>>>>>>>>>>>>        End
86513>>>>>>>>>>>>>>>>>>
86513>>>>>>>>>>>>>>>>>      End
86513>>>>>>>>>>>>>>>>>>
86513>>>>>>>>>>>>>>>>>    End
86513>>>>>>>>>>>>>>>>>>
86513>>>>>>>>>>>>>>>>>  End_Procedure
86514>>>>>>>>>>>>>>>>>
86514>>>>>>>>>>>>>>>>>  Procedure ReplaceText String sReplaceWith
86516>>>>>>>>>>>>>>>>>    String sTargetText
86516>>>>>>>>>>>>>>>>>    String sReplaceText
86516>>>>>>>>>>>>>>>>>    String sSearchText
86516>>>>>>>>>>>>>>>>>    Integer iVoid
86516>>>>>>>>>>>>>>>>>
86516>>>>>>>>>>>>>>>>>    Get psSearchText to sSearchText
86517>>>>>>>>>>>>>>>>>    If (sSearchText<>"") Begin
86519>>>>>>>>>>>>>>>>>      Move (sReplaceWith+"") To sReplaceText
86520>>>>>>>>>>>>>>>>>      Move (ZeroString(300)) to sTargetText
86521>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_TARGETFROMSELECTION
86522>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETTARGETTEXT 0 (AddressOf(sTargetText)) to iVoid
86523>>>>>>>>>>>>>>>>>      If (lowercase(Cstring(sTargetText)) = lowercase(sSearchText)) Begin
86525>>>>>>>>>>>>>>>>>        //Send EditorMessage SCI_SETTARGETRANGE iPos iPos
86525>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sReplaceText))
86526>>>>>>>>>>>>>>>>>      End
86526>>>>>>>>>>>>>>>>>>
86526>>>>>>>>>>>>>>>>>    End
86526>>>>>>>>>>>>>>>>>>
86526>>>>>>>>>>>>>>>>>  End_Procedure
86527>>>>>>>>>>>>>>>>>
86527>>>>>>>>>>>>>>>>>  //        // Replace
86527>>>>>>>>>>>>>>>>>  //    Procedure Replace
86527>>>>>>>>>>>>>>>>>  //        Integer iRet
86527>>>>>>>>>>>>>>>>>  //        Get CM_ExecuteCmd CMD_FindReplace 0 to iRet
86527>>>>>>>>>>>>>>>>>  //    End_Procedure
86527>>>>>>>>>>>>>>>>>
86527>>>>>>>>>>>>>>>>>  // Goto line...
86527>>>>>>>>>>>>>>>>>  // CMD_GOTOLINE - Moves to a user-specified line.
86527>>>>>>>>>>>>>>>>>  // ( int ) The zero-based line number to jump to.
86527>>>>>>>>>>>>>>>>>  // If no argument is passed then the user is prompted.
86527>>>>>>>>>>>>>>>>>  Procedure GotoLine Integer iNrEx
86529>>>>>>>>>>>>>>>>>    Integer iLine iRet
86529>>>>>>>>>>>>>>>>>    Integer iScreenLines
86529>>>>>>>>>>>>>>>>>    Integer iFirstLine
86529>>>>>>>>>>>>>>>>>    Integer iLinesToScroll
86529>>>>>>>>>>>>>>>>>
86529>>>>>>>>>>>>>>>>>    If NUM_Arguments Gt 0 Begin
86531>>>>>>>>>>>>>>>>>      Move iNrEx    to iLine
86532>>>>>>>>>>>>>>>>>    End
86532>>>>>>>>>>>>>>>>>>
86532>>>>>>>>>>>>>>>>>    Else Begin
86533>>>>>>>>>>>>>>>>>      Send RequestDetails to oGotoDialog (&iLine)
86534>>>>>>>>>>>>>>>>>      If (iLine<0) Begin
86536>>>>>>>>>>>>>>>>>        Procedure_Return
86537>>>>>>>>>>>>>>>>>      End
86537>>>>>>>>>>>>>>>>>>
86537>>>>>>>>>>>>>>>>>    End
86537>>>>>>>>>>>>>>>>>>
86537>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_GOTOLINE iLine
86538>>>>>>>>>>>>>>>>>    Get CM_SetHighlightedLine iLine to iRet
86539>>>>>>>>>>>>>>>>>    // SCI_LINESONSCREEN = get lines visible on screen
86539>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINESONSCREEN to iScreenLines
86540>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFIRSTVISIBLELINE to iFirstLine
86541>>>>>>>>>>>>>>>>>    Get piLinesToScrollAfterGoto to iLinesToScroll // scroll a few lines to display more context if at
86542>>>>>>>>>>>>>>>>>    If (iScreenLines > iLinesToScroll) Begin       // first or last line in the window after the goto line.
86544>>>>>>>>>>>>>>>>>      If (iLine=iFirstLine) Begin
86546>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_LINESCROLL 0 (-iLinesToScroll)
86547>>>>>>>>>>>>>>>>>      End
86547>>>>>>>>>>>>>>>>>>
86547>>>>>>>>>>>>>>>>>      Else If (iLine=(iFirstLine+iScreenLines-1)) Begin
86550>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_LINESCROLL 0 iLinesToScroll
86551>>>>>>>>>>>>>>>>>      End
86551>>>>>>>>>>>>>>>>>>
86551>>>>>>>>>>>>>>>>>    End
86551>>>>>>>>>>>>>>>>>>
86551>>>>>>>>>>>>>>>>>  End_Procedure
86552>>>>>>>>>>>>>>>>>
86552>>>>>>>>>>>>>>>>>  //
86552>>>>>>>>>>>>>>>>>  // useful for debugging
86552>>>>>>>>>>>>>>>>>  //
86552>>>>>>>>>>>>>>>>>  Procedure showCurrentLineStyle
86554>>>>>>>>>>>>>>>>>    Integer iVoid iStartLine //iStartCol iEndLine iEndCol
86554>>>>>>>>>>>>>>>>>    Integer iPosStart
86554>>>>>>>>>>>>>>>>>    Integer iPosChar iPos
86554>>>>>>>>>>>>>>>>>    Integer eStyle
86554>>>>>>>>>>>>>>>>>    Integer iLineLength
86554>>>>>>>>>>>>>>>>>    String  sLine
86554>>>>>>>>>>>>>>>>>
86554>>>>>>>>>>>>>>>>>    Get CM_GetSel False  to iVoid
86555>>>>>>>>>>>>>>>>>    Get piSelStartLine   to iStartLine
86556>>>>>>>>>>>>>>>>>    Get value item iStartLine to sLine
86557>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iStartLine to iPosStart
86558>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH iStartLine to iLineLength
86559>>>>>>>>>>>>>>>>>    Showln sLine
86561>>>>>>>>>>>>>>>>>    For iPosChar from iPosStart to (iPosStart+iLineLength)
86567>>>>>>>>>>>>>>>>>>
86567>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETSTYLEAT iPosChar to eStyle
86568>>>>>>>>>>>>>>>>>      Move (iPosChar-iPosStart+1) To iPos // to keep it simple,  this is the position in the sLine string
86569>>>>>>>>>>>>>>>>>      Showln "Style for [" (Mid(sLine,1,iPos)) "] " (iPosChar-iPosStart) " " eStyle
86576>>>>>>>>>>>>>>>>>    Loop
86577>>>>>>>>>>>>>>>>>>
86577>>>>>>>>>>>>>>>>>  End_Procedure
86578>>>>>>>>>>>>>>>>>
86578>>>>>>>>>>>>>>>>>  //
86578>>>>>>>>>>>>>>>>>  // Normalizes the selected line by finding the DataFlex keywords in the line and then
86578>>>>>>>>>>>>>>>>>  // matching those up with how they are defined and adjusting the case if needed.
86578>>>>>>>>>>>>>>>>>  // If bUndo is true then it will add an undo action for this line.
86578>>>>>>>>>>>>>>>>>  // Will return true if the line was changed.
86578>>>>>>>>>>>>>>>>>  //
86578>>>>>>>>>>>>>>>>>  Function LineNormalizeCase Integer iLine Boolean bUndo Returns Boolean
86580>>>>>>>>>>>>>>>>>    Boolean bChanged
86580>>>>>>>>>>>>>>>>>    Integer iPosStart
86580>>>>>>>>>>>>>>>>>    Integer iPosChar iPos
86580>>>>>>>>>>>>>>>>>    Integer eStyle eLastStyle
86580>>>>>>>>>>>>>>>>>    Integer iLineLength
86580>>>>>>>>>>>>>>>>>    Integer iWordStart
86580>>>>>>>>>>>>>>>>>    String  sLine sTALine
86580>>>>>>>>>>>>>>>>>    String  sWord sTAWord
86580>>>>>>>>>>>>>>>>>
86580>>>>>>>>>>>>>>>>>    Move False To bChanged
86581>>>>>>>>>>>>>>>>>    Get value item iLine to sLine
86582>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_FINDCOLUMN iLine to iPosStart
86583>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINELENGTH iLine to iLineLength
86584>>>>>>>>>>>>>>>>>    Move sLine To sTALine
86585>>>>>>>>>>>>>>>>>    For iPosChar from iPosStart to (iPosStart+iLineLength)
86591>>>>>>>>>>>>>>>>>>
86591>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETSTYLEAT iPosChar to eStyle
86592>>>>>>>>>>>>>>>>>      Move (iPosChar-iPosStart+1) To iPos // to keep it simple,  this is the position in the sLine string
86593>>>>>>>>>>>>>>>>>      //Showln "Style " (iPosChar-iPosStart) " " eStyle
86593>>>>>>>>>>>>>>>>>      If (eStyle=SCE_DF_WORD and eLastStyle<>SCE_DF_WORD) Begin
86595>>>>>>>>>>>>>>>>>        Move SCE_DF_WORD To eLastStyle
86596>>>>>>>>>>>>>>>>>        Move iPos to iWordStart
86597>>>>>>>>>>>>>>>>>      End
86597>>>>>>>>>>>>>>>>>>
86597>>>>>>>>>>>>>>>>>      Else If (eStyle=SCE_DF_SCOPEWORD and eLastStyle<>SCE_DF_SCOPEWORD) Begin
86600>>>>>>>>>>>>>>>>>        Move SCE_DF_SCOPEWORD To eLastStyle
86601>>>>>>>>>>>>>>>>>        Move iPos To iWordStart
86602>>>>>>>>>>>>>>>>>      End
86602>>>>>>>>>>>>>>>>>>
86602>>>>>>>>>>>>>>>>>      If (eLastStyle=SCE_DF_WORD and eStyle<>SCE_DF_WORD) Begin
86604>>>>>>>>>>>>>>>>>        //Show " [" (Mid(sLine,iPos-iWordStart,iWordStart)) "]"
86604>>>>>>>>>>>>>>>>>        Move (Mid(sLine,iPos-iWordStart,iWordStart)) To sWord
86605>>>>>>>>>>>>>>>>>        Get FindKeyWord of oNormalizeCase SCLEX_DATAFLEX sWord to sTAWord
86606>>>>>>>>>>>>>>>>>        Move (Overstrike(sTAWord,sTALine,iWordStart)) To sTALine
86607>>>>>>>>>>>>>>>>>        Move 0 To eLastStyle
86608>>>>>>>>>>>>>>>>>      End
86608>>>>>>>>>>>>>>>>>>
86608>>>>>>>>>>>>>>>>>      Else If (eLastStyle=SCE_DF_SCOPEWORD and eStyle<>SCE_DF_SCOPEWORD) Begin
86611>>>>>>>>>>>>>>>>>        //Show " <" (Mid(sLine,iPos-iWordStart,iWordStart)) ">"
86611>>>>>>>>>>>>>>>>>        Move (Mid(sLine,iPos-iWordStart,iWordStart)) To sWord
86612>>>>>>>>>>>>>>>>>        Get FindScopeWord of oNormalizeCase SCLEX_DATAFLEX sWord to sTAWord
86613>>>>>>>>>>>>>>>>>        Move (Overstrike(sTAWord,sTALine,iWordStart)) To sTALine
86614>>>>>>>>>>>>>>>>>        Move 0 To eLastStyle
86615>>>>>>>>>>>>>>>>>      End
86615>>>>>>>>>>>>>>>>>>
86615>>>>>>>>>>>>>>>>>    Loop
86616>>>>>>>>>>>>>>>>>>
86616>>>>>>>>>>>>>>>>>    If (sLine<>sTALine) Begin
86618>>>>>>>>>>>>>>>>>      Move True To bChanged
86619>>>>>>>>>>>>>>>>>      If (bUndo) Begin
86621>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_BEGINUNDOACTION
86622>>>>>>>>>>>>>>>>>      End
86622>>>>>>>>>>>>>>>>>>
86622>>>>>>>>>>>>>>>>>      Set Value Item iLine To sTALine
86623>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_COLOURISE iPosStart (iPosStart+iLineLength)  // apply style to the changed text!
86624>>>>>>>>>>>>>>>>>      If (bUndo) Begin
86626>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_ENDUNDOACTION
86627>>>>>>>>>>>>>>>>>      End
86627>>>>>>>>>>>>>>>>>>
86627>>>>>>>>>>>>>>>>>    End
86627>>>>>>>>>>>>>>>>>>
86627>>>>>>>>>>>>>>>>>    Function_Return bChanged
86628>>>>>>>>>>>>>>>>>  End_Function
86629>>>>>>>>>>>>>>>>>
86629>>>>>>>>>>>>>>>>>
86629>>>>>>>>>>>>>>>>>  Procedure doNormalizeCase
86631>>>>>>>>>>>>>>>>>    Boolean bChanged
86631>>>>>>>>>>>>>>>>>    Integer iVoid iStartLine iStartCol iEndLine iEndCol
86631>>>>>>>>>>>>>>>>>
86631>>>>>>>>>>>>>>>>>    //Send EditorMessage SCI_CLEARCMDKEY ((65536*(SCMOD_CTRL))+Ascii("O"))
86631>>>>>>>>>>>>>>>>>
86631>>>>>>>>>>>>>>>>>    Get CM_GetSel False  to iVoid
86632>>>>>>>>>>>>>>>>>    Get piSelStartLine   to iStartLine
86633>>>>>>>>>>>>>>>>>    Get piSelStartCol    to iStartCol
86634>>>>>>>>>>>>>>>>>    Get piSelEndLine     to iEndLine
86635>>>>>>>>>>>>>>>>>    Get piSelEndCol      To iEndCol
86636>>>>>>>>>>>>>>>>>    Get LineNormalizeCase iStartLine True To bChanged
86637>>>>>>>>>>>>>>>>>    If (bChanged) Begin
86639>>>>>>>>>>>>>>>>>      // move cursor back to where it was
86639>>>>>>>>>>>>>>>>>      Get CM_SetSel iStartLine iStartCol iEndLine iEndCol True to iVoid
86640>>>>>>>>>>>>>>>>>    End
86640>>>>>>>>>>>>>>>>>>
86640>>>>>>>>>>>>>>>>>  End_Procedure
86641>>>>>>>>>>>>>>>>>
86641>>>>>>>>>>>>>>>>>  Procedure StartUndoTransaction
86643>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
86644>>>>>>>>>>>>>>>>>  End_Procedure
86645>>>>>>>>>>>>>>>>>
86645>>>>>>>>>>>>>>>>>  Procedure EndUndoTransaction
86647>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
86648>>>>>>>>>>>>>>>>>  End_Procedure
86649>>>>>>>>>>>>>>>>>
86649>>>>>>>>>>>>>>>>>
86649>>>>>>>>>>>>>>>>>  // Fills the position of the cursor in pixels into Properties.
86649>>>>>>>>>>>>>>>>>  // - getting the curren postion in Line / Col
86649>>>>>>>>>>>>>>>>>  // - Retrieving this Position in Pixesl with CM_PosFromChar
86649>>>>>>>>>>>>>>>>>  // - Retrieving the absolute position of the Window
86649>>>>>>>>>>>>>>>>>  // =  ABSOLUTE CURSOR POSITION in the Edit.
86649>>>>>>>>>>>>>>>>>  Procedure FillCurrentPosition
86651>>>>>>>>>>>>>>>>>    Integer iRet
86651>>>>>>>>>>>>>>>>>    Move (CM_GetSel(Self,False))                                        to iRet
86652>>>>>>>>>>>>>>>>>    Move (CM_PosFromChar(Self,piSelEndLine(Self),piSelEndCol(Self)))    to iRet
86653>>>>>>>>>>>>>>>>>    Set piAbsPosYEnd    to (Hi (Absolute_GuiOriginEx(Self))+piPosEndY(Self))
86654>>>>>>>>>>>>>>>>>    Set piAbsPosXEnd    to (Low(Absolute_GuiOriginEx(Self))+piPosEndX(Self))
86655>>>>>>>>>>>>>>>>>    Set piAbsPosYStart  to (Hi (Absolute_GuiOriginEx(Self))+piPosStartY(Self))
86656>>>>>>>>>>>>>>>>>    Set piAbsPosXStart  to (Low(Absolute_GuiOriginEx(Self))+piPosStartX(Self))
86657>>>>>>>>>>>>>>>>>  End_Procedure
86658>>>>>>>>>>>>>>>>>
86658>>>>>>>>>>>>>>>>>  // Delivers the current line.
86658>>>>>>>>>>>>>>>>>  Function Current_Item Returns Integer
86660>>>>>>>>>>>>>>>>>    Integer iRet
86660>>>>>>>>>>>>>>>>>    Get CM_GetSel False                 to iRet
86661>>>>>>>>>>>>>>>>>    Function_Return (piSelEndLine(Self))
86662>>>>>>>>>>>>>>>>>  End_Function
86663>>>>>>>>>>>>>>>>>  //  As I'm a bit thick, let's create a function with that name to make my life easier
86663>>>>>>>>>>>>>>>>>  Function Current_Line Returns Integer
86665>>>>>>>>>>>>>>>>>    Integer iRet
86665>>>>>>>>>>>>>>>>>    Get CM_GetSel False                 to iRet
86666>>>>>>>>>>>>>>>>>    Function_Return (piSelEndLine(Self))
86667>>>>>>>>>>>>>>>>>  End_Function
86668>>>>>>>>>>>>>>>>>  // For VDF closer access.    - number of lines.
86668>>>>>>>>>>>>>>>>>  Function Item_Count Returns Integer
86670>>>>>>>>>>>>>>>>>    Function_Return (SC_LineCount(Self))
86671>>>>>>>>>>>>>>>>>  End_Function
86672>>>>>>>>>>>>>>>>>  // Value of the line with the given LineNr.
86672>>>>>>>>>>>>>>>>>  Function Value Integer iItem Returns String
86674>>>>>>>>>>>>>>>>>    If iItem Eq -99 Begin
86676>>>>>>>>>>>>>>>>>      Move (Current_Item(Self)) to iItem
86677>>>>>>>>>>>>>>>>>    End
86677>>>>>>>>>>>>>>>>>>
86677>>>>>>>>>>>>>>>>>    Function_Return (CM_GetLine(Self,iItem))
86678>>>>>>>>>>>>>>>>>  End_Function
86679>>>>>>>>>>>>>>>>>
86679>>>>>>>>>>>>>>>>>  // Sets the value of a given line. (For compatibility with VDF)
86679>>>>>>>>>>>>>>>>>  Procedure Set Value Integer iItem String sValue
86681>>>>>>>>>>>>>>>>>    Integer iRet iC iCol iLine
86681>>>>>>>>>>>>>>>>>
86681>>>>>>>>>>>>>>>>>    Get CM_GetSel False                to iRet
86682>>>>>>>>>>>>>>>>>    Get piSelEndCol                    to iCol
86683>>>>>>>>>>>>>>>>>    Get piSelEndLine                   to iLine
86684>>>>>>>>>>>>>>>>>    If iItem Eq -99 Begin
86686>>>>>>>>>>>>>>>>>      Get Current_Item  to iItem
86687>>>>>>>>>>>>>>>>>    End
86687>>>>>>>>>>>>>>>>>>
86687>>>>>>>>>>>>>>>>>    Get CM_SelectLine iItem False      to iRet // select line up to EOL character
86688>>>>>>>>>>>>>>>>>    Get CM_DeleteSel                   to iRet
86689>>>>>>>>>>>>>>>>>    Get CM_InsertText sValue iItem 0   to iRet
86690>>>>>>>>>>>>>>>>>    If (iLine <> iItem) Begin
86692>>>>>>>>>>>>>>>>>      Get CM_SetSel iLine iCol iLine iCol False  to iRet
86693>>>>>>>>>>>>>>>>>    End
86693>>>>>>>>>>>>>>>>>>
86693>>>>>>>>>>>>>>>>>  End_Procedure
86694>>>>>>>>>>>>>>>>>
86694>>>>>>>>>>>>>>>>>  Procedure Delete_Data
86696>>>>>>>>>>>>>>>>>    // Unless the document is read-only, this deletes all the text.
86696>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CLEARALL
86697>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_EMPTYUNDOBUFFER
86698>>>>>>>>>>>>>>>>>    // Clear all styling information and reset the folding state.
86698>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CLEARDOCUMENTSTYLE
86699>>>>>>>>>>>>>>>>>  End_Procedure
86700>>>>>>>>>>>>>>>>>
86700>>>>>>>>>>>>>>>>>
86700>>>>>>>>>>>>>>>>>  // Inserts the Sting into the current Position.
86700>>>>>>>>>>>>>>>>>  Procedure Insert String sValue
86702>>>>>>>>>>>>>>>>>    Integer iRet
86702>>>>>>>>>>>>>>>>>    Get CM_GetSel False to iRet
86703>>>>>>>>>>>>>>>>>    Move (CM_InsertText(Self,sValue,piSelEndLine(Self),piSelEndCol(Self))) to iRet
86704>>>>>>>>>>>>>>>>>  End_Procedure
86705>>>>>>>>>>>>>>>>>
86705>>>>>>>>>>>>>>>>>  // This is en advanced set value which automatically indents the new
86705>>>>>>>>>>>>>>>>>  // value text as far as the text in the line was, or if empty the text of the line before.
86705>>>>>>>>>>>>>>>>>  Procedure Set ValueSmart Integer iLine String sVal
86707>>>>>>>>>>>>>>>>>    Integer iPos
86707>>>>>>>>>>>>>>>>>    String sValOld
86707>>>>>>>>>>>>>>>>>    Get value item iLine    to sValOld
86708>>>>>>>>>>>>>>>>>    If (Trim(sValOld)) Eq "" If iLine Gt 0 Begin
86712>>>>>>>>>>>>>>>>>      Get Value Item (iLine-1) to sValOld
86713>>>>>>>>>>>>>>>>>    End
86713>>>>>>>>>>>>>>>>>>
86713>>>>>>>>>>>>>>>>>    If (Trim(sValOld)) Ne "" Begin
86715>>>>>>>>>>>>>>>>>      For iPos from 1 to (Length(sValOld))
86721>>>>>>>>>>>>>>>>>>
86721>>>>>>>>>>>>>>>>>
86721>>>>>>>>>>>>>>>>>        If (Mid(sValOld,1,iPos)) Ne " " Break
86724>>>>>>>>>>>>>>>>>      Loop
86725>>>>>>>>>>>>>>>>>>
86725>>>>>>>>>>>>>>>>>
86725>>>>>>>>>>>>>>>>>      Move (LTrim(sVal))      to sVal
86726>>>>>>>>>>>>>>>>>      Move (Append(Repeat(" ",iPos-1),sVal))  to sVal
86727>>>>>>>>>>>>>>>>>    End
86727>>>>>>>>>>>>>>>>>>
86727>>>>>>>>>>>>>>>>>
86727>>>>>>>>>>>>>>>>>    Set value item iLine                        to sVal
86728>>>>>>>>>>>>>>>>>  End_Procedure
86729>>>>>>>>>>>>>>>>>
86729>>>>>>>>>>>>>>>>>  // To determine if an object is a cCodeMaxEdit
86729>>>>>>>>>>>>>>>>>  Function iscWinMaxEdit Returns Integer
86731>>>>>>>>>>>>>>>>>    Function_Return 1
86732>>>>>>>>>>>>>>>>>  End_Function
86733>>>>>>>>>>>>>>>>>
86733>>>>>>>>>>>>>>>>>  //____NOTIFICATION_TRAPPING..._____________________________________________
86733>>>>>>>>>>>>>>>>>  // all of the followinf procedures and functions are sent by the
86733>>>>>>>>>>>>>>>>>  // procedure Notify - which is caused by WM_Notify message.
86733>>>>>>>>>>>>>>>>>
86733>>>>>>>>>>>>>>>>>  // Key capturing...
86733>>>>>>>>>>>>>>>>>
86733>>>>>>>>>>>>>>>>>  // Blocks iKeyCode
86733>>>>>>>>>>>>>>>>>  Procedure BlockKey Integer iKeyCode Integer iExtKey Integer iFlag
86735>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT ;      Set psBlockedKeysNo    to (Overstrike(String(iFlag),psBlockedKeysNo   (Self),iKeyCode))
86738>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT ;      Set psBlockedKeysShift to (Overstrike(String(iFlag),psBlockedKeysShift(Self),iKeyCode))
86741>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT   ;      Set psBlockedKeysAlt   to (Overstrike(String(iFlag),psBlockedKeysAlt  (Self),iKeyCode))
86744>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL  ;      Set psBlockedKeysCtrl  to (Overstrike(String(iFlag),psBlockedKeysCtrl (Self),iKeyCode))
86747>>>>>>>>>>>>>>>>>  End_Procedure
86748>>>>>>>>>>>>>>>>>
86748>>>>>>>>>>>>>>>>>  Function isKeyBlocked Integer iKeyCode Integer iExtKey Returns Integer
86750>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT ;      Function_Return (Mid(psBlockedKeysNo   (Self),1,iKeyCode))
86753>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT ;      Function_Return (Mid(psBlockedKeysShift(Self),1,iKeyCode))
86756>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT   ;      Function_Return (Mid(psBlockedKeysAlt  (Self),1,iKeyCode))
86759>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL  ;      Function_Return (Mid(psBlockedKeysCtrl (Self),1,iKeyCode))
86762>>>>>>>>>>>>>>>>>    Function_Return 0
86763>>>>>>>>>>>>>>>>>  End_Function
86764>>>>>>>>>>>>>>>>>
86764>>>>>>>>>>>>>>>>>
86764>>>>>>>>>>>>>>>>>  // Like Block Key but the Blocked key is reset with onKeyUp.
86764>>>>>>>>>>>>>>>>>  Procedure BlockKeyOnce Integer iKeyCode Integer iExtKey Integer iFlag
86766>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT ;      Set psBlockedKeysNoOnce    to (Overstrike(String(iFlag),psBlockedKeysNoOnce   (Self),iKeyCode))
86769>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT ;      Set psBlockedKeysShiftOnce to (Overstrike(String(iFlag),psBlockedKeysShiftOnce(Self),iKeyCode))
86772>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT   ;      Set psBlockedKeysAltOnce   to (Overstrike(String(iFlag),psBlockedKeysAltOnce  (Self),iKeyCode))
86775>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL  ;      Set psBlockedKeysCtrlOnce  to (Overstrike(String(iFlag),psBlockedKeysCtrlOnce (Self),iKeyCode))
86778>>>>>>>>>>>>>>>>>  End_Procedure
86779>>>>>>>>>>>>>>>>>  Function isKeyBlockedOnce Integer iKeyCode Integer iExtKey Returns Integer
86781>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_NOEXT  ;      Function_Return (Mid(psBlockedKeysNoOnce   (Self),1,iKeyCode))
86784>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_SHIFT  ;      Function_Return (Mid(psBlockedKeysShiftOnce(Self),1,iKeyCode))
86787>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_ALT    ;      Function_Return (Mid(psBlockedKeysAltOnce  (Self),1,iKeyCode))
86790>>>>>>>>>>>>>>>>>    If iExtKey Eq CM_KEY_CTRL   ;      Function_Return (Mid(psBlockedKeysCtrlOnce (Self),1,iKeyCode))
86793>>>>>>>>>>>>>>>>>    Function_Return 0
86794>>>>>>>>>>>>>>>>>  End_Function
86795>>>>>>>>>>>>>>>>>
86795>>>>>>>>>>>>>>>>>  Procedure onCMKeyUp Longptr iKeyCode Longptr iKeyExt
86797>>>>>>>>>>>>>>>>>  End_Procedure
86798>>>>>>>>>>>>>>>>>  Procedure onCMKeyDown Longptr iKeyCode Longptr iKeyExt
86800>>>>>>>>>>>>>>>>>  End_Procedure
86801>>>>>>>>>>>>>>>>>  Procedure onCMKeyPress Longptr iKeyCode Longptr iKeyExt
86803>>>>>>>>>>>>>>>>>  End_Procedure
86804>>>>>>>>>>>>>>>>>
86804>>>>>>>>>>>>>>>>>  //
86804>>>>>>>>>>>>>>>>>  // We apparently can't use WM_KEYDOWN event, but our higher class depends on that. So from a keypress we now
86804>>>>>>>>>>>>>>>>>  // simulate that by only watching the specific keys that are handled. While hackish, this appears to work.
86804>>>>>>>>>>>>>>>>>  //
86804>>>>>>>>>>>>>>>>>  Procedure SimulateOnKeyDown
86806>>>>>>>>>>>>>>>>>    Integer iKeyCode iKeyExt iRet
86806>>>>>>>>>>>>>>>>>    Move 0 To iKeyCode
86807>>>>>>>>>>>>>>>>>    Move 0 To iKeyExt
86808>>>>>>>>>>>>>>>>>    If (GetKeyState(VK_HOME)) ;      Move VK_HOME To iKeyCode
86811>>>>>>>>>>>>>>>>>    Else If (GetKeyState(VK_END)) ;      Move VK_END To iKeyCode
86815>>>>>>>>>>>>>>>>>    Else If (GetKeyState(VK_RETURN)) ;      Move VK_RETURN To iKeyCode
86819>>>>>>>>>>>>>>>>>    If (GetKeyState(VK_CONTROL)) ;      Move CM_KEY_CTRL To iKeyExt
86822>>>>>>>>>>>>>>>>>    Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
86823>>>>>>>>>>>>>>>>>  End_Procedure
86824>>>>>>>>>>>>>>>>>
86824>>>>>>>>>>>>>>>>>  Procedure DoKeyAction Integer iChar  Longptr lParam
86826>>>>>>>>>>>>>>>>>    Integer iKeyExt iRet // iKeyCode iBlocked
86826>>>>>>>>>>>>>>>>>    Boolean bHasCallTip
86826>>>>>>>>>>>>>>>>>    //        Local_BUFFER_CPY sKeyData pKeyData CM_KEYDATA pCM_KeyData
86826>>>>>>>>>>>>>>>>>    //        GetBuff from sKeyData At CM_KeyData.nKeyCode        to iKeyCode
86826>>>>>>>>>>>>>>>>>    //        GetBuff from sKeyData At CM_KeyData.nKeyModifier    to iKeyExt
86826>>>>>>>>>>>>>>>>>    //        If (iMode=CMN_KEYUP   ) Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
86826>>>>>>>>>>>>>>>>>    //        If (iMode=CMN_KEYDOWN ) Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
86826>>>>>>>>>>>>>>>>>    //        If (iMode=CMN_KEYPRESS) Get Msg_onCMKeyPress   iKeyCode iKeyExt  to iRet
86826>>>>>>>>>>>>>>>>>
86826>>>>>>>>>>>>>>>>>    Send SimulateOnKeyDown
86827>>>>>>>>>>>>>>>>>    Get Msg_onCMKeyPress   iChar iKeyExt  to iRet
86828>>>>>>>>>>>>>>>>>
86828>>>>>>>>>>>>>>>>>    If (pbCodeTipRequest(Self)=False) Begin
86830>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_CALLTIPACTIVE to bHasCallTip
86831>>>>>>>>>>>>>>>>>      If (bHasCallTip) Begin
86833>>>>>>>>>>>>>>>>>        Set pbCodetipRequest to True // code tip is still on the screen, keep calculating to see if it has to be deactivated.
86834>>>>>>>>>>>>>>>>>      End
86834>>>>>>>>>>>>>>>>>>
86834>>>>>>>>>>>>>>>>>    End
86834>>>>>>>>>>>>>>>>>>
86834>>>>>>>>>>>>>>>>>
86834>>>>>>>>>>>>>>>>>    //            // Blocks keystrokes. (only with every ExtKey, dont need this at the moment)
86834>>>>>>>>>>>>>>>>>    //        If (isKeyBlocked(Self,iKeyCode,iKeyExt)) Begin
86834>>>>>>>>>>>>>>>>>    //            Procedure_Return 1
86834>>>>>>>>>>>>>>>>>    //        End
86834>>>>>>>>>>>>>>>>>    //            // Same as above but the Key blocking is released with KeyUp -> Block Key only once!
86834>>>>>>>>>>>>>>>>>    //        If (isKeyBlockedOnce(Self,iKeyCode,iKeyExt)) Begin
86834>>>>>>>>>>>>>>>>>    //            If (iMode=CMN_KEYUP) Send BlockKeyOnce iKeyCode iKeyExt False   // Reset Key.
86834>>>>>>>>>>>>>>>>>    //            Procedure_Return 1
86834>>>>>>>>>>>>>>>>>    //        End
86834>>>>>>>>>>>>>>>>>    Procedure_Return iRet
86835>>>>>>>>>>>>>>>>>  End_Procedure
86836>>>>>>>>>>>>>>>>>
86836>>>>>>>>>>>>>>>>>  Procedure onKeyUp Longptr iKey Longptr lParam
86838>>>>>>>>>>>>>>>>>    Boolean bHasCodeList
86838>>>>>>>>>>>>>>>>>    Integer iRet iKeyCode iKeyExt
86838>>>>>>>>>>>>>>>>>    Move iKey To iKeyCode
86839>>>>>>>>>>>>>>>>>    Forward Send onKeyUp iKey lParam
86841>>>>>>>>>>>>>>>>>    Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
86842>>>>>>>>>>>>>>>>>    If (pbIsCodelistActive(Self)) Begin
86844>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_AUTOCACTIVE to bHasCodeList
86845>>>>>>>>>>>>>>>>>      If (bHasCodeList=False) Begin
86847>>>>>>>>>>>>>>>>>        Send DoCodeListCancel
86848>>>>>>>>>>>>>>>>>      End
86848>>>>>>>>>>>>>>>>>>
86848>>>>>>>>>>>>>>>>>    End
86848>>>>>>>>>>>>>>>>>>
86848>>>>>>>>>>>>>>>>>  End_Procedure
86849>>>>>>>>>>>>>>>>>
86849>>>>>>>>>>>>>>>>>
86849>>>>>>>>>>>>>>>>>  Procedure Key Integer iKey
86851>>>>>>>>>>>>>>>>>    Boolean bBlockSelect
86851>>>>>>>>>>>>>>>>>    Boolean bDisableKey
86851>>>>>>>>>>>>>>>>>
86851>>>>>>>>>>>>>>>>>    Move False to bDisableKey
86852>>>>>>>>>>>>>>>>>    Set pbBlockSelectBackspace to False
86853>>>>>>>>>>>>>>>>>    If iKey Eq 2166 Begin
86855>>>>>>>>>>>>>>>>>      Send OnBeforePaste // Paste Ctrl+V
86856>>>>>>>>>>>>>>>>>    End
86856>>>>>>>>>>>>>>>>>>
86856>>>>>>>>>>>>>>>>>    If iKey Eq 2168 Begin
86858>>>>>>>>>>>>>>>>>      Send OnBeforeCut   // Cut Ctrl+X
86859>>>>>>>>>>>>>>>>>    End
86859>>>>>>>>>>>>>>>>>>
86859>>>>>>>>>>>>>>>>>    Get pbBlockSelectActive to bBlockSelect
86860>>>>>>>>>>>>>>>>>    If (bBlockSelect) Begin
86862>>>>>>>>>>>>>>>>>      Send BlockSelectRemoveTextBlockBugfix
86863>>>>>>>>>>>>>>>>>
86863>>>>>>>>>>>>>>>>>      If (iKey=KEY_TAB) Begin
86865>>>>>>>>>>>>>>>>>        // tab works, but not when only space characters at first line, then it is a mess.
86865>>>>>>>>>>>>>>>>>        // But if we then move the selection to the first column it works again. It's a bit ugly, but it works
86865>>>>>>>>>>>>>>>>>        Send BlockSelectTabKeyBugfix
86866>>>>>>>>>>>>>>>>>        Move True to bDisableKey
86867>>>>>>>>>>>>>>>>>      End
86867>>>>>>>>>>>>>>>>>>
86867>>>>>>>>>>>>>>>>>    End
86867>>>>>>>>>>>>>>>>>>
86867>>>>>>>>>>>>>>>>>    //IfNot (bDisableKey) Forward Send Key iKey
86867>>>>>>>>>>>>>>>>>    Forward Send Key iKey
86869>>>>>>>>>>>>>>>>>    If iKey Eq 2166 Begin
86871>>>>>>>>>>>>>>>>>      Send OnAfterPaste  // Paste Ctrl+V
86872>>>>>>>>>>>>>>>>>    End
86872>>>>>>>>>>>>>>>>>>
86872>>>>>>>>>>>>>>>>>    If iKey Eq 2168 Begin
86874>>>>>>>>>>>>>>>>>      Send OnAfterCut    // Cut Ctrl+X
86875>>>>>>>>>>>>>>>>>    End
86875>>>>>>>>>>>>>>>>>>
86875>>>>>>>>>>>>>>>>>    If (bBlockSelect) Begin
86877>>>>>>>>>>>>>>>>>      If (iKey=KEY_BACK_SPACE) Begin  // in block select the backspace reselection only works one time, to make it work well, we have to reselect by hand
86879>>>>>>>>>>>>>>>>>        Set pbBlockSelectBackspace to True
86880>>>>>>>>>>>>>>>>>      End
86880>>>>>>>>>>>>>>>>>>
86880>>>>>>>>>>>>>>>>>    End
86880>>>>>>>>>>>>>>>>>>
86880>>>>>>>>>>>>>>>>>  End_Procedure
86881>>>>>>>>>>>>>>>>>
86881>>>>>>>>>>>>>>>>>  Procedure onDrawLine Handle hDC Integer iTop Integer iLeft Integer iBottom Integer iRight Integer iColLeft Integer iColRight Integer iLine Pointer pItemData Integer iStyle
86883>>>>>>>>>>>>>>>>>    Integer iRet
86883>>>>>>>>>>>>>>>>>    String sTxt
86883>>>>>>>>>>>>>>>>>    
86883>>>>>>>>>>>>>>>>>    Move (Repeat(Character(0),20))  To sTxt
86884>>>>>>>>>>>>>>>>>    Move "Michis TestText"  to sTxt
86885>>>>>>>>>>>>>>>>>    Move (TextOut(hDC,iLeft,iTop,AddressOf(sTxt),15)) to iRet
86886>>>>>>>>>>>>>>>>>    Showln "iRet: " iRet
86889>>>>>>>>>>>>>>>>>
86889>>>>>>>>>>>>>>>>>    Procedure_Return
86890>>>>>>>>>>>>>>>>>    Showln "hDC "   hDC
86893>>>>>>>>>>>>>>>>>    Showln "iTop "  iTop
86896>>>>>>>>>>>>>>>>>    Showln "iLeft " iLeft
86899>>>>>>>>>>>>>>>>>    Showln "iBottom " iBottom
86902>>>>>>>>>>>>>>>>>    Showln "iRight " iRight
86905>>>>>>>>>>>>>>>>>    Showln "iColLeft " iColLeft
86908>>>>>>>>>>>>>>>>>    Showln "iColRight " iColRight
86911>>>>>>>>>>>>>>>>>    Showln "iLine " iLine
86914>>>>>>>>>>>>>>>>>    Showln "pItemData " pItemData
86917>>>>>>>>>>>>>>>>>    Showln "iStyle " iStyle
86920>>>>>>>>>>>>>>>>>  End_Procedure
86921>>>>>>>>>>>>>>>>>
86921>>>>>>>>>>>>>>>>>  Procedure DoDrawline Pointer pCM_DrawLineData
86923>>>>>>>>>>>>>>>>>    //        Local_BUFFER_CPY sDrawData pDrawData CM_DRAWLINEDATA pCM_DrawLineData
86923>>>>>>>>>>>>>>>>>    //        Integer iTop iBottom iLeft iRight iColLeft iColRight iLine iStyle
86923>>>>>>>>>>>>>>>>>    //        Pointer pItemData
86923>>>>>>>>>>>>>>>>>    //        Handle  hDC
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.top    to iTop
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.bottom to iBottom
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Left   to iLeft
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Right  to iRight
86923>>>>>>>>>>>>>>>>>    //
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.hDC           to hDC
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nLeftCol      to iColLeft
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nRightCol     to iColRight
86923>>>>>>>>>>>>>>>>>    //
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.nLine         to iLine
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.lParam        to pItemData
86923>>>>>>>>>>>>>>>>>    //
86923>>>>>>>>>>>>>>>>>    //        GetBuff from sDrawData At CM_DRAWLINEDATA.dwStyle       to iStyle
86923>>>>>>>>>>>>>>>>>    //        Send onDrawLine hDC iTop iLeft iBottom iRight iColLeft iColRight iLine pItemData iStyle
86923>>>>>>>>>>>>>>>>>  End_Procedure
86924>>>>>>>>>>>>>>>>>
86924>>>>>>>>>>>>>>>>>
86924>>>>>>>>>>>>>>>>>  // Trap buffer modification...
86924>>>>>>>>>>>>>>>>>  Procedure DoModifiedChange
86926>>>>>>>>>>>>>>>>>    Send onModifiedChange (CM_IsModified(Self))
86927>>>>>>>>>>>>>>>>>  End_Procedure
86928>>>>>>>>>>>>>>>>>  Procedure onModifiedChange Integer bModified
86930>>>>>>>>>>>>>>>>>  End_Procedure
86931>>>>>>>>>>>>>>>>>  // Property change notification...
86931>>>>>>>>>>>>>>>>>  Procedure onPropsChange
86933>>>>>>>>>>>>>>>>>  End_Procedure
86934>>>>>>>>>>>>>>>>>
86934>>>>>>>>>>>>>>>>>  Function IsBraceOpenCharacter Integer iChar Returns Boolean
86936>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86936>>>>>>>>>>>>>>>>>    String  sChar
86936>>>>>>>>>>>>>>>>>
86936>>>>>>>>>>>>>>>>>    Move False to bIsBraceChar
86937>>>>>>>>>>>>>>>>>    Move (Character(iChar)) To sChar
86938>>>>>>>>>>>>>>>>>    If (sChar="(" or sChar="[" or sChar="{") Begin
86940>>>>>>>>>>>>>>>>>      Move True to bIsBraceChar
86941>>>>>>>>>>>>>>>>>    End
86941>>>>>>>>>>>>>>>>>>
86941>>>>>>>>>>>>>>>>>    Function_Return bIsBraceChar
86942>>>>>>>>>>>>>>>>>  End_Function
86943>>>>>>>>>>>>>>>>>
86943>>>>>>>>>>>>>>>>>  Function IsBraceCloseCharacter Integer iChar Returns Boolean
86945>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86945>>>>>>>>>>>>>>>>>    String  sChar
86945>>>>>>>>>>>>>>>>>
86945>>>>>>>>>>>>>>>>>    Move False to bIsBraceChar
86946>>>>>>>>>>>>>>>>>    Move (Character(iChar)) To sChar
86947>>>>>>>>>>>>>>>>>    If (sChar="]" or sChar=")" or sChar="}") Begin
86949>>>>>>>>>>>>>>>>>      Move True to bIsBraceChar
86950>>>>>>>>>>>>>>>>>    End
86950>>>>>>>>>>>>>>>>>>
86950>>>>>>>>>>>>>>>>>    Function_Return bIsBraceChar
86951>>>>>>>>>>>>>>>>>  End_Function
86952>>>>>>>>>>>>>>>>>
86952>>>>>>>>>>>>>>>>>  Function IsBraceCharacter Integer iChar Returns Boolean
86954>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
86954>>>>>>>>>>>>>>>>>
86954>>>>>>>>>>>>>>>>>    Get IsBraceOpenCharacter iChar to bIsBraceChar
86955>>>>>>>>>>>>>>>>>    If (bIsBraceChar=False) Begin
86957>>>>>>>>>>>>>>>>>      Get IsBraceCloseCharacter iChar to bIsBraceChar
86958>>>>>>>>>>>>>>>>>    End
86958>>>>>>>>>>>>>>>>>>
86958>>>>>>>>>>>>>>>>>    Function_Return bIsBraceChar
86959>>>>>>>>>>>>>>>>>  End_Function
86960>>>>>>>>>>>>>>>>>
86960>>>>>>>>>>>>>>>>>  // Selection has changed. (Position is included!)
86960>>>>>>>>>>>>>>>>>  Procedure onSelChange
86962>>>>>>>>>>>>>>>>>  End_Procedure
86963>>>>>>>>>>>>>>>>>
86963>>>>>>>>>>>>>>>>>  //
86963>>>>>>>>>>>>>>>>>  // Ordinary method to swap the contents of 2 integer variables
86963>>>>>>>>>>>>>>>>>  //
86963>>>>>>>>>>>>>>>>>  Procedure SwapIntegerVariables Integer ByRef iLine1 Integer ByRef iLine2
86965>>>>>>>>>>>>>>>>>    Integer iTemp
86965>>>>>>>>>>>>>>>>>    Move iLine1 To iTemp
86966>>>>>>>>>>>>>>>>>    Move iLine2 To iLine1
86967>>>>>>>>>>>>>>>>>    Move iTemp  To iLine2
86968>>>>>>>>>>>>>>>>>  End_Procedure
86969>>>>>>>>>>>>>>>>>
86969>>>>>>>>>>>>>>>>>  Function IsValidBraceCharMatch Integer iPos Integer iMatchPos Returns Boolean
86971>>>>>>>>>>>>>>>>>    Boolean bIsValid
86971>>>>>>>>>>>>>>>>>    Integer iLoop
86971>>>>>>>>>>>>>>>>>    Integer iLine
86971>>>>>>>>>>>>>>>>>    Integer iMatchLine
86971>>>>>>>>>>>>>>>>>    String  sLine
86971>>>>>>>>>>>>>>>>>
86971>>>>>>>>>>>>>>>>>    Move False to bIsValid
86972>>>>>>>>>>>>>>>>>    If (iMatchPos<>INVALID_POSITION) Begin
86974>>>>>>>>>>>>>>>>>      // check if the matched brace is on the same line
86974>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iPos      to iLine
86975>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iMatchPos to iMatchLine
86976>>>>>>>>>>>>>>>>>      If (iLine=iMatchLine) Begin
86978>>>>>>>>>>>>>>>>>        Move True To bIsValid
86979>>>>>>>>>>>>>>>>>      End
86979>>>>>>>>>>>>>>>>>>
86979>>>>>>>>>>>>>>>>>      Else Begin
86980>>>>>>>>>>>>>>>>>        // not on the same line, so can only be valid if the line ends with a ;
86980>>>>>>>>>>>>>>>>>        If (iLine>iMatchLine) Begin
86982>>>>>>>>>>>>>>>>>          Send SwapIntegerVariables (&iLine) (&iMatchLine)
86983>>>>>>>>>>>>>>>>>        End
86983>>>>>>>>>>>>>>>>>>
86983>>>>>>>>>>>>>>>>>        Move True To bIsValid
86984>>>>>>>>>>>>>>>>>        For iLoop from iLine to (iMatchLine-1)
86990>>>>>>>>>>>>>>>>>>
86990>>>>>>>>>>>>>>>>>          Get Value iLoop to sLine
86991>>>>>>>>>>>>>>>>>          Move (Rtrim(sLine)) To sLine
86992>>>>>>>>>>>>>>>>>          If (Right(sLine,1)<>";") Begin
86994>>>>>>>>>>>>>>>>>            Move False To bIsValid
86995>>>>>>>>>>>>>>>>>            Move iMatchLine To iLoop // stop
86996>>>>>>>>>>>>>>>>>          End
86996>>>>>>>>>>>>>>>>>>
86996>>>>>>>>>>>>>>>>>        Loop
86997>>>>>>>>>>>>>>>>>>
86997>>>>>>>>>>>>>>>>>      End
86997>>>>>>>>>>>>>>>>>>
86997>>>>>>>>>>>>>>>>>    End
86997>>>>>>>>>>>>>>>>>>
86997>>>>>>>>>>>>>>>>>    Function_Return bIsValid
86998>>>>>>>>>>>>>>>>>  End_Function
86999>>>>>>>>>>>>>>>>>
86999>>>>>>>>>>>>>>>>>  //
86999>>>>>>>>>>>>>>>>>  // Check if the style at the position supplied is either a comment or a DataFlex image
86999>>>>>>>>>>>>>>>>>  //
86999>>>>>>>>>>>>>>>>>  Function StyleAtPosIsComment Integer iPos Returns Boolean
87001>>>>>>>>>>>>>>>>>    Boolean bIsComment
87001>>>>>>>>>>>>>>>>>    Integer eStyle
87001>>>>>>>>>>>>>>>>>
87001>>>>>>>>>>>>>>>>>    Move False to bIsComment
87002>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
87003>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_IMAGE or eStyle=SCE_DF_COMMENTLINE) Begin
87005>>>>>>>>>>>>>>>>>      Move True to bIsComment
87006>>>>>>>>>>>>>>>>>    End
87006>>>>>>>>>>>>>>>>>>
87006>>>>>>>>>>>>>>>>>    Function_Return bIsComment
87007>>>>>>>>>>>>>>>>>  End_Function
87008>>>>>>>>>>>>>>>>>
87008>>>>>>>>>>>>>>>>>  Function StyleAtCurrentPosIsComment Returns Boolean
87010>>>>>>>>>>>>>>>>>    Boolean bIsComment
87010>>>>>>>>>>>>>>>>>    Integer iPos
87010>>>>>>>>>>>>>>>>>
87010>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS To iPos
87011>>>>>>>>>>>>>>>>>    Get StyleAtPosIsComment iPos To bIsComment
87012>>>>>>>>>>>>>>>>>    Function_Return bIsComment
87013>>>>>>>>>>>>>>>>>  End_Function
87014>>>>>>>>>>>>>>>>>
87014>>>>>>>>>>>>>>>>>  Function StyleAtPosIsDfImage Integer iPos Returns Boolean
87016>>>>>>>>>>>>>>>>>    Boolean bIsComment
87016>>>>>>>>>>>>>>>>>    Integer eStyle
87016>>>>>>>>>>>>>>>>>
87016>>>>>>>>>>>>>>>>>    Move False to bIsComment
87017>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
87018>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_IMAGE) Begin
87020>>>>>>>>>>>>>>>>>      Move True to bIsComment
87021>>>>>>>>>>>>>>>>>    End
87021>>>>>>>>>>>>>>>>>>
87021>>>>>>>>>>>>>>>>>    Function_Return bIsComment
87022>>>>>>>>>>>>>>>>>  End_Function
87023>>>>>>>>>>>>>>>>>
87023>>>>>>>>>>>>>>>>>  Function StyleAtPosIsDfKeyword Integer iPos Returns Boolean
87025>>>>>>>>>>>>>>>>>    Boolean bIsKeyword
87025>>>>>>>>>>>>>>>>>    Integer eStyle
87025>>>>>>>>>>>>>>>>>
87025>>>>>>>>>>>>>>>>>    Move False to bIsKeyword
87026>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
87027>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_SCOPEWORD) Begin // SCE_DF_WORD
87029>>>>>>>>>>>>>>>>>      Move True to bIsKeyword
87030>>>>>>>>>>>>>>>>>    End
87030>>>>>>>>>>>>>>>>>>
87030>>>>>>>>>>>>>>>>>    Function_Return bIsKeyword
87031>>>>>>>>>>>>>>>>>  End_Function
87032>>>>>>>>>>>>>>>>>
87032>>>>>>>>>>>>>>>>>  Function PosAtEndOfLine Integer iPos Returns Boolean
87034>>>>>>>>>>>>>>>>>    Boolean bAtEOL
87034>>>>>>>>>>>>>>>>>    Integer iLine
87034>>>>>>>>>>>>>>>>>    Integer iPosAtEOL
87034>>>>>>>>>>>>>>>>>
87034>>>>>>>>>>>>>>>>>    Move False To bAtEOL
87035>>>>>>>>>>>>>>>>>    Get Editormessage SCI_LINEFROMPOSITION   iPos  To iLine
87036>>>>>>>>>>>>>>>>>    Get Editormessage SCI_GETLINEENDPOSITION iLine To iPosAtEOL
87037>>>>>>>>>>>>>>>>>    If (iPos=(iPosAtEOL-1)) Begin
87039>>>>>>>>>>>>>>>>>      Move True to bAtEOL
87040>>>>>>>>>>>>>>>>>    End
87040>>>>>>>>>>>>>>>>>>
87040>>>>>>>>>>>>>>>>>    Function_Return bAtEOL
87041>>>>>>>>>>>>>>>>>  End_Function
87042>>>>>>>>>>>>>>>>>
87042>>>>>>>>>>>>>>>>>  // Shows matching braces for the characters ({[]})
87042>>>>>>>>>>>>>>>>>  // Note that SCI_BRACEHIGHLIGHT can only highlight two characters so it will not
87042>>>>>>>>>>>>>>>>>  // work for highlighting words like begin/end.
87042>>>>>>>>>>>>>>>>>  Procedure ShowMatchingBraces Integer iPos
87044>>>>>>>>>>>>>>>>>    Integer iChar
87044>>>>>>>>>>>>>>>>>    Integer imaxReStyle
87044>>>>>>>>>>>>>>>>>    Integer iMatchPos
87044>>>>>>>>>>>>>>>>>    Integer iMainSelection
87044>>>>>>>>>>>>>>>>>    Integer iVirtSpace
87044>>>>>>>>>>>>>>>>>    Boolean bMatchPreviousChar
87044>>>>>>>>>>>>>>>>>    Boolean bIsMatch
87044>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
87044>>>>>>>>>>>>>>>>>    Boolean bIsComment
87044>>>>>>>>>>>>>>>>>    Boolean bPosAtEOL
87044>>>>>>>>>>>>>>>>>    // get the char
87044>>>>>>>>>>>>>>>>>    Move 0 To iVirtSpace
87045>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMAINSELECTION to iMainSelection
87046>>>>>>>>>>>>>>>>>    If (imainSelection>=0) Begin
87048>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETSELECTIONNCARETVIRTUALSPACE iMainSelection to iVirtSpace
87049>>>>>>>>>>>>>>>>>    End
87049>>>>>>>>>>>>>>>>>>
87049>>>>>>>>>>>>>>>>>    If (iVirtSpace>0) Begin  // we are navigating the cursor past the end of line into "virtual space"
87051>>>>>>>>>>>>>>>>>      If (pbBraceHighLightState(Self)) Begin
87053>>>>>>>>>>>>>>>>>        // remove the highlight
87053>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
87054>>>>>>>>>>>>>>>>>        Set pbBraceHighLightState to False
87055>>>>>>>>>>>>>>>>>      End
87055>>>>>>>>>>>>>>>>>>
87055>>>>>>>>>>>>>>>>>    End
87055>>>>>>>>>>>>>>>>>>
87055>>>>>>>>>>>>>>>>>    Else Begin
87056>>>>>>>>>>>>>>>>>      Move True to bMatchPreviousChar // this seems to make more sense as you see match while you type
87057>>>>>>>>>>>>>>>>>      Move False to bIsBraceChar
87058>>>>>>>>>>>>>>>>>      If (iPos>0 and bMatchPreviousChar) Begin
87060>>>>>>>>>>>>>>>>>        Move (iPos-1) To iPos
87061>>>>>>>>>>>>>>>>>      End
87061>>>>>>>>>>>>>>>>>>
87061>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCHARAT iPos to iChar
87062>>>>>>>>>>>>>>>>>      Get IsBraceCharacter iChar To bIsBraceChar
87063>>>>>>>>>>>>>>>>>      If (bIsBraceChar) Begin
87065>>>>>>>>>>>>>>>>>        Get StyleAtPosIsComment iPos To bIsComment
87066>>>>>>>>>>>>>>>>>        If (bIsComment=false) Begin
87068>>>>>>>>>>>>>>>>>          Move 0 to imaxReStyle
87069>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
87070>>>>>>>>>>>>>>>>>          Get IsValidBraceCharMatch iPos iMatchPos to bIsMatch
87071>>>>>>>>>>>>>>>>>          If (bIsMatch) Begin
87073>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_BRACEHIGHLIGHT iPos iMatchPos
87074>>>>>>>>>>>>>>>>>            Set pbBraceHighLightState to True
87075>>>>>>>>>>>>>>>>>          End
87075>>>>>>>>>>>>>>>>>>
87075>>>>>>>>>>>>>>>>>          Else Begin
87076>>>>>>>>>>>>>>>>>            Get PosAtEndOfLine iPos To bPosAtEOL
87077>>>>>>>>>>>>>>>>>            If (bPosAtEOL=false) Begin
87079>>>>>>>>>>>>>>>>>              Send EditorMessage SCI_BRACEBADLIGHT iPos
87080>>>>>>>>>>>>>>>>>              Set pbBraceHighLightState to True
87081>>>>>>>>>>>>>>>>>            End
87081>>>>>>>>>>>>>>>>>>
87081>>>>>>>>>>>>>>>>>          End
87081>>>>>>>>>>>>>>>>>>
87081>>>>>>>>>>>>>>>>>        End
87081>>>>>>>>>>>>>>>>>>
87081>>>>>>>>>>>>>>>>>      End
87081>>>>>>>>>>>>>>>>>>
87081>>>>>>>>>>>>>>>>>      Else Begin
87082>>>>>>>>>>>>>>>>>        If (pbBraceHighLightState(Self)) Begin
87084>>>>>>>>>>>>>>>>>          // remove the highlight
87084>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
87085>>>>>>>>>>>>>>>>>          Set pbBraceHighLightState to False
87086>>>>>>>>>>>>>>>>>        End
87086>>>>>>>>>>>>>>>>>>
87086>>>>>>>>>>>>>>>>>      End
87086>>>>>>>>>>>>>>>>>>
87086>>>>>>>>>>>>>>>>>    End
87086>>>>>>>>>>>>>>>>>>
87086>>>>>>>>>>>>>>>>>  End_Procedure
87087>>>>>>>>>>>>>>>>>
87087>>>>>>>>>>>>>>>>>  //
87087>>>>>>>>>>>>>>>>>  // A preparsed line is a "normal" line but it has some of the parsing difficulties removed.
87087>>>>>>>>>>>>>>>>>  // Eg. all string literals are now underscores, eg. "abc" becomes ____
87087>>>>>>>>>>>>>>>>>  //                             or plus symbols  eg. 'abc' becomes ++++
87087>>>>>>>>>>>>>>>>>  //     all comments are cut off
87087>>>>>>>>>>>>>>>>>  //     all space characters on the right are trimmed
87087>>>>>>>>>>>>>>>>>  // So the relevant part of the line has just as much characters as before, but no longer creates
87087>>>>>>>>>>>>>>>>>  // parsing issues with parse targets that are embedded in strings or comments.
87087>>>>>>>>>>>>>>>>>  Function PreParsedLine Integer iLine Returns String
87089>>>>>>>>>>>>>>>>>    Boolean bDoubleQuote
87089>>>>>>>>>>>>>>>>>    Boolean bSingleQuote
87089>>>>>>>>>>>>>>>>>    Integer iChar
87089>>>>>>>>>>>>>>>>>    Integer iLength
87089>>>>>>>>>>>>>>>>>    String  sLine
87089>>>>>>>>>>>>>>>>>    String  sChar
87089>>>>>>>>>>>>>>>>>
87089>>>>>>>>>>>>>>>>>    Get CM_GetLine iLine to sLine
87090>>>>>>>>>>>>>>>>>    Move (Length(sLine)) To iLength
87091>>>>>>>>>>>>>>>>>    For iChar From 1 To iLength
87097>>>>>>>>>>>>>>>>>>
87097>>>>>>>>>>>>>>>>>      Move (Mid(sLine,1,iChar)) To sChar
87098>>>>>>>>>>>>>>>>>      If (sChar=Character(9)) Begin // tab characters should be treated as a single space char, this keeps the
87100>>>>>>>>>>>>>>>>>        Move (Overstrike(" ",sLine,iChar)) To sLine // position in the string the same.
87101>>>>>>>>>>>>>>>>>        Move " " To sChar
87102>>>>>>>>>>>>>>>>>      End
87102>>>>>>>>>>>>>>>>>>
87102>>>>>>>>>>>>>>>>>      If (bDoubleQuote and sChar='"') Begin
87104>>>>>>>>>>>>>>>>>        Move (Overstrike("_",sLine,iChar)) To sLine
87105>>>>>>>>>>>>>>>>>        Move "" To sChar
87106>>>>>>>>>>>>>>>>>        Move False To bDoubleQuote
87107>>>>>>>>>>>>>>>>>      End
87107>>>>>>>>>>>>>>>>>>
87107>>>>>>>>>>>>>>>>>      If (bSingleQuote and sChar="'") Begin
87109>>>>>>>>>>>>>>>>>        Move (Overstrike("+",sLine,iChar)) To sLine
87110>>>>>>>>>>>>>>>>>        Move "" To sChar
87111>>>>>>>>>>>>>>>>>        Move False To bSingleQuote
87112>>>>>>>>>>>>>>>>>      End
87112>>>>>>>>>>>>>>>>>>
87112>>>>>>>>>>>>>>>>>      If (sChar='"') ;        Move True To bDoubleQuote
87115>>>>>>>>>>>>>>>>>      If (sChar="'") ;        Move True To bSingleQuote
87118>>>>>>>>>>>>>>>>>      If bDoubleQuote ;        Move (Overstrike("_",sLine,iChar)) To sLine
87121>>>>>>>>>>>>>>>>>      Else ;        If bSingleQuote ;        Move (Overstrike("+",sLine,iChar)) To sLine
87125>>>>>>>>>>>>>>>>>      Else If (sChar="/") Begin
87128>>>>>>>>>>>>>>>>>        If (Mid(sLine,2,iChar)="//") Begin
87130>>>>>>>>>>>>>>>>>          Move (Left(sLine,iChar-1)) To sLine
87131>>>>>>>>>>>>>>>>>          Move iLength to iChar // end loop
87132>>>>>>>>>>>>>>>>>        End
87132>>>>>>>>>>>>>>>>>>
87132>>>>>>>>>>>>>>>>>      End
87132>>>>>>>>>>>>>>>>>>
87132>>>>>>>>>>>>>>>>>    Loop
87133>>>>>>>>>>>>>>>>>>
87133>>>>>>>>>>>>>>>>>    Move (Rtrim(sLine)) To sLine
87134>>>>>>>>>>>>>>>>>    Function_Return sLine
87135>>>>>>>>>>>>>>>>>  End_Function
87136>>>>>>>>>>>>>>>>>
87136>>>>>>>>>>>>>>>>>
87136>>>>>>>>>>>>>>>>>  Procedure BraceMatchLocation Integer iChar String sLine Integer iCol Integer ByRef iBraceCount Integer ByRef iBraceMatch
87138>>>>>>>>>>>>>>>>>    Boolean bOpenChar
87138>>>>>>>>>>>>>>>>>    Boolean bCloseChar
87138>>>>>>>>>>>>>>>>>    Integer iLinePos
87138>>>>>>>>>>>>>>>>>    Integer iLineChar
87138>>>>>>>>>>>>>>>>>    Integer iLength
87138>>>>>>>>>>>>>>>>>
87138>>>>>>>>>>>>>>>>>    Move (Length(sLine)) To iLength
87139>>>>>>>>>>>>>>>>>    If (iCol<=iLength) Begin
87141>>>>>>>>>>>>>>>>>      Get IsBraceOpenCharacter iChar to bOpenChar
87142>>>>>>>>>>>>>>>>>      If (bOpenChar) Begin
87144>>>>>>>>>>>>>>>>>        For iLinePos from iCol to iLength
87150>>>>>>>>>>>>>>>>>>
87150>>>>>>>>>>>>>>>>>          Move False to bOpenChar
87151>>>>>>>>>>>>>>>>>          Move False To bCloseChar
87152>>>>>>>>>>>>>>>>>          Move (Ascii(Mid(sLine,1,iLinePos))) To iLineChar
87153>>>>>>>>>>>>>>>>>          Get IsBraceOpenCharacter iLineChar to bOpenChar
87154>>>>>>>>>>>>>>>>>          If (bOpenChar) ;            Increment iBraceCount
87157>>>>>>>>>>>>>>>>>          Else ;            Get IsBraceCloseCharacter iLineChar to bCloseChar
87159>>>>>>>>>>>>>>>>>          If (bCloseChar) Begin
87161>>>>>>>>>>>>>>>>>            Decrement iBraceCount
87162>>>>>>>>>>>>>>>>>            If (iBraceCount=0) Begin
87164>>>>>>>>>>>>>>>>>              Move iLinePos To iBraceMatch
87165>>>>>>>>>>>>>>>>>              Move iLength  To iLinePos
87166>>>>>>>>>>>>>>>>>            End
87166>>>>>>>>>>>>>>>>>>
87166>>>>>>>>>>>>>>>>>          End
87166>>>>>>>>>>>>>>>>>>
87166>>>>>>>>>>>>>>>>>        Loop
87167>>>>>>>>>>>>>>>>>>
87167>>>>>>>>>>>>>>>>>      End
87167>>>>>>>>>>>>>>>>>>
87167>>>>>>>>>>>>>>>>>      Else Begin  // We're on a close brace
87168>>>>>>>>>>>>>>>>>        Move iCol To iLinePos
87169>>>>>>>>>>>>>>>>>        While (iLinePos>0)
87173>>>>>>>>>>>>>>>>>          Move False To bOpenChar
87174>>>>>>>>>>>>>>>>>          Move False To bCloseChar
87175>>>>>>>>>>>>>>>>>          Move (Ascii(Mid(sLine,1,iLinePos))) To iLineChar
87176>>>>>>>>>>>>>>>>>          Get IsBraceCloseCharacter iLineChar to bCloseChar
87177>>>>>>>>>>>>>>>>>          If (bCloseChar) ;            Increment iBraceCount
87180>>>>>>>>>>>>>>>>>          Else ;            Get IsBraceOpenCharacter iLineChar to bOpenChar
87182>>>>>>>>>>>>>>>>>          If (bOpenChar) Begin
87184>>>>>>>>>>>>>>>>>            Decrement iBraceCount
87185>>>>>>>>>>>>>>>>>            If (iBraceCount=0) Begin
87187>>>>>>>>>>>>>>>>>              Move iLinePos To iBraceMatch
87188>>>>>>>>>>>>>>>>>              Move -1 To iLinePos
87189>>>>>>>>>>>>>>>>>            End
87189>>>>>>>>>>>>>>>>>>
87189>>>>>>>>>>>>>>>>>          End
87189>>>>>>>>>>>>>>>>>>
87189>>>>>>>>>>>>>>>>>          Decrement iLinePos
87190>>>>>>>>>>>>>>>>>        Loop
87191>>>>>>>>>>>>>>>>>>
87191>>>>>>>>>>>>>>>>>      End
87191>>>>>>>>>>>>>>>>>>
87191>>>>>>>>>>>>>>>>>    End
87191>>>>>>>>>>>>>>>>>>
87191>>>>>>>>>>>>>>>>>  End_Procedure
87192>>>>>>>>>>>>>>>>>
87192>>>>>>>>>>>>>>>>>  Function FoldLevelWhiteLine Integer iLine Returns Boolean
87194>>>>>>>>>>>>>>>>>    Boolean bWhiteLine
87194>>>>>>>>>>>>>>>>>    Integer uFoldLevel
87194>>>>>>>>>>>>>>>>>
87194>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel // unmasked level
87195>>>>>>>>>>>>>>>>>    Move ((uFoldLevel iAnd SC_FOLDLEVELWHITEFLAG)=SC_FOLDLEVELWHITEFLAG) To bWhiteLine
87196>>>>>>>>>>>>>>>>>    Function_Return bWhiteLine
87197>>>>>>>>>>>>>>>>>  End_Function
87198>>>>>>>>>>>>>>>>>
87198>>>>>>>>>>>>>>>>>  Function MatchKeywordPosition Integer iMatchLine Boolean bFoldPoint Integer iFoldLevel Returns Integer
87200>>>>>>>>>>>>>>>>>    Boolean bWhiteLine
87200>>>>>>>>>>>>>>>>>    Integer eStyle
87200>>>>>>>>>>>>>>>>>    Integer iStartPos
87200>>>>>>>>>>>>>>>>>    Integer iEndPos
87200>>>>>>>>>>>>>>>>>    Integer iPos
87200>>>>>>>>>>>>>>>>>    Integer iMatchPos
87200>>>>>>>>>>>>>>>>>
87200>>>>>>>>>>>>>>>>>    Move -1 To iMatchPos
87201>>>>>>>>>>>>>>>>>    If (iMatchLine>-1) Begin
87203>>>>>>>>>>>>>>>>>      If (bFoldPoint) Begin // white lines are also part of the fold, move up if needed
87205>>>>>>>>>>>>>>>>>        Get FoldLevelWhiteLine iMatchLine to bWhiteLine
87206>>>>>>>>>>>>>>>>>        While (bWhiteLine)
87210>>>>>>>>>>>>>>>>>          Decrement iMatchLine
87211>>>>>>>>>>>>>>>>>          Get FoldLevelWhiteLine iMatchLine to bWhiteLine
87212>>>>>>>>>>>>>>>>>        Loop
87213>>>>>>>>>>>>>>>>>>
87213>>>>>>>>>>>>>>>>>      End
87213>>>>>>>>>>>>>>>>>>
87213>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_POSITIONFROMLINE   iMatchLine to iStartPos
87214>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETLINEENDPOSITION iMatchLine to iEndPos
87215>>>>>>>>>>>>>>>>>      For iPos From iStartPos To iEndPos
87221>>>>>>>>>>>>>>>>>>
87221>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
87222>>>>>>>>>>>>>>>>>        If (eStyle=SCE_DF_SCOPEWORD) Begin
87224>>>>>>>>>>>>>>>>>          Move iPos To iMatchPos
87225>>>>>>>>>>>>>>>>>          Move iEndPos To iPos
87226>>>>>>>>>>>>>>>>>        End
87226>>>>>>>>>>>>>>>>>>
87226>>>>>>>>>>>>>>>>>      Loop
87227>>>>>>>>>>>>>>>>>>
87227>>>>>>>>>>>>>>>>>    End
87227>>>>>>>>>>>>>>>>>>
87227>>>>>>>>>>>>>>>>>    Function_Return iMatchPos
87228>>>>>>>>>>>>>>>>>  End_Function
87229>>>>>>>>>>>>>>>>>
87229>>>>>>>>>>>>>>>>>  Function LineFoldLevel Integer iLine Returns Integer
87231>>>>>>>>>>>>>>>>>    Integer uFoldLevel
87231>>>>>>>>>>>>>>>>>    Integer iFoldLevel
87231>>>>>>>>>>>>>>>>>
87231>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETFOLDLEVEL iLine To uFoldLevel // unmasked level
87232>>>>>>>>>>>>>>>>>    Move (uFoldLevel iAnd SC_FOLDLEVELNUMBERMASK) To iFoldLevel
87233>>>>>>>>>>>>>>>>>    Move (iFoldLevel-SC_FOLDLEVELBASE) To iFoldLevel
87234>>>>>>>>>>>>>>>>>    Function_Return iFoldLevel
87235>>>>>>>>>>>>>>>>>  End_Function
87236>>>>>>>>>>>>>>>>>
87236>>>>>>>>>>>>>>>>>  Procedure GotoMatchBraceKeyword Integer iPos Integer iLine
87238>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
87238>>>>>>>>>>>>>>>>>    Integer eStyle
87238>>>>>>>>>>>>>>>>>    Integer uFoldLevel
87238>>>>>>>>>>>>>>>>>    Integer iFoldLevel
87238>>>>>>>>>>>>>>>>>    Integer iMatchLine
87238>>>>>>>>>>>>>>>>>    Integer iMatchPos
87238>>>>>>>>>>>>>>>>>
87238>>>>>>>>>>>>>>>>>    Move -1 To iMatchPos
87239>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT iPos to eStyle
87240>>>>>>>>>>>>>>>>>    If (eStyle=SCE_DF_SCOPEWORD) Begin
87242>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETFOLDLEVEL iLine to uFoldLevel // unmasked level
87243>>>>>>>>>>>>>>>>>      Move (uFoldLevel iAnd SC_FOLDLEVELNUMBERMASK) To iFoldLevel
87244>>>>>>>>>>>>>>>>>      Move ((uFoldLevel iAnd SC_FOLDLEVELHEADERFLAG)=SC_FOLDLEVELHEADERFLAG)To bFoldPoint
87245>>>>>>>>>>>>>>>>>      If (bFoldPoint) Begin
87247>>>>>>>>>>>>>>>>>        Get Editormessage SCI_GETLASTCHILD iLine -1 to iMatchLine
87248>>>>>>>>>>>>>>>>>        //If (iMatchLine>-1 and iFoldLevel=(SC_FOLDLEVELBASE+1)) Decrement iMatchLine
87248>>>>>>>>>>>>>>>>>        Get MatchKeywordPosition iMatchLine bFoldPoint iFoldLevel to iMatchPos
87249>>>>>>>>>>>>>>>>>      End
87249>>>>>>>>>>>>>>>>>>
87249>>>>>>>>>>>>>>>>>      Else Begin
87250>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETFOLDPARENT iLine to iMatchLine
87251>>>>>>>>>>>>>>>>>        Get MatchKeywordPosition iMatchLine bFoldPoint iFoldLevel to iMatchPos
87252>>>>>>>>>>>>>>>>>      End
87252>>>>>>>>>>>>>>>>>>
87252>>>>>>>>>>>>>>>>>    End
87252>>>>>>>>>>>>>>>>>>
87252>>>>>>>>>>>>>>>>>    If (iMatchPos>-1) Begin
87254>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_GOTOPOS iMatchPos
87255>>>>>>>>>>>>>>>>>    End
87255>>>>>>>>>>>>>>>>>>
87255>>>>>>>>>>>>>>>>>  End_Procedure
87256>>>>>>>>>>>>>>>>>
87256>>>>>>>>>>>>>>>>>
87256>>>>>>>>>>>>>>>>>  Procedure GotoMatchBrace
87258>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
87258>>>>>>>>>>>>>>>>>    Boolean bOpenChar
87258>>>>>>>>>>>>>>>>>    Integer iBraceCount
87258>>>>>>>>>>>>>>>>>    Integer iPos
87258>>>>>>>>>>>>>>>>>    Integer iCol
87258>>>>>>>>>>>>>>>>>    Integer iChar
87258>>>>>>>>>>>>>>>>>    Integer iLine
87258>>>>>>>>>>>>>>>>>    Integer iLineLength
87258>>>>>>>>>>>>>>>>>    Integer iBraceMatch
87258>>>>>>>>>>>>>>>>>    String  sLine
87258>>>>>>>>>>>>>>>>>
87258>>>>>>>>>>>>>>>>>    Move -1 To iBraceMatch
87259>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCURRENTPOS To iPos
87260>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iPos to iLine
87261>>>>>>>>>>>>>>>>>    If (iPos>0) Begin
87263>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCHARAT (iPos-1) to iChar
87264>>>>>>>>>>>>>>>>>    End
87264>>>>>>>>>>>>>>>>>>
87264>>>>>>>>>>>>>>>>>    Get IsBraceCharacter iChar To bIsBraceChar
87265>>>>>>>>>>>>>>>>>    If (bIsBraceChar) Begin
87267>>>>>>>>>>>>>>>>>      Get PreParsedLine iLine to sLine
87268>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCOLUMN (iPos-1) to iCol // zero based
87269>>>>>>>>>>>>>>>>>      Send BraceMatchLocation iChar sLine (iCol+1) (&iBraceCount) (&iBraceMatch)
87270>>>>>>>>>>>>>>>>>      If (iBraceMatch=-1) Begin
87272>>>>>>>>>>>>>>>>>        Move (iPos-iCol) To iPos
87273>>>>>>>>>>>>>>>>>        Move 0 To iCol // current column no longer relative as we are trying to match against another line
87274>>>>>>>>>>>>>>>>>        Get IsBraceOpenCharacter iChar to bOpenChar
87275>>>>>>>>>>>>>>>>>        If (bOpenChar) Begin
87277>>>>>>>>>>>>>>>>>          While (iBraceMatch=-1 and Right(sLine,1)=";")
87281>>>>>>>>>>>>>>>>>            Get EditorMessage SCI_LINELENGTH iLine to iLineLength
87282>>>>>>>>>>>>>>>>>            Move (iPos+iLineLength) To iPos
87283>>>>>>>>>>>>>>>>>            Increment iLine
87284>>>>>>>>>>>>>>>>>            Get PreParsedLine iLine to sLine
87285>>>>>>>>>>>>>>>>>            Send BraceMatchLocation iChar sLine 1 (&iBraceCount) (&iBraceMatch)
87286>>>>>>>>>>>>>>>>>          Loop
87287>>>>>>>>>>>>>>>>>>
87287>>>>>>>>>>>>>>>>>        End
87287>>>>>>>>>>>>>>>>>>
87287>>>>>>>>>>>>>>>>>        Else Begin // it's a closed char
87288>>>>>>>>>>>>>>>>>          If (iLine>1) Begin
87290>>>>>>>>>>>>>>>>>            Get PreParsedLine (iLine-1) to sLine
87291>>>>>>>>>>>>>>>>>            While (iBraceMatch=-1 and Right(sLine,1)=";" and iLine>1)
87295>>>>>>>>>>>>>>>>>              Send BraceMatchLocation iChar sLine (Length(sLine)) (&iBraceCount) (&iBraceMatch)
87296>>>>>>>>>>>>>>>>>              Decrement iLine
87297>>>>>>>>>>>>>>>>>              Get EditorMessage SCI_LINELENGTH iLine to iLineLength
87298>>>>>>>>>>>>>>>>>              Move (iPos-iLineLength) To iPos
87299>>>>>>>>>>>>>>>>>              Get PreParsedLine (iLine-1) to sLine
87300>>>>>>>>>>>>>>>>>            Loop
87301>>>>>>>>>>>>>>>>>>
87301>>>>>>>>>>>>>>>>>          End
87301>>>>>>>>>>>>>>>>>>
87301>>>>>>>>>>>>>>>>>        End
87301>>>>>>>>>>>>>>>>>>
87301>>>>>>>>>>>>>>>>>      End
87301>>>>>>>>>>>>>>>>>>
87301>>>>>>>>>>>>>>>>>      If (iBraceMatch>-1) Begin
87303>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_GOTOPOS (iPos-(iCol+1)+iBraceMatch)
87304>>>>>>>>>>>>>>>>>      End
87304>>>>>>>>>>>>>>>>>>
87304>>>>>>>>>>>>>>>>>    End
87304>>>>>>>>>>>>>>>>>>
87304>>>>>>>>>>>>>>>>>    Else Begin // not a brace char, is there a scope keyword under our cursor?
87305>>>>>>>>>>>>>>>>>      Send GotoMatchBraceKeyword iPos iLine
87306>>>>>>>>>>>>>>>>>    End
87306>>>>>>>>>>>>>>>>>>
87306>>>>>>>>>>>>>>>>>  End_Procedure
87307>>>>>>>>>>>>>>>>>
87307>>>>>>>>>>>>>>>>>  //
87307>>>>>>>>>>>>>>>>>  // Navigation, the cursor changed lines event
87307>>>>>>>>>>>>>>>>>  //
87307>>>>>>>>>>>>>>>>>  Procedure onLineChanged Integer iLineOld Integer iLineNew
87309>>>>>>>>>>>>>>>>>  End_Procedure
87310>>>>>>>>>>>>>>>>>
87310>>>>>>>>>>>>>>>>>  //
87310>>>>>>>>>>>>>>>>>  // Navigation, called when the cursor changes lines
87310>>>>>>>>>>>>>>>>>  //
87310>>>>>>>>>>>>>>>>>  Procedure LineChanged Integer iLineOld Integer iLineNew
87312>>>>>>>>>>>>>>>>>    Handle  hMarker
87312>>>>>>>>>>>>>>>>>    Integer iLine
87312>>>>>>>>>>>>>>>>>    String  sLine
87312>>>>>>>>>>>>>>>>>
87312>>>>>>>>>>>>>>>>>    Get phMarkerLineHighLight to hMarker
87313>>>>>>>>>>>>>>>>>    If (hMarker<>0) Begin
87315>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker to iLine
87316>>>>>>>>>>>>>>>>>      If (iLine<>iLineNew) Begin
87318>>>>>>>>>>>>>>>>>        Send ResetHighlightedLine
87319>>>>>>>>>>>>>>>>>      End
87319>>>>>>>>>>>>>>>>>>
87319>>>>>>>>>>>>>>>>>    End
87319>>>>>>>>>>>>>>>>>>
87319>>>>>>>>>>>>>>>>>    If (iLineOld<>iLineNew) Begin
87321>>>>>>>>>>>>>>>>>      Get CM_GetLine iLineNew to sLine
87322>>>>>>>>>>>>>>>>>      Set psLineOnEnter       to sLine
87323>>>>>>>>>>>>>>>>>      Set Status_Help to "" // remove status help if anything in there
87324>>>>>>>>>>>>>>>>>      Send Request_Status_Help True
87325>>>>>>>>>>>>>>>>>    End
87325>>>>>>>>>>>>>>>>>>
87325>>>>>>>>>>>>>>>>>    Send onLineChanged iLineOld iLineNew
87326>>>>>>>>>>>>>>>>>  End_Procedure
87327>>>>>>>>>>>>>>>>>
87327>>>>>>>>>>>>>>>>>  Procedure onNavigate Integer iPos
87329>>>>>>>>>>>>>>>>>    Integer iLineOld
87329>>>>>>>>>>>>>>>>>    Integer iLineNew
87329>>>>>>>>>>>>>>>>>    Boolean bShowMatchingBraces
87329>>>>>>>>>>>>>>>>>
87329>>>>>>>>>>>>>>>>>    Get piSelEndLine to iLineOld
87330>>>>>>>>>>>>>>>>>    Get pbShowMatchingBraces to bShowMatchingBraces
87331>>>>>>>>>>>>>>>>>    If (bShowMatchingBraces) Begin
87333>>>>>>>>>>>>>>>>>      Send ShowMatchingBraces iPos
87334>>>>>>>>>>>>>>>>>    End
87334>>>>>>>>>>>>>>>>>>
87334>>>>>>>>>>>>>>>>>    Send onSelChange
87335>>>>>>>>>>>>>>>>>    Get piSelEndLine to iLineNew
87336>>>>>>>>>>>>>>>>>    If (iLineOld<>iLineNew) Begin
87338>>>>>>>>>>>>>>>>>      Send LineChanged iLineOld iLineNew
87339>>>>>>>>>>>>>>>>>    End
87339>>>>>>>>>>>>>>>>>>
87339>>>>>>>>>>>>>>>>>  End_Procedure
87340>>>>>>>>>>>>>>>>>
87340>>>>>>>>>>>>>>>>>  //
87340>>>>>>>>>>>>>>>>>  // Is called when the user has inserted or deleted text, so effectively when our document
87340>>>>>>>>>>>>>>>>>  // line count changes.
87340>>>>>>>>>>>>>>>>>  //
87340>>>>>>>>>>>>>>>>>  Procedure LineCountChanged
87342>>>>>>>>>>>>>>>>>    Integer iOldDigits
87342>>>>>>>>>>>>>>>>>    Integer iNewDigits
87342>>>>>>>>>>>>>>>>>    Integer iMinDigits
87342>>>>>>>>>>>>>>>>>    Integer iLineCount
87342>>>>>>>>>>>>>>>>>    Integer iVoid
87342>>>>>>>>>>>>>>>>>    Integer iWidth
87342>>>>>>>>>>>>>>>>>
87342>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS to iWidth
87343>>>>>>>>>>>>>>>>>    If (iWidth<>0) Begin  // we have a line number margin, how many lines?
87345>>>>>>>>>>>>>>>>>      Get Item_Count to iLineCount // the margin width is determined based on number of digits
87346>>>>>>>>>>>>>>>>>      Move 3 To iMinDigits         // we set a minimum digits width of 3 digits
87347>>>>>>>>>>>>>>>>>      Get piMarginLineNumberDigits    To iOldDigits
87348>>>>>>>>>>>>>>>>>      Move (Length(Trim(iLineCount))) To iNewDigits
87349>>>>>>>>>>>>>>>>>      If (inewDigits<iMinDigits) Begin
87351>>>>>>>>>>>>>>>>>        Move iMinDigits to iNewDigits
87352>>>>>>>>>>>>>>>>>      End
87352>>>>>>>>>>>>>>>>>>
87352>>>>>>>>>>>>>>>>>      If (iOldDigits<>iNewDigits) Begin
87354>>>>>>>>>>>>>>>>>        Get CM_SetLineNumbering True 0 0 to iVoid  // by enabling line numbering we tell the logic to update the width
87355>>>>>>>>>>>>>>>>>      End
87355>>>>>>>>>>>>>>>>>>
87355>>>>>>>>>>>>>>>>>    End
87355>>>>>>>>>>>>>>>>>>
87355>>>>>>>>>>>>>>>>>  End_Procedure
87356>>>>>>>>>>>>>>>>>
87356>>>>>>>>>>>>>>>>>  // Insert mode / Overwrite mode
87356>>>>>>>>>>>>>>>>>  Procedure onOvertypeChange
87358>>>>>>>>>>>>>>>>>  End_Procedure
87359>>>>>>>>>>>>>>>>>
87359>>>>>>>>>>>>>>>>>  Procedure RegisterKeyBindingToClear String sKey
87361>>>>>>>>>>>>>>>>>    String[] KeyBindings
87362>>>>>>>>>>>>>>>>>
87362>>>>>>>>>>>>>>>>>    Get psClearKeyBindings to KeyBindings
87363>>>>>>>>>>>>>>>>>    Move sKey To KeyBindings[SizeOfArray(KeyBindings)]
87364>>>>>>>>>>>>>>>>>    Set psClearKeyBindings to KeyBindings
87365>>>>>>>>>>>>>>>>>  End_Procedure
87366>>>>>>>>>>>>>>>>>
87366>>>>>>>>>>>>>>>>>  Procedure RemoveSCIKeyBinding String sKey
87368>>>>>>>>>>>>>>>>>    Integer iModKeys
87368>>>>>>>>>>>>>>>>>    Integer iKey
87368>>>>>>>>>>>>>>>>>    String  sKeyDefine
87368>>>>>>>>>>>>>>>>>    //
87368>>>>>>>>>>>>>>>>>    Move 0 To iModKeys
87369>>>>>>>>>>>>>>>>>    Move sKey To sKeyDefine
87370>>>>>>>>>>>>>>>>>    Move (Replaces(" ",sKey,"")) To sKey // in Sci we can have "Ctrl + F" so get rid of the space characters
87371>>>>>>>>>>>>>>>>>    Move (Uppercase(sKey)) To sKey
87372>>>>>>>>>>>>>>>>>    If (pos("CTRL+",sKey)<>0) Begin
87374>>>>>>>>>>>>>>>>>      Move (iModKeys iOr SCMOD_CTRL)   To iModKeys
87375>>>>>>>>>>>>>>>>>      Move (Replace("CTRL+",sKey,""))  To sKey
87376>>>>>>>>>>>>>>>>>    End
87376>>>>>>>>>>>>>>>>>>
87376>>>>>>>>>>>>>>>>>    If (Pos("ALT+",sKey)<>0) Begin
87378>>>>>>>>>>>>>>>>>      Move (iModKeys iOr SCMOD_ALT)    To iModKeys
87379>>>>>>>>>>>>>>>>>      Move (Replace("ALT+",sKey,""))   To sKey
87380>>>>>>>>>>>>>>>>>    End
87380>>>>>>>>>>>>>>>>>>
87380>>>>>>>>>>>>>>>>>    If (Pos("SHIFT+",sKey)<>0) Begin
87382>>>>>>>>>>>>>>>>>      Move (iModKeys iOr SCMOD_SHIFT)  To iModKeys
87383>>>>>>>>>>>>>>>>>      Move (Replace("SHIFT+",sKey,"")) To sKey
87384>>>>>>>>>>>>>>>>>    End
87384>>>>>>>>>>>>>>>>>>
87384>>>>>>>>>>>>>>>>>    If (Length(sKey)=1) Begin
87386>>>>>>>>>>>>>>>>>      Move (Ascii(sKey)) To iKey
87387>>>>>>>>>>>>>>>>>    End
87387>>>>>>>>>>>>>>>>>>
87387>>>>>>>>>>>>>>>>>    Else Begin
87388>>>>>>>>>>>>>>>>>      Case Begin  // It isn't clear to me if SCI uses VK_xxx keys, but it seems so
87388>>>>>>>>>>>>>>>>>        Case (sKey="F1")
87390>>>>>>>>>>>>>>>>>          Move VK_F1 To iKey
87391>>>>>>>>>>>>>>>>>          Case break
87392>>>>>>>>>>>>>>>>>        Case (sKey="F2")
87395>>>>>>>>>>>>>>>>>          Move VK_F2 To iKey
87396>>>>>>>>>>>>>>>>>          Case break
87397>>>>>>>>>>>>>>>>>        Case (sKey="F3")
87400>>>>>>>>>>>>>>>>>          Move VK_F3 To iKey
87401>>>>>>>>>>>>>>>>>          Case break
87402>>>>>>>>>>>>>>>>>        Case (sKey="F4")
87405>>>>>>>>>>>>>>>>>          Move VK_F4 To iKey
87406>>>>>>>>>>>>>>>>>          Case break
87407>>>>>>>>>>>>>>>>>        Case (sKey="F5")
87410>>>>>>>>>>>>>>>>>          Move VK_F5 To iKey
87411>>>>>>>>>>>>>>>>>          Case break
87412>>>>>>>>>>>>>>>>>        Case (sKey="F6")
87415>>>>>>>>>>>>>>>>>          Move VK_F6 To iKey
87416>>>>>>>>>>>>>>>>>          Case break
87417>>>>>>>>>>>>>>>>>        Case (sKey="F7")
87420>>>>>>>>>>>>>>>>>          Move VK_F7 To iKey
87421>>>>>>>>>>>>>>>>>          Case break
87422>>>>>>>>>>>>>>>>>        Case (sKey="F8")
87425>>>>>>>>>>>>>>>>>          Move VK_F8 To iKey
87426>>>>>>>>>>>>>>>>>          Case break
87427>>>>>>>>>>>>>>>>>        Case (sKey="F9")
87430>>>>>>>>>>>>>>>>>          Move VK_F9 To iKey
87431>>>>>>>>>>>>>>>>>          Case break
87432>>>>>>>>>>>>>>>>>        Case (sKey="F10")
87435>>>>>>>>>>>>>>>>>          Move VK_F10 To iKey
87436>>>>>>>>>>>>>>>>>          Case break
87437>>>>>>>>>>>>>>>>>        Case (sKey="F11")
87440>>>>>>>>>>>>>>>>>          Move VK_F11 To iKey
87441>>>>>>>>>>>>>>>>>          Case break
87442>>>>>>>>>>>>>>>>>        Case (sKey="F12")
87445>>>>>>>>>>>>>>>>>          Move VK_F12 To iKey
87446>>>>>>>>>>>>>>>>>          Case break
87447>>>>>>>>>>>>>>>>>        Case (sKey="ENTER")
87450>>>>>>>>>>>>>>>>>          Move SCK_RETURN To iKey
87451>>>>>>>>>>>>>>>>>        Case (sKey="DOWN")
87454>>>>>>>>>>>>>>>>>          Move SCK_DOWN To iKey
87455>>>>>>>>>>>>>>>>>        Case (sKey="UP")
87458>>>>>>>>>>>>>>>>>          Move SCK_UP To iKey
87459>>>>>>>>>>>>>>>>>      Case End
87459>>>>>>>>>>>>>>>>>    End
87459>>>>>>>>>>>>>>>>>>
87459>>>>>>>>>>>>>>>>>    If (iKey<>0) Begin
87461>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_CLEARCMDKEY ((65536*(iModKeys))+iKey)
87462>>>>>>>>>>>>>>>>>    End
87462>>>>>>>>>>>>>>>>>>
87462>>>>>>>>>>>>>>>>>    Else Begin
87463>>>>>>>>>>>>>>>>>      Send none
87464>>>>>>>>>>>>>>>>>      // might be handy for debugging, or just annoying :) so use send none instead
87464>>>>>>>>>>>>>>>>>      //Send Info_Box ("Scintilla unknown key to clear "+sKeyDefine)
87464>>>>>>>>>>>>>>>>>    End
87464>>>>>>>>>>>>>>>>>>
87464>>>>>>>>>>>>>>>>>  End_Procedure
87465>>>>>>>>>>>>>>>>>
87465>>>>>>>>>>>>>>>>>  Procedure ClearRegisteredKeyBindings
87467>>>>>>>>>>>>>>>>>    Integer iKey
87467>>>>>>>>>>>>>>>>>    Integer iCount
87467>>>>>>>>>>>>>>>>>    String[] KeyBindings
87468>>>>>>>>>>>>>>>>>
87468>>>>>>>>>>>>>>>>>    Get psClearKeyBindings to KeyBindings
87469>>>>>>>>>>>>>>>>>    Move (SizeOfArray(KeyBindings)) To iCount
87470>>>>>>>>>>>>>>>>>    If (iCount>0) Begin
87472>>>>>>>>>>>>>>>>>      For iKey from 0 to (iCount-1)
87478>>>>>>>>>>>>>>>>>>
87478>>>>>>>>>>>>>>>>>        Send RemoveSCIKeyBinding KeyBindings[iKey]
87479>>>>>>>>>>>>>>>>>      Loop
87480>>>>>>>>>>>>>>>>>>
87480>>>>>>>>>>>>>>>>>      //Send EditorMessage SCI_CLEARALLCMDKEYS
87480>>>>>>>>>>>>>>>>>    End
87480>>>>>>>>>>>>>>>>>>
87480>>>>>>>>>>>>>>>>>    // each scintilla window can run this 1 time only
87480>>>>>>>>>>>>>>>>>    Move (ResizeArray(KeyBindings,0)) To KeyBindings
87481>>>>>>>>>>>>>>>>>    Set psClearKeyBindings to KeyBindings
87482>>>>>>>>>>>>>>>>>  End_Procedure
87483>>>>>>>>>>>>>>>>>  // Is sent when the end of the files was reached.
87483>>>>>>>>>>>>>>>>>  Procedure onFindWrapping
87485>>>>>>>>>>>>>>>>>  End_Procedure
87486>>>>>>>>>>>>>>>>>
87486>>>>>>>>>>>>>>>>>  Procedure DoFindWrapping
87488>>>>>>>>>>>>>>>>>    Integer iRet
87488>>>>>>>>>>>>>>>>>    Move False To Found // Sets the std. Found Indicator.
87489>>>>>>>>>>>>>>>>>    Get Msg_onFindWrapping    to iRet
87490>>>>>>>>>>>>>>>>>    If iRet Begin
87492>>>>>>>>>>>>>>>>>      Procedure_Return iRet
87493>>>>>>>>>>>>>>>>>    End
87493>>>>>>>>>>>>>>>>>>
87493>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrap Begin
87495>>>>>>>>>>>>>>>>>      Procedure_Return 1
87496>>>>>>>>>>>>>>>>>    End
87496>>>>>>>>>>>>>>>>>>
87496>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrapMsg Begin
87498>>>>>>>>>>>>>>>>>      If (Window_Handle(Self)) Eq (GetFocus()) Begin
87500>>>>>>>>>>>>>>>>>        Send Info_Box "Not Found."                  // Not so pretty but prevents object from loosing the focus.
87501>>>>>>>>>>>>>>>>>      End
87501>>>>>>>>>>>>>>>>>>
87501>>>>>>>>>>>>>>>>>      Procedure_Return 1
87502>>>>>>>>>>>>>>>>>    End
87502>>>>>>>>>>>>>>>>>>
87502>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_WrapSilent Begin
87504>>>>>>>>>>>>>>>>>      Procedure_Return 0
87505>>>>>>>>>>>>>>>>>    End
87505>>>>>>>>>>>>>>>>>>
87505>>>>>>>>>>>>>>>>>    If (piFindWrapMode(Self)) Eq FindWrapMode_WrapAsk Begin
87507>>>>>>>>>>>>>>>>>      Get YesNo_Box "End of file reached restart from the beginning?"     to iRet
87508>>>>>>>>>>>>>>>>>      If iRet Eq MBR_Yes ;        Procedure_Return 0
87511>>>>>>>>>>>>>>>>>      Else ;        Procedure_Return 1
87513>>>>>>>>>>>>>>>>>    End
87513>>>>>>>>>>>>>>>>>>
87513>>>>>>>>>>>>>>>>>  End_Procedure
87514>>>>>>>>>>>>>>>>>
87514>>>>>>>>>>>>>>>>>  // Should be overwrited, returns True if Ok or false if failed
87514>>>>>>>>>>>>>>>>>  Function CM_InitCodeList Handle hCodeList Returns Integer
87516>>>>>>>>>>>>>>>>>    Function_Return 0
87517>>>>>>>>>>>>>>>>>  End_Function
87518>>>>>>>>>>>>>>>>>  // This procedure should Set codetip text etc...
87518>>>>>>>>>>>>>>>>>  Procedure OnCodeTip
87520>>>>>>>>>>>>>>>>>  End_Procedure
87521>>>>>>>>>>>>>>>>>  Procedure OnCodeTipInitialize
87523>>>>>>>>>>>>>>>>>  End_Procedure
87524>>>>>>>>>>>>>>>>>  Procedure OnCodeTipUpdate
87526>>>>>>>>>>>>>>>>>  End_Procedure
87527>>>>>>>>>>>>>>>>>  Procedure OnCodeTipCancel
87529>>>>>>>>>>>>>>>>>  End_Procedure
87530>>>>>>>>>>>>>>>>>  Function DoCodeListInit Handle hCodeList Returns Integer
87532>>>>>>>>>>>>>>>>>    Function_Return 0
87533>>>>>>>>>>>>>>>>>  End_Function
87534>>>>>>>>>>>>>>>>>  Procedure CM_CodeListItemSelected String sItem Integer iRefVal
87536>>>>>>>>>>>>>>>>>  End_Procedure
87537>>>>>>>>>>>>>>>>>
87537>>>>>>>>>>>>>>>>>  Function LoadAutoCompleteImage String sBitmap Integer iType Returns Boolean
87539>>>>>>>>>>>>>>>>>    Boolean bOK
87539>>>>>>>>>>>>>>>>>    Pointer pImage
87539>>>>>>>>>>>>>>>>>    UInteger uSize uWidth uHeight
87539>>>>>>>>>>>>>>>>>    UInteger iErr iVoid
87539>>>>>>>>>>>>>>>>>    String  sFileName
87539>>>>>>>>>>>>>>>>>    String  sError
87539>>>>>>>>>>>>>>>>>
87539>>>>>>>>>>>>>>>>>    Move False to bOK
87540>>>>>>>>>>>>>>>>>    Move (sBitmap+Character(0)) To sFileName
87541>>>>>>>>>>>>>>>>>    Move 0 To uWidth
87542>>>>>>>>>>>>>>>>>    Move 0 To uHeight
87543>>>>>>>>>>>>>>>>>    Move 0 To uSize
87544>>>>>>>>>>>>>>>>>    Move 0 To pImage
87545>>>>>>>>>>>>>>>>>    //Move (SciLoadPngAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight),AddressOf(uSize))) To iErr
87545>>>>>>>>>>>>>>>>>    Move (SciLoadImageAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight))) To iErr
87546>>>>>>>>>>>>>>>>>    If (iErr=0) Begin
87548>>>>>>>>>>>>>>>>>      //Send Info_Box ("Image Width= "+Trim(uWidth)+" Height= "+Trim(uHeight)+" Size = "+Trim(uSize))
87548>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_RGBAIMAGESETWIDTH  uWidth
87549>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_RGBAIMAGESETHEIGHT uHeight
87550>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_REGISTERRGBAIMAGE  iType pImage
87551>>>>>>>>>>>>>>>>>      Move (SciFreeRGBAImage(pImage)) To iVoid
87552>>>>>>>>>>>>>>>>>      Move True to bOK
87553>>>>>>>>>>>>>>>>>    End
87553>>>>>>>>>>>>>>>>>>
87553>>>>>>>>>>>>>>>>>    Else Begin
87554>>>>>>>>>>>>>>>>>      Get SciLoadImageErrorText iErr to sError
87555>>>>>>>>>>>>>>>>>      Send Info_Box (sError+"\nImage: "+sFileName+"\nNote that only uncompressed 24 bits and 32 bits bmp files are supported.") "Error loading CodeList image"
87556>>>>>>>>>>>>>>>>>    End
87556>>>>>>>>>>>>>>>>>>
87556>>>>>>>>>>>>>>>>>
87556>>>>>>>>>>>>>>>>>    Function_Return bOK
87557>>>>>>>>>>>>>>>>>  End_Function
87558>>>>>>>>>>>>>>>>>
87558>>>>>>>>>>>>>>>>>  //
87558>>>>>>>>>>>>>>>>>  // Scintilla calls the codelist feature autocomplete.
87558>>>>>>>>>>>>>>>>>  // When this is called the array phoCodelistHandler has our list that we want to display
87558>>>>>>>>>>>>>>>>>  // sWord is the word to select on
87558>>>>>>>>>>>>>>>>>  //
87558>>>>>>>>>>>>>>>>>  Procedure ShowAutoComplete String sWord
87560>>>>>>>>>>>>>>>>>    Boolean bAutoCompleteActive
87560>>>>>>>>>>>>>>>>>    Boolean bHasBmp
87560>>>>>>>>>>>>>>>>>    Handle  hoArray
87560>>>>>>>>>>>>>>>>>    Integer iChar
87560>>>>>>>>>>>>>>>>>    Integer iItem
87560>>>>>>>>>>>>>>>>>    Integer iCount
87560>>>>>>>>>>>>>>>>>    String  sItem
87560>>>>>>>>>>>>>>>>>    String  sBitmap
87560>>>>>>>>>>>>>>>>>    String  sList
87560>>>>>>>>>>>>>>>>>    String  sSelect
87560>>>>>>>>>>>>>>>>>
87560>>>>>>>>>>>>>>>>>    //Get EditorMessage SCI_AUTOCACTIVE to bAutoCompleteActive  // doesn't work already gone before recursion
87560>>>>>>>>>>>>>>>>>    Get pbIsCodelistActive to bAutoCompleteActive
87561>>>>>>>>>>>>>>>>>    If (bAutoCompleteActive=False) Begin
87563>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_AUTOCSETIGNORECASE True
87564>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE
87565>>>>>>>>>>>>>>>>>      //Send EditorMessage SCI_AUTOCSETORDER SC_ORDER_PERFORMSORT // we sort on our end as we need to know the item number
87565>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_AUTOCSETSEPARATOR (Ascii("|"))
87566>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_CLEARREGISTEREDIMAGES
87567>>>>>>>>>>>>>>>>>      Move "" To sList
87568>>>>>>>>>>>>>>>>>      Get phoCodelistHandler to hoArray
87569>>>>>>>>>>>>>>>>>      Send SortAscending of hoArray  // Our list MUST be ascending order or the autocomplete won't work!
87570>>>>>>>>>>>>>>>>>      Get Codelist_Item_Count of hoArray to iCount
87571>>>>>>>>>>>>>>>>>      If (iCount>0) Begin
87573>>>>>>>>>>>>>>>>>        For iItem from 0 To (iCount-1)
87579>>>>>>>>>>>>>>>>>>
87579>>>>>>>>>>>>>>>>>          Get Codelist_value  of hoArray Item iItem To sItem
87580>>>>>>>>>>>>>>>>>          Get Codelist_bitmap of hoArray item iItem to sBitmap
87581>>>>>>>>>>>>>>>>>          Move False to bHasBmp
87582>>>>>>>>>>>>>>>>>          If (sBitmap<>"") Begin  // bitmap exists and found
87584>>>>>>>>>>>>>>>>>            Get LoadAutoCompleteImage sBitmap (iItem+1) to bHasBmp
87585>>>>>>>>>>>>>>>>>          End
87585>>>>>>>>>>>>>>>>>>
87585>>>>>>>>>>>>>>>>>          If (bHasBmp) Begin
87587>>>>>>>>>>>>>>>>>            Move (sList+sItem+"?"+Trim(iItem+1)) To sList
87588>>>>>>>>>>>>>>>>>          End
87588>>>>>>>>>>>>>>>>>>
87588>>>>>>>>>>>>>>>>>          Else Begin
87589>>>>>>>>>>>>>>>>>            Move (sList+sItem) to sList
87590>>>>>>>>>>>>>>>>>          End
87590>>>>>>>>>>>>>>>>>>
87590>>>>>>>>>>>>>>>>>          If (iItem<(iCount-1)) Begin // separator character is pipe symbol, add everywhere except on last
87592>>>>>>>>>>>>>>>>>            Move (sList+"|") To sList
87593>>>>>>>>>>>>>>>>>          End
87593>>>>>>>>>>>>>>>>>>
87593>>>>>>>>>>>>>>>>>        Loop
87594>>>>>>>>>>>>>>>>>>
87594>>>>>>>>>>>>>>>>>        Move (Length(sWord)) To iChar
87595>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_AUTOCSHOW iChar (AddressOf(sList))
87596>>>>>>>>>>>>>>>>>        Move (String(sWord)+Character(0)) To sSelect
87597>>>>>>>>>>>>>>>>>        Send EditorMessage SCI_AUTOCSELECT 0 (AddressOf(sSelect))
87598>>>>>>>>>>>>>>>>>      End
87598>>>>>>>>>>>>>>>>>>
87598>>>>>>>>>>>>>>>>>    End
87598>>>>>>>>>>>>>>>>>>
87598>>>>>>>>>>>>>>>>>  End_Procedure
87599>>>>>>>>>>>>>>>>>
87599>>>>>>>>>>>>>>>>>  //
87599>>>>>>>>>>>>>>>>>  // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter
87599>>>>>>>>>>>>>>>>>  // counting and doesn't look nice in presenting in tooltip et al.
87599>>>>>>>>>>>>>>>>>  // We reduce the spaces here to just one.
87599>>>>>>>>>>>>>>>>>  //
87599>>>>>>>>>>>>>>>>>  Procedure StripConcatenatingSpaces String ByRef sText
87601>>>>>>>>>>>>>>>>>    While (Pos("  ",sText)<>0)
87605>>>>>>>>>>>>>>>>>      Move (Replaces("  ",sText," ")) To sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
87606>>>>>>>>>>>>>>>>>    Loop
87607>>>>>>>>>>>>>>>>>>
87607>>>>>>>>>>>>>>>>>  End_Procedure
87608>>>>>>>>>>>>>>>>>
87608>>>>>>>>>>>>>>>>>  //
87608>>>>>>>>>>>>>>>>>  // Takes care of the argument highlighting
87608>>>>>>>>>>>>>>>>>  //
87608>>>>>>>>>>>>>>>>>  Procedure CodetipParameterHighLight
87610>>>>>>>>>>>>>>>>>    Integer iType
87610>>>>>>>>>>>>>>>>>    Integer iPos
87610>>>>>>>>>>>>>>>>>    Integer iLastPos
87610>>>>>>>>>>>>>>>>>    Integer iArg
87610>>>>>>>>>>>>>>>>>    Integer iSelectedArg
87610>>>>>>>>>>>>>>>>>    Integer iHighlightStart
87610>>>>>>>>>>>>>>>>>    Integer iHighlightEnd
87610>>>>>>>>>>>>>>>>>    String  sTip
87610>>>>>>>>>>>>>>>>>
87610>>>>>>>>>>>>>>>>>    Move 0 To iHighLightStart
87611>>>>>>>>>>>>>>>>>    Move 0 To iHighLightEnd
87612>>>>>>>>>>>>>>>>>    Get psCodeTipCurrent to sTip
87613>>>>>>>>>>>>>>>>>    If (sTip<>"") Begin
87615>>>>>>>>>>>>>>>>>      Move (Pos(Character(10),sTip)) To iPos
87616>>>>>>>>>>>>>>>>>      If (iPos>0) Begin
87618>>>>>>>>>>>>>>>>>        Move (Left(sTip,iPos-1)) to sTip // first line has the expression/function/method, next line is the description
87619>>>>>>>>>>>>>>>>>      End
87619>>>>>>>>>>>>>>>>>>
87619>>>>>>>>>>>>>>>>>      Send StripConcatenatingSpaces (&sTip)        // no double spaces as it confuses the argument counting logic
87620>>>>>>>>>>>>>>>>>      Get piCodeTipArgument to iSelectedArg
87621>>>>>>>>>>>>>>>>>      Get piCodeTipType to iType
87622>>>>>>>>>>>>>>>>>      If (iType=C_TIPTYPE_EXPRESSION) Begin
87624>>>>>>>>>>>>>>>>>        Move (Pos("(",sTip)) To iPos // start first argument
87625>>>>>>>>>>>>>>>>>        Move 0 To iArg
87626>>>>>>>>>>>>>>>>>        While (iPos>0)
87630>>>>>>>>>>>>>>>>>
87630>>>>>>>>>>>>>>>>>          If (iSelectedArg=iArg) Begin
87632>>>>>>>>>>>>>>>>>            Move (iPos+1) to iHighLightStart
87633>>>>>>>>>>>>>>>>>          End
87633>>>>>>>>>>>>>>>>>>
87633>>>>>>>>>>>>>>>>>          Move (Pos(",",sTip,iPos+1)) To iPos
87634>>>>>>>>>>>>>>>>>          If (iHighLightStart<>0) Begin
87636>>>>>>>>>>>>>>>>>            If (iPos=0) Begin
87638>>>>>>>>>>>>>>>>>              Move (Pos(")",sTip,iHighlightStart)) to iPos
87639>>>>>>>>>>>>>>>>>            End
87639>>>>>>>>>>>>>>>>>>
87639>>>>>>>>>>>>>>>>>            If (iPos<>0) Begin
87641>>>>>>>>>>>>>>>>>              Move (iPos-1) To iHighLightEnd
87642>>>>>>>>>>>>>>>>>              Move 0 To iPos
87643>>>>>>>>>>>>>>>>>            End
87643>>>>>>>>>>>>>>>>>>
87643>>>>>>>>>>>>>>>>>          End
87643>>>>>>>>>>>>>>>>>>
87643>>>>>>>>>>>>>>>>>          Increment iArg
87644>>>>>>>>>>>>>>>>>          If (iArg>100) Begin
87646>>>>>>>>>>>>>>>>>            Move 0 to iPos // should not happen, but .. never loop and hang!
87647>>>>>>>>>>>>>>>>>          End
87647>>>>>>>>>>>>>>>>>>
87647>>>>>>>>>>>>>>>>>        Loop
87648>>>>>>>>>>>>>>>>>>
87648>>>>>>>>>>>>>>>>>        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
87650>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
87651>>>>>>>>>>>>>>>>>        End
87651>>>>>>>>>>>>>>>>>>
87651>>>>>>>>>>>>>>>>>        Else Begin
87652>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT 0 0
87653>>>>>>>>>>>>>>>>>        End
87653>>>>>>>>>>>>>>>>>>
87653>>>>>>>>>>>>>>>>>      End
87653>>>>>>>>>>>>>>>>>>
87653>>>>>>>>>>>>>>>>>      Else If (iType=C_TIPTYPE_FUNCTION) Begin
87656>>>>>>>>>>>>>>>>>        // function foo string sBar Integer iVoid Returns integer
87656>>>>>>>>>>>>>>>>>        // function foo string sBar Integer ByRef iVoid Returns integer
87656>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip)) To iPos // start function name
87657>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above function
87658>>>>>>>>>>>>>>>>>        Move 0 To iArg
87659>>>>>>>>>>>>>>>>>        While (iPos>0)
87663>>>>>>>>>>>>>>>>>
87663>>>>>>>>>>>>>>>>>          If (iSelectedArg=iArg) Begin
87665>>>>>>>>>>>>>>>>>            Move iPos to iHighLightStart
87666>>>>>>>>>>>>>>>>>          End
87666>>>>>>>>>>>>>>>>>>
87666>>>>>>>>>>>>>>>>>          Move (Pos(" ",sTip,iPos+1)) To iPos
87667>>>>>>>>>>>>>>>>>          Move iPos To iLastPos
87668>>>>>>>>>>>>>>>>>          If (iPos<>0) Begin
87670>>>>>>>>>>>>>>>>>            Move (Pos(" ",sTip,iPos+1)) To iPos
87671>>>>>>>>>>>>>>>>>            If (Mid(lowercase(sTip),iPos-(iLastPos+1),iLastPos+1)="byref") Begin
87673>>>>>>>>>>>>>>>>>              Move (Pos(" ",sTip,iPos+1)) To iPos
87674>>>>>>>>>>>>>>>>>            End
87674>>>>>>>>>>>>>>>>>>
87674>>>>>>>>>>>>>>>>>          End
87674>>>>>>>>>>>>>>>>>>
87674>>>>>>>>>>>>>>>>>          If (iHighLightStart<>0) Begin
87676>>>>>>>>>>>>>>>>>            If (iPos=0) Begin
87678>>>>>>>>>>>>>>>>>              Move (Length(sTip)+1) to iPos
87679>>>>>>>>>>>>>>>>>            End
87679>>>>>>>>>>>>>>>>>>
87679>>>>>>>>>>>>>>>>>            If (iPos<>0) Begin
87681>>>>>>>>>>>>>>>>>              Move (iPos-1) To iHighLightEnd
87682>>>>>>>>>>>>>>>>>              Move 0 To iPos
87683>>>>>>>>>>>>>>>>>            End
87683>>>>>>>>>>>>>>>>>>
87683>>>>>>>>>>>>>>>>>          End
87683>>>>>>>>>>>>>>>>>>
87683>>>>>>>>>>>>>>>>>          Increment iArg
87684>>>>>>>>>>>>>>>>>          If (iArg>100) Begin
87686>>>>>>>>>>>>>>>>>            Move 0 to iPos // should not happen, but .. never loop and hang!
87687>>>>>>>>>>>>>>>>>          End
87687>>>>>>>>>>>>>>>>>>
87687>>>>>>>>>>>>>>>>>        Loop
87688>>>>>>>>>>>>>>>>>>
87688>>>>>>>>>>>>>>>>>        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
87690>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
87691>>>>>>>>>>>>>>>>>        End
87691>>>>>>>>>>>>>>>>>>
87691>>>>>>>>>>>>>>>>>        Else Begin
87692>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT 0 0
87693>>>>>>>>>>>>>>>>>        End
87693>>>>>>>>>>>>>>>>>>
87693>>>>>>>>>>>>>>>>>      End
87693>>>>>>>>>>>>>>>>>>
87693>>>>>>>>>>>>>>>>>      Else If (iType=C_TIPTYPE_PROCEDURE) Begin
87696>>>>>>>>>>>>>>>>>        // procedure foo string sBar Integer iVoid Returns integer
87696>>>>>>>>>>>>>>>>>        // procedure foo string sBar Integer iVoid
87696>>>>>>>>>>>>>>>>>        // procedure foo string sBar Integer ByRef iVoid
87696>>>>>>>>>>>>>>>>>        // procedure set foo string sBar Integer iVoid
87696>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip)) To iPos // start procedure name or set
87697>>>>>>>>>>>>>>>>>        If (Mid(lowercase(sTip),3,iPos+1)="set") Begin
87699>>>>>>>>>>>>>>>>>          Move (Pos(" ",sTip,iPos+1)) To iPos // at start procedure name
87700>>>>>>>>>>>>>>>>>        End
87700>>>>>>>>>>>>>>>>>>
87700>>>>>>>>>>>>>>>>>        Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above method
87701>>>>>>>>>>>>>>>>>        Move 0 To iArg
87702>>>>>>>>>>>>>>>>>        While (iPos>0)
87706>>>>>>>>>>>>>>>>>
87706>>>>>>>>>>>>>>>>>          If (iSelectedArg=iArg) Begin
87708>>>>>>>>>>>>>>>>>            Move iPos to iHighLightStart
87709>>>>>>>>>>>>>>>>>          End
87709>>>>>>>>>>>>>>>>>>
87709>>>>>>>>>>>>>>>>>          Move (Pos(" ",sTip,iPos+1)) To iPos
87710>>>>>>>>>>>>>>>>>          Move iPos To iLastPos
87711>>>>>>>>>>>>>>>>>          If (iPos<>0) Begin
87713>>>>>>>>>>>>>>>>>            Move (Pos(" ",sTip,iPos+1)) To iPos
87714>>>>>>>>>>>>>>>>>            If (Mid(lowercase(sTip),iPos-(iLastPos+1),iLastPos+1)="byref") Begin
87716>>>>>>>>>>>>>>>>>              Move (Pos(" ",sTip,iPos+1)) To iPos
87717>>>>>>>>>>>>>>>>>            End
87717>>>>>>>>>>>>>>>>>>
87717>>>>>>>>>>>>>>>>>          End
87717>>>>>>>>>>>>>>>>>>
87717>>>>>>>>>>>>>>>>>          If (iHighLightStart<>0) Begin
87719>>>>>>>>>>>>>>>>>            If (iPos=0) Begin
87721>>>>>>>>>>>>>>>>>              Move (Length(sTip)+1) to iPos
87722>>>>>>>>>>>>>>>>>            End
87722>>>>>>>>>>>>>>>>>>
87722>>>>>>>>>>>>>>>>>            If (iPos<>0) Begin
87724>>>>>>>>>>>>>>>>>              Move (iPos-1) To iHighLightEnd
87725>>>>>>>>>>>>>>>>>              Move 0 To iPos
87726>>>>>>>>>>>>>>>>>            End
87726>>>>>>>>>>>>>>>>>>
87726>>>>>>>>>>>>>>>>>          End
87726>>>>>>>>>>>>>>>>>>
87726>>>>>>>>>>>>>>>>>          Increment iArg
87727>>>>>>>>>>>>>>>>>          If (iArg>100) Begin
87729>>>>>>>>>>>>>>>>>            Move 0 to iPos // should not happen, but .. never loop and hang!
87730>>>>>>>>>>>>>>>>>          End
87730>>>>>>>>>>>>>>>>>>
87730>>>>>>>>>>>>>>>>>        Loop
87731>>>>>>>>>>>>>>>>>>
87731>>>>>>>>>>>>>>>>>        If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
87733>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
87734>>>>>>>>>>>>>>>>>        End
87734>>>>>>>>>>>>>>>>>>
87734>>>>>>>>>>>>>>>>>        Else Begin
87735>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSETHLT 0 0
87736>>>>>>>>>>>>>>>>>        End
87736>>>>>>>>>>>>>>>>>>
87736>>>>>>>>>>>>>>>>>      End
87736>>>>>>>>>>>>>>>>>>
87736>>>>>>>>>>>>>>>>>    End
87736>>>>>>>>>>>>>>>>>>
87736>>>>>>>>>>>>>>>>>  End_Procedure
87737>>>>>>>>>>>>>>>>>
87737>>>>>>>>>>>>>>>>>  // Codetip requested: return the type of Codetip to display or CM_TIPSTYLE_NONE to not displaying a codetip
87737>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87737>>>>>>>>>>>>>>>>>  Procedure DoCodeTip
87739>>>>>>>>>>>>>>>>>    Boolean bCallTipActive
87739>>>>>>>>>>>>>>>>>    Integer iOk
87739>>>>>>>>>>>>>>>>>    Integer iPos
87739>>>>>>>>>>>>>>>>>    Integer iChar
87739>>>>>>>>>>>>>>>>>    String  sTip
87739>>>>>>>>>>>>>>>>>
87739>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_CALLTIPACTIVE to bCallTipActive // calltip active on screen
87740>>>>>>>>>>>>>>>>>    If (bCallTipActive) Begin
87742>>>>>>>>>>>>>>>>>      If (piCodeTipType(Self)=C_TIPTYPE_EXPRESSION) Begin
87744>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETCURRENTPOS to iPos
87745>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETCHARAT (iPos-1) to iChar
87746>>>>>>>>>>>>>>>>>        If (iChar=Ascii(")")) Begin
87748>>>>>>>>>>>>>>>>>          Send DoCodeTipCancel
87749>>>>>>>>>>>>>>>>>        End
87749>>>>>>>>>>>>>>>>>>
87749>>>>>>>>>>>>>>>>>        Else Begin
87750>>>>>>>>>>>>>>>>>          Send DoCodeTipUpdate
87751>>>>>>>>>>>>>>>>>        End
87751>>>>>>>>>>>>>>>>>>
87751>>>>>>>>>>>>>>>>>      End
87751>>>>>>>>>>>>>>>>>>
87751>>>>>>>>>>>>>>>>>      Else Begin
87752>>>>>>>>>>>>>>>>>        Send DoCodeTipUpdate
87753>>>>>>>>>>>>>>>>>      End
87753>>>>>>>>>>>>>>>>>>
87753>>>>>>>>>>>>>>>>>    End
87753>>>>>>>>>>>>>>>>>>
87753>>>>>>>>>>>>>>>>>    Else Begin
87754>>>>>>>>>>>>>>>>>
87754>>>>>>>>>>>>>>>>>      Get msg_OnCodeTip to iOk
87755>>>>>>>>>>>>>>>>>      If (iOk) Begin
87757>>>>>>>>>>>>>>>>>        Get psCodeTipCurrent to sTip
87758>>>>>>>>>>>>>>>>>        If (sTip<>"") Begin
87760>>>>>>>>>>>>>>>>>          Send StripConcatenatingSpaces (&sTip)   // no gap of more than one space
87761>>>>>>>>>>>>>>>>>          Move (Replaces("//",sTip,"\n")) To sTip // display description on a new line
87762>>>>>>>>>>>>>>>>>          Move (Replaces("\n",sTip,Character(10))) To sTip
87763>>>>>>>>>>>>>>>>>          Move (sTip+"  ") To sTip // HACK to make the tip a tiny bit wider at the end, so that the bold argument does not cut anything off at the end.
87764>>>>>>>>>>>>>>>>>          // Cannot calc afterwards as dynamic bolding is done on existing tooltip.
87764>>>>>>>>>>>>>>>>>          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
87765>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
87766>>>>>>>>>>>>>>>>>        End
87766>>>>>>>>>>>>>>>>>>
87766>>>>>>>>>>>>>>>>>      End
87766>>>>>>>>>>>>>>>>>>
87766>>>>>>>>>>>>>>>>>    End
87766>>>>>>>>>>>>>>>>>>
87766>>>>>>>>>>>>>>>>>  End_Procedure
87767>>>>>>>>>>>>>>>>>  // Codetip is to be displayed: return TRUE if changes applied to the codetip structure or FALSE if not
87767>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87767>>>>>>>>>>>>>>>>>  Procedure DoCodeTipInitialize   Integer lParam
87769>>>>>>>>>>>>>>>>>    Integer iOk
87769>>>>>>>>>>>>>>>>>    Get msg_OnCodeTipInitialize to iOk
87770>>>>>>>>>>>>>>>>>    If (iOk) Begin
87772>>>>>>>>>>>>>>>>>      Send CodetipParameterHighLight
87773>>>>>>>>>>>>>>>>>      Procedure_Return 1
87774>>>>>>>>>>>>>>>>>    End
87774>>>>>>>>>>>>>>>>>>
87774>>>>>>>>>>>>>>>>>    Procedure_Return 0
87775>>>>>>>>>>>>>>>>>  End_Procedure
87776>>>>>>>>>>>>>>>>>
87776>>>>>>>>>>>>>>>>>  // Reset CodeTip Properties
87776>>>>>>>>>>>>>>>>>  Procedure CodeTipReset
87778>>>>>>>>>>>>>>>>>    Set piCodeTipHighlightedStart  to -1
87779>>>>>>>>>>>>>>>>>    Set piCodeTipHighlightedEnd    to -1
87780>>>>>>>>>>>>>>>>>    Set piCodeTipArgument          to -1
87781>>>>>>>>>>>>>>>>>    //
87781>>>>>>>>>>>>>>>>>    Set psCodeTipCurrent           to ""
87782>>>>>>>>>>>>>>>>>    Set piCodeTipCurrLine          to -1
87783>>>>>>>>>>>>>>>>>  End_Procedure
87784>>>>>>>>>>>>>>>>>
87784>>>>>>>>>>>>>>>>>  // Codetip is to be removed: return FALSE if the codetip should be removed or TRUE if to codetip should remain visible
87784>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87784>>>>>>>>>>>>>>>>>  Procedure DoCodeTipCancel
87786>>>>>>>>>>>>>>>>>    Integer iOk
87786>>>>>>>>>>>>>>>>>    //
87786>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPCANCEL
87787>>>>>>>>>>>>>>>>>    // Reset CodeTip Properties
87787>>>>>>>>>>>>>>>>>    Send CodeTipReset
87788>>>>>>>>>>>>>>>>>    Get msg_OnCodeTipCancel to iOk
87789>>>>>>>>>>>>>>>>>    Procedure_Return iOk
87790>>>>>>>>>>>>>>>>>  End_Procedure
87791>>>>>>>>>>>>>>>>>  // Codetip is to be updated (position, values...): return TRUE if changes applied to the codetip structure or FALSE if not
87791>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87791>>>>>>>>>>>>>>>>>  Procedure DoCodeTipUpdate
87793>>>>>>>>>>>>>>>>>    Integer iOk
87793>>>>>>>>>>>>>>>>>    Get msg_OnCodeTipUpdate to iOk
87794>>>>>>>>>>>>>>>>>    If (iOk) Begin
87796>>>>>>>>>>>>>>>>>      Send CodetipParameterHighLight
87797>>>>>>>>>>>>>>>>>      Procedure_Return 1
87798>>>>>>>>>>>>>>>>>    End
87798>>>>>>>>>>>>>>>>>>
87798>>>>>>>>>>>>>>>>>    Procedure_Return 0
87799>>>>>>>>>>>>>>>>>  End_Procedure
87800>>>>>>>>>>>>>>>>>
87800>>>>>>>>>>>>>>>>>  Procedure RestoreTipBeforeAutoComplete
87802>>>>>>>>>>>>>>>>>    Boolean bCallTipActive
87802>>>>>>>>>>>>>>>>>    Integer iPos
87802>>>>>>>>>>>>>>>>>    String  sTip
87802>>>>>>>>>>>>>>>>>
87802>>>>>>>>>>>>>>>>>    If (pbHadTipBeforeAutocomplete(Self)) Begin
87804>>>>>>>>>>>>>>>>>      Set pbCodetipRequest to True
87805>>>>>>>>>>>>>>>>>      Set pbHadTipBeforeAutocomplete to False
87806>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_CALLTIPACTIVE To bCallTipActive
87807>>>>>>>>>>>>>>>>>      If (bCallTipActive=False) Begin
87809>>>>>>>>>>>>>>>>>        // We first need to put the tooltip back up on the screen again
87809>>>>>>>>>>>>>>>>>        Get psCodeTipCurrent to sTip
87810>>>>>>>>>>>>>>>>>        If (sTip<>"") Begin
87812>>>>>>>>>>>>>>>>>          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
87813>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
87814>>>>>>>>>>>>>>>>>        End
87814>>>>>>>>>>>>>>>>>>
87814>>>>>>>>>>>>>>>>>      End
87814>>>>>>>>>>>>>>>>>>
87814>>>>>>>>>>>>>>>>>      Send CodetipParameterHighLight
87815>>>>>>>>>>>>>>>>>    End
87815>>>>>>>>>>>>>>>>>>
87815>>>>>>>>>>>>>>>>>  End_Procedure
87816>>>>>>>>>>>>>>>>>
87816>>>>>>>>>>>>>>>>>  // Remove the codelist window
87816>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87816>>>>>>>>>>>>>>>>>  Procedure CancelCodelist
87818>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_AUTOCCANCEL
87819>>>>>>>>>>>>>>>>>    Send RestoreTipBeforeAutoComplete
87820>>>>>>>>>>>>>>>>>  End_Procedure
87821>>>>>>>>>>>>>>>>>
87821>>>>>>>>>>>>>>>>>  // Remove the codetip window
87821>>>>>>>>>>>>>>>>>  // 12.2.2003 BP
87821>>>>>>>>>>>>>>>>>  Procedure CancelCodetip
87823>>>>>>>>>>>>>>>>>    Set pbCodeTipRequest  To False
87824>>>>>>>>>>>>>>>>>    Send EditorMessage SCI_CALLTIPCANCEL
87825>>>>>>>>>>>>>>>>>  End_Procedure
87826>>>>>>>>>>>>>>>>>
87826>>>>>>>>>>>>>>>>>  Procedure Request_Cancel
87828>>>>>>>>>>>>>>>>>    Boolean bCodeListActive
87828>>>>>>>>>>>>>>>>>
87828>>>>>>>>>>>>>>>>>    Get pbIsCodelistActive to bCodeListActive
87829>>>>>>>>>>>>>>>>>    If (bCodeListActive) Begin
87831>>>>>>>>>>>>>>>>>      Send CancelCodeList
87832>>>>>>>>>>>>>>>>>      Send DoCodeListCancel
87833>>>>>>>>>>>>>>>>>    End
87833>>>>>>>>>>>>>>>>>>
87833>>>>>>>>>>>>>>>>>  End_Procedure
87834>>>>>>>>>>>>>>>>>
87834>>>>>>>>>>>>>>>>>  // BP CodeList Support
87834>>>>>>>>>>>>>>>>>  // DoCodeList: Notification that a Codelist is requested
87834>>>>>>>>>>>>>>>>>  // Connect the VDF-Codelist Object to the delivered codelist handle, adjust some features
87834>>>>>>>>>>>>>>>>>  // and fill in the requested lines.
87834>>>>>>>>>>>>>>>>>  Procedure DoCodeList            Integer lParam
87836>>>>>>>>>>>>>>>>>    Integer iRet
87836>>>>>>>>>>>>>>>>>    Handle hCodeList
87836>>>>>>>>>>>>>>>>>
87836>>>>>>>>>>>>>>>>>    If (not(phoCodeListHandler(Self))) Begin
87838>>>>>>>>>>>>>>>>>      Procedure_Return False
87839>>>>>>>>>>>>>>>>>    End
87839>>>>>>>>>>>>>>>>>>
87839>>>>>>>>>>>>>>>>>
87839>>>>>>>>>>>>>>>>>    Move 0 To hCodeList
87840>>>>>>>>>>>>>>>>>    Get DoCodeListInit hCodeList to iRet
87841>>>>>>>>>>>>>>>>>    If (iRet) Begin
87843>>>>>>>>>>>>>>>>>      Procedure_Return True
87844>>>>>>>>>>>>>>>>>    End
87844>>>>>>>>>>>>>>>>>>
87844>>>>>>>>>>>>>>>>>    Procedure_Return False
87845>>>>>>>>>>>>>>>>>  End_Procedure
87846>>>>>>>>>>>>>>>>>
87846>>>>>>>>>>>>>>>>>  Procedure OnCodelistCancel
87848>>>>>>>>>>>>>>>>>  End_Procedure
87849>>>>>>>>>>>>>>>>>
87849>>>>>>>>>>>>>>>>>  // DoCodelistCancel
87849>>>>>>>>>>>>>>>>>  // Notification that the listview was canceled without selecting a value
87849>>>>>>>>>>>>>>>>>  Procedure DoCodeListCancel
87851>>>>>>>>>>>>>>>>>    Send OnCodelistCancel
87852>>>>>>>>>>>>>>>>>    Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
87853>>>>>>>>>>>>>>>>>    Set pbIsCodelistActive To False
87854>>>>>>>>>>>>>>>>>    Procedure_Return False // return FALSE to remove the listview from screen
87855>>>>>>>>>>>>>>>>>  End_Procedure
87856>>>>>>>>>>>>>>>>>
87856>>>>>>>>>>>>>>>>>
87856>>>>>>>>>>>>>>>>>  // DoCodelistSelMade
87856>>>>>>>>>>>>>>>>>  // Notification that a item was selected within the listview
87856>>>>>>>>>>>>>>>>>  // Originally called DoCodelistSelMade, renamed as we have different parameters
87856>>>>>>>>>>>>>>>>>  Procedure DoAutoCompleteSelection Address aText
87858>>>>>>>>>>>>>>>>>    String sItem sText
87858>>>>>>>>>>>>>>>>>    Integer iRet iItem iRefVal iRetVal
87858>>>>>>>>>>>>>>>>>
87858>>>>>>>>>>>>>>>>>    If (not(phoCodeListHandler(Self))) Begin
87860>>>>>>>>>>>>>>>>>      Procedure_Return False
87861>>>>>>>>>>>>>>>>>    End
87861>>>>>>>>>>>>>>>>>>
87861>>>>>>>>>>>>>>>>>
87861>>>>>>>>>>>>>>>>>    If (aText<>0) Begin
87863>>>>>>>>>>>>>>>>>      Move aText To sText
87864>>>>>>>>>>>>>>>>>    End
87864>>>>>>>>>>>>>>>>>>
87864>>>>>>>>>>>>>>>>>    Else Begin
87865>>>>>>>>>>>>>>>>>      Move "" to sText
87866>>>>>>>>>>>>>>>>>    End
87866>>>>>>>>>>>>>>>>>>
87866>>>>>>>>>>>>>>>>>    If (sText<>"") Begin
87868>>>>>>>>>>>>>>>>>      Send CancelCodelist // we handle insertion of the value by ourself
87869>>>>>>>>>>>>>>>>>      Move sText to sItem // we still need the iRefVal as it is a helper variable for finding the relevant parts
87870>>>>>>>>>>>>>>>>>      Get Codelist_find_item of (phoCodeListHandler(Self)) sText To iItem
87871>>>>>>>>>>>>>>>>>      If iItem Ne -1 Begin
87873>>>>>>>>>>>>>>>>>        Get Codelist_value of (phoCodelistHandler(Self)) iItem to sItem  // get the item text of the selected item
87874>>>>>>>>>>>>>>>>>        Get piRefValue of (phoCodelistHandler(Self)) to iRefVal
87875>>>>>>>>>>>>>>>>>        Get msg_CM_CodeListItemSelected sItem iRefVal to iRetVal
87876>>>>>>>>>>>>>>>>>      End
87876>>>>>>>>>>>>>>>>>>
87876>>>>>>>>>>>>>>>>>    End
87876>>>>>>>>>>>>>>>>>>
87876>>>>>>>>>>>>>>>>>    Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
87877>>>>>>>>>>>>>>>>>  End_Procedure
87878>>>>>>>>>>>>>>>>>
87878>>>>>>>>>>>>>>>>>  // To be filled in at higher class
87878>>>>>>>>>>>>>>>>>  Function TranslateCharacter Integer iKey Returns Integer
87880>>>>>>>>>>>>>>>>>    Function_Return 0
87881>>>>>>>>>>>>>>>>>  End_Function
87882>>>>>>>>>>>>>>>>>
87882>>>>>>>>>>>>>>>>>  // To be filled in at higher class
87882>>>>>>>>>>>>>>>>>  Function ShouldTranslateCharacter Integer iKeyCode Returns Boolean
87884>>>>>>>>>>>>>>>>>    Function_Return false
87885>>>>>>>>>>>>>>>>>  End_Function
87886>>>>>>>>>>>>>>>>>
87886>>>>>>>>>>>>>>>>>
87886>>>>>>>>>>>>>>>>>  Procedure doCharacterTranslation Address aText Integer iLength
87888>>>>>>>>>>>>>>>>>    Boolean bTranslateChar
87888>>>>>>>>>>>>>>>>>    Integer iKey
87888>>>>>>>>>>>>>>>>>    Integer iNewKey
87888>>>>>>>>>>>>>>>>>    String  sText
87888>>>>>>>>>>>>>>>>>    String  sNewChar
87888>>>>>>>>>>>>>>>>>
87888>>>>>>>>>>>>>>>>>    If (pbFileLoading(Self)=false) Begin // don't translate text when loading from disk
87890>>>>>>>>>>>>>>>>>      If (aText<>0) Begin
87892>>>>>>>>>>>>>>>>>        Move aText To sText
87893>>>>>>>>>>>>>>>>>      End
87893>>>>>>>>>>>>>>>>>>
87893>>>>>>>>>>>>>>>>>      Else Begin
87894>>>>>>>>>>>>>>>>>        Move "" to sText
87895>>>>>>>>>>>>>>>>>      End
87895>>>>>>>>>>>>>>>>>>
87895>>>>>>>>>>>>>>>>>      If (sText<>"" and iLength=1) Begin
87897>>>>>>>>>>>>>>>>>        Move (Ascii(sText)) To iKey
87898>>>>>>>>>>>>>>>>>        Get ShouldTranslateCharacter iKey to bTranslateChar
87899>>>>>>>>>>>>>>>>>        If (bTranslateChar) Begin
87901>>>>>>>>>>>>>>>>>          Get TranslateCharacter iKey to iNewKey
87902>>>>>>>>>>>>>>>>>          If (iNewKey<>0) Begin
87904>>>>>>>>>>>>>>>>>            Move (Character(iNewKey)) To sNewChar
87905>>>>>>>>>>>>>>>>>            Send EditorMessage SCI_CHANGEINSERTION 1 (AddressOf(sNewChar))
87906>>>>>>>>>>>>>>>>>          End
87906>>>>>>>>>>>>>>>>>>
87906>>>>>>>>>>>>>>>>>        End
87906>>>>>>>>>>>>>>>>>>
87906>>>>>>>>>>>>>>>>>      End
87906>>>>>>>>>>>>>>>>>>
87906>>>>>>>>>>>>>>>>>    End
87906>>>>>>>>>>>>>>>>>>
87906>>>>>>>>>>>>>>>>>  End_Procedure
87907>>>>>>>>>>>>>>>>>
87907>>>>>>>>>>>>>>>>>  Procedure UpdateUIBlockSelectEdit
87909>>>>>>>>>>>>>>>>>    Boolean bBlockSelect
87909>>>>>>>>>>>>>>>>>    Integer iCaretPos iAnchorPos
87909>>>>>>>>>>>>>>>>>
87909>>>>>>>>>>>>>>>>>    If (pbBlockSelectBackspace(Self)) Begin
87911>>>>>>>>>>>>>>>>>      // bugfix
87911>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETSELECTIONMODE SC_SEL_RECTANGLE
87912>>>>>>>>>>>>>>>>>    End
87912>>>>>>>>>>>>>>>>>>
87912>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_SELECTIONISRECTANGLE to bBlockSelect
87913>>>>>>>>>>>>>>>>>    //Set pbBlockSelectActive to bBlockSelect
87913>>>>>>>>>>>>>>>>>    If (bBlockSelect) Begin
87915>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETRECTANGULARSELECTIONANCHOR to iAnchorPos
87916>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETRECTANGULARSELECTIONCARET  to iCaretPos
87917>>>>>>>>>>>>>>>>>      Set piBlockSelectAnchorPos to iAnchorPos
87918>>>>>>>>>>>>>>>>>      Set piBlockSelectCaretPos  to iCaretPos
87919>>>>>>>>>>>>>>>>>    End
87919>>>>>>>>>>>>>>>>>>
87919>>>>>>>>>>>>>>>>>    If (bBlockSelect=False) Begin
87921>>>>>>>>>>>>>>>>>      Set piBlockSelectAnchorPos to 0
87922>>>>>>>>>>>>>>>>>      Set piBlockSelectCaretPos  to 0
87923>>>>>>>>>>>>>>>>>    End
87923>>>>>>>>>>>>>>>>>>
87923>>>>>>>>>>>>>>>>>  End_Procedure
87924>>>>>>>>>>>>>>>>>
87924>>>>>>>>>>>>>>>>>  // tab works, but not when only space characters at first line, then it is a mess.
87924>>>>>>>>>>>>>>>>>  // But if I move the selection to the first column it works again. It's a bit ugly, but it works
87924>>>>>>>>>>>>>>>>>  Procedure BlockSelectTabKeyBugfix
87926>>>>>>>>>>>>>>>>>    Boolean bNeedBugfix
87926>>>>>>>>>>>>>>>>>    Integer iAnchorPos iCaretPos iColumn
87926>>>>>>>>>>>>>>>>>    Integer iLine iStartLine iEndLine
87926>>>>>>>>>>>>>>>>>    String  sLine sValue
87926>>>>>>>>>>>>>>>>>
87926>>>>>>>>>>>>>>>>>    Move True to bNeedBugfix
87927>>>>>>>>>>>>>>>>>    Get piBlockSelectAnchorPos to iAnchorPos
87928>>>>>>>>>>>>>>>>>    Get piBlockSelectCaretPos  to iCaretPos
87929>>>>>>>>>>>>>>>>>    // As it is a block select, the start column is the end column and thus we check the text of
87929>>>>>>>>>>>>>>>>>    // all selected lines from column 0 to iColumn
87929>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN  iAnchorPos to iColumn
87930>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87931>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87932>>>>>>>>>>>>>>>>>    For iLine from iStartLine to iEndLine
87938>>>>>>>>>>>>>>>>>>
87938>>>>>>>>>>>>>>>>>      Get Value item iLine to sLine
87939>>>>>>>>>>>>>>>>>      Move (Left(sLine,iColumn)) To sValue
87940>>>>>>>>>>>>>>>>>      If (sValue<>"") Begin
87942>>>>>>>>>>>>>>>>>        Move False To bNeedBugfix
87943>>>>>>>>>>>>>>>>>        Move iEndLine to iLine
87944>>>>>>>>>>>>>>>>>      End
87944>>>>>>>>>>>>>>>>>>
87944>>>>>>>>>>>>>>>>>    Loop
87945>>>>>>>>>>>>>>>>>>
87945>>>>>>>>>>>>>>>>>    If (bNeedBugfix) Begin
87947>>>>>>>>>>>>>>>>>      Send BlockSelectAdjustSelectionColumn iAnchorPos iCaretPos (-iColumn)
87948>>>>>>>>>>>>>>>>>    End
87948>>>>>>>>>>>>>>>>>>
87948>>>>>>>>>>>>>>>>>  End_Procedure
87949>>>>>>>>>>>>>>>>>
87949>>>>>>>>>>>>>>>>>  // If you do a block select and then start typing it should remove the selected block of text
87949>>>>>>>>>>>>>>>>>  // before it does the multiline text type.
87949>>>>>>>>>>>>>>>>>  Procedure BlockSelectRemoveTextBlockBugfix
87951>>>>>>>>>>>>>>>>>    Integer iCaretPos iAnchorPos
87951>>>>>>>>>>>>>>>>>    Integer iStartLine iStartColumn
87951>>>>>>>>>>>>>>>>>    Integer iEndLine   iEndColumn
87951>>>>>>>>>>>>>>>>>
87951>>>>>>>>>>>>>>>>>    Get piBlockSelectAnchorPos to iAnchorPos
87952>>>>>>>>>>>>>>>>>    Get piBlockSelectCaretPos  to iCaretPos
87953>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87954>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn
87955>>>>>>>>>>>>>>>>>
87955>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87956>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
87957>>>>>>>>>>>>>>>>>    If (iStartColumn<>iEndColumn) Begin
87959>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_DELETEBACK  //<--  this actually works ?\_(?)_/?
87960>>>>>>>>>>>>>>>>>    End
87960>>>>>>>>>>>>>>>>>>
87960>>>>>>>>>>>>>>>>>  End_Procedure
87961>>>>>>>>>>>>>>>>>
87961>>>>>>>>>>>>>>>>>  //
87961>>>>>>>>>>>>>>>>>  // Move the block selection by iAdjust positions to the left or right
87961>>>>>>>>>>>>>>>>>  //
87961>>>>>>>>>>>>>>>>>  Procedure BlockSelectAdjustSelectionColumn Integer iAnchorPos Integer iCaretPos Integer iAdjust
87963>>>>>>>>>>>>>>>>>    Integer iStartLine iStartColumn
87963>>>>>>>>>>>>>>>>>    Integer iEndLine   iEndColumn
87963>>>>>>>>>>>>>>>>>
87963>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87964>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn
87965>>>>>>>>>>>>>>>>>
87965>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87966>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
87967>>>>>>>>>>>>>>>>>    If (iStartColumn=iEndColumn) Begin
87969>>>>>>>>>>>>>>>>>      //
87969>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iStartLine (iStartColumn+iAdjust) to iAnchorPos
87970>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iEndLine   (iEndColumn+iAdjust)   to iCaretPos
87971>>>>>>>>>>>>>>>>>      // move selection to the new position
87971>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONANCHOR iAnchorPos
87972>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONCARET  iCaretPos
87973>>>>>>>>>>>>>>>>>    End
87973>>>>>>>>>>>>>>>>>>
87973>>>>>>>>>>>>>>>>>  End_Procedure
87974>>>>>>>>>>>>>>>>>
87974>>>>>>>>>>>>>>>>>  Procedure BlockSelectEdit Integer iChar Longptr lParam
87976>>>>>>>>>>>>>>>>>    Integer iCaretPos iAnchorPos
87976>>>>>>>>>>>>>>>>>    Integer iStartLine iStartColumn iLine
87976>>>>>>>>>>>>>>>>>    Integer iEndLine   iEndColumn iRet
87976>>>>>>>>>>>>>>>>>    String  sChar
87976>>>>>>>>>>>>>>>>>
87976>>>>>>>>>>>>>>>>>    Move (character(iChar)) To sChar
87977>>>>>>>>>>>>>>>>>    Get piBlockSelectAnchorPos to iAnchorPos
87978>>>>>>>>>>>>>>>>>    Get piBlockSelectCaretPos  to iCaretPos
87979>>>>>>>>>>>>>>>>>
87979>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iAnchorPos to iStartLine
87980>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iAnchorPos to iStartColumn
87981>>>>>>>>>>>>>>>>>
87981>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iCaretPos  to iEndLine
87982>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iCaretPos  to iEndColumn
87983>>>>>>>>>>>>>>>>>    If (iStartColumn=iEndColumn) Begin
87985>>>>>>>>>>>>>>>>>      If (iStartLine>iEndLine) Begin
87987>>>>>>>>>>>>>>>>>        Send SwapIntegerVariables (&iStartLine) (&iEndLine)
87988>>>>>>>>>>>>>>>>>      End
87988>>>>>>>>>>>>>>>>>>
87988>>>>>>>>>>>>>>>>>      // easy type over multiple lines, cursor is on endline and will type itself
87988>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_BEGINUNDOACTION
87989>>>>>>>>>>>>>>>>>      For iLine from iStartLine to (iEndLine-1)
87995>>>>>>>>>>>>>>>>>>
87995>>>>>>>>>>>>>>>>>        Get CM_InsertText sChar iLine iStartColumn to iRet
87996>>>>>>>>>>>>>>>>>      Loop
87997>>>>>>>>>>>>>>>>>>
87997>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_ENDUNDOACTION
87998>>>>>>>>>>>>>>>>>      //
87998>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iStartLine (iStartColumn+1) to iAnchorPos
87999>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iEndLine   (iEndColumn+1)   to iCaretPos
88000>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONANCHOR iAnchorPos
88001>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETRECTANGULARSELECTIONCARET  iCaretPos
88002>>>>>>>>>>>>>>>>>      //Send BlockSelectAdjustSelectionColumn iAnchorPos iCaretPos 1  // this one doesn't work, don't quite understand why
88002>>>>>>>>>>>>>>>>>    End
88002>>>>>>>>>>>>>>>>>>
88002>>>>>>>>>>>>>>>>>  End_Procedure
88003>>>>>>>>>>>>>>>>>
88003>>>>>>>>>>>>>>>>>  // BP
88003>>>>>>>>>>>>>>>>>
88003>>>>>>>>>>>>>>>>>  Procedure onBeforeFloatingMenu
88005>>>>>>>>>>>>>>>>>  End_Procedure
88006>>>>>>>>>>>>>>>>>  Procedure onAfterFloatingMenu
88008>>>>>>>>>>>>>>>>>  End_Procedure
88009>>>>>>>>>>>>>>>>>
88009>>>>>>>>>>>>>>>>>  // Is sent when a WM_Notify with NM_RCLICK occusrs.
88009>>>>>>>>>>>>>>>>>  // I use it to implement the Popup of the floating_poup_menu.
88009>>>>>>>>>>>>>>>>>  Procedure DoRightClick Longptr lParam
88011>>>>>>>>>>>>>>>>>    If (Floating_Menu_Object(Self)) Ne 0 Begin
88013>>>>>>>>>>>>>>>>>      Set phoServedObject of (Floating_menu_object(Self)) to Self
88014>>>>>>>>>>>>>>>>>      Send OnBeforeFloatingMenu
88015>>>>>>>>>>>>>>>>>      Send Popup  to (Floating_Menu_Object(Self))
88016>>>>>>>>>>>>>>>>>      Send OnAfterFloatingMenu
88017>>>>>>>>>>>>>>>>>      Procedure_Return 1
88018>>>>>>>>>>>>>>>>>    End
88018>>>>>>>>>>>>>>>>>>
88018>>>>>>>>>>>>>>>>>  End_Procedure
88019>>>>>>>>>>>>>>>>>
88019>>>>>>>>>>>>>>>>>  Procedure onSetFocus
88021>>>>>>>>>>>>>>>>>  End_Procedure
88022>>>>>>>>>>>>>>>>>  Procedure onKillFocus
88024>>>>>>>>>>>>>>>>>  End_Procedure
88025>>>>>>>>>>>>>>>>>  Procedure onChange
88027>>>>>>>>>>>>>>>>>  End_Procedure
88028>>>>>>>>>>>>>>>>>
88028>>>>>>>>>>>>>>>>>
88028>>>>>>>>>>>>>>>>>  Procedure OnCharAdded
88030>>>>>>>>>>>>>>>>>  End_Procedure
88031>>>>>>>>>>>>>>>>>
88031>>>>>>>>>>>>>>>>>  Procedure OnStyleNeeded
88033>>>>>>>>>>>>>>>>>  End_Procedure
88034>>>>>>>>>>>>>>>>>
88034>>>>>>>>>>>>>>>>>  Procedure OnSavePointReached
88036>>>>>>>>>>>>>>>>>  End_Procedure
88037>>>>>>>>>>>>>>>>>
88037>>>>>>>>>>>>>>>>>  Procedure OnSavePointLeft
88039>>>>>>>>>>>>>>>>>  End_Procedure
88040>>>>>>>>>>>>>>>>>
88040>>>>>>>>>>>>>>>>>  Procedure OnDoubleClick
88042>>>>>>>>>>>>>>>>>    //Send Info_Box "double click"
88042>>>>>>>>>>>>>>>>>  End_Procedure
88043>>>>>>>>>>>>>>>>>  
88043>>>>>>>>>>>>>>>>>  // If you double click on a brace character then we select
88043>>>>>>>>>>>>>>>>>  // the text underneath until the matching brace character
88043>>>>>>>>>>>>>>>>>  Procedure MatchingBracesSelectText Integer iPos
88045>>>>>>>>>>>>>>>>>    Boolean bIsBraceChar
88045>>>>>>>>>>>>>>>>>    Boolean bIsComment
88045>>>>>>>>>>>>>>>>>    Boolean bIsMatch
88045>>>>>>>>>>>>>>>>>    Integer iChar
88045>>>>>>>>>>>>>>>>>    Integer iMatchPos
88045>>>>>>>>>>>>>>>>>    Integer imaxRestyle
88045>>>>>>>>>>>>>>>>>    
88045>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCHARAT iPos 0 to iChar
88046>>>>>>>>>>>>>>>>>    Get IsBraceCharacter iChar To bIsBraceChar
88047>>>>>>>>>>>>>>>>>    If (bIsBraceChar) Begin
88049>>>>>>>>>>>>>>>>>      Get StyleAtPosIsComment iPos To bIsComment
88050>>>>>>>>>>>>>>>>>      If (bIsComment=false) Begin
88052>>>>>>>>>>>>>>>>>        Move 0 to imaxReStyle
88053>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
88054>>>>>>>>>>>>>>>>>        Get IsValidBraceCharMatch iPos iMatchPos to bIsMatch
88055>>>>>>>>>>>>>>>>>        If (bIsMatch) Begin
88057>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETEMPTYSELECTION iMatchPos  // remove existing selections
88058>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETSELECTIONSTART iPos
88059>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_SETSELECTIONEND   (iMatchPos+1)
88060>>>>>>>>>>>>>>>>>        End
88060>>>>>>>>>>>>>>>>>>
88060>>>>>>>>>>>>>>>>>      End
88060>>>>>>>>>>>>>>>>>>
88060>>>>>>>>>>>>>>>>>    End
88060>>>>>>>>>>>>>>>>>>
88060>>>>>>>>>>>>>>>>>  End_Procedure
88061>>>>>>>>>>>>>>>>>  
88061>>>>>>>>>>>>>>>>>  Procedure DoDoubleClick Integer iPos
88063>>>>>>>>>>>>>>>>>    Send MatchingBracesSelectText iPos
88064>>>>>>>>>>>>>>>>>    Send OnDoubleClick
88065>>>>>>>>>>>>>>>>>  End_Procedure
88066>>>>>>>>>>>>>>>>>
88066>>>>>>>>>>>>>>>>>  Procedure OnModified
88068>>>>>>>>>>>>>>>>>  End_Procedure
88069>>>>>>>>>>>>>>>>>  
88069>>>>>>>>>>>>>>>>>  Procedure onUpdateCursorPosition
88071>>>>>>>>>>>>>>>>>  End_Procedure
88072>>>>>>>>>>>>>>>>>  
88072>>>>>>>>>>>>>>>>>  Procedure onStatusMarginClicked Integer iLine
88074>>>>>>>>>>>>>>>>>  End_Procedure
88075>>>>>>>>>>>>>>>>>
88075>>>>>>>>>>>>>>>>>  Procedure OnMarginClick Integer iMargin Integer iLine
88077>>>>>>>>>>>>>>>>>    Boolean bFoldPoint
88077>>>>>>>>>>>>>>>>>
88077>>>>>>>>>>>>>>>>>    Case Begin
88077>>>>>>>>>>>>>>>>>      Case (iMargin=MARGIN_CODE_FOLDING)
88079>>>>>>>>>>>>>>>>>        Get LineHasFoldPoint iLine To bFoldPoint
88080>>>>>>>>>>>>>>>>>        If (bFoldPoint) Begin
88082>>>>>>>>>>>>>>>>>          Send EditorMessage SCI_TOGGLEFOLD iLine
88083>>>>>>>>>>>>>>>>>        End
88083>>>>>>>>>>>>>>>>>>
88083>>>>>>>>>>>>>>>>>        Case Break
88084>>>>>>>>>>>>>>>>>      Case (iMargin=MARGIN_STATUS)
88087>>>>>>>>>>>>>>>>>        Send onStatusMarginClicked iLine
88088>>>>>>>>>>>>>>>>>        Case Break
88089>>>>>>>>>>>>>>>>>    Case End
88089>>>>>>>>>>>>>>>>>  End_Procedure
88090>>>>>>>>>>>>>>>>>
88090>>>>>>>>>>>>>>>>>  Procedure OnMarginRightClick
88092>>>>>>>>>>>>>>>>>  End_Procedure
88093>>>>>>>>>>>>>>>>>
88093>>>>>>>>>>>>>>>>>  //
88093>>>>>>>>>>>>>>>>>  // Brace matching wasn't done on typing only when navigating, so we now call it from onCharAdd
88093>>>>>>>>>>>>>>>>>  //
88093>>>>>>>>>>>>>>>>>  Procedure BraceMatchingCharAdded
88095>>>>>>>>>>>>>>>>>    Boolean bShowMatchingBraces
88095>>>>>>>>>>>>>>>>>    Integer iPos
88095>>>>>>>>>>>>>>>>>    Get pbShowMatchingBraces to bShowMatchingBraces
88096>>>>>>>>>>>>>>>>>    If (bShowMatchingBraces) Begin
88098>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_GETCURRENTPOS to iPos
88099>>>>>>>>>>>>>>>>>      Send ShowMatchingBraces iPos
88100>>>>>>>>>>>>>>>>>    End
88100>>>>>>>>>>>>>>>>>>
88100>>>>>>>>>>>>>>>>>  End_Procedure
88101>>>>>>>>>>>>>>>>>
88101>>>>>>>>>>>>>>>>>  Procedure onQuickInfo Integer iPos String ByRef sTooltip
88103>>>>>>>>>>>>>>>>>  End_Procedure
88104>>>>>>>>>>>>>>>>>  
88104>>>>>>>>>>>>>>>>>  Procedure ShowScopeQuickInfo Integer iPos String ByRef sTooltip
88106>>>>>>>>>>>>>>>>>    Integer iLine
88106>>>>>>>>>>>>>>>>>    Integer iMatchLine
88106>>>>>>>>>>>>>>>>>    Integer iColumn
88106>>>>>>>>>>>>>>>>>    Integer eStyle
88106>>>>>>>>>>>>>>>>>    String  sWord
88106>>>>>>>>>>>>>>>>>    String  sLine
88106>>>>>>>>>>>>>>>>>
88106>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETSTYLEAT       iPos 0 To eStyle
88107>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_LINEFROMPOSITION iPos 0 To iLine
88108>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETCOLUMN        iPos 0 To iColumn
88109>>>>>>>>>>>>>>>>>    Get CM_GetWord iLine iColumn To sWord
88110>>>>>>>>>>>>>>>>>    If (sWord<>"" and eStyle=SCE_DF_SCOPEWORD) Begin
88112>>>>>>>>>>>>>>>>>      Move (lowercase(sWord)) To sWord
88113>>>>>>>>>>>>>>>>>      If (sWord="end_procedure" or sWord="end_function" or sWord="end_object" or sWord="end_class") Begin
88115>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_GETFOLDPARENT iLine 0 To iMatchLine
88116>>>>>>>>>>>>>>>>>        If (iMatchLine) Begin
88118>>>>>>>>>>>>>>>>>          Get CM_GetLine iMatchLine to sLine
88119>>>>>>>>>>>>>>>>>          Move (Ltrim(sLine)) To sTooltip
88120>>>>>>>>>>>>>>>>>        End
88120>>>>>>>>>>>>>>>>>>
88120>>>>>>>>>>>>>>>>>      End
88120>>>>>>>>>>>>>>>>>>
88120>>>>>>>>>>>>>>>>>    End
88120>>>>>>>>>>>>>>>>>>
88120>>>>>>>>>>>>>>>>>  End_Procedure
88121>>>>>>>>>>>>>>>>>  
88121>>>>>>>>>>>>>>>>>  Procedure doQuickInfo Integer iPos
88123>>>>>>>>>>>>>>>>>    String  sTip
88123>>>>>>>>>>>>>>>>>    
88123>>>>>>>>>>>>>>>>>    Get psCodeTipCurrent To sTip
88124>>>>>>>>>>>>>>>>>    Send ShowScopeQuickInfo iPos (&sTip)
88125>>>>>>>>>>>>>>>>>    Send onQuickInfo iPos (&sTip)
88126>>>>>>>>>>>>>>>>>    If (iPos>-1 and sTip<>"") Begin
88128>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
88129>>>>>>>>>>>>>>>>>    End
88129>>>>>>>>>>>>>>>>>>
88129>>>>>>>>>>>>>>>>>  End_Procedure
88130>>>>>>>>>>>>>>>>>
88130>>>>>>>>>>>>>>>>>  Procedure Notify Longptr wParam Longptr lParam
88132>>>>>>>>>>>>>>>>>    Integer iRet
88132>>>>>>>>>>>>>>>>>    Integer iCode
88132>>>>>>>>>>>>>>>>>    Integer iLine
88132>>>>>>>>>>>>>>>>>    Integer iPos
88132>>>>>>>>>>>>>>>>>    tSCNotification SCNotify
88132>>>>>>>>>>>>>>>>>    tSCNotification SCNotify
88132>>>>>>>>>>>>>>>>>
88132>>>>>>>>>>>>>>>>>    Move 0 To SCNotify.line // variable exists and is initialized
88133>>>>>>>>>>>>>>>>>    Move (CopyMemory(AddressOf(SCNotify),lParam,SizeOfType(tSCNotification))) to iRet
88134>>>>>>>>>>>>>>>>>    Move SCNotify.Nmhdr.uCode  to iCode
88135>>>>>>>>>>>>>>>>>
88135>>>>>>>>>>>>>>>>>    // Trap Events...________________________
88135>>>>>>>>>>>>>>>>>    Move 0 to iRet
88136>>>>>>>>>>>>>>>>>
88136>>>>>>>>>>>>>>>>>    Case Begin
88136>>>>>>>>>>>>>>>>>      Case (iCode=SCN_STYLENEEDED)
88138>>>>>>>>>>>>>>>>>        Send OnStyleNeeded
88139>>>>>>>>>>>>>>>>>        Case Break
88140>>>>>>>>>>>>>>>>>      Case (iCode=SCN_CHARADDED)
88143>>>>>>>>>>>>>>>>>        Send OnCharAdded
88144>>>>>>>>>>>>>>>>>        Get Msg_onChange                    to iRet
88145>>>>>>>>>>>>>>>>>        Get Msg_DoKeyAction SCNotify.ch lParam    to iRet
88146>>>>>>>>>>>>>>>>>        If (pbBlockSelectActive(Self)) Begin
88148>>>>>>>>>>>>>>>>>          Send BlockSelectEdit SCNotify.ch lParam
88149>>>>>>>>>>>>>>>>>        End
88149>>>>>>>>>>>>>>>>>>
88149>>>>>>>>>>>>>>>>>        Send BraceMatchingCharAdded
88150>>>>>>>>>>>>>>>>>        Case Break
88151>>>>>>>>>>>>>>>>>      Case (iCode=SCN_SAVEPOINTREACHED   )
88154>>>>>>>>>>>>>>>>>        Send OnSavePointReached
88155>>>>>>>>>>>>>>>>>        Get Msg_DoModifiedChange            to iRet
88156>>>>>>>>>>>>>>>>>        Case Break
88157>>>>>>>>>>>>>>>>>      Case (iCode=SCN_SAVEPOINTLEFT      )
88160>>>>>>>>>>>>>>>>>        Send OnSavePointLeft
88161>>>>>>>>>>>>>>>>>        Get Msg_DoModifiedChange            to iRet
88162>>>>>>>>>>>>>>>>>        Case Break
88163>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MODIFYATTEMPTRO    )
88166>>>>>>>>>>>>>>>>>        //Send Info_Box "Document cannot be changed, it is readonly"
88166>>>>>>>>>>>>>>>>>        Case Break
88167>>>>>>>>>>>>>>>>>      Case (iCode=SCN_KEY                )  //  Used on GTK+ because of some problems with keyboard focus and is not sent by the Windows version.
88170>>>>>>>>>>>>>>>>>        //Get Msg_DoKeyAction iCode lParam    to iRet
88170>>>>>>>>>>>>>>>>>        Send none
88171>>>>>>>>>>>>>>>>>        Case Break
88172>>>>>>>>>>>>>>>>>      Case (iCode=SCN_DOUBLECLICK        )
88175>>>>>>>>>>>>>>>>>        Send DoDoubleClick SCNotify.position
88176>>>>>>>>>>>>>>>>>        Case Break
88177>>>>>>>>>>>>>>>>>      Case (iCode=SCN_UPDATEUI           )
88180>>>>>>>>>>>>>>>>>        If (SCNotify.updated iAnd (SC_UPDATE_SELECTION+SC_UPDATE_V_SCROLL)) Begin
88182>>>>>>>>>>>>>>>>>          Get EditorMessage SCI_GETCURRENTPOS to iPos
88183>>>>>>>>>>>>>>>>>          Send onNavigate iPos
88184>>>>>>>>>>>>>>>>>        End
88184>>>>>>>>>>>>>>>>>>
88184>>>>>>>>>>>>>>>>>        If (SCNotify.updated iAnd SC_UPDATE_SELECTION) Begin
88186>>>>>>>>>>>>>>>>>          Send UpdateUIBlockSelectEdit
88187>>>>>>>>>>>>>>>>>        End
88187>>>>>>>>>>>>>>>>>>
88187>>>>>>>>>>>>>>>>>        Case Break
88188>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MODIFIED           )
88191>>>>>>>>>>>>>>>>>        Send OnModified
88192>>>>>>>>>>>>>>>>>        If (SCNotify.modificationType iAnd (SC_MOD_INSERTTEXT+SC_MOD_DELETETEXT)) Begin
88194>>>>>>>>>>>>>>>>>          Send LineCountChanged
88195>>>>>>>>>>>>>>>>>          If ((SCNotify.modificationType iAnd SC_STARTACTION)=0) Begin
88197>>>>>>>>>>>>>>>>>            If (SCNotify.modificationType iAnd (SC_PERFORMED_REDO+SC_PERFORMED_UNDO+SC_PERFORMED_USER)) Begin
88199>>>>>>>>>>>>>>>>>              Get Msg_onChange                    to iRet
88200>>>>>>>>>>>>>>>>>            End
88200>>>>>>>>>>>>>>>>>>
88200>>>>>>>>>>>>>>>>>          End
88200>>>>>>>>>>>>>>>>>>
88200>>>>>>>>>>>>>>>>>
88200>>>>>>>>>>>>>>>>>        End
88200>>>>>>>>>>>>>>>>>>
88200>>>>>>>>>>>>>>>>>        If (SCNotify.modificationType = SC_MOD_INSERTCHECK) Begin
88202>>>>>>>>>>>>>>>>>          Send doCharacterTranslation SCNotify.Text SCNotify.length
88203>>>>>>>>>>>>>>>>>        End
88203>>>>>>>>>>>>>>>>>>
88203>>>>>>>>>>>>>>>>>        Case Break
88204>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MACRORECORD        )
88207>>>>>>>>>>>>>>>>>        Case Break
88208>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MARGINCLICK        )
88211>>>>>>>>>>>>>>>>>        Get EditorMessage SCI_LINEFROMPOSITION SCNotify.position to iLine
88212>>>>>>>>>>>>>>>>>        Send OnMarginClick SCNotify.margin iLine
88213>>>>>>>>>>>>>>>>>        Case Break
88214>>>>>>>>>>>>>>>>>      Case (iCode=SCN_NEEDSHOWN          )
88217>>>>>>>>>>>>>>>>>        Case Break
88218>>>>>>>>>>>>>>>>>      Case (iCode=SCN_PAINTED            )
88221>>>>>>>>>>>>>>>>>        Case Break
88222>>>>>>>>>>>>>>>>>      Case (iCode=SCN_USERLISTSELECTION  )
88225>>>>>>>>>>>>>>>>>        Case Break
88226>>>>>>>>>>>>>>>>>      Case (iCode=SCN_URIDROPPED         )
88229>>>>>>>>>>>>>>>>>        Case Break
88230>>>>>>>>>>>>>>>>>      Case (iCode=SCN_DWELLSTART         )
88233>>>>>>>>>>>>>>>>>        Send doQuickInfo SCNotify.position
88234>>>>>>>>>>>>>>>>>        Case Break
88235>>>>>>>>>>>>>>>>>      Case (iCode=SCN_DWELLEND           )
88238>>>>>>>>>>>>>>>>>        Send CancelCodetip
88239>>>>>>>>>>>>>>>>>        Case Break
88240>>>>>>>>>>>>>>>>>      Case (iCode=SCN_ZOOM               )
88243>>>>>>>>>>>>>>>>>        Case Break
88244>>>>>>>>>>>>>>>>>      Case (iCode=SCN_HOTSPOTCLICK       )
88247>>>>>>>>>>>>>>>>>        Case Break
88248>>>>>>>>>>>>>>>>>      Case (iCode=SCN_HOTSPOTDOUBLECLICK )
88251>>>>>>>>>>>>>>>>>        Case Break
88252>>>>>>>>>>>>>>>>>      Case (iCode=SCN_CALLTIPCLICK       )
88255>>>>>>>>>>>>>>>>>        Case Break
88256>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCSELECTION     )
88259>>>>>>>>>>>>>>>>>        Get Msg_DoAutoCompleteSelection SCNotify.Text to iRet
88260>>>>>>>>>>>>>>>>>        Case Break
88261>>>>>>>>>>>>>>>>>      Case (iCode=SCN_INDICATORCLICK     )
88264>>>>>>>>>>>>>>>>>        Case Break
88265>>>>>>>>>>>>>>>>>      Case (iCode=SCN_INDICATORRELEASE   )
88268>>>>>>>>>>>>>>>>>        Case Break
88269>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCCANCELLED     )
88272>>>>>>>>>>>>>>>>>        Send DoCodeListCancel
88273>>>>>>>>>>>>>>>>>        Case Break
88274>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCCHARDELETED   )
88277>>>>>>>>>>>>>>>>>        Send none
88278>>>>>>>>>>>>>>>>>        Case Break
88279>>>>>>>>>>>>>>>>>      Case (iCode=SCN_HOTSPOTRELEASECLICK)
88282>>>>>>>>>>>>>>>>>        Case Break
88283>>>>>>>>>>>>>>>>>      Case (iCode=SCN_FOCUSIN            )
88286>>>>>>>>>>>>>>>>>        Send onUpdateCursorPosition
88287>>>>>>>>>>>>>>>>>        Get Msg_onSetFocus                  to iRet
88288>>>>>>>>>>>>>>>>>        Case Break
88289>>>>>>>>>>>>>>>>>      Case (iCode=SCN_FOCUSOUT           )
88292>>>>>>>>>>>>>>>>>        Get Msg_onKillFocus                 to iRet
88293>>>>>>>>>>>>>>>>>        Case Break
88294>>>>>>>>>>>>>>>>>      Case (iCode=SCN_AUTOCCOMPLETED     )
88297>>>>>>>>>>>>>>>>>        // Only called when using built-in selection method, we do it manually
88297>>>>>>>>>>>>>>>>>        Case Break
88298>>>>>>>>>>>>>>>>>      Case (iCode=SCN_MARGINRIGHTCLICK   )
88301>>>>>>>>>>>>>>>>>        Send OnMarginRightClick
88302>>>>>>>>>>>>>>>>>        Case Break
88303>>>>>>>>>>>>>>>>>      Case (iCode=SCEN_CHANGE            )
88306>>>>>>>>>>>>>>>>>        Send none
88307>>>>>>>>>>>>>>>>>        Case Break
88308>>>>>>>>>>>>>>>>>      Case (iCode=SCEN_SETFOCUS          )
88311>>>>>>>>>>>>>>>>>        Case Break
88312>>>>>>>>>>>>>>>>>      Case (iCode=SCEN_KILLFOCUS         )
88315>>>>>>>>>>>>>>>>>        Case Break
88316>>>>>>>>>>>>>>>>>    Case End
88316>>>>>>>>>>>>>>>>>
88316>>>>>>>>>>>>>>>>>    //// SVN CodeTip Support
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_CODETIPINITIALIZE   Get Msg_DoCodeTipInitialize lParam to iRet
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_CODETIPCANCEL       Get Msg_DoCodeTipCancel     to iRet
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_CODETIPUPDATE       Get Msg_DoCodeTipUpdate     to iRet
88316>>>>>>>>>>>>>>>>>    //// SVN
88316>>>>>>>>>>>>>>>>>    //
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_PROPSCHANGE         Get Msg_onPropsChange               to iRet
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_OVERTYPECHANGE      Get Msg_onOvertypeChange            to iRet
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_REGISTEREDCMD       Get Msg_DoRegisteredCmd   lParam    to iRet
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_FINDWRAPPED         Get Msg_DoFindWrapping              to iRet
88316>>>>>>>>>>>>>>>>>    //If iCode Eq CMN_DRAWLINE            Get Msg_DoDrawLine        lParam    to iRet
88316>>>>>>>>>>>>>>>>>    Procedure_Return iRet
88317>>>>>>>>>>>>>>>>>  End_Procedure
88318>>>>>>>>>>>>>>>>>
88318>>>>>>>>>>>>>>>>>  // Delivers line and row (complex) from the given position
88318>>>>>>>>>>>>>>>>>  // -> Position local to the Edit!
88318>>>>>>>>>>>>>>>>>  Function LineRowFromRelativePosition Integer iY Integer iX  Returns Integer
88320>>>>>>>>>>>>>>>>>    Integer iLine iCol iRet
88320>>>>>>>>>>>>>>>>>    Integer iRow
88320>>>>>>>>>>>>>>>>>    Move -1 To iRow
88321>>>>>>>>>>>>>>>>>    If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin
88323>>>>>>>>>>>>>>>>>      Get CM_GetSelFromPoint iX iY        to iRet
88324>>>>>>>>>>>>>>>>>      Move (piSelStartLine(Self))         to iLine
88325>>>>>>>>>>>>>>>>>      Move (piSelStartCol (Self))         to iCol
88326>>>>>>>>>>>>>>>>>      Move (MAKEWPARAM(iCol,iLine)) To iRow
88327>>>>>>>>>>>>>>>>>    End
88327>>>>>>>>>>>>>>>>>>
88327>>>>>>>>>>>>>>>>>    Function_Return iRow
88328>>>>>>>>>>>>>>>>>  End_Function
88329>>>>>>>>>>>>>>>>>
88329>>>>>>>>>>>>>>>>>  // Same as above but uses absolute Screen coordinates.
88329>>>>>>>>>>>>>>>>>  Function LineRowFromAbsolutePosition Integer iY Integer iX  Returns Integer
88331>>>>>>>>>>>>>>>>>    Integer iPY iPX
88331>>>>>>>>>>>>>>>>>    Integer iRow
88331>>>>>>>>>>>>>>>>>    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
88332>>>>>>>>>>>>>>>>>    Move (Low(iPy))                     to iPx
88333>>>>>>>>>>>>>>>>>    Move (Hi(iPy))                      to iPy
88334>>>>>>>>>>>>>>>>>    Move (iY-iPy)                       to iY
88335>>>>>>>>>>>>>>>>>    Move (iX-iPx)                       to iX
88336>>>>>>>>>>>>>>>>>    Get LineRowFromRelativePosition iY iX to iRow
88337>>>>>>>>>>>>>>>>>    Function_Return iRow
88338>>>>>>>>>>>>>>>>>  End_Function
88339>>>>>>>>>>>>>>>>>
88339>>>>>>>>>>>>>>>>>  // Delivers the Line and Col under the Mouse Cursor.
88339>>>>>>>>>>>>>>>>>  Function LineRowUnderMouseCursor Returns Integer
88341>>>>>>>>>>>>>>>>>    Integer iX iY iRet
88341>>>>>>>>>>>>>>>>>    Integer iRow
88341>>>>>>>>>>>>>>>>>    tWinPoint wPoint
88341>>>>>>>>>>>>>>>>>    tWinPoint wPoint
88341>>>>>>>>>>>>>>>>>
88341>>>>>>>>>>>>>>>>>    Move 0 to wPoint.x
88342>>>>>>>>>>>>>>>>>    Move (GetCursorPos(AddressOf(wPoint)))     to iRet
88343>>>>>>>>>>>>>>>>>    Move wPoint.x to iX
88344>>>>>>>>>>>>>>>>>    Move wPoint.y to iY
88345>>>>>>>>>>>>>>>>>    Get LineRowFromAbsolutePosition iY iX to iRow
88346>>>>>>>>>>>>>>>>>    Function_Return iRow
88347>>>>>>>>>>>>>>>>>  End_Function
88348>>>>>>>>>>>>>>>>>
88348>>>>>>>>>>>>>>>>>
88348>>>>>>>>>>>>>>>>>  // To find the Scope for Inserting a Text.
88348>>>>>>>>>>>>>>>>>  Function GetScopeAboveFromLine Integer iLine Returns Integer
88350>>>>>>>>>>>>>>>>>    Integer iEnd
88350>>>>>>>>>>>>>>>>>    Integer iScope
88350>>>>>>>>>>>>>>>>>    String  sLine
88350>>>>>>>>>>>>>>>>>
88350>>>>>>>>>>>>>>>>>    Move 0  To iScope
88351>>>>>>>>>>>>>>>>>    Move "" To sLine
88352>>>>>>>>>>>>>>>>>    Move 0  To iEnd
88353>>>>>>>>>>>>>>>>>    Repeat
88353>>>>>>>>>>>>>>>>>>
88353>>>>>>>>>>>>>>>>>      If (Trim(sLine)) Ne "" ;        Move 1 to iEnd
88356>>>>>>>>>>>>>>>>>      If iLine Lt 0 ;        Move 1 to iEnd
88359>>>>>>>>>>>>>>>>>      If not iEnd ;        Get value item iLine to sLine
88362>>>>>>>>>>>>>>>>>      Decrement iLine
88363>>>>>>>>>>>>>>>>>    Until (iEnd)
88365>>>>>>>>>>>>>>>>>    If (sLine<>"") ;      Move (Pos(Trim(sLine),sLine)-1) To iScope
88368>>>>>>>>>>>>>>>>>    Function_Return iScope
88369>>>>>>>>>>>>>>>>>  End_Function
88370>>>>>>>>>>>>>>>>>  
88370>>>>>>>>>>>>>>>>>  Procedure NormalizeCaseRange Integer iLine Integer iCol Integer iLen
88372>>>>>>>>>>>>>>>>>    Boolean bChanged
88372>>>>>>>>>>>>>>>>>    Integer iStartPos iEndPos
88372>>>>>>>>>>>>>>>>>    Integer iStartLine iStopLine
88372>>>>>>>>>>>>>>>>>    
88372>>>>>>>>>>>>>>>>>    If (pbNormalizeCase(Self)) Begin
88374>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
88375>>>>>>>>>>>>>>>>>      Move (iStartPos+iLen) To iEndPos
88376>>>>>>>>>>>>>>>>>      Send EditorMessage SCI_COLOURISE iStartPos iEndPos  // apply style to the inserted text!
88377>>>>>>>>>>>>>>>>>      Move iLine To iStartLine
88378>>>>>>>>>>>>>>>>>      Get EditorMessage SCI_LINEFROMPOSITION iEndPos 0 to iStopLine
88379>>>>>>>>>>>>>>>>>      For iLine from iStartLine to iStopLine
88385>>>>>>>>>>>>>>>>>>
88385>>>>>>>>>>>>>>>>>        Get LineNormalizeCase iLine False To bChanged
88386>>>>>>>>>>>>>>>>>      Loop
88387>>>>>>>>>>>>>>>>>>
88387>>>>>>>>>>>>>>>>>    End
88387>>>>>>>>>>>>>>>>>>
88387>>>>>>>>>>>>>>>>>  End_Procedure
88388>>>>>>>>>>>>>>>>>
88388>>>>>>>>>>>>>>>>>
88388>>>>>>>>>>>>>>>>>  // Inserts a Text at this Position.
88388>>>>>>>>>>>>>>>>>  // Understands commands like:
88388>>>>>>>>>>>>>>>>>  //  \n  ... New Line
88388>>>>>>>>>>>>>>>>>  //  \t  ... Keep ScopeLevel
88388>>>>>>>>>>>>>>>>>  //  \s  ... New Line and InsertColumn
88388>>>>>>>>>>>>>>>>>  Procedure InsertTextAtPosition Integer iLine Integer iCol String sTxt
88390>>>>>>>>>>>>>>>>>    Integer iRet iScopeCol
88390>>>>>>>>>>>>>>>>>    Integer iNewLineCount iMarker
88390>>>>>>>>>>>>>>>>>    String  sCR
88390>>>>>>>>>>>>>>>>>    Move 0 To iNewLineCount
88391>>>>>>>>>>>>>>>>>    Append sCR (Character(13)) (Character(10))
88393>>>>>>>>>>>>>>>>>    If (Left(sTxt,2)) Eq "\s" Begin
88395>>>>>>>>>>>>>>>>>      Move iCol              to iScopeCol
88396>>>>>>>>>>>>>>>>>    End
88396>>>>>>>>>>>>>>>>>>
88396>>>>>>>>>>>>>>>>>    Else Begin
88397>>>>>>>>>>>>>>>>>      Get GetScopeAboveFromLine iLine             to iScopeCol
88398>>>>>>>>>>>>>>>>>    End
88398>>>>>>>>>>>>>>>>>>
88398>>>>>>>>>>>>>>>>>    While (Pos("\n",sTxt))
88402>>>>>>>>>>>>>>>>>      Increment iNewLineCount
88403>>>>>>>>>>>>>>>>>      Move (Replace("\n",sTxt,sCR))               to sTxt               // TO insert a new Line.
88404>>>>>>>>>>>>>>>>>    Loop
88405>>>>>>>>>>>>>>>>>>
88405>>>>>>>>>>>>>>>>>    Move (Replaces("\t",sTxt,Repeat(" ",iScopeCol))) to sTxt               // To keep the scope level.
88406>>>>>>>>>>>>>>>>>    If (Left(sTxt,2)) Eq "\s" Begin                                        // Insert in new line.
88408>>>>>>>>>>>>>>>>>      Move (Replace("\s",sTxt,Append("",Repeat(" ",iCol))))   to sTxt    // TO insert a new Line.
88409>>>>>>>>>>>>>>>>>      Move 0                                                  to iCol
88410>>>>>>>>>>>>>>>>>    End
88410>>>>>>>>>>>>>>>>>>
88410>>>>>>>>>>>>>>>>>    Move (CM_InsertText(Self,sTxt,iLine,iCol))                  to iRet
88411>>>>>>>>>>>>>>>>>    Send NormalizeCaseRange iLine iCol (Length(sTxt))
88412>>>>>>>>>>>>>>>>>    For iMarker from 0 To (iNewLineCount-1)
88418>>>>>>>>>>>>>>>>>>
88418>>>>>>>>>>>>>>>>>      Set psLineOnEnter to ""
88419>>>>>>>>>>>>>>>>>      Increment iLine
88420>>>>>>>>>>>>>>>>>      Send LineChangedMark iLine
88421>>>>>>>>>>>>>>>>>    Loop
88422>>>>>>>>>>>>>>>>>>
88422>>>>>>>>>>>>>>>>>  End_Procedure
88423>>>>>>>>>>>>>>>>>
88423>>>>>>>>>>>>>>>>>  // Tries to insert a text after the character with the given relative
88423>>>>>>>>>>>>>>>>>  // position (Used for Drag and Drop)
88423>>>>>>>>>>>>>>>>>  Procedure Request_InsertTextAfterPosRel Integer iY Integer iX String sTxt
88425>>>>>>>>>>>>>>>>>    Integer iRet iLine iCol
88425>>>>>>>>>>>>>>>>>
88425>>>>>>>>>>>>>>>>>    If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin // Only if the Coord. are over the editspace.
88427>>>>>>>>>>>>>>>>>      Get CM_GetSelFromPoint iX iY    to iRet
88428>>>>>>>>>>>>>>>>>      If iRet Begin
88430>>>>>>>>>>>>>>>>>        Move (piSelStartLine(Self))         to iLine
88431>>>>>>>>>>>>>>>>>        Move (piSelStartCol (Self))         To iCol
88432>>>>>>>>>>>>>>>>>        Send GotoLine iLine // Move the cursor to the line where you insert the text
88433>>>>>>>>>>>>>>>>>        Send InsertTextAtPosition iLine iCol sTxt
88434>>>>>>>>>>>>>>>>>      End
88434>>>>>>>>>>>>>>>>>>
88434>>>>>>>>>>>>>>>>>    End
88434>>>>>>>>>>>>>>>>>>
88434>>>>>>>>>>>>>>>>>  End_Procedure
88435>>>>>>>>>>>>>>>>>
88435>>>>>>>>>>>>>>>>>
88435>>>>>>>>>>>>>>>>>
88435>>>>>>>>>>>>>>>>>
88435>>>>>>>>>>>>>>>>>  // Tries to insert a text after the character with the given absolut
88435>>>>>>>>>>>>>>>>>  // position (Used for Drag and Drop)
88435>>>>>>>>>>>>>>>>>  Procedure Request_InsertTextAfterPosAbs Integer iY Integer iX String sTxt
88437>>>>>>>>>>>>>>>>>    Integer iPY iPX
88437>>>>>>>>>>>>>>>>>    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
88438>>>>>>>>>>>>>>>>>    Move (Low(iPy))                     to iPx
88439>>>>>>>>>>>>>>>>>    Move (Hi(iPy))                      to iPy
88440>>>>>>>>>>>>>>>>>    Move (iY-iPy)                       to iY
88441>>>>>>>>>>>>>>>>>    Move (iX-iPx)                       to iX
88442>>>>>>>>>>>>>>>>>    Send Request_InsertTextAfterPosRel iY iX sTxt
88443>>>>>>>>>>>>>>>>>  End_Procedure
88444>>>>>>>>>>>>>>>>>  // Inserts text under the mouse cursor position.
88444>>>>>>>>>>>>>>>>>  Procedure Request_InsertTextUnderMouseCursor String sTxt
88446>>>>>>>>>>>>>>>>>    Integer iRet iX iY
88446>>>>>>>>>>>>>>>>>    tWinPoint wPoint
88446>>>>>>>>>>>>>>>>>    tWinPoint wPoint
88446>>>>>>>>>>>>>>>>>
88446>>>>>>>>>>>>>>>>>    Move 0 to wPoint.x
88447>>>>>>>>>>>>>>>>>    Move (GetCursorPos(AddressOf(wPoint)))     to iRet
88448>>>>>>>>>>>>>>>>>    Move wPoint.x to iX
88449>>>>>>>>>>>>>>>>>    Move wPoint.y to iY
88450>>>>>>>>>>>>>>>>>    Send Request_InsertTextAfterPosAbs iY iX sTxt
88451>>>>>>>>>>>>>>>>>  End_Procedure
88452>>>>>>>>>>>>>>>>>
88452>>>>>>>>>>>>>>>>>  Function HitTestCurrentMouse Returns Integer
88454>>>>>>>>>>>>>>>>>    Integer iRet iX iY iPy iPx
88454>>>>>>>>>>>>>>>>>    tWinPoint wPoint
88454>>>>>>>>>>>>>>>>>    tWinPoint wPoint
88454>>>>>>>>>>>>>>>>>    Move 0 to wPoint.x
88455>>>>>>>>>>>>>>>>>    Move (GetCursorPos(AddressOf(wPoint))) to iRet
88456>>>>>>>>>>>>>>>>>    Move wPoint.x to iX
88457>>>>>>>>>>>>>>>>>    Move wPoint.y to iY
88458>>>>>>>>>>>>>>>>>    Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
88459>>>>>>>>>>>>>>>>>    Move (Low(iPy))                     to iPx
88460>>>>>>>>>>>>>>>>>    Move (Hi(iPy))                      to iPy
88461>>>>>>>>>>>>>>>>>    Move (iY-iPy)                       to iY
88462>>>>>>>>>>>>>>>>>    Move (iX-iPx)                       to iX
88463>>>>>>>>>>>>>>>>>    Function_Return (Hi(CM_HitTest(Self,iX,iY)))
88464>>>>>>>>>>>>>>>>>  End_Function
88465>>>>>>>>>>>>>>>>>
88465>>>>>>>>>>>>>>>>>  //
88465>>>>>>>>>>>>>>>>>  // For re-indenting when a line is a comment line or if it is a DataFlex image line it should not do
88465>>>>>>>>>>>>>>>>>  // the extra indent. So we have to figure out what it is...
88465>>>>>>>>>>>>>>>>>  //
88465>>>>>>>>>>>>>>>>>  Function LineIsComment Integer iLine String sLine Returns Boolean
88467>>>>>>>>>>>>>>>>>    Boolean bIsComment
88467>>>>>>>>>>>>>>>>>    Integer iPos
88467>>>>>>>>>>>>>>>>>    Integer iFirstChar
88467>>>>>>>>>>>>>>>>>
88467>>>>>>>>>>>>>>>>>    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
88468>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
88469>>>>>>>>>>>>>>>>>    Move (iPos+iFirstChar) To iPos
88470>>>>>>>>>>>>>>>>>    Get StyleAtPosIsComment iPos To bIsComment
88471>>>>>>>>>>>>>>>>>    Function_Return bIsComment
88472>>>>>>>>>>>>>>>>>  End_Function
88473>>>>>>>>>>>>>>>>>
88473>>>>>>>>>>>>>>>>>  //
88473>>>>>>>>>>>>>>>>>  // For re-indenting a DataFlex image should not be touched, so we cannot treat it the same as a comment
88473>>>>>>>>>>>>>>>>>  //
88473>>>>>>>>>>>>>>>>>  Function LineIsDfImage Integer iLine String sLine Returns Boolean
88475>>>>>>>>>>>>>>>>>    Boolean bIsImage
88475>>>>>>>>>>>>>>>>>    Integer iPos
88475>>>>>>>>>>>>>>>>>    Integer iFirstChar
88475>>>>>>>>>>>>>>>>>
88475>>>>>>>>>>>>>>>>>    Move (Length(sLine)-length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
88476>>>>>>>>>>>>>>>>>    Get EditorMessage SCI_POSITIONFROMLINE iLine To iPos
88477>>>>>>>>>>>>>>>>>    Move (iPos+iFirstChar) To iPos
88478>>>>>>>>>>>>>>>>>    Get StyleAtPosIsDfImage iPos To bIsImage
88479>>>>>>>>>>>>>>>>>    Function_Return bIsImage
88480>>>>>>>>>>>>>>>>>  End_Function
88481>>>>>>>>>>>>>>>>>    
88481>>>>>>>>>>>>>>>>>  Function LineIsGotoLabel Integer iLine String sLine Returns Boolean
88483>>>>>>>>>>>>>>>>>    Boolean iPos
88483>>>>>>>>>>>>>>>>>    Boolean iColonPos
88483>>>>>>>>>>>>>>>>>    Boolean bIsLabel
88483>>>>>>>>>>>>>>>>>      
88483>>>>>>>>>>>>>>>>>    Move False To bIsLabel
88484>>>>>>>>>>>>>>>>>    Get PreParsedLine iLine To sLine
88485>>>>>>>>>>>>>>>>>    If (Right(sLine,1)=":") Begin
88487>>>>>>>>>>>>>>>>>      Move True to bIsLabel
88488>>>>>>>>>>>>>>>>>      Move (Trim(sLine)) to sLine
88489>>>>>>>>>>>>>>>>>      Move (Pos(":",sLine)-1) to iColonPos
88490>>>>>>>>>>>>>>>>>      For iPos from 1 to iColonPos
88496>>>>>>>>>>>>>>>>>>
88496>>>>>>>>>>>>>>>>>        If (Mid(sLine,1,iPos)=" ") Begin
88498>>>>>>>>>>>>>>>>>          Move False To bIsLabel
88499>>>>>>>>>>>>>>>>>          MOve iColonPos To iPos // stop
88500>>>>>>>>>>>>>>>>>        End
88500>>>>>>>>>>>>>>>>>>
88500>>>>>>>>>>>>>>>>>      Loop
88501>>>>>>>>>>>>>>>>>>
88501>>>>>>>>>>>>>>>>>    End
88501>>>>>>>>>>>>>>>>>>
88501>>>>>>>>>>>>>>>>>    Function_Return bIsLabel
88502>>>>>>>>>>>>>>>>>  End_Function
88503>>>>>>>>>>>>>>>>>
88503>>>>>>>>>>>>>>>>>
88503>>>>>>>>>>>>>>>>>  Function ReIndentLineIndentation Integer iLine Integer iLineCount Integer iTabSize Boolean bUseTabs Integer ByRef iPrevLevel Returns String
88505>>>>>>>>>>>>>>>>>    Boolean bIsComment
88505>>>>>>>>>>>>>>>>>    Boolean bIsLabel
88505>>>>>>>>>>>>>>>>>    Integer iFoldLevel
88505>>>>>>>>>>>>>>>>>    Integer iNextLevel
88505>>>>>>>>>>>>>>>>>    Integer iLevel
88505>>>>>>>>>>>>>>>>>    Integer iIndentWanted
88505>>>>>>>>>>>>>>>>>    Integer iFirstChar
88505>>>>>>>>>>>>>>>>>    String  sLine
88505>>>>>>>>>>>>>>>>>    String  sIndent
88505>>>>>>>>>>>>>>>>>
88505>>>>>>>>>>>>>>>>>    If ((iLineCount-1)>iLine) Begin
88507>>>>>>>>>>>>>>>>>      //Send GotoLine (iLine+1) // the line has to be visible in order to be able to get the fold level
88507>>>>>>>>>>>>>>>>>    End
88507>>>>>>>>>>>>>>>>>>
88507>>>>>>>>>>>>>>>>>    Get LineFoldLevel iLine To iFoldLevel
88508>>>>>>>>>>>>>>>>>    If (iLine<(iLineCount-1)) Begin
88510>>>>>>>>>>>>>>>>>      Get LineFoldLevel (iLine+1) to iNextLevel
88511>>>>>>>>>>>>>>>>>    End
88511>>>>>>>>>>>>>>>>>>
88511>>>>>>>>>>>>>>>>>    Else Begin
88512>>>>>>>>>>>>>>>>>      Move 0 to iNextLevel
88513>>>>>>>>>>>>>>>>>    End
88513>>>>>>>>>>>>>>>>>>
88513>>>>>>>>>>>>>>>>>    Move iFoldLevel To iLevel
88514>>>>>>>>>>>>>>>>>    If (iNextLevel<iFoldLevel) Begin
88516>>>>>>>>>>>>>>>>>      Move iNextLevel to iLevel
88517>>>>>>>>>>>>>>>>>    End
88517>>>>>>>>>>>>>>>>>>
88517>>>>>>>>>>>>>>>>>    Get Value Item iLine To sLine
88518>>>>>>>>>>>>>>>>>    Get LineIsComment iLine sLine to bIsComment // a multi-line comment is also a code fold point, don't indent on that.
88519>>>>>>>>>>>>>>>>>    If (bIsComment) Begin
88521>>>>>>>>>>>>>>>>>      Move false To bIsComment
88522>>>>>>>>>>>>>>>>>      If (iLine>0) Begin
88524>>>>>>>>>>>>>>>>>        Get Value Item (iLine-1) to sLine
88525>>>>>>>>>>>>>>>>>        Get LineIsComment (iLine-1) sLine to bIsComment
88526>>>>>>>>>>>>>>>>>      End
88526>>>>>>>>>>>>>>>>>>
88526>>>>>>>>>>>>>>>>>      If (bIsComment) ;        Move iPrevLevel to iLevel
88529>>>>>>>>>>>>>>>>>      Get Value Item iLine to sLine  // get the correct line data again.
88530>>>>>>>>>>>>>>>>>      If (Left(sLine,2)="//" and pbReindentStudioCommentOut(Self)) Begin // if a comment starts at column 0, leave it alone
88532>>>>>>>>>>>>>>>>>        Move 0 To iLevel                                                 // (for Df Studio comment-out feature, see feature # 126)
88533>>>>>>>>>>>>>>>>>        Move False To bIsComment
88534>>>>>>>>>>>>>>>>>      End
88534>>>>>>>>>>>>>>>>>>
88534>>>>>>>>>>>>>>>>>    End
88534>>>>>>>>>>>>>>>>>>
88534>>>>>>>>>>>>>>>>>    Move (iLevel*iTabSize) To iIndentWanted
88535>>>>>>>>>>>>>>>>>    Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) To sIndent
88536>>>>>>>>>>>>>>>>>    Move (Length(sLine)-length(LTrim(sLine))+1) To iFirstChar // first non white space character on line is at this pos
88537>>>>>>>>>>>>>>>>>    // For macro's preserve the existing indentation
88537>>>>>>>>>>>>>>>>>    If (Mid(sLine,1,iFirstChar)="#") Begin
88539>>>>>>>>>>>>>>>>>        Move (Left(sLine,iFirstChar-1)) To sIndent
88540>>>>>>>>>>>>>>>>>    End
88540>>>>>>>>>>>>>>>>>>
88540>>>>>>>>>>>>>>>>>    Move (LTrim(sLine))  To sLine
88541>>>>>>>>>>>>>>>>>    // It is my opinion that a use should always be at the start of a line
88541>>>>>>>>>>>>>>>>>    // so I make exceptions for indenting on that and set the indent to ""
88541>>>>>>>>>>>>>>>>>    If (lowercase(Left(sLine,4))="use ") Begin
88543>>>>>>>>>>>>>>>>>        Move "" To sIndent
88544>>>>>>>>>>>>>>>>>    End
88544>>>>>>>>>>>>>>>>>>
88544>>>>>>>>>>>>>>>>>    // On labels and goto's you don't want indentation either
88544>>>>>>>>>>>>>>>>>    Get LineIsGotoLabel iLine sLine To bIsLabel
88545>>>>>>>>>>>>>>>>>    If (bIsLabel) Begin
88547>>>>>>>>>>>>>>>>>      Move "" To sIndent
88548>>>>>>>>>>>>>>>>>    End
88548>>>>>>>>>>>>>>>>>>
88548>>>>>>>>>>>>>>>>>    Move iLevel To iPrevLevel
88549>>>>>>>>>>>>>>>>>    //Showln iLine " -> " iFoldLevel " [-->] " iNextLevel " result {" sIndent "}" sLine
88549>>>>>>>>>>>>>>>>>
88549>>>>>>>>>>>>>>>>>    Function_Return sIndent
88550>>>>>>>>>>>>>>>>>  End_Function
88551>>>>>>>>>>>>>>>>>
88551>>>>>>>>>>>>>>>>>  // Standard Interface Support
88551>>>>>>>>>>>>>>>>>  // By SVN on 23/03/2017
88551>>>>>>>>>>>>>>>>>  Function CanCut Returns Integer
88553>>>>>>>>>>>>>>>>>    Function_Return (CM_CanCut(Self))
88554>>>>>>>>>>>>>>>>>  End_Function
88555>>>>>>>>>>>>>>>>>  Function CanCopy Returns Integer
88557>>>>>>>>>>>>>>>>>    Function_Return (CM_CanCopy(Self))
88558>>>>>>>>>>>>>>>>>  End_Function
88559>>>>>>>>>>>>>>>>>  Function CanPaste Returns Integer
88561>>>>>>>>>>>>>>>>>    Function_Return (CM_CanPaste(Self))
88562>>>>>>>>>>>>>>>>>  End_Function
88563>>>>>>>>>>>>>>>>>  Function CanUndo Returns Integer
88565>>>>>>>>>>>>>>>>>    Function_Return (CM_CanUndo(Self))
88566>>>>>>>>>>>>>>>>>  End_Function
88567>>>>>>>>>>>>>>>>>  Function CanRedo Returns Integer
88569>>>>>>>>>>>>>>>>>    Function_Return (CM_CanRedo(Self))
88570>>>>>>>>>>>>>>>>>  End_Function
88571>>>>>>>>>>>>>>>>>  Function CanDelete Returns Integer
88573>>>>>>>>>>>>>>>>>    Function_Return (CM_CanCut(Self))
88574>>>>>>>>>>>>>>>>>  End_Function
88575>>>>>>>>>>>>>>>>>  Procedure Redo
88577>>>>>>>>>>>>>>>>>    Integer iRet
88577>>>>>>>>>>>>>>>>>    Get CM_Redo to iRet
88578>>>>>>>>>>>>>>>>>  End_Procedure
88579>>>>>>>>>>>>>>>>>  Procedure Undo
88581>>>>>>>>>>>>>>>>>    Integer iRet
88581>>>>>>>>>>>>>>>>>    Get CM_Undo to iRet
88582>>>>>>>>>>>>>>>>>  End_Procedure
88583>>>>>>>>>>>>>>>>>  Procedure Cut
88585>>>>>>>>>>>>>>>>>    Integer iRet
88585>>>>>>>>>>>>>>>>>    Get CM_Cut to iRet
88586>>>>>>>>>>>>>>>>>  End_Procedure
88587>>>>>>>>>>>>>>>>>  Procedure Delete
88589>>>>>>>>>>>>>>>>>    Integer iRet
88589>>>>>>>>>>>>>>>>>    Get CM_Cut to iRet
88590>>>>>>>>>>>>>>>>>  End_Procedure
88591>>>>>>>>>>>>>>>>>  Procedure Copy
88593>>>>>>>>>>>>>>>>>    Integer iRet
88593>>>>>>>>>>>>>>>>>    Get CM_Copy to iRet
88594>>>>>>>>>>>>>>>>>  End_Procedure
88595>>>>>>>>>>>>>>>>>  Procedure Paste
88597>>>>>>>>>>>>>>>>>    Integer iRet
88597>>>>>>>>>>>>>>>>>    Get CM_Paste to iRet
88598>>>>>>>>>>>>>>>>>  End_Procedure
88599>>>>>>>>>>>>>>>>>  //
88599>>>>>>>>>>>>>>>>>
88599>>>>>>>>>>>>>>>>>  // Should Start the Properties.
88599>>>>>>>>>>>>>>>>>  Procedure Properties
88601>>>>>>>>>>>>>>>>>    //        Integer iRet
88601>>>>>>>>>>>>>>>>>    //Move (CM_ExecuteCmd(Self,CMD_PROPERTIES,0)) to iRet
88601>>>>>>>>>>>>>>>>>    //Send Info_Box "Start configuration screen for editor component"
88601>>>>>>>>>>>>>>>>>    //Send PopupEditorSettingsDialog Self
88601>>>>>>>>>>>>>>>>>  End_Procedure
88602>>>>>>>>>>>>>>>>>
88602>>>>>>>>>>>>>>>>>End_Class
88603>>>>>>>>>>>>>>>>>
88603>>>>>>>>>>>>>>>>>Define CM_NewFileName   For "Untitled"  // sometimes ver useful.
88603>>>>>>>>>>>>>>>Use Messagebox2.dg
Including file: MessageBox2.dg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MessageBox2.dg)
88603>>>>>>>>>>>>>>>>>Use Windows.pkg
88603>>>>>>>>>>>>>>>>>Use msgbox.pkg
88603>>>>>>>>>>>>>>>>>Use DTFUNC.PKG
Including file: DTFUNC.PKG    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\DTFUNC.PKG)
88603>>>>>>>>>>>>>>>>>>>// external function call used in Procedure DoStartDocument
88603>>>>>>>>>>>>>>>>>>>External_Function ShellExecute "ShellExecuteA" shell32.dll ;    Handle hWnd ;    String lpOperation ;    String lpFile ;    String lpParameters ;    String lpDirectory ;    Dword iShowCmd Returns Handle
88604>>>>>>>>>>>>>>>>>>>
88604>>>>>>>>>>>>>>>>>>>// this will perform an operation on a file (e.g. open) with the application
88604>>>>>>>>>>>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
88604>>>>>>>>>>>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
88604>>>>>>>>>>>>>>>>>>>
88604>>>>>>>>>>>>>>>>>>>Procedure DoStartDocument Global String sOperation String sDocument
88606>>>>>>>>>>>>>>>>>>>    Handle hInstance hWnd
88606>>>>>>>>>>>>>>>>>>>    Get Window_Handle To hWnd
88607>>>>>>>>>>>>>>>>>>>    Move (ShellExecute (hWnd, sOperation, (Trim (sDocument)), '', '', 1)) To hInstance
88608>>>>>>>>>>>>>>>>>>>End_Procedure
88609>>>>>>>>>>>>>>>>>>>
88609>>>>>>>>>>>>>>>>>>>Function ParseString String sString String sSeparator Returns Integer
88612>>>>>>>>>>>>>>>>>>>    Integer iCnt p hoRetVal
88612>>>>>>>>>>>>>>>>>>>    String sTemp
88612>>>>>>>>>>>>>>>>>>>
88612>>>>>>>>>>>>>>>>>>>    Object oArray is an Array
88614>>>>>>>>>>>>>>>>>>>        Move Self to hoRetVal
88615>>>>>>>>>>>>>>>>>>>    End_Object
88616>>>>>>>>>>>>>>>>>>>
88616>>>>>>>>>>>>>>>>>>>    Move (Trim(sString)+sSeparator) to sString
88617>>>>>>>>>>>>>>>>>>>    While (sString<>'')
88621>>>>>>>>>>>>>>>>>>>        Move (Pos(sSeparator,sString)) to p
88622>>>>>>>>>>>>>>>>>>>        Move (Left(sString,p-1)) to sTemp
88623>>>>>>>>>>>>>>>>>>>        Get item_count of hoRetVal to iCnt
88624>>>>>>>>>>>>>>>>>>>        Set Value of hoRetVal Item iCnt to sTemp
88625>>>>>>>>>>>>>>>>>>>        Move (Mid(sString,Length(sString),p+1)) to sString
88626>>>>>>>>>>>>>>>>>>>    Loop
88627>>>>>>>>>>>>>>>>>>>>
88627>>>>>>>>>>>>>>>>>>>
88627>>>>>>>>>>>>>>>>>>>    Function_Return hoRetVal
88628>>>>>>>>>>>>>>>>>>>End_Function
88629>>>>>>>>>>>>>>>>>>>
88629>>>>>>>>>>>>>>>>>>>Function ParseString2 Global String sStr String sDelim Returns String[]
88631>>>>>>>>>>>>>>>>>>>    String[] sRetVal
88632>>>>>>>>>>>>>>>>>>>    Integer i
88632>>>>>>>>>>>>>>>>>>>
88632>>>>>>>>>>>>>>>>>>>    If (Right(sStr,1)<>sDelim) Begin
88634>>>>>>>>>>>>>>>>>>>        Move (sStr+sDelim) to sStr
88635>>>>>>>>>>>>>>>>>>>    End
88635>>>>>>>>>>>>>>>>>>>>
88635>>>>>>>>>>>>>>>>>>>    Repeat
88635>>>>>>>>>>>>>>>>>>>>
88635>>>>>>>>>>>>>>>>>>>        Move (Left(sStr,Pos(sDelim,sStr)-1)) to sRetVal[i]
88636>>>>>>>>>>>>>>>>>>>        Add 1 to i
88637>>>>>>>>>>>>>>>>>>>        Move (Mid(sStr,Length(sStr),Pos(sDelim,sStr)+1)) to sStr
88638>>>>>>>>>>>>>>>>>>>    Until (sStr='')
88640>>>>>>>>>>>>>>>>>>>    Function_Return sRetVal
88641>>>>>>>>>>>>>>>>>>>End_Function
88642>>>>>>>>>>>>>>>>>>>
88642>>>>>>>>>>>>>>>>>>>Function ParseString3 Global String sStr String sDelim String sGroup Returns String[]
88644>>>>>>>>>>>>>>>>>>>    String[] sRetVal
88645>>>>>>>>>>>>>>>>>>>    Integer i p
88645>>>>>>>>>>>>>>>>>>>
88645>>>>>>>>>>>>>>>>>>>    If (Right(sStr,1)<>sDelim) Begin
88647>>>>>>>>>>>>>>>>>>>        Move (sStr+sDelim) to sStr
88648>>>>>>>>>>>>>>>>>>>    End
88648>>>>>>>>>>>>>>>>>>>>
88648>>>>>>>>>>>>>>>>>>>    Repeat
88648>>>>>>>>>>>>>>>>>>>>
88648>>>>>>>>>>>>>>>>>>>        If (Left(sStr,1)=sGroup) Begin
88650>>>>>>>>>>>>>>>>>>>            Move (Pos(sGroup,sStr,2)) to p
88651>>>>>>>>>>>>>>>>>>>            If (p=0) Begin
88653>>>>>>>>>>>>>>>>>>>                Move (Length(sStr)) to p
88654>>>>>>>>>>>>>>>>>>>            End
88654>>>>>>>>>>>>>>>>>>>>
88654>>>>>>>>>>>>>>>>>>>            Move (Mid(sStr,p-2,2)) to sRetVal[i]
88655>>>>>>>>>>>>>>>>>>>            Add 1 to i
88656>>>>>>>>>>>>>>>>>>>            Move (Mid(sStr,Length(sStr),p+2)) to sStr
88657>>>>>>>>>>>>>>>>>>>        End
88657>>>>>>>>>>>>>>>>>>>>
88657>>>>>>>>>>>>>>>>>>>        Else Begin
88658>>>>>>>>>>>>>>>>>>>            Move (Left(sStr,Pos(sDelim,sStr)-1)) to sRetVal[i]
88659>>>>>>>>>>>>>>>>>>>            Add 1 to i
88660>>>>>>>>>>>>>>>>>>>            Move (Mid(sStr,Length(sStr),Pos(sDelim,sStr)+1)) to sStr
88661>>>>>>>>>>>>>>>>>>>        End
88661>>>>>>>>>>>>>>>>>>>>
88661>>>>>>>>>>>>>>>>>>>    Until (sStr='')
88663>>>>>>>>>>>>>>>>>>>    Function_Return sRetVal
88664>>>>>>>>>>>>>>>>>>>End_Function
88665>>>>>>>>>>>>>>>>>Use MessageboxLanguage.pkg
Including file: MessageboxLanguage.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\MessageboxLanguage.pkg)
88665>>>>>>>>>>>>>>>>>>>Use LanguageText.pkg
88665>>>>>>>>>>>>>>>>>>>
88665>>>>>>>>>>>>>>>>>>>
88665>>>>>>>>>>>>>>>>>>>
88665>>>>>>>>>>>>>>>>>Use Dftimer.pkg
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dftimer.pkg)
88665>>>>>>>>>>>>>>>>>>>Use LanguageText.pkg
88665>>>>>>>>>>>>>>>>>>>Use Windows.pkg
88665>>>>>>>>>>>>>>>>>>>Use WinUser.pkg
88665>>>>>>>>>>>>>>>>>>>
88665>>>>>>>>>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
88666>>>>>>>>>>>>>>>>>>>
88666>>>>>>>>>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
88667>>>>>>>>>>>>>>>>>>>
88667>>>>>>>>>>>>>>>>>>>// This global integer holds the ID of the object
88667>>>>>>>>>>>>>>>>>>>// that manages all timers.
88667>>>>>>>>>>>>>>>>>>>Integer giTimerManager
88667>>>>>>>>>>>>>>>>>>>
88667>>>>>>>>>>>>>>>>>>>// This class is used to store the object IDs
88667>>>>>>>>>>>>>>>>>>>// of the active timer objects. It augments
88667>>>>>>>>>>>>>>>>>>>// the Destroy_Object procedure to notify
88667>>>>>>>>>>>>>>>>>>>// the DFTimerManager to kill all its active
88667>>>>>>>>>>>>>>>>>>>// timers.
88667>>>>>>>>>>>>>>>>>>>// NOTE: This class looks very much like the
88667>>>>>>>>>>>>>>>>>>>// Set class. I didn't want to use Set because
88667>>>>>>>>>>>>>>>>>>>// Remove_Element shifts items which I don't
88667>>>>>>>>>>>>>>>>>>>// want to happen because item numbers are used
88667>>>>>>>>>>>>>>>>>>>// as timerIDs.
88667>>>>>>>>>>>>>>>>>>>
88667>>>>>>>>>>>>>>>>>>>Class TimersArray is an Array
88668>>>>>>>>>>>>>>>>>>>    
88668>>>>>>>>>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
88670>>>>>>>>>>>>>>>>>>>        Integer iMax
88670>>>>>>>>>>>>>>>>>>>        Integer iItem
88670>>>>>>>>>>>>>>>>>>>        Integer iValue
88670>>>>>>>>>>>>>>>>>>>        Get Item_count to iMax
88671>>>>>>>>>>>>>>>>>>>        Decrement iMax
88672>>>>>>>>>>>>>>>>>>>        For iItem from 1 to iMax
88678>>>>>>>>>>>>>>>>>>>>
88678>>>>>>>>>>>>>>>>>>>            Get Integer_Value iItem to iValue
88679>>>>>>>>>>>>>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
88682>>>>>>>>>>>>>>>>>>>        Loop
88683>>>>>>>>>>>>>>>>>>>>
88683>>>>>>>>>>>>>>>>>>>        Function_Return -1
88684>>>>>>>>>>>>>>>>>>>    End_Function
88685>>>>>>>>>>>>>>>>>>>    
88685>>>>>>>>>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
88687>>>>>>>>>>>>>>>>>>>        Integer iItem
88687>>>>>>>>>>>>>>>>>>>        Get Find_Object iObj to iItem
88688>>>>>>>>>>>>>>>>>>>        If (iItem < 0) Begin
88690>>>>>>>>>>>>>>>>>>>            Get Find_Object 0 to iItem
88691>>>>>>>>>>>>>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
88694>>>>>>>>>>>>>>>>>>>        End
88694>>>>>>>>>>>>>>>>>>>>
88694>>>>>>>>>>>>>>>>>>>        Set Array_Value iItem to iObj
88695>>>>>>>>>>>>>>>>>>>        Procedure_Return iItem
88696>>>>>>>>>>>>>>>>>>>    End_Procedure
88697>>>>>>>>>>>>>>>>>>>    
88697>>>>>>>>>>>>>>>>>>>    Procedure Remove_Object Integer iObj
88699>>>>>>>>>>>>>>>>>>>        Integer iItem
88699>>>>>>>>>>>>>>>>>>>        Get Find_Object iObj to iItem
88700>>>>>>>>>>>>>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
88703>>>>>>>>>>>>>>>>>>>    End_Procedure
88704>>>>>>>>>>>>>>>>>>>    
88704>>>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
88706>>>>>>>>>>>>>>>>>>>        Delegate Send Kill_All_Timers
88708>>>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
88710>>>>>>>>>>>>>>>>>>>    End_Procedure
88711>>>>>>>>>>>>>>>>>>>    
88711>>>>>>>>>>>>>>>>>>>End_Class
88712>>>>>>>>>>>>>>>>>>>
88712>>>>>>>>>>>>>>>>>>>// This class is the actual timer manager
88712>>>>>>>>>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
88712>>>>>>>>>>>>>>>>>>>// has been send. This message needs two arguments. The first
88712>>>>>>>>>>>>>>>>>>>// is the objectID of the object to receive the timer event,
88712>>>>>>>>>>>>>>>>>>>// and the second is state. The object which ID has been passed,
88712>>>>>>>>>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
88712>>>>>>>>>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
88712>>>>>>>>>>>>>>>>>>>// timer event occurs.
88712>>>>>>>>>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
88712>>>>>>>>>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
88712>>>>>>>>>>>>>>>>>>>// is the itemnumber of the object in the array.
88712>>>>>>>>>>>>>>>>>>>//
88712>>>>>>>>>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
88713>>>>>>>>>>>>>>>>>>>    
88713>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88715>>>>>>>>>>>>>>>>>>>        
88715>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88717>>>>>>>>>>>>>>>>>>>        
88717>>>>>>>>>>>>>>>>>>>        Set Visible_State to False
88718>>>>>>>>>>>>>>>>>>>        
88718>>>>>>>>>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
88719>>>>>>>>>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
88720>>>>>>>>>>>>>>>>>>>        
88720>>>>>>>>>>>>>>>>>>>        Object TimersArray is a TimersArray
88722>>>>>>>>>>>>>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
88723>>>>>>>>>>>>>>>>>>>        End_Object
88724>>>>>>>>>>>>>>>>>>>        
88724>>>>>>>>>>>>>>>>>>>        Move Self to giTimerManager
88725>>>>>>>>>>>>>>>>>>>        
88725>>>>>>>>>>>>>>>>>>>    End_Procedure
88726>>>>>>>>>>>>>>>>>>>    
88726>>>>>>>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
88728>>>>>>>>>>>>>>>>>>>        Integer iTimerID
88728>>>>>>>>>>>>>>>>>>>        Integer iTimeout
88728>>>>>>>>>>>>>>>>>>>        Integer iResult
88728>>>>>>>>>>>>>>>>>>>        Integer iSet
88728>>>>>>>>>>>>>>>>>>>        DWord   nResult
88728>>>>>>>>>>>>>>>>>>>        Handle  hWnd
88728>>>>>>>>>>>>>>>>>>>        
88728>>>>>>>>>>>>>>>>>>>        // Get the handle of this object
88728>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
88729>>>>>>>>>>>>>>>>>>>        If (not(hWnd)) Begin
88731>>>>>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
88732>>>>>>>>>>>>>>>>>>>>
88732>>>>>>>>>>>>>>>>>>>            Procedure_Return
88733>>>>>>>>>>>>>>>>>>>        End
88733>>>>>>>>>>>>>>>>>>>>
88733>>>>>>>>>>>>>>>>>>>        
88733>>>>>>>>>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
88733>>>>>>>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
88736>>>>>>>>>>>>>>>>>>>        
88736>>>>>>>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
88737>>>>>>>>>>>>>>>>>>>        
88737>>>>>>>>>>>>>>>>>>>        If (iSet) Begin
88739>>>>>>>>>>>>>>>>>>>            
88739>>>>>>>>>>>>>>>>>>>            // Let's create or modify a timer
88739>>>>>>>>>>>>>>>>>>>            If iState Begin
88741>>>>>>>>>>>>>>>>>>>                
88741>>>>>>>>>>>>>>>>>>>                // Get the exising to new TimerID
88741>>>>>>>>>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
88742>>>>>>>>>>>>>>>>>>>                
88742>>>>>>>>>>>>>>>>>>>                // Set/Modify the timer
88742>>>>>>>>>>>>>>>>>>>                Get Timeout of iObj to iTimeout
88743>>>>>>>>>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
88744>>>>>>>>>>>>>>>>>>>                If not iResult Begin
88746>>>>>>>>>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
88747>>>>>>>>>>>>>>>>>>>>
88747>>>>>>>>>>>>>>>>>>>                    Procedure_Return
88748>>>>>>>>>>>>>>>>>>>                End
88748>>>>>>>>>>>>>>>>>>>>
88748>>>>>>>>>>>>>>>>>>>                
88748>>>>>>>>>>>>>>>>>>>            End
88748>>>>>>>>>>>>>>>>>>>>
88748>>>>>>>>>>>>>>>>>>>            
88748>>>>>>>>>>>>>>>>>>>            // Let's kill an existing timer
88748>>>>>>>>>>>>>>>>>>>            Else Begin
88749>>>>>>>>>>>>>>>>>>>                
88749>>>>>>>>>>>>>>>>>>>                // Look up the object in the set
88749>>>>>>>>>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
88750>>>>>>>>>>>>>>>>>>>                
88750>>>>>>>>>>>>>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
88753>>>>>>>>>>>>>>>>>>>                
88753>>>>>>>>>>>>>>>>>>>                // Kill the timer
88753>>>>>>>>>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
88754>>>>>>>>>>>>>>>>>>>                If not iResult Begin
88756>>>>>>>>>>>>>>>>>>>                    Move (GetLastError()) to nResult
88757>>>>>>>>>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
88758>>>>>>>>>>>>>>>>>>>>
88758>>>>>>>>>>>>>>>>>>>                    Procedure_Return
88759>>>>>>>>>>>>>>>>>>>                End
88759>>>>>>>>>>>>>>>>>>>>
88759>>>>>>>>>>>>>>>>>>>                
88759>>>>>>>>>>>>>>>>>>>                // Remove the objectID
88759>>>>>>>>>>>>>>>>>>>                Send Remove_Object to iSet iObj
88760>>>>>>>>>>>>>>>>>>>            End
88760>>>>>>>>>>>>>>>>>>>>
88760>>>>>>>>>>>>>>>>>>>        End
88760>>>>>>>>>>>>>>>>>>>>
88760>>>>>>>>>>>>>>>>>>>    End_Procedure
88761>>>>>>>>>>>>>>>>>>>    
88761>>>>>>>>>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
88763>>>>>>>>>>>>>>>>>>>        Integer iResult
88763>>>>>>>>>>>>>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
88764>>>>>>>>>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
88765>>>>>>>>>>>>>>>>>>>    End_Function
88766>>>>>>>>>>>>>>>>>>>    
88766>>>>>>>>>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
88766>>>>>>>>>>>>>>>>>>>    Procedure Kill_All_Timers
88768>>>>>>>>>>>>>>>>>>>        Integer iMax
88768>>>>>>>>>>>>>>>>>>>        Integer iSet
88768>>>>>>>>>>>>>>>>>>>        Integer iItem
88768>>>>>>>>>>>>>>>>>>>        Integer iObj
88768>>>>>>>>>>>>>>>>>>>        Integer iResult
88768>>>>>>>>>>>>>>>>>>>        Handle  hWnd
88768>>>>>>>>>>>>>>>>>>>        
88768>>>>>>>>>>>>>>>>>>>        // Get the handle of this object
88768>>>>>>>>>>>>>>>>>>>        Get Window_Handle to hWnd
88769>>>>>>>>>>>>>>>>>>>        If (not(hWnd)) Begin
88771>>>>>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
88772>>>>>>>>>>>>>>>>>>>>
88772>>>>>>>>>>>>>>>>>>>            Procedure_Return
88773>>>>>>>>>>>>>>>>>>>        End
88773>>>>>>>>>>>>>>>>>>>>
88773>>>>>>>>>>>>>>>>>>>        
88773>>>>>>>>>>>>>>>>>>>        // If the window handle is no longer valid, we
88773>>>>>>>>>>>>>>>>>>>        // leave this procedure. This can happen when the
88773>>>>>>>>>>>>>>>>>>>        // program is begin aborted using Exit_Application
88773>>>>>>>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
88776>>>>>>>>>>>>>>>>>>>        
88776>>>>>>>>>>>>>>>>>>>        // Scan the set and kill all known timers
88776>>>>>>>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
88777>>>>>>>>>>>>>>>>>>>        If (iSet) Begin
88779>>>>>>>>>>>>>>>>>>>            Get Item_Count of iSet to iMax
88780>>>>>>>>>>>>>>>>>>>            Decrement iMax
88781>>>>>>>>>>>>>>>>>>>            For iItem from 1 to iMax
88787>>>>>>>>>>>>>>>>>>>>
88787>>>>>>>>>>>>>>>>>>>                Get Integer_Value of iSet iItem to iObj
88788>>>>>>>>>>>>>>>>>>>                If iObj Begin
88790>>>>>>>>>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
88791>>>>>>>>>>>>>>>>>>>                    Set Array_Value of iSet iItem to 0
88792>>>>>>>>>>>>>>>>>>>                End
88792>>>>>>>>>>>>>>>>>>>>
88792>>>>>>>>>>>>>>>>>>>            Loop
88793>>>>>>>>>>>>>>>>>>>>
88793>>>>>>>>>>>>>>>>>>>        End
88793>>>>>>>>>>>>>>>>>>>>
88793>>>>>>>>>>>>>>>>>>>        
88793>>>>>>>>>>>>>>>>>>>    End_Procedure
88794>>>>>>>>>>>>>>>>>>>    
88794>>>>>>>>>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
88796>>>>>>>>>>>>>>>>>>>        Integer iObj
88796>>>>>>>>>>>>>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
88797>>>>>>>>>>>>>>>>>>>        If not iObj Begin
88799>>>>>>>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
88800>>>>>>>>>>>>>>>>>>>>
88800>>>>>>>>>>>>>>>>>>>            Procedure_Return
88801>>>>>>>>>>>>>>>>>>>        End
88801>>>>>>>>>>>>>>>>>>>>
88801>>>>>>>>>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
88802>>>>>>>>>>>>>>>>>>>    End_Procedure
88803>>>>>>>>>>>>>>>>>>>    
88803>>>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
88805>>>>>>>>>>>>>>>>>>>        Send Kill_All_Timers
88806>>>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
88808>>>>>>>>>>>>>>>>>>>        Move 0 to giTimerManager
88809>>>>>>>>>>>>>>>>>>>    End_Procedure
88810>>>>>>>>>>>>>>>>>>>    
88810>>>>>>>>>>>>>>>>>>>End_Class
88811>>>>>>>>>>>>>>>>>>>
88811>>>>>>>>>>>>>>>>>>>
88811>>>>>>>>>>>>>>>>>>>
88811>>>>>>>>>>>>>>>>>>>
88811>>>>>>>>>>>>>>>>>>>// This class acts as a container for the
88811>>>>>>>>>>>>>>>>>>>// timer manager object. This is needed because
88811>>>>>>>>>>>>>>>>>>>// A DFTimerManager object created directly at the
88811>>>>>>>>>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
88811>>>>>>>>>>>>>>>>>>>// need to create a Windoows timer. By placing
88811>>>>>>>>>>>>>>>>>>>// this non-visual container around the timer
88811>>>>>>>>>>>>>>>>>>>// manager, it does get a Window_Handle.
88811>>>>>>>>>>>>>>>>>>>// The procedure End_Construct_Object has been
88811>>>>>>>>>>>>>>>>>>>// augmented to create a window and also
88811>>>>>>>>>>>>>>>>>>>// automatically page all children, which will
88811>>>>>>>>>>>>>>>>>>>// be the timer manager.
88811>>>>>>>>>>>>>>>>>>>//
88811>>>>>>>>>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
88812>>>>>>>>>>>>>>>>>>>    
88812>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88814>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88816>>>>>>>>>>>>>>>>>>>        Set Visible_State to False
88817>>>>>>>>>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
88819>>>>>>>>>>>>>>>>>>>        End_Object
88820>>>>>>>>>>>>>>>>>>>    End_Procedure
88821>>>>>>>>>>>>>>>>>>>    
88821>>>>>>>>>>>>>>>>>>>    Procedure End_Construct_Object
88823>>>>>>>>>>>>>>>>>>>        Forward Send End_Construct_Object
88825>>>>>>>>>>>>>>>>>>>        Send Page_Object True
88826>>>>>>>>>>>>>>>>>>>        Broadcast Send Page_Object True
88828>>>>>>>>>>>>>>>>>>>    End_Procedure
88829>>>>>>>>>>>>>>>>>>>    
88829>>>>>>>>>>>>>>>>>>>End_Class
88830>>>>>>>>>>>>>>>>>>>
88830>>>>>>>>>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
88830>>>>>>>>>>>>>>>>>>>
88830>>>>>>>>>>>>>>>>>>>
88830>>>>>>>>>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
88830>>>>>>>>>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
88830>>>>>>>>>>>>>>>>>>>Class DFTimer is a Textbox
88831>>>>>>>>>>>>>>>>>>>    
88831>>>>>>>>>>>>>>>>>>>    Procedure Construct_Object
88833>>>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
88835>>>>>>>>>>>>>>>>>>>        
88835>>>>>>>>>>>>>>>>>>>        // Make sure this object never appears
88835>>>>>>>>>>>>>>>>>>>        Set Visible_State to False
88836>>>>>>>>>>>>>>>>>>>        
88836>>>>>>>>>>>>>>>>>>>        Property Integer Private.Timeout    1000
88837>>>>>>>>>>>>>>>>>>>        
88837>>>>>>>>>>>>>>>>>>>        Property Integer Timer_Message      0
88838>>>>>>>>>>>>>>>>>>>        Property Integer Timer_Object       0
88839>>>>>>>>>>>>>>>>>>>        Property Integer Auto_Start_State   True
88840>>>>>>>>>>>>>>>>>>>        Property Integer Auto_Stop_State    True
88841>>>>>>>>>>>>>>>>>>>    End_Procedure
88842>>>>>>>>>>>>>>>>>>>    
88842>>>>>>>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
88844>>>>>>>>>>>>>>>>>>>        Integer iObj
88844>>>>>>>>>>>>>>>>>>>        Move Self to iObj
88845>>>>>>>>>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
88848>>>>>>>>>>>>>>>>>>>    End_Procedure
88849>>>>>>>>>>>>>>>>>>>    
88849>>>>>>>>>>>>>>>>>>>    Function Timer_Active_State Returns Integer
88851>>>>>>>>>>>>>>>>>>>        Integer iState
88851>>>>>>>>>>>>>>>>>>>        Integer iObj
88851>>>>>>>>>>>>>>>>>>>        Move Self to iObj
88852>>>>>>>>>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
88855>>>>>>>>>>>>>>>>>>>        Function_Return iState
88856>>>>>>>>>>>>>>>>>>>    End_Function
88857>>>>>>>>>>>>>>>>>>>    
88857>>>>>>>>>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
88859>>>>>>>>>>>>>>>>>>>        Integer iActive
88859>>>>>>>>>>>>>>>>>>>        Set Private.Timeout to iTimeout
88860>>>>>>>>>>>>>>>>>>>        Get Timer_Active_State to iActive
88861>>>>>>>>>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to True
88864>>>>>>>>>>>>>>>>>>>    End_Procedure
88865>>>>>>>>>>>>>>>>>>>    
88865>>>>>>>>>>>>>>>>>>>    Function Timeout Returns Integer
88867>>>>>>>>>>>>>>>>>>>        Integer iTimeout
88867>>>>>>>>>>>>>>>>>>>        Get Private.Timeout to iTimeout
88868>>>>>>>>>>>>>>>>>>>        Function_Return iTimeout
88869>>>>>>>>>>>>>>>>>>>    End_Function
88870>>>>>>>>>>>>>>>>>>>    
88870>>>>>>>>>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
88872>>>>>>>>>>>>>>>>>>>        Integer iMsg
88872>>>>>>>>>>>>>>>>>>>        Integer iObj
88872>>>>>>>>>>>>>>>>>>>        Get Timer_Message to iMsg
88873>>>>>>>>>>>>>>>>>>>        If (iMsg) Begin
88875>>>>>>>>>>>>>>>>>>>            Get Timer_Object  to iObj
88876>>>>>>>>>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
88879>>>>>>>>>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
88881>>>>>>>>>>>>>>>>>>>        End
88881>>>>>>>>>>>>>>>>>>>>
88881>>>>>>>>>>>>>>>>>>>    End_Procedure
88882>>>>>>>>>>>>>>>>>>>    
88882>>>>>>>>>>>>>>>>>>>    // Augmented to Auto_Start a timer
88882>>>>>>>>>>>>>>>>>>>    //
88882>>>>>>>>>>>>>>>>>>>    Procedure Page_Object Integer iState
88884>>>>>>>>>>>>>>>>>>>        Forward Send Page_Object iState
88886>>>>>>>>>>>>>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
88889>>>>>>>>>>>>>>>>>>>    End_Procedure
88890>>>>>>>>>>>>>>>>>>>    
88890>>>>>>>>>>>>>>>>>>>    // Augmented to Auto_Stop a timer
88890>>>>>>>>>>>>>>>>>>>    //
88890>>>>>>>>>>>>>>>>>>>    Procedure Page_Delete
88892>>>>>>>>>>>>>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
88895>>>>>>>>>>>>>>>>>>>        Forward Send Page_Delete
88897>>>>>>>>>>>>>>>>>>>    End_Procedure
88898>>>>>>>>>>>>>>>>>>>    
88898>>>>>>>>>>>>>>>>>>>    // Augmented to stop the timer
88898>>>>>>>>>>>>>>>>>>>    //
88898>>>>>>>>>>>>>>>>>>>    Procedure Destroy_Object
88900>>>>>>>>>>>>>>>>>>>        Set Timer_Active_State to False
88901>>>>>>>>>>>>>>>>>>>        Forward Send Destroy_Object
88903>>>>>>>>>>>>>>>>>>>    End_Procedure
88904>>>>>>>>>>>>>>>>>>>    
88904>>>>>>>>>>>>>>>>>>>End_Class
88905>>>>>>>>>>>>>>>>>>>
88905>>>>>>>>>>>>>>>>>>>//
88905>>>>>>>>>>>>>>>>>>>// This was moved into a method so it can be reliable created
88905>>>>>>>>>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
88905>>>>>>>>>>>>>>>>>>>//
88905>>>>>>>>>>>>>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
88907>>>>>>>>>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
88907>>>>>>>>>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
88909>>>>>>>>>>>>>>>>>>>    End_Object
88910>>>>>>>>>>>>>>>>>>>End_Procedure
88911>>>>>>>>>>>>>>>>>>>
88911>>>>>>>>>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
88912>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>Use monitor.pkg
Including file: monitor.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\monitor.pkg)
88912>>>>>>>>>>>>>>>>>>>Use Set.pkg
88912>>>>>>>>>>>>>>>>>>>//typedef struct tagPOINT {
88912>>>>>>>>>>>>>>>>>>>//  LONG x;
88912>>>>>>>>>>>>>>>>>>>//  LONG y;
88912>>>>>>>>>>>>>>>>>>>//} POINT, *PPOINT;
88912>>>>>>>>>>>>>>>>>>>//
88912>>>>>>>>>>>>>>>>>>>//typedef Struct _RECT {
88912>>>>>>>>>>>>>>>>>>>//  LONG left;
88912>>>>>>>>>>>>>>>>>>>//  LONG top;
88912>>>>>>>>>>>>>>>>>>>//  LONG right;
88912>>>>>>>>>>>>>>>>>>>//  LONG bottom;
88912>>>>>>>>>>>>>>>>>>>//} RECT, *PRECT;
88912>>>>>>>>>>>>>>>>>>>//
88912>>>>>>>>>>>>>>>>>>>//typedef Struct tagMONITORINFO {
88912>>>>>>>>>>>>>>>>>>>//  DWORD  cbSize;
88912>>>>>>>>>>>>>>>>>>>//  RECT   rcMonitor;
88912>>>>>>>>>>>>>>>>>>>//  RECT   rcWork;
88912>>>>>>>>>>>>>>>>>>>//  DWord  dwFlags;
88912>>>>>>>>>>>>>>>>>>>//} MONITORINFO, *LPMONITORINFO;
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>Struct tRECT
88912>>>>>>>>>>>>>>>>>>>  Integer Left
88912>>>>>>>>>>>>>>>>>>>  Integer Top
88912>>>>>>>>>>>>>>>>>>>  Integer Right
88912>>>>>>>>>>>>>>>>>>>  Integer Bottom
88912>>>>>>>>>>>>>>>>>>>End_Struct
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>Struct tMONITORINFO
88912>>>>>>>>>>>>>>>>>>>  DWord cbSize
88912>>>>>>>>>>>>>>>>>>>  tRECT rcMonitor
88912>>>>>>>>>>>>>>>>>>>  tRECT rcMonitor
88912>>>>>>>>>>>>>>>>>>>  tRECT rcWork
88912>>>>>>>>>>>>>>>>>>>  tRECT rcWork
88912>>>>>>>>>>>>>>>>>>>  DWord dwFlags
88912>>>>>>>>>>>>>>>>>>>End_Struct
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>//HMONITOR MonitorFromWindow(
88912>>>>>>>>>>>>>>>>>>>//  HWND hwnd,       // handle to a window
88912>>>>>>>>>>>>>>>>>>>//  DWord dwFlags    // determine return value
88912>>>>>>>>>>>>>>>>>>>//);
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>//BOOL GetMonitorInfo(
88912>>>>>>>>>>>>>>>>>>>//  HMONITOR hMonitor,  // handle to display monitor
88912>>>>>>>>>>>>>>>>>>>//  LPMONITORINFO lpmi  // display monitor information
88912>>>>>>>>>>>>>>>>>>>//);
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>//#define MONITOR_DEFAULTTONULL       0x00000000
88912>>>>>>>>>>>>>>>>>>>//#define MONITOR_DEFAULTTOPRIMARY    0x00000001
88912>>>>>>>>>>>>>>>>>>>//#define MONITOR_DEFAULTTONEAREST    0x00000002
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>Define MONITOR_DEFAULTONNULL For 0
88912>>>>>>>>>>>>>>>>>>>Define MONITOR_DEFAULTONPRIMARY For 1
88912>>>>>>>>>>>>>>>>>>>Define MONITOR_DEFAULTONNEAREST For 2
88912>>>>>>>>>>>>>>>>>>>
88912>>>>>>>>>>>>>>>>>>>// a set that contains a list of monitor handles
88912>>>>>>>>>>>>>>>>>>>Object oMonitorHandles is a Set
88914>>>>>>>>>>>>>>>>>>>End_Object
88915>>>>>>>>>>>>>>>>>>>
88915>>>>>>>>>>>>>>>>>>>// "brute force" monitor enumeration:
88915>>>>>>>>>>>>>>>>>>>//  we can't do a callback function so the Windows API is out
88915>>>>>>>>>>>>>>>>>>>//  this Procedure will determine what monitors (if any) are
88915>>>>>>>>>>>>>>>>>>>//  immediately adjacent to the primary monitor and store the
88915>>>>>>>>>>>>>>>>>>>//  monitor handles in a set for use later
88915>>>>>>>>>>>>>>>>>>>
88915>>>>>>>>>>>>>>>>>>>Procedure EnumerateMonitors
88918>>>>>>>>>>>>>>>>>>>  tMONITORINFO tPrimary
88918>>>>>>>>>>>>>>>>>>>  tMONITORINFO tPrimary
88918>>>>>>>>>>>>>>>>>>>  Handle hMonitor
88918>>>>>>>>>>>>>>>>>>>  Boolean bRetVal
88918>>>>>>>>>>>>>>>>>>>
88918>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(0,0,MONITOR_DEFAULTONPRIMARY)) To hMonitor
88919>>>>>>>>>>>>>>>>>>>  Set Value Of oMonitorHandles Item 0 To hMonitor
88920>>>>>>>>>>>>>>>>>>>  Move (SizeofType(tMONITORINFO)) To tPrimary.cbSize
88921>>>>>>>>>>>>>>>>>>>  Move (GetMonitorInfo(hMonitor, AddressOf(tPrimary))) To bRetVal
88922>>>>>>>>>>>>>>>>>>>  //
88922>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(-1,0,MONITOR_DEFAULTONNULL)) To hMonitor
88923>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88926>>>>>>>>>>>>>>>>>>>  //
88926>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(-1,-1,MONITOR_DEFAULTONNULL)) To hMonitor
88927>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88930>>>>>>>>>>>>>>>>>>>  //
88930>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(0,-1,MONITOR_DEFAULTONNULL)) To hMonitor
88931>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88934>>>>>>>>>>>>>>>>>>>  //
88934>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right+1,-1,MONITOR_DEFAULTONNULL)) To hMonitor
88935>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88938>>>>>>>>>>>>>>>>>>>  //
88938>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right+1,0,MONITOR_DEFAULTONNULL)) To hMonitor
88939>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88942>>>>>>>>>>>>>>>>>>>  //
88942>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right+1,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88943>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88946>>>>>>>>>>>>>>>>>>>  //
88946>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(tPrimary.rcMonitor.Right,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88947>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88950>>>>>>>>>>>>>>>>>>>  //
88950>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(0,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88951>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88954>>>>>>>>>>>>>>>>>>>  //
88954>>>>>>>>>>>>>>>>>>>  Move (MonitorFromPoint(-1,tPrimary.rcMonitor.Bottom+1,MONITOR_DEFAULTONNULL)) To hMonitor
88955>>>>>>>>>>>>>>>>>>>  If (hMonitor<>0) ;    Send add_element Of oMonitorHandles hMonitor
88958>>>>>>>>>>>>>>>>>>>End_Procedure
88959>>>>>>>>>>>>>>>>>>>
88959>>>>>>>>>>>>>>>>>>>Send EnumerateMonitors
88960>>>>>>>>>>>>>>>>>>>
88960>>>>>>>>>>>>>>>>>>>Procedure DisplayMonitorInfo Handle hWnd
88963>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
88963>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
88963>>>>>>>>>>>>>>>>>>>  Boolean bRetVal
88963>>>>>>>>>>>>>>>>>>>  Integer i iCnt iRetVal
88963>>>>>>>>>>>>>>>>>>>  Handle hMonitor
88963>>>>>>>>>>>>>>>>>>>
88963>>>>>>>>>>>>>>>>>>>  Get item_count Of oMonitorHandles To iCnt
88964>>>>>>>>>>>>>>>>>>>  If (iCnt=0) ;    Send EnumerateMonitors
88967>>>>>>>>>>>>>>>>>>>  //
88967>>>>>>>>>>>>>>>>>>>  Get item_count Of oMonitorHandles To iCnt
88968>>>>>>>>>>>>>>>>>>>  For i From 0 To (iCnt-1)
88974>>>>>>>>>>>>>>>>>>>>
88974>>>>>>>>>>>>>>>>>>>    Get Value Of oMonitorHandles Item i To hMonitor
88975>>>>>>>>>>>>>>>>>>>    Move (SizeofType(tMONITORINFO)) To tMonInfo.cbSize
88976>>>>>>>>>>>>>>>>>>>    Move (GetMonitorInfo(hMonitor, AddressOf(tMonInfo))) To bRetVal
88977>>>>>>>>>>>>>>>>>>>    If (bRetVal=0) ;      Get ShowLastError To iRetVal
88980>>>>>>>>>>>>>>>>>>>    Showln "Monitor #" i
88983>>>>>>>>>>>>>>>>>>>    Showln "Top Left: " tMonInfo.rcMonitor.Left ',' tMonInfo.rcMonitor.Top
88988>>>>>>>>>>>>>>>>>>>    Showln "Bottom Right: " tMonInfo.rcMonitor.Right ',' tMonInfo.rcMonitor.Bottom
88993>>>>>>>>>>>>>>>>>>>    Showln "Resolution: " (tMonInfo.rcMonitor.Right-tMonInfo.rcMonitor.Left) 'x' (tMonInfo.rcMonitor.Bottom-tMonInfo.rcMonitor.Top)
88998>>>>>>>>>>>>>>>>>>>    Showln
88999>>>>>>>>>>>>>>>>>>>  Loop
89000>>>>>>>>>>>>>>>>>>>>
89000>>>>>>>>>>>>>>>>>>>End_Procedure
89001>>>>>>>>>>>>>>>>>>>
89001>>>>>>>>>>>>>>>>>>>Function MonitorInfo Handle hWnd Returns tMONITORINFO
89004>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
89004>>>>>>>>>>>>>>>>>>>  tMONITORINFO tMonInfo
89004>>>>>>>>>>>>>>>>>>>  Boolean bRetVal
89004>>>>>>>>>>>>>>>>>>>  Integer iRetVal
89004>>>>>>>>>>>>>>>>>>>  Handle hMonitor
89004>>>>>>>>>>>>>>>>>>>
89004>>>>>>>>>>>>>>>>>>>  Move (SizeofType(tMONITORINFO)) To tMonInfo.cbSize
89005>>>>>>>>>>>>>>>>>>>  Move (MonitorFromWindow(hWnd,MONITOR_DEFAULTONPRIMARY)) To hMonitor
89006>>>>>>>>>>>>>>>>>>>  Move (GetMonitorInfo(hMonitor, AddressOf(tMonInfo))) To bRetVal
89007>>>>>>>>>>>>>>>>>>>  If (bRetVal=0) ;    Get ShowLastError To iRetVal
89010>>>>>>>>>>>>>>>>>>>  Function_Return tMonInfo
89011>>>>>>>>>>>>>>>>>>>End_Function
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>//
89012>>>>>>>>>>>>>>>>>// "Message Box 2.02"
89012>>>>>>>>>>>>>>>>>//  Copyright 2014 Davidian Busines Services
89012>>>>>>>>>>>>>>>>>//  Free for use for any purpose, provided as-is
89012>>>>>>>>>>>>>>>>>//  Report bugs/send enhancements to:  matthewd@datatechag.com
89012>>>>>>>>>>>>>>>>>//
89012>>>>>>>>>>>>>>>>>// new and improved message box replacement "2.0"
89012>>>>>>>>>>>>>>>>>//  1. Works with new font system in 17.1 (not hardcoded to Microsoft Sans Serif)
89012>>>>>>>>>>>>>>>>>//  2. Backwards compatible with old 15.0 Message Box replacement, including Help button and Checkbox control
89012>>>>>>>>>>>>>>>>>//  3. Can be used via struct interface to define more elaborate message boxes, including support for:
89012>>>>>>>>>>>>>>>>>//      A. Multiple sections of text
89012>>>>>>>>>>>>>>>>>//      B. font size/bold/italic/underline formatting of text in each section (17.0+)
89012>>>>>>>>>>>>>>>>>//      C. Multiple checkboxes
89012>>>>>>>>>>>>>>>>>//      D. mini-icons (16x16 bitmaps)
89012>>>>>>>>>>>>>>>>>//      E. Buttons other than Ok/Cancel/Yes/No/Abort/Retry/Fail
89012>>>>>>>>>>>>>>>>>//  4. Message boxes can appear on the "correct" monitor in multi-monitor setups
89012>>>>>>>>>>>>>>>>>//
89012>>>>>>>>>>>>>>>>>// Changes since release 2.0:
89012>>>>>>>>>>>>>>>>>//  added global handle to refer to message box object:  ghoMessageBox
89012>>>>>>>>>>>>>>>>>//  add property of message box object pbDisplayOnFocusMonitor to display the dialog on the same monitor as focus object
89012>>>>>>>>>>>>>>>>>//  added hoMonitor member (a handle to a VDF object, not a monitor handle)
89012>>>>>>>>>>>>>>>>>//  implemented code for hMonitor member (this is a handle to a monitor)
89012>>>>>>>>>>>>>>>>>//  fixed StandardButtons function (wasn't returning a value, renamed to mbButtons)
89012>>>>>>>>>>>>>>>>>//  added helper messages to return messagebox and message structs
89012>>>>>>>>>>>>>>>>>//  MessageBoxLanguage.pkg with Dutch labels contributed by Pieter van Dieran, labels
89012>>>>>>>>>>>>>>>>>//      for additional languages should be added to this file.
89012>>>>>>>>>>>>>>>>>//  added property for button width, piButtonWidth, this is initialized to the
89012>>>>>>>>>>>>>>>>>//      constant C_mbButtonWidth defined in MessageBoxLanguage.pkg
89012>>>>>>>>>>>>>>>>>//
89012>>>>>>>>>>>>>>>>>// Possible future enhancements:
89012>>>>>>>>>>>>>>>>>//  Set maximum width and wrap text accordingly (defined in struct member .iWidth)
89012>>>>>>>>>>>>>>>>>//  Input dialog (for dates/strings/numbers/etc)
89012>>>>>>>>>>>>>>>>>//  Add other predefined bitmaps
89012>>>>>>>>>>>>>>>>>//
89012>>>>>>>>>>>>>>>>>// Changes since release 2.01:
89012>>>>>>>>>>>>>>>>>//  added a timeout property to automatically close the message box by setting the iTimeout member of the
89012>>>>>>>>>>>>>>>>>//  tmbMessageBox struct to the number of milliseconds to keep the message dialog open
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>Define MBR_CHECKED             For   |CI$01000000
89012>>>>>>>>>>>>>>>>>Define MBR_CHECKED2            For   |CI$02000000
89012>>>>>>>>>>>>>>>>>Define MBR_MASK                For   |CI$0000000F
89012>>>>>>>>>>>>>>>>>Define MB_ICONDOWNLOAD         For   |CI$00000050
89012>>>>>>>>>>>>>>>>>Define MB_DEFBUTTONMASK        For   |CI$00000F00
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>Struct tmbMessageText
89012>>>>>>>>>>>>>>>>>    String sMessage
89012>>>>>>>>>>>>>>>>>    String sBitmap              // "mini-icon" 16x16 icon that will appear to the left of the text section
89012>>>>>>>>>>>>>>>>>    Integer iIndent
89012>>>>>>>>>>>>>>>>>    Integer iFontPointHeight
89012>>>>>>>>>>>>>>>>>    Boolean bBold               // bold text
89012>>>>>>>>>>>>>>>>>    Boolean bItalic             // italic
89012>>>>>>>>>>>>>>>>>    Boolean bUnderline          // underline
89012>>>>>>>>>>>>>>>>>    Boolean bCheckbox           // if true, this message is a checkbox
89012>>>>>>>>>>>>>>>>>    Boolean bChecked            // default state of checkbox
89012>>>>>>>>>>>>>>>>>    Integer iSpaceAfter         // spacing after this message
89012>>>>>>>>>>>>>>>>>    Handle _hoCheckbox          // private, handle to checkbox object
89012>>>>>>>>>>>>>>>>>End_Struct
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>Struct tmbButtons
89012>>>>>>>>>>>>>>>>>    String sLabel               // label (not required if a predefined button)
89012>>>>>>>>>>>>>>>>>    Boolean bDefault            // set to true for one button
89012>>>>>>>>>>>>>>>>>    Integer iType               // return value when this button is clicked, MBR_Yes, MBR_OK, MBR_No, etc.
89012>>>>>>>>>>>>>>>>>    Handle hoObject
89012>>>>>>>>>>>>>>>>>End_Struct
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>Struct tmbMessageBox
89012>>>>>>>>>>>>>>>>>    String sTitle               // title of message box
89012>>>>>>>>>>>>>>>>>    String sBitmap              // bitmap to display
89012>>>>>>>>>>>>>>>>>    Integer iBitmap             // predefined bitmaps to display
89012>>>>>>>>>>>>>>>>>    Integer iWidth              // override calculated width
89012>>>>>>>>>>>>>>>>>    Integer iHelp               // help id (if zero, no help button)
89012>>>>>>>>>>>>>>>>>    String sHtmlHelpTopic       //
89012>>>>>>>>>>>>>>>>>    Handle hoMonitor            // a handle to a dataflex object; the message box will appear on the same monitor as this object
89012>>>>>>>>>>>>>>>>>    Handle hMonitor             // a monitor handle
89012>>>>>>>>>>>>>>>>>    tmbMessageText[] Message    // 1 or more messages/checkboxes to display
89012>>>>>>>>>>>>>>>>>    tmbMessageText[] Message    // 1 or more messages/checkboxes to display
89012>>>>>>>>>>>>>>>>>    tmbButtons[] Button         // 1 or more buttons
89012>>>>>>>>>>>>>>>>>    tmbButtons[] Button         // 1 or more buttons
89012>>>>>>>>>>>>>>>>>    Integer iRetVal             // return value of button clicked
89012>>>>>>>>>>>>>>>>>    Integer iTimeout            // milliseconds until automatic timeout
89012>>>>>>>>>>>>>>>>>    Integer iButtonWidth        // width of buttons (overrides piButtonWidth if set)
89012>>>>>>>>>>>>>>>>>    Integer iButtonHeight
89012>>>>>>>>>>>>>>>>>End_Struct
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>Struct tmbDeferredCheckbox
89012>>>>>>>>>>>>>>>>>    String sLabel               // label for checkbox
89012>>>>>>>>>>>>>>>>>    Integer iY                  // vertical pos for checkbox
89012>>>>>>>>>>>>>>>>>    Integer iMsgIndex           // index into tmbMessageText array for source of checkbox
89012>>>>>>>>>>>>>>>>>End_Struct
89012>>>>>>>>>>>>>>>>>
89012>>>>>>>>>>>>>>>>>Class cmbTextBox is a TextBox
89013>>>>>>>>>>>>>>>>>// dummy message
89013>>>>>>>>>>>>>>>>>    Procedure Set CurrentButtonState Integer iState
89015>>>>>>>>>>>>>>>>>    End_Procedure
89016>>>>>>>>>>>>>>>>>End_Class
89017>>>>>>>>>>>>>>>>>
89017>>>>>>>>>>>>>>>>>Register_Function piButtonWidth Returns Integer
89017>>>>>>>>>>>>>>>>>Register_Function piButtonHeight Returns Integer
89017>>>>>>>>>>>>>>>>>
89017>>>>>>>>>>>>>>>>>Class cmbButton is a Button
89018>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89020>>>>>>>>>>>>>>>>>        Property Integer piButtonType_private        0
89021>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89023>>>>>>>>>>>>>>>>>        Set Size to (piButtonHeight(Self)) (piButtonWidth(Self))
89024>>>>>>>>>>>>>>>>>        Set Default_State to False
89025>>>>>>>>>>>>>>>>>        On_Key Key_Right_Arrow Send previous
89026>>>>>>>>>>>>>>>>>        On_Key Key_Left_Arrow Send next
89027>>>>>>>>>>>>>>>>>    End_Procedure
89028>>>>>>>>>>>>>>>>>
89028>>>>>>>>>>>>>>>>>    Procedure Set piButtonType Integer iType
89030>>>>>>>>>>>>>>>>>        Set piButtonType_private to iType
89031>>>>>>>>>>>>>>>>>        If (iType=-1) Begin
89033>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxHelp    // -1
89034>>>>>>>>>>>>>>>>>        End
89034>>>>>>>>>>>>>>>>>>
89034>>>>>>>>>>>>>>>>>        If (iType=MBR_Ok) Begin
89036>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxOk      // 1
89037>>>>>>>>>>>>>>>>>        End
89037>>>>>>>>>>>>>>>>>>
89037>>>>>>>>>>>>>>>>>        If (iType=MBR_Cancel) Begin
89039>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxCancel  // 2
89040>>>>>>>>>>>>>>>>>        End
89040>>>>>>>>>>>>>>>>>>
89040>>>>>>>>>>>>>>>>>        If (iType=MBR_Abort) Begin
89042>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxAbort   // 3
89043>>>>>>>>>>>>>>>>>        End
89043>>>>>>>>>>>>>>>>>>
89043>>>>>>>>>>>>>>>>>        If (iType=MBR_Retry) Begin
89045>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxRetry   // 4
89046>>>>>>>>>>>>>>>>>        End
89046>>>>>>>>>>>>>>>>>>
89046>>>>>>>>>>>>>>>>>        If (iType=MBR_Ignore) Begin
89048>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxIgnore  // 5
89049>>>>>>>>>>>>>>>>>        End
89049>>>>>>>>>>>>>>>>>>
89049>>>>>>>>>>>>>>>>>        If (iType=MBR_Yes) Begin
89051>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxYes     // 6
89052>>>>>>>>>>>>>>>>>        End
89052>>>>>>>>>>>>>>>>>>
89052>>>>>>>>>>>>>>>>>        If (iType=MBR_No) Begin
89054>>>>>>>>>>>>>>>>>            Set Label to C_$MessageBoxNo      // 7
89055>>>>>>>>>>>>>>>>>        End
89055>>>>>>>>>>>>>>>>>>
89055>>>>>>>>>>>>>>>>>    End_Procedure
89056>>>>>>>>>>>>>>>>>
89056>>>>>>>>>>>>>>>>>    Procedure OnClick
89058>>>>>>>>>>>>>>>>>        If (piButtonType_private(Self)>=0) Begin
89060>>>>>>>>>>>>>>>>>            Delegate Send OnClick (piButtonType_private(Self))
89062>>>>>>>>>>>>>>>>>        End
89062>>>>>>>>>>>>>>>>>>
89062>>>>>>>>>>>>>>>>>        Else Begin
89063>>>>>>>>>>>>>>>>>            Send help HELP_CONTEXT_ID
89064>>>>>>>>>>>>>>>>>        End
89064>>>>>>>>>>>>>>>>>>
89064>>>>>>>>>>>>>>>>>    End_Procedure
89065>>>>>>>>>>>>>>>>>End_Class
89066>>>>>>>>>>>>>>>>>
89066>>>>>>>>>>>>>>>>>Class cMessageBox_mixin is a cObject
89067>>>>>>>>>>>>>>>>>    Procedure Define_cMessageBox_mixin
89069>>>>>>>>>>>>>>>>>        Property Integer piButtonPressed 0
89070>>>>>>>>>>>>>>>>>        Property Boolean pbDisplayOnFocusMonitor True
89071>>>>>>>>>>>>>>>>>        Property Integer piButtonWidth C_mbButtonWidth
89072>>>>>>>>>>>>>>>>>        Property Integer piButtonHeight C_mbButtonHeight
89073>>>>>>>>>>>>>>>>>        Property String psMessageText ''
89074>>>>>>>>>>>>>>>>>
89074>>>>>>>>>>>>>>>>>        Set Size to 89 211
89075>>>>>>>>>>>>>>>>>        Set Label to C_$MessageBox
89076>>>>>>>>>>>>>>>>>        Set Location to 2 2
89077>>>>>>>>>>>>>>>>>        Set Border_Style to Border_Normal
89078>>>>>>>>>>>>>>>>>        Set Sysmenu_Icon to False
89079>>>>>>>>>>>>>>>>>        Set Minimize_Icon to False
89080>>>>>>>>>>>>>>>>>        Set Extended_Window_Style to WS_EX_TOOLWINDOW False
89081>>>>>>>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
89082>>>>>>>>>>>>>>>>>
89082>>>>>>>>>>>>>>>>>        Object oBitmap is a BitmapContainer
89084>>>>>>>>>>>>>>>>>            Set Size to 20 22
89085>>>>>>>>>>>>>>>>>            Set guiSize to 48 48
89086>>>>>>>>>>>>>>>>>            Set Location to 6 6
89087>>>>>>>>>>>>>>>>>            Set Bitmap to "info256.bmp/3d"
89088>>>>>>>>>>>>>>>>>            Set Border_Style to Border_None
89089>>>>>>>>>>>>>>>>>        End_Object
89090>>>>>>>>>>>>>>>>>    End_Procedure
89091>>>>>>>>>>>>>>>>>
89091>>>>>>>>>>>>>>>>>    Procedure Set CurrentButtonState Integer iState
89093>>>>>>>>>>>>>>>>>    End_Procedure
89094>>>>>>>>>>>>>>>>>
89094>>>>>>>>>>>>>>>>>    // handle positioning: if pbDisplayOnFocusMonitor is true, get the focus object and place the
89094>>>>>>>>>>>>>>>>>    //  message box on the same monitor that the focus object is on, OTHERWISE
89094>>>>>>>>>>>>>>>>>    // hoMonitor may contain a Handle to a VDF Object, and put the message on the same monitor as it, OR
89094>>>>>>>>>>>>>>>>>    //  if hMonitor <> 0, use that monitor handle (to force messages to appear on secondary display(s)
89094>>>>>>>>>>>>>>>>>    //  since the primary display should always be zero)
89094>>>>>>>>>>>>>>>>>    // otherwise, use the CENTER_ON_SCREEN locate mode.
89094>>>>>>>>>>>>>>>>>    Procedure DeterminePosition tmbMessageBox Msg
89096>>>>>>>>>>>>>>>>>        tMONITORINFO MonitorInfo
89096>>>>>>>>>>>>>>>>>        tMONITORINFO MonitorInfo
89096>>>>>>>>>>>>>>>>>        Integer iSize iLoc iY iX
89096>>>>>>>>>>>>>>>>>        Handle hMonitor
89096>>>>>>>>>>>>>>>>>        Integer iRetVal
89096>>>>>>>>>>>>>>>>>
89096>>>>>>>>>>>>>>>>>        If (pbDisplayOnFocusMonitor(Self) and Msg.hoMonitor=0) Begin
89098>>>>>>>>>>>>>>>>>            Get Focus to Msg.hoMonitor
89099>>>>>>>>>>>>>>>>>        End
89099>>>>>>>>>>>>>>>>>>
89099>>>>>>>>>>>>>>>>>        //
89099>>>>>>>>>>>>>>>>>        If (Msg.hoMonitor=0 and Msg.hMonitor=0) Begin
89101>>>>>>>>>>>>>>>>>            Set Locate_Mode to CENTER_ON_SCREEN
89102>>>>>>>>>>>>>>>>>        End
89102>>>>>>>>>>>>>>>>>>
89102>>>>>>>>>>>>>>>>>        Else Begin
89103>>>>>>>>>>>>>>>>>            If (Msg.hMonitor=0) Begin
89105>>>>>>>>>>>>>>>>>                Get Absolute_GuiOrigin of Msg.hoMonitor to iLoc
89106>>>>>>>>>>>>>>>>>                Move (MonitorFromPoint(Low(iLoc),Hi(iLoc),MONITOR_DEFAULTONPRIMARY)) to hMonitor
89107>>>>>>>>>>>>>>>>>            End
89107>>>>>>>>>>>>>>>>>>
89107>>>>>>>>>>>>>>>>>            Else Begin
89108>>>>>>>>>>>>>>>>>                Move Msg.hMonitor to hMonitor
89109>>>>>>>>>>>>>>>>>            End
89109>>>>>>>>>>>>>>>>>>
89109>>>>>>>>>>>>>>>>>            //
89109>>>>>>>>>>>>>>>>>            Move (SizeofType(tMONITORINFO)) to MonitorInfo.cbSize
89110>>>>>>>>>>>>>>>>>            Move (GetMonitorInfo(hMonitor, AddressOf(MonitorInfo))) to iRetVal
89111>>>>>>>>>>>>>>>>>            If (iRetVal) Begin
89113>>>>>>>>>>>>>>>>>                Set Locate_Mode to NO_LOCATE
89114>>>>>>>>>>>>>>>>>                Get GUISize to iSize
89115>>>>>>>>>>>>>>>>>                Move MonitorInfo.rcMonitor.Top to iY
89116>>>>>>>>>>>>>>>>>                Add ((MonitorInfo.rcMonitor.bottom-monitorInfo.rcMonitor.Top)/2) to iY
89117>>>>>>>>>>>>>>>>>                Subtract (Hi(iSize)/2) From iY
89118>>>>>>>>>>>>>>>>>                Move MonitorInfo.rcMonitor.Left to iX
89119>>>>>>>>>>>>>>>>>                Add ((monitorInfo.rcMonitor.right-MonitorInfo.rcMonitor.Left)/2) to iX
89120>>>>>>>>>>>>>>>>>                Subtract (Low(iSize)/2) From iX
89121>>>>>>>>>>>>>>>>>                Set GuiLocation to iY iX
89122>>>>>>>>>>>>>>>>>                Send Adjust_Logicals
89123>>>>>>>>>>>>>>>>>            End
89123>>>>>>>>>>>>>>>>>>
89123>>>>>>>>>>>>>>>>>        End
89123>>>>>>>>>>>>>>>>>>
89123>>>>>>>>>>>>>>>>>    End_Procedure
89124>>>>>>>>>>>>>>>>>
89124>>>>>>>>>>>>>>>>>    Procedure ShowMessageBox tmbMessageBox ByRef Msg
89126>>>>>>>>>>>>>>>>>        Integer i
89126>>>>>>>>>>>>>>>>>        Handle[] hoObject
89127>>>>>>>>>>>>>>>>>
89127>>>>>>>>>>>>>>>>>        Get ConstructMessageBox (&Msg) to hoObject
89128>>>>>>>>>>>>>>>>>        // Nils. This is no longer needed for more recent DataFlex versions.
89128>>>>>>>>>>>>>>>>>        // In fact, not commenting it out will/can display the message box on the
89128>>>>>>>>>>>>>>>>>        // wrong screen/monitor.
89128>>>>>>>>>>>>>>>>>        Send DeterminePosition Msg
89129>>>>>>>>>>>>>>>>>        Send Popup
89130>>>>>>>>>>>>>>>>>        // get any checkbox values back into the struct
89130>>>>>>>>>>>>>>>>>        For i From 0 to (SizeOfArray(Msg.Message)-1)
89136>>>>>>>>>>>>>>>>>>
89136>>>>>>>>>>>>>>>>>            If (Msg.Message[i]._hoCheckbox<>0) Begin
89138>>>>>>>>>>>>>>>>>                Get checked_state of Msg.Message[i]._hoCheckbox to Msg.Message[i].bChecked
89139>>>>>>>>>>>>>>>>>            End
89139>>>>>>>>>>>>>>>>>>
89139>>>>>>>>>>>>>>>>>        Loop
89140>>>>>>>>>>>>>>>>>>
89140>>>>>>>>>>>>>>>>>        // resize the array in case a timer message was added (struct can then be re-used, not sure you would want to do that, but just in case)
89140>>>>>>>>>>>>>>>>>        If (Msg.iTimeout<>0) Begin
89142>>>>>>>>>>>>>>>>>            Move (ResizeArray(Msg.Message,SizeOfArray(Msg.Message)-1)) to Msg.Message
89143>>>>>>>>>>>>>>>>>        End
89143>>>>>>>>>>>>>>>>>>
89143>>>>>>>>>>>>>>>>>        // destroy objects
89143>>>>>>>>>>>>>>>>>        For i From 0 to (Sizeofarray(hoObject)-1)
89149>>>>>>>>>>>>>>>>>>
89149>>>>>>>>>>>>>>>>>            Send Destroy to hoObject[i]
89150>>>>>>>>>>>>>>>>>        Loop
89151>>>>>>>>>>>>>>>>>>
89151>>>>>>>>>>>>>>>>>        Get piButtonPressed to Msg.iRetVal
89152>>>>>>>>>>>>>>>>>    End_Procedure
89153>>>>>>>>>>>>>>>>>
89153>>>>>>>>>>>>>>>>>    // these are the default bitmaps
89153>>>>>>>>>>>>>>>>>    Function IconBitmap Integer iIcon Returns String
89155>>>>>>>>>>>>>>>>>        Move (iIcon iand MB_ICONMASK) to iIcon
89156>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONEXCLAMATION) Begin
89158>>>>>>>>>>>>>>>>>            Function_Return "warning256.bmp/3d"
89159>>>>>>>>>>>>>>>>>        End
89159>>>>>>>>>>>>>>>>>>
89159>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONHAND) Begin
89161>>>>>>>>>>>>>>>>>            Function_Return "stop256.bmp/3d"
89162>>>>>>>>>>>>>>>>>        End
89162>>>>>>>>>>>>>>>>>>
89162>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONASTERISK) Begin
89164>>>>>>>>>>>>>>>>>            Function_Return "info256.bmp/3d"
89165>>>>>>>>>>>>>>>>>        End
89165>>>>>>>>>>>>>>>>>>
89165>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONQUESTION) Begin
89167>>>>>>>>>>>>>>>>>            Function_Return "question256.bmp/3d"
89168>>>>>>>>>>>>>>>>>        End
89168>>>>>>>>>>>>>>>>>>
89168>>>>>>>>>>>>>>>>>        If (iIcon=MB_ICONDOWNLOAD) Begin
89170>>>>>>>>>>>>>>>>>            Function_Return "download256.bmp/3d"
89171>>>>>>>>>>>>>>>>>        End
89171>>>>>>>>>>>>>>>>>>
89171>>>>>>>>>>>>>>>>>    End_Function
89172>>>>>>>>>>>>>>>>>
89172>>>>>>>>>>>>>>>>>    Function ConstructMessageBox tmbMessageBox ByRef Msg Returns Handle[]
89174>>>>>>>>>>>>>>>>>        Boolean bButtonRepos
89174>>>>>>>>>>>>>>>>>        String sCR sText sLabel sMessageText
89174>>>>>>>>>>>>>>>>>        String[] sMsg
89175>>>>>>>>>>>>>>>>>        Integer i iCnt iLine yPos xPos iSize iMaxLength iWidth iFirstButton iFirstxPos iCheckboxCnt xMaxPos xMsgPos iLineWidth iFirstButtonIndex iButtonSpan
89175>>>>>>>>>>>>>>>>>        Integer iLoc
89175>>>>>>>>>>>>>>>>>        Handle hoObj hoFirstButton
89175>>>>>>>>>>>>>>>>>        Handle[] hoObject
89176>>>>>>>>>>>>>>>>>        tmbDeferredCheckbox[] Checkboxes
89176>>>>>>>>>>>>>>>>>        tmbDeferredCheckbox[] Checkboxes
89177>>>>>>>>>>>>>>>>>
89177>>>>>>>>>>>>>>>>>        Set private.Current_Action_button to 0
89178>>>>>>>>>>>>>>>>>        Set piButtonPressed to 0        // possible if Alt+F4 used
89179>>>>>>>>>>>>>>>>>
89179>>>>>>>>>>>>>>>>>        Move (Character(13)) to sCR
89180>>>>>>>>>>>>>>>>>        Move 8 to yPos
89181>>>>>>>>>>>>>>>>>        If (Msg.sBitmap<>'') Begin
89183>>>>>>>>>>>>>>>>>            Set Bitmap of oBitmap to Msg.sBitmap
89184>>>>>>>>>>>>>>>>>        End
89184>>>>>>>>>>>>>>>>>>
89184>>>>>>>>>>>>>>>>>        Else If (Msg.ibitmap<>0) Begin
89187>>>>>>>>>>>>>>>>>            Set Bitmap of oBitmap to (IconBitmap(Self,Msg.iBitmap))
89188>>>>>>>>>>>>>>>>>        End
89188>>>>>>>>>>>>>>>>>>
89188>>>>>>>>>>>>>>>>>        Set Label to Msg.sTitle
89189>>>>>>>>>>>>>>>>>        Set piButtonWidth to C_mbButtonWidth
89190>>>>>>>>>>>>>>>>>        Set piButtonHeight to C_mbButtonHeight
89191>>>>>>>>>>>>>>>>>        If (Msg.iButtonWidth<>0) Begin
89193>>>>>>>>>>>>>>>>>            Set piButtonWidth to Msg.iButtonWidth
89194>>>>>>>>>>>>>>>>>        End
89194>>>>>>>>>>>>>>>>>>
89194>>>>>>>>>>>>>>>>>        If (Msg.iButtonHeight<>0) Begin
89196>>>>>>>>>>>>>>>>>            Set piButtonHeight to Msg.iButtonHeight
89197>>>>>>>>>>>>>>>>>        End
89197>>>>>>>>>>>>>>>>>>
89197>>>>>>>>>>>>>>>>>        //
89197>>>>>>>>>>>>>>>>>        // following loop creates textbox/checkbox/bitmap objects for each line of the each message
89197>>>>>>>>>>>>>>>>>        //  line breaks should be indicated with the \n sequence
89197>>>>>>>>>>>>>>>>>        If (Msg.iTimeout<>0) Begin
89199>>>>>>>>>>>>>>>>>            Move (SizeOfArray(Msg.Message)) to i
89200>>>>>>>>>>>>>>>>>            Move (SFormat(C_$MessageBoxTimeout,String(Msg.iTimeout/1000))) to Msg.Message[i].sMessage
89201>>>>>>>>>>>>>>>>>        End
89201>>>>>>>>>>>>>>>>>>
89201>>>>>>>>>>>>>>>>>        For i From 0 to (SizeofArray(Msg.Message)-1)
89207>>>>>>>>>>>>>>>>>>
89207>>>>>>>>>>>>>>>>>            Move (Msg.Message[i].sMessage+"\n") to sText
89208>>>>>>>>>>>>>>>>>            Move (Replaces("\n",sText,sCR)) to sText
89209>>>>>>>>>>>>>>>>>            If (msg.message[i].bCheckbox=False) Begin
89211>>>>>>>>>>>>>>>>>                Move (sMessageText+sText) to sMessageText   // for copy Ctrl+C
89212>>>>>>>>>>>>>>>>>            End
89212>>>>>>>>>>>>>>>>>>
89212>>>>>>>>>>>>>>>>>
89212>>>>>>>>>>>>>>>>>            Move (ParseString2(sText,sCR)) to sMsg
89213>>>>>>>>>>>>>>>>>            //
89213>>>>>>>>>>>>>>>>>            Move 40 to xMsgPos
89214>>>>>>>>>>>>>>>>>            For iLine From 0 to (SizeOfArray(sMsg)-1)
89220>>>>>>>>>>>>>>>>>>
89220>>>>>>>>>>>>>>>>>                If (Msg.Message[i].bCheckbox and iLine=0) Begin
89222>>>>>>>>>>>>>>>>>                // checkbox object creation is deferred until after the buttons to set up the desired tab order
89222>>>>>>>>>>>>>>>>>                // we remember the settings here and use them after the buttons are created
89222>>>>>>>>>>>>>>>>>                    Move (SizeOfArray(Checkboxes)) to iCheckboxCnt
89223>>>>>>>>>>>>>>>>>                    Move sMsg[iLine] to Checkboxes[iCheckboxCnt].sLabel
89224>>>>>>>>>>>>>>>>>                    Add 8 to yPos
89225>>>>>>>>>>>>>>>>>                    Move yPos to checkboxes[iCheckboxCnt].iY
89226>>>>>>>>>>>>>>>>>                    Move i to Checkboxes[iCheckboxCnt].iMsgIndex
89227>>>>>>>>>>>>>>>>>                    If (hoObj) Begin
89229>>>>>>>>>>>>>>>>>                        Get size of hoObj to iSize
89230>>>>>>>>>>>>>>>>>                    End
89230>>>>>>>>>>>>>>>>>>
89230>>>>>>>>>>>>>>>>>                    Move 0 to hoObj
89231>>>>>>>>>>>>>>>>>                    Add (Hi(iSize)) to yPos
89232>>>>>>>>>>>>>>>>>                End
89232>>>>>>>>>>>>>>>>>>
89232>>>>>>>>>>>>>>>>>                Else Begin
89233>>>>>>>>>>>>>>>>>                    If (Msg.Message[i].sBitmap<>'' and iLine=0) Begin
89235>>>>>>>>>>>>>>>>>                        Object oBitmap is a BitmapContainer
89237>>>>>>>>>>>>>>>>>                            Set GuiSize to 16 16
89238>>>>>>>>>>>>>>>>>                            Set Location to yPos xMsgPos
89239>>>>>>>>>>>>>>>>>                            Set Bitmap to Msg.Message[i].sBitmap
89240>>>>>>>>>>>>>>>>>                            Set Border_Style to Border_None
89241>>>>>>>>>>>>>>>>>                            Move Self to hoObj
89242>>>>>>>>>>>>>>>>>                        End_Object
89243>>>>>>>>>>>>>>>>>                        Send Add_Focus to hoObj Self
89244>>>>>>>>>>>>>>>>>                        Move hoObj to hoObject[SizeOfArray(hoObject)]
89245>>>>>>>>>>>>>>>>>                        Move 54 to xMsgPos
89246>>>>>>>>>>>>>>>>>                    End
89246>>>>>>>>>>>>>>>>>>
89246>>>>>>>>>>>>>>>>>                    // indent text box position for multi-line checkbox message
89246>>>>>>>>>>>>>>>>>                    If (Msg.Message[i].bCheckbox) Begin
89248>>>>>>>>>>>>>>>>>                        Move 50 to xMsgPos
89249>>>>>>>>>>>>>>>>>                    End
89249>>>>>>>>>>>>>>>>>>
89249>>>>>>>>>>>>>>>>>                    If (sMsg[iLine]<>'') Begin
89251>>>>>>>>>>>>>>>>>                        Object oTextBox is a cmbTextbox
89253>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].iFontPointHeight<>0) Begin
89255>>>>>>>>>>>>>>>>>                                Set FontPointHeight to Msg.Message[i].iFontPointHeight
89256>>>>>>>>>>>>>>>>>                            End
89256>>>>>>>>>>>>>>>>>>
89256>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].bBold) Begin
89258>>>>>>>>>>>>>>>>>                                Set FontWeight to 800
89259>>>>>>>>>>>>>>>>>                            End
89259>>>>>>>>>>>>>>>>>>
89259>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].bItalic) Begin
89261>>>>>>>>>>>>>>>>>                                Set FontItalics to True
89262>>>>>>>>>>>>>>>>>                            End
89262>>>>>>>>>>>>>>>>>>
89262>>>>>>>>>>>>>>>>>                            If (Msg.Message[i].bUnderline) Begin
89264>>>>>>>>>>>>>>>>>                                Set FontUnderline to True
89265>>>>>>>>>>>>>>>>>                            End
89265>>>>>>>>>>>>>>>>>>
89265>>>>>>>>>>>>>>>>>                            Set Auto_Size_State to True
89266>>>>>>>>>>>>>>>>>                            Set Transparent_State to True
89267>>>>>>>>>>>>>>>>>                            Set Label to sMsg[iLine]
89268>>>>>>>>>>>>>>>>>                            Set Location to yPos (xMsgPos+Msg.Message[i].iIndent)
89269>>>>>>>>>>>>>>>>>                            Set Justification_Mode to jMode_Left
89270>>>>>>>>>>>>>>>>>                            Move Self to hoObj
89271>>>>>>>>>>>>>>>>>                            Get size of hoObj to iSize
89272>>>>>>>>>>>>>>>>>                            Add (hi(iSize)) to yPos
89273>>>>>>>>>>>>>>>>>                        End_Object
89274>>>>>>>>>>>>>>>>>                        Send Add_Focus to hoObj Self
89275>>>>>>>>>>>>>>>>>                    End
89275>>>>>>>>>>>>>>>>>>
89275>>>>>>>>>>>>>>>>>                    Else Begin
89276>>>>>>>>>>>>>>>>>                    // blank line, just increase yPos
89276>>>>>>>>>>>>>>>>>                        Add (Hi(iSize)) to yPos
89277>>>>>>>>>>>>>>>>>                        Move 0 to hoObj
89278>>>>>>>>>>>>>>>>>                    End
89278>>>>>>>>>>>>>>>>>>
89278>>>>>>>>>>>>>>>>>                End
89278>>>>>>>>>>>>>>>>>>
89278>>>>>>>>>>>>>>>>>                If (hoObj<>0) Begin
89280>>>>>>>>>>>>>>>>>                // store object in array for destruction later
89280>>>>>>>>>>>>>>>>>                    Move hoObj to hoObject[SizeOfArray(hoObject)]
89281>>>>>>>>>>>>>>>>>                    // determine longest element so we know how wide to make the dialog
89281>>>>>>>>>>>>>>>>>                    Move (Low(iSize)+If(Msg.Message[i].sBitmap<>'',14,0)) to iLineWidth
89282>>>>>>>>>>>>>>>>>                    If (iLineWidth>iMaxLength) Begin
89284>>>>>>>>>>>>>>>>>                        Move iLineWidth to iMaxLength
89285>>>>>>>>>>>>>>>>>                    End
89285>>>>>>>>>>>>>>>>>>
89285>>>>>>>>>>>>>>>>>                End
89285>>>>>>>>>>>>>>>>>>
89285>>>>>>>>>>>>>>>>>            Loop
89286>>>>>>>>>>>>>>>>>>
89286>>>>>>>>>>>>>>>>>            Add Msg.Message[i].iSpaceAfter to yPos
89287>>>>>>>>>>>>>>>>>        Loop
89288>>>>>>>>>>>>>>>>>>
89288>>>>>>>>>>>>>>>>>        Set psMessageText to sMessageText
89289>>>>>>>>>>>>>>>>>        Add 8 to yPos
89290>>>>>>>>>>>>>>>>>        //
89290>>>>>>>>>>>>>>>>>        // determine button horizontal positioning
89290>>>>>>>>>>>>>>>>>        Move (SizeOfArray(Msg.Button)) to iCnt
89291>>>>>>>>>>>>>>>>>        If (Msg.iHelp<>0 or Msg.sHtmlHelpTopic<>'') Begin
89293>>>>>>>>>>>>>>>>>            Add 1 to iCnt
89294>>>>>>>>>>>>>>>>>        End
89294>>>>>>>>>>>>>>>>>>
89294>>>>>>>>>>>>>>>>>        Move ((iCnt*piButtonWidth(Self))+((iCnt-1)*4)) to iWidth
89295>>>>>>>>>>>>>>>>>        If (iMaxLength<120) Begin
89297>>>>>>>>>>>>>>>>>            Move 120 to iMaxLength
89298>>>>>>>>>>>>>>>>>        End
89298>>>>>>>>>>>>>>>>>>
89298>>>>>>>>>>>>>>>>>        If (iWidth>=iMaxLength+80) Begin
89300>>>>>>>>>>>>>>>>>            Move (iWidth+20) to iMaxLength
89301>>>>>>>>>>>>>>>>>        End
89301>>>>>>>>>>>>>>>>>>
89301>>>>>>>>>>>>>>>>>        Move (((iMaxLength+80)-iWidth)/2) to xPos
89302>>>>>>>>>>>>>>>>>        Move xPos to iFirstxPos
89303>>>>>>>>>>>>>>>>>        //
89303>>>>>>>>>>>>>>>>>        For i From 0 to (SizeOfArray(Msg.Button)-1)
89309>>>>>>>>>>>>>>>>>>
89309>>>>>>>>>>>>>>>>>            If (Msg.Button[i].bDefault) Begin
89311>>>>>>>>>>>>>>>>>                Move i to iFirstButton
89312>>>>>>>>>>>>>>>>>                Move xPos to iFirstxPos
89313>>>>>>>>>>>>>>>>>            End
89313>>>>>>>>>>>>>>>>>>
89313>>>>>>>>>>>>>>>>>            Add (piButtonWidth(Self)+4) to xPos
89314>>>>>>>>>>>>>>>>>        End
89315>>>>>>>>>>>>>>>>>>
89315>>>>>>>>>>>>>>>>>
89315>>>>>>>>>>>>>>>>>        // check for minimum dialog height
89315>>>>>>>>>>>>>>>>>        If (yPos<50) Begin
89317>>>>>>>>>>>>>>>>>            Move 50 to yPos
89318>>>>>>>>>>>>>>>>>        End
89318>>>>>>>>>>>>>>>>>>
89318>>>>>>>>>>>>>>>>>        // create the buttons: default button first, then the rest in order
89318>>>>>>>>>>>>>>>>>        Move iFirstButton to i
89319>>>>>>>>>>>>>>>>>        Move iFirstxPos to xPos
89320>>>>>>>>>>>>>>>>>        Repeat
89320>>>>>>>>>>>>>>>>>>
89320>>>>>>>>>>>>>>>>>            Get Create (RefClass(cmbButton)) to hoObj
89321>>>>>>>>>>>>>>>>>            Set Label of hoObj to Msg.Button[i].sLabel
89322>>>>>>>>>>>>>>>>>            Set Location of hoObj to yPos xPos
89323>>>>>>>>>>>>>>>>>            Set piButtonType of hoObj to Msg.Button[i].iType
89324>>>>>>>>>>>>>>>>>            If (iFirstButtonIndex=0) Begin
89326>>>>>>>>>>>>>>>>>                Move (SizeOfArray(hoObject)) to iFirstButtonIndex
89327>>>>>>>>>>>>>>>>>            End
89327>>>>>>>>>>>>>>>>>>
89327>>>>>>>>>>>>>>>>>            Move hoObj to hoObject[SizeOfArray(hoObject)]
89328>>>>>>>>>>>>>>>>>            Move hoObj to Msg.Button[i].hoObject
89329>>>>>>>>>>>>>>>>>            If (hoFirstButton=0) Begin
89331>>>>>>>>>>>>>>>>>                Move hoObj to hoFirstButton
89332>>>>>>>>>>>>>>>>>            End
89332>>>>>>>>>>>>>>>>>>
89332>>>>>>>>>>>>>>>>>            If (Pos("&",Label(hoObj))>0) Begin
89334>>>>>>>>>>>>>>>>>                Send SetupAccelerator hoObj
89335>>>>>>>>>>>>>>>>>            End
89335>>>>>>>>>>>>>>>>>>
89335>>>>>>>>>>>>>>>>>            If (xMaxPos<xPos) Begin
89337>>>>>>>>>>>>>>>>>                Move xPos to xMaxPos
89338>>>>>>>>>>>>>>>>>            End
89338>>>>>>>>>>>>>>>>>>
89338>>>>>>>>>>>>>>>>>            Send Add_Focus to hoObj Self
89339>>>>>>>>>>>>>>>>>            Add 1 to i
89340>>>>>>>>>>>>>>>>>            If (i>SizeOfArray(Msg.Button)-1) Begin
89342>>>>>>>>>>>>>>>>>                Move 0 to i
89343>>>>>>>>>>>>>>>>>                Move (((iMaxLength+80)-iWidth)/2) to xPos
89344>>>>>>>>>>>>>>>>>            End
89344>>>>>>>>>>>>>>>>>>
89344>>>>>>>>>>>>>>>>>            Else Begin
89345>>>>>>>>>>>>>>>>>                Add (piButtonWidth(Self)+4) to xPos
89346>>>>>>>>>>>>>>>>>            End
89346>>>>>>>>>>>>>>>>>>
89346>>>>>>>>>>>>>>>>>            Add (piButtonWidth(Self)+4) to iButtonSpan
89347>>>>>>>>>>>>>>>>>        Until (i=iFirstButton)
89349>>>>>>>>>>>>>>>>>
89349>>>>>>>>>>>>>>>>>        If (Msg.iTimeout<>0) Begin
89351>>>>>>>>>>>>>>>>>            Get Create (RefClass(dfTimer)) to hoObj
89352>>>>>>>>>>>>>>>>>            Set Timeout of hoObj to Msg.itimeout
89353>>>>>>>>>>>>>>>>>            Set timer_object of hoObj to hoFirstButton
89354>>>>>>>>>>>>>>>>>            Set Timer_Active_State of hoObj to True
89355>>>>>>>>>>>>>>>>>            Set Timer_Message of hoObj to msg_keyaction
89356>>>>>>>>>>>>>>>>>            Move hoObj to hoObject[SizeOfArray(hoObject)]
89357>>>>>>>>>>>>>>>>>        End
89357>>>>>>>>>>>>>>>>>>
89357>>>>>>>>>>>>>>>>>
89357>>>>>>>>>>>>>>>>>        // if a help id was included, create the help button
89357>>>>>>>>>>>>>>>>>        If (msg.iHelp<>0 or Msg.sHtmlHelpTopic<>'') Begin
89359>>>>>>>>>>>>>>>>>            Object oButton is a cmbButton
89361>>>>>>>>>>>>>>>>>                Set piButtonType to -1
89362>>>>>>>>>>>>>>>>>                Set Location to yPos (xMaxPos+piButtonWidth(Self)+4)
89363>>>>>>>>>>>>>>>>>                Set Help_Id to Msg.iHelp
89364>>>>>>>>>>>>>>>>>                Set psHtmlHelpTopic to Msg.sHtmlHelpTopic
89365>>>>>>>>>>>>>>>>>                Move Self to hoObj
89366>>>>>>>>>>>>>>>>>                Move hoObj to hoObject[SizeOfArray(hoObject)]
89367>>>>>>>>>>>>>>>>>            End_Object
89368>>>>>>>>>>>>>>>>>            If (Pos("&",Label(hoObj))>0) Begin
89370>>>>>>>>>>>>>>>>>                Send SetupAccelerator hoObj
89371>>>>>>>>>>>>>>>>>            End
89371>>>>>>>>>>>>>>>>>>
89371>>>>>>>>>>>>>>>>>        End
89371>>>>>>>>>>>>>>>>>>
89371>>>>>>>>>>>>>>>>>
89371>>>>>>>>>>>>>>>>>        For i From 0 to (SizeOfArray(Checkboxes)-1)
89377>>>>>>>>>>>>>>>>>>
89377>>>>>>>>>>>>>>>>>            Object oCheckbox is a Checkbox
89379>>>>>>>>>>>>>>>>>                Set Auto_Size_State to True
89380>>>>>>>>>>>>>>>>>                // Set FontSize to 14 0
89380>>>>>>>>>>>>>>>>>                Set Label to Checkboxes[i].sLabel
89381>>>>>>>>>>>>>>>>>                Set Location to Checkboxes[i].iY 40
89382>>>>>>>>>>>>>>>>>                Move Self to hoObj
89383>>>>>>>>>>>>>>>>>                Move Self to Msg.Message[checkboxes[i].iMsgIndex]._hoCheckbox
89384>>>>>>>>>>>>>>>>>                Set Checked_State to Msg.Message[checkboxes[i].iMsgIndex].bChecked
89385>>>>>>>>>>>>>>>>>                Get Size to iSize
89386>>>>>>>>>>>>>>>>>                Move (Low(iSize)+If(Msg.Message[i].sBitmap<>'',14,0)) to iLineWidth
89387>>>>>>>>>>>>>>>>>                If (iLineWidth>iMaxLength) Begin
89389>>>>>>>>>>>>>>>>>                    Move iLineWidth to iMaxLength
89390>>>>>>>>>>>>>>>>>                    Move True to bButtonRepos
89391>>>>>>>>>>>>>>>>>                End
89391>>>>>>>>>>>>>>>>>>
89391>>>>>>>>>>>>>>>>>                On_Key Key_Right_Arrow Send previous
89392>>>>>>>>>>>>>>>>>                On_Key Key_Left_Arrow Send next
89393>>>>>>>>>>>>>>>>>            End_Object
89394>>>>>>>>>>>>>>>>>            Send Add_Focus to hoObj Self
89395>>>>>>>>>>>>>>>>>            Move hoObj to hoObject[SizeOfArray(hoObject)]
89396>>>>>>>>>>>>>>>>>        Loop
89397>>>>>>>>>>>>>>>>>>
89397>>>>>>>>>>>>>>>>>
89397>>>>>>>>>>>>>>>>>        // if iMaxLength has changed, reposition buttons
89397>>>>>>>>>>>>>>>>>        If (bButtonRepos) Begin
89399>>>>>>>>>>>>>>>>>            Move (((iMaxLength+80)-iButtonSpan)/2) to xPos
89400>>>>>>>>>>>>>>>>>            For i From 0 to (SizeOfArray(Msg.Button)-1)
89406>>>>>>>>>>>>>>>>>>
89406>>>>>>>>>>>>>>>>>                If (Msg.Button[i].bDefault) Begin
89408>>>>>>>>>>>>>>>>>                    Move i to iFirstButton
89409>>>>>>>>>>>>>>>>>                    Move xPos to iFirstxPos
89410>>>>>>>>>>>>>>>>>                End
89410>>>>>>>>>>>>>>>>>>
89410>>>>>>>>>>>>>>>>>                Add (piButtonWidth(Self)+4) to xPos
89411>>>>>>>>>>>>>>>>>            Loop
89412>>>>>>>>>>>>>>>>>>
89412>>>>>>>>>>>>>>>>>            Move iFirstButton to i
89413>>>>>>>>>>>>>>>>>            Move iFirstxPos to xPos
89414>>>>>>>>>>>>>>>>>            Repeat
89414>>>>>>>>>>>>>>>>>>
89414>>>>>>>>>>>>>>>>>                Get Location of Msg.Button[i].hoObject to iLoc
89415>>>>>>>>>>>>>>>>>                Get size of Msg.button[i].hoObject to iSize
89416>>>>>>>>>>>>>>>>>                Set Location of Msg.Button[i].hoObject to (Hi(iLoc)) xPos
89417>>>>>>>>>>>>>>>>>                Add 1 to i
89418>>>>>>>>>>>>>>>>>                If (i>SizeOfArray(Msg.Button)-1) Begin
89420>>>>>>>>>>>>>>>>>                    Move 0 to i
89421>>>>>>>>>>>>>>>>>                    Move (((iMaxLength+80)-iButtonSpan)/2) to xPos
89422>>>>>>>>>>>>>>>>>                End
89422>>>>>>>>>>>>>>>>>>
89422>>>>>>>>>>>>>>>>>                Else Begin
89423>>>>>>>>>>>>>>>>>                    Add (piButtonWidth(Self)+4) to xPos
89424>>>>>>>>>>>>>>>>>                End
89424>>>>>>>>>>>>>>>>>>
89424>>>>>>>>>>>>>>>>>            Until (i=iFirstButton)
89426>>>>>>>>>>>>>>>>>        End
89426>>>>>>>>>>>>>>>>>>
89426>>>>>>>>>>>>>>>>>
89426>>>>>>>>>>>>>>>>>        Set Size to (yPos+piButtonHeight(Self)+4) (If(Msg.iWidth<>0,Msg.iWidth,iMaxLength+80))
89427>>>>>>>>>>>>>>>>>
89427>>>>>>>>>>>>>>>>>        On_Key key_ctrl+Key_C Send CopyMessageText
89428>>>>>>>>>>>>>>>>>        Function_Return hoObject        // return an array of object IDs
89429>>>>>>>>>>>>>>>>>    End_Function
89430>>>>>>>>>>>>>>>>>
89430>>>>>>>>>>>>>>>>>    Procedure CopyMessageText
89432>>>>>>>>>>>>>>>>>        Direct_Output "clipboard:"
89433>>>>>>>>>>>>>>>>>        Writeln (psMessageText(Self))
89435>>>>>>>>>>>>>>>>>        Close_Output
89436>>>>>>>>>>>>>>>>>    End_Procedure
89437>>>>>>>>>>>>>>>>>
89437>>>>>>>>>>>>>>>>>    Procedure OnClick Integer iButton
89439>>>>>>>>>>>>>>>>>        Set piButtonPressed to iButton
89440>>>>>>>>>>>>>>>>>        Send stop_modal_ui
89441>>>>>>>>>>>>>>>>>    End_Procedure
89442>>>>>>>>>>>>>>>>>
89442>>>>>>>>>>>>>>>>>    Procedure SetupAccelerator Handle hoObj
89444>>>>>>>>>>>>>>>>>        String sLabel
89444>>>>>>>>>>>>>>>>>        Get Label of hoObj to sLabel
89445>>>>>>>>>>>>>>>>>        Move (Uppercase(Mid(sLabel,1,Pos("&",sLabel)+1))) to sLabel
89446>>>>>>>>>>>>>>>>>        If (sLabel="A") Begin
89448>>>>>>>>>>>>>>>>>            On_Key Key_A Send KeyAction to hoObj
89449>>>>>>>>>>>>>>>>>        End
89449>>>>>>>>>>>>>>>>>>
89449>>>>>>>>>>>>>>>>>        Else If (sLabel="B") Begin
89452>>>>>>>>>>>>>>>>>            On_Key Key_B Send KeyAction to hoObj
89453>>>>>>>>>>>>>>>>>        End
89453>>>>>>>>>>>>>>>>>>
89453>>>>>>>>>>>>>>>>>        Else If (sLabel="C") Begin
89456>>>>>>>>>>>>>>>>>            On_Key Key_C Send KeyAction to hoObj
89457>>>>>>>>>>>>>>>>>        End
89457>>>>>>>>>>>>>>>>>>
89457>>>>>>>>>>>>>>>>>        Else If (sLabel="D") Begin
89460>>>>>>>>>>>>>>>>>            On_Key Key_D Send KeyAction to hoObj
89461>>>>>>>>>>>>>>>>>        End
89461>>>>>>>>>>>>>>>>>>
89461>>>>>>>>>>>>>>>>>        Else If (sLabel="E") Begin
89464>>>>>>>>>>>>>>>>>            On_Key Key_E Send KeyAction to hoObj
89465>>>>>>>>>>>>>>>>>        End
89465>>>>>>>>>>>>>>>>>>
89465>>>>>>>>>>>>>>>>>        Else If (sLabel="F") Begin
89468>>>>>>>>>>>>>>>>>            On_Key Key_F Send KeyAction to hoObj
89469>>>>>>>>>>>>>>>>>        End
89469>>>>>>>>>>>>>>>>>>
89469>>>>>>>>>>>>>>>>>        Else If (sLabel="G") Begin
89472>>>>>>>>>>>>>>>>>            On_Key Key_G Send KeyAction to hoObj
89473>>>>>>>>>>>>>>>>>        End
89473>>>>>>>>>>>>>>>>>>
89473>>>>>>>>>>>>>>>>>        Else If (sLabel="H") Begin
89476>>>>>>>>>>>>>>>>>            On_Key Key_H Send KeyAction to hoObj
89477>>>>>>>>>>>>>>>>>        End
89477>>>>>>>>>>>>>>>>>>
89477>>>>>>>>>>>>>>>>>        Else If (sLabel="I") Begin
89480>>>>>>>>>>>>>>>>>            On_Key Key_I Send KeyAction to hoObj
89481>>>>>>>>>>>>>>>>>        End
89481>>>>>>>>>>>>>>>>>>
89481>>>>>>>>>>>>>>>>>        Else If (sLabel="J") Begin
89484>>>>>>>>>>>>>>>>>            On_Key Key_J Send KeyAction to hoObj
89485>>>>>>>>>>>>>>>>>        End
89485>>>>>>>>>>>>>>>>>>
89485>>>>>>>>>>>>>>>>>        Else If (sLabel="K") Begin
89488>>>>>>>>>>>>>>>>>            On_Key Key_K Send KeyAction to hoObj
89489>>>>>>>>>>>>>>>>>        End
89489>>>>>>>>>>>>>>>>>>
89489>>>>>>>>>>>>>>>>>        Else If (sLabel="L") Begin
89492>>>>>>>>>>>>>>>>>            On_Key Key_L Send KeyAction to hoObj
89493>>>>>>>>>>>>>>>>>        End
89493>>>>>>>>>>>>>>>>>>
89493>>>>>>>>>>>>>>>>>        Else If (sLabel="M") Begin
89496>>>>>>>>>>>>>>>>>            On_Key Key_M Send KeyAction to hoObj
89497>>>>>>>>>>>>>>>>>        End
89497>>>>>>>>>>>>>>>>>>
89497>>>>>>>>>>>>>>>>>        Else If (sLabel="N") Begin
89500>>>>>>>>>>>>>>>>>            On_Key Key_N Send KeyAction to hoObj
89501>>>>>>>>>>>>>>>>>        End
89501>>>>>>>>>>>>>>>>>>
89501>>>>>>>>>>>>>>>>>        Else If (sLabel="O") Begin
89504>>>>>>>>>>>>>>>>>            On_Key Key_O Send KeyAction to hoObj
89505>>>>>>>>>>>>>>>>>        End
89505>>>>>>>>>>>>>>>>>>
89505>>>>>>>>>>>>>>>>>        Else If (sLabel="P") Begin
89508>>>>>>>>>>>>>>>>>            On_Key Key_P Send KeyAction to hoObj
89509>>>>>>>>>>>>>>>>>        End
89509>>>>>>>>>>>>>>>>>>
89509>>>>>>>>>>>>>>>>>        Else If (sLabel="Q") Begin
89512>>>>>>>>>>>>>>>>>            On_Key Key_Q Send KeyAction to hoObj
89513>>>>>>>>>>>>>>>>>        End
89513>>>>>>>>>>>>>>>>>>
89513>>>>>>>>>>>>>>>>>        Else If (sLabel="R") Begin
89516>>>>>>>>>>>>>>>>>            On_Key Key_R Send KeyAction to hoObj
89517>>>>>>>>>>>>>>>>>        End
89517>>>>>>>>>>>>>>>>>>
89517>>>>>>>>>>>>>>>>>        Else If (sLabel="S") Begin
89520>>>>>>>>>>>>>>>>>            On_Key Key_S Send KeyAction to hoObj
89521>>>>>>>>>>>>>>>>>        End
89521>>>>>>>>>>>>>>>>>>
89521>>>>>>>>>>>>>>>>>        Else If (sLabel="T") Begin
89524>>>>>>>>>>>>>>>>>            On_Key Key_T Send KeyAction to hoObj
89525>>>>>>>>>>>>>>>>>        End
89525>>>>>>>>>>>>>>>>>>
89525>>>>>>>>>>>>>>>>>        Else If (sLabel="U") Begin
89528>>>>>>>>>>>>>>>>>            On_Key Key_U Send KeyAction to hoObj
89529>>>>>>>>>>>>>>>>>        End
89529>>>>>>>>>>>>>>>>>>
89529>>>>>>>>>>>>>>>>>        Else If (sLabel="V") Begin
89532>>>>>>>>>>>>>>>>>            On_Key Key_V Send KeyAction to hoObj
89533>>>>>>>>>>>>>>>>>        End
89533>>>>>>>>>>>>>>>>>>
89533>>>>>>>>>>>>>>>>>        Else If (sLabel="W") Begin
89536>>>>>>>>>>>>>>>>>            On_Key Key_W Send KeyAction to hoObj
89537>>>>>>>>>>>>>>>>>        End
89537>>>>>>>>>>>>>>>>>>
89537>>>>>>>>>>>>>>>>>        Else If (sLabel="X") Begin
89540>>>>>>>>>>>>>>>>>            On_Key Key_X Send KeyAction to hoObj
89541>>>>>>>>>>>>>>>>>        End
89541>>>>>>>>>>>>>>>>>>
89541>>>>>>>>>>>>>>>>>        Else If (sLabel="Y") Begin
89544>>>>>>>>>>>>>>>>>            On_Key Key_Y Send KeyAction to hoObj
89545>>>>>>>>>>>>>>>>>        End
89545>>>>>>>>>>>>>>>>>>
89545>>>>>>>>>>>>>>>>>        Else If (sLabel="Z") Begin
89548>>>>>>>>>>>>>>>>>            On_Key Key_Z Send KeyAction to hoObj
89549>>>>>>>>>>>>>>>>>        End
89549>>>>>>>>>>>>>>>>>>
89549>>>>>>>>>>>>>>>>>        Else If (sLabel="Z") Begin
89552>>>>>>>>>>>>>>>>>            On_Key Key_Z Send KeyAction to hoObj
89553>>>>>>>>>>>>>>>>>        End
89553>>>>>>>>>>>>>>>>>>
89553>>>>>>>>>>>>>>>>>        Else If (sLabel="0") Begin
89556>>>>>>>>>>>>>>>>>            On_Key Key_0 Send KeyAction to hoObj
89557>>>>>>>>>>>>>>>>>        End
89557>>>>>>>>>>>>>>>>>>
89557>>>>>>>>>>>>>>>>>        Else If (sLabel="1") Begin
89560>>>>>>>>>>>>>>>>>            On_Key Key_1 Send KeyAction to hoObj
89561>>>>>>>>>>>>>>>>>        End
89561>>>>>>>>>>>>>>>>>>
89561>>>>>>>>>>>>>>>>>        Else If (sLabel="2") Begin
89564>>>>>>>>>>>>>>>>>            On_Key Key_2 Send KeyAction to hoObj
89565>>>>>>>>>>>>>>>>>        End
89565>>>>>>>>>>>>>>>>>>
89565>>>>>>>>>>>>>>>>>        Else If (sLabel="3") Begin
89568>>>>>>>>>>>>>>>>>            On_Key Key_3 Send KeyAction to hoObj
89569>>>>>>>>>>>>>>>>>        End
89569>>>>>>>>>>>>>>>>>>
89569>>>>>>>>>>>>>>>>>        Else If (sLabel="4") Begin
89572>>>>>>>>>>>>>>>>>            On_Key Key_4 Send KeyAction to hoObj
89573>>>>>>>>>>>>>>>>>        End
89573>>>>>>>>>>>>>>>>>>
89573>>>>>>>>>>>>>>>>>        Else If (sLabel="5") Begin
89576>>>>>>>>>>>>>>>>>            On_Key Key_5 Send KeyAction to hoObj
89577>>>>>>>>>>>>>>>>>        End
89577>>>>>>>>>>>>>>>>>>
89577>>>>>>>>>>>>>>>>>        Else If (sLabel="6") Begin
89580>>>>>>>>>>>>>>>>>            On_Key Key_6 Send KeyAction to hoObj
89581>>>>>>>>>>>>>>>>>        End
89581>>>>>>>>>>>>>>>>>>
89581>>>>>>>>>>>>>>>>>        Else If (sLabel="7") Begin
89584>>>>>>>>>>>>>>>>>            On_Key Key_7 Send KeyAction to hoObj
89585>>>>>>>>>>>>>>>>>        End
89585>>>>>>>>>>>>>>>>>>
89585>>>>>>>>>>>>>>>>>        Else If (sLabel="8") Begin
89588>>>>>>>>>>>>>>>>>            On_Key Key_8 Send KeyAction to hoObj
89589>>>>>>>>>>>>>>>>>        End
89589>>>>>>>>>>>>>>>>>>
89589>>>>>>>>>>>>>>>>>        Else If (sLabel="9") Begin
89592>>>>>>>>>>>>>>>>>            On_Key Key_9 Send KeyAction to hoObj
89593>>>>>>>>>>>>>>>>>        End
89593>>>>>>>>>>>>>>>>>>
89593>>>>>>>>>>>>>>>>>    End_Procedure
89594>>>>>>>>>>>>>>>>>
89594>>>>>>>>>>>>>>>>>    // helper functions that return a tmbButton struct for predefined buttons
89594>>>>>>>>>>>>>>>>>    Function mbOkButton Returns tmbButtons
89596>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89596>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89596>>>>>>>>>>>>>>>>>        Move MBR_Ok to RetVal.iType
89597>>>>>>>>>>>>>>>>>        Function_Return RetVal
89598>>>>>>>>>>>>>>>>>    End_Function
89599>>>>>>>>>>>>>>>>>
89599>>>>>>>>>>>>>>>>>    Function mbCancelButton Returns tmbButtons
89601>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89601>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89601>>>>>>>>>>>>>>>>>        Move MBR_Cancel to RetVal.iType
89602>>>>>>>>>>>>>>>>>        Function_Return RetVal
89603>>>>>>>>>>>>>>>>>    End_Function
89604>>>>>>>>>>>>>>>>>
89604>>>>>>>>>>>>>>>>>    Function mbYesButton Returns tmbButtons
89606>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89606>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89606>>>>>>>>>>>>>>>>>        Move MBR_Yes to RetVal.iType
89607>>>>>>>>>>>>>>>>>        Function_Return RetVal
89608>>>>>>>>>>>>>>>>>    End_Function
89609>>>>>>>>>>>>>>>>>
89609>>>>>>>>>>>>>>>>>    Function mbNoButton Returns tmbButtons
89611>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89611>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89611>>>>>>>>>>>>>>>>>        Move MBR_No to RetVal.iType
89612>>>>>>>>>>>>>>>>>        Function_Return RetVal
89613>>>>>>>>>>>>>>>>>    End_Function
89614>>>>>>>>>>>>>>>>>
89614>>>>>>>>>>>>>>>>>    Function mbAbortButton Returns tmbButtons
89616>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89616>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89616>>>>>>>>>>>>>>>>>        Move MBR_Abort to RetVal.iType
89617>>>>>>>>>>>>>>>>>        Function_Return RetVal
89618>>>>>>>>>>>>>>>>>    End_Function
89619>>>>>>>>>>>>>>>>>
89619>>>>>>>>>>>>>>>>>    Function mbRetryButton Returns tmbButtons
89621>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89621>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89621>>>>>>>>>>>>>>>>>        Move MBR_Retry to RetVal.iType
89622>>>>>>>>>>>>>>>>>        Function_Return RetVal
89623>>>>>>>>>>>>>>>>>    End_Function
89624>>>>>>>>>>>>>>>>>
89624>>>>>>>>>>>>>>>>>    Function mbIgnoreButton Returns tmbButtons
89626>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89626>>>>>>>>>>>>>>>>>        tmbButtons RetVal
89626>>>>>>>>>>>>>>>>>        Move MBR_Ignore to RetVal.iType
89627>>>>>>>>>>>>>>>>>        Function_Return RetVal
89628>>>>>>>>>>>>>>>>>    End_Function
89629>>>>>>>>>>>>>>>>>
89629>>>>>>>>>>>>>>>>>    Function mbButtons Integer iButton1 Integer iButton2 Integer iButton3 Integer iButton4 Returns tmbButtons[]
89631>>>>>>>>>>>>>>>>>        tmbButtons[] RetVal
89631>>>>>>>>>>>>>>>>>        tmbButtons[] RetVal
89632>>>>>>>>>>>>>>>>>        Move iButton1 to RetVal[0].iType
89633>>>>>>>>>>>>>>>>>        If (num_arguments>1) Begin
89635>>>>>>>>>>>>>>>>>            Move iButton2 to RetVal[1].iType
89636>>>>>>>>>>>>>>>>>        End
89636>>>>>>>>>>>>>>>>>>
89636>>>>>>>>>>>>>>>>>        If (num_arguments>2) Begin
89638>>>>>>>>>>>>>>>>>            Move iButton3 to RetVal[2].iType
89639>>>>>>>>>>>>>>>>>        End
89639>>>>>>>>>>>>>>>>>>
89639>>>>>>>>>>>>>>>>>        If (num_arguments>3) Begin
89641>>>>>>>>>>>>>>>>>            Move iButton4 to RetVal[3].iType
89642>>>>>>>>>>>>>>>>>        End
89642>>>>>>>>>>>>>>>>>>
89642>>>>>>>>>>>>>>>>>        Function_Return RetVal
89643>>>>>>>>>>>>>>>>>    End_Function
89644>>>>>>>>>>>>>>>>>
89644>>>>>>>>>>>>>>>>>    Function mbMessageBox String sMessage String sTitle Integer iBitmap String sBitmap Integer iFontPointHeight Boolean bBold Boolean bItalic Boolean bUnderline Returns tmbMessageBox
89646>>>>>>>>>>>>>>>>>        tmbMessageBox mb
89646>>>>>>>>>>>>>>>>>        tmbMessageBox mb
89646>>>>>>>>>>>>>>>>>        Move sMessage to mb.Message[0].sMessage
89647>>>>>>>>>>>>>>>>>        Move sTitle to mb.sTitle
89648>>>>>>>>>>>>>>>>>        If (num_arguments>2) Begin
89650>>>>>>>>>>>>>>>>>            Move iBitmap to mb.iBitmap
89651>>>>>>>>>>>>>>>>>        End
89651>>>>>>>>>>>>>>>>>>
89651>>>>>>>>>>>>>>>>>        If (Num_arguments>3) Begin
89653>>>>>>>>>>>>>>>>>            Move sBitmap to mb.sBitmap
89654>>>>>>>>>>>>>>>>>        End
89654>>>>>>>>>>>>>>>>>>
89654>>>>>>>>>>>>>>>>>        If (num_arguments>4) Begin
89656>>>>>>>>>>>>>>>>>            Move iFontPointHeight to mb.Message[0].iFontPointHeight
89657>>>>>>>>>>>>>>>>>        End
89657>>>>>>>>>>>>>>>>>>
89657>>>>>>>>>>>>>>>>>        If (num_arguments>5) Begin
89659>>>>>>>>>>>>>>>>>            Move bBold to mb.Message[0].bBold
89660>>>>>>>>>>>>>>>>>        End
89660>>>>>>>>>>>>>>>>>>
89660>>>>>>>>>>>>>>>>>        If (num_arguments>6) Begin
89662>>>>>>>>>>>>>>>>>            Move bItalic to mb.Message[0].bItalic
89663>>>>>>>>>>>>>>>>>        End
89663>>>>>>>>>>>>>>>>>>
89663>>>>>>>>>>>>>>>>>        If (num_arguments>7) Begin
89665>>>>>>>>>>>>>>>>>            Move bUnderline to mb.Message[0].bUnderline
89666>>>>>>>>>>>>>>>>>        End
89666>>>>>>>>>>>>>>>>>>
89666>>>>>>>>>>>>>>>>>        Function_Return mb
89667>>>>>>>>>>>>>>>>>    End_Function
89668>>>>>>>>>>>>>>>>>
89668>>>>>>>>>>>>>>>>>    Function mbMessage String sMessage Boolean bCheckbox Boolean bChecked String sBitmap Integer iFontPointHeight Boolean bBold Boolean bItalic Boolean bUnderline Integer iSpaceAfter Returns tmbMessageText
89670>>>>>>>>>>>>>>>>>        tmbMessageText msg
89670>>>>>>>>>>>>>>>>>        tmbMessageText msg
89670>>>>>>>>>>>>>>>>>        Move sMessage to msg.sMessage
89671>>>>>>>>>>>>>>>>>        Move 4 to msg.iSpaceAfter
89672>>>>>>>>>>>>>>>>>        If (num_arguments>1) Begin
89674>>>>>>>>>>>>>>>>>            Move bCheckbox to msg.bCheckbox
89675>>>>>>>>>>>>>>>>>        End
89675>>>>>>>>>>>>>>>>>>
89675>>>>>>>>>>>>>>>>>        If (num_arguments>2) Begin
89677>>>>>>>>>>>>>>>>>            Move bChecked to msg.bChecked
89678>>>>>>>>>>>>>>>>>        End
89678>>>>>>>>>>>>>>>>>>
89678>>>>>>>>>>>>>>>>>        If (num_arguments>3) Begin
89680>>>>>>>>>>>>>>>>>            Move sBitmap to msg.sBitmap
89681>>>>>>>>>>>>>>>>>        End
89681>>>>>>>>>>>>>>>>>>
89681>>>>>>>>>>>>>>>>>        If (num_arguments>4) Begin
89683>>>>>>>>>>>>>>>>>            Move iFontPointHeight to msg.iFontPointHeight
89684>>>>>>>>>>>>>>>>>        End
89684>>>>>>>>>>>>>>>>>>
89684>>>>>>>>>>>>>>>>>        If (num_arguments>5) Begin
89686>>>>>>>>>>>>>>>>>            Move bBold to msg.bBold
89687>>>>>>>>>>>>>>>>>        End
89687>>>>>>>>>>>>>>>>>>
89687>>>>>>>>>>>>>>>>>        If (num_arguments>6) Begin
89689>>>>>>>>>>>>>>>>>            Move bItalic to msg.bItalic
89690>>>>>>>>>>>>>>>>>        End
89690>>>>>>>>>>>>>>>>>>
89690>>>>>>>>>>>>>>>>>        If (num_arguments>7) Begin
89692>>>>>>>>>>>>>>>>>            Move bUnderline to msg.bUnderline
89693>>>>>>>>>>>>>>>>>        End
89693>>>>>>>>>>>>>>>>>>
89693>>>>>>>>>>>>>>>>>        If (num_arguments>8) Begin
89695>>>>>>>>>>>>>>>>>            Move iSpaceAfter to msg.iSpaceAfter
89696>>>>>>>>>>>>>>>>>        End
89696>>>>>>>>>>>>>>>>>>
89696>>>>>>>>>>>>>>>>>        Function_Return msg
89697>>>>>>>>>>>>>>>>>    End_Function
89698>>>>>>>>>>>>>>>>>
89698>>>>>>>>>>>>>>>>>End_Class
89699>>>>>>>>>>>>>>>>>
89699>>>>>>>>>>>>>>>>>Class cMessageBoxPanel is a ModalPanel
89700>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89702>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89704>>>>>>>>>>>>>>>>>        Send Define_cMessageBox_mixin
89705>>>>>>>>>>>>>>>>>    End_Procedure
89706>>>>>>>>>>>>>>>>>
89706>>>>>>>>>>>>>>>>>    Import_Class_Protocol cMessageBox_mixin
89707>>>>>>>>>>>>>>>>>End_Class
89708>>>>>>>>>>>>>>>>>
89708>>>>>>>>>>>>>>>>>// following three classes are experimental
89708>>>>>>>>>>>>>>>>>//  here be dragons
89708>>>>>>>>>>>>>>>>>Class cMessageBoxTitle is a Container3d
89709>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89711>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89713>>>>>>>>>>>>>>>>>        Set Border_Style to Border_None
89714>>>>>>>>>>>>>>>>>        Set Location to 0 0
89715>>>>>>>>>>>>>>>>>        Object oTitle is a TextBox
89717>>>>>>>>>>>>>>>>>            Set peAnchors to anTopLeftRight
89718>>>>>>>>>>>>>>>>>            Set Location to 0 0
89719>>>>>>>>>>>>>>>>>            Set Color to clLtGray
89720>>>>>>>>>>>>>>>>>        End_Object
89721>>>>>>>>>>>>>>>>>    End_Procedure
89722>>>>>>>>>>>>>>>>>
89722>>>>>>>>>>>>>>>>>    Procedure Set Label String Val
89724>>>>>>>>>>>>>>>>>        Integer iSize
89724>>>>>>>>>>>>>>>>>        Set Label of oTitle to Val
89725>>>>>>>>>>>>>>>>>        Delegate Get Size to iSize
89727>>>>>>>>>>>>>>>>>        Set Size to 10 (Low(iSize))
89728>>>>>>>>>>>>>>>>>        Set Size of oTitle to 10 (Low(iSize))
89729>>>>>>>>>>>>>>>>>    End_Procedure
89730>>>>>>>>>>>>>>>>>End_Class
89731>>>>>>>>>>>>>>>>>
89731>>>>>>>>>>>>>>>>>Class cMessageBoxContainer is a Container3d
89732>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89734>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89736>>>>>>>>>>>>>>>>>        Set Border_Style to border_none
89737>>>>>>>>>>>>>>>>>        Send Define_cMessageBox_mixin
89738>>>>>>>>>>>>>>>>>        Set Location to 11 0
89739>>>>>>>>>>>>>>>>>        Set Visible_State to True
89740>>>>>>>>>>>>>>>>>        Set Shadow_State to False
89741>>>>>>>>>>>>>>>>>        Property Handle[] phoObjects
89742>>>>>>>>>>>>>>>>>    End_Procedure
89743>>>>>>>>>>>>>>>>>
89743>>>>>>>>>>>>>>>>>    Import_Class_Protocol cMessageBox_mixin
89744>>>>>>>>>>>>>>>>>
89744>>>>>>>>>>>>>>>>>    Procedure RefreshPreview tmbMessageBox ByRef Msg
89746>>>>>>>>>>>>>>>>>        Handle[] hoObject
89747>>>>>>>>>>>>>>>>>        Integer i
89747>>>>>>>>>>>>>>>>>
89747>>>>>>>>>>>>>>>>>        Get phoObjects to hoObject
89748>>>>>>>>>>>>>>>>>        For i From 0 to (Sizeofarray(hoObject)-1)
89754>>>>>>>>>>>>>>>>>>
89754>>>>>>>>>>>>>>>>>            Send Destroy to hoObject[i]
89755>>>>>>>>>>>>>>>>>        Loop
89756>>>>>>>>>>>>>>>>>>
89756>>>>>>>>>>>>>>>>>        Get ConstructMessageBox (&Msg) to hoObject
89757>>>>>>>>>>>>>>>>>        Set phoObjects to hoObject
89758>>>>>>>>>>>>>>>>>    End_Procedure
89759>>>>>>>>>>>>>>>>>
89759>>>>>>>>>>>>>>>>>    Procedure Set Label String Val
89761>>>>>>>>>>>>>>>>>        Delegate Set Label to Val
89763>>>>>>>>>>>>>>>>>    End_Procedure
89764>>>>>>>>>>>>>>>>>
89764>>>>>>>>>>>>>>>>>    Procedure Set Size Integer iHeight Integer iWidth
89766>>>>>>>>>>>>>>>>>        Forward Set Size to iHeight iWidth
89768>>>>>>>>>>>>>>>>>        Delegate Set Size to (iHeight+10) iWidth
89770>>>>>>>>>>>>>>>>>        Set Location to 11 0
89771>>>>>>>>>>>>>>>>>        Send Adjust_Logicals
89772>>>>>>>>>>>>>>>>>        Delegate Send Adjust_Logicals
89774>>>>>>>>>>>>>>>>>    End_Procedure
89775>>>>>>>>>>>>>>>>>
89775>>>>>>>>>>>>>>>>>End_Class
89776>>>>>>>>>>>>>>>>>
89776>>>>>>>>>>>>>>>>>Class cMessageBoxPreview is a Container3d
89777>>>>>>>>>>>>>>>>>
89777>>>>>>>>>>>>>>>>>    Procedure Construct_Object
89779>>>>>>>>>>>>>>>>>        Forward Send Construct_Object
89781>>>>>>>>>>>>>>>>>        Object oTitle is a cMessageBoxTitle
89783>>>>>>>>>>>>>>>>>        End_Object
89784>>>>>>>>>>>>>>>>>        Object oPreviewer is a cMessageBoxContainer
89786>>>>>>>>>>>>>>>>>        End_Object
89787>>>>>>>>>>>>>>>>>        Send Add_Focus to oPreviewer Self
89788>>>>>>>>>>>>>>>>>    End_Procedure
89789>>>>>>>>>>>>>>>>>
89789>>>>>>>>>>>>>>>>>    Procedure Set Label String Val
89791>>>>>>>>>>>>>>>>>        Set Label of oTitle to Val
89792>>>>>>>>>>>>>>>>>    End_Procedure
89793>>>>>>>>>>>>>>>>>
89793>>>>>>>>>>>>>>>>>    Procedure createButton
89795>>>>>>>>>>>>>>>>>        Send CreateButton to oPreviewer
89796>>>>>>>>>>>>>>>>>    End_Procedure
89797>>>>>>>>>>>>>>>>>
89797>>>>>>>>>>>>>>>>>    Procedure RefreshPreview tmbMessageBox ByRef Msg
89799>>>>>>>>>>>>>>>>>        Send RefreshPreview to oPreviewer (&Msg)
89800>>>>>>>>>>>>>>>>>        Broadcast Set Visible_State to True
89802>>>>>>>>>>>>>>>>>    End_Procedure
89803>>>>>>>>>>>>>>>>>End_Class
89804>>>>>>>>>>>>>>>>>
89804>>>>>>>>>>>>>>>>>// create the main object that is used to display message boxes
89804>>>>>>>>>>>>>>>>>Global_Variable Handle ghoMessageBox
89804>>>>>>>>>>>>>>>>>Object oMessageBox is a cMessageBoxPanel
89806>>>>>>>>>>>>>>>>>    Move Self to ghoMessageBox
89807>>>>>>>>>>>>>>>>>End_Object
89808>>>>>>>>>>>>>>>>>
89808>>>>>>>>>>>>>>>>>// a standard message to access the enhanced message box functionality
89808>>>>>>>>>>>>>>>>>//  by passing a struct
89808>>>>>>>>>>>>>>>>>Procedure ShowMessageBox tmbMessageBox ByRef Msg
89811>>>>>>>>>>>>>>>>>    Send ShowMessageBox to ghoMessageBox (&Msg)
89812>>>>>>>>>>>>>>>>>End_Procedure
89813>>>>>>>>>>>>>>>>>
89813>>>>>>>>>>>>>>>>>// substitutes for the standard message box procedures/functions
89813>>>>>>>>>>>>>>>>>//  plus some extras (WarningBox, WarningCancelBox, AbortRetryIgnoreBox)
89813>>>>>>>>>>>>>>>>>Procedure StopBox String sText String sLabel Integer iHelp
89816>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89816>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89816>>>>>>>>>>>>>>>>>
89816>>>>>>>>>>>>>>>>>    If (num_arguments=1) Begin
89818>>>>>>>>>>>>>>>>>        Get StopBox sText to mb
89819>>>>>>>>>>>>>>>>>    End
89819>>>>>>>>>>>>>>>>>>
89819>>>>>>>>>>>>>>>>>    If (num_arguments=2) Begin
89821>>>>>>>>>>>>>>>>>        Get StopBox sText sLabel to mb
89822>>>>>>>>>>>>>>>>>    End
89822>>>>>>>>>>>>>>>>>>
89822>>>>>>>>>>>>>>>>>    If (num_arguments=3) Begin
89824>>>>>>>>>>>>>>>>>        Get StopBox sText sLabel iHelp to mb
89825>>>>>>>>>>>>>>>>>    End
89825>>>>>>>>>>>>>>>>>>
89825>>>>>>>>>>>>>>>>>    Send ShowMessageBox (&mb)
89826>>>>>>>>>>>>>>>>>End_Procedure
89827>>>>>>>>>>>>>>>>>
89827>>>>>>>>>>>>>>>>>Function StopBox String sText String sLabel Integer iHelp String sHtmlHelpTopic Returns tmbMessageBox
89830>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89830>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89830>>>>>>>>>>>>>>>>>
89830>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89831>>>>>>>>>>>>>>>>>    Move "stop256.bmp/3d" to mb.sBitmap
89832>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89834>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89835>>>>>>>>>>>>>>>>>    End
89835>>>>>>>>>>>>>>>>>>
89835>>>>>>>>>>>>>>>>>    Else Begin
89836>>>>>>>>>>>>>>>>>        Move C_$MessageBoxStop to mb.sTitle
89837>>>>>>>>>>>>>>>>>    End
89837>>>>>>>>>>>>>>>>>>
89837>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89839>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89840>>>>>>>>>>>>>>>>>    End
89840>>>>>>>>>>>>>>>>>>
89840>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89842>>>>>>>>>>>>>>>>>        Move sHtmlHelpTopic to mb.sHtmlHelpTopic
89843>>>>>>>>>>>>>>>>>    End
89843>>>>>>>>>>>>>>>>>>
89843>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89844>>>>>>>>>>>>>>>>>    Function_Return mb
89845>>>>>>>>>>>>>>>>>End_Function
89846>>>>>>>>>>>>>>>>>
89846>>>>>>>>>>>>>>>>>Procedure WarningBox String sText String sLabel Integer iHelp
89849>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89849>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89849>>>>>>>>>>>>>>>>>
89849>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89850>>>>>>>>>>>>>>>>>    Move "warning256.bmp/3d" to mb.sBitmap
89851>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89853>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89854>>>>>>>>>>>>>>>>>    End
89854>>>>>>>>>>>>>>>>>>
89854>>>>>>>>>>>>>>>>>    Else Begin
89855>>>>>>>>>>>>>>>>>        Move C_$MessageBoxWarning to mb.sTitle
89856>>>>>>>>>>>>>>>>>    End
89856>>>>>>>>>>>>>>>>>>
89856>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89858>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89859>>>>>>>>>>>>>>>>>    End
89859>>>>>>>>>>>>>>>>>>
89859>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89860>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89861>>>>>>>>>>>>>>>>>End_Procedure
89862>>>>>>>>>>>>>>>>>
89862>>>>>>>>>>>>>>>>>Procedure InfoBox String sText String sLabel Integer iHelp
89865>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89865>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89865>>>>>>>>>>>>>>>>>
89865>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89866>>>>>>>>>>>>>>>>>    Move "info256.bmp/3d" to mb.sBitmap
89867>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89869>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89870>>>>>>>>>>>>>>>>>    End
89870>>>>>>>>>>>>>>>>>>
89870>>>>>>>>>>>>>>>>>    Else Begin
89871>>>>>>>>>>>>>>>>>        Move C_$MessageBoxInfo to mb.sTitle
89872>>>>>>>>>>>>>>>>>    End
89872>>>>>>>>>>>>>>>>>>
89872>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89874>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89875>>>>>>>>>>>>>>>>>    End
89875>>>>>>>>>>>>>>>>>>
89875>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89876>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89877>>>>>>>>>>>>>>>>>End_Procedure
89878>>>>>>>>>>>>>>>>>
89878>>>>>>>>>>>>>>>>>Function WarningCancelBox String sText String sLabel Integer iHelp Returns Integer
89881>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89881>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89881>>>>>>>>>>>>>>>>>
89881>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89882>>>>>>>>>>>>>>>>>    Move "warning256.bmp/3d" to mb.sBitmap
89883>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89885>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89886>>>>>>>>>>>>>>>>>    End
89886>>>>>>>>>>>>>>>>>>
89886>>>>>>>>>>>>>>>>>    Else Begin
89887>>>>>>>>>>>>>>>>>        Move C_$MessageBoxWarning to mb.sTitle
89888>>>>>>>>>>>>>>>>>    End
89888>>>>>>>>>>>>>>>>>>
89888>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89890>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89891>>>>>>>>>>>>>>>>>    End
89891>>>>>>>>>>>>>>>>>>
89891>>>>>>>>>>>>>>>>>    Get mbOkButton of (oMessageBox(Self)) to mb.Button[0]
89892>>>>>>>>>>>>>>>>>    Get mbCancelButton of (oMessageBox(Self)) to mb.Button[1]
89893>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89894>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89895>>>>>>>>>>>>>>>>>End_Function
89896>>>>>>>>>>>>>>>>>
89896>>>>>>>>>>>>>>>>>Function YesNoBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns Integer
89899>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89899>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89899>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89900>>>>>>>>>>>>>>>>>    Get mbYesButton of (oMessageBox(Self)) to mb.Button[0]
89901>>>>>>>>>>>>>>>>>    Get mbNoButton of (oMessageBox(Self)) to mb.Button[1]
89902>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89904>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89905>>>>>>>>>>>>>>>>>    End
89905>>>>>>>>>>>>>>>>>>
89905>>>>>>>>>>>>>>>>>    Else Begin
89906>>>>>>>>>>>>>>>>>        Move C_$MessageBoxQuestion to mb.sTitle
89907>>>>>>>>>>>>>>>>>    End
89907>>>>>>>>>>>>>>>>>>
89907>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89909>>>>>>>>>>>>>>>>>        If ((iDefButton iand MB_ICONMASK)<>0) Begin
89911>>>>>>>>>>>>>>>>>            Get IconBitmap of (oMessageBox(Self)) (iDefButton iand MB_ICONMASK) to mb.sBitmap
89912>>>>>>>>>>>>>>>>>        End
89912>>>>>>>>>>>>>>>>>>
89912>>>>>>>>>>>>>>>>>        Else Begin
89913>>>>>>>>>>>>>>>>>            Move "question256.bmp/3d" to mb.sBitmap
89914>>>>>>>>>>>>>>>>>        End
89914>>>>>>>>>>>>>>>>>>
89914>>>>>>>>>>>>>>>>>        Move (iDefButton iand MB_DEFBUTTONMASK) to iDefButton
89915>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON1) to mb.Button[0].bDefault
89916>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON2) to mb.Button[1].bDefault
89917>>>>>>>>>>>>>>>>>    End
89917>>>>>>>>>>>>>>>>>>
89917>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89919>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89920>>>>>>>>>>>>>>>>>    End
89920>>>>>>>>>>>>>>>>>>
89920>>>>>>>>>>>>>>>>>    If (num_arguments>=5) Begin
89922>>>>>>>>>>>>>>>>>        Move sCheckbox to mb.Message[1].sMessage
89923>>>>>>>>>>>>>>>>>        Move True to mb.Message[1].bCheckbox
89924>>>>>>>>>>>>>>>>>        If (num_arguments>=6) Begin
89926>>>>>>>>>>>>>>>>>            Move bChecked to mb.Message[1].bChecked
89927>>>>>>>>>>>>>>>>>        End
89927>>>>>>>>>>>>>>>>>>
89927>>>>>>>>>>>>>>>>>    End
89927>>>>>>>>>>>>>>>>>>
89927>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89928>>>>>>>>>>>>>>>>>    If (num_arguments>=5 and mb.Message[1].bChecked) Begin
89930>>>>>>>>>>>>>>>>>        Move (MBR_CHECKED ior mb.iRetVal) to mb.iRetVal
89931>>>>>>>>>>>>>>>>>    End
89931>>>>>>>>>>>>>>>>>>
89931>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89932>>>>>>>>>>>>>>>>>End_Function
89933>>>>>>>>>>>>>>>>>
89933>>>>>>>>>>>>>>>>>Function mbYesNoCancelBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns tmbMessageBox
89936>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89936>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89936>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89937>>>>>>>>>>>>>>>>>    Get mbYesButton of (oMessageBox(Self)) to mb.Button[0]
89938>>>>>>>>>>>>>>>>>    Get mbNoButton of (oMessageBox(Self)) to mb.Button[1]
89939>>>>>>>>>>>>>>>>>    Get mbCancelButton of (oMessageBox(Self)) to mb.Button[2]
89940>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
89942>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
89943>>>>>>>>>>>>>>>>>    End
89943>>>>>>>>>>>>>>>>>>
89943>>>>>>>>>>>>>>>>>    Else Begin
89944>>>>>>>>>>>>>>>>>        Move C_$MessageBoxQuestion to mb.sTitle
89945>>>>>>>>>>>>>>>>>    End
89945>>>>>>>>>>>>>>>>>>
89945>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
89947>>>>>>>>>>>>>>>>>        If ((iDefButton iand MB_ICONMASK)<>0) Begin
89949>>>>>>>>>>>>>>>>>            Get IconBitmap of (oMessageBox(Self)) (iDefButton iand MB_ICONMASK) to mb.sBitmap
89950>>>>>>>>>>>>>>>>>        End
89950>>>>>>>>>>>>>>>>>>
89950>>>>>>>>>>>>>>>>>        Else Begin
89951>>>>>>>>>>>>>>>>>            Move "question256.bmp/3d" to mb.sBitmap
89952>>>>>>>>>>>>>>>>>        End
89952>>>>>>>>>>>>>>>>>>
89952>>>>>>>>>>>>>>>>>        Move (iDefButton iand MB_DEFBUTTONMASK) to iDefButton
89953>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON1) to mb.Button[0].bDefault
89954>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON2) to mb.Button[1].bDefault
89955>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON3) to mb.Button[2].bDefault
89956>>>>>>>>>>>>>>>>>    End
89956>>>>>>>>>>>>>>>>>>
89956>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
89958>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
89959>>>>>>>>>>>>>>>>>    End
89959>>>>>>>>>>>>>>>>>>
89959>>>>>>>>>>>>>>>>>    If (num_arguments>=5) Begin
89961>>>>>>>>>>>>>>>>>        Move sCheckbox to mb.Message[1].sMessage
89962>>>>>>>>>>>>>>>>>        Move True to mb.Message[1].bCheckbox
89963>>>>>>>>>>>>>>>>>        If (num_arguments>=6) Begin
89965>>>>>>>>>>>>>>>>>            Move bChecked to mb.Message[1].bChecked
89966>>>>>>>>>>>>>>>>>        End
89966>>>>>>>>>>>>>>>>>>
89966>>>>>>>>>>>>>>>>>    End
89966>>>>>>>>>>>>>>>>>>
89966>>>>>>>>>>>>>>>>>    Function_Return mb
89967>>>>>>>>>>>>>>>>>End_Function
89968>>>>>>>>>>>>>>>>>
89968>>>>>>>>>>>>>>>>>Function YesNoCancelBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns Integer
89971>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89971>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89971>>>>>>>>>>>>>>>>>
89971>>>>>>>>>>>>>>>>>    If (num_arguments=2) Begin
89973>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel to mb
89974>>>>>>>>>>>>>>>>>    End
89974>>>>>>>>>>>>>>>>>>
89974>>>>>>>>>>>>>>>>>    If (num_arguments=3) Begin
89976>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton to mb
89977>>>>>>>>>>>>>>>>>    End
89977>>>>>>>>>>>>>>>>>>
89977>>>>>>>>>>>>>>>>>    If (num_arguments=4) Begin
89979>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton iHelp to mb
89980>>>>>>>>>>>>>>>>>    End
89980>>>>>>>>>>>>>>>>>>
89980>>>>>>>>>>>>>>>>>    If (num_arguments=5) Begin
89982>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton iHelp sCheckbox False to mb
89983>>>>>>>>>>>>>>>>>    End
89983>>>>>>>>>>>>>>>>>>
89983>>>>>>>>>>>>>>>>>    If (num_arguments=6) Begin
89985>>>>>>>>>>>>>>>>>        Get mbYesNoCancelBox sText sLabel iDefButton iHelp sCheckbox bChecked to mb
89986>>>>>>>>>>>>>>>>>    End
89986>>>>>>>>>>>>>>>>>>
89986>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
89987>>>>>>>>>>>>>>>>>    If (num_arguments>=5 and mb.Message[1].bChecked) Begin
89989>>>>>>>>>>>>>>>>>        Move (MBR_CHECKED ior mb.iRetVal) to mb.iRetVal
89990>>>>>>>>>>>>>>>>>    End
89990>>>>>>>>>>>>>>>>>>
89990>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
89991>>>>>>>>>>>>>>>>>End_Function
89992>>>>>>>>>>>>>>>>>
89992>>>>>>>>>>>>>>>>>Function AbortRetryIgnoreBox String sText String sLabel Integer iDefButton Integer iHelp String sCheckbox Boolean bChecked Returns Integer
89995>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89995>>>>>>>>>>>>>>>>>    tmbMessageBox mb
89995>>>>>>>>>>>>>>>>>    Move sText to mb.Message[0].sMessage
89996>>>>>>>>>>>>>>>>>    Get mbAbortButton of (oMessageBox(Self)) to mb.Button[0]
89997>>>>>>>>>>>>>>>>>    Get mbRetryButton of (oMessageBox(Self)) to mb.Button[1]
89998>>>>>>>>>>>>>>>>>    Get mbIgnoreButton of (oMessageBox(Self)) to mb.Button[2]
89999>>>>>>>>>>>>>>>>>    If (num_arguments>=2) Begin
90001>>>>>>>>>>>>>>>>>        Move sLabel to mb.sTitle
90002>>>>>>>>>>>>>>>>>    End
90002>>>>>>>>>>>>>>>>>>
90002>>>>>>>>>>>>>>>>>    Else Begin
90003>>>>>>>>>>>>>>>>>        Move C_$MessageBoxProblem to mb.sTitle
90004>>>>>>>>>>>>>>>>>    End
90004>>>>>>>>>>>>>>>>>>
90004>>>>>>>>>>>>>>>>>    If (num_arguments>=3) Begin
90006>>>>>>>>>>>>>>>>>        If ((iDefButton iand MB_ICONMASK)<>0) Begin
90008>>>>>>>>>>>>>>>>>            Get IconBitmap of (oMessageBox(Self)) (iDefButton iand MB_ICONMASK) to mb.sBitmap
90009>>>>>>>>>>>>>>>>>        End
90009>>>>>>>>>>>>>>>>>>
90009>>>>>>>>>>>>>>>>>        Else Begin
90010>>>>>>>>>>>>>>>>>            Move "warning256.bmp/3d" to mb.sBitmap
90011>>>>>>>>>>>>>>>>>        End
90011>>>>>>>>>>>>>>>>>>
90011>>>>>>>>>>>>>>>>>        Move (iDefButton iand MB_DEFBUTTONMASK) to iDefButton
90012>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON1) to mb.Button[0].bDefault
90013>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON2) to mb.Button[1].bDefault
90014>>>>>>>>>>>>>>>>>        Move (iDefButton=MB_DEFBUTTON3) to mb.Button[2].bDefault
90015>>>>>>>>>>>>>>>>>    End
90015>>>>>>>>>>>>>>>>>>
90015>>>>>>>>>>>>>>>>>    If (num_arguments>=4) Begin
90017>>>>>>>>>>>>>>>>>        Move iHelp to mb.iHelp
90018>>>>>>>>>>>>>>>>>    End
90018>>>>>>>>>>>>>>>>>>
90018>>>>>>>>>>>>>>>>>    If (num_arguments>=5) Begin
90020>>>>>>>>>>>>>>>>>        Move sCheckbox to mb.Message[1].sMessage
90021>>>>>>>>>>>>>>>>>        Move True to mb.Message[1].bCheckbox
90022>>>>>>>>>>>>>>>>>        If (num_arguments>=6) Begin
90024>>>>>>>>>>>>>>>>>            Move bChecked to mb.Message[1].bChecked
90025>>>>>>>>>>>>>>>>>        End
90025>>>>>>>>>>>>>>>>>>
90025>>>>>>>>>>>>>>>>>    End
90025>>>>>>>>>>>>>>>>>>
90025>>>>>>>>>>>>>>>>>    Send ShowMessageBox to (oMessageBox(Self)) (&mb)
90026>>>>>>>>>>>>>>>>>    If (num_arguments>=5 and mb.Message[1].bChecked) Begin
90028>>>>>>>>>>>>>>>>>        Move (MBR_CHECKED ior mb.iRetVal) to mb.iRetVal
90029>>>>>>>>>>>>>>>>>    End
90029>>>>>>>>>>>>>>>>>>
90029>>>>>>>>>>>>>>>>>    Function_Return mb.iRetVal
90030>>>>>>>>>>>>>>>>>End_Function
90031>>>>>>>>>>>>>>>
90031>>>>>>>>>>>>>>>Struct tRefactorResponse
90031>>>>>>>>>>>>>>>  String sObject
90031>>>>>>>>>>>>>>>  Integer eResponse
90031>>>>>>>>>>>>>>>  Boolean bPadded
90031>>>>>>>>>>>>>>>End_Struct
90031>>>>>>>>>>>>>>>
90031>>>>>>>>>>>>>>>Enum_List
90031>>>>>>>>>>>>>>>  Define CI_NoCaseStatement  For 0
90031>>>>>>>>>>>>>>>  Define CI_CaseBegin
90031>>>>>>>>>>>>>>>  Define CI_CaseCondition
90031>>>>>>>>>>>>>>>  Define CI_CaseBreak
90031>>>>>>>>>>>>>>>  Define CI_CaseEnd
90031>>>>>>>>>>>>>>>End_Enum_List
90031>>>>>>>>>>>>>>>
90031>>>>>>>>>>>>>>>Class cSciLexerRefactor Is a cSciLexer
90032>>>>>>>>>>>>>>>  Procedure Construct_Object
90034>>>>>>>>>>>>>>>    Forward Send Construct_Object
90036>>>>>>>>>>>>>>>    Property Boolean pbRefactorPadReplaceString    True
90037>>>>>>>>>>>>>>>    Property Boolean pbIndentCaseBreak             True // Indent on "case break", set to false if you don't want that.
90038>>>>>>>>>>>>>>>    Property tRefactorResponse[] pRefactorResponse      // Remember the refactoring response per object
90039>>>>>>>>>>>>>>>  End_Procedure
90040>>>>>>>>>>>>>>>
90040>>>>>>>>>>>>>>>  Function RefactorReplaceObjectConfirmation Integer iLine String sFind String sReplace Boolean bPadded Boolean bRemember Returns Integer
90042>>>>>>>>>>>>>>>    Integer eResponse
90042>>>>>>>>>>>>>>>    String  szAnnotate
90042>>>>>>>>>>>>>>>    String  sCheckbox1
90042>>>>>>>>>>>>>>>    String  sCheckbox2
90042>>>>>>>>>>>>>>>    tmbMessageBox mb
90042>>>>>>>>>>>>>>>    tmbMessageBox mb
90042>>>>>>>>>>>>>>>
90042>>>>>>>>>>>>>>>    Move ("Do you want to replace '"+sFind+"' with '"+sReplace+"' ?") To szAnnotate
90043>>>>>>>>>>>>>>>    Send GotoLine iLine
90044>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETSTYLE iLine STYLE_CALLTIP
90045>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETTEXT  iLine (AddressOf(szAnnotate))
90046>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETVISIBLE ANNOTATION_BOXED
90047>>>>>>>>>>>>>>>    Move "Keep same width padded with spaces"  To sCheckbox1
90048>>>>>>>>>>>>>>>    Move "Remember the choice for this object" To sCheckbox2
90049>>>>>>>>>>>>>>>    Get mbYesNoCancelBox "Change into suggestion?" "Question" MB_DEFBUTTON2 0 sCheckbox1 bPadded To mb
90050>>>>>>>>>>>>>>>    Move sCheckbox2 To mb.Message[2].sMessage
90051>>>>>>>>>>>>>>>    Move True       To mb.Message[2].bCheckbox
90052>>>>>>>>>>>>>>>    Move bRemember  To mb.Message[2].bChecked
90053>>>>>>>>>>>>>>>    Send ShowMessageBox (&mb)
90054>>>>>>>>>>>>>>>    Move (mb.iRetVal ior If(mb.message[1].bchecked,MBR_CHECKED,0))  To mb.iRetVal
90055>>>>>>>>>>>>>>>    Move (mb.iRetVal ior If(mb.message[2].bchecked,MBR_CHECKED2,0)) To mb.iRetVal
90056>>>>>>>>>>>>>>>    Move  mb.iRetVal To eResponse
90057>>>>>>>>>>>>>>>    Move "" To szAnnotate
90058>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETTEXT iLine (AddressOf(szAnnotate))
90059>>>>>>>>>>>>>>>    Send EditorMessage SCI_ANNOTATIONSETVISIBLE ANNOTATION_HIDDEN
90060>>>>>>>>>>>>>>>    Function_Return eResponse
90061>>>>>>>>>>>>>>>  End_Function
90062>>>>>>>>>>>>>>>
90062>>>>>>>>>>>>>>>  //
90062>>>>>>>>>>>>>>>  // Sometimes we already know that we do not have to offer a replacement
90062>>>>>>>>>>>>>>>  //
90062>>>>>>>>>>>>>>>  Function IsDropSelfReplaceTargetValid String sReplace Returns Boolean
90064>>>>>>>>>>>>>>>    Boolean bIsValid
90064>>>>>>>>>>>>>>>
90064>>>>>>>>>>>>>>>    Move True To bIsValid
90065>>>>>>>>>>>>>>>    Move (Lowercase(sReplace)) To sReplace
90066>>>>>>>>>>>>>>>    If (sReplace = "parent") Begin
90068>>>>>>>>>>>>>>>      Move False To bIsValid
90069>>>>>>>>>>>>>>>    End
90069>>>>>>>>>>>>>>>>
90069>>>>>>>>>>>>>>>
90069>>>>>>>>>>>>>>>    Function_Return bIsValid
90070>>>>>>>>>>>>>>>  End_Function
90071>>>>>>>>>>>>>>>
90071>>>>>>>>>>>>>>>  Procedure RefactorLocateSourceObject String sLine Integer iPos Integer iLength Integer ByRef iPosStart Integer ByRef iPosEnd Integer ByRef iLevel
90073>>>>>>>>>>>>>>>    Integer iNext
90073>>>>>>>>>>>>>>>    String  sChar
90073>>>>>>>>>>>>>>>
90073>>>>>>>>>>>>>>>    Move (Pos("(",sLine,iPosStart+4)) To iPosStart // search for ( after " to " (or for functions after " of "
90074>>>>>>>>>>>>>>>    Move (Pos(")",sLine,iPosStart)) To iPosEnd     // find first close quote
90075>>>>>>>>>>>>>>>    If (iPos>=iPosStart and iPos<iPosEnd) Begin    // check what is between the quotes
90077>>>>>>>>>>>>>>>      // found one!
90077>>>>>>>>>>>>>>>      Move 0 To iLevel
90078>>>>>>>>>>>>>>>      Move iPosEnd To iNext
90079>>>>>>>>>>>>>>>      Move (Mid(sLine,1,iNext)) To sChar
90080>>>>>>>>>>>>>>>      While (iNext<=iLength and (sChar=" " or sChar=")" or sChar=Character(9)))
90084>>>>>>>>>>>>>>>        If (sChar=")") Begin
90086>>>>>>>>>>>>>>>          Move iNext To iPosEnd
90087>>>>>>>>>>>>>>>          Increment iLevel
90088>>>>>>>>>>>>>>>        End
90088>>>>>>>>>>>>>>>>
90088>>>>>>>>>>>>>>>        Increment iNext
90089>>>>>>>>>>>>>>>        Move (Mid(sLine,1,iNext)) To sChar
90090>>>>>>>>>>>>>>>      Loop
90091>>>>>>>>>>>>>>>>
90091>>>>>>>>>>>>>>>    End
90091>>>>>>>>>>>>>>>>
90091>>>>>>>>>>>>>>>  End_Procedure
90092>>>>>>>>>>>>>>>
90092>>>>>>>>>>>>>>>  //
90092>>>>>>>>>>>>>>>  // The refactoring dialog lets you remember the response per object.
90092>>>>>>>>>>>>>>>  // This function tests for your object if it already has an autoresponse.
90092>>>>>>>>>>>>>>>  //
90092>>>>>>>>>>>>>>>  Function RefactorObjectAutoResponse String sObject Returns Integer
90094>>>>>>>>>>>>>>>    Integer iItem
90094>>>>>>>>>>>>>>>    Integer iCount
90094>>>>>>>>>>>>>>>    Integer eResponse
90094>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
90094>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
90095>>>>>>>>>>>>>>>
90095>>>>>>>>>>>>>>>    Move 0 To eResponse
90096>>>>>>>>>>>>>>>    Move (lowercase(sObject)) To sObject
90097>>>>>>>>>>>>>>>    Get pRefactorResponse To RefactorResponse
90098>>>>>>>>>>>>>>>    Move (Sizeofarray(RefactorResponse)) To iCount
90099>>>>>>>>>>>>>>>    For iItem From 0 To (iCount-1)
90105>>>>>>>>>>>>>>>>
90105>>>>>>>>>>>>>>>      If (RefactorResponse[iItem].sObject=sObject) Begin
90107>>>>>>>>>>>>>>>        Move RefactorResponse[iItem].eResponse To eResponse
90108>>>>>>>>>>>>>>>        If (RefactorResponse[iItem].bPadded) Begin
90110>>>>>>>>>>>>>>>          Move (eResponse ior MBR_CHECKED) To eResponse
90111>>>>>>>>>>>>>>>        End
90111>>>>>>>>>>>>>>>>
90111>>>>>>>>>>>>>>>        Move iCount To iItem // done
90112>>>>>>>>>>>>>>>      End
90112>>>>>>>>>>>>>>>>
90112>>>>>>>>>>>>>>>    Loop
90113>>>>>>>>>>>>>>>>
90113>>>>>>>>>>>>>>>    Function_Return eResponse
90114>>>>>>>>>>>>>>>  End_Function
90115>>>>>>>>>>>>>>>
90115>>>>>>>>>>>>>>>  Procedure AddObjectToRefactorAutoResponse String sObject Integer eResponse Boolean bPadded
90117>>>>>>>>>>>>>>>    Integer iCount
90117>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
90117>>>>>>>>>>>>>>>    tRefactorResponse[] RefactorResponse
90118>>>>>>>>>>>>>>>
90118>>>>>>>>>>>>>>>    Get pRefactorResponse To RefactorResponse
90119>>>>>>>>>>>>>>>    Move (Sizeofarray(RefactorResponse)) To iCount
90120>>>>>>>>>>>>>>>    Move (lowercase(sObject)) To RefactorResponse[iCount].sObject
90121>>>>>>>>>>>>>>>    Move eResponse            To RefactorResponse[iCount].eResponse
90122>>>>>>>>>>>>>>>    Move bPadded              To RefactorResponse[iCount].bPadded
90123>>>>>>>>>>>>>>>    Set pRefactorResponse To RefactorResponse
90124>>>>>>>>>>>>>>>  End_Procedure
90125>>>>>>>>>>>>>>>
90125>>>>>>>>>>>>>>>  Procedure ClearRefactorAutoResponse
90127>>>>>>>>>>>>>>>    tRefactorResponse[] AutoResponse
90127>>>>>>>>>>>>>>>    tRefactorResponse[] AutoResponse
90128>>>>>>>>>>>>>>>    Move (ResizeArray(AutoResponse,0)) To AutoResponse
90129>>>>>>>>>>>>>>>    Set pRefactorResponse To AutoResponse
90130>>>>>>>>>>>>>>>  End_Procedure
90131>>>>>>>>>>>>>>>
90131>>>>>>>>>>>>>>>  Procedure WipeUntilPosition Integer iPos String ByRef sLine
90133>>>>>>>>>>>>>>>    Integer iChar
90133>>>>>>>>>>>>>>>    If (iPos>0) Begin
90135>>>>>>>>>>>>>>>      For iChar From 1 To (iPos-1)
90141>>>>>>>>>>>>>>>>
90141>>>>>>>>>>>>>>>        Move (Overstrike(" ",sLine,iChar)) To sLine
90142>>>>>>>>>>>>>>>      Loop
90143>>>>>>>>>>>>>>>>
90143>>>>>>>>>>>>>>>    End
90143>>>>>>>>>>>>>>>>
90143>>>>>>>>>>>>>>>  End_Procedure
90144>>>>>>>>>>>>>>>
90144>>>>>>>>>>>>>>>  //
90144>>>>>>>>>>>>>>>  // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
90144>>>>>>>>>>>>>>>  // send/get/set as the first string and that complicates our detection.
90144>>>>>>>>>>>>>>>  // What this does is simply overwrite everything with spaces before our methods if
90144>>>>>>>>>>>>>>>  // we have such a compound statement.
90144>>>>>>>>>>>>>>>  // The variable sLine is not always lowercase.
90144>>>>>>>>>>>>>>>  //
90144>>>>>>>>>>>>>>>  Procedure ClearFirstCompoundBeforeMethod String ByRef sLine
90146>>>>>>>>>>>>>>>    Integer iPos
90146>>>>>>>>>>>>>>>    String  sLtrimLine
90146>>>>>>>>>>>>>>>
90146>>>>>>>>>>>>>>>    Move (lowercase(LTrim(sLine))) To sLTrimLine
90147>>>>>>>>>>>>>>>    If (Left(sLtrimLine,3)="if " or Left(sLtrimLine,5)="else " or Left(sLtrimLine,7)="on_key ") Begin
90149>>>>>>>>>>>>>>>      // a line that starts with an if or else can still call a method
90149>>>>>>>>>>>>>>>      Move (Pos("send ",lowercase(sLine))) To iPos
90150>>>>>>>>>>>>>>>      If (iPos=0) ;        Move (Pos("get ",lowercase(sLine))) To iPos
90153>>>>>>>>>>>>>>>      If (iPos=0) ;        Move (Pos("set ",lowercase(sLine))) To iPos
90156>>>>>>>>>>>>>>>      Send WipeUntilPosition iPos (&sLine)
90157>>>>>>>>>>>>>>>    End
90157>>>>>>>>>>>>>>>>
90157>>>>>>>>>>>>>>>  End_Procedure
90158>>>>>>>>>>>>>>>
90158>>>>>>>>>>>>>>>  Procedure RefactorDropSelf
90160>>>>>>>>>>>>>>>    Boolean bAutoResponse
90160>>>>>>>>>>>>>>>    Boolean bSuggestReplace
90160>>>>>>>>>>>>>>>    Boolean bPadded
90160>>>>>>>>>>>>>>>    Boolean bRemember
90160>>>>>>>>>>>>>>>    Boolean bCanceled
90160>>>>>>>>>>>>>>>    Integer iPos
90160>>>>>>>>>>>>>>>    Integer iPosStart
90160>>>>>>>>>>>>>>>    Integer iPosEnd
90160>>>>>>>>>>>>>>>    Integer iLevel
90160>>>>>>>>>>>>>>>    Integer iStartLine
90160>>>>>>>>>>>>>>>    Integer iLine
90160>>>>>>>>>>>>>>>    Integer iLineCount
90160>>>>>>>>>>>>>>>    Integer iLength
90160>>>>>>>>>>>>>>>    Integer eResponse
90160>>>>>>>>>>>>>>>    String  sLine
90160>>>>>>>>>>>>>>>    String  sFind
90160>>>>>>>>>>>>>>>    String  sReplace
90160>>>>>>>>>>>>>>>    String  sPad
90160>>>>>>>>>>>>>>>
90160>>>>>>>>>>>>>>>    Move False To bCanceled
90161>>>>>>>>>>>>>>>    Send ClearRefactorAutoResponse
90162>>>>>>>>>>>>>>>    Get pbRefactorPadReplaceString To bPadded
90163>>>>>>>>>>>>>>>    Get CurrentLine To iStartLine
90164>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
90165>>>>>>>>>>>>>>>    For iLine From iStartLine To iLineCount
90171>>>>>>>>>>>>>>>>
90171>>>>>>>>>>>>>>>      Move False To bSuggestReplace
90172>>>>>>>>>>>>>>>      Get PreParsedLine iLine To sLine
90173>>>>>>>>>>>>>>>      Move (Lowercase(sLine)) To sLine
90174>>>>>>>>>>>>>>>      Move (Pos("(self)",sLine)) To iPos
90175>>>>>>>>>>>>>>>      If (iPos>0) Begin
90177>>>>>>>>>>>>>>>        Send ClearFirstCompoundBeforeMethod (&sLine)
90178>>>>>>>>>>>>>>>        Move (Pos("(self)",sLine)) To iPos
90179>>>>>>>>>>>>>>>      End
90179>>>>>>>>>>>>>>>>
90179>>>>>>>>>>>>>>>      If (iPos>0) Begin // only check if there's a self in the line
90181>>>>>>>>>>>>>>>        If (Left(LTrim(sLine),5)="send ") Begin
90183>>>>>>>>>>>>>>>          Move (Pos(" to ",sLine)) To iPosStart
90184>>>>>>>>>>>>>>>          If (iPosStart=0) ;            Move (Pos(" of ",sLine)) To iPosStart
90187>>>>>>>>>>>>>>>          If (iPosStart<>0) Begin
90189>>>>>>>>>>>>>>>            Move (Length(sLine)) To iLength
90190>>>>>>>>>>>>>>>            Send RefactorLocateSourceObject sLine iPos iLength (&iPosStart) (&iPosEnd) (&iLevel)
90191>>>>>>>>>>>>>>>            Get Value iLine To sLine // real line data
90192>>>>>>>>>>>>>>>            Move (Mid(sLine,iPosEnd-iPosStart+1,iPosStart)) To sFind
90193>>>>>>>>>>>>>>>            Move sFind To sReplace
90194>>>>>>>>>>>>>>>            If (iLevel=2) Begin // not supporting multiple levels atm
90196>>>>>>>>>>>>>>>              Move (Left(sReplace,RightPos("(",sReplace)-1)) To sReplace
90197>>>>>>>>>>>>>>>              Move (Replace("(",sReplace,"")) To sReplace
90198>>>>>>>>>>>>>>>            End
90198>>>>>>>>>>>>>>>>
90198>>>>>>>>>>>>>>>            If (iLevel=2) Begin
90200>>>>>>>>>>>>>>>              Get IsDropSelfReplaceTargetValid sReplace To bSuggestReplace
90201>>>>>>>>>>>>>>>            End
90201>>>>>>>>>>>>>>>>
90201>>>>>>>>>>>>>>>          End
90201>>>>>>>>>>>>>>>>
90201>>>>>>>>>>>>>>>        End
90201>>>>>>>>>>>>>>>>
90201>>>>>>>>>>>>>>>        If (Left(LTrim(sLine),4)="get " or Left(LTrim(sLine),4)="set ") Begin
90203>>>>>>>>>>>>>>>          Move (Pos(" of ",sLine)) To iPosStart
90204>>>>>>>>>>>>>>>          If (iPosStart<>0) Begin
90206>>>>>>>>>>>>>>>            Move (Pos(" to ",sLine)) To iLength // don't search past the " to " bit
90207>>>>>>>>>>>>>>>            Send RefactorLocateSourceObject sLine iPos iLength (&iPosStart) (&iPosEnd) (&iLevel)
90208>>>>>>>>>>>>>>>            Get Value iLine To sLine // real line data
90209>>>>>>>>>>>>>>>            Move (Mid(sLine,iPosEnd-iPosStart+1,iPosStart)) To sFind
90210>>>>>>>>>>>>>>>            Move sFind To sReplace
90211>>>>>>>>>>>>>>>            If (iLevel=2) Begin // not supporting multiple levels atm
90213>>>>>>>>>>>>>>>              Move (Left(sReplace,RightPos("(",sReplace)-1)) To sReplace
90214>>>>>>>>>>>>>>>              Move (Replace("(",sReplace,"")) To sReplace
90215>>>>>>>>>>>>>>>            End
90215>>>>>>>>>>>>>>>>
90215>>>>>>>>>>>>>>>            If (iLevel=2) Begin
90217>>>>>>>>>>>>>>>              Get IsDropSelfReplaceTargetValid sReplace To bSuggestReplace
90218>>>>>>>>>>>>>>>            End
90218>>>>>>>>>>>>>>>>
90218>>>>>>>>>>>>>>>          End
90218>>>>>>>>>>>>>>>>
90218>>>>>>>>>>>>>>>        End
90218>>>>>>>>>>>>>>>>
90218>>>>>>>>>>>>>>>        If (bSuggestReplace) Begin
90220>>>>>>>>>>>>>>>          Move False To bAutoResponse
90221>>>>>>>>>>>>>>>          Get RefactorObjectAutoResponse sFind To eResponse
90222>>>>>>>>>>>>>>>          If (eResponse=0) Begin
90224>>>>>>>>>>>>>>>            Get RefactorReplaceObjectConfirmation iLine sFind sReplace bPadded bRemember To eResponse
90225>>>>>>>>>>>>>>>          End
90225>>>>>>>>>>>>>>>>
90225>>>>>>>>>>>>>>>          Else Begin
90226>>>>>>>>>>>>>>>            Move True To bAutoResponse
90227>>>>>>>>>>>>>>>          End
90227>>>>>>>>>>>>>>>>
90227>>>>>>>>>>>>>>>          If (IsFlagIn(MBR_CHECKED,eResponse)) Begin
90229>>>>>>>>>>>>>>>            Move True To bPadded
90230>>>>>>>>>>>>>>>            Move (eResponse-MBR_CHECKED) To eResponse
90231>>>>>>>>>>>>>>>          End
90231>>>>>>>>>>>>>>>>
90231>>>>>>>>>>>>>>>          Else Begin
90232>>>>>>>>>>>>>>>            Move False To bPadded
90233>>>>>>>>>>>>>>>          End
90233>>>>>>>>>>>>>>>>
90233>>>>>>>>>>>>>>>          If (IsFlagIn(MBR_CHECKED2,eResponse)) Begin
90235>>>>>>>>>>>>>>>            Move (eResponse-MBR_CHECKED2) To eResponse
90236>>>>>>>>>>>>>>>            Send AddObjectToRefactorAutoResponse sFind eResponse bPadded
90237>>>>>>>>>>>>>>>            Move True To bRemember
90238>>>>>>>>>>>>>>>          End
90238>>>>>>>>>>>>>>>>
90238>>>>>>>>>>>>>>>          Else If (not(bAutoResponse)) Begin
90241>>>>>>>>>>>>>>>            Move False To bRemember
90242>>>>>>>>>>>>>>>          End
90242>>>>>>>>>>>>>>>>
90242>>>>>>>>>>>>>>>
90242>>>>>>>>>>>>>>>          If (eResponse=MBR_Cancel) Begin
90244>>>>>>>>>>>>>>>            Move True To bCanceled
90245>>>>>>>>>>>>>>>            Move iLineCount To iLine
90246>>>>>>>>>>>>>>>          End
90246>>>>>>>>>>>>>>>>
90246>>>>>>>>>>>>>>>          Else If (eResponse=MBR_Yes) Begin
90249>>>>>>>>>>>>>>>            Set pbRefactorPadReplaceString To bPadded
90250>>>>>>>>>>>>>>>            If (bPadded) ;              Move "        " To sPad // the 8 spaces are so that you do not have to re-align your code manually
90253>>>>>>>>>>>>>>>            Else ;              Move ""         To sPad
90255>>>>>>>>>>>>>>>            Move (Replace(sFind,sLine,sReplace+sPad)) To sLine
90256>>>>>>>>>>>>>>>            Send EditorMessage SCI_BEGINUNDOACTION
90257>>>>>>>>>>>>>>>            Set Value iLine To sLine
90258>>>>>>>>>>>>>>>            Send EditorMessage SCI_ENDUNDOACTION
90259>>>>>>>>>>>>>>>          End
90259>>>>>>>>>>>>>>>>
90259>>>>>>>>>>>>>>>        End
90259>>>>>>>>>>>>>>>>
90259>>>>>>>>>>>>>>>      End
90259>>>>>>>>>>>>>>>>
90259>>>>>>>>>>>>>>>    Loop
90260>>>>>>>>>>>>>>>>
90260>>>>>>>>>>>>>>>    If (bSuggestReplace=false and bCanceled=false) Begin
90262>>>>>>>>>>>>>>>      Set Status_Help To (_T("Drop Self: No more occurrences have been found.",1606))
90263>>>>>>>>>>>>>>>      Send Request_Status_Help True
90264>>>>>>>>>>>>>>>    End
90264>>>>>>>>>>>>>>>>
90264>>>>>>>>>>>>>>>  End_Procedure
90265>>>>>>>>>>>>>>>
90265>>>>>>>>>>>>>>>  //
90265>>>>>>>>>>>>>>>  // Process the whole file and adjust the case of all scope and keywords to match the casing
90265>>>>>>>>>>>>>>>  // as defined in the language configuration.
90265>>>>>>>>>>>>>>>  //
90265>>>>>>>>>>>>>>>  Procedure RefactorNormalizeCase
90267>>>>>>>>>>>>>>>    Boolean bChanged
90267>>>>>>>>>>>>>>>    Integer iCurrentLine
90267>>>>>>>>>>>>>>>    Integer iLine
90267>>>>>>>>>>>>>>>    Integer iLineCount
90267>>>>>>>>>>>>>>>    
90267>>>>>>>>>>>>>>>    Get CurrentLine  To iCurrentLine
90268>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
90269>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
90270>>>>>>>>>>>>>>>    Send GotoLine iLineCount
90271>>>>>>>>>>>>>>>    Send PumpMsgQueue Of Desktop
90272>>>>>>>>>>>>>>>    Send GotoLine 1
90273>>>>>>>>>>>>>>>    For iLine From 0 To (iLineCount-1)
90279>>>>>>>>>>>>>>>>
90279>>>>>>>>>>>>>>>      Get LineNormalizeCase iLine false To bChanged
90280>>>>>>>>>>>>>>>    Loop
90281>>>>>>>>>>>>>>>>
90281>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
90282>>>>>>>>>>>>>>>    Send GotoLine iCurrentLine
90283>>>>>>>>>>>>>>>  End_Procedure
90284>>>>>>>>>>>>>>>  
90284>>>>>>>>>>>>>>>  //
90284>>>>>>>>>>>>>>>  // For re-indenting we want to know if we are on a case statement
90284>>>>>>>>>>>>>>>  //
90284>>>>>>>>>>>>>>>  Function LineIsCaseStatement String sLine Returns Integer
90286>>>>>>>>>>>>>>>    Boolean bIsCase
90286>>>>>>>>>>>>>>>    Integer eCaseStatus
90286>>>>>>>>>>>>>>>    Integer iFirstChar
90286>>>>>>>>>>>>>>>
90286>>>>>>>>>>>>>>>    Move CI_NoCaseStatement To eCaseStatus
90287>>>>>>>>>>>>>>>    Move (Length(sLine)-Length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
90288>>>>>>>>>>>>>>>    If (lowercase(Mid(sLine,4,iFirstChar+1))="case") Begin
90290>>>>>>>>>>>>>>>      Move True To bIsCase
90291>>>>>>>>>>>>>>>    End
90291>>>>>>>>>>>>>>>>
90291>>>>>>>>>>>>>>>    If (bIsCase) Begin
90293>>>>>>>>>>>>>>>      Move (LTrim(lowercase(sLine))) To sLine
90294>>>>>>>>>>>>>>>      Move (Right(sLine,Length(sLine)-4))  To sLine
90295>>>>>>>>>>>>>>>      Move (LTrim(sLine)) To sLine
90296>>>>>>>>>>>>>>>      If (Left(sLine,5)="begin") Begin
90298>>>>>>>>>>>>>>>        Move CI_CaseBegin To eCaseStatus
90299>>>>>>>>>>>>>>>      End
90299>>>>>>>>>>>>>>>>
90299>>>>>>>>>>>>>>>      Else If (Left(sLine,5)="break") Begin
90302>>>>>>>>>>>>>>>        Move CI_CaseBreak To eCaseStatus
90303>>>>>>>>>>>>>>>      End
90303>>>>>>>>>>>>>>>>
90303>>>>>>>>>>>>>>>      Else If (Left(sLine,3)="end") Begin
90306>>>>>>>>>>>>>>>        Move CI_CaseEnd To eCaseStatus
90307>>>>>>>>>>>>>>>      End
90307>>>>>>>>>>>>>>>>
90307>>>>>>>>>>>>>>>      Else Begin
90308>>>>>>>>>>>>>>>        Move CI_CaseCondition To eCaseStatus
90309>>>>>>>>>>>>>>>      End
90309>>>>>>>>>>>>>>>>
90309>>>>>>>>>>>>>>>    End
90309>>>>>>>>>>>>>>>>
90309>>>>>>>>>>>>>>>    Function_Return eCaseStatus
90310>>>>>>>>>>>>>>>  End_Function
90311>>>>>>>>>>>>>>>
90311>>>>>>>>>>>>>>>  //
90311>>>>>>>>>>>>>>>  // If we have a single line if/else statement that has its compound statement
90311>>>>>>>>>>>>>>>  // broken up over multiple lines using a semicolumn then we want an indentation
90311>>>>>>>>>>>>>>>  // on the next line.
90311>>>>>>>>>>>>>>>  // iLine = line of source code
90311>>>>>>>>>>>>>>>  // sLine = content of line
90311>>>>>>>>>>>>>>>  // bIndentActive = if already indenting because of this rule then there might be another line
90311>>>>>>>>>>>>>>>  //                 that ends on a ; and thus also needs the indent.
90311>>>>>>>>>>>>>>>  //
90311>>>>>>>>>>>>>>>  Function LineIsSingleLineIfElseStatement Integer iLine String sLine Boolean bIndentActive Returns Boolean
90313>>>>>>>>>>>>>>>    Boolean bIsIfElse
90313>>>>>>>>>>>>>>>    Integer iFirstChar
90313>>>>>>>>>>>>>>>
90313>>>>>>>>>>>>>>>    Move False To bIsIfElse
90314>>>>>>>>>>>>>>>    Move (Length(sLine)-Length(LTrim(sLine))) To iFirstChar // first non white space character on line is at this pos
90315>>>>>>>>>>>>>>>    Move (RTrim(lowercase(sLine))) To sLine
90316>>>>>>>>>>>>>>>    If ((Mid(sLine,3,iFirstChar+1)="if ") or (Mid(sLine,5,iFirstChar+1)="else ") or (Mid(sLine,5,iFirstChar+1)="else;") or bIndentActive) Begin
90318>>>>>>>>>>>>>>>      Get PreParsedLine iLine To sLine // strip any comments if there are any
90319>>>>>>>>>>>>>>>      If (Right(sLine,1)=";") Begin
90321>>>>>>>>>>>>>>>        Move True To bIsIfElse
90322>>>>>>>>>>>>>>>      End
90322>>>>>>>>>>>>>>>>
90322>>>>>>>>>>>>>>>    End
90322>>>>>>>>>>>>>>>>
90322>>>>>>>>>>>>>>>    Function_Return bIsIfElse
90323>>>>>>>>>>>>>>>  End_Function
90324>>>>>>>>>>>>>>>  
90324>>>>>>>>>>>>>>>  //
90324>>>>>>>>>>>>>>>  // Function returns true if the line of code we are on define's a command macro.
90324>>>>>>>>>>>>>>>  // We do not want to change the indentation on a macro definition
90324>>>>>>>>>>>>>>>  //
90324>>>>>>>>>>>>>>>  Function LineIsCommandMacro Integer iLine String sLine Boolean bMacroCommandOpen Returns Boolean
90326>>>>>>>>>>>>>>>    Boolean bIsCommandMacro
90326>>>>>>>>>>>>>>>    Boolean bHasFoldPoint
90326>>>>>>>>>>>>>>>    
90326>>>>>>>>>>>>>>>    Move bMacroCommandOpen To bIsCommandMacro
90327>>>>>>>>>>>>>>>    Get LineHasFoldPoint iLine To bHasFoldPoint
90328>>>>>>>>>>>>>>>    If (bHasFoldPoint Or bMacroCommandOpen) Begin
90330>>>>>>>>>>>>>>>      Move (LTrim(sLine)) To sLine
90331>>>>>>>>>>>>>>>      If (Left(sLine,1)="#") Begin
90333>>>>>>>>>>>>>>>        Move (Uppercase(sLine)) To sLine
90334>>>>>>>>>>>>>>>        If (Left(sLine,9)="#COMMAND ") Begin
90336>>>>>>>>>>>>>>>          Move True To bIsCommandMacro
90337>>>>>>>>>>>>>>>        End
90337>>>>>>>>>>>>>>>>
90337>>>>>>>>>>>>>>>        Else If (Left(sLine,11)="#ENDCOMMAND") Begin
90340>>>>>>>>>>>>>>>          Move False To bIsCommandMacro
90341>>>>>>>>>>>>>>>        End
90341>>>>>>>>>>>>>>>>
90341>>>>>>>>>>>>>>>      End
90341>>>>>>>>>>>>>>>>
90341>>>>>>>>>>>>>>>    End
90341>>>>>>>>>>>>>>>>
90341>>>>>>>>>>>>>>>    Function_Return bIsCommandMacro
90342>>>>>>>>>>>>>>>  End_Function
90343>>>>>>>>>>>>>>>
90343>>>>>>>>>>>>>>>  Procedure RefactorReIndent
90345>>>>>>>>>>>>>>>    Boolean bUseTabs
90345>>>>>>>>>>>>>>>    Boolean bIsDfImage
90345>>>>>>>>>>>>>>>    Boolean bIsIfElse bIsIfElseIndent
90345>>>>>>>>>>>>>>>    Boolean bMacroCommandOpen
90345>>>>>>>>>>>>>>>    Integer eCaseStatus
90345>>>>>>>>>>>>>>>    Integer iCurrentLine
90345>>>>>>>>>>>>>>>    Integer iLine
90345>>>>>>>>>>>>>>>    Integer iLineCount
90345>>>>>>>>>>>>>>>    Integer iTabSize
90345>>>>>>>>>>>>>>>    Integer iCaseLevel
90345>>>>>>>>>>>>>>>    Integer iPrevLevel
90345>>>>>>>>>>>>>>>    String  sIndent
90345>>>>>>>>>>>>>>>    String  sTab sTabLevel
90345>>>>>>>>>>>>>>>    String  sLine
90345>>>>>>>>>>>>>>>    String  sLineSave
90345>>>>>>>>>>>>>>>    UChar[] ucaLine
90346>>>>>>>>>>>>>>>    Address aTextData
90346>>>>>>>>>>>>>>>    UChar[] TextData
90347>>>>>>>>>>>>>>>  
90347>>>>>>>>>>>>>>>    Move 0 To iCaseLevel
90348>>>>>>>>>>>>>>>    Move (ResizeArray(TextData,0)) To TextData
90349>>>>>>>>>>>>>>>    Move False To bIsIfElseIndent
90350>>>>>>>>>>>>>>>    Move False To bMacroCommandOpen
90351>>>>>>>>>>>>>>>    Get CurrentLine To iCurrentLine
90352>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETTABWIDTH To iTabSize
90353>>>>>>>>>>>>>>>    Get EditorMessage SCI_GETUSETABS  To bUseTabs
90354>>>>>>>>>>>>>>>    If (bUseTabs) ;      Move (Character(9)) To sTab
90357>>>>>>>>>>>>>>>    Else ;      Move (Repeat(" ",iTabSize)) To sTab
90359>>>>>>>>>>>>>>>    Get SC_LineCount To iLineCount
90360>>>>>>>>>>>>>>>    Send GotoLine iLineCount
90361>>>>>>>>>>>>>>>    Send PumpMsgQueue Of Desktop
90362>>>>>>>>>>>>>>>    Send GotoLine 1
90363>>>>>>>>>>>>>>>    Send EditorMessage SCI_BEGINUNDOACTION
90364>>>>>>>>>>>>>>>    For iLine From 0 To (iLineCount-1)
90370>>>>>>>>>>>>>>>>
90370>>>>>>>>>>>>>>>      Get SC_GetLine Item iLine To sLine
90371>>>>>>>>>>>>>>>      If (RTrim(sLine)<>"") Begin
90373>>>>>>>>>>>>>>>        Get LineIsDfImage iLine sLine To bIsDfImage
90374>>>>>>>>>>>>>>>        If (bIsDfImage=False) Begin
90376>>>>>>>>>>>>>>>          Get LineIsCaseStatement sLine To eCaseStatus
90377>>>>>>>>>>>>>>>          If (eCaseStatus<>CI_NoCaseStatement) Begin
90379>>>>>>>>>>>>>>>            If (eCaseStatus=CI_CaseBegin) Begin
90381>>>>>>>>>>>>>>>              Increment iCaseLevel
90382>>>>>>>>>>>>>>>            End
90382>>>>>>>>>>>>>>>>
90382>>>>>>>>>>>>>>>            Else If (eCaseStatus=CI_CaseEnd) Begin
90385>>>>>>>>>>>>>>>              Decrement iCaseLevel
90386>>>>>>>>>>>>>>>            End
90386>>>>>>>>>>>>>>>>
90386>>>>>>>>>>>>>>>          End
90386>>>>>>>>>>>>>>>>
90386>>>>>>>>>>>>>>>          Get LineIsSingleLineIfElseStatement iLine sLine bIsIfElseIndent To bIsIfElse
90387>>>>>>>>>>>>>>>          Get LineIsCommandMacro iLine sLine bMacroCommandOpen To bMacroCommandOpen
90388>>>>>>>>>>>>>>>          If (bMacroCommandOpen) Begin
90390>>>>>>>>>>>>>>>            Move sLine To sLineSave
90391>>>>>>>>>>>>>>>          End
90391>>>>>>>>>>>>>>>>
90391>>>>>>>>>>>>>>>          Move (LTrim(sLine))  To sLine
90392>>>>>>>>>>>>>>>          If (bIsIfElseIndent) Begin                      // don't indent on begin after single line if/else
90394>>>>>>>>>>>>>>>            If (Left(Lowercase(sLine),6)="begin ") Begin // scenario pointed out by Mike (Starzen), see
90396>>>>>>>>>>>>>>>              Move false To bIsIfElseIndent               // bug https://projects.vdf-guidance.com/issues/127
90397>>>>>>>>>>>>>>>            End
90397>>>>>>>>>>>>>>>>
90397>>>>>>>>>>>>>>>          End
90397>>>>>>>>>>>>>>>>
90397>>>>>>>>>>>>>>>          Get ReIndentLineIndentation iLine iLineCount iTabSize bUseTabs (&iPrevLevel) To sIndent
90398>>>>>>>>>>>>>>>          If (iCaseLevel>0) Begin
90400>>>>>>>>>>>>>>>            If (eCaseStatus=CI_NoCaseStatement or eCaseStatus=CI_CaseEnd or (eCaseStatus=CI_CaseBreak and pbIndentCaseBreak(Self))) Begin
90402>>>>>>>>>>>>>>>              Move (Repeat(sTab,iCaseLevel)) To sTabLevel
90403>>>>>>>>>>>>>>>              Move (sIndent+sTabLevel) To sIndent
90404>>>>>>>>>>>>>>>            End
90404>>>>>>>>>>>>>>>>
90404>>>>>>>>>>>>>>>            Else Begin
90405>>>>>>>>>>>>>>>              Move (Repeat(sTab,iCaseLevel-1)) To sTabLevel
90406>>>>>>>>>>>>>>>              Move (sIndent+sTabLevel) To sIndent
90407>>>>>>>>>>>>>>>            End
90407>>>>>>>>>>>>>>>>
90407>>>>>>>>>>>>>>>          End
90407>>>>>>>>>>>>>>>>
90407>>>>>>>>>>>>>>>          If (bIsIfElseIndent) Begin
90409>>>>>>>>>>>>>>>            Move (sIndent+sTab) To sIndent
90410>>>>>>>>>>>>>>>          End
90410>>>>>>>>>>>>>>>>
90410>>>>>>>>>>>>>>>          Move (sIndent+sLine) To sLine
90411>>>>>>>>>>>>>>>          If (bMacroCommandOpen) Begin
90413>>>>>>>>>>>>>>>            Move sLineSave To sLine
90414>>>>>>>>>>>>>>>          End
90414>>>>>>>>>>>>>>>>
90414>>>>>>>>>>>>>>>          Move bIsIfElse To bIsIfElseIndent
90415>>>>>>>>>>>>>>>        End
90415>>>>>>>>>>>>>>>>
90415>>>>>>>>>>>>>>>      End
90415>>>>>>>>>>>>>>>>
90415>>>>>>>>>>>>>>>      Move (StringToUCharArray(sLine)) To ucaLine
90416>>>>>>>>>>>>>>>      Move (AppendArray(TextData,ucaLine)) To TextData
90417>>>>>>>>>>>>>>>    Loop
90418>>>>>>>>>>>>>>>>
90418>>>>>>>>>>>>>>>    Move 0 To TextData[SizeOfArray(TextData)]  // add a zero at the end
90419>>>>>>>>>>>>>>>    Move (AddressOf(TextData)) To aTextData
90420>>>>>>>>>>>>>>>    If (aTextData<>0) Begin
90422>>>>>>>>>>>>>>>      Send EditorMessage SCI_CLEARALL 0 0
90423>>>>>>>>>>>>>>>      Send EditorMessage SCI_SETTEXT  0 aTextData
90424>>>>>>>>>>>>>>>    End
90424>>>>>>>>>>>>>>>>
90424>>>>>>>>>>>>>>>    Send EditorMessage SCI_ENDUNDOACTION
90425>>>>>>>>>>>>>>>    Send GotoLine iCurrentLine
90426>>>>>>>>>>>>>>>  End_Procedure
90427>>>>>>>>>>>>>>>    
90427>>>>>>>>>>>>>>>End_Class
90428>>>>>>>>>>>>>Use cEditorHotKey_Mixin.pkg
Including file: cEditorHotKey_Mixin.pkg    (C:\Projects\DF18\DfRefactor\Libraries\SciControlLib\AppSrc\cEditorHotKey_Mixin.pkg)
90428>>>>>>>>>>>>>>>Use cSciLexer.h
90428>>>>>>>>>>>>>>>
90428>>>>>>>>>>>>>>>Register_Procedure CME_Find
90428>>>>>>>>>>>>>>>Register_Procedure CME_FindNext
90428>>>>>>>>>>>>>>>Register_Procedure CME_FindPrevious
90428>>>>>>>>>>>>>>>Register_Procedure CME_FindReplace
90428>>>>>>>>>>>>>>>Register_Procedure CME_GotoLine
90428>>>>>>>>>>>>>>>Register_Procedure CME_SelectAll
90428>>>>>>>>>>>>>>>Register_Function phoEditorEditView Returns Handle // it's actually a property, but this should do
90428>>>>>>>>>>>>>>>Register_Procedure CAPopUpFindInFiles
90428>>>>>>>>>>>>>>>Register_Procedure CASaveFile
90428>>>>>>>>>>>>>>>Register_Procedure CASaveFileAs
90428>>>>>>>>>>>>>>>Register_Procedure CASaveAllFiles
90428>>>>>>>>>>>>>>>Register_Procedure CACloseFile
90428>>>>>>>>>>>>>>>Register_Procedure CACloseAllFiles
90428>>>>>>>>>>>>>>>Register_Procedure CASelectWorkSpace
90428>>>>>>>>>>>>>>>Register_Procedure CABuildRun
90428>>>>>>>>>>>>>>>Register_Procedure CABuildRunCurrent
90428>>>>>>>>>>>>>>>Register_Procedure CABuildCompile
90428>>>>>>>>>>>>>>>Register_Procedure CABuildPreCompile
90428>>>>>>>>>>>>>>>Register_Procedure CABuildExecute
90428>>>>>>>>>>>>>>>Register_Procedure CABuildDebugRun
90428>>>>>>>>>>>>>>>Register_Procedure CABuildDebugRunCurrent
90428>>>>>>>>>>>>>>>
90428>>>>>>>>>>>>>>>Register_Procedure Define_EditViewHotkeys Handle hoEditView
90428>>>>>>>>>>>>>>>
90428>>>>>>>>>>>>>>>//
90428>>>>>>>>>>>>>>>// The hotkeys have to be defined in any object that is part of the main Editor view and as
90428>>>>>>>>>>>>>>>// such it is best declared in a mixin, so that it becomes easy to include.
90428>>>>>>>>>>>>>>>//
90428>>>>>>>>>>>>>>>Class cEditorHotKey_Mixin is a Mixin
90429>>>>>>>>>>>>>>>
90429>>>>>>>>>>>>>>>  Procedure Define_cEditorHotKey_Mixin
90431>>>>>>>>>>>>>>>    Send Define_EditorHotKeys
90432>>>>>>>>>>>>>>>  End_Procedure
90433>>>>>>>>>>>>>>>  
90433>>>>>>>>>>>>>>>  //
90433>>>>>>>>>>>>>>>  // If the focus is not in the editorview or editor control itself then it might even be outside of
90433>>>>>>>>>>>>>>>  // the client area (like in one of the toolpanels). In that case we need to reroute the hotkey action
90433>>>>>>>>>>>>>>>  // to the editor control. In that case we override this function and return true, so that we know
90433>>>>>>>>>>>>>>>  // the action needs to be rerouted.
90433>>>>>>>>>>>>>>>  //
90433>>>>>>>>>>>>>>>  Function RerouteHotKeys Returns Boolean
90435>>>>>>>>>>>>>>>    Function_Return False
90436>>>>>>>>>>>>>>>  End_Function
90437>>>>>>>>>>>>>>>  
90437>>>>>>>>>>>>>>>  Function IsInEditorView Returns Boolean
90439>>>>>>>>>>>>>>>    Boolean bInEditView
90439>>>>>>>>>>>>>>>    Integer hoEditView
90439>>>>>>>>>>>>>>>    
90439>>>>>>>>>>>>>>>    Move False To bInEditView
90440>>>>>>>>>>>>>>>    Get phoEditorEditView To hoEditView
90441>>>>>>>>>>>>>>>    If (hoEditView=Self) Begin
90443>>>>>>>>>>>>>>>      Move True To bInEditView
90444>>>>>>>>>>>>>>>    End
90444>>>>>>>>>>>>>>>>
90444>>>>>>>>>>>>>>>    Function_Return bInEditView
90445>>>>>>>>>>>>>>>  End_Function
90446>>>>>>>>>>>>>>>
90446>>>>>>>>>>>>>>>  Procedure DefineOnKey Integer iCmd Integer iMsg
90448>>>>>>>>>>>>>>>    Boolean bInEditView
90448>>>>>>>>>>>>>>>    Handle  hoEdit
90448>>>>>>>>>>>>>>>    Integer iDfKey
90448>>>>>>>>>>>>>>>    String  sKey
90448>>>>>>>>>>>>>>>    tSciCommandHotKey Command
90448>>>>>>>>>>>>>>>    tSciCommandHotKey Command
90448>>>>>>>>>>>>>>>
90448>>>>>>>>>>>>>>>    Get CMCommandToHotKeyStr iCmd To sKey
90449>>>>>>>>>>>>>>>    If (sKey<>"") Begin
90451>>>>>>>>>>>>>>>      Get IsInEditorView To bInEditView
90452>>>>>>>>>>>>>>>      If (bInEditView) Begin // only run in EditorEditView
90454>>>>>>>>>>>>>>>        Get phoCodeMaxEditor To hoEdit
90455>>>>>>>>>>>>>>>        If (hoEdit) Begin
90457>>>>>>>>>>>>>>>          // if we define a new keybinding, then we need to remove any old keybinding also
90457>>>>>>>>>>>>>>>          // as otherwise you end up with both actions.
90457>>>>>>>>>>>>>>>          Send RegisterKeyBindingToClear of hoEdit sKey
90458>>>>>>>>>>>>>>>        End
90458>>>>>>>>>>>>>>>>
90458>>>>>>>>>>>>>>>      End
90458>>>>>>>>>>>>>>>>
90458>>>>>>>>>>>>>>>      Get FindCommand of oSciCommandHotKeys iCmd to Command
90459>>>>>>>>>>>>>>>      If (Command.iCmd=iCmd) Begin
90461>>>>>>>>>>>>>>>        If (SizeOfArray(Command.HotKey.VKcode)>0) Begin
90463>>>>>>>>>>>>>>>          Get DataFlexOnKey of oSciCommandHotKeys Command.HotKey  to iDfkey
90464>>>>>>>>>>>>>>>          On_Key iDFKey Send iMsg
90465>>>>>>>>>>>>>>>        End
90465>>>>>>>>>>>>>>>>
90465>>>>>>>>>>>>>>>        If (SizeOfArray(Command.HotKey2.VKcode)>0) Begin
90467>>>>>>>>>>>>>>>          Get DataFlexOnKey of oSciCommandHotKeys Command.HotKey2 to iDfkey
90468>>>>>>>>>>>>>>>          On_Key iDFKey Send iMsg
90469>>>>>>>>>>>>>>>        End
90469>>>>>>>>>>>>>>>>
90469>>>>>>>>>>>>>>>      End
90469>>>>>>>>>>>>>>>>
90469>>>>>>>>>>>>>>>    End
90469>>>>>>>>>>>>>>>>
90469>>>>>>>>>>>>>>>  End_Procedure
90470>>>>>>>>>>>>>>>
90470>>>>>>>>>>>>>>>  Procedure onPreHotKey Integer iCmd
90472>>>>>>>>>>>>>>>    Boolean bHasAlt
90472>>>>>>>>>>>>>>>
90472>>>>>>>>>>>>>>>    Get HotKeyHasAlt of oSciCommandHotKeys iCmd to bHasAlt
90473>>>>>>>>>>>>>>>    If (bHasAlt) Begin
90475>>>>>>>>>>>>>>>      Send DispatchHotkey
90476>>>>>>>>>>>>>>>    End
90476>>>>>>>>>>>>>>>>
90476>>>>>>>>>>>>>>>  End_Procedure
90477>>>>>>>>>>>>>>>
90477>>>>>>>>>>>>>>>  Procedure HKSC_GotoMatchBrace
90479>>>>>>>>>>>>>>>    Send onPreHotKey CMD_GOTOMATCHBRACE
90480>>>>>>>>>>>>>>>    Send GotoMatchBrace
90481>>>>>>>>>>>>>>>  End_Procedure
90482>>>>>>>>>>>>>>>
90482>>>>>>>>>>>>>>>  // HKSC => Hot Key SCintilla
90482>>>>>>>>>>>>>>>  Procedure HKSC_OpenFile
90484>>>>>>>>>>>>>>>    Send DispatchHotKey  // don't leak a shortcut key into the text window
90485>>>>>>>>>>>>>>>    Send CAOpenFile
90486>>>>>>>>>>>>>>>  End_Procedure
90487>>>>>>>>>>>>>>>
90487>>>>>>>>>>>>>>>  Procedure HKSC_NewFile
90489>>>>>>>>>>>>>>>    Send DispatchHotKey  // don't leak a shortcut key into the text window
90490>>>>>>>>>>>>>>>    Send CANewFile
90491>>>>>>>>>>>>>>>  End_Procedure
90492>>>>>>>>>>>>>>>
90492>>>>>>>>>>>>>>>  Procedure HKSC_Properties
90494>>>>>>>>>>>>>>>    Send onPreHotKey CMD_PROPERTIES
90495>>>>>>>>>>>>>>>    Send Properties
90496>>>>>>>>>>>>>>>  End_Procedure
90497>>>>>>>>>>>>>>>
90497>>>>>>>>>>>>>>>  Procedure HKSC_LineCut
90499>>>>>>>>>>>>>>>    Send SC_LineCut
90500>>>>>>>>>>>>>>>  End_Procedure
90501>>>>>>>>>>>>>>>
90501>>>>>>>>>>>>>>>  Procedure HKSC_LowercaseSelection
90503>>>>>>>>>>>>>>>    Send SC_LowercaseSelection
90504>>>>>>>>>>>>>>>  End_Procedure
90505>>>>>>>>>>>>>>>
90505>>>>>>>>>>>>>>>  Procedure HKSC_UppercaseSelection
90507>>>>>>>>>>>>>>>    Send SC_UppercaseSelection
90508>>>>>>>>>>>>>>>  End_Procedure
90509>>>>>>>>>>>>>>>
90509>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkToggle
90511>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKTOGGLE
90512>>>>>>>>>>>>>>>    Send BookmarkToggle
90513>>>>>>>>>>>>>>>  End_Procedure
90514>>>>>>>>>>>>>>>
90514>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkNext
90516>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKNEXT
90517>>>>>>>>>>>>>>>    Send BookmarkNext
90518>>>>>>>>>>>>>>>  End_Procedure
90519>>>>>>>>>>>>>>>
90519>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkPrevious
90521>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKPREV
90522>>>>>>>>>>>>>>>    Send BookmarkPrevious
90523>>>>>>>>>>>>>>>  End_Procedure
90524>>>>>>>>>>>>>>>
90524>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkClearAll
90526>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKCLEARALL
90527>>>>>>>>>>>>>>>    Send BookmarkClearAll
90528>>>>>>>>>>>>>>>  End_Procedure
90529>>>>>>>>>>>>>>>
90529>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkJumpToFirst
90531>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKJUMPTOFIRST
90532>>>>>>>>>>>>>>>    Send BookmarkJumpToFirst
90533>>>>>>>>>>>>>>>  End_Procedure
90534>>>>>>>>>>>>>>>
90534>>>>>>>>>>>>>>>  Procedure HKSC_BookmarkJumpToLast
90536>>>>>>>>>>>>>>>    Send onPreHotKey CMD_BOOKMARKJUMPTOLAST
90537>>>>>>>>>>>>>>>    Send BookmarkJumpToLast
90538>>>>>>>>>>>>>>>  End_Procedure
90539>>>>>>>>>>>>>>>
90539>>>>>>>>>>>>>>>  Procedure HKSC_MoveLineUp
90541>>>>>>>>>>>>>>>    Send onPreHotKey CMD_MOVELINEUP
90542>>>>>>>>>>>>>>>    Send MoveLineUp
90543>>>>>>>>>>>>>>>  End_Procedure
90544>>>>>>>>>>>>>>>
90544>>>>>>>>>>>>>>>  Procedure HKSC_MoveLineDown
90546>>>>>>>>>>>>>>>    Send onPreHotKey CMD_MOVELINEDOWN
90547>>>>>>>>>>>>>>>    Send MoveLineDown
90548>>>>>>>>>>>>>>>  End_Procedure
90549>>>>>>>>>>>>>>>
90549>>>>>>>>>>>>>>>  Procedure HKSC_DuplicateSelection
90551>>>>>>>>>>>>>>>    Send onPreHotKey CMD_DUPLICATESELECTION
90552>>>>>>>>>>>>>>>    Send DuplicateSelection
90553>>>>>>>>>>>>>>>  End_Procedure
90554>>>>>>>>>>>>>>>
90554>>>>>>>>>>>>>>>  Procedure HKSC_InsertHeaderGlobal
90556>>>>>>>>>>>>>>>    Send onPreHotKey CMD_ToolsInsertHeaderGlobal
90557>>>>>>>>>>>>>>>    Send InsertHeaderGlobal
90558>>>>>>>>>>>>>>>  End_Procedure
90559>>>>>>>>>>>>>>>
90559>>>>>>>>>>>>>>>  Procedure HKSC_InsertHeaderUser
90561>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ToolsInsertHeaderUser
90562>>>>>>>>>>>>>>>    Send InsertHeaderUser
90563>>>>>>>>>>>>>>>  End_Procedure
90564>>>>>>>>>>>>>>>
90564>>>>>>>>>>>>>>>  Procedure HKSC_OpenFileUnderCursor
90566>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_OpenFileUnderCursor
90567>>>>>>>>>>>>>>>    Send OpenFileUnderCursor
90568>>>>>>>>>>>>>>>  End_Procedure
90569>>>>>>>>>>>>>>>
90569>>>>>>>>>>>>>>>  Procedure HKSC_InsertRevision
90571>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_InsertRevisionMark
90572>>>>>>>>>>>>>>>    Send InsertRevision
90573>>>>>>>>>>>>>>>  End_Procedure
90574>>>>>>>>>>>>>>>
90574>>>>>>>>>>>>>>>  Procedure HKSC_InsertColorValue
90576>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_InsertColor
90577>>>>>>>>>>>>>>>    Send InsertColorValue
90578>>>>>>>>>>>>>>>  End_Procedure
90579>>>>>>>>>>>>>>>
90579>>>>>>>>>>>>>>>  Procedure HKSC_WindowSwitchToCodeView
90581>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowSwitchToCodeView
90582>>>>>>>>>>>>>>>    Send WindowSwitchToCodeView
90583>>>>>>>>>>>>>>>  End_Procedure
90584>>>>>>>>>>>>>>>
90584>>>>>>>>>>>>>>>  Procedure HKSC_PAWindowSwitchToErrorView
90586>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowSwitchToErrorView
90587>>>>>>>>>>>>>>>    Send PAWindowSwitchToErrorView
90588>>>>>>>>>>>>>>>  End_Procedure
90589>>>>>>>>>>>>>>>
90589>>>>>>>>>>>>>>>  Procedure HKSC_SyncCodeView
90591>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowSyncCodeView
90592>>>>>>>>>>>>>>>    Send SyncCodeView
90593>>>>>>>>>>>>>>>  End_Procedure
90594>>>>>>>>>>>>>>>
90594>>>>>>>>>>>>>>>  Procedure HKSC_CASwitchToNextView
90596>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowNextView
90597>>>>>>>>>>>>>>>    Send CASwitchToNextView
90598>>>>>>>>>>>>>>>  End_Procedure
90599>>>>>>>>>>>>>>>
90599>>>>>>>>>>>>>>>  Procedure HKSC_CASwitchToPreviousView
90601>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_WindowPreviousView
90602>>>>>>>>>>>>>>>    Send CASwitchToPreviousView
90603>>>>>>>>>>>>>>>  End_Procedure
90604>>>>>>>>>>>>>>>
90604>>>>>>>>>>>>>>>  Procedure HKSC_ListCreator
90606>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListCreator
90607>>>>>>>>>>>>>>>    Send ListCreator
90608>>>>>>>>>>>>>>>  End_Procedure
90609>>>>>>>>>>>>>>>
90609>>>>>>>>>>>>>>>  Procedure HKSC_ListObjects
90611>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListObjects
90612>>>>>>>>>>>>>>>    Send ListObjects
90613>>>>>>>>>>>>>>>  End_Procedure
90614>>>>>>>>>>>>>>>
90614>>>>>>>>>>>>>>>  Procedure HKSC_ListVars
90616>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListVars
90617>>>>>>>>>>>>>>>    Send ListVars
90618>>>>>>>>>>>>>>>  End_Procedure
90619>>>>>>>>>>>>>>>
90619>>>>>>>>>>>>>>>  Procedure HKSC_ListKeys
90621>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListKeys
90622>>>>>>>>>>>>>>>    Send ListKeys
90623>>>>>>>>>>>>>>>  End_Procedure
90624>>>>>>>>>>>>>>>
90624>>>>>>>>>>>>>>>  Procedure HKSC_ListProcedures
90626>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListProcedures
90627>>>>>>>>>>>>>>>    Send ListProcedures
90628>>>>>>>>>>>>>>>  End_Procedure
90629>>>>>>>>>>>>>>>
90629>>>>>>>>>>>>>>>  Procedure HKSC_ListFunctions
90631>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListFunctions
90632>>>>>>>>>>>>>>>    Send ListFunctions
90633>>>>>>>>>>>>>>>  End_Procedure
90634>>>>>>>>>>>>>>>
90634>>>>>>>>>>>>>>>  Procedure HKSC_ListClasses
90636>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListClasses
90637>>>>>>>>>>>>>>>    Send ListClasses
90638>>>>>>>>>>>>>>>  End_Procedure
90639>>>>>>>>>>>>>>>
90639>>>>>>>>>>>>>>>  Procedure HKSC_ListIDETags
90641>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ListIDETags
90642>>>>>>>>>>>>>>>    Send ListIDETags
90643>>>>>>>>>>>>>>>  End_Procedure
90644>>>>>>>>>>>>>>>
90644>>>>>>>>>>>>>>>  Procedure HKSC_ToggleComment
90646>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ToggleComment
90647>>>>>>>>>>>>>>>    Send ToggleComment
90648>>>>>>>>>>>>>>>  End_Procedure
90649>>>>>>>>>>>>>>>
90649>>>>>>>>>>>>>>>  Procedure HKSC_Toggle_OnItem_AddItem
90651>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertOnItemToAddItem
90652>>>>>>>>>>>>>>>    Send Toggle_OnItem_AddItem
90653>>>>>>>>>>>>>>>  End_Procedure
90654>>>>>>>>>>>>>>>
90654>>>>>>>>>>>>>>>  Procedure HKSC_ConvertCStructToVDF
90656>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertCStructToVDF
90657>>>>>>>>>>>>>>>    Send ConvertCStructToVDF
90658>>>>>>>>>>>>>>>  End_Procedure
90659>>>>>>>>>>>>>>>
90659>>>>>>>>>>>>>>>  Procedure HKSC_ConvertCDllCallToVDF
90661>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertCDllCallToVDF
90662>>>>>>>>>>>>>>>    Send ConvertCDllCallToVDF
90663>>>>>>>>>>>>>>>  End_Procedure
90664>>>>>>>>>>>>>>>
90664>>>>>>>>>>>>>>>  Procedure HKSC_ConvertVDFTypeToHandler
90666>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_ConvertVDFTypeToHandler
90667>>>>>>>>>>>>>>>    Send ConvertVDFTypeToHandler
90668>>>>>>>>>>>>>>>  End_Procedure
90669>>>>>>>>>>>>>>>
90669>>>>>>>>>>>>>>>  Procedure HKSC_MarkScopeBlock
90671>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_MarkScopeBlock
90672>>>>>>>>>>>>>>>    Send MarkScopeBlock
90673>>>>>>>>>>>>>>>  End_Procedure
90674>>>>>>>>>>>>>>>
90674>>>>>>>>>>>>>>>  Procedure HKSC_PerfCounters
90676>>>>>>>>>>>>>>>    Send OnPreHotKey CMD_DEBUGPERFCOUNTERS
90677>>>>>>>>>>>>>>>    Send DisplayPerfCounters of ghoApplication
90678>>>>>>>>>>>>>>>  End_Procedure
90679>>>>>>>>>>>>>>>
90679>>>>>>>>>>>>>>>  Procedure HKSC_RefactorDropSelf
90681>>>>>>>>>>>>>>>    Send DispatchHotKey  // don't leak a shortcut key into the text window
90682>>>>>>>>>>>>>>>    Send RefactorDropSelf
90683>>>>>>>>>>>>>>>  End_Procedure
90684>>>>>>>>>>>>>>>
90684>>>>>>>>>>>>>>>  Procedure HKSC_RefactorObjectNeighborhood
90686>>>>>>>>>>>>>>>    Send DispatchHotKey
90687>>>>>>>>>>>>>>>    Send RefactorObjectNeighborhood
90688>>>>>>>>>>>>>>>  End_Procedure
90689>>>>>>>>>>>>>>>
90689>>>>>>>>>>>>>>>  Procedure HKSC_RefactorReindent
90691>>>>>>>>>>>>>>>    Send DispatchHotKey
90692>>>>>>>>>>>>>>>    Send RefactorReIndent
90693>>>>>>>>>>>>>>>  End_Procedure
90694>>>>>>>>>>>>>>>
90694>>>>>>>>>>>>>>>  Procedure HKSC_GotoFirstIndentMismatch
90696>>>>>>>>>>>>>>>    Send DispatchHotKey
90697>>>>>>>>>>>>>>>    Send GoToFirstIndentationMismatch
90698>>>>>>>>>>>>>>>  End_Procedure
90699>>>>>>>>>>>>>>>
90699>>>>>>>>>>>>>>>  Procedure HKSC_RefactorMethodExtract
90701>>>>>>>>>>>>>>>    Send DispatchHotKey
90702>>>>>>>>>>>>>>>    Send RefactorMethodExtract
90703>>>>>>>>>>>>>>>  End_Procedure
90704>>>>>>>>>>>>>>>
90704>>>>>>>>>>>>>>>  Procedure DefinePredefinedHotKeys Boolean bInEditView
90706>>>>>>>>>>>>>>>    Boolean bReroute
90706>>>>>>>>>>>>>>>
90706>>>>>>>>>>>>>>>    If (bInEditView=false) Begin
90708>>>>>>>>>>>>>>>      Get RerouteHotKeys To bReroute
90709>>>>>>>>>>>>>>>      If (bReroute) Begin
90711>>>>>>>>>>>>>>>        Send RouteHotkeysToCurrentView
90712>>>>>>>>>>>>>>>      End
90712>>>>>>>>>>>>>>>>
90712>>>>>>>>>>>>>>>    End
90712>>>>>>>>>>>>>>>>
90712>>>>>>>>>>>>>>>    Else Begin
90713>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FIND                   (RefProc(CME_Find))
90714>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FindNext               (RefProc(CME_FindNext))
90715>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FINDPREV               (RefProc(CME_FindPrevious))
90716>>>>>>>>>>>>>>>      Send DefineOnKey CMD_FindReplace            (RefProc(CME_FindReplace))
90717>>>>>>>>>>>>>>>      Send DefineOnKey CMD_GOTOLINE               (RefProc(CME_GotoLine))
90718>>>>>>>>>>>>>>>      Send DefineOnKey CMD_SELECTALL              (RefProc(CME_SelectAll))
90719>>>>>>>>>>>>>>>    End
90719>>>>>>>>>>>>>>>>
90719>>>>>>>>>>>>>>>    
90719>>>>>>>>>>>>>>>    Send DefineOnKey CMD_GOTOMATCHBRACE           (RefProc(HKSC_GotoMatchBrace))
90720>>>>>>>>>>>>>>>    Send DefineOnKey CMD_PROPERTIES               (RefProc(HKSC_Properties))
90721>>>>>>>>>>>>>>>    Send DefineOnKey CMD_LINECUT                  (RefProc(HKSC_LineCut))
90722>>>>>>>>>>>>>>>    Send DefineOnKey CMD_LOWERCASESELECTION       (RefProc(HKSC_LowercaseSelection))
90723>>>>>>>>>>>>>>>    Send DefineOnKey CMD_UPPERCASESELECTION       (RefProc(HKSC_UppercaseSelection))
90724>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKTOGGLE           (RefProc(HKSC_BookmarkToggle))
90725>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKNEXT             (RefProc(HKSC_BookmarkNext))
90726>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKPREV             (RefProc(HKSC_BookmarkPrevious))
90727>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKCLEARALL         (RefProc(HKSC_BookmarkClearAll))
90728>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKJUMPTOFIRST      (RefProc(HKSC_BookmarkJumpToFirst))
90729>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BOOKMARKJUMPTOLAST       (RefProc(HKSC_BookmarkJumpToLast))
90730>>>>>>>>>>>>>>>    Send DefineOnKey CMD_MOVELINEUP               (RefProc(HKSC_MoveLineUp))
90731>>>>>>>>>>>>>>>    Send DefineOnKey CMD_MOVELINEDOWN             (RefProc(HKSC_MoveLineDown))
90732>>>>>>>>>>>>>>>    Send DefineOnKey CMD_DUPLICATESELECTION       (RefProc(HKSC_DuplicateSelection))
90733>>>>>>>>>>>>>>>
90733>>>>>>>>>>>>>>>    // Window Menu.
90733>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowSwitchToCodeView   (RefProc(HKSC_WindowSwitchToCodeView))
90734>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowSwitchToErrorView  (RefProc(HKSC_PAWindowSwitchToErrorView))
90735>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowSyncCodeView       (RefProc(HKSC_SyncCodeView))
90736>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowNextView           (RefProc(HKSC_CASwitchToNextView))
90737>>>>>>>>>>>>>>>    Send DefineOnKey CMD_WindowPreviousView       (RefProc(HKSC_CASwitchToPreviousView))
90738>>>>>>>>>>>>>>>
90738>>>>>>>>>>>>>>>    // Lists.
90738>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListCreator              (RefProc(HKSC_ListCreator))
90739>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListObjects              (RefProc(HKSC_ListObjects))
90740>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListVars                 (RefProc(HKSC_ListVars))
90741>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListKeys                 (RefProc(HKSC_ListKeys))
90742>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListProcedures           (RefProc(HKSC_ListProcedures))
90743>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListFunctions            (RefProc(HKSC_ListFunctions))
90744>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListClasses              (RefProc(HKSC_ListClasses))
90745>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ListIDETags              (RefProc(HKSC_ListIDETags))
90746>>>>>>>>>>>>>>>
90746>>>>>>>>>>>>>>>    // Mixed
90746>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ToggleComment            (RefProc(HKSC_ToggleComment))
90747>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ToolsInsertHeaderGlobal  (RefProc(HKSC_InsertHeaderGlobal))
90748>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ToolsInsertHeaderUser    (RefProc(HKSC_InsertHeaderUser))
90749>>>>>>>>>>>>>>>    Send DefineOnKey CMD_OpenFileUnderCursor      (RefProc(HKSC_OpenFileUnderCursor))
90750>>>>>>>>>>>>>>>    Send DefineOnKey CMD_InsertRevisionMark       (RefProc(HKSC_InsertRevision))
90751>>>>>>>>>>>>>>>    Send DefineOnKey CMD_InsertColor              (RefProc(HKSC_InsertColorValue))
90752>>>>>>>>>>>>>>>
90752>>>>>>>>>>>>>>>    // Convetion.
90752>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertOnItemToAddItem   (RefProc(HKSC_Toggle_OnItem_AddItem))
90753>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertCStructToVDF      (RefProc(HKSC_ConvertCStructToVDF))
90754>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertCDllCallToVDF     (RefProc(HKSC_ConvertCDllCallToVDF))
90755>>>>>>>>>>>>>>>    Send DefineOnKey CMD_ConvertVDFTypeToHandler  (RefProc(HKSC_ConvertVDFTypeToHandler))
90756>>>>>>>>>>>>>>>
90756>>>>>>>>>>>>>>>    Send DefineOnKey CMD_MarkScopeBlock           (RefProc(HKSC_MarkScopeBlock))
90757>>>>>>>>>>>>>>>
90757>>>>>>>>>>>>>>>
90757>>>>>>>>>>>>>>>    Send DefineOnKey CMD_DEBUGPERFCOUNTERS        (RefProc(HKSC_PerfCounters))
90758>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTORDROPSELF         (RefProc(HKSC_RefactorDropSelf))
90759>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTOROBJECTNEIGHBORHOOD (RefProc(HKSC_RefactorObjectNeighborhood))
90760>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTORREINDENT         (RefProc(HKSC_RefactorReindent))
90761>>>>>>>>>>>>>>>    Send DefineOnKey CMD_GOTOFIRSTINDENTMISMATCH  (RefProc(HKSC_GotoFirstIndentMismatch))
90762>>>>>>>>>>>>>>>    Send DefineOnKey CMD_REFACTORMETHODEXTRACT    (RefProc(HKSC_RefactorMethodExtract))
90763>>>>>>>>>>>>>>>  End_Procedure
90764>>>>>>>>>>>>>>>  
90764>>>>>>>>>>>>>>>  Function CurrentView Returns Integer
90766>>>>>>>>>>>>>>>    Handle hoView
90766>>>>>>>>>>>>>>>    Handle hoClient
90766>>>>>>>>>>>>>>>
90766>>>>>>>>>>>>>>>    Move 0 To hoView
90767>>>>>>>>>>>>>>>    Get Client_ID To hoClient
90768>>>>>>>>>>>>>>>    If (hoClient) Begin
90770>>>>>>>>>>>>>>>//      Get FindCurrentView of hoClient To hoView
90770>>>>>>>>>>>>>>>    End
90770>>>>>>>>>>>>>>>>
90770>>>>>>>>>>>>>>>    Function_Return hoView
90771>>>>>>>>>>>>>>>  End_Function
90772>>>>>>>>>>>>>>>  
90772>>>>>>>>>>>>>>>  Procedure CurrentViewHotKeyReroute Integer iMsg
90774>>>>>>>>>>>>>>>    Handle hoView
90774>>>>>>>>>>>>>>>    
90774>>>>>>>>>>>>>>>    Get CurrentView To hoView
90775>>>>>>>>>>>>>>>    If (hoView<>0) Begin
90777>>>>>>>>>>>>>>>      Send DispatchHotkey
90778>>>>>>>>>>>>>>>      Send iMsg to hoView
90779>>>>>>>>>>>>>>>    End
90779>>>>>>>>>>>>>>>>
90779>>>>>>>>>>>>>>>  End_Procedure
90780>>>>>>>>>>>>>>>  
90780>>>>>>>>>>>>>>>  Procedure CurrentView_CAPopUpFindInFiles
90782>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CAPopUpFindInFiles))
90783>>>>>>>>>>>>>>>  End_Procedure
90784>>>>>>>>>>>>>>>  
90784>>>>>>>>>>>>>>>  Procedure CurrentView_HKSC_OpenFile
90786>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(HKSC_OpenFile))
90787>>>>>>>>>>>>>>>  End_Procedure
90788>>>>>>>>>>>>>>>  
90788>>>>>>>>>>>>>>>  Procedure CurrentView_CASaveFile
90790>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASaveFile))
90791>>>>>>>>>>>>>>>  End_Procedure
90792>>>>>>>>>>>>>>>  
90792>>>>>>>>>>>>>>>  Procedure CurrentView_CASaveFileAs
90794>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASaveFileAs))
90795>>>>>>>>>>>>>>>  End_Procedure
90796>>>>>>>>>>>>>>>  
90796>>>>>>>>>>>>>>>  Procedure CurrentView_CASaveAllFiles
90798>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASaveAllFiles))
90799>>>>>>>>>>>>>>>  End_Procedure
90800>>>>>>>>>>>>>>>  
90800>>>>>>>>>>>>>>>  Procedure CurrentView_CACloseFile
90802>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CACloseFile))
90803>>>>>>>>>>>>>>>  End_Procedure
90804>>>>>>>>>>>>>>>  
90804>>>>>>>>>>>>>>>  Procedure CurrentView_CACloseAllFiles
90806>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CACloseAllFiles))
90807>>>>>>>>>>>>>>>  End_Procedure
90808>>>>>>>>>>>>>>>  
90808>>>>>>>>>>>>>>>  Procedure CurrentView_HKSC_NewFile
90810>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(HKSC_NewFile))
90811>>>>>>>>>>>>>>>  End_Procedure
90812>>>>>>>>>>>>>>>  
90812>>>>>>>>>>>>>>>  Procedure CurrentView_CASelectWorkSpace
90814>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CASelectWorkSpace))
90815>>>>>>>>>>>>>>>  End_Procedure
90816>>>>>>>>>>>>>>>  
90816>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildRun
90818>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildRun))
90819>>>>>>>>>>>>>>>  End_Procedure
90820>>>>>>>>>>>>>>>  
90820>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildRunCurrent
90822>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildRunCurrent))
90823>>>>>>>>>>>>>>>  End_Procedure
90824>>>>>>>>>>>>>>>  
90824>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildCompile
90826>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildCompile))
90827>>>>>>>>>>>>>>>  End_Procedure
90828>>>>>>>>>>>>>>>  
90828>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildPreCompile
90830>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildPreCompile))
90831>>>>>>>>>>>>>>>  End_Procedure
90832>>>>>>>>>>>>>>>  
90832>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildExecute
90834>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildExecute))
90835>>>>>>>>>>>>>>>  End_Procedure
90836>>>>>>>>>>>>>>>  
90836>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildDebugRun
90838>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildDebugRun))
90839>>>>>>>>>>>>>>>  End_Procedure
90840>>>>>>>>>>>>>>>  
90840>>>>>>>>>>>>>>>  Procedure CurrentView_CABuildDebugRunCurrent
90842>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CABuildDebugRunCurrent))
90843>>>>>>>>>>>>>>>  End_Procedure
90844>>>>>>>>>>>>>>>  
90844>>>>>>>>>>>>>>>  Procedure CurrentView_CME_Find
90846>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_Find))
90847>>>>>>>>>>>>>>>  End_Procedure
90848>>>>>>>>>>>>>>>                         
90848>>>>>>>>>>>>>>>  Procedure CurrentView_CME_FindNext
90850>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_FindNext))
90851>>>>>>>>>>>>>>>  End_Procedure
90852>>>>>>>>>>>>>>>  
90852>>>>>>>>>>>>>>>  Procedure CurrentView_CME_FindPrevious
90854>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_FindPrevious))
90855>>>>>>>>>>>>>>>  End_Procedure
90856>>>>>>>>>>>>>>>  
90856>>>>>>>>>>>>>>>  Procedure CurrentView_CME_FindReplace
90858>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_FindReplace))
90859>>>>>>>>>>>>>>>  End_Procedure
90860>>>>>>>>>>>>>>>  
90860>>>>>>>>>>>>>>>  Procedure CurrentView_CME_GotoLine
90862>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_GotoLine))
90863>>>>>>>>>>>>>>>  End_Procedure
90864>>>>>>>>>>>>>>>  
90864>>>>>>>>>>>>>>>  Procedure CurrentView_CME_SelectAll
90866>>>>>>>>>>>>>>>    Send CurrentViewHotKeyReroute (RefProc(CME_SelectAll))
90867>>>>>>>>>>>>>>>  End_Procedure
90868>>>>>>>>>>>>>>>  
90868>>>>>>>>>>>>>>>  Procedure RouteHotKeysToCurrentView
90870>>>>>>>>>>>>>>>
90870>>>>>>>>>>>>>>>    // File Menu
90870>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileOpenFile         (RefProc(CurrentView_HKSC_OpenFile))
90871>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileSaveFile         (RefProc(CurrentView_CASaveFile))
90872>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileSaveFileAs       (RefProc(CurrentView_CASaveFileAs))
90873>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileSaveAll          (RefProc(CurrentView_CASaveAllFiles))
90874>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileCloseFile        (RefProc(CurrentView_CACloseFile))
90875>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileCloseAllFiles    (RefProc(CurrentView_CACloseAllFiles))
90876>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FileNewFile          (RefProc(CurrentView_HKSC_NewFile))
90877>>>>>>>>>>>>>>>
90877>>>>>>>>>>>>>>>    // Edit Menu
90877>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FindInFiles          (RefProc(CurrentView_CAPopUpFindInFiles))
90878>>>>>>>>>>>>>>>
90878>>>>>>>>>>>>>>>    // Options Menu
90878>>>>>>>>>>>>>>>    Send DefineOnKey CMD_SelectWorkSpace      (RefProc(CurrentView_CASelectWorkSpace))
90879>>>>>>>>>>>>>>>
90879>>>>>>>>>>>>>>>    // Build Menu
90879>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildRun             (RefProc(CurrentView_CABuildRun))
90880>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildRunCurrent      (RefProc(CurrentView_CABuildRunCurrent))
90881>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildCompileCurrent  (RefProc(CurrentView_CABuildCompile))
90882>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildPreCompile      (RefProc(CurrentView_CABuildPreCompile))
90883>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildExecute         (RefProc(CurrentView_CABuildExecute))
90884>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildDebugRun        (RefProc(CurrentView_CABuildDebugRun))
90885>>>>>>>>>>>>>>>    Send DefineOnKey CMD_BuildDebugRunCurrent (RefProc(CurrentView_CABuildDebugRunCurrent))
90886>>>>>>>>>>>>>>>
90886>>>>>>>>>>>>>>>    // Find/replace/select all/gotoline
90886>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FIND                 (RefProc(CurrentView_CME_Find))
90887>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FindNext             (RefProc(CurrentView_CME_FindNext))
90888>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FINDPREV             (RefProc(CurrentView_CME_FindPrevious))
90889>>>>>>>>>>>>>>>    Send DefineOnKey CMD_FindReplace          (RefProc(CurrentView_CME_FindReplace))
90890>>>>>>>>>>>>>>>    Send DefineOnKey CMD_GOTOLINE             (RefProc(CurrentView_CME_GotoLine))
90891>>>>>>>>>>>>>>>    Send DefineOnKey CMD_SELECTALL            (RefProc(CurrentView_CME_SelectAll))
90892>>>>>>>>>>>>>>>  End_Procedure
90893>>>>>>>>>>>>>>>
90893>>>>>>>>>>>>>>>  // This defines the on_key commands via editor hotkeys
90893>>>>>>>>>>>>>>>  Procedure Define_EditorHotKeys
90895>>>>>>>>>>>>>>>    Boolean bInEditView
90895>>>>>>>>>>>>>>>    //    Can't set the definition here as the message isn't known in the subclass
90895>>>>>>>>>>>>>>>    //      Send DefineOnKey CMD_FileNewFile msg_CANewFile
90895>>>>>>>>>>>>>>>    Get IsInEditorView to bInEditView
90896>>>>>>>>>>>>>>>    If (bInEditView) Begin
90898>>>>>>>>>>>>>>>      // Calls method in clientArea object to then execute the above DefineOnKey
90898>>>>>>>>>>>>>>>      Delegate Send Define_EditViewHotkeys Self
90900>>>>>>>>>>>>>>>    End
90900>>>>>>>>>>>>>>>>
90900>>>>>>>>>>>>>>>    //
90900>>>>>>>>>>>>>>>    Send DefinePredefinedHotkeys bInEditView
90901>>>>>>>>>>>>>>>    //
90901>>>>>>>>>>>>>>>  End_Procedure
90902>>>>>>>>>>>>>>>
90902>>>>>>>>>>>>>>>End_Class
90903>>>>>>>>>>>>>Use cCJCommandBarSystem.pkg
90903>>>>>>>>>>>>>Use cCJStandardMenuItemClasses.pkg
90903>>>>>>>>>>>>>Use Cursor.pkg
90903>>>>>>>>>>>>>//Use cEditorProperties.pkg  
90903>>>>>>>>>>>>>
90903>>>>>>>>>>>>>Register_Object oOpenFolderMenuItem
90903>>>>>>>>>>>>>
90903>>>>>>>>>>>>>Object oSciContextMenu is a cCJContextMenu
90905>>>>>>>>>>>>>    Property Handle phoServedObject 0
90907>>>>>>>>>>>>>
90907>>>>>>>>>>>>>    Object oSourceFileText_MenuItem is a cCJMenuItem
90909>>>>>>>>>>>>>        Set psCaption to "Select Source File"
90910>>>>>>>>>>>>>        Set psDescription to "Displays an Open File dialog to select a source file from (Ctrl+O)"
90911>>>>>>>>>>>>>        Set psImage to "ActionOpen.ico"
90912>>>>>>>>>>>>>        Set psShortcut to "Ctrl+O"
90913>>>>>>>>>>>>>
90913>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90916>>>>>>>>>>>>>            Forward Send OnExecute vCommandBarControl
90918>>>>>>>>>>>>>            Send Execute of (oOpenFolderMenuItem(ghoCommandBars))
90919>>>>>>>>>>>>>        End_Procedure
90920>>>>>>>>>>>>>
90920>>>>>>>>>>>>>        Function IsEnabled Returns Boolean
90923>>>>>>>>>>>>>            Boolean bState
90923>>>>>>>>>>>>>            String sSWSFile
90923>>>>>>>>>>>>>
90923>>>>>>>>>>>>>            Move False to bState
90924>>>>>>>>>>>>>            Get psSWSFile of ghoApplication to sSWSFile
90925>>>>>>>>>>>>>            Move (sSWSFile <> "") to bState
90926>>>>>>>>>>>>>
90926>>>>>>>>>>>>>            Function_Return bState
90927>>>>>>>>>>>>>        End_Function
90928>>>>>>>>>>>>>
90928>>>>>>>>>>>>>    End_Object
90929>>>>>>>>>>>>>
90929>>>>>>>>>>>>>    Object oCutMenuItem is a cCJCutMenuItem
90931>>>>>>>>>>>>>    End_Object
90932>>>>>>>>>>>>>
90932>>>>>>>>>>>>>    Object oCopyMenuItem is a cCJCopyMenuItem
90934>>>>>>>>>>>>>    End_Object
90935>>>>>>>>>>>>>
90935>>>>>>>>>>>>>    Object oPasteMenuItem is a cCJPasteMenuItem
90937>>>>>>>>>>>>>    End_Object
90938>>>>>>>>>>>>>
90938>>>>>>>>>>>>>    Object oFindMenuItem is a cCJMenuItem
90940>>>>>>>>>>>>>        Set pbControlBeginGroup to True
90941>>>>>>>>>>>>>        Set psCaption to "&Find"
90942>>>>>>>>>>>>>        Set psToolTip to "Find text"
90943>>>>>>>>>>>>>        Set psDescription to "Find text in current file"
90944>>>>>>>>>>>>>        Set psShortcut to "Ctrl+F"
90945>>>>>>>>>>>>>        Set psImage to "ActionFind.ico"
90946>>>>>>>>>>>>>
90946>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90949>>>>>>>>>>>>>            Send CME_Find of (phoServedObject(Self))
90950>>>>>>>>>>>>>        End_Procedure
90951>>>>>>>>>>>>>    End_Object
90952>>>>>>>>>>>>>
90952>>>>>>>>>>>>>    Object oFindNextMenuItem is a cCJMenuItem
90954>>>>>>>>>>>>>        Set psCaption to "Find &Next"
90955>>>>>>>>>>>>>        Set psToolTip to "Find next text"
90956>>>>>>>>>>>>>        Set psDescription to "Find next text in current file"
90957>>>>>>>>>>>>>        Set psShortcut to "F3"
90958>>>>>>>>>>>>>        Set psImage to "ActionFindNext.ico"
90959>>>>>>>>>>>>>
90959>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90962>>>>>>>>>>>>>            Send CME_FindNext of (phoServedObject(Self))
90963>>>>>>>>>>>>>        End_Procedure
90964>>>>>>>>>>>>>    End_Object
90965>>>>>>>>>>>>>
90965>>>>>>>>>>>>>    Object oFindPreviousMenuItem is a cCJMenuItem
90967>>>>>>>>>>>>>        Set psCaption to "Find &Previous"
90968>>>>>>>>>>>>>        Set psToolTip to "Find previous text"
90969>>>>>>>>>>>>>        Set psDescription to "Find previous text in current file"
90970>>>>>>>>>>>>>        Set psShortcut to "Shift+F3"
90971>>>>>>>>>>>>>        Set psImage to "ActionFindPrevious.ico"
90972>>>>>>>>>>>>>
90972>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90975>>>>>>>>>>>>>            Send CME_FindPrevious of (phoServedObject(Self))
90976>>>>>>>>>>>>>        End_Procedure
90977>>>>>>>>>>>>>    End_Object
90978>>>>>>>>>>>>>
90978>>>>>>>>>>>>>    Object oFindReplaceMenuItem is a cCJMenuItem
90980>>>>>>>>>>>>>        Set psCaption to "Find &Replace"
90981>>>>>>>>>>>>>        Set psToolTip to "Find Replace text"
90982>>>>>>>>>>>>>        Set psDescription to "Find and replace text in current file"
90983>>>>>>>>>>>>>        Set psShortcut to "Ctrl+Alt+F3"
90984>>>>>>>>>>>>>        Set psImage to "ActionFindAndReplace.ico"
90985>>>>>>>>>>>>>
90985>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
90988>>>>>>>>>>>>>            Send CME_FindReplace of (phoServedObject(Self))
90989>>>>>>>>>>>>>        End_Procedure
90990>>>>>>>>>>>>>    End_Object
90991>>>>>>>>>>>>>
90991>>>>>>>>>>>>>    Object oGotoLineMenuItem is a cCJMenuItem
90993>>>>>>>>>>>>>        Set pbControlBeginGroup to True
90994>>>>>>>>>>>>>        Set psCaption to "Goto &Line"
90995>>>>>>>>>>>>>        Set psToolTip to "Goto Line"
90996>>>>>>>>>>>>>        Set psDescription to "Goto line in current file"
90997>>>>>>>>>>>>>        Set psShortcut to "Ctrl+G"
90998>>>>>>>>>>>>>        Set psImage to "ActionGoToLine.ico"
90999>>>>>>>>>>>>>
90999>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
91002>>>>>>>>>>>>>            Send CME_GotoLine of (phoServedObject(Self))
91003>>>>>>>>>>>>>        End_Procedure
91004>>>>>>>>>>>>>    End_Object
91005>>>>>>>>>>>>>
91005>>>>>>>>>>>>>    Object oSelectAllMenuItem is a cCJMenuItem
91007>>>>>>>>>>>>>        Set psCaption to "Select &All"
91008>>>>>>>>>>>>>        Set psToolTip to "Select All"
91009>>>>>>>>>>>>>        Set psDescription to "Select All text in current file"
91010>>>>>>>>>>>>>        Set psShortcut to "Ctrl+A"
91011>>>>>>>>>>>>>        Set psImage to "ActionSelectAll.ico"
91012>>>>>>>>>>>>>
91012>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
91015>>>>>>>>>>>>>            Send CME_SelectAll of (phoServedObject(Self))
91016>>>>>>>>>>>>>        End_Procedure
91017>>>>>>>>>>>>>    End_Object
91018>>>>>>>>>>>>>
91018>>>>>>>>>>>>>    Object oUndoMenuItem is a cCJMenuItem
91020>>>>>>>>>>>>>        Set psCaption to "Undo"
91021>>>>>>>>>>>>>        Set psToolTip to "Undo"
91022>>>>>>>>>>>>>        Set psDescription to "Undo the last editor action"
91023>>>>>>>>>>>>>        Set psShortcut to "Ctrl+Z"
91024>>>>>>>>>>>>>        Set psImage to "ActionUndo.ico"
91025>>>>>>>>>>>>>
91025>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
91028>>>>>>>>>>>>>            Send CME_UndoAction of (phoServedObject(Self))
91029>>>>>>>>>>>>>        End_Procedure
91030>>>>>>>>>>>>>    End_Object
91031>>>>>>>>>>>>>
91031>>>>>>>>>>>>>    Object oNormalizeCaseMenuItem is a cCJMenuItem
91033>>>>>>>>>>>>>        Set psCaption to "Adjust Upper/Lowercase"
91034>>>>>>>>>>>>>        Set psToolTip to "Adjust Upper/Lowercase"
91035>>>>>>>>>>>>>        Set psDescription to "Normalize the case on all of the text in the current file"
91036>>>>>>>>>>>>>        Set pbControlBeginGroup to True
91037>>>>>>>>>>>>>        Set psImage to "ActionCasing.ico"
91038>>>>>>>>>>>>>
91038>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
91041>>>>>>>>>>>>>            Send RefactorNormalizeCase of (phoServedObject(Self))
91042>>>>>>>>>>>>>        End_Procedure
91043>>>>>>>>>>>>>    End_Object
91044>>>>>>>>>>>>>
91044>>>>>>>>>>>>>    Object oReIndentMenuItem is a cCJMenuItem
91046>>>>>>>>>>>>>        Set psCaption to "Reindent code"
91047>>>>>>>>>>>>>        Set psToolTip to "Reindent code"
91048>>>>>>>>>>>>>        Set psDescription to "ReIndent all of the text in the current file"
91049>>>>>>>>>>>>>        Set psImage to "ActionIndent.ico"
91050>>>>>>>>>>>>>
91050>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
91053>>>>>>>>>>>>>            Send RefactorReIndent of (phoServedObject(Self))
91054>>>>>>>>>>>>>        End_Procedure
91055>>>>>>>>>>>>>    End_Object
91056>>>>>>>>>>>>>
91056>>>>>>>>>>>>>    Object oDropSelfMenuItem is a cCJMenuItem
91058>>>>>>>>>>>>>        Set psCaption to "Drop Self"
91059>>>>>>>>>>>>>        Set psToolTip to "Drop Self"
91060>>>>>>>>>>>>>        Set psDescription to "Refactoring drop self method"
91061>>>>>>>>>>>>>        Set psImage to "ActionDrop.ico"
91062>>>>>>>>>>>>>
91062>>>>>>>>>>>>>        Procedure OnExecute Variant vCommandBarControl
91065>>>>>>>>>>>>>            Send RefactorDropSelf of (phoServedObject(Self))
91066>>>>>>>>>>>>>        End_Procedure
91067>>>>>>>>>>>>>    End_Object
91068>>>>>>>>>>>>>
91068>>>>>>>>>>>>>End_Object
91069>>>>>>>>>>>>>
91069>>>>>>>>>>>>>Class cScintillaEdit is a cSciLexerRefactor
91070>>>>>>>>>>>>>
91070>>>>>>>>>>>>>    Import_Class_Protocol cEditorHotKey_Mixin
91071>>>>>>>>>>>>>
91071>>>>>>>>>>>>>    Procedure Construct_Object
91073>>>>>>>>>>>>>        Forward Send Construct_Object
91075>>>>>>>>>>>>>        Property Handle phoCodeMaxEditor   0
91076>>>>>>>>>>>>>        Property Handle phoEditorEditView  0 // This is only needed in The Hammer where an editor view has also components such as a treeview on the left
91077>>>>>>>>>>>>>        Set phoCodeMaxEditor     to Self
91078>>>>>>>>>>>>>        Set Floating_Menu_Object to oSciContextMenu
91079>>>>>>>>>>>>>        Set pbAnsiMode           to False    // Don't do any ANSI/OEM Translation on load and save
91080>>>>>>>>>>>>>        Send Define_cEditorHotKey_Mixin
91081>>>>>>>>>>>>>    End_Procedure
91082>>>>>>>>>>>>>
91082>>>>>>>>>>>>>    Procedure CME_Find
91084>>>>>>>>>>>>>        Handle hoEdit
91084>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91085>>>>>>>>>>>>>        If (hoEdit) Begin
91087>>>>>>>>>>>>>            Send Activate of hoEdit
91088>>>>>>>>>>>>>            Send Find of hoEdit
91089>>>>>>>>>>>>>        End
91089>>>>>>>>>>>>>>
91089>>>>>>>>>>>>>    End_Procedure
91090>>>>>>>>>>>>>
91090>>>>>>>>>>>>>    Procedure CME_FindNext
91092>>>>>>>>>>>>>        Handle hoEdit
91092>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91093>>>>>>>>>>>>>        If (hoEdit) Begin
91095>>>>>>>>>>>>>            Send Activate of hoEdit
91096>>>>>>>>>>>>>            Send FindNext of hoEdit
91097>>>>>>>>>>>>>        End
91097>>>>>>>>>>>>>>
91097>>>>>>>>>>>>>    End_Procedure
91098>>>>>>>>>>>>>
91098>>>>>>>>>>>>>    Procedure CME_FindPrevious
91100>>>>>>>>>>>>>        Handle hoEdit
91100>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91101>>>>>>>>>>>>>        If (hoEdit) Begin
91103>>>>>>>>>>>>>            Send Activate of hoEdit
91104>>>>>>>>>>>>>            Send FindPrevious of hoEdit
91105>>>>>>>>>>>>>        End
91105>>>>>>>>>>>>>>
91105>>>>>>>>>>>>>    End_Procedure
91106>>>>>>>>>>>>>
91106>>>>>>>>>>>>>    Procedure CME_FindReplace
91108>>>>>>>>>>>>>        Handle hoEdit
91108>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91109>>>>>>>>>>>>>        If (hoEdit) Begin
91111>>>>>>>>>>>>>            Send Activate of hoEdit
91112>>>>>>>>>>>>>            Send Replace of hoEdit
91113>>>>>>>>>>>>>        End
91113>>>>>>>>>>>>>>
91113>>>>>>>>>>>>>    End_Procedure
91114>>>>>>>>>>>>>
91114>>>>>>>>>>>>>    Procedure CME_GotoLine
91116>>>>>>>>>>>>>        Handle hoEdit
91116>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91117>>>>>>>>>>>>>        If (hoEdit) Begin
91119>>>>>>>>>>>>>            Send Activate of hoEdit
91120>>>>>>>>>>>>>            Send GotoLine of hoEdit
91121>>>>>>>>>>>>>        End
91121>>>>>>>>>>>>>>
91121>>>>>>>>>>>>>    End_Procedure
91122>>>>>>>>>>>>>
91122>>>>>>>>>>>>>    Procedure CME_SelectAll
91124>>>>>>>>>>>>>        Handle hoEdit
91124>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91125>>>>>>>>>>>>>        If (hoEdit) Begin
91127>>>>>>>>>>>>>            Send Activate of hoEdit
91128>>>>>>>>>>>>>            Send SelectAll of hoEdit
91129>>>>>>>>>>>>>        End
91129>>>>>>>>>>>>>>
91129>>>>>>>>>>>>>    End_Procedure
91130>>>>>>>>>>>>>
91130>>>>>>>>>>>>>    Procedure CME_UndoAction
91132>>>>>>>>>>>>>        Handle hoEdit
91132>>>>>>>>>>>>>        Integer iRet
91132>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91133>>>>>>>>>>>>>        If (hoEdit) Begin
91135>>>>>>>>>>>>>            Send Activate of hoEdit
91136>>>>>>>>>>>>>            Get CM_Undo to iRet
91137>>>>>>>>>>>>>        End
91137>>>>>>>>>>>>>>
91137>>>>>>>>>>>>>    End_Procedure
91138>>>>>>>>>>>>>
91138>>>>>>>>>>>>>    Function Can_UndoAction Returns Boolean
91140>>>>>>>>>>>>>        Handle hoEdit
91140>>>>>>>>>>>>>        Integer iRet
91140>>>>>>>>>>>>>        Move 0 to iRet
91141>>>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit
91142>>>>>>>>>>>>>        If (hoEdit) Begin
91144>>>>>>>>>>>>>            Get CM_CanUndo to iRet
91145>>>>>>>>>>>>>        End
91145>>>>>>>>>>>>>>
91145>>>>>>>>>>>>>        Function_Return (iRet = 1)
91146>>>>>>>>>>>>>    End_Function
91147>>>>>>>>>>>>>
91147>>>>>>>>>>>>>    // Dummy methods, don't implement these as it will be a pain to keep in sync.
91147>>>>>>>>>>>>>    // If any of these below will be implemented then that is best done in
91147>>>>>>>>>>>>>    // coordinated effort with the Hammer.
91147>>>>>>>>>>>>>    Procedure CAOpenFile
91149>>>>>>>>>>>>>    End_Procedure
91150>>>>>>>>>>>>>    Procedure CANewFile
91152>>>>>>>>>>>>>    End_Procedure
91153>>>>>>>>>>>>>    Procedure InsertHeaderGlobal
91155>>>>>>>>>>>>>    End_Procedure
91156>>>>>>>>>>>>>    Procedure InsertHeaderUser
91158>>>>>>>>>>>>>    End_Procedure
91159>>>>>>>>>>>>>    Procedure OpenFileUnderCursor
91161>>>>>>>>>>>>>    End_Procedure
91162>>>>>>>>>>>>>    Procedure InsertRevision
91164>>>>>>>>>>>>>    End_Procedure
91165>>>>>>>>>>>>>    Procedure InsertColorValue
91167>>>>>>>>>>>>>    End_Procedure
91168>>>>>>>>>>>>>    Procedure WindowSwitchToCodeView
91170>>>>>>>>>>>>>    End_Procedure
91171>>>>>>>>>>>>>    Procedure PAWindowSwitchToErrorView
91173>>>>>>>>>>>>>    End_Procedure
91174>>>>>>>>>>>>>    Procedure SyncCodeView
91176>>>>>>>>>>>>>    End_Procedure
91177>>>>>>>>>>>>>    Procedure CASwitchToNextView
91179>>>>>>>>>>>>>    End_Procedure
91180>>>>>>>>>>>>>    Procedure CASwitchToPreviousView
91182>>>>>>>>>>>>>    End_Procedure
91183>>>>>>>>>>>>>    Procedure ListCreator
91185>>>>>>>>>>>>>    End_Procedure
91186>>>>>>>>>>>>>    Procedure ListObjects
91188>>>>>>>>>>>>>    End_Procedure
91189>>>>>>>>>>>>>    Procedure ListVars
91191>>>>>>>>>>>>>    End_Procedure
91192>>>>>>>>>>>>>    Procedure ListKeys
91194>>>>>>>>>>>>>    End_Procedure
91195>>>>>>>>>>>>>    Procedure ListProcedures
91197>>>>>>>>>>>>>    End_Procedure
91198>>>>>>>>>>>>>    Procedure ListFunctions
91200>>>>>>>>>>>>>    End_Procedure
91201>>>>>>>>>>>>>    Procedure ListClasses
91203>>>>>>>>>>>>>    End_Procedure
91204>>>>>>>>>>>>>    Procedure ListIDETags
91206>>>>>>>>>>>>>    End_Procedure
91207>>>>>>>>>>>>>    Procedure ToggleComment
91209>>>>>>>>>>>>>    End_Procedure
91210>>>>>>>>>>>>>    Procedure Toggle_OnItem_AddItem
91212>>>>>>>>>>>>>    End_Procedure
91213>>>>>>>>>>>>>    Procedure ConvertCStructToVDF
91215>>>>>>>>>>>>>    End_Procedure
91216>>>>>>>>>>>>>    Procedure ConvertCDllCallToVDF
91218>>>>>>>>>>>>>    End_Procedure
91219>>>>>>>>>>>>>    Procedure ConvertVDFTypeToHandler
91221>>>>>>>>>>>>>    End_Procedure
91222>>>>>>>>>>>>>    Procedure MarkScopeBlock
91224>>>>>>>>>>>>>    End_Procedure
91225>>>>>>>>>>>>>    Procedure RefactorObjectNeighborhood
91227>>>>>>>>>>>>>    End_Procedure
91228>>>>>>>>>>>>>    Procedure GoToFirstIndentationMismatch
91230>>>>>>>>>>>>>    End_Procedure
91231>>>>>>>>>>>>>    Procedure RefactorMethodExtract
91233>>>>>>>>>>>>>    End_Procedure
91234>>>>>>>>>>>>>
91234>>>>>>>>>>>>>    Procedure SetAdjustments
91236>>>>>>>>>>>>>        Integer hoIni iRet
91236>>>>>>>>>>>>>        // Font Face
91236>>>>>>>>>>>>>        String  sFontData
91236>>>>>>>>>>>>>        String  sFontTemp
91236>>>>>>>>>>>>>        String  sFontFace
91236>>>>>>>>>>>>>        Integer iFontSize
91236>>>>>>>>>>>>>        Integer iCharSet
91236>>>>>>>>>>>>>        //
91236>>>>>>>>>>>>>
91236>>>>>>>>>>>>>        Move (CM_ENABLEGLOBALPROPS(Self,False))    to iRet
91237>>>>>>>>>>>>>
91237>>>>>>>>>>>>>        Move ghoEditorProperties  to hoIni
91238>>>>>>>>>>>>>        Move (CM_SetLineNumbering(Self,Low(piLineNumbering(hoIni)),Hi(piLineNumbering(hoIni)),Low(piLineNumbering(hoIni)))) to iRet
91239>>>>>>>>>>>>>        Move (CM_EnableLeftMargin(Self,pbLeftMargin(hoIni)))            to iRet
91240>>>>>>>>>>>>>
91240>>>>>>>>>>>>>        Move (CM_SetLanguage(Self,psLanguage(hoIni)))                   to iRet
91241>>>>>>>>>>>>>        Move (CM_ShowScrollBar(Self,True,pbScrollBarH(hoIni)))          to iRet
91242>>>>>>>>>>>>>        Move (CM_ShowScrollBar(Self,False,pbScrollBarV(hoIni)))         to iRet
91243>>>>>>>>>>>>>        // Editor font face?
91243>>>>>>>>>>>>>        Move (psFontFace(ghoEditorProperties))                          to sFontData
91244>>>>>>>>>>>>>        If (sFontData="") Begin
91246>>>>>>>>>>>>>            Move "11pt; 0; Courier New"                   to sFontData
91247>>>>>>>>>>>>>        End
91247>>>>>>>>>>>>>>
91247>>>>>>>>>>>>>        // Font Size
91247>>>>>>>>>>>>>        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
91248>>>>>>>>>>>>>        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
91249>>>>>>>>>>>>>        Move (Trim(Replace("PT;", Uppercase(sFontTemp), "")))           to iFontSize
91250>>>>>>>>>>>>>        // Code Page
91250>>>>>>>>>>>>>        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
91251>>>>>>>>>>>>>        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
91252>>>>>>>>>>>>>        Move (Trim(Replace(";", sFontTemp, "")))                        to iCharSet
91253>>>>>>>>>>>>>        // Font Face
91253>>>>>>>>>>>>>        Move (Trim(sFontData))                                          to sFontFace
91254>>>>>>>>>>>>>        //
91254>>>>>>>>>>>>>        Move SC_CHARSET_OEM to iCharSet
91255>>>>>>>>>>>>>        //
91255>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETFONT STYLE_DEFAULT (AddressOf(sFontFace))
91256>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETSIZE STYLE_DEFAULT iFontSize
91257>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETCHARACTERSET STYLE_DEFAULT iCharSet
91258>>>>>>>>>>>>>        Send EditorMessage SCI_STYLESETSIZE STYLE_LINENUMBER (iFontSize-1) // Set font size
91259>>>>>>>>>>>>>        //
91259>>>>>>>>>>>>>        Set  pbShowMatchingBraces to (pbShowMatchingBraces(hoIni))
91260>>>>>>>>>>>>>        If  (pbShowIndentGuides(hoIni)) Begin
91262>>>>>>>>>>>>>            Send ShowIndentationGuides
91263>>>>>>>>>>>>>        End
91263>>>>>>>>>>>>>>
91263>>>>>>>>>>>>>        Send SelectTillEndOfLine (pbSelectWholeLine(hoIni))
91264>>>>>>>>>>>>>
91264>>>>>>>>>>>>>        Move (CM_EnableDragDrop(Self,pbDragDrop(hoIni)))                to iRet
91265>>>>>>>>>>>>>        Move (CM_EnableColumnSel(Self,pbColumnSel(hoIni)))              to iRet
91266>>>>>>>>>>>>>        Move (CM_SetAutoIndentMode(Self,piAutoIndentMode(hoIni)))       to iRet
91267>>>>>>>>>>>>>        Move (CM_SetTabSize(Self,piTabSize(hoIni)))                     to iRet
91268>>>>>>>>>>>>>        Move (CM_EnableTabExpand(Self,pbTabExpand(hoIni)))              to iRet
91269>>>>>>>>>>>>>        Move (CM_EnableNormalizeCase(Self,pbNormalizeCase(hoIni)))      to iRet
91270>>>>>>>>>>>>>        Move (CM_EnableSelBounds(Self,pbSelBounds(hoIni)))              to iRet
91271>>>>>>>>>>>>>        Move (CM_EnableCaseSensitive(Self,pbCaseSensitive(hoIni)))      to iRet
91272>>>>>>>>>>>>>        Move (CM_EnableWholeWord(Self,pbWholeWord(hoIni)))              to iRet
91273>>>>>>>>>>>>>    End_Procedure
91274>>>>>>>>>>>>>
91274>>>>>>>>>>>>>    Procedure SetLexer
91276>>>>>>>>>>>>>        Boolean bInit
91276>>>>>>>>>>>>>        Integer iRet
91276>>>>>>>>>>>>>        Integer iLanguage
91276>>>>>>>>>>>>>        Integer iLexer
91276>>>>>>>>>>>>>        String  sKeywords sScopeKeywords1 sScopeKeywords2 sOperators
91276>>>>>>>>>>>>>        String  sLanguage sLexerLang
91276>>>>>>>>>>>>>        String  sHotKeys
91276>>>>>>>>>>>>>
91276>>>>>>>>>>>>>        Get psLanguage of ghoEditorProperties  to sLanguage
91277>>>>>>>>>>>>>        Move (CM_SetLanguage(Self,sLanguage))  to iRet
91278>>>>>>>>>>>>>        Get EditorMessage SCI_GETLEXER 0 0     to iLexer
91279>>>>>>>>>>>>>        Move (ZeroString(255)) to sLexerLang
91280>>>>>>>>>>>>>        Get EditorMessage SCI_GETLEXERLANGUAGE 0 (AddressOf(sLexerLang)) to iRet
91281>>>>>>>>>>>>>        Get FindLanguage    of ghoEditorProperties sLanguage    to iLanguage
91282>>>>>>>>>>>>>
91282>>>>>>>>>>>>>        If (iLexer=SCLEX_DATAFLEX) Begin
91284>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szKeywords(ghoEditorProperties, iLanguage))         to sKeywords
91285>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szScopeKeywords1(ghoEditorProperties, iLanguage))   to sScopeKeywords1
91286>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szScopeKeywords2(ghoEditorProperties, iLanguage))   to sScopeKeywords2
91287>>>>>>>>>>>>>            Get SCKeywords (psLanguages.szOperators(ghoEditorProperties,iLanguage))         to sOperators
91288>>>>>>>>>>>>>            Move (Replaces("^",sOperators,"")) to sOperators // The ^ char is a wildcard match in scintilla, the result is EVERYTHING is an operator, so remove it before passing it, it is a hardcoded operator in scintilla.
91289>>>>>>>>>>>>>            // Fill the arrays for normalizing case feature when typing
91289>>>>>>>>>>>>>            Get InitializedLanguage of oNormalizeCase SCLEX_DATAFLEX to bInit
91290>>>>>>>>>>>>>            If (bInit=False) Begin
91292>>>>>>>>>>>>>                Send AddKeywords   of oNormalizeCase SCLEX_DATAFLEX sKeywords
91293>>>>>>>>>>>>>                Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords1
91294>>>>>>>>>>>>>                Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords2
91295>>>>>>>>>>>>>            End
91295>>>>>>>>>>>>>>
91295>>>>>>>>>>>>>            // Supply the keywords/scope keywords in lower case as the lexer matches on lowercase characters
91295>>>>>>>>>>>>>            Move (Lowercase(sKeywords)) to sKeywords
91296>>>>>>>>>>>>>            Move (sKeywords+Character(0)) to sKeywords
91297>>>>>>>>>>>>>            Move (Lowercase(sScopeKeywords1)) to sScopeKeywords1
91298>>>>>>>>>>>>>            Move (Lowercase(sScopeKeywords2)) to sScopeKeywords2
91299>>>>>>>>>>>>>            Move (Lowercase(sOperators))      to sOperators
91300>>>>>>>>>>>>>            Send EditorMessage SCI_SETKEYWORDS 0 (AddressOf(sKeywords))         // language keywords
91301>>>>>>>>>>>>>            If (sScopeKeywords1<>"" and sScopeKeywords2<>"") Begin
91303>>>>>>>>>>>>>                Send EditorMessage SCI_SETKEYWORDS 1 (AddressOf(sScopeKeywords1)) // scope open
91304>>>>>>>>>>>>>                Send EditorMessage SCI_SETKEYWORDS 2 (AddressOf(sScopeKeywords2)) // scope close
91305>>>>>>>>>>>>>                Send EditorMessage SCI_SETKEYWORDS 3 (AddressOf(sOperators))      // operators
91306>>>>>>>>>>>>>            End
91306>>>>>>>>>>>>>>
91306>>>>>>>>>>>>>            //
91306>>>>>>>>>>>>>        End
91306>>>>>>>>>>>>>>
91306>>>>>>>>>>>>>        // Use shortcut keys as defined in hammer config codemaxedit.ini file.
91306>>>>>>>>>>>>>        Send RegisterAllInternalCommands
91307>>>>>>>>>>>>>        Send RegisterExtraCommands
91308>>>>>>>>>>>>>        Get psEditorHotKeys of ghoEditorProperties to sHotKeys
91309>>>>>>>>>>>>>        Get CMSetHotkeys sHotKeys  to iRet
91310>>>>>>>>>>>>>    End_Procedure
91311>>>>>>>>>>>>>
91311>>>>>>>>>>>>>    Function Line_Count Returns Integer
91313>>>>>>>>>>>>>        Integer iCount
91313>>>>>>>>>>>>>        Get SC_LineCount to iCount
91314>>>>>>>>>>>>>//        Get CM_GetLineCount to iCount
91314>>>>>>>>>>>>>        Function_Return iCount
91315>>>>>>>>>>>>>    End_Function
91316>>>>>>>>>>>>>
91316>>>>>>>>>>>>>    Function Line Integer iLine Returns String
91318>>>>>>>>>>>>>        String sLine
91318>>>>>>>>>>>>>        Get CM_GetLine iLine to sLine
91319>>>>>>>>>>>>>        Function_Return sLine
91320>>>>>>>>>>>>>    End_Function
91321>>>>>>>>>>>>>
91321>>>>>>>>>>>>>    Procedure AppendText String sText
91323>>>>>>>>>>>>>        Integer eSuccess
91323>>>>>>>>>>>>>        Get CM_AddText sText to eSuccess
91324>>>>>>>>>>>>>    End_Procedure
91325>>>>>>>>>>>>>
91325>>>>>>>>>>>>>End_Class
91326>>>>>>>>>>>Use seq_chnl.pkg
91326>>>>>>>>>>>
91326>>>>>>>>>>>// On_Key constant for Ctrl+Shift+Tab
91326>>>>>>>>>>>Define C_CtrlShiftTab for 7170
91326>>>>>>>>>>>Class cScintillaRefactorEditor is a cScintillaEdit
91327>>>>>>>>>>>    
91327>>>>>>>>>>>    Procedure Construct_Object
91329>>>>>>>>>>>        Forward Send Construct_Object
91331>>>>>>>>>>>
91331>>>>>>>>>>>        Set peAnchors to anAll
91332>>>>>>>>>>>        
91332>>>>>>>>>>>        Property Boolean piInSetFocus False
91333>>>>>>>>>>>        Property DateTime pdtCurrentFileDateTime
91334>>>>>>>>>>>        Property String psCodeFile
91335>>>>>>>>>>>        
91335>>>>>>>>>>>        On_Key Key_Ctrl+Key_Tab Send Switch_Next_View
91336>>>>>>>>>>>        On_Key C_CtrlShiftTab   Send Switch_Prior_View
91337>>>>>>>>>>>        On_Key Key_Ctrl+Key_S   Send Request_Save
91338>>>>>>>>>>>        On_Key Key_Ctrl+Key_F   Send CME_Find
91339>>>>>>>>>>>        On_Key Key_F3           Send CME_FindNext
91340>>>>>>>>>>>        On_Key Key_Shift+Key_F3 Send CME_FindPrevious   
91341>>>>>>>>>>>        On_Key Key_Ctrl+Key_G   Send CME_GotoLine  
91342>>>>>>>>>>>        
91342>>>>>>>>>>>        On_Key Key_Ctrl+Key_Alt+Key_F3 Send CME_FindReplace  
91343>>>>>>>>>>>    End_Procedure
91344>>>>>>>>>>>    
91344>>>>>>>>>>>    // These three should only be send when the function library is not called,
91344>>>>>>>>>>>    // from the main program DFRefactor. The program instead calls function 
91344>>>>>>>>>>>    // RefactorSourceFileInEditor from the EditorView.vw.
91344>>>>>>>>>>>    // Note that a WriteDataToEditor call is needed before calling these functions,
91344>>>>>>>>>>>    // to write the asSourceFile string array to the editor.
91344>>>>>>>>>>>    // After calling the function a WriteDataToDisk call should be made. 
91344>>>>>>>>>>>//    Function RefactorNormalizeCase String[] ByRef asSourceFile Returns Boolean
91344>>>>>>>>>>>//        Boolean bChanged bOK
91344>>>>>>>>>>>//        String[] ByRef asSourceFileOrg
91344>>>>>>>>>>>//        
91344>>>>>>>>>>>//        Move False to bChanged
91344>>>>>>>>>>>//        Move asSourceFile to asSourceFileOrg
91344>>>>>>>>>>>//        Get WriteDataToEditor asSourceFile to bOK
91344>>>>>>>>>>>//        If (bOK = True) Begin
91344>>>>>>>>>>>//            Send RefactorNormalizeCase                                   
91344>>>>>>>>>>>//            Get EditorDataAsStringArray to asSourceFile
91344>>>>>>>>>>>//            Move (not(IsSameArray(asSourceFile, asSourceFileOrg))) to bChanged
91344>>>>>>>>>>>//        End
91344>>>>>>>>>>>//        Function_Return bChanged
91344>>>>>>>>>>>//    End_Function
91344>>>>>>>>>>>//        
91344>>>>>>>>>>>//    Function RefactorReIndent String[] ByRef asSourceFile Returns Integer
91344>>>>>>>>>>>//        Boolean bChanged bOK
91344>>>>>>>>>>>//        String[] ByRef asSourceFileOrg
91344>>>>>>>>>>>//        
91344>>>>>>>>>>>//        Move False to bChanged
91344>>>>>>>>>>>//        Move asSourceFile to asSourceFileOrg
91344>>>>>>>>>>>//        Get WriteDataToEditor asSourceFile to bOK
91344>>>>>>>>>>>//        If (bOK = True) Begin
91344>>>>>>>>>>>//            Send RefactorReIndent
91344>>>>>>>>>>>//            Get EditorDataAsStringArray to asSourceFile
91344>>>>>>>>>>>//            Move (not(IsSameArray(asSourceFile, asSourceFileOrg))) to bChanged
91344>>>>>>>>>>>//        End
91344>>>>>>>>>>>//        Function_Return bChanged
91344>>>>>>>>>>>//    End_Function
91344>>>>>>>>>>>//        
91344>>>>>>>>>>>//    Function RefactorDropSelf String[] ByRef asSourceFile Returns Integer
91344>>>>>>>>>>>//        Boolean bChanged bOK
91344>>>>>>>>>>>//        String[] ByRef asSourceFileOrg
91344>>>>>>>>>>>//
91344>>>>>>>>>>>//        Move False to bChanged
91344>>>>>>>>>>>//        Move asSourceFile to asSourceFileOrg
91344>>>>>>>>>>>//        Get WriteDataToEditor asSourceFile to bOK
91344>>>>>>>>>>>//        If (bOK = True) Begin
91344>>>>>>>>>>>//            Send RefactorDropSelf
91344>>>>>>>>>>>//            Get EditorDataAsStringArray to asSourceFile
91344>>>>>>>>>>>//            Move (not(IsSameArray(asSourceFile, asSourceFileOrg))) to bChanged
91344>>>>>>>>>>>//        End
91344>>>>>>>>>>>//        Function_Return bChanged
91344>>>>>>>>>>>//    End_Function
91344>>>>>>>>>>>
91344>>>>>>>>>>>    Function ReadImageDataToStringArray Integer iImg Returns String[]
91346>>>>>>>>>>>        Integer iChannel iCount
91346>>>>>>>>>>>        String sTextValue sLine
91346>>>>>>>>>>>        Boolean bSeqEof
91346>>>>>>>>>>>        String[] asCode
91347>>>>>>>>>>>        
91347>>>>>>>>>>>        Move "" to sTextValue
91348>>>>>>>>>>>        Move 0 to iCount
91349>>>>>>>>>>>        
91349>>>>>>>>>>>        Get Seq_New_Channel to iChannel
91350>>>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
91352>>>>>>>>>>>             Send Stop_box "No channel available. Function: 'ReadImageDataToStringArray'"
91353>>>>>>>>>>>             Function_Return asCode
91354>>>>>>>>>>>        End
91354>>>>>>>>>>>>
91354>>>>>>>>>>>        
91354>>>>>>>>>>>        Send Delete_Data
91355>>>>>>>>>>>        Direct_Input channel iChannel ("image: " + String(iImg))
91357>>>>>>>>>>>        
91357>>>>>>>>>>>        While (SeqEof = False)
91361>>>>>>>>>>>            Readln channel iChannel sLine
91363>>>>>>>>>>>            Move sLine to asCode[iCount]
91364>>>>>>>>>>>            Increment iCount
91365>>>>>>>>>>>        Loop
91366>>>>>>>>>>>>
91366>>>>>>>>>>>        Close_Input channel iChannel
91368>>>>>>>>>>>        Send Seq_Release_Channel iChannel 
91369>>>>>>>>>>>        Move (ResizeArray(asCode, (iCount -1))) to asCode
91370>>>>>>>>>>>        
91370>>>>>>>>>>>        Function_Return asCode
91371>>>>>>>>>>>    End_Function
91372>>>>>>>>>>>    
91372>>>>>>>>>>>    Function ToggleScopeBlocks Returns Integer
91374>>>>>>>>>>>        Integer iMode
91374>>>>>>>>>>>        Get EditorMessage SCI_FOLDALL to iMode
91375>>>>>>>>>>>        Function_Return iMode
91376>>>>>>>>>>>    End_Function
91377>>>>>>>>>>>    
91377>>>>>>>>>>>    // Needed by the toolbar system.
91377>>>>>>>>>>>    Procedure Request_Save
91379>>>>>>>>>>>        Send SaveFile
91380>>>>>>>>>>>    End_Procedure
91381>>>>>>>>>>>    
91381>>>>>>>>>>>    Procedure Help
91383>>>>>>>>>>>       Delegate Send Help
91385>>>>>>>>>>>    End_Procedure
91386>>>>>>>>>>>
91386>>>>>>>>>>>    Procedure SaveFile
91388>>>>>>>>>>>        Boolean bOK
91388>>>>>>>>>>>
91388>>>>>>>>>>>        Send DispatchAnyKey
91389>>>>>>>>>>>        Get WriteToDisk to bOK
91390>>>>>>>>>>>        If (bOK = False) Begin
91392>>>>>>>>>>>            Send Info_Box "An error occured and the file couldn't be saved properly."
91393>>>>>>>>>>>        End
91393>>>>>>>>>>>>
91393>>>>>>>>>>>        Else Begin
91394>>>>>>>>>>>            Set ActionText of (StatusBar_Id(Self))  to "Changes saved!"
91395>>>>>>>>>>>        End
91395>>>>>>>>>>>>
91395>>>>>>>>>>>    End_Procedure
91396>>>>>>>>>>>    
91396>>>>>>>>>>>    // Helper function (to SaveFile)
91396>>>>>>>>>>>    Function WriteToDisk Returns Boolean
91398>>>>>>>>>>>        String sFileName
91398>>>>>>>>>>>        Integer eResult
91398>>>>>>>>>>>        Boolean bOK
91398>>>>>>>>>>>
91398>>>>>>>>>>>        Get psCodeFile to sFileName
91399>>>>>>>>>>>        Get CM_SaveFile sFileName False to eResult
91400>>>>>>>>>>>        Send FillFileTimeStamp sFileName // Update the filetime.
91401>>>>>>>>>>>
91401>>>>>>>>>>>        Function_Return (eResult = CME_SUCCESS)
91402>>>>>>>>>>>    End_Function
91403>>>>>>>>>>>
91403>>>>>>>>>>>    Function WriteDataToEditor String[] asCode Returns Boolean
91405>>>>>>>>>>>        Integer iCount iSize     
91405>>>>>>>>>>>        String sLine
91405>>>>>>>>>>>        
91405>>>>>>>>>>>        Send Delete_Data
91406>>>>>>>>>>>        Move (SizeOfArray(asCode)) to iSize
91407>>>>>>>>>>>        Decrement iSize
91408>>>>>>>>>>>        
91408>>>>>>>>>>>        For iCount from 0 to iSize
91414>>>>>>>>>>>>
91414>>>>>>>>>>>            Move asCode[iCount] to sLine
91415>>>>>>>>>>>            If (iCount < iSize) Begin
91417>>>>>>>>>>>                Move (sLine + CS_CRLF) to sLine
91418>>>>>>>>>>>            End
91418>>>>>>>>>>>>
91418>>>>>>>>>>>            Send AppendText sLine
91419>>>>>>>>>>>        Loop
91420>>>>>>>>>>>>
91420>>>>>>>>>>>        
91420>>>>>>>>>>>        Function_Return True
91421>>>>>>>>>>>    End_Function
91422>>>>>>>>>>>
91422>>>>>>>>>>>    Function EditorDataAsStringArray Returns String[]
91424>>>>>>>>>>>        String[] asCode
91425>>>>>>>>>>>        String sLine
91425>>>>>>>>>>>        Integer iSize iCount 
91425>>>>>>>>>>>        
91425>>>>>>>>>>>        Get Line_Count to iSize   
91426>>>>>>>>>>>        Decrement iSize
91427>>>>>>>>>>>        For iCount from 0 to iSize
91433>>>>>>>>>>>>
91433>>>>>>>>>>>            Get Line iCount to sLine
91434>>>>>>>>>>>            Move sLine to asCode[iCount]    
91435>>>>>>>>>>>        Loop                                  
91436>>>>>>>>>>>>
91436>>>>>>>>>>>        
91436>>>>>>>>>>>        Function_Return asCode
91437>>>>>>>>>>>    End_Function   
91438>>>>>>>>>>>
91438>>>>>>>>>>>    Procedure JumpToSourceLine Integer iLine
91440>>>>>>>>>>>        Handle hoEdit
91440>>>>>>>>>>>        Get phoCodeMaxEditor to hoEdit    
91441>>>>>>>>>>>        If (hoEdit <> 0) Begin
91443>>>>>>>>>>>            Send Activate of hoEdit
91444>>>>>>>>>>>            Send EditorMessage of hoEdit SCI_GOTOLINE iLine
91445>>>>>>>>>>>        End
91445>>>>>>>>>>>>
91445>>>>>>>>>>>    End_Procedure
91446>>>>>>>>>>>            
91446>>>>>>>>>>>    Procedure LoadFile String sFileName
91448>>>>>>>>>>>        Integer eStatus
91448>>>>>>>>>>>        
91448>>>>>>>>>>>        If (sFileName <> "") Begin
91450>>>>>>>>>>>            Set psCodeFile to sFileName
91451>>>>>>>>>>>            Send Delete_Data
91452>>>>>>>>>>>            Get CM_OpenFile sFileName to eStatus
91453>>>>>>>>>>>            Send FillFileTimeStamp sFileName // Update the filetime.  
91454>>>>>>>>>>>            // Activate the Editor object(!) and view.
91454>>>>>>>>>>>            Send Activate
91455>>>>>>>>>>>        End
91455>>>>>>>>>>>>
91455>>>>>>>>>>>    End_Procedure   
91456>>>>>>>>>>>    
91456>>>>>>>>>>>    Procedure Request_Clear
91458>>>>>>>>>>>        Send Delete_Data
91459>>>>>>>>>>>    End_Procedure
91460>>>>>>>>>>>
91460>>>>>>>>>>>    Function CharacterCount Returns Integer
91462>>>>>>>>>>>        Integer iLineCount iStartPos iEndPos
91462>>>>>>>>>>>        Integer iTotalCharacters
91462>>>>>>>>>>>
91462>>>>>>>>>>>        Move 0 to iTotalCharacters
91463>>>>>>>>>>>        Get EditorMessage SCI_GETLINECOUNT 0 0 to iLineCount
91464>>>>>>>>>>>        If (iLineCount > 0) Begin
91466>>>>>>>>>>>            Get EditorMessage SCI_POSITIONFROMLINE 0 0 to iStartPos
91467>>>>>>>>>>>            Get EditorMessage SCI_GETLINEENDPOSITION (iLineCount - 1) 0 to iEndPos
91468>>>>>>>>>>>            Get EditorMessage SCI_COUNTCHARACTERS iStartPos iEndPos to iTotalCharacters
91469>>>>>>>>>>>        End
91469>>>>>>>>>>>>
91469>>>>>>>>>>>
91469>>>>>>>>>>>        Function_Return iTotalCharacters
91470>>>>>>>>>>>    End_Function
91471>>>>>>>>>>>
91471>>>>>>>>>>>    Procedure ApplyEditorOptions
91473>>>>>>>>>>>        Forward Send ApplyEditorOptions
91475>>>>>>>>>>>    End_Procedure
91476>>>>>>>>>>>
91476>>>>>>>>>>>    Procedure FillFileTimeStamp String sFileName
91478>>>>>>>>>>>        DateTime dtCurrentFileDateTime
91478>>>>>>>>>>>        Get FileModTime sFileName  to dtCurrentFileDateTime
91479>>>>>>>>>>>        Set pdtCurrentFileDateTime to dtCurrentFileDateTime
91480>>>>>>>>>>>    End_Procedure
91481>>>>>>>>>>>
91481>>>>>>>>>>>    // Returns the DateTime of the passed file name was modified, with seconds (only) precision.
91481>>>>>>>>>>>    Function FileModTime String sFileName Returns DateTime
91483>>>>>>>>>>>        Date dDate
91483>>>>>>>>>>>        Integer iYY iHH iMM iSS
91483>>>>>>>>>>>        Boolean bExists
91483>>>>>>>>>>>        DateTime dtFileDateTime
91483>>>>>>>>>>>
91483>>>>>>>>>>>        Move (NullDateTime()) to dtFileDateTime
91484>>>>>>>>>>>        Get vFilePathExists sFileName to bExists
91485>>>>>>>>>>>        If (bExists = True) Begin
91487>>>>>>>>>>>            Get_File_Mod_Time sFileName to dDate iHH iMM iSS
91491>>>>>>>>>>>            Move dDate            to dtFileDateTime
91492>>>>>>>>>>>            Move (DateGetYear       (dtFileDateTime))      to iYY
91493>>>>>>>>>>>            Move (DateSetYear       (dtFileDateTime, iYY)) to dtFileDateTime
91494>>>>>>>>>>>            Move (DateSetHour       (dtFileDateTime, iHH)) to dtFileDateTime
91495>>>>>>>>>>>            Move (DateSetMinute     (dtFileDateTime, iMM)) to dtFileDateTime
91496>>>>>>>>>>>            Move (DateSetSecond     (dtFileDateTime, iSS)) to dtFileDateTime
91497>>>>>>>>>>>            Move (DateSetMillisecond(dtFileDateTime, 0))   to dtFileDateTime
91498>>>>>>>>>>>        End
91498>>>>>>>>>>>>
91498>>>>>>>>>>>
91498>>>>>>>>>>>        Function_Return dtFileDateTime
91499>>>>>>>>>>>    End_Function
91500>>>>>>>>>>>
91500>>>>>>>>>>>    Function IsFileTimeNewer String sFileName Returns Boolean
91502>>>>>>>>>>>        Boolean bExists bIsNewer
91502>>>>>>>>>>>        DateTime dtCurrentFileDateTime dtCompareFileDateTime
91502>>>>>>>>>>>
91502>>>>>>>>>>>        Move False to bIsNewer
91503>>>>>>>>>>>        Get vFilePathExists sFileName to bExists
91504>>>>>>>>>>>        If (bExists = True) Begin
91506>>>>>>>>>>>            Get pdtCurrentFileDateTime to dtCurrentFileDateTime
91507>>>>>>>>>>>            Get FileModTime sFileName  to dtCompareFileDateTime
91508>>>>>>>>>>>            Move (dtCompareFileDateTime > dtCurrentFileDateTime) to bIsNewer
91509>>>>>>>>>>>        End
91509>>>>>>>>>>>>
91509>>>>>>>>>>>        Function_Return bIsNewer
91510>>>>>>>>>>>    End_Function
91511>>>>>>>>>>>
91511>>>>>>>>>>>    Procedure Set piTabSize Integer iTabSize
91513>>>>>>>>>>>        Send EditorMessage SCI_SETTABWIDTH iTabSize
91514>>>>>>>>>>>        Set piTabSize of ghoEditorProperties to iTabSize
91515>>>>>>>>>>>        Send SaveIni  of ghoEditorProperties
91516>>>>>>>>>>>    End_Procedure
91517>>>>>>>>>>>
91517>>>>>>>>>>>    Function piTabSize Returns Integer
91519>>>>>>>>>>>        Integer iTabSize
91519>>>>>>>>>>>        Send EditorMessage SCI_GETTABWIDTH iTabSize
91520>>>>>>>>>>>        Function_Return iTabSize
91521>>>>>>>>>>>    End_Function
91522>>>>>>>>>>>
91522>>>>>>>>>>>    Procedure UpdateStatusBar String sText Boolean bIdleTextOnly Integer iLi Integer iChrs
91524>>>>>>>>>>>        Handle hoStatusBar
91524>>>>>>>>>>>        Integer iLines iCharacters
91524>>>>>>>>>>>
91524>>>>>>>>>>>        Move (StatusBar_Id(Self)) to hoStatusBar   
91525>>>>>>>>>>>        If (num_arguments > 2) Begin
91527>>>>>>>>>>>            Move iChrs to iCharacters
91528>>>>>>>>>>>            If (iCharacters = 0) Begin
91530>>>>>>>>>>>                Move 0 to iLines
91531>>>>>>>>>>>            End                 
91531>>>>>>>>>>>>
91531>>>>>>>>>>>            Else Begin
91532>>>>>>>>>>>                Move iLi to iLines
91533>>>>>>>>>>>            End
91533>>>>>>>>>>>>
91533>>>>>>>>>>>            Set NumberOfEditorLines      of hoStatusBar to iLines
91534>>>>>>>>>>>            Set NumberOfEditorCharacters of hoStatusBar to iCharacters
91535>>>>>>>>>>>        End
91535>>>>>>>>>>>>
91535>>>>>>>>>>>        Else Begin
91536>>>>>>>>>>>            If (bIdleTextOnly = True) Begin
91538>>>>>>>>>>>                Set psIdleText of hoStatusBar to sText
91539>>>>>>>>>>>                Set ActionText of hoStatusBar to ""
91540>>>>>>>>>>>            End
91540>>>>>>>>>>>>
91540>>>>>>>>>>>            Else Begin
91541>>>>>>>>>>>                Set ActionText of hoStatusBar to sText 
91542>>>>>>>>>>>            End
91542>>>>>>>>>>>>
91542>>>>>>>>>>>        End
91542>>>>>>>>>>>>
91542>>>>>>>>>>>        Send PumpMsgQueue of Desktop
91543>>>>>>>>>>>    End_Procedure    
91544>>>>>>>>>>>    
91544>>>>>>>>>>>    Procedure Request_Save
91546>>>>>>>>>>>        Send SaveFile    
91547>>>>>>>>>>>    End_Procedure
91548>>>>>>>>>>>    
91548>>>>>>>>>>>    Procedure Changed_State Boolean bChanged
91550>>>>>>>>>>>        Send EditorMessage SCI_GETMODIFY bChanged
91551>>>>>>>>>>>    End_Procedure
91552>>>>>>>>>>>    
91552>>>>>>>>>>>    Function Changed_State Returns Boolean
91554>>>>>>>>>>>        Boolean bChanged
91554>>>>>>>>>>>        Get CM_IsModified to bChanged
91555>>>>>>>>>>>        Function_Return bChanged        
91556>>>>>>>>>>>    End_Function
91557>>>>>>>>>>>    
91557>>>>>>>>>>>    Procedure OnChange
91559>>>>>>>>>>>        Boolean bChanged
91559>>>>>>>>>>>        Get CM_IsModified to bChanged
91560>>>>>>>>>>>        If (bChanged = True) Begin
91562>>>>>>>>>>>            Set ActionText of (StatusBar_Id(Self))  to ""
91563>>>>>>>>>>>        End
91563>>>>>>>>>>>>
91563>>>>>>>>>>>    End_Procedure
91564>>>>>>>>>>>
91564>>>>>>>>>>>    // Used for checking if the file in editor has changed externally and
91564>>>>>>>>>>>    // if so reload it.
91564>>>>>>>>>>>    Procedure OnSetFocus
91566>>>>>>>>>>>        Integer iRet iCurrentLine
91566>>>>>>>>>>>        String  sMsg  sFileName
91566>>>>>>>>>>>        Handle  hoMain hoEditor
91566>>>>>>>>>>>        Boolean bUserModified bHasChangedExternal bDoReloadFile
91566>>>>>>>>>>>        Integer iLines iSize
91566>>>>>>>>>>>
91566>>>>>>>>>>>        Get Line_Count to iLines
91567>>>>>>>>>>>        Get CharacterCount to iSize
91568>>>>>>>>>>>        Send UpdateStatusBar "" False iLines iSize
91569>>>>>>>>>>>        Send OnSelChange
91570>>>>>>>>>>>        Send OnOvertypeChange
91571>>>>>>>>>>>        Move False to bDoReloadFile
91572>>>>>>>>>>>
91572>>>>>>>>>>>        Get Main_Panel_Id to hoMain
91573>>>>>>>>>>>        If (not(piInSetFocus(Self))) Begin // recursive protection
91575>>>>>>>>>>>            Set piInSetFocus to True
91576>>>>>>>>>>>            Get psCodeFile to sFileName
91577>>>>>>>>>>>            If (sFileName = "") Begin
91579>>>>>>>>>>>                Procedure_Return
91580>>>>>>>>>>>            End
91580>>>>>>>>>>>>
91580>>>>>>>>>>>            Get IsFileTimeNewer sFileName to bHasChangedExternal
91581>>>>>>>>>>>            Get CM_IsModified to bUserModified
91582>>>>>>>>>>>            If (bHasChangedExternal and bUserModified) Begin
91584>>>>>>>>>>>                If (bUserModified) Begin
91586>>>>>>>>>>>                    Append sMsg "The file has been changed by another program.\n\n"
91587>>>>>>>>>>>                End
91587>>>>>>>>>>>>
91587>>>>>>>>>>>                Append sMsg "Do you want to reload it?\n"
91588>>>>>>>>>>>                If (bUserModified) Begin
91590>>>>>>>>>>>                    Append sMsg "Pressing YES will discard any changes made.\n"
91591>>>>>>>>>>>                End
91591>>>>>>>>>>>>
91591>>>>>>>>>>>
91591>>>>>>>>>>>                Get YesNo_Box sMsg (Label(hoMain)) to iRet
91592>>>>>>>>>>>                If (iRet = MBR_Yes) Begin  
91594>>>>>>>>>>>                    Move True to bDoReloadFile
91595>>>>>>>>>>>                End
91595>>>>>>>>>>>>
91595>>>>>>>>>>>                Else Begin
91596>>>>>>>>>>>                    Send FillFileTimeStamp sFileName // Update the file modified datetime.
91597>>>>>>>>>>>                End
91597>>>>>>>>>>>>
91597>>>>>>>>>>>            End
91597>>>>>>>>>>>>
91597>>>>>>>>>>>
91597>>>>>>>>>>>            // If file has changed externally, but we didn't edit, then do not ask, just refresh
91597>>>>>>>>>>>            If (bHasChangedExternal and bUserModified = False) Begin
91599>>>>>>>>>>>                Get SC_LineCount to iRet
91600>>>>>>>>>>>                If (iRet > 1) Begin
91602>>>>>>>>>>>                    Move True to bDoReloadFile
91603>>>>>>>>>>>                End
91603>>>>>>>>>>>>
91603>>>>>>>>>>>            End
91603>>>>>>>>>>>>
91603>>>>>>>>>>>            If (bDoReloadFile = True) Begin
91605>>>>>>>>>>>                Move "The Editor file has been changed by another program.\n\n" to sMsg
91606>>>>>>>>>>>                Append sMsg "Reload?\n"
91607>>>>>>>>>>>                Get YesNo_Box sMsg (Label(hoMain)) to iRet
91608>>>>>>>>>>>                If (iRet = MBR_Yes) Begin
91610>>>>>>>>>>>                    Get CurrentLine to iCurrentLine
91611>>>>>>>>>>>                    Get CM_OpenFile sFileName to iRet
91612>>>>>>>>>>>                    Send EditorMessage SCI_SETSAVEPOINT
91613>>>>>>>>>>>                    If (iCurrentLine <> 0) Begin
91615>>>>>>>>>>>                        Send EditorMessage SCI_GOTOLINE iCurrentLine
91616>>>>>>>>>>>                    End
91616>>>>>>>>>>>>
91616>>>>>>>>>>>                    Send FillFileTimeStamp sFileName // Update the file modified datetime.
91617>>>>>>>>>>>                End
91617>>>>>>>>>>>>
91617>>>>>>>>>>>            End
91617>>>>>>>>>>>>
91617>>>>>>>>>>>            Set piInSetFocus to False
91618>>>>>>>>>>>        End
91618>>>>>>>>>>>>
91618>>>>>>>>>>>    End_Procedure
91619>>>>>>>>>>>
91619>>>>>>>>>>>    Procedure End_Construct_Object
91621>>>>>>>>>>>        Forward Send End_Construct_Object
91623>>>>>>>>>>>
91623>>>>>>>>>>>    End_Procedure
91624>>>>>>>>>>>
91624>>>>>>>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
91626>>>>>>>>>>>        String sSWSFile
91626>>>>>>>>>>>        Forward Send OnFileDropped sFilename bLast
91628>>>>>>>>>>>        If (bLast = True) Begin
91630>>>>>>>>>>>            Get psSWSFile of ghoApplication to sSWSFile
91631>>>>>>>>>>>            If (sSWSFile = "") Begin
91633>>>>>>>>>>>                Send Info_Box "You need to select a workspace first."
91634>>>>>>>>>>>                Procedure_Return
91635>>>>>>>>>>>            End
91635>>>>>>>>>>>>
91635>>>>>>>>>>>            Send UpdateSourceFileNameDisplay of ghoApplication sFileName
91636>>>>>>>>>>>            Send LoadFile sFilename
91637>>>>>>>>>>>        End
91637>>>>>>>>>>>>
91637>>>>>>>>>>>    End_Procedure
91638>>>>>>>>>>>
91638>>>>>>>>>>>End_Class
91639>>>>>>>>>Use cRemoveUnusedLocals.pkg
91639>>>>>>>>>Use cUnusedSourceFiles.pkg
Including file: cUnusedSourceFiles.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cUnusedSourceFiles.pkg)
91639>>>>>>>>>>>// Original work by Sean Bamforth, APG.
91639>>>>>>>>>>>// Adapted to this project by Nils Svedmyr, RDC Tools International
91639>>>>>>>>>>>//
91639>>>>>>>>>>>Use Batchdd.pkg
91639>>>>>>>>>>>Use cApplication.pkg
91639>>>>>>>>>>>Use vWin32fh.pkg
91639>>>>>>>>>>>
91639>>>>>>>>>>>Struct tUnusedSourceFiles
91639>>>>>>>>>>>    String sUsedPackageName
91639>>>>>>>>>>>    String sFileName
91639>>>>>>>>>>>    String sPath
91639>>>>>>>>>>>    Integer iRow
91639>>>>>>>>>>>End_Struct
91639>>>>>>>>>>>
91639>>>>>>>>>>>Use RefactorFunctionConstants.inc
91639>>>>>>>>>>>//Use UnusedSourceFiles.dg
91639>>>>>>>>>>>
91639>>>>>>>>>>>
91639>>>>>>>>>>>Class cUnusedSourceFiles is a BusinessProcess
91640>>>>>>>>>>>
91640>>>>>>>>>>>    Procedure Construct_Object
91642>>>>>>>>>>>        Forward Send Construct_Object
91644>>>>>>>>>>>        
91644>>>>>>>>>>>        // The path and psFileFilter needs to be set to the current workspace before using this class
91644>>>>>>>>>>>        Property String psHomePath (psHome(phoWorkspace(ghoApplication)))
91645>>>>>>>>>>>        Property String psFileFilter "*.src;*.vw;*.sl;*.dg;*.rv;*.bp;*.pkg;*.wo;*.dd;*.inc"
91646>>>>>>>>>>>        
91646>>>>>>>>>>>        Property String[] pasAllFolders
91647>>>>>>>>>>>        Property Integer piNoOfUnusedSourceFiles 0
91648>>>>>>>>>>>        Property Boolean pbOK True
91649>>>>>>>>>>>        //
91649>>>>>>>>>>>        // Return array:
91649>>>>>>>>>>>        Property String[] pasUnusedSource
91650>>>>>>>>>>>    End_Procedure
91651>>>>>>>>>>>
91651>>>>>>>>>>>    Function AllSourceFiles String[] asFolders String sFileFilter Returns tUnusedSourceFiles[]
91653>>>>>>>>>>>        String[] asFileFilters
91654>>>>>>>>>>>        String[] asSearch
91655>>>>>>>>>>>        tUnusedSourceFiles[] asAllSource asSource asEmpty
91655>>>>>>>>>>>        tUnusedSourceFiles[] asAllSource asSource asEmpty
91658>>>>>>>>>>>        Integer iFilterCount iFilterSize iFolderCount iFolderSize iSize iCount iSearchCount iSearchSize iItem
91658>>>>>>>>>>>        String sFolder sFilename
91658>>>>>>>>>>>        tsSearchResult[] SearchResult
91658>>>>>>>>>>>        tsSearchResult[] SearchResult
91659>>>>>>>>>>>
91659>>>>>>>>>>>        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilters
91660>>>>>>>>>>>
91660>>>>>>>>>>>        Move (SizeOfArray(asFolders)) to iFolderSize
91661>>>>>>>>>>>        Decrement iFolderSize
91662>>>>>>>>>>>        Move (SizeOfArray(asFileFilters)) to iFilterSize
91663>>>>>>>>>>>        Decrement iFilterSize
91664>>>>>>>>>>>
91664>>>>>>>>>>>        For iFolderCount From 0 to iFolderSize
91670>>>>>>>>>>>>
91670>>>>>>>>>>>            For iFilterCount From 0 to iFilterSize
91676>>>>>>>>>>>>
91676>>>>>>>>>>>                Move asFolders[iFolderCount] to sFolder
91677>>>>>>>>>>>                Get vFolderFormat sFolder to sFolder
91678>>>>>>>>>>>                Move (Lowercase(sFolder) + asFileFilters[iFilterCount]) to asSearch[SizeOfArray(asSearch)]
91679>>>>>>>>>>>            Loop
91680>>>>>>>>>>>>
91680>>>>>>>>>>>        Loop
91681>>>>>>>>>>>>
91681>>>>>>>>>>>
91681>>>>>>>>>>>        Move (SizeOfArray(asSearch)) to iSize
91682>>>>>>>>>>>        Decrement iSize
91683>>>>>>>>>>>        For iCount From 0 to iSize
91689>>>>>>>>>>>>
91689>>>>>>>>>>>            Move asSearch[iCount]  to sFolder
91690>>>>>>>>>>>            Get ParseFolderName sFolder to sFolder
91691>>>>>>>>>>>            Get vFolderFormat   sFolder to sFolder
91692>>>>>>>>>>>
91692>>>>>>>>>>>            Move 0 to iItem
91693>>>>>>>>>>>            Move asEmpty to asSource
91694>>>>>>>>>>>            Get FileSearch of ghoFileSystem asSearch[iCount] DIRMODE_FILES_ONLY False to SearchResult
91695>>>>>>>>>>>            Move (SizeOfArray(SearchResult)) to iSearchSize
91696>>>>>>>>>>>            Decrement iSearchSize
91697>>>>>>>>>>>            For iSearchCount from 0 to iSearchSize
91703>>>>>>>>>>>>
91703>>>>>>>>>>>                Move sFolder                                to asSource[iItem].sPath
91704>>>>>>>>>>>                Move (SearchResult[iSearchCount].sFilename) to asSource[iItem].sFileName
91705>>>>>>>>>>>                Increment iItem
91706>>>>>>>>>>>            Loop
91707>>>>>>>>>>>>
91707>>>>>>>>>>>
91707>>>>>>>>>>>            Move (AppendArray(asSource, asAllSource)) to asAllSource
91708>>>>>>>>>>>        Loop
91709>>>>>>>>>>>>
91709>>>>>>>>>>>
91709>>>>>>>>>>>        Function_Return asAllSource
91710>>>>>>>>>>>    End_Function
91711>>>>>>>>>>>
91711>>>>>>>>>>>    Function IsUseOrIncludeLine String sInp Returns Boolean
91713>>>>>>>>>>>        Boolean bOK
91713>>>>>>>>>>>
91713>>>>>>>>>>>        Move False to bOK
91714>>>>>>>>>>>        Move (Lowercase(sInp)) to sInp
91715>>>>>>>>>>>        Get StripComment sInp  to sInp
91716>>>>>>>>>>>        Move (Trim(sInp)) to sInp
91717>>>>>>>>>>>
91717>>>>>>>>>>>        If ((Pos("use ", sInp)) = 1) Begin
91719>>>>>>>>>>>            Move True to bOK
91720>>>>>>>>>>>        End
91720>>>>>>>>>>>>
91720>>>>>>>>>>>        If ((Pos("#include ", sInp)) = 1) Begin
91722>>>>>>>>>>>            Move True to bOK
91723>>>>>>>>>>>        End                   
91723>>>>>>>>>>>>
91723>>>>>>>>>>>        // Hardcoded exception for the LoginEncryption.pkg file(!). It should never be removed.
91723>>>>>>>>>>>        If (lowercase(sInp) contains "loginencryption.pkg") Begin
91725>>>>>>>>>>>            Move False to bOK
91726>>>>>>>>>>>        End
91726>>>>>>>>>>>>
91726>>>>>>>>>>>        Function_Return bOK
91727>>>>>>>>>>>    End_Function
91728>>>>>>>>>>>
91728>>>>>>>>>>>    Function StripComment String sLine Returns String
91730>>>>>>>>>>>        Integer iPos
91730>>>>>>>>>>>
91730>>>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
91731>>>>>>>>>>>        If (iPos > 0) Begin
91733>>>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine
91734>>>>>>>>>>>        End
91734>>>>>>>>>>>>
91734>>>>>>>>>>>        Function_Return sLine
91735>>>>>>>>>>>    End_Function
91736>>>>>>>>>>>
91736>>>>>>>>>>>    // Note: The function adds a ".pkg" to the package name if no extension has been specifieds in the source code.
91736>>>>>>>>>>>    Function ExtractPackageName String sLine Returns String
91738>>>>>>>>>>>        Integer iPos
91738>>>>>>>>>>>
91738>>>>>>>>>>>        Move (Trim(Lowercase(sLine))) to sLine
91739>>>>>>>>>>>        Get StripComment sLine to sLine
91740>>>>>>>>>>>        Move (Pos("#include ", sLine)) to iPos
91741>>>>>>>>>>>        If (iPos = 1) Begin
91743>>>>>>>>>>>            Move (Mid(sLine, CI_EOL, (iPos + 8))) to sLine
91744>>>>>>>>>>>        End
91744>>>>>>>>>>>>
91744>>>>>>>>>>>        Move (Pos("use ", sLine)) to iPos
91745>>>>>>>>>>>        If (iPos = 1) Begin
91747>>>>>>>>>>>            Move (Mid(sLine, CI_EOL, (iPos + 3))) to sLine
91748>>>>>>>>>>>        End
91748>>>>>>>>>>>>
91748>>>>>>>>>>>        Move (Trim(sLine)) to sLine
91749>>>>>>>>>>>        If (not(sLine contains ".")) Begin
91751>>>>>>>>>>>            Move (sLine + ".pkg") to sLine
91752>>>>>>>>>>>        End
91752>>>>>>>>>>>>
91752>>>>>>>>>>>
91752>>>>>>>>>>>        Move (Pos(CS_DirSeparator, sLine)) to iPos
91753>>>>>>>>>>>        If (iPos <> 0) Begin
91755>>>>>>>>>>>            Get ParseFileName sLine to sLine
91756>>>>>>>>>>>        End
91756>>>>>>>>>>>>
91756>>>>>>>>>>>
91756>>>>>>>>>>>        Function_Return sLine
91757>>>>>>>>>>>    End_Function
91758>>>>>>>>>>>
91758>>>>>>>>>>>    Function ReadSourceFile String sFilename Returns String[]
91760>>>>>>>>>>>        Integer iCh iFileSize iCount
91760>>>>>>>>>>>        String[] asFile
91761>>>>>>>>>>>
91761>>>>>>>>>>>        Get Seq_New_Channel to iCh
91762>>>>>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin 
91764>>>>>>>>>>>            Error "No Channel Available for Process: Procedure 'ReadSourceFile (cUnusedSourceFiles)'"            
91765>>>>>>>>>>>>
91765>>>>>>>>>>>            Function_Return asFile
91766>>>>>>>>>>>        End
91766>>>>>>>>>>>>
91766>>>>>>>>>>>
91766>>>>>>>>>>>        Move 0 to iCount
91767>>>>>>>>>>>        Get vWin32_APIFileSize sFilename to iFileSize
91768>>>>>>>>>>>        Move (ResizeArray(asFile, iFileSize)) to asFile
91769>>>>>>>>>>>
91769>>>>>>>>>>>        Direct_Input channel iCh ("binary:" + sFilename)
91771>>>>>>>>>>>        While (SeqEof = False)
91775>>>>>>>>>>>            Readln channel iCh asFile[iCount]
91777>>>>>>>>>>>            Increment iCount
91778>>>>>>>>>>>        Loop
91779>>>>>>>>>>>>
91779>>>>>>>>>>>        Close_Input channel iCh
91781>>>>>>>>>>>        Send Seq_Release_Channel iCh
91782>>>>>>>>>>>        Move (ResizeArray(asFile, iCount)) to asFile
91783>>>>>>>>>>>
91783>>>>>>>>>>>        Function_Return asFile
91784>>>>>>>>>>>    End_Function
91785>>>>>>>>>>>
91785>>>>>>>>>>>    Function SingleFileUsedPackages String sFullFilename Returns tUnusedSourceFiles[]
91787>>>>>>>>>>>        tUnusedSourceFiles[] asRetVal
91787>>>>>>>>>>>        tUnusedSourceFiles[] asRetVal
91788>>>>>>>>>>>        String[] asFile
91789>>>>>>>>>>>        String sLine sPath sFilename sPackageName sSourceLine
91789>>>>>>>>>>>        Integer iItem iCount iSize
91789>>>>>>>>>>>        Boolean bOK
91789>>>>>>>>>>>
91789>>>>>>>>>>>        Move 0 to iItem
91790>>>>>>>>>>>        Get ReadSourceFile sFullFilename to asFile
91791>>>>>>>>>>>        Move (SizeOfArray(asFile)) to iSize
91792>>>>>>>>>>>        If (iSize = 0) Begin
91794>>>>>>>>>>>            Function_Return asRetVal
91795>>>>>>>>>>>        End
91795>>>>>>>>>>>>
91795>>>>>>>>>>>
91795>>>>>>>>>>>        Get ParseFolderName sFullFilename  to sPath
91796>>>>>>>>>>>        Get ParseFileName   sFullFilename  to sFilename
91797>>>>>>>>>>>        Set Title_Text of ghoStatusPanel   to ("Scanning for 'Use':" * String(sPath))
91798>>>>>>>>>>>        Set Message_Text of ghoStatusPanel to ("in file:" * String(sFilename))
91799>>>>>>>>>>>        Decrement iSize
91800>>>>>>>>>>>        For iCount from 0 to iSize
91806>>>>>>>>>>>>
91806>>>>>>>>>>>            Move asFile[iCount] to sLine
91807>>>>>>>>>>>            Move (Lowercase(sLine)) to sLine
91808>>>>>>>>>>>            Move (Trim(sLine)) to sSourceLine
91809>>>>>>>>>>>            If (sSourceLine <> "") Begin
91811>>>>>>>>>>>                Get IsUseOrIncludeLine sLine to bOK
91812>>>>>>>>>>>                If (bOK = True) Begin
91814>>>>>>>>>>>                    Get ExtractPackageName sLine to sPackageName
91815>>>>>>>>>>>                    Move sPackageName to asRetVal[iItem].sUsedPackageName
91816>>>>>>>>>>>                    Move sPath        to asRetVal[iItem].sPath
91817>>>>>>>>>>>                    Move sFilename    to asRetVal[iItem].sFileName
91818>>>>>>>>>>>                    Move iCount       to asRetVal[iItem].iRow
91819>>>>>>>>>>>                    Increment iItem
91820>>>>>>>>>>>                End
91820>>>>>>>>>>>>
91820>>>>>>>>>>>            End
91820>>>>>>>>>>>>
91820>>>>>>>>>>>        Loop
91821>>>>>>>>>>>>
91821>>>>>>>>>>>
91821>>>>>>>>>>>        Set Title_Text   of ghoStatusPanel to ""
91822>>>>>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91823>>>>>>>>>>>
91823>>>>>>>>>>>        Function_Return asRetVal
91824>>>>>>>>>>>    End_Function
91825>>>>>>>>>>>
91825>>>>>>>>>>>    Function IncludeOrUseFile String sLine Returns String
91827>>>>>>>>>>>        Integer iPos
91827>>>>>>>>>>>
91827>>>>>>>>>>>        Move (lowercase(sLine)) to sLine
91828>>>>>>>>>>>        Move (Replace("#include ", sLine, "use ")) to sLine
91829>>>>>>>>>>>
91829>>>>>>>>>>>        Move (Pos("use ",sLine)) to iPos
91830>>>>>>>>>>>        If (iPos = 0) Begin
91832>>>>>>>>>>>            Function_Return ""
91833>>>>>>>>>>>        End
91833>>>>>>>>>>>>
91833>>>>>>>>>>>
91833>>>>>>>>>>>        Move (Mid(sLine, CI_EOL, (iPos + 4))) to sLine
91834>>>>>>>>>>>        Move (Trim(sLine)) to sLine
91835>>>>>>>>>>>        If ((Pos(".", sLine)) = 0) Begin
91837>>>>>>>>>>>            Append sLine ".pkg"
91838>>>>>>>>>>>        End
91838>>>>>>>>>>>>
91838>>>>>>>>>>>
91838>>>>>>>>>>>        Function_Return sLine
91839>>>>>>>>>>>    End_Function
91840>>>>>>>>>>>
91840>>>>>>>>>>>    //    Function RemoveStructArrayDuplicates tUnusedSourceFiles[] asUsedSourceFiles Returns tUnusedSourceFiles[]
91840>>>>>>>>>>>    //        tUnusedSourceFiles[] asNoDuplicates
91840>>>>>>>>>>>    //        Integer iSize iCount iItem
91840>>>>>>>>>>>    //        String sUsedPackageName sUsedPackageNameCompare
91840>>>>>>>>>>>    //
91840>>>>>>>>>>>    //        Move 0 to iItem
91840>>>>>>>>>>>    //        Move (SortArray(asUsedSourceFiles))   to asUsedSourceFiles
91840>>>>>>>>>>>    //        Move (SizeOfArray(asUsedSourceFiles)) to iSize
91840>>>>>>>>>>>    //        Decrement iSize
91840>>>>>>>>>>>    //        For iCount from 0 to iSize
91840>>>>>>>>>>>    //            Move asUsedSourceFiles[iCount].sUsedPackageName to sUsedPackageName
91840>>>>>>>>>>>    //            Move asNoDuplicates[iItem].sUsedPackageName     to sUsedPackageNameCompare
91840>>>>>>>>>>>    //            If (Lowercase(sUsedPackageName) <> Lowercase(sUsedPackageNameCompare)) Begin
91840>>>>>>>>>>>    //                Move asUsedSourceFiles[iCount].iRow         to asNoDuplicates[iItem].iRow
91840>>>>>>>>>>>    //                Move asUsedSourceFiles[iCount].sFileName    to asNoDuplicates[iItem].sFileName
91840>>>>>>>>>>>    //                Move asUsedSourceFiles[iCount].sPath        to asNoDuplicates[iItem].sPath
91840>>>>>>>>>>>    //                Move sUsedPackageName                       to asNoDuplicates[iItem].sUsedPackageName
91840>>>>>>>>>>>    //                Increment iItem
91840>>>>>>>>>>>    //            End
91840>>>>>>>>>>>    //        Loop
91840>>>>>>>>>>>    //
91840>>>>>>>>>>>    //        Function_Return asNoDuplicates
91840>>>>>>>>>>>    //    End_Function
91840>>>>>>>>>>>
91840>>>>>>>>>>>    // Note: Only uniqely identifed package files are returned in the struct array.
91840>>>>>>>>>>>    // All duplicates have been removed.
91840>>>>>>>>>>>    Function UsedPackageFiles tUnusedSourceFiles[] asSourceAllFiles Returns tUnusedSourceFiles[]
91842>>>>>>>>>>>        tUnusedSourceFiles[] asSingleFile asUsedSourceFiles
91842>>>>>>>>>>>        tUnusedSourceFiles[] asSingleFile asUsedSourceFiles
91844>>>>>>>>>>>        Integer iCount iSize
91844>>>>>>>>>>>
91844>>>>>>>>>>>        Move (SizeOfArray(asSourceAllFiles)) to iSize
91845>>>>>>>>>>>        Decrement iSize
91846>>>>>>>>>>>        For iCount From 0 to iSize
91852>>>>>>>>>>>>
91852>>>>>>>>>>>            Get SingleFileUsedPackages (asSourceAllFiles[iCount].sPath + String(asSourceAllFiles[iCount].sFileName)) to asSingleFile
91853>>>>>>>>>>>            If (SizeOfArray(asSingleFile) <> 0) Begin
91855>>>>>>>>>>>                Move (AppendArray(asUsedSourceFiles, asSingleFile)) to asUsedSourceFiles
91856>>>>>>>>>>>            End
91856>>>>>>>>>>>>
91856>>>>>>>>>>>        Loop
91857>>>>>>>>>>>>
91857>>>>>>>>>>>
91857>>>>>>>>>>>        // It doesn't make any time difference if duplicates are removed or not.
91857>>>>>>>>>>>        //        Get RemoveStructArrayDuplicates asUsedSourceFiles to asUsedSourceFiles
91857>>>>>>>>>>>
91857>>>>>>>>>>>        Function_Return asUsedSourceFiles
91858>>>>>>>>>>>    End_Function
91859>>>>>>>>>>>
91859>>>>>>>>>>>    Function UnusedPackages tUnusedSourceFiles[] asUsedFiles tUnusedSourceFiles[] asAllFiles Returns tUnusedSourceFiles[]
91861>>>>>>>>>>>        Integer iCount iSize iIndex iItem
91861>>>>>>>>>>>        String sFilename sExt
91861>>>>>>>>>>>        tUnusedSourceFiles[] aUnusedSource
91861>>>>>>>>>>>        tUnusedSourceFiles[] aUnusedSource
91862>>>>>>>>>>>        tUnusedSourceFiles UsedFile
91862>>>>>>>>>>>        tUnusedSourceFiles UsedFile
91862>>>>>>>>>>>
91862>>>>>>>>>>>        Move 0 to iItem
91863>>>>>>>>>>>        Move (SortArray(asUsedFiles))  to asUsedFiles
91864>>>>>>>>>>>        Move (SizeOfArray(asAllFiles)) to iSize
91865>>>>>>>>>>>        Decrement iSize
91866>>>>>>>>>>>
91866>>>>>>>>>>>        For iCount From 0 to iSize
91872>>>>>>>>>>>>
91872>>>>>>>>>>>            Move asAllFiles[iCount].sFileName to sFilename
91873>>>>>>>>>>>            Move (Lowercase(sFilename))       to sFilename
91874>>>>>>>>>>>            Move sFilename                    to UsedFile.sUsedPackageName
91875>>>>>>>>>>>            Get ParseFileExtension sFilename  to sExt
91876>>>>>>>>>>>
91876>>>>>>>>>>>            If (sExt <> "src") Begin
91878>>>>>>>>>>>                Move (SearchArray(UsedFile, asUsedFiles)) to iIndex
91879>>>>>>>>>>>                If (iIndex = -1) Begin                                      
91881>>>>>>>>>>>                    // Fix for Bug #182 "LoginEncryptionKey.inc" should never be listed as an unused source file.
91881>>>>>>>>>>>                    If (Lowercase(asAllFiles[iCount].sFileName) <> "loginencryptionkey.inc") Begin
91883>>>>>>>>>>>                        Move asAllFiles[iCount].sFileName to aUnusedSource[iItem].sFileName
91884>>>>>>>>>>>                        Move asAllFiles[iCount].sPath     to aUnusedSource[iItem].sPath
91885>>>>>>>>>>>                        Increment iItem
91886>>>>>>>>>>>                    End
91886>>>>>>>>>>>>
91886>>>>>>>>>>>                End
91886>>>>>>>>>>>>
91886>>>>>>>>>>>            End
91886>>>>>>>>>>>>
91886>>>>>>>>>>>        Loop
91887>>>>>>>>>>>>
91887>>>>>>>>>>>
91887>>>>>>>>>>>        Function_Return aUnusedSource
91888>>>>>>>>>>>    End_Function
91889>>>>>>>>>>>
91889>>>>>>>>>>>    Procedure OnProcess
91891>>>>>>>>>>>        String sFileFilter sHomePath
91891>>>>>>>>>>>        String[] asAllFolders
91892>>>>>>>>>>>        tUnusedSourceFiles[] asAllSourceFiles asUsedSourceFiles asUsedFiles asUnusedSource
91892>>>>>>>>>>>        tUnusedSourceFiles[] asAllSourceFiles asUsedSourceFiles asUsedFiles asUnusedSource
91896>>>>>>>>>>>        Integer iCh iSize iCount
91896>>>>>>>>>>>
91896>>>>>>>>>>>        Get psFileFilter                                      to sFileFilter
91897>>>>>>>>>>>        Get pasAllFolders                                     to asAllFolders
91898>>>>>>>>>>>        Get AllSourceFiles asAllFolders sFileFilter           to asAllSourceFiles
91899>>>>>>>>>>>        Get UsedPackageFiles asAllSourceFiles                 to asUsedSourceFiles
91900>>>>>>>>>>>        Get UnusedPackages asUsedSourceFiles asAllSourceFiles to asUnusedSource
91901>>>>>>>>>>>        Set piNoOfUnusedSourceFiles to (SizeOfArray(asUnusedSource))
91902>>>>>>>>>>>
91902>>>>>>>>>>>        Get Seq_New_Channel to iCh
91903>>>>>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
91905>>>>>>>>>>>            Set pbOK to False
91906>>>>>>>>>>>            Error "No channel available for writing Unused Source Code. Procedure: 'OnProcess' (cUnusedSourceFiles)"
91907>>>>>>>>>>>>
91907>>>>>>>>>>>            Procedure_Return
91908>>>>>>>>>>>        End
91908>>>>>>>>>>>>
91908>>>>>>>>>>>
91908>>>>>>>>>>>        Move (SizeOfArray(asUnusedSource)) to iSize
91909>>>>>>>>>>>        If (iSize <> 0) Begin
91911>>>>>>>>>>>            Decrement iSize
91912>>>>>>>>>>>            Get psHomePath to sHomePath
91913>>>>>>>>>>>            Get vFolderFormat sHomePath to sHomePath
91914>>>>>>>>>>>
91914>>>>>>>>>>>            Direct_Output channel iCh (sHomePath + CS_BackupFolder + CS_DirSeparator + CS_UnusedSourceLogFile)
91916>>>>>>>>>>>            For iCount from 0 to iSize
91922>>>>>>>>>>>>
91922>>>>>>>>>>>                Writeln channel iCh (asUnusedSource[iCount].sPath + String(asUnusedSource[iCount].sFileName))
91925>>>>>>>>>>>            Loop
91926>>>>>>>>>>>>
91926>>>>>>>>>>>
91926>>>>>>>>>>>            // For testing purposes:
91926>>>>>>>>>>>            //            Writeln channel iCh ""
91926>>>>>>>>>>>            //            Writeln channel iCh "asUsedFiles"
91926>>>>>>>>>>>            //            Move (SizeOfArray(asUsedFiles)) to iSize
91926>>>>>>>>>>>            //            Decrement iSize
91926>>>>>>>>>>>            //            For iCount from 0 to iSize
91926>>>>>>>>>>>            //                Writeln channel iCh asUsedFiles[iCount]
91926>>>>>>>>>>>            //            Loop
91926>>>>>>>>>>>            //
91926>>>>>>>>>>>            //            Writeln channel iCh ""
91926>>>>>>>>>>>            //            Writeln channel iCh "asAllSourceFiles"
91926>>>>>>>>>>>            //            Move (SizeOfArray(asAllSourceFiles)) to iSize
91926>>>>>>>>>>>            //            Decrement iSize
91926>>>>>>>>>>>            //            For iCount from 0 to iSize
91926>>>>>>>>>>>            //                Writeln channel iCh asAllSourceFiles[iCount]
91926>>>>>>>>>>>            //            Loop
91926>>>>>>>>>>>            //
91926>>>>>>>>>>>            //            Writeln channel iCh ""
91926>>>>>>>>>>>            //            Writeln channel iCh "asUsedSourceFiles"
91926>>>>>>>>>>>            //            Move (SizeOfArray(asUsedSourceFiles)) to iSize
91926>>>>>>>>>>>            //            Decrement iSize
91926>>>>>>>>>>>            //            For iCount from 0 to iSize
91926>>>>>>>>>>>            //                Writeln channel iCh asUsedSourceFiles[iCount]
91926>>>>>>>>>>>            //            Loop
91926>>>>>>>>>>>
91926>>>>>>>>>>>            Close_Output channel iCh
91928>>>>>>>>>>>            Send Seq_Release_Channel iCh
91929>>>>>>>>>>>        End
91929>>>>>>>>>>>>
91929>>>>>>>>>>>        Set pbOK to True   
91930>>>>>>>>>>>        
91930>>>>>>>>>>>        Set pasUnusedSource to asUnusedSource
91931>>>>>>>>>>>
91931>>>>>>>>>>>    End_Procedure
91932>>>>>>>>>>>    
91932>>>>>>>>>>>End_Class
91933>>>>>>>>>Use cDDOReStyler.pkg
Including file: cDDOReStyler.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cDDOReStyler.pkg)
91933>>>>>>>>>>>// Copyright (c)  2014  KURANT Project
91933>>>>>>>>>>>// All rights reserved.
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// $FileName    : .\Hammer\AppSrc\DDOReStyler.src
91933>>>>>>>>>>>// $ProjectName : The Hammer 2.0
91933>>>>>>>>>>>// $Authors     : wil
91933>>>>>>>>>>>// $Created     : 11.14.2014  14:21
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// $Edited      : 09.21.2021 Nils Svedmyr. Refactored to a package for the "DFRefactor" project.
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// $Type        : LGPL
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// Contents:
91933>>>>>>>>>>>//  Unfortunately the naming style of datadictionaries over time has not been constant.
91933>>>>>>>>>>>//  The new style is
91933>>>>>>>>>>>//    Object o<tablename>_DD is a c<TableName>Datadictionary
91933>>>>>>>>>>>//  They also have a switch so you can keep on using the legacy style name which is
91933>>>>>>>>>>>//    Object o<tablename>_DD is a <tablename>_Datadictionary
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//  However before VDF12, the
91933>>>>>>>>>>>//    Object <tableName>_DD is a <tablename>_Datadictionary
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
91933>>>>>>>>>>>//  all over the place. Copying old code into new views/dialogs simply breaks and if your
91933>>>>>>>>>>>//  codebase has mixed styles then the compiler will not catch that.
91933>>>>>>>>>>>//  A code nightmare.
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//  This program allows you to switch between the following code styles:
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//  <TableName>_DD              == eDDOldStyle
91933>>>>>>>>>>>//  o<TableName>_DD             == eDDStudioStyle
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// How this code works:
91933>>>>>>>>>>>// 1. It scans your source file and for each file it will locate the datadictionary objects
91933>>>>>>>>>>>//    These datadictionary objects are then stored in an array
91933>>>>>>>>>>>// 2. We read the whole filelist into another array so that we know what table names can be
91933>>>>>>>>>>>//    used.
91933>>>>>>>>>>>// 3. The DDOs found in step 1) are classified against the filelist items and we determine
91933>>>>>>>>>>>//    the DDO style used for the declared DDOs. DDOs that could be verified are labeled
91933>>>>>>>>>>>//    on style used and marked as being verified.
91933>>>>>>>>>>>// 4. We scan the source again and replace the verified DDOs with the style wanted.
91933>>>>>>>>>>>// 5. Write the source out to disk (overwriting the original)
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// Please note that if your source already contains unknown DD objects (eg. You copied old
91933>>>>>>>>>>>// style code from another version of your appinto new style code) that this parser will
91933>>>>>>>>>>>// not try to correct that. The starting point should be correct working code.
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// Note if a detected DDO is in commented out source code then we will still replace it,
91933>>>>>>>>>>>// this is to make sure uncommenting code doesn't break the source.
91933>>>>>>>>>>>// Commented out DDO declarations are -not- detected.
91933>>>>>>>>>>>//
91933>>>>>>>>>>>// The following use cases are not supported by the DDRestyler:
91933>>>>>>>>>>>//   - include files,
91933>>>>>>>>>>>//   - source files with incorrect DDOs already in there
91933>>>>>>>>>>>//       (eg. declare o<table>_DD but later on use <table>_DD)
91933>>>>>>>>>>>//   - references to DDO's not declared in the source file (non autonomous usage)
91933>>>>>>>>>>>//
91933>>>>>>>>>>>//*****************************************************************************************
91933>>>>>>>>>>>Use seq_chnl.pkg
91933>>>>>>>>>>>Use RefactorFunctionConstants.inc
91933>>>>>>>>>>>Use vwin32fh.pkg
91933>>>>>>>>>>>Use cFilesystem.pkg
91933>>>>>>>>>>>Use cSysFileDataDictionary.dd
Including file: cSysFileDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cSysFileDataDictionary.dd)
91933>>>>>>>>>>>>>Use DataDict.pkg
91933>>>>>>>>>>>>>Use cDDOReStyler.pkg
91933>>>>>>>>>>>>>
91933>>>>>>>>>>>>>Open SysFile
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>Enum_List
91935>>>>>>>>>>>>>    Define eSplitUnknown              for 0 
91935>>>>>>>>>>>>>    Define eSplitBySpaceSemiColumn    for 1
91935>>>>>>>>>>>>>    Define eSplitBySemiColumn         for 2
91935>>>>>>>>>>>>>    Define eSplitByBeginEnd           for 3
91935>>>>>>>>>>>>>End_Enum_List
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>Define CS_SplitBySpaceSemiColumn    for "Split line space and semicolon"
91935>>>>>>>>>>>>>Define CS_SplitBySemiColumn         for "Split line with semicolon"
91935>>>>>>>>>>>>>Define CS_SplitByBeginEnd           for "Add a Begin/End block"
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>// ToDo: These doesn't feel right! Ask Wil about them
91935>>>>>>>>>>>>>// Aren't modern DD classes named o<tablename>_DataDictionary ?
91935>>>>>>>>>>>>>Enum_List
91935>>>>>>>>>>>>>    Define eDDUnknown       for 0 // style unknown or not yet classified
91935>>>>>>>>>>>>>    Define eDDOldStyle      for 1 // <tablename>_DD
91935>>>>>>>>>>>>>    Define eDDStudioStyle   for 2 // o<tablename>_DD
91935>>>>>>>>>>>>>    Define eDDNewStyle      for 3 // o<tablename>_dd
91935>>>>>>>>>>>>>End_Enum_List
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>Define CS_DDOldStyle      for "<tablename>_DD"
91935>>>>>>>>>>>>>Define CS_DDLegacyStyle   for "o<tablename>_DD"
91935>>>>>>>>>>>>>Define CS_DDNewStyle      for "o<tablename>_dd"
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>
91935>>>>>>>>>>>>>Object oSplitInFile is a DescriptionValidationTable
91937>>>>>>>>>>>>>    Procedure Fill_List
91940>>>>>>>>>>>>>        Forward Send Fill_List
91942>>>>>>>>>>>>>        Send Add_Table_Value eSplitBySpaceSemiColumn CS_SplitBySpaceSemiColumn
91943>>>>>>>>>>>>>        Send Add_Table_Value eSplitBySemiColumn      CS_SplitBySemiColumn
91944>>>>>>>>>>>>>        Send Add_Table_Value eSplitByBeginEnd        CS_SplitByBeginEnd
91945>>>>>>>>>>>>>    End_Procedure
91946>>>>>>>>>>>>>End_Object
91947>>>>>>>>>>>>>
91947>>>>>>>>>>>>>Object oDDOStyler is a DescriptionValidationTable
91949>>>>>>>>>>>>>    Procedure Fill_List
91952>>>>>>>>>>>>>        Forward Send Fill_List
91954>>>>>>>>>>>>>        Send Add_Table_Value eDDOldStyle    CS_DDOldStyle
91955>>>>>>>>>>>>>        Send Add_Table_Value eDDStudioStyle CS_DDLegacyStyle
91956>>>>>>>>>>>>>        Send Add_Table_Value eDDNewStyle    CS_DDNewStyle
91957>>>>>>>>>>>>>    End_Procedure
91958>>>>>>>>>>>>>End_Object
91959>>>>>>>>>>>>>
91959>>>>>>>>>>>>>Class cSysFileDataDictionary is a DataDictionary
91960>>>>>>>>>>>>>    
91960>>>>>>>>>>>>>    Procedure Construct_Object
91962>>>>>>>>>>>>>        Forward Send Construct_Object
91964>>>>>>>>>>>>>        Set Main_File to SysFile.File_Number
91965>>>>>>>>>>>>>
91965>>>>>>>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
91966>>>>>>>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
91967>>>>>>>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
91968>>>>>>>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
91969>>>>>>>>>>>>>
91969>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.PathStarZen to "Path to Starzen tool"
91970>>>>>>>>>>>>>
91970>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.PathSourceCompareTool to "Source Compare tool"
91971>>>>>>>>>>>>>        Set Field_Label_Short Field SysFile.PathSourceCompareTool to "Source Compare tool"
91972>>>>>>>>>>>>>        Set Status_Help Field SysFile.PathSourceCompareTool to "Path to a Source Compare tool"
91973>>>>>>>>>>>>>
91973>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.FileExtensionFilter to "File Extension Filter"
91974>>>>>>>>>>>>>        Set Field_Label_Short Field SysFile.FileExtensionFilter to "File Extension Filter"
91975>>>>>>>>>>>>>        Set Field_Class_Name Field SysFile.FileExtensionFilter to "Combo"
91976>>>>>>>>>>>>>
91976>>>>>>>>>>>>>        Set Field_Label_Long Field SysFile.bCountSourceLines to "Count number of source lines"
91977>>>>>>>>>>>>>        Set Field_Label_Short Field SysFile.bCountSourceLines to "Count source lines"
91978>>>>>>>>>>>>>        Set Field_Class_Name Field SysFile.bCountSourceLines to "Checkbox"
91979>>>>>>>>>>>>>        Set Field_Checkbox_Values Field SysFile.bCountSourceLines to "1" "0"
91980>>>>>>>>>>>>>        Set Status_Help Field SysFile.bCountSourceLines to "Note: This function must be run alone. All other functions will be ignored!"
91981>>>>>>>>>>>>>        Set Field_Checkbox_Values Field SysFile.bEditorDropSelf to "1" "0"
91982>>>>>>>>>>>>>
91982>>>>>>>>>>>>>    End_Procedure
91983>>>>>>>>>>>>>
91983>>>>>>>>>>>>>    Procedure Field_Defaults
91985>>>>>>>>>>>>>        Forward Send Field_Defaults
91987>>>>>>>>>>>>>        Set Field_Changed_Value Field SysFile.bCountSourceLines to 0
91988>>>>>>>>>>>>>        Set Field_Changed_Value Field SysFile.bEditorDropSelf to 0
91989>>>>>>>>>>>>>    End_Procedure 
91990>>>>>>>>>>>>>    
91990>>>>>>>>>>>>>    Procedure Update
91992>>>>>>>>>>>>>        Forward Send Update
91994>>>>>>>>>>>>>    End_Procedure
91995>>>>>>>>>>>>>
91995>>>>>>>>>>>>>End_Class
91996>>>>>>>>>>>
91996>>>>>>>>>>>Struct tFileList
91996>>>>>>>>>>>    Integer iFileNum
91996>>>>>>>>>>>    String  sRootName     // actual filename
91996>>>>>>>>>>>    String  sDisplayName  // description
91996>>>>>>>>>>>    String  sTable        // datadictionary name is based on sTable (see aliases)
91996>>>>>>>>>>>End_Struct
91996>>>>>>>>>>>
91996>>>>>>>>>>>Struct tDDO
91996>>>>>>>>>>>    String  sDDO          // sDDO name
91996>>>>>>>>>>>    Boolean bVerified     // sDDO name has been verified against filelist
91996>>>>>>>>>>>    Integer eDDOStyle     // DDO naming style
91996>>>>>>>>>>>    Integer iLine         // source line where the DDO is declared
91996>>>>>>>>>>>    Integer iFileNum      // Not needed at this stage, but we got the data, so stick it in
91996>>>>>>>>>>>    String  sTableName    // Just as easy to have
91996>>>>>>>>>>>End_Struct
91996>>>>>>>>>>>
91996>>>>>>>>>>>Class cDataFiles is a cObject
91997>>>>>>>>>>>    Procedure Construct_Object
91999>>>>>>>>>>>        Forward Send Construct_Object
92001>>>>>>>>>>>        Property tFileList[] pFileList
92002>>>>>>>>>>>    End_Procedure
92003>>>>>>>>>>>
92003>>>>>>>>>>>    // Loops through the Filelist.cfg and enumerates all tables.
92003>>>>>>>>>>>    Procedure EnumerateAllFiles
92005>>>>>>>>>>>        Integer iFile iIndex 
92005>>>>>>>>>>>        String sRoot sDisplay sTable
92005>>>>>>>>>>>        tFileList[] aFilelist
92005>>>>>>>>>>>        tFileList[] aFilelist
92006>>>>>>>>>>>
92006>>>>>>>>>>>        Move (ResizeArray(aFilelist,0)) to aFilelist
92007>>>>>>>>>>>        Move 0 to iFile
92008>>>>>>>>>>>        Move 0 to iIndex
92009>>>>>>>>>>>        Repeat
92009>>>>>>>>>>>>
92009>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iFile to iFile
92012>>>>>>>>>>>            If (iFile > 0) Begin
92014>>>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of iFile to sRoot
92017>>>>>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of iFile to sDisplay
92020>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sTable
92023>>>>>>>>>>>                Move iFile    to aFilelist[iIndex].iFileNum
92024>>>>>>>>>>>                Move sRoot    to aFilelist[iIndex].sRootName
92025>>>>>>>>>>>                Move sDisplay to aFilelist[iIndex].sDisplayName
92026>>>>>>>>>>>                Move sTable   to aFilelist[iIndex].sTable
92027>>>>>>>>>>>                Increment iIndex
92028>>>>>>>>>>>            End
92028>>>>>>>>>>>>
92028>>>>>>>>>>>        Until (iFile = 0)
92030>>>>>>>>>>>        
92030>>>>>>>>>>>        Set pFileList to aFilelist
92031>>>>>>>>>>>    End_Procedure
92032>>>>>>>>>>>
92032>>>>>>>>>>>End_Class
92033>>>>>>>>>>>
92033>>>>>>>>>>>//Class cStylerFolder is a cObject 
92033>>>>>>>>>>>//    Procedure Construct_Object
92033>>>>>>>>>>>//        Forward Send Construct_Object
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Property Boolean pbOk
92033>>>>>>>>>>>//        Property String  psFolderName  ""
92033>>>>>>>>>>>//        Property String  psFileMask    ""
92033>>>>>>>>>>>//        Property Integer peNewStyle    0
92033>>>>>>>>>>>//        
92033>>>>>>>>>>>//        Property String psHomePath
92033>>>>>>>>>>>//        Property String[] pasFolderNames
92033>>>>>>>>>>>//        Property String psFileFilter
92033>>>>>>>>>>>//        Property Handle phoFileSystem
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Object oFilesystem is a cFilesystem
92033>>>>>>>>>>>//            Set phoFileSystem to Self
92033>>>>>>>>>>>//        End_Object                   
92033>>>>>>>>>>>//        
92033>>>>>>>>>>>//    End_Procedure
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Procedure OnProcess
92033>>>>>>>>>>>//        Boolean bOk
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Get MainProcedure to bOK
92033>>>>>>>>>>>//        Set pbOk to bOk
92033>>>>>>>>>>>//    End_Procedure
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Procedure RestyleDDObjects String sFileName Integer eDDStyle
92033>>>>>>>>>>>//        Delegate Send RestyleDDObjects sFileName eDDStyle
92033>>>>>>>>>>>//    End_Procedure
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Function MainProcedure Returns Boolean
92033>>>>>>>>>>>//        Boolean bOk bStop bFound
92033>>>>>>>>>>>//        Integer iCount iSize iTmp
92033>>>>>>>>>>>//        String  sPath sFileName sFileFilter
92033>>>>>>>>>>>//        Handle  hoDir
92033>>>>>>>>>>>//        String[] asFolderNames
92033>>>>>>>>>>>//        tsSearchResult[] asSearchResult
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Get pasFolderNames to asFolderNames
92033>>>>>>>>>>>//        Get psFileFilter   to sFileFilter
92033>>>>>>>>>>>//        Get AllSourceFiles asFolderNames sFileFilter to asSearchResult
92033>>>>>>>>>>>//        Move (SizeOfArray(asSearchResult)) to iSize
92033>>>>>>>>>>>//        Decrement iSize
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        For iCount from 0 to iSize
92033>>>>>>>>>>>//            Move asSearchResult[iCount].sAlternateFileName to sPath
92033>>>>>>>>>>>//            Get vFolderFormat sPath               to sPath
92033>>>>>>>>>>>//            Move asSearchResult[iCount].sFilename to sFileName
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//            Send RestyleDDObjects (sPath + sFileName) (peNewStyle(Self))
92033>>>>>>>>>>>//        Loop
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Function_Return bOk
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Function NoFolderListAsArray Boolean bNoBackupFolder Returns String[]
92033>>>>>>>>>>>//        String sNoFolderList
92033>>>>>>>>>>>//        String[] saNoFolderList
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Move CS_NoFolderList to sNoFolderList
92033>>>>>>>>>>>//        If (bNoBackupFolder = False) Begin
92033>>>>>>>>>>>//            Move (sNoFolderList + "|" + CS_BackupFolder) to sNoFolderList
92033>>>>>>>>>>>//        End
92033>>>>>>>>>>>//        Move (Lowercase(sNoFolderList)) to sNoFolderList
92033>>>>>>>>>>>//        Move (StrSplitToArray(sNoFolderList, "|")) to saNoFolderList
92033>>>>>>>>>>>//        Function_Return saNoFolderList
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Function AllSourceFolders String[] asUserSelectedFolders Returns String[]
92033>>>>>>>>>>>//        String sHomePath
92033>>>>>>>>>>>//        String[] asNoFolderSearch asSourceFolders asAllSourceFolders
92033>>>>>>>>>>>//        Integer iSize iCount
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Get psHomePath to sHomePath
92033>>>>>>>>>>>//        Get vFolderFormat sHomePath to sHomePath
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Get NoFolderListAsArray False to asNoFolderSearch
92033>>>>>>>>>>>//        Move (SizeOfArray(asUserSelectedFolders)) to iSize
92033>>>>>>>>>>>//        Decrement iSize
92033>>>>>>>>>>>//        For iCount from 0 to iSize
92033>>>>>>>>>>>//            Get RecursiveSearchFolders asUserSelectedFolders[iCount] asNoFolderSearch to asSourceFolders
92033>>>>>>>>>>>//            Move (AppendArray(asAllSourceFolders, asSourceFolders)) to asAllSourceFolders
92033>>>>>>>>>>>//        Loop
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Function_Return asAllSourceFolders
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Function AllSourceFiles String[] asUserSelectedFolders String sFileFilter Returns tsSearchResult[]
92033>>>>>>>>>>>//        Boolean bIsFileInFilter
92033>>>>>>>>>>>//        String sSourceFolder sFileMask sFileName
92033>>>>>>>>>>>//        String[] asAllSourceFolders
92033>>>>>>>>>>>//        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
92033>>>>>>>>>>>//        Integer iFolder iFolders iFile iFiles
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Move asUserSelectedFolders to asAllSourceFolders
92033>>>>>>>>>>>//        Move (SizeOfArray(asAllSourceFolders)) to iFolders
92033>>>>>>>>>>>//        Decrement iFolders
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        // Folder loop:
92033>>>>>>>>>>>//        For iFolder from 0 to iFolders
92033>>>>>>>>>>>//            Move asAllSourceFolders[iFolder] to sSourceFolder
92033>>>>>>>>>>>//            Get vFolderFormat sSourceFolder to sSourceFolder
92033>>>>>>>>>>>//            Move (sSourceFolder + "*.*") to sFileMask
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//            Get FileSearch of (phoFileSystem(Self)) sFileMask DIRMODE_FILES_ONLY False to asSourceFiles
92033>>>>>>>>>>>//            Move (SizeOfArray(asSourceFiles)) to iFiles
92033>>>>>>>>>>>//            Decrement iFiles
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//            // File loop:
92033>>>>>>>>>>>//            For iFile from 0 to iFiles
92033>>>>>>>>>>>//                Move asSourceFiles[iFile].sFilename to sFileName
92033>>>>>>>>>>>//                Get IsFileInFilter sFileName sFileFilter to bIsFileInFilter
92033>>>>>>>>>>>//                If (bIsFileInFilter = True) Begin
92033>>>>>>>>>>>//                    // Store the path in the sAlternateFileName struct item
92033>>>>>>>>>>>//                    Move sSourceFolder to asSourceFiles[iFile].sAlternateFileName
92033>>>>>>>>>>>//                End
92033>>>>>>>>>>>//                Else Begin
92033>>>>>>>>>>>//                    Move (RemoveFromArray(asSourceFiles, iFile)) to asSourceFiles
92033>>>>>>>>>>>//                    Decrement iFile
92033>>>>>>>>>>>//                    Decrement iFiles
92033>>>>>>>>>>>//                End
92033>>>>>>>>>>>//            Loop
92033>>>>>>>>>>>//            Move (AppendArray(asSourceFilesTotal, asSourceFiles)) to asSourceFilesTotal
92033>>>>>>>>>>>//        Loop
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Function_Return asSourceFilesTotal
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Function IsFileInFilter String sFileName String sFileFilter Returns Boolean
92033>>>>>>>>>>>//        Integer iSearchIndex
92033>>>>>>>>>>>//        String sExtension sChar
92033>>>>>>>>>>>//        String[] asFileFilter
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Move (Lowercase(sFileName))      to sFileName
92033>>>>>>>>>>>//        Get ParseFileExtension sFileName to sExtension
92033>>>>>>>>>>>//        Move (Left(sExtension, 1))       to sChar
92033>>>>>>>>>>>//        If (sChar <> ".") Begin
92033>>>>>>>>>>>//            Move ("." + String(sExtension)) to sExtension
92033>>>>>>>>>>>//        End
92033>>>>>>>>>>>//        Move (Lowercase(sFileFilter))         to sFileFilter
92033>>>>>>>>>>>//        Move (Replaces("*", sFileFilter, "")) to sFileFilter
92033>>>>>>>>>>>//        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilter
92033>>>>>>>>>>>//        Move (SearchArray(sExtension, asFileFilter)) to iSearchIndex
92033>>>>>>>>>>>//        Function_Return (iSearchIndex <> -1)
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    // Returns True if the passed sFolderName exists in the passed string array.
92033>>>>>>>>>>>//    Function IsFolderInNoFolderList String[] saNoFolderList String sFolderName Returns Boolean
92033>>>>>>>>>>>//        Integer iSize iCount iIndex iCurrentFolder
92033>>>>>>>>>>>//        Boolean bOK bFound
92033>>>>>>>>>>>//        String sNoFolder sFolderNameShort
92033>>>>>>>>>>>//        String[] saFolderList
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Move False to bOK
92033>>>>>>>>>>>//        Move (SearchArray(".",  saNoFolderList)) to iCurrentFolder
92033>>>>>>>>>>>//        Move (iCurrentFolder <> -1) to bFound
92033>>>>>>>>>>>//        If (bFound = True) Begin
92033>>>>>>>>>>>//            // We need to remove "." from the array to avoid problems with folders containing a "."
92033>>>>>>>>>>>//            Move (RemoveFromArray(saNoFolderList, iCurrentFolder)) to saNoFolderList
92033>>>>>>>>>>>//            // The rightmost folder name:
92033>>>>>>>>>>>//            Get ParseFileName sFolderName to sFolderNameShort
92033>>>>>>>>>>>//            Move (sFolderNameShort = ".." or sFolderNameShort = ".") to bOK // Then we're done
92033>>>>>>>>>>>//        End
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        If (bOK = False) Begin
92033>>>>>>>>>>>//            Move (Lowercase(sFolderName)) to sFolderName
92033>>>>>>>>>>>//            Move (StrSplitToArray(sFolderName, CS_DirSeparator)) to saFolderList
92033>>>>>>>>>>>//            Move (Lowercase(sFolderName)) to sFolderName
92033>>>>>>>>>>>//            Move (SizeOfArray(saNoFolderList)) to iSize
92033>>>>>>>>>>>//            Decrement iSize
92033>>>>>>>>>>>//            For iCount from 0 to iSize
92033>>>>>>>>>>>//                Move (Lowercase(saNoFolderList[iCount])) to sNoFolder
92033>>>>>>>>>>>//                Move (SearchArray(sNoFolder, saFolderList)) to iIndex
92033>>>>>>>>>>>//                If (iIndex <> -1) Begin
92033>>>>>>>>>>>//                    Move True to bOK
92033>>>>>>>>>>>//                End
92033>>>>>>>>>>>//                If (bOK = True) Break
92033>>>>>>>>>>>//            Loop
92033>>>>>>>>>>>//        End
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Function_Return bOK
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//    Function RecursiveSearchFolders String sSourceFolder String[] asNoFolderList Returns String[]
92033>>>>>>>>>>>//        Boolean bFound
92033>>>>>>>>>>>//        Integer iCount iSize iItem
92033>>>>>>>>>>>//        String sMask sFileName sPrevFolderName sHomePath
92033>>>>>>>>>>>//        tsSearchResult[] asSearchResult
92033>>>>>>>>>>>//        String[] saSearchFolders
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        If (not(sSourceFolder contains ":")) Begin
92033>>>>>>>>>>>//            Get psHomePath to sHomePath
92033>>>>>>>>>>>//            Get vFolderFormat sHomePath to sHomePath
92033>>>>>>>>>>>//            Move (sHomePath + sSourceFolder) to sSourceFolder
92033>>>>>>>>>>>//        End
92033>>>>>>>>>>>//        Get vFolderFormat sSourceFolder to sSourceFolder
92033>>>>>>>>>>>//        Move (sSourceFolder + "*") to sMask
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Move 0 to iItem
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        // Recursive folder search
92033>>>>>>>>>>>//        Get FileSearchRecursive of ghoFileSystem sMask DIRMODE_DIRECTORIES_ONLY False to asSearchResult
92033>>>>>>>>>>>//        Move (SizeOfArray(asSearchResult)) to iSize
92033>>>>>>>>>>>//        Decrement iSize
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        // Remove folder names from array where we should not search for source files
92033>>>>>>>>>>>//        Move "" to sPrevFolderName
92033>>>>>>>>>>>//        For iCount from 0 to iSize
92033>>>>>>>>>>>//            Get IsFolderInNoFolderList of ghoApplication asNoFolderList asSearchResult[iCount].sFilename to bFound
92033>>>>>>>>>>>//            If (bFound = False) Begin
92033>>>>>>>>>>>//                If (asSearchResult[iCount].sFilename <> sPrevFolderName) Begin
92033>>>>>>>>>>>//                    Move asSearchResult[iCount].sFilename to saSearchFolders[iItem]
92033>>>>>>>>>>>//                    Increment iItem
92033>>>>>>>>>>>//                End
92033>>>>>>>>>>>//            End
92033>>>>>>>>>>>//            Move asSearchResult[iCount].sFilename to sPrevFolderName
92033>>>>>>>>>>>//        Loop
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Move sSourceFolder to saSearchFolders[SizeOfArray(saSearchFolders)]
92033>>>>>>>>>>>//        // Sort the folder array to get the top one first.
92033>>>>>>>>>>>//        Move (SortArray(saSearchFolders)) to saSearchFolders
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//        Function_Return saSearchFolders
92033>>>>>>>>>>>//    End_Function
92033>>>>>>>>>>>//
92033>>>>>>>>>>>//End_Class
92033>>>>>>>>>>>
92033>>>>>>>>>>>Class cDDOReStyler is a cObject
92034>>>>>>>>>>>    Procedure Construct_Object
92036>>>>>>>>>>>        Forward Send Construct_Object
92038>>>>>>>>>>>  
92038>>>>>>>>>>>        Property String   psFileName  ""
92039>>>>>>>>>>>        Property String[] psSource
92040>>>>>>>>>>>        Property tDDO[]   pDDObjects
92041>>>>>>>>>>>        Property Boolean  pbCreateBackup True
92042>>>>>>>>>>>        Property Boolean  pbStrict       True   // Only replace verified DDOs, non strict not supported atm (Search code if need)
92043>>>>>>>>>>>        Property Integer  peNewStyle     eDDNewStyle
92044>>>>>>>>>>>        Property Boolean  pbCamelCaseTableName True // For new tablename Camel Case the TableName in the object
92045>>>>>>>>>>>
92045>>>>>>>>>>>        Property String psHomePath
92046>>>>>>>>>>>        Property String[] pasAllSourceFiles
92047>>>>>>>>>>>        Property Handle phoFileSystem
92048>>>>>>>>>>>
92048>>>>>>>>>>>        Object oDataFiles is a cDataFiles
92050>>>>>>>>>>>        End_Object
92051>>>>>>>>>>>
92051>>>>>>>>>>>        Object oFilesystem is a cFilesystem
92053>>>>>>>>>>>            Set phoFileSystem to Self
92054>>>>>>>>>>>        End_Object                   
92055>>>>>>>>>>>        
92055>>>>>>>>>>>    End_Procedure
92056>>>>>>>>>>>
92056>>>>>>>>>>>    Function MainDDORestyler Returns Boolean
92058>>>>>>>>>>>        Boolean bOk 
92058>>>>>>>>>>>        Integer iCount iSize 
92058>>>>>>>>>>>        String[] asAllSourceFiles 
92059>>>>>>>>>>>
92059>>>>>>>>>>>        Get pasAllSourceFiles to asAllSourceFiles
92060>>>>>>>>>>>        Move (SizeOfArray(asAllSourceFiles)) to iSize
92061>>>>>>>>>>>        Decrement iSize
92062>>>>>>>>>>>
92062>>>>>>>>>>>        For iCount from 0 to iSize
92068>>>>>>>>>>>>
92068>>>>>>>>>>>            Send RestyleDDObjects asAllSourceFiles[iCount] (peNewStyle(Self))
92069>>>>>>>>>>>        Loop
92070>>>>>>>>>>>>
92070>>>>>>>>>>>
92070>>>>>>>>>>>        Function_Return bOk
92071>>>>>>>>>>>    End_Function
92072>>>>>>>>>>>
92072>>>>>>>>>>>    Procedure ReadFile String sFileName
92074>>>>>>>>>>>        Integer iChannel iLine
92074>>>>>>>>>>>        String sLine
92074>>>>>>>>>>>        String[] sSource
92075>>>>>>>>>>>
92075>>>>>>>>>>>        Move 0 to iLine
92076>>>>>>>>>>>        Move (ResizeArray(sSource, 0)) to sSource
92077>>>>>>>>>>>        Get OpenInput sFileName to iChannel
92078>>>>>>>>>>>        If (iChannel > 0) Begin
92080>>>>>>>>>>>            Set psFileName to sFileName
92081>>>>>>>>>>>            Repeat
92081>>>>>>>>>>>>
92081>>>>>>>>>>>                Readln channel iChannel sLine
92083>>>>>>>>>>>                If (not(SeqEof)) Begin
92085>>>>>>>>>>>                    Move (RTrim(sLine)) to sSource[iLine]
92086>>>>>>>>>>>                    Increment iLine
92087>>>>>>>>>>>                End
92087>>>>>>>>>>>>
92087>>>>>>>>>>>            Until (SeqEof)
92089>>>>>>>>>>>            Send CloseInput iChannel
92090>>>>>>>>>>>        End
92090>>>>>>>>>>>>
92090>>>>>>>>>>>        Set psSource to sSource
92091>>>>>>>>>>>    End_Procedure
92092>>>>>>>>>>>
92092>>>>>>>>>>>    // ToDo: Set this to the backup for the DFRefactor logic.
92092>>>>>>>>>>>    Procedure CreateBackup
92094>>>>>>>>>>>    End_Procedure
92095>>>>>>>>>>>
92095>>>>>>>>>>>    Procedure WriteFile
92097>>>>>>>>>>>        Boolean  bBackup
92097>>>>>>>>>>>        Integer  iChannel iLine iCount
92097>>>>>>>>>>>        String   sFileName sLine
92097>>>>>>>>>>>        String[] sSource
92098>>>>>>>>>>>
92098>>>>>>>>>>>        Get pbCreateBackup to bBackup
92099>>>>>>>>>>>        If (bBackup) Begin
92101>>>>>>>>>>>            Send Createbackup
92102>>>>>>>>>>>        End
92102>>>>>>>>>>>>
92102>>>>>>>>>>>        Get psSource to sSource
92103>>>>>>>>>>>        Get psFileName to sFileName
92104>>>>>>>>>>>        If (sFileName <> "") Begin
92106>>>>>>>>>>>            Get OpenOutput sFileName to iChannel
92107>>>>>>>>>>>            If (iChannel > 0) Begin
92109>>>>>>>>>>>                Move (SizeOfArray(sSource) -1) to iCount
92110>>>>>>>>>>>                If (iCount >= 0) Begin
92112>>>>>>>>>>>                    For iLine from 0 to iCount
92118>>>>>>>>>>>>
92118>>>>>>>>>>>                        If (iLine) Begin
92120>>>>>>>>>>>                            Move sSource[iLine] to sLine
92121>>>>>>>>>>>                        End
92121>>>>>>>>>>>>
92121>>>>>>>>>>>                        Writeln channel iChannel sLine
92124>>>>>>>>>>>                    Loop
92125>>>>>>>>>>>>
92125>>>>>>>>>>>                End
92125>>>>>>>>>>>>
92125>>>>>>>>>>>                Send CloseOutput iChannel
92126>>>>>>>>>>>            End
92126>>>>>>>>>>>>
92126>>>>>>>>>>>        End
92126>>>>>>>>>>>>
92126>>>>>>>>>>>    End_Procedure
92127>>>>>>>>>>>
92127>>>>>>>>>>>    // Scans the whole file and locates the declared datadictionary objects based on that
92127>>>>>>>>>>>    // the line will start with "Object" and ends with "_DataDictionary".
92127>>>>>>>>>>>    //
92127>>>>>>>>>>>    // The search is case insensitive, commented out source will be ignored.
92127>>>>>>>>>>>    //
92127>>>>>>>>>>>    // Example line that will be detected:
92127>>>>>>>>>>>    //  Object oCustomer_DD is a Customer_DataDictionary
92127>>>>>>>>>>>    //
92127>>>>>>>>>>>    Procedure FindCurrentDDObjects
92129>>>>>>>>>>>        Integer iCount iLine iPos iSpaceChars iDDO
92129>>>>>>>>>>>        String  sLine sDDObject sNline   // normalized line, lowercase and trimmed
92129>>>>>>>>>>>        String[] sSource
92130>>>>>>>>>>>        tDDO[] DDObjects
92130>>>>>>>>>>>        tDDO[] DDObjects
92131>>>>>>>>>>>
92131>>>>>>>>>>>        Move 0 to iDDO
92132>>>>>>>>>>>        Move (ResizeArray(DDObjects, 0)) to DDObjects
92133>>>>>>>>>>>        Get psSource to sSource
92134>>>>>>>>>>>        
92134>>>>>>>>>>>        Move (SizeOfArray(sSource) -1) to iCount
92135>>>>>>>>>>>        If (iCount >= 0) Begin
92137>>>>>>>>>>>            For iLine from 0 to iCount
92143>>>>>>>>>>>>
92143>>>>>>>>>>>                Move sSource[iLine] to sLine
92144>>>>>>>>>>>                Move (Lowercase(Trim(sLine))) to sNline
92145>>>>>>>>>>>                If (Pos("object ", sNline) = 1) Begin
92147>>>>>>>>>>>                    Move (Pos("_datadictionary", sNline)) to iPos
92148>>>>>>>>>>>                    If (iPos > 0) Begin
92150>>>>>>>>>>>                        Move (Replace("object ", sNline, "")) to sNline
92151>>>>>>>>>>>                        // Space characters on the left? Count them
92151>>>>>>>>>>>                        Move (Length(sNline) - (Length(Ltrim(sNline)))) to iSpaceChars
92152>>>>>>>>>>>                        Move (Ltrim(sNline)) to sNline // Remove them
92153>>>>>>>>>>>                        Move (Pos(" ", sNline)) to iPos
92154>>>>>>>>>>>                        If (iPos <> 0) Begin
92156>>>>>>>>>>>                            Move (Mid(Ltrim(sLine), (iPos -1), (8 + iSpaceChars))) to sDDObject
92157>>>>>>>>>>>                            Move sDDObject  to DDObjects[iDDO].sDDO
92158>>>>>>>>>>>                            Move iLine      to DDObjects[iDDO].iLine
92159>>>>>>>>>>>                            Move False      to DDObjects[iDDO].bVerified
92160>>>>>>>>>>>                            Move eDDUnknown to DDObjects[iDDO].eDDOStyle
92161>>>>>>>>>>>                            Increment iDDO
92162>>>>>>>>>>>                        End
92162>>>>>>>>>>>>
92162>>>>>>>>>>>                    End
92162>>>>>>>>>>>>
92162>>>>>>>>>>>                End
92162>>>>>>>>>>>>
92162>>>>>>>>>>>            Loop
92163>>>>>>>>>>>>
92163>>>>>>>>>>>        End
92163>>>>>>>>>>>>
92163>>>>>>>>>>>        
92163>>>>>>>>>>>        Set pDDObjects to DDObjects
92164>>>>>>>>>>>    End_Procedure
92165>>>>>>>>>>>
92165>>>>>>>>>>>    // Helper function for comparing tablenames in the filelist
92165>>>>>>>>>>>    //
92165>>>>>>>>>>>    // Custom comparison function:
92165>>>>>>>>>>>    //   Returns (GT) if struct value in first parameter > struct value in second parameter.
92165>>>>>>>>>>>    //   Returns (LT) if struct value in first parameter < struct value in second parameter.
92165>>>>>>>>>>>    //   Otherwise returns (EQ).
92165>>>>>>>>>>>    Function CompareTableNames tFileList  List1 tFileList List2 Returns Integer
92167>>>>>>>>>>>        Move (Lowercase(List1.sTable)) to List1.sTable
92168>>>>>>>>>>>        Move (Lowercase(List2.sTable)) to List2.sTable
92169>>>>>>>>>>>        If (List1.sTable > List2.sTable) Begin
92171>>>>>>>>>>>            Function_Return (GT)
92172>>>>>>>>>>>        End
92172>>>>>>>>>>>>
92172>>>>>>>>>>>        Else If (List1.sTable < List2.sTable) Begin
92175>>>>>>>>>>>            Function_Return (LT)
92176>>>>>>>>>>>        End
92176>>>>>>>>>>>>
92176>>>>>>>>>>>        Function_Return (EQ)
92177>>>>>>>>>>>    End_Function
92178>>>>>>>>>>>
92178>>>>>>>>>>>    // Looks at the DD Objects found in the source and
92178>>>>>>>>>>>    // tests them against the filelist plus determines the type
92178>>>>>>>>>>>    Procedure ClassifyDDObjects
92180>>>>>>>>>>>        Boolean bHasObjectPrefix bHasDDPostfix bHasDataDictionaryPostfix
92180>>>>>>>>>>>        Integer iListSize iCount iDDO iFile
92180>>>>>>>>>>>        String sDDO sTableName sTableNameO // exception if tablename actually starts with letter O
92180>>>>>>>>>>>        tDDO[] DDObjects
92180>>>>>>>>>>>        tDDO[] DDObjects
92181>>>>>>>>>>>        tFileList SearchFile
92181>>>>>>>>>>>        tFileList SearchFile
92181>>>>>>>>>>>        tFileList[] FileList
92181>>>>>>>>>>>        tFileList[] FileList
92182>>>>>>>>>>>
92182>>>>>>>>>>>        Send EnumerateAllFiles of oDataFiles // not entirely optimal to run this in each source file but meh
92183>>>>>>>>>>>        Get pFileList of oDataFiles    to FileList
92184>>>>>>>>>>>        Move (SizeOfArray(FileList)-1) to iListSize
92185>>>>>>>>>>>        Get pDDObjects to DDObjects
92186>>>>>>>>>>>        Move (SizeOfArray(DDObjects)-1) to iCount
92187>>>>>>>>>>>        
92187>>>>>>>>>>>        If (iListSize >= 0 and iCount >= 0) Begin
92189>>>>>>>>>>>            For iDDO from 0 to iCount
92195>>>>>>>>>>>>
92195>>>>>>>>>>>                Move False to bHasObjectPrefix
92196>>>>>>>>>>>                Move False to bHasDDPostfix
92197>>>>>>>>>>>                Move False to bHasDataDictionaryPostfix
92198>>>>>>>>>>>                Move ""    to sTableNameO
92199>>>>>>>>>>>                Move DDObjects[iDDO].sDDO to sDDO
92200>>>>>>>>>>>                Move (Trim(sDDO)) to sTableName
92201>>>>>>>>>>>                If (sTableName<>"") Begin
92203>>>>>>>>>>>                    If (Lowercase(Left(sTableName, 1)) = "o") Begin
92205>>>>>>>>>>>                        Move True to bHasObjectPrefix
92206>>>>>>>>>>>                        Move (Replace(Mid(sTableName, 1, 1), sTableName, "")) to sTableName
92207>>>>>>>>>>>                        Move (Trim(sDDO)) to sTableNameO // What if tablename actually starts with a letter "o" ?
92208>>>>>>>>>>>                    End
92208>>>>>>>>>>>>
92208>>>>>>>>>>>                    If (Lowercase(Right(sTableName, 3)) = "_dd") Begin
92210>>>>>>>>>>>                        Move True to bHasDDPostFix
92211>>>>>>>>>>>                        Move (Left(sTableName,Length(sTableName) -3)) to sTableName
92212>>>>>>>>>>>                        If (sTableNameO <> "") Begin
92214>>>>>>>>>>>                            Move (Left(sTableNameO,Length(sTableNameO) -3)) to sTableNameO
92215>>>>>>>>>>>                        End
92215>>>>>>>>>>>>
92215>>>>>>>>>>>                    End
92215>>>>>>>>>>>>
92215>>>>>>>>>>>                    Else If (Lowercase(Right(sTableName, 15)) = "_datadictionary") Begin
92218>>>>>>>>>>>                        Move True to bHasDataDictionaryPostFix
92219>>>>>>>>>>>                        Move (Left(sTableName, Length(sTableName) -15)) to sTableName
92220>>>>>>>>>>>                        If (sTableNameO <> "") Begin
92222>>>>>>>>>>>                            Move (Left(sTableNameO,Length(sTableNameO) -15)) to sTableNameO
92223>>>>>>>>>>>                        End
92223>>>>>>>>>>>>
92223>>>>>>>>>>>                    End
92223>>>>>>>>>>>>
92223>>>>>>>>>>>                    Move sTableName to SearchFile.sTable
92224>>>>>>>>>>>                    Move (SearchArray(SearchFile,FileList, Self, (RefFunc(CompareTableNames)) )) to iFile
92225>>>>>>>>>>>                    If (iFile >- 1) Begin
92227>>>>>>>>>>>                        Move True to DDObjects[iDDO].bVerified
92228>>>>>>>>>>>                        Move FileList[iFile].iFileNum to DDObjects[iDDO].iFileNum
92229>>>>>>>>>>>                        Move FileList[iFile].sTable   to DDObjects[iDDO].sTableName
92230>>>>>>>>>>>                    End
92230>>>>>>>>>>>>
92230>>>>>>>>>>>                    Else If (sTableNameO <> "") Begin
92233>>>>>>>>>>>                        Move sTableNameO to SearchFile.sTable
92234>>>>>>>>>>>                        Move (SearchArray(SearchFile,FileList, Self, (RefFunc(CompareTableNames)) )) to iFile
92235>>>>>>>>>>>                        If (iFile >- 1) Begin
92237>>>>>>>>>>>                            Move False to bHasObjectPrefix
92238>>>>>>>>>>>                            Move True  to DDObjects[iDDO].bVerified
92239>>>>>>>>>>>                            Move FileList[iFile].iFileNum to DDObjects[iDDO].iFileNum
92240>>>>>>>>>>>                            Move FileList[iFile].sTable   to DDObjects[iDDO].sTableName
92241>>>>>>>>>>>                        End
92241>>>>>>>>>>>>
92241>>>>>>>>>>>                    End
92241>>>>>>>>>>>>
92241>>>>>>>>>>>                    If (bHasObjectPrefix = False and bHasDDPostfix) Begin
92243>>>>>>>>>>>                        Move eDDOldStyle to DDObjects[iDDO].eDDOStyle
92244>>>>>>>>>>>                    End
92244>>>>>>>>>>>>
92244>>>>>>>>>>>                    Else If (bHasObjectPrefix) Begin
92247>>>>>>>>>>>                        If (bHasDDPostfix) Begin
92249>>>>>>>>>>>                            Move eDDStudioStyle to DDObjects[iDDO].eDDOStyle
92250>>>>>>>>>>>                        End
92250>>>>>>>>>>>>
92250>>>>>>>>>>>                    End
92250>>>>>>>>>>>>
92250>>>>>>>>>>>                End
92250>>>>>>>>>>>>
92250>>>>>>>>>>>            Loop
92251>>>>>>>>>>>>
92251>>>>>>>>>>>            Set pDDObjects to DDObjects
92252>>>>>>>>>>>        End
92252>>>>>>>>>>>>
92252>>>>>>>>>>>    End_Procedure
92253>>>>>>>>>>>
92253>>>>>>>>>>>    Function NewStyleName String sTableName Integer eNewStyle Returns String
92255>>>>>>>>>>>        String  sDDStyle
92255>>>>>>>>>>>        Boolean bCamelCase
92255>>>>>>>>>>>
92255>>>>>>>>>>>        Get pbCamelCaseTableName to bCamelCase
92256>>>>>>>>>>>        If (bCamelCase) Begin
92258>>>>>>>>>>>            // Camel Case makes the whole tablename lowercase except for the first Letter
92258>>>>>>>>>>>            Move (lowercase(sTableName)) to sTableName
92259>>>>>>>>>>>            Move (Overstrike(Uppercase(Left(sTableName,1)),sTableName,1)) to sTableName
92260>>>>>>>>>>>        End
92260>>>>>>>>>>>>
92260>>>>>>>>>>>
92260>>>>>>>>>>>        Case Begin
92260>>>>>>>>>>>            Case (eNewStyle = eDDOldStyle)
92262>>>>>>>>>>>                Move (sTableName + "_DD") to sDDStyle
92263>>>>>>>>>>>                Case Break
92264>>>>>>>>>>>            Case (eNewStyle = eDDStudioStyle)
92267>>>>>>>>>>>                Move ("o" + sTableName + "_DD") to sDDStyle
92268>>>>>>>>>>>                Case Break
92269>>>>>>>>>>>            Case (eNewStyle = eDDNewStyle)
92272>>>>>>>>>>>                Move ("o" + sTableName + "_DD") to sDDStyle
92273>>>>>>>>>>>                Case Break
92274>>>>>>>>>>>            Case Else
92274>>>>>>>>>>>                Showln ("Unexpected error new style" * Trim(eNewStyle) * "is undefined.")
92276>>>>>>>>>>>        Case End
92276>>>>>>>>>>>        Function_Return sDDStyle
92277>>>>>>>>>>>    End_Function
92278>>>>>>>>>>>
92278>>>>>>>>>>>    Procedure ApplyNewStyleForTable tDDO DDObject
92280>>>>>>>>>>>        Boolean bUpdated
92280>>>>>>>>>>>        Integer eNewStyle eOldStyle iCount iLine iPos iLen
92280>>>>>>>>>>>        String sLine sNline sNOldDDName sNewDDName
92280>>>>>>>>>>>        String[] sSource
92281>>>>>>>>>>>
92281>>>>>>>>>>>        Get peNewStyle to eNewStyle
92282>>>>>>>>>>>        Move DDObject.eDDOStyle to eOldStyle
92283>>>>>>>>>>>        If (eNewStyle <> eOldStyle) Begin
92285>>>>>>>>>>>            Get psSource to sSource
92286>>>>>>>>>>>            Move (Lowercase(DDObject.sDDO)) to sNOldDDName
92287>>>>>>>>>>>            Move (Length(sNOldDDName))      to iLen
92288>>>>>>>>>>>            Get NewStyleName DDObject.sTableName eNewStyle to sNewDDName
92289>>>>>>>>>>>            Move (SizeOfArray(sSource) -1)  to iCount
92290>>>>>>>>>>>            
92290>>>>>>>>>>>            If (iCount >= 0) Begin
92292>>>>>>>>>>>                For iLine from 0 to iCount
92298>>>>>>>>>>>>
92298>>>>>>>>>>>                    Move False to bUpdated
92299>>>>>>>>>>>                    Move sSource[iLine] to sLine
92300>>>>>>>>>>>                    
92300>>>>>>>>>>>                    // End of line happens, see Set DDO_Server To <table>_DD
92300>>>>>>>>>>>                    Move (sLine + " ") to sLine
92301>>>>>>>>>>>                    Move (Lowercase(sLine)) to sNline
92302>>>>>>>>>>>                    // Valid separate characters are: " ",",","(",")", EOL
92302>>>>>>>>>>>                    // The DDO objects are _never_ at the start of the line
92302>>>>>>>>>>>                    Move (Replaces(",", sNline, " ")) to sNline
92303>>>>>>>>>>>                    Move (Replaces("(", sNline, " ")) to sNline
92304>>>>>>>>>>>                    Move (Replaces(")", sNline, " ")) to sNline
92305>>>>>>>>>>>
92305>>>>>>>>>>>                    // Only one type of replacement left, easy testing :)
92305>>>>>>>>>>>                    Move (Pos(" " + sNOldDDName + " ", sNline)) to iPos
92306>>>>>>>>>>>                    While (iPos <> 0)
92310>>>>>>>>>>>                        Move True to bUpdated
92311>>>>>>>>>>>                        Move (Replace(" " + sNOldDDName + " ", sNline, " " + sNewDDName + " ")) to sNline
92312>>>>>>>>>>>                        // Don't know correct case in the actual line, use remove+insert
92312>>>>>>>>>>>                        // Can't use replace on the real line as it will end up replacing replaced
92312>>>>>>>>>>>                        Move (Remove(sLine, (iPos +1), iLen)) to sLine
92313>>>>>>>>>>>                        Move (Insert(sNewDDName, sLine, (iPos +1))) to sLine
92314>>>>>>>>>>>
92314>>>>>>>>>>>                        Move (Pos(" " + sNOldDDName + " ", sNline)) to iPos
92315>>>>>>>>>>>                    Loop
92316>>>>>>>>>>>>
92316>>>>>>>>>>>                    If (bUpdated) Begin
92318>>>>>>>>>>>                        Move (RTrim(sLine)) to sSource[iLine]
92319>>>>>>>>>>>                    End
92319>>>>>>>>>>>>
92319>>>>>>>>>>>                Loop
92320>>>>>>>>>>>>
92320>>>>>>>>>>>                Set psSource to sSource
92321>>>>>>>>>>>            End
92321>>>>>>>>>>>>
92321>>>>>>>>>>>        End
92321>>>>>>>>>>>>
92321>>>>>>>>>>>    End_Procedure
92322>>>>>>>>>>>
92322>>>>>>>>>>>    Procedure ApplyNewStyle
92324>>>>>>>>>>>        Boolean bStrict bReplace
92324>>>>>>>>>>>        Integer iFile iCount eStyle
92324>>>>>>>>>>>        String  sFileName
92324>>>>>>>>>>>        tDDO[]  DDObjects
92324>>>>>>>>>>>        tDDO[]  DDObjects
92325>>>>>>>>>>>
92325>>>>>>>>>>>        Get peNewStyle to eStyle
92326>>>>>>>>>>>
92326>>>>>>>>>>>        If (eStyle <> eDDUnknown) Begin
92328>>>>>>>>>>>            Get pbStrict to bStrict   // Default is to only rename DDO's that exist in filelist
92329>>>>>>>>>>>            Get ParseFileName (psFileName(Self)) to sFileName
92330>>>>>>>>>>>            Get pDDObjects to DDObjects
92331>>>>>>>>>>>            Move (SizeOfArray(DDObjects) - 1) to iCount
92332>>>>>>>>>>>            
92332>>>>>>>>>>>            If (iCount >= 0) Begin
92334>>>>>>>>>>>                For iFile from 0 to iCount
92340>>>>>>>>>>>>
92340>>>>>>>>>>>                    Move False to bReplace
92341>>>>>>>>>>>                    If (bStrict) Begin
92343>>>>>>>>>>>                        If (DDObjects[iFile].bVerified=True) Begin
92345>>>>>>>>>>>                            Move True to bReplace
92346>>>>>>>>>>>                        End
92346>>>>>>>>>>>>
92346>>>>>>>>>>>                        Else Begin
92347>>>>>>>>>>>                            Showln ("DDO" * DDObjects[iFile].sDDO * "was not found in the filelist. File" * sFileName)
92349>>>>>>>>>>>                        End
92349>>>>>>>>>>>>
92349>>>>>>>>>>>                    End
92349>>>>>>>>>>>>
92349>>>>>>>>>>>                    Else Begin
92350>>>>>>>>>>>                        // if you want to do non strict, you need to fill in ddobject.sTableName still!
92350>>>>>>>>>>>                        Move True to bReplace
92351>>>>>>>>>>>                    End
92351>>>>>>>>>>>>
92351>>>>>>>>>>>                    If (DDObjects[iFile].eDDOStyle = eDDUnknown) Begin
92353>>>>>>>>>>>                        Move False to bReplace
92354>>>>>>>>>>>                        Showln ("DDO" * DDObjects[iFile].sDDO * "style is not recognized. File" * sFileName)
92356>>>>>>>>>>>                    End
92356>>>>>>>>>>>>
92356>>>>>>>>>>>                    If (DDObjects[iFile].eDDOStyle = eStyle) Begin
92358>>>>>>>>>>>                        Move False to bReplace
92359>>>>>>>>>>>                        Showln ("DDO" * DDObjects[iFile].sDDO * "style already correct. File" * sFileName)
92361>>>>>>>>>>>                    End
92361>>>>>>>>>>>>
92361>>>>>>>>>>>                    If (bReplace) Begin
92363>>>>>>>>>>>                        Send ApplyNewStyleForTable DDObjects[iFile]
92364>>>>>>>>>>>                    End
92364>>>>>>>>>>>>
92364>>>>>>>>>>>                Loop
92365>>>>>>>>>>>>
92365>>>>>>>>>>>            End
92365>>>>>>>>>>>>
92365>>>>>>>>>>>        End 
92365>>>>>>>>>>>>
92365>>>>>>>>>>>    End_Procedure
92366>>>>>>>>>>>
92366>>>>>>>>>>>    Function OpenOutput String sFileName Returns Integer
92368>>>>>>>>>>>        Integer iChannel
92368>>>>>>>>>>>
92368>>>>>>>>>>>        Get Seq_New_Channel to iChannel
92369>>>>>>>>>>>        If (iChannel <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
92371>>>>>>>>>>>            Direct_Output channel iChannel sFileName
92373>>>>>>>>>>>        End
92373>>>>>>>>>>>>
92373>>>>>>>>>>>        Function_Return iChannel
92374>>>>>>>>>>>    End_Function
92375>>>>>>>>>>>
92375>>>>>>>>>>>    Procedure CloseOutput Integer iChannel
92377>>>>>>>>>>>        Close_Output channel iChannel
92379>>>>>>>>>>>        Send Seq_Release_Channel iChannel
92380>>>>>>>>>>>    End_Procedure
92381>>>>>>>>>>>
92381>>>>>>>>>>>    Function OpenInput String sFileName Returns Integer
92383>>>>>>>>>>>        Integer iChannel
92383>>>>>>>>>>>
92383>>>>>>>>>>>        Get Seq_New_Channel to iChannel
92384>>>>>>>>>>>        If (iChannel<>DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
92386>>>>>>>>>>>            Direct_Input channel iChannel ("binary:"+sFileName)
92388>>>>>>>>>>>        End
92388>>>>>>>>>>>>
92388>>>>>>>>>>>        Function_Return iChannel
92389>>>>>>>>>>>    End_Function
92390>>>>>>>>>>>
92390>>>>>>>>>>>    Procedure CloseInput Integer iChannel
92392>>>>>>>>>>>        Close_Input channel iChannel
92394>>>>>>>>>>>        Send Seq_Release_Channel iChannel
92395>>>>>>>>>>>    End_Procedure
92396>>>>>>>>>>>
92396>>>>>>>>>>>    // Code that handles the restyle on the DD Object in the source filename supplied
92396>>>>>>>>>>>    // and changes it to the new style eDDStyle
92396>>>>>>>>>>>    Procedure RestyleDDObjects String sFileName Integer eDDStyle
92398>>>>>>>>>>>        Send ReadFile sFilename
92399>>>>>>>>>>>        Send FindCurrentDDObjects
92400>>>>>>>>>>>        Send ClassifyDDObjects
92401>>>>>>>>>>>        Set peNewStyle to eDDStyle
92402>>>>>>>>>>>        Send ApplyNewStyle
92403>>>>>>>>>>>        Send WriteFile
92404>>>>>>>>>>>    End_Procedure
92405>>>>>>>>>>>
92405>>>>>>>>>>>End_Class
92406>>>>>>>>>// ToDo: Test with this package:
92406>>>>>>>>>//Use stringtokenizer.pkg
92406>>>>>>>>>
92406>>>>>>>>>Register_Function phoEditor Returns Handle 
92406>>>>>>>>>Register_Function phoRemoveUnusedLocals Returns Handle
92406>>>>>>>>>Register_Function phoReportUnusedSourceFiles Returns Handle
92406>>>>>>>>>
92406>>>>>>>>>
92406>>>>>>>>>Global_Variable Handle ghoStatusLog
92406>>>>>>>>>
92406>>>>>>>>>Use cSysFileDataDictionary.dd  
92406>>>>>>>>>Open FunctionsA
Including file: FunctionsA.fd    (C:\Projects\DF18\DfRefactor\DDSrc\FunctionsA.fd)
92408>>>>>>>>>
92408>>>>>>>>>Class cRefactorFunctionLibrary is a cObject
92409>>>>>>>>>    
92409>>>>>>>>>    Procedure Construct_Object
92411>>>>>>>>>        String[] asLocalVariableTypes asLocalVariableArrayTypes
92413>>>>>>>>>
92413>>>>>>>>>        Forward Send Construct_Object
92415>>>>>>>>>        Move Self to ghoRefactorFunctionLibrary
92416>>>>>>>>>
92416>>>>>>>>>        Property Handle phoEditor
92417>>>>>>>>>        Property Integer peNewStyle eDDUnknown
92418>>>>>>>>>
92418>>>>>>>>>        Property tRefactorSettings pRefactorSettings
92419>>>>>>>>>        //
92419>>>>>>>>>        Property Boolean pbToggleState True     
92420>>>>>>>>>        Property Boolean pbInRepeatLoop False
92421>>>>>>>>>        
92421>>>>>>>>>        Property String[] paCommands
92422>>>>>>>>>        Property String[] paCommandFunctions    
92423>>>>>>>>>        Property String[] pasLocalVariableTypes
92424>>>>>>>>>        Property String[] pasLocalVariableArrayTypes
92425>>>>>>>>>
92425>>>>>>>>>        Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
92426>>>>>>>>>        Set pasLocalVariableTypes to asLocalVariableTypes
92427>>>>>>>>>        Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
92428>>>>>>>>>        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes
92429>>>>>>>>>
92429>>>>>>>>>        // Properties for the RemovePRoejctObjectStructure function:
92429>>>>>>>>>        Property Boolean pbProjectObjectStructureStart False 
92430>>>>>>>>>        Property Boolean pbProjectObjectStructureEnd False
92431>>>>>>>>>        Property Boolean pbRegisterAllObjectsStart False    
92432>>>>>>>>>        Property Boolean pbRegisterAllObjectsEnd False
92433>>>>>>>>>        Property String[] pasObjectNames
92434>>>>>>>>>
92434>>>>>>>>>    End_Procedure
92435>>>>>>>>>
92435>>>>>>>>>    Procedure End_Construct_Object
92437>>>>>>>>>        Forward Send End_Construct_Object
92439>>>>>>>>>        Send AddAllCommands  
92440>>>>>>>>>        Send AddAllCommandFunctions
92441>>>>>>>>>    End_Procedure
92442>>>>>>>>>    
92442>>>>>>>>>    // *** External function package(s) must to be included here. ***
92442>>>>>>>>>    // Asolvi function package.  
92442>>>>>>>>>//    Define CS_Use_Asolvi for "UseAsolvi"
92442>>>>>>>>>
92442>>>>>>>>>    // ToDo: *** LINE-BY-LINE FUNCTIONS ***
92442>>>>>>>>>    
92442>>>>>>>>>    // Only does a replace of "Current_Object" to "Self"
92442>>>>>>>>>    Function ChangeCurrent_ObjectToSelf String ByRef sLine String sParameter Returns Boolean
92444>>>>>>>>>        String sText sStart sStop
92444>>>>>>>>>        Boolean bFound
92444>>>>>>>>>        Integer iPos
92444>>>>>>>>>        
92444>>>>>>>>>        Move sLine to sText
92445>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92446>>>>>>>>>        If (bFound = True) Begin
92448>>>>>>>>>            Function_Return False
92449>>>>>>>>>        End
92449>>>>>>>>>>
92449>>>>>>>>>        Move (Lowercase(sText)) to sText
92450>>>>>>>>>        Move (Pos(lowercase(CS_Current_Object), sText)) to iPos
92451>>>>>>>>>        If (iPos = 0) Begin
92453>>>>>>>>>            Function_Return False
92454>>>>>>>>>        End                      
92454>>>>>>>>>>
92454>>>>>>>>>        Move (Left(sLine, (iPos -1))) to sStart
92455>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + Length(CS_Current_Object)))) to sStop
92456>>>>>>>>>        Move (sStart + CS_Self + String(sStop)) to sLine 
92457>>>>>>>>>        
92457>>>>>>>>>        // Note! Recursively calls the same function if there are more than one "current_object" in the code line.
92457>>>>>>>>>        Move (Lowercase(sLine)) to sText
92458>>>>>>>>>        Move (Pos(lowercase(CS_Current_Object), sText)) to iPos
92459>>>>>>>>>        If (iPos <> 0) Begin                             
92461>>>>>>>>>            Move sLine to sText
92462>>>>>>>>>            Get ChangeCurrent_ObjectToSelf sLine to sText
92463>>>>>>>>>        End                      
92463>>>>>>>>>>
92463>>>>>>>>>        
92463>>>>>>>>>        Function_Return True    
92464>>>>>>>>>    End_Function
92465>>>>>>>>>    
92465>>>>>>>>>    // Changes "DfTrue" --> "True" and "DfFalse" --> "False"
92465>>>>>>>>>    Function ChangeDfTrueDfFalse String ByRef sLine String sParameter Returns Boolean
92467>>>>>>>>>        String sText sIndicator sCommand sEndString
92467>>>>>>>>>        Boolean bFound
92467>>>>>>>>>        Integer iPos 
92467>>>>>>>>>        
92467>>>>>>>>>        Move sLine to sText
92468>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92469>>>>>>>>>        If (bFound = True) Begin
92471>>>>>>>>>            Function_Return False
92472>>>>>>>>>        End
92472>>>>>>>>>>
92472>>>>>>>>>        
92472>>>>>>>>>        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
92472>>>>>>>>>        Get IsKeywordInLine (CS_DfTrue + "|" + CS_DfFalse + "|" ) sText to bFound
92473>>>>>>>>>        If (bFound = False) Begin
92475>>>>>>>>>            Function_Return False
92476>>>>>>>>>        End
92476>>>>>>>>>>
92476>>>>>>>>>        
92476>>>>>>>>>        Move (Lowercase(sText)) to sText
92477>>>>>>>>>        While (bFound = True)
92481>>>>>>>>>            Move (Pos(Lowercase(CS_DfTrue), sText)) to iPos
92482>>>>>>>>>            If (iPos > 0) Begin
92484>>>>>>>>>                Move (Overstrike("||", sText, iPos)) to sText
92485>>>>>>>>>                Move (Overstrike("||", sLine, iPos)) to sLine
92486>>>>>>>>>            End
92486>>>>>>>>>>
92486>>>>>>>>>            Move (iPos > 0) to bFound
92487>>>>>>>>>            Move (Pos(Lowercase(CS_DfFalse), sText)) to iPos
92488>>>>>>>>>            If (iPos > 0) Begin
92490>>>>>>>>>                Move (Overstrike("||", sText, iPos)) to sText
92491>>>>>>>>>                Move (Overstrike("||", sLine, iPos)) to sLine
92492>>>>>>>>>            End
92492>>>>>>>>>>
92492>>>>>>>>>            If (bFound = False) Begin
92494>>>>>>>>>                Move (iPos > 0) to bFound
92495>>>>>>>>>            End
92495>>>>>>>>>>
92495>>>>>>>>>        Loop              
92496>>>>>>>>>>
92496>>>>>>>>>
92496>>>>>>>>>        Move (Replaces("||", sLine, "")) to sLine
92497>>>>>>>>>        Function_Return True
92498>>>>>>>>>    End_Function  
92499>>>>>>>>>    
92499>>>>>>>>>    // Changes; [Found] Loop --> Loop
92499>>>>>>>>>    Function ChangeFoundLoopIndicator String ByRef sLine String sParameter Returns Boolean
92501>>>>>>>>>        tCodeComponents LineComponents 
92501>>>>>>>>>        tCodeComponents LineComponents 
92501>>>>>>>>>        tBooleanIndicator BooleanIndicator
92501>>>>>>>>>        tBooleanIndicator BooleanIndicator
92501>>>>>>>>>        String sText                  
92501>>>>>>>>>        Boolean bIsLoopStatement bIsRepeatStatement bFound
92501>>>>>>>>>        Integer iFoundIndicator iPosLoop
92501>>>>>>>>>        
92501>>>>>>>>>        Get IsCommentLineOrBlank sLine to bFound
92502>>>>>>>>>        If (bFound = True) Begin
92504>>>>>>>>>            Function_Return False
92505>>>>>>>>>        End
92505>>>>>>>>>>
92505>>>>>>>>>
92505>>>>>>>>>        Get IsLoopStatement sLine to bIsLoopStatement  
92506>>>>>>>>>        If (bIsLoopStatement = False) Begin
92508>>>>>>>>>            Function_Return False
92509>>>>>>>>>        End
92509>>>>>>>>>>
92509>>>>>>>>>        
92509>>>>>>>>>        Get IsRepeatStatement sLine to bIsRepeatStatement
92510>>>>>>>>>        Get Tokenizer sLine to LineComponents
92511>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
92512>>>>>>>>>        If (bIsRepeatStatement = True) Begin
92514>>>>>>>>>            // We save the start of a Repeat/Loop in a class property, which gets set to False when a Loop statement is found.
92514>>>>>>>>>            If (BooleanIndicator.bHasBracket = False) Begin
92516>>>>>>>>>                Set pbInRepeatLoop to True
92517>>>>>>>>>                Function_Return False
92518>>>>>>>>>            End    
92518>>>>>>>>>>
92518>>>>>>>>>        End
92518>>>>>>>>>>
92518>>>>>>>>>        
92518>>>>>>>>>        // If no indicator e.g. "[Found]" before the Loop command, we're done.
92518>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
92520>>>>>>>>>            Set pbInRepeatLoop to False
92521>>>>>>>>>            Function_Return False
92522>>>>>>>>>        End        
92522>>>>>>>>>>
92522>>>>>>>>>        
92522>>>>>>>>>        If (pbInRepeatLoop(Self) = True) Begin
92524>>>>>>>>>            Move CS_Until to BooleanIndicator.sCode
92525>>>>>>>>>            Move (String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression)) to LineComponents.sCode
92526>>>>>>>>>        End 
92526>>>>>>>>>>
92526>>>>>>>>>        Else Begin
92527>>>>>>>>>            Move CS_Loop to LineComponents.sCode
92528>>>>>>>>>        End
92528>>>>>>>>>>
92528>>>>>>>>>        Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * String(LineComponents.sToStatement) + String(LineComponents.sRightComment))) to sLine
92529>>>>>>>>>        Set pbInRepeatLoop to False
92530>>>>>>>>>        
92530>>>>>>>>>        Function_Return True
92531>>>>>>>>>    End_Function
92532>>>>>>>>>
92532>>>>>>>>>    // Changes [Found] Reread (and other commnds _except Loop, While, [Select], and If & Begin
92532>>>>>>>>>    //     to: If (Found) command
92532>>>>>>>>>    Function ChangeFoundAndFindErrIndicators String ByRef sLine String sParameter Returns Boolean
92534>>>>>>>>>        String sText sIndicator sCommand sEndString
92534>>>>>>>>>        Boolean bChanged bFound
92534>>>>>>>>>        Integer iPos 
92534>>>>>>>>>        tCodeComponents LineComponents 
92534>>>>>>>>>        tCodeComponents LineComponents 
92534>>>>>>>>>        tBooleanIndicator BooleanIndicator
92534>>>>>>>>>        tBooleanIndicator BooleanIndicator
92534>>>>>>>>>        
92534>>>>>>>>>        Move sLine to sText
92535>>>>>>>>>        Get IsFoundOrFindErrIndicator sText to bFound
92536>>>>>>>>>        If (bFound = False) Begin
92538>>>>>>>>>            Function_Return False
92539>>>>>>>>>        End
92539>>>>>>>>>>
92539>>>>>>>>>        
92539>>>>>>>>>        Get Tokenizer sLine to LineComponents
92540>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
92541>>>>>>>>>        Move (Lowercase(BooleanIndicator.sExpression) contains Lowercase(CS_Found)) to bFound
92542>>>>>>>>>        // [Finderr]
92542>>>>>>>>>        If (bFound = False) Begin
92544>>>>>>>>>            Move ("(" + String(CS_Found) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression
92545>>>>>>>>>        End
92545>>>>>>>>>>
92545>>>>>>>>>        
92545>>>>>>>>>        Move (Pos(" ", LineComponents.sCode)) to iPos
92546>>>>>>>>>        Move (Mid(LineComponents.sCode, Length(LineComponents.sCode), (iPos + 1))) to LineComponents.sCode
92547>>>>>>>>>        // Must check that it isn't a "Repeat" or "While" or "Loop" command 
92547>>>>>>>>>   
92547>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Repeat)) to bFound
92548>>>>>>>>>        If (bFound = True) Begin
92550>>>>>>>>>            Function_Return False
92551>>>>>>>>>        End
92551>>>>>>>>>>
92551>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Loop)) to bFound
92552>>>>>>>>>        If (bFound = True) Begin
92554>>>>>>>>>            Function_Return False
92555>>>>>>>>>        End
92555>>>>>>>>>>
92555>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_While)) to bFound
92556>>>>>>>>>        If (bFound = True) Begin
92558>>>>>>>>>            Function_Return False
92559>>>>>>>>>        End
92559>>>>>>>>>>
92559>>>>>>>>>        Move (Lowercase(BooleanIndicator.sCode) = Lowercase(CS_Select)) to bFound
92560>>>>>>>>>        If (bFound = True) Begin
92562>>>>>>>>>            Function_Return False
92563>>>>>>>>>        End
92563>>>>>>>>>>
92563>>>>>>>>>        
92563>>>>>>>>>        Move "" to sEndString
92564>>>>>>>>>        If (LineComponents.sOfStatement <> "") Begin
92566>>>>>>>>>            Move (" " + String(LineComponents.sOfStatement)) to sEndString
92567>>>>>>>>>        End
92567>>>>>>>>>>
92567>>>>>>>>>        If (LineComponents.sToStatement <> "") Begin
92569>>>>>>>>>            Move (sEndString * String(LineComponents.sToStatement)) to sEndString
92570>>>>>>>>>        End
92570>>>>>>>>>>
92570>>>>>>>>>        If (LineComponents.sRightComment <> "") Begin
92572>>>>>>>>>            Move (sEndString * LineComponents.sRightComment) to sEndString
92573>>>>>>>>>        End 
92573>>>>>>>>>>
92573>>>>>>>>>        
92573>>>>>>>>>        Move (String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to LineComponents.sCode
92574>>>>>>>>>        Move (LineComponents.sIndentation + String(CS_If) * String(LineComponents.sCode) * String(sEndString)) to sLine
92575>>>>>>>>>        Function_Return True
92576>>>>>>>>>    End_Function 
92577>>>>>>>>>    
92577>>>>>>>>>    // Changes 'GetAddress of sVal to aAddress --> Move (AddressOf(sVal)) to aAddress'
92577>>>>>>>>>    // For the function to do anything, the line needs to contain a "GetAddress" command.
92577>>>>>>>>>    Function ChangeGetAddress String ByRef sLine String sParameter Returns Boolean
92579>>>>>>>>>        Boolean bFound
92579>>>>>>>>>        String sText sToVar sOfVar sCommand
92579>>>>>>>>>        Integer iPos  
92579>>>>>>>>>        tCodeComponents CodeComponents
92579>>>>>>>>>        tCodeComponents CodeComponents
92579>>>>>>>>>
92579>>>>>>>>>        Move sLine to sText
92580>>>>>>>>>
92580>>>>>>>>>        // Skip line if it is a comment or blank
92580>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92581>>>>>>>>>        If (bFound = True) Begin
92583>>>>>>>>>            Function_Return False
92584>>>>>>>>>        End
92584>>>>>>>>>>
92584>>>>>>>>>        // Skip line if it contains a semi colon
92584>>>>>>>>>        Get IsLineEndSemiColon sText to bFound    
92585>>>>>>>>>        If (bFound = True) Begin
92587>>>>>>>>>            Function_Return False
92588>>>>>>>>>        End
92588>>>>>>>>>>
92588>>>>>>>>>        Get _RetrieveFirstWord sText to sCommand
92589>>>>>>>>>        If (Lowercase(sCommand) = Lowercase(CS_Function)) Begin
92591>>>>>>>>>            Function_Return False
92592>>>>>>>>>        End
92592>>>>>>>>>>
92592>>>>>>>>>        
92592>>>>>>>>>        Get Tokenizer sLine to CodeComponents
92593>>>>>>>>>        Get IsKeywordInLine (CS_GetAddress + "|") CodeComponents.sCode to bFound
92594>>>>>>>>>        If (bFound = False) Begin
92596>>>>>>>>>            Function_Return False
92597>>>>>>>>>        End
92597>>>>>>>>>>
92597>>>>>>>>>        
92597>>>>>>>>>        If (CodeComponents.sRightComment <> "") Begin
92599>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + CodeComponents.sOfStatement + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
92600>>>>>>>>>        End 
92600>>>>>>>>>>
92600>>>>>>>>>        Else Begin
92601>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * "(" + CS_AddressOf + "(" + CodeComponents.sOfStatement + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
92602>>>>>>>>>        End
92602>>>>>>>>>>
92602>>>>>>>>>        
92602>>>>>>>>>        Function_Return True
92603>>>>>>>>>    End_Function
92604>>>>>>>>>
92604>>>>>>>>>    // Changes e.g. "Indicate indicator as True" --> "Move (True) to indicator"
92604>>>>>>>>>    //              "[Select] Indicate Select as Windowindex Eq Fieldindex"
92604>>>>>>>>>    Function ChangeIndicateFoundToMoveTrueToFound String ByRef sLine String sParameter Returns Boolean
92606>>>>>>>>>        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis
92606>>>>>>>>>        String sText sVariable sExpression sIndicate sChar
92606>>>>>>>>>        Integer iPos                      
92606>>>>>>>>>        tCodeComponents CodeComponents
92606>>>>>>>>>        tCodeComponents CodeComponents
92606>>>>>>>>>        
92606>>>>>>>>>        Move False to bChanged
92607>>>>>>>>>        Move (Lowercase(sLine)) to sText
92608>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentLineOrBlank
92609>>>>>>>>>        If (bIsCommentLineOrBlank = True) Begin
92611>>>>>>>>>            Function_Return False
92612>>>>>>>>>        End
92612>>>>>>>>>>
92612>>>>>>>>>        
92612>>>>>>>>>        Move (Ltrim(Lowercase(sText))) to sText
92613>>>>>>>>>        Move (Pos(Lowercase(CS_Indicate + " "), sText)) to iPos
92614>>>>>>>>>        If (iPos <> 1) Begin
92616>>>>>>>>>            Function_Return False
92617>>>>>>>>>        End
92617>>>>>>>>>>
92617>>>>>>>>>        Get Tokenizer sLine to CodeComponents
92618>>>>>>>>>        Move (Pos(" ", CodeComponents.sCode)) to iPos
92619>>>>>>>>>        Move (Left(CodeComponents.sCode, (iPos -1))) to sIndicate
92620>>>>>>>>>        If ((Lowercase(sIndicate) + " ") <> (Lowercase(CS_Indicate) + " ")) Begin
92622>>>>>>>>>            Function_Return False
92623>>>>>>>>>        End                      
92623>>>>>>>>>>
92623>>>>>>>>>        
92623>>>>>>>>>        Move (Pos(" ", CodeComponents.sCode)) to iPos // Indicate (a < b) as False
92624>>>>>>>>>        Move (Left(CodeComponents.sCode, (iPos -1))) to sText //   (a < b) as False
92625>>>>>>>>>        Move (Replace(sText, CodeComponents.sCode, "")) to CodeComponents.sCode
92626>>>>>>>>>        Move (Trim(CodeComponents.sCode)) to CodeComponents.sCode
92627>>>>>>>>>        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(CodeComponents.sCode))) to iPos 
92628>>>>>>>>>        Move (Left(CodeComponents.sCode, (iPos -1))) to sExpression // (a < b)
92629>>>>>>>>>        Move (Replace(sExpression, CodeComponents.sCode, "")) to CodeComponents.sCode //  as False
92630>>>>>>>>>        Move (Pos((" " + Lowercase(CS_As) + " "), Lowercase(CodeComponents.sCode))) to iPos         
92631>>>>>>>>>        Move (Mid(CodeComponents.sCode, Length(CodeComponents.sCode), (iPos + Length(CS_As) + 2))) to sVariable
92632>>>>>>>>>        Move (Left(sVariable, 1)) to sChar
92633>>>>>>>>>        Move (sChar = "(") to bIsParanthesis
92634>>>>>>>>>        If (bIsParanthesis = False) Begin
92636>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * "(" + String(sVariable) + ")" * CS_To * String(sExpression) + CodeComponents.sRightComment) to sLine
92637>>>>>>>>>        End 
92637>>>>>>>>>>
92637>>>>>>>>>        Else Begin
92638>>>>>>>>>            Move (CodeComponents.sIndentation + CS_Move * String(sVariable) * CS_To * String(sExpression) + CodeComponents.sRightComment) to sLine
92639>>>>>>>>>        End
92639>>>>>>>>>>
92639>>>>>>>>>                                                            
92639>>>>>>>>>        Function_Return bChanged
92640>>>>>>>>>    End_Function 
92641>>>>>>>>>
92641>>>>>>>>>    // [Select] Indicate Select as Windowindex Eq Fieldindex --> If (Select) Move (Windowindex = Fieldindex) to Select // Comment
92641>>>>>>>>>    Function ChangeIndicatorToMoveStateToVariable String ByRef sLine String sParameter Returns Boolean
92643>>>>>>>>>        Boolean bChanged bIsCommentLineOrBlank bIsParanthesis bStartIndicator bFound bIsIfStatement
92643>>>>>>>>>        String sText sVariable sExpression sIndicator sChar sOrgLine sIfStatement sCommand
92643>>>>>>>>>        Integer iPos iStart iEnd
92643>>>>>>>>>        tCodeComponents Components 
92643>>>>>>>>>        tCodeComponents Components 
92643>>>>>>>>>        tBooleanIndicator BooleanIndicator
92643>>>>>>>>>        tBooleanIndicator BooleanIndicator
92643>>>>>>>>>        
92643>>>>>>>>>        Move False to bChanged
92644>>>>>>>>>        Move sLine to sText                                        
92645>>>>>>>>>        Move sLine to sOrgLine
92646>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentLineOrBlank
92647>>>>>>>>>        If (bIsCommentLineOrBlank = True) Begin
92649>>>>>>>>>            Function_Return False
92650>>>>>>>>>        End              
92650>>>>>>>>>>
92650>>>>>>>>>        Move (Trim(sText)) to sChar
92651>>>>>>>>>        If (Left(sChar, 1) = "#") Begin
92653>>>>>>>>>            Function_Return False
92654>>>>>>>>>        End
92654>>>>>>>>>>
92654>>>>>>>>>        // While, Repeat, Loop and Until are delt with by other functions.
92654>>>>>>>>>        Get IsWhileStatement sText to bFound
92655>>>>>>>>>        If (bFound = True) Begin
92657>>>>>>>>>            Function_Return False
92658>>>>>>>>>        End
92658>>>>>>>>>>
92658>>>>>>>>>        Get IsRepeatStatement sText to bFound
92659>>>>>>>>>        If (bFound = True) Begin
92661>>>>>>>>>            Function_Return False
92662>>>>>>>>>        End
92662>>>>>>>>>>
92662>>>>>>>>>        Get IsLoopStatement sText to bFound
92663>>>>>>>>>        If (bFound = True) Begin
92665>>>>>>>>>            Function_Return False
92666>>>>>>>>>        End
92666>>>>>>>>>>
92666>>>>>>>>>        Get IsUntilStatement sText to bFound
92667>>>>>>>>>        If (bFound = True) Begin
92669>>>>>>>>>            Function_Return False
92670>>>>>>>>>        End
92670>>>>>>>>>>
92670>>>>>>>>>        Get _RetrieveFirstWord sLine to sIfStatement
92671>>>>>>>>>        Move (Lowercase(sIfStatement) = Lowercase(CS_If)) to bIsIfStatement
92672>>>>>>>>>        If (bIsIfStatement = True) Begin
92674>>>>>>>>>            Move "" to sIfStatement
92675>>>>>>>>>        End
92675>>>>>>>>>>
92675>>>>>>>>>
92675>>>>>>>>>        Get Tokenizer sText to Components
92676>>>>>>>>>        Get _ExtractIndicatorContent Components.sCode to BooleanIndicator
92677>>>>>>>>>        If (BooleanIndicator.bHasBracket = False and Components.bHasIndicateCommand = False) Begin
92679>>>>>>>>>            Function_Return False
92680>>>>>>>>>        End                                 
92680>>>>>>>>>>
92680>>>>>>>>>        
92680>>>>>>>>>        // There are other function dealing with loop, while & move statements.
92680>>>>>>>>>        Get IsRepeatStatement BooleanIndicator.sCode to bFound
92681>>>>>>>>>        If (bFound = True) Begin
92683>>>>>>>>>            Function_Return False
92684>>>>>>>>>        End
92684>>>>>>>>>>
92684>>>>>>>>>        Get IsWhileStatement BooleanIndicator.sCode to bFound
92685>>>>>>>>>        If (bFound = True) Begin
92687>>>>>>>>>            Function_Return False
92688>>>>>>>>>        End
92688>>>>>>>>>>
92688>>>>>>>>>        Get IsMoveCommand BooleanIndicator.sCode to bFound
92689>>>>>>>>>        If (bFound = True) Begin
92691>>>>>>>>>            Function_Return False
92692>>>>>>>>>        End           
92692>>>>>>>>>>
92692>>>>>>>>>        If (BooleanIndicator.sCode = "") Begin
92694>>>>>>>>>            Move Components.sCode to BooleanIndicator.sCode
92695>>>>>>>>>        End
92695>>>>>>>>>>
92695>>>>>>>>>        
92695>>>>>>>>>        If (Lowercase(BooleanIndicator.sCode) contains Lowercase(CS_Indicate)) Begin
92697>>>>>>>>>            Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iEnd
92698>>>>>>>>>            If (iEnd <> 0) Begin
92700>>>>>>>>>                Move (Pos(Lowercase(CS_Indicate + " "), Lowercase(BooleanIndicator.sCode))) to iStart
92701>>>>>>>>>                Move (Left(BooleanIndicator.sCode, (iStart + Length(CS_Indicate)))) to sText
92702>>>>>>>>>                Move (Replace(sText, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
92703>>>>>>>>>                Move (Pos(Lowercase(CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
92704>>>>>>>>>                Move (Left(BooleanIndicator.sCode, (iPos - 1))) to sIndicator
92705>>>>>>>>>                Move (Replace(sIndicator, BooleanIndicator.sCode, "")) to BooleanIndicator.sCode
92706>>>>>>>>>                Move (Pos(Lowercase(" " + CS_As + " "), Lowercase(BooleanIndicator.sCode))) to iPos
92707>>>>>>>>>                Move (Mid(BooleanIndicator.sCode, Length(BooleanIndicator.sCode), (iPos + 1 + Length(CS_As)))) to BooleanIndicator.sCode
92708>>>>>>>>>                Move (Trim(sIndicator)) to sIndicator
92709>>>>>>>>>                Move (String(CS_Move) * Trim(BooleanIndicator.sCode) * CS_To * String(sIndicator)) to BooleanIndicator.sCode
92710>>>>>>>>>                Get IsLegacyOperators BooleanIndicator.sCode to bFound
92711>>>>>>>>>                If (bFound = True) Begin            
92713>>>>>>>>>                    Move BooleanIndicator.sExpression to sText
92714>>>>>>>>>                    Get _AddExpressionParenthesis (&sText) to bFound  
92715>>>>>>>>>                    If (bFound = True) Begin
92717>>>>>>>>>                        Move sText to BooleanIndicator.sExpression
92718>>>>>>>>>                    End
92718>>>>>>>>>>
92718>>>>>>>>>                End
92718>>>>>>>>>>
92718>>>>>>>>>            End
92718>>>>>>>>>>
92718>>>>>>>>>        End
92718>>>>>>>>>>
92718>>>>>>>>>        
92718>>>>>>>>>        If (bIsIfStatement = True) Begin
92720>>>>>>>>>            Get _RetrieveFirstWord Components.sCode to sCommand
92721>>>>>>>>>            If (Lowercase(sCommand) = Lowercase(CS_If)) Begin
92723>>>>>>>>>                Move (String(Components.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
92724>>>>>>>>>            End
92724>>>>>>>>>>
92724>>>>>>>>>            Else Begin
92725>>>>>>>>>                Move (String(Components.sIndentation) + String(CS_If) * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
92726>>>>>>>>>            End
92726>>>>>>>>>>
92726>>>>>>>>>        End 
92726>>>>>>>>>>
92726>>>>>>>>>        Else If (BooleanIndicator.sExpression <> "" or BooleanIndicator.sCode <> "") Begin
92729>>>>>>>>>            If (Left(BooleanIndicator.sExpression, 1) = "(") Begin  
92731>>>>>>>>>                If (Components.sLineStartIndicator <> "") Begin
92733>>>>>>>>>                    If (Left(Components.sLineStartIndicator, 1) <> "(") Begin
92735>>>>>>>>>                        Move ("(" + String(Components.sLineStartIndicator) + ")") to Components.sLineStartIndicator
92736>>>>>>>>>                    End
92736>>>>>>>>>>
92736>>>>>>>>>                    Move (CS_If * String(Components.sLineStartIndicator)) to sLine 
92737>>>>>>>>>                    Move BooleanIndicator.sCode to sText
92738>>>>>>>>>                    Get _AddExpressionParenthesis (&sText) to bFound  // XXXX
92739>>>>>>>>>                    If (bFound = True) Begin
92741>>>>>>>>>                        Move sText to BooleanIndicator.sCode
92742>>>>>>>>>                    End
92742>>>>>>>>>>
92742>>>>>>>>>                    Move (String(sLine) * String(BooleanIndicator.sCode)) to BooleanIndicator.sCode
92743>>>>>>>>>                    Move "" to BooleanIndicator.sExpression
92744>>>>>>>>>                End
92744>>>>>>>>>>
92744>>>>>>>>>                Else Begin
92745>>>>>>>>>                    Move (CS_If * String(BooleanIndicator.sExpression)) to sLine
92746>>>>>>>>>                    Move (String(Components.sIndentation) + String(sLine) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
92747>>>>>>>>>                End
92747>>>>>>>>>>
92747>>>>>>>>>            End
92747>>>>>>>>>>
92747>>>>>>>>>            If (BooleanIndicator.sExpression <> "") Begin   
92749>>>>>>>>>                Move (String(Components.sIndentation) + String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to sLine
92750>>>>>>>>>            End
92750>>>>>>>>>>
92750>>>>>>>>>            Else Begin
92751>>>>>>>>>                Move (String(Components.sIndentation) + String(BooleanIndicator.sCode)) to sLine
92752>>>>>>>>>            End
92752>>>>>>>>>>
92752>>>>>>>>>        End
92752>>>>>>>>>>
92752>>>>>>>>>            
92752>>>>>>>>>        If (Components.sOfStatement <> "") Begin
92754>>>>>>>>>            Move (String(sLine) * CS_Of * String(Components.sOfStatement)) to sLine
92755>>>>>>>>>        End
92755>>>>>>>>>>
92755>>>>>>>>>        If (Components.sToStatement <> "") Begin
92757>>>>>>>>>            Move (String(sLine) * CS_To * String(Components.sToStatement)) to sLine
92758>>>>>>>>>        End                                                                
92758>>>>>>>>>>
92758>>>>>>>>>        If (Components.sRightComment <> "") Begin
92760>>>>>>>>>            Move (String(sLine) * String(Components.sRightComment)) to sLine
92761>>>>>>>>>        End
92761>>>>>>>>>>
92761>>>>>>>>>        Function_Return (sLine <> sOrgLine)
92762>>>>>>>>>    End_Function 
92763>>>>>>>>>    
92763>>>>>>>>>    // Changes; [Found] Repeat --> While (Found)
92763>>>>>>>>>    //          [not Seqeof] Repeat --> While (not(Seqeof))
92763>>>>>>>>>    Function ChangeIndicatorRepeatToWhile String ByRef sLine String sParameter Returns Boolean
92765>>>>>>>>>        tCodeComponents LineComponents 
92765>>>>>>>>>        tCodeComponents LineComponents 
92765>>>>>>>>>        tBooleanIndicator BooleanIndicator
92765>>>>>>>>>        tBooleanIndicator BooleanIndicator
92765>>>>>>>>>        String sChar sText sBoolean sNot sOrgLine
92765>>>>>>>>>        Boolean bIsRepeatStatement bFound
92765>>>>>>>>>        Integer iPosIndicator iPosRepeat iPos
92765>>>>>>>>>        
92765>>>>>>>>>        Move sLine to sText                      
92766>>>>>>>>>        Move sLine to sOrgLine
92767>>>>>>>>>        Get IsRepeatStatement sText to bIsRepeatStatement
92768>>>>>>>>>        If (bIsRepeatStatement = False) Begin
92770>>>>>>>>>            Function_Return False
92771>>>>>>>>>        End                      
92771>>>>>>>>>>
92771>>>>>>>>>        
92771>>>>>>>>>        Get Tokenizer sLine to LineComponents  
92772>>>>>>>>>        Get IsKeywordInLine (CS_Repeat + "|") LineComponents.sCode to bFound
92773>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
92774>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
92776>>>>>>>>>            Function_Return False
92777>>>>>>>>>        End        
92777>>>>>>>>>>
92777>>>>>>>>>
92777>>>>>>>>>        Move (CS_While * BooleanIndicator.sExpression) to LineComponents.sCode
92778>>>>>>>>>        Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * String(LineComponents.sToStatement) + String(LineComponents.sRightComment))) to sLine
92779>>>>>>>>>        
92779>>>>>>>>>        Function_Return (sLine <> sOrgLine)
92780>>>>>>>>>    End_Function
92781>>>>>>>>>    
92781>>>>>>>>>    // Changes; E.g. [Found] Begin --> If (Found) Begin  
92781>>>>>>>>>    //               [not Seqeof] Begin --> If (not(Seqeof)) Begin
92781>>>>>>>>>    Function ChangeIndicatorToIfBegin String ByRef sLine String sParameter Returns Boolean
92783>>>>>>>>>        tCodeComponents LineComponents   
92783>>>>>>>>>        tCodeComponents LineComponents   
92783>>>>>>>>>        tBooleanIndicator BooleanIndicator
92783>>>>>>>>>        tBooleanIndicator BooleanIndicator
92783>>>>>>>>>        String sText sNot sLogical
92783>>>>>>>>>        Boolean bFound bBegin
92783>>>>>>>>>        Integer iFoundIndicator iPosBegin iPos
92783>>>>>>>>>        
92783>>>>>>>>>        Move sLine to sText
92784>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92785>>>>>>>>>        If (bFound = True) Begin
92787>>>>>>>>>            Function_Return False
92788>>>>>>>>>        End
92788>>>>>>>>>>
92788>>>>>>>>>        
92788>>>>>>>>>        Get IsBeginStatement sText to bBegin
92789>>>>>>>>>        If (bBegin = False) Begin
92791>>>>>>>>>            Function_Return False
92792>>>>>>>>>        End                      
92792>>>>>>>>>>
92792>>>>>>>>>        
92792>>>>>>>>>        Get Tokenizer sLine to LineComponents
92793>>>>>>>>>        
92793>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
92794>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
92796>>>>>>>>>            Function_Return False
92797>>>>>>>>>        End
92797>>>>>>>>>>
92797>>>>>>>>>        Move (CS_If * String(BooleanIndicator.sExpression) * String(BooleanIndicator.sCode)) to LineComponents.sCode 
92798>>>>>>>>>        If (bBegin = True) Begin
92800>>>>>>>>>            Move (LineComponents.sIndentation + String(LineComponents.sCode) * String(LineComponents.sRightComment)) to sLine
92801>>>>>>>>>        End
92801>>>>>>>>>>
92801>>>>>>>>>        Else Begin
92802>>>>>>>>>            Move (LineComponents.sIndentation + String(LineComponents.sCode) + String(LineComponents.sOfStatement * CS_To + String(LineComponents.sToStatement) * String(LineComponents.sRightComment))) to sLine
92803>>>>>>>>>        End
92803>>>>>>>>>>
92803>>>>>>>>>        
92803>>>>>>>>>        Function_Return True
92804>>>>>>>>>    End_Function     
92805>>>>>>>>>    
92805>>>>>>>>>    // Changes: Insert "," In sText At 2 --> Move (Inert(",", sText, 2)) to sText
92805>>>>>>>>>    Function ChangeInsertCommandToFunction String ByRef sLine String sParameter Returns Boolean
92807>>>>>>>>>        Boolean bChanged bIsCommentOrBlank bIsReplace
92807>>>>>>>>>        String sText sStart sStop sVariableName sPlace sChar
92807>>>>>>>>>        Integer iPos 
92807>>>>>>>>>        tCodeComponents CodeComponents
92807>>>>>>>>>        tCodeComponents CodeComponents
92807>>>>>>>>>        
92807>>>>>>>>>        Move sLine to sText    
92808>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
92808>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
92809>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
92811>>>>>>>>>            Function_Return False
92812>>>>>>>>>        End
92812>>>>>>>>>>
92812>>>>>>>>>        Move (Ltrim(sText)) to sText
92813>>>>>>>>>        Move (Pos(Lowercase(CS_Insert + " "), Lowercase(sText))) to iPos
92814>>>>>>>>>        If (iPos < 1) Begin
92816>>>>>>>>>            Function_Return False
92817>>>>>>>>>        End
92817>>>>>>>>>>
92817>>>>>>>>>        
92817>>>>>>>>>        // Also check that the keyword is not part of a variable name:
92817>>>>>>>>>        Move (Mid(sText, 1, (iPos -1))) to sChar
92818>>>>>>>>>        If (sChar <> " " and sChar <> "(") Begin
92820>>>>>>>>>            Function_Return False
92821>>>>>>>>>        End
92821>>>>>>>>>>
92821>>>>>>>>>        
92821>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Insert to bChanged
92822>>>>>>>>>        Get Tokenizer sLine to CodeComponents
92823>>>>>>>>>        Move (Replace(CodeComponents.sIndentation, sLine, "")) to sLine
92824>>>>>>>>>        Send StripConcatenatingSpaces (&sLine)
92825>>>>>>>>>        Move (Lowercase(sLine)) to sText
92826>>>>>>>>>        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
92827>>>>>>>>>        Move (Overstrike("||||", sLine, iPos)) to sLine 
92828>>>>>>>>>        Move (Replace("||||", sLine, ", ")) to sLine
92829>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + 2))) to sStop
92830>>>>>>>>>        Move (Pos(" ", sStop)) to iPos
92831>>>>>>>>>        Move (Left(sStop, (iPos -1))) to sVariableName
92832>>>>>>>>>        Move (Lowercase(sLine)) to sText
92833>>>>>>>>>        Move (Pos(Lowercase(" " + CS_At + " "), sText)) to iPos
92834>>>>>>>>>        Move (Overstrike("||||", sLine, iPos)) to sLine
92835>>>>>>>>>        Move (Replace("||||", sLine, ", ")) to sLine
92836>>>>>>>>>
92836>>>>>>>>>        Move (CodeComponents.sIndentation + String(sLine) * String(sVariableName)) to sLine
92837>>>>>>>>>        Function_Return bChanged
92838>>>>>>>>>    End_Function
92839>>>>>>>>>    
92839>>>>>>>>>    // Replaces 'IN' with 'Contains
92839>>>>>>>>>    Function ChangeInToContains String ByRef sLine String sParameter Returns Boolean
92841>>>>>>>>>        Boolean bChanged bIsPosCommand bIsCommentOrBlank bFound
92841>>>>>>>>>        String sPattern sOrg
92841>>>>>>>>>        String sMatched sRemain sHost sSub sText sKeyWord sStart
92841>>>>>>>>>        tRegexMatch[] myReg           
92841>>>>>>>>>        tRegexMatch[] myReg           
92842>>>>>>>>>        Integer iPos
92842>>>>>>>>>        tCodeComponents CodeComponents
92842>>>>>>>>>        tCodeComponents CodeComponents
92842>>>>>>>>>        
92842>>>>>>>>>        Move False to bChanged
92843>>>>>>>>>        Move sLine to sText 
92844>>>>>>>>>        Move sLine to sOrg   
92845>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
92845>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
92846>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
92848>>>>>>>>>            Function_Return False
92849>>>>>>>>>        End
92849>>>>>>>>>>
92849>>>>>>>>>
92849>>>>>>>>>        Get _OverstrikeStrings sText to sText
92850>>>>>>>>>        Move (Lowercase(sText)) to sText
92851>>>>>>>>>        Move (Ltrim(sText)) to sText
92852>>>>>>>>>        // First check if there is a "In" keyword in the source code.
92852>>>>>>>>>        Move (Lowercase((" " + CS_In + " "))) to sKeyWord
92853>>>>>>>>>        If (Pos(sKeyWord, sText) = 0) Begin
92855>>>>>>>>>            Function_Return False
92856>>>>>>>>>        End
92856>>>>>>>>>>
92856>>>>>>>>>
92856>>>>>>>>>        // Check for "home cocked" commands; in case we do nothing.
92856>>>>>>>>>        Get Tokenizer sLine to CodeComponents
92857>>>>>>>>>
92857>>>>>>>>>        // If we are in a "Pos", "Insert" or "Replace" command line, we're done.
92857>>>>>>>>>        Get IsKeywordInLine (CS_Pos + "|" + CS_Insert + "|" + CS_Replace + "|") CodeComponents.sCode to bFound
92858>>>>>>>>>        If (bFound = True) Begin
92860>>>>>>>>>            Function_Return False
92861>>>>>>>>>        End
92861>>>>>>>>>>
92861>>>>>>>>>        
92861>>>>>>>>>        If (CodeComponents.sOfStatement <> "") Begin
92863>>>>>>>>>            Move (CodeComponents.sCode * CS_Of * String(CodeComponents.sOfStatement)) to sText
92864>>>>>>>>>        End
92864>>>>>>>>>>
92864>>>>>>>>>        If (CodeComponents.sToStatement <> "") Begin
92866>>>>>>>>>            Move (CodeComponents.sCode * CS_To * String(CodeComponents.sToStatement)) to sText
92867>>>>>>>>>        End
92867>>>>>>>>>>
92867>>>>>>>>>            
92867>>>>>>>>>        Get _RetrieveFirstWord sText to sStart
92868>>>>>>>>>        Move (" " + Lowercase(sStart) + " ") to sStart
92869>>>>>>>>>        Get _FindFirstCommand sStart to iPos
92870>>>>>>>>>        If (iPos = 0) Begin
92872>>>>>>>>>            Get _TestCommandFunctions sStart to iPos
92873>>>>>>>>>        End
92873>>>>>>>>>>
92873>>>>>>>>>        If (iPos = 0) Begin
92875>>>>>>>>>            Function_Return False 
92876>>>>>>>>>        End
92876>>>>>>>>>>
92876>>>>>>>>>        
92876>>>>>>>>>        Move CodeComponents.sCode to sText
92877>>>>>>>>>        Move (Replaces('`', '(".*"|`.*`|\S+)\s+in\s+(".*"|`.*`|\S+)', "'")) to sPattern
92878>>>>>>>>>        Get Regex_Match sText sPattern True to myReg
92879>>>>>>>>>        If (SizeOfArray(myReg)) Begin
92881>>>>>>>>>            Move myReg[0].Val to sMatched
92882>>>>>>>>>            Move (Replaces('`', '(".*"|`.*`|\S+)\s+', "'")) to sPattern
92883>>>>>>>>>            Get Regex_Match sMatched sPattern True to myReg
92884>>>>>>>>>            Move (Trim(myReg[0].Val)) to sSub
92885>>>>>>>>>            Move (Trim(Replace(sSub, sMatched, ''))) to sRemain // Remove the subString
92886>>>>>>>>>            Move (Remove(sRemain,0 ,2)) to sRemain // Remove the 'In'
92887>>>>>>>>>            Move (Replaces('`', '\s+(".*"|`.*`|\S+)', "'")) to sPattern
92888>>>>>>>>>            Get Regex_Match sRemain sPattern True to myReg
92889>>>>>>>>>            Move (Trim(myReg[0].Val)) to sHost
92890>>>>>>>>>
92890>>>>>>>>>            Move (Replace(sMatched, sText, ("(" + sHost + ' contains ' + sSub + ")"))) to sLine
92891>>>>>>>>>            If (Length(CodeComponents.sIndentation)) Begin
92893>>>>>>>>>                Move (CodeComponents.sIndentation + String(sLine)) to sLine
92894>>>>>>>>>            End
92894>>>>>>>>>>
92894>>>>>>>>>            If (CodeComponents.sOfStatement <> "") Begin
92896>>>>>>>>>                Move (String(sLine) * String(CS_Of) * String(CodeComponents.sOfStatement)) to sLine
92897>>>>>>>>>            End
92897>>>>>>>>>>
92897>>>>>>>>>            If (CodeComponents.sToStatement <> "") Begin
92899>>>>>>>>>                Move (String(sLine) * String(CS_To) * String(CodeComponents.sToStatement)) to sLine
92900>>>>>>>>>            End    
92900>>>>>>>>>>
92900>>>>>>>>>            If (CodeComponents.sRightComment <> "") Begin
92902>>>>>>>>>                Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine
92903>>>>>>>>>            End
92903>>>>>>>>>>
92903>>>>>>>>>        End          
92903>>>>>>>>>>
92903>>>>>>>>>                
92903>>>>>>>>>        Function_Return (sLine <> sOrg)
92904>>>>>>>>>    End_Function
92905>>>>>>>>>
92905>>>>>>>>>    // Changes "Set Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
92905>>>>>>>>>    // and     "Set Object_Shadow_State [of oObject] to True" to "Set Enabled_State [of oObject] to False"
92905>>>>>>>>>    Function ChangeLegacyShadow_State String ByRef sLine Returns Boolean
92907>>>>>>>>>        tCodeComponents LineComponents                       
92907>>>>>>>>>        tCodeComponents LineComponents                       
92907>>>>>>>>>        String sCode sState sFirstChar sText
92907>>>>>>>>>        Boolean bIsComment bIsOfOperator
92907>>>>>>>>>        Integer iPos
92907>>>>>>>>>        
92907>>>>>>>>>        Get IsCommentLineOrBlank sLine to bIsComment
92908>>>>>>>>>        If (bIsComment = True) Begin
92910>>>>>>>>>            Function_Return False
92911>>>>>>>>>        End
92911>>>>>>>>>>
92911>>>>>>>>>        
92911>>>>>>>>>        Get Tokenizer sLine to LineComponents
92912>>>>>>>>>        Move (Trim(sLine)) to sCode
92913>>>>>>>>>        Move (Lowercase(sCode)) to sCode
92914>>>>>>>>>        Move (Left(sCode, 1)) to sFirstChar 
92915>>>>>>>>>        
92915>>>>>>>>>        // There are two variants of shadow state; Shadow_State and Object_Shadow_State
92915>>>>>>>>>        Move "et shadow_state " to sText
92916>>>>>>>>>        Move (Pos(sText, sCode)) to iPos
92917>>>>>>>>>        If (iPos = 0) Begin
92919>>>>>>>>>            Move "et object_shadow_state " to sText
92920>>>>>>>>>            Move (Pos(sText, sCode)) to iPos
92921>>>>>>>>>        End   
92921>>>>>>>>>>
92921>>>>>>>>>        If (iPos = 0) Begin
92923>>>>>>>>>            Function_Return False
92924>>>>>>>>>        End
92924>>>>>>>>>>
92924>>>>>>>>>        
92924>>>>>>>>>        Move (Pos((" " + Lowercase(CS_To) + " "), sCode)) to iPos
92925>>>>>>>>>        If (iPos = 0) Begin
92927>>>>>>>>>            Function_Return False
92928>>>>>>>>>        End
92928>>>>>>>>>>
92928>>>>>>>>>    
92928>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + 3 + Length(LineComponents.sIndentation)))) to sState // Could also be a variable name (if get statement)
92929>>>>>>>>>        Move (Replace(LineComponents.sRightComment, sState, "")) to sState 
92930>>>>>>>>>        Move (" " + Trim(sState)) to sState
92931>>>>>>>>>    
92931>>>>>>>>>        // Set syntax:
92931>>>>>>>>>        If (sFirstChar = "s") Begin
92933>>>>>>>>>            If (Lowercase(sState) contains (" " + Lowercase(CS_True))) Begin
92935>>>>>>>>>                Move (" " + CS_False) to sState
92936>>>>>>>>>            End
92936>>>>>>>>>>
92936>>>>>>>>>            Else Begin   
92937>>>>>>>>>                If (Lowercase(sState) contains (" " + Lowercase(CS_False))) Begin
92939>>>>>>>>>                    Move CS_True to sState
92940>>>>>>>>>                End 
92940>>>>>>>>>>
92940>>>>>>>>>                Else Begin      
92941>>>>>>>>>                    If (Lowercase(sState) contains ("(" + Lowercase(CS_Not)) or sState contains ("( " + Lowercase(CS_Not)) or Lowercase(sState) contains (Lowercase(CS_Not + ")")) or Lowercase(sState) contains (Lowercase(CS_Not + " )"))) Begin
92943>>>>>>>>>                        Move (Replace(CS_Not, sState, "")) to sState
92944>>>>>>>>>                        Move (Replaces(")", sState, "")) to sState
92945>>>>>>>>>                        Move (Pos("(", sState)) to iPos
92946>>>>>>>>>                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
92947>>>>>>>>>                        Move (Pos("(", sState)) to iPos
92948>>>>>>>>>                        Move (Mid(sState, Length(sState), (iPos +1))) to sState
92949>>>>>>>>>                    End   
92949>>>>>>>>>>
92949>>>>>>>>>                    Else Begin
92950>>>>>>>>>                        Move ("(" + CS_Not + "(" + Trim(sState) + "))") to sState
92951>>>>>>>>>                    End
92951>>>>>>>>>>
92951>>>>>>>>>                End
92951>>>>>>>>>>
92951>>>>>>>>>                    
92951>>>>>>>>>            End
92951>>>>>>>>>>
92951>>>>>>>>>            If (Length(LineComponents.sOfStatement)) Begin
92953>>>>>>>>>                Move (CS_Set * CS_Enabled_State * CS_Of * LineComponents.sOfStatement * CS_To * String(sState)) to sCode 
92954>>>>>>>>>            End
92954>>>>>>>>>>
92954>>>>>>>>>            Else Begin
92955>>>>>>>>>                Move (CS_Set * CS_Enabled_State * CS_To * Trim(sState)) to sCode 
92956>>>>>>>>>            End
92956>>>>>>>>>>
92956>>>>>>>>>        End           
92956>>>>>>>>>>
92956>>>>>>>>>    
92956>>>>>>>>>        // Get Syntax:
92956>>>>>>>>>        Else If (sFirstChar = "g") Begin                         
92959>>>>>>>>>            Move (Lowercase(LineComponents.sToStatement)) to sText
92960>>>>>>>>>            Move (Pos(Lowercase(CS_To), sText)) to iPos
92961>>>>>>>>>            // Remove "To" keyword:
92961>>>>>>>>>            If (iPos <> 0) Begin
92963>>>>>>>>>                Move (Mid(LineComponents.sToStatement, Length(LineComponents.sToStatement), (iPos + 3))) to LineComponents.sToStatement
92964>>>>>>>>>            End
92964>>>>>>>>>>
92964>>>>>>>>>            If (Length(LineComponents.sOfStatement)) Begin
92966>>>>>>>>>                Move (CS_Get * CS_Enabled_State * LineComponents.sOfStatement * CS_To * "(" + CS_Not + "(" + LineComponents.sToStatement + "))") to sCode
92967>>>>>>>>>            End
92967>>>>>>>>>>
92967>>>>>>>>>            Else Begin
92968>>>>>>>>>                Move (CS_Get * CS_Enabled_State * CS_To * "(" + CS_Not + "(" + LineComponents.sToStatement + "))") to sCode
92969>>>>>>>>>            End
92969>>>>>>>>>>
92969>>>>>>>>>        End
92969>>>>>>>>>>
92969>>>>>>>>>        If (LineComponents.sRightComment <> "") Begin
92971>>>>>>>>>             Move (LineComponents.sIndentation + String(sCode) * String(LineComponents.sRightComment)) to sLine
92972>>>>>>>>>        End
92972>>>>>>>>>>
92972>>>>>>>>>        Else Begin
92973>>>>>>>>>            Move (LineComponents.sIndentation + String(sCode)) to sLine
92974>>>>>>>>>        End
92974>>>>>>>>>>
92974>>>>>>>>>                                
92974>>>>>>>>>        Function_Return True
92975>>>>>>>>>    End_Function
92976>>>>>>>>>
92976>>>>>>>>>    // Dummy function (Asolvi)
92976>>>>>>>>>    Function ChangewsDoTranslateTo_ String ByRef sLine Returns Boolean
92978>>>>>>>>>        Function_Return False
92979>>>>>>>>>    End_Function
92980>>>>>>>>>
92980>>>>>>>>>    // Pass only the code part of a source line.
92980>>>>>>>>>    // Replaces "gt, ge, lt, le, eq, ne" with "> >= < <= = <>" for If-Begin lines and While statements.
92980>>>>>>>>>    Function ChangeLegacyOperators String ByRef sLine String sParameter Returns Boolean
92982>>>>>>>>>        String sSource sText sLeftExpression sRightExpression sStart sCommand sFirstChar sLastChar sOrg
92982>>>>>>>>>        Boolean bFound bChanged
92982>>>>>>>>>        Integer iPos                       
92982>>>>>>>>>        tCodeComponents CodeComponents
92982>>>>>>>>>        tCodeComponents CodeComponents
92982>>>>>>>>>
92982>>>>>>>>>        Move sLine to sText     
92983>>>>>>>>>        Move sLine to sOrg
92984>>>>>>>>>        // Skip line if it is a comment or blank
92984>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
92985>>>>>>>>>        If (bFound = True) Begin
92987>>>>>>>>>            Function_Return False
92988>>>>>>>>>        End
92988>>>>>>>>>>
92988>>>>>>>>>        // Skip line if it contains a semi colon ?? Should we??
92988>>>>>>>>>        Get IsLineEndSemiColon sText to bFound
92989>>>>>>>>>        If (bFound = True) Begin
92991>>>>>>>>>            Function_Return False
92992>>>>>>>>>        End
92992>>>>>>>>>>
92992>>>>>>>>>        Get IsFirstWord sText CS_Find to bFound
92993>>>>>>>>>        If (bFound = True) Begin
92995>>>>>>>>>            Function_Return False
92996>>>>>>>>>        End                 
92996>>>>>>>>>>
92996>>>>>>>>>        Get IsFirstWord sText CS_Send to bFound
92997>>>>>>>>>        If (bFound = True) Begin
92999>>>>>>>>>            Function_Return False
93000>>>>>>>>>        End                 
93000>>>>>>>>>>
93000>>>>>>>>>        Get IsFirstWord sText CS_Constrain to bFound
93001>>>>>>>>>        If (bFound = True) Begin
93003>>>>>>>>>            Function_Return False 
93004>>>>>>>>>        End
93004>>>>>>>>>>
93004>>>>>>>>>        Get IsLegacyOperators sText to bFound
93005>>>>>>>>>        If (bFound = False) Begin
93007>>>>>>>>>            Function_Return False
93008>>>>>>>>>        End            
93008>>>>>>>>>>
93008>>>>>>>>>        Move (Lowercase(sText)) to sSource 
93009>>>>>>>>>        
93009>>>>>>>>>        Move (Pos(" gt ", sSource)) to iPos
93010>>>>>>>>>        While (iPos <> 0)
93014>>>>>>>>>            Move (Overstrike(" >_ ", sText, iPos)) to sText
93015>>>>>>>>>            Move (Replace(" >_ ", sText, " > ")) to sText
93016>>>>>>>>>            Move (Pos(" gt ", sText)) to iPos  
93017>>>>>>>>>        Loop
93018>>>>>>>>>>
93018>>>>>>>>>
93018>>>>>>>>>        Move (Pos(" ge ", sSource)) to iPos
93019>>>>>>>>>        While (iPos <> 0)
93023>>>>>>>>>            Move (Overstrike(" >= ", sText, iPos)) to sText
93024>>>>>>>>>            Move (Pos(" ge ", sText)) to iPos
93025>>>>>>>>>        Loop
93026>>>>>>>>>>
93026>>>>>>>>>
93026>>>>>>>>>        Move (Pos(" lt ", sSource)) to iPos
93027>>>>>>>>>        While (iPos <> 0)
93031>>>>>>>>>            Move (Overstrike(" <_ ", sText, iPos)) to sText
93032>>>>>>>>>            Move (Replace(" <_ ", sText, " < ")) to sText
93033>>>>>>>>>            Move (Pos(" lt ", sText)) to iPos
93034>>>>>>>>>        Loop
93035>>>>>>>>>>
93035>>>>>>>>>
93035>>>>>>>>>        Move (Pos(" le ", sSource)) to iPos
93036>>>>>>>>>        While (iPos <> 0)
93040>>>>>>>>>            Move (Overstrike(" <= ", sText, iPos)) to sText
93041>>>>>>>>>            Move (Pos(" le ", sText)) to iPos
93042>>>>>>>>>        Loop
93043>>>>>>>>>>
93043>>>>>>>>>
93043>>>>>>>>>        Move (Pos(" eq ", sSource)) to iPos
93044>>>>>>>>>        While (iPos <> 0)
93048>>>>>>>>>            Move (Overstrike(" =_ ", sText, iPos)) to sText
93049>>>>>>>>>            Move (Replace(" =_ ", sText, " = ")) to sText
93050>>>>>>>>>            Move (Pos(" eq ", sText)) to iPos
93051>>>>>>>>>        Loop
93052>>>>>>>>>>
93052>>>>>>>>>
93052>>>>>>>>>        Move (Pos(" ne ", sSource)) to iPos
93053>>>>>>>>>        While (iPos <> 0)
93057>>>>>>>>>            Move (Overstrike(" <> ", sText, iPos)) to sText
93058>>>>>>>>>            Move (Pos(" ne ", sText)) to iPos
93059>>>>>>>>>        Loop 
93060>>>>>>>>>>
93060>>>>>>>>>        
93060>>>>>>>>>        Move (String(sText) <> String(sLine)) to bChanged
93061>>>>>>>>>        If (bChanged = False) Begin
93063>>>>>>>>>            Function_Return False
93064>>>>>>>>>        End                      
93064>>>>>>>>>>
93064>>>>>>>>>        
93064>>>>>>>>>        Get Tokenizer sText to CodeComponents 
93065>>>>>>>>>        // For some reason we can get an exception error passing a struct member as
93065>>>>>>>>>        // a ByRef argument. Just moving to a local variable cures it.
93065>>>>>>>>>        Move CodeComponents.sCode to sText
93066>>>>>>>>>        Get _AddExpressionParenthesis (&sText) to bChanged
93067>>>>>>>>>        If (bChanged = True) Begin
93069>>>>>>>>>            Move sText to CodeComponents.sCode
93070>>>>>>>>>        End
93070>>>>>>>>>>
93070>>>>>>>>>                    
93070>>>>>>>>>        Move (String(CodeComponents.sIndentation + String(CodeComponents.sCode))) to sLine
93071>>>>>>>>>        If (CodeComponents.sOfStatement <> "") Begin
93073>>>>>>>>>            Move (String(sLine) * CodeComponents.sOfStatement) to sLine
93074>>>>>>>>>        End                   
93074>>>>>>>>>>
93074>>>>>>>>>        If (CodeComponents.sToStatement <> "") Begin
93076>>>>>>>>>            Move (String(sLine) * String(CS_To) * String(CodeComponents.sToStatement)) to sLine
93077>>>>>>>>>        End                                                                    
93077>>>>>>>>>>
93077>>>>>>>>>        If (CodeComponents.sRightComment <> "") Begin
93079>>>>>>>>>            Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine
93080>>>>>>>>>        End
93080>>>>>>>>>>
93080>>>>>>>>>
93080>>>>>>>>>        Function_Return (sLine <> sOrg)
93081>>>>>>>>>    End_Function 
93082>>>>>>>>>    
93082>>>>>>>>>    Function ChangeLengthCommandToFunction String ByRef sLine String sParameter Returns Boolean
93084>>>>>>>>>        Boolean bChanged
93084>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Length to bChanged
93085>>>>>>>>>        Function_Return bChanged
93086>>>>>>>>>    End_Function
93087>>>>>>>>>    
93087>>>>>>>>>    Function ChangePosCommandToFunction String ByRef sLine String sParameter Returns Boolean
93089>>>>>>>>>        Boolean bChanged
93089>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Pos to bChanged
93090>>>>>>>>>        Function_Return bChanged
93091>>>>>>>>>    End_Function
93092>>>>>>>>>    
93092>>>>>>>>>    // Changes: Replace "," In sText With "." --> Move (Replace(",",sText,".")) to sText
93092>>>>>>>>>    Function ChangeReplaceCommandToFunction String ByRef sLine String sParameter Returns Boolean
93094>>>>>>>>>        Boolean bChanged bFound
93094>>>>>>>>>        String sText sStart sStop sVariableName sOrg sFirstWord
93094>>>>>>>>>        Integer iPos 
93094>>>>>>>>>        tCodeComponents CodeComponents
93094>>>>>>>>>        tCodeComponents CodeComponents
93094>>>>>>>>>        
93094>>>>>>>>>        Move sLine to sOrg
93095>>>>>>>>>        Move sLine to sText    
93096>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
93096>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
93097>>>>>>>>>        If (bFound = True) Begin
93099>>>>>>>>>            Function_Return False
93100>>>>>>>>>        End   
93100>>>>>>>>>>
93100>>>>>>>>>        Get IsKeywordInLine (CS_Replace + "|") sLine to bFound
93101>>>>>>>>>        If (bFound = False) Begin
93103>>>>>>>>>            Function_Return False
93104>>>>>>>>>        End
93104>>>>>>>>>>
93104>>>>>>>>>        
93104>>>>>>>>>        Get Tokenizer sLine to CodeComponents
93105>>>>>>>>>        // If a "#Replace" command line, we're done.
93105>>>>>>>>>        Move (Pos(("#"+ CS_Replace), CodeComponents.sCode)) to iPos
93106>>>>>>>>>        If (iPos <> 0) Begin
93108>>>>>>>>>            Function_Return False
93109>>>>>>>>>        End
93109>>>>>>>>>>
93109>>>>>>>>>
93109>>>>>>>>>        Move CodeComponents.sCode to sLine
93110>>>>>>>>>        Send StripConcatenatingSpaces (&sLine)
93111>>>>>>>>>        Move (Lowercase(sLine)) to sText
93112>>>>>>>>>
93112>>>>>>>>>        Get _RetrieveFirstWord sText to sFirstWord
93113>>>>>>>>>        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
93115>>>>>>>>>            Get _RemoveFirstWord sLine to sLine
93116>>>>>>>>>            Get _RemoveFirstWord sText to sText
93117>>>>>>>>>        End
93117>>>>>>>>>>
93117>>>>>>>>>
93117>>>>>>>>>        Move (Pos(Lowercase(" " + CS_In + " "), sText)) to iPos
93118>>>>>>>>>        Move (Overstrike("||||", sLine, iPos)) to sLine 
93119>>>>>>>>>        Move (Mid(sLine, Length(sLine), (iPos + Length(" " + CS_In + " ")))) to sStop
93120>>>>>>>>>        Move (Pos(" ", sStop)) to iPos
93121>>>>>>>>>        Move (Left(sStop, (iPos -1))) to sVariableName
93122>>>>>>>>>        Move (Replace("||||", sLine, ", ")) to sLine
93123>>>>>>>>>        Move (Lowercase(sLine)) to sText
93124>>>>>>>>>        Move (Pos(Lowercase(" " + CS_With + " "), sText)) to iPos
93125>>>>>>>>>        Move (Overstrike("||||||", sLine, iPos)) to sLine
93126>>>>>>>>>        Move (Replace("||||||", sLine, ", ")) to sLine 
93127>>>>>>>>>        
93127>>>>>>>>>        Move (CS_Move * "(" + CS_Replace + "(" + String(sLine)) to sLine  
93128>>>>>>>>>//        Get Tokenizer sLine to CodeComponents
93128>>>>>>>>>//        Get _AddExpressionParenthesis (&sLine) to bChanged
93128>>>>>>>>>        If (Lowercase(sFirstWord) = Lowercase(CS_Replace)) Begin
93130>>>>>>>>>            Move (sLine + "))") to sLine
93131>>>>>>>>>        End
93131>>>>>>>>>>
93131>>>>>>>>>
93131>>>>>>>>>        Move (CodeComponents.sIndentation + String(sLine) * CS_To * String(sVariableName)) to sLine
93132>>>>>>>>>        If (CodeComponents.sRightComment <> "") Begin
93134>>>>>>>>>            Move (String(sLine) * String(CodeComponents.sRightComment)) to sLine         
93135>>>>>>>>>        End               
93135>>>>>>>>>>
93135>>>>>>>>>        Function_Return (sLine <> sOrg)
93136>>>>>>>>>    End_Function
93137>>>>>>>>>    
93137>>>>>>>>>    Function ChangeSysdate4 String ByRef sLine String sParameter Returns Boolean
93139>>>>>>>>>        String sText
93139>>>>>>>>>        Boolean bFound
93139>>>>>>>>>        Integer iPos
93139>>>>>>>>>        
93139>>>>>>>>>        Move (Lowercase(sLine)) to sText
93140>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
93141>>>>>>>>>        If (bFound = True) Begin
93143>>>>>>>>>            Function_Return False
93144>>>>>>>>>        End
93144>>>>>>>>>>
93144>>>>>>>>>        
93144>>>>>>>>>        // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
93144>>>>>>>>>        Get IsKeywordInLine (CS_Sysdate4 + "|") sText to bFound
93145>>>>>>>>>        If (bFound = False) Begin
93147>>>>>>>>>            Function_Return False
93148>>>>>>>>>        End                                   
93148>>>>>>>>>>
93148>>>>>>>>>        
93148>>>>>>>>>        Move (Pos(Lowercase(CS_Sysdate4), sText)) to iPos
93149>>>>>>>>>        Move (Overstrike("|", sLine, (iPos - 1 + Length(CS_Sysdate4)))) to sLine
93150>>>>>>>>>        Move (Replace("|", sLine, "")) to sLine
93151>>>>>>>>>        Function_Return True
93152>>>>>>>>>    End_Function
93153>>>>>>>>>
93153>>>>>>>>>    Function ChangeTrimCommandToFunction String ByRef sLine String sParameter Returns Boolean
93155>>>>>>>>>        Boolean bChanged
93155>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_Trim to bChanged
93156>>>>>>>>>        Function_Return bChanged
93157>>>>>>>>>    End_Function
93158>>>>>>>>>    
93158>>>>>>>>>    Function ChangeZeroStringCommandToFunction String ByRef sLine String sParameter Returns Boolean
93160>>>>>>>>>        Boolean bChanged
93160>>>>>>>>>        Get _SingleCommandSyntaxToFunction (&sLine) CS_ZeroString to bChanged
93161>>>>>>>>>        Function_Return bChanged
93162>>>>>>>>>    End_Function 
93163>>>>>>>>>    
93163>>>>>>>>>    // Changes: Until [expression] to Until (expression) and the same for the While command.
93163>>>>>>>>>    Function ChangeUntilAndWhileIndicators String ByRef sLine String sParameter Returns Boolean
93165>>>>>>>>>        String sText sCommand sNot
93165>>>>>>>>>        Boolean bFound
93165>>>>>>>>>        Integer iPos
93165>>>>>>>>>        tCodeComponents LineComponents 
93165>>>>>>>>>        tCodeComponents LineComponents 
93165>>>>>>>>>        tBooleanIndicator BooleanIndicator
93165>>>>>>>>>        tBooleanIndicator BooleanIndicator
93165>>>>>>>>>        
93165>>>>>>>>>        Move sLine to sText
93166>>>>>>>>>        // Skip line if it is a comment or blank
93166>>>>>>>>>        Get IsCommentLineOrBlank sText to bFound
93167>>>>>>>>>        If (bFound = True) Begin
93169>>>>>>>>>            Function_Return False
93170>>>>>>>>>        End             
93170>>>>>>>>>>
93170>>>>>>>>>        // Skip line if it contains a semi colon
93170>>>>>>>>>        Get IsLineEndSemiColon sText to bFound
93171>>>>>>>>>        If (bFound = True) Begin
93173>>>>>>>>>            Function_Return False
93174>>>>>>>>>        End
93174>>>>>>>>>>
93174>>>>>>>>>        
93174>>>>>>>>>        Get IsWhileStatement sText to bFound
93175>>>>>>>>>        If (bFound = False) Begin
93177>>>>>>>>>            Get IsUntilStatement sText to bFound
93178>>>>>>>>>            If (bFound = False) Begin
93180>>>>>>>>>                Function_Return False
93181>>>>>>>>>            End
93181>>>>>>>>>>
93181>>>>>>>>>        End
93181>>>>>>>>>>
93181>>>>>>>>>        Get Tokenizer sLine to LineComponents
93182>>>>>>>>>        Get _ExtractIndicatorContent LineComponents.sCode to BooleanIndicator
93183>>>>>>>>>        If (BooleanIndicator.bHasBracket = False) Begin
93185>>>>>>>>>            Function_Return False
93186>>>>>>>>>        End
93186>>>>>>>>>>
93186>>>>>>>>>
93186>>>>>>>>>        Move (LineComponents.sIndentation + String(BooleanIndicator.sCode) * String(BooleanIndicator.sExpression) + LineComponents.sRightComment) to sLine
93187>>>>>>>>>
93187>>>>>>>>>        Function_Return True
93188>>>>>>>>>    End_Function
93189>>>>>>>>>    
93189>>>>>>>>>    // Rewrites Get Create U_Class to Get Create (RefClass(Class))
93189>>>>>>>>>    Function ChangeUClassToRefClass String ByRef sLine String sParameter Returns Boolean
93191>>>>>>>>>        Boolean bChanged bValid bIgnore
93191>>>>>>>>>        String sTest sClassName sOldStyle sNewStyle
93191>>>>>>>>>        Integer iPos
93191>>>>>>>>>
93191>>>>>>>>>        Move False to bChanged
93192>>>>>>>>>        Move "" to sClassName
93193>>>>>>>>>        Move (Lowercase(sLine)) to sTest
93194>>>>>>>>>        Move (Replaces(Character(9), sTest, " ")) to sTest // tab
93195>>>>>>>>>        Send StripConcatenatingSpaces (&sTest)
93196>>>>>>>>>        // Two lines which are mostly for protection when running DfRefactor on the DfRefactor code itself
93196>>>>>>>>>        Get _RemoveComments (&sTest)     to bIgnore // Don't rewrite this in a comment
93197>>>>>>>>>        Get _RemoveStringsFromLine sTest to sTest   // If this is in a string then obviously leave it alone too
93198>>>>>>>>>        If (Pos(" create u_", sTest)) Begin
93200>>>>>>>>>            Move (Lowercase(sLine)) to sTest
93201>>>>>>>>>            Move (Pos("u_", sTest)) to iPos
93202>>>>>>>>>            Get IsValidClassCharacter sTest iPos to bValid
93203>>>>>>>>>            While (bValid)
93207>>>>>>>>>                Move (sClassName + Mid(sLine, 1, iPos)) to sClassName
93208>>>>>>>>>                Increment iPos
93209>>>>>>>>>                Get IsValidClassCharacter sTest iPos to bValid
93210>>>>>>>>>            Loop
93211>>>>>>>>>>
93211>>>>>>>>>        End
93211>>>>>>>>>>
93211>>>>>>>>>        If (sClassName <> "") Begin
93213>>>>>>>>>            Move True to bChanged
93214>>>>>>>>>            Move sClassName to sOldStyle
93215>>>>>>>>>            Move (Right(sClassName, Length(sClassName) - 2)) to sClassName // strip away the "U_"
93216>>>>>>>>>            Move ("(RefClass(" + sClassName + "))") to sNewStyle
93217>>>>>>>>>            Move (Replace(sOldStyle, sLine, sNewStyle)) to sLine
93218>>>>>>>>>        End
93218>>>>>>>>>>
93218>>>>>>>>>        Function_Return bChanged
93219>>>>>>>>>    End_Function
93220>>>>>>>>>    
93220>>>>>>>>>    // Replaces "Calc/MoveInt/MoveNum/MoveReal/MoveStr" statements to "Move" if present.
93220>>>>>>>>>    Function ReplaceCalcWithMoveStatement String ByRef sLine String sParameter Returns Boolean
93222>>>>>>>>>        Boolean bChanged bIsIn bIsCommentOrBlank
93222>>>>>>>>>        String sTest sStart sStop
93222>>>>>>>>>        Integer iPos                             
93222>>>>>>>>>
93222>>>>>>>>>        Move False to bChanged
93223>>>>>>>>>        Move sLine to sTest
93224>>>>>>>>>
93224>>>>>>>>>        // Check if this is a comment line, in case we do nothing.
93224>>>>>>>>>        Get IsCommentLineOrBlank sTest to bIsCommentOrBlank
93225>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
93227>>>>>>>>>            Function_Return False
93228>>>>>>>>>        End
93228>>>>>>>>>>
93228>>>>>>>>>
93228>>>>>>>>>        Move (Lowercase(sLine)) to sTest
93229>>>>>>>>>        Get _OverstrikeStrings sTest to sTest
93230>>>>>>>>>        // Replaces all quotes string contents to "_" so we don't get false positives.
93230>>>>>>>>>
93230>>>>>>>>>        // Check if line contains one of the keywords and that none of the keywords are within quotes.
93230>>>>>>>>>        Get IsKeywordInLine "calc|moveint|movenum|movereal|movestr|" sTest to bIsIn
93231>>>>>>>>>        If (bIsIn = False) Begin
93233>>>>>>>>>            Function_Return False
93234>>>>>>>>>        End
93234>>>>>>>>>>
93234>>>>>>>>>        
93234>>>>>>>>>        Case Begin
93234>>>>>>>>>            Case (Pos("calc ", sTest))
93236>>>>>>>>>                Move (Pos("calc ", sTest))         to iPos
93237>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
93238>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 4))) to sStop
93239>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
93240>>>>>>>>>                Move True                          to bChanged
93241>>>>>>>>>                Case Break
93242>>>>>>>>>
93242>>>>>>>>>            Case (Pos("moveint ", sTest))
93245>>>>>>>>>                Move (Pos("moveint ", sTest))      to iPos
93246>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
93247>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
93248>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
93249>>>>>>>>>                Move True                          to bChanged
93250>>>>>>>>>                Case Break
93251>>>>>>>>>
93251>>>>>>>>>            Case (Pos("movenum ", sTest))
93254>>>>>>>>>                Move (Pos("movenum ", sTest))      to iPos
93255>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
93256>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
93257>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
93258>>>>>>>>>                Move True                          to bChanged
93259>>>>>>>>>                Case Break
93260>>>>>>>>>
93260>>>>>>>>>            Case (Pos("movereal ", sTest))
93263>>>>>>>>>                Move (Pos("movereal ", sTest))     to iPos
93264>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
93265>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 8))) to sStop
93266>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
93267>>>>>>>>>                Move True                          to bChanged
93268>>>>>>>>>                Case Break
93269>>>>>>>>>
93269>>>>>>>>>            Case (Pos("movestr ", sTest))
93272>>>>>>>>>                Move (Pos("movestr ", sTest))      to iPos
93273>>>>>>>>>                Move (Left(sLine, (iPos -1)))      to sStart
93274>>>>>>>>>                Move (Mid(sLine, CI_EOL, (iPos + 7))) to sStop
93275>>>>>>>>>                Move (sStart + "Move" + sStop)     to sLine
93276>>>>>>>>>                Move True                          to bChanged
93277>>>>>>>>>                Case Break
93278>>>>>>>>>        Case End
93278>>>>>>>>>
93278>>>>>>>>>        Function_Return bChanged
93279>>>>>>>>>    End_Function
93280>>>>>>>>>
93280>>>>>>>>>    // Removes local statement if present.
93280>>>>>>>>>    Function RemoveLocalKeyWord String ByRef sLine String sParameter Returns Boolean
93282>>>>>>>>>        Boolean bChanged bFound
93282>>>>>>>>>        String sTest
93282>>>>>>>>>        Integer iPos
93282>>>>>>>>>
93282>>>>>>>>>        Move sLine to sTest
93283>>>>>>>>>        Get IsCommentLineOrBlank sTest to bFound
93284>>>>>>>>>        If (bFound = True) Begin
93286>>>>>>>>>            Function_Return False
93287>>>>>>>>>        End
93287>>>>>>>>>>
93287>>>>>>>>>        Move False to bChanged
93288>>>>>>>>>        Move (LTrim(sLine)) to sTest
93289>>>>>>>>>        Move (Left(sTest, 6)) to sTest
93290>>>>>>>>>        Move (Lowercase(sTest)) to sTest
93291>>>>>>>>>        If (sTest = (Lowercase(CS_Local) + " ")) Begin
93293>>>>>>>>>            // local must be the first word in the line.
93293>>>>>>>>>            // Now find the local statement in the line and remove it.
93293>>>>>>>>>            Move (Lowercase(sLine)) to sTest
93294>>>>>>>>>            Move (Pos((Lowercase(CS_Local) + " "), sTest)) to iPos
93295>>>>>>>>>            If (iPos > 0) Begin
93297>>>>>>>>>                Move (Remove(sLine, iPos, 6)) to sLine
93298>>>>>>>>>                Move True to bChanged
93299>>>>>>>>>            End
93299>>>>>>>>>>
93299>>>>>>>>>        End
93299>>>>>>>>>>
93299>>>>>>>>>        Function_Return bChanged
93300>>>>>>>>>    End_Function
93301>>>>>>>>>
93301>>>>>>>>>// This would compile but not work well with the ReplaceCalcWithMoveStatement function.
93301>>>>>>>>>// Reported by: JJ
93301>>>>>>>>>//    Procedure Testing
93301>>>>>>>>>//        // Before refactor
93301>>>>>>>>>//        String moveStr
93301>>>>>>>>>//        String s
93301>>>>>>>>>//        Move moveStr to s
93301>>>>>>>>>//       
93301>>>>>>>>>//        // After refactor
93301>>>>>>>>>//        String moveStr
93301>>>>>>>>>//        String s
93301>>>>>>>>>//        Move Move to s
93301>>>>>>>>>//    End_Procedure    
93301>>>>>>>>>
93301>>>>>>>>>    Function RemovePropertyPrivate String ByRef sLine String sParameter Returns Boolean
93303>>>>>>>>>        Boolean bChanged
93303>>>>>>>>>        Get _RemovePropertyPublicPrivate (&sLine) "private" to bChanged
93304>>>>>>>>>        Function_Return bChanged
93305>>>>>>>>>    End_Function
93306>>>>>>>>>    
93306>>>>>>>>>    Function RemovePropertyPublic String ByRef sLine String sParameter Returns Boolean
93308>>>>>>>>>        Boolean bChanged
93308>>>>>>>>>        Get _RemovePropertyPublicPrivate (&sLine) "public" to bChanged
93309>>>>>>>>>        Function_Return bChanged
93310>>>>>>>>>    End_Function
93311>>>>>>>>>
93311>>>>>>>>>    // Removes end of line comments for: End_Class, End_Object, End_Function & End_Procedure
93311>>>>>>>>>    Function RemoveEndComments String ByRef sLine String sParameter Returns Boolean
93313>>>>>>>>>        Boolean bChanged bFound
93313>>>>>>>>>        String  sTestLine sTest
93313>>>>>>>>>
93313>>>>>>>>>        Move False to bChanged
93314>>>>>>>>>        Move (LTrim(sLine)) to sTestLine
93315>>>>>>>>>        Move (Lowercase(sTestLine)) to sTestLine
93316>>>>>>>>>        Get IsCommentLineOrBlank sTestLine to bFound
93317>>>>>>>>>        If (bFound = True) Begin
93319>>>>>>>>>            Function_Return False
93320>>>>>>>>>        End
93320>>>>>>>>>>
93320>>>>>>>>>        
93320>>>>>>>>>        Move False to bFound
93321>>>>>>>>>        // We check both for a space between the key word and the comment _and_
93321>>>>>>>>>        // comments placed directly after the key word _without_ a space between, aka "end_object//this is a comment"
93321>>>>>>>>>        //
93321>>>>>>>>>        // end_class:
93321>>>>>>>>>        Move (Left(sTestLine, 10)) to sTest
93322>>>>>>>>>        Move (sTest = "end_class ") to bFound
93323>>>>>>>>>        If (bFound = False) Begin
93325>>>>>>>>>            Move (Left(sTestLine, 11)) to sTest
93326>>>>>>>>>            Move (sTest = ("end_class" + CS_CommentSymbol)) to bFound
93327>>>>>>>>>        End
93327>>>>>>>>>>
93327>>>>>>>>>        If (bFound = True) Begin
93329>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
93330>>>>>>>>>            Function_Return bChanged
93331>>>>>>>>>        End
93331>>>>>>>>>>
93331>>>>>>>>>
93331>>>>>>>>>        // end_object:
93331>>>>>>>>>        Move (Left(sTestLine, 11)) to sTest
93332>>>>>>>>>        Move (sTest = "end_object ") to bFound
93333>>>>>>>>>        If (bFound = False) Begin
93335>>>>>>>>>            Move (Left(sTestLine, 12)) to sTest
93336>>>>>>>>>            Move (sTest = ("end_object" + CS_CommentSymbol)) to bFound
93337>>>>>>>>>        End
93337>>>>>>>>>>
93337>>>>>>>>>        If (bFound = True) Begin
93339>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
93340>>>>>>>>>            Function_Return bChanged
93341>>>>>>>>>        End
93341>>>>>>>>>>
93341>>>>>>>>>
93341>>>>>>>>>        // end_function:
93341>>>>>>>>>        Move (Left(sTestLine, 13)) to sTest
93342>>>>>>>>>        Move (sTest = "end_function ") to bFound
93343>>>>>>>>>        If (bFound = False) Begin
93345>>>>>>>>>            Move (Left(sTestLine, 14)) to sTest
93346>>>>>>>>>            Move (sTest = ("end_function" + CS_CommentSymbol)) to bFound
93347>>>>>>>>>        End
93347>>>>>>>>>>
93347>>>>>>>>>        If (bFound = True) Begin
93349>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
93350>>>>>>>>>            Function_Return bChanged
93351>>>>>>>>>        End
93351>>>>>>>>>>
93351>>>>>>>>>        
93351>>>>>>>>>        // end_procedure:
93351>>>>>>>>>        Move (Left(sTestLine, 14)) to sTest
93352>>>>>>>>>        Move (sTest = "end_procedure ") to bFound
93353>>>>>>>>>        If (bFound = False) Begin
93355>>>>>>>>>            Move (Left(sTestLine, 15)) to sTest
93356>>>>>>>>>            Move (sTest = ("end_procedure" + CS_CommentSymbol)) to bFound
93357>>>>>>>>>        End
93357>>>>>>>>>>
93357>>>>>>>>>        If (bFound = True) Begin
93359>>>>>>>>>            Get _RemoveComments (&sLine) to bChanged
93360>>>>>>>>>        End
93360>>>>>>>>>>
93360>>>>>>>>>
93360>>>>>>>>>        Function_Return bChanged
93361>>>>>>>>>    End_Function
93362>>>>>>>>>    
93362>>>>>>>>>    // Returns True if a legacy IDE (Studio) source code marker is found. 
93362>>>>>>>>>    // This is a "Remove Type Function".
93362>>>>>>>>>    Function RemoveOldStudioMarkers String sLine Returns Boolean
93364>>>>>>>>>        Boolean bFound
93364>>>>>>>>>
93364>>>>>>>>>        Move False to bFound
93365>>>>>>>>>        Move (Trim(sLine)) to sLine
93366>>>>>>>>>
93366>>>>>>>>>        Case Begin
93366>>>>>>>>>            Case (sLine = "//AB-IgnoreStart")
93368>>>>>>>>>                Move True to bFound
93369>>>>>>>>>                Case Break
93370>>>>>>>>>
93370>>>>>>>>>            Case (sLine = "//AB-IgnoreEnd")
93373>>>>>>>>>                Move True to bFound
93374>>>>>>>>>                Case Break
93375>>>>>>>>>
93375>>>>>>>>>            Case (sLine = "//AB-StoreStart")
93378>>>>>>>>>                Move True to bFound
93379>>>>>>>>>                Case Break
93380>>>>>>>>>
93380>>>>>>>>>            Case (sLine = "//AB-StoreEnd")
93383>>>>>>>>>                Move True to bFound
93384>>>>>>>>>                Case Break
93385>>>>>>>>>
93385>>>>>>>>>            Case (sLine = "//AB-StoreTopStart")
93388>>>>>>>>>                Move True to bFound
93389>>>>>>>>>                Case Break
93390>>>>>>>>>
93390>>>>>>>>>            Case (sLine = "//AB-StoreTopEnd")
93393>>>>>>>>>                Move True to bFound
93394>>>>>>>>>                Case Break
93395>>>>>>>>>
93395>>>>>>>>>            Case (sLine = "//AB-PanelStoreTopStart")
93398>>>>>>>>>                Move True to bFound
93399>>>>>>>>>                Case Break
93400>>>>>>>>>
93400>>>>>>>>>            Case (sLine = "//AB-PanelStoreTopEnd")
93403>>>>>>>>>                Move True to bFound
93404>>>>>>>>>                Case Break
93405>>>>>>>>>
93405>>>>>>>>>            Case (sLine = "//AB-PanelStoreStart")
93408>>>>>>>>>                Move True to bFound
93409>>>>>>>>>                Case Break
93410>>>>>>>>>
93410>>>>>>>>>            Case (sLine = "//AB-PanelStoreEnd")
93413>>>>>>>>>                Move True to bFound
93414>>>>>>>>>                Case Break
93415>>>>>>>>>
93415>>>>>>>>>            Case (sLine = "//AB-ClientStoreTopStart")
93418>>>>>>>>>                Move True to bFound
93419>>>>>>>>>                Case Break
93420>>>>>>>>>
93420>>>>>>>>>            Case (sLine = "//AB-ClientStoreTopEnd")
93423>>>>>>>>>                Move True to bFound
93424>>>>>>>>>                Case Break
93425>>>>>>>>>
93425>>>>>>>>>            Case (sLine = "//AB-ClientStoreStart")
93428>>>>>>>>>                Move True to bFound
93429>>>>>>>>>                Case Break
93430>>>>>>>>>
93430>>>>>>>>>            Case (sLine = "//AB-ClientStoreEnd")
93433>>>>>>>>>                Move True to bFound
93434>>>>>>>>>                Case Break
93435>>>>>>>>>
93435>>>>>>>>>            Case (sLine = "//AB-DDOStart")
93438>>>>>>>>>                Move True to bFound
93439>>>>>>>>>                Case Break
93440>>>>>>>>>
93440>>>>>>>>>            Case (sLine = "//AB-DDOEnd")
93443>>>>>>>>>                Move True to bFound
93444>>>>>>>>>                Case Break
93445>>>>>>>>>
93445>>>>>>>>>            Case (Left(sLine, 6) = "//AB/ ")
93448>>>>>>>>>                Move True to bFound
93449>>>>>>>>>                Case Break
93450>>>>>>>>>
93450>>>>>>>>>            Case (sLine = "//AB-MenuPackage")
93453>>>>>>>>>                Move True to bFound
93454>>>>>>>>>                Case Break
93455>>>>>>>>>
93455>>>>>>>>>            Case (sLine = "//AB-End")
93458>>>>>>>>>                Move True to bFound
93459>>>>>>>>>                Case Break
93460>>>>>>>>>
93460>>>>>>>>>            Case (sLine = "//AB-ToolbarPackage")
93463>>>>>>>>>                Move True to bFound
93464>>>>>>>>>                Case Break
93465>>>>>>>>>
93465>>>>>>>>>            Case (sLine = "//AB-ViewStart")
93468>>>>>>>>>                Move True to bFound
93469>>>>>>>>>                Case Break
93470>>>>>>>>>
93470>>>>>>>>>            Case (sLine = "//AB-ViewEnd")
93473>>>>>>>>>                Move True to bFound
93474>>>>>>>>>                Case Break
93475>>>>>>>>>
93475>>>>>>>>>            Case (sLine = "//AB-StatusBarPackage")
93478>>>>>>>>>                Move True to bFound
93479>>>>>>>>>                Case Break
93480>>>>>>>>>
93480>>>>>>>>>            Case (sLine = "//IDE-FileType=ftApplication")
93483>>>>>>>>>                Move True to bFound
93484>>>>>>>>>                Case Break
93485>>>>>>>>>
93485>>>>>>>>>        Case End
93485>>>>>>>>>
93485>>>>>>>>>        Function_Return bFound
93486>>>>>>>>>    End_Function
93487>>>>>>>>>
93487>>>>>>>>>    // To remove hardcoded MS Sans Serif fonts if present.
93487>>>>>>>>>    Function RemoveSansSerif String sLine Returns Boolean
93489>>>>>>>>>        String sTest
93489>>>>>>>>>        Boolean bWriteLine
93489>>>>>>>>>
93489>>>>>>>>>        Move False to bWriteLine
93490>>>>>>>>>        Move (Trim(sLine)) to sTest
93491>>>>>>>>>        Move (Lowercase(sTest)) to sTest
93492>>>>>>>>>        Move (Replaces(" ", sTest, ""))  to sTest
93493>>>>>>>>>        Move (Replaces("'", sTest, "*")) to sTest
93494>>>>>>>>>        Move (Replaces('"', sTest, "*")) to sTest
93495>>>>>>>>>        If (sTest contains 'settypefaceto*mssansserif*') Begin
93497>>>>>>>>>            Move True to bWriteLine
93498>>>>>>>>>        End
93498>>>>>>>>>>
93498>>>>>>>>>        Function_Return bWriteLine
93499>>>>>>>>>    End_Function
93500>>>>>>>>>
93500>>>>>>>>>    // Removes Studio generated comments:
93500>>>>>>>>>    //               "// fires when the button is clicked"
93500>>>>>>>>>    //               "//OnChange is called on every changed character
93500>>>>>>>>>    //               "// Visual DataFlex 14.0 Client Size Adjuster     
93500>>>>>>>>>    //               "// Visual DataFlex 14.0 Migration Utility,"
93500>>>>>>>>>    //               ...and so on 
93500>>>>>>>>>    Function RemoveStudioGeneratedComments String ByRef sLine Returns Boolean
93502>>>>>>>>>        String sText sComment
93502>>>>>>>>>        Boolean bFound bChanged
93502>>>>>>>>>        
93502>>>>>>>>>        Move False to bChanged
93503>>>>>>>>>        Move sLine to sText
93504>>>>>>>>>        Get IsCommentLine sText to bFound
93505>>>>>>>>>        If (bFound = False) Begin
93507>>>>>>>>>            Function_Return False
93508>>>>>>>>>        End                      
93508>>>>>>>>>>
93508>>>>>>>>>        
93508>>>>>>>>>        Move "fires when the button is clicked" to sComment   
93509>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93510>>>>>>>>>        If (bFound = True) Begin
93512>>>>>>>>>            Move "" to sLine  
93513>>>>>>>>>            Function_Return True
93514>>>>>>>>>        End
93514>>>>>>>>>>
93514>>>>>>>>>
93514>>>>>>>>>        Move "onchange is called on every changed character" to sComment
93515>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93516>>>>>>>>>        If (bFound = True) Begin
93518>>>>>>>>>            Move "" to sLine  
93519>>>>>>>>>            Function_Return True
93520>>>>>>>>>        End
93520>>>>>>>>>>
93520>>>>>>>>>        
93520>>>>>>>>>        Move "visual dataflex 14.0 client size adjuster" to sComment
93521>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93522>>>>>>>>>        If (bFound = True) Begin
93524>>>>>>>>>            Move "" to sLine  
93525>>>>>>>>>            Function_Return True
93526>>>>>>>>>        End             
93526>>>>>>>>>>
93526>>>>>>>>>        
93526>>>>>>>>>        Move "visual dataflex 14.0 migration utility," to sComment
93527>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93528>>>>>>>>>        If (bFound = True) Begin
93530>>>>>>>>>            Move "" to sLine  
93531>>>>>>>>>            Function_Return True
93532>>>>>>>>>        End             
93532>>>>>>>>>>
93532>>>>>>>>>        
93532>>>>>>>>>        Move "If you set Current_radio you must set this after the" to sComment
93533>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93534>>>>>>>>>        If (bFound = True) Begin
93536>>>>>>>>>            Move "" to sLine  
93537>>>>>>>>>            Function_Return True
93538>>>>>>>>>        End
93538>>>>>>>>>>
93538>>>>>>>>>        
93538>>>>>>>>>        Move "radio objects have been created AND after Notify_select_State has been" to sComment
93539>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93540>>>>>>>>>        If (bFound = True) Begin
93542>>>>>>>>>            Move "" to sLine  
93543>>>>>>>>>            Function_Return True
93544>>>>>>>>>        End
93544>>>>>>>>>>
93544>>>>>>>>>
93544>>>>>>>>>        Move "created. i.e. Set in bottom-code at end!!" to sComment
93545>>>>>>>>>        Get IsStudioGeneratedComment sLine sComment to bFound
93546>>>>>>>>>        If (bFound = True) Begin
93548>>>>>>>>>            Move "" to sLine  
93549>>>>>>>>>            Function_Return True
93550>>>>>>>>>        End
93550>>>>>>>>>>
93550>>>>>>>>>        
93550>>>>>>>>>        Function_Return bChanged
93551>>>>>>>>>    End_Function
93552>>>>>>>>>    
93552>>>>>>>>>    // Remove trailing spaces if present.
93552>>>>>>>>>    Function RemoveTrailingSpaces String ByRef sLine Returns Boolean
93554>>>>>>>>>        Integer iBefore iAfter
93554>>>>>>>>>        Boolean bChanged
93554>>>>>>>>>
93554>>>>>>>>>        Move (Length(sLine))     to iBefore
93555>>>>>>>>>        Move (RTrim(sLine))      to sLine
93556>>>>>>>>>        Move (Length(sLine))     to iAfter
93557>>>>>>>>>        Move (iBefore <> iAfter) to bChanged
93558>>>>>>>>>
93558>>>>>>>>>        Function_Return bChanged
93559>>>>>>>>>    End_Function  
93560>>>>>>>>>    
93560>>>>>>>>>    Procedure ResetProjectObjectStructureProperties
93562>>>>>>>>>        String[] asObjectNames
93563>>>>>>>>>        Set pbProjectObjectStructureStart to False 
93564>>>>>>>>>        Set pbProjectObjectStructureEnd   to False
93565>>>>>>>>>        Set pbRegisterAllObjectsStart     to False    
93566>>>>>>>>>        Set pbRegisterAllObjectsEnd       to False
93567>>>>>>>>>        Set pasObjectNames                to asObjectNames
93568>>>>>>>>>    End_Procedure
93569>>>>>>>>>
93569>>>>>>>>>    Function RemoveProjectObjectStructure String ByRef sLine String sParameter Returns Boolean
93571>>>>>>>>>        Boolean bWriteLine bRegisterAllObjectsStart bRegisterAllObjectsEnd
93571>>>>>>>>>        Boolean bProjectObjectStructureStart bProjectObjectStructureEnd
93571>>>>>>>>>        Move False to bWriteLine
93572>>>>>>>>>        String[] asObjectNames
93573>>>>>>>>>        
93573>>>>>>>>>        Get pbRegisterAllObjectsStart     to bRegisterAllObjectsStart
93574>>>>>>>>>        Get pbRegisterAllObjectsEnd       to bRegisterAllObjectsEnd   
93575>>>>>>>>>        Get pbProjectObjectStructureStart to bProjectObjectStructureStart
93576>>>>>>>>>        Get pbProjectObjectStructureEnd   to bProjectObjectStructureEnd
93577>>>>>>>>>        Get pasObjectNames                to asObjectNames
93578>>>>>>>>>        
93578>>>>>>>>>        If (bRegisterAllObjectsEnd = False) Begin
93580>>>>>>>>>            If (bRegisterAllObjectsStart = False) Begin
93582>>>>>>>>>                Get IsRegisterAllObjectsStart sLine to bRegisterAllObjectsStart
93583>>>>>>>>>                Set pbRegisterAllObjectsStart       to bRegisterAllObjectsStart
93584>>>>>>>>>            End
93584>>>>>>>>>>
93584>>>>>>>>>            If (bRegisterAllObjectsStart = True) Begin
93586>>>>>>>>>                Get IsRegisterObjectInArray sLine asObjectNames to bWriteLine
93587>>>>>>>>>                Move False to bProjectObjectStructureStart
93588>>>>>>>>>                Set           pbProjectObjectStructureStart to False
93589>>>>>>>>>            End
93589>>>>>>>>>>
93589>>>>>>>>>            If (bRegisterAllObjectsStart = False and bProjectObjectStructureEnd = False and bProjectObjectStructureStart = False) Begin
93591>>>>>>>>>                Get IsProjectObjectStructureStart sLine to bProjectObjectStructureStart
93592>>>>>>>>>                Set pbProjectObjectStructureStart       to bProjectObjectStructureStart
93593>>>>>>>>>            End
93593>>>>>>>>>>
93593>>>>>>>>>            If (bProjectObjectStructureStart = True) Begin
93595>>>>>>>>>                Get IsProjectObjectStructureLine sLine (&asObjectNames) to bWriteLine
93596>>>>>>>>>            End
93596>>>>>>>>>>
93596>>>>>>>>>            Get IsRegisterAllObjectsEnd sLine to bRegisterAllObjectsEnd
93597>>>>>>>>>            If (bRegisterAllObjectsEnd = True) Begin
93599>>>>>>>>>                Send ResetProjectObjectStructureProperties
93600>>>>>>>>>                // This means that we won't bother with the rest of the file.
93600>>>>>>>>>                Set pbRegisterAllObjectsEnd to True
93601>>>>>>>>>            End                                           
93601>>>>>>>>>>
93601>>>>>>>>>        End
93601>>>>>>>>>>
93601>>>>>>>>>        Function_Return bWriteLine
93602>>>>>>>>>    End_Function
93603>>>>>>>>>    
93603>>>>>>>>>    // The former passed parameters; eSplitBy and iTabSize has been made into
93603>>>>>>>>>    // class properties. That way we can have a uniform calling interface to all functions.
93603>>>>>>>>>    // The two user selected values can be found in Sysfile.
93603>>>>>>>>>    Function SplitInlineIfElseLine String ByRef sLine String sParameter Returns Boolean
93605>>>>>>>>>        Boolean bStop bChanged
93605>>>>>>>>>        Integer iIndent eSplitBy iTabSize iID
93605>>>>>>>>>        String  sText
93605>>>>>>>>>        
93605>>>>>>>>>        // We need to get a second parameter; the tab-size:
93605>>>>>>>>>        Move FunctionsA.ID to iID
93606>>>>>>>>>        Clear FunctionsA
93607>>>>>>>>>        Move CS_EditorReIndent to FunctionsA.Function_Name
93608>>>>>>>>>        Find eq FunctionsA by Index.5
93609>>>>>>>>>>
93609>>>>>>>>>        If (Found = False) Begin
93611>>>>>>>>>            Send UserError ("Could not find function:" * CS_EditorReIndent)
93612>>>>>>>>>            Function_Return False
93613>>>>>>>>>        End                      
93613>>>>>>>>>>
93613>>>>>>>>>        Else Begin
93614>>>>>>>>>            Move (Trim(FunctionsA.Parameter)) to iTabSize
93615>>>>>>>>>            // Reset record buffert:
93615>>>>>>>>>            Move iID to FunctionsA.ID
93616>>>>>>>>>            Find Eq FunctionsA by Index.1
93617>>>>>>>>>>
93617>>>>>>>>>        End
93617>>>>>>>>>>
93617>>>>>>>>>        
93617>>>>>>>>>        Move False to bChanged
93618>>>>>>>>>        Move sParameter to eSplitBy
93619>>>>>>>>>        
93619>>>>>>>>>        Move (LTrim(sLine))     to sText
93620>>>>>>>>>        Move (Pos(sText,sLine) - 1) to iIndent
93621>>>>>>>>>        Move (Left(sText, 3))   to sText
93622>>>>>>>>>        Move (Lowercase(sText)) to sText
93623>>>>>>>>>        If (sText = (Lowercase(CS_If) + " ")) Begin
93625>>>>>>>>>            Get IsLineEndSemiColonOrBegin sLine to bStop
93626>>>>>>>>>            If (bStop = False) Begin
93628>>>>>>>>>                // It's one of those single line if statements, break it up
93628>>>>>>>>>                Move (Lowercase(sLine)) to sText
93629>>>>>>>>>                Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
93630>>>>>>>>>            End
93630>>>>>>>>>>
93630>>>>>>>>>        End
93630>>>>>>>>>>
93630>>>>>>>>>        Else Begin
93631>>>>>>>>>            Move (LTrim(sLine))     to sText
93632>>>>>>>>>            Move (Left(sText, 5))   to sText
93633>>>>>>>>>            Move (Lowercase(sText)) to sText
93634>>>>>>>>>            If (sText = (Lowercase(CS_Else) + " ")) Begin
93636>>>>>>>>>                Get IsLineEndSemiColonOrBegin sLine to bStop
93637>>>>>>>>>                If (bStop = False) Begin
93639>>>>>>>>>                    Get _BreakupCompoundStatement iIndent (&sLine) eSplitBy iTabSize to bChanged
93640>>>>>>>>>                End
93640>>>>>>>>>>
93640>>>>>>>>>            End
93640>>>>>>>>>>
93640>>>>>>>>>        End
93640>>>>>>>>>>
93640>>>>>>>>>        Function_Return bChanged
93641>>>>>>>>>    End_Function
93642>>>>>>>>>
93642>>>>>>>>>    // ToDo: *** FULL SOURCE FILE FUNCTIONS ***
93642>>>>>>>>>    //
93642>>>>>>>>>    // Counts total number of source lines for the passed file name.
93642>>>>>>>>>    // It does _not_ count empty or comment lines. 
93642>>>>>>>>>    // it does _not_ count COM proxy class files generated by the Studio for COM/ActiveX components.
93642>>>>>>>>>    Function CountNumberOfLines String sFullSourceFileName String sParameter Returns Integer
93644>>>>>>>>>        Integer iLines iChannel 
93644>>>>>>>>>        String sLine     
93644>>>>>>>>>        Boolean bExists bBlank bIsCOM
93644>>>>>>>>>        
93644>>>>>>>>>        File_Exist sFullSourceFileName bExists
93645>>>>>>>>>        If (bExists = False) Begin
93647>>>>>>>>>            Send UserError ("Couldn't find file:" * String(sFullSourceFileName) * "No source lines added to counter for this file.")
93648>>>>>>>>>            Function_Return 0
93649>>>>>>>>>        End                  
93649>>>>>>>>>>
93649>>>>>>>>>
93649>>>>>>>>>        Get IsDataFlexCOMProxyClassesFile sFullSourceFileName to bIsCOM
93650>>>>>>>>>        If (bIsCOM = True) Begin
93652>>>>>>>>>            Function_Return 0
93653>>>>>>>>>        End
93653>>>>>>>>>>
93653>>>>>>>>>        
93653>>>>>>>>>        Get Seq_New_Channel to iChannel
93654>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93656>>>>>>>>>            Send UserError "No Channel Available for Process: Procedure 'CountNumberOfLines'"
93657>>>>>>>>>            Function_Return 0
93658>>>>>>>>>        End
93658>>>>>>>>>>
93658>>>>>>>>>
93658>>>>>>>>>        Move 0 to iLines
93659>>>>>>>>>        Direct_Input channel iChannel sFullSourceFileName
93661>>>>>>>>>        While (SeqEof = False)
93665>>>>>>>>>            Readln channel iChannel sLine 
93667>>>>>>>>>            Get IsCommentLineOrBlank sLine to bBlank
93668>>>>>>>>>            If (bBlank = False) Begin
93670>>>>>>>>>                Increment iLines
93671>>>>>>>>>            End
93671>>>>>>>>>>
93671>>>>>>>>>        Loop
93672>>>>>>>>>>
93672>>>>>>>>>        Close_Input channel iChannel
93674>>>>>>>>>        Send Seq_Release_Channel iChannel
93675>>>>>>>>>        
93675>>>>>>>>>        Function_Return iLines
93676>>>>>>>>>    End_Function
93677>>>>>>>>>
93677>>>>>>>>>    // Pass the whole source file as a string array
93677>>>>>>>>>    // Removes all unusad locally defined (in Procedures & Functions) for the
93677>>>>>>>>>    // passed string array. Returns number of removed unused local variables.
93677>>>>>>>>>    Function RemoveUnusedLocals String[] ByRef asSourceFile String sParameter Returns Integer
93679>>>>>>>>>        Handle ho                               
93679>>>>>>>>>        Integer iRetval
93679>>>>>>>>>        Get phoRemoveUnusedLocals to ho
93680>>>>>>>>>        If (ho = 0) Begin
93682>>>>>>>>>            Send UserError "phoRemoveUnusedLocals = 0"
93683>>>>>>>>>            Function_Return 0
93684>>>>>>>>>        End                                                
93684>>>>>>>>>>
93684>>>>>>>>>        Get MainProcedure of ho asSourceFile to iRetval
93685>>>>>>>>>//        If (iRetval > 1) Begin
93685>>>>>>>>>//            Reread SysFile
93685>>>>>>>>>//                Add iRetval to SysFile.iCountUnusedLocals
93685>>>>>>>>>//                SaveRecord SysFile
93685>>>>>>>>>//            Unlock
93685>>>>>>>>>//        End
93685>>>>>>>>>
93685>>>>>>>>>        Function_Return iRetval
93686>>>>>>>>>    End_Function                                                          
93687>>>>>>>>>    
93687>>>>>>>>>    // Pass the whole source file as a string array.
93687>>>>>>>>>    // Removes  consecutive empty blank lines if more than piMaxNoOfEmptyLines.
93687>>>>>>>>>    // Returns the passed string array but with removed duplicated empty lines.
93687>>>>>>>>>    Function RemoveMultipleBlankLines String[] ByRef asSourceFile String sParameter Returns Integer
93689>>>>>>>>>        String[] asSourceFileOut
93690>>>>>>>>>        Integer iCount iSize iCurrentNoOfEmptyLines iEmptyLines iMaxNoOfEmptyLines 
93690>>>>>>>>>        String sLine
93690>>>>>>>>>        Boolean bImageStart bImageEnd bMakeImageTest
93690>>>>>>>>>
93690>>>>>>>>>        Move False to bImageStart
93691>>>>>>>>>        Move False to bImageEnd
93692>>>>>>>>>        Move True  to bMakeImageTest
93693>>>>>>>>>        Move 0 to iCurrentNoOfEmptyLines                                           
93694>>>>>>>>>        Move sParameter to iMaxNoOfEmptyLines
93695>>>>>>>>>        
93695>>>>>>>>>        Move (SizeOfArray(asSourceFile)) to iSize
93696>>>>>>>>>        Decrement iSize
93697>>>>>>>>>
93697>>>>>>>>>        For iCount from 0 to iSize
93703>>>>>>>>>>
93703>>>>>>>>>            Move (Trim(asSourceFile[iCount])) to sLine
93704>>>>>>>>>
93704>>>>>>>>>            If (bMakeImageTest = True) Begin
93706>>>>>>>>>                If (bImageStart = False and bImageEnd = False) Begin
93708>>>>>>>>>                    Get IsImagePageStartOrEnd sLine True to bImageStart
93709>>>>>>>>>                End
93709>>>>>>>>>>
93709>>>>>>>>>            End
93709>>>>>>>>>>
93709>>>>>>>>>
93709>>>>>>>>>            If (bImageStart = False and bImageEnd = False) Begin
93711>>>>>>>>>                If (sLine = "") Begin
93713>>>>>>>>>                    Increment iCurrentNoOfEmptyLines
93714>>>>>>>>>                End
93714>>>>>>>>>>
93714>>>>>>>>>                Else Begin
93715>>>>>>>>>                    Move 0 to iCurrentNoOfEmptyLines
93716>>>>>>>>>                End
93716>>>>>>>>>>
93716>>>>>>>>>            End
93716>>>>>>>>>>
93716>>>>>>>>>            If (iCurrentNoOfEmptyLines <= iMaxNoOfEmptyLines) Begin
93718>>>>>>>>>                Move asSourceFile[iCount] to asSourceFileOut[SizeOfArray(asSourceFileOut)]
93719>>>>>>>>>            End
93719>>>>>>>>>>
93719>>>>>>>>>
93719>>>>>>>>>            If (bMakeImageTest = True) Begin
93721>>>>>>>>>                If (bImageStart = True) Begin
93723>>>>>>>>>                    Get IsImagePageStartOrEnd sLine False to bImageEnd
93724>>>>>>>>>                    If (bImageEnd = True) Begin
93726>>>>>>>>>                        Move False to bImageStart
93727>>>>>>>>>                        Move False to bImageEnd
93728>>>>>>>>>                        Move False to bMakeImageTest
93729>>>>>>>>>                    End
93729>>>>>>>>>>
93729>>>>>>>>>                End
93729>>>>>>>>>>
93729>>>>>>>>>            End
93729>>>>>>>>>>
93729>>>>>>>>>        Loop
93730>>>>>>>>>>
93730>>>>>>>>>
93730>>>>>>>>>        Move (SizeOfArray(asSourceFile) - SizeOfArray(asSourceFileOut)) to iEmptyLines
93731>>>>>>>>>        Move asSourceFileOut to asSourceFile
93732>>>>>>>>>
93732>>>>>>>>>        Function_Return iEmptyLines
93733>>>>>>>>>    End_Function    
93734>>>>>>>>>    
93734>>>>>>>>>    Function RestylelDDOs String[] ByRef asSourceFile String sParameter Returns Integer
93736>>>>>>>>>//        String sFileFilter sHomePath
93736>>>>>>>>>//        Handle ho 
93736>>>>>>>>>        Integer iRetval                  
93736>>>>>>>>>//        tRefactorSettings RefactorSettings
93736>>>>>>>>>//        tsSearchResult[] asAllSourceFiles
93736>>>>>>>>>//        
93736>>>>>>>>>//        // ToDo: This needs to be available for the unit tester as well.
93736>>>>>>>>>//        Get phoDDOReStyler to ho
93736>>>>>>>>>//        If (ho = 0) Begin
93736>>>>>>>>>//            Send UserError "phoDDORestyler = 0"
93736>>>>>>>>>//            Function_Return 0
93736>>>>>>>>>//        End
93736>>>>>>>>>//        
93736>>>>>>>>>//        Get psHomePath of ghoApplication to sHomePath 
93736>>>>>>>>>//        Get pRefactorSettings to RefactorSettings
93736>>>>>>>>>//        Get AllSourceFiles of ghoApplication RefactorSettings.asFolderNames RefactorSettings.sFileFilter to asAllSourceFiles
93736>>>>>>>>>//        
93736>>>>>>>>>//        Set psHomePath of ho to sHomePath
93736>>>>>>>>>//        Set peDDOStyle of ho to RefactorSettings.eDDOStyle
93736>>>>>>>>>//        Set pasAllSourceFiles of ho to asAllSourceFiles
93736>>>>>>>>>//        
93736>>>>>>>>>//        Get MainDDORestyler of ho to iRetval 
93736>>>>>>>>>        Function_Return iRetval
93737>>>>>>>>>    End_Function
93738>>>>>>>>>    
93738>>>>>>>>>    // ToDo: *** EDITOR FUNCTIONS ***   
93738>>>>>>>>>    //
93738>>>>>>>>>    // Wrapper functions for the cScintillaEdit editor
93738>>>>>>>>>    // Note that a full visible instantiation of the cScintillaEdit class
93738>>>>>>>>>    // should be used for usage, and the phoEditor property for that
93738>>>>>>>>>    // object _must_ be set to that editor object id.   
93738>>>>>>>>>    //
93738>>>>>>>>>    Function EditorNormalizeCase String[] ByRef asSourceFile String sParameter Returns Integer
93740>>>>>>>>>        Handle hoEditor                                       
93740>>>>>>>>>        Integer iRetval
93740>>>>>>>>>        Boolean bErr
93740>>>>>>>>>        
93740>>>>>>>>>        Get phoEditor to hoEditor
93741>>>>>>>>>        If (hoEditor = 0) Begin
93743>>>>>>>>>            Send UserError "phoEditor = 0 (Function: EditorNormalizeCase)"
93744>>>>>>>>>            Function_Return 0
93745>>>>>>>>>        End
93745>>>>>>>>>>
93745>>>>>>>>>        Send RefactorNormalizeCase of hoEditor 
93746>>>>>>>>>        If (Err = True) Begin
93748>>>>>>>>>            Move 0 to iRetval
93749>>>>>>>>>        End                  
93749>>>>>>>>>>
93749>>>>>>>>>        Else Begin
93750>>>>>>>>>            Move 1 to iRetval
93751>>>>>>>>>        End
93751>>>>>>>>>>
93751>>>>>>>>>        Move bErr to Err
93752>>>>>>>>>        Function_Return iRetval
93753>>>>>>>>>    End_Function
93754>>>>>>>>>
93754>>>>>>>>>    Function EditorReIndent String[] ByRef asSourceFile String sParameter Returns Integer
93756>>>>>>>>>        Handle hoEditor                                       
93756>>>>>>>>>        Integer iRetval 
93756>>>>>>>>>        Boolean bErr
93756>>>>>>>>>        
93756>>>>>>>>>        Move Err to bErr
93757>>>>>>>>>        Move False to Err
93758>>>>>>>>>        Get phoEditor to hoEditor
93759>>>>>>>>>        If (hoEditor = 0) Begin
93761>>>>>>>>>            Send UserError "phoEditor = 0 (Function: EditorReIndent)"
93762>>>>>>>>>            Function_Return 0
93763>>>>>>>>>        End                                            
93763>>>>>>>>>>
93763>>>>>>>>>        Set piTabSize of hoEditor to sParameter
93764>>>>>>>>>        Send RefactorReIndent of hoEditor
93765>>>>>>>>>        If (Err = True) Begin
93767>>>>>>>>>            Move 0 to iRetval
93768>>>>>>>>>        End                  
93768>>>>>>>>>>
93768>>>>>>>>>        Else Begin
93769>>>>>>>>>            Move 1 to iRetval
93770>>>>>>>>>        End
93770>>>>>>>>>>
93770>>>>>>>>>        Move bErr to Err
93771>>>>>>>>>        Function_Return iRetval
93772>>>>>>>>>    End_Function
93773>>>>>>>>>
93773>>>>>>>>>    Function EditorDropSelf String[] ByRef asSourceFile String sParameter Returns Integer
93775>>>>>>>>>        Handle hoEditor
93775>>>>>>>>>        Integer iRetval
93775>>>>>>>>>        Boolean bErr
93775>>>>>>>>>        
93775>>>>>>>>>        Get phoEditor to hoEditor
93776>>>>>>>>>        If (hoEditor = 0) Begin
93778>>>>>>>>>            Send UserError "phoEditor = 0 (Function: EditorDropSelf)"
93779>>>>>>>>>            Function_Return 0
93780>>>>>>>>>        End                  
93780>>>>>>>>>>
93780>>>>>>>>>        Send RefactorDropSelf of hoEditor
93781>>>>>>>>>        Else Begin
93782>>>>>>>>>            Move 1 to iRetval
93783>>>>>>>>>        End
93783>>>>>>>>>>
93783>>>>>>>>>        Move bErr to Err
93784>>>>>>>>>        Function_Return iRetval
93785>>>>>>>>>    End_Function
93786>>>>>>>>>
93786>>>>>>>>>
93786>>>>>>>>>    // ToDo: *** REPORT FUNCTIONS ***
93786>>>>>>>>>    //                        
93786>>>>>>>>>    Function ReportUnusedSourceFiles String[] ByRef asSourceFiles String sParameter Returns Integer
93788>>>>>>>>>        Handle ho                 
93788>>>>>>>>>        String sFilter                       
93788>>>>>>>>>        Integer iRetval
93788>>>>>>>>>        tRefactorSettings RefactorSettings
93788>>>>>>>>>        tRefactorSettings RefactorSettings
93788>>>>>>>>>        
93788>>>>>>>>>        Get phoReportUnusedSourceFiles to ho
93789>>>>>>>>>        If (ho = 0) Begin
93791>>>>>>>>>            Function_Return 0
93792>>>>>>>>>        End                              
93792>>>>>>>>>>
93792>>>>>>>>>        
93792>>>>>>>>>        Get pRefactorSettings to RefactorSettings
93793>>>>>>>>>        Set psFileFilter  of ho to RefactorSettings.sFileFilter
93794>>>>>>>>>//        Set pasAllFolders of ho to RefactorSettings.asFolderNames
93794>>>>>>>>>// ToDo: *** Change interface!!! ***
93794>>>>>>>>>//        Set pasSourceFiles of ho to asSourceFiles 
93794>>>>>>>>>Function_Return 0
93795>>>>>>>>>        
93795>>>>>>>>>        Send DoProcess    of ho  
93796>>>>>>>>>        
93796>>>>>>>>>        Get piNoOfUnusedSourceFiles of ho to iRetval
93797>>>>>>>>>        Reread SysFile
93801>>>>>>>>>            Move iRetval to SysFile.iCountUnusedSourceFiles
93802>>>>>>>>>            SaveRecord SysFile
93803>>>>>>>>>        Unlock
93804>>>>>>>>>>
93804>>>>>>>>>        Function_Return iRetval
93805>>>>>>>>>    End_Function
93806>>>>>>>>>    
93806>>>>>>>>>    // ToDo: *** HELPER FUNCTIONS ***   
93806>>>>>>>>>
93806>>>>>>>>>    // Note: It must only be the code part of a source line that is passed here.
93806>>>>>>>>>    //       Use the Tokenizer helper function first.
93806>>>>>>>>>    Function _AddExpressionParenthesis String ByRef sLine Returns Boolean
93808>>>>>>>>>        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
93808>>>>>>>>>        Boolean bFound bChanged bStartOperators bIfCommand bSecondCommand bWhile
93808>>>>>>>>>        Integer iPos iPos2
93808>>>>>>>>>        
93808>>>>>>>>>        Move sLine to sText    
93809>>>>>>>>>        Move sLine to sOrg             
93810>>>>>>>>>        // Do nothing if a Constrain command.
93810>>>>>>>>>        Get HasCommand sText (CS_Constrain + " ") to bFound
93811>>>>>>>>>        If (bFound = True) Begin
93813>>>>>>>>>            Function_Return False
93814>>>>>>>>>        End
93814>>>>>>>>>>
93814>>>>>>>>>
93814>>>>>>>>>        Move "" to sStart
93815>>>>>>>>>        Move "" to sLast                                  
93816>>>>>>>>>        Get ExpressionExtractor sText CI_LeftExpression to sExpression
93817>>>>>>>>>        If (Trim(sExpression) = "") Begin
93819>>>>>>>>>            Get ExpressionExtractor sText CI_OfExpression to sExpression
93820>>>>>>>>>            If (Trim(sExpression) = "") Begin
93822>>>>>>>>>                Get ExpressionExtractor sText CI_ToTexpression to sExpression
93823>>>>>>>>>            End
93823>>>>>>>>>>
93823>>>>>>>>>        End
93823>>>>>>>>>>
93823>>>>>>>>>        If (Trim(sExpression) = "") Begin
93825>>>>>>>>>            Function_Return False
93826>>>>>>>>>        End 
93826>>>>>>>>>>
93826>>>>>>>>>        Move (Pos(sExpression, sText)) to iPos
93827>>>>>>>>>        If (iPos <> 0) Begin
93829>>>>>>>>>            Move (Left(sLine, (iPos - 1))) to sStart
93830>>>>>>>>>            If (sStart <> "") Begin
93832>>>>>>>>>                Move (Replace(sStart, sLine, "")) to sText
93833>>>>>>>>>                Move (Replace(sExpression, sText, "")) to sLast
93834>>>>>>>>>            End
93834>>>>>>>>>>
93834>>>>>>>>>        End
93834>>>>>>>>>>
93834>>>>>>>>>//        If (sStart <> "") Begin
93834>>>>>>>>>//            Move sStart to sLine
93834>>>>>>>>>//        End                     
93834>>>>>>>>>        If (sExpression <> "") Begin               
93836>>>>>>>>>            Move sExpression to sText
93837>>>>>>>>>            Send StripConcatenatingSpaces (&sExpression)  
93838>>>>>>>>>            Move (Trim(sExpression)) to sExpression 
93839>>>>>>>>>            Get HasDoubleExpression sExpression to bFound
93840>>>>>>>>>            Move (Left(sExpression, 1)) to sChar
93841>>>>>>>>>            If (sChar <> "(" or bFound = True) Begin
93843>>>>>>>>>                Move ("(" + sExpression + ")") to sExpression
93844>>>>>>>>>            End                      
93844>>>>>>>>>>
93844>>>>>>>>>            If (sText = sLine) Begin
93846>>>>>>>>>                Move sExpression to sLine
93847>>>>>>>>>            End
93847>>>>>>>>>>
93847>>>>>>>>>        End                                                    
93847>>>>>>>>>>
93847>>>>>>>>>        If (sStart <> "" or sLast <> "") Begin    
93849>>>>>>>>>            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
93850>>>>>>>>>        End
93850>>>>>>>>>>
93850>>>>>>>>>        
93850>>>>>>>>>        Function_Return (sLine <> sOrg)
93851>>>>>>>>>    End_Function   
93852>>>>>>>>>                   
93852>>>>>>>>>    // Helper message for _ClearFirstCompoundBeforeMethod
93852>>>>>>>>>    Procedure _WipeUntilPosition Integer iPos String ByRef sLine
93854>>>>>>>>>        Integer iChar
93854>>>>>>>>>        If (iPos > 0) Begin
93856>>>>>>>>>            For iChar from 1 to (iPos - 1)
93862>>>>>>>>>>
93862>>>>>>>>>                Move (Overstrike(" ", sLine, iChar)) to sLine
93863>>>>>>>>>            Loop
93864>>>>>>>>>>
93864>>>>>>>>>        End
93864>>>>>>>>>>
93864>>>>>>>>>    End_Procedure
93865>>>>>>>>>
93865>>>>>>>>>    // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
93865>>>>>>>>>    // send/get/set as the first string and that complicates our detection.
93865>>>>>>>>>    // What this does is simply overwrite everything with spaces before our methods if
93865>>>>>>>>>    // we have such a compound statement.
93865>>>>>>>>>    // The variable sLine is not always lowercase.
93865>>>>>>>>>    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
93867>>>>>>>>>        Integer iPos
93867>>>>>>>>>        String  sLtrimLine sOrgLine
93867>>>>>>>>>        Boolean bChanged
93867>>>>>>>>>        
93867>>>>>>>>>        Move sLine to sOrgLine
93868>>>>>>>>>        Move (Lowercase(LTrim(sLine))) to sLTrimLine
93869>>>>>>>>>        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
93871>>>>>>>>>            // A line that starts with an "if" or "else" can still call a method
93871>>>>>>>>>            Move (Pos("send ", Lowercase(sLine))) to iPos
93872>>>>>>>>>            If (iPos = 0) Begin
93874>>>>>>>>>                Move (Pos("get ", Lowercase(sLine))) to iPos
93875>>>>>>>>>            End
93875>>>>>>>>>>
93875>>>>>>>>>            If (iPos = 0) Begin
93877>>>>>>>>>                Move (Pos("set ", Lowercase(sLine))) to iPos
93878>>>>>>>>>            End
93878>>>>>>>>>>
93878>>>>>>>>>            Send _WipeUntilPosition iPos (&sLine)
93879>>>>>>>>>        End       
93879>>>>>>>>>>
93879>>>>>>>>>        
93879>>>>>>>>>        Function_Return (sLine <> sOrgLine)
93880>>>>>>>>>    End_Function
93881>>>>>>>>>  
93881>>>>>>>>>    // Helper function to return expressions from a source line;
93881>>>>>>>>>    //   eExpressionMode can be any of; CI_LeftExpression, CI_OfExpression or CI_ToTexpression.
93881>>>>>>>>>    // As expressions only expressions in rounded parenthesis "()" are acted upon and returned (Not square brackets)
93881>>>>>>>>>    Function ExpressionExtractor String sLine Integer eExpressionMode Returns String
93883>>>>>>>>>        String sExpression sText sChar sStart sLast sCommand 
93883>>>>>>>>>        String[] asTokens asTokensLower
93885>>>>>>>>>        Integer iStart iEnd iLength iLeftParantheses iRightParantheses iPos iCount iSize
93885>>>>>>>>>        Boolean bFound bOperator bParenthesis 
93885>>>>>>>>>        tOperatorsInfo OperatorsInfo
93885>>>>>>>>>        tOperatorsInfo OperatorsInfo
93885>>>>>>>>>        tCodeComponents CodeComponents
93885>>>>>>>>>        tCodeComponents CodeComponents
93885>>>>>>>>>        
93885>>>>>>>>>        Get _RemoveEndComment sLine to sText
93886>>>>>>>>>        Move (Trim(sText)) to sText
93887>>>>>>>>>        Get _OverstrikeStrings sText to sText
93888>>>>>>>>>        Move (Pos("(", sText)) to iStart
93889>>>>>>>>>        Move (Pos(")", sText)) to iEnd 
93890>>>>>>>>>        Get IsLogicalOperators sText to OperatorsInfo
93891>>>>>>>>>        If (OperatorsInfo.bIsOperator = False and (iStart < 1 or iEnd < 1) ) Begin
93893>>>>>>>>>            Function_Return sLine
93894>>>>>>>>>        End
93894>>>>>>>>>>
93894>>>>>>>>>        
93894>>>>>>>>>        Move (Trim(sLine)) to sText
93895>>>>>>>>>//        Get StrSplitToArray sLine " " to asTokens
93895>>>>>>>>>//        Move (Lowercase(sLine)) to sText
93895>>>>>>>>>//        Get StrSplitToArray sText " " to asTokensLower
93895>>>>>>>>>        
93895>>>>>>>>>        Case Begin
93895>>>>>>>>>            Case (eExpressionMode = CI_LeftExpression) 
93897>>>>>>>>>                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
93898>>>>>>>>>                If (iPos > 0) Begin
93900>>>>>>>>>                    Move (Left(sText, (iPos -1))) to sText
93901>>>>>>>>>                End                                       
93901>>>>>>>>>>
93901>>>>>>>>>                Else Begin
93902>>>>>>>>>                    Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
93903>>>>>>>>>                End                                            
93903>>>>>>>>>>
93903>>>>>>>>>                If (iPos > 0) Begin
93905>>>>>>>>>                    Move (Left(sText, (iPos - 1))) to sText // XXX
93906>>>>>>>>>                End
93906>>>>>>>>>>
93906>>>>>>>>>                Case Break   
93907>>>>>>>>>            
93907>>>>>>>>>            // ToDo: This does not belong here:!!!    
93907>>>>>>>>>            // Move to Tokenizer???
93907>>>>>>>>>            Case (eExpressionMode = CI_CommandExpression)
93910>>>>>>>>>                Get Tokenizer sLine to CodeComponents 
93911>>>>>>>>>                If (Lowercase(CodeComponents.sLeftCommand) = Lowercase(CS_If)) Begin
93913>>>>>>>>>                    Move (lowercase(sLine) contains (" " + Lowercase(CS_Move) + " ")) to bFound
93914>>>>>>>>>                    If (bFound) Begin
93916>>>>>>>>>                        
93916>>>>>>>>>                    End
93916>>>>>>>>>>
93916>>>>>>>>>                End
93916>>>>>>>>>>
93916>>>>>>>>>                Case Break
93917>>>>>>>>>            Case (eExpressionMode = CI_OfExpression)
93920>>>>>>>>>                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
93921>>>>>>>>>                If (iPos > 0) Begin
93923>>>>>>>>>                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText
93924>>>>>>>>>                    Move (Pos((" " + Lowercase(CS_to) + " "), Lowercase(sText))) to iPos
93925>>>>>>>>>                    If (iPos > 0) Begin
93927>>>>>>>>>                        Move (Left(sText, (iPos -1))) to sText
93928>>>>>>>>>                    End
93928>>>>>>>>>>
93928>>>>>>>>>                    Get IsOperators sText to bOperator
93929>>>>>>>>>                    Move (sText contains "(" and sText contains ")") to bParenthesis
93930>>>>>>>>>                    If (bOperator = True or bParenthesis = True) Begin
93932>>>>>>>>>                        Move (Trim(sText)) to sExpression
93933>>>>>>>>>                    End
93933>>>>>>>>>>
93933>>>>>>>>>                End
93933>>>>>>>>>>
93933>>>>>>>>>                Else Begin
93934>>>>>>>>>                    Move "" to sText // Nothing to do.
93935>>>>>>>>>                End
93935>>>>>>>>>>
93935>>>>>>>>>                Case Break
93936>>>>>>>>>            Case (eExpressionMode = CI_ToTexpression)
93939>>>>>>>>>                Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
93940>>>>>>>>>                If (iPos > 0) Begin
93942>>>>>>>>>                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText 
93943>>>>>>>>>                    Get IsOperators sText to bOperator
93944>>>>>>>>>                    Move (sText contains "(" and sText contains ")") to bParenthesis
93945>>>>>>>>>                    If (bOperator = True or bParenthesis = True) Begin
93947>>>>>>>>>                        Move (Trim(sText)) to sExpression
93948>>>>>>>>>                    End
93948>>>>>>>>>>
93948>>>>>>>>>                End 
93948>>>>>>>>>>
93948>>>>>>>>>                Else Begin
93949>>>>>>>>>                    Move "" to sText // Nothing to do.
93950>>>>>>>>>                End
93950>>>>>>>>>>
93950>>>>>>>>>                Case Break 
93951>>>>>>>>>            Case Else
93951>>>>>>>>>                Move "" to sText
93952>>>>>>>>>        Case End
93952>>>>>>>>>        
93952>>>>>>>>>//        Move "" to sExpression  
93952>>>>>>>>>//        Move 0  to iLeftParantheses
93952>>>>>>>>>//        Move 0  to iRightParantheses
93952>>>>>>>>>        If (sText <> "") Begin
93954>>>>>>>>>//            Move (Pos("(", sText)) to iStart
93954>>>>>>>>>//            Move (Pos(")", sText)) to iEnd
93954>>>>>>>>>//            Get IsOperators sText to bOperator
93954>>>>>>>>>//            If (bOperator = False and (iStart = 0 or iEnd = 0) ) Begin
93954>>>>>>>>>//                Function_Return ""
93954>>>>>>>>>//            End 
93954>>>>>>>>>//
93954>>>>>>>>>            Get IsLogicalOperators sText to OperatorsInfo
93955>>>>>>>>>            If (OperatorsInfo.bIsOperator = True) Begin
93957>>>>>>>>>                Get _ExtractParenthesisExpression sText to sExpression
93958>>>>>>>>>                If (sExpression = "") Begin
93960>>>>>>>>>                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to sExpression
93961>>>>>>>>>                End
93961>>>>>>>>>>
93961>>>>>>>>>            End
93961>>>>>>>>>>
93961>>>>>>>>>//            Move (Length(sText)) to iLength
93961>>>>>>>>>//            For iCount from iStart to iLength
93961>>>>>>>>>//                Move (Mid(sText, 1, iCount)) to sChar
93961>>>>>>>>>//                If (sChar = "(" or sChar = ")") Begin
93961>>>>>>>>>//                    Add (sChar = "(") to iLeftParantheses
93961>>>>>>>>>//                    Add (sChar = ")") to iRightParantheses
93961>>>>>>>>>//                    Move iCount to iPos
93961>>>>>>>>>//                End                        
93961>>>>>>>>>//                If (sChar = " " and iLeftParantheses = iRightParantheses) Break
93961>>>>>>>>>//            Loop
93961>>>>>>>>>//            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
93961>>>>>>>>>//            If (sExpression = "" and (bOperator = True) and (iStart <> 1 or iEnd <> 0)) Begin
93961>>>>>>>>>//                Get _RemoveFirstWord sText to sText
93961>>>>>>>>>//                Get IsOperators sText to bOperator
93961>>>>>>>>>//                If (bOperator = True) Begin
93961>>>>>>>>>//                    Move sText to sExpression 
93961>>>>>>>>>//                    Move sLine to sText
93961>>>>>>>>>//                End
93961>>>>>>>>>//            End
93961>>>>>>>>>        End
93961>>>>>>>>>>
93961>>>>>>>>>        
93961>>>>>>>>>        // Check if we have an expression like; "If (psWrkSpcOpenFileName(ghoApplication)) <> "" Send WrkSpcDoForAllFiles"
93961>>>>>>>>>        //   which in case we need to add "<>" to the sExpression.
93961>>>>>>>>>        Get _RemoveLeft sExpression (&sText) to bFound
93962>>>>>>>>>        If (bFound = True) Begin
93964>>>>>>>>>            Get IsLogicalOperators sText to OperatorsInfo
93965>>>>>>>>>            If (OperatorsInfo.bIsOperator = True) Begin
93967>>>>>>>>>                Move (Pos(sExpression, sLine)) to iPos
93968>>>>>>>>>                If (iPos <> "") Begin        
93970>>>>>>>>>                    Move (Left(sLine, (iPos - 1))) to sStart
93971>>>>>>>>>                    Move (Replace(sStart, sLine, "")) to sLine
93972>>>>>>>>>                    Move (Trim(sText)) to sText 
93973>>>>>>>>>                    Move (Length(sText)) to iLength    
93974>>>>>>>>>                    Get _OverstrikeStrings sText to sText
93975>>>>>>>>>                    Get _FindFirstCommand sText to iPos
93976>>>>>>>>>                    If (iPos <> 0) Begin
93978>>>>>>>>>                        Move (Replace(sExpression, sLine, "")) to sLine 
93979>>>>>>>>>                        Move (Trim(sLine)) to sLine
93980>>>>>>>>>                        Move (Left(sLine, (iPos -1))) to sStart 
93981>>>>>>>>>                        Move (Trim(sStart)) to sStart
93982>>>>>>>>>                        If (sStart <> "") Begin
93984>>>>>>>>>                            Move (Right(sStart, 1)) to sChar
93985>>>>>>>>>                            If (sChar <> ")") Begin
93987>>>>>>>>>                                Move (String(sExpression) * String(sStart)) to sExpression    
93988>>>>>>>>>                            End
93988>>>>>>>>>>
93988>>>>>>>>>                        End
93988>>>>>>>>>>
93988>>>>>>>>>                    End
93988>>>>>>>>>>
93988>>>>>>>>>                End
93988>>>>>>>>>>
93988>>>>>>>>>            End
93988>>>>>>>>>>
93988>>>>>>>>>        End
93988>>>>>>>>>>
93988>>>>>>>>>        Function_Return sExpression
93989>>>>>>>>>    End_Function
93990>>>>>>>>>
93990>>>>>>>>>    // Rturns the first expression that exist in the passed sText string and that is within parenthesis,
93990>>>>>>>>>    // else it returns a blank string.
93990>>>>>>>>>    Function _ExtractParenthesisExpression String sText Returns String
93992>>>>>>>>>        String sExpression sChar
93992>>>>>>>>>        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
93992>>>>>>>>>        tOperatorsInfo OperatorInfo
93992>>>>>>>>>        tOperatorsInfo OperatorInfo
93992>>>>>>>>>        
93992>>>>>>>>>        Move "" to sExpression
93993>>>>>>>>>        Move 0  to iLeftParantheses
93994>>>>>>>>>        Move 0  to iRightParantheses
93995>>>>>>>>>        
93995>>>>>>>>>        If (sText <> "") Begin
93997>>>>>>>>>            Move (Pos("(", sText)) to iStart
93998>>>>>>>>>            Move (RightPos(")", sText)) to iEnd
93999>>>>>>>>>            Get IsLogicalOperators sText to OperatorInfo
94000>>>>>>>>>            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
94002>>>>>>>>>                Function_Return ""
94003>>>>>>>>>            End 
94003>>>>>>>>>>
94003>>>>>>>>>
94003>>>>>>>>>            Move (Length(sText)) to iLength
94004>>>>>>>>>            For iCount from iStart to iLength
94010>>>>>>>>>>
94010>>>>>>>>>                Move (Mid(sText, 1, iCount)) to sChar
94011>>>>>>>>>                If (sChar = "(" or sChar = ")") Begin
94013>>>>>>>>>                    Add (sChar = "(") to iLeftParantheses
94014>>>>>>>>>                    Add (sChar = ")") to iRightParantheses
94015>>>>>>>>>                    Move iCount to iPos
94016>>>>>>>>>                End                        
94016>>>>>>>>>>
94016>>>>>>>>>                If (iLeftParantheses = iRightParantheses) Break
94019>>>>>>>>>            Loop
94020>>>>>>>>>>
94020>>>>>>>>>            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
94021>>>>>>>>>        End
94021>>>>>>>>>>
94021>>>>>>>>>        Function_Return sExpression
94022>>>>>>>>>    End_Function
94023>>>>>>>>>
94023>>>>>>>>>    Function _ExtractExpressionNoParenthesis String sLine tOperatorsInfo OperatorsInfo Returns String
94025>>>>>>>>>        String sText sExpression sChar sFirst sLast sLeft sRight
94025>>>>>>>>>        Integer iCount iLength iSize iStart iEnd iPos
94025>>>>>>>>>        Boolean bStop bSpace bParanthesis
94025>>>>>>>>>        
94025>>>>>>>>>        // ToDo: Is this really correct in all cases?
94025>>>>>>>>>        If (OperatorsInfo.bIsOperator = False) Begin
94027>>>>>>>>>            Function_Return ""
94028>>>>>>>>>        End
94028>>>>>>>>>>
94028>>>>>>>>>        Move "" to sExpression  
94029>>>>>>>>>//        Move (Pos(Lowercase(" " + CS_As + " "), sLine)) to iPos 
94029>>>>>>>>>//        If (iPos <> 0) Begin
94029>>>>>>>>>//            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sText    
94029>>>>>>>>>//        End
94029>>>>>>>>>//        Else Begin
94029>>>>>>>>>            Move (OperatorsInfo.iPos - Length(OperatorsInfo.sOperator)) to iStart
94030>>>>>>>>>            Move (Left(sLine, (iStart + 1))) to sText
94031>>>>>>>>>//        End
94031>>>>>>>>>        Send StripConcatenatingSpaces (&sText)
94032>>>>>>>>>        Get _OverstrikeStrings (&sText) to sText
94033>>>>>>>>>        Move (Length(sText)) to iLength   
94034>>>>>>>>>        Move (Pos(Lowercase(" " + CS_As + " "), sText)) to iPos 
94035>>>>>>>>>        If (iPos <> 0) Begin
94037>>>>>>>>>            Move (Mid(sText, Length(sText), (iPos + 3))) to sText    
94038>>>>>>>>>        End
94038>>>>>>>>>>
94038>>>>>>>>>        
94038>>>>>>>>>        // First get the left part of the expression:
94038>>>>>>>>>        Move iLength to iStart
94039>>>>>>>>>        Move 0 to iCount
94040>>>>>>>>>        Move False to bSpace
94041>>>>>>>>>        Move (Pos(")", sText)) to bParanthesis
94042>>>>>>>>>        Repeat
94042>>>>>>>>>>
94042>>>>>>>>>            Move (Mid(sText, 1, (iStart - iCount))) to sChar
94043>>>>>>>>>            If (bParanthesis = True) Begin
94045>>>>>>>>>                Move ((iCount >= iLength) or (bSpace = True and sChar <> " ")) to bStop
94046>>>>>>>>>            End 
94046>>>>>>>>>>
94046>>>>>>>>>            Else Begin
94047>>>>>>>>>                Move (sChar = " " and bSpace) to bStop
94048>>>>>>>>>            End
94048>>>>>>>>>>
94048>>>>>>>>>            If (bSpace = False) Begin
94050>>>>>>>>>                Move (sChar = " ") to bSpace
94051>>>>>>>>>            End
94051>>>>>>>>>>
94051>>>>>>>>>            Increment iCount
94052>>>>>>>>>        Until (bStop = True)
94054>>>>>>>>>        Move (Left(sText, (iStart - iCount + 1))) to sFirst  
94055>>>>>>>>>        Move (Replace(sFirst, sText, "")) to sLeft
94056>>>>>>>>>        If (sLeft = "") Begin
94058>>>>>>>>>            Move sText to sLeft
94059>>>>>>>>>        End
94059>>>>>>>>>>
94059>>>>>>>>>        Move (Length(sLine)) to iLength   
94060>>>>>>>>>        
94060>>>>>>>>>        // Then get the right part of the expression:
94060>>>>>>>>>        Move 1 to iCount   
94061>>>>>>>>>        Move False to bSpace
94062>>>>>>>>>        Move (OperatorsInfo.iPos) to iStart
94063>>>>>>>>>        Move (Mid(sLine, iLength, (iStart + 1))) to sText  
94064>>>>>>>>>        Move (Length(sText)) to iLength
94065>>>>>>>>>        Move (Pos(")", sText)) to bParanthesis
94066>>>>>>>>>        Repeat
94066>>>>>>>>>>
94066>>>>>>>>>            Move (Mid(sLine, 1, (iStart + iCount))) to sChar
94067>>>>>>>>>            If (bParanthesis = False) Begin
94069>>>>>>>>>                Move ((iCount >= iLength) or (bSpace = True and sChar = " ")) to bStop
94070>>>>>>>>>            End 
94070>>>>>>>>>>
94070>>>>>>>>>            Else Begin
94071>>>>>>>>>                Move (sChar = " " and bSpace) to bStop
94072>>>>>>>>>            End
94072>>>>>>>>>>
94072>>>>>>>>>            If (bSpace = False) Begin
94074>>>>>>>>>                Move (sChar = " ") to bSpace
94075>>>>>>>>>            End
94075>>>>>>>>>>
94075>>>>>>>>>            Increment iCount
94076>>>>>>>>>        Until (bStop = True)
94078>>>>>>>>>                                                     
94078>>>>>>>>>        Move (Left(sText, (iCount - 1))) to sRight
94079>>>>>>>>>        Move (String(sLeft) * String(sRight)) to sExpression
94080>>>>>>>>>        
94080>>>>>>>>>        Function_Return (Trim(sExpression))
94081>>>>>>>>>    End_Function
94082>>>>>>>>>
94082>>>>>>>>>    // Syntax:
94082>>>>>>>>>    //    Get Tokenizer sTest to "tCodeComponents"
94082>>>>>>>>>    // Breaks up a source line into these tokens;
94082>>>>>>>>>    //     tCodeComponents
94082>>>>>>>>>    //  a) sIndentation = spaces or tab-characters to the left (start) of the source code line
94082>>>>>>>>>    //  b) sLineStartIndicator = [Found] or other indicators within brackets placed at beginning of line.   
94082>>>>>>>>>    //  c) sLeftCommand = "Move, Calc" etc. 
94082>>>>>>>>>    // ToDo: Should we add a Second left command param???
94082>>>>>>>>>    //  d) sCode = the source code itself (or left hand side code if a "of" or "to" or right comment)
94082>>>>>>>>>    //  e) sOfStatement = " of xxx"
94082>>>>>>>>>    //  f) sToStatement = " to xxx" 
94082>>>>>>>>>    //  g) sRightComment = any comment placed at the end of the line.
94082>>>>>>>>>    //
94082>>>>>>>>>    // It does not Rtrim the end-of-line comment.  Should it??
94082>>>>>>>>>    // Note: If the line is a compound statement (one that spans over several lines),
94082>>>>>>>>>    //       aka it contains a ";", the function will NOT try to break up the source code line.
94082>>>>>>>>>    //       Instead it returns a struct with empty members, except for the 
94082>>>>>>>>>    //       bHasEndSemiColon member that will be true.
94082>>>>>>>>>    Function Tokenizer String sLine Returns tCodeComponents
94084>>>>>>>>>        tCodeComponents LineComponents
94084>>>>>>>>>        tCodeComponents LineComponents
94084>>>>>>>>>        String sText sChar sCommand
94084>>>>>>>>>        Boolean bEndComment bStop bOfStatement bToStatement bIndicator bFound bMoveCommand
94084>>>>>>>>>        Integer iPos iStart iEnd
94084>>>>>>>>>                                                
94084>>>>>>>>>        Move "" to LineComponents.sIndentation
94085>>>>>>>>>        Move "" to LineComponents.sLineStartIndicator  
94086>>>>>>>>>        Move "" to LineComponents.sLeftCommand
94087>>>>>>>>>        Move "" to LineComponents.sCode
94088>>>>>>>>>        Move "" to LineComponents.sOfStatement
94089>>>>>>>>>        Move "" to LineComponents.sToStatement
94090>>>>>>>>>        Move "" to LineComponents.sRightComment
94091>>>>>>>>>        Move False to LineComponents.bHasEndSemiColon
94092>>>>>>>>>        
94092>>>>>>>>>        Get IsCommentLineOrBlank sLine to bStop
94093>>>>>>>>>        If (bStop = True) Begin
94095>>>>>>>>>            Function_Return LineComponents
94096>>>>>>>>>        End  
94096>>>>>>>>>>
94096>>>>>>>>>        
94096>>>>>>>>>        Get IsLineEndSemiColon sLine to bStop
94097>>>>>>>>>        If (bStop = True) Begin
94099>>>>>>>>>            Move True to LineComponents.bHasEndSemiColon
94100>>>>>>>>>            Function_Return LineComponents
94101>>>>>>>>>        End  
94101>>>>>>>>>>
94101>>>>>>>>>        
94101>>>>>>>>>        // Get the indentation part
94101>>>>>>>>>        Move (Ltrim(sLine)) to sText
94102>>>>>>>>>        If (sText <> sLine) Begin
94104>>>>>>>>>            Move (Replace(sText, sLine, "")) to LineComponents.sIndentation
94105>>>>>>>>>            Move (Replace(LineComponents.sIndentation, sLine, "")) to sLine
94106>>>>>>>>>        End     
94106>>>>>>>>>>
94106>>>>>>>>>        
94106>>>>>>>>>        Get IsKeywordInLine (CS_Indicate + "|") sLine to bFound
94107>>>>>>>>>        If (bFound = True) Begin
94109>>>>>>>>>            Move True to LineComponents.bHasIndicateCommand
94110>>>>>>>>>        End                                                
94110>>>>>>>>>>
94110>>>>>>>>>        
94110>>>>>>>>>        Get IsIndicatorStatement sLine to bIndicator
94111>>>>>>>>>        If (bIndicator = True) Begin
94113>>>>>>>>>            // Get the start indicator part
94113>>>>>>>>>            Move (Ltrim(sLine)) to sText
94114>>>>>>>>>            Move (Left(sText, 1)) to sChar
94115>>>>>>>>>            If (sChar = "[") Begin
94117>>>>>>>>>                Move (Pos("]", sText)) to iPos
94118>>>>>>>>>                Move (Left(sText, (iPos -1))) to LineComponents.sLineStartIndicator
94119>>>>>>>>>                Move (Left(LineComponents.sLineStartIndicator, 1)) to sChar
94120>>>>>>>>>                If (sChar = "[") Begin
94122>>>>>>>>>                    Move (Replace("[", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
94123>>>>>>>>>                End
94123>>>>>>>>>>
94123>>>>>>>>>                Move (Right(LineComponents.sLineStartIndicator, 1)) to sChar
94124>>>>>>>>>                If (sChar = "]") Begin
94126>>>>>>>>>                    Move (Replace("]", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
94127>>>>>>>>>                End
94127>>>>>>>>>>
94127>>>>>>>>>            End
94127>>>>>>>>>>
94127>>>>>>>>>            
94127>>>>>>>>>            // Get the End indicator part
94127>>>>>>>>>            Move (Trim(sLine)) to sText    
94128>>>>>>>>>            Get _RemoveEndComment sText to sText
94129>>>>>>>>>            Move (Right(sText, 1)) to sChar
94130>>>>>>>>>            If (sChar = "]") Begin  
94132>>>>>>>>>                Move (Pos(Lowercase(" to "), Lowercase(sText))) to iPos
94133>>>>>>>>>                If (iPos > 0) Begin
94135>>>>>>>>>                    Move (Mid(sText, Length(sText), (iPos + 4))) to sText
94136>>>>>>>>>                End
94136>>>>>>>>>>
94136>>>>>>>>>                // We need to check that this isn't an array/struct value.
94136>>>>>>>>>                Move (Pos(" [", sText)) to iStart
94137>>>>>>>>>                If (iStart > 0) Begin
94139>>>>>>>>>                    Move (Pos("]", sText)) to iEnd
94140>>>>>>>>>                    Move (Mid(sText, Length(sText), (iStart +1))) to LineComponents.sLineEndIndicator
94141>>>>>>>>>                    Move (Left(LineComponents.sLineEndIndicator, 1)) to sChar
94142>>>>>>>>>                    If (sChar = "[") Begin
94144>>>>>>>>>                        Move (Replace("[", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
94145>>>>>>>>>                    End
94145>>>>>>>>>>
94145>>>>>>>>>                    Move (Right(LineComponents.sLineEndIndicator, 1)) to sChar
94146>>>>>>>>>                    If (sChar = "]") Begin
94148>>>>>>>>>                        Move (Replace("]", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
94149>>>>>>>>>                    End
94149>>>>>>>>>>
94149>>>>>>>>>                End
94149>>>>>>>>>>
94149>>>>>>>>>            End
94149>>>>>>>>>>
94149>>>>>>>>>        End
94149>>>>>>>>>>
94149>>>>>>>>>
94149>>>>>>>>>        Get IsMoveCommand sText to bMoveCommand
94150>>>>>>>>>        If (bMoveCommand = True) Begin
94152>>>>>>>>>            Move (Pos(" ", sText)) to iPos
94153>>>>>>>>>            Move (Left(sText, (iPos - 1))) to sCommand
94154>>>>>>>>>            Move sCommand to LineComponents.sLeftCommand
94155>>>>>>>>>        End                                             
94155>>>>>>>>>>
94155>>>>>>>>>        
94155>>>>>>>>>        // Get the end comment part
94155>>>>>>>>>        Move sLine to sText
94156>>>>>>>>>        Get _RemoveComments (&sText) to bEndComment
94157>>>>>>>>>        If (bEndComment = True) Begin
94159>>>>>>>>>            Move (Replace(sText, sLine, "")) to LineComponents.sRightComment
94160>>>>>>>>>            Move (Replace(LineComponents.sRightComment, sLine, "")) to sLine
94161>>>>>>>>>        End     
94161>>>>>>>>>>
94161>>>>>>>>>        
94161>>>>>>>>>        // Get the " to " part
94161>>>>>>>>>        Move (Lowercase(sLine)) to sText
94162>>>>>>>>>        Move (sText contains (" " + Lowercase(CS_To) + " ")) to bToStatement
94163>>>>>>>>>        If (bToStatement = True) Begin
94165>>>>>>>>>            Move (Pos((" " + Lowercase(CS_To) + " "), sText)) to iPos
94166>>>>>>>>>            Move (Mid(sLine, Length(sLine), (iPos +1))) to LineComponents.sToStatement
94167>>>>>>>>>            Move (Replace(LineComponents.sToStatement, sLine, "")) to sLine
94168>>>>>>>>>            Move (Replace((CS_To) + " ", LineComponents.sToStatement, "")) to LineComponents.sToStatement
94169>>>>>>>>>            Move (Trim(LineComponents.sToStatement)) to LineComponents.sToStatement
94170>>>>>>>>>        End
94170>>>>>>>>>>
94170>>>>>>>>>        
94170>>>>>>>>>        // Get the " of xxxx " part
94170>>>>>>>>>        Move (Lowercase(sLine)) to sText
94171>>>>>>>>>        Move (sText contains (" " + Lowercase(CS_Of) + " ")) to bOfStatement
94172>>>>>>>>>        If (bOfStatement = True) Begin
94174>>>>>>>>>            Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sLine))) to iPos
94175>>>>>>>>>            Move (Mid(sLine, (Length(sLine) -1), (iPos + Length(CS_Of) + 1))) to LineComponents.sOfStatement
94176>>>>>>>>>            Move (Left(sLine, (iPos - 1))) to sLine
94177>>>>>>>>>            Move (Trim(LineComponents.sOfStatement)) to LineComponents.sOfStatement
94178>>>>>>>>>        End    
94178>>>>>>>>>>
94178>>>>>>>>>        
94178>>>>>>>>>        // The reminder of the code line
94178>>>>>>>>>        Move (Trim(sLine)) to LineComponents.sCode
94179>>>>>>>>>                                      
94179>>>>>>>>>        Function_Return LineComponents
94180>>>>>>>>>    End_Function       
94181>>>>>>>>>    
94181>>>>>>>>>    // Helper function.
94181>>>>>>>>>    Function _BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
94183>>>>>>>>>        Boolean bChanged
94183>>>>>>>>>        Integer iPos
94183>>>>>>>>>        String  sLineIndent
94183>>>>>>>>>        String  sIndent
94183>>>>>>>>>        String  sLine1 sLine2
94183>>>>>>>>>        String  sText
94183>>>>>>>>>
94183>>>>>>>>>        Move False to bChanged
94184>>>>>>>>>        Move (Lowercase(sLine)) to sText
94185>>>>>>>>>        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
94186>>>>>>>>>        Move (Repeat(" ", iLineIndent)) to sLineIndent
94187>>>>>>>>>        Get _OverstrikeStrings sText to sText
94188>>>>>>>>>        Get _FindFirstCommand sText to iPos
94189>>>>>>>>>        If (iPos <> 0) Begin
94191>>>>>>>>>            Move True to bChanged
94192>>>>>>>>>            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
94194>>>>>>>>>                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
94195>>>>>>>>>            End
94195>>>>>>>>>>
94195>>>>>>>>>            Else If (eSplitBy = eSplitBySemiColumn) Begin
94198>>>>>>>>>                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
94199>>>>>>>>>            End
94199>>>>>>>>>>
94199>>>>>>>>>            Else If (eSplitBy = eSplitByBeginEnd) Begin
94202>>>>>>>>>                Move (Insert((" Begin" + CS_CRLF + sLineIndent + sIndent), sLine, iPos)) to sLine
94203>>>>>>>>>                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
94204>>>>>>>>>            End
94204>>>>>>>>>>
94204>>>>>>>>>
94204>>>>>>>>>            // Remove any spaces before the point on which we break the line
94204>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine1
94205>>>>>>>>>            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
94206>>>>>>>>>            Move (RTrim(sLine1)) to sLine1
94207>>>>>>>>>            Move (sLine1 + sLine2) to sLine
94208>>>>>>>>>        End
94208>>>>>>>>>>
94208>>>>>>>>>        Function_Return bChanged
94209>>>>>>>>>    End_Function
94210>>>>>>>>>
94210>>>>>>>>>    // Takes a string like: [not Seqeof] Begin
94210>>>>>>>>>    // and returns struct as: True, True, "(not(Seqeof))" and "Begin",
94210>>>>>>>>>    //   _but_ it doesn't do anything with a line that starts with a [Select] stetement;
94210>>>>>>>>>    //   "[Select] Indicate Select as Windowindex Eq Fieldindex"
94210>>>>>>>>>    // Note: The brackets _must_ be at the start of code line.
94210>>>>>>>>>    //       bHasBracket denotes that the line starts with a "[", bHasNot denotes that the expression has a "not" in it.
94210>>>>>>>>>    Function _ExtractIndicatorContent String sLine Returns tBooleanIndicator
94212>>>>>>>>>        Integer iPos                                             
94212>>>>>>>>>        String sText sChar sNot sBoolean sFirstWord sCommand sExpression
94212>>>>>>>>>        Boolean bRightSideIndicator bFound bIndicateWord
94212>>>>>>>>>        tBooleanIndicator BooleanIndicator  
94212>>>>>>>>>        tBooleanIndicator BooleanIndicator  
94212>>>>>>>>>        tOperatorsInfo OperatorsInfo
94212>>>>>>>>>        tOperatorsInfo OperatorsInfo
94212>>>>>>>>>        
94212>>>>>>>>>        Move False to BooleanIndicator.bHasBracket
94213>>>>>>>>>        Move False to BooleanIndicator.bHasNot
94214>>>>>>>>>        Move ""    to BooleanIndicator.sCode
94215>>>>>>>>>        Move ""    to BooleanIndicator.sExpression
94216>>>>>>>>>        
94216>>>>>>>>>        Get IsIndicatorStatement sLine to bFound
94217>>>>>>>>>        Move (Lowercase(sLine) contains Lowercase(CS_Indicate)) to bIndicateWord
94218>>>>>>>>>        If (bFound = False and bIndicateWord = False) Begin
94220>>>>>>>>>            Function_Return BooleanIndicator
94221>>>>>>>>>        End
94221>>>>>>>>>>
94221>>>>>>>>>        Move (Trim(sLine)) to sText 
94222>>>>>>>>>        Get _OverstrikeStrings sText to sText
94223>>>>>>>>>        Move (sText contains "[" and sText contains "]") to BooleanIndicator.bHasBracket  
94224>>>>>>>>>        
94224>>>>>>>>>        Move "" to sNot
94225>>>>>>>>>        Get _RetrieveFirstWord sText to sFirstWord
94226>>>>>>>>>        // Is the indicator placed on the right hand side of the command?
94226>>>>>>>>>        Move (Pos("[", sFirstWord) = 0) to bRightSideIndicator
94227>>>>>>>>>        If (bRightSideIndicator = True) Begin
94229>>>>>>>>>            Move (Pos("[", sText)) to iPos
94230>>>>>>>>>            Move (Mid(sText, Length(sText), iPos)) to sBoolean
94231>>>>>>>>>        End
94231>>>>>>>>>>
94231>>>>>>>>>        Else Begin
94232>>>>>>>>>            Move (Pos("]", sText)) to iPos
94233>>>>>>>>>            If (iPos <> 0) Begin
94235>>>>>>>>>                Move (Left(sText, iPos)) to sBoolean 
94236>>>>>>>>>                Move (Mid(sText, Length(sText), (iPos + 1))) to sFirstWord
94237>>>>>>>>>                Move sFirstWord to BooleanIndicator.sCode
94238>>>>>>>>>            End
94238>>>>>>>>>>
94238>>>>>>>>>        End
94238>>>>>>>>>>
94238>>>>>>>>>        Move (Trim(sFirstWord)) to sCommand
94239>>>>>>>>>        Move (Replaces("[", sBoolean, "")) to sBoolean
94240>>>>>>>>>        Move (Replaces("]", sBoolean, "")) to sBoolean
94241>>>>>>>>>        Move (Trim(sBoolean)) to sBoolean
94242>>>>>>>>>
94242>>>>>>>>>        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
94243>>>>>>>>>        If (iPos <> 0) Begin
94245>>>>>>>>>            Move (Mid(sBoolean, Length(sBoolean), (iPos + 4))) to sBoolean
94246>>>>>>>>>            Move (String(CS_Not)) to sNot
94247>>>>>>>>>        End                    
94247>>>>>>>>>>
94247>>>>>>>>>        If (sNot <> "") Begin
94249>>>>>>>>>            Move ("(" + String(sBoolean) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression 
94250>>>>>>>>>            Move True to BooleanIndicator.bHasNot
94251>>>>>>>>>        End 
94251>>>>>>>>>>
94251>>>>>>>>>        Else If (Lowercase(sBoolean) = Lowercase(CS_Finderr)) Begin
94254>>>>>>>>>            Move ("(" + CS_Found * " = " * CS_False + ")") to BooleanIndicator.sExpression
94255>>>>>>>>>        End
94255>>>>>>>>>>
94255>>>>>>>>>        Else Begin                
94256>>>>>>>>>            Get IsLogicalOperators sText to OperatorsInfo
94257>>>>>>>>>            If (OperatorsInfo.bIsOperator = True) Begin
94259>>>>>>>>>                Get _ExtractParenthesisExpression sText to BooleanIndicator.sExpression
94260>>>>>>>>>                If (BooleanIndicator.sExpression = "") Begin
94262>>>>>>>>>                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to BooleanIndicator.sExpression
94263>>>>>>>>>                End
94263>>>>>>>>>>
94263>>>>>>>>>//                Move True to BooleanIndicator.bHasNot 
94263>>>>>>>>>                Move sLine to sCommand
94264>>>>>>>>>            End
94264>>>>>>>>>>
94264>>>>>>>>>            Else Begin
94265>>>>>>>>>                Move ("(" + String(sBoolean) + ")") to BooleanIndicator.sExpression
94266>>>>>>>>>                Move False to BooleanIndicator.bHasNot
94267>>>>>>>>>            End
94267>>>>>>>>>>
94267>>>>>>>>>        End
94267>>>>>>>>>>
94267>>>>>>>>>        Move (Trim(sCommand)) to BooleanIndicator.sCode
94268>>>>>>>>>            
94268>>>>>>>>>        Function_Return BooleanIndicator
94269>>>>>>>>>    End_Function
94270>>>>>>>>>    
94270>>>>>>>>>    // Tries to find the first DataFlex command found in the passed string.
94270>>>>>>>>>    // Returns the starting pos of that same command (or 0 if not found).
94270>>>>>>>>>    Function _FindFirstCommand String sTest Returns Integer
94272>>>>>>>>>        Boolean bRemoved
94272>>>>>>>>>        Integer iCount iSize iPos iTest
94272>>>>>>>>>        String  sCommand
94272>>>>>>>>>        String[] asCommands
94273>>>>>>>>>
94273>>>>>>>>>        Move 0 to iPos
94274>>>>>>>>>        Move (" " + sTest) to sTest
94275>>>>>>>>>        Get _RemoveComments (&sTest) to bRemoved
94276>>>>>>>>>        Get paCommands to asCommands
94277>>>>>>>>>        Move (SizeOfArray(asCommands)) to iSize
94278>>>>>>>>>        If (iSize = 0) Begin
94280>>>>>>>>>            Send AddAllCommands
94281>>>>>>>>>            Get paCommands to asCommands
94282>>>>>>>>>            Move (SizeOfArray(asCommands)) to iSize        
94283>>>>>>>>>        End
94283>>>>>>>>>>
94283>>>>>>>>>        Decrement iSize
94284>>>>>>>>>        For iCount from 0 to iSize
94290>>>>>>>>>>
94290>>>>>>>>>            Move asCommands[iCount] to sCommand
94291>>>>>>>>>            Move (Pos(" " + Lowercase(sCommand), Lowercase(sTest))) to iTest // The command MUST start with a space and MIGHT end with a space.
94292>>>>>>>>>            If (iTest <> 0) Begin
94294>>>>>>>>>                If (iPos = 0) Begin
94296>>>>>>>>>                    Move iTest to iPos
94297>>>>>>>>>                End
94297>>>>>>>>>>
94297>>>>>>>>>                Else Begin
94298>>>>>>>>>                    If (iTest < iPos) Begin
94300>>>>>>>>>                        Move iTest to iPos
94301>>>>>>>>>                    End
94301>>>>>>>>>>
94301>>>>>>>>>                End
94301>>>>>>>>>>
94301>>>>>>>>>            End
94301>>>>>>>>>>
94301>>>>>>>>>        Loop              
94302>>>>>>>>>>
94302>>>>>>>>>        // We added a beginning " " at the top of this function, so adjust for that now.
94302>>>>>>>>>//        If (iPos = 1) Begin
94302>>>>>>>>>//            Move 0 to iPos
94302>>>>>>>>>//        End
94302>>>>>>>>>        Function_Return iPos
94303>>>>>>>>>    End_Function
94304>>>>>>>>>    
94304>>>>>>>>>    // Parses the method name from the string
94304>>>>>>>>>    Function _MethodName String sMethod Returns String
94306>>>>>>>>>        Integer iPos
94306>>>>>>>>>        Get _RemoveFirstWord sMethod to sMethod
94307>>>>>>>>>        Move (Right(sMethod, (Length(sMethod) - iPos))) to sMethod
94308>>>>>>>>>        If (Uppercase(Left(Trim(sMethod), 4)) = "SET ") Begin
94310>>>>>>>>>            Get _RemoveFirstWord sMethod to sMethod
94311>>>>>>>>>        End
94311>>>>>>>>>>
94311>>>>>>>>>        // Remove any trailing arguments
94311>>>>>>>>>        Move (Pos(" ", sMethod)) to iPos
94312>>>>>>>>>        Function_Return (Left(sMethod, (iPos - 1)))
94313>>>>>>>>>    End_Function
94314>>>>>>>>>
94314>>>>>>>>>    // For declarations like "string [] saAddress"
94314>>>>>>>>>    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
94316>>>>>>>>>        Boolean bChanged
94316>>>>>>>>>        String sText
94316>>>>>>>>>        Move sLine to sText
94317>>>>>>>>>        While (Pos(" [", sText) > 0)
94321>>>>>>>>>          Move (Replace(" [", sText, "[")) to sText
94322>>>>>>>>>        Loop                                       
94323>>>>>>>>>>
94323>>>>>>>>>        Move (sLine = sText) to bChanged
94324>>>>>>>>>        Function_Return bChanged
94325>>>>>>>>>    End_Function
94326>>>>>>>>>
94326>>>>>>>>>    //  This will pad out the strings in a line and overstrike them
94326>>>>>>>>>    //  with _ characters for a "string" and + characters for a 'string'
94326>>>>>>>>>    Function _OverstrikeStrings String sLine Returns String
94328>>>>>>>>>        Boolean bDoubleQuote bSingleQuote bChanged
94328>>>>>>>>>        Integer iChar iLength
94328>>>>>>>>>        String  sChar sText
94328>>>>>>>>>
94328>>>>>>>>>        Move False to bChanged 
94329>>>>>>>>>        Move sLine to sText
94330>>>>>>>>>        Move (Length(sText)) to iLength
94331>>>>>>>>>        For iChar from 1 to iLength
94337>>>>>>>>>>
94337>>>>>>>>>            Move (Mid(sText, 1, iChar)) to sChar
94338>>>>>>>>>            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
94340>>>>>>>>>                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
94341>>>>>>>>>                Move True to bChanged
94342>>>>>>>>>                Move " " to sChar
94343>>>>>>>>>            End
94343>>>>>>>>>>
94343>>>>>>>>>            If (bDoubleQuote and sChar= '"') Begin
94345>>>>>>>>>                Move (Overstrike("_", sText, iChar)) to sText
94346>>>>>>>>>                Move True to bChanged
94347>>>>>>>>>                Move "" to sChar
94348>>>>>>>>>                Move False to bDoubleQuote
94349>>>>>>>>>            End
94349>>>>>>>>>>
94349>>>>>>>>>            If (bSingleQuote and sChar = "'") Begin
94351>>>>>>>>>                Move (Overstrike("+", sText, iChar)) to sText
94352>>>>>>>>>                Move True to bChanged
94353>>>>>>>>>                Move "" to sChar
94354>>>>>>>>>                Move False to bSingleQuote
94355>>>>>>>>>            End
94355>>>>>>>>>>
94355>>>>>>>>>            If (bSingleQuote = False and sChar ='"') Begin
94357>>>>>>>>>                Move True to bDoubleQuote
94358>>>>>>>>>            End
94358>>>>>>>>>>
94358>>>>>>>>>            If (bDoubleQuote = False and sChar = "'") Begin
94360>>>>>>>>>                Move True to bSingleQuote
94361>>>>>>>>>            End
94361>>>>>>>>>>
94361>>>>>>>>>            If bDoubleQuote Begin
94363>>>>>>>>>                Move (Overstrike("_", sText, iChar)) to sText
94364>>>>>>>>>                Move True to bChanged
94365>>>>>>>>>            End
94365>>>>>>>>>>
94365>>>>>>>>>            Else If bSingleQuote Begin
94368>>>>>>>>>                Move (Overstrike("+", sText, iChar)) to sText
94369>>>>>>>>>                Move True to bChanged
94370>>>>>>>>>            End
94370>>>>>>>>>>
94370>>>>>>>>>        Loop
94371>>>>>>>>>>
94371>>>>>>>>>
94371>>>>>>>>>        If (bChanged = True) Begin
94373>>>>>>>>>            Move sText to sLine
94374>>>>>>>>>        End
94374>>>>>>>>>>
94374>>>>>>>>>        Function_Return sLine
94375>>>>>>>>>    End_Function
94376>>>>>>>>>
94376>>>>>>>>>    Function _RemoveComments String ByRef sLine Returns Boolean
94378>>>>>>>>>        Boolean bRemoved
94378>>>>>>>>>        Integer iPos
94378>>>>>>>>>
94378>>>>>>>>>        Move False to bRemoved
94379>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
94380>>>>>>>>>        If (iPos > 0) Begin
94382>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine
94383>>>>>>>>>            Move True to bRemoved
94384>>>>>>>>>        End
94384>>>>>>>>>>
94384>>>>>>>>>        Function_Return bRemoved
94385>>>>>>>>>    End_Function    
94386>>>>>>>>>
94386>>>>>>>>>    // Returns an end comment if exists. It also removes the end comment
94386>>>>>>>>>    // from the passed string.
94386>>>>>>>>>    Function _RemoveEndComment String sLine Returns String
94388>>>>>>>>>        Integer iPos
94388>>>>>>>>>        String sTest
94388>>>>>>>>>
94388>>>>>>>>>        Move (Trim(sLine)) to sTest
94389>>>>>>>>>        Move (Pos(CS_CommentSymbol, sTest)) to iPos
94390>>>>>>>>>        // Only remove comment if the line is not commented at the beginning.
94390>>>>>>>>>        If (iPos > 1) Begin
94392>>>>>>>>>            Move (Pos(CS_CommentSymbol, sLine)) to iPos
94393>>>>>>>>>            Move (Left(sLine, iPos - 1)) to sLine
94394>>>>>>>>>        End
94394>>>>>>>>>>
94394>>>>>>>>>        Function_Return sLine
94395>>>>>>>>>    End_Function
94396>>>>>>>>>
94396>>>>>>>>>    // Removes the first word of any input string
94396>>>>>>>>>    // all up to the first space encountered
94396>>>>>>>>>    Function _RemoveFirstWord String sLine Returns String
94398>>>>>>>>>        Integer iPos
94398>>>>>>>>>        Boolean bChanged
94398>>>>>>>>>        Move (Trim(sLine)) to sLine
94399>>>>>>>>>        Get _NormalizeArrayNotation (&sLine) to bChanged
94400>>>>>>>>>        Move (Pos(" ", sLine)) to iPos
94401>>>>>>>>>        Function_Return (Right(sLine, (Length(sLine) - iPos)))
94402>>>>>>>>>    End_Function
94403>>>>>>>>>
94403>>>>>>>>>    // Returns the first word of any input string
94403>>>>>>>>>    // all up to the first space encountered
94403>>>>>>>>>    Function _RetrieveFirstWord String sLine Returns String
94405>>>>>>>>>        String sFirstWord
94405>>>>>>>>>        Boolean bChanged
94405>>>>>>>>>        Get _RemoveFirstWord sLine            to sFirstWord
94406>>>>>>>>>        Move (Replace(sFirstWord, sLine, "")) to sFirstWord
94407>>>>>>>>>        Move (Trim(sFirstWord))               to sFirstWord
94408>>>>>>>>>        Get _NormalizeArrayNotation (&sFirstWord) to bChanged
94409>>>>>>>>>        Function_Return sFirstWord
94410>>>>>>>>>    End_Function
94411>>>>>>>>>
94411>>>>>>>>>    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
94411>>>>>>>>>    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
94411>>>>>>>>>    // RemoveLeft("D", "ABC")                   -> "ABC"
94411>>>>>>>>>    // RemoveLeft("is ", "This is an example")  -> "an example"    
94411>>>>>>>>>    // Note: It it also looks within strings aka "This is a string"
94411>>>>>>>>>    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
94413>>>>>>>>>        Integer iPosStart iPosEnd 
94413>>>>>>>>>        String sText
94413>>>>>>>>>        
94413>>>>>>>>>        Move sHostString to sText
94414>>>>>>>>>        Move (Pos(sSubString, sText)) to iPosStart
94415>>>>>>>>>        Move (iPosStart + Length(sSubString) - 1) to iPosEnd
94416>>>>>>>>>
94416>>>>>>>>>        If (iPosStart) Begin                                
94418>>>>>>>>>            If (iPosEnd = Length(sText)) Begin
94420>>>>>>>>>                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
94421>>>>>>>>>            End 
94421>>>>>>>>>>
94421>>>>>>>>>            Else Begin
94422>>>>>>>>>                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
94423>>>>>>>>>            End
94423>>>>>>>>>>
94423>>>>>>>>>        End                                              
94423>>>>>>>>>>
94423>>>>>>>>>        
94423>>>>>>>>>        Function_Return (sHostString <> sText)
94424>>>>>>>>>    End_Function
94425>>>>>>>>>
94425>>>>>>>>>    // Helper function
94425>>>>>>>>>    Function _RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
94427>>>>>>>>>        Boolean bChanged
94427>>>>>>>>>        String sText
94427>>>>>>>>>        Integer iPos
94427>>>>>>>>>
94427>>>>>>>>>        Move False to bChanged
94428>>>>>>>>>        Move (LTrim(sLine))     to sText
94429>>>>>>>>>        Move (Left(sText, 9))   to sText
94430>>>>>>>>>        Move (Lowercase(sText)) to sText
94431>>>>>>>>>        If (sText = "property ") Begin
94433>>>>>>>>>            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
94434>>>>>>>>>            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
94435>>>>>>>>>            If (iPos = 0) Begin // if there's a tab char instead of a space then..
94437>>>>>>>>>                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
94438>>>>>>>>>            End
94438>>>>>>>>>>
94438>>>>>>>>>            If (iPos > 0) Begin
94440>>>>>>>>>                Move (Overstrike(Repeat(" ", Length(sPubPriv)), sLine, iPos + 1)) to sLine // skip first character, don't overwrite a tab with a space
94441>>>>>>>>>                Move True to bChanged
94442>>>>>>>>>            End
94442>>>>>>>>>>
94442>>>>>>>>>        End
94442>>>>>>>>>>
94442>>>>>>>>>        Function_Return bChanged
94443>>>>>>>>>    End_Function
94444>>>>>>>>>
94444>>>>>>>>>    // helper function for IsKeywordInLine, when a keyword is found in a string declaration
94444>>>>>>>>>    Function _RemoveStringsFromLine String sLine Returns String
94446>>>>>>>>>        Integer iLength iPos
94446>>>>>>>>>        Boolean bSep1 bSep2
94446>>>>>>>>>        String  sChar sSep1 sSep2 sReturn
94446>>>>>>>>>
94446>>>>>>>>>        Move False to bSep1
94447>>>>>>>>>        Move False to bSep2
94448>>>>>>>>>        Move "'" to sSep1
94449>>>>>>>>>        Move '"' to sSep2
94450>>>>>>>>>        Move ""  to sReturn
94451>>>>>>>>>        Move (Length(sLine)) to iLength
94452>>>>>>>>>
94452>>>>>>>>>        For iPos from 1 to iLength
94458>>>>>>>>>>
94458>>>>>>>>>            Move (Mid(sLine, 1, iPos)) to sChar
94459>>>>>>>>>            If (bSep1 = False and bSep2 = False) Begin
94461>>>>>>>>>                If (sChar = sSep1) Begin
94463>>>>>>>>>                    Move True to bSep1
94464>>>>>>>>>                End
94464>>>>>>>>>>
94464>>>>>>>>>                Else If (sChar = sSep2) Begin
94467>>>>>>>>>                    Move True to bSep2
94468>>>>>>>>>                End
94468>>>>>>>>>>
94468>>>>>>>>>                If (bSep1 = False and bSep2 = False) Begin
94470>>>>>>>>>                    Move (sReturn + sChar) to sReturn
94471>>>>>>>>>                End
94471>>>>>>>>>>
94471>>>>>>>>>            End
94471>>>>>>>>>>
94471>>>>>>>>>            Else Begin
94472>>>>>>>>>                If (bSep1) Begin
94474>>>>>>>>>                    If (sChar = sSep1) Begin
94476>>>>>>>>>                        Move False to bSep1
94477>>>>>>>>>                    End
94477>>>>>>>>>>
94477>>>>>>>>>                End
94477>>>>>>>>>>
94477>>>>>>>>>                Else If (bSep2) Begin
94480>>>>>>>>>                    If (sChar = sSep2) Begin
94482>>>>>>>>>                        Move False to bSep2
94483>>>>>>>>>                    End
94483>>>>>>>>>>
94483>>>>>>>>>                End
94483>>>>>>>>>>
94483>>>>>>>>>            End
94483>>>>>>>>>>
94483>>>>>>>>>        Loop
94484>>>>>>>>>>
94484>>>>>>>>>
94484>>>>>>>>>        Function_Return sReturn
94485>>>>>>>>>    End_Function
94486>>>>>>>>>
94486>>>>>>>>>    Function _SingleCommandSyntaxToFunction String ByRef sLine String sKeyWord Returns Boolean
94488>>>>>>>>>        Boolean bChanged bIsCommentOrBlank bFound bIfStatement bIsFirstKeyWord
94488>>>>>>>>>        tCodeComponents CodeComponents
94488>>>>>>>>>        tCodeComponents CodeComponents
94488>>>>>>>>>        String sText sLowerKeyWord sLowerCase sFirstWord sExpression
94488>>>>>>>>>        Integer iPos
94488>>>>>>>>>        
94488>>>>>>>>>        Move False to bChanged
94489>>>>>>>>>        Move False to bIsFirstKeyWord  
94490>>>>>>>>>        Move "" to sExpression
94491>>>>>>>>>        Move sLine to sText
94492>>>>>>>>>        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
94493>>>>>>>>>        If (bIsCommentOrBlank = True) Begin
94495>>>>>>>>>            Function_Return False
94496>>>>>>>>>        End      
94496>>>>>>>>>>
94496>>>>>>>>>        
94496>>>>>>>>>        Get HasCommand sText sKeyWord to bFound
94497>>>>>>>>>        If (bFound = False) Begin
94499>>>>>>>>>            Function_Return False
94500>>>>>>>>>        End
94500>>>>>>>>>>
94500>>>>>>>>>        
94500>>>>>>>>>        Get IsIfCommand sText to bIfStatement
94501>>>>>>>>>        Move (Lowercase(sKeyWord)) to sLowerKeyWord
94502>>>>>>>>>        If (bIfStatement = False) Begin
94504>>>>>>>>>            Get _RetrieveFirstWord sText to sFirstWord
94505>>>>>>>>>            If (Lowercase(sFirstWord) = Lowercase(sKeyWord)) Begin
94507>>>>>>>>>                Get _RemoveFirstWord sText to sText
94508>>>>>>>>>            End    
94508>>>>>>>>>>
94508>>>>>>>>>//            If (Lowercase(sFirstWord) <> sLowerKeyWord) Begin
94508>>>>>>>>>//                Function_Return False
94508>>>>>>>>>//            End
94508>>>>>>>>>        End
94508>>>>>>>>>>
94508>>>>>>>>>        If (bIfStatement = True) Begin
94510>>>>>>>>>            Get ExpressionExtractor sText CI_LeftExpression to sExpression  
94511>>>>>>>>>            If (Trim(sExpression) <> "") Begin
94513>>>>>>>>>                Move (Pos(sExpression, sText)) to iPos
94514>>>>>>>>>                Move (Mid(sText, Length(sText), (iPos + Length(sExpression)))) to sText
94515>>>>>>>>>                Move (Mid(sLine, Length(sLine), (iPos + Length(sExpression)))) to sLine
94516>>>>>>>>>            End
94516>>>>>>>>>>
94516>>>>>>>>>            // Do we still have the keyword in the line?
94516>>>>>>>>>            Get HasCommand sText sKeyWord to bFound
94517>>>>>>>>>            If (bFound = False) Begin   
94519>>>>>>>>>                Move (String(sExpression) + String(sLine)) to sLine 
94520>>>>>>>>>                If (bIfStatement = True) Begin
94522>>>>>>>>>                    Move (CS_If * String(sLine)) to sLine
94523>>>>>>>>>                End
94523>>>>>>>>>>
94523>>>>>>>>>                Function_Return False
94524>>>>>>>>>            End
94524>>>>>>>>>>
94524>>>>>>>>>        End
94524>>>>>>>>>>
94524>>>>>>>>>        
94524>>>>>>>>>//        Move (Pos(sLowerKeyWord, Lowercase(sText))) to iPos
94524>>>>>>>>>        Move sLine to sText
94525>>>>>>>>>        Get Tokenizer sText to CodeComponents
94526>>>>>>>>>        
94526>>>>>>>>>        // If the line starts with the Key word.
94526>>>>>>>>>//        If (Pos(sLowerKeyWord, Lowercase(CodeComponents.sCode)) = 1) Begin
94526>>>>>>>>>//            Move (sLowerKeyWord + " ") to sLowerKeyWord
94526>>>>>>>>>//        End                                  
94526>>>>>>>>>//        Else Begin
94526>>>>>>>>>//            Move (" " + String(sLowerKeyWord) + " ") to sLowerKeyWord
94526>>>>>>>>>//        End
94526>>>>>>>>>//        Move (Lowercase(CodeComponents.sCode) contains sLowerKeyWord) to bFound
94526>>>>>>>>>        Get _RetrieveFirstWord sText to sFirstWord
94527>>>>>>>>>        Move (Lowercase(sFirstWord) = Lowercase(sKeyWord)) to bFound
94528>>>>>>>>>        If (bFound = False) Begin      
94530>>>>>>>>>//            If (sExpression <> "") Begin
94530>>>>>>>>>//                Move (CS_If * String(sExpression) + String(sLine)) to sLine
94530>>>>>>>>>//            End
94530>>>>>>>>>            Function_Return False
94531>>>>>>>>>        End
94531>>>>>>>>>>
94531>>>>>>>>>        
94531>>>>>>>>>        Move (Lowercase(CodeComponents.sCode)) to sText
94532>>>>>>>>>        Move (Mid(CodeComponents.sCode, (Length(CodeComponents.sCode)), (Length(sKeyWord) + 1))) to sText
94533>>>>>>>>>        Move (Ltrim(sText)) to sText   
94534>>>>>>>>>        If (sKeyWord = CS_Pos) Begin
94536>>>>>>>>>            Move (Lowercase(sText)) to sLowerCase
94537>>>>>>>>>            Move (Pos(" in ", sLowerCase)) to iPos
94538>>>>>>>>>            If (iPos <> 0) Begin
94540>>>>>>>>>                Move (Overstrike("____", sText, iPos)) to sText
94541>>>>>>>>>                Move (Replace("____", sText, ", ")) to sText
94542>>>>>>>>>                Move True to bChanged
94543>>>>>>>>>            End
94543>>>>>>>>>>
94543>>>>>>>>>        End                                                                                                                              
94543>>>>>>>>>>
94543>>>>>>>>>        If (Length(CodeComponents.sRightComment)  > 0) Begin
94545>>>>>>>>>            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
94546>>>>>>>>>            Move True to bChanged
94547>>>>>>>>>        End
94547>>>>>>>>>>
94547>>>>>>>>>        Else Begin
94548>>>>>>>>>            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
94549>>>>>>>>>            Move True to bChanged
94550>>>>>>>>>        End
94550>>>>>>>>>>
94550>>>>>>>>>        
94550>>>>>>>>>        Function_Return bChanged
94551>>>>>>>>>    End_Function
94552>>>>>>>>>
94552>>>>>>>>>    // Helper function. This is a list of commands that also exists as global build in functions.
94552>>>>>>>>>    Function _TestCommandFunctions String sTest Returns Integer
94554>>>>>>>>>        Boolean bRemoved
94554>>>>>>>>>        Integer iCount iSize iPos iTest
94554>>>>>>>>>        String  sCommand
94554>>>>>>>>>        String[] asCommandFunctions
94555>>>>>>>>>
94555>>>>>>>>>        Move 0 to iPos
94556>>>>>>>>>        Get _RemoveComments (&sTest) to bRemoved
94557>>>>>>>>>        Get paCommandFunctions to asCommandFunctions
94558>>>>>>>>>        Move (SizeOfArray(asCommandFunctions)) to iSize
94559>>>>>>>>>        If (iSize = 0) Begin
94561>>>>>>>>>            Send AddAllCommandFunctions
94562>>>>>>>>>            Get paCommandFunctions to asCommandFunctions
94563>>>>>>>>>            Move (SizeOfArray(asCommandFunctions)) to iSize        
94564>>>>>>>>>        End
94564>>>>>>>>>>
94564>>>>>>>>>        Decrement iSize
94565>>>>>>>>>        For iCount from 0 to iSize
94571>>>>>>>>>>
94571>>>>>>>>>            Move asCommandFunctions[iCount] to sCommand
94572>>>>>>>>>            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
94573>>>>>>>>>            If (iTest <> 0) Begin
94575>>>>>>>>>                If (iPos = 0) Begin
94577>>>>>>>>>                    Move iTest to iPos
94578>>>>>>>>>                End
94578>>>>>>>>>>
94578>>>>>>>>>                Else Begin
94579>>>>>>>>>                    If (iTest < iPos) Begin
94581>>>>>>>>>                        Move iTest to iPos
94582>>>>>>>>>                    End
94582>>>>>>>>>>
94582>>>>>>>>>                End
94582>>>>>>>>>>
94582>>>>>>>>>            End
94582>>>>>>>>>>
94582>>>>>>>>>        Loop
94583>>>>>>>>>>
94583>>>>>>>>>
94583>>>>>>>>>        Function_Return iPos
94584>>>>>>>>>    End_Function
94585>>>>>>>>>
94585>>>>>>>>>    Function HasDoubleExpression String sLine Returns Boolean
94587>>>>>>>>>        Boolean bFound      
94587>>>>>>>>>        Integer iCount iSize iOpCount iParanthesis
94587>>>>>>>>>        String sChar sOperators
94587>>>>>>>>>        
94587>>>>>>>>>        Move False to bFound  
94588>>>>>>>>>        Move 0 to iParanthesis           
94589>>>>>>>>>        Move "<=>" to sOperators
94590>>>>>>>>>        Move (Length(sLine)) to iSize
94591>>>>>>>>>        For iCount from 1 to iSize
94597>>>>>>>>>>
94597>>>>>>>>>            Move (Mid(sLine, 1, iCount)) to sChar
94598>>>>>>>>>            If (sChar = "(") Begin
94600>>>>>>>>>                Increment iOpCount          
94601>>>>>>>>>                Increment iParanthesis
94602>>>>>>>>>            End
94602>>>>>>>>>>
94602>>>>>>>>>            If (sChar = ")") Begin
94604>>>>>>>>>                Decrement iOpCount
94605>>>>>>>>>            End
94605>>>>>>>>>>
94605>>>>>>>>>            If (iParanthesis <> 0 and sOperators contains sChar) Begin
94607>>>>>>>>>                If (iOpCount = 0) Begin
94609>>>>>>>>>                    Move True to bFound
94610>>>>>>>>>                    Move iSize to iCount // We're done.
94611>>>>>>>>>                End
94611>>>>>>>>>>
94611>>>>>>>>>            End
94611>>>>>>>>>>
94611>>>>>>>>>        Loop
94612>>>>>>>>>>
94612>>>>>>>>>        
94612>>>>>>>>>        Function_Return bFound
94613>>>>>>>>>    End_Function
94614>>>>>>>>>    
94614>>>>>>>>>    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
94614>>>>>>>>>    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
94614>>>>>>>>>    Function HasCommand String sLine String sCommand Returns Boolean
94616>>>>>>>>>        Boolean bFound bOk
94616>>>>>>>>>        String sText
94616>>>>>>>>>        
94616>>>>>>>>>        Move False to bFound 
94617>>>>>>>>>        Move sLine to sText
94618>>>>>>>>>        Get _RemoveComments (&sText) to bOK
94619>>>>>>>>>//        Move (Trim(sText)) to sText
94619>>>>>>>>>        Get _OverstrikeStrings sText to sText
94620>>>>>>>>>        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound
94621>>>>>>>>>        
94621>>>>>>>>>        Function_Return bFound
94622>>>>>>>>>    End_Function
94623>>>>>>>>>    
94623>>>>>>>>>    // Returns True iif the source line contains a "Begin" statement.
94623>>>>>>>>>    Function IsBeginStatement String sLine Returns Boolean
94625>>>>>>>>>        Boolean bFound
94625>>>>>>>>>        Get HasCommand sLine (" " + CS_Begin) to bFound
94626>>>>>>>>>        Function_Return bFound
94627>>>>>>>>>    End_Function   
94628>>>>>>>>>    
94628>>>>>>>>>    Function IsBlankLine String sLine Returns Boolean
94630>>>>>>>>>        Boolean bIsBlank
94630>>>>>>>>>        
94630>>>>>>>>>        Move False to bIsBlank
94631>>>>>>>>>        Move (Trim(sLine)) to sLine
94632>>>>>>>>>        If (Length(sLine) = 0) Begin
94634>>>>>>>>>            Move True to bIsBlank
94635>>>>>>>>>        End
94635>>>>>>>>>>
94635>>>>>>>>>        
94635>>>>>>>>>        Function_Return bIsBlank        
94636>>>>>>>>>    End_Function
94637>>>>>>>>>    
94637>>>>>>>>>    Function IsCommentLine String sLine Returns Boolean
94639>>>>>>>>>        Boolean bIsComment
94639>>>>>>>>>        Integer iPos
94639>>>>>>>>>        
94639>>>>>>>>>        Move False to bIsComment
94640>>>>>>>>>//        Move (Trim(sLine)) to sLine
94640>>>>>>>>>//        Move (Pos(CS_CommentSymbol, sLine)) to iPos
94640>>>>>>>>>//        If (iPos = 1) Begin
94640>>>>>>>>>//            Move True to bIsComment
94640>>>>>>>>>//        End
94640>>>>>>>>>        // Replaces all quotes string contents to "_" so we don't get false positives.
94640>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
94641>>>>>>>>>        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment
94642>>>>>>>>>        
94642>>>>>>>>>        Function_Return bIsComment
94643>>>>>>>>>    End_Function
94644>>>>>>>>>
94644>>>>>>>>>    // Returns True if this is a comment line with "//" to the left,
94644>>>>>>>>>    // or if the line is blank.
94644>>>>>>>>>    Function IsCommentLineOrBlank String sLine Returns Boolean
94646>>>>>>>>>        Boolean bIsComment bIsBlank
94646>>>>>>>>>        
94646>>>>>>>>>        Get IsCommentLine sLine to bIsComment
94647>>>>>>>>>        Get IsBlankLine sLine to bIsBlank
94648>>>>>>>>>        
94648>>>>>>>>>        Function_Return (bIsComment = True or bIsBlank = True)
94649>>>>>>>>>    End_Function
94650>>>>>>>>>
94650>>>>>>>>>    // Returns False if the first line in the passed file is _not_ an automatically generated
94650>>>>>>>>>    // COM wrapper file created by the Studio.
94650>>>>>>>>>    // If it returns True, we should not process that file.
94650>>>>>>>>>    Function IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
94652>>>>>>>>>        Boolean bIsDFCOMProxyClasses bExists        
94652>>>>>>>>>        Integer iCh iPos
94652>>>>>>>>>        String sLine
94652>>>>>>>>>        
94652>>>>>>>>>        Move False to bIsDFCOMProxyClasses  
94653>>>>>>>>>        File_Exist sFileName bExists
94654>>>>>>>>>        If (bExists = False) Begin
94656>>>>>>>>>            Error ("The file doesn't exist:" * String(sFileName))
94657>>>>>>>>>>
94657>>>>>>>>>            Function_Return False
94658>>>>>>>>>        End
94658>>>>>>>>>>
94658>>>>>>>>>        Get Seq_New_Channel to iCh
94659>>>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
94661>>>>>>>>>            Error "No Channel Available for Process: Procedure 'IsDataFlexCOMProxyClassesFile'"
94662>>>>>>>>>>
94662>>>>>>>>>            Function_Return False
94663>>>>>>>>>        End
94663>>>>>>>>>>
94663>>>>>>>>>        
94663>>>>>>>>>        Direct_Input channel iCh sFileName
94665>>>>>>>>>        Readln channel iCh sLine
94667>>>>>>>>>        Close_Input channel ich
94669>>>>>>>>>        Send Seq_Release_Channel iCh
94670>>>>>>>>>        Move (Trim(sLine)) to sLine
94671>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
94672>>>>>>>>>        If (iPos <> 1) Begin
94674>>>>>>>>>            Function_Return False
94675>>>>>>>>>        End
94675>>>>>>>>>>
94675>>>>>>>>>
94675>>>>>>>>>        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses
94676>>>>>>>>>        
94676>>>>>>>>>        Function_Return bIsDFCOMProxyClasses
94677>>>>>>>>>    End_Function
94678>>>>>>>>>    
94678>>>>>>>>>    // Returns True iif the source line starts with the sCommand statement.
94678>>>>>>>>>    Function IsFirstWord String sLine String sCommand Returns Boolean
94680>>>>>>>>>        Boolean bFound
94680>>>>>>>>>        Integer iPos  
94680>>>>>>>>>        String sFirstWord
94680>>>>>>>>>        
94680>>>>>>>>>        Move (Ltrim(Lowercase(sLine))) to sLine
94681>>>>>>>>>        Move (Ltrim(Lowercase(sCommand))) to sCommand
94682>>>>>>>>>        If (sLine = sCommand) Begin
94684>>>>>>>>>            Function_Return True
94685>>>>>>>>>        End
94685>>>>>>>>>>
94685>>>>>>>>>        Move (sCommand + " ") to sCommand
94686>>>>>>>>>        Move (Pos(" ", sLine)) to iPos
94687>>>>>>>>>        Move (Left(sLine, iPos)) to sFirstWord
94688>>>>>>>>>        Move (sFirstWord = sCommand) to bFound
94689>>>>>>>>>        Function_Return bFound
94690>>>>>>>>>    End_Function   
94691>>>>>>>>>    
94691>>>>>>>>>    // Returns True if source line contains a "[Found]", or "[FindErr]".
94691>>>>>>>>>    Function IsFoundOrFindErrIndicator String sLine Returns Boolean
94693>>>>>>>>>        Boolean bFound
94693>>>>>>>>>        Integer iLeft iRight iPos
94693>>>>>>>>>        String sText
94693>>>>>>>>>        
94693>>>>>>>>>        Get IsIndicatorStatement sLine to bFound
94694>>>>>>>>>        If (bFound = False) Begin
94696>>>>>>>>>            Function_Return False
94697>>>>>>>>>        End
94697>>>>>>>>>>
94697>>>>>>>>>
94697>>>>>>>>>        Get _RemoveComments (&sLine) to bFound
94698>>>>>>>>>        Get _OverstrikeStrings sLine to sText  
94699>>>>>>>>>        Send StripConcatenatingSpaces (&sText) sLine
94700>>>>>>>>>        Move (Pos("[", sLine)) to iLeft
94701>>>>>>>>>        Move (Pos("]", sLine)) to iRight
94702>>>>>>>>>        Move (Pos(("[" + Lowercase(CS_Found)), sLine)) to iPos
94703>>>>>>>>>        If (iPos = 0) Begin
94705>>>>>>>>>            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
94706>>>>>>>>>        End
94706>>>>>>>>>>
94706>>>>>>>>>        If (iPos = 0) Begin
94708>>>>>>>>>            Move (Pos(("[" + Lowercase(CS_Finderr)), sLine)) to iPos
94709>>>>>>>>>        End
94709>>>>>>>>>>
94709>>>>>>>>>        If (iPos = 0) Begin
94711>>>>>>>>>            Move (Pos((Lowercase(CS_Finderr) + "]"), sLine)) to iPos
94712>>>>>>>>>        End
94712>>>>>>>>>>
94712>>>>>>>>>            
94712>>>>>>>>>        Function_Return (iPos <> 0)    
94713>>>>>>>>>    End_Function
94714>>>>>>>>>    
94714>>>>>>>>>    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
94714>>>>>>>>>    // Note: The source line must first have been stripped of any comments
94714>>>>>>>>>    Function IsIfBeginStatement String sLine Returns Boolean
94716>>>>>>>>>        Boolean bisIfBegin bIsBeginStatement 
94716>>>>>>>>>        Get IsIfCommand sLine to bisIfBegin
94717>>>>>>>>>        Get IsBeginStatement sLine to bIsBeginStatement
94718>>>>>>>>>        Function_Return (bisIfBegin = True and bIsBeginStatement = True)
94719>>>>>>>>>    End_Function   
94720>>>>>>>>>    
94720>>>>>>>>>    Function IsIfCommand String sLine Returns Boolean
94722>>>>>>>>>        Boolean bFound
94722>>>>>>>>>        Get HasCommand sLine (CS_If + " ") to bFound
94723>>>>>>>>>        Function_Return bFound
94724>>>>>>>>>    End_Function                                                  
94725>>>>>>>>>    
94725>>>>>>>>>    Function IsImagePageStartOrEnd String sLine Boolean bCheckImageStart Returns Boolean
94727>>>>>>>>>        Boolean bFound
94727>>>>>>>>>        Integer iPos
94727>>>>>>>>>
94727>>>>>>>>>        Move False to bFound
94728>>>>>>>>>        Move (Trim(sLine)) to sLine
94729>>>>>>>>>        If (bCheckImageStart = True) Begin
94731>>>>>>>>>            Get IsImageStart sLine to bFound
94732>>>>>>>>>        End
94732>>>>>>>>>>
94732>>>>>>>>>        Else Begin
94733>>>>>>>>>            Move (Pos(CS_ImageNameEnd, sLine)) to iPos
94734>>>>>>>>>            If (iPos = 1) Begin
94736>>>>>>>>>                Move True to bFound
94737>>>>>>>>>            End
94737>>>>>>>>>>
94737>>>>>>>>>        End
94737>>>>>>>>>>
94737>>>>>>>>>
94737>>>>>>>>>        Function_Return bFound
94738>>>>>>>>>    End_Function
94739>>>>>>>>>
94739>>>>>>>>>    Function IsImageStart String sLine Returns Boolean
94741>>>>>>>>>        Boolean bIsChar
94741>>>>>>>>>        Integer iPos
94741>>>>>>>>>        String sChar
94741>>>>>>>>>
94741>>>>>>>>>        Move False to bIsChar
94742>>>>>>>>>        Move (Trim(sLine)) to sLine
94743>>>>>>>>>        Move (Pos(CS_ImageNameStart, sLine)) to iPos
94744>>>>>>>>>        If (iPos = 1) Begin
94746>>>>>>>>>            Move (Mid(sLine, 1, 2)) to sChar
94747>>>>>>>>>            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsChar
94748>>>>>>>>>        End
94748>>>>>>>>>>
94748>>>>>>>>>
94748>>>>>>>>>        Function_Return bIsChar
94749>>>>>>>>>    End_Function
94750>>>>>>>>>
94750>>>>>>>>>    // Returns True if source code contains both a "[" and a "]", but not a "[]"
94750>>>>>>>>>    Function IsIndicatorStatement String sLine Returns Boolean
94752>>>>>>>>>        Boolean bFound bIndicatorWord
94752>>>>>>>>>        Integer iLeft iRight iPos
94752>>>>>>>>>        String sChar sLeftBracket
94752>>>>>>>>>        
94752>>>>>>>>>        Get IsCommentLineOrBlank sLine to bFound
94753>>>>>>>>>        If (bFound = True) Begin
94755>>>>>>>>>            Function_Return False
94756>>>>>>>>>        End
94756>>>>>>>>>>
94756>>>>>>>>>        Get _RemoveComments (&sLine) to bFound
94757>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
94758>>>>>>>>>        Move (Left(sLine, 1)) to sChar
94759>>>>>>>>>        If (sChar = "[") Begin
94761>>>>>>>>>            Move "[" to sLeftBracket
94762>>>>>>>>>        End                         
94762>>>>>>>>>>
94762>>>>>>>>>        Else Begin
94763>>>>>>>>>            Move " [" to sLeftBracket
94764>>>>>>>>>        End
94764>>>>>>>>>>
94764>>>>>>>>>//        Move (Lowercase(sLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
94764>>>>>>>>>        Move (bIndicatorWord = True or (sLine contains sLeftBracket and sLine contains "]")) to bFound
94765>>>>>>>>>        If (bFound = True) Begin
94767>>>>>>>>>            Move (Pos(sLeftBracket, sLine)) to iLeft
94768>>>>>>>>>            Move (Pos("]", sLine)) to iRight
94769>>>>>>>>>            Move ((iRight - iLeft) > 1) to bFound
94770>>>>>>>>>        End
94770>>>>>>>>>>
94770>>>>>>>>>        Function_Return (bIndicatorWord or bFound)
94771>>>>>>>>>    End_Function
94772>>>>>>>>>
94772>>>>>>>>>    // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
94772>>>>>>>>>    Function IsKeywordInLine String sKeywords String sLine Returns Boolean
94774>>>>>>>>>        String sKeyword sChar  
94774>>>>>>>>>        Integer iPos   
94774>>>>>>>>>        Boolean bOK
94774>>>>>>>>>
94774>>>>>>>>>        Move (Lowercase(sKeywords)) to sKeywords
94775>>>>>>>>>        Move (Lowercase(sLine)) to sLine
94776>>>>>>>>>        Get _RemoveStringsFromLine sLine to sLine
94777>>>>>>>>>        Move (Pos(" ", sLine)) to iPos
94778>>>>>>>>>        // Then there is only one "word" in sLine. Check if the sKeywords = sLine
94778>>>>>>>>>        If (iPos = 0) Begin
94780>>>>>>>>>            Move (Replace("|", sKeywords, "")) to sKeyword
94781>>>>>>>>>            If (Trim(sKeyword) = Trim(sLine)) Begin
94783>>>>>>>>>                Function_Return True
94784>>>>>>>>>            End
94784>>>>>>>>>>
94784>>>>>>>>>        End
94784>>>>>>>>>>
94784>>>>>>>>>        
94784>>>>>>>>>        While (sKeywords <> "")
94788>>>>>>>>>            Move (Left(sKeywords, (Pos("|", sKeywords)))) to sKeyword
94789>>>>>>>>>            Move (Replace(sKeyword, sKeywords, "")) to sKeywords
94790>>>>>>>>>            Move (Trim(Replace("|", sKeyword, ""))) to sKeyword
94791>>>>>>>>>            Move ((sKeyword <> "") and ((Pos((" " + sKeyword + " "), sLine)) <> 0)) to bOK
94792>>>>>>>>>            If (bOK = False) Begin
94794>>>>>>>>>                Move ((sKeyword <> "") and ((Pos((sKeyword + " "), sLine)) <> 0) ) to bOK
94795>>>>>>>>>            End
94795>>>>>>>>>>
94795>>>>>>>>>            // Also check if this might be the very first statement on the sLine 
94795>>>>>>>>>            If (bOK = True) Begin    
94797>>>>>>>>>                Move (Left(sKeyword, 1)) to sChar
94798>>>>>>>>>                // Is this a command?
94798>>>>>>>>>                If (sChar = "#") Begin
94800>>>>>>>>>                    Function_Return False
94801>>>>>>>>>                End
94801>>>>>>>>>>
94801>>>>>>>>>                Else Begin
94802>>>>>>>>>                    Function_Return True
94803>>>>>>>>>                End
94803>>>>>>>>>>
94803>>>>>>>>>            End
94803>>>>>>>>>>
94803>>>>>>>>>        Loop
94804>>>>>>>>>>
94804>>>>>>>>>        Function_Return False
94805>>>>>>>>>    End_Function
94806>>>>>>>>>
94806>>>>>>>>>    Function IsMethodStart String sLine Returns Boolean
94808>>>>>>>>>        Boolean bMethodStart
94808>>>>>>>>>
94808>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
94809>>>>>>>>>        Move (Lowercase(Trim(sLine))) to sLine
94810>>>>>>>>>        Move (Left(sLine, 10) = "procedure " or Left(sLine, 9) = "function ") to bMethodStart
94811>>>>>>>>>
94811>>>>>>>>>        Function_Return bMethodStart
94812>>>>>>>>>    End_Function
94813>>>>>>>>>
94813>>>>>>>>>    Function IsMethodEnd String sLine Returns Boolean
94815>>>>>>>>>        Boolean bMethodEnd
94815>>>>>>>>>
94815>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
94816>>>>>>>>>        Get _RemoveEndComment  sLine to sLine
94817>>>>>>>>>        Move (Lowercase(Trim(sLine))) to sLine
94818>>>>>>>>>        Move (Left(sLine, 14) = "end_procedure " or Left(sLine, 13) = "end_function ") to bMethodEnd
94819>>>>>>>>>
94819>>>>>>>>>        Function_Return bMethodEnd
94820>>>>>>>>>    End_Function
94821>>>>>>>>>
94821>>>>>>>>>    // Pass only the code part of a source line.
94821>>>>>>>>>    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>" 
94821>>>>>>>>>    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator. 
94821>>>>>>>>>    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
94821>>>>>>>>>    Function IsLogicalOperators String sLine Returns tOperatorsInfo
94823>>>>>>>>>        Boolean bHas 
94823>>>>>>>>>        tOperatorsInfo OperatorsInfo
94823>>>>>>>>>        tOperatorsInfo OperatorsInfo
94823>>>>>>>>>        
94823>>>>>>>>>        Get IsCommentLineOrBlank sLine to bHas
94824>>>>>>>>>        If (bHas = True) Begin
94826>>>>>>>>>            Function_Return OperatorsInfo
94827>>>>>>>>>        End
94827>>>>>>>>>>
94827>>>>>>>>>        Get _RemoveComments (&sLine) to bHas
94828>>>>>>>>>        Get _OverstrikeStrings sLine to sLine 
94829>>>>>>>>>        Move (Lowercase(sLine)) to sLine
94830>>>>>>>>>
94830>>>>>>>>>        Case Begin                
94830>>>>>>>>>            // "Legacy" operators;
94830>>>>>>>>>            Case (sLine contains " gt ")
94832>>>>>>>>>                Move (Pos(" gt ", sLine))   to OperatorsInfo.iPos
94833>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94834>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
94835>>>>>>>>>                Move "gt"                   to OperatorsInfo.sOperator
94836>>>>>>>>>                Case Break
94837>>>>>>>>>            Case (sLine contains " ge ")
94840>>>>>>>>>                Move (Pos(" ge ", sLine))   to OperatorsInfo.iPos
94841>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94842>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
94843>>>>>>>>>                Move "ge"                   to OperatorsInfo.sOperator
94844>>>>>>>>>                Case Break
94845>>>>>>>>>            Case (sLine contains " lt ")
94848>>>>>>>>>                Move (Pos(" lt ", sLine))   to OperatorsInfo.iPos
94849>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94850>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
94851>>>>>>>>>                Move "lt"                   to OperatorsInfo.sOperator
94852>>>>>>>>>                Case Break
94853>>>>>>>>>            Case (sLine contains " le ")
94856>>>>>>>>>                Move (Pos(" le ", sLine))   to OperatorsInfo.iPos
94857>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94858>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
94859>>>>>>>>>                Move "le"                   to OperatorsInfo.sOperator
94860>>>>>>>>>                Case Break
94861>>>>>>>>>            Case (sLine contains " eq ")
94864>>>>>>>>>                Move (Pos(" eq ", sLine))   to OperatorsInfo.iPos
94865>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94866>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
94867>>>>>>>>>                Move "eq"                   to OperatorsInfo.sOperator
94868>>>>>>>>>                Case Break
94869>>>>>>>>>            Case (sLine contains " ne ")
94872>>>>>>>>>                Move (Pos(" ne ", sLine))   to OperatorsInfo.iPos
94873>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94874>>>>>>>>>                Move True                   to OperatorsInfo.bIsLegacy
94875>>>>>>>>>                Move "ne"                   to OperatorsInfo.sOperator
94876>>>>>>>>>                Case Break
94877>>>>>>>>>            
94877>>>>>>>>>            // "Modern" operators;
94877>>>>>>>>>            Case (sLine contains ">")
94880>>>>>>>>>                Move (Pos(">", sLine))      to OperatorsInfo.iPos
94881>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94882>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94883>>>>>>>>>                Move ">"                    to OperatorsInfo.sOperator
94884>>>>>>>>>                Case Break
94885>>>>>>>>>            Case (sLine contains ">=")
94888>>>>>>>>>                Move (Pos(">=", sLine))     to OperatorsInfo.iPos
94889>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94890>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94891>>>>>>>>>                Move ">="                   to OperatorsInfo.sOperator
94892>>>>>>>>>                Case Break
94893>>>>>>>>>            Case (sLine contains "<")
94896>>>>>>>>>                Move (Pos("<", sLine))      to OperatorsInfo.iPos
94897>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94898>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94899>>>>>>>>>                Move "<"                    to OperatorsInfo.sOperator
94900>>>>>>>>>                Case Break
94901>>>>>>>>>            Case (sLine contains "<=")
94904>>>>>>>>>                Move (Pos("<=", sLine))     to OperatorsInfo.iPos
94905>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94906>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94907>>>>>>>>>                Move "<="                   to OperatorsInfo.sOperator
94908>>>>>>>>>                Case Break
94909>>>>>>>>>            Case (sLine contains "=")
94912>>>>>>>>>                Move (Pos("=", sLine))      to OperatorsInfo.iPos
94913>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94914>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94915>>>>>>>>>                Move "="                    to OperatorsInfo.sOperator
94916>>>>>>>>>                Case Break
94917>>>>>>>>>            Case (sLine contains "<>")
94920>>>>>>>>>                Move (Pos("<>", sLine))     to OperatorsInfo.iPos
94921>>>>>>>>>                Move True                   to OperatorsInfo.bIsOperator
94922>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94923>>>>>>>>>                Move "<>"                   to OperatorsInfo.sOperator
94924>>>>>>>>>                Case Break
94925>>>>>>>>>            Case Else
94925>>>>>>>>>                Move -1                     to OperatorsInfo.iPos
94926>>>>>>>>>                Move False                  to OperatorsInfo.bIsOperator
94927>>>>>>>>>                Move False                  to OperatorsInfo.bIsLegacy
94928>>>>>>>>>                Move ""                     to OperatorsInfo.sOperator
94929>>>>>>>>>        Case End
94929>>>>>>>>>                
94929>>>>>>>>>        Function_Return OperatorsInfo
94930>>>>>>>>>    End_Function
94931>>>>>>>>>    
94931>>>>>>>>>    // Pass only the code part of a source line.
94931>>>>>>>>>    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
94931>>>>>>>>>    Function IsLegacyOperators String sLine Returns Boolean
94933>>>>>>>>>        Boolean bHas bFound
94933>>>>>>>>>        
94933>>>>>>>>>        Get IsCommentLineOrBlank sLine to bFound
94934>>>>>>>>>        If (bFound = True) Begin
94936>>>>>>>>>            Function_Return False
94937>>>>>>>>>        End
94937>>>>>>>>>>
94937>>>>>>>>>        Get _RemoveComments (&sLine) to bHas
94938>>>>>>>>>        Get _OverstrikeStrings sLine to sLine 
94939>>>>>>>>>        Move (Lowercase(sLine)) to sLine
94940>>>>>>>>>
94940>>>>>>>>>        Case Begin
94940>>>>>>>>>            Case (sLine contains " gt ")
94942>>>>>>>>>                Move True to bHas
94943>>>>>>>>>                Case Break
94944>>>>>>>>>            Case (sLine contains " ge ")
94947>>>>>>>>>                Move True to bHas
94948>>>>>>>>>                Case Break
94949>>>>>>>>>            Case (sLine contains " lt ")
94952>>>>>>>>>                Move True to bHas
94953>>>>>>>>>                Case Break
94954>>>>>>>>>            Case (sLine contains " le ")
94957>>>>>>>>>                Move True to bHas
94958>>>>>>>>>                Case Break
94959>>>>>>>>>            Case (sLine contains " eq ")
94962>>>>>>>>>                Move True to bHas
94963>>>>>>>>>                Case Break
94964>>>>>>>>>            Case (sLine contains " ne ")
94967>>>>>>>>>                Move True to bHas
94968>>>>>>>>>                Case Break
94969>>>>>>>>>            Case Else
94969>>>>>>>>>                Move False to bHas
94970>>>>>>>>>        Case End
94970>>>>>>>>>                
94970>>>>>>>>>        Function_Return bHas
94971>>>>>>>>>    End_Function
94972>>>>>>>>>    
94972>>>>>>>>>    // Pass only the code part of a source line.
94972>>>>>>>>>    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
94972>>>>>>>>>    Function IsOperators String sLine Returns Boolean
94974>>>>>>>>>        Boolean bHas
94974>>>>>>>>>        
94974>>>>>>>>>        Get _RemoveComments (&sLine) to bHas 
94975>>>>>>>>>        Get _OverstrikeStrings sLine to sLine
94976>>>>>>>>>
94976>>>>>>>>>        Case Begin
94976>>>>>>>>>            Case (sLine contains ">")
94978>>>>>>>>>                Move True to bHas
94979>>>>>>>>>                Case Break
94980>>>>>>>>>            Case (sLine contains ">=")
94983>>>>>>>>>                Move True to bHas
94984>>>>>>>>>                Case Break
94985>>>>>>>>>            Case (sLine contains "<")
94988>>>>>>>>>                Move True to bHas
94989>>>>>>>>>                Case Break
94990>>>>>>>>>            Case (sLine contains "<=")
94993>>>>>>>>>                Move True to bHas
94994>>>>>>>>>                Case Break
94995>>>>>>>>>            Case (sLine contains "=")
94998>>>>>>>>>                Move True to bHas
94999>>>>>>>>>                Case Break
95000>>>>>>>>>            Case (sLine contains "<>")
95003>>>>>>>>>                Move True to bHas
95004>>>>>>>>>                Case Break
95005>>>>>>>>>            Case Else
95005>>>>>>>>>                Move False to bHas
95006>>>>>>>>>        Case End
95006>>>>>>>>>                
95006>>>>>>>>>        Function_Return bHas
95007>>>>>>>>>    End_Function
95008>>>>>>>>>    
95008>>>>>>>>>    Function IsLineEndSemiColon String sLine Returns Boolean
95010>>>>>>>>>        Boolean bRemoved
95010>>>>>>>>>        String  sText
95010>>>>>>>>>        
95010>>>>>>>>>        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
95011>>>>>>>>>        Get _RemoveComments (&sLine) to bRemoved
95012>>>>>>>>>        Move (RTrim(sLine)) to sText
95013>>>>>>>>>        If (Right(sText, 1) = ";") Begin
95015>>>>>>>>>            Function_Return True
95016>>>>>>>>>        End
95016>>>>>>>>>>
95016>>>>>>>>>        Function_Return False
95017>>>>>>>>>    End_Function
95018>>>>>>>>>
95018>>>>>>>>>    Function IsLineEndSemiColonOrBegin String sLine Returns Boolean
95020>>>>>>>>>        Boolean bRemoved
95020>>>>>>>>>        Boolean bStop
95020>>>>>>>>>        String  sTest
95020>>>>>>>>>        
95020>>>>>>>>>        Move False to bStop
95021>>>>>>>>>        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
95022>>>>>>>>>        Get _RemoveComments (&sLine) to bRemoved
95023>>>>>>>>>        Move (RTrim(sLine)) to sTest
95024>>>>>>>>>        If (Right(sTest, 1) = ";") Begin
95026>>>>>>>>>            Move True to bStop
95027>>>>>>>>>        End
95027>>>>>>>>>>
95027>>>>>>>>>        If (bStop = False) Begin
95029>>>>>>>>>            Move (Lowercase(sTest)) to sTest
95030>>>>>>>>>            If (Right(sTest, 5) = "begin") Begin
95032>>>>>>>>>                Move True to bStop
95033>>>>>>>>>            End
95033>>>>>>>>>>
95033>>>>>>>>>        End
95033>>>>>>>>>>
95033>>>>>>>>>        Function_Return bStop
95034>>>>>>>>>    End_Function    
95035>>>>>>>>>    
95035>>>>>>>>>    // Returns True iif the source line is a "Loop" statement.
95035>>>>>>>>>    Function IsLoopStatement String sLine Returns Boolean
95037>>>>>>>>>        Boolean bFound
95037>>>>>>>>>        Get HasCommand sLine (" " + CS_Loop) to bFound
95038>>>>>>>>>        Function_Return bFound
95039>>>>>>>>>    End_Function   
95040>>>>>>>>>
95040>>>>>>>>>    Function IsMoveCommand String sLine Returns Boolean
95042>>>>>>>>>        Boolean bFound
95042>>>>>>>>>        Get HasCommand sLine (" " + String(CS_Move) + " ") to bFound
95043>>>>>>>>>        If (bFound = False) Begin
95045>>>>>>>>>            Get HasCommand sLine (String(CS_Move) + " ") to bFound
95046>>>>>>>>>        End
95046>>>>>>>>>>
95046>>>>>>>>>        Function_Return bFound
95047>>>>>>>>>    End_Function                                                  
95048>>>>>>>>>    
95048>>>>>>>>>    // Returns True iif the source line is a "Until" statement.
95048>>>>>>>>>    Function IsUntilStatement String sLine Returns Boolean
95050>>>>>>>>>        Boolean bFound
95050>>>>>>>>>        Get HasCommand sLine (" " + CS_Until) to bFound
95051>>>>>>>>>        If (bFound = False) Begin
95053>>>>>>>>>            Get HasCommand sLine (CS_Until + " ") to bFound
95054>>>>>>>>>            If (bFound = False) Begin
95056>>>>>>>>>                Get HasCommand sLine (CS_Until) to bFound
95057>>>>>>>>>            End
95057>>>>>>>>>>
95057>>>>>>>>>        End  
95057>>>>>>>>>>
95057>>>>>>>>>            
95057>>>>>>>>>        Function_Return bFound
95058>>>>>>>>>    End_Function   
95059>>>>>>>>>
95059>>>>>>>>>    Function IsVariableDeclarationLine String sLine Returns Boolean
95061>>>>>>>>>        Boolean bVariableDeclaration
95061>>>>>>>>>        String[] asLocalVariableTypes asLocalVariableArrayTypes
95063>>>>>>>>>        Integer iRetval
95063>>>>>>>>>        String sFirstWord
95063>>>>>>>>>
95063>>>>>>>>>        Move False to bVariableDeclaration
95064>>>>>>>>>        Get pasLocalVariableTypes      to asLocalVariableTypes
95065>>>>>>>>>        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
95066>>>>>>>>>        Move (Trim(sLine)) to sLine
95067>>>>>>>>>        Get _RetrieveFirstWord sLine to sFirstWord
95068>>>>>>>>>        Move (Uppercase(sFirstWord)) to sFirstWord
95069>>>>>>>>>        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
95070>>>>>>>>>        If (iRetval <> -1) Begin
95072>>>>>>>>>            Move True to bVariableDeclaration
95073>>>>>>>>>        End
95073>>>>>>>>>>
95073>>>>>>>>>        Else Begin
95074>>>>>>>>>            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
95075>>>>>>>>>            If (iRetval <> -1) Begin
95077>>>>>>>>>                Move True to bVariableDeclaration
95078>>>>>>>>>            End
95078>>>>>>>>>>
95078>>>>>>>>>        End
95078>>>>>>>>>>
95078>>>>>>>>>
95078>>>>>>>>>        Function_Return bVariableDeclaration
95079>>>>>>>>>    End_Function
95080>>>>>>>>>
95080>>>>>>>>>    Function IsVariableInLine String sLine String sVariableName Returns Boolean
95082>>>>>>>>>        Boolean bIsUseLine
95082>>>>>>>>>        String sChar
95082>>>>>>>>>        Integer iPos
95082>>>>>>>>>
95082>>>>>>>>>        Move False to bIsUseLine
95083>>>>>>>>>        Move (Uppercase(sLine)) to sLine
95084>>>>>>>>>        Move (Uppercase(sVariableName)) to sVariableName
95085>>>>>>>>>
95085>>>>>>>>>        If (sLine contains sVariableName) Begin
95087>>>>>>>>>            Move (Pos(sVariableName, sLine)) to iPos
95088>>>>>>>>>            If (iPos > 0) Begin
95090>>>>>>>>>                Repeat
95090>>>>>>>>>>
95090>>>>>>>>>                    Move (Mid(sLine, 1, (iPos - 1))) to sChar
95091>>>>>>>>>                    If (CS_ValidLeftCharacters contains sChar) Begin
95093>>>>>>>>>                        Move True to bIsUseLine
95094>>>>>>>>>                    End
95094>>>>>>>>>>
95094>>>>>>>>>                    If (bIsUseLine = False) Begin
95096>>>>>>>>>                        Move (Replace(sVariableName, sLine, "")) to sLine
95097>>>>>>>>>                        Move (Pos(sVariableName, sLine)) to iPos
95098>>>>>>>>>                    End
95098>>>>>>>>>>
95098>>>>>>>>>                Until (bIsUseLine = True or iPos = 0)
95100>>>>>>>>>            End
95100>>>>>>>>>>
95100>>>>>>>>>        End
95100>>>>>>>>>>
95100>>>>>>>>>
95100>>>>>>>>>        Function_Return bIsUseLine
95101>>>>>>>>>    End_Function
95102>>>>>>>>>
95102>>>>>>>>>    Function IsProjectObjectStructureLine String sLine String[] ByRef asObjectNames Returns Boolean
95104>>>>>>>>>        Boolean bWriteLine
95104>>>>>>>>>        Integer iPos iSize
95104>>>>>>>>>        String sObjectName
95104>>>>>>>>>
95104>>>>>>>>>        Move (Trim(sLine)) to sLine
95105>>>>>>>>>        Move True to bWriteLine
95106>>>>>>>>>        Move (Pos(CS_CommentSymbol, sLine)) to iPos
95107>>>>>>>>>        If (iPos = 1) Begin
95109>>>>>>>>>            Move (Lowercase(sLine)) to sLine
95110>>>>>>>>>            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
95111>>>>>>>>>            If (bWriteLine = False) Begin
95113>>>>>>>>>                Move (SizeOfArray(asObjectNames)) to iSize
95114>>>>>>>>>                Move (Pos(" is a", sLine)) to iPos
95115>>>>>>>>>                Move (Left(sLine, (iPos -1))) to sObjectName
95116>>>>>>>>>                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
95117>>>>>>>>>                Move (Trim(sObjectName)) to sObjectName
95118>>>>>>>>>                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
95119>>>>>>>>>            End
95119>>>>>>>>>>
95119>>>>>>>>>        End
95119>>>>>>>>>>
95119>>>>>>>>>        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
95121>>>>>>>>>            Move False to bWriteLine
95122>>>>>>>>>        End
95122>>>>>>>>>>
95122>>>>>>>>>        Function_Return bWriteLine
95123>>>>>>>>>    End_Function
95124>>>>>>>>>
95124>>>>>>>>>    // Returns True iif the source line contains a "Repeat" statement.
95124>>>>>>>>>    Function IsRepeatStatement String sLine Returns Boolean
95126>>>>>>>>>        Boolean bFound
95126>>>>>>>>>        Get HasCommand sLine (" " + CS_Repeat) to bFound
95127>>>>>>>>>        Function_Return bFound
95128>>>>>>>>>    End_Function   
95129>>>>>>>>>    
95129>>>>>>>>>    Function IsRegisterObjectInArray String sLine String[] ByRef asObjectNames Returns Boolean
95131>>>>>>>>>        Boolean bWriteLine bRegisterObjectStart
95131>>>>>>>>>        Integer iPos
95131>>>>>>>>>
95131>>>>>>>>>        Move False to bWriteLine
95132>>>>>>>>>        Get IsRegisterAllObjectsStart sLine to bRegisterObjectStart
95133>>>>>>>>>        If (bRegisterObjectStart = False) Begin
95135>>>>>>>>>            Move (Lowercase(sLine)) to sLine
95136>>>>>>>>>            Move (Replace("register_object", sLine, "")) to sLine
95137>>>>>>>>>            Move (Trim(sLine)) to sLine
95138>>>>>>>>>            Move (SearchArray(sLine, asObjectNames)) to iPos
95139>>>>>>>>>            Move (iPos = -1) to bWriteLine
95140>>>>>>>>>        End
95140>>>>>>>>>>
95140>>>>>>>>>
95140>>>>>>>>>        Function_Return bWriteLine
95141>>>>>>>>>    End_Function
95142>>>>>>>>>
95142>>>>>>>>>    Function IsStudioGeneratedComment String sLine String sComment Returns Boolean
95144>>>>>>>>>        String sText
95144>>>>>>>>>        
95144>>>>>>>>>        Move (Lowercase(sLine)) to sText      
95145>>>>>>>>>        
95145>>>>>>>>>        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
95147>>>>>>>>>            Function_Return True 
95148>>>>>>>>>        End
95148>>>>>>>>>>
95148>>>>>>>>>        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) Begin
95151>>>>>>>>>            Function_Return True 
95152>>>>>>>>>        End                 
95152>>>>>>>>>>
95152>>>>>>>>>        
95152>>>>>>>>>        Function_Return False
95153>>>>>>>>>    End_Function
95154>>>>>>>>>    
95154>>>>>>>>>    // Returns True iif the source line contains a "While" statement.
95154>>>>>>>>>    Function IsWhileStatement String sLine Returns Boolean
95156>>>>>>>>>        Boolean bFound
95156>>>>>>>>>        Get HasCommand sLine (CS_While + " ") to bFound
95157>>>>>>>>>        Function_Return bFound
95158>>>>>>>>>    End_Function   
95159>>>>>>>>>    
95159>>>>>>>>>    Function IsProjectObjectStructureStart String sLine Returns Boolean
95161>>>>>>>>>        Boolean bFound
95161>>>>>>>>>        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
95162>>>>>>>>>        Function_Return bFound
95163>>>>>>>>>    End_Function
95164>>>>>>>>>
95164>>>>>>>>>    Function IsRegisterAllObjectsStart String sLine Returns Boolean
95166>>>>>>>>>        Boolean bFound
95166>>>>>>>>>        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
95167>>>>>>>>>        Function_Return bFound
95168>>>>>>>>>    End_Function
95169>>>>>>>>>
95169>>>>>>>>>    Function IsRegisterAllObjectsEnd String sLine Returns Boolean
95171>>>>>>>>>        Boolean bFound
95171>>>>>>>>>        Integer iPos
95171>>>>>>>>>        String sFirstWord
95171>>>>>>>>>
95171>>>>>>>>>        Move False to bFound
95172>>>>>>>>>        Move (Lowercase(sLine)) to sLine
95173>>>>>>>>>        Move (Trim(sLine)) to sLine
95174>>>>>>>>>        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
95176>>>>>>>>>            Move (Pos(" ", sLine)) to iPos
95177>>>>>>>>>            If (iPos <> 0) Begin
95179>>>>>>>>>                Move (Left(sLine, (iPos -1))) to sFirstWord
95180>>>>>>>>>                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
95181>>>>>>>>>            End
95181>>>>>>>>>>
95181>>>>>>>>>        End
95181>>>>>>>>>>
95181>>>>>>>>>        Function_Return bFound
95182>>>>>>>>>    End_Function
95183>>>>>>>>>
95183>>>>>>>>>    Function IsRegisterObjectLine String sLine Returns Boolean
95185>>>>>>>>>        Boolean bFound
95185>>>>>>>>>        Integer iPos
95185>>>>>>>>>        Move False to bFound
95186>>>>>>>>>        Move (Pos(CS_RegisterObject, sLine)) to iPos
95187>>>>>>>>>        If (iPos = 1) Begin
95189>>>>>>>>>            Move True to bFound
95190>>>>>>>>>        End
95190>>>>>>>>>>
95190>>>>>>>>>        Function_Return bFound
95191>>>>>>>>>    End_Function
95192>>>>>>>>>
95192>>>>>>>>>    // Tests if the lowercase character passed in sLine on position iPos is
95192>>>>>>>>>    // a valid character for a class name
95192>>>>>>>>>    Function IsValidClassCharacter String sLine Integer iPos Returns Boolean
95194>>>>>>>>>        Boolean bIsValid
95194>>>>>>>>>        String  sChar
95194>>>>>>>>>        Move False to bIsValid
95195>>>>>>>>>        Move (Mid(sLine, 1, iPos)) to sChar
95196>>>>>>>>>        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
95198>>>>>>>>>            Move True to bIsValid
95199>>>>>>>>>        End
95199>>>>>>>>>>
95199>>>>>>>>>        Function_Return bIsValid
95200>>>>>>>>>    End_Function
95201>>>>>>>>>      
95201>>>>>>>>>    // (nicked from cSciLexer.pkg)
95201>>>>>>>>>    // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter counting.
95201>>>>>>>>>    // We reduce the spaces here to just one.
95201>>>>>>>>>    Procedure StripConcatenatingSpaces String ByRef sText
95203>>>>>>>>>        While (Pos("  ", sText) <> 0)
95207>>>>>>>>>            Move (Replaces("  ", sText, " ")) to sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
95208>>>>>>>>>        Loop
95209>>>>>>>>>>
95209>>>>>>>>>    End_Procedure
95210>>>>>>>>>
95210>>>>>>>>>    Procedure AddCommand String sCommand
95212>>>>>>>>>        String[] Commands
95213>>>>>>>>>
95213>>>>>>>>>        Get paCommands to Commands
95214>>>>>>>>>        Move (Lowercase(sCommand)) to sCommand
95215>>>>>>>>>        Move sCommand to Commands[SizeOfArray(Commands)]
95216>>>>>>>>>        Set paCommands to Commands
95217>>>>>>>>>    End_Procedure
95218>>>>>>>>>
95218>>>>>>>>>    Procedure AddCommandFunction String sCommand
95220>>>>>>>>>        String[] aCommandFunctions
95221>>>>>>>>>
95221>>>>>>>>>        Get paCommandFunctions to aCommandFunctions
95222>>>>>>>>>        Move (Lowercase(sCommand)) to sCommand
95223>>>>>>>>>        Move sCommand to aCommandFunctions[SizeOfArray(aCommandFunctions)]
95224>>>>>>>>>        Set paCommandFunctions to aCommandFunctions
95225>>>>>>>>>    End_Procedure
95226>>>>>>>>>
95226>>>>>>>>>    // Command list used for testing against inline if/else statements et. al.
95226>>>>>>>>>    // Note that it is not a complete command list and that we should be careful
95226>>>>>>>>>    // about commands that might be used as functions or in functions!
95226>>>>>>>>>    // For example, it is by intention that none of the variable declaration commands
95226>>>>>>>>>    // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
95226>>>>>>>>>    //
95226>>>>>>>>>    // All commands can be entered case insensitive
95226>>>>>>>>>    // Standalone commands can end on a end of line, such as Abort.
95226>>>>>>>>>    // Other commands need more parameters and in such case we can improve our success rate
95226>>>>>>>>>    // by adding a space character.
95226>>>>>>>>>    //
95226>>>>>>>>>    Procedure AddAllCommands
95228>>>>>>>>>        String[] Empty
95229>>>>>>>>>
95229>>>>>>>>>        Set paCommands to Empty
95230>>>>>>>>>
95230>>>>>>>>>        //Send AddCommand "Repeat"  // nope, it is a function too
95230>>>>>>>>>        Send AddCommand "Abort"
95231>>>>>>>>>        Send AddCommand "Abort_Transaction"
95232>>>>>>>>>        Send AddCommand "Activate_View "
95233>>>>>>>>>        Send AddCommand "Add "
95234>>>>>>>>>        Send AddCommand "Address "
95235>>>>>>>>>        Send AddCommand "Append "
95236>>>>>>>>>        Send AddCommand "Append_Output "
95237>>>>>>>>>        Send AddCommand "Attach "
95238>>>>>>>>>        Send AddCommand "Begin_Constraints"
95239>>>>>>>>>        Send AddCommand "Begin_Transaction"
95240>>>>>>>>>        Send AddCommand "Broadcast "
95241>>>>>>>>>        Send AddCommand "Broadcast_Focus "
95242>>>>>>>>>        Send AddCommand "Calc "
95243>>>>>>>>>        Send AddCommand "Calculate "
95244>>>>>>>>>        Send AddCommand "Call_Driver "
95245>>>>>>>>>        Send AddCommand "CallStackDump "
95246>>>>>>>>>        Send AddCommand "Case "
95247>>>>>>>>>        Send AddCommand "Clear "
95248>>>>>>>>>        Send AddCommand "Close "
95249>>>>>>>>>        Send AddCommand "Close_Input"
95250>>>>>>>>>        Send AddCommand "Close_Output"
95251>>>>>>>>>        Send AddCommand "Constrain "
95252>>>>>>>>>        Send AddCommand "Constrained_Clear "
95253>>>>>>>>>        Send AddCommand "Constrained_Find "
95254>>>>>>>>>        Send AddCommand "Constraint_Set"
95255>>>>>>>>>        Send AddCommand "Constraint_Validate"
95256>>>>>>>>>        Send AddCommand "Copy_db "
95257>>>>>>>>>        Send AddCommand "Copy_Records "
95258>>>>>>>>>        Send AddCommand "Copyfile "
95259>>>>>>>>>        Send AddCommand "Create_Field "
95260>>>>>>>>>        Send AddCommand "Create_Index "
95261>>>>>>>>>        Send AddCommand "Declare_DataFile "
95262>>>>>>>>>        Send AddCommand "Decrement "
95263>>>>>>>>>        Send AddCommand "Delegate "
95264>>>>>>>>>        Send AddCommand "Delete "
95265>>>>>>>>>        Send AddCommand "Delete_db "
95266>>>>>>>>>        Send AddCommand "Delete_Field "
95267>>>>>>>>>        Send AddCommand "Delete_Index "
95268>>>>>>>>>        Send AddCommand "Direct_Input "
95269>>>>>>>>>        Send AddCommand "Direct_Output "
95270>>>>>>>>>        Send AddCommand "DiskFree "
95271>>>>>>>>>        Send AddCommand "EraseFile "
95272>>>>>>>>>        Send AddCommand "Error "
95273>>>>>>>>>        Send AddCommand "Field_Map "
95274>>>>>>>>>        Send AddCommand "File_Exist "
95275>>>>>>>>>        Send AddCommand "Fill_Field "
95276>>>>>>>>>        Send AddCommand "Find "
95277>>>>>>>>>        Send AddCommand "For "
95278>>>>>>>>>        Send AddCommand "For_All "
95279>>>>>>>>>        Send AddCommand "Forward "
95280>>>>>>>>>        Send AddCommand "Function_Return " // you might have code that does not return a value, I'd consider that a warning
95281>>>>>>>>>        Send AddCommand "Get "
95282>>>>>>>>>        Send AddCommand "Get_Argument_Size "
95283>>>>>>>>>        Send AddCommand "Get_Attribute "
95284>>>>>>>>>        Send AddCommand "Get_Channel_Position "
95285>>>>>>>>>        Send AddCommand "Get_Channel_Size "
95286>>>>>>>>>        Send AddCommand "Get_Current_Directory "
95287>>>>>>>>>        Send AddCommand "Get_Current_Input_Channel "
95288>>>>>>>>>        Send AddCommand "Get_Current_Output_Channel "
95289>>>>>>>>>        Send AddCommand "Get_Current_User_Count "
95290>>>>>>>>>        Send AddCommand "Get_Date_Attribute "
95291>>>>>>>>>        Send AddCommand "Get_Directory "
95292>>>>>>>>>        Send AddCommand "Get_Environment "
95293>>>>>>>>>        Send AddCommand "Get_Field_Value "
95294>>>>>>>>>        Send AddCommand "Get_FieldNumber "
95295>>>>>>>>>        Send AddCommand "Get_File_Mod_Time "
95296>>>>>>>>>        Send AddCommand "Get_File_Path "
95297>>>>>>>>>        Send AddCommand "Get_FileNumber "
95298>>>>>>>>>        Send AddCommand "Get_Licensed_Max_Users "
95299>>>>>>>>>        Send AddCommand "Get_StrictEval "
95300>>>>>>>>>        Send AddCommand "Get_Transaction_Retry "
95301>>>>>>>>>        Send AddCommand "Get_Windows_Directory "
95302>>>>>>>>>        Send AddCommand "GetAddress "
95303>>>>>>>>>        Send AddCommand "GetBuff "
95304>>>>>>>>>        Send AddCommand "GetBuff_String "
95305>>>>>>>>>        Send AddCommand "GetDskInfo "
95306>>>>>>>>>        Send AddCommand "Global_Variable "
95307>>>>>>>>>        Send AddCommand "Include_Resource "
95308>>>>>>>>>        Send AddCommand "Increment "
95309>>>>>>>>>        Send AddCommand "Indicate "
95310>>>>>>>>>        Send AddCommand "Indicator "
95311>>>>>>>>>        Send AddCommand "Load_Def "
95312>>>>>>>>>        Send AddCommand "Load_Driver "
95313>>>>>>>>>        Send AddCommand "Lock"
95314>>>>>>>>>        Send AddCommand "Login "
95315>>>>>>>>>        Send AddCommand "Logout"
95316>>>>>>>>>        Send AddCommand "Make_Directory "
95317>>>>>>>>>        Send AddCommand "Make_File "
95318>>>>>>>>>        Send AddCommand "Make_Temp_File "
95319>>>>>>>>>        Send AddCommand "Move "
95320>>>>>>>>>        Send AddCommand "Movedate "
95321>>>>>>>>>        Send AddCommand "Moveint "
95322>>>>>>>>>        Send AddCommand "Movenum "
95323>>>>>>>>>        Send AddCommand "Movereal "
95324>>>>>>>>>        Send AddCommand "Movestr "
95325>>>>>>>>>        Send AddCommand "NewRecord "
95326>>>>>>>>>        Send AddCommand "On_Item"
95327>>>>>>>>>        Send AddCommand "On_key "
95328>>>>>>>>>        Send AddCommand "Open "
95329>>>>>>>>>        Send AddCommand "Output "
95330>>>>>>>>>        Send AddCommand "Output_Aux_File "
95331>>>>>>>>>        Send AddCommand "Output_Wrap"
95332>>>>>>>>>        Send AddCommand "Playwave "
95333>>>>>>>>>        Send AddCommand "Procedure_Return"
95334>>>>>>>>>        Send AddCommand "Property "
95335>>>>>>>>>        Send AddCommand "Put "
95336>>>>>>>>>        Send AddCommand "Read "
95337>>>>>>>>>        Send AddCommand "Read_Block "
95338>>>>>>>>>        Send AddCommand "Read_hex "
95339>>>>>>>>>        Send AddCommand "Readln "
95340>>>>>>>>>        Send AddCommand "Reg_Close_Key "
95341>>>>>>>>>        Send AddCommand "Reg_Enum_Key "
95342>>>>>>>>>        Send AddCommand "Reg_Enum_Key_Info "
95343>>>>>>>>>        Send AddCommand "Reg_Enum_Value "
95344>>>>>>>>>        Send AddCommand "Relate "
95345>>>>>>>>>        Send AddCommand "Remove_Directory "
95346>>>>>>>>>        Send AddCommand "Renamefile "
95347>>>>>>>>>        Send AddCommand "Report_Breaks "
95348>>>>>>>>>        Send AddCommand "Reread"
95349>>>>>>>>>        Send AddCommand "RunProgram "
95350>>>>>>>>>        Send AddCommand "Save "
95351>>>>>>>>>        Send AddCommand "SaveRecord "
95352>>>>>>>>>        Send AddCommand "Send "
95353>>>>>>>>>        Send AddCommand "Set "
95354>>>>>>>>>        Send AddCommand "Set_Argument_Size "
95355>>>>>>>>>        Send AddCommand "Set_Attribute "
95356>>>>>>>>>        Send AddCommand "Set_Channel_Position "
95357>>>>>>>>>        Send AddCommand "Set_Date_Attribute "
95358>>>>>>>>>        Send AddCommand "Set_Directory "
95359>>>>>>>>>        Send AddCommand "Set_Field_Value "
95360>>>>>>>>>        Send AddCommand "Set_File_Mod_Time "
95361>>>>>>>>>        Send AddCommand "Set_Foreign_Profile_String "
95362>>>>>>>>>        Send AddCommand "set_registry_root "
95363>>>>>>>>>        Send AddCommand "Set_Relate "
95364>>>>>>>>>        Send AddCommand "Set_StrictEval "
95365>>>>>>>>>        Send AddCommand "Set_Transaction_Retry "
95366>>>>>>>>>        Send AddCommand "Shift_State "
95367>>>>>>>>>        Send AddCommand "Show "
95368>>>>>>>>>        Send AddCommand "Showln"
95369>>>>>>>>>        Send AddCommand "Sleep "
95370>>>>>>>>>        Send AddCommand "Sort "
95371>>>>>>>>>        Send AddCommand "Start_UI"
95372>>>>>>>>>        Send AddCommand "Structure_Abort "
95373>>>>>>>>>        Send AddCommand "Structure_Copy "
95374>>>>>>>>>        Send AddCommand "Structure_End "
95375>>>>>>>>>        Send AddCommand "Structure_Start "
95376>>>>>>>>>        Send AddCommand "Subtract "
95377>>>>>>>>>        Send AddCommand "Sysdate "
95378>>>>>>>>>        Send AddCommand "Sysdate4 "
95379>>>>>>>>>        Send AddCommand "Unload_Driver "
95380>>>>>>>>>        Send AddCommand "Unlock"   
95381>>>>>>>>>        Send AddCommand "Until"
95382>>>>>>>>>        Send AddCommand "Valid_Drive "
95383>>>>>>>>>        Send AddCommand "ValueTreeDeserializeParameter "
95384>>>>>>>>>        Send AddCommand "ValueTreeSerializeParameter "
95385>>>>>>>>>        Send AddCommand "VConstrain "
95386>>>>>>>>>        Send AddCommand "Version_Information "
95387>>>>>>>>>        Send AddCommand "VFind "
95388>>>>>>>>>        Send AddCommand "Virtual_Key "
95389>>>>>>>>>        Send AddCommand "WebGet "
95390>>>>>>>>>        Send AddCommand "WebPublishFunction "
95391>>>>>>>>>        Send AddCommand "WebPublishProcedure "
95392>>>>>>>>>        Send AddCommand "WebSet "
95393>>>>>>>>>        Send AddCommand "WebSetResponsive "
95394>>>>>>>>>        Send AddCommand "While "
95395>>>>>>>>>        Send AddCommand "Write "
95396>>>>>>>>>        Send AddCommand "Write_Hex "
95397>>>>>>>>>        Send AddCommand "WriteLn"
95398>>>>>>>>>        Send AddCommand "ZeroFile "
95399>>>>>>>>>        Send AddCommand "ZeroString "
95400>>>>>>>>>        Send AddCommand "ZeroType "
95401>>>>>>>>>    End_Procedure
95402>>>>>>>>>
95402>>>>>>>>>    Procedure AddAllCommandFunctions
95404>>>>>>>>>        String[] Empty
95405>>>>>>>>>
95405>>>>>>>>>        Set paCommandFunctions to Empty
95406>>>>>>>>>
95406>>>>>>>>>        Send AddCommandFunction "Repeat"  
95407>>>>>>>>>        Send AddCommandFunction "If "
95408>>>>>>>>>        Send AddCommandFunction "Else "  
95409>>>>>>>>>        Send AddCommandFunction "Pos"
95410>>>>>>>>>        Send AddCommandFunction "Insert"
95411>>>>>>>>>    End_Procedure
95412>>>>>>>>>
95412>>>>>>>>>//    Procedure Activating
95412>>>>>>>>>//        Send AddAllCommands  
95412>>>>>>>>>//        Send AddAllCommandFunctions
95412>>>>>>>>>//    End_Procedure
95412>>>>>>>>>
95412>>>>>>>>>    // splits a line to a string array.
95412>>>>>>>>>    // Ignores any special characters, spaces or new line, CR "multi line"
95412>>>>>>>>>    Function SplitTextByLengthPure Global String sText Integer iAntal Returns String[]
95414>>>>>>>>>        String s
95414>>>>>>>>>        String[] saText
95415>>>>>>>>>    
95415>>>>>>>>>        Move sText to s
95416>>>>>>>>>    
95416>>>>>>>>>        While (Length(s) > 0)
95420>>>>>>>>>            Move (Mid(s, iAntal, 1)) to saText[(SizeOfArray(saText))]
95421>>>>>>>>>            Move (Mid(s, (Length(s) - iAntal), (iAntal + 1))) to s
95422>>>>>>>>>        Loop
95423>>>>>>>>>>
95423>>>>>>>>>    
95423>>>>>>>>>        Function_Return saText
95424>>>>>>>>>    End_Function
95425>>>>>>>>>
95425>>>>>>>>>    // Splits a string to a string array.
95425>>>>>>>>>    Function Split String sSplitKey String sText Returns String[]
95427>>>>>>>>>        String[] sArray
95428>>>>>>>>>        Integer iLeftPos
95428>>>>>>>>>        Boolean bAtLeastOneSplit
95428>>>>>>>>>    
95428>>>>>>>>>        Move (ResizeArray(sArray, 0)) to sArray
95429>>>>>>>>>        If ((sSplitKey = "") and ((Length(sSplitKey)) = 0)) Begin
95431>>>>>>>>>            For iLeftPos from 1 to ((Length(sText)))
95437>>>>>>>>>>
95437>>>>>>>>>                Move (Mid(sText, 1, iLeftPos)) to sArray[SizeOfArray(sArray)]
95438>>>>>>>>>            Loop
95439>>>>>>>>>>
95439>>>>>>>>>        End
95439>>>>>>>>>>
95439>>>>>>>>>        Else Begin
95440>>>>>>>>>            Move (Pos(sSplitKey, sText)) to iLeftPos
95441>>>>>>>>>    
95441>>>>>>>>>            While (iLeftPos > 0)
95445>>>>>>>>>                Move True to bAtLeastOneSplit
95446>>>>>>>>>                Move (Left(sText, iLeftPos - 1)) to sArray[SizeOfArray(sArray)]
95447>>>>>>>>>                Move (Right(sText, ((Length(sText) - (iLeftPos + (Length(sSplitKey))) )+1))) to sText
95448>>>>>>>>>                Move (Pos(sSplitKey, sText)) to iLeftPos
95449>>>>>>>>>            Loop
95450>>>>>>>>>>
95450>>>>>>>>>    
95450>>>>>>>>>            // Ta med text hger om sista splittecknet
95450>>>>>>>>>            Move sText to sArray[SizeOfArray(sArray)]
95451>>>>>>>>>        End
95451>>>>>>>>>>
95451>>>>>>>>>    
95451>>>>>>>>>        Function_Return sArray
95452>>>>>>>>>    End_Function
95453>>>>>>>>>
95453>>>>>>>>>    // Create a string by joining array elements using a separator
95453>>>>>>>>>    Function JoinArray Global String[] saValues String sSeparator Returns String
95455>>>>>>>>>        Integer i iLength
95455>>>>>>>>>        String sRet
95455>>>>>>>>>        Move "" to sRet
95456>>>>>>>>>        Move (SizeOfArray(saValues)-1) to iLength
95457>>>>>>>>>        For i from 0 to iLength
95463>>>>>>>>>>
95463>>>>>>>>>            // First element
95463>>>>>>>>>            If (i = 0) Begin
95465>>>>>>>>>                Append sRet saValues[i]
95466>>>>>>>>>            End
95466>>>>>>>>>>
95466>>>>>>>>>            // Other elements
95466>>>>>>>>>            Else Begin
95467>>>>>>>>>                Append sRet sSeparator saValues[i]
95469>>>>>>>>>            End
95469>>>>>>>>>>
95469>>>>>>>>>        Loop
95470>>>>>>>>>>
95470>>>>>>>>>        Function_Return sRet
95471>>>>>>>>>    End_Function
95472>>>>>>>>>
95472>>>>>>>>>    // Convert Integer to a binary value
95472>>>>>>>>>    // Courtesy of Frank Cheng.
95472>>>>>>>>>    Function IntToBinary Global Integer i Returns String
95474>>>>>>>>>        String sResult
95474>>>>>>>>>        If (i < 0) Function_Return ""
95477>>>>>>>>>        Move "" to sResult
95478>>>>>>>>>        Repeat
95478>>>>>>>>>>
95478>>>>>>>>>            Move (String(Mod(i, 2)) + sResult) to sResult
95479>>>>>>>>>            Move (i / 2) to i
95480>>>>>>>>>        Until (i = 0)
95482>>>>>>>>>        Function_Return sResult
95483>>>>>>>>>    End_Function
95484>>>>>>>>>
95484>>>>>>>>>    // Courtesy of Frank Cheng.
95484>>>>>>>>>    // There is another verion (HexToInt) in mStrConv.pkg
95484>>>>>>>>>    Function HexToInt2 Global String sNum Returns Integer
95486>>>>>>>>>        Integer iLength iDigit iNum iPower
95486>>>>>>>>>        Move (Length(sNum)) to iLength
95487>>>>>>>>>        Move 1 to iPower
95488>>>>>>>>>        Move 0 to iNum
95489>>>>>>>>>        While (iLength > 0)
95493>>>>>>>>>            Move (Ascii(Mid(sNum,1,iLength))) to iDigit
95494>>>>>>>>>            Subtract (If(iDigit > 57, 55, 48)) from iDigit
95495>>>>>>>>>            Add (iDigit * iPower) to iNum
95496>>>>>>>>>            Move (iPower * 16) to iPower
95497>>>>>>>>>            Decrement iLength
95498>>>>>>>>>        Loop
95499>>>>>>>>>>
95499>>>>>>>>>        Function_Return iNum
95500>>>>>>>>>    End_Function
95501>>>>>>>>>
95501>>>>>>>>>    // Curtesy of Evertjan Dondergoor DAE
95501>>>>>>>>>    Function SQLDateTimeToDFDateTime String s Returns DateTime
95503>>>>>>>>>        DateTime dt
95503>>>>>>>>>        Integer iYear iMonth iDay
95503>>>>>>>>>        Integer iHour iMinute iSecond
95503>>>>>>>>>
95503>>>>>>>>>        Move (Mid(s, 4,  1)) to iYear
95504>>>>>>>>>        Move (Mid(s, 2,  6)) to iMonth
95505>>>>>>>>>        Move (Mid(s, 2,  9)) to iDay
95506>>>>>>>>>        Move (Mid(s, 2, 12)) to iHour
95507>>>>>>>>>        Move (Mid(s, 2, 15)) to iMinute
95508>>>>>>>>>        Move (Mid(s, 2, 18)) to iSecond
95509>>>>>>>>>
95509>>>>>>>>>        Move (DateSetYear  (dt, iYear  )) to dt
95510>>>>>>>>>        Move (DateSetMonth (dt, iMonth )) to dt
95511>>>>>>>>>        Move (DateSetDay   (dt, iDay   )) to dt
95512>>>>>>>>>        Move (DateSetHour  (dt, iHour  )) to dt
95513>>>>>>>>>        Move (DateSetMinute(dt, iMinute)) to dt
95514>>>>>>>>>        Move (DateSetSecond(dt, iSecond)) to dt
95515>>>>>>>>>
95515>>>>>>>>>        Function_Return dt
95516>>>>>>>>>    End_Function
95517>>>>>>>>>
95517>>>>>>>>>    // Returns True if the "sCheckFieldName" field exists in the passed iFile datbase table.
95517>>>>>>>>>    // If it doesn't exist, False is returned
95517>>>>>>>>>    Function IsFieldExisting Integer iFile String sCheckFieldName Returns Boolean
95519>>>>>>>>>        Integer iNumFields iCount                                      
95519>>>>>>>>>        String sFieldName
95519>>>>>>>>>      
95519>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
95522>>>>>>>>>        Decrement iNumFields
95523>>>>>>>>>        For iCount from 0 to iNumFields  
95529>>>>>>>>>>
95529>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iCount to sFieldName        
95532>>>>>>>>>            If ((Uppercase (sFieldName)) = (Uppercase (sCheckFieldName))) Begin
95534>>>>>>>>>                Function_Return True
95535>>>>>>>>>            End
95535>>>>>>>>>>
95535>>>>>>>>>        Loop
95536>>>>>>>>>>
95536>>>>>>>>>      
95536>>>>>>>>>        Function_Return False
95537>>>>>>>>>    End_Function
95538>>>>>>>>>
95538>>>>>>>>>End_Class       
95539>>>>>>>Use vWin32fh.pkg
95539>>>>>>>
95539>>>>>>>Struct tUnusedLocals
95539>>>>>>>    Boolean bInUse
95539>>>>>>>    String VarName
95539>>>>>>>    String MethodName
95539>>>>>>>    Integer Line#
95539>>>>>>>End_Struct
95539>>>>>>>
95539>>>>>>>Define CS_UnusedVariablesLogFile for "UnusedVariables.txt"
95539>>>>>>>
95539>>>>>>>Class cRemoveUnusedLocals is a cObject
95540>>>>>>>    Procedure Construct_Object
95542>>>>>>>        String[] asLocalVariableTypes asLocalVariableArrayTypes
95544>>>>>>>
95544>>>>>>>        Forward Send Construct_Object
95546>>>>>>>        
95546>>>>>>>        Property String[] pasLocalVariableTypes
95547>>>>>>>            Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
95548>>>>>>>            Set pasLocalVariableTypes to asLocalVariableTypes
95549>>>>>>>
95549>>>>>>>        Property String[] pasLocalVariableArrayTypes
95550>>>>>>>            Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
95551>>>>>>>            Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes
95552>>>>>>>
95552>>>>>>>        Property String[] pasSourceFile
95553>>>>>>>        Property Integer piNoOfUnusedLocalVariables 0
95554>>>>>>>
95554>>>>>>>    End_Procedure
95555>>>>>>>
95555>>>>>>>    // Remove all variables that are used.
95555>>>>>>>    Function CleanupLocalVariables tUnusedLocals[] asLocalVariables Returns tUnusedLocals
95557>>>>>>>        Integer iCount iSize
95557>>>>>>>
95557>>>>>>>        Move (SortArray(asLocalVariables))   to asLocalVariables
95558>>>>>>>        Move (SizeOfArray(asLocalVariables)) to iSize
95559>>>>>>>        Decrement iSize
95560>>>>>>>        For iCount From 0 to iSize
95566>>>>>>>>
95566>>>>>>>            If (asLocalVariables[iCount].bInUse = True) Begin
95568>>>>>>>                Move (RemoveFromArray(asLocalVariables, iCount)) to asLocalVariables
95569>>>>>>>                Decrement iSize
95570>>>>>>>                Decrement iCount
95571>>>>>>>            End
95571>>>>>>>>
95571>>>>>>>        Loop
95572>>>>>>>>
95572>>>>>>>
95572>>>>>>>        Function_Return asLocalVariables
95573>>>>>>>    End_Function
95574>>>>>>>
95574>>>>>>>    // Custom comparison function:
95574>>>>>>>    //   Returns (GT) struct value in first parameter > struct value in second parameter.
95574>>>>>>>    //   Returns (LT) struct value in first parameter < struct value in second parameter.
95574>>>>>>>    //   Otherwise returns (EQ).
95574>>>>>>>    Function CompareLineNum tUnusedLocals Local1 tUnusedLocals Local2 Returns Integer
95576>>>>>>>        If (Local1.Line# > Local2.Line#) ;            Function_Return (GT)
95579>>>>>>>        If (Local1.Line# < Local2.Line#) ;            Function_Return (LT)
95582>>>>>>>        Function_Return (EQ)
95583>>>>>>>    End_Function
95584>>>>>>>
95584>>>>>>>    // We now have the source file array and the unused variables struct array.
95584>>>>>>>    // Remove those unused variables from the source file array.
95584>>>>>>>    Procedure RemoveUnusedVariablesFromSourceArray String[] ByRef asSourceFile tUnusedLocals[] asLocalVariables Integer ByRef iUnusedLocalVariables
95586>>>>>>>        Integer iCount iSize iItem iLength iOffset
95586>>>>>>>        String sVarName sLine sVarType sVariableDeclarationConstant
95586>>>>>>>        Boolean bInUse bFound bIgnore bChanged
95586>>>>>>>
95586>>>>>>>        Move 0 to iOffset
95587>>>>>>>        Get CleanupLocalVariables asLocalVariables      to asLocalVariables
95588>>>>>>>        Move (SizeOfArray(asLocalVariables))            to iSize
95589>>>>>>>        // sort array by line number as otherwise the iOffset logic won't work!
95589>>>>>>>        Move (SortArray(asLocalVariables, Self, (RefFunc(CompareLineNum)))) to asLocalVariables
95590>>>>>>>        Decrement iSize
95591>>>>>>>        For iCount From 0 to iSize
95597>>>>>>>>
95597>>>>>>>            Move asLocalVariables[iCount].bInUse        to bInUse
95598>>>>>>>            If (bInUse = False) Begin
95600>>>>>>>                Move asLocalVariables[iCount].Line#     to iItem
95601>>>>>>>                Move (iItem - 1 + iOffset)              to iItem
95602>>>>>>>                Move asLocalVariables[iCount].VarName   to sVarName
95603>>>>>>>                Move (Length(sVarName))                 to iLength
95604>>>>>>>                Move asSourceFile[iItem]                to sLine
95605>>>>>>>                Get RemoveLocalKeyWord of ghoRefactorFunctionLibrary (&sLine) to bIgnore
95606>>>>>>>                Get _RetrieveFirstWord of ghoRefactorFunctionLibrary sLine    to sVarType
95607>>>>>>>
95607>>>>>>>                Move ((sLine+" ") contains (" " + sVarName + " "))  to bFound
95608>>>>>>>                If (bFound = False) Begin
95610>>>>>>>                    Move (sLine contains sVarName)      to bFound
95611>>>>>>>                End
95611>>>>>>>>
95611>>>>>>>                If (bFound = True) Begin
95613>>>>>>>                    Move (Replace((" " + sVarName + " "), sLine+" ", " ")) to sLine
95614>>>>>>>                End
95614>>>>>>>>
95614>>>>>>>
95614>>>>>>>                Get _NormalizeArrayNotation of ghoRefactorFunctionLibrary (&sLine) to bChanged
95615>>>>>>>                // If all that remains on the line is the variable type declaration,
95615>>>>>>>                // remove the line from the source array.
95615>>>>>>>                Move sLine to sVariableDeclarationConstant
95616>>>>>>>                Get RemoveLocalKeyWord of ghoRefactorFunctionLibrary (&sVariableDeclarationConstant) to bIgnore
95617>>>>>>>                Get _RemoveEndComment of ghoRefactorFunctionLibrary sVariableDeclarationConstant to sVariableDeclarationConstant
95618>>>>>>>                Move (Trim(sVariableDeclarationConstant)) to sVariableDeclarationConstant
95619>>>>>>>                If (sVarType = sVariableDeclarationConstant) Begin
95621>>>>>>>                    Move (RemoveFromArray(asSourceFile, iItem)) to asSourceFile
95622>>>>>>>                    Decrement iOffset
95623>>>>>>>                End
95623>>>>>>>>
95623>>>>>>>                Else Begin
95624>>>>>>>                    Move (RTrim(sLine)) to sLine
95625>>>>>>>                    Move sLine to asSourceFile[iItem]
95626>>>>>>>                End
95626>>>>>>>>
95626>>>>>>>
95626>>>>>>>                Increment iUnusedLocalVariables
95627>>>>>>>            End
95627>>>>>>>>
95627>>>>>>>        Loop
95628>>>>>>>>
95628>>>>>>>
95628>>>>>>>        Procedure_Return
95629>>>>>>>    End_Procedure
95630>>>>>>>    
95630>>>>>>>    // *** MAIN PROCEDURE ***
95630>>>>>>>    // Call this and pass a source file as string ByRef array.
95630>>>>>>>    // Returns number of unused local variables
95630>>>>>>>    Function MainProcedure String[] ByRef asSourceFile Returns Integer
95632>>>>>>>        Set piNoOfUnusedLocalVariables to 0
95633>>>>>>>        Send ParseFile (&asSourceFile)
95634>>>>>>>        Function_Return (piNoOfUnusedLocalVariables(Self))
95635>>>>>>>    End_Function
95636>>>>>>>
95636>>>>>>>    Procedure ParseFile String[] ByRef asSourceFile
95638>>>>>>>        String sLine sVars sVariableName sMethodName sSourceFile
95638>>>>>>>        Integer iArrayCount iMax iCounter iItems iLineCount iUnusedLocalVariables iSize iCount
95638>>>>>>>        tUnusedLocals[] asLocalVars
95638>>>>>>>        tUnusedLocals[] asLocalVars
95639>>>>>>>        String[] asVars
95640>>>>>>>        Boolean bComment bInMethod bVariableDeclaration bIsVariable bMethodEnd bIgnore
95640>>>>>>>
95640>>>>>>>        Move (SizeOfArray(asSourceFile)) to iSize
95641>>>>>>>        If (iSize = 0) Begin
95643>>>>>>>            Get psIdleText of (phoStatusBar(ghoCommandBars)) to sSourceFile
95644>>>>>>>            Send Info_Box ("Source File Array is empty.\n" + String(sSourceFile)) "Error in ParseFile method [cRemoveUnusedLocals.pkg]"
95645>>>>>>>            Move True to Err
95646>>>>>>>            Procedure_Return
95647>>>>>>>        End
95647>>>>>>>>
95647>>>>>>>
95647>>>>>>>        Move False to bMethodEnd
95648>>>>>>>        Decrement iSize
95649>>>>>>>        Move False to Err
95650>>>>>>>        Move 0 to iUnusedLocalVariables
95651>>>>>>>
95651>>>>>>>        For iCount From 0 to iSize
95657>>>>>>>>
95657>>>>>>>            Move asSourceFile[iCount] to sLine
95658>>>>>>>            Move (Trim(sLine)) to sLine
95659>>>>>>>            Get _OverstrikeStrings of ghoRefactorFunctionLibrary sLine to sLine
95660>>>>>>>            Get _RemoveEndComment  of ghoRefactorFunctionLibrary sLine to sLine
95661>>>>>>>            Get IsCommentLine      of ghoRefactorFunctionLibrary sLine to bComment
95662>>>>>>>
95662>>>>>>>            If (bComment = False and Trim(sLine) <> "") Begin
95664>>>>>>>                Get IsMethodStart of ghoRefactorFunctionLibrary sLine to bInMethod
95665>>>>>>>                Get IsMethodEnd   of ghoRefactorFunctionLibrary sLine to bMethodEnd
95666>>>>>>>                If (bInMethod = True and bMethodEnd = False) Begin
95668>>>>>>>                    Get _MethodName of ghoRefactorFunctionLibrary sLine to sMethodName
95669>>>>>>>                    // To start reading the next line after the start "Procedure" or "Function" line
95669>>>>>>>                    Move (iCount + 1) to iLineCount
95670>>>>>>>                    // If the method declaration is split over multiple lines, then we need to get past that part
95670>>>>>>>                    While (Right(Trim(sLine), 1) = ";")
95674>>>>>>>                        If (iLineCount <= iSize) Begin
95676>>>>>>>                            Move asSourceFile[iLineCount] to sLine
95677>>>>>>>                        End
95677>>>>>>>>
95677>>>>>>>                        Else Begin
95678>>>>>>>                          Move "" to sLine
95679>>>>>>>                        End
95679>>>>>>>>
95679>>>>>>>
95679>>>>>>>                        Get _OverstrikeStrings sLine to sLine
95680>>>>>>>                        Get _RemoveEndComment of ghoRefactorFunctionLibrary sLine to sLine
95681>>>>>>>                        Increment iLineCount
95682>>>>>>>                    Loop
95683>>>>>>>>
95683>>>>>>>
95683>>>>>>>                    // Begin search line-by-line until "End_Procedure" or "End_Function"
95683>>>>>>>                    Repeat
95683>>>>>>>>
95683>>>>>>>                        If (iLineCount <= iSize) Begin
95685>>>>>>>                            Move asSourceFile[iLineCount] to sLine
95686>>>>>>>                        End
95686>>>>>>>>
95686>>>>>>>
95686>>>>>>>                        Move (Trim(sLine)) to sLine
95687>>>>>>>                        Get _OverstrikeStrings of ghoRefactorFunctionLibrary sLine to sLine
95688>>>>>>>                        Get _RemoveEndComment  of ghoRefactorFunctionLibrary sLine to sLine
95689>>>>>>>                        Get IsCommentLine      of ghoRefactorFunctionLibrary sLine to bComment
95690>>>>>>>                        Get IsMethodEnd        of ghoRefactorFunctionLibrary sLine to bMethodEnd
95691>>>>>>>                        If (bComment = False and bMethodEnd = False and Trim(sLine) <> "") Begin
95693>>>>>>>                            Get RemoveLocalKeyWord of ghoRefactorFunctionLibrary (&sLine) to bIgnore
95694>>>>>>>
95694>>>>>>>                            // Does the line contain one or more variable declarations?
95694>>>>>>>                            Get IsVariableDeclarationLine of ghoRefactorFunctionLibrary sLine to bVariableDeclaration
95695>>>>>>>                            If (bVariableDeclaration = True) Begin
95697>>>>>>>                            // Remove the data type command
95697>>>>>>>                                Get _RemoveFirstWord of ghoRefactorFunctionLibrary sLine to sVars
95698>>>>>>>                                Move (StrSplitToArray(Trim(sVars), " ")) to asVars
95699>>>>>>>
95699>>>>>>>                                // Loop through the variable's array and add to struct array of locally declared variables.
95699>>>>>>>                                // Need to do this here because we don't know where the programmer will place variable declarations,
95699>>>>>>>                                // so we need to update the array as they occur.
95699>>>>>>>                                Move (SizeOfArray(asVars)) to iItems
95700>>>>>>>                                Decrement iItems
95701>>>>>>>                                For iCounter From 0 to iItems
95707>>>>>>>>
95707>>>>>>>                                    Move asVars[iCounter] to sVariableName
95708>>>>>>>                                    Move (SizeOfArray(asLocalVars)) to iArrayCount
95709>>>>>>>
95709>>>>>>>                                    // If the procedure or function line is wrapped, it may
95709>>>>>>>                                    // contain the variable type, and we don't want that
95709>>>>>>>                                    // showing up as an unused variable
95709>>>>>>>                                    If ((not((CS_VarTypes + ";") contains Uppercase(sVariableName+";")) or not(CS_VarArrayTypes contains Uppercase(sVariableName))) and Trim(sVariableName) <> "") Begin
95711>>>>>>>                                        Move sVariableName    to asLocalVars[iArrayCount].VarName
95712>>>>>>>                                        Move False            to asLocalVars[iArrayCount].bInUse
95713>>>>>>>                                        Move sMethodName      to asLocalVars[iArrayCount].MethodName
95714>>>>>>>                                        // Array item number (zero based) to source code line number:
95714>>>>>>>                                        Move (iLineCount + 1) to asLocalVars[iArrayCount].Line#
95715>>>>>>>                                    End
95715>>>>>>>>
95715>>>>>>>                                Loop
95716>>>>>>>>
95716>>>>>>>                            End
95716>>>>>>>>
95716>>>>>>>
95716>>>>>>>                            // If not a variable declaration line. For each line, we look in the asLocalVars array,
95716>>>>>>>                            // and if the variable is found we mark it as "used"
95716>>>>>>>                            Else Begin
95717>>>>>>>                                If (Trim(sLine) <> "") Begin
95719>>>>>>>                                    Move (SizeOfArray(asLocalVars)) to iMax
95720>>>>>>>                                    Decrement iMax
95721>>>>>>>                                    For iCounter From 0 to iMax
95727>>>>>>>>
95727>>>>>>>                                        If (asLocalVars[iCounter].bInUse = False and asLocalVars[iCounter].MethodName = sMethodName) Begin
95729>>>>>>>                                            Get IsVariableInLine of ghoRefactorFunctionLibrary sLine asLocalVars[iCounter].VarName to bIsVariable
95730>>>>>>>                                            If (bIsVariable = True) Begin
95732>>>>>>>                                                // Mark as found
95732>>>>>>>                                                Move True to asLocalVars[iCounter].bInUse
95733>>>>>>>                                            End
95733>>>>>>>>
95733>>>>>>>                                        End
95733>>>>>>>>
95733>>>>>>>                                    Loop
95734>>>>>>>>
95734>>>>>>>                                End
95734>>>>>>>>
95734>>>>>>>                            End
95734>>>>>>>>
95734>>>>>>>                        End
95734>>>>>>>>
95734>>>>>>>
95734>>>>>>>                        Increment iLineCount
95735>>>>>>>                    Until (bMethodEnd or iCount = iSize or iLineCount >= iSize)
95737>>>>>>>                End
95737>>>>>>>>
95737>>>>>>>            End
95737>>>>>>>>
95737>>>>>>>            If (iCount < iLineCount) Begin
95739>>>>>>>                Move iLineCount to iCount
95740>>>>>>>            End
95740>>>>>>>>
95740>>>>>>>        Loop
95741>>>>>>>>
95741>>>>>>>
95741>>>>>>>        If (SizeOfArray(asLocalVars)) Begin
95743>>>>>>>            Send RemoveUnusedVariablesFromSourceArray (&asSourceFile) asLocalVars (&iUnusedLocalVariables)
95744>>>>>>>        End
95744>>>>>>>>
95744>>>>>>>
95744>>>>>>>        Get piNoOfUnusedLocalVariables to iCounter
95745>>>>>>>        Set piNoOfUnusedLocalVariables to (iCounter + iUnusedLocalVariables)
95746>>>>>>>    End_Procedure
95747>>>>>>>
95747>>>>>>>End_Class
95748>>>>>Use cUnusedSourceFiles.pkg
95748>>>>>Use cScintillaRefactorEditor.pkg
95748>>>>>Use cRefactorFunctionLibrary.pkg
95748>>>>>
95748>>>>>Use cSysFileDataDictionary.dd      
95748>>>>>Use cFunctionsDataDictionary.dd
Including file: cFunctionsDataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cFunctionsDataDictionary.dd)
95748>>>>>>>Use DataDict.pkg  
95748>>>>>>>Use RefactorFunctionConstants.inc
95748>>>>>>>
95748>>>>>>>Open SysFile    
95750>>>>>>>Open Functions
Including file: Functions.fd    (C:\Projects\DF18\DfRefactor\DDSrc\Functions.fd)
95752>>>>>>>Open FunctionsA
95754>>>>>>>Set_Attribute DF_FILE_ALIAS of Functions.File_Number to DF_FILE_IS_MASTER
95757>>>>>>>Set_Attribute DF_FILE_ALIAS of FunctionsA.File_Number to DF_FILE_IS_ALIAS
95760>>>>>>>
95760>>>>>>>Struct tFunctionTypes
95760>>>>>>>    Integer iAll_Functions
95760>>>>>>>    Integer iStandard_Function
95760>>>>>>>    Integer iRemove_Function
95760>>>>>>>    Integer iEditor_Function
95760>>>>>>>    Integer iReport_Function   
95760>>>>>>>    Integer iReport_FunctionAll
95760>>>>>>>    Integer iOther_Function
95760>>>>>>>    Integer iOther_FunctionAll
95760>>>>>>>End_Struct
95760>>>>>>>
95760>>>>>>>Enum_List
95760>>>>>>>    Define eAll_Functions         for 0 
95760>>>>>>>    Define eStandard_Function     for 1   // One source line at a time will be passed for these functions.
95760>>>>>>>    Define eRemove_Function       for 2   // One source line at a time will be passed for these functions.
95760>>>>>>>    Define eEditor_Function       for 3   // A source file as a string array will be passed
95760>>>>>>>    Define eReport_Function       for 4   // A source file as a string array. Makes no source changes.
95760>>>>>>>    Define eReport_FunctionAll    for 5   // Makes no source changes.
95760>>>>>>>    Define eOther_Function        for 6   // A source file as a string array will be passed.
95760>>>>>>>    Define eOther_FunctionAll     for 7   // All selected files as a string array will be passed. 
95760>>>>>>>End_Enum_List
95760>>>>>>>
95760>>>>>>>Define CS_All_Functions             for "All functions"
95760>>>>>>>Define CS_Standard_Function         for "Standard - Line-by-line"
95760>>>>>>>Define CS_Remove_Function           for "Remove   - Line-by-line"
95760>>>>>>>Define CS_Editor_Function           for "Editor   - One File"
95760>>>>>>>Define CS_Report_Function           for "Report   - One File"   // Makes no source changes.
95760>>>>>>>Define CS_Report_FunctionAll        for "Report   - All Files"  // Makes no source changes.
95760>>>>>>>Define CS_Other_Function            for "Other    - One File"
95760>>>>>>>Define CS_Other_FunctionAll         for "Other    - All Files"
95760>>>>>>>
95760>>>>>>>Object oFunctionTypes is a DescriptionValidationTable
95762>>>>>>>    Procedure Fill_List
95765>>>>>>>        Forward Send Fill_List
95767>>>>>>>        Send Add_Table_Value eStandard_Function   CS_Standard_Function
95768>>>>>>>        Send Add_Table_Value eRemove_Function     CS_Remove_Function
95769>>>>>>>        Send Add_Table_Value eEditor_Function     CS_Editor_Function
95770>>>>>>>        Send Add_Table_Value eReport_Function     CS_Report_Function
95771>>>>>>>        Send Add_Table_Value eReport_FunctionAll  CS_Report_FunctionAll
95772>>>>>>>        Send Add_Table_Value eOther_Function      CS_Other_Function
95773>>>>>>>        Send Add_Table_Value eOther_FunctionAll   CS_Other_FunctionAll
95774>>>>>>>    End_Procedure
95775>>>>>>>End_Object
95776>>>>>>>
95776>>>>>>>Register_Object oFunctions_sl
95776>>>>>>>
95776>>>>>>>Class cFunctionsDataDictionary is a DataDictionary
95777>>>>>>>    
95777>>>>>>>    Procedure Construct_Object
95779>>>>>>>        Forward Send Construct_Object        
95781>>>>>>>        
95781>>>>>>>        Property Integer piFunctionType eAll_Functions
95782>>>>>>>
95782>>>>>>>        Set Main_File to Functions.File_Number
95783>>>>>>>        Set Add_System_File to SysFile.File_Number DD_Lock_On_All
95784>>>>>>>
95784>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
95785>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
95786>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
95787>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
95788>>>>>>>
95788>>>>>>>        Set Field_Auto_Increment Field Functions.ID to File_Field SysFile.Next_Functions_ID
95789>>>>>>>        Set Key_Field_State Field Functions.ID to True
95790>>>>>>>        Set Field_Prompt_Object Field Functions.ID to oFunctions_sl
95791>>>>>>>        Set Status_Help Field Functions.ID to "Automatically generated ID number"
95792>>>>>>>
95792>>>>>>>        Set Field_Prompt_Object Field Functions.Function_Name to oFunctions_sl
95793>>>>>>>        Set Status_Help Field Functions.Function_Name to "the name entered must be exactly the same as the function name itself. Then the code must be added to the cRefactorDbView class (cRefactorDbView.pkg). See class code for standard function parameters."
95794>>>>>>>
95794>>>>>>>        Set Status_Help Field Functions.Function_Description to "A short description of what the function does. Appears in grids next to the function name."
95795>>>>>>>
95795>>>>>>>        Set Status_Help Field Functions.Function_Help to "Longer explanation on what the function does. Shows when the mouse hovers above a function grid."
95796>>>>>>>
95796>>>>>>>        Set Status_Help Field Functions.Function_Summary to "Function summary text that appears after a refactoring has run."
95797>>>>>>>
95797>>>>>>>        Set Field_Class_Name Field Functions.Selected to "Checkbox"
95798>>>>>>>        Set Field_Checkbox_Values Field Functions.Selected to "1" "0"
95799>>>>>>>        Set Status_Help Field Functions.Selected to "Selected function"
95800>>>>>>>
95800>>>>>>>        Set Field_Value_Table Field Functions.Type to oFunctionTypes
95801>>>>>>>        Set Status_Help Field Functions.Type to "The type of function. The type determines what data is send to the function: Line-by-line, as a String array, or all files as a string array."
95802>>>>>>>        Set Field_Class_Name Field Functions.Type to "Combo"
95803>>>>>>>
95803>>>>>>>        Set Status_Help Field Functions.Count to "Counter for the current refactoring run."
95804>>>>>>>
95804>>>>>>>        Set Field_Class_Name Field Functions.bHasParameter to "Checkbox"
95805>>>>>>>        Set Field_Checkbox_Values Field Functions.bHasParameter to "1" "0"
95806>>>>>>>        Set Status_Help Field Functions.bHasParameter to "This is a system function and may not be changed, because it is handled a bit differently."
95807>>>>>>>
95807>>>>>>>    End_Procedure
95808>>>>>>>
95808>>>>>>>    Procedure Field_Defaults
95810>>>>>>>        Forward Send Field_Defaults
95812>>>>>>>        Set Field_Changed_Value Field Functions.Selected to 0
95813>>>>>>>        Set Field_Changed_Value Field Functions.Type to 0
95814>>>>>>>        Set Field_Changed_Value Field Functions.bHasParameter to 0
95815>>>>>>>    End_Procedure  
95816>>>>>>>    
95816>>>>>>>    Procedure Update
95818>>>>>>>        Integer iType iIndex
95818>>>>>>>        Boolean bState bChangeWriteProtected 
95818>>>>>>>        String sFunctionName sParam sValue
95818>>>>>>>        String[] asValidations
95819>>>>>>>        
95819>>>>>>>        Move Functions.Selected to bState
95820>>>>>>>        Move Functions.Type to iType
95821>>>>>>>        Send AdjustSelected bState iType
95822>>>>>>>        Move (Trim(Functions.Function_Name)) to sFunctionName
95823>>>>>>>        If (not(Lowercase(Functions.Function_Help) contains Lowercase("Function:" * String(sFunctionName)))) Begin
95825>>>>>>>            Move (Trim(Functions.Function_Help) * String("(Function:" * String(sFunctionName) + ")")) ;                to Functions.Function_Help
95826>>>>>>>        End      
95826>>>>>>>>
95826>>>>>>>        
95826>>>>>>>        If (Functions.bHasParameter = True) Begin
95828>>>>>>>            Move (Trim(Functions.Parameter)) to sParam    
95829>>>>>>>            Move (Trim(Functions.ParameterValidation)) to sValue
95830>>>>>>>            Move (StrSplitToArray(sValue, ",")) to asValidations
95831>>>>>>>            Move (SearchArray(sParam, asValidations)) to iIndex
95832>>>>>>>            If (iIndex = -1) Begin
95834>>>>>>>                Send UserError ("Invalid value. Must be one of:" * String(sValue))
95835>>>>>>>            End
95835>>>>>>>>
95835>>>>>>>        End 
95835>>>>>>>>
95835>>>>>>>        Else Begin
95836>>>>>>>            If (Trim(Functions.Parameter) <> "") Begin
95838>>>>>>>                Send UserError "This function doesn't use a parameter and you are therefore not allowed to enter one."
95839>>>>>>>            End
95839>>>>>>>>
95839>>>>>>>        End
95839>>>>>>>>
95839>>>>>>>    End_Procedure
95840>>>>>>>    
95840>>>>>>>    Procedure Backout
95842>>>>>>>        Integer iType iState
95842>>>>>>>        Move Functions.Selected to iState
95843>>>>>>>        Move Functions.Type to iType
95844>>>>>>>        Send AdjustSelected (-iState) iType
95845>>>>>>>    End_Procedure  
95846>>>>>>>    
95846>>>>>>>    Procedure AdjustSelected Integer iState Integer iType 
95848>>>>>>>        String sFunctionName
95848>>>>>>>        Integer iTotFunctions
95848>>>>>>>
95848>>>>>>>        Get TotalNoOfFunctions to iTotFunctions
95849>>>>>>>        Move (Lowercase(Trim(Functions.Function_Name))) to sFunctionName  
95850>>>>>>>        // For handling of special functions.
95850>>>>>>>        Case Begin
95850>>>>>>>            Case (sFunctionName = Lowercase(CS_CountSourceLines)) 
95852>>>>>>>                Move Functions.Selected to SysFile.bCountSourceLines  
95853>>>>>>>                Case Break
95854>>>>>>>            Case (sFunctionName = Lowercase(CS_EditorDropSelf))
95857>>>>>>>                Move Functions.Selected to SysFile.bEditorDropSelf
95858>>>>>>>                Case Break
95859>>>>>>>        Case End
95859>>>>>>>         
95859>>>>>>>        If (iState = 0 or SysFile.SelectedFunctionTotal < iTotFunctions) Begin
95861>>>>>>>            Add iState to SysFile.SelectedFunctionTotal
95862>>>>>>>        End
95862>>>>>>>>
95862>>>>>>>            
95862>>>>>>>        Case Begin
95862>>>>>>>            Case (iType = eStandard_Function) 
95864>>>>>>>                Add iState to SysFile.SelectedStandardFunctions
95865>>>>>>>                Case Break
95866>>>>>>>            Case (iType = eRemove_Function) 
95869>>>>>>>                Add iState to SysFile.SelectedRemoveFunctions
95870>>>>>>>                Case Break
95871>>>>>>>            Case (iType = eEditor_Function) 
95874>>>>>>>                Add iState to SysFile.SelectedEditorFunctions
95875>>>>>>>                Case Break
95876>>>>>>>            Case (iType = eReport_Function) 
95879>>>>>>>                Add iState to SysFile.SelectedReportFunctions
95880>>>>>>>                Case Break
95881>>>>>>>            Case (iType = eReport_FunctionAll) 
95884>>>>>>>                Add iState to SysFile.SelectedReportAllFunctions
95885>>>>>>>                Case Break
95886>>>>>>>            Case (iType = eOther_Function) 
95889>>>>>>>                Add iState to SysFile.SelectedOtherFunctions
95890>>>>>>>                Case Break
95891>>>>>>>            Case (iType = eOther_FunctionAll) 
95894>>>>>>>                Add iState to SysFile.SelectedOtherAllFunctions
95895>>>>>>>                Case Break
95896>>>>>>>        Case End      
95896>>>>>>>            
95896>>>>>>>        SaveRecord SysFile
95897>>>>>>>    End_Procedure
95898>>>>>>>    
95898>>>>>>>    Procedure SelectAll
95900>>>>>>>        Send SelectItems True
95901>>>>>>>    End_Procedure
95902>>>>>>>    
95902>>>>>>>    Procedure DeSelectAll
95904>>>>>>>        Send SelectItems False
95905>>>>>>>    End_Procedure
95906>>>>>>>    
95906>>>>>>>    Procedure SelectItems Boolean bSelect
95908>>>>>>>        Boolean bFound
95908>>>>>>>        Integer iItems iSelected iType iID
95908>>>>>>>        tFunctionTypes FunctionsTypes
95908>>>>>>>        tFunctionTypes FunctionsTypes
95908>>>>>>>        
95908>>>>>>>        Get piFunctionType to iType
95909>>>>>>>        If (bSelect = True) Begin
95911>>>>>>>            Move 1 to iSelected
95912>>>>>>>        End          
95912>>>>>>>>
95912>>>>>>>        Else Begin
95913>>>>>>>            Move -1 to iSelected
95914>>>>>>>        End
95914>>>>>>>>
95914>>>>>>>        
95914>>>>>>>        Move Functions.ID to iID
95915>>>>>>>
95915>>>>>>>        Constraint_Set (Self) Clear  
95917>>>>>>>        Constrained_Clear eq Functions by Index.2 
95920>>>>>>>        If (iType <> eAll_Functions) Begin
95922>>>>>>>            Constrain Functions.Type eq iType
95924>>>>>>>        End
95924>>>>>>>>
95924>>>>>>>        Constrained_Find First Functions by Index.2
95929>>>>>>>        While (Found)
95933>>>>>>>            Reread Functions SysFile    
95940>>>>>>>                Move bSelect to Functions.Selected
95941>>>>>>>                SaveRecord Functions
95942>>>>>>>                Send AdjustSelected bSelect iType
95943>>>>>>>            Unlock
95944>>>>>>>>
95944>>>>>>>            Constrained_Find Next
95945>>>>>>>        Loop
95946>>>>>>>>
95946>>>>>>>
95946>>>>>>>        If (bSelect = False) Begin
95948>>>>>>>            Reread SysFile
95952>>>>>>>                Move 0 to SysFile.SelectedFunctionTotal
95953>>>>>>>                Move 0 to SysFile.SelectedStandardFunctions          
95954>>>>>>>                Move 0 to SysFile.SelectedEditorFunctions          
95955>>>>>>>                Move 0 to SysFile.SelectedReportFunctions          
95956>>>>>>>                Move 0 to SysFile.SelectedReportAllFunctions          
95957>>>>>>>                Move 0 to SysFile.SelectedRemoveFunctions          
95958>>>>>>>                Move 0 to SysFile.SelectedOtherFunctions          
95959>>>>>>>                Move 0 to SysFile.SelectedOtherAllFunctions          
95960>>>>>>>                SaveRecord SysFile
95961>>>>>>>            Unlock
95962>>>>>>>>
95962>>>>>>>        End
95962>>>>>>>>
95962>>>>>>>
95962>>>>>>>    End_Procedure
95963>>>>>>>    
95963>>>>>>>    // Pass one of the pre-defined function types;
95963>>>>>>>    //   eStandard_Function, eEditor_Function, eReport_Function or eRemove_Function  
95963>>>>>>>    // Returns number of selected functions for the passed type.
95963>>>>>>>    Function SelectedTypeFunctions Integer iType Returns Integer
95965>>>>>>>        Integer iItems        
95965>>>>>>>        
95965>>>>>>>        Case Begin
95965>>>>>>>            Case (iType = eStandard_Function) 
95967>>>>>>>                Move SysFile.SelectedStandardFunctions to iItems
95968>>>>>>>                Case Break
95969>>>>>>>            Case (iType = eEditor_Function) 
95972>>>>>>>                Move SysFile.SelectedEditorFunctions to iItems
95973>>>>>>>                Case Break
95974>>>>>>>            Case (iType = eReport_Function) 
95977>>>>>>>                Move SysFile.SelectedReportFunctions to iItems
95978>>>>>>>                Case Break
95979>>>>>>>            Case (iType = eRemove_Function) 
95982>>>>>>>                Move SysFile.SelectedRemoveFunctions to iItems
95983>>>>>>>                Case Break
95984>>>>>>>            Case Else 
95984>>>>>>>                Move SysFile.SelectedFunctionTotal to iItems                               
95985>>>>>>>        Case End
95985>>>>>>>
95985>>>>>>>        Function_Return iItems
95986>>>>>>>    End_Function   
95987>>>>>>>    
95987>>>>>>>    // Finds the first selected Function record for the passed type.
95987>>>>>>>    // Returns True if a match was found.
95987>>>>>>>    // NOTE: It leaves the FunctionsA global record buffer after
95987>>>>>>>    //       a successful find, to be used elsewhere.
95987>>>>>>>    Function FindFirstSelectedFunction Integer iType Returns Boolean
95989>>>>>>>        Clear FunctionsA
95990>>>>>>>        Move True  to FunctionsA.Selected
95991>>>>>>>        Move iType to FunctionsA.Type
95992>>>>>>>        Find gt FunctionsA by Index.4
95993>>>>>>>>
95993>>>>>>>        Function_Return (Found and FunctionsA.Type = iType)
95994>>>>>>>    End_Function
95995>>>>>>>    
95995>>>>>>>    // Finds the next selected function for the passed type
95995>>>>>>>    // Returns True if a match was found.
95995>>>>>>>    // It is mandatory to start a loop by first calling the 
95995>>>>>>>    // FindFirstSelectedFunction function.
95995>>>>>>>    // NOTE: It leaves the FunctionsA global record buffer after
95995>>>>>>>    //       a successful find, to be used elsewhere.
95995>>>>>>>    Function FindNextSelectedFunction Integer iType Returns Boolean
95997>>>>>>>        Move True  to FunctionsA.Selected
95998>>>>>>>        Move iType to FunctionsA.Type        
95999>>>>>>>        Find gt FunctionsA by Index.4
96000>>>>>>>>
96000>>>>>>>        Function_Return (Found and FunctionsA.Type = iType)
96001>>>>>>>    End_Function
96002>>>>>>>    
96002>>>>>>>    // Returns the total number of selected functions for all types.
96002>>>>>>>    Function SelectedFunctions Returns Integer
96004>>>>>>>        Function_Return (SysFile.SelectedFunctionTotal)
96005>>>>>>>    End_Function  
96006>>>>>>>    
96006>>>>>>>    // Returns the total number of functions in the database.
96006>>>>>>>    Function TotalNoOfFunctions Returns Integer
96008>>>>>>>        Integer iItems
96008>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of FunctionsA.File_Number to iItems
96011>>>>>>>        Function_Return iItems
96012>>>>>>>    End_Function
96013>>>>>>>    
96013>>>>>>>    // Zeroe's out all line counters
96013>>>>>>>    Procedure ResetLineCounters
96015>>>>>>>        Constraint_Set (Self  + 1) Clear  
96017>>>>>>>        Constrained_Clear eq FunctionsA by Index.1
96020>>>>>>>        Constrained_Find First FunctionsA by Index.1
96025>>>>>>>        While (Found)
96029>>>>>>>            Reread FunctionsA
96033>>>>>>>                Move 0 to FunctionsA.Count
96034>>>>>>>                SaveRecord FunctionsA
96035>>>>>>>            Unlock
96036>>>>>>>>
96036>>>>>>>            Constrained_Find Next
96037>>>>>>>        Loop                                 
96038>>>>>>>>
96038>>>>>>>        Reread SysFile
96042>>>>>>>            Move 0 to SysFile.iCountNumberOfFiles  
96043>>>>>>>            Move 0 to SysFile.iCountNumberOfChangedFiles
96044>>>>>>>            Move 0 to SysFile.iCountNumberOfLines    
96045>>>>>>>            Move 0 to SysFile.iCountProjectObjectStructures
96046>>>>>>>            Move 0 to SysFile.iCountRemoveBlankLines
96047>>>>>>>            Move 0 to SysFile.iCountUnusedSourceFiles 
96048>>>>>>>            Move 0 to SysFile.iCountUnusedLocals
96049>>>>>>>            SaveRecord SysFile
96050>>>>>>>        Unlock
96051>>>>>>>>
96051>>>>>>>    End_Procedure
96052>>>>>>>    
96052>>>>>>>End_Class
96053>>>>>>>
96053>>>>>>>Use Functions.sl
Including file: Functions.sl    (C:\Projects\DF18\DfRefactor\AppSrc\Functions.sl)
96053>>>>>>>>>// Functions.sl
96053>>>>>>>>>// Functions Lookup List
96053>>>>>>>>>
96053>>>>>>>>>Use DFClient.pkg
96053>>>>>>>>>Use cDbCJGridPromptList.pkg
96053>>>>>>>>>Use cDbCJGridColumn.pkg
96053>>>>>>>>>Use Windows.pkg
96053>>>>>>>>>
96053>>>>>>>>>Use cFunctionsDataDictionary.dd
96053>>>>>>>>>
96053>>>>>>>>>CD_Popup_Object oFunctions_sl is a dbModalPanel
96071>>>>>>>>>>
96071>>>>>>>>>    Set Location to 5 5
96072>>>>>>>>>    Set Size to 134 269
96073>>>>>>>>>    Set Label To "Functions Lookup List"
96074>>>>>>>>>    Set Border_Style to Border_Thick
96075>>>>>>>>>    Set Minimize_Icon to False
96076>>>>>>>>>
96076>>>>>>>>>    Object oFunctions_DD is a cFunctionsDataDictionary
96078>>>>>>>>>    End_Object 
96079>>>>>>>>>
96079>>>>>>>>>    Set Main_DD To oFunctions_DD
96080>>>>>>>>>    Set Server  To oFunctions_DD
96081>>>>>>>>>
96081>>>>>>>>>    Object oSelList is a cDbCJGridPromptList
96083>>>>>>>>>        Set Size to 105 259
96084>>>>>>>>>        Set Location to 5 5
96085>>>>>>>>>        Set peAnchors to anAll
96086>>>>>>>>>        Set psLayoutSection to "oFunctions_sl_oSelList"
96087>>>>>>>>>        Set Ordering to 1
96088>>>>>>>>>        Set pbAutoServer to True
96089>>>>>>>>>
96089>>>>>>>>>        Object oFunctions_ID is a cDbCJGridColumn
96091>>>>>>>>>            Entry_Item Functions.ID
96092>>>>>>>>>            Set piWidth to 31
96093>>>>>>>>>            Set psCaption to "ID"
96094>>>>>>>>>        End_Object 
96095>>>>>>>>>
96095>>>>>>>>>        Object oFunctions_Function_Name is a cDbCJGridColumn
96097>>>>>>>>>            Entry_Item Functions.Function_Name
96098>>>>>>>>>            Set piWidth to 284
96099>>>>>>>>>            Set psCaption to "Function Name"
96100>>>>>>>>>        End_Object 
96101>>>>>>>>>
96101>>>>>>>>>        Object oFunctions_Type is a cDbCJGridColumn
96103>>>>>>>>>            Entry_Item Functions.Type
96104>>>>>>>>>            Set piWidth to 117
96105>>>>>>>>>            Set psCaption to "Type"
96106>>>>>>>>>            Set pbComboButton to True
96107>>>>>>>>>        End_Object 
96108>>>>>>>>>
96108>>>>>>>>>    End_Object 
96109>>>>>>>>>
96109>>>>>>>>>    Object oOk_bn is a Button
96111>>>>>>>>>        Set Label to "&Ok"
96112>>>>>>>>>        Set Location to 115 106
96113>>>>>>>>>        Set peAnchors to anBottomRight
96114>>>>>>>>>
96114>>>>>>>>>        Procedure OnClick
96117>>>>>>>>>            Send OK of oSelList
96118>>>>>>>>>        End_Procedure
96119>>>>>>>>>
96119>>>>>>>>>    End_Object 
96120>>>>>>>>>
96120>>>>>>>>>    Object oCancel_bn is a Button
96122>>>>>>>>>        Set Label to "&Cancel"
96123>>>>>>>>>        Set Location to 115 160
96124>>>>>>>>>        Set peAnchors to anBottomRight
96125>>>>>>>>>
96125>>>>>>>>>        Procedure OnClick
96128>>>>>>>>>            Send Cancel of oSelList
96129>>>>>>>>>        End_Procedure
96130>>>>>>>>>
96130>>>>>>>>>    End_Object 
96131>>>>>>>>>
96131>>>>>>>>>    Object oSearch_bn is a Button
96133>>>>>>>>>        Set Label to "&Search..."
96134>>>>>>>>>        Set Location to 115 214
96135>>>>>>>>>        Set peAnchors to anBottomRight
96136>>>>>>>>>
96136>>>>>>>>>        Procedure OnClick
96139>>>>>>>>>            Send Search of oSelList
96140>>>>>>>>>        End_Procedure
96141>>>>>>>>>
96141>>>>>>>>>    End_Object 
96142>>>>>>>>>
96142>>>>>>>>>    Procedure Activating
96145>>>>>>>>>        Set Icon to "FunctionLibrary.ico"
96146>>>>>>>>>    End_Procedure
96147>>>>>>>>>
96147>>>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOk_bn
96148>>>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_bn
96149>>>>>>>>>    On_Key Key_Alt+Key_S Send KeyAction of oSearch_bn
96150>>>>>>>>>Cd_End_Object
96152>>>>>>>>>>
96152>>>>>Use cFunctionsADataDictionary.dd
Including file: cFunctionsADataDictionary.dd    (C:\Projects\DF18\DfRefactor\DDSrc\cFunctionsADataDictionary.dd)
96152>>>>>>>Use cFunctionsDataDictionary.dd
96152>>>>>>>
96152>>>>>>>Open FunctionsA
96154>>>>>>>Set_Attribute DF_FILE_ALIAS of FunctionsA.File_Number to DF_FILE_IS_ALIAS
96157>>>>>>>
96157>>>>>>>Class cFunctionsADataDictionary is a cFunctionsDataDictionary
96158>>>>>>>    
96158>>>>>>>    Procedure Construct_Object
96160>>>>>>>        Forward Send Construct_Object
96162>>>>>>>        Set Alias_File to FunctionsA.File_Number
96163>>>>>>>        Set pbForeignReadOnly to True
96164>>>>>>>        Set pbUseDDRelates to True
96165>>>>>>>        Set pbNoCascadeDeleteStrict to True
96166>>>>>>>    End_Procedure
96167>>>>>>>    
96167>>>>>>>    Procedure Update
96169>>>>>>>    End_Procedure
96170>>>>>>> 
96170>>>>>>>    Procedure Backout
96172>>>>>>>    End_Procedure
96173>>>>>>>
96173>>>>>>>    Procedure Deleting
96175>>>>>>>    End_Procedure
96176>>>>>>>    
96176>>>>>>>    Procedure Creating
96178>>>>>>>    End_Procedure
96179>>>>>>>    
96179>>>>>>>    Function Validate_Save Returns Integer
96181>>>>>>>    End_Function
96182>>>>>>>
96182>>>>>>>    Function Validate_Delete Returns Integer
96184>>>>>>>    End_Function
96185>>>>>>>    
96185>>>>>>>    Function Validate_Cascade_Delete Returns Boolean
96187>>>>>>>    End_Function
96188>>>>>>>    
96188>>>>>>>    Procedure OnSaveRecord
96190>>>>>>>    End_Procedure
96191>>>>>>>    
96191>>>>>>>    Procedure OnPreFind Integer eMessage
96193>>>>>>>    End_Procedure
96194>>>>>>>
96194>>>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
96196>>>>>>>    End_Procedure
96197>>>>>>>    
96197>>>>>>>    Procedure OnConstrain
96199>>>>>>>    End_Procedure
96200>>>>>>>    
96200>>>>>>>End_Class
96201>>>>>
96201>>>>>
96201>>>>>Class cRefactorStatusLog is a StatusDbLog
96202>>>>>    Procedure Construct_Object
96204>>>>>        Forward Send Construct_Object
96206>>>>>        Move Self to ghoStatusLog
96207>>>>>        Open StatLog
96209>>>>>    End_Procedure                    
96210>>>>>    
96210>>>>>    Procedure OnNewRecord
96212>>>>>        String sFunctionName  
96212>>>>>        Integer iDateFormat
96212>>>>>        Move (Trim(Functions.Function_Name)) to sFunctionName
96213>>>>>        If (sFunctionName = "") Begin
96215>>>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName
96216>>>>>        End
96216>>>>>>
96216>>>>>        Move sFunctionName to StatLog.FunctionName
96217>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
96220>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
96223>>>>>        Move (CurrentDateTime()) to StatLog.Time
96224>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
96227>>>>>    End_Procedure
96228>>>>>    
96228>>>>>End_Class
96229>>>>>
96229>>>>>Class cRefactorDbView is a dbView
96230>>>>>
96230>>>>>    Procedure Construct_Object
96232>>>>>        Forward Send Construct_Object
96234>>>>>
96234>>>>>        Set Border_Style to Border_Thick
96235>>>>>        Set pbAutoActivate to True
96236>>>>>
96236>>>>>        Property String  psLineBreak ""
96237>>>>>        Property Boolean pbLastLineBreak False
96238>>>>>        
96238>>>>>        // Object handles:
96238>>>>>        Property Handle private.phoEditor
96239>>>>>        Property Handle phoBPO 
96240>>>>>        Property Handle phoRemoveUnusedLocals
96241>>>>>        Property Handle phoReportUnusedSourceFiles 
96242>>>>>        Property Handle phoDDOReStyler
96243>>>>>        
96243>>>>>        Object Status_Log is a cRefactorStatusLog
96245>>>>>            Move Self to ghoStatusLog
96246>>>>>        End_Object
96247>>>>>
96247>>>>>        Object oRemoveUnusedLocals is a cRemoveUnusedLocals
96249>>>>>            Set phoRemoveUnusedLocals to Self
96250>>>>>        End_Object
96251>>>>>    
96251>>>>>        Object oReportUnusedSourceFiles is a cUnusedSourceFiles
96253>>>>>            Set phoReportUnusedSourceFiles to Self
96254>>>>>        End_Object
96255>>>>>        
96255>>>>>        Object oDDOReStyler is a cDDOReStyler
96257>>>>>            Set phoDDOReStyler to Self
96258>>>>>        End_Object
96259>>>>>
96259>>>>>        // *** MAIN FUNCTION LIBRARY ***
96259>>>>>        //
96259>>>>>        Object oRefactorFunctionLibrary is a cRefactorFunctionLibrary
96261>>>>>        End_Object
96262>>>>>        
96262>>>>>        Set pbAutoActivate to True
96263>>>>>        Set Verify_Save_msg to (RefFunc(No_Confirmation))
96264>>>>>
96264>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
96265>>>>>        On_Key Key_Escape Send None
96266>>>>>        On_Key Key_Ctrl+Key_F4 Send None   
96267>>>>>        Send Switch_Prior_View //of (ClientAreaObject (ghoCommandBars))
96268>>>>>    End_Procedure
96269>>>>>
96269>>>>>    Procedure Set phoEditor Handle ho
96271>>>>>        Set private.phoEditor to ho
96272>>>>>        Set phoEditor of ghoRefactorFunctionLibrary to ho
96273>>>>>    End_Procedure
96274>>>>>    
96274>>>>>    Function phoEditor Returns Handle
96276>>>>>        Function_Return (private.phoEditor(Self))
96277>>>>>    End_Function
96278>>>>>        
96278>>>>>    Procedure RefactorCheckboxChanged Boolean bState Handle hObject Boolean bReportFunction
96280>>>>>    End_Procedure
96281>>>>>
96281>>>>>    Procedure WaitForFileToGetWritten String sFile
96283>>>>>        Integer iCh iMaxSec
96283>>>>>        Boolean bOK bExist
96283>>>>>        DateTime dtStart dtStartCheck
96283>>>>>        TimeSpan tsTime
96283>>>>>
96283>>>>>        Move False to bOK
96284>>>>>        Move 3 to iMaxSec
96285>>>>>        Get vFilePathExists sFile to bExist
96286>>>>>        If (bExist = False) Begin
96288>>>>>            Procedure_Return
96289>>>>>        End
96289>>>>>>
96289>>>>>        Move (CurrentDateTime()) to dtStart
96290>>>>>        Get Seq_New_Channel to iCh   
96291>>>>>        // No channel available 
96291>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
96293>>>>>            Error "No Channel Available for Process: Procedure 'WaitForFileToGetWritten'"
96294>>>>>>
96294>>>>>            Procedure_Return
96295>>>>>        End
96295>>>>>>
96295>>>>>        
96295>>>>>        Repeat
96295>>>>>>
96295>>>>>            Direct_Input channel iCh
96296>>>>>            Move (SeqEof = False) to bOK
96297>>>>>            If (bOK = False) Begin
96299>>>>>                Close_Input channel iCh
96301>>>>>            End
96301>>>>>>
96301>>>>>            Move (CurrentDateTime()) to dtStartCheck
96302>>>>>            Move (dtStartCheck - dtStart) to tsTime
96303>>>>>            If (SpanSeconds(tsTime) > iMaxSec) Begin
96305>>>>>                Move True to bOK
96306>>>>>            End
96306>>>>>>
96306>>>>>        Until (bOK = True)
96308>>>>>
96308>>>>>        Close_Input channel iCh
96310>>>>>        Send Seq_Release_Channel iCh
96311>>>>>    End_Procedure
96312>>>>>
96312>>>>>    Function ReadSourceFileToArray String sSourceFile Returns String[]
96314>>>>>        Boolean bLastLineBreak bEndOfFile bFirstLine
96314>>>>>        Integer iLine iChannel iFileSize
96314>>>>>        String sLine sLastLine sLineBreak sFileNameOnly
96314>>>>>        String[] asSourceFile
96315>>>>>
96315>>>>>        Move 0 to iLine
96316>>>>>        Move True  to bFirstLine
96317>>>>>        Move False to bEndOfFile
96318>>>>>        Move False to bLastLineBreak
96319>>>>>        Move ""    to sLastLine
96320>>>>>
96320>>>>>        Get Seq_New_Channel to iChannel
96321>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
96323>>>>>            Error "No Channel Available for Process: Procedure 'ReadSourceFileToArray'"
96324>>>>>>
96324>>>>>            Function_Return asSourceFile
96325>>>>>        End
96325>>>>>>
96325>>>>>
96325>>>>>        Get ParseFileName sSourceFile to sFileNameOnly
96326>>>>>        Set Message_Text of ghoStatusPanel to ("Reading:" * String(sFileNameOnly))
96327>>>>>        Get vWin32_APIFileSize sSourceFile to iFileSize
96328>>>>>        Move (ResizeArray(asSourceFile, iFileSize)) to asSourceFile
96329>>>>>
96329>>>>>        // Need to use binary read mode if we want to preserve tab characters and not have automatic tab replacement
96329>>>>>        // filemode options don't seem to work as documented, not sure why.
96329>>>>>        // Direct_Input channel iInChannel ("binary: "+"cr: 13: "+"eof: 26: "+sSourceFile)
96329>>>>>        // Direct_Input channel iInChannel ("binary: "+"cr: 13:"+"eof: 26:"+sSourceFile)
96329>>>>>        Direct_Input channel iChannel ("binary:" + sSourceFile)
96331>>>>>
96331>>>>>        While (bEndOfFile = False)
96335>>>>>            Readln channel iChannel sLine
96337>>>>>            Move (SeqEof) to bEndOfFile
96338>>>>>            If (bEndOfFile and Length(sLastLine) > 0) Begin
96340>>>>>                If (Right(sLastLine, 1) = CS_CR) Begin
96342>>>>>                    Move True to bLastLineBreak
96343>>>>>                End
96343>>>>>>
96343>>>>>            End
96343>>>>>>
96343>>>>>            Move sLine to sLastLine
96344>>>>>            If (bFirstLine = True) Begin
96346>>>>>                Move False to bFirstLine
96347>>>>>                // Determine the linebreak character to use for the file based on what is in the first line
96347>>>>>                // The readline automatically reads Until LF, but does not report LF back in the string
96347>>>>>                If (Length(sLine) > 0 and Right(sLine, 1) = CS_CR) Begin
96349>>>>>                    Move CS_CRLF to sLineBreak
96350>>>>>                End
96350>>>>>>
96350>>>>>                Else Begin
96351>>>>>                    Move CS_LF to sLineBreak
96352>>>>>                End
96352>>>>>>
96352>>>>>                Set psLineBreak to sLineBreak
96353>>>>>            End
96353>>>>>>
96353>>>>>            If (sLineBreak = CS_CRLF) Begin
96355>>>>>                If (Right(sLine, 1) = CS_CR) Begin
96357>>>>>                    Move (Left(sLine, Length(sLine) - 1)) to sLine
96358>>>>>                End
96358>>>>>>
96358>>>>>            End
96358>>>>>>
96358>>>>>            If (bEndOfFile = False) Begin
96360>>>>>                Move sLine to asSourceFile[iLine]
96361>>>>>                Increment iLine
96362>>>>>            End
96362>>>>>>
96362>>>>>        Loop
96363>>>>>>
96363>>>>>
96363>>>>>        Move (ResizeArray(asSourceFile, iLine)) to asSourceFile
96364>>>>>        Set pbLastLineBreak to bLastLineBreak
96365>>>>>        Close_Input channel iChannel
96367>>>>>        Send Seq_Release_Channel iChannel
96368>>>>>
96368>>>>>        Function_Return asSourceFile
96369>>>>>    End_Function
96370>>>>>
96370>>>>>    Function WriteArrayToSourceFile String sSourceFile String[] asNewSourceFile Returns Boolean
96372>>>>>        Boolean bLastLineBreak
96372>>>>>        Integer iOutChannel iSize iCount
96372>>>>>        String  sLineBreak
96372>>>>>
96372>>>>>        Move False to Err
96373>>>>>        Get psLineBreak     to sLineBreak
96374>>>>>        Get pbLastLineBreak to bLastLineBreak
96375>>>>>        Get Seq_New_Channel to iOutChannel
96376>>>>>        If (iOutChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
96378>>>>>            Error "No Channel Available for Process: Procedure 'WriteArrayToSourceFile'"
96379>>>>>>
96379>>>>>            Function_Return False
96380>>>>>        End
96380>>>>>>
96380>>>>>
96380>>>>>        Direct_Output channel iOutChannel sSourceFile
96382>>>>>        Move (SizeOfArray(asNewSourceFile)) to iSize
96383>>>>>        Decrement iSize   
96384>>>>>        If (iSize >= 0) Begin
96386>>>>>            For iCount from 0 to (iSize-1)
96392>>>>>>
96392>>>>>                Write channel iOutChannel asNewSourceFile[iCount] sLineBreak
96395>>>>>            Loop
96396>>>>>>
96396>>>>>            If (bLastLineBreak=True) Begin
96398>>>>>                Write channel iOutChannel asNewSourceFile[iSize] sLineBreak
96401>>>>>            End
96401>>>>>>
96401>>>>>            Else Begin
96402>>>>>                Write channel iOutChannel asNewSourceFile[iSize]
96404>>>>>            End
96404>>>>>>
96404>>>>>        End
96404>>>>>>
96404>>>>>
96404>>>>>        Close_Input channel iOutChannel
96406>>>>>        Send Seq_Release_Channel iOutChannel
96407>>>>>        Function_Return (Err = False)
96408>>>>>    End_Function  
96409>>>>>    
96409>>>>>    Function TimeSpanToString TimeSpan tsTime Returns String
96411>>>>>        Integer iDays iHours iMinutes iSeconds iMilliseconds
96411>>>>>        String  sTime
96411>>>>>
96411>>>>>        Move "" to sTime
96412>>>>>        Move (SpanDays(tsTime))    to iDays
96413>>>>>        Move (SpanHours(tsTime))   to iHours
96414>>>>>        Move (SpanMinutes(tsTime)) to iMinutes
96415>>>>>        Move (SpanSeconds(tsTime)) to iSeconds
96416>>>>>        Move (SpanMilliSeconds(tsTime)) to iMilliSeconds
96417>>>>>        If (iDays > 0) Begin   // Don't show days if it is zero
96419>>>>>            Move (String(iDays) + ":") to sTime
96420>>>>>        End
96420>>>>>>
96420>>>>>        If (iHours < 10) Begin
96422>>>>>            Move (sTime+"0") to sTime
96423>>>>>        End
96423>>>>>>
96423>>>>>        Move (sTime + String(iHours) + ":") to sTime
96424>>>>>        If (iMinutes < 10) Begin
96426>>>>>            Move (sTime + "0") to sTime
96427>>>>>        End
96427>>>>>>
96427>>>>>        Move (sTime + String(iMinutes) + ":") to sTime
96428>>>>>        If (iSeconds < 10) Begin
96430>>>>>            Move (sTime + "0") to sTime
96431>>>>>        End
96431>>>>>>
96431>>>>>        Move (sTime + String(iSeconds) + "." + String(iMilliSeconds)) to sTime
96432>>>>>
96432>>>>>        Function_Return sTime
96433>>>>>    End_Function
96434>>>>>
96434>>>>>    // ToDo: Should probably be done by the function in the library.
96434>>>>>    Procedure RemoveReportLogFiles String sPath
96436>>>>>        Boolean bOK
96436>>>>>        tRefactorSettings RefactorSettings
96436>>>>>        tRefactorSettings RefactorSettings
96436>>>>>
96436>>>>>        Get pRefactorSettings of ghoRefactorFunctionLibrary to RefactorSettings
96437>>>>>        Get vFolderFormat sPath to sPath
96438>>>>>        Send Info_Box "To be done! (RemoveReportLogFiles)"
96439>>>>>//        If (RefactorSettings.bUnusedSourceFiles = True) Begin
96439>>>>>//            Get vDeleteFile (sPath + CS_BackupFolder + CS_DirSeparator + CS_UnusedSourceLogFile) to bOK
96439>>>>>//        End
96439>>>>>    End_Procedure
96440>>>>>
96440>>>>>    Function pbShouldSave Returns Boolean
96442>>>>>        Boolean bChanged bIsReadOnly
96442>>>>>        Handle hoEditor
96442>>>>>
96442>>>>>        Get phoEditor to hoEditor
96443>>>>>        If (hoEditor <> 0) Begin
96445>>>>>            Get CM_IsModified of hoEditor to bChanged
96446>>>>>            Get CM_IsReadOnly of hoEditor to bIsReadOnly
96447>>>>>        End
96447>>>>>>
96447>>>>>        Function_Return (bChanged = True and bIsReadOnly = False)
96448>>>>>    End_Function
96449>>>>>
96449>>>>>    Procedure Request_Save
96451>>>>>        Handle hoEditor
96451>>>>>        Boolean bChanged
96451>>>>>
96451>>>>>        Get phoEditor to hoEditor
96452>>>>>        Get pbShouldSave to bChanged
96453>>>>>        If (hoEditor <> 0 and bChanged = True) Begin
96455>>>>>            Send SaveFile of hoEditor
96456>>>>>        End  
96456>>>>>>
96456>>>>>        Forward Send Request_Save
96458>>>>>    End_Procedure
96459>>>>>
96459>>>>>    Procedure Request_Clear
96461>>>>>        Handle hoEditor
96461>>>>>        Get phoEditor to hoEditor
96462>>>>>        If (hoEditor <> 0) Begin
96464>>>>>            Send Delete_Data of hoEditor
96465>>>>>        End
96465>>>>>>
96465>>>>>        Send UpdateStatusBar "" False   
96466>>>>>        Forward Send Request_Clear
96468>>>>>    End_Procedure
96469>>>>>
96469>>>>>    Procedure Request_Clear_All
96471>>>>>        Handle hoEditor
96471>>>>>        Get phoEditor to hoEditor
96472>>>>>        If (hoEditor <> 0) Begin
96474>>>>>            Send Delete_Data of hoEditor
96475>>>>>        End
96475>>>>>>
96475>>>>>        Send UpdateStatusBar "" False  
96476>>>>>        // ToDo: I don't quite understand this, but if we forward send
96476>>>>>        // it activates the EditorView.vw!?
96476>>>>>        // Forward Send Request_Clear_All
96476>>>>>    End_Procedure
96477>>>>>
96477>>>>>    Procedure UpdateStatusBar String sText Boolean bIdleTextOnly Integer iLi Integer iChrs
96479>>>>>        Handle hoStatusBar
96479>>>>>        Integer iLines iCharacters
96479>>>>>
96479>>>>>        Move (StatusBar_Id(Self)) to hoStatusBar
96480>>>>>        If (num_arguments > 2) Begin
96482>>>>>            Move iChrs to iCharacters
96483>>>>>            If (iCharacters = 0) Begin
96485>>>>>                Move 0 to iLines
96486>>>>>            End                 
96486>>>>>>
96486>>>>>            Else Begin
96487>>>>>                Move iLi to iLines
96488>>>>>            End
96488>>>>>>
96488>>>>>            Set NumberOfEditorLines      of hoStatusBar to iLines
96489>>>>>            Set NumberOfEditorCharacters of hoStatusBar to iCharacters
96490>>>>>        End
96490>>>>>>
96490>>>>>        Else Begin
96491>>>>>            If (bIdleTextOnly = True) Begin
96493>>>>>                Set psIdleText of hoStatusBar to sText
96494>>>>>                Set ActionText of hoStatusBar to ""
96495>>>>>            End
96495>>>>>>
96495>>>>>            Else Begin
96496>>>>>                Set ActionText of hoStatusBar to sText
96497>>>>>            End
96497>>>>>>
96497>>>>>        End
96497>>>>>>
96497>>>>>    End_Procedure
96498>>>>>
96498>>>>>    // To enable Ctrl+MouseWheel in the grid to change font size.
96498>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
96500>>>>>       Integer iKeys iClicks iX iY iCONTROL
96500>>>>>       Short iDelta     // Short signed integer
96500>>>>>       Boolean bok 
96500>>>>>       
96500>>>>>       Move 0 to iDelta
96501>>>>>       Move (Low(wParam)) to iKeys           // any keys down when pressed
96502>>>>>       Move (MemCopy(AddressOf(iDelta),AddressOf(wParam)+2,2)) to bok
96503>>>>>       // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
96503>>>>>       Move (iDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
96504>>>>>       Move (Low(lParam)) to iX  // cursor position
96505>>>>>       Move (Hi(lParam)) to iY   
96506>>>>>
96506>>>>>       Move (iKeys iand MK_CONTROL ) to iCONTROL  //$008
96507>>>>>       If (iCONTROL) Begin
96509>>>>>            Broadcast Recursive Send ScaleFont iClicks
96511>>>>>       End
96511>>>>>>
96511>>>>>
96511>>>>>       // Tell windows that we've handled the event.    
96511>>>>>       Set Windows_Override_State to True    
96512>>>>>    End_Procedure
96513>>>>>        
96513>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
96515>>>>>        Integer iSize jSize kSize iSup iInf iDef
96515>>>>>        Handle hoPaintManager hoFont
96515>>>>>        Variant vFont
96515>>>>>        
96515>>>>>        Move 3 to iInf      //max size
96516>>>>>        Move 18 to iSup     //min size
96517>>>>>        Move 8 to iDef      //default
96518>>>>>        Boolean blimite
96518>>>>>        Get phoReportPaintManager to hoPaintManager
96519>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
96521>>>>>            Procedure_Return
96522>>>>>        End
96522>>>>>>
96522>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
96523>>>>>        Get ComTextFont of hoPaintManager to vFont
96524>>>>>        Set pvComObject of hoFont to vFont
96525>>>>>        If (iDirection = 0) Begin
96527>>>>>            Set ComSize of hoFont to iDef
96528>>>>>        End
96528>>>>>>
96528>>>>>        Else Begin
96529>>>>>           Get ComSize of hoFont to iSize
96530>>>>>           Move iSize to jSize
96531>>>>>           Repeat
96531>>>>>>
96531>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
96532>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
96533>>>>>                If (not(blimite)) Begin       
96535>>>>>                   Set ComSize of hoFont to jSize
96536>>>>>                   Get ComSize of hoFont to kSize
96537>>>>>                End
96537>>>>>>
96537>>>>>            Until (iSize <> kSize or blimite)
96539>>>>>        End
96539>>>>>>
96539>>>>>        Send Destroy to hoFont 
96540>>>>>        Send ComRedraw  
96541>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
96542>>>>>    End_Procedure 
96543>>>>>
96543>>>>>End_Class
96544>>>Use cRDCDbSpinForm.pkg
Including file: cRDCDbSpinForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbSpinForm.pkg)
96544>>>>>//****************************************************************************
96544>>>>>// $Module type: Class
96544>>>>>// $Module name: cRDCDbSpinForm
96544>>>>>// $Author     : Nils Svedmyr, RDC Tools International
96544>>>>>// Created     : 2021-08-24 @ 10:24
96544>>>>>//
96544>>>>>// Description :
96544>>>>>//
96544>>>>>// $Rev History:
96544>>>>>//    2021-08-24  Module header created
96544>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96544>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96544>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96544>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96544>>>>>// in the help folder for more details.
96544>>>>>//
96544>>>>>//****************************************************************************
96544>>>>>Use Windows.pkg
96544>>>>>Use Dfspnent.pkg
96544>>>>>
96544>>>>>Class cDbSpinFormIdleHandler is a cIdleHandler
96545>>>>>    Procedure Construct_Object
96547>>>>>        Forward Send Construct_Object
96549>>>>>
96549>>>>>    End_Procedure
96550>>>>>
96550>>>>>    Procedure OnIdle
96552>>>>>        Delegate Send DoUpdate
96554>>>>>    End_Procedure
96555>>>>>
96555>>>>>End_Class
96556>>>>>
96556>>>>>Class cRDCDbSpinForm is a dbSpinForm
96557>>>>>
96557>>>>>    Procedure Construct_Object
96559>>>>>        Forward Send Construct_Object
96561>>>>>
96561>>>>>        Property Boolean pbAutoEnable False
96562>>>>>
96562>>>>>        Property Boolean pbEnabled True
96563>>>>>
96563>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cDbSpinFormIdleHandler)))
96564>>>>>
96564>>>>>        Set Label_Justification_mode to JMode_Right
96565>>>>>        Set Label_Col_Offset to 2
96566>>>>>        Set Label_Row_Offset to 0
96567>>>>>    End_Procedure
96568>>>>>
96568>>>>>    Procedure End_Construct_Object
96570>>>>>        String sTooltip sStatus_Help
96570>>>>>
96570>>>>>        Forward Send End_Construct_Object
96572>>>>>
96572>>>>>        Get psToolTip   to sTooltip
96573>>>>>        Get Status_Help to sStatus_Help
96574>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96576>>>>>            Set psToolTip to sStatus_Help
96577>>>>>        End
96577>>>>>>
96577>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
96578>>>>>    End_Procedure
96579>>>>>
96579>>>>>    Procedure DoUpdate
96581>>>>>        If (pbAutoEnable(Self) = False) Begin
96583>>>>>            Procedure_Return
96584>>>>>        End
96584>>>>>>
96584>>>>>        Set Enabled_State to (IsEnabled(Self))
96585>>>>>    End_Procedure
96586>>>>>
96586>>>>>    Function IsEnabled Returns Boolean
96588>>>>>        Boolean bEnabled
96588>>>>>        Get pbEnabled to bEnabled
96589>>>>>        Function_Return bEnabled
96590>>>>>    End_Function
96591>>>>>
96591>>>>>    // Enable the idle handler timer when the object is activated
96591>>>>>    Procedure Activating
96593>>>>>        Forward Send Activating
96595>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
96596>>>>>    End_Procedure
96597>>>>>
96597>>>>>    // Disable the idle handler when the object is deactivated
96597>>>>>    Procedure Deactivating
96599>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
96600>>>>>        Forward Send Deactivating
96602>>>>>    End_Procedure
96603>>>>>
96603>>>>>    // For some reason spinforms doesn't change the background color
96603>>>>>    // when disabled - only the frame around it changes to "none".
96603>>>>>    // This makes it hard to see that the object is unavailable.
96603>>>>>    // This augmentation changes the background color to "gray",
96603>>>>>    // when disabled.
96603>>>>>    //    Procedure Set Enabled_State Integer bState
96603>>>>>    //        Forward Set Enabled_State to bState
96603>>>>>    //        If (bState = False) Begin
96603>>>>>    //            Set Color to clBtnFace
96603>>>>>    //        End
96603>>>>>    //        Else Begin
96603>>>>>    //            Set Color to clWindow
96603>>>>>    //        End
96603>>>>>    //    End_Procedure
96603>>>>>
96603>>>>>End_Class  
96604>>>Use cRDCDbForm.pkg
Including file: cRDCDbForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbForm.pkg)
96604>>>>>Use DFEntry.pkg
96604>>>>>
96604>>>>>Class cRDCDbForm is a dbForm
96605>>>>>
96605>>>>>    Procedure Construct_Object
96607>>>>>        Forward Send Construct_Object
96609>>>>>
96609>>>>>        Set Label_Justification_mode to JMode_Right
96610>>>>>        Set Label_Col_Offset to 2
96611>>>>>        Set Label_Row_Offset to 0
96612>>>>>
96612>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
96613>>>>>        On_Key kCancel Send None
96614>>>>>        On_Key Key_F3  Send None 
96615>>>>>        On_Key Key_Ctrl+Key_F4 Send None
96616>>>>>    End_Procedure
96617>>>>>
96617>>>>>    Procedure End_Construct_Object
96619>>>>>        String sTooltip sStatus_Help
96619>>>>>
96619>>>>>        Forward Send End_Construct_Object
96621>>>>>
96621>>>>>        Get psToolTip   to sTooltip
96622>>>>>        Get Status_Help to sStatus_Help
96623>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
96625>>>>>            Set psToolTip to sStatus_Help
96626>>>>>        End
96626>>>>>>
96626>>>>>    End_Procedure
96627>>>>>
96627>>>>>End_Class
96628>>>Use cFileNameForm.pkg
Including file: cFileNameForm.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\cFileNameForm.pkg)
96628>>>>>Use Windows.pkg
96628>>>>>
96628>>>>>Class cFileNameForm is a Form
96629>>>>>    Procedure Construct_Object
96631>>>>>        Forward Send Construct_Object
96633>>>>>        Set Enabled_State to False
96634>>>>>    End_Procedure                    
96635>>>>>    
96635>>>>>    Procedure Set psFileName String sFileName
96637>>>>>        String sPath sFullFileName
96637>>>>>        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath
96638>>>>>        Get vFolderFormat sPath to sPath
96639>>>>>        Move (sPath + String(sFileName)) to sFullFileName
96640>>>>>        Set Value to sFullFileName
96641>>>>>    End_Procedure  
96642>>>>>    
96642>>>>>    Procedure SaveData String[] asCode
96644>>>>>        Integer iChannel iSize iCount iRetval
96644>>>>>        String sFileName
96644>>>>>        Boolean bExists
96644>>>>>        
96644>>>>>        Get Seq_New_Channel to iChannel
96645>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
96647>>>>>            Send Stop_Box "No Channel Available for Process: Procedure 'SaveData'"
96648>>>>>            Procedure_Return
96649>>>>>        End
96649>>>>>>
96649>>>>>        
96649>>>>>        Get Value to sFileName
96650>>>>>        
96650>>>>>        Direct_Output channel iChannel sFileName
96652>>>>>        Move (SizeOfArray(asCode)) to iSize
96653>>>>>        Decrement iSize
96654>>>>>        
96654>>>>>        For iCount from 0 to iSize
96660>>>>>>
96660>>>>>            Writeln channel iChannel asCode[iCount]
96663>>>>>        Loop                                       
96664>>>>>>
96664>>>>>        Close_Input channel iChannel
96666>>>>>        Send Seq_Release_Channel iChannel
96667>>>>>                                         
96667>>>>>    End_Procedure
96668>>>>>
96668>>>>>End_Class
96669>>>Use cScintillaRefactorEditor.pkg
96669>>>Use oEditorProperties.pkg
96669>>>Use mfiletime.pkg
Including file: mFileTime.pkg    (C:\Projects\DF18\DfRefactor\AppSrc\mFileTime.pkg)
96669>>>>>//*****************************************************************************************
96669>>>>>// Copyright (c) 2000 Michael Kurz
96669>>>>>// All rights reserved.
96669>>>>>// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
96669>>>>>//
96669>>>>>// $FileName    : mFILETIME_ft.pkg
96669>>>>>// $ProjectName : Shared Methods
96669>>>>>// $Author      : Michael Kurz <MichaelKurz@gmx.at>
96669>>>>>// $Created     : 01-25-2001 @ 19:00
96669>>>>>//
96669>>>>>// Contents:
96669>>>>>//      Gets the FILETIME_ft with a slightly changed Get_File_Mod_Time command which gets the
96669>>>>>//      date in 4 digit format.
96669>>>>>//      And also creates a TimeStamp.
96669>>>>>//
96669>>>>>// $Rev History
96669>>>>>//
96669>>>>>//*****************************************************************************************
96669>>>>>
96669>>>>>//Use mWinAPIErrorText.pkg
96669>>>>>// Function's needed for getting the FILETIME_ft. 16.05.01 Bernhard
96669>>>>>    External_Function FileTimeToSystemTime "FileTimeToSystemTime" kernel32.dll Pointer pSYSTEMTIME_ft Pointer pFILETIME Returns Integer
96670>>>>>    External_Function CloseHandle "CloseHandle" kernel32.dll Handle hFile Returns Integer
96671>>>>>    External_Function FindFirstFile "FindFirstFileA" kernel32.dll Pointer lpFile Pointer lpFindFileData Returns Integer
96672>>>>>    External_Function FindClose "FindClose" kernel32.dll Handle hFile Returns Integer
96673>>>>>// Types needed for getting the FILETIME. 16.05.01 Bernhard
96673>>>>>Type SYSTEMTIME_ft
96673>>>>>Field SYSTEMTIME_ft.wYear          as WORD
96673>>>>>Field SYSTEMTIME_ft.wMonth         as WORD
96673>>>>>Field SYSTEMTIME_ft.wDayOfWeek     as WORD
96673>>>>>Field SYSTEMTIME_ft.wDay           as WORD
96673>>>>>Field SYSTEMTIME_ft.wHour          as WORD
96673>>>>>Field SYSTEMTIME_ft.wMinute        as WORD
96673>>>>>Field SYSTEMTIME_ft.wSecond        as WORD
96673>>>>>Field SYSTEMTIME_ft.wMilliseconds  as WORD
96673>>>>>End_Type
96673>>>>>
96673>>>>>Type FILETIME_ft
96673>>>>>Field FILETIME_ft.dwLowDateTime    as DWord
96673>>>>>Field FIELTIME.dwHighDateTime   as DWord
96673>>>>>End_Type
96673>>>>>
96673>>>>>Type WIN32_FIND_DATA_ft
96673>>>>>Field WIN32_FIND_DATA_ft.dwFileAttributes as DWord
96673>>>>>Field WIN32_FIND_DATA_ft.ftCreationTime as Char 8
96673>>>>>Field WIN32_FIND_DATA_ft.ftLastAccessTime as Char 8
96673>>>>>Field WIN32_FIND_DATA_ft.ftLastWriteTime as Char 8
96673>>>>>Field WIN32_FIND_DATA_ft.nFileSizeHigh as DWord
96673>>>>>Field WIN32_FIND_DATA_ft.nFileSizeLow as DWord
96673>>>>>Field WIN32_FIND_DATA_ft.dwReserved0 as DWord
96673>>>>>Field WIN32_FIND_DATA_ft.dwReserverd1 as DWord
96673>>>>>Field WIN32_FIND_DATA_ft.cFileName as Char 260
96673>>>>>Field WIN32_FIND_DATA_ft.cAlternateFileName as Char 14
96673>>>>>End_Type
96673>>>>>
96673>>>>>// Convert 3 Integer's to a Date based on the System-Settings. 16.05.01 Bernhard
96673>>>>>Function MKConvertYearMonthDay Integer iYear Integer iMonth Integer iDay Returns Date
96676>>>>>    Integer iFormat iSeparator
96676>>>>>    String sSeparator
96676>>>>>    Date dRetVal
96676>>>>>
96676>>>>>    Get_Attribute DF_DATE_FORMAT to iFormat
96679>>>>>    Get_Attribute DF_DATE_SEPARATOR to iSeparator
96682>>>>>    Move (Character(iSeparator)) to sSeparator
96683>>>>>
96683>>>>>    If iFormat Eq DF_DATE_USA Begin
96685>>>>>        Move ( (String(iMonth)) + sSeparator + (String(iDay)) + sSeparator + (String(iYear))) to dRetVal
96686>>>>>    End
96686>>>>>>
96686>>>>>    If iFormat Eq DF_DATE_EUROPEAN Begin
96688>>>>>        Move ( (String(iDay)) + sSeparator + (String(iMonth)) + sSeparator + (String(iYear))) to dRetVal
96689>>>>>    End
96689>>>>>>
96689>>>>>    If iFormat Eq DF_DATE_MILITARY Begin
96691>>>>>        Move ( (String(iYear)) + sSeparator + (String(iMonth)) + sSeparator + (String(iDay))) to dRetVal
96692>>>>>    End
96692>>>>>>
96692>>>>>    Function_Return dRetVal
96693>>>>>End_Function
96694>>>>>
96694>>>>>// Creates a time stamp which is a Number value which contains Date,Time in Seconds.
96694>>>>>Function MKCreateTimeStamp Global Date dDat Integer iH Integer iM Integer is Returns Number
96696>>>>>    Number nDays
96696>>>>>    Number  nRet
96696>>>>>    Move dDat                                   to nDays
96697>>>>>    Move ((nDays*24*3600)+(iH*3600)+(iM*60)+is) to nRet
96698>>>>>    Function_Return nRet
96699>>>>>End_Function
96700>>>>>
96700>>>>>// Does a correction of the DateValue becouse the native command gets only 2 digit!
96700>>>>>
96700>>>>>// Retrieves the FILETIME with the command above and creates a TimeStamp out of it.
96700>>>>>// Changed to workaround a bug in vdf's get_file_mod_time. 16.05.01 Bernhard
96700>>>>>Function MKTimeStampOfFile Global String sFile Returns Number
96702>>>>>    Date dDat
96702>>>>>    Number nH nM nS
96702>>>>>    String sDir sFILETIME_ft sSYSTEMTIME_ft sFindData sDirSep
96702>>>>>    Pointer pFile pFILETIME_ft pSYSTEMTIME_ft pFindData
96702>>>>>    Integer iRet iYear iDay iMonth
96702>>>>>    Handle hFile
96702>>>>>
96702>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
96703>>>>>    If (Left(sFile, 2) = ("." + sDir)) Begin
96705>>>>>        Get_Current_Directory to sDir
96706>>>>>        Move (Replace(("." + sDir), sFile, "")) to sFile
96707>>>>>        Move (sDir + sDir + sFile) to sFile
96708>>>>>    End
96708>>>>>>
96708>>>>>
96708>>>>>    Move (sFile + (Character(0))) to sFile
96709>>>>>    GetAddress of sFile to pFile
96710>>>>>    Move (OemToAnsi(pFile,pFile)) to iRet
96711>>>>>    ZeroType WIN32_FIND_DATA_ft to sFindData
96712>>>>>    GetAddress of sFindData to pFindData
96713>>>>>    Move (FindFirstFile(pFile,pFindData)) to hFile
96714>>>>>
96714>>>>>    If hFile Gt 0 Begin
96716>>>>>        GetBuff_String From sFindData At WIN32_FIND_DATA_ft.ftLastWriteTime to sFILETIME_ft
96717>>>>>        ZeroType SYSTEMTIME_ft to sSYSTEMTIME_ft
96718>>>>>        GetAddress of sFILETIME_ft to pFILETIME_ft
96719>>>>>        GetAddress of sSYSTEMTIME_ft to pSYSTEMTIME_ft
96720>>>>>        Move (FiletimeToSystemtime(pFILETIME_ft,pSYSTEMTIME_ft)) to iRet
96721>>>>>        If (iRet) Begin
96723>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wYear to iYear
96724>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMonth to iMonth
96725>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wDay to iDay
96726>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wHour to nH
96727>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMinute to nM
96728>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wSecond to nS
96729>>>>>            Move (MKConvertYearMonthDay(Self,iYear,iMonth,iDay)) to dDat
96730>>>>>        End
96730>>>>>>
96730>>>>>        Move (FindClose(hFile)) to iRet
96731>>>>>    End
96731>>>>>>
96731>>>>>    Function_Return (MKCreateTimeStamp(dDat,nH,nM,nS))
96732>>>>>End_Function
96733>>>>>
96733>>>>>// Delivers a string with the file date and time.
96733>>>>>Function MKFileTimeString Global String sFile Returns String
96735>>>>>    Date dDat
96735>>>>>    Number nH nM nS
96735>>>>>    String sDir sFILETIME_ft sSYSTEMTIME_ft sFindData sDirSep
96735>>>>>    Pointer pFile pFILETIME_ft pSYSTEMTIME_ft pFindData
96735>>>>>    Integer iRet iYear iDay iMonth
96735>>>>>    Handle hFile
96735>>>>>    String sRet
96735>>>>>
96735>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
96736>>>>>    If (Left(sFile,2) = ("." + sDirSep)) Begin
96738>>>>>        Get_Current_Directory to sDir
96739>>>>>        Move (Replace(("." + sDir), sFile, "")) to sFile
96740>>>>>        Move (sDir + sDir + sFile) to sFile
96741>>>>>    End
96741>>>>>>
96741>>>>>
96741>>>>>    Move (sFile + (Character(0))) to sFile
96742>>>>>    GetAddress of sFile to pFile
96743>>>>>    Move (OemToAnsi(pFile,pFile)) to iRet
96744>>>>>    ZeroType WIN32_FIND_DATA_ft to sFindData
96745>>>>>    GetAddress of sFindData to pFindData
96746>>>>>    Move (FindFirstFile(pFile,pFindData)) to hFile
96747>>>>>
96747>>>>>    If hFile Gt 0 Begin
96749>>>>>        GetBuff_String From sFindData At WIN32_FIND_DATA_ft.ftLastWriteTime to sFILETIME_ft
96750>>>>>        ZeroType SYSTEMTIME_ft to sSYSTEMTIME_ft
96751>>>>>        GetAddress of sFILETIME_ft to pFILETIME_ft
96752>>>>>        GetAddress of sSYSTEMTIME_ft to pSYSTEMTIME_ft
96753>>>>>        Move (FiletimeToSystemtime(pFILETIME_ft,pSYSTEMTIME_ft)) to iRet
96754>>>>>        If (iRet) Begin
96756>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wYear to iYear
96757>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMonth to iMonth
96758>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wDay to iDay
96759>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wHour to nH
96760>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wMinute to nM
96761>>>>>            GetBuff From sSYSTEMTIME_ft At SYSTEMTIME_ft.wSecond to nS
96762>>>>>            Move (MKConvertYearMonthDay(Self,iYear,iMonth,iDay)) to dDat
96763>>>>>        End
96763>>>>>>
96763>>>>>        Move (FindClose(hFile)) to iRet
96764>>>>>    End
96764>>>>>>
96764>>>>>    Append sRet dDat " " (Right(Append("0",nH),2)) ":" (Right(Append("0",nM),2)) ":" (Right(Append("0",nS),2))
96771>>>>>    Function_Return sRet
96772>>>>>End_Function
96773>>>>>
96773>>>>>Define FILE_ATTRIBUTE_READONLY  For |CI$00000001
96773>>>>>Define FILE_ATTRIBUTE_ARCHIVE   For |CI$00000020
96773>>>>>
96773>>>>>// Retrieves the FILETIME_ft with the command above and creates a TimeStamp out of it.
96773>>>>>// Changed to workaround a bug in vdf's get_file_mod_time. 16.05.01 Bernhard
96773>>>>>Function MKAttribOfFile Global String sFile Returns DWord // **WvA: 18-3-2003 This is not a number according to VDF8
96775>>>>>    String sDir sFindData sDirSep
96775>>>>>    Pointer pFile pFindData
96775>>>>>    Integer iRet iAttr
96775>>>>>    Handle hFile
96775>>>>>
96775>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
96776>>>>>    If (Left(sFile, 2) = ("." + sDirSep)) Begin
96778>>>>>        Get_Current_Directory to sDir
96779>>>>>        Move (Replace(("." + sDir), sFile, "")) to sFile
96780>>>>>        Move (sDir + sDir + sFile) to sFile
96781>>>>>    End
96781>>>>>>
96781>>>>>
96781>>>>>    Move (sFile + (Character(0))) to sFile
96782>>>>>    GetAddress of sFile to pFile
96783>>>>>    Move (OemToAnsi(pFile,pFile)) to iRet
96784>>>>>    ZeroType WIN32_FIND_DATA_ft to sFindData
96785>>>>>    GetAddress of sFindData to pFindData
96786>>>>>    Move (FindFirstFile(pFile,pFindData)) to hFile
96787>>>>>
96787>>>>>    If hFile Gt 0 Begin
96789>>>>>        GetBuff From sFindData At WIN32_FIND_DATA_ft.dwFileAttributes to iAttr
96790>>>>>        Move (FindClose(hFile)) to iRet
96791>>>>>    End
96791>>>>>>
96791>>>>>    Else Begin
96792>>>>>        Move -1 to iAttr
96793>>>>>    End
96793>>>>>>
96793>>>>>    Function_Return iAttr
96794>>>>>End_Function
96795>>>>>
96795>>>>>// Delivers true when the given file has the Readonly attribute set to true.
96795>>>>>Function MKisFileReadOnly Global String sFile Returns Integer
96797>>>>>    Function_Return (MKAttribOfFile(sFile) Iand FILE_ATTRIBUTE_READONLY)
96798>>>>>End_Function
96799>>>Use vwin32fh.pkg
96799>>>
96799>>>Use LogFileDialog.dg
Including file: LogFileDialog.dg    (C:\Projects\DF18\DfRefactor\AppSrc\LogFileDialog.dg)
96799>>>>>Use Windows.pkg
96799>>>>>Use cRichEdit.pkg
96799>>>>>Use cRDCButtonDPI.pkg
96799>>>>>Use cRDCModalPanel.pkg
96799>>>>>Use seq_chnl.pkg
96799>>>>>Use vWin32fh.pkg
96799>>>>>
96799>>>>>Object oLogFileDialog_dg is a cRDCModalPanel
96801>>>>>    Set Size to 269 624
96802>>>>>    Set Label to "Log File Dialog"
96803>>>>>    Set piMinSize to 89 211
96804>>>>>    Set Location to 2 2
96805>>>>>    Set Icon to "OpenLogFile.ico"
96806>>>>>
96806>>>>>    Property String psLogFileName ""
96808>>>>>    Property Integer piIndent
96810>>>>>
96810>>>>>    Object oLogFile_edt is a cRichEdit
96812>>>>>        Set Size to 224 603
96813>>>>>        Set Location to 16 11
96814>>>>>        Set TextColor to clBlack
96815>>>>>        Set peAnchors to anAll
96816>>>>>        Set Label_Row_Offset to 3
96817>>>>>        Set Label_TextColor to clGreenGreyLight
96818>>>>>        Set TextColor to clGreenGreyLight 
96819>>>>>        Set Label_FontItalics to True
96820>>>>>        Set piFontSize to 200
96821>>>>>        Set psTypeFace to 'Consolas'
96822>>>>>
96822>>>>>        Delegate Set piIndent to (piParagraphIndent(Self))
96824>>>>>
96824>>>>>        Procedure DoSaveDocument
96827>>>>>            String sLogFileName
96827>>>>>            Boolean bOk bOkToSave bChanged
96827>>>>>
96827>>>>>            Move False to bOkToSave
96828>>>>>            Get pbCanUndo to bChanged
96829>>>>>            If (bChanged = False) Begin
96831>>>>>                Procedure_Return
96832>>>>>            End
96832>>>>>>
96832>>>>>
96832>>>>>            Get psLogFileName to sLogFileName
96833>>>>>            Send Write sLogFileName
96834>>>>>            // clear undo buffer on save
96834>>>>>            // we want undo buffer to only apply to the new document
96834>>>>>            Send ClearUndoBuffer
96835>>>>>            Send Info_Box "Changes saved."
96836>>>>>        End_Procedure
96837>>>>>
96837>>>>>        Procedure LoadData
96840>>>>>            String sLogFileName
96840>>>>>            Integer iTwips iIndent
96840>>>>>
96840>>>>>            Get psLogFileName to sLogFileName
96841>>>>>            Set Label to sLogFileName  
96842>>>>>            Move 1440 to iTwips
96843>>>>>            Get piIndent to iIndent
96844>>>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
96845>>>>>
96845>>>>>            Send Read sLogFileName
96846>>>>>        End_Procedure
96847>>>>>        
96847>>>>>        Procedure DisplayCurrentSourceLine
96850>>>>>            Integer iLine iPos iSize
96850>>>>>            String sLine sSearch           
96850>>>>>            Boolean bFound    
96850>>>>>            Handle ho
96850>>>>>            
96850>>>>>//            Get phoEditorRefactored of ghoApplication to ho
96850>>>>>//            Get Line_Count of ho to iSize
96850>>>>>//            If (iSize <= 1) Begin
96850>>>>>//                Procedure_Return
96850>>>>>//            End
96850>>>>>//            
96850>>>>>//            Move -1 to iLine    
96850>>>>>//            Move " ON LINE: " to sSearch
96850>>>>>//            Get LineFromChar iLine to iLine
96850>>>>>//            Get Line iLine to sLine     
96850>>>>>//            Move (Pos(sSearch, sLine)) to iPos
96850>>>>>//            If (iPos <> 0) Begin
96850>>>>>//                Move (Mid(sLine, Length(sLine), (iPos + Length(sSearch)))) to sLine
96850>>>>>//                Move (Pos(" ", sLine)) to iPos
96850>>>>>//                Move (Left(sLine, (iPos - 1))) to sLine
96850>>>>>//                Move (Trim(sLine)) to iLine 
96850>>>>>//                Decrement iLine
96850>>>>>//                Move True to bFound
96850>>>>>//            End
96850>>>>>//            
96850>>>>>//            If (bFound = True) Begin         
96850>>>>>//                Send Close_Panel
96850>>>>>//                Send JumpToSourceLine of (Client_Id(phoMainPanel(ghoApplication))) iLine    
96850>>>>>//                Send Activate of ho
96850>>>>>//            End
96850>>>>>        End_Procedure   
96851>>>>>        
96851>>>>>        Procedure Mouse_Click
96854>>>>>            Send DisplayCurrentSourceLine
96855>>>>>        End_Procedure
96856>>>>>
96856>>>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
96857>>>>>        On_Key kCancel Send Cancel  
96858>>>>>        On_Key kEnter  Send DisplayCurrentSourceLine
96859>>>>>    End_Object
96860>>>>>
96860>>>>>    Object oCancel_Btn is a cRDCButtonDPI
96862>>>>>        Set Label    to "&Close"
96863>>>>>        Set Location to 248 564
96864>>>>>        Set peAnchors to anBottomRight
96865>>>>>
96865>>>>>        Procedure OnClick
96868>>>>>            Send Close_Panel
96869>>>>>        End_Procedure
96870>>>>>
96870>>>>>    End_Object
96871>>>>>
96871>>>>>
96871>>>>>    Object oFirstRun_btn is a cRDCButtonDPI
96873>>>>>        Set Location to 248 450
96874>>>>>        Set Label to "View Top"
96875>>>>>        Set peAnchors to anBottomRight
96876>>>>>
96876>>>>>        Procedure OnClick
96879>>>>>            Send Beginning_of_Data to oLogFile_edt
96880>>>>>        End_Procedure
96881>>>>>
96881>>>>>    End_Object
96882>>>>>
96882>>>>>    Object oLatestRun_btn is a cRDCButtonDPI
96884>>>>>        Set Location to 248 507
96885>>>>>        Set Label to "View Bottom"
96886>>>>>        Set peAnchors to anBottomRight
96887>>>>>
96887>>>>>        Procedure OnClick
96890>>>>>            Send End_of_Data to oLogFile_edt
96891>>>>>        End_Procedure
96892>>>>>
96892>>>>>    End_Object
96893>>>>>
96893>>>>>    // Automatically load data into the grid when activating.
96893>>>>>    Procedure Activating
96896>>>>>        Handle ho  
96896>>>>>        String sLogFileName
96896>>>>>        
96896>>>>>        Forward Send Activating
96898>>>>>        Move (oLogFile_edt(Self)) to ho
96899>>>>>        Send LoadData    of ho
96900>>>>>        // We need to active before we can send end_of_data.
96900>>>>>        Send Activate    of ho
96901>>>>>        Send End_of_Data to ho
96902>>>>>        Get psLogFileName to sLogFileName
96903>>>>>        Set psText of (oStatusIdle(Statusbar_Id(Self))) to sLogFileName
96904>>>>>    End_Procedure
96905>>>>>
96905>>>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRun_btn
96906>>>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRun_btn
96907>>>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRun_btn
96908>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRun_btn
96909>>>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
96910>>>>>End_Object
96911>>>>>
96911>>>>>Procedure ActivateLogFileDialog String sLogFile
96914>>>>>    Handle ho
96914>>>>>    Boolean bExists
96914>>>>>
96914>>>>>    Get vFilePathExists sLogFile to bExists
96915>>>>>    If (bExists = False) Begin
96917>>>>>        Send Info_Box "The logfile doesn't exist."
96918>>>>>        Procedure_Return
96919>>>>>    End
96919>>>>>>
96919>>>>>    Move (oLogFileDialog_dg(Self)) to ho
96920>>>>>    Set psLogFileName of ho to sLogFile
96921>>>>>    Send Popup of ho
96922>>>>>End_Procedure
96923>>>Use cSysFileDataDictionary.dd
96923>>>Use cFunctionsDataDictionary.dd  
96923>>>Use cFunctionsADataDictionary.dd
96923>>>
96923>>>Activate_View Activate_oFunctionTableTesting for oFunctionTableTesting
96933>>>>
96933>>>Object oFunctionTableTesting is a cRefactorDbView
96935>>>    Set Border_Style to Border_Thick
96936>>>    Set Size to 289 831
96937>>>    Set Location to 2 7
96938>>>    Set Label to "Test Bench for Functions"
96939>>>    Set pbAutoActivate to True
96940>>>    Set Maximize_Icon to True 
96941>>>    Set pbAcceptDropFiles to True
96942>>>
96942>>>    Set phoTestView of ghoApplication to Self
96943>>>    Property Handle phoEditorLegacy
96945>>>    Property Handle phoEditorRefactored   
96947>>>        
96947>>>    Object oSysFile_DD is a cSysFileDataDictionary
96949>>>    End_Object
96950>>>
96950>>>    Object oFunctions_DD is a cFunctionsDataDictionary
96952>>>        Procedure Request_Save
96955>>>            Send Request_Save of oSysFile_DD
96956>>>            Forward Send Request_Save
96958>>>        End_Procedure
96959>>>    End_Object     
96960>>>    
96960>>>    Procedure Request_Save
96963>>>        Send Request_Save of (Main_DD(Self))
96964>>>        Forward Send Request_Save
96966>>>    End_Procedure
96967>>>    
96967>>>    Set Main_DD to oFunctions_DD
96968>>>    Set Server to oFunctions_DD
96969>>>
96969>>>    Object oSplitterContainer is a cDbSplitterContainer
96971>>>        Set piSplitterLocation to 498
96972>>>
96972>>>        Object oSplitterContainerChild1 is a cDbSplitterContainerChild
96974>>>
96974>>>            Object oOpenDialog is a OpenDialog
96976>>>                Set Dialog_Caption to "Select your file compare application of choice"
96977>>>                Set Filter_String to "Programs|*.exe|Any file|*.*"
96978>>>            End_Object
96979>>>
96979>>>            Object oInfo_tb is a TextBox
96981>>>                Set Size to 10 251
96982>>>                Set Location to 5 126
96983>>>                Set Label to "- You can drag && drop a source file from Windows Explorer to this editor object"
96984>>>            End_Object
96985>>>
96985>>>            Object oLegacyEditor_tb is a TextBox
96987>>>                Set Size to 10 74
96988>>>                Set Location to 4 8
96989>>>                Set Label to "Legacy Code: (Before)"
96990>>>                Set FontWeight to fw_Bold
96991>>>                Set FontPointHeight to 10
96992>>>            End_Object
96993>>>        
96993>>>            Object oLegacyCode_edt is a cScintillaRefactorEditor
96995>>>                Set Size to 176 481
96996>>>                Set Location to 17 6
96997>>>                Delegate Set phoEditorLegacy to (Self)
96999>>>                Set phoEditorLegacy of ghoApplication to (Self)
97000>>>                Set psCodeFile to (psAppSrcPath(phoWorkspace(ghoApplication)) + "\" + CS_LegacyCode)
97001>>>
97001>>>                Property Boolean pbIsFileDropped False
97003>>>                
97003>>>                Procedure OnFileDropped String sFileName Boolean bLast
97006>>>                    Integer iChannel iCount
97006>>>                    String sTextValue sLine
97006>>>                    Boolean bSeqEof
97006>>>                    String[] asLegacyCode    
97007>>>                    Handle ho
97007>>>                    
97007>>>                    If (bLast = True) Begin
97009>>>                        Set pbIsFileDropped to False
97010>>>                        Send LoadFile sFileName 
97011>>>                        Send SaveFile 
97012>>>                    End 
97012>>>>
97012>>>                    // We use a property to only show info_box once if multiple files are dropped.
97012>>>                    Else If (pbIsFileDropped(Self) = False) Begin
97015>>>                        Send Info_Box "Only one source file can be dropped at a time. The last file will be used."
97016>>>                        Set pbIsFileDropped to True
97017>>>                    End
97017>>>>
97017>>>                End_Procedure
97018>>>                
97018>>>                // Important: Must be after the object has been paged, else the text won't show
97018>>>                Procedure Page Integer iPageObject
97021>>>                    String[] asLegacyCode
97022>>>                    String sFileName                         
97022>>>                    Handle ho   
97022>>>                    Integer iLines
97022>>>                    
97022>>>                    Forward Send Page iPageObject
97024>>>                    If (iPageObject) Begin
97026>>>                        Get Line_Count to iLines
97027>>>                        If (iLines > 1) Begin
97029>>>                            Procedure_Return
97030>>>                        End
97030>>>>
97030>>>//                        Get ReadImageDataToStringArray 1 to asLegacyCode 
97030>>>                        Move (oLegacyCodeFilename_fm(Self)) to ho
97031>>>                        Get psCodeFile of (phoEditorLegacy(ghoApplication)) to sFileName
97032>>>//                        Send SaveData of ho asLegacyCode
97032>>>                        Send LoadFile sFileName   
97033>>>                        Send OnModified
97034>>>                    End     
97034>>>>
97034>>>                End_Procedure
97035>>>            
97035>>>                Procedure OnModified
97038>>>                    Integer iLines
97038>>>                    
97038>>>                    Forward Send OnModified
97040>>>                    Get Line_Count to iLines
97041>>>                    Set Value of oLegacyCode_NoOfLines_fm to iLines                    
97042>>>                End_Procedure
97043>>>            
97043>>>            End_Object
97044>>>
97044>>>            Object oLegacyCode_NoOfLines_fm is a Form
97046>>>                Set Size to 10 33
97047>>>                Set Location to 197 454
97048>>>                Set Enabled_State to False
97049>>>                Set Label to "No of Lines:"
97050>>>                Set Value to "0"
97051>>>                Set Label_Justification_Mode to JMode_Right
97052>>>                Set peAnchors to anBottomRight
97053>>>                Set Form_Datatype to 0 
97054>>>                Set Label_Col_Offset to 2
97055>>>                Set Label_Row_Offset to 2
97056>>>                
97056>>>                    Procedure Set Value Integer iItem String sValue
97059>>>                    Integer iValue
97059>>>                    String sFormatString 
97059>>>                    Move sValue to iValue
97060>>>                    Move ",#." to sFormatString
97061>>>                    Move (FormatValue(iValue, sFormatString)) to sValue
97062>>>                    Forward Set Value to sValue
97064>>>                End_Procedure
97065>>>            End_Object
97066>>>
97066>>>            Object oSaveFiles_grp is a dbGroup
97068>>>                Set Size to 71 383
97069>>>                Set Location to 205 5
97070>>>                Set Label to "Refactoring Code Sample Files:"
97071>>>                Set peAnchors to anBottomLeftRight
97072>>>
97072>>>                Object oLegacyCodeFilename_fm is a cFileNameForm
97074>>>                    Set Size to 14 368
97075>>>                    Set Location to 19 7
97076>>>                    Set Label to "Legacy Code File"
97077>>>                    Set Label_Col_Offset to 0
97078>>>                    Set Label_Justification_Mode to JMode_Top
97079>>>                    Set peAnchors to anBottomLeftRight 
97080>>>
97080>>>                    Procedure Set Value Integer iItem String sFileName
97083>>>                        Forward Set Value to sFileName
97085>>>                        Set psLegacySourceFile of ghoApplication to sFileName
97086>>>                    End_Procedure
97087>>>                End_Object
97088>>>
97088>>>                Object oRefactoredCodeFilename_fm is a cFileNameForm
97090>>>                    Set Size to 14 368
97091>>>                    Set Location to 45 6
97092>>>                    Set Label to "Refactored Code File"
97093>>>                    Set Label_Col_Offset to 0
97094>>>                    Set Label_Justification_Mode to JMode_Top
97095>>>                    Set peAnchors to anBottomLeftRight
97096>>>
97096>>>                    Procedure Set Value Integer iItem String sFileName
97099>>>                        Forward Set Value to sFileName
97101>>>                        Set psRefactoredSourceFile of ghoApplication to sFileName
97102>>>                    End_Procedure
97103>>>                End_Object
97104>>>
97104>>>            End_Object
97105>>>
97105>>>//            Object oSplitBy_rgp is a dbRadioGroup
97105>>>//                Entry_Item SysFile.eSplitBy
97105>>>//                Set Server to oSysFile_DD
97105>>>//                Set Location to 205 308
97105>>>//                Set Size to 51 117
97105>>>//                Set Label to "Split 'If' line to:"
97105>>>//                Set peAnchors to anBottomRight
97105>>>//
97105>>>//                Object oRadio0 is a Radio
97105>>>//                    Set Label to CS_SplitBySpaceSemiColumn
97105>>>//                    Set psToolTip to "Break the if/else line with a space followed by a semicolon"
97105>>>//                    Set Size to 10 119
97105>>>//                    Set Location to 13 5
97105>>>//                End_Object
97105>>>//
97105>>>//                Object oRadio1 is a Radio
97105>>>//                    Set Size to 10 119
97105>>>//                    Set Location to 24 5
97105>>>//                    Set Label to CS_SplitBySemiColumn
97105>>>//                    Set psToolTip to "Break the if/else line with a semicolon"
97105>>>//                End_Object
97105>>>//
97105>>>//                Object oRadio2 is a Radio
97105>>>//                    Set Size to 10 119
97105>>>//                    Set Location to 36 5
97105>>>//                    Set Label to CS_SplitByBeginEnd
97105>>>//                    Set psToolTip to "Break the if/else line by adding a begin / end block"
97105>>>//                End_Object
97105>>>//
97105>>>//                Procedure Notify_Select_State Integer NewId Integer OldId
97105>>>//                    Forward Send Notify_Select_State NewId OldId
97105>>>//                End_Procedure
97105>>>//        
97105>>>//            End_Object
97105>>>
97105>>>//            Object oDDOStyle_rgp is a dbRadioGroup
97105>>>//                Entry_Item SysFile.eDDOStyle
97105>>>//                Set Server to oSysFile_DD
97105>>>//                Set Location to 205 183
97105>>>//                Set Size to 51 120
97105>>>//                Set Label to "DDO Style:"
97105>>>//                Set peAnchors to anBottomRight
97105>>>//
97105>>>//                Object oRadio0 is a Radio
97105>>>//                    Set Label to CS_DDOldStyle
97105>>>//                    Set Size to 10 119
97105>>>//                    Set Location to 12 5
97105>>>//                End_Object
97105>>>//
97105>>>//                Object oRadio1 is a Radio
97105>>>//                    Set Size to 10 119
97105>>>//                    Set Location to 23 5
97105>>>//                    Set Label to CS_DDLegacyStyle
97105>>>//                End_Object
97105>>>//
97105>>>//                Object oRadio2 is a Radio
97105>>>//                    Set Size to 10 119
97105>>>//                    Set Location to 35 5
97105>>>//                    Set Label to CS_DDNewStyle
97105>>>//                End_Object
97105>>>//
97105>>>//                Procedure Notify_Select_State Integer NewId Integer OldId
97105>>>//                    Forward Send Notify_Select_State NewId OldId
97105>>>//                End_Procedure
97105>>>//        
97105>>>//            End_Object
97105>>>            
97105>>>//            Object oTabSize_sf is a cRDCDbSpinForm
97105>>>//                Entry_Item SysFile.TabSize
97105>>>//                Set Server to oSysFile_DD
97105>>>//                Set Size to 13 27
97105>>>//                Set Location to 240 460
97105>>>//                Set Label to "Tab Size"
97105>>>//                Set Label_Col_Offset to 2
97105>>>//                Set Label_Justification_Mode to JMode_Right
97105>>>//                Set psToolTip to "Select the indent size you want to use when indenting code and when breaking a line on rewriting a single line to multiple lines. It is the same value that can be set on the Editor Settings dialog tab size."
97105>>>//                Set peAnchors to anBottomRight
97105>>>//            End_Object
97105>>>
97105>>>//            Object oMaxBlankLines_sf is a cRDCDbSpinForm
97105>>>//                Entry_Item SysFile.MaxBlankLines
97105>>>//                Set Server to oSysFile_DD
97105>>>//                Set Size to 13 27
97105>>>//                Set Location to 261 460
97105>>>//                Set Label to "Max blank lines"
97105>>>//                Set Label_Col_Offset to 2
97105>>>//                Set Label_Justification_Mode to JMode_Right
97105>>>//                Set psToolTip to "Select the maximum number of consecutive blank lines that is allowed in a source file. If more empty lines are encountered, they will be removed."
97105>>>//                Set Maximum_Position to 6
97105>>>//                Set Minimum_Position to 1
97105>>>//                Set peAnchors to anBottomRight
97105>>>//            End_Object
97105>>>
97105>>>        End_Object
97106>>>
97106>>>        Object oSplitterContainerChild2 is a cDbSplitterContainerChild
97108>>>
97108>>>            Object oLegacyEditor_tb is a TextBox
97110>>>                Set Size to 10 84
97111>>>                Set Location to 4 5
97112>>>                Set Label to "Refactored Code: (After)"
97113>>>                Set FontWeight to fw_Bold
97114>>>                Set FontPointHeight to 10
97115>>>            End_Object
97116>>>    
97116>>>            Object oRefactoredCode_edt is a cScintillaRefactorEditor
97118>>>                Set Size to 176 476
97119>>>                Set Location to 17 6
97120>>>                Delegate Set phoEditorRefactored to (Self)  
97122>>>                Delegate Set phoEditor to (Self)
97124>>>                Set phoEditorRefactored of ghoApplication to (Self)
97125>>>                Set psCodeFile to (psAppSrcPath(phoWorkspace(ghoApplication)) + "\" + CS_RefactoredCode)
97126>>>        
97126>>>                Procedure OnModified
97129>>>                    Integer iLines
97129>>>                    
97129>>>                    Forward Send OnModified
97131>>>                    Get Line_Count to iLines
97132>>>                    Set Value of oRefactoredCode_NoOfLines_fm to iLines                    
97133>>>                End_Procedure          
97134>>>                
97134>>>                On_Key Key_Ctrl+Key_E Send Execute of (oErrorLog_ToolItem(ghoCommandBars))
97135>>>            End_Object
97136>>>
97136>>>            Object oRefactoredCode_NoOfLines_fm is a Form
97138>>>                Set Size to 10 28
97139>>>                Set Location to 197 48
97140>>>                Set Enabled_State to False
97141>>>                Set Label to "No of Lines:"
97142>>>                Set Value to "0"
97143>>>                Set Label_Col_Offset to 2
97144>>>                Set Label_Justification_Mode to JMode_Right
97145>>>                Set peAnchors to anBottomLeft
97146>>>                Set Form_Datatype to 0 
97147>>>                Set Label_Row_Offset to 2
97148>>>                Procedure Set Value Integer iItem String sValue
97151>>>                    Integer iValue
97151>>>                    String sFormatString 
97151>>>                    Move sValue to iValue
97152>>>                    Move ",#." to sFormatString
97153>>>                    Move (FormatValue(iValue, sFormatString)) to sValue
97154>>>                    Forward Set Value to sValue
97156>>>                End_Procedure
97157>>>            End_Object
97158>>>
97158>>>            Object oRefactoredCode_Time_fm is a Form
97160>>>                Set Size to 10 33
97161>>>                Set Location to 197 113
97162>>>                Set Enabled_State to False
97163>>>                Set Label to "Elapsed:"
97164>>>                Set Label_Col_Offset to 2
97165>>>                Set Label_Justification_Mode to JMode_Right
97166>>>                Set peAnchors to anBottomLeft
97167>>>                Set Form_Datatype to Mask_Clock_Window
97168>>>                Set Label_Row_Offset to 2
97169>>>            End_Object
97170>>>
97170>>>            Object oRefactor_btn is a Button
97172>>>                Set Size to 26 100
97173>>>                Set Location to 213 225
97174>>>                Set Label to "&Refactor Legacy Code"
97175>>>                Set peAnchors to anBottomRight
97176>>>                Set Default_State to True
97177>>>                // Note: We use Form_FontWeight instead of FontWeight to _not_ make the object larger
97177>>>                // because of the bold font.
97177>>>                Set Form_FontWeight to FW_BOLD
97178>>>                Set psImage to "Start.ico"
97179>>>                Set psToolTip to "Refactors the legacy code from the left editor, then saves it to disk. (Ctrl+R)"
97180>>>                Set piImageSize to 24
97181>>>                
97181>>>                Procedure OnClick                          
97184>>>                    Boolean bUseConstraints
97184>>>                    Get Checked_State of (phoUseConstraints_cb(ghoApplication)) to bUseConstraints
97185>>>                    Delegate Send RefactoreCode bUseConstraints
97187>>>                End_Procedure
97188>>>            
97188>>>            End_Object
97189>>>    
97189>>>            Object oCompareProgram_btn is a cRDCButton
97191>>>                Set Size to 14 100
97192>>>                Set Location to 250 225
97193>>>                Set Label to "Co&mpare Before && After"
97194>>>                Set peAnchors to anBottomRight
97195>>>                Set psImage to "Compare.ico"
97196>>>                Set psToolTip to "Starts the selected compare program and passes the two source files (Ctrl+M). It automatically saves the source files first."
97197>>>            
97197>>>                Procedure OnClick
97200>>>                    String sCompareApp
97200>>>                    Send Execute of (oSave_ToolItem(ghoCommandBars))
97201>>>                    Get psFileCompareApp of ghoApplication to sCompareApp
97202>>>                    Send CompareFiles of ghoApplication sCompareApp
97203>>>                End_Procedure
97204>>>        
97204>>>                Function IsEnabled Returns Boolean
97207>>>                    Integer iLines
97207>>>                    Get SC_LineCount of (phoEditor(Self)) to iLines
97208>>>                    Function_Return (iLines > 1)
97209>>>                End_Function
97210>>>        
97210>>>            End_Object
97211>>>
97211>>>            Object oCompareprogram_fm is a dbForm
97213>>>                Entry_Item SysFile.PathSourceCompareTool
97214>>>                Set Server to oSysFile_DD
97215>>>                Set Size to 12 140
97216>>>                Set Location to 251 7
97217>>>                Set Label_Col_Offset to 0
97218>>>                Set Label_Row_Offset to 1
97219>>>                Set Label_Justification_Mode to JMode_Top
97220>>>                Set Label to "Select Compare Program:"
97221>>>                Set psToolTip to "Select a file comparison tool, such as 'Beyond Compare', 'WinMerge', 'Araxis Merge' etc.. (Press F4)"
97222>>>                Set peAnchors to anBottomLeftRight                                                                              
97223>>>        
97223>>>                Procedure Prompt
97226>>>                    Integer bOpen
97226>>>                    String sFileName
97226>>>        
97226>>>                    Get Show_Dialog of oOpenDialog to bOpen
97227>>>                    If (bOpen) Begin
97229>>>                        Get File_Name of oOpenDialog to sFileName
97230>>>                        Set Value to sFileName
97231>>>                        Set Changed_State to True
97232>>>                        Set psFileCompareApp of ghoApplication to sFileName
97233>>>                    End
97233>>>>
97233>>>                End_Procedure  
97234>>>                
97234>>>            End_Object
97235>>>
97235>>>            Object oSelectCompareProgram_btn is a cRDCButton
97237>>>                Set Size to 14 41
97238>>>                Set Location to 250 151
97239>>>                Set Label to "Select"
97240>>>                Set peAnchors to anBottomRight
97241>>>                Set psImage to "ActionOpen.ico"
97242>>>                Set psToolTip to "Select a file comparison tool, such as 'Beyond Compare', 'WinMerge', 'Araxis Merge' etc.. (Press F4)"
97243>>>            
97243>>>                Procedure OnClick
97246>>>                    Send Prompt of oCompareprogram_fm
97247>>>                End_Procedure
97248>>>            End_Object
97249>>>
97249>>>            Object oTestCompileRefactoredCode_btn is a cRDCButton
97251>>>                Set Size to 14 100
97252>>>                Set Location to 267 225
97253>>>                Set Label to "Compile Refactored Code"
97254>>>                Set peAnchors to anBottomRight
97255>>>                Set psImage to "CompileProject.ico"
97256>>>                Set psToolTip to "Compiles a test program (CompiledRefactoredCode.src) where the refactored code file is Use'd. (F5)"
97257>>>            
97257>>>                Procedure OnClick
97260>>>                    Send CompileRefactoredCode of ghoApplication
97261>>>                End_Procedure  
97262>>>                
97262>>>                Function IsEnabled Returns Boolean
97265>>>                    Integer iLines
97265>>>                    Get SC_LineCount of (phoEditor(Self)) to iLines
97266>>>                    Function_Return (iLines > 1)
97267>>>                End_Function
97268>>>        
97268>>>            End_Object
97269>>>
97269>>>            Object oUseConstraints_cb is a CheckBox
97271>>>                Set Location to 222 128
97272>>>                Set Size to 8 109
97273>>>                Set Label to "Constrain Function Calls"
97274>>>                Set peAnchors to anBottomRight
97275>>>                Set psToolTip to "If checked only Functions selected on the 'Function List' tab-page will be called."
97276>>>                Set phoUseConstraints_cb of ghoApplication to Self
97277>>>                
97277>>>                Procedure OnChange
97280>>>                    Boolean bState
97280>>>                    Get Checked_State to bState
97281>>>                    Set Visible_State of oNoOfSelectedFunctions2_fm to (bState = True)
97282>>>                End_Procedure
97283>>>            End_Object
97284>>>
97284>>>            Object oNoOfSelectedFunctions2_fm is a cRDCDbForm
97286>>>                Entry_Item SysFile.SelectedFunctionTotal
97287>>>                Set Server to oSysFile_DD
97288>>>                Set Size to 13 15
97289>>>                Set Location to 221 106
97290>>>                Set Label_Justification_Mode to JMode_Right
97291>>>                Set Label to "Tot No of Selected Functions"
97292>>>                Set psToolTip to "Total number of functions selected."
97293>>>                Set Enabled_State to False
97294>>>                Set peAnchors to anBottomRight
97295>>>                Set Label_Col_Offset to 3
97296>>>                Set Label_FontWeight to fw_Bold
97297>>>                Set FontWeight to fw_Bold
97298>>>                Set Visible_State to False
97299>>>            End_Object
97300>>>
97300>>>        End_Object
97301>>>
97301>>>    End_Object
97302>>>
97302>>>    Procedure OnSetFocus
97305>>>        Set Value of (oLegacyCodeFilename_fm(Self))     to (psCodeFile(phoEditorLegacy(ghoApplication)))
97306>>>        Set Value of (oRefactoredCodeFilename_fm(Self)) to (psCodeFile(phoEditorRefactored(ghoApplication)))
97307>>>        Set Value of oNoOfSelectedFunctions2_fm to SysFile.SelectedFunctionTotal
97308>>>    End_Procedure
97309>>>
97309>>>    // *** MAIN REFACTORING ROUTINE ***
97309>>>    // Testing of various refactor functions:
97309>>>    Procedure RefactoreCode Boolean bUseConstraints
97312>>>        String[] asLegacyCode asRefactoredCode asSourceFiles
97315>>>        String sLine sLegacyFileName sRefactoredFileName sFunctionName sParameter
97315>>>        Handle hoEditor ho
97315>>>        Integer iSize iCount iTabSize iRetval iFunctionID eSplitMode
97315>>>        Boolean bChanged bLoopFound bisCOMProcxy bWriteLine bOK
97315>>>        DateTime dtStart dtEnd
97315>>>        
97315>>>        Move (CurrentDateTime()) to dtStart
97316>>>        Set Value of (oRefactoredCode_Time_fm(Self)) to ""
97317>>>        Move False to bLoopFound
97318>>>        Send Activate_oFunctionTableTesting
97319>>>        
97319>>>        Get phoEditorLegacy to hoEditor
97320>>>        Get psCodeFile of hoEditor to sLegacyFileName
97321>>>        Get IsDataFlexCOMProxyClassesFile of ghoRefactorFunctionLibrary sLegacyFileName to bisCOMProcxy
97322>>>        If (bisCOMProcxy = True) Begin
97324>>>            Send Info_Box "This file is marked as a Studio COM Proxy classes auto generated file and will _not_ be refactored!"
97325>>>            Procedure_Return
97326>>>        End
97326>>>>
97326>>>
97326>>>        Send UpdateStatusBar of hoEditor "" True
97327>>>        Get EditorDataAsStringArray of hoEditor to asLegacyCode
97328>>>        Move (SizeOfArray(asLegacyCode)) to iSize
97329>>>
97329>>>        Get phoEditorRefactored to hoEditor
97330>>>        Get psCodeFile of hoEditor to sRefactoredFileName
97331>>>        Set phoEditor to hoEditor
97332>>>        If (iSize > 0) Begin
97334>>>            Send Delete_Data of hoEditor
97335>>>        End        
97335>>>>
97335>>>        Else Begin
97336>>>            Send Info_Box "No Legacy code found."
97337>>>            Procedure_Return
97338>>>        End
97338>>>>
97338>>>
97338>>>        Set pbIsRefactoring of ghoApplication to True   
97339>>>        Send Cursor_Wait of (Cursor_Control(Self)) 
97340>>>        Decrement iSize  
97341>>>        
97341>>>        For iCount from 0 to iSize
97347>>>>
97347>>>            // Need this to show "Number of lines:" changes
97347>>>            Send PumpMsgQueue of Desktop   
97348>>>            // Read next source line
97348>>>            Move asLegacyCode[iCount] to sLine
97349>>>            
97349>>>            // These are functions that may potentially remove the line (Sets bWriteLIne to False)
97349>>>            // eRemove_Functions
97349>>>            Move True to bWriteLine
97350>>>            Constraint_Set (Self + 1) Clear  
97352>>>            Constrained_Clear eq FunctionsA by Index.2   
97355>>>            If (bUseConstraints = True) Begin
97357>>>                Constrain FunctionsA.Selected eq True
97359>>>            End
97359>>>>
97359>>>            Constrain FunctionsA.Type eq eRemove_Function
97361>>>            Constrained_Find First FunctionsA by Index.2
97366>>>            While (Found)                          
97370>>>                Move (Trim(FunctionsA.Parameter)) to sParameter
97371>>>                Move (Trim(FunctionsA.Function_Name)) to sFunctionName
97372>>>                Move (Eval("get_" - (sFunctionName))) to iFunctionID
97373>>>                Get iFunctionID of ghoRefactorFunctionLibrary (&sLine) sParameter to bChanged
97374>>>                If (bChanged = True) Begin
97376>>>                    Move False to bWriteLine
97377>>>                End
97377>>>>
97377>>>                Constrained_Find Next
97378>>>            Loop
97379>>>>
97379>>>            
97379>>>            If (bWriteLine = True) Begin
97381>>>                
97381>>>                // eStandard_Function
97381>>>                Constraint_Set (Self + 2) Clear  
97383>>>                Constrained_Clear eq FunctionsA by Index.2
97386>>>                If (bUseConstraints = True) Begin
97388>>>                    Constrain FunctionsA.Selected eq True
97390>>>                End
97390>>>>
97390>>>                Constrain FunctionsA.Type eq eStandard_Function
97392>>>                Constrained_Find First FunctionsA by Index.2
97397>>>                While (Found)
97401>>>                    Move (Trim(FunctionsA.Parameter)) to sParameter
97402>>>                    Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97403>>>                    Move (Eval("get_" - (sFunctionName))) to iFunctionID
97404>>>                    Get iFunctionID of ghoRefactorFunctionLibrary (&sLine) sParameter to bChanged
97405>>>                    Constrained_Find Next
97406>>>                Loop
97407>>>>
97407>>>                
97407>>>                If (iCount < iSize) Begin
97409>>>                    Move (sLine + CS_CRLF) to sLine
97410>>>                End            
97410>>>>
97410>>>                Send AppendText of hoEditor sLine
97411>>>            End
97411>>>>
97411>>>        Loop  
97412>>>>
97412>>>
97412>>>        Send PumpMsgQueue of Desktop  
97413>>>        Send UpdateStatusBar of hoEditor "Executing Editor functions..." True
97414>>>        Get EditorDataAsStringArray of hoEditor to asRefactoredCode
97415>>>        
97415>>>        // eEditor_Function
97415>>>        Move False to bChanged
97416>>>        Constraint_Set (Self + 3) Clear  
97418>>>        Constrained_Clear eq FunctionsA by Index.2
97421>>>        If (bUseConstraints = True) Begin
97423>>>            Constrain FunctionsA.Selected eq True
97425>>>        End
97425>>>>
97425>>>        Constrain FunctionsA.Type eq eEditor_Function
97427>>>        Constrained_Find First FunctionsA by Index.2
97432>>>        While (Found)
97436>>>            Move (Trim(FunctionsA.Parameter)) to sParameter
97437>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97438>>>            If (Lowercase(sFunctionName) <> Lowercase(CS_EditorDropSelf)) Begin
97440>>>                Move (Eval("get_" - (sFunctionName))) to iFunctionID
97441>>>                Get iFunctionID of ghoRefactorFunctionLibrary (&asRefactoredCode) sParameter to bOK
97442>>>                If (bOK = True) Begin
97444>>>                    Move True to bChanged
97445>>>                End
97445>>>>
97445>>>            End
97445>>>>
97445>>>            Constrained_Find Next
97446>>>        Loop
97447>>>>
97447>>>        If (bChanged = True) Begin
97449>>>            Send SaveFile of hoEditor                    
97450>>>            Get EditorDataAsStringArray of hoEditor to asRefactoredCode
97451>>>        End
97451>>>>
97451>>>        Send UpdateStatusBar of hoEditor "" True
97452>>>
97452>>>        // eOther_Function - A source file as a string array is passed.
97452>>>        Move False to bChanged
97453>>>        Constraint_Set (Self + 4) Clear  
97455>>>        Constrained_Clear eq FunctionsA by Index.2
97458>>>        If (bUseConstraints = True) Begin
97460>>>            Constrain FunctionsA.Selected eq True
97462>>>        End
97462>>>>
97462>>>        Constrain FunctionsA.Type eq eOther_Function
97464>>>        Constrained_Find First FunctionsA by Index.2
97469>>>        While (Found)
97473>>>            Move (Trim(FunctionsA.Parameter)) to sParameter
97474>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97475>>>            Move (Eval("get_" - (sFunctionName))) to iFunctionID
97476>>>            Get iFunctionID of ghoRefactorFunctionLibrary (&asRefactoredCode) sParameter to bOK
97477>>>            If (bOK = True) Begin
97479>>>                Move True to bChanged
97480>>>            End
97480>>>>
97480>>>            Constrained_Find Next
97481>>>        Loop
97482>>>>
97482>>>        If (bChanged = True) Begin
97484>>>            Get WriteDataToEditor of hoEditor asRefactoredCode to bOK
97485>>>        End
97485>>>>
97485>>>        
97485>>>        // eOther_FunctionAll - All source files with full pathing is passed to these functions as a string array.
97485>>>        Move sRefactoredFileName to asSourceFiles[0]
97486>>>        Move False to bChanged
97487>>>        Constraint_Set (Self + 4) Clear  
97489>>>        Constrained_Clear eq FunctionsA by Index.2
97492>>>        If (bUseConstraints = True) Begin
97494>>>            Constrain FunctionsA.Selected eq True
97496>>>        End
97496>>>>
97496>>>        Constrain FunctionsA.Type eq eOther_FunctionAll
97498>>>        Constrained_Find First FunctionsA by Index.2
97503>>>        While (Found)
97507>>>            Move (Trim(FunctionsA.Parameter)) to sParameter
97508>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97509>>>            Move (Eval("get_" - (sFunctionName))) to iFunctionID
97510>>>            Get iFunctionID of ghoRefactorFunctionLibrary (&asSourceFiles) sParameter to bOK
97511>>>            If (bOK = True) Begin
97513>>>                Move True to bChanged
97514>>>            End
97514>>>>
97514>>>            Constrained_Find Next
97515>>>        Loop
97516>>>>
97516>>>        If (bChanged = True) Begin
97518>>>            Send LoadFile of hoEditor sRefactoredFileName
97519>>>        End
97519>>>>
97519>>>        
97519>>>        // eReport_Function - A source file as a string array is passed.
97519>>>        // Makes no source code changes
97519>>>        Move False to bChanged
97520>>>        Constraint_Set (Self + 4) Clear  
97522>>>        Constrained_Clear eq FunctionsA by Index.2
97525>>>        If (bUseConstraints = True) Begin
97527>>>            Constrain FunctionsA.Selected eq True
97529>>>        End
97529>>>>
97529>>>        Constrain FunctionsA.Type eq eReport_Function
97531>>>        Constrained_Find First FunctionsA by Index.2
97536>>>        While (Found)
97540>>>            Move (Trim(FunctionsA.Parameter)) to sParameter
97541>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97542>>>            Move (Eval("get_" - (sFunctionName))) to iFunctionID
97543>>>            Get iFunctionID of ghoRefactorFunctionLibrary (&asRefactoredCode) sParameter to bOK
97544>>>            If (bOK = True) Begin
97546>>>                Move True to bChanged
97547>>>            End            
97547>>>>
97547>>>            Constrained_Find Next
97548>>>        Loop
97549>>>>
97549>>>        
97549>>>        // eReport_FunctionAll - All source files with full pathing is passed to these functions as an array.
97549>>>        // Makes no source code changes
97549>>>        Move sLegacyFileName to asSourceFiles[0]
97550>>>        Move False to bChanged
97551>>>        Constraint_Set (Self + 4) Clear  
97553>>>        Constrained_Clear eq FunctionsA by Index.2
97556>>>        If (bUseConstraints = True) Begin
97558>>>            Constrain FunctionsA.Selected eq True
97560>>>        End
97560>>>>
97560>>>        Constrain FunctionsA.Type eq eReport_FunctionAll
97562>>>        Constrained_Find First FunctionsA by Index.2
97567>>>        While (Found)
97571>>>            Move (Trim(FunctionsA.Parameter)) to sParameter
97572>>>            Move (Trim(FunctionsA.Function_Name)) to sFunctionName 
97573>>>            Move (Eval("get_" - (sFunctionName))) to iFunctionID
97574>>>            Get iFunctionID of ghoRefactorFunctionLibrary (&asSourceFiles) sParameter to bOK
97575>>>            If (bOK = True) Begin
97577>>>                Move True to bChanged
97578>>>            End
97578>>>>
97578>>>            Constrained_Find Next
97579>>>        Loop
97580>>>>
97580>>>        
97580>>>        Move (CurrentDateTime()) to dtEnd
97581>>>        Set Value of (oRefactoredCode_Time_fm(Self)) to (dtEnd - dtStart)
97582>>>        Set pbIsRefactoring of ghoApplication to False
97583>>>        Send UpdateStatusBar of hoEditor "Ready!" True
97584>>>        Send Cursor_Ready of (Cursor_Control(Self))        
97585>>>    End_Procedure
97586>>>    
97586>>>End_Object
97587>>>
97587>>>Procedure JumpToSourceLine Integer iLine
97590>>>    Handle hoEdit
97590>>>    Move (phoEditorRefactored(oFunctionTableTesting(Self))) to hoEdit
97591>>>    Send Activate_oFunctionTableTesting
97592>>>    Send JumpToSourceLine of hoEdit iLine    
97593>>>End_Procedure
97594>>>            
97594>        Use FunctionMaintenance.vw
Including file: FunctionMaintenance.vw    (C:\Projects\DF18\DfRefactor\AppSrc\FunctionMaintenance.vw)
97594>>>// C:\Projects\DF18\DfRefactor\AppSrc\FunctionMaintenance.vw
97594>>>// Functions Maintenance
97594>>>//
97594>>>Use cRefactorDbView.pkg
97594>>>Use DFEntry.pkg
97594>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cDbScrollingContainer.pkg)
97594>>>>>// Provides support for db aware scrolling containers.
97594>>>>>// Scrolling containers is provided by creating two objects,
97594>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
97594>>>>>// The host has no public interface, you just drop the object. It should have only one child object
97594>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
97594>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
97594>>>>>
97594>>>>>Use DFClient.pkg
97594>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cScrollingContainerMixin.pkg)
97594>>>>>>>// Mixin classes for scrolling container support:
97594>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
97594>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
97594>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
97594>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
97594>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
97594>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
97594>>>>>>>
97594>>>>>>>Use Windows.pkg
97594>>>>>>>Use Winuser.pkg
97594>>>>>>>Use tWinStructs.pkg
97594>>>>>>>
97594>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
97594>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
97594>>>>>>>// support for the scrolling client area mixin object.
97594>>>>>>>
97594>>>>>>>Class cScrollingClientAreaMixin is a Mixin
97595>>>>>>>    
97595>>>>>>>    Procedure Define_cScrollingClientAreaMixin
97597>>>>>>>        
97597>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
97598>>>>>>>        Set Border_Style to Border_None
97599>>>>>>>        
97599>>>>>>>        Property Boolean pbAutoScroll True
97600>>>>>>>        Property Boolean pbAutoScrollFocus True
97601>>>>>>>        Property Integer piAutoScrollMarginX 5
97602>>>>>>>        Property Integer piAutoScrollMarginY 5
97603>>>>>>>        Property Integer piAutoScrollMinX 0
97604>>>>>>>        Property Integer piAutoScrollMinY 0
97605>>>>>>>        Property Boolean pbShowDisabledScrollBar False
97606>>>>>>>        
97606>>>>>>>        
97606>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
97607>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
97608>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
97609>>>>>>>        // keeps track of scrolling
97609>>>>>>>        Property Integer piCurrentVertScrolled 0
97610>>>>>>>        Property Integer piCurrentHorzScrolled 0
97611>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
97612>>>>>>>        Delegate Set phoScrollingClientArea to Self
97614>>>>>>>        
97614>>>>>>>        // set this true to make this a tabbed workspace view (design time)
97614>>>>>>>        Property Boolean pbTabWorkspaceView False
97615>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
97615>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
97616>>>>>>>    End_Procedure
97617>>>>>>>    
97617>>>>>>>    // low level event sent from windows.
97617>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97619>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
97619>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
97620>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
97621>>>>>>>        If (wParam<0) Begin
97623>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
97624>>>>>>>        End
97624>>>>>>>>
97624>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
97625>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
97626>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
97626>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
97627>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
97628>>>>>>>        // If we have enough Clicks send OnMouseWheel
97628>>>>>>>        If (iClicks<>0) Begin
97630>>>>>>>            Send OnMouseWheel iClicks iKeys
97631>>>>>>>        End
97631>>>>>>>>
97631>>>>>>>        // tell windows that we've handled the event.
97631>>>>>>>        Set Windows_Override_State to True
97632>>>>>>>    End_Procedure
97633>>>>>>>    
97633>>>>>>>    
97633>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
97633>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
97635>>>>>>>        Integer iLineScrollUnit
97635>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
97636>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
97637>>>>>>>    End_Procedure
97638>>>>>>>    
97638>>>>>>>    // should be sent by WM_VSCROLL
97638>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97640>>>>>>>        Boolean bOk
97640>>>>>>>        tWinScrollInfo ScrollInfo
97640>>>>>>>        tWinScrollInfo ScrollInfo
97640>>>>>>>        Integer iLineScrollUnit
97640>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
97641>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
97642>>>>>>>        If bOk Begin
97644>>>>>>>            
97644>>>>>>>            Case Begin
97644>>>>>>>                Case (iType=SB_PAGEDOWN)
97646>>>>>>>                    Send VScroll ScrollInfo.nPage
97647>>>>>>>                    Case Break
97648>>>>>>>                
97648>>>>>>>                Case (iType=SB_PAGEUP)
97651>>>>>>>                    Send VScroll (-ScrollInfo.nPage)
97652>>>>>>>                    Case Break
97653>>>>>>>                
97653>>>>>>>                Case (iType=SB_LINEDOWN)
97656>>>>>>>                    Send VScroll iLineScrollUnit
97657>>>>>>>                    Case Break
97658>>>>>>>                
97658>>>>>>>                Case (iType=SB_LINEUP)
97661>>>>>>>                    Send VScroll (-iLineScrollUnit)
97662>>>>>>>                    Case Break
97663>>>>>>>                
97663>>>>>>>                Case (iType=SB_BOTTOM)
97666>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
97667>>>>>>>                    Case Break
97668>>>>>>>                
97668>>>>>>>                Case (iType=SB_Top)
97671>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
97672>>>>>>>                    Case Break
97673>>>>>>>                
97673>>>>>>>                Case (iType=SB_THUMBPOSITION)
97676>>>>>>>                    Case Break
97677>>>>>>>                
97677>>>>>>>                Case (iType=SB_THUMBTRACK)
97680>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
97681>>>>>>>                    Case Break
97682>>>>>>>            Case End
97682>>>>>>>        End
97682>>>>>>>>
97682>>>>>>>    End_Procedure
97683>>>>>>>    
97683>>>>>>>    // should be sent by WM_HSCROLL
97683>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97685>>>>>>>        Boolean bOk
97685>>>>>>>        tWinScrollInfo ScrollInfo
97685>>>>>>>        tWinScrollInfo ScrollInfo
97685>>>>>>>        Integer iLineScrollUnit
97685>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
97686>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
97687>>>>>>>        If bOk Begin
97689>>>>>>>            
97689>>>>>>>            Case Begin
97689>>>>>>>                Case (iType=SB_PAGEDOWN)
97691>>>>>>>                    Send hScroll ScrollInfo.nPage
97692>>>>>>>                    Case Break
97693>>>>>>>                
97693>>>>>>>                Case (iType=SB_PAGEUP)
97696>>>>>>>                    Send hScroll (-ScrollInfo.nPage)
97697>>>>>>>                    Case Break
97698>>>>>>>                
97698>>>>>>>                Case (iType=SB_LINEDOWN)
97701>>>>>>>                    Send hScroll iLineScrollUnit
97702>>>>>>>                    Case Break
97703>>>>>>>                
97703>>>>>>>                Case (iType=SB_LINEUP)
97706>>>>>>>                    Send hScroll (-iLineScrollUnit)
97707>>>>>>>                    Case Break
97708>>>>>>>                
97708>>>>>>>                Case (iType=SB_BOTTOM)
97711>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
97712>>>>>>>                    Case Break
97713>>>>>>>                
97713>>>>>>>                Case (iType=SB_Top)
97716>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
97717>>>>>>>                    Case Break
97718>>>>>>>                
97718>>>>>>>                Case (iType=SB_THUMBPOSITION)
97721>>>>>>>                    Case Break
97722>>>>>>>                
97722>>>>>>>                Case (iType=SB_THUMBTRACK)
97725>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
97726>>>>>>>                    Case Break
97727>>>>>>>            Case End
97727>>>>>>>        End
97727>>>>>>>>
97727>>>>>>>    End_Procedure
97728>>>>>>>    
97728>>>>>>>    
97728>>>>>>>    // this calls SetScrollInfo with proper info
97728>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
97730>>>>>>>        tWinScrollInfo ScrollInfo
97730>>>>>>>        tWinScrollInfo ScrollInfo
97730>>>>>>>        Integer iVoid
97730>>>>>>>        Handle hWnd
97730>>>>>>>        Boolean bShow
97730>>>>>>>        
97730>>>>>>>        Delegate Get Window_Handle to hWnd
97732>>>>>>>        If (hWnd <> 0) Begin
97734>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
97735>>>>>>>            
97735>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
97736>>>>>>>            Get pbShowDisabledScrollBar to bShow
97737>>>>>>>            If bShow Begin
97739>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
97740>>>>>>>            End
97740>>>>>>>>
97740>>>>>>>            Move iRangeMin to ScrollInfo.nMin
97741>>>>>>>            Move iRangeMax to ScrollInfo.nMax
97742>>>>>>>            Move iPageSize to ScrollInfo.nPage
97743>>>>>>>            Move 0 to ScrollInfo.nPos
97744>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
97745>>>>>>>            
97745>>>>>>>        End
97745>>>>>>>>
97745>>>>>>>    End_Procedure
97746>>>>>>>    
97746>>>>>>>    // this wraps GetScrollInfo
97746>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
97748>>>>>>>        Boolean bOk
97748>>>>>>>        Handle hWnd
97748>>>>>>>        
97748>>>>>>>        Delegate Get Window_Handle to hWnd
97750>>>>>>>        If (hWnd <> 0) Begin
97752>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
97753>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
97754>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
97755>>>>>>>        End
97755>>>>>>>>
97755>>>>>>>        Function_Return bOk
97756>>>>>>>    End_Function
97757>>>>>>>    
97757>>>>>>>    // this wraps SetScrollPos
97757>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
97759>>>>>>>        Integer iVoid
97759>>>>>>>        Handle hWnd
97759>>>>>>>        
97759>>>>>>>        Delegate Get Window_Handle to hWnd
97761>>>>>>>        If (hWnd <> 0) Begin
97763>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
97764>>>>>>>        End
97764>>>>>>>>
97764>>>>>>>    End_Procedure
97765>>>>>>>    
97765>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
97765>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
97765>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
97767>>>>>>>        Send ScrollClientArea
97768>>>>>>>    End_Procedure
97769>>>>>>>    
97769>>>>>>>    // augment to handle the scrolling area initialization.
97769>>>>>>>    Procedure Add_Focus Handle hoParent
97771>>>>>>>        Forward Send Add_Focus hoParent
97773>>>>>>>        // at this the scrolling container and client area should both be paged.
97773>>>>>>>        // child objects ae also paged with initial anchors applied
97773>>>>>>>        Send CalculateAutoScrollMinimums
97774>>>>>>>    End_Procedure
97775>>>>>>>    
97775>>>>>>>    Procedure Page Integer iPage
97777>>>>>>>        Forward Send Page iPage
97779>>>>>>>        If iPage Begin
97781>>>>>>>            // at this the scrolling container and client area should both be paged
97781>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
97781>>>>>>>            // the child items are paged (else they may get anchored oddly)
97781>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
97781>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
97781>>>>>>>            // before they were really needed. This should be more accurate
97781>>>>>>>            Send SetScrollBarInfo True 0 0 0
97782>>>>>>>            Send SetScrollBarInfo False 0 0 0
97783>>>>>>>        End
97783>>>>>>>>
97783>>>>>>>    End_Procedure
97784>>>>>>>    
97784>>>>>>>    // determine scrolling minimums and set the client area as required.
97784>>>>>>>    
97784>>>>>>>    Procedure CalculateAutoScrollMinimums
97786>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
97786>>>>>>>        Integer iAutoMinX iAutoMinY
97786>>>>>>>        Boolean bAutoScroll
97786>>>>>>>        Handle hoNext hoFirst
97786>>>>>>>        
97786>>>>>>>        Get pbAutoScroll to bAutoScroll
97787>>>>>>>        Get piAutoScrollMinX to iAutoMinX
97788>>>>>>>        Get piAutoScrollMinY to iAutoMinY
97789>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
97790>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
97791>>>>>>>        Move (Low(iSiz)) to iAutoMinX
97792>>>>>>>        Set piMinimumHeight to iAutoMinY
97793>>>>>>>        Set piMinimumWidth to iAutoMinX
97794>>>>>>>        
97794>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
97796>>>>>>>            
97796>>>>>>>            Get Next_Level to hoFirst
97797>>>>>>>            Move hoFirst to hoNext
97798>>>>>>>            If (hoFirst) Begin
97800>>>>>>>                Repeat
97800>>>>>>>>
97800>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
97801>>>>>>>                    Get GuiLocation of hoNext to iLoc
97802>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
97803>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
97804>>>>>>>                    Get Next_Focus of hoNext to hoNext
97805>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
97807>>>>>>>                
97807>>>>>>>                If (iAutoMinY=0) Begin
97809>>>>>>>                    Get piAutoScrollMarginY to iMargin
97810>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
97811>>>>>>>                End
97811>>>>>>>>
97811>>>>>>>                
97811>>>>>>>                If (iAutoMinX=0) Begin
97813>>>>>>>                    Get piAutoScrollMarginX to iMargin
97814>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
97815>>>>>>>                    
97815>>>>>>>                End
97815>>>>>>>>
97815>>>>>>>            End
97815>>>>>>>>
97815>>>>>>>        End
97815>>>>>>>>
97815>>>>>>>        
97815>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
97815>>>>>>>        Broadcast Set pbAnchorCreated to False
97817>>>>>>>        Send ScrollClientArea
97818>>>>>>>        // after the scroll set up, reinitialize all anchors.
97818>>>>>>>        Broadcast Send DoCreateAnchors
97820>>>>>>>    End_Procedure
97821>>>>>>>    
97821>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
97821>>>>>>>    // work of scrolling.
97821>>>>>>>    
97821>>>>>>>    Procedure ScrollClientArea
97823>>>>>>>        Integer iSiz
97823>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
97823>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
97823>>>>>>>        Integer iSzY iSzX iLocX iLocY
97823>>>>>>>        
97823>>>>>>>        Delegate Get GuiClientSize to iSiz
97825>>>>>>>        Move (Hi(iSiz)) to iHeight
97826>>>>>>>        Move (Low(iSiz)) to iWidth
97827>>>>>>>        
97827>>>>>>>        // Vertical scrolling
97827>>>>>>>        
97827>>>>>>>        Get piMinimumHeight to iOrig
97828>>>>>>>        Get piMinimumWidth to iWOrig
97829>>>>>>>        
97829>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
97831>>>>>>>            
97831>>>>>>>            If (iOrig<>0) Begin
97833>>>>>>>                Get piCurrentVertScrolled to iHCur
97834>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
97834>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
97836>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
97837>>>>>>>                    Set piCurrentVertScrolled to iHCur
97838>>>>>>>                End
97838>>>>>>>>
97838>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
97840>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
97841>>>>>>>                    Send SetScrollBarPosInfo True iHCur
97842>>>>>>>                End
97842>>>>>>>>
97842>>>>>>>                Else Begin
97843>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
97844>>>>>>>                End
97844>>>>>>>>
97844>>>>>>>            End
97844>>>>>>>>
97844>>>>>>>            
97844>>>>>>>            // Horiz scrolling
97844>>>>>>>            
97844>>>>>>>            Get piCurrentHorzScrolled to iWCur
97845>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
97845>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
97847>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
97848>>>>>>>                Set piCurrentHorzScrolled to iWCur
97849>>>>>>>            End
97849>>>>>>>>
97849>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
97851>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
97852>>>>>>>                Send SetScrollBarPosInfo False iWCur
97853>>>>>>>            End
97853>>>>>>>>
97853>>>>>>>            Else Begin
97854>>>>>>>                Send SetScrollBarInfo False 0 0 0
97855>>>>>>>            End
97855>>>>>>>>
97855>>>>>>>        End
97855>>>>>>>>
97855>>>>>>>        
97855>>>>>>>        // this could change depending on scrollbars appearing or not
97855>>>>>>>        Delegate Get GuiClientSize to iSiz
97857>>>>>>>        
97857>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
97857>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
97857>>>>>>>        // This is required to make anchors work sensibly
97857>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
97858>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
97859>>>>>>>        Move (-iHCur) to iLocY
97860>>>>>>>        Move (-iWCur) to iLocX
97861>>>>>>>        
97861>>>>>>>        // Allow chance to make modifications
97861>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
97862>>>>>>>        
97862>>>>>>>        Set GuiSize to iSzY iSzX
97863>>>>>>>        // if we've scrolled, we need to reposition the container
97863>>>>>>>        Set GuiLocation to iLocY iLocX
97864>>>>>>>    End_Procedure
97865>>>>>>>    
97865>>>>>>>    // note that scrolling never changes the size of the scrolling client.
97865>>>>>>>    // this way, it does not interfere with anchors.
97865>>>>>>>    
97865>>>>>>>    Procedure VScroll Integer iDelta
97867>>>>>>>        Integer iHeight iCur iOrig iSiz
97867>>>>>>>        Delegate Get GuiClientSize to iSiz
97869>>>>>>>        Move (hi(iSiz)) to iHeight
97870>>>>>>>        Get piCurrentVertScrolled to iCur
97871>>>>>>>        Get piMinimumHeight to iOrig
97872>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
97874>>>>>>>            Procedure_Return
97875>>>>>>>        End
97875>>>>>>>>
97875>>>>>>>        // make sure delta is within range
97875>>>>>>>        If (iDelta+iCur<0) Begin
97877>>>>>>>            Move (-iCur) to iDelta
97878>>>>>>>        End
97878>>>>>>>>
97878>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97881>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97882>>>>>>>        End
97882>>>>>>>>
97882>>>>>>>        If (iDelta=0) ;            Procedure_Return
97885>>>>>>>        
97885>>>>>>>        Move (iCur + iDelta) to iCur
97886>>>>>>>        Set piCurrentVertScrolled to iCur
97887>>>>>>>        Send SetScrollBarPosInfo True iCur
97888>>>>>>>        Get GuiLocation to iSiz
97889>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)-iDelta) (cast(low(iSiz),Short))
97890>>>>>>>        Send ScrollClientArea
97891>>>>>>>    End_Procedure
97892>>>>>>>    
97892>>>>>>>    
97892>>>>>>>    Procedure HScroll Integer iDelta
97894>>>>>>>        Integer iHeight iCur iOrig iSiz
97894>>>>>>>        Delegate Get GuiClientSize to iSiz
97896>>>>>>>        Move (low(iSiz)) to iHeight
97897>>>>>>>        Get piCurrentHorzScrolled to iCur
97898>>>>>>>        Get piMinimumWidth to iOrig
97899>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
97901>>>>>>>            Procedure_Return
97902>>>>>>>        End
97902>>>>>>>>
97902>>>>>>>        If (iDelta+iCur<0) Begin
97904>>>>>>>            Move (-iCur) to iDelta
97905>>>>>>>        End
97905>>>>>>>>
97905>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97908>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97909>>>>>>>        End
97909>>>>>>>>
97909>>>>>>>        If (iDelta=0) ;            Procedure_Return
97912>>>>>>>        
97912>>>>>>>        Move (iCur + iDelta) to iCur
97913>>>>>>>        Set piCurrentHorzScrolled to iCur
97914>>>>>>>        Send SetScrollBarPosInfo False iCur
97915>>>>>>>        Get GuiLocation to iSiz
97916>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
97917>>>>>>>        Send ScrollClientArea
97918>>>>>>>    End_Procedure
97919>>>>>>>    
97919>>>>>>>    // make sure client is a 0,0
97919>>>>>>>    Procedure ScrollHome
97921>>>>>>>        Send SetVScrollbox SB_TOP 0
97922>>>>>>>        Send SetHScrollbox SB_TOP 0
97923>>>>>>>    End_Procedure
97924>>>>>>>    
97924>>>>>>>    // get relative GUI location of this object to the parent one passed.
97924>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
97926>>>>>>>        Integer ivoid
97926>>>>>>>        tWinRect Rect0 Rect1
97926>>>>>>>        tWinRect Rect0 Rect1
97926>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
97927>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
97928>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
97929>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
97930>>>>>>>    End_Procedure
97931>>>>>>>    
97931>>>>>>>    // This scrolls this object into visual range.
97931>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
97933>>>>>>>        Handle hoScrollingContainer
97933>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
97933>>>>>>>        Integer iViewHeight iViewWidth
97933>>>>>>>        Integer iRelLocHeight iRelLocWidth
97933>>>>>>>        Integer iSize iControlHeight iControlWidth
97933>>>>>>>        Integer iScroll
97933>>>>>>>        Integer iMarginX iMarginY
97933>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
97933>>>>>>>        
97933>>>>>>>        Get piAutoScrollMarginX to iMarginX
97934>>>>>>>        Get piAutoScrollMarginY to iMarginY
97935>>>>>>>        
97935>>>>>>>        // the scrolling container
97935>>>>>>>        Move Self to hoScrollingContainer
97936>>>>>>>        // the amount the SC is currently scrolled
97936>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
97937>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
97938>>>>>>>        
97938>>>>>>>        // size of view's client area (this is the viewport area)
97938>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
97939>>>>>>>        Move (hi(iSize)) to iViewHeight
97940>>>>>>>        Move (low(iSize)) to iViewWidth
97941>>>>>>>        
97941>>>>>>>        // get this object's location relative to the scrolling container
97941>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
97942>>>>>>>        
97942>>>>>>>        // we expect that the client size is the window size but just in case
97942>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
97943>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
97944>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
97945>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
97946>>>>>>>        
97946>>>>>>>        // the outer size of the control object
97946>>>>>>>        Get GUIWindowSize of hoControl to iSize
97947>>>>>>>        Move (hi(iSize)) to iControlHeight
97948>>>>>>>        Move (low(iSize)) to iControlWidth
97949>>>>>>>        
97949>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
97949>>>>>>>        
97949>>>>>>>        // Vertical Scroll
97949>>>>>>>        
97949>>>>>>>        // Vertical Scroll down
97949>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
97949>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
97951>>>>>>>            
97951>>>>>>>            // set scroll amount so that the bottom of the control is visible
97951>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
97952>>>>>>>            
97952>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
97952>>>>>>>            // top of the object appears at the bottom
97952>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
97954>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
97955>>>>>>>            End
97955>>>>>>>>
97955>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
97955>>>>>>>            If (iScroll>0) Begin
97957>>>>>>>                Send VScroll of hoScrollingContainer iScroll
97958>>>>>>>            End
97958>>>>>>>>
97958>>>>>>>        End
97958>>>>>>>>
97958>>>>>>>        // else vertical scroll up
97958>>>>>>>        // We scroll if the top of the object is not visible.
97958>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
97961>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
97961>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
97962>>>>>>>            If (iScroll<0) Begin
97964>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
97965>>>>>>>            End
97965>>>>>>>>
97965>>>>>>>        End
97965>>>>>>>>
97965>>>>>>>        
97965>>>>>>>        // Horizonal Scroll
97965>>>>>>>        
97965>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
97965>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
97967>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
97968>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
97970>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
97971>>>>>>>            End
97971>>>>>>>>
97971>>>>>>>            If (iScroll>0) Begin
97973>>>>>>>                Send HScroll of hoScrollingContainer iScroll
97974>>>>>>>            End
97974>>>>>>>>
97974>>>>>>>        End
97974>>>>>>>>
97974>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
97976>>>>>>>            // if this can fit by moving all the way to left, do so.
97976>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
97978>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
97979>>>>>>>            End
97979>>>>>>>>
97979>>>>>>>            Else Begin
97980>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
97981>>>>>>>            End
97981>>>>>>>>
97981>>>>>>>            If (iScroll<0) Begin
97983>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
97984>>>>>>>            End
97984>>>>>>>>
97984>>>>>>>        End
97984>>>>>>>>
97984>>>>>>>        
97984>>>>>>>        
97984>>>>>>>    End_Procedure
97985>>>>>>>    
97985>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
97985>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
97987>>>>>>>        Boolean bScrollOnFocus
97987>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
97988>>>>>>>        If bScrollOnFocus Begin
97990>>>>>>>            Send ScrollObjectInRange hoControl
97991>>>>>>>        End
97991>>>>>>>>
97991>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
97993>>>>>>>    End_Procedure
97994>>>>>>>    
97994>>>>>>>    
97994>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
97996>>>>>>>        Boolean bCenter
97996>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
97997>>>>>>>        Function_Return bCenter
97998>>>>>>>    End_Function
97999>>>>>>>    
97999>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
98001>>>>>>>        Boolean bTabWorkspaceView
98001>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
98002>>>>>>>        If bTabWorkspaceView Begin
98004>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
98005>>>>>>>        End
98005>>>>>>>>
98005>>>>>>>    End_Procedure
98006>>>>>>>    
98006>>>>>>>    Function ParentView Returns Handle
98008>>>>>>>        Function_Return (Parent(Parent(Self)))
98009>>>>>>>    End_Function
98010>>>>>>>    
98010>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
98012>>>>>>>        Integer iSize iMax iDiff
98012>>>>>>>        Handle hoView
98012>>>>>>>        Boolean bCenter bModal
98012>>>>>>>        Get ParentView to hoView
98013>>>>>>>        Get Block_Mouse_State of hoView to bModal
98014>>>>>>>        If not bModal Begin
98016>>>>>>>            Get CenterTabWorkspaceView to bCenter
98017>>>>>>>            Get GuiSize of hoView to iSize
98018>>>>>>>            Get piMaxSize of hoView to iMax
98019>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
98020>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
98022>>>>>>>                If bCenter Begin
98024>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
98025>>>>>>>                End
98025>>>>>>>>
98025>>>>>>>                Move (Low(iMax)) to iWidth
98026>>>>>>>            End
98026>>>>>>>>
98026>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
98028>>>>>>>                If bCenter Begin
98030>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
98031>>>>>>>                    Move (iLocy min 25) to  iLocY
98032>>>>>>>                End
98032>>>>>>>>
98032>>>>>>>                Move (Hi(imax)) to iHeight
98033>>>>>>>            End
98033>>>>>>>>
98033>>>>>>>        End
98033>>>>>>>>
98033>>>>>>>    End_Procedure
98034>>>>>>>    
98034>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
98034>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
98034>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
98034>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
98034>>>>>>>    // This should almost always yield the right answer.
98034>>>>>>>    // This is called by the scrolling container's end_constructor
98034>>>>>>>    Procedure AutoSetTabWorkspaceView
98036>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
98036>>>>>>>        Handle hoParent
98036>>>>>>>        Integer iSize
98036>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
98037>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
98039>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
98040>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
98040>>>>>>>            // change this after the commandbar is paged.
98040>>>>>>>            If (bTabView) Begin
98042>>>>>>>                Get ParentView to hoParent
98043>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
98044>>>>>>>                If (bIsView) Begin
98046>>>>>>>                    // set this as a tab workspace view
98046>>>>>>>                    Set pbTabWorkspaceView to True
98047>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
98047>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
98047>>>>>>>                    Set pbAutoScroll to True
98048>>>>>>>                    
98048>>>>>>>                End
98048>>>>>>>>
98048>>>>>>>            End
98048>>>>>>>>
98048>>>>>>>        End
98048>>>>>>>>
98048>>>>>>>    End_Procedure
98049>>>>>>>    
98049>>>>>>>End_Class
98050>>>>>>>
98050>>>>>>>// Container scrolling class support. Nothing in here is public
98050>>>>>>>Class cScrollingContainerMixin is a Mixin
98051>>>>>>>    
98051>>>>>>>    Procedure Define_cScrollingContainerMixin
98053>>>>>>>        Forward Set Border_Style to Border_None
98055>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
98056>>>>>>>        Forward Set peAnchors to anAll
98058>>>>>>>        
98058>>>>>>>        // forcing scrollbars right away seems to make painting better
98058>>>>>>>        Set Window_Style WS_HSCROLL to True
98059>>>>>>>        Set Window_Style WS_VSCROLL to True
98060>>>>>>>        
98060>>>>>>>        Property Handle phoScrollingClientArea 0
98061>>>>>>>    End_Procedure
98062>>>>>>>    
98062>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
98062>>>>>>>    Procedure Set peAnchors Integer eAnchors
98064>>>>>>>    End_Procedure
98065>>>>>>>    
98065>>>>>>>    // if a border style is set, it will not work. We won't let that happen
98065>>>>>>>    Procedure Set Border_Style Integer eStyle
98067>>>>>>>    End_Procedure
98068>>>>>>>    
98068>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
98068>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
98070>>>>>>>        Handle hoClient
98070>>>>>>>        Get phoScrollingClientArea to hoClient
98071>>>>>>>        If hoClient Begin
98073>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
98074>>>>>>>        End
98074>>>>>>>>
98074>>>>>>>    End_Procedure
98075>>>>>>>    
98075>>>>>>>    // should be sent by WM_VSCROLL
98075>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
98077>>>>>>>        Handle hoClient
98077>>>>>>>        Get phoScrollingClientArea to hoClient
98078>>>>>>>        If hoClient Begin
98080>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
98081>>>>>>>        End
98081>>>>>>>>
98081>>>>>>>    End_Procedure
98082>>>>>>>    
98082>>>>>>>    // should be sent by WM_HSCROLL
98082>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
98084>>>>>>>        Handle hoClient
98084>>>>>>>        Get phoScrollingClientArea to hoClient
98085>>>>>>>        If hoClient Begin
98087>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
98088>>>>>>>        End
98088>>>>>>>>
98088>>>>>>>    End_Procedure
98089>>>>>>>    
98089>>>>>>>    // augmented to adjust its size to the size of the parent client area.
98089>>>>>>>    // After this is set, anchors will handle any further resizing.
98089>>>>>>>    Procedure Page Integer iState
98091>>>>>>>        Integer iSiz iHeight iWidth
98091>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
98091>>>>>>>        Boolean bGroup
98091>>>>>>>        Handle hoClient
98091>>>>>>>        If (iState =1) Begin
98093>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
98095>>>>>>>            // We have special code to support groups because they
98095>>>>>>>            // draw a border inside of the client rectangle
98095>>>>>>>            If bGroup Begin
98097>>>>>>>                Get Physical_FontSize to iFontSize
98098>>>>>>>                Move (Hi(iFontSize)) to iTop
98099>>>>>>>                Move 2 to iLeft
98100>>>>>>>                Move 2 to iRight
98101>>>>>>>                Move 2 to iBottom
98102>>>>>>>            End
98102>>>>>>>>
98102>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
98102>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
98102>>>>>>>            // makes anchors work properly with unpaged tab-pages
98102>>>>>>>            Delegate Get GetContainerClientSize to iSiz
98104>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
98105>>>>>>>            Set GuiLocation to iTop iLeft
98106>>>>>>>            Send Adjust_Logicals
98107>>>>>>>        End
98107>>>>>>>>
98107>>>>>>>        Forward Send Page iState
98109>>>>>>>    End_Procedure
98110>>>>>>>    
98110>>>>>>>    Procedure End_Construct_Object
98112>>>>>>>        Handle hoClient
98112>>>>>>>        Forward Send End_Construct_Object
98114>>>>>>>        Get phoScrollingClientArea to hoClient
98115>>>>>>>        If (hoClient) Begin
98117>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
98118>>>>>>>        End
98118>>>>>>>>
98118>>>>>>>    End_Procedure
98119>>>>>>>    
98119>>>>>>>End_Class
98120>>>>>
98120>>>>>Class cDbScrollingClientArea is a dbContainer3d
98121>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
98122>>>>>    Procedure Construct_Object
98124>>>>>        Forward Send Construct_Object
98126>>>>>        Send Define_cScrollingClientAreaMixin
98127>>>>>    End_Procedure
98128>>>>>End_Class
98129>>>>>
98129>>>>>
98129>>>>>
98129>>>>>Class cDbScrollingContainer is a dbContainer3d
98130>>>>>    Import_Class_Protocol cScrollingContainerMixin
98131>>>>>    Procedure Construct_Object
98133>>>>>        Forward Send Construct_Object
98135>>>>>        Send Define_cScrollingContainerMixin
98136>>>>>    End_Procedure
98137>>>>>End_Class
98138>>>Use DFEnChk.pkg
98138>>>Use Dfenrad.pkg
98138>>>Use cRDCDbHeaderGroup.pkg
Including file: cRDCDbHeaderGroup.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbHeaderGroup.pkg)
98138>>>>>//****************************************************************************
98138>>>>>// $Module type: Package
98138>>>>>// $Module name: cRDCHeaderGroup.pkg
98138>>>>>//
98138>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
98138>>>>>// Copyright (c) 2017 RDC Tools International
98138>>>>>// E-mail      : support@rdctools.com
98138>>>>>// Web-site    : http://www.rdctools.com
98138>>>>>//
98138>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
98138>>>>>//
98138>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
98138>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
98138>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
98138>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
98138>>>>>// in the help folder for more details.
98138>>>>>//
98138>>>>>//****************************************************************************
98138>>>>>Use Dfclient.pkg
98138>>>>>Use cCommandLinkButton.pkg
98138>>>>>
98138>>>>>Class cRDCDbHeaderGroupImage is a cCommandLinkButton
98139>>>>>    Procedure Construct_Object
98141>>>>>        Forward Send Construct_Object
98143>>>>>
98143>>>>>        Set Size to 18 19
98144>>>>>        Set Focus_Mode to NonFocusable
98145>>>>>        Set peImageAlign to Button_ImageList_Align_Top
98146>>>>>        Set pbAutoResizeIcons to True
98147>>>>>    End_Procedure
98148>>>>>
98148>>>>>    Procedure OnClick
98150>>>>>        Broadcast Send Prompt of (Parent(Self))
98152>>>>>    End_Procedure
98153>>>>>
98153>>>>>    Procedure Set Bitmap String sBitmapName
98155>>>>>        Forward Set psImage to sBitmapName
98157>>>>>    End_Procedure
98158>>>>>
98158>>>>>    Procedure End_Construct_Object
98160>>>>>        Set pbShield to False
98161>>>>>        Forward Send End_Construct_Object
98163>>>>>    End_Procedure
98164>>>>>
98164>>>>>End_Class
98165>>>>>
98165>>>>>// Intermediate class - don't use.
98165>>>>>Class _cRDCDbHeaderGroup is a dbContainer3d
98166>>>>>
98166>>>>>    Procedure Construct_Object
98168>>>>>        Forward Send Construct_Object
98170>>>>>
98170>>>>>        Property String private.psImage
98171>>>>>        Property String private.psLabel
98172>>>>>
98172>>>>>    End_Procedure
98173>>>>>
98173>>>>>    Procedure Set psImage String sImage
98175>>>>>        Set private.psImage to sImage
98176>>>>>    End_Procedure
98177>>>>>
98177>>>>>    Function psImage Returns String
98179>>>>>        Function_Return (private.psImage(Self))
98180>>>>>    End_Function
98181>>>>>
98181>>>>>    Procedure Set psLabel String sLabel
98183>>>>>        Set private.psLabel to sLabel
98184>>>>>    End_Procedure
98185>>>>>
98185>>>>>    Function psLabel Returns String
98187>>>>>        Function_Return (private.psLabel(Self))
98188>>>>>    End_Function
98189>>>>>
98189>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
98189>>>>>    Procedure Set Label String sLabel
98191>>>>>        Set psLabel to sLabel
98192>>>>>    End_Procedure
98193>>>>>
98193>>>>>    Function Label Returns String
98195>>>>>        Function_Return (private.psLabel(Self))
98196>>>>>    End_Function
98197>>>>>
98197>>>>>End_Class
98198>>>>>
98198>>>>>Register_Procedure NavigatePrevious
98198>>>>>Register_Procedure NavigateNext
98198>>>>>
98198>>>>>Class cRDCDbHeaderGroup is a _cRDCDbHeaderGroup
98199>>>>>
98199>>>>>    Procedure Construct_Object
98201>>>>>        Forward Send Construct_Object
98203>>>>>
98203>>>>>        Set peAnchors to anTopBottom //anTopLeftRight
98204>>>>>        Set pbAcceptDropFiles to True
98205>>>>>        Set Border_Style to Border_Normal
98206>>>>>
98206>>>>>        Property Integer private.piColorOrg
98207>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
98208>>>>>        Property String private.psToolTip ""
98209>>>>>
98209>>>>>        Property Integer piImageColOffset 4
98210>>>>>        Property Integer piImageRowOffset -1
98211>>>>>        Property String psNote ""
98212>>>>>        Property Boolean pbLargeImageSize True
98213>>>>>        Property Integer private.piLargeImageSize 24
98214>>>>>        Property Integer private.piSmallImageSize 16
98215>>>>>        Property Boolean pbUseHotspotColor False
98216>>>>>        Property Integer piHeaderHotspotColor clAqua
98217>>>>>        Property String private.psLabel ""
98218>>>>>        Property Integer piLabelColor clGreenGrey
98219>>>>>        Property Boolean pbLabelFontItalics False
98220>>>>>        Property Integer piLabelLargeFontHeight 12
98221>>>>>        Property Integer piLabelSmallFontHeight 10
98222>>>>>        Property Boolean pbUseLargeFontHeight False
98223>>>>>
98223>>>>>        Property Integer piLabelFontPointWeight fw_Bold
98224>>>>>        Property Integer piLabelColOffset 28
98225>>>>>        Property Integer piLabelRowOffset 4
98226>>>>>        Property Boolean pbCreateTooltipItem True
98227>>>>>
98227>>>>>        Set pbAcceptDropFiles to True
98228>>>>>
98228>>>>>        Send Define_ToolTip_Support_Mixin
98229>>>>>
98229>>>>>        // For the Studio to render the header image
98229>>>>>        Set Bitmap to "Default32x32.bmp"
98230>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
98230>>>>>        // to render some text in the header when in design mode?
98230>>>>>        Set Label to "HEADER TEXT"
98231>>>>>
98231>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
98232>>>>>        On_Key kCancel Send None
98233>>>>>        On_Key Key_F3  Send None 
98234>>>>>        On_Key Key_Ctrl+Key_F4 Send None
98235>>>>>        On_Key kLeftArrow  Send NavigatePrevious
98236>>>>>        On_Key kUpArrow    Send NavigatePrevious
98237>>>>>        On_Key kRightArrow Send NavigateNext
98238>>>>>        On_Key kDownArrow  Send NavigateNext
98239>>>>>        On_Key kSwitch     Send Switch_Next_Area
98240>>>>>    End_Procedure
98241>>>>>
98241>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
98242>>>>>
98242>>>>>    Procedure Set psImage String sImage
98244>>>>>        Set Bitmap to ""
98245>>>>>        Forward Set psImage to sImage
98247>>>>>    End_Procedure
98248>>>>>
98248>>>>>    Function psImage Returns String
98250>>>>>        Function_Return (psImage(Self))
98251>>>>>    End_Function
98252>>>>>
98252>>>>>    Procedure Set Label String sLabel
98254>>>>>        Forward Set psLabel to sLabel
98256>>>>>    End_Procedure
98257>>>>>
98257>>>>>    Procedure Set psToolTip String sToolTip
98259>>>>>        Set private.psToolTip to sToolTip
98260>>>>>    End_Procedure
98261>>>>>
98261>>>>>    Function psToolTip Returns String
98263>>>>>        Function_Return (private.psToolTip(Self))
98264>>>>>    End_Function
98265>>>>>
98265>>>>>    Procedure End_Construct_Object
98267>>>>>        String sNote sLabel
98267>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
98267>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
98267>>>>>
98267>>>>>        Forward Send End_Construct_Object
98269>>>>>
98269>>>>>        Get piLabelColOffset to iLabelColOffset
98270>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
98271>>>>>        If (bUseLargeFontHeight = True) Begin
98273>>>>>            Get piLabelLargeFontHeight to iFontHeight
98274>>>>>            Move 8 to iLabelRowOffset
98275>>>>>        End
98275>>>>>>
98275>>>>>        Else Begin
98276>>>>>            Get piLabelSmallFontHeight to iFontHeight
98277>>>>>            Move 6 to iLabelRowOffset
98278>>>>>        End
98278>>>>>>
98278>>>>>
98278>>>>>        Get pbLargeImageSize to bLargeImageSize
98279>>>>>        If (bLargeImageSize = True) Begin
98281>>>>>            Get private.piLargeImageSize to iImageSize
98282>>>>>        End
98282>>>>>>
98282>>>>>        Else Begin
98283>>>>>            Get private.piSmallImageSize to iImageSize
98284>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
98285>>>>>        End
98285>>>>>>
98285>>>>>
98285>>>>>        Object oHeaderGroupImage is a cRDCDbHeaderGroupImage
98287>>>>>            Set piImageSize to iImageSize
98288>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
98289>>>>>            Set psImage to (private.psImage(Self))
98290>>>>>            Set peImageAlign to Button_ImageList_Align_Center
98291>>>>>            Set psToolTip to (private.psToolTip(Self))
98292>>>>>        End_Object
98293>>>>>
98293>>>>>        Object oHeaderGroupInfo_tb is a TextBox
98295>>>>>            Set Size to 12 100
98296>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
98297>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
98298>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
98299>>>>>            Set FontPointHeight to iFontHeight
98300>>>>>            Set Label to (private.psLabel(Self))
98301>>>>>            Set TextColor to (piLabelColor(Self))
98302>>>>>            Set psToolTip to (private.psToolTip(Self))
98303>>>>>            Get Size to iSize
98304>>>>>        End_Object
98305>>>>>
98305>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
98305>>>>>        // How can it be improved?
98305>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
98306>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
98308>>>>>            Get private.psLabel to sLabel
98309>>>>>            Get Text_Extent sLabel to iTextOffset
98310>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
98311>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
98313>>>>>                Set Size to 10 10
98314>>>>>                If (bUseLargeFontHeight = True) Begin
98316>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
98316>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
98317>>>>>                End
98317>>>>>>
98317>>>>>                Else Begin
98318>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
98318>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
98319>>>>>                End
98319>>>>>>
98319>>>>>                Set psToolTip to (private.psToolTip(Self))
98320>>>>>                Set Bitmap to "ActionAbout.bmp"
98321>>>>>            End_Object
98322>>>>>        End
98322>>>>>>
98322>>>>>
98322>>>>>        Get psNote to sNote
98323>>>>>        If (Trim(sNote) <> "") Begin
98325>>>>>            Object oHeaderGroupNote_tb is a TextBox
98327>>>>>                Set Size to 12 100
98328>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
98329>>>>>                Set Label to ("-" * String(sNote))
98330>>>>>                Set TextColor to (piLabelColor(Self))
98331>>>>>                Set FontPointHeight to 9
98332>>>>>                Set psToolTip to (private.psToolTip(Self))
98333>>>>>            End_Object
98334>>>>>        End
98334>>>>>>
98334>>>>>
98334>>>>>    End_Procedure
98335>>>>>
98335>>>>>    Function Popup_State Returns Boolean
98337>>>>>        Boolean bIsPopup
98337>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
98338>>>>>        Function_Return bIsPopup
98339>>>>>    End_Function
98340>>>>>
98340>>>>>    Procedure OnEnterArea Handle hoFrom
98342>>>>>        Integer iColor
98342>>>>>        Forward Send OnEnterArea hoFrom
98344>>>>>        // Not ideal, but works most of the time.
98344>>>>>        //       When navigating to i.e a popup we don't want
98344>>>>>        //       the coloring to appear. Else there will be 2
98344>>>>>        //       cRDCHeaderGroup's with the highlight color...
98344>>>>>        // Is there a better way?
98344>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
98346>>>>>            Procedure_Return
98347>>>>>        End
98347>>>>>>
98347>>>>>        If (pbUseHotspotColor(Self) = True) Begin
98349>>>>>            Get Color to iColor
98350>>>>>            Set private.piColorOrg to iColor
98351>>>>>            Get piHeaderHotspotColor to iColor
98352>>>>>            Set Color to iColor
98353>>>>>            Broadcast Recursive Set Color to iColor
98355>>>>>        End
98355>>>>>>
98355>>>>>    End_Procedure
98356>>>>>
98356>>>>>    Procedure OnExitArea Handle hoFrom
98358>>>>>        Integer iColor
98358>>>>>        Forward Send OnExitArea hoFrom
98360>>>>>        If (pbUseHotspotColor(Self) = True) Begin
98362>>>>>            Get private.piColorOrg to iColor
98363>>>>>            Set Color to iColor
98364>>>>>            Broadcast Recursive Set Color to iColor
98366>>>>>        End
98366>>>>>>
98366>>>>>    End_Procedure
98367>>>>>
98367>>>>>    // Public access message to change the group header text color at runtime.
98367>>>>>    Procedure Set Label_Color Integer iColor
98369>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
98370>>>>>    End_Procedure
98371>>>>>
98371>>>>>    Procedure NavigatePrevious
98373>>>>>        Integer iMulti ivoid iLastErr
98373>>>>>        Handle hWnd
98373>>>>>        Boolean bErr
98373>>>>>
98373>>>>>        Move Err to bErr
98374>>>>>        Move LastErr to iLastErr
98375>>>>>
98375>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98376>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
98377>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98378>>>>>        If (Err) Begin
98380>>>>>            Move bErr to Err
98381>>>>>            Move iLastErr to LastErr
98382>>>>>            Procedure_Return
98383>>>>>        End
98383>>>>>>
98383>>>>>
98383>>>>>        Move bErr to Err
98384>>>>>        Move iLastErr to LastErr
98385>>>>>        If (iMulti = Multi_Select) Begin
98387>>>>>            Send Previous
98388>>>>>        End
98388>>>>>>
98388>>>>>        Else Begin
98389>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
98390>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
98391>>>>>        End
98391>>>>>>
98391>>>>>    End_Procedure
98392>>>>>
98392>>>>>    Procedure NavigateNext
98394>>>>>        Integer iMulti iVoid iLastErr
98394>>>>>        Handle hWnd
98394>>>>>        Boolean bErr
98394>>>>>
98394>>>>>        Move Err to bErr
98395>>>>>        Move LastErr to iLastErr
98396>>>>>
98396>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98397>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
98398>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98399>>>>>        If (Err) Begin
98401>>>>>            Move bErr to Err
98402>>>>>            Move iLastErr to LastErr
98403>>>>>            Procedure_Return
98404>>>>>        End
98404>>>>>>
98404>>>>>
98404>>>>>        Move bErr to Err
98405>>>>>        Move iLastErr to LastErr
98406>>>>>        If (iMulti = Multi_Select) Begin
98408>>>>>            Send Next
98409>>>>>        End
98409>>>>>>
98409>>>>>        Else Begin
98410>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
98411>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
98412>>>>>        End
98412>>>>>>
98412>>>>>
98412>>>>>    End_Procedure
98413>>>>>
98413>>>>>    Procedure Enable_Window Integer iState
98415>>>>>        Handle hWnd
98415>>>>>        Get Window_Handle to hWnd
98416>>>>>        If hWnd Begin
98418>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
98419>>>>>        End
98419>>>>>>
98419>>>>>    End_Procedure
98420>>>>>
98420>>>>>    Procedure Page_Object Integer iState
98422>>>>>        Handle hWnd
98422>>>>>        Get Window_Handle to hWnd
98423>>>>>        Forward Send Page_Object iState
98425>>>>>        If (hWnd = 0 and iState) Begin
98427>>>>>            Send Shadow_Display
98428>>>>>        End
98428>>>>>>
98428>>>>>    End_Procedure
98429>>>>>
98429>>>>>    Procedure Shadow_Display
98431>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
98432>>>>>    End_Procedure
98433>>>>>
98433>>>>>    Function Explicit_Shadow_State Returns Boolean
98435>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
98436>>>>>    End_Function
98437>>>>>
98437>>>>>    // For some reason we need to augment this event to allow
98437>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
98437>>>>>    // happen.
98437>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
98439>>>>>        Delegate Send OnFileDropped sFilename bLast
98441>>>>>    End_Procedure
98442>>>>>
98442>>>>>End_Class
98443>>>>>
98443>>>>>// We don't want the broadcast of setting color to set the background
98443>>>>>// color for forms that are within a cRDCHeaderGroup object.
98443>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
98443>>>>>// behave as it always has. But if you don't like this; just comment
98443>>>>>// it out.
98443>>>>>//Procedure Set Color for Form Integer eColor
98443>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
98443>>>>>//    Integer iLastErr
98443>>>>>//
98443>>>>>//    Move Err to bErr
98443>>>>>//    Move LastErr to iLastErr
98443>>>>>//
98443>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
98443>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
98443>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
98443>>>>>//    Move bErr to Err
98443>>>>>//    Move iLastErr to LastErr
98443>>>>>//    If (bIsHeaderGroup = False) Begin
98443>>>>>//        Forward Set Color to eColor
98443>>>>>//    End
98443>>>>>//End_Procedure
98443>>>Use cRDCDbForm.pkg
98443>>>Use cRDCDbComboForm.pkg
Including file: cRDCDbComboForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbComboForm.pkg)
98443>>>>>//****************************************************************************
98443>>>>>// $Module type: Package
98443>>>>>// $Module name: cRDCDbComboform.pkg
98443>>>>>//
98443>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
98443>>>>>// Copyright (c) 2014 RDC Tools International
98443>>>>>// E-mail      : support@rdctools.com
98443>>>>>// Web-site    : http://www.rdctools.com
98443>>>>>//
98443>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
98443>>>>>//
98443>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
98443>>>>>//               The auto-size combo width logic was developed by Raveen.
98443>>>>>//
98443>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
98443>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
98443>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
98443>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
98443>>>>>// in the help folder for more details.
98443>>>>>//
98443>>>>>//****************************************************************************
98443>>>>>Use Dfcentry.pkg
98443>>>>>
98443>>>>>// Used by the "Page" message below to show
98443>>>>>// a focus rectangle around ComboForm and Checkbox objects.
98443>>>>>
98443>>>>>Class cDbComboFormIdleHandler is a cIdleHandler
98444>>>>>    Procedure Construct_Object
98446>>>>>        Forward Send Construct_Object
98448>>>>>
98448>>>>>        Set Label_Row_Offset to 0
98449>>>>>        Set Label_Col_Offset to 2
98450>>>>>        Set Label_Justification_Mode to jMode_Right
98451>>>>>        Set Combo_Sort_State to False
98452>>>>>        Set Entry_State to False
98453>>>>>
98453>>>>>    End_Procedure
98454>>>>>
98454>>>>>    Procedure OnIdle
98456>>>>>        Delegate Send DoUpdate
98458>>>>>    End_Procedure
98459>>>>>
98459>>>>>End_Class
98460>>>>>
98460>>>>>Class cRDCDbComboForm is a dbComboForm
98461>>>>>    Procedure Construct_Object
98463>>>>>        Forward Send Construct_Object
98465>>>>>
98465>>>>>        Property Boolean pbAutoListWidth True
98466>>>>>
98466>>>>>        Property Boolean pbAutoShadowLabelObject True
98467>>>>>
98467>>>>>        Property Boolean pbAutoEnable False
98468>>>>>        Set Label_Col_Offset to 2
98469>>>>>        Property Boolean pbEnabled True
98470>>>>>        Set Label_Justification_Mode to JMode_Right
98471>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cDbComboFormIdleHandler)))
98472>>>>>
98472>>>>>        On_Key Key_Ctrl+Key_S Send Request_Save
98473>>>>>        On_Key kCancel Send None
98474>>>>>        On_Key Key_F3  Send None 
98475>>>>>        On_Key Key_Ctrl+Key_F4 Send None
98476>>>>>    End_Procedure
98477>>>>>
98477>>>>>    Procedure End_Construct_Object
98479>>>>>        Boolean bAutoShadowLabelObject
98479>>>>>        String sTooltip sStatus_Help
98479>>>>>
98479>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
98480>>>>>        If (bAutoShadowLabelObject = True) Begin
98482>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
98483>>>>>        End
98483>>>>>>
98483>>>>>
98483>>>>>        Forward Send End_Construct_Object
98485>>>>>
98485>>>>>        Get psToolTip   to sTooltip
98486>>>>>        Get Status_Help to sStatus_Help
98487>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
98489>>>>>            Set psToolTip to sStatus_Help
98490>>>>>        End
98490>>>>>>
98490>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
98493>>>>>            Set Status_Help to sTooltip
98494>>>>>        End
98494>>>>>>
98494>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
98495>>>>>
98495>>>>>    End_Procedure
98496>>>>>
98496>>>>>    Procedure DoUpdate
98498>>>>>        If (pbAutoEnable(Self) = False) Begin
98500>>>>>            Procedure_Return
98501>>>>>        End
98501>>>>>>
98501>>>>>        Set Enabled_State to (IsEnabled(Self))
98502>>>>>    End_Procedure
98503>>>>>
98503>>>>>    Function IsEnabled Returns Boolean
98505>>>>>        Boolean bEnabled
98505>>>>>        Get pbEnabled to bEnabled
98506>>>>>        Function_Return bEnabled
98507>>>>>    End_Function
98508>>>>>
98508>>>>>    // Enable the idle handler timer when the object is activated
98508>>>>>    Procedure Activating
98510>>>>>        Forward Send Activating
98512>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
98513>>>>>    End_Procedure
98514>>>>>
98514>>>>>    // Disable the idle handler when the object is deactivated
98514>>>>>    Procedure Deactivating
98516>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
98517>>>>>        Forward Send Deactivating
98519>>>>>    End_Procedure
98520>>>>>
98520>>>>>    // To "un-select" the text in the comboform on startup
98520>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
98522>>>>>        Integer iStart iEnd
98522>>>>>
98522>>>>>        If (Focus(Desktop)=Self) Begin
98524>>>>>            Get SelStart to iStart
98525>>>>>            Get SelEnd   to iEnd
98526>>>>>        End
98526>>>>>>
98526>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
98528>>>>>        Send SetSel iStart iEnd
98529>>>>>    End_Procedure
98530>>>>>
98530>>>>>    // Message that will drop down the list without the user clicking it,
98530>>>>>    // so you can send "DropDownList" to the combo to show the list.
98530>>>>>    Procedure DropDownList
98532>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
98533>>>>>    End_Procedure
98534>>>>>
98534>>>>>    Procedure SizeComboWidth
98536>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
98536>>>>>        String sVal
98536>>>>>
98536>>>>>        // Initialise Width
98536>>>>>        Set ListWidth to 0
98537>>>>>        Send DoSetListWidth
98538>>>>>
98538>>>>>        Get ListRowCount     to iRows
98539>>>>>        Get Combo_Item_Count to iCount
98540>>>>>
98540>>>>>        // Vertical scroll-bar adjustment is needed
98540>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
98541>>>>>        If (iVertAdj) Begin
98543>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
98544>>>>>        End
98544>>>>>>
98544>>>>>        Else Begin
98545>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
98546>>>>>        End
98546>>>>>>
98546>>>>>
98546>>>>>        // Calculate New Width
98546>>>>>        Decrement iCount
98547>>>>>        For iItem from 0 to iCount
98553>>>>>>
98553>>>>>            Get Combo_Value iItem to sVal
98554>>>>>            If (sVal <> "") Begin
98556>>>>>                Get Text_Extent sVal to iTextExt
98557>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
98558>>>>>                If (iWd > iNewWd) Begin
98560>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
98561>>>>>                End
98561>>>>>>
98561>>>>>            End
98561>>>>>>
98561>>>>>        Loop
98562>>>>>>
98562>>>>>
98562>>>>>        // Set New Width
98562>>>>>        Set ListWidth to iNewWd
98563>>>>>        Send DoSetListWidth
98564>>>>>    End_Procedure
98565>>>>>
98565>>>>>    Procedure Combo_Add_Item String sValue
98567>>>>>        Forward Send Combo_Add_Item sValue
98569>>>>>        If (pbAutoListWidth(Self)) Begin
98571>>>>>            Send SizeComboWidth
98572>>>>>        End
98572>>>>>>
98572>>>>>    End_Procedure
98573>>>>>
98573>>>>>    Procedure Combo_Fill_List
98575>>>>>        Forward Send Combo_Fill_List
98577>>>>>        If (pbAutoListWidth(Self)) Begin
98579>>>>>            Send SizeComboWidth
98580>>>>>        End
98580>>>>>>
98580>>>>>    End_Procedure
98581>>>>>
98581>>>>>    // Fix for a bug when using manifest files & running Vista and above.
98581>>>>>    // The bug being that the focus rectangle doesn't show.
98581>>>>>    Procedure Page Integer iPageObject
98583>>>>>        Handle hWnd
98583>>>>>        Integer iRet iState
98583>>>>>
98583>>>>>        Forward Send Page iPageObject
98585>>>>>
98585>>>>>        If (iPageObject) Begin
98587>>>>>            Get Window_Handle to hWnd
98588>>>>>            If (hWnd) Begin
98590>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
98591>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
98593>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
98594>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
98595>>>>>                End
98595>>>>>>
98595>>>>>            End
98595>>>>>>
98595>>>>>        End
98595>>>>>>
98595>>>>>
98595>>>>>        // To "un-select" the text in the comboform
98595>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
98597>>>>>            Send SetSel 0 0
98598>>>>>        End
98598>>>>>>
98598>>>>>    End_Procedure
98599>>>>>
98599>>>>>End_Class
98600>>>
98600>>>Use cFunctionsDataDictionary.dd
98600>>>Use dfEnRad.pkg
98600>>>
98600>>>ACTIVATE_VIEW Activate_oFunctionMaintenance_vw FOR oFunctionMaintenance_vw
98610>>>>
98610>>>Object oFunctionMaintenance_vw is a cRefactorDbView
98612>>>    Set Location to 5 5
98613>>>    Set Size to 197 602
98614>>>    Set piMaxSize to 197 602
98615>>>    Set Label to "Function Maintenance"
98616>>>    Set Auto_Clear_DEO_State to False
98617>>>
98617>>>    Procedure Log_Status String sMsg
98620>>>    End_Procedure
98621>>>                
98621>>>    Object oFunctions_DD is a cFunctionsDataDictionary
98623>>>        Procedure Update
98626>>>//            Integer iState iType              
98626>>>//            Boolean bChangeWriteProtected
98626>>>//            
98626>>>//            Move Functions.Selected to iState
98626>>>//            Move Functions.bWriteProtected to bChangeWriteProtected
98626>>>//            If (bChangeWriteProtected = True) Begin
98626>>>//                Send UserError "This is a write protected system function which cannot be changed, as it is handled a bit differently."
98626>>>//                Procedure_Return
98626>>>//            End
98626>>>            Forward Send Update
98628>>>        End_Procedure
98629>>>    End_Object 
98630>>>
98630>>>    Set Main_DD To oFunctions_DD
98631>>>    Set Server  To oFunctions_DD
98632>>>
98632>>>    Object oScrollingContainer is a cDbScrollingContainer
98634>>>        
98634>>>        Object oScrollingClientArea is a cDbScrollingClientArea
98636>>>
98636>>>            Object oStandardFunctions_grp is a cRDCDbHeaderGroup
98638>>>                Set Size to 192 599
98639>>>                Set piMinSize to 134 248
98640>>>                Set Location to 4 3
98641>>>                Set Label to "Functions Maintenance"             
98642>>>                Set psImage to "FunctionLibrary.ico"
98643>>>                Set psNote to "Edit functions properties."
98644>>>                Set psToolTip to "To add a function, the name entered must be EXACTLY the same as the function name itself. Then the code must be added to the cRefactorDbView class (cRefactorDbView.pkg). See class code for standard function parameters."
98645>>>                Set Border_Style to Border_Normal
98646>>>                Set peAnchors to anAll
98647>>>            
98647>>>                Object oFunctionsFunction_Name is a cRDCDbForm
98649>>>                    Entry_Item Functions.Function_Name
98650>>>                    Set Size to 12 474
98651>>>                    Set Location to 58 112
98652>>>                    Set Label to "Function Name"
98653>>>                    Set Label_Justification_mode to jMode_right
98654>>>                    Set Label_Col_Offset to 2
98655>>>                    Set Label_Row_Offset to 0
98656>>>                End_Object 
98657>>>            
98657>>>                Object oFunctionsFunction_Description is a cRDCDbForm
98659>>>                    Entry_Item Functions.Function_Description
98660>>>                    Set Size to 12 474
98661>>>                    Set Location to 72 112
98662>>>                    Set Label to "Function Description"
98663>>>                    Set Label_Justification_mode to jMode_right
98664>>>                    Set Label_Col_Offset to 2
98665>>>                    Set Label_Row_Offset to 0
98666>>>                End_Object 
98667>>>            
98667>>>                Object oFunctionsFunction_Help is a cRDCDbForm
98669>>>                    Entry_Item Functions.Function_Help
98670>>>                    Set Size to 12 474
98671>>>                    Set Location to 86 112
98672>>>                    Set Label to "Function Help"
98673>>>                    Set Label_Justification_mode to jMode_right
98674>>>                    Set Label_Col_Offset to 2
98675>>>                    Set Label_Row_Offset to 0
98676>>>                End_Object 
98677>>>            
98677>>>                Object oFunctionsFunction_Summary is a cRDCDbForm
98679>>>                    Entry_Item Functions.Function_Summary
98680>>>                    Set Size to 12 474
98681>>>                    Set Location to 100 112
98682>>>                    Set Label to "Function Summary"
98683>>>                    Set Label_Justification_mode to jMode_right
98684>>>                    Set Label_Col_Offset to 2
98685>>>                    Set Label_Row_Offset to 0
98686>>>                End_Object 
98687>>>                                        // Can't use cRDCDbComboForm. It has a bug that makes the value not to change when finding records(!).
98687>>>                Object oFunctionsType is a DbComboForm 
98689>>>                    Entry_Item Functions.Type
98690>>>                    Set Size to 12 133
98691>>>                    Set Location to 116 112
98692>>>                    Set Label to "Type"                
98693>>>                    Set Label_Justification_Mode to JMode_Right
98694>>>                    Set Label_Col_Offset to 2
98695>>>                    Set Label_Row_Offset to 0
98696>>>                    Set Entry_State to False
98697>>>                    Set Combo_Sort_State to False   
98698>>>                    Set psToolTip to ("Determines how data is passed to the function." + CS_CRLF + ;                                      "Standard - Line-by-line" + CS_CRLF + ;                                      "Remove - Line-by-line" + CS_CRLF + ;                                      "Editor One - A source file as a string array." + CS_CRLF + ;                                      "Other One - A source file as a string array." + CS_CRLF + ;                                      "Other All - All source files as a string array with full path." + CS_CRLF + ;                                      "Report One - A source file as a string array." + CS_CRLF + ;                                      "Report All - All source files as a string array with full path.")
98699>>>                End_Object 
98700>>>
98700>>>//                Object oFunctions_bWriteProtected is a dbCheckbox
98700>>>//                    Entry_Item Functions.bWriteProtected
98700>>>//                    Set Location to 157 79
98700>>>//                    Set Size to 10 60
98700>>>//                    Set Label to "Write Protected (This is a system type function and cannot be changed)"
98700>>>//                    Set Enabled_State to False
98700>>>//                End_Object
98700>>>
98700>>>                Object oFunctionsID is a cRDCDbForm
98702>>>                    Entry_Item Functions.ID
98703>>>                    Set Size to 12 42
98704>>>                    Set Location to 44 112
98705>>>                    Set Label to "ID"
98706>>>                    Set Label_Justification_mode to jMode_right
98707>>>                    Set Label_Col_Offset to 2
98708>>>                    Set Label_row_Offset to 0
98709>>>                End_Object 
98710>>>
98710>>>                Object oFunctions_bHasParameter is a dbCheckBox
98712>>>                    Entry_Item Functions.bHasParameter
98713>>>                    Set Location to 131 112
98714>>>                    Set Size to 10 60
98715>>>                    Set Label to "bHasParameter" 
98716>>>                    Set psToolTip to "If an extra parameter in addition to the source line/file needs to be passed to the function you can enter details about it by selecting this checkbox." 
98717>>>                    
98717>>>                    Procedure OnChange
98720>>>                        Boolean bChecked
98720>>>                        Get Checked_State to bChecked
98721>>>                        Set Enabled_State of oFunctions_Parameter           to bChecked
98722>>>                        Set Enabled_State of oFunctions_ParameterValidation to bChecked
98723>>>                        Set Enabled_State of oFunctions_ParameterHelp       to bChecked
98724>>>                    End_Procedure
98725>>>
98725>>>                End_Object
98726>>>
98726>>>                Object oFunctions_Parameter is a dbForm
98728>>>                    Entry_Item Functions.Parameter
98729>>>                    Set Location to 143 112
98730>>>                    Set Size to 12 132
98731>>>                    Set Label to "Optional Parameter"
98732>>>                    Set Label_Col_Offset to 2
98733>>>                    Set Label_Justification_Mode to JMode_Right
98734>>>                    Set psToolTip to "Optional parameter to be passed to the function, in addition to the source code line/file(s). Enter the default value here, that later can be changed by the user in the DFRefactor program's Function Selection grid."
98735>>>                End_Object
98736>>>
98736>>>                Object oFunctions_ParameterValidation is a dbForm
98738>>>                    Entry_Item Functions.ParameterValidation
98739>>>                    Set Location to 157 111
98740>>>                    Set Size to 12 474
98741>>>                    Set Label to "Validation"
98742>>>                    Set Label_Col_Offset to 2
98743>>>                    Set Label_Justification_Mode to JMode_Right
98744>>>                    Set psToolTip to "Comma separated list of valid parameter values. When a parameter gets changed by the user in the DFRefactor function selection grid, it will be validated against this list."
98745>>>                End_Object
98746>>>
98746>>>                Object oFunctions_ParameterHelp is a dbForm
98748>>>                    Entry_Item Functions.ParameterHelp
98749>>>                    Set Location to 171 112
98750>>>                    Set Size to 12 474
98751>>>                    Set Label to "Parameter Help"
98752>>>                    Set Label_Col_Offset to 2
98753>>>                    Set Label_Justification_Mode to JMode_Right
98754>>>                    Set psToolTip to "Instructions for entering optional parameter values in the DFRefactor program's function selection grid. You may add '\n' to separate help text with a new line (CR+LF)."
98755>>>                End_Object
98756>>>
98756>>>                Object oCheckAllFunctions_btn is a Button
98758>>>                    Set Size to 14 101
98759>>>                    Set Location to 140 484
98760>>>                    Set Label to "Check all functions"  
98761>>>                    Set psToolTip to "Makes a call to all functions that has been added to the database. If e.g. a spelling error of the function name has been made, an error message will be shown."
98762>>>                    Set peAnchors to anTopRight
98763>>>                
98763>>>                    Procedure OnClick
98766>>>                        Integer iFunctionID iRetval
98766>>>                        String sFunctionName sLine sPath sSourceFile sParameter
98766>>>                        Boolean bChanged
98766>>>                        String[] asSource asSourceFiles
98768>>>
98768>>>                        Move False to Err
98769>>>                        Move "    [Found] Reread // End comment" to sLine
98770>>>                        Move sLine to asSource[0]                   
98771>>>                        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath
98772>>>                        Get vFolderFormat sPath to sPath
98773>>>                        Move CS_LegacyCode to sSourceFile
98774>>>                        Move (sPath + String(sSourceFile)) to asSourceFiles[0]
98775>>>                        Constraint_Set (Self) Clear  
98777>>>                        Constrained_Clear eq FunctionsA by Index.1
98780>>>                        Constrained_Find First FunctionsA by Index.1
98785>>>                        While (Found)
98789>>>                            Move (Trim(FunctionsA.Parameter)) to sParameter
98790>>>                            Move (Trim(FunctionsA.Function_Name)) to sFunctionName
98791>>>                            If (Lowercase(sFunctionName) <> Lowercase(CS_EditorDropSelf)) Begin
98793>>>                                Move (Eval("get_" - (sFunctionName))) to iFunctionID   
98794>>>                                If (FunctionsA.Type = eAll_Functions or FunctionsA.Type = eRemove_Function) Begin
98796>>>                                    Get iFunctionID of ghoRefactorFunctionLibrary (&sLine) sParameter to bChanged
98797>>>                                End 
98797>>>>
98797>>>                                If (FunctionsA.Type = eEditor_Function or FunctionsA.Type = eReport_Function or FunctionsA.Type = eOther_Function) Begin                                    
98799>>>                                    Get iFunctionID of ghoRefactorFunctionLibrary (&asSource) sParameter to bChanged
98800>>>                                End
98800>>>>
98800>>>                                If (FunctionsA.Type = eOther_FunctionAll or FunctionsA.Type = eReport_FunctionAll) Begin                                    
98802>>>                                    Get iFunctionID of ghoRefactorFunctionLibrary (&asSourceFiles) sParameter to bChanged
98803>>>                                End
98803>>>>
98803>>>
98803>>>                                Showln FunctionsA.ID "  " sFunctionName " sLine = " sLine " bChanged = " bChanged
98811>>>                                If (Err = True) Begin
98813>>>                                    Get YesNo_Box "An error occured. Do you want to quite?" to iRetval
98814>>>                                    If (iRetval = MBR_Yes) Begin
98816>>>                                        Procedure_Return
98817>>>                                    End
98817>>>>
98817>>>                                    Else Begin
98818>>>                                        Move False to Err
98819>>>                                    End
98819>>>>
98819>>>                                End
98819>>>>
98819>>>                            End
98819>>>>
98819>>>                            Constrained_Find Next  
98820>>>                        Loop
98821>>>>
98821>>>                        Send Info_Box "Done! All functions were run. Check the Output Window (DataFlex Console Window)"
98822>>>                    End_Procedure
98823>>>                
98823>>>                End_Object
98824>>>            
98824>>>            End_Object
98825>>>            
98825>>>        End_Object
98826>>>    
98826>>>    End_Object        
98827>>>    
98827>>>    Procedure Activating            
98830>>>        Send Clear of oFunctions_DD
98831>>>        Send Find of oFunctions_DD GT 1   
98832>>>    End_Procedure
98833>>>                                                                   
98833>>>//    Procedure OnSetFocus
98833>>>//        Set pbVisible of (oFindToolBar(ghoCommandBars)) to True
98833>>>//        Send ComRecalcLayout of ghoCommandBars
98833>>>//    End_Procedure
98833>>>//                                                                   
98833>>>//    Procedure Exiting_Scope Handle hoNewScope
98833>>>//        Forward Send Exiting_Scope hoNewScope
98833>>>//        Set pbVisible of (oFindToolBar(ghoCommandBars)) to False
98833>>>//        Send ComRecalcLayout of ghoCommandBars
98833>>>//    End_Procedure
98833>>>
98833>>>    On_Key Key_Escape Send None
98834>>>    On_Key Key_Ctrl+Key_S Send Request_Save
98835>>>    On_Key Key_Ctrl+Key_F4 Send None
98836>>>End_Object 
98837>>>
98837>>>Procedure ActivateFunctionsView Integer iFunctionID
98840>>>    Handle ho hoDD  
98840>>>    Boolean bDone
98840>>>    
98840>>>    Move (oFunctionMaintenance_vw(Self)) to ho
98841>>>    Get Main_DD of ho to hoDD
98842>>>    Clear Functions
98843>>>    Move iFunctionID to Functions.ID
98844>>>    Find eq Functions by Index.1
98845>>>>
98845>>>    If (Found = True) Begin
98847>>>        Send Request_Assign of hoDD
98848>>>        Send Activate_oFunctionMaintenance_vw 
98849>>>        Send Activate of (oFunctionsID(ho))
98850>>>    End
98850>>>>
98850>>>End_Procedure
98851>        Use SelectFunctions.vw
Including file: SelectFunctions.vw    (C:\Projects\DF18\DfRefactor\AppSrc\SelectFunctions.vw)
98851>>>Use DFClient
98851>>>Use cCJGridColumnRowIndicator.pkg
98851>>>Use cRDCDbCJGrid.pkg
Including file: cRDCDbCJGrid.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGrid.pkg)
98851>>>>>Use cDbCJGrid.pkg
98851>>>>>Use cRDCDbCJGridColumnHyperLink.pkg
Including file: cRDCDbCJGridColumnHyperLink.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGridColumnHyperLink.pkg)
98851>>>>>>>// Written by Peter Bragg.
98851>>>>>>>// Subclass for using hyperlinks in cDbCJGrid/cCJGrid column objects.
98851>>>>>>>//
98851>>>>>>>// Set pbHyperLink to True and it will call the Function "IsHyperLink" passing the Row Index.
98851>>>>>>>// To be honest you don't really need this property at all - the function on its own would do.
98851>>>>>>>//
98851>>>>>>>// Anyway, code this function accordingly to return True or False If the row value for that column
98851>>>>>>>// should be displayed as a hyperlink or not. (Within this Function you can call "Get RowValue"
98851>>>>>>>// to Get the value for that column)
98851>>>>>>>//
98851>>>>>>>// All you then need to do is Add the following to your Grid Class:
98851>>>>>>>//
98851>>>>>>>//    Procedure OnComHyperlinkClick Variant llRow Variant llItem Integer llHyperlinkIndex
98851>>>>>>>//        Handle  hoRow hoItem hoColumn
98851>>>>>>>//        String  sLink
98851>>>>>>>//        Integer iRow iColumn
98851>>>>>>>//
98851>>>>>>>//        Get phoReportRow to hoRow
98851>>>>>>>//        Get phoReportRecordItem to hoItem
98851>>>>>>>//
98851>>>>>>>//        Set pvComObject of hoItem to llItem
98851>>>>>>>//        Get ComIndex    of hoItem to iColumn
98851>>>>>>>//        Set pvComObject of hoRow to llRow
98851>>>>>>>//        Get ComIndex    of hoRow to iRow
98851>>>>>>>//        Get ColumnObject iColumn to hoColumn
98851>>>>>>>//        Get RowValue of hoColumn iRow to sLink
98851>>>>>>>//
98851>>>>>>>//        Send OnLinkClicked of hoColumn sLink iRow
98851>>>>>>>//    End_Procedure
98851>>>>>>>
98851>>>>>>>Use cDbCJGridColumn.pkg
98851>>>>>>>
98851>>>>>>>Class cDbCJGridColumnHyperLink is a cDbCJGridColumn
98852>>>>>>>
98852>>>>>>>    Procedure Construct_Object
98854>>>>>>>        Forward Send Construct_Object
98856>>>>>>>
98856>>>>>>>        Property Boolean pbHyperlink    False
98857>>>>>>>    End_Procedure
98858>>>>>>>
98858>>>>>>>    Function IsHyperlink Integer iRow Returns Boolean
98860>>>>>>>        Function_Return False
98861>>>>>>>    End_Function
98862>>>>>>>
98862>>>>>>>    Procedure OnLinkClicked String sLink Integer iRow
98864>>>>>>>    End_Procedure
98865>>>>>>>
98865>>>>>>>    Procedure DrawCell Handle hoRow Handle hoItem Handle hoMetrics Integer iRow String sValue
98867>>>>>>>        Boolean bIsHyperlink
98867>>>>>>>        Variant vHyperLinks vHyperLink
98867>>>>>>>        Handle  hoHyperLinks
98867>>>>>>>        Integer iLinks
98867>>>>>>>
98867>>>>>>>        Get pbHyperlink to bIsHyperlink
98868>>>>>>>        If (bIsHyperlink) Begin
98870>>>>>>>            Get IsHyperlink iRow to bIsHyperlink
98871>>>>>>>        End
98871>>>>>>>>
98871>>>>>>>
98871>>>>>>>        Get ComHyperlinks of hoItem to vHyperLinks
98872>>>>>>>        Get Create (RefClass(cCJReportHyperlinks)) to hoHyperLinks
98873>>>>>>>        Set pvComObject of hoHyperLinks to vHyperLinks
98874>>>>>>>        Get ComCount of hoHyperLinks to iLinks
98875>>>>>>>        If (bIsHyperlink) Begin
98877>>>>>>>            If (iLinks=0) Begin
98879>>>>>>>                Get ComAddHyperlink of hoHyperLinks 0 (Length(sValue)) to vHyperLink
98880>>>>>>>            End
98880>>>>>>>>
98880>>>>>>>        End
98880>>>>>>>>
98880>>>>>>>        Else If (iLinks>0) Begin
98883>>>>>>>            Send ComRemoveAll of hoHyperLinks
98884>>>>>>>        End
98884>>>>>>>>
98884>>>>>>>        Send Destroy of hoHyperLinks
98885>>>>>>>
98885>>>>>>>        Forward Send DrawCell hoRow hoItem hoMetrics iRow sValue
98887>>>>>>>    End_Procedure
98888>>>>>>>
98888>>>>>>>    Procedure OnCreateColumn
98890>>>>>>>        Variant vHyperLinkStyle
98890>>>>>>>        Handle  hoPaintManager hoHyperLinkStyle
98890>>>>>>>
98890>>>>>>>        Forward Send OnCreateColumn
98892>>>>>>>        Get phoReportPaintManager to hoPaintManager
98893>>>>>>>        Get ComHyperlinkStyle of hoPaintManager to vHyperLinkStyle
98894>>>>>>>        Get Create (RefClass(cCJReportHyperlinkStyle)) to hoHyperLinkStyle
98895>>>>>>>        Set pvComObject of hoHyperLinkStyle to vHyperLinkStyle
98896>>>>>>>        Set ComTextDecoration of hoHyperLinkStyle to xtpReportTextDecorationUnderline
98897>>>>>>>        Send Destroy of hoHyperLinkStyle
98898>>>>>>>    End_Procedure
98899>>>>>>>
98899>>>>>>>End_Class
98900>>>>>Use RefactorFunctionConstants.inc
98900>>>>>
98900>>>>>Enum_List
98900>>>>>    Define cx_DbSelect_All
98900>>>>>    Define cx_DbSelect_None
98900>>>>>    Define cx_DbSelect_Invert
98900>>>>>End_Enum_List
98900>>>>>
98900>>>>>
98900>>>>>// Classes used by the cRDCCJSelectionGrid
98900>>>>>Class cRDCDbCJToggleSelectMenuItem is a cCJMenuItem
98901>>>>>
98901>>>>>    Procedure Construct_Object
98903>>>>>        Forward Send Construct_Object
98905>>>>>        Set psCaption to "Toggle Current Item"
98906>>>>>        Set psImage to "ToggleOn.ico"
98907>>>>>        Set psShortcut to "Space-Bar"
98908>>>>>    End_Procedure
98909>>>>>
98909>>>>>    Procedure OnExecute Variant vCommandBarControl
98911>>>>>        Forward Send OnExecute vCommandBarControl
98913>>>>>        Send ToggleCurrentItem
98914>>>>>    End_Procedure
98915>>>>>
98915>>>>>End_Class
98916>>>>>
98916>>>>>Class cRDCDbCJSelectAllMenuItem is a cCJMenuItem
98917>>>>>
98917>>>>>    Procedure Construct_Object
98919>>>>>        Forward Send Construct_Object
98921>>>>>        Set pbControlBeginGroup to True
98922>>>>>        Set psCaption to "Select All"
98923>>>>>        Set psImage to "SelectAll.ico"
98924>>>>>        Set psShortcut to "Ctrl+A"
98925>>>>>    End_Procedure
98926>>>>>
98926>>>>>    Procedure OnExecute Variant vCommandBarControl
98928>>>>>        Forward Send OnExecute vCommandBarControl
98930>>>>>        Send SelectAll of (Server(Self))
98931>>>>>        Send RefreshSelectionUpdate
98932>>>>>    End_Procedure
98933>>>>>
98933>>>>>End_Class
98934>>>>>
98934>>>>>Class cRDCDbCJDeSelectAllMenuItem is a cCJMenuItem
98935>>>>>
98935>>>>>    Procedure Construct_Object
98937>>>>>        Forward Send Construct_Object
98939>>>>>        Set psCaption to "Select None"
98940>>>>>        Set psImage to "SelectNone.ico"
98941>>>>>        Set psShortcut to "Ctrl+N"
98942>>>>>    End_Procedure
98943>>>>>
98943>>>>>    Procedure OnExecute Variant vCommandBarControl
98945>>>>>        Forward Send OnExecute vCommandBarControl
98947>>>>>        Send DeSelectAll of (Server(Self)) 
98948>>>>>        Send RefreshSelectionUpdate
98949>>>>>    End_Procedure
98950>>>>>
98950>>>>>End_Class
98951>>>>>
98951>>>>>Class cRDCDbCJInvertSelectionsMenuItem is a cCJMenuItem
98952>>>>>
98952>>>>>    Procedure Construct_Object
98954>>>>>        Forward Send Construct_Object
98956>>>>>        Set psCaption to "Invert Selection"
98957>>>>>        Set psImage to "SelectInvert.ico"
98958>>>>>        Set psShortcut to "Ctrl+I"
98959>>>>>    End_Procedure
98960>>>>>
98960>>>>>    Procedure OnExecute Variant vCommandBarControl
98962>>>>>        Forward Send OnExecute vCommandBarControl
98964>>>>>//        Set SelectItems to cx_Select_Invert
98964>>>>>    End_Procedure
98965>>>>>
98965>>>>>End_Class
98966>>>>>
98966>>>>>Class cRDCDbCJAddFolderMenuItem is a cCJMenuItem
98967>>>>>
98967>>>>>    Procedure Construct_Object
98969>>>>>        Forward Send Construct_Object
98971>>>>>        Set psCaption to "Add Folder"
98972>>>>>        Set psImage to "AddFolder.ico"
98973>>>>>        Set psShortcut to "Ins"
98974>>>>>    End_Procedure
98975>>>>>
98975>>>>>    Procedure OnExecute Variant vCommandBarControl
98977>>>>>        Forward Send OnExecute vCommandBarControl
98979>>>>>        Send BrowseForFolder
98980>>>>>    End_Procedure
98981>>>>>
98981>>>>>End_Class
98982>>>>>
98982>>>>>Class cRDCDbCJRemoveItemMenuItem is a cCJMenuItem
98983>>>>>
98983>>>>>    Procedure Construct_Object
98985>>>>>        Forward Send Construct_Object
98987>>>>>        Set psCaption to "Remove From Grid"
98988>>>>>        Set psImage to "ActionDelete.ico"
98989>>>>>        Set psShortcut to "Del"
98990>>>>>    End_Procedure
98991>>>>>
98991>>>>>    Procedure OnExecute Variant vCommandBarControl
98993>>>>>        Forward Send OnExecute vCommandBarControl
98995>>>>>        Send Request_Delete
98996>>>>>    End_Procedure
98997>>>>>
98997>>>>>End_Class
98998>>>>>
98998>>>>>Register_Function pbDbShowAddFolderMenuItem Returns Boolean
98998>>>>>Register_Function pbDbShowRemoveFolderMenuItem Returns Boolean
98998>>>>>Register_Function pbDbShowInvertSelectionsMenuItem Returns Boolean
98998>>>>>
98998>>>>>Class cDbGridContext_mnu is a cCJContextMenu
98999>>>>>    Procedure Construct_Object
99001>>>>>        Handle hoMenuItem
99001>>>>>        Forward Send Construct_Object
99003>>>>>
99003>>>>>        Get Create (RefClass(cRDCDbCJToggleSelectMenuItem))      to hoMenuItem
99004>>>>>        Get Create (RefClass(cRDCDbCJSelectAllMenuItem))         to hoMenuItem
99005>>>>>        Get Create (RefClass(cRDCDbCJDeSelectAllMenuItem))       to hoMenuItem
99006>>>>>        If (pbDbShowInvertSelectionsMenuItem(Self) = True) Begin
99008>>>>>            Get Create (RefClass(cRDCDbCJInvertSelectionsMenuItem))  to hoMenuItem
99009>>>>>        End
99009>>>>>>
99009>>>>>        If (pbDbShowAddFolderMenuItem(Self) = True) Begin
99011>>>>>            Get Create (RefClass(cRDCDbCJAddFolderMenuItem))  to hoMenuItem
99012>>>>>            Set pbControlBeginGroup of hoMenuItem to True
99013>>>>>        End
99013>>>>>>
99013>>>>>        If (pbDbShowRemoveFolderMenuItem(Self) = True) Begin
99015>>>>>            Get Create (RefClass(cRDCDbCJRemoveItemMenuItem))  to hoMenuItem
99016>>>>>            If (pbDbShowAddFolderMenuItem(Self) = False) Begin
99018>>>>>                Set pbControlBeginGroup of hoMenuItem to True
99019>>>>>            End
99019>>>>>>
99019>>>>>        End
99019>>>>>>
99019>>>>>    End_Procedure
99020>>>>>
99020>>>>>End_Class
99021>>>>>
99021>>>>>Class cRDCDbCJGrid is a cDbCJGrid
99022>>>>>
99022>>>>>    Procedure Construct_Object
99024>>>>>        Forward Send Construct_Object
99026>>>>>
99026>>>>>        // Set to true if an descending index is in use
99026>>>>>        Property Boolean pbDescendingIndexInUse False
99027>>>>>
99027>>>>>        // If you quickly double-right-click, or quickly click around a cCJGrid
99027>>>>>        // (using a combination of middle-clicks, right-clicks and left-clicks), the application can crash.
99027>>>>>        // To guard against this see the augmented procedure OnComRowRClick below.
99027>>>>>        Property Boolean pbRightClickProcessing False   
99028>>>>>        Property Handle phoCheckbox_Col
99029>>>>>        Property Handle phoData_Col
99030>>>>>        Property Boolean pbDbShowAddFolderMenuItem False
99031>>>>>        Property Boolean pbDbShowRemoveFolderMenuItem False
99032>>>>>        Property Boolean pbDbShowInvertSelectionsMenuItem False
99033>>>>>        
99033>>>>>        Set pbRestoreLayout to True
99034>>>>>        Set psLayoutSection to ((Object_Label(Parent(Self))) + "-" + (Object_Label(Self)))
99035>>>>>        Set pbUseAlternateRowBackgroundColor to True     
99036>>>>>        Set pbUseFocusCellRectangle to False
99037>>>>>        Set pbShowRowFocus to True
99038>>>>>        Set pbHotTracking to True
99039>>>>>        Set pbSelectionEnable to True
99040>>>>>        Set piSelectedRowBackColor to clGreenGreyLight
99041>>>>>        Set piHighlightBackColor   to clGreenGreyLight
99042>>>>>        Set pbShowFooter to True  
99043>>>>>        Set peAnchors to anAll
99044>>>>>        Set peVisualTheme to xtpReportThemeExplorer
99045>>>>>
99045>>>>>        On_Key Key_End   Send MoveToLastEnterableColumn
99046>>>>>        On_Key Key_Home  Send MoveToFirstEnterableColumn
99047>>>>>        On_Key Key_Space Send ToggleCurrentItem
99048>>>>>    End_Procedure
99049>>>>>
99049>>>>>    Procedure End_Construct_Object    
99051>>>>>        Handle hoContextMenu
99051>>>>>        Forward Send End_Construct_Object
99053>>>>>        Get Create (RefClass(cDbGridContext_mnu)) to hoContextMenu
99054>>>>>        Set phoContextMenu to hoContextMenu
99055>>>>>    End_Procedure
99056>>>>>
99056>>>>>    // Set checkbox column to selected states.
99056>>>>>    // iState can be one of the following:
99056>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
99056>>>>>    Procedure Set SelectItems Integer iState
99058>>>>>        Integer iCount iSize iCheckbox_Col
99058>>>>>        Boolean bChecked
99058>>>>>        Handle hoDataSource hoCheckBox_Col hoDD
99058>>>>>        tDataSourceRow[] TheData
99058>>>>>        tDataSourceRow[] TheData
99059>>>>>        
99059>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
99060>>>>>        If (hoCheckBox_Col = 0) Begin
99062>>>>>            Procedure_Return
99063>>>>>        End                 
99063>>>>>>
99063>>>>>        
99063>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
99064>>>>>        Get phoDataSource               to hoDataSource
99065>>>>>        Get DataSource of hoDataSource  to TheData
99066>>>>>        Move (SizeOfArray(TheData))     to iSize
99067>>>>>        Decrement iSize
99068>>>>>        For iCount from 0 to iSize
99074>>>>>>
99074>>>>>            Case Begin
99074>>>>>                Case (iState = cx_DbSelect_All)
99076>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
99077>>>>>                    Case Break
99078>>>>>                Case (iState = cx_DbSelect_None)
99081>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
99082>>>>>                    Case Break
99083>>>>>                Case (iState = cx_DbSelect_Invert)
99086>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
99087>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
99088>>>>>                    Case Break
99089>>>>>            Case End
99089>>>>>        Loop
99090>>>>>>
99090>>>>>
99090>>>>>        Send ReInitializeData TheData False
99091>>>>>        Send Request_Save
99092>>>>>        Get Main_DD to hoDD
99093>>>>>        If (hoDD <> 0) Begin    
99095>>>>>            If (iState = cx_DbSelect_All) Begin
99097>>>>>                Send SelectAll of hoDD
99098>>>>>            End 
99098>>>>>>
99098>>>>>            If (iState = cx_DbSelect_None) Begin
99100>>>>>                Send DeSelectAll of hoDD
99101>>>>>            End 
99101>>>>>>
99101>>>>>            Send Request_Assign of hoDD
99102>>>>>            Send Refind_Records of hoDD
99103>>>>>        End
99103>>>>>>
99103>>>>>        Send DoSetCheckboxFooterText
99104>>>>>    End_Procedure
99105>>>>>
99105>>>>>    Procedure RefreshSelectionUpdate 
99107>>>>>        Handle hoDataSource
99107>>>>>        Integer iSelectedRow
99107>>>>>        Get phoDataSource to hoDataSource 
99108>>>>>        Get SelectedRow of hoDataSource to iSelectedRow
99109>>>>>        Send RefreshDataFromDD iSelectedRow
99110>>>>>    End_Procedure
99111>>>>>
99111>>>>>Register_Object oCheckbox_Col
99111>>>>>
99111>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
99111>>>>>    Function SelectedItems Returns String[]
99113>>>>>        Integer i iItems iSize iCheckbox_Col iData_Col
99113>>>>>        String[] sDataArray
99114>>>>>        Handle hoDataSource hoData_Col hoCheckBox_Col
99114>>>>>        tDataSourceRow[] TheData
99114>>>>>        tDataSourceRow[] TheData
99115>>>>>        Boolean bChecked
99115>>>>>
99115>>>>>        Get phoData_Col to hoData_Col
99116>>>>>        If (hoData_Col = 0) Begin
99118>>>>>            Move 1 to iData_Col
99119>>>>>        End                    
99119>>>>>>
99119>>>>>        Else Begin
99120>>>>>            Get piColumnId of hoData_Col to iData_Col
99121>>>>>        End                                          
99121>>>>>>
99121>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
99122>>>>>        If (hoCheckBox_Col = 0) Begin
99124>>>>>            Function_Return sDataArray
99125>>>>>        End                           
99125>>>>>>
99125>>>>>        Else Begin
99126>>>>>            Get piColumnId of oCheckbox_Col to iCheckbox_Col
99127>>>>>        End
99127>>>>>>
99127>>>>>
99127>>>>>        Get phoDataSource to hoDataSource
99128>>>>>        Get DataSource of hoDataSource to TheData
99129>>>>>        Move (SizeOfArray(TheData)) to iItems
99130>>>>>        Decrement iItems
99131>>>>>
99131>>>>>        For i from 0 to iItems
99137>>>>>>
99137>>>>>            Move TheData[i].sValue[iCheckbox_Col] to bChecked
99138>>>>>            If (bChecked = True) Begin
99140>>>>>                Move (SizeOfArray(sDataArray)) to iSize
99141>>>>>                Move TheData[i].sValue[iData_Col] to sDataArray[iSize]
99142>>>>>            End
99142>>>>>>
99142>>>>>        Loop
99143>>>>>>
99143>>>>>
99143>>>>>        Function_Return sDataArray
99144>>>>>    End_Function
99145>>>>>
99145>>>>>    Procedure SelectAll
99147>>>>>        Set SelectItems to cx_DbSelect_All
99148>>>>>    End_Procedure
99149>>>>>
99149>>>>>    Procedure SelectNone
99151>>>>>        Set SelectItems to cx_DbSelect_None
99152>>>>>    End_Procedure
99153>>>>>
99153>>>>>    Procedure SelectInvert
99155>>>>>        Set SelectItems to cx_DbSelect_Invert
99156>>>>>    End_Procedure
99157>>>>>
99157>>>>>    Procedure AddItem String sDataValue
99159>>>>>        Handle hoDataSource
99159>>>>>        tDataSourceRow[] TheData
99159>>>>>        tDataSourceRow[] TheData
99160>>>>>        tsSearchResult[] asFolderArray
99160>>>>>        tsSearchResult[] asFolderArray
99161>>>>>        Integer iSize iData_Col iCheckbox_Col
99161>>>>>
99161>>>>>        If (not(IsComObjectCreated(Self))) Begin
99163>>>>>            Procedure_Return
99164>>>>>        End
99164>>>>>>
99164>>>>>
99164>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
99165>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
99166>>>>>        Get phoDataSource to hoDataSource
99167>>>>>        Get DataSource of hoDataSource to TheData
99168>>>>>        Move (SizeOfArray(TheData)) to iSize
99169>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
99170>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
99171>>>>>
99171>>>>>        Send ReInitializeData TheData False
99172>>>>>        Send MoveToFirstRow
99173>>>>>    End_Procedure
99174>>>>>
99174>>>>>    Procedure BrowseForFolder
99176>>>>>        String sFolderName
99176>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
99177>>>>>        If (sFolderName <> "") Begin
99179>>>>>            Send AddItem sFolderName
99180>>>>>        End
99180>>>>>>
99180>>>>>    End_Procedure
99181>>>>>
99181>>>>>    // Returns number of items.
99181>>>>>    Function ItemCount Returns Integer
99183>>>>>        Integer iItems
99183>>>>>        Handle hoDataSource
99183>>>>>        tDataSourceRow[] TheData
99183>>>>>        tDataSourceRow[] TheData
99184>>>>>
99184>>>>>        Get phoDataSource to hoDataSource
99185>>>>>        Get DataSource of hoDataSource to TheData
99186>>>>>        Move (SizeOfArray(TheData)) to iItems
99187>>>>>
99187>>>>>        Function_Return iItems
99188>>>>>    End_Function
99189>>>>>
99189>>>>>    // Returns number of checked items.
99189>>>>>    Function CheckedItems Returns Integer
99191>>>>>        Integer iCount iItems iCheckbox_Col iRetval
99191>>>>>        Handle hoDataSource hoCheckbox_Col
99191>>>>>        tDataSourceRow[] TheData
99191>>>>>        tDataSourceRow[] TheData
99192>>>>>        Boolean bChecked
99192>>>>>        
99192>>>>>        Move 0 to iRetval
99193>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
99194>>>>>        If (hoCheckbox_Col = 0) Begin
99196>>>>>            Procedure_Return
99197>>>>>        End
99197>>>>>>
99197>>>>>        Get piColumnId of hoCheckbox_Col to iCheckbox_Col
99198>>>>>        Get phoDataSource to hoDataSource
99199>>>>>        Get DataSource of hoDataSource to TheData
99200>>>>>        Move (SizeOfArray(TheData)) to iItems
99201>>>>>        Decrement iItems
99202>>>>>
99202>>>>>        For iCount from 0 to iItems
99208>>>>>>
99208>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
99209>>>>>            If (bChecked = True) Begin
99211>>>>>                Increment iRetval
99212>>>>>            End
99212>>>>>>
99212>>>>>        Loop
99213>>>>>>
99213>>>>>
99213>>>>>        Function_Return iRetval
99214>>>>>    End_Function
99215>>>>>
99215>>>>>    // Toggles the current row on/off (the checkbox)
99215>>>>>    Procedure ToggleCurrentItem
99217>>>>>        Boolean bChecked
99217>>>>>        Integer iCol
99217>>>>>        Handle hoCol hoCheckbox_Col hoDD
99217>>>>>
99217>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
99218>>>>>        If (hoCheckbox_Col = 0) Begin
99220>>>>>            Procedure_Return
99221>>>>>        End
99221>>>>>>
99221>>>>>        Get piColumnId of hoCheckbox_Col to iCol
99222>>>>>        Get ColumnObject iCol   to hoCol
99223>>>>>        Get SelectedRowValue    of hoCol to bChecked
99224>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
99225>>>>>        Get Server to hoDD
99226>>>>>        If (hoDD <> 0) Begin
99228>>>>>            Send Request_Save of hoDD
99229>>>>>        End
99229>>>>>>
99229>>>>>        Send DoSetCheckboxFooterText
99230>>>>>    End_Procedure
99231>>>>>
99231>>>>>    Procedure DoSetCheckboxFooterText
99233>>>>>        Integer iCol iSelected iItems
99233>>>>>        Handle hoCol hoCheckbox_Col hoData_Col
99233>>>>>        
99233>>>>>        Get phoData_Col to hoData_Col
99234>>>>>        If (hoData_Col = 0) Begin
99236>>>>>            Move 0 to iCol
99237>>>>>        End
99237>>>>>>
99237>>>>>        Else Begin
99238>>>>>            Get piColumnId of hoData_Col to iCol
99239>>>>>        End
99239>>>>>>
99239>>>>>        Get ItemCount to iItems
99240>>>>>        Get CheckedItems to iSelected
99241>>>>>        Get ColumnObject iCol to hoCol
99242>>>>>        If (hoCol <> 0) Begin
99244>>>>>            Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))            
99245>>>>>        End
99245>>>>>>
99245>>>>>    End_Procedure
99246>>>>>
99246>>>>>    Procedure OnCreateGridControl
99248>>>>>        Forward Send OnCreateGridControl
99250>>>>>        Send DoChangeTooltipStyle
99251>>>>>    End_Procedure    
99252>>>>>    
99252>>>>>    Procedure Activating
99254>>>>>        Send DoChangeFontSize      
99255>>>>>    End_Procedure    
99256>>>>>
99256>>>>>    Procedure DoChangeFontSize
99258>>>>>        Handle hoFont hoPaintManager
99258>>>>>        Variant vFont
99258>>>>>        String sFont sFontSize
99258>>>>>        Boolean bCreated
99258>>>>>        Integer iVal
99258>>>>>
99258>>>>>        Get IsComObjectCreated to bCreated  // When program is started, grid object isn't created yet.
99259>>>>>        If (bCreated = False) Begin
99261>>>>>            Procedure_Return
99262>>>>>        End
99262>>>>>>
99262>>>>>
99262>>>>>        Get phoReportPaintManager to hoPaintManager
99263>>>>>        Get Create (RefClass(cComStdFont)) to hoFont  // Create a font object
99264>>>>>        Get ComTextFont of hoPaintManager to vFont    // Bind the font object to the Grid's text font
99265>>>>>        Set pvComObject of hoFont to vFont            // Connect DataFlex object with com object
99266>>>>>
99266>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iVal
99267>>>>>        Set ComSize of hoFont to iVal
99268>>>>>        Send ComRedraw
99269>>>>>        Send Destroy to hoFont                        // Destroy the font object (releases memory)
99270>>>>>    End_Procedure
99271>>>>>
99271>>>>>    Procedure DoChangeTooltipStyle
99273>>>>>        Handle  hoTooltip
99273>>>>>        Integer iIcon iStyle iWidth
99273>>>>>        Boolean bBaloon
99273>>>>>
99273>>>>>        Get phoToolTipContext to hoTooltip
99274>>>>>
99274>>>>>        // This is the programs global tooltip control defined at desktop level.
99274>>>>>        If (ghoToolTipController > 0) Begin
99276>>>>>            Get piIcon of ghoToolTipController    to iIcon
99277>>>>>            // The global tooltip controller allows the icons to be
99277>>>>>            // from 0-5, but the tooltip context class only allows
99277>>>>>            // the tooltip icon to be between 0-3.
99277>>>>>            If (iIcon > 3) Begin
99279>>>>>                Move xtpToolTipIconInfo to iIcon
99280>>>>>            End
99280>>>>>>
99280>>>>>            Get piMaxWidth of ghoToolTipController to iWidth
99281>>>>>            Get pbBalloonStyle of ghoToolTipController to bBaloon
99282>>>>>            If (bBaloon = True) Begin
99284>>>>>                Move xtpToolTipBalloon to iStyle
99285>>>>>            End
99285>>>>>>
99285>>>>>            Else Begin
99286>>>>>                Move xtpToolTipOffice2007 to iStyle
99287>>>>>            End
99287>>>>>>
99287>>>>>        End
99287>>>>>>
99287>>>>>        Else Begin
99288>>>>>            Move xtpToolTipIconInfo   to iIcon
99289>>>>>            Move xtpToolTipOffice2007 to iStyle
99290>>>>>            Move 400                  to iWidth
99291>>>>>        End
99291>>>>>>
99291>>>>>
99291>>>>>        Set ComStyle of hoTooltip to iStyle
99292>>>>>        Set ComMaxTipWidth of hoTooltip to iWidth
99293>>>>>    End_Procedure    
99294>>>>>    
99294>>>>>    Procedure OnComGetToolTipInfo Variant lltoolTipInfo
99296>>>>>        Forward Send OnComGetToolTipInfo lltoolTipInfo
99298>>>>>    End_Procedure
99299>>>>>
99299>>>>>    // When changing to new row, update the form 'No of Rows'
99299>>>>>    Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
99301>>>>>        Forward Send OnRowChanged iOldRow iNewSelectedRow
99303>>>>>        Send DoSetCurrentRow
99304>>>>>    End_Procedure
99305>>>>>
99305>>>>>    // When loading data, update the footer 'No of Items' text
99305>>>>>    Procedure Refresh Integer eMode
99307>>>>>        Forward Send Refresh eMode
99309>>>>>        Send DoSetCurrentRow
99310>>>>>    End_Procedure
99311>>>>>
99311>>>>>    Procedure DoSetCurrentRow
99313>>>>>        Send DoSetCheckboxFooterText
99314>>>>>    End_Procedure
99315>>>>>
99315>>>>>    Function Checkbox_item_State Integer iItem Returns Integer
99317>>>>>        Forward Get Checkbox_Item_State to iItem
99319>>>>>        Send DoSetCheckboxFooterText
99320>>>>>        Function_Return iItem
99321>>>>>    End_Function
99322>>>>>    
99322>>>>>    Procedure OnComHyperlinkClick Variant llRow Variant llItem Integer llHyperlinkIndex
99324>>>>>        Handle  hoRow hoItem hoColumn
99324>>>>>        String  sLink
99324>>>>>        Integer iRow iColumn
99324>>>>>
99324>>>>>        Get phoReportRow to hoRow
99325>>>>>        Get phoReportRecordItem to hoItem
99326>>>>>
99326>>>>>        Set pvComObject of hoItem to llItem
99327>>>>>        Get ComIndex    of hoItem to iColumn
99328>>>>>        Set pvComObject of hoRow to llRow
99329>>>>>        Get ComIndex    of hoRow to iRow
99330>>>>>        Get ColumnObject iColumn to hoColumn
99331>>>>>        Get RowValue of hoColumn iRow to sLink
99332>>>>>
99332>>>>>        Send OnLinkClicked of hoColumn sLink iRow
99333>>>>>    End_Procedure
99334>>>>>
99334>>>>>    // Redisplay the grid records around the current record.
99334>>>>>    // If the  record no longer exists or no longer conforms to the current constraints
99334>>>>>    // this will redisplay the records with the same iOffset.
99334>>>>>    // If both finds fail the grid will not be updated so we need to clear it.
99334>>>>>    Procedure RefreshGrid
99336>>>>>        Send Find to (Server(Self)) GE (Ordering(Self))   // to refresh grid
99337>>>>>        If (not(Found)) Begin
99339>>>>>            If (pbDescendingIndexInUse(Self) = True or pbReverseOrdering(Self) = True) Begin
99341>>>>>                Send Find to (Server(Self)) FIRST_RECORD (Ordering(Self))
99342>>>>>            End
99342>>>>>>
99342>>>>>            Else If (pbDescendingIndexInUse(Self) = False or pbReverseOrdering(Self) = False) Begin
99345>>>>>                Send Find to (Server(Self)) LAST_RECORD (Ordering(Self))
99346>>>>>            End
99346>>>>>>
99346>>>>>        End
99346>>>>>>
99346>>>>>        If (not(Found) and IsComObjectCreated(Self)) Begin
99348>>>>>            Send ResetGrid
99349>>>>>        End
99349>>>>>>
99349>>>>>    End_Procedure
99350>>>>>
99350>>>>>    Procedure Request_Delete
99352>>>>>        Forward Send Request_Delete
99354>>>>>
99354>>>>>        // Needed to ensure list of remaining records displayed correctly
99354>>>>>        Send RefreshGrid
99355>>>>>    End_Procedure
99356>>>>>
99356>>>>>    // If you quickly double-right-click, or quickly click around a cCJGrid
99356>>>>>    // (using a combination of middle-clicks, right-clicks and left-clicks), the application can crash.
99356>>>>>    // This fixes that little problem.
99356>>>>>    Procedure OnComRowRClick Variant llRow Variant llItem
99358>>>>>        Boolean bProcessing
99358>>>>>        Get pbRightClickProcessing to bProcessing
99359>>>>>        If (not(bProcessing)) Begin
99361>>>>>            Set pbRightClickProcessing to True
99362>>>>>            Forward Send OnComRowRClick llRow llItem
99364>>>>>            Set pbRightClickProcessing to False
99365>>>>>        End
99365>>>>>>
99365>>>>>    End_Procedure
99366>>>>>
99366>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
99368>>>>>        Integer iSize jSize kSize iSup iInf iDef
99368>>>>>        Handle hoPaintManager hoFont
99368>>>>>        Variant vFont
99368>>>>>        
99368>>>>>        Move 3 to iInf      //max size
99369>>>>>        Move 18 to iSup     //min size
99370>>>>>        Move 8 to iDef      //default
99371>>>>>        Boolean blimite
99371>>>>>        Get phoReportPaintManager to hoPaintManager
99372>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
99374>>>>>            Procedure_Return
99375>>>>>        End
99375>>>>>>
99375>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
99376>>>>>        Get ComTextFont of hoPaintManager to vFont
99377>>>>>        Set pvComObject of hoFont to vFont
99378>>>>>        If (iDirection = 0) Begin
99380>>>>>            Set ComSize of hoFont to iDef
99381>>>>>        End
99381>>>>>>
99381>>>>>        Else Begin
99382>>>>>           Get ComSize of hoFont to iSize
99383>>>>>           Move iSize to jSize
99384>>>>>           Repeat
99384>>>>>>
99384>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
99385>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
99386>>>>>                If (not(blimite)) Begin       
99388>>>>>                   Set ComSize of hoFont to jSize
99389>>>>>                   Get ComSize of hoFont to kSize
99390>>>>>                End
99390>>>>>>
99390>>>>>            Until (iSize <> kSize or blimite)
99392>>>>>        End
99392>>>>>>
99392>>>>>        Send Destroy to hoFont 
99393>>>>>        Send ComRedraw  
99394>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
99395>>>>>    End_Procedure 
99396>>>>>
99396>>>>>End_Class
99397>>>Use cRDCDbCJGridColumn.pkg
Including file: cRDCDbCJGridColumn.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCDbCJGridColumn.pkg)
99397>>>>>Use cDbCJGridColumn.pkg
99397>>>>>
99397>>>>>Class cRDCDbCJGridColumn is a cDbCJGridColumn
99398>>>>>
99398>>>>>    Procedure Construct_Object
99400>>>>>        Forward Send Construct_Object
99402>>>>>        Set psToolTip to "Right-click grid for context sensitive menu options"
99403>>>>>
99403>>>>>    End_Procedure
99404>>>>>
99404>>>>>    Procedure End_Construct_Object
99406>>>>>        Forward Send End_Construct_Object
99408>>>>>
99408>>>>>    End_Procedure
99409>>>>>
99409>>>>>//    Function OnGetTooltip Integer iRow String sValue String sText Returns String
99409>>>>>//        String sRetVal
99409>>>>>//        Forward Get OnGetTooltip iRow sValue sText to sRetVal
99409>>>>>//        Function_Return sRetVal
99409>>>>>//    End_Function
99409>>>>>
99409>>>>>End_Class
99410>>>Use cRDCDbForm.pkg
99410>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF18\DfRefactor\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
99410>>>>>//****************************************************************************
99410>>>>>// $Module type: Package
99410>>>>>// $Module name: cRDCComboform.pkg
99410>>>>>//
99410>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
99410>>>>>// Copyright (c) 2014 RDC Tools International
99410>>>>>// E-mail      : support@rdctools.com
99410>>>>>// Web-site    : http://www.rdctools.com
99410>>>>>//
99410>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
99410>>>>>//
99410>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
99410>>>>>//               The auto-size combo width logic was developed by Raveen.
99410>>>>>//
99410>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
99410>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
99410>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
99410>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
99410>>>>>// in the help folder for more details.
99410>>>>>//
99410>>>>>//****************************************************************************
99410>>>>>Use Windows.pkg
99410>>>>>
99410>>>>>// Used by the "Page" message below to show
99410>>>>>// a focus rectangle around ComboForm and Checkbox objects.
99410>>>>>
99410>>>>>Class cComboFormIdleHandler is a cIdleHandler
99411>>>>>    Procedure Construct_Object
99413>>>>>        Forward Send Construct_Object
99415>>>>>
99415>>>>>        Set Label_Row_Offset to 0
99416>>>>>        Set Label_Col_Offset to 2
99417>>>>>        Set Label_Justification_Mode to jMode_Right
99418>>>>>        Set Combo_Sort_State to False
99419>>>>>        Set Entry_State to False
99420>>>>>
99420>>>>>    End_Procedure
99421>>>>>
99421>>>>>    Procedure OnIdle
99423>>>>>        Delegate Send DoUpdate
99425>>>>>    End_Procedure
99426>>>>>
99426>>>>>End_Class
99427>>>>>
99427>>>>>Class cRDCComboForm is a ComboForm
99428>>>>>    Procedure Construct_Object
99430>>>>>        Forward Send Construct_Object
99432>>>>>
99432>>>>>        Property Boolean pbAutoListWidth True
99433>>>>>
99433>>>>>        Property Boolean pbAutoShadowLabelObject True
99434>>>>>
99434>>>>>        Property Boolean pbAutoEnable False
99435>>>>>        Set Label_Col_Offset to 2
99436>>>>>        Property Boolean pbEnabled True
99437>>>>>        Set Label_Justification_Mode to JMode_Right
99438>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
99439>>>>>
99439>>>>>    End_Procedure
99440>>>>>
99440>>>>>    Procedure End_Construct_Object
99442>>>>>        Boolean bAutoShadowLabelObject
99442>>>>>        String sTooltip sStatus_Help
99442>>>>>
99442>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
99443>>>>>        If (bAutoShadowLabelObject = True) Begin
99445>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
99446>>>>>        End
99446>>>>>>
99446>>>>>
99446>>>>>        Forward Send End_Construct_Object
99448>>>>>
99448>>>>>        Get psToolTip   to sTooltip
99449>>>>>        Get Status_Help to sStatus_Help
99450>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
99452>>>>>            Set psToolTip to sStatus_Help
99453>>>>>        End
99453>>>>>>
99453>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
99456>>>>>            Set Status_Help to sTooltip
99457>>>>>        End
99457>>>>>>
99457>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
99458>>>>>
99458>>>>>    End_Procedure
99459>>>>>
99459>>>>>    Procedure DoUpdate
99461>>>>>        If (pbAutoEnable(Self) = False) Begin
99463>>>>>            Procedure_Return
99464>>>>>        End
99464>>>>>>
99464>>>>>        Set Enabled_State to (IsEnabled(Self))
99465>>>>>    End_Procedure
99466>>>>>
99466>>>>>    Function IsEnabled Returns Boolean
99468>>>>>        Boolean bEnabled
99468>>>>>        Get pbEnabled to bEnabled
99469>>>>>        Function_Return bEnabled
99470>>>>>    End_Function
99471>>>>>
99471>>>>>    // Enable the idle handler timer when the object is activated
99471>>>>>    Procedure Activating
99473>>>>>        Forward Send Activating
99475>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
99476>>>>>    End_Procedure
99477>>>>>
99477>>>>>    // Disable the idle handler when the object is deactivated
99477>>>>>    Procedure Deactivating
99479>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
99480>>>>>        Forward Send Deactivating
99482>>>>>    End_Procedure
99483>>>>>
99483>>>>>    // To "un-select" the text in the comboform on startup
99483>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
99485>>>>>        Integer iStart iEnd
99485>>>>>
99485>>>>>        If (Focus(Desktop)=Self) Begin
99487>>>>>            Get SelStart to iStart
99488>>>>>            Get SelEnd   to iEnd
99489>>>>>        End
99489>>>>>>
99489>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
99491>>>>>        Send SetSel iStart iEnd
99492>>>>>    End_Procedure
99493>>>>>
99493>>>>>    // Message that will drop down the list without the user clicking it,
99493>>>>>    // so you can send "DropDownList" to the combo to show the list.
99493>>>>>    Procedure DropDownList
99495>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
99496>>>>>    End_Procedure
99497>>>>>
99497>>>>>    Procedure SizeComboWidth
99499>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
99499>>>>>        String sVal
99499>>>>>
99499>>>>>        // Initialise Width
99499>>>>>        Set ListWidth to 0
99500>>>>>        Send DoSetListWidth
99501>>>>>
99501>>>>>        Get ListRowCount     to iRows
99502>>>>>        Get Combo_Item_Count to iCount
99503>>>>>
99503>>>>>        // Vertical scroll-bar adjustment is needed
99503>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
99504>>>>>        If (iVertAdj) Begin
99506>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
99507>>>>>        End
99507>>>>>>
99507>>>>>        Else Begin
99508>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
99509>>>>>        End
99509>>>>>>
99509>>>>>
99509>>>>>        // Calculate New Width
99509>>>>>        Decrement iCount
99510>>>>>        For iItem from 0 to iCount
99516>>>>>>
99516>>>>>            Get Combo_Value iItem to sVal
99517>>>>>            If (sVal <> "") Begin
99519>>>>>                Get Text_Extent sVal to iTextExt
99520>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
99521>>>>>                If (iWd > iNewWd) Begin
99523>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
99524>>>>>                End
99524>>>>>>
99524>>>>>            End
99524>>>>>>
99524>>>>>        Loop
99525>>>>>>
99525>>>>>
99525>>>>>        // Set New Width
99525>>>>>        Set ListWidth to iNewWd
99526>>>>>        Send DoSetListWidth
99527>>>>>    End_Procedure
99528>>>>>
99528>>>>>    Procedure Combo_Add_Item String sValue
99530>>>>>        Forward Send Combo_Add_Item sValue
99532>>>>>        If (pbAutoListWidth(Self)) Begin
99534>>>>>            Send SizeComboWidth
99535>>>>>        End
99535>>>>>>
99535>>>>>    End_Procedure
99536>>>>>
99536>>>>>    Procedure Combo_Fill_List
99538>>>>>        Forward Send Combo_Fill_List
99540>>>>>        If (pbAutoListWidth(Self)) Begin
99542>>>>>            Send SizeComboWidth
99543>>>>>        End
99543>>>>>>
99543>>>>>    End_Procedure
99544>>>>>
99544>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99544>>>>>    // The bug being that the focus rectangle doesn't show.
99544>>>>>    Procedure Page Integer iPageObject
99546>>>>>        Handle hWnd
99546>>>>>        Integer iRet iState
99546>>>>>
99546>>>>>        Forward Send Page iPageObject
99548>>>>>
99548>>>>>        If (iPageObject) Begin
99550>>>>>            Get Window_Handle to hWnd
99551>>>>>            If (hWnd) Begin
99553>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99554>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99556>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99557>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99558>>>>>                End
99558>>>>>>
99558>>>>>            End
99558>>>>>>
99558>>>>>        End
99558>>>>>>
99558>>>>>
99558>>>>>        // To "un-select" the text in the comboform
99558>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
99560>>>>>            Send SetSel 0 0
99561>>>>>        End
99561>>>>>>
99561>>>>>    End_Procedure
99562>>>>>
99562>>>>>End_Class
99563>>>
99563>>>Use cSysFileDataDictionary.dd
99563>>>Use cFunctionsDataDictionary.dd
99563>>>Use cdbCJGridColumn.pkg
99563>>>Use Windows.pkg
99563>>>
99563>>>ACTIVATE_VIEW Activate_oMaintainFunctions FOR oMaintainFunctions
99573>>>>
99573>>>Object oMaintainFunctions is a dbView
99575>>>    Set Location to 2 4
99576>>>    Set Size to 143 591
99577>>>    Set Label to "Functions List"
99578>>>    Set Border_Style to Border_Thick
99579>>>    Set pbAutoActivate to True
99580>>>    Set Maximize_Icon to True
99581>>>
99581>>>    Object oSysFile_DD is a cSysFileDataDictionary
99583>>>        Set No_Delete_State to True
99584>>>    End_Object
99585>>>
99585>>>    Object oFunctions_DD is a cFunctionsDataDictionary  
99587>>>        Set No_Delete_State to True
99588>>>    End_Object 
99589>>>
99589>>>    Set Main_DD To oFunctions_DD
99590>>>    Set Server  To oFunctions_DD
99591>>>
99591>>>    Object oInfo_tb is a TextBox
99593>>>        Set Size to 10 91
99594>>>        Set Location to 6 230
99595>>>        Set Label to "List of all Functions in the database. Double-Click a row to Edit, Right-Click for options"
99596>>>        Set FontWeight to fw_Bold
99597>>>    End_Object
99598>>>
99598>>>    Object oFunctionSelection_grd is a cRDCDbCJGrid
99600>>>        Set Size to 125 578
99601>>>        Set Location to 26 7
99602>>>        Set Ordering to 5
99603>>>        Set piLayoutBuild to 3
99604>>>        Set pbHeaderReorders to True
99605>>>        Set pbHeaderTogglesDirection to True
99606>>>        Set pbAllowAppendRow to False
99607>>>        Set pbAllowDeleteRow to False
99608>>>        Set pbAllowInsertRow to False
99609>>>        Set pbAutoAppend to False
99610>>>
99610>>>//        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
99610>>>//            Set piWidth to 17
99610>>>//        End_Object
99610>>>
99610>>>        Object oFunctions_ID is a cRDCDbCJGridColumn
99612>>>            Entry_Item Functions.ID
99613>>>            Set piWidth to 41
99614>>>            Set psCaption to "ID"
99615>>>            Set pbEditable to False
99616>>>            Set pbEditable to False
99617>>>        End_Object
99618>>>
99618>>>        Object oFunctions_Function_Name is a cRDCDbCJGridColumn
99620>>>            Entry_Item Functions.Function_Name
99621>>>            Set piWidth to 205
99622>>>            Set psCaption to "Function Name"    
99623>>>            Set phoData_Col to Self
99624>>>            Set pbEditable to False
99625>>>        End_Object
99626>>>
99626>>>        Object oFunctions_Function_Description is a cRDCDbCJGridColumn
99628>>>            Entry_Item Functions.Function_Description
99629>>>            Set piWidth to 204
99630>>>            Set psCaption to "Function Description"
99631>>>            Set pbMultiLine to True
99632>>>            Set pbEditable to False
99633>>>        End_Object
99634>>>
99634>>>        Object oFunctions_Function_Help is a cRDCDbCJGridColumn
99636>>>            Entry_Item Functions.Function_Help
99637>>>            Set piWidth to 310
99638>>>            Set psCaption to "Function Help"
99639>>>            Set pbMultiLine to True
99640>>>            Set pbEditable to False
99641>>>        End_Object
99642>>>
99642>>>        Object oFunctions_Type is a cRDCDbCJGridColumn
99644>>>            Entry_Item Functions.Type
99645>>>            Set piWidth to 86
99646>>>            Set psCaption to "Type"
99647>>>            Set peHeaderAlignment to xtpAlignmentCenter  
99648>>>            Set pbComboButton to True
99649>>>            Set pbEditable to False
99650>>>        End_Object                    
99651>>>
99651>>>        Object oFunctions_Parameter is a cDbCJGridColumn
99653>>>            Entry_Item Functions.Parameter
99654>>>            Set piWidth to 65
99655>>>            Set psCaption to "Option"  
99656>>>            Set psToolTip to "For some functions an extra parameter setting can be passed. You can only change existing values. Hover the mouse over a value to see valid values to be selected from."
99657>>>            Set pbEditable to False
99658>>>
99658>>>            Function OnGetTooltip Integer iRow String sValue String sText Returns String
99661>>>                Get RowValue of oFunctions_ParameterHelp iRow to sText
99662>>>                Move (Replaces("\n", sText, CS_CRLF)) to sText
99663>>>                Function_Return sText
99664>>>            End_Function
99665>>>
99665>>>        End_Object
99666>>>
99666>>>        Object oFunctions_ParameterHelp is a cDbCJGridColumn
99668>>>            Entry_Item Functions.ParameterHelp
99669>>>            Set piWidth to 200
99670>>>            Set psCaption to "Parameter Help"
99671>>>            Set pbVisible to False
99672>>>            Set pbEditable to False
99673>>>        End_Object
99674>>>
99674>>>        Object oFunctions_Selected is a cRDCDbCJGridColumn
99676>>>            Entry_Item Functions.Selected
99677>>>            Set piWidth to 42
99678>>>            Set psCaption to "Select"
99679>>>            Set pbCheckbox to True
99680>>>            Set peHeaderAlignment to xtpAlignmentCenter  
99681>>>            Set phoCheckbox_Col to Self
99682>>>        End_Object
99683>>>
99683>>>        Procedure Refresh Integer eMode
99686>>>            Forward Send Refresh eMode
99688>>>            Set Value of oSysFile_TotFunctionsSelected to SysFile.SelectedFunctionTotal
99689>>>        End_Procedure
99690>>>
99690>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
99693>>>            Integer iFunctionID
99693>>>            Forward Send OnComRowDblClick llRow llItem
99695>>>            Get Field_Current_Value of oFunctions_DD Field Functions.ID to iFunctionID
99696>>>            Delegate Send ActivateFunctionsView iFunctionID
99698>>>        End_Procedure
99699>>>
99699>>>    End_Object
99700>>>
99700>>>    // To enable Ctrl+MouseWheel in the grid to change font size.
99700>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
99703>>>       Integer iKeys iClicks iX iY iCONTROL
99703>>>       Short iDelta     // Short signed integer
99703>>>       Boolean bok 
99703>>>       Handle hoGrid
99703>>>       
99703>>>       Move 0 to iDelta
99704>>>       Move (Low(wParam)) to iKeys           // any keys down when pressed
99705>>>       Move (MemCopy(AddressOf(iDelta),AddressOf(wParam)+2,2)) to bok
99706>>>       // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
99706>>>       Move (iDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
99707>>>       Move (Low(lParam)) to iX  // cursor position
99708>>>       Move (Hi(lParam)) to iY   
99709>>>
99709>>>       Move (oFunctionSelection_grd(Self)) to hoGrid
99710>>>       Move (iKeys iand MK_CONTROL ) to iCONTROL  //$008
99711>>>       If (iCONTROL) Begin
99713>>>            Send ScaleFont of hoGrid iClicks
99714>>>       End
99714>>>>
99714>>>
99714>>>       // Tell windows that we've handled the event.    
99714>>>       Set Windows_Override_State to True    
99715>>>    End_Procedure
99716>>>        
99716>>>    Object oSysFile_TotFunctionsSelected is a cRDCDbForm
99718>>>        Entry_Item SysFile.SelectedFunctionTotal
99719>>>        Set Server to oSysFile_DD
99720>>>        Set Location to 5 198
99721>>>        Set Size to 12 20
99722>>>        Set Label to "Total Functions Selected:"
99723>>>        Set Enabled_State to False
99724>>>        Set peAnchors to anNone
99725>>>    End_Object
99726>>>
99726>>>    Object oGridFontSize_cf is a cRDCComboForm
99728>>>        Set Size to 13 54
99729>>>        Set Location to 4 54
99730>>>        Set Label to "Grid font size"
99731>>>        Set psToolTip to "Sets the font size for grids"
99732>>>        Set Label_Col_Offset to 2
99733>>>        Set Label_Justification_Mode to JMode_Right
99734>>>        Set Entry_State to False
99735>>>        Set Combo_Sort_State to False
99736>>>
99736>>>        Procedure Combo_Fill_List
99739>>>            Integer iSize
99739>>>
99739>>>            Send Combo_Add_Item "6"
99740>>>            Send Combo_Add_Item "7"
99741>>>            Send Combo_Add_Item "8"
99742>>>            Send Combo_Add_Item "9"
99743>>>            Send Combo_Add_Item "10"
99744>>>            Send Combo_Add_Item "11"
99745>>>            Send Combo_Add_Item "12"
99746>>>            Send Combo_Add_Item "13"
99747>>>            Send Combo_Add_Item "14"
99748>>>            Send Combo_Add_Item "15"
99749>>>            Send Combo_Add_Item "16"
99750>>>
99750>>>            Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iSize
99751>>>            Set Value to iSize
99752>>>        End_Procedure
99753>>>
99753>>>        Procedure OnChange     
99756>>>            Integer iSize
99756>>>            Get Value to iSize
99757>>>            Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
99758>>>            Broadcast Recursive Send DoChangeFontSize of (Client_Id(ghoCommandBars))
99760>>>        End_Procedure
99761>>>
99761>>>    End_Object
99762>>>
99762>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
99765>>>        Integer iSize jSize kSize iSup iInf iDef
99765>>>        Handle hoPaintManager hoFont
99765>>>        Variant vFont
99765>>>        
99765>>>        Move 3 to iInf      //max size
99766>>>        Move 18 to iSup     //min size
99767>>>        Move 8 to iDef      //default
99768>>>        Boolean blimite
99768>>>        Get phoReportPaintManager to hoPaintManager
99769>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
99771>>>            Procedure_Return
99772>>>        End
99772>>>>
99772>>>        Get Create (RefClass(cComStdFont)) to hoFont
99773>>>        Get ComTextFont of hoPaintManager to vFont
99774>>>        Set pvComObject of hoFont to vFont
99775>>>        If (iDirection = 0) Begin
99777>>>            Set ComSize of hoFont to iDef
99778>>>        End
99778>>>>
99778>>>        Else Begin
99779>>>           Get ComSize of hoFont to iSize
99780>>>           Move iSize to jSize
99781>>>           Repeat
99781>>>>
99781>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
99782>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
99783>>>                If (not(blimite)) Begin       
99785>>>                   Set ComSize of hoFont to jSize
99786>>>                   Get ComSize of hoFont to kSize
99787>>>                End
99787>>>>
99787>>>            Until (iSize <> kSize or blimite)
99789>>>        End
99789>>>>
99789>>>        Send Destroy to hoFont 
99790>>>        Send ComRedraw  
99791>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
99792>>>    End_Procedure 
99793>>>
99793>>>    Procedure Close_Panel
99796>>>    End_Procedure
99797>>>
99797>>>    Set Verify_Save_msg to (RefFunc(No_Confirmation))
99798>>>
99798>>>    On_Key Key_Escape Send None
99799>>>    On_Key Key_Ctrl+Key_S Send Request_Save
99800>>>    On_Key Key_Ctrl+Key_F4 Send None
99801>>>End_Object 
99802>//        Use MaintainFunctions.vw
99802>
99802>        Use ErrorLog.dg
Including file: ErrorLog.dg    (C:\Projects\DF18\DfRefactor\AppSrc\ErrorLog.dg)
99802>>>Use Windows.pkg
99802>>>Use cRDCButtonDPI.pkg
99802>>>Use cRDCModalPanel.pkg
99802>>>Use seq_chnl.pkg
99802>>>Use vwin32fh.pkg
99802>>>Use cCJGrid.pkg
99802>>>Use cCJGridColumnRowIndicator.pkg
99802>>>Use cCJGridColumn.pkg
99802>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridPromptList.pkg)
99802>>>>>Use Windows.pkg
99802>>>>>Use cCJGrid.pkg
99802>>>>>
99802>>>>>
99802>>>>>
99802>>>>>Class cCJGridPromptList is a cCJGrid
99803>>>>>    
99803>>>>>    Procedure Construct_Object
99805>>>>>        Forward Send Construct_Object
99807>>>>>        
99807>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
99808>>>>>        Property Boolean Private_pbAutoOrdering True
99809>>>>>        Property Boolean pbAutoSearch True  // pops up search window
99810>>>>>        Property Integer peUpdateMode umPromptValue
99811>>>>>        Property Integer piUpdateColumn 0
99812>>>>>        Property Integer piInitialColumn -1
99813>>>>>        Property String  psSeedValue ''
99814>>>>>        Property Handle phmPromptUpdateCallback 0
99815>>>>>        Property Integer phoInvokingObject
99816>>>>>        
99816>>>>>        Property Boolean pbStoredAutoSeed
99817>>>>>        Property Boolean pbStoredAutoOrdering
99818>>>>>        Property Boolean pbStoredAutoSearch
99819>>>>>        Property Integer peStoredUpdateMode
99820>>>>>        Property Integer piStoredUpdateColumn
99821>>>>>        Property Integer piStoredInitialColumn
99822>>>>>        Property Handle  phmStoredPromptUpdateCallback
99823>>>>>        Property Boolean pbStoredSelectionEnable
99824>>>>>        Property Boolean pbStoredMultipleSelection
99825>>>>>        
99825>>>>>        // internally set by list
99825>>>>>        // these must be set upon closing the list and can be used for manual list updates
99825>>>>>        Property Boolean pbCanceled
99826>>>>>        Property Integer[] pSelectedRows
99827>>>>>        
99827>>>>>        Property Boolean pbNeedsNewOrdering
99828>>>>>        Property Boolean pbRequestSearch
99829>>>>>        Property tGridKeyPair[] pSearchKeys
99830>>>>>        
99830>>>>>        // these properties makes a prompt list a prompt list
99830>>>>>        // and should not be changed.
99830>>>>>        Set pbEditOnKeyNavigation to False
99831>>>>>        Set pbEditOnClick to False
99832>>>>>        Set pbReadOnly to True
99833>>>>>        Set pbFocusSubItems to True
99834>>>>>        
99834>>>>>        // these could maybe be changed
99834>>>>>        Set pbShadeSortColumn to True
99835>>>>>        Set pbHeaderReorders to True
99836>>>>>        Set pbHeaderTogglesDirection to True
99837>>>>>        Set pbHeaderSelectsColumn to True
99838>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
99839>>>>>        Set piFocusCellBackColor to clNone
99840>>>>>        Set piFocusCellForeColor to clNone
99841>>>>>        Set piFocusCellRectangleColor to clBlack
99842>>>>>        Set pbUseFocusCellRectangle to False
99843>>>>>        Set pbSelectionEnable to True
99844>>>>>        
99844>>>>>        On_Key kEnter Send Ok
99845>>>>>        On_Key kCancel Send Cancel
99846>>>>>        
99846>>>>>    End_Procedure
99847>>>>>    
99847>>>>>    // reorder list automatically on column change
99847>>>>>    // this also set pbFocusSubItems which is required to make the two states work
99847>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
99849>>>>>        Set Private_pbAutoOrdering to bAutoOrder
99850>>>>>        Set pbFocusSubItems to bAutoOrder
99851>>>>>    End_Procedure
99852>>>>>    
99852>>>>>    Function pbAutoOrdering Returns Boolean
99854>>>>>        Boolean bAutoOrder
99854>>>>>        Get Private_pbAutoOrdering to bAutoOrder
99855>>>>>        Function_Return bAutoOrder
99856>>>>>    End_Function
99857>>>>>    
99857>>>>>    // augmented to handle auto-ordering and invoking the search popup list
99857>>>>>    Procedure OnIdle
99859>>>>>        Boolean bNeedsReorder bSearch bOldToggle
99859>>>>>        Handle hoCol
99859>>>>>        Integer iKy1 iKy2 iCol
99859>>>>>        
99859>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
99860>>>>>        If bNeedsReorder Begin
99862>>>>>            Get SelectedColumn to iCol
99863>>>>>            If (iCol<>-1) Begin
99865>>>>>                
99865>>>>>                Get pbHeaderTogglesDirection to bOldToggle
99866>>>>>                Set pbHeaderTogglesDirection to False
99867>>>>>                Send HeaderReorder iCol
99868>>>>>                Set pbHeaderTogglesDirection to bOldToggle
99869>>>>>                
99869>>>>>                Set pbNeedsNewOrdering to False
99870>>>>>            End
99870>>>>>>
99870>>>>>        End
99870>>>>>>
99870>>>>>        
99870>>>>>        Get pbRequestSearch to bSearch
99871>>>>>        If bSearch Begin
99873>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
99874>>>>>        End
99874>>>>>>
99874>>>>>        
99874>>>>>        Forward Send OnIdle
99876>>>>>    End_Procedure
99877>>>>>    
99877>>>>>    Procedure OnStoreDefaults
99879>>>>>        Integer iVal
99879>>>>>        Boolean bVal
99879>>>>>        
99879>>>>>        Get pbAutoSeed to bVal
99880>>>>>        Set pbStoredAutoSeed to bVal
99881>>>>>        
99881>>>>>        Get pbAutoOrdering to bVal
99882>>>>>        Set pbStoredAutoOrdering to bVal
99883>>>>>        
99883>>>>>        Get pbAutoSearch to bVal
99884>>>>>        Set pbStoredAutoSearch to bVal
99885>>>>>        
99885>>>>>        Get peUpdateMode to iVal
99886>>>>>        Set peStoredUpdateMode to iVal
99887>>>>>        
99887>>>>>        Get piUpdateColumn to iVal
99888>>>>>        Set piStoredUpdateColumn to iVal
99889>>>>>        
99889>>>>>        Get piInitialColumn to iVal
99890>>>>>        Set piStoredInitialColumn to iVal
99891>>>>>        
99891>>>>>        Get phmPromptUpdateCallback to iVal
99892>>>>>        Set phmStoredPromptUpdateCallback to iVal
99893>>>>>        
99893>>>>>        Get pbSelectionEnable to bVal
99894>>>>>        Set pbStoredSelectionEnable to bVal
99895>>>>>        
99895>>>>>        Get pbMultipleSelection to bVal
99896>>>>>        Set pbStoredMultipleSelection to bVal
99897>>>>>        
99897>>>>>    End_Procedure
99898>>>>>    
99898>>>>>    Procedure OnRestoreDefaults
99900>>>>>        Integer iVal
99900>>>>>        Boolean bVal
99900>>>>>        
99900>>>>>        Get pbStoredAutoSeed to bVal
99901>>>>>        Set pbAutoSeed to bVal
99902>>>>>        
99902>>>>>        Get pbStoredAutoOrdering to bVal
99903>>>>>        Set pbAutoOrdering to bVal
99904>>>>>        
99904>>>>>        Get pbStoredAutoSearch to bVal
99905>>>>>        Set pbAutoSearch to bVal
99906>>>>>        
99906>>>>>        Get peStoredUpdateMode to iVal
99907>>>>>        Set peUpdateMode to iVal
99908>>>>>        
99908>>>>>        Get piStoredInitialColumn to iVal
99909>>>>>        Set piInitialColumn to iVal
99910>>>>>        
99910>>>>>        Get phmStoredPromptUpdateCallback to iVal
99911>>>>>        Set phmPromptUpdateCallback to iVal
99912>>>>>        
99912>>>>>        Get pbStoredSelectionEnable to bVal
99913>>>>>        Set pbSelectionEnable to bVal
99914>>>>>        
99914>>>>>        Get pbStoredMultipleSelection to bVal
99915>>>>>        Set pbMultipleSelection to bVal
99916>>>>>        
99916>>>>>    End_Procedure
99917>>>>>    
99917>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
99917>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
99917>>>>>    // Suitable for augmentation
99917>>>>>    Procedure OnSeedData
99919>>>>>        Integer iUpdateColumn iSortColumn
99919>>>>>        Boolean bSeed bAuto
99919>>>>>        String sValue
99919>>>>>        Handle hoCol
99919>>>>>        
99919>>>>>        Get piUpdateColumn to iUpdateColumn
99920>>>>>        Get psSeedValue to sValue
99921>>>>>        Get pbAutoSeed to bSeed
99922>>>>>        Get piSortColumn to iSortColumn
99923>>>>>        Get pbAutoOrdering to bAuto
99924>>>>>        // if not yet sorted and this is auto ordering we will
99924>>>>>        // sort the data for the search column. We do this to make the
99924>>>>>        // column search GE logic work properly.
99924>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
99926>>>>>            Get ColumnObject iUpdateColumn to hoCol
99927>>>>>            Send SortGridByColumn hoCol False
99928>>>>>        End
99928>>>>>>
99928>>>>>        
99928>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
99930>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
99931>>>>>        End
99931>>>>>>
99931>>>>>        Else Begin
99932>>>>>            Send MovetoFirstRow
99933>>>>>        End
99933>>>>>>
99933>>>>>        
99933>>>>>    End_Procedure
99934>>>>>    
99934>>>>>    Procedure OnMoveValueOutByValue
99936>>>>>        String sValue
99936>>>>>        Handle hoInvokingObject hoCol  hoDataSource
99936>>>>>        Integer iRow iCol
99936>>>>>        Integer[] SelRowsIndexes
99937>>>>>        
99937>>>>>        Get phoInvokingObject to hoInvokingObject
99938>>>>>        Get pSelectedRows to SelRowsIndexes
99939>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
99941>>>>>            Get piUpdateColumn to iCol
99942>>>>>            Get ColumnObject iCol to hoCol
99943>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
99944>>>>>            Set Value of hoInvokingObject to sValue
99945>>>>>            Set Item_Changed_State of hoInvokingObject to True
99946>>>>>        End
99946>>>>>>
99946>>>>>    End_Procedure
99947>>>>>    
99947>>>>>    Procedure OnMoveValueOutByCustom
99949>>>>>    End_Procedure
99950>>>>>    
99950>>>>>    // augment to popup a search window when allowed
99950>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
99952>>>>>        Boolean bSubFocus bAutoSearch bChar
99952>>>>>        Integer iVal
99952>>>>>        
99952>>>>>        Get pbFocusSubItems to bSubFocus
99953>>>>>        Get pbAutoSearch to bAutoSearch
99954>>>>>        Forward Send OnComKeyDown llKeyCode llShift
99956>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
99958>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
99960>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
99961>>>>>                Move (iVal<>0) to bChar
99962>>>>>            End
99962>>>>>>
99962>>>>>            If bChar Begin
99964>>>>>                // this can get called multiple times before a search dialog pops up
99964>>>>>                Send AddToSearchKeys llKeyCode llShift
99965>>>>>            End
99965>>>>>>
99965>>>>>        End
99965>>>>>>
99965>>>>>    End_Procedure
99966>>>>>    
99966>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
99968>>>>>        Boolean bAutoSearch
99968>>>>>        Integer iKeyCode iShiftCode
99968>>>>>        Get pbAutoSearch to bAutoSearch
99969>>>>>        If bAutoSearch Begin
99971>>>>>            // this can get called multiple times before a search dialog pops up
99971>>>>>            Get piLastKey to iKeyCode
99972>>>>>            Get piLastKey2 to iShiftCode
99973>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
99974>>>>>        End
99974>>>>>>
99974>>>>>        Move True to llCancel
99975>>>>>    End_Procedure
99976>>>>>    
99976>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
99978>>>>>        Send ClearSearchRequest // kill any deferred search popup
99979>>>>>        Forward Send OnComRowDblClick llRow llItem
99981>>>>>    End_Procedure
99982>>>>>    
99982>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
99984>>>>>        Send Ok
99985>>>>>    End_Procedure
99986>>>>>    
99986>>>>>    
99986>>>>>    // we don't want a menu for prompt lists
99986>>>>>    Function CreateContextMenu Returns Handle
99988>>>>>        Function_Return 0
99989>>>>>    End_Function
99990>>>>>    
99990>>>>>    // if we use auto-ordering, change the order when the column changes
99990>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
99992>>>>>        Boolean bAutoOrder
99992>>>>>        Forward Send ColumnChanged iOld iNew
99994>>>>>        Get pbAutoOrdering to bAutoOrder
99995>>>>>        If bAutoOrder Begin
99997>>>>>            // will be reordered in idle event
99997>>>>>            Set pbNeedsNewOrdering to True
99998>>>>>        End
99998>>>>>>
99998>>>>>    End_Procedure
99999>>>>>    
99999>>>>>    
99999>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
100001>>>>>        Integer eMode
100001>>>>>        Integer[] SelRowsIndexes
100002>>>>>        Set pbCanceled to True // assume cancel unless changed
100003>>>>>        Set pSelectedRows to SelRowsIndexes // empty
100004>>>>>        Get peUpdateMode to eMode
100005>>>>>        If (eMode<>umPromptNonInvoking) Begin
100007>>>>>            Send OnStoreDefaults
100008>>>>>        End
100008>>>>>>
100008>>>>>        Send InitializePromptList
100009>>>>>        Forward Send Add_Focus hoParent
100011>>>>>        Send LoadData
100012>>>>>        Set psSeedValue to ""
100013>>>>>    End_Procedure
100014>>>>>    
100014>>>>>    // called before the list is activated.
100014>>>>>    Procedure InitializePromptList
100016>>>>>        Integer hoInvokingObject
100016>>>>>        Boolean bAutoColumn bAutoSeed
100016>>>>>        Integer i iOldMode eUpdateMode
100016>>>>>        String sValue
100016>>>>>        
100016>>>>>        Get peUpdateMode to eUpdateMode
100017>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
100019>>>>>            Get Focus of Desktop to hoInvokingObject
100020>>>>>            If (hoInvokingObject<=Desktop) Begin
100022>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
100023>>>>>>
100023>>>>>                Procedure_Return
100024>>>>>            End
100024>>>>>>
100024>>>>>            
100024>>>>>            Set phoInvokingObject to hoInvokingObject
100025>>>>>            
100025>>>>>            Send Prompt_Callback to hoInvokingObject Self
100026>>>>>            Get peUpdateMode to eUpdateMode
100027>>>>>        End
100027>>>>>>
100027>>>>>        
100027>>>>>        Send ClearSearchRequest // clear the search keys
100028>>>>>        Set pbNeedsNewOrdering to False
100029>>>>>        
100029>>>>>        Get pbAutoSeed to bAutoSeed
100030>>>>>        
100030>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
100032>>>>>            Get Value of hoInvokingObject to sValue
100033>>>>>            Set psSeedValue to sValue
100034>>>>>        End
100034>>>>>>
100034>>>>>        
100034>>>>>    End_Procedure
100035>>>>>    
100035>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
100035>>>>>    Procedure LoadData
100037>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
100037>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
100037>>>>>        Integer eUpdateMode
100037>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
100037>>>>>        
100037>>>>>        Get phoDataSource to hoDataSource
100038>>>>>        Get peUpdateMode to eUpdateMode
100039>>>>>        Get phoInvokingObject to hoInvokingObject
100040>>>>>        Get pbAutoSeed to bAutoSeed
100041>>>>>        Get piInitialColumn to iInitialColumn
100042>>>>>        Get piUpdateColumn to iUpdateColumn
100043>>>>>        Get RowCount of hoDataSource to iRows
100044>>>>>        
100044>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
100044>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
100044>>>>>        If (iInitialColumn=-1) Begin
100046>>>>>            Move iUpdateColumn to iInitialColumn
100047>>>>>        End
100047>>>>>>
100047>>>>>        If (iInitialColumn>=0) Begin
100049>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
100050>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
100051>>>>>        End
100051>>>>>>
100051>>>>>        Send OnSeedData // find a good starting place for the row
100052>>>>>        Get pbFocusSubItems to bSubFocus
100053>>>>>        If bSubFocus Begin
100055>>>>>            // if column focus, which is normal, go to initialcolumn
100055>>>>>            If hoInitialColumn Begin
100057>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
100058>>>>>            End
100058>>>>>>
100058>>>>>            Else Begin
100059>>>>>                Send MoveToFirstEnterableColumn
100060>>>>>            End
100060>>>>>>
100060>>>>>        End
100060>>>>>>
100060>>>>>        
100060>>>>>    End_Procedure
100061>>>>>    
100061>>>>>    // This is only called in a successful close
100061>>>>>    Procedure ClosePromptList
100063>>>>>        Handle hoDataSource hoInvokingObject
100063>>>>>        Handle hmCallBack
100063>>>>>        Integer iRow eUpdateMode
100063>>>>>        Integer[] SelRowsIndexes
100064>>>>>        
100064>>>>>        Get phoDataSource to hoDataSource
100065>>>>>        Get phoInvokingObject to hoInvokingObject
100066>>>>>        
100066>>>>>        If (pbMultipleSelection(Self)) Begin
100068>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
100069>>>>>        End
100069>>>>>>
100069>>>>>        Else Begin
100070>>>>>            Get SelectedRow of hoDataSource to iRow
100071>>>>>            If (iRow<>-1) Begin
100073>>>>>                Move iRow to SelRowsIndexes[0]
100074>>>>>            End
100074>>>>>>
100074>>>>>        End
100074>>>>>>
100074>>>>>        
100074>>>>>        Set pbCanceled to False
100075>>>>>        Set pSelectedRows to SelRowsIndexes
100076>>>>>        
100076>>>>>        Get peUpdateMode to eUpdateMode
100077>>>>>        // if non-invoking there is by definition, no move value out
100077>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
100079>>>>>            
100079>>>>>            If (eUpdateMode=umPromptValue) Begin
100081>>>>>                Send OnMoveValueOutByValue
100082>>>>>            End
100082>>>>>>
100082>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
100085>>>>>                Send OnMoveValueOutByCustom
100086>>>>>            End
100086>>>>>>
100086>>>>>            Get phmPromptUpdateCallback to hmCallBack
100087>>>>>            If hmCallBack Begin
100089>>>>>                Send hmCallBack of hoInvokingObject Self
100090>>>>>            End
100090>>>>>>
100090>>>>>        End
100090>>>>>>
100090>>>>>        
100090>>>>>        Send Close_Panel
100091>>>>>    End_Procedure
100092>>>>>    
100092>>>>>    // augment to send OnRestoreDefaults.
100092>>>>>    Procedure Release_Focus
100094>>>>>        Integer eUpdateMode
100094>>>>>        Get peUpdateMode to eUpdateMode
100095>>>>>        Forward Send Release_Focus
100097>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
100099>>>>>            Send OnRestoreDefaults
100100>>>>>        End
100100>>>>>>
100100>>>>>    End_Procedure
100101>>>>>    
100101>>>>>    Function SelectedRowIds Returns RowID[]
100103>>>>>        RowID[] SelectedRowids
100104>>>>>        Integer[] SelectedRows
100105>>>>>        Integer i iRows
100105>>>>>        Handle hoDataSource
100105>>>>>        Get phoDataSource to hoDataSource
100106>>>>>        Get pSelectedRows to SelectedRows
100107>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
100108>>>>>        For i from 0 to (iRows-1)
100114>>>>>>
100114>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
100115>>>>>        Loop
100116>>>>>>
100116>>>>>        Function_Return SelectedRowids
100117>>>>>    End_Function
100118>>>>>    
100118>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
100120>>>>>        String[] SelectedValues
100121>>>>>        Integer[] SelectedRows
100122>>>>>        Integer i iRows
100122>>>>>        Handle hoCol
100122>>>>>        Get ColumnObject iCol to hoCol
100123>>>>>        Get pSelectedRows to SelectedRows
100124>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
100125>>>>>        For i from 0 to (iRows-1)
100131>>>>>>
100131>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
100132>>>>>        Loop
100133>>>>>>
100133>>>>>        Function_Return SelectedValues
100134>>>>>    End_Function
100135>>>>>    
100135>>>>>    Procedure Ok Returns Integer
100137>>>>>        Send ClosePromptList
100138>>>>>    End_Procedure
100139>>>>>    
100139>>>>>    Procedure Cancel Returns Integer
100141>>>>>        Send Close_Panel
100142>>>>>    End_Procedure
100143>>>>>    
100143>>>>>    Procedure Search
100145>>>>>        Send Activate // give focus back to list so focus things are correct
100146>>>>>        Send Request_Search 0 0
100147>>>>>    End_Procedure
100148>>>>>    
100148>>>>>    // do a search using the current keys in the search key buffer for the sort column.
100148>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
100148>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
100148>>>>>    Procedure Request_SearchEx
100150>>>>>        tGridKeyPair[] Keys
100150>>>>>        tGridKeyPair[] Keys
100151>>>>>        Integer iCol
100151>>>>>        Handle hoCol hoSearchDialog
100151>>>>>        Boolean bOk
100151>>>>>        String sValue
100151>>>>>        
100151>>>>>        Get piSortColumn to iCol
100152>>>>>        If (iCol<>-1) Begin
100154>>>>>            Get ColumnObject iCol to hoCol
100155>>>>>            Get pSearchKeys to Keys
100156>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
100157>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
100158>>>>>            If bOk Begin
100160>>>>>                Send RequestFindColumnValue iCol sValue True 0
100161>>>>>            End
100161>>>>>>
100161>>>>>            Send Destroy of hoSearchDialog
100162>>>>>        End
100162>>>>>>
100162>>>>>        Send ClearSearchRequest // clear the search keys
100163>>>>>    End_Procedure
100164>>>>>    
100164>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
100164>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
100166>>>>>        tGridKeyPair[] Keys
100166>>>>>        tGridKeyPair[] Keys
100167>>>>>        tGridKeyPair KeyPair
100167>>>>>        tGridKeyPair KeyPair
100167>>>>>        Set pbRequestSearch to True
100168>>>>>        Move iKeyCode to KeyPair.KeyCode
100169>>>>>        Move iShiftCode to KeyPair.ShiftCode
100170>>>>>        Get pSearchKeys to Keys
100171>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
100172>>>>>        Set pSearchKeys to Keys
100173>>>>>    End_Procedure
100174>>>>>    
100174>>>>>    Procedure ClearSearchRequest
100176>>>>>        tGridKeyPair[] SearchKeys
100176>>>>>        tGridKeyPair[] SearchKeys
100177>>>>>        Set pSearchKeys to SearchKeys
100178>>>>>        Set pbRequestSearch to False
100179>>>>>    End_Procedure
100180>>>>>    
100180>>>>>End_Class
100181>>>>>
100181>>>
100181>>>Object oErrorLog_dg is a cRDCModalPanel
100183>>>    Set Size to 214 590
100184>>>    Set Label to "Error Log Dialog"
100185>>>    Set piMinSize to 89 211
100186>>>    Set Location to 2 2
100187>>>    Set Icon to "OpenLogFile.ico" 
100188>>>    Set Locate_Mode to CENTER_ON_PARENT
100189>>>
100189>>>    Property String psErrorLogFile ""
100191>>>    Property Integer piIndent
100193>>>
100193>>>    Object oErrorLog_grd is a cCJGridPromptList
100195>>>        Set Size to 177 566
100196>>>        Set Location to 9 10
100197>>>        Set pbGrayIfDisable to False
100198>>>        Set pbShowFooter to True
100199>>>        Set pbShowRowFocus to True
100200>>>        Set pbUseAlternateRowBackgroundColor to True
100201>>>        Set pbUseFocusCellRectangle to False
100202>>>        Set peAnchors to anAll
100203>>>        Set psNoItemsText to "No error log file"
100204>>>        Set pbAllowAppendRow to False
100205>>>        Set pbAllowInsertRow to False
100206>>>        Set pbAutoAppend to False
100207>>>        Set pbRestoreLayout to True 
100208>>>        Set psLayoutSection to (Name(Self))
100209>>>        Set pbSelectionEnable to True
100210>>>        Set peUpdateMode to umPromptCustom
100211>>>        Set pbAllowColumnReorder to False
100212>>>        Set pbAutoOrdering to False
100213>>>        Set pbAutoSeed to False
100214>>>        Set pbEditOnTyping to False
100215>>>        Set pbHeaderReorders to False
100216>>>        Set pbHeaderSelectsColumn to False
100217>>>        Set pbHeaderTogglesDirection to False
100218>>>
100218>>>        Object oLineNumber_col is a cCJGridColumn
100220>>>            Set piWidth to 34
100221>>>            Set pbEditable to False
100222>>>            Set psCaption to "Line"
100223>>>        End_Object
100224>>>
100224>>>        Object oErrorText_col is a cCJGridColumn
100226>>>            Set piWidth to 910
100227>>>            Set psCaption to "Error Message"
100228>>>        End_Object   
100229>>>        
100229>>>        Procedure LoadData
100232>>>            String sErrorLogFile sLine
100232>>>            Integer iRow iColRow iCol iChannel iLine
100232>>>            Handle hoDataSource
100232>>>            tDataSourceRow[] TheData
100232>>>            tDataSourceRow[] TheData
100233>>>            Boolean bFound
100233>>>    
100233>>>            Get Seq_New_Channel to iChannel
100234>>>            If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
100236>>>                Send Info_Box "No channel available for processing error log file" "Error"
100237>>>                Procedure_Return
100238>>>            End 
100238>>>>
100238>>>            
100238>>>            Move 0 to iRow
100239>>>            Get phoDataSource to hoDataSource
100240>>>            Get piColumnId of oLineNumber_col to iColRow
100241>>>            Get piColumnId of oErrorText_col to iCol
100242>>>            Get psErrorLogFile to sErrorLogFile        
100243>>>            
100243>>>            Direct_Input channel iChannel sErrorLogFile
100245>>>            While (SeqEof = False)
100249>>>                Readln channel iChannel sLine
100251>>>                If (Trim(sLine) <> "") Begin     
100253>>>                    Get ExtractLineNumber sLine to iLine
100254>>>                    Move iLine to TheData[iRow].sValue[iColRow] 
100255>>>                    Move sLine  to TheData[iRow].sValue[iCol] 
100256>>>                    Increment iRow
100257>>>                End
100257>>>>
100257>>>            Loop
100258>>>>
100258>>>            
100258>>>            Close_Input
100259>>>            Send Seq_Release_Channel iChannel
100260>>>            Set psFooterText of oLineNumber_col to iRow
100261>>>            Set psFooterText of oErrorText_col to sErrorLogFile
100262>>>            Send InitializeData TheData
100263>>>            Send MovetoFirstRow
100264>>>        End_Procedure      
100265>>>        
100265>>>        Function ExtractLineNumber String sLine Returns Integer
100268>>>            String sSearch
100268>>>            Integer iPos iLine
100268>>>            
100268>>>            Move 0 to iLine
100269>>>            Move " ON LINE: " to sSearch
100270>>>            Move (Pos(sSearch, sLine)) to iPos
100271>>>            If (iPos <> 0) Begin
100273>>>                Move (Mid(sLine, Length(sLine), (iPos + Length(sSearch)))) to sLine
100274>>>                Move (Pos(" ", sLine)) to iPos
100275>>>                Move (Left(sLine, (iPos - 1))) to sLine
100276>>>                Move (Trim(sLine)) to iLine 
100277>>>            End
100277>>>>
100277>>>            Function_Return iLine
100278>>>        End_Function                    
100279>>>
100279>>>        Procedure OnMoveValueOutByCustom 
100282>>>            Boolean bFound 
100282>>>            Integer iCol iPos iLine
100282>>>            String[] asSel   
100283>>>            String sLine sSearch
100283>>>            Handle ho
100283>>>            
100283>>>            Move False to bFound     
100284>>>            Get piColumnId of oLineNumber_col to iCol
100285>>>            Get SelectedColumnValues iCol to asSel
100286>>>            Move asSel[0] to iLine
100287>>>            Send Close_Panel
100288>>>            // GotoLine in the Scintilla editor is zero based.
100288>>>            Send JumpToSourceLine of (Client_Id(phoMainPanel(ghoApplication))) (iLine - 1)
100289>>>        End_Procedure
100290>>>
100290>>>    End_Object
100291>>>    
100291>>>    Object oFirstRow_btn is a cRDCButtonDPI
100293>>>        Set Location to 193 414
100294>>>        Set Label to "View Top"
100295>>>        Set peAnchors to anBottomRight
100296>>>
100296>>>        Procedure OnClick
100299>>>            Send MovetoFirstRow to oErrorLog_grd
100300>>>        End_Procedure
100301>>>
100301>>>    End_Object
100302>>>
100302>>>    Object oLatestRow_btn is a cRDCButtonDPI
100304>>>        Set Location to 193 471
100305>>>        Set Label to "View Bottom"
100306>>>        Set peAnchors to anBottomRight
100307>>>
100307>>>        Procedure OnClick
100310>>>            Send MoveToLastRow to oErrorLog_grd
100311>>>        End_Procedure
100312>>>
100312>>>    End_Object
100313>>>
100313>>>    Object oCancel_Btn is a cRDCButtonDPI
100315>>>        Set Label    to "&Close"
100316>>>        Set Location to 193 528
100317>>>        Set peAnchors to anBottomRight
100318>>>
100318>>>        Procedure OnClick
100321>>>            Send Close_Panel
100322>>>        End_Procedure
100323>>>
100323>>>    End_Object
100324>>>
100324>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRow_btn
100325>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRow_btn
100326>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRow_btn
100327>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRow_btn
100328>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
100329>>>End_Object
100330>>>
100330>>>Procedure ActivateErrorDialog String sErrorLogFile
100333>>>    Handle ho
100333>>>    Boolean bExists
100333>>>
100333>>>    Get vFilePathExists sErrorLogFile to bExists
100334>>>    If (bExists = False) Begin
100336>>>        Send Info_Box "The ErrorLog doesn't exist."
100337>>>        Procedure_Return
100338>>>    End
100338>>>>
100338>>>    Move (oErrorLog_dg(Self)) to ho
100339>>>    Set psErrorLogFile of ho to sErrorLogFile
100340>>>    Send Popup of ho
100341>>>End_Procedure
100342>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\StdAbout.pkg)
100342>>>//************************************************************************
100342>>>// Confidential Trade Secret.
100342>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
100342>>>// as an unpublished work.  All rights reserved.
100342>>>// DataFlex is a registered trademark of Data Access Corporation.
100342>>>//
100342>>>//************************************************************************
100342>>>//************************************************************************
100342>>>//
100342>>>// $File name  : StdAbout.pkg
100342>>>// $File title : Standard about object package for VDF
100342>>>// Notice      :
100342>>>// $Author(s)  : John Tuohy
100342>>>//
100342>>>// $Rev History
100342>>>//
100342>>>// JT 06/27/97   File created
100342>>>//************************************************************************
100342>>>
100342>>>// This provides a quick and simple way to create an about package for a program.
100342>>>// You need to create a message inside you client area called Activate_About.
100342>>>// Within this message you should send the message DoAbout passing needed
100342>>>// string information.
100342>>>//
100342>>>//       Procedure Activate_About
100342>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
100342>>>//       End_Procedure
100342>>>//    where: sTitle =     Name of application. If none provided, uses caption
100342>>>//                        bar title
100342>>>//           sVersion   = Version Line. If none provided, will be blank
100342>>>//           sCopyRight = Copyright Line. If none provided, will be blank
100342>>>//           sAuthor    = Author name, blank if none provided
100342>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
100342>>>//                        is used.
100342>>>// It is expected that you will place this in your own object package. For
100342>>>// example an order about package may look like this:
100342>>>//
100342>>>//   // OrderAbout.pkg
100342>>>//   Use StdAbout.pkg
100342>>>//   Procedure Activate_About
100342>>>//      String sTitle sCopyright sVersion sAuthor
100342>>>//      Move "My Order Entry System" to sTitle
100342>>>//      Move "Version 2.1" to sVersion
100342>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
100342>>>//      Move "John Smith"  to sAuthor
100342>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
100342>>>//   end_procedure
100342>>>//   // end of file.
100342>>>
100342>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DfRefactor\Libraries\DFAbout\DfAbout.pkg)
100342>>>>>Use LanguageText.pkg
100342>>>>>Use Windows.pkg
100342>>>>>Use Dfclient.pkg
100342>>>>>Use DFbitmap.pkg
100342>>>>>Use GlobalFunctionsProcedures.pkg
100342>>>>>Use cRichEdit.pkg
100342>>>>>Use cTextEdit.pkg
100342>>>>>Use cRichEdit.pkg
100342>>>>>Use gFormatNumbers.pkg
100342>>>>>Use tWinStructs.pkg
100342>>>>>
100342>>>>>Use cli.pkg
100342>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
100342>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
100342>>>>>>>// Notice      : This package contains constants and commands, used to call
100342>>>>>>>//               specific functions in the DFBTRDRV.
100342>>>>>>>Use Ui
100342>>>>>>>//
100342>>>>>>>// Driver Indentification
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>// Driver attributes
100342>>>>>>>//
100342>>>>>>>// Call_Driver functions ID's
100342>>>>>>>//
100342>>>>>>>//
100342>>>>>>>// DFBTRFN_CONVERT_FILE options
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// DFBTRFN_SET_OWNER options
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to create all vars which may be needed
100342>>>>>>>// in other commands.
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to set the owner of a Btrieve file.
100342>>>>>>>// File must have been opened.
100342>>>>>>>// Filenumber needs to be passed.
100342>>>>>>>// To clear set the owner to "".
100342>>>>>>>// Examples:
100342>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
100342>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
100342>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
100342>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
100342>>>>>>>// To clear:
100342>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to parse DFBTR_SET_OWNVER
100342>>>>>>>// options.
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to parse for Callback
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to clear the owner of a Btrieve file.
100342>>>>>>>// File must have been opened.
100342>>>>>>>// Filenumber needs to be passed.
100342>>>>>>>// Examples:
100342>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to add a owner name to the internal list of ownernames
100342>>>>>>>// which will be tries when opening files.
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to remove all owners from the internal list of ownernames
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to set the owner name to be used when opening the DDF files.
100342>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
100342>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
100342>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to change the transaction type.
100342>>>>>>>// Valid types are:
100342>>>>>>>//     DFBTRTT_NONE
100342>>>>>>>//     DFBTRTT_EXCLUSIVE
100342>>>>>>>//     DFBTRTT_CONCURRENT
100342>>>>>>>//
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to get the current transaction type.
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to set explicit_locking
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to get explicit locking
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>//
100342>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
100342>>>>>>>//
100342>>>>>>>
100342>>>>>>>// Purpose: An instance of this class can be used as a broker object to
100342>>>>>>>//          call several Dfbtrdrv releated methods.
100342>>>>>>>
100342>>>>>>>Class cDFBtrDrvHandler is an Array
100343>>>>>>>    
100343>>>>>>>    Procedure Construct_Object Integer iImage
100345>>>>>>>        Forward Send Construct_object iImage
100347>>>>>>>        
100347>>>>>>>        Property String  psDriverID "DFBTRDRV"
100348>>>>>>>    End_Procedure
100349>>>>>>>    
100349>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
100349>>>>>>>    //
100349>>>>>>>    
100349>>>>>>>    Function CKRevision Returns String
100351>>>>>>>        String  sDriverID
100351>>>>>>>        String  sRevision
100351>>>>>>>        String  sVoid
100351>>>>>>>        Integer iRetval
100351>>>>>>>        
100351>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
100351>>>>>>>        // This error would otherwise be raised when we have an older
100351>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
100351>>>>>>>        Send Ignore_error to Error_object_Id 20491
100352>>>>>>>        Get psDriverID to sDriverID
100353>>>>>>>        Move (Repeat(" ", 255)) to sRevision
100354>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
100359>>>>>>>        Send Trap_Error to Error_object_Id 20491
100360>>>>>>>        If (Trim(sRevision) = "") Begin
100362>>>>>>>            // Unable to get the revision. return all zeroes.
100362>>>>>>>            Move "0.0.0.0" to sRevision
100363>>>>>>>        End
100363>>>>>>>>
100363>>>>>>>        Function_Return sRevision
100364>>>>>>>    End_Function
100365>>>>>>>    
100365>>>>>>>    Function CkUsesUri Returns Integer
100367>>>>>>>        String  sDriverID
100367>>>>>>>        String  sVoid1
100367>>>>>>>        String  sVoid2
100367>>>>>>>        Integer iRetval
100367>>>>>>>        
100367>>>>>>>        Get psDriverID to sDriverID
100368>>>>>>>        
100368>>>>>>>        Move 0 to iRetval
100369>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
100369>>>>>>>        // This error would otherwise be raised when we have an older
100369>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
100369>>>>>>>        Send Ignore_error to Error_object_Id 20491
100370>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
100375>>>>>>>        Send Trap_Error to Error_object_Id 20491
100376>>>>>>>        
100376>>>>>>>        Function_Return iRetval
100377>>>>>>>    End_Function
100378>>>>>>>    
100378>>>>>>>    
100378>>>>>>>    
100378>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
100378>>>>>>>    //
100378>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
100378>>>>>>>    //
100378>>>>>>>    
100378>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
100380>>>>>>>        Integer iPartRev
100380>>>>>>>        Integer iCurrentPart
100380>>>>>>>        Integer iSeparatorPos
100380>>>>>>>        
100380>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
100383>>>>>>>        
100383>>>>>>>        Move 0 to iCurrentPart
100384>>>>>>>        Repeat
100384>>>>>>>>
100384>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
100385>>>>>>>            If (iSeparatorPos > 0) Begin
100387>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
100388>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
100389>>>>>>>                Increment iCurrentPart
100390>>>>>>>            End
100390>>>>>>>>
100390>>>>>>>            Else If (sRevision <> "") Begin
100393>>>>>>>                Move sRevision to iPartRev
100394>>>>>>>                Move "" to sRevision
100395>>>>>>>                Increment iCurrentPart
100396>>>>>>>            End
100396>>>>>>>>
100396>>>>>>>            Else ;                Move -1 to iPartRev
100398>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
100400>>>>>>>        
100400>>>>>>>        Function_Return iPartRev
100401>>>>>>>    End_Function
100402>>>>>>>    
100402>>>>>>>    
100402>>>>>>>    
100402>>>>>>>    //
100402>>>>>>>    //  Returns the major revision of the CK
100402>>>>>>>    //
100402>>>>>>>    
100402>>>>>>>    Function CKMajorRevision Returns Integer
100404>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
100405>>>>>>>    End_Function
100406>>>>>>>    
100406>>>>>>>    
100406>>>>>>>    
100406>>>>>>>    //  Returns the minor revision of the CK
100406>>>>>>>    //
100406>>>>>>>    
100406>>>>>>>    Function CKMinorRevision Returns Integer
100408>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
100409>>>>>>>    End_Function
100410>>>>>>>    
100410>>>>>>>    
100410>>>>>>>    //  Returns the release revision of the CK
100410>>>>>>>    //
100410>>>>>>>    
100410>>>>>>>    Function CKReleaseRevision Returns Integer
100412>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
100413>>>>>>>    End_Function
100414>>>>>>>    
100414>>>>>>>    
100414>>>>>>>    //  Returns the major revision of the CK
100414>>>>>>>    //
100414>>>>>>>    
100414>>>>>>>    Function CKBuildRevision Returns Integer
100416>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
100417>>>>>>>    End_Function
100418>>>>>>>    
100418>>>>>>>    
100418>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
100418>>>>>>>    //
100418>>>>>>>    
100418>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
100420>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
100423>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
100426>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
100429>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
100432>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
100435>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
100439>>>>>>>            End
100439>>>>>>>>
100439>>>>>>>        End
100439>>>>>>>>
100439>>>>>>>        
100439>>>>>>>        Function_Return (False)
100440>>>>>>>    End_Function
100441>>>>>>>    
100441>>>>>>>    //   Functions to query the Pervasive.SQL version:
100441>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
100441>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
100441>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
100441>>>>>>>    //
100441>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
100441>>>>>>>    //   in the following format:
100441>>>>>>>    //       <version>.<revision>.<type>
100441>>>>>>>    //   possible values for <type>:
100441>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
100441>>>>>>>    //         server using Workgroup authentication mode
100441>>>>>>>    //       C for client cache engine
100441>>>>>>>    //       D for DOS workstation
100441>>>>>>>    //       N for client Requester
100441>>>>>>>    //       S for NetWare server
100441>>>>>>>    //       T for 32-bit Windows server engine
100441>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
100441>>>>>>>    //
100441>>>>>>>    //   example:
100441>>>>>>>    //       8.50.T
100441>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
100441>>>>>>>    //   32-bits Windows server.
100441>>>>>>>    //
100441>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
100441>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
100441>>>>>>>    //
100441>>>>>>>    //   If the version information is not available or can not be obtained
100441>>>>>>>    //   the functions will return "0.0.0"
100441>>>>>>>    
100441>>>>>>>    //  Returns the version information of the
100441>>>>>>>    //           Pervasive.SQL Client requester.
100441>>>>>>>    
100441>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
100443>>>>>>>        
100443>>>>>>>        String  sDriverID
100443>>>>>>>        String  sVersion
100443>>>>>>>        String  sVoid
100443>>>>>>>        Integer iRetval
100443>>>>>>>        
100443>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
100443>>>>>>>        // This error would otherwise be raised when we have an older
100443>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
100443>>>>>>>        Send Ignore_error to Error_object_Id 20491
100444>>>>>>>        Get psDriverID to sDriverID
100445>>>>>>>        Move (Repeat(" ", 255)) to sVersion
100446>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
100451>>>>>>>        Send Trap_Error to Error_object_Id 20491
100452>>>>>>>        If (Trim(sVersion) = "") Begin
100454>>>>>>>            // Unable to get the revision. return all zeroes.
100454>>>>>>>            Move "0.0.0" to sVersion
100455>>>>>>>        End
100455>>>>>>>>
100455>>>>>>>        Function_Return sVersion
100456>>>>>>>    End_Function
100457>>>>>>>    
100457>>>>>>>    //           Pervasive.SQL Engine
100457>>>>>>>    
100457>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
100459>>>>>>>        
100459>>>>>>>        String  sDriverID
100459>>>>>>>        String  sVersion
100459>>>>>>>        String  sVoid
100459>>>>>>>        Integer iRetval
100459>>>>>>>        
100459>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
100459>>>>>>>        // This error would otherwise be raised when we have an older
100459>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
100459>>>>>>>        Send Ignore_error to Error_object_Id 20491
100460>>>>>>>        Get psDriverID to sDriverID
100461>>>>>>>        Move (Repeat(" ", 255)) to sVersion
100462>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
100467>>>>>>>        Send Trap_Error to Error_object_Id 20491
100468>>>>>>>        If (Trim(sVersion) = "") Begin
100470>>>>>>>            // Unable to get the revision. return all zeroes.
100470>>>>>>>            Move "0.0.0" to sVersion
100471>>>>>>>        End
100471>>>>>>>>
100471>>>>>>>        Function_Return sVersion
100472>>>>>>>    End_Function
100473>>>>>>>    
100473>>>>>>>    //  Returns the version information of the
100473>>>>>>>    //           Pervasive.SQL Server Engine
100473>>>>>>>    
100473>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
100475>>>>>>>        
100475>>>>>>>        String  sDriverID
100475>>>>>>>        String  sVersion
100475>>>>>>>        String  sVoid
100475>>>>>>>        Integer iRetval
100475>>>>>>>        
100475>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
100475>>>>>>>        // This error would otherwise be raised when we have an older
100475>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
100475>>>>>>>        Send Ignore_error to Error_object_Id 20491
100476>>>>>>>        Get psDriverID to sDriverID
100477>>>>>>>        Move (Repeat(" ", 255)) to sVersion
100478>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
100483>>>>>>>        Send Trap_Error to Error_object_Id 20491
100484>>>>>>>        If (Trim(sVersion) = "") Begin
100486>>>>>>>            // Unable to get the revision. return all zeroes.
100486>>>>>>>            Move "0.0.0" to sVersion
100487>>>>>>>        End
100487>>>>>>>>
100487>>>>>>>        Function_Return sVersion
100488>>>>>>>    End_Function
100489>>>>>>>    
100489>>>>>>>End_Class
100490>>>>>>>
100490>>>>>>>
100490>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
100490>>>>>>>//     Package that declares MS SQL driver constants and functions.
100490>>>>>>>//     This package can be used by developers who want to add Data Access
100490>>>>>>>//     MS SQL Client specific code to a DataFlex application.
100490>>>>>>>
100490>>>>>>>Use Cli.pkg
100490>>>>>>>Use SQL.pkg
100490>>>>>>>
100490>>>>>>>//   Driver Indentification
100490>>>>>>>
100490>>>>>>>//   Error number constants
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>// SQL Server spcific types.
100490>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
100490>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
100490>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
100490>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
100490>>>>>>>
100490>>>>>>>// SQL Server spcific types.
100490>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
100490>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
100490>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
100490>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
100490>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
100490>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
100490>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
100490>>>>>>>//
100490>>>>>>>//     Setup a constraint for a file.
100490>>>>>>>
100490>>>>>>>
100490>>>>>>>Class cMSSQLHandler is a cCLIHandler
100491>>>>>>>    
100491>>>>>>>    Procedure Construct_Object
100493>>>>>>>        Forward Send Construct_Object
100495>>>>>>>        
100495>>>>>>>        Set psDriverID to MSSQLDRV_ID
100496>>>>>>>    End_Procedure
100497>>>>>>>    
100497>>>>>>>    
100497>>>>>>>    
100497>>>>>>>    //   Extract the list from the out connect string.
100497>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
100499>>>>>>>        String  sItem
100499>>>>>>>        Integer iStart
100499>>>>>>>        Integer iEnd
100499>>>>>>>        
100499>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
100502>>>>>>>        
100502>>>>>>>        Send Delete_Data to hoStore
100503>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
100504>>>>>>>        While (iStart > 0)
100508>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
100509>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
100512>>>>>>>            Else Begin
100513>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
100514>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
100515>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
100518>>>>>>>                
100518>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
100521>>>>>>>                
100521>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
100524>>>>>>>            End
100524>>>>>>>>
100524>>>>>>>        Loop
100525>>>>>>>>
100525>>>>>>>        
100525>>>>>>>        Function_Return (Item_Count(hoStore))
100526>>>>>>>    End_Function
100527>>>>>>>    
100527>>>>>>>    
100527>>>>>>>    
100527>>>>>>>    //   Call the driver's browse connect function
100527>>>>>>>    Function BrowseConnect String sInConnStr Returns String
100529>>>>>>>        String  sDriver
100529>>>>>>>        String  sOutConnStr
100529>>>>>>>        Integer iArg
100529>>>>>>>        Integer iRetval
100529>>>>>>>        
100529>>>>>>>        Get psDriverID to sDriver
100530>>>>>>>        If (sDriver <> "") Begin
100532>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
100533>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
100538>>>>>>>        End
100538>>>>>>>>
100538>>>>>>>        
100538>>>>>>>        Function_Return sOutConnStr
100539>>>>>>>    End_Function// BrowseConnect
100540>>>>>>>    
100540>>>>>>>    
100540>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
100542>>>>>>>        String  sDriver
100542>>>>>>>        String  sOutConnStr
100542>>>>>>>        Integer iArg
100542>>>>>>>        Integer iRetval
100542>>>>>>>        
100542>>>>>>>        Move 1 to iArg // Browses only local
100543>>>>>>>        
100543>>>>>>>        Get psDriverID to sDriver
100544>>>>>>>        If (sDriver <> "") Begin
100546>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
100547>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
100552>>>>>>>        End
100552>>>>>>>>
100552>>>>>>>        
100552>>>>>>>        Function_Return sOutConnStr
100553>>>>>>>    End_Function// BrowseConnect
100554>>>>>>>    
100554>>>>>>>    
100554>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
100556>>>>>>>        
100556>>>>>>>        String  sServerList
100556>>>>>>>        Integer iNumServers
100556>>>>>>>        Integer iDriver
100556>>>>>>>        Integer iClientVersion
100556>>>>>>>        String  sDriver
100556>>>>>>>        
100556>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
100557>>>>>>>        
100557>>>>>>>        If (iDriver) Begin
100559>>>>>>>            
100559>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
100562>>>>>>>            
100562>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
100563>>>>>>>            
100563>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
100564>>>>>>>            If (iNetworkLocal = 0) Begin
100566>>>>>>>                Get BrowseConnect sDriver to sServerList
100567>>>>>>>            End
100567>>>>>>>>
100567>>>>>>>            Else Begin
100568>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
100569>>>>>>>            End
100569>>>>>>>>
100569>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
100570>>>>>>>        End
100570>>>>>>>>
100570>>>>>>>        
100570>>>>>>>        Function_Return iNumServers
100571>>>>>>>        
100571>>>>>>>    End_Function
100572>>>>>>>    
100572>>>>>>>    //   Enumerate the available SQL Server database servers
100572>>>>>>>    //   This function will return all SQL Server instances on the network.
100572>>>>>>>    //   This may take a long time.
100572>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
100572>>>>>>>    Function EnumerateServers Returns Integer
100574>>>>>>>        
100574>>>>>>>        Integer iNumServers
100574>>>>>>>        Integer iNetworkLocal
100574>>>>>>>        
100574>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
100575>>>>>>>        
100575>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
100576>>>>>>>        
100576>>>>>>>        Function_Return iNumServers
100577>>>>>>>        
100577>>>>>>>    End_Function
100578>>>>>>>    
100578>>>>>>>    
100578>>>>>>>    //   Enumerate the available SQL Server database servers
100578>>>>>>>    //   This function will return only return SQL Server instance on the local machine
100578>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
100578>>>>>>>    Function EnumerateServersLocal Returns Integer
100580>>>>>>>        
100580>>>>>>>        Integer iNumServers
100580>>>>>>>        Integer iNetworkLocal
100580>>>>>>>        
100580>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
100581>>>>>>>        
100581>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
100582>>>>>>>        
100582>>>>>>>        Function_Return iNumServers
100583>>>>>>>        
100583>>>>>>>    End_Function
100584>>>>>>>    
100584>>>>>>>    
100584>>>>>>>    
100584>>>>>>>    //   Enumerate database in a given server.
100584>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
100586>>>>>>>        Integer hoSQL
100586>>>>>>>        String  sConnect
100586>>>>>>>        String  sDatabase
100586>>>>>>>        Integer hdbc
100586>>>>>>>        Integer hstmt
100586>>>>>>>        Integer iFetchResult
100586>>>>>>>        
100586>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
100589>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
100592>>>>>>>        
100592>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
100595>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
100597>>>>>>>        
100597>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
100599>>>>>>>            Move Current_Object to hoSQL
100600>>>>>>>        End_Object
100601>>>>>>>        
100601>>>>>>>        If (hoSQL <> 0) Begin
100603>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
100604>>>>>>>            If (hdbc <> 0) Begin
100606>>>>>>>                Get SQLOpen of hdbc to hstmt
100607>>>>>>>                If (hstmt <> 0) Begin
100609>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
100609>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
100609>>>>>>>                    //   approach in case meta data might change, the stored procedure will
100609>>>>>>>                    //   stay the same.
100609>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
100610>>>>>>>                    Send SQLCall to hstmt
100611>>>>>>>                    Repeat
100611>>>>>>>>
100611>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
100612>>>>>>>                        If (iFetchResult <> 0) Begin
100614>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
100615>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
100616>>>>>>>                        End
100616>>>>>>>>
100616>>>>>>>                    Until (iFetchResult = 0)
100618>>>>>>>                    
100618>>>>>>>                    Send SQLClose to hstmt
100619>>>>>>>                End
100619>>>>>>>>
100619>>>>>>>                Send SQLDisconnect to hdbc
100620>>>>>>>            End
100620>>>>>>>>
100620>>>>>>>        End
100620>>>>>>>>
100620>>>>>>>        Send Destroy_Object to hoSQL
100621>>>>>>>        
100621>>>>>>>        Function_Return (Item_Count(Current_Object))
100622>>>>>>>    End_Function
100623>>>>>>>    
100623>>>>>>>    
100623>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
100625>>>>>>>        
100625>>>>>>>        String  sSqlServerClientVersionName
100625>>>>>>>        
100625>>>>>>>        
100625>>>>>>>        Case Begin
100625>>>>>>>            
100625>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
100627>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
100628>>>>>>>                Case Break
100629>>>>>>>                
100629>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
100632>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
100633>>>>>>>                Case Break
100634>>>>>>>            
100634>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
100637>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
100638>>>>>>>                Case Break
100639>>>>>>>            
100639>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
100642>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
100643>>>>>>>                Case Break
100644>>>>>>>            
100644>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
100647>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
100648>>>>>>>                Case Break
100649>>>>>>>            
100649>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
100652>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
100653>>>>>>>                Case Break
100654>>>>>>>            
100654>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
100657>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
100658>>>>>>>                Case Break
100659>>>>>>>            
100659>>>>>>>            Case Else
100659>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
100660>>>>>>>                
100660>>>>>>>        Case End
100660>>>>>>>        
100660>>>>>>>        
100660>>>>>>>        Function_Return sSqlServerClientVersionName
100661>>>>>>>        
100661>>>>>>>    End_Function
100662>>>>>>>
100662>>>>>>>
100662>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
100664>>>>>>>        
100664>>>>>>>        String  sSqlServerClientDriverName
100664>>>>>>>        
100664>>>>>>>        Case Begin
100664>>>>>>>            
100664>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
100666>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
100667>>>>>>>                Case Break
100668>>>>>>>                
100668>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
100671>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
100672>>>>>>>                Case Break
100673>>>>>>>            
100673>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
100676>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
100677>>>>>>>                Case Break
100678>>>>>>>            
100678>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
100681>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
100682>>>>>>>                Case Break
100683>>>>>>>            
100683>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
100686>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
100687>>>>>>>                Case Break
100688>>>>>>>            
100688>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
100691>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
100692>>>>>>>                Case Break
100693>>>>>>>            
100693>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
100696>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
100697>>>>>>>                Case Break
100698>>>>>>>            
100698>>>>>>>            Case Else
100698>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
100699>>>>>>>                
100699>>>>>>>        Case End
100699>>>>>>>        
100699>>>>>>>        
100699>>>>>>>        Function_Return sSqlServerClientDriverName
100700>>>>>>>        
100700>>>>>>>    End_Function
100701>>>>>>>    
100701>>>>>>>    
100701>>>>>>>End_Class
100702>>>>>>>
100702>>>>>>>
100702>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
100702>>>>>>>// DB2_DRV.PKG                                                          
100702>>>>>>>//   Package that declares DB2 driver constants and functions.          
100702>>>>>>>//   This package can be used by developers who want to add DB2 driver  
100702>>>>>>>//   specific code to a DataFlex application.                           
100702>>>>>>>
100702>>>>>>>Use Cli.pkg
100702>>>>>>>
100702>>>>>>>// Driver attributes
100702>>>>>>>
100702>>>>>>>
100702>>>>>>>// Driver Indentification
100702>>>>>>>
100702>>>>>>>// Error number constants
100702>>>>>>>
100702>>>>>>>// Call driver function identifiers
100702>>>>>>>
100702>>>>>>>// DB2 specific data types
100702>>>>>>>Define SQL_CLOB           for   (-99)
100702>>>>>>>Define SQL_BLOB           for   (-98)
100702>>>>>>>Define SQL_XML            for   (-370)
100702>>>>>>>// DB2 Graphic types are Unicode types
100702>>>>>>>Define SQL_GRAPHIC        for   (-95)
100702>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
100702>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
100702>>>>>>>Define SQL_DBCLOB         for   (-350)
100702>>>>>>>
100702>>>>>>>
100702>>>>>>>// Extra DB2 commands
100702>>>>>>>
100702>>>>>>>
100702>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
100702>>>>>>>//   Setup a constraint for a file.                                     
100702>>>>>>>
100702>>>>>>>
100702>>>>>>>
100702>>>>>>>Class cDB2Handler is a cCLIHandler
100703>>>>>>>    
100703>>>>>>>    Procedure Construct_Object
100705>>>>>>>        Forward Send Construct_Object
100707>>>>>>>        
100707>>>>>>>        Set psDriverID to DB2_DRV_ID
100708>>>>>>>    End_Procedure
100709>>>>>>>    
100709>>>>>>>    
100709>>>>>>>    
100709>>>>>>>    // Reset the datasource list to the beginning
100709>>>>>>>    Procedure SeedDataSources
100711>>>>>>>        String  sDriver
100711>>>>>>>        String  sVoid
100711>>>>>>>        Integer iRetval
100711>>>>>>>        
100711>>>>>>>        Get psDriverID to sDriver
100712>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
100719>>>>>>>    End_Procedure
100720>>>>>>>    
100720>>>>>>>    
100720>>>>>>>    
100720>>>>>>>    // Call the driver's data sources function
100720>>>>>>>    Function DataSources Returns String
100722>>>>>>>        String  sDriver
100722>>>>>>>        String  sDataSource
100722>>>>>>>        String  sDescription
100722>>>>>>>        Integer iLength
100722>>>>>>>        Integer iRetval
100722>>>>>>>        
100722>>>>>>>        Get psDriverID to sDriver
100723>>>>>>>        If (sDriver <> "") Begin
100725>>>>>>>            Move 8192 to iLength
100726>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
100727>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
100728>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
100733>>>>>>>        End
100733>>>>>>>>
100733>>>>>>>        
100733>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
100736>>>>>>>        Else ;            Function_Return ""
100738>>>>>>>    End_Function
100739>>>>>>>    
100739>>>>>>>End_Class
100740>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
100740>>>>>>>//   Package that declares ODBC driver constants and functions.         
100740>>>>>>>//   This package can be used by developers who want to add Data Access 
100740>>>>>>>//   ODBC Client specific code to a DataFlex application.               
100740>>>>>>>
100740>>>>>>>Use Cli.pkg
100740>>>>>>>
100740>>>>>>>// Driver Indentification
100740>>>>>>>
100740>>>>>>>// Error number constants
100740>>>>>>>
100740>>>>>>>// Call driver function identifiers
100740>>>>>>>
100740>>>>>>>Class cODBCHandler is a cCLIHandler
100741>>>>>>>    
100741>>>>>>>    Procedure Construct_Object
100743>>>>>>>        Forward Send Construct_Object
100745>>>>>>>        
100745>>>>>>>        Set psDriverID to ODBC_DRV_ID
100746>>>>>>>    End_Procedure
100747>>>>>>>    
100747>>>>>>>    
100747>>>>>>>    
100747>>>>>>>    // Setup the type of data sources returned by the datasources function
100747>>>>>>>    Procedure Set DataSourceType Integer iNewType
100749>>>>>>>        String  sDriver
100749>>>>>>>        String  sVoid
100749>>>>>>>        Integer iRetval
100749>>>>>>>        
100749>>>>>>>        Get psDriverID to sDriver
100750>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
100757>>>>>>>    End_Procedure
100758>>>>>>>    
100758>>>>>>>    
100758>>>>>>>    // Call the driver's data sources function
100758>>>>>>>    Function DataSources Returns String
100760>>>>>>>        String  sDriver
100760>>>>>>>        String  sDataSource
100760>>>>>>>        String  sDescription
100760>>>>>>>        Integer iLength
100760>>>>>>>        Integer iRetval
100760>>>>>>>        
100760>>>>>>>        Get psDriverID to sDriver
100761>>>>>>>        If (sDriver <> "") Begin
100763>>>>>>>            Move 8192 to iLength
100764>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
100765>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
100766>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
100771>>>>>>>        End
100771>>>>>>>>
100771>>>>>>>        
100771>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
100774>>>>>>>        Else ;            Function_Return ""
100776>>>>>>>    End_Function
100777>>>>>>>    
100777>>>>>>>End_Class
100778>>>>>>>
100778>>>>>Use seq_chnl.pkg
100778>>>>>
100778>>>>>Register_Function phoWorkspace Returns Handle
100778>>>>>Register_Function Help_filename Returns String
100778>>>>>Register_Function GetHelpFile Returns String
100778>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
100778>>>>>
100778>>>>>// Use of Mertech drivers:
100778>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
100778>>>>>
100778>>>>>    Define ORAFLEX   for "ORA_DRV"
100778>>>>>
100778>>>>>    Define SQLFLEX   for "SQL_DRV"
100778>>>>>
100778>>>>>    Define MDSPgSQL  for "MDSPGSQL"
100778>>>>>
100778>>>>>    Define MDSMySQL  for "MDSMYSQL"
100778>>>>>
100778>>>>>// *** Constant Declarations: ***
100778>>>>>//
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>
100778>>>>>    Define DATAFLEX_ID for "DATAFLEX"
100778>>>>>
100778>>>>>// System icon menu constants. If the upper left hand
100778>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
100778>>>>>    Define SC_RESTORE  for |CI$F120
100778>>>>>    Define SC_MOVE     for |CI$F010
100778>>>>>    Define SC_SIZE     for |CI$F000
100778>>>>>    Define SC_MINIMIZE for |CI$F020
100778>>>>>    Define SC_MAXIMIZE for |CI$F030
100778>>>>>    Define SC_CLOSE    for |CI$F060
100778>>>>>    Define SC_KEYMENU  for |CI$F100
100778>>>>>    Define SC_NEXTWINDOW for |CI$F040
100778>>>>>    Define SC_PREVWINDOW for |CI$F050
100778>>>>>
100778>>>>>Define CS_SignProgram        for "signtool.exe"
100778>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
100778>>>>>Define CS_VerifyCredentials  for "verify"
100778>>>>>Define CS_VerifyFileParam    for "/a"
100778>>>>>Define CS_DefAuthVerPolicy   for "/pa"
100778>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
100778>>>>>
100778>>>>>// *** Struct Declarations: ***
100778>>>>>
100778>>>>>Struct AboutSHELLEXECUTEINFO
100778>>>>>    DWord   cbSize
100778>>>>>    Integer fMask
100778>>>>>    Handle  hwnd
100778>>>>>    Pointer lpVerb
100778>>>>>    Pointer lpFile
100778>>>>>    Pointer lpParameters
100778>>>>>    Pointer lpDirectory
100778>>>>>    Integer nShow
100778>>>>>    Pointer hInstApp
100778>>>>>    Pointer lpIDList
100778>>>>>    Pointer lpClass
100778>>>>>    Handle  hkeyClass
100778>>>>>    DWord   dwHotKey
100778>>>>>    Handle  hIconMonitor // Union
100778>>>>>    //Handle  hMonitor     // Union
100778>>>>>    Handle  hProcess
100778>>>>>End_Struct
100778>>>>>
100778>>>>>
100778>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
100778>>>>>//Type MEMORYSTATUS
100778>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
100778>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
100778>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
100778>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
100778>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
100778>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
100778>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
100778>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
100778>>>>>//End_Type
100778>>>>>
100778>>>>>// *** External Function calls: ***
100778>>>>>//
100778>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
100779>>>>>
100779>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
100780>>>>>
100780>>>>>
100780>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
100781>>>>>
100781>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
100782>>>>>
100782>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
100783>>>>>
100783>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
100784>>>>>
100784>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
100785>>>>>
100785>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
100786>>>>>
100786>>>>>// *** Global/Desktop Function Declarations: ***
100786>>>>>
100786>>>>>Function ComputerName Desktop Returns String
100788>>>>>    String sName
100788>>>>>    Get_Environment "COMPUTERNAME" to sName
100789>>>>>>
100789>>>>>    Function_Return sName
100790>>>>>End_Function
100791>>>>>
100791>>>>>Function Network_User_Name Desktop Returns String
100793>>>>>    String sName
100793>>>>>    Get_Environment "USERNAME" to sName
100794>>>>>>
100794>>>>>    Function_Return sName
100795>>>>>End_Function
100796>>>>>
100796>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
100798>>>>>    String sClient sDriver sClientDriver
100798>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
100798>>>>>    Handle hoMsqlDrv
100798>>>>>
100798>>>>>    Move 0 to iDriver
100799>>>>>    Move "" to sClient
100800>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100803>>>>>    For iCount from 1 to iNumberOfDrivers
100809>>>>>>
100809>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
100812>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
100814>>>>>            Move iCount to iDriver
100815>>>>>            Move iNumberOfDrivers to iCount // We're done.
100816>>>>>        End
100816>>>>>>
100816>>>>>    Loop
100817>>>>>>
100817>>>>>
100817>>>>>    // This info is (at current) only available for the MS SQL driver:
100817>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
100819>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
100822>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
100823>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
100824>>>>>        Send Destroy of hoMsqlDrv
100825>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
100826>>>>>    End
100826>>>>>>
100826>>>>>
100826>>>>>    Function_Return sClient
100827>>>>>End_Function
100828>>>>>
100828>>>>>// *** Class Declarations: ***
100828>>>>>//
100828>>>>>Class cBitmapContainerDFLink is a BitmapContainer
100829>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
100831>>>>>        Send Mouse_Up iWindowNumber iPosition
100832>>>>>    End_Procedure
100833>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
100835>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
100837>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
100838>>>>>    End_Procedure
100839>>>>>End_Class
100840>>>>>
100840>>>>>Class cCopyEditorContentButton is a Button
100841>>>>>    Procedure Construct_Object
100843>>>>>        Forward Send Construct_Object
100845>>>>>        Property Handle phoEditorHandle
100846>>>>>        Set psToolTip to C_$DescCopy
100847>>>>>    End_Procedure
100848>>>>>
100848>>>>>    Procedure CopyToWindowsClipboard
100850>>>>>        Handle hoEditor
100850>>>>>        Boolean bCanCopy
100850>>>>>        Address aEditorAddress
100850>>>>>
100850>>>>>        Get phoEditorHandle to hoEditor
100851>>>>>        Send Select_All of hoEditor
100852>>>>>        Get CanCopy of hoEditor to bCanCopy
100853>>>>>        If (bCanCopy = True) Begin
100855>>>>>            Get paValue of hoEditor to aEditorAddress
100856>>>>>            Send Copy   of hoEditor
100857>>>>>            // Remove the selection after text is copied to the clipboard.
100857>>>>>            Send Beginning_of_Data of hoEditor
100858>>>>>            Send Info_Box C_$CopyToClipboard_Text
100859>>>>>        End
100859>>>>>>
100859>>>>>    End_Procedure
100860>>>>>End_Class
100861>>>>>
100861>>>>>Class SysinfoDisplay is a cTextEdit
100862>>>>>    Procedure Construct_Object
100864>>>>>        Forward Send Construct_Object
100866>>>>>
100866>>>>>        Set Size to 100 245
100867>>>>>        Set Location to 6 6
100868>>>>>        Set Border_Style to Border_None
100869>>>>>        Set Read_Only_State to True
100870>>>>>        Set pbWrap to True
100871>>>>>        Set peAnchors to anAll
100872>>>>>    End_Procedure
100873>>>>>
100873>>>>>    // Augmented class message to adjust certain text strings that are wrong...
100873>>>>>
100873>>>>>    Procedure AppendTextLn String sText
100875>>>>>        String sWorkspaceWSFile
100875>>>>>
100875>>>>>        // Only works for English:
100875>>>>>        If (ghoApplication > 0) Begin
100877>>>>>            If (sText contains "Workspace Name") Begin
100879>>>>>                Move "Workspace Config Filename:" to sText
100880>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
100881>>>>>                Move (sText * sWorkspaceWSFile) to sText
100882>>>>>            End
100882>>>>>>
100882>>>>>        End
100882>>>>>>
100882>>>>>        Send AppendText sText
100883>>>>>        Send AppendText (character(10))
100884>>>>>    End_Procedure
100885>>>>>
100885>>>>>    //    This method will show the name Of the current directory in the system
100885>>>>>    //    information box
100885>>>>>    Procedure Show_Current_Directory
100887>>>>>        String sDir
100887>>>>>
100887>>>>>        Get_Current_Directory To sDir
100888>>>>>
100888>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
100889>>>>>    End_Procedure
100890>>>>>
100890>>>>>    Procedure Show_Windows_Directory
100892>>>>>        String sWindir
100892>>>>>
100892>>>>>        Get_Windows_Directory To sWindir
100893>>>>>
100893>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
100894>>>>>    End_Procedure
100895>>>>>
100895>>>>>    Procedure Show_Current_User
100897>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
100898>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
100899>>>>>    End_Procedure
100900>>>>>
100900>>>>>    Procedure Show_Number_Format
100902>>>>>        Integer iFormat
100902>>>>>        String sFormatText
100902>>>>>
100902>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
100905>>>>>        Move (Character (iFormat)) To sFormatText
100906>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
100907>>>>>
100907>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
100910>>>>>        Move (Character (iFormat)) to sFormatText
100911>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
100912>>>>>    End_Procedure
100913>>>>>
100913>>>>>    Procedure Show_Filelist_Name
100915>>>>>        String sFilename
100915>>>>>
100915>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
100918>>>>>
100918>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
100919>>>>>    End_Procedure
100920>>>>>
100920>>>>>    Procedure Show_Lock_Delay
100922>>>>>        Integer iLockdelay
100922>>>>>
100922>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
100925>>>>>
100925>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
100926>>>>>    End_Procedure
100927>>>>>
100927>>>>>    Procedure Show_Lock_Timeout
100929>>>>>        Integer iLockTimeout
100929>>>>>
100929>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
100932>>>>>
100932>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
100933>>>>>    End_Procedure
100934>>>>>
100934>>>>>    Procedure Show_Screen_Size
100936>>>>>        Integer iYscreensize iXscreensize
100936>>>>>
100936>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
100937>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
100938>>>>>
100938>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
100939>>>>>    End_Procedure
100940>>>>>
100940>>>>>    Procedure Show_Page_Size
100942>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
100943>>>>>    End_procedure
100944>>>>>
100944>>>>>    Procedure Show_Date
100946>>>>>        Date dToday
100946>>>>>
100946>>>>>        Move (CurrentDateTime()) to dToday
100947>>>>>
100947>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
100948>>>>>    End_procedure
100949>>>>>
100949>>>>>    Procedure Show_Date_Format
100951>>>>>        Integer iDateFormat
100951>>>>>        String sDateFormat
100951>>>>>
100951>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
100954>>>>>        Case Begin
100954>>>>>            Case (iDateFormat = DF_DATE_USA)
100956>>>>>                Move C_$USA To sDateFormat
100957>>>>>                Case Break
100958>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
100961>>>>>                Move C_$European To sDateFormat
100962>>>>>                Case Break
100963>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
100966>>>>>                Move C_$Military To sDateFormat
100967>>>>>                Case Break
100968>>>>>            Case Else
100968>>>>>                Move C_$UnknownDateType To sDateFormat
100969>>>>>                Case Break
100970>>>>>        Case End
100970>>>>>
100970>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
100971>>>>>    End_Procedure
100972>>>>>
100972>>>>>    // 2013-08-14 NGS
100972>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
100972>>>>>    Procedure Show_Systemresources
100974>>>>>        tWinMemoryStatusEx MemoryStatusInfo
100974>>>>>        tWinMemoryStatusEx MemoryStatusInfo
100974>>>>>        Integer iRetval
100974>>>>>        Number nValue
100974>>>>>        String sValue
100974>>>>>
100974>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
100975>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
100976>>>>>        If (iRetval = 0) Begin
100978>>>>>            Move (ShowLastError ()) to iRetval
100979>>>>>            Procedure_Return
100980>>>>>        End
100980>>>>>>
100980>>>>>
100980>>>>>        Send AppendTextLn ""
100981>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
100982>>>>>
100982>>>>>        // Show memory in Gigabytes:
100982>>>>>        Move (nValue/1024/1024/1024) to nValue
100983>>>>>        Move (Round(nValue)) to nValue
100984>>>>>        Get FormatNumber nValue 2 to sValue
100985>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
100986>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
100987>>>>>
100987>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
100987>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
100988>>>>>        Move (Round(nValue)) to nValue
100989>>>>>        Get FormatNumber nValue 0 to sValue
100990>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
100991>>>>>
100991>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
100991>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
100992>>>>>        Move (Round(nValue)) to nValue
100993>>>>>        Get FormatNumber nValue 0 to sValue
100994>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
100995>>>>>
100995>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
100995>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
100996>>>>>        Move (Round(nValue)) to nValue
100997>>>>>        Get FormatNumber nValue 0 to sValue
100998>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
100999>>>>>
100999>>>>>        // Add an empty row after the memory information:
100999>>>>>        Send AppendTextLn ""
101000>>>>>    End_Procedure
101001>>>>>
101001>>>>>    Procedure Show_Registration
101003>>>>>        String sRegName
101003>>>>>        Integer iSN iUsersMax iUserCount
101003>>>>>
101003>>>>>        Registration sRegName iSN
101004>>>>>>
101004>>>>>        Get_Licensed_Max_Users to iUsersMax
101005>>>>>        Get_Current_User_Count to iUserCount
101006>>>>>
101006>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
101007>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
101008>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
101009>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
101010>>>>>    End_Procedure
101011>>>>>
101011>>>>>    //****************************************************************************
101011>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
101011>>>>>    // To the workspace object passing the an object and message To send back
101011>>>>>    // To this object. It is expected that the workspace object will send this
101011>>>>>    // message for every line Of information it wants displayed (passing the
101011>>>>>    // information To be displayed
101011>>>>>    //****************************************************************************
101011>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
101011>>>>>
101011>>>>>    Procedure Show_ServicePack
101013>>>>>        String sKey sVersion sDataFlex
101013>>>>>        Handle hoRegistry
101013>>>>>        Boolean bExists bOpened
101013>>>>>
101013>>>>>        Move "DataFlex"        to sDataFlex
101014>>>>>
101014>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
101015>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
101016>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
101017>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
101018>>>>>
101018>>>>>        If (bExists) Begin
101020>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
101021>>>>>        End
101021>>>>>>
101021>>>>>        Else Begin
101022>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
101023>>>>>        End
101023>>>>>>
101023>>>>>        Get KeyExists of hoRegistry sKey to bExists
101024>>>>>        If (bExists) Begin
101026>>>>>            Get OpenKey of hoRegistry sKey to bOpened
101027>>>>>            If (bOpened) Begin
101029>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
101030>>>>>                If (bExists) Begin
101032>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
101033>>>>>                End
101033>>>>>>
101033>>>>>                Send CloseKey of hoRegistry
101034>>>>>            End
101034>>>>>>
101034>>>>>        End
101034>>>>>>
101034>>>>>        Send Destroy of hoRegistry
101035>>>>>
101035>>>>>        If (sVersion <> "") Begin
101037>>>>>           Send AppendTextLn sVersion
101038>>>>>           Send AppendTextLn ""
101039>>>>>        End
101039>>>>>>
101039>>>>>    End_Procedure
101040>>>>>
101040>>>>>    Procedure Show_WorkspaceInformation
101042>>>>>        Integer hoWorkspace
101042>>>>>
101042>>>>>        If (ghoApplication <> 0) Begin
101044>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
101045>>>>>            If (hoWorkspace <> 0) Begin
101047>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
101048>>>>>            End
101048>>>>>>
101048>>>>>        End
101048>>>>>>
101048>>>>>    End_Procedure
101049>>>>>
101049>>>>>    //****************************************************************************
101049>>>>>    // If connection ids are used, we will send the message EnumerateConnections
101049>>>>>    // to the connection manager object passing the an object and message to send
101049>>>>>    // back to this object. It is expected that the connection manager object will
101049>>>>>    // send this message for every line Of information it wants displayed (passing
101049>>>>>    // the information To be displayed
101049>>>>>    //****************************************************************************
101049>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
101049>>>>>
101049>>>>>    Procedure Show_ConnectionIdInformation
101051>>>>>        If (ghoConnection > 0) Begin
101053>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
101054>>>>>            Send AppendTextLn ""
101055>>>>>        End
101055>>>>>>
101055>>>>>    End_Procedure
101056>>>>>
101056>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
101058>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
101059>>>>>    End_Function
101060>>>>>
101060>>>>>    Procedure Show_Versions
101062>>>>>        Integer iVersion iRevision iBuild
101062>>>>>
101062>>>>>        Version_information iVersion iRevision iBuild
101064>>>>>
101064>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
101065>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
101066>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
101067>>>>>        Send AppendTextLn "This is a 32-bit exe file"
101068>>>>>    End_Procedure
101069>>>>>
101069>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
101071>>>>>        Boolean bOK
101071>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
101072>>>>>        Function_Return bOK
101073>>>>>    End_Function
101074>>>>>
101074>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
101076>>>>>        Boolean bOK
101076>>>>>        Function_Return bOK
101077>>>>>    End_Function
101078>>>>>
101078>>>>>    //***
101078>>>>>    //*** BW
101078>>>>>    //*** Procedure: Show_Drivers
101078>>>>>    //*** Purpose  : Show loaded database drivers
101078>>>>>    //***
101078>>>>>
101078>>>>>    Procedure Show_Drivers
101080>>>>>        String sDriverID sVersion sClient sValue
101080>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
101080>>>>>        Handle hoCLIHandler hoBtrvHandler
101080>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
101080>>>>>
101080>>>>>        Move False to bStudioLicense
101081>>>>>
101081>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
101082>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
101083>>>>>
101083>>>>>        // For testing purposes:
101083>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101083>>>>>//        Load_Driver MSSQLDRV_ID
101083>>>>>//        Load_Driver ODBC_DRV_ID
101083>>>>>//        Load_Driver DB2_DRV_ID
101083>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101083>>>>>//
101083>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
101083>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101083>>>>>//            Load_Driver SQLFLEX
101083>>>>>//            Load_Driver MDSPgSQL
101083>>>>>//            Load_Driver MDSMySQL
101083>>>>>//            Load_Driver ORAFLEX
101083>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101083>>>>>//        #ENDIF
101083>>>>>        Move False to Err
101084>>>>>
101084>>>>>        // Loop through all loaded drivers.
101084>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
101087>>>>>        If (iNumberOfDrivers > 1) Begin
101089>>>>>            Send AppendTextLn ""
101090>>>>>        End
101090>>>>>>
101090>>>>>        For iDriver from 1 to iNumberOfDrivers
101096>>>>>>
101096>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
101096>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
101096>>>>>            // would be thrown, so we safeguard from that here.
101096>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
101097>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
101100>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
101101>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
101102>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
101103>>>>>
101103>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
101105>>>>>
101105>>>>>                // Pervasive/Btrieve database
101105>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
101107>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
101108>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
101109>>>>>                    If (sClient <> "0.0.0") Begin
101111>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
101112>>>>>                    End
101112>>>>>>
101112>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
101113>>>>>                    If (sClient <> "0.0.0") Begin
101115>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
101116>>>>>                    End
101116>>>>>>
101116>>>>>                End
101116>>>>>>
101116>>>>>
101116>>>>>                Else Begin
101117>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
101118>>>>>                    Move 0 to iNumServers
101119>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
101121>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
101124>>>>>                    End
101124>>>>>>
101124>>>>>
101124>>>>>                    If (bIsDAWDriver = True) Begin
101126>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
101128>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
101129>>>>>                        End
101129>>>>>>
101129>>>>>                        Get CKRevision of hoCLIHandler to sVersion
101130>>>>>                    End
101130>>>>>>
101130>>>>>
101130>>>>>                    If (bIsMertechDriver = True) Begin
101132>>>>>                    End
101132>>>>>>
101132>>>>>
101132>>>>>                    // If the serialnumber is = 0, it means that the
101132>>>>>                    // Studio licens is in use and there is no
101132>>>>>                    // number of max users defined because the driver is
101132>>>>>                    // relying on the info from the VDF license.
101132>>>>>                    If (bStudioLicense = False) Begin
101134>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
101135>>>>>                        Move (iSerialNo = 0) to bStudioLicense
101136>>>>>                    End
101136>>>>>>
101136>>>>>                End
101136>>>>>>
101136>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
101137>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
101139>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
101140>>>>>                End
101140>>>>>>
101140>>>>>                If (iNumServers <> 0) Begin
101142>>>>>                    For iCount from 1 to iNumServers
101148>>>>>>
101148>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
101151>>>>>                        If (not(sValue contains ";PWD=")) Begin
101153>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
101154>>>>>                        End
101154>>>>>>
101154>>>>>                    Loop
101155>>>>>>
101155>>>>>                End
101155>>>>>>
101155>>>>>            End
101155>>>>>>
101155>>>>>        Loop
101156>>>>>>
101156>>>>>
101156>>>>>        Send AppendTextLn ""
101157>>>>>        If (bStudioLicense = False) Begin
101159>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
101160>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
101161>>>>>        End
101161>>>>>>
101161>>>>>        Else Begin
101162>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
101163>>>>>        End
101163>>>>>>
101163>>>>>        Send Destroy of hoCLIHandler
101164>>>>>        Send Destroy of hoBtrvHandler
101165>>>>>    End_Procedure
101166>>>>>
101166>>>>>    Procedure Show_HelpFile
101168>>>>>        String sHelpFile
101168>>>>>        Integer eHelpType
101168>>>>>
101168>>>>>        If (ghoApplication <> 0) Begin
101170>>>>>            Get peHelpType Of ghoApplication To eHelpType
101171>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
101173>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
101174>>>>>            End
101174>>>>>>
101174>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
101177>>>>>                Get Help_filename Of Help_object_id To sHelpFile
101178>>>>>            End
101178>>>>>>
101178>>>>>            Else Begin
101179>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
101180>>>>>            End
101180>>>>>>
101180>>>>>
101180>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
101181>>>>>        End
101181>>>>>>
101181>>>>>    End_Procedure
101182>>>>>
101182>>>>>    Procedure Show_EnterAsTab
101184>>>>>        Boolean bEnterKeyAsTabKey
101184>>>>>        String sText
101184>>>>>
101184>>>>>        If (ghoApplication <> 0) Begin
101186>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
101187>>>>>            If (bEnterKeyAsTabKey) Begin
101189>>>>>                Move "True" To sText
101190>>>>>            End
101190>>>>>>
101190>>>>>            Else Begin
101191>>>>>                Move "False" To sText
101192>>>>>            End
101192>>>>>>
101192>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
101193>>>>>        End
101193>>>>>>
101193>>>>>    End_Procedure
101194>>>>>
101194>>>>>    //    During activation we will remove the old information and add the newly
101194>>>>>    //    found systeminformation
101194>>>>>    Procedure Add_Focus Integer hoRoot
101196>>>>>        Forward Send Add_Focus hoRoot
101198>>>>>
101198>>>>>        Send Delete_Data
101199>>>>>
101199>>>>>        Set Changed_State To False
101200>>>>>        Set Read_Only_State To True
101201>>>>>
101201>>>>>        Send Show_Registration
101202>>>>>        Send Show_Drivers
101203>>>>>        Send Show_ServicePack
101204>>>>>        Send Show_Versions
101205>>>>>        Send AppendTextLn ""
101206>>>>>
101206>>>>>        If (ghoApplication <> 0) Begin
101208>>>>>            Send Show_WorkSpaceInformation
101209>>>>>            Send Show_HelpFile
101210>>>>>            Send AppendTextLn ""
101211>>>>>        End
101211>>>>>>
101211>>>>>        Else Begin
101212>>>>>            Send AppendTextLn ""
101213>>>>>        End
101213>>>>>>
101213>>>>>
101213>>>>>        If (ghoConnection <> 0) Begin
101215>>>>>            Send Show_ConnectionIdInformation
101216>>>>>        End
101216>>>>>>
101216>>>>>
101216>>>>>        Send Show_Current_User
101217>>>>>        Send Show_Windows_Directory
101218>>>>>        Send Show_Current_Directory
101219>>>>>
101219>>>>>        // This is already shown in the workspace details,
101219>>>>>        // unless no workspace object is present:
101219>>>>>        If (ghoApplication = 0) Begin
101221>>>>>            Send Show_Filelist_Name
101222>>>>>        End
101222>>>>>>
101222>>>>>
101222>>>>>        If (ghoApplication <> 0) Begin
101224>>>>>            Send AppendTextLn ""
101225>>>>>            Send Show_EnterAsTab
101226>>>>>        End
101226>>>>>>
101226>>>>>
101226>>>>>        Send Show_Screen_Size
101227>>>>>        Send Show_Page_Size
101228>>>>>        Send Show_Number_Format
101229>>>>>        Send Show_Date_Format
101230>>>>>        Send Show_Lock_Delay
101231>>>>>        Send Show_Lock_Timeout
101232>>>>>        Send Show_Date
101233>>>>>        Send Show_Systemresources
101234>>>>>        Send Beginning_of_Data
101235>>>>>
101235>>>>>        Set Icon to 'default.ico'
101236>>>>>    End_Procedure
101237>>>>>End_Class
101238>>>>>
101238>>>>>Class SysInfoDialog is a ModalPanel
101239>>>>>    Procedure Construct_Object
101241>>>>>        Forward Send Construct_Object
101243>>>>>
101243>>>>>        Set Label to C_$SystemInformation
101244>>>>>        Set Size to 140 267
101245>>>>>        Set Locate_Mode to CENTER_ON_PARENT
101246>>>>>        Set Border_Style to Border_Thick
101247>>>>>        Set Sysmenu_Icon to False
101248>>>>>
101248>>>>>        // "+1" will make the panel to paint correctly.
101248>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
101249>>>>>
101249>>>>>        // 2014-09-14 NGS
101249>>>>>        // Added a container object around the cTexteditor
101249>>>>>        // object to get a border around the text.
101249>>>>>        Object oSysinfoDisplayContainer is a Container3d
101251>>>>>            Set Location to 2 4
101252>>>>>            Set Size to 110 255
101253>>>>>            Set Border_Style to Border_ClientEdge
101254>>>>>            Set Color to clWhite
101255>>>>>            Set peAnchors to anAll
101256>>>>>
101256>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
101258>>>>>            End_Object
101259>>>>>
101259>>>>>        End_Object
101260>>>>>
101260>>>>>        Object oCloseButton is a Button
101262>>>>>            Set Label to C_$Close
101263>>>>>            Set Location to 120 210
101264>>>>>            Set Message item 0 to msg_Close_Panel
101265>>>>>            Set Default_State To True
101266>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
101266>>>>>            // and changes its peAnchors, we might as well prepare this object
101266>>>>>            // for that situation.
101266>>>>>            Set peAnchors to anBottomRight
101267>>>>>        End_Object
101268>>>>>
101268>>>>>        Object oCopyButton is a cCopyEditorContentButton
101270>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
101271>>>>>            Set Size to 14 50
101272>>>>>            Set Location to 120 158
101273>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
101273>>>>>            // we might as well prepare the object for it.
101273>>>>>            Set peAnchors to anBottomRight
101274>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
101275>>>>>        End_Object
101276>>>>>
101276>>>>>        On_Key kCancel Send Close_Panel
101277>>>>>    End_Procedure
101278>>>>>
101278>>>>>    Procedure Page Integer iPageObject
101280>>>>>        Handle hMenu
101280>>>>>        Integer iPrevState
101280>>>>>
101280>>>>>        Forward Send Page iPageObject
101282>>>>>
101282>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
101282>>>>>        //
101282>>>>>    End_Procedure
101283>>>>>
101283>>>>>End_Class
101284>>>>>
101284>>>>>Class cAboutEdit is an cRichEdit
101285>>>>>    Procedure Construct_Object
101287>>>>>        Forward Send Construct_Object
101289>>>>>
101289>>>>>        Property String psContentText
101290>>>>>
101290>>>>>        Set Size to 77 153
101291>>>>>        Set Location to 8 60
101292>>>>>        Set Read_Only_State to True
101293>>>>>        Set Skip_State to True
101294>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
101294>>>>>        // or 1/20 of a printer's point.
101294>>>>>        Set piRightMargin to (0.1 * 1440)
101295>>>>>        Set Border_Style  to Border_None
101296>>>>>    End_Procedure
101297>>>>>
101297>>>>>    // Adds a line of text to the edit object
101297>>>>>    Procedure Add_Line String sText
101299>>>>>        String sContentText
101299>>>>>        Get psContentText to sContentText
101300>>>>>        Move (sContentText + String(sText)) to sContentText
101301>>>>>        Set psContentText to sContentText
101302>>>>>    End_Procedure
101303>>>>>
101303>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
101303>>>>>    // Note that we use a property psContentText and add to it,
101303>>>>>    // because the object isn't paged yet when we add these
101303>>>>>    // values and the COM edit object needs to be paged
101303>>>>>    // for the text to become visible. See Also: Procedure Page below.
101303>>>>>    Procedure Add_LineLn String sText
101305>>>>>        String sContentText sCR
101305>>>>>
101305>>>>>        Move (Character(10) + String(Character(13))) to sCR
101306>>>>>        Get psContentText to sContentText
101307>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
101308>>>>>        Set psContentText to sContentText
101309>>>>>    End_Procedure
101310>>>>>
101310>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
101312>>>>>        String sLinkText
101312>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
101313>>>>>        Send Show_HomePage sLinkText
101314>>>>>    End_Procedure
101315>>>>>
101315>>>>>    Procedure Page Integer iPageObject
101317>>>>>        String sContentText
101317>>>>>
101317>>>>>        Forward Send Page iPageObject
101319>>>>>        Get psContentText to sContentText
101320>>>>>        Send AppendText sContentText
101321>>>>>        send Beginning_of_Data
101322>>>>>    End_Procedure
101323>>>>>
101323>>>>>End_Class
101324>>>>>
101324>>>>>Class AboutDialog is a ModalPanel
101325>>>>>    Procedure Construct_Object
101327>>>>>
101327>>>>>        Forward Send Construct_Object
101329>>>>>
101329>>>>>        Set Label to C_$About
101330>>>>>        Set Size to 118 230
101331>>>>>        Set Locate_Mode to CENTER_ON_PARENT
101332>>>>>        Set Border_Style to Border_Thick
101333>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
101334>>>>>
101334>>>>>        Object oSysInfoDialog is a SysInfoDialog
101336>>>>>        End_Object
101337>>>>>
101337>>>>>        Object oBox is a Container3d
101339>>>>>            Set Border_Style to Border_Normal
101340>>>>>            Set Size to 90 220
101341>>>>>            Set Location to 4 5
101342>>>>>            Set Color to clWhite
101343>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
101343>>>>>            // we might as well prepare the object for it.
101343>>>>>            Set peAnchors to anAll
101344>>>>>
101344>>>>>            Object oAboutGraphic is a BitmapContainer
101346>>>>>                Set Border_Style To Border_None
101347>>>>>                Set Bitmap_Style to Bitmap_Center
101348>>>>>                Set Color to clWhite
101349>>>>>                Set Size to 45 50
101350>>>>>                Set Location to 0 3
101351>>>>>            End_Object
101352>>>>>
101352>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
101354>>>>>                Set Border_Style to Border_None
101355>>>>>                Set Bitmap_Style to Bitmap_Center
101356>>>>>                Set Color to clWhite
101357>>>>>                Set Size to 30 55
101358>>>>>                Set Location to 50 3
101359>>>>>            End_Object
101360>>>>>
101360>>>>>            Object oInfoList_Editor is an cAboutEdit
101362>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
101362>>>>>                // we might as well prepare the object for it.
101362>>>>>                Set peAnchors to anAll
101363>>>>>            End_Object
101364>>>>>
101364>>>>>            // These objects are here for backwards compatability only.
101364>>>>>            // They are not used.
101364>>>>>            Object oProductName is a TextBox
101366>>>>>                Set Label To C_$ProductName
101367>>>>>                Set Size To 10 45
101368>>>>>                Set Location To 8 53
101369>>>>>                Set Visible_State to False
101370>>>>>                Set Focus_Mode to NonFocusable
101371>>>>>            End_Object
101372>>>>>
101372>>>>>            Object oVersion is a TextBox
101374>>>>>                Set Label To C_$Version
101375>>>>>                Set Size To 10 25
101376>>>>>                Set Location To 21 53
101377>>>>>                Set Visible_State to False
101378>>>>>                Set Focus_Mode to NonFocusable
101379>>>>>            End_Object
101380>>>>>
101380>>>>>            Object oCopyright is a TextBox
101382>>>>>                Set Label To C_$Copyright
101383>>>>>                Set Size To 10 31
101384>>>>>                Set Location To 34 53
101385>>>>>                Set Visible_State to False
101386>>>>>                Set Focus_Mode to NonFocusable
101387>>>>>            End_Object
101388>>>>>
101388>>>>>            Object oAuthor is a TextBox
101390>>>>>                Set Label To C_$Author
101391>>>>>                Set Size To 10 22
101392>>>>>                Set Location To 46 53
101393>>>>>                Set Visible_State to False
101394>>>>>                Set Focus_Mode to NonFocusable
101395>>>>>            End_Object
101396>>>>>
101396>>>>>        End_Object
101397>>>>>
101397>>>>>        Object oOKButton is a Button
101399>>>>>            On_Item C_$Close Send Close_Panel
101400>>>>>            Set Location to 98 176
101401>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
101401>>>>>            // we might as well prepare the object for it.
101401>>>>>            Set peAnchors to anBottomRight
101402>>>>>        End_Object
101403>>>>>
101403>>>>>        Object oSysInfoButton is a Button
101405>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
101406>>>>>            Set Location to 98 123
101407>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
101407>>>>>            // we might as well prepare the object for it.
101407>>>>>            Set peAnchors to anBottomRight
101408>>>>>        End_Object
101409>>>>>
101409>>>>>        Object oCopyButton is a cCopyEditorContentButton
101411>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
101412>>>>>            Set Size to 14 50
101413>>>>>            Set Location to 98 70
101414>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
101414>>>>>            // we might as well prepare the object for it.
101414>>>>>            Set peAnchors to anBottomRight
101415>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
101416>>>>>        End_Object
101417>>>>>
101417>>>>>        On_Key Kcancel Send KeyAction of oOKButton
101418>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
101419>>>>>        Set LogoDF to "DF32.bmp"
101420>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
101420>>>>>    End_Procedure
101421>>>>>
101421>>>>>    Procedure Page Integer iPageObject
101423>>>>>        Handle hMenu
101423>>>>>        Integer iPrevState
101423>>>>>
101423>>>>>        Forward Send Page iPageObject
101425>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
101425>>>>>        Set Icon to "Default.ico"
101426>>>>>
101426>>>>>        // Shadow upper left corner menu items: (icon menu items)
101426>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
101427>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
101428>>>>>        // The "Move" menu command may come in handy to have.
101428>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
101428>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
101429>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
101430>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
101431>>>>>        // The "Close" menu command may be good to have.
101431>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
101431>>>>>    End_Procedure
101432>>>>>
101432>>>>>    Procedure Set ProductName String sText
101434>>>>>        Set Value of oProductName to sText
101435>>>>>    End_Procedure
101436>>>>>
101436>>>>>    Procedure Set Copyright String sText
101438>>>>>        Set Value of oCopyright to sText
101439>>>>>    End_Procedure
101440>>>>>
101440>>>>>    Procedure Set Author String sText
101442>>>>>        Set Value of oAuthor to sText
101443>>>>>    End_Procedure
101444>>>>>
101444>>>>>    Procedure Set Version String sVersion
101446>>>>>        Handle hoVersionInfo
101446>>>>>        Boolean bIncluded
101446>>>>>        Integer iMajor iMinor iRelease iBuild
101446>>>>>//        Date dCompileDate
101446>>>>>        String sCertInfo sCompileDateAndTime
101446>>>>>
101446>>>>>        If (sVersion = "") Begin
101448>>>>>            // This automatically shows the program version of the program, if available.
101448>>>>>            // It will be displayed as the second item in the edit object.
101448>>>>>            If (ghoApplication <> 0) Begin
101450>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
101451>>>>>                If (hoVersionInfo <> 0) Begin
101453>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
101454>>>>>                    If (bIncluded) Begin
101456>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
101457>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
101458>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
101459>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
101460>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
101461>>>>>                    End
101461>>>>>>
101461>>>>>                End
101461>>>>>>
101461>>>>>            End
101461>>>>>>
101461>>>>>        End
101461>>>>>>
101461>>>>>
101461>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
101461>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
101462>>>>>        If (sCompileDateAndTime <> "") Begin
101464>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
101465>>>>>        End
101465>>>>>>
101465>>>>>//        Get GetCompileDate to dCompileDate
101465>>>>>//        If (sVersion <> "") Begin
101465>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
101465>>>>>//        End
101465>>>>>
101465>>>>>        Get IsProgramDigitallySigned to sCertInfo
101466>>>>>        If (sCertInfo <> "-1") Begin
101468>>>>>            If (sCertInfo <> "") Begin
101470>>>>>                Send Add_LineLn sCertInfo
101471>>>>>            End
101471>>>>>>
101471>>>>>            Else Begin
101472>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
101473>>>>>            End
101473>>>>>>
101473>>>>>        End
101473>>>>>>
101473>>>>>    End_Procedure
101474>>>>>
101474>>>>>    Function IsDate String sDate Returns Boolean
101476>>>>>        Boolean bIsDate
101476>>>>>        String sGoodCharacters sChar
101476>>>>>        Integer iCount iLength
101476>>>>>
101476>>>>>        Move True to bIsDate
101477>>>>>        Move "0123456789-/" to sGoodCharacters
101478>>>>>        Move (Length(sDate)) to iLength
101479>>>>>        For iCount from 1 to iLength
101485>>>>>>
101485>>>>>            Move (Left(sDate, 1)) to sChar
101486>>>>>            Move (Mid(sDate, 12, 2)) to sDate
101487>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
101488>>>>>            If (bIsDate = False) Begin
101490>>>>>                Move iLength to iCount
101491>>>>>            End
101491>>>>>>
101491>>>>>        Loop
101492>>>>>>
101492>>>>>        Function_Return bIsDate
101493>>>>>    End_Function
101494>>>>>
101494>>>>>    Function GetCompileDate Returns Date
101496>>>>>        Date dCompileDate
101496>>>>>        String sAppFilename sProgram sData sCompileDate
101496>>>>>        Integer iChannel iPos iDateFormat iCount iSize
101496>>>>>        Boolean bIsValid   
101496>>>>>        
101496>>>>>        Move 0 to dCompileDate
101497>>>>>        // Get full path to the current running executable
101497>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
101498>>>>>        Get GetApplicationName     of ghoApplication to sProgram
101499>>>>>
101499>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
101499>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
101500>>>>>
101500>>>>>        Get_Argument_Size to iSize
101501>>>>>        Set_Argument_Size 20000000
101502>>>>>>
101502>>>>>        Read_Block channel iChannel sData 20000000   // This must be big enough to reach the compile date location
101504>>>>>        Move (Pos(sProgram, sData)) to iPos
101505>>>>>        If (iPos > 0) Begin
101507>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
101507>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
101508>>>>>
101508>>>>>            // If the current date format is non US, we need to temporary
101508>>>>>            // change the format and then move the string to the date variable.
101508>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
101511>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
101514>>>>>            Send Ignore_Error of Error_Object_Id 16 
101515>>>>>            If (Left(sCompileDate, 1) = "0") Begin
101517>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
101518>>>>>            End
101518>>>>>>
101518>>>>>            Move (Date(sCompileDate))    to dCompileDate
101519>>>>>            Send Trap_Error of Error_Object_Id 16
101520>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
101523>>>>>        End
101523>>>>>>
101523>>>>>        Else Begin
101524>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
101525>>>>>>
101525>>>>>        End
101525>>>>>>
101525>>>>>
101525>>>>>        Send Seq_Close_Channel iChannel
101526>>>>>        Set_Argument_Size iSize
101527>>>>>>
101527>>>>>
101527>>>>>        Function_Return dCompileDate
101528>>>>>    End_Function
101529>>>>>
101529>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
101529>>>>>    // (the passed program), has been finished
101529>>>>>    // The DOS box does also _not_ flash briefly.
101529>>>>>    Procedure RunProgramWait String sProgram String sParameter
101531>>>>>        Handle hProcess
101531>>>>>        Integer iVoid
101531>>>>>        AboutSHELLEXECUTEINFO sInfo
101531>>>>>        AboutSHELLEXECUTEINFO sInfo
101531>>>>>
101531>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
101532>>>>>
101532>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
101533>>>>>        Move SW_SHOW                 to sInfo.nShow
101534>>>>>
101534>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
101535>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
101536>>>>>        // This will "hide" the DOS box from showing (no flasing box):
101536>>>>>        Move 0                       to sInfo.nShow
101537>>>>>
101537>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
101538>>>>>        Move sInfo.hProcess to hProcess
101539>>>>>        If (hProcess) Begin
101541>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
101542>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
101543>>>>>        End
101543>>>>>>
101543>>>>>    End_Procedure
101544>>>>>
101544>>>>>    Function AddFolderDelimiter String sPath Returns String
101546>>>>>        String sDirSep
101546>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
101547>>>>>        Move (Trim(sPath)) to sPath
101548>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
101550>>>>>            Move (sPath + sDirSep) to sPath
101551>>>>>        End
101551>>>>>>
101551>>>>>        Function_Return sPath
101552>>>>>    End_Function
101553>>>>>
101553>>>>>    // Returns an empty string if the current program is not digitally signed,
101553>>>>>    // or there is a problem with the certificate.
101553>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
101553>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
101553>>>>>    Function IsProgramDigitallySigned Returns String
101555>>>>>        Boolean bExists
101555>>>>>        String sPath sProgram sParams sRetval
101555>>>>>        Integer iCh
101555>>>>>
101555>>>>>        Move "" to sRetval
101556>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
101557>>>>>        Get AddFolderDelimiter sPath to sPath
101558>>>>>        File_Exist (sPath + CS_SignProgram) bExists
101559>>>>>        If (bExists = False) Begin
101561>>>>>            Function_Return "-1"
101562>>>>>        End
101562>>>>>>
101562>>>>>
101562>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
101563>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
101564>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
101565>>>>>        Move (sParams * String("| clip"))    to sParams
101566>>>>>        Get Seq_New_Channel to iCh
101567>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
101569>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
101572>>>>>        Close_Output channel iCh
101574>>>>>        // New ShellExecute based message that waits for the passed process to end.
101574>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
101575>>>>>        Direct_Input channel iCh "CLIPBOARD:"
101577>>>>>            Readln channel iCh sRetval
101579>>>>>            Readln channel iCh sRetval
101581>>>>>            Readln channel iCh sRetval
101583>>>>>            Readln channel iCh sRetval
101585>>>>>        Close_Input channel iCh
101587>>>>>        Send Seq_Release_Channel iCh
101588>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
101590>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
101591>>>>>        End
101591>>>>>>
101591>>>>>        Else Begin
101592>>>>>            Move "" to sRetval
101593>>>>>        End
101593>>>>>>
101593>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
101593>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
101594>>>>>>
101594>>>>>        Function_Return sRetval
101595>>>>>    End_Function
101596>>>>>
101596>>>>>    Procedure Add_LineLn String sValue
101598>>>>>        Send Add_LineLn of oInfoList_Editor sValue
101599>>>>>    End_Procedure
101600>>>>>
101600>>>>>    Procedure Add_Line String sValue
101602>>>>>        Send Add_Line of oInfoList_Editor sValue
101603>>>>>    End_Procedure
101604>>>>>
101604>>>>>    Procedure Set Logo string sLogo
101606>>>>>        // Square bitmaps of 80x80 work best
101606>>>>>        Set Bitmap of oAboutGraphic to sLogo
101607>>>>>    End_Procedure
101608>>>>>
101608>>>>>    Procedure Set LogoDF String sLogo
101610>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
101611>>>>>    End_Procedure
101612>>>>>
101612>>>>>    Procedure Show_Sysinfo
101614>>>>>        Send Popup_Modal of oSysinfoDialog
101615>>>>>    End_Procedure
101616>>>>>
101616>>>>>    Procedure Show_HomePage String sWebpage
101618>>>>>        Handle hWnd
101618>>>>>        Get Window_Handle to hWnd
101619>>>>>        Runprogram Shell Background (Trim(sWebpage))
101620>>>>>    End_Procedure
101621>>>>>
101621>>>>>End_Class
101622>>>
101622>>>// *************************************************************************
101622>>>//  Public message. This is the default message. It is expected that you will
101622>>>//   create your own message to override this
101622>>>// *************************************************************************
101622>>>
101622>>>Procedure Activate_About
101625>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
101626>>>End_Procedure
101627>>>
101627>>>// *************************************************************************
101627>>>//  Public message. It is expected that you will send this message (most
101627>>>//  likely from Activate_About. This creates an about object, activates it
101627>>>//  and destroys it when done. It is not exepected that you will augment this.
101627>>>// *************************************************************************
101627>>>// Sample usage:
101627>>>//   The first two params will automatically be filled from the application settings if not provided.
101627>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
101627>>>
101627>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
101630>>>    Integer hoObj hoMain iArgs
101630>>>    String sValue
101630>>>
101630>>>    // Create object
101630>>>    Object About is an AboutDialog
101632>>>    // Uncomment these two lines if you would like to have a resizable About object.
101632>>>    //            Set Border_Style to Border_Thick
101632>>>    //            Set peAnchors to anAll
101632>>>
101632>>>    // Add checking for the number of arguments passed to avoid runtime errors
101632>>>    // if one of them is not passed. This makes the interface
101632>>>    // more flexible.
101632>>>        Move num_arguments to iArgs
101633>>>
101633>>>        // If no title is passed use the label of the main panel (if a main panel exists).
101633>>>        If (iArgs > 0 and sTitle = "") Begin
101635>>>            Get Main_Window of Desktop to hoMain
101636>>>            If hoMain Begin
101638>>>                Get Label of hoMain to sValue
101639>>>            End
101639>>>>
101639>>>        End
101639>>>>
101639>>>        Else If (iArgs > 0 and sTitle <> "") Begin
101642>>>            Move sTitle to sValue
101643>>>        End
101643>>>>
101643>>>        Else If (iArgs = 0) Begin
101646>>>            Get Main_Window of Desktop to hoMain
101647>>>            If hoMain Begin
101649>>>                Get Label of hoMain to sValue
101650>>>            End
101650>>>>
101650>>>        End
101650>>>>
101650>>>
101650>>>        If (sValue <> "") Begin
101652>>>            Send Add_LineLn sValue
101653>>>        End
101653>>>>
101653>>>        Move "" to sValue
101654>>>
101654>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
101654>>>        // For this to work the Project Properties Version must have been set in the Studio.
101654>>>        If (iArgs < 2) Begin
101656>>>            Move "" to sValue
101657>>>        End
101657>>>>
101657>>>        Else Begin
101658>>>            Move sVersion to sValue
101659>>>        End
101659>>>>
101659>>>        Set Version to sValue
101660>>>
101660>>>        If (iArgs > 2 and sCopyRight <> "") Begin
101662>>>            Send Add_LineLn sCopyRight
101663>>>        End
101663>>>>
101663>>>
101663>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
101663>>>        // else we do.
101663>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
101665>>>            Send Add_Line sAuthor
101666>>>        End
101666>>>>
101666>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
101669>>>            Send Add_LineLn sAuthor
101670>>>        End
101670>>>>
101670>>>
101670>>>        // Square bitmaps of 80x80 works best
101670>>>        If (iArgs > 4 and sBitmap <> "") Begin
101672>>>            Set Logo to sBitMap
101673>>>        End
101673>>>>
101673>>>
101673>>>        // Here starts handling of the five optional params:
101673>>>        If (iArgs = 6 and sParam6  <> "") Begin
101675>>>            Send Add_Line sParam6
101676>>>        End
101676>>>>
101676>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
101679>>>            Send Add_LineLn sParam6
101680>>>        End
101680>>>>
101680>>>
101680>>>        If (iArgs = 7 and sParam7  <> "") Begin
101682>>>            Send Add_Line sParam7
101683>>>        End
101683>>>>
101683>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
101686>>>            Send Add_LineLn sParam7
101687>>>        End
101687>>>>
101687>>>
101687>>>        If (iArgs = 8 and sParam8  <> "") Begin
101689>>>            Send Add_Line sParam8
101690>>>        End
101690>>>>
101690>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
101693>>>            Send Add_LineLn sParam8
101694>>>        End
101694>>>>
101694>>>
101694>>>        If (iArgs = 9 and sParam9  <> "") Begin
101696>>>            Send Add_Line sParam9
101697>>>        End
101697>>>>
101697>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
101700>>>            Send Add_LineLn sParam9
101701>>>        End
101701>>>>
101701>>>
101701>>>        If (iArgs = 10 and sParam10 <> "") Begin
101703>>>            Send Add_Line sParam10
101704>>>        End
101704>>>>
101704>>>
101704>>>        Move Self to hoObj
101705>>>    End_Object
101706>>>
101706>>>    Send Popup   of hoObj // Popup the about object
101707>>>    Send Destroy of hoObj // When done, it will be destroyed
101708>>>End_Procedure
101709>        Procedure Activate_About
101712>            Send DoAbout "" "" "" "Author: Nils Svedmyr" "DFRefactorTest72x72.bmp" "http://www.rdctools.com" "http://vdf-guidance.com"
101713>        End_Procedure
101714>    
101714>        // We doesn't allow closing of a view - it just doesn't make
101714>        // sense with a tabbed interface.
101714>        Function Exit_Loss_Confirmation for cUIObject Returns Integer
101716>            Function_Return 1
101717>        End_Function
101718>
101718>        On_Key Key_Ctrl+Key_W Send Execute of (oToggleWhiteSpaceItm(ghoCommandBars))
101719>        On_Key Key_Ctrl+Key_I Send Execute of (oToogleIndentationGuides(ghoCommandBars))
101720>        On_Key Key_Ctrl+Key_S Send Execute of (oSave_ToolItem(ghoCommandBars))          
101721>        On_Key Key_Ctrl+Key_R Send Execute of (oRefactor_ToolItem(ghoCommandBars))
101722>        On_Key Key_Ctrl+Key_M Send Execute of (oCompare_MenuItem(ghoCommandBars))
101723>        On_Key Key_F5         Send Execute of (oCompile_ToolItem(ghoCommandBars))
101724>        On_Key Key_Ctrl+Key_E Send Execute of (oErrorLog_ToolItem(ghoCommandBars))
101725>        On_Key Key_Ctrl+Key_U Send Execute of (oUnitTest_MenuItem(ghoCommandBars))
101726>        On_Key Key_Ctrl+Key_O Send OpenContainingContainer of ghoApplication
101727>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
101728>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
101729>    End_Object
101730>                                
101730>End_Object
101731>
101731>Send Switch_Prior_View of (Client_Id(phoMainPanel(ghoApplication)))
101732>
101732>Start_UI                                
101733>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 56944
Total Resources: 1
Total Commands : 101732
Total Windows  : 0
Total Pages    : 0
Static Data    : 769655
Message area   : 679766
Total Blocks   : 37141
