Compiling Program: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
Memory Available: 2147483646
1>//TH-Header
1>//*****************************************************************************************
1>// Copyright (c)  2014  KURANT Project
1>// All rights reserved.
1>//
1>// $FileName    : .\Hammer\AppSrc\DDOReStyler.src
1>// $ProjectName : The Hammer 2.0
1>// $Authors     : wil
1>// $Created     : 11.14.2014  14:21
1>// $Type        : LGPL
1>//
1>// Contents:
1>//  Unfortunately the naming style of datadictionaries over time has not been constant.
1>//  The new style is
1>//    Object o<tablename>_DD is a c<TableName>Datadictionary
1>//  They also have a switch so you can keep on using the legacy style name which is
1>//    Object o<tablename>_DD is a <tablename>_Datadictionary
1>//
1>//  However before VDF12, the
1>//    Object <tableName>_DD is a <tablename>_Datadictionary
1>//
1>//  This caused tremendous headaches as due to the extra "o" we ended up with name clashes
1>//  all over the place. Copying old code into new views/dialogs simply breaks and if your
1>//  codebase has mixed styles then the compiler will not catch that.
1>//  A code nightmare.
1>//
1>//  This program allows you to switch between the following code styles:
1>//
1>//  <TableName>_DD              == eDDOldStyle
1>//  o<TableName>_DD             == eDDLegacyStyle
1>//
1>//
1>// How this code works:
1>// 1. It scans your source file and for each file it will locate the datadictionary objects
1>//    These datadictionary objects are then stored in an array
1>// 2. We read the whole filelist into another array so that we know what table names can be
1>//    used.
1>// 3. The DDOs found in step 1) are classified against the filelist items and we determine
1>//    the DDO style used for the declared DDOs. DDOs that could be verified are labeled
1>//    on style used and marked as being verified.
1>// 4. We scan the source again and replace the verified DDOs with the style wanted.
1>// 5. Write the source out to disk (overwriting the original)
1>//
1>//
1>// Please note that if your source already contains unknown DD objects (eg. You copied old
1>// style code from another version of your appinto new style code) that this parser will
1>// not try to correct that. The starting point should be correct working code.
1>//
1>// Note if a detected DDO is in commented out source code then we will still replace it,
1>// this is to make sure uncommenting code doesn't break the source.
1>// Commented out DDO declarations are -not- detected.
1>//
1>// The following use cases are not supported by the DDRestyler:
1>//   - include files,
1>//   - source files with incorrect DDOs already in there
1>//       (eg. declare o<table>_DD but later on use <table>_DD)
1>//   - references to DDO's not declared in the source file (non autonomous usage)
1>//
1>// How to use:
1>//  1. Compile the .src into your local workspace so that it can find your filelist.
1>//
1>//  Restyle a single file:
1>//
1>//  Object oDDRestyler is a cDDStylingParser
1>//  End_Object
1>//
1>//  Send doRestyleDDObjects of oDDRestyler "C:\Projects\OrderEntry\AppSrc\Customer.vw" eDDLegacyStyle
1>//
1>//  Restyle a whole folder with a filemask:
1>//
1>//  Send doRestyleFolder of oDDRestyler "C:\Projects\OrderEntry\AppSrc" "*.dg;*.sl;*.rv;*.bp;*.vw" eDDLegacyStyle
1>//
1>//*****************************************************************************************
1>//TH-RevisionStart
1>//TH-RevisionEnd
1>
1>
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\windows.pkd)
7602>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cApplication.pkg)
7602>>>Use Windows.pkg
7602>>>
7602>>>Use LanguageText.pkg
7602>>>Use WinUser.pkg
7602>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinShell.pkg)
7602>>>>>Use DLL.pkg
7602>>>>>
7602>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7603>>>>>
7603>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7604>>>>>
7604>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;    Returns Integer // void
7605>>>>>
7605>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;    Returns Integer
7606>>>>>
7606>>>>>
7606>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
7606>>>>>Define URL_ESCAPE_SEGMENT_ONLY                 for |CI$00002000
7606>>>>>
7606>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;    Returns Integer // S_OK if succesfull
7607>>>>>
7607>>>>>External_Function UrlEscape "UrlEscapeA" shlwapi.dll;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord dwFlags;    Returns Integer
7608>>>>>
7608>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWorkspace.pkg)
7608>>>>>Use VdfBase.pkg
7608>>>>>Use tWinStructs.pkg
7608>>>>>Use LanguageText.pkg
7608>>>>>Use WinShell.pkg // Shell API functions
7608>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\seq_chnl.pkg)
7608>>>>>>>Use LanguageText.pkg
7608>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\DataFlex 19.1\Pkg\errornum.inc)
7608>>>>>>>>
7608>>>>>>>>//
7608>>>>>>>>// these will get defined in fmac
7608>>>>>>>>//
7608>>>>>>>>// already defined
7608>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
7608>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
7608>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
7608>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
7608>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
7608>>>>>>>>// new compiler errors used by fmac
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
7608>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
7608>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
7608>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>
7608>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
7608>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
7608>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
7608>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
7608>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
7608>>>>>>>// so that programs that use direct_input/output
7608>>>>>>>// w/o specifying a channel will work.
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Integer Seq$Channel$Error$Mode
7608>>>>>>>
7608>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
7610>>>>>>>    Move Mode to Seq$Channel$Error$Mode
7611>>>>>>>End_Procedure
7612>>>>>>>
7612>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
7614>>>>>>>    Function_Return Seq$Channel$Error$Mode
7615>>>>>>>End_Function
7616>>>>>>>
7616>>>>>>>Object Seq_Channel_List is an Array
7618>>>>>>>    Procedure Initialize
7621>>>>>>>        Integer Itm
7621>>>>>>>        
7621>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
7622>>>>>>>        
7622>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
7626>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
7627>>>>>>>            Increment Itm
7628>>>>>>>        Loop
7629>>>>>>>>
7629>>>>>>>    End_Procedure
7630>>>>>>>    
7630>>>>>>>    Send Initialize
7631>>>>>>>End_Object
7632>>>>>>>
7632>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
7633>>>>>>>
7633>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
7635>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
7636>>>>>>>End_Function
7637>>>>>>>
7637>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
7639>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
7640>>>>>>>End_Procedure
7641>>>>>>>
7641>>>>>>>Function Seq_New_Channel Global Returns Integer
7643>>>>>>>    Integer Obj Chnl
7643>>>>>>>    
7643>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
7644>>>>>>>    
7644>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
7648>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7650>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7651>>>>>>>            Function_Return Chnl
7652>>>>>>>        End
7652>>>>>>>>
7652>>>>>>>        
7652>>>>>>>        Increment Chnl
7653>>>>>>>    Loop
7654>>>>>>>>
7654>>>>>>>    
7654>>>>>>>    // wrap back to beginning
7654>>>>>>>    Move 0 to Chnl
7655>>>>>>>    
7655>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
7659>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7661>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7662>>>>>>>            Function_Return Chnl
7663>>>>>>>        End
7663>>>>>>>>
7663>>>>>>>        
7663>>>>>>>        Increment Chnl
7664>>>>>>>    Loop
7665>>>>>>>>
7665>>>>>>>    
7665>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
7666>>>>>>>End_Function
7667>>>>>>>
7667>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
7669>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
7672>>>>>>>End_Procedure
7673>>>>>>>
7673>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
7675>>>>>>>    Integer Chnl
7675>>>>>>>    
7675>>>>>>>    Move (Seq_New_Channel()) to Chnl
7676>>>>>>>    
7676>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7678>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
7681>>>>>>>        Function_Return Chnl
7682>>>>>>>    End
7682>>>>>>>>
7682>>>>>>>    
7682>>>>>>>    Move False to Err
7683>>>>>>>    Direct_Input channel Chnl Dvc
7685>>>>>>>    
7685>>>>>>>    If (Err) Begin
7687>>>>>>>        Send Seq_Release_Channel Chnl
7688>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7689>>>>>>>    End
7689>>>>>>>>
7689>>>>>>>    
7689>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
7690>>>>>>>    
7690>>>>>>>    Function_Return Chnl
7691>>>>>>>End_Function
7692>>>>>>>
7692>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
7694>>>>>>>    Integer Chnl
7694>>>>>>>    
7694>>>>>>>    Move (Seq_New_Channel()) to Chnl
7695>>>>>>>    
7695>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7697>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7699>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7700>>>>>>>>
7700>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7701>>>>>>>        End
7701>>>>>>>>
7701>>>>>>>        
7701>>>>>>>        Function_Return Chnl
7702>>>>>>>    End
7702>>>>>>>>
7702>>>>>>>    
7702>>>>>>>    Move False to Err
7703>>>>>>>    Direct_Output channel Chnl Dvc
7705>>>>>>>    
7705>>>>>>>    If (Err) Begin
7707>>>>>>>        Send Seq_Release_Channel Chnl
7708>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7709>>>>>>>    End
7709>>>>>>>>
7709>>>>>>>    
7709>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7710>>>>>>>    
7710>>>>>>>    Function_Return Chnl
7711>>>>>>>End_Function
7712>>>>>>>
7712>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
7714>>>>>>>    Integer Chnl
7714>>>>>>>    
7714>>>>>>>    Move (Seq_New_Channel()) to Chnl
7715>>>>>>>    
7715>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7717>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7719>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7720>>>>>>>>
7720>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7721>>>>>>>        End
7721>>>>>>>>
7721>>>>>>>        
7721>>>>>>>        Function_Return Chnl
7722>>>>>>>    End
7722>>>>>>>>
7722>>>>>>>    
7722>>>>>>>    Move False to Err
7723>>>>>>>    Append_Output channel Chnl Dvc
7725>>>>>>>    
7725>>>>>>>    If (Err) Begin
7727>>>>>>>        Send Seq_Release_Channel Chnl
7728>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7729>>>>>>>    End
7729>>>>>>>>
7729>>>>>>>    
7729>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7730>>>>>>>    
7730>>>>>>>    Function_Return Chnl
7731>>>>>>>End_Function
7732>>>>>>>
7732>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
7734>>>>>>>    Integer Mode
7734>>>>>>>    
7734>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
7736>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
7737>>>>>>>        
7737>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
7741>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
7746>>>>>>>        // If channel not open, release it! No (fatal) Error.
7746>>>>>>>        Send Seq_Release_Channel Chnl
7747>>>>>>>    End
7747>>>>>>>>
7747>>>>>>>End_Procedure
7748>>>>>>>
7748>>>>>Use GlobalFunctionsProcedures.pkg
7748>>>>>
7748>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7748>>>>>Register_Function VdfSystemDfPath   Returns String
7748>>>>>Register_Function VdfSystemMakePath Returns String
7748>>>>>
7748>>>>>Enum_List
7748>>>>>    Define wsWorkspaceOpened       // WS opened ok
7748>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7748>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7748>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7748>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7748>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7748>>>>>End_Enum_List
7748>>>>>
7748>>>>>Define INVALID_HANDLE_VALUE for -1
7748>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
7748>>>>>
7748>>>>>
7748>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7749>>>>>
7749>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7750>>>>>
7750>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7751>>>>>
7751>>>>>Function DoesFileExist Global String sFilename Returns Boolean
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    String sMask
7753>>>>>    Integer iVoid
7753>>>>>    Handle hFileFind
7753>>>>>    
7753>>>>>    Move (winFindFirstFile(ToAnsi(sFilename), AddressOf(Win32FindData))) to hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7754>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7756>>>>>        Move (winFindClose(hFileFind)) to iVoid
7757>>>>>    End
7757>>>>>>
7757>>>>>    
7757>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7758>>>>>End_Function
7759>>>>>
7759>>>>>
7759>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cIniFile.pkg)
7759>>>>>>>Use Dll.pkg
7759>>>>>>>Use errornum.inc
7759>>>>>>>Use LanguageText.pkg
7759>>>>>>>Use GlobalFunctionsProcedures.pkg
7759>>>>>>>
7759>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7759>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7759>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7760>>>>>>>
7760>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7761>>>>>>>
7761>>>>>>>Class cIniFile is a cObject
7762>>>>>>>    Procedure Construct_Object
7764>>>>>>>        Forward Send Construct_Object
7766>>>>>>>        
7766>>>>>>>        Property String psFileName
7767>>>>>>>    End_Procedure
7768>>>>>>>    
7768>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7770>>>>>>>        Boolean bSuccess
7770>>>>>>>        
7770>>>>>>>        If (trim(psFileName(Self))="") Begin
7772>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7773>>>>>>>>
7773>>>>>>>            Procedure_Return
7774>>>>>>>        End
7774>>>>>>>>
7774>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(Self)))) to bSuccess
7775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7778>>>>>>>    End_Procedure
7779>>>>>>>    
7779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7781>>>>>>>        Integer iNumChars iSizeValue
7781>>>>>>>        String sValue
7781>>>>>>>        
7781>>>>>>>        Move (ToAnsi(sSection)) to sSection
7782>>>>>>>        Move (ToAnsi(sKey))     to sKey
7783>>>>>>>        Move (ToAnsi(sDefault)) to sDefault
7784>>>>>>>        
7784>>>>>>>        Move 2047 to iSizeValue
7785>>>>>>>        
7785>>>>>>>        Move (Pad(" ",iSizeValue)) to sValue
7786>>>>>>>        
7786>>>>>>>        If (trim(psFileName(Self))="") Begin
7788>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7789>>>>>>>>
7789>>>>>>>            Function_Return ''
7790>>>>>>>        End
7790>>>>>>>>
7790>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, ToAnsi(psFilename(Self)))) to iNumChars
7791>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7792>>>>>>>    End_Function
7793>>>>>>>    
7793>>>>>>>    Function SectionExists String sSection Returns Boolean
7795>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7795>>>>>>>        Handle hoKeys
7795>>>>>>>        Integer icKey iKey
7795>>>>>>>        
7795>>>>>>>        Get Create U_ARRAY to hoKeys
7796>>>>>>>        Send ReadSection sSection hoKeys
7797>>>>>>>        Get Item_Count of hoKeys to icKey
7798>>>>>>>        Send Destroy of hoKeys
7799>>>>>>>        
7799>>>>>>>        Function_Return (icKey >0)
7800>>>>>>>    End_Function
7801>>>>>>>    
7801>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7803>>>>>>>        Integer iNumChars iSizeValue iPos
7803>>>>>>>        Pointer lpsKeys
7803>>>>>>>        String sKeys sKey
7803>>>>>>>        
7803>>>>>>>        Move 16384 to iSizeValue
7804>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sKeys
7805>>>>>>>        
7805>>>>>>>        Move (AddressOf(sKeys)) to lpsKeys
7806>>>>>>>        
7806>>>>>>>        Move (ToAnsi(sSection)) to sSection
7807>>>>>>>        
7807>>>>>>>        If (trim(psFileName(Self))="") Begin
7809>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7810>>>>>>>>
7810>>>>>>>            Procedure_Return
7811>>>>>>>        End
7811>>>>>>>>
7811>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(Self)))) to iNumChars
7812>>>>>>>        If (iNumChars >0) Begin
7814>>>>>>>            Repeat
7814>>>>>>>>
7814>>>>>>>                Move (Pos(Character(0),sKeys)) to iPos
7815>>>>>>>                If (iPos >1) Begin
7817>>>>>>>                    Move (Left(sKeys,iPos -1))  to sKey
7818>>>>>>>                    Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
7819>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sKey))
7820>>>>>>>                End
7820>>>>>>>>
7820>>>>>>>            Until (iPos <=1)
7822>>>>>>>        End
7822>>>>>>>>
7822>>>>>>>    End_Procedure
7823>>>>>>>    
7823>>>>>>>    Procedure ReadSections Handle hoArray
7825>>>>>>>        Integer iNumChars iSizeValue iPos
7825>>>>>>>        Pointer lpsSections
7825>>>>>>>        String sSections sSection
7825>>>>>>>        
7825>>>>>>>        Move 16384 to iSizeValue
7826>>>>>>>        
7826>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sSections
7827>>>>>>>        Move (AddressOf(sSections)) to lpsSections
7828>>>>>>>        
7828>>>>>>>        If (trim(psFileName(Self))="") Begin
7830>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7831>>>>>>>>
7831>>>>>>>            Procedure_Return
7832>>>>>>>        End
7832>>>>>>>>
7832>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(Self)))) to iNumChars
7833>>>>>>>        If (iNumChars >0) Begin
7835>>>>>>>            Repeat
7835>>>>>>>>
7835>>>>>>>                Move (Pos(Character(0),sSections)) to iPos
7836>>>>>>>                If (iPos >1) Begin
7838>>>>>>>                    Move (Left(sSections,iPos -1)) to sSection
7839>>>>>>>                    Move (Right(sSections, Length(sSections) - iPos)) to sSections
7840>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sSection))
7841>>>>>>>                End
7841>>>>>>>>
7841>>>>>>>            Until (iPos <=1)
7843>>>>>>>        End
7843>>>>>>>>
7843>>>>>>>        
7843>>>>>>>    End_Procedure
7844>>>>>>>    
7844>>>>>>>    Procedure DeleteSection String sSection
7846>>>>>>>        
7846>>>>>>>        If (trim(psFileName(Self))="") Begin
7848>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7849>>>>>>>>
7849>>>>>>>            Procedure_Return
7850>>>>>>>        End
7850>>>>>>>>
7850>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(Self))) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
7853>>>>>>>    End_Procedure
7854>>>>>>>    
7854>>>>>>>    Procedure DeleteKey String sSection String sKey
7856>>>>>>>        Integer iVoid
7856>>>>>>>        If (trim(psFileName(Self))="") Begin
7858>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7859>>>>>>>>
7859>>>>>>>            Procedure_Return
7860>>>>>>>        End
7860>>>>>>>>
7860>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(Self)))) to iVoid
7861>>>>>>>    End_Procedure
7862>>>>>>>    
7862>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7864>>>>>>>        Handle hoKeys
7864>>>>>>>        Integer iKey
7864>>>>>>>        Boolean bExists
7864>>>>>>>        
7864>>>>>>>        Move (False) to bExists
7865>>>>>>>        
7865>>>>>>>        Move (ToAnsi(Uppercase(sKey))) to sKey
7866>>>>>>>        
7866>>>>>>>        Get Create U_ARRAY to hoKeys
7867>>>>>>>        
7867>>>>>>>        Send ReadSection sSection hoKeys
7868>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
7874>>>>>>>>
7874>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7876>>>>>>>                Move (True) to bExists
7877>>>>>>>            End
7877>>>>>>>>
7877>>>>>>>        Loop
7878>>>>>>>>
7878>>>>>>>        
7878>>>>>>>        Send Destroy of hoKeys
7879>>>>>>>        
7879>>>>>>>        Function_Return bExists
7880>>>>>>>    End_Function
7881>>>>>>>    
7881>>>>>>>End_Class
7882>>>>>
7882>>>>>Class cWorkspace is a cObject
7883>>>>>    
7883>>>>>    Procedure Construct_Object
7885>>>>>        Forward Send Construct_Object
7887>>>>>        
7887>>>>>        
7887>>>>>        Property String psAppSrcPath
7888>>>>>        Property String psBitmapPath
7889>>>>>        Property String psDataPath
7890>>>>>        Property String psDdSrcPath
7891>>>>>        Property String psDescription
7892>>>>>        Property String psFileList
7893>>>>>        Property String psHelpPath
7894>>>>>        Property String psHome
7895>>>>>        Property String psIdeSrcPath
7896>>>>>        Property String psProgramPath
7897>>>>>        Property String psAppHtmlPath
7898>>>>>        Property String psWorkspaceName
7899>>>>>        Property String psWorkspaceWSFile
7900>>>>>        Property String psConnectionIni
7901>>>>>        
7901>>>>>        Property String psSystemDfPath // took from the Registry!
7902>>>>>        Property String psSystemMakePath // took from the Registry!
7903>>>>>        Property String psDfPath        // Calculated
7904>>>>>        
7904>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7905>>>>>        
7905>>>>>    End_Procedure
7906>>>>>    
7906>>>>>    Function FullPathNames String sShortPathNames Returns String
7908>>>>>        String sFileName
7908>>>>>        String sFullPathNames sFullPathName sShortPathName
7908>>>>>        Pointer lpsFilePart
7908>>>>>        Integer icChar // the number of characters returned
7908>>>>>        Integer iPos
7908>>>>>        
7908>>>>>        Move (Pos(";", sShortPathNames)) to iPos
7909>>>>>        While (length(sShortPathNames) >0)
7913>>>>>            If (iPos =0) Begin
7915>>>>>                Move sShortPathNames to sShortPathName
7916>>>>>                Move "" to sShortPathNames
7917>>>>>            End
7917>>>>>>
7917>>>>>            Else Begin // multiple paths
7918>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
7919>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
7920>>>>>            End
7920>>>>>>
7920>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
7921>>>>>            Move -1 to lpsFilePart
7922>>>>>            Move (GetFullPathName(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
7923>>>>>            Append sFullPathNames (CString(sFullPathName))
7924>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
7927>>>>>            Move (Pos(";", sShortPathNames)) to iPos
7928>>>>>        Loop
7929>>>>>>
7929>>>>>        
7929>>>>>        Function_Return sFullPathNames
7930>>>>>    End_Function
7931>>>>>    
7931>>>>>    Function GetApplicationPath Returns String
7933>>>>>        // Returns the path of the Application (no trailing "\")
7933>>>>>        String sApplicationFileName sPath
7933>>>>>        Boolean bRemoved
7933>>>>>        Integer iNumChars
7933>>>>>        String sFilename
7933>>>>>        
7933>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7934>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7935>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7936>>>>>        
7936>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7937>>>>>        Move (CString(sApplicationFileName)) to sPath
7938>>>>>        
7938>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
7941>>>>>        Function_Return sPath
7942>>>>>    End_Function
7943>>>>>    
7943>>>>>    Procedure DoClearPaths
7945>>>>>        // Call this prior to changing from one WorkspAce to another
7945>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7945>>>>>        Set psHome           to ""
7946>>>>>        Set psAppSrcPath     to ""
7947>>>>>        Set psBitmapPath     to ""
7948>>>>>        Set psDataPath       to ""
7949>>>>>        Set psDdSrcPath      to ""
7950>>>>>        Set psDescription    to ""
7951>>>>>        Set psFileList       to ""
7952>>>>>        Set psHelpPath       to ""
7953>>>>>        Set psIdeSrcPath     to ""
7954>>>>>        Set psAppHtmlPath    to ""
7955>>>>>        Set psProgramPath    to ""
7956>>>>>        Set psWorkspaceName  to ""
7957>>>>>        Set psSystemDfPath   to ""
7958>>>>>        Set psSystemMakePath to ""
7959>>>>>        Set psWorkspaceWSFile to ""
7960>>>>>        Set psConnectionIni to ""
7961>>>>>    End_Procedure
7962>>>>>    
7962>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7964>>>>>        String sApplicationStartPath
7964>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7964>>>>>        Boolean bRemoved
7964>>>>>        Handle hoIniFile
7964>>>>>        Boolean bSuccess // call succeeded?
7964>>>>>        String sOldDirectory
7964>>>>>        String sSystemDfPath sSystemMakePath
7964>>>>>        Boolean bExist // does the WS file exist?
7964>>>>>        Boolean bChangingWorkspace
7964>>>>>        
7964>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7964>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
7964>>>>>        
7964>>>>>        Set psWorkspaceWSFile to ""
7965>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
7968>>>>>        
7968>>>>>        // Append extension if not supplied...
7968>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7970>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
7971>>>>>        End
7971>>>>>>
7971>>>>>        
7971>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
7972>>>>>        
7972>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7974>>>>>            // Set the properties to the paths of the Workspace
7974>>>>>            // Find the WS file (with program)...
7974>>>>>            Get GetApplicationPath to sApplicationStartPath
7975>>>>>            
7975>>>>>            Move sWorkspaceFile to sWsName
7976>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
7977>>>>>        End
7977>>>>>>
7977>>>>>        Else Begin
7978>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
7979>>>>>            
7979>>>>>            Move sWorkspaceFile to sApplicationStartPath
7980>>>>>            Move (PathRemoveFileSpec(AddressOf(sApplicationStartPath))) to bRemoved
7981>>>>>        End
7981>>>>>>
7981>>>>>        
7981>>>>>        // Ensure that the file can be found...
7981>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7981>>>>>        // [JVH] Turn off support for
7981>>>>>        // Ansi extended characters in workspace until we can
7981>>>>>        // resolve all open issues
7981>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7982>>>>>        File_Exist sWorkspaceFile bExist
7983>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
7986>>>>>        
7986>>>>>        Get psHome           to sHome
7987>>>>>        Get psAppSrcPath     to sAppSrcPath
7988>>>>>        Get psAppHtmlPath    to sAppHtmlPath
7989>>>>>        Get psBitmapPath     to sBitmapPath
7990>>>>>        Get psDataPath       to sDataPath
7991>>>>>        Get psDdSrcPath      to sDdSrcPath
7992>>>>>        Get psDescription    to sDescription
7993>>>>>        Get psFileList       to sFileList
7994>>>>>        Get psHelpPath       to sHelpPath
7995>>>>>        Get psIdeSrcPath     to sIdeSrcPath
7996>>>>>        Get psProgramPath    to sProgramPath
7997>>>>>        Get psSystemDfPath   to sSystemDfPath
7998>>>>>        Get psSystemMakePath to sSystemMakePath
7999>>>>>        Get psWorkspaceName  to sWorkspaceName
8000>>>>>        Get psConnectionIni to sConnectionIni
8001>>>>>        
8001>>>>>        Get_Current_Directory to sOldDirectory
8002>>>>>        // Note- this conversion is temporarily rolled back
8002>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
8002>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) to bSuccess
8003>>>>>        
8003>>>>>        Get Create U_cIniFile to hoIniFile
8004>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
8005>>>>>        
8005>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
8008>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
8011>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
8014>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
8017>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
8020>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
8023>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
8026>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
8029>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
8032>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
8035>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
8038>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
8041>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
8044>>>>>        
8044>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
8047>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
8050>>>>>        
8050>>>>>        Set psHome          to (FullPathNames(Self, sHome))
8051>>>>>        
8051>>>>>        // Set CWD to Home...
8051>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
8052>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
8053>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
8054>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
8055>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
8056>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
8057>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
8058>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
8059>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
8060>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
8061>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
8062>>>>>        
8062>>>>>        Set psWorkspaceName to sWorkspaceName
8063>>>>>        Set psDescription   to sDescription
8064>>>>>        
8064>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
8065>>>>>        
8065>>>>>        // Restore CWD...
8065>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
8066>>>>>        
8066>>>>>        // Check for error conditions:
8066>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
8066>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
8069>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
8072>>>>>        
8072>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
8073>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
8076>>>>>        
8076>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
8079>>>>>        
8079>>>>>        Send DoAssignPaths // set psDfPath
8080>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
8081>>>>>        Set pbWorkspaceOpened to True
8082>>>>>        
8082>>>>>        Function_Return wsWorkspaceOpened
8083>>>>>    End_Function
8084>>>>>    
8084>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
8086>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
8086>>>>>        
8086>>>>>        Handle hoSections hoIniFile
8086>>>>>        Integer iWorkspace eOpened
8086>>>>>        String sWorkspaceName sPath
8086>>>>>        String sVdfRootDir
8086>>>>>        
8086>>>>>        Get Create U_Array    to hoSections
8087>>>>>        Get Create U_cIniFile to hoIniFile
8088>>>>>        
8088>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8091>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8094>>>>>        
8094>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8095>>>>>        
8095>>>>>        Send ReadSections of hoIniFile hoSections
8096>>>>>        
8096>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
8102>>>>>>
8102>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
8103>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
8105>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
8106>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
8109>>>>>                
8109>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
8110>>>>>                Send Destroy of hoSections
8111>>>>>                Send Destroy of hoIniFile
8112>>>>>                Function_Return eOpened
8113>>>>>            End
8113>>>>>>
8113>>>>>        Loop
8114>>>>>>
8114>>>>>        
8114>>>>>        Send Destroy of hoSections
8115>>>>>        Send Destroy of hoIniFile
8116>>>>>        Function_Return wsWorkspaceNotFound
8117>>>>>    End_Function
8118>>>>>    
8118>>>>>    Function IsRegistered String sWorkspace Returns Boolean
8120>>>>>        Boolean bRegistered
8120>>>>>        Handle hoIniFile
8120>>>>>        String sVdfRootDir
8120>>>>>        
8120>>>>>        Get Create U_cIniFile to hoIniFile
8121>>>>>        
8121>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8124>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8127>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8128>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
8129>>>>>        
8129>>>>>        Send Destroy of hoIniFile
8130>>>>>        
8130>>>>>        Function_Return bRegistered
8131>>>>>    End_Function
8132>>>>>    
8132>>>>>    Function VdfSystemDfPath Returns String
8134>>>>>        String sSystemDfPath
8134>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
8137>>>>>        
8137>>>>>        Function_Return sSystemDfPath
8138>>>>>    End_Function
8139>>>>>    
8139>>>>>    Function VdfSystemMakePath Returns String
8141>>>>>        String sSystemMakePath
8141>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
8144>>>>>        
8144>>>>>        Function_Return sSystemMakePath
8145>>>>>    End_Function
8146>>>>>    
8146>>>>>    Procedure DoAssignPaths
8148>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
8148>>>>>        
8148>>>>>        Get psDataPath     to sDataPath
8149>>>>>        Get psBitmapPath   to sBitmapPath
8150>>>>>        Get psHelpPath     to sHelpPath
8151>>>>>        Get psProgramPath  to sProgramPath
8152>>>>>        Get psSystemDfPath to sSystemDfPath
8153>>>>>        
8153>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
8154>>>>>        
8154>>>>>    End_Procedure
8155>>>>>    
8155>>>>>    Procedure DoSetPaths
8157>>>>>        // [JVH] must convert paths to Ansi before setting these values
8157>>>>>        // Note- this conversion is temporarily rolled back
8157>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
8157>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
8157>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
8160>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
8163>>>>>    End_Procedure
8164>>>>>    
8164>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
8166>>>>>        String sPath
8166>>>>>        
8166>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
8169>>>>>        Else Begin
8170>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
8171>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
8172>>>>>            Send hmGeneric to hoCallBack ""
8173>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
8174>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
8175>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
8176>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
8177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
8178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
8179>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
8180>>>>>        End
8180>>>>>>
8180>>>>>    End_Procedure
8181>>>>>    
8181>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
8183>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
8183>>>>>        // returns a corresponding message string.
8183>>>>>        String sError
8183>>>>>        
8183>>>>>        Case Begin
8183>>>>>            Case (eErrorCode = wsWorkspaceOpened)
8185>>>>>                Move C_$NoErrors to sError
8186>>>>>                Case Break
8187>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
8190>>>>>                Move C_$NoWsName to sError
8191>>>>>                Case Break
8192>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
8195>>>>>                Move C_$NoWsFileFound to sError
8196>>>>>                Case Break
8197>>>>>            Case (eErrorCode = wsDataPathEmpty)
8200>>>>>                Move C_$NoWsDataPath to sError
8201>>>>>                Case Break
8202>>>>>            Case (eErrorCode = wsFileListEmpty)
8205>>>>>                Move C_$NoWsFileList to sError
8206>>>>>                Case Break
8207>>>>>            Case (eErrorCode = wsFileListNotExist)
8210>>>>>                Move C_$NoFileListCfg to sError
8211>>>>>                Case Break
8212>>>>>            Case Else
8212>>>>>                Move C_$UnknownError to sError
8213>>>>>                Case Break
8214>>>>>        Case End
8214>>>>>        
8214>>>>>        Function_Return (sError-".")
8215>>>>>    End_Function
8216>>>>>    
8216>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
8218>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
8218>>>>>        String sVdfRootDir
8218>>>>>        Handle hoIniFile
8218>>>>>        String sPath
8218>>>>>        String sFileName
8218>>>>>        String sWorkspacePath
8218>>>>>        
8218>>>>>        Move "" to sFileName
8219>>>>>        
8219>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8222>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8225>>>>>        
8225>>>>>        Get Create U_cIniFile to hoIniFile
8226>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8227>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
8228>>>>>        If (sWorkspacePath <>"") Begin
8230>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
8233>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
8234>>>>>        End
8234>>>>>>
8234>>>>>        Send Destroy of hoIniFile
8235>>>>>        
8235>>>>>        Function_Return sFileName
8236>>>>>    End_Function
8237>>>>>    
8237>>>>>    Function CountOfPaths String sPaths Returns Integer
8239>>>>>        // Returns the number of paths defined in a string of paths
8239>>>>>        Integer iChar icChar icPath
8239>>>>>        
8239>>>>>        If (sPaths ="") ;            Function_Return 0
8242>>>>>        
8242>>>>>        Move (Length(sPaths) -1) to icChar
8243>>>>>        For iChar from 1 to icChar
8249>>>>>>
8249>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
8252>>>>>        Loop
8253>>>>>>
8253>>>>>        
8253>>>>>        Function_Return (icPath +1)
8254>>>>>    End_Function
8255>>>>>    
8255>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
8257>>>>>        // Returns the path at the 1-based index of passed paths.
8257>>>>>        // If the path contains a trailing "\", it will be removed
8257>>>>>        Integer iChar icPath iPath iPos
8257>>>>>        String sPath
8257>>>>>        
8257>>>>>        Move (sPaths +";") to sPaths
8258>>>>>        For iPath from 1 to iIndex
8264>>>>>>
8264>>>>>            Move (Pos(";", sPaths)) to iPos
8265>>>>>            If iPos Begin
8267>>>>>                Move (Left(sPaths, iPos -1)) to sPath
8268>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
8271>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
8272>>>>>            End
8272>>>>>>
8272>>>>>            Else ;                Function_Return "" // index past number of paths
8274>>>>>        Loop
8275>>>>>>
8275>>>>>        
8275>>>>>        Function_Return sPath
8276>>>>>    End_Function
8277>>>>>    
8277>>>>>End_Class
8278>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLine.pkg)
8278>>>>>Use VDFBase.pkg
8278>>>>>
8278>>>>>Class cCommandLine is a cObject
8279>>>>>    
8279>>>>>    Procedure Construct_Object
8281>>>>>        Forward Send Construct_Object
8283>>>>>        
8283>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
8284>>>>>    End_Procedure
8285>>>>>    
8285>>>>>    Procedure Private_DoCreateArgsArray
8287>>>>>        // creates the array for holding the arguments. Created upon demand only!
8287>>>>>        Integer icArg
8287>>>>>        String sArg
8287>>>>>        
8287>>>>>        Object oArgs is an Array
8289>>>>>            Delegate Set phoArgs to Self
8291>>>>>            Repeat
8291>>>>>>
8291>>>>>                CmdLine sArg
8292>>>>>>
8292>>>>>                If (sArg <> "") Begin
8294>>>>>                    Increment icArg
8295>>>>>                    Set Value  (icArg -1) to sArg
8296>>>>>                End
8296>>>>>>
8296>>>>>            Until (sArg = "")
8298>>>>>        End_Object
8299>>>>>    End_Procedure
8300>>>>>    
8300>>>>>    Function CountOfArgs Returns Integer
8302>>>>>        //Returns the number of arguments passed
8302>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8305>>>>>        Function_Return (Item_Count(phoArgs(Self)))
8306>>>>>    End_Function
8307>>>>>    
8307>>>>>    Function Argument Integer iIndex Returns String
8309>>>>>        //Returns the one-based argument string
8309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8312>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
8313>>>>>    End_Function
8314>>>>>    
8314>>>>>End_Class
8315>>>>>
8315>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRegistry.pkg)
8315>>>>>Use Dll.pkg
8315>>>>>Use RegistryAPI.pkg
8315>>>>>
8315>>>>>Enum_List // Registry Data types
8315>>>>>    Define rdString
8315>>>>>    Define rdDword
8315>>>>>    Define rdBinary
8315>>>>>    Define rdUnknown
8315>>>>>End_Enum_List
8315>>>>>
8315>>>>>//Prototypes
8315>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
8315>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
8315>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
8315>>>>>Register_Function pbLazyWrite    Returns Boolean // True
8315>>>>>
8315>>>>>Register_Function CountOfSubkeys      Returns Integer
8315>>>>>Register_Function CountOfValues       Returns Integer
8315>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
8315>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
8315>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
8315>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
8315>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
8315>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
8315>>>>>Register_Function LongestDataLength   Returns Integer
8315>>>>>Register_Function LongestSubkeyLength Returns Integer
8315>>>>>Register_Function LongestValueLength  Returns Integer
8315>>>>>Register_Function OpenKey             String sKeyName Returns Integer
8315>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
8315>>>>>Register_Function ReadDword           String sValueName Returns DWord
8315>>>>>Register_Function ReadString          String sValueName Returns String
8315>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
8315>>>>>Register_Function ValueLength         String sValueName Returns Integer
8315>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
8315>>>>>Register_Procedure CloseKey
8315>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
8315>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
8315>>>>>Register_Procedure WriteString        String sValue String sValueData
8315>>>>>
8315>>>>>
8315>>>>>Class cRegistry is a cObject
8316>>>>>    Procedure Construct_Object
8318>>>>>        Forward Send Construct_Object
8320>>>>>        
8320>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
8321>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
8322>>>>>        Property Handle phCurrentKey
8323>>>>>        Property Boolean pbLazyWrite True
8324>>>>>    End_Procedure
8325>>>>>    
8325>>>>>    Function CountOfSubkeys Returns Integer
8327>>>>>        DWord dwCountOfSubkeys
8327>>>>>        Integer iError
8327>>>>>        String sError
8327>>>>>        
8327>>>>>        Move 0 to dwCountOfSubkeys
8328>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
8329>>>>>        If iError Begin
8331>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8332>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8333>>>>>>
8333>>>>>        End
8333>>>>>>
8333>>>>>        Function_Return dwCountOfSubkeys
8334>>>>>    End_Function
8335>>>>>    
8335>>>>>    Function CountOfValues Returns Integer
8337>>>>>        DWord dwCountOfValues
8337>>>>>        Integer iError
8337>>>>>        String sError
8337>>>>>        
8337>>>>>        Move 0 to dwCountOfValues
8338>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
8339>>>>>        If iError Begin
8341>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8342>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8343>>>>>>
8343>>>>>        End
8343>>>>>>
8343>>>>>        
8343>>>>>        Function_Return dwCountOfValues
8344>>>>>    End_Function
8345>>>>>    
8345>>>>>    Function LongestSubkeyLength Returns Integer
8347>>>>>        DWord dwLongestSubkeyLength
8347>>>>>        Integer iError
8347>>>>>        String sError
8347>>>>>        
8347>>>>>        Move 0 to dwLongestSubkeyLength
8348>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
8349>>>>>        If iError Begin
8351>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8352>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8353>>>>>>
8353>>>>>        End
8353>>>>>>
8353>>>>>        
8353>>>>>        Function_Return dwLongestSubkeyLength
8354>>>>>    End_Function
8355>>>>>    
8355>>>>>    Function LongestValueLength Returns Integer
8357>>>>>        DWord dwLongestValueLength
8357>>>>>        Integer iError
8357>>>>>        String sError
8357>>>>>        
8357>>>>>        Move 0 to dwLongestValueLength
8358>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
8359>>>>>        If iError Begin
8361>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8362>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8363>>>>>>
8363>>>>>        End
8363>>>>>>
8363>>>>>        
8363>>>>>        Function_Return dwLongestValueLength
8364>>>>>    End_Function
8365>>>>>    
8365>>>>>    Function LongestDataLength Returns Integer
8367>>>>>        DWord dwLongestDataLength
8367>>>>>        Integer iError
8367>>>>>        String sError
8367>>>>>        
8367>>>>>        Move 0 to dwLongestDataLength
8368>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
8369>>>>>        If iError Begin
8371>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8372>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8373>>>>>>
8373>>>>>        End
8373>>>>>>
8373>>>>>        
8373>>>>>        Function_Return dwLongestDataLength
8374>>>>>    End_Function
8375>>>>>    
8375>>>>>    Function ValueType String sValueName Returns Integer
8377>>>>>        DWord dwType
8377>>>>>        Integer iError eType
8377>>>>>        String sError
8377>>>>>        
8377>>>>>        Move 0 to dwType
8378>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) to iError
8379>>>>>        If iError Begin
8381>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8382>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8383>>>>>>
8383>>>>>        End
8383>>>>>>
8383>>>>>        
8383>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
8386>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
8390>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
8394>>>>>        Else ;            Move rdUnknown to eType
8396>>>>>        
8396>>>>>        Function_Return eType
8397>>>>>    End_Function
8398>>>>>    
8398>>>>>    Function ValueLength String sValueName Returns Integer
8400>>>>>        DWord dwSize
8400>>>>>        Integer iError
8400>>>>>        String sError
8400>>>>>        
8400>>>>>        Move 0 to dwSize
8401>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) to iError
8402>>>>>        If iError Begin
8404>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8405>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8406>>>>>>
8406>>>>>        End
8406>>>>>>
8406>>>>>        
8406>>>>>        Function_Return dwSize
8407>>>>>    End_Function
8408>>>>>    
8408>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
8410>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
8410>>>>>        Handle hKey hKeyOpened
8410>>>>>        Integer iError
8410>>>>>        String sError
8410>>>>>        
8410>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8411>>>>>        
8411>>>>>        Get phRootKey to hKey
8412>>>>>        
8412>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
8413>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8416>>>>>        Else Begin
8417>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8418>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8419>>>>>>
8419>>>>>        End
8419>>>>>>
8419>>>>>        Function_Return iError
8420>>>>>    End_Function
8421>>>>>    
8421>>>>>    Procedure CloseKey
8423>>>>>        Integer iError
8423>>>>>        Handle hKey
8423>>>>>        
8423>>>>>        Get phCurrentKey to hKey
8424>>>>>        
8424>>>>>        If (hKey <>0) Begin
8426>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
8429>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
8431>>>>>            
8431>>>>>            Set phCurrentKey to 0
8432>>>>>        End
8432>>>>>>
8432>>>>>    End_Procedure
8433>>>>>    
8433>>>>>    Function OpenKey String sKeyName Returns Boolean
8435>>>>>        Handle hKey hKeyOpened
8435>>>>>        Integer iError
8435>>>>>        
8435>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8436>>>>>        
8436>>>>>        Get phRootKey to hKey
8437>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8438>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8441>>>>>        
8441>>>>>        Function_Return (iError=0)
8442>>>>>    End_Function
8443>>>>>    
8443>>>>>    Procedure WriteDword String sValue DWord dwValueData
8445>>>>>        Handle hKey
8445>>>>>        Integer iError
8445>>>>>        DWord dwData
8445>>>>>        String sError
8445>>>>>        
8445>>>>>        Move dwValueData to dwData
8446>>>>>        Get phCurrentKey to hKey
8447>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, AddressOf(dwData), SizeOfType(DWord))) to iError
8448>>>>>        If iError Begin
8450>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8451>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8452>>>>>>
8452>>>>>        End
8452>>>>>>
8452>>>>>    End_Procedure
8453>>>>>    
8453>>>>>    Procedure WriteString String sValue String sValueData
8455>>>>>        Handle hKey
8455>>>>>        Integer iError cbData
8455>>>>>        String sError
8455>>>>>        
8455>>>>>        If (sValueData = "") Begin
8457>>>>>            Move (Character(0)) to sValueData
8458>>>>>            Move 1 to cbData
8459>>>>>        End
8459>>>>>>
8459>>>>>        Else Begin
8460>>>>>            Move (Length(sValueData) +1) to cbData
8461>>>>>        End
8461>>>>>>
8461>>>>>        Move (ToAnsi(sValueData)) to sValueData
8462>>>>>        Get phCurrentKey to hKey
8463>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, AddressOf(sValueData), cbData)) to iError
8464>>>>>        If iError Begin
8466>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8467>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8468>>>>>>
8468>>>>>        End
8468>>>>>>
8468>>>>>    End_Procedure
8469>>>>>    
8469>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
8471>>>>>        Handle hKey
8471>>>>>        Integer iError
8471>>>>>        String sError
8471>>>>>        
8471>>>>>        Get phCurrentKey to hKey
8472>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) to iError
8473>>>>>        If iError Begin
8475>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8476>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8477>>>>>>
8477>>>>>        End
8477>>>>>>
8477>>>>>    End_Procedure
8478>>>>>    
8478>>>>>    Function ReadDword String sValueName Returns DWord
8480>>>>>        Handle hKey
8480>>>>>        Integer iError
8480>>>>>        DWord dwValueData dwValueDataLength
8480>>>>>        String sError
8480>>>>>        
8480>>>>>        Move 0           to dwValueData
8481>>>>>        Move (SizeOfType(DWord)) to dwValueDataLength
8482>>>>>        
8482>>>>>        Get phCurrentKey to hKey
8483>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) to iError
8484>>>>>        If iError Begin
8486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8488>>>>>>
8488>>>>>        End
8488>>>>>>
8488>>>>>        
8488>>>>>        Function_Return dwValueData
8489>>>>>    End_Function
8490>>>>>    
8490>>>>>    Function ReadString String sValueName Returns String
8492>>>>>        Handle hKey
8492>>>>>        Integer iError
8492>>>>>        String sValueData
8492>>>>>        DWord dwValueDataLength
8492>>>>>        Pointer lpsValueData
8492>>>>>        String sError
8492>>>>>        
8492>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to sValueData
8493>>>>>        Move (AddressOf(sValueData)) to lpsValueData
8494>>>>>        
8494>>>>>        Move (Length(sValueData)) to dwValueDataLength
8495>>>>>        
8495>>>>>        Get phCurrentKey to hKey
8496>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) to iError
8497>>>>>        If iError Begin
8499>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8500>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8501>>>>>>
8501>>>>>        End
8501>>>>>>
8501>>>>>        
8501>>>>>        Function_Return (ToOem(CString(sValueData)))
8502>>>>>    End_Function
8503>>>>>    
8503>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
8505>>>>>        Handle hKey
8505>>>>>        Integer iError
8505>>>>>        String sError
8505>>>>>        
8505>>>>>        Get phCurrentKey to hKey
8506>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) to iError
8507>>>>>        If iError Begin
8509>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8510>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8511>>>>>>
8511>>>>>        End
8511>>>>>>
8511>>>>>        
8511>>>>>        Function_Return (iDataLength >0)
8512>>>>>    End_Function
8513>>>>>    
8513>>>>>    
8513>>>>>    // Private....
8513>>>>>    Function GetBaseKey Returns Handle
8515>>>>>        Handle hBaseKey
8515>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
8518>>>>>        Else ;            Get phCurrentKey to hBaseKey
8520>>>>>        
8520>>>>>        Function_Return hBaseKey
8521>>>>>    End_Function
8522>>>>>    
8522>>>>>    Function GetKey String sKeyName Returns Handle
8524>>>>>        Handle hKeyOpened
8524>>>>>        Integer iError
8524>>>>>        
8524>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
8525>>>>>        
8525>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8526>>>>>        
8526>>>>>        If (iError =0) ;            Function_Return hKeyOpened
8529>>>>>        Else ;            Function_Return 0
8531>>>>>    End_Function
8532>>>>>    
8532>>>>>    // Public
8532>>>>>    Function KeyExists String sKeyName Returns Boolean
8534>>>>>        Handle hKey
8534>>>>>        Integer iVoid
8534>>>>>        
8534>>>>>        Get GetKey sKeyName to hKey
8535>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
8538>>>>>        Function_Return (hKey <>0)
8539>>>>>    End_Function
8540>>>>>    
8540>>>>>    Function ValueExists String sValueName Returns Boolean
8542>>>>>        // Determines whether a Value exists for the currently-opened Key.
8542>>>>>        Integer iError
8542>>>>>        DWord dwDataType
8542>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
8543>>>>>        
8543>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) to iError
8544>>>>>        
8544>>>>>        Function_Return (iError=0)
8545>>>>>    End_Function
8546>>>>>    
8546>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
8548>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), ToAnsi(sKeyName)) =0)
8549>>>>>    End_Function
8550>>>>>    
8550>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
8552>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), ToAnsi(sValueName)) =0)
8553>>>>>    End_Function
8554>>>>>    
8554>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
8556>>>>>        Integer iError
8556>>>>>        Integer icValue iLongestSubkey
8556>>>>>        Handle hKey
8556>>>>>        DWord dwSubkeyNameLength
8556>>>>>        String sSubkeyName
8556>>>>>        tWinFileTime FileTime
8556>>>>>        tWinFileTime FileTime
8556>>>>>        
8556>>>>>        Get LongestSubkeyLength to iLongestSubkey
8557>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
8558>>>>>        
8558>>>>>        Get phCurrentKey to hKey
8559>>>>>        Repeat
8559>>>>>>
8559>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
8560>>>>>            
8560>>>>>            Move (RegEnumKeyEx(hKey, icValue, AddressOf(sSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
8561>>>>>            If (iError =0) Begin
8563>>>>>                Increment icValue
8564>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sSubkeyName)))
8565>>>>>            End
8565>>>>>>
8565>>>>>        Until (iError)
8567>>>>>        Function_Return icValue
8568>>>>>        
8568>>>>>    End_Function
8569>>>>>    
8569>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
8571>>>>>        Integer iError
8571>>>>>        Integer icValue iLongestValue
8571>>>>>        Handle hKey
8571>>>>>        DWord dwValueNameLength
8571>>>>>        String sValueName sValueNameSize
8571>>>>>        Pointer lpsValueName
8571>>>>>        
8571>>>>>        Get LongestValueLength to iLongestValue
8572>>>>>        Move (Repeat(character(0), iLongestValue +1)) to sValueName
8573>>>>>        Move (AddressOf(sValueName)) to lpsValueName
8574>>>>>        
8574>>>>>        Get phCurrentKey to hKey
8575>>>>>        Repeat
8575>>>>>>
8575>>>>>            Move (iLongestValue +1) to dwValueNameLength
8576>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
8577>>>>>            If (iError =0) Begin
8579>>>>>                Increment icValue
8580>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sValueName)))
8581>>>>>            End
8581>>>>>>
8581>>>>>        Until (iError)
8583>>>>>        Function_Return icValue
8584>>>>>        
8584>>>>>    End_Function
8585>>>>>    
8585>>>>>End_Class
8586>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cVersionInfo.pkg)
8586>>>>>Use VdfBase.pkg
8586>>>>>Use DLL.pkg
8586>>>>>Use tWinStructs.pkg
8586>>>>>Use WinKern.pkg
8586>>>>>
8586>>>>>Define VS_FF_DEBUG         for |CI$00000001
8586>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
8586>>>>>Define VS_FF_PATCHED       for |CI$00000004
8586>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
8586>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
8586>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
8586>>>>>
8586>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
8587>>>>>
8587>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    DWord dwHandle ;    DWord dwLen ;    Address aData ;    Returns Integer
8588>>>>>
8588>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;    Returns Integer
8589>>>>>
8589>>>>>
8589>>>>>Class cVersionInfo is a cObject
8590>>>>>    Procedure Construct_Object
8592>>>>>        Forward Send Construct_Object
8594>>>>>        
8594>>>>>        
8594>>>>>        Property Integer piVersionMajor
8595>>>>>        Property Integer piVersionMinor
8596>>>>>        Property Integer piVersionRelease
8597>>>>>        Property Integer piVersionBuild
8598>>>>>        
8598>>>>>        Property Boolean pbIncluded
8599>>>>>        Property Boolean pbSpecialBuild
8600>>>>>        Property Boolean pbPrivateBuild
8601>>>>>        
8601>>>>>    End_Procedure
8602>>>>>    
8602>>>>>    Procedure DoCreate String sFileName
8604>>>>>        DWord dwHandle
8604>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
8604>>>>>        String sData
8604>>>>>        String sVersionBuffer
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        String sSubBlock
8604>>>>>        Address aVsFixedFileInfo
8604>>>>>        
8604>>>>>        Move 0 to aVsFixedFileInfo
8605>>>>>        Move 0 to dwHandle
8606>>>>>        Move 0 to iVerSize
8607>>>>>        
8607>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
8608>>>>>        Set pbIncluded to (iInfoSize <>0)
8609>>>>>        
8609>>>>>        If (pbIncluded(Self)) Begin
8611>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
8612>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
8613>>>>>            
8613>>>>>            If (iSuccess <>0) Begin
8615>>>>>                Move "\" to sSubBlock
8616>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
8618>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
8619>>>>>                    
8619>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
8620>>>>>                    Set piVersionMajor to (Hi(iVersion))
8621>>>>>                    Set piVersionMinor to (Low(iVersion))
8622>>>>>                    
8622>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
8623>>>>>                    Set piVersionRelease to (Hi(iVersion))
8624>>>>>                    Set piVersionBuild   to (Low(iVersion))
8625>>>>>                    
8625>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
8626>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
8627>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
8628>>>>>                End
8628>>>>>>
8628>>>>>            End
8628>>>>>>
8628>>>>>            
8628>>>>>        End
8628>>>>>>
8628>>>>>    End_Procedure
8629>>>>>    
8629>>>>>End_Class
8630>>>Use GlobalFunctionsProcedures.pkg
8630>>>Use tWinStructs.pkg
8630>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
8630>>>
8630>>>Register_Function phoWorkspace Returns Handle
8630>>>Register_Function phoCommandLine Returns Handle
8630>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8630>>>Register_Function GetApplicationName Returns String
8630>>>Register_Function GetApplicationFileName Returns String
8630>>>
8630>>>Register_Function Statusbar_State Returns Integer
8630>>>Register_Function Toolbar_State Returns Integer
8630>>>Register_Procedure Set Statusbar_State
8630>>>Register_Procedure Set Toolbar_State
8630>>>
8630>>>
8630>>>Class cApplication is a cObject
8631>>>    Procedure Construct_Object
8633>>>        Forward Send Construct_Object
8635>>>        
8635>>>        Move Self to ghoApplication
8636>>>        
8636>>>        Property Handle phoVersionInfo
8637>>>        Property Handle phoWorkspace
8638>>>        Property Handle phoCommandLine
8639>>>        Property Handle phoMainPanel       // main panel will set this for us.
8640>>>        Property String psHelpFile         // type of file is determined by peHelpType
8641>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8642>>>        
8642>>>        Property String psCompany "Data Access Worldwide"
8643>>>        Property String psProduct "DataFlex Applications"
8644>>>        Property String psVersion C_DFVersion
8645>>>        Property String psProgram (Module_Name(desktop))
8646>>>        
8646>>>        // set to '' to stop the auto open workspace behavior
8646>>>        Property String psAutoOpenWorkspace 'Config.ws'
8647>>>        
8647>>>        
8647>>>        Property Boolean pbPreserveEnvironment True
8648>>>        
8648>>>        Object oCommandLine is a cCommandLine
8650>>>            Delegate Set phoCommandLine to Self
8652>>>        End_Object
8653>>>        
8653>>>        Object oWorkspace is a cWorkspace
8655>>>            Delegate Set phoWorkspace to Self
8657>>>        End_Object
8658>>>        
8658>>>        Object oVersionInfo is a cVersionInfo
8660>>>            Delegate Set phoVersionInfo to Self
8662>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
8663>>>        End_Object
8664>>>        
8664>>>        Set pbUseWindowsFont to True
8665>>>        
8665>>>    End_Procedure
8666>>>    
8666>>>    Procedure Destroy_Object
8668>>>        If (ghoApplication=Self) Begin
8670>>>            Move 0 to ghoApplication
8671>>>        End
8671>>>>
8671>>>        Forward Send Destroy_Object
8673>>>    End_Procedure
8674>>>    
8674>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8674>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8674>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8676>>>        Move bNext to gbKEnterNext
8677>>>    End_Procedure
8678>>>    
8678>>>    Function pbEnterKeyAsTabKey Returns Boolean
8680>>>        Function_Return gbKEnterNext
8681>>>    End_Function
8682>>>    
8682>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8684>>>// not used with webapp
8684>>>        Handle hoRegistry hoCommandBars
8684>>>        Handle hMonitor
8684>>>        Integer iError cxy
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        String sKey
8684>>>        Boolean bSuccess
8684>>>        String sObjectName
8684>>>        
8684>>>        If (pbPreserveEnvironment(Self)) Begin
8686>>>            Get Create U_cRegistry to hoRegistry
8687>>>            Set pfAccessRights of hoRegistry to KEY_READ
8688>>>            
8688>>>            Get RegistryKeyString to sKey
8689>>>            
8689>>>            If (bProgram = False) Begin
8691>>>                Move (sKey +"\WINDOWS") to sKey
8692>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8693>>>                Move (sKey +"\" +sObjectName) to sKey
8694>>>            End
8694>>>>
8694>>>            Else ;                Move (sKey + "\Preferences") to sKey
8696>>>            
8696>>>            Get OpenKey of hoRegistry sKey to bSuccess
8697>>>            
8697>>>            If bSuccess Begin
8699>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8701>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8702>>>                    If bSuccess Begin
8704>>>                        // Do not restore size if the window is not resizable
8704>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8706>>>                            // restore always works with outer size
8706>>>                            Get GuiWindowSize     of hoContainer to cxy
8707>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
8708>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8709>>>                        End
8709>>>>
8709>>>                        
8709>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
8709>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
8709>>>                        If (bProgram) Begin
8711>>>                            // Test the top left point
8711>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
8712>>>                            
8712>>>                            If (hMonitor = 0) Begin
8714>>>                                // test the bottom right point
8714>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
8715>>>                            End
8715>>>>
8715>>>                            
8715>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
8715>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
8715>>>                            If (hMonitor = 0) Begin
8717>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
8718>>>                            End
8718>>>>
8718>>>                        End
8718>>>>
8718>>>                        
8718>>>                        // Set the placement
8718>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8719>>>                    End
8719>>>>
8719>>>                End
8719>>>>
8719>>>                If bProgram Begin
8721>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8722>>>                    If not hoCommandBars Begin
8724>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8727>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8730>>>                    End
8730>>>>
8730>>>                End
8730>>>>
8730>>>                
8730>>>                Send CloseKey of hoRegistry
8731>>>            End
8731>>>>
8731>>>            
8731>>>            Send Destroy of hoRegistry
8732>>>        End
8732>>>>
8732>>>    End_Procedure
8733>>>    
8733>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8735>>>// not used with webapp
8735>>>        Handle hoRegistry
8735>>>        Integer iError
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        String sKey
8735>>>        Boolean bSuccess
8735>>>        Integer eShowCmd
8735>>>        String sObjectName
8735>>>        
8735>>>        If (pbPreserveEnvironment(Self)) Begin
8737>>>            Get Create U_cRegistry to hoRegistry
8738>>>            Get RegistryKeyString to sKey
8739>>>            
8739>>>            If (bProgram = False) Begin
8741>>>                Move (sKey +"\WINDOWS") to sKey
8742>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8743>>>                Move (sKey +"\" +sObjectName) to sKey
8744>>>            End
8744>>>>
8744>>>            Else ;                Move (sKey +"\Preferences") to sKey
8746>>>            
8746>>>            Get CreateKey of hoRegistry sKey to iError
8747>>>            If (iError = 0) Begin
8749>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8750>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8751>>>                If bSuccess Begin
8753>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8753>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8755>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8756>>>                    End
8756>>>>
8756>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8757>>>                End
8757>>>>
8757>>>                
8757>>>                If bProgram Begin
8759>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8760>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8761>>>                End
8761>>>>
8761>>>                
8761>>>                
8761>>>                Send CloseKey of hoRegistry
8762>>>            End
8762>>>>
8762>>>            
8762>>>            Send Destroy of hoRegistry
8763>>>        End
8763>>>>
8763>>>    End_Procedure
8764>>>    
8764>>>    
8764>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
8766>>>        Integer ixySize ixSize iySize
8766>>>        Integer ixOffset iyOffset
8766>>>        
8766>>>        // first calculate the offset needed to move onto the main monitor at 0,0
8766>>>        Move (0 - WindowPos.left) to ixOffset
8767>>>        Move (0 - WindowPos.top) to iyOffset
8768>>>        
8768>>>        Move 0 to WindowPos.left
8769>>>        Move 0 to WindowPos.top
8770>>>        
8770>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
8771>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
8772>>>        
8772>>>        // also make sure that the size of the window is <= the size of the main monitor
8772>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
8773>>>        Move (low(ixySize))      to ixSize
8774>>>        Move (hi(ixySize))       to iySize
8775>>>        
8775>>>        Move (ixSize min WindowPos.right) to WindowPos.right
8776>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
8777>>>    End_Procedure
8778>>>    
8778>>>    
8778>>>    Function RegistryKeyString Returns String
8780>>>        String sCompany sProduct sVersion sProgram
8780>>>        
8780>>>        Get psCompany to sCompany
8781>>>        Get psProduct to sProduct
8782>>>        Get psVersion to sVersion
8783>>>        Get psProgram to sProgram
8784>>>        
8784>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
8787>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
8790>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
8793>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
8796>>>        
8796>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8797>>>    End_Function
8798>>>    
8798>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8800>>>        String sKey
8800>>>        Handle hoRegistry
8800>>>        Integer iError
8800>>>        
8800>>>        Get Create U_cRegistry to hoRegistry
8801>>>        Get RegistryKeyString to sKey
8802>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8805>>>        Get CreateKey of hoRegistry sKey to iError
8806>>>        If (iError = 0) Begin
8808>>>            Send WriteString of hoRegistry sValueName sValueData
8809>>>            Send CloseKey of hoRegistry
8810>>>        End
8810>>>>
8810>>>        
8810>>>        Send Destroy of hoRegistry
8811>>>    End_Procedure
8812>>>    Procedure WriteDword String sSubKey String sValueName DWord dwValueData
8814>>>        String sKey
8814>>>        Handle hoRegistry
8814>>>        Integer iError
8814>>>        
8814>>>        Get Create U_cRegistry to hoRegistry
8815>>>        Get RegistryKeyString to sKey
8816>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8819>>>        Get CreateKey of hoRegistry sKey to iError
8820>>>        If (iError = 0) Begin
8822>>>            Send WriteDword of hoRegistry sValueName dwValueData
8823>>>            Send CloseKey of hoRegistry
8824>>>        End
8824>>>>
8824>>>        
8824>>>        Send Destroy of hoRegistry
8825>>>    End_Procedure
8826>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
8828>>>        String sKey
8828>>>        Handle hoRegistry
8828>>>        Integer iError
8828>>>        
8828>>>        Get Create U_cRegistry to hoRegistry
8829>>>        Get RegistryKeyString to sKey
8830>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8833>>>        Get CreateKey of hoRegistry sKey to iError
8834>>>        If (iError = 0) Begin
8836>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
8837>>>            Send CloseKey of hoRegistry
8838>>>        End
8838>>>>
8838>>>        
8838>>>        Send Destroy of hoRegistry
8839>>>    End_Procedure
8840>>>    
8840>>>    // returns true if both sub-key and value exists.
8840>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
8842>>>        String sKey
8842>>>        Handle hoRegistry
8842>>>        Boolean bOK
8842>>>        Get Create U_cRegistry to hoRegistry
8843>>>        Get RegistryKeyString to sKey
8844>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8847>>>        Get OpenKey of hoRegistry sKey to bOk
8848>>>        If (bOK) Begin
8850>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
8851>>>            Send CloseKey of hoRegistry
8852>>>        End
8852>>>>
8852>>>        Send Destroy of hoRegistry
8853>>>        Function_Return bOk
8854>>>    End_Function
8855>>>    
8855>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
8857>>>        String sKey sData
8857>>>        Handle hoRegistry
8857>>>        Boolean bOK
8857>>>        
8857>>>        Move sDefault to sData
8858>>>        Get Create U_cRegistry to hoRegistry
8859>>>        Get RegistryKeyString to sKey
8860>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8863>>>        Get OpenKey of hoRegistry sKey to bOk
8864>>>        If (bOK) Begin
8866>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
8869>>>            Send CloseKey of hoRegistry
8870>>>        End
8870>>>>
8870>>>        
8870>>>        Send Destroy of hoRegistry
8871>>>        Function_Return sData
8872>>>    End_Function
8873>>>    
8873>>>    Function ReadDword String sSubKey String sValueName DWord dwDefault Returns DWord
8875>>>        String sKey
8875>>>        DWord dwData
8875>>>        Handle hoRegistry
8875>>>        Boolean bOK
8875>>>        
8875>>>        Move dwDefault to dwData
8876>>>        Get Create U_cRegistry to hoRegistry
8877>>>        Get RegistryKeyString to sKey
8878>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8881>>>        Get OpenKey of hoRegistry sKey to bOk
8882>>>        If bOK Begin
8884>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName to dwData
8887>>>            Send CloseKey of hoRegistry
8888>>>        End
8888>>>>
8888>>>        
8888>>>        Send Destroy of hoRegistry
8889>>>        Function_Return dwData
8890>>>    End_Function
8891>>>    
8891>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
8893>>>        String sKey
8893>>>        Handle hoRegistry
8893>>>        Boolean bOK bSuccess
8893>>>        
8893>>>        Get Create U_cRegistry to hoRegistry
8894>>>        Get RegistryKeyString to sKey
8895>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8898>>>        Get OpenKey of hoRegistry sKey to bOk
8899>>>        If bOK Begin
8901>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength to bSuccess
8902>>>            Send CloseKey of hoRegistry
8903>>>        End
8903>>>>
8903>>>        
8903>>>        Send Destroy of hoRegistry
8904>>>        Function_Return bSuccess
8905>>>    End_Function
8906>>>    
8906>>>    Procedure DoOpenWorkspace String sWorkspace
8908>>>        // Tries to open in this order:
8908>>>        // 1) if absolute path, use that; otherwise
8908>>>        // 2) try to open in the path of the EXE; otherwise
8908>>>        // 3) load it via the Registered list
8908>>>        
8908>>>        Integer eOpened
8908>>>        String sError sWSFile
8908>>>        Handle hoWorkspace
8908>>>        Boolean bChangingWorkspace
8908>>>        
8908>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
8908>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
8908>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
8908>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
8908>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
8908>>>        // that there should be no automatic opening of a worskpace.
8908>>>        Set psAutoOpenWorkspace to ""
8909>>>        
8909>>>        Get phoWorkspace to hoWorkspace
8910>>>        
8910>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
8911>>>        If (bChangingWorkspace and ghoConnection) Begin
8913>>>            Send AutoDisconnect
8914>>>        End
8914>>>>
8914>>>        
8914>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
8915>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
8917>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
8919>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
8920>>>            End
8920>>>>
8920>>>        End
8920>>>>
8920>>>        If (eOpened <> wsWorkspaceOpened) Begin
8922>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
8923>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
8924>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
8925>>>>
8925>>>            Abort
8926>>>>
8926>>>        End
8926>>>>
8926>>>        Else Begin
8927>>>            Send AutoConnect
8928>>>            Send OnWorkspaceOpened
8929>>>        End
8929>>>>
8929>>>    End_Procedure
8930>>>    
8930>>>    Procedure AutoConnect
8932>>>        If (ghoConnection) Begin
8934>>>            Send AutoConnect of ghoConnection
8935>>>        End
8935>>>>
8935>>>    End_Procedure
8936>>>    
8936>>>    Procedure AutoDisconnect
8938>>>        If (ghoConnection) Begin
8940>>>            Send AutoDisconnect of ghoConnection
8941>>>        End
8941>>>>
8941>>>    End_Procedure
8942>>>    
8942>>>    // send after a workspace is successfully opened and connected
8942>>>    Procedure OnWorkspaceOpened
8944>>>    End_Procedure
8945>>>    
8945>>>    Procedure OnCreate
8947>>>        // Event called when the Application object is ready to be used
8947>>>        // to open a Workspace, etc.
8947>>>    End_Procedure
8948>>>    
8948>>>    Procedure End_Construct_Object
8950>>>        String sName
8950>>>        Forward Send End_Construct_Object
8952>>>        Send OnCreate
8953>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
8953>>>        Get psAutoOpenWorkspace to sName
8954>>>        If (sName<>"") Begin
8956>>>            Send DoOpenWorkspace sName
8957>>>        End
8957>>>>
8957>>>    End_Procedure
8958>>>    
8958>>>    Function GetApplicationFileName Returns String
8960>>>        // Returns the filename from Windows
8960>>>        Integer iNumChars
8960>>>        String sFilename
8960>>>        
8960>>>        Move (Repeat(Character(0), 1024)) to sFileName
8961>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) to iNumChars
8962>>>        
8962>>>        Function_Return (CString(sFilename))
8963>>>    End_Function
8964>>>    
8964>>>    Function GetApplicationPath Returns String
8966>>>        // Returns the path of the Application (no trailing "\")
8966>>>        String sApplicationFileName sPath
8966>>>        Boolean bRemoved
8966>>>        
8966>>>        Get GetApplicationFileName  to sApplicationFileName
8967>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
8968>>>        Move (CString(sApplicationFileName)) to sPath
8969>>>        
8969>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8972>>>        Function_Return sPath
8973>>>    End_Function
8974>>>    
8974>>>    Function GetApplicationName Returns String
8976>>>        // Returns the name of the Application (without its Path or Extension)
8976>>>        String sApplicationFileName sApplicationName
8976>>>        Boolean bRemoved
8976>>>        Integer iVoid
8976>>>        
8976>>>        Get GetApplicationFileName to sApplicationFileName
8977>>>        Move (ExtractFileName(sApplicationFileName)) to sApplicationName
8978>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) to iVoid
8979>>>        Function_Return (CString(sApplicationName))
8980>>>    End_Function
8981>>>    
8981>>>    Function DFRootPath Returns String
8983>>>        String sRoot
8983>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
8986>>>        // Ensure it does not contain a trailing "\"
8986>>>        If (Right(sRoot,1) = "\") Begin
8988>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
8989>>>        End
8989>>>>
8989>>>        Function_Return sRoot
8990>>>    End_Function
8991>>>    
8991>>>    Function DFBinPath Returns String
8993>>>        String sRoot
8993>>>        Get DFRootPath to sRoot
8994>>>        If (sRoot<>"") Begin
8996>>>            Move (sRoot+"\bin") to sRoot
8997>>>        End
8997>>>>
8997>>>        Else Begin
8998>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
8998>>>            // bin path must be the same as the application path.
8998>>>            Get GetApplicationPath to sRoot
8999>>>        End
8999>>>>
8999>>>        Function_Return sRoot
9000>>>    End_Function
9001>>>    
9001>>>    // this just directs to the desktop property. If you are using an application object you are
9001>>>    // encouraged to set this here.
9001>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
9003>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
9004>>>    End_Procedure
9005>>>    
9005>>>    Function pbUseWindowsFont Returns Boolean
9007>>>        Boolean bUseWindowsFont
9007>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
9008>>>        Function_Return bUseWindowsFont
9009>>>    End_Function
9010>>>    
9010>>>    // this just directs to the desktop property. If you are using an application object you are
9010>>>    // encouraged to set this here.
9010>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
9012>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
9013>>>    End_Procedure
9014>>>    
9014>>>    Function pbLegacyDialogRatio Returns Boolean
9016>>>        Boolean bLegacy
9016>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
9017>>>        Function_Return bLegacy
9018>>>    End_Function
9019>>>End_Class
9020>>>
9020>>>
9020>Use seq_chnl.pkg
9020>Use vwin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vwin32fh.pkg)
9020>>>// This code is part of VDF GUIdance
9020>>>// Visit us @ http://www.vdf-guidance.com
9020>>>// e-Mail us @ info@vdf-guidance.com
9020>>>// VDF GUIdance is a mutual project of
9020>>>// Frank Vandervelpen - Vandervelpen Systems and
9020>>>// Wil van Antwerpen  - Antwise Solutions
9020>>>// All software source code should be used <<AS IS>> without any warranty.
9020>>>//
9020>>>//
9020>>>// *** Windows 32bit file handling wrapper class ***
9020>>>//
9020>>>
9020>>>
9020>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
Including file: File_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\File_dlg.pkg)
9020>>>>>Use Windows.pkg
9020>>>>>Use GlobalFunctionsProcedures.pkg
9020>>>>>
9020>>>>>External_Function GetOpenFileName "GetOpenFileNameA" Comdlg32.DLL Pointer OpenStruct Returns Integer
9021>>>>>External_Function GetSaveFileName "GetSaveFileNameA" Comdlg32.DLL Pointer OpenStruct Returns Integer
9022>>>>>
9022>>>>>Struct TOpenFileName
9022>>>>>    DWord    lStructSize          // length, in bytes, of the structure.
9022>>>>>    Handle   hwndOwner            // Handle to the window that owns the dialog box.
9022>>>>>    Handle   hInstance            // handle to a memory object containing a dialog box template.
9022>>>>>    Pointer  lpstrFilter          // pointer to a buffer containing pairs of null-terminated filter strings.
9022>>>>>    Pointer  lpstrCustomFilter    // Pointer to a static buffer that contains a pair of null-terminated filter strings for preserving the filter pattern chosen by the user.
9022>>>>>    DWord    nMaxCustFilter       // size, in chars, of the buffer identified by lpstrCustomFilter.
9022>>>>>    DWord    nFilterIndex         // index of the currently selected filter
9022>>>>>    Pointer  lpstrFile            // Pointer to a buffer that contains the file name(s)
9022>>>>>    DWord    nMaxFile             // Size, in CHARs, of the buffer pointed to by lpstrFile.
9022>>>>>    Pointer  lpstrFileTitle       // Pointer to a buffer that receives the file name and extension
9022>>>>>    DWord    nMaxFileTitle        // size, in CHARs, of the buffer pointed to by lpstrFileTitle
9022>>>>>    Pointer  lpstrInitialDir      // Pointer to a NULL terminated string that can specify the initial directory.
9022>>>>>    Pointer  lpstrTitle           // Pointer to a string to be placed in the title bar of the dialog box.
9022>>>>>    DWord    ofnFlags             // set of bit flags you can use to initialize the dialog box.
9022>>>>>    Short    nFileOffset          // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name in the string pointed to by lpstrFile.
9022>>>>>    Short    nFileExtension       // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name extension in the string pointed to by lpstrFile.
9022>>>>>    Pointer  lpstrDefExt          // Pointer to a buffer that contains the default extension.
9022>>>>>    Longptr  lCustData            // Specifies application-defined data that the system passes to the hook procedure identified by the lpfnHook member.
9022>>>>>    Pointer  lpfnHook             // Pointer to a hook procedure.
9022>>>>>    Pointer  lpTemplateName       // Pointer to a null-terminated string that names a dialog template resource in the module identified by the hInstance member.
9022>>>>>    Pointer  lpvReserved          // Reserved
9022>>>>>    DWord    dwReserved           // Reserved
9022>>>>>    DWord    FlagsEx              // A set of bit flags you can use to initialize the dialog box.
9022>>>>>End_Struct
9022>>>>>
9022>>>>>
9022>>>>>Class AbstractFileDialog is a cObject
9023>>>>>    
9023>>>>>    Procedure Construct_Object
9025>>>>>        Forward Send Construct_Object
9027>>>>>        
9027>>>>>        Property String  Filter_String
9028>>>>>        Property String  Initial_Folder
9029>>>>>        Property String  File_Name
9030>>>>>        Property String  File_Title
9031>>>>>        Property String  Dialog_Caption
9032>>>>>        Property Integer Filter_Index          1
9033>>>>>        Property Integer HideReadOnly_State    False
9034>>>>>        Property Integer TickReadOnly_State    False
9035>>>>>        Property Integer AllowReadOnly_State   True
9036>>>>>        Property Integer FileMustExist_State   True
9037>>>>>        Property Integer PathMustExist_State   True
9038>>>>>        Property Integer CreatePrompt_State    True
9039>>>>>        Property Integer ShowFileTitle_State   False
9040>>>>>        Property Integer OverwritePrompt_State False
9041>>>>>        Property Integer NoChangeDir_State     False
9042>>>>>        
9042>>>>>        Property Boolean Private_MultiSelect_State False
9043>>>>>        
9043>>>>>        Property String[] Private_Selected_Files
9044>>>>>        
9044>>>>>        Property Integer PrivateExternal_msg
9045>>>>>        
9045>>>>>        //Set Focus_Mode To No_Activate
9045>>>>>    End_Procedure
9046>>>>>    
9046>>>>>    Function OwnerHandle Returns Handle
9048>>>>>        Handle hWnd
9048>>>>>        Handle hoObj
9048>>>>>        Get Focus of desktop to hoObj // start with the focus
9049>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
9050>>>>>        Function_Return hWnd
9051>>>>>    End_Function
9052>>>>>    
9052>>>>>    
9052>>>>>    Function Show_Dialog Returns Integer // bool
9054>>>>>        Handle hWnd
9054>>>>>        Integer bOK iFilter iFlags bHideRO bTickRO bFileExist bPathExist iMsg
9054>>>>>        Integer icInitDir bCreatePrompt bOverwritePrompt bAllowReadOnly
9054>>>>>        Integer iPos iCount
9054>>>>>        Integer bNoChangeDir
9054>>>>>        Pointer lpsFileTitle lpsFileName lpsFilter lpsInitDir
9054>>>>>        Pointer lpsTitle lpsDefExt
9054>>>>>        String sFileName sFileTitle sFilter sInitDir sTitle sDefExt
9054>>>>>        Pointer lpOpenFileData
9054>>>>>        Boolean bMultiSelect
9054>>>>>        String[] sFiles
9055>>>>>        TOpenFileName OpenFileData
9055>>>>>        TOpenFileName OpenFileData
9055>>>>>        
9055>>>>>        //Delegate Get Container_Handle To hWnd
9055>>>>>        Get OwnerHandle to hWnd
9056>>>>>        
9056>>>>>        If (ShowFileTitle_State(Self)) Begin
9058>>>>>            Get File_Title to sFileName
9059>>>>>        End
9059>>>>>>
9059>>>>>        
9059>>>>>        Get private_MultiSelect_State to bMultiSelect
9060>>>>>        
9060>>>>>        Get Initial_Folder        to sInitDir
9061>>>>>        Get Dialog_Caption        to sTitle
9062>>>>>        Get Filter_String         to sFilter
9063>>>>>        Get HideReadOnly_State    to bHideRO
9064>>>>>        Get TickReadOnly_State    to bTickRO
9065>>>>>        Get FileMustExist_State   to bFileExist
9066>>>>>        Get PathMustExist_State   to bPathExist
9067>>>>>        Get CreatePrompt_State    to bCreatePrompt
9068>>>>>        Get OverwritePrompt_State to bOverwritePrompt
9069>>>>>        Get AllowReadOnly_State   to bAllowReadOnly
9070>>>>>        Get NoChangeDir_State     to bNoChangeDir
9071>>>>>        Get Filter_Index          to iFilter
9072>>>>>        
9072>>>>>        Move (sFilter + Character(0) + Character(0)) to sFilter
9073>>>>>        Move (ToAnsi(sFilter)) to sFilter
9074>>>>>        Move (Replaces('|', sFilter, Character(0))) to sFilter
9075>>>>>        
9075>>>>>        Append sInitDir   (character(0))
9076>>>>>        Append sFileTitle (Repeat(character(0),32000))
9077>>>>>        Append sFileName  (Repeat(character(0),32000))
9078>>>>>        Append sTitle     (Repeat(character(0),255))
9079>>>>>        Append sDefExt    (character(0))
9080>>>>>        
9080>>>>>        Move (ToAnsi(sInitDir)) to sInitDir
9081>>>>>        Move (ToAnsi(sFileName)) to sFileName
9082>>>>>        Move (ToAnsi(sTitle)) to sTitle
9083>>>>>        
9083>>>>>        Move (AddressOf(sInitDir))   to lpsInitDir
9084>>>>>        Move (AddressOf(sFileName))  to lpsFileName
9085>>>>>        Move (AddressOf(sFileTitle)) to lpsFileTitle
9086>>>>>        Move (AddressOf(sTitle))     to lpsTitle
9087>>>>>        Move (AddressOf(sDefExt))    to lpsDefExt
9088>>>>>        Move (AddressOf(sFilter))    to lpsFilter
9089>>>>>        
9089>>>>>        
9089>>>>>        If (bMultiSelect) Begin
9091>>>>>            Move (OFN_EXPLORER + OFN_ALLOWMULTISELECT) to iFlags  // Multi-select!
9092>>>>>        End
9092>>>>>>
9092>>>>>        
9092>>>>>        If bFileExist ;            Move (iFlags + OFN_FILEMUSTEXIST)    to iFlags
9095>>>>>        If bPathExist ;            Move (iFlags + OFN_PATHMUSTEXIST)    to iFlags
9098>>>>>        If bHideRO ;            Move (iFlags + OFN_HIDEREADONLY)     to iFlags
9101>>>>>        If bTickRO ;            Move (iFlags + OFN_READONLY)         to iFlags
9104>>>>>        If bCreatePrompt ;            Move (iFlags + OFN_CREATEPROMPT)     to iFlags
9107>>>>>        If bOverwritePrompt ;            Move (iFlags + OFN_OVERWRITEPROMPT)  to iFlags
9110>>>>>        If not bAllowReadOnly ;            Move (iFlags + OFN_NOREADONLYRETURN) to iFlags
9113>>>>>        If bNoChangeDir ;            Move (iFlags + OFN_NOCHANGEDIR)      to iFlags
9116>>>>>        
9116>>>>>        Move (SizeOfType(TOpenFileName)) to OpenFileData.lStructSize
9117>>>>>        Move hWnd         to OpenFileData.hWndOwner
9118>>>>>        Move iFilter      to OpenFileData.nFilterIndex
9119>>>>>        Move lpsFileName  to OpenFileData.lpstrFile
9120>>>>>        
9120>>>>>        If (sInitDir <> '') Begin
9122>>>>>            Move lpsInitDir    to OpenFileData.lpstrInitialDir
9123>>>>>        End
9123>>>>>>
9123>>>>>        
9123>>>>>        If (sTitle <> '') Begin
9125>>>>>            Move lpsTitle      to OpenFileData.lpstrTitle
9126>>>>>        End
9126>>>>>>
9126>>>>>        
9126>>>>>        Move 32000             to OpenFileData.nMaxFileTitle
9127>>>>>        Move 32000             to OpenFileData.nMaxFile
9128>>>>>        Move lpsFileTitle      to OpenFileData.lpstrFileTitle
9129>>>>>        Move iFlags            to OpenFileData.ofnFlags
9130>>>>>        Move lpsFilter         to OpenFileData.lpstrFilter
9131>>>>>        Move lpsDefExt         to OpenFileData.lpstrDefExt
9132>>>>>        
9132>>>>>        Move (AddressOf(OpenFileData)) to lpOpenFileData
9133>>>>>        
9133>>>>>        Get PrivateExternal_msg to iMsg
9134>>>>>        If (iMsg = Get_GetOpenFileName) ;            Move (GetOpenFileName(lpOpenFileData)) to bOK
9137>>>>>        If (iMsg = Get_GetSaveFileName) ;            Move (GetSaveFileName(lpOpenFileData)) to bOK
9140>>>>>        
9140>>>>>        If bOK Begin
9142>>>>>            Move OpenFileData.ofnFlags     to iFlags
9143>>>>>            Move OpenFileData.nFilterIndex to iFilter
9144>>>>>            Move OpenFileData.nFileOffset  to icInitDir
9145>>>>>            
9145>>>>>            Move (CString(Left(sFileName, icInitDir))) to sInitDir    // Trim trailing null
9146>>>>>            Set Initial_Folder     to (ToOEM(sInitDir))
9147>>>>>            
9147>>>>>            Set TickReadOnly_State to (iFlags iand OFN_READONLY)
9148>>>>>            Set Filter_Index       to iFilter
9149>>>>>            // Note that ToOEM only converts up to first null
9149>>>>>            Set File_Name          to (CString(ToOEM( sFileName )))
9150>>>>>            Set File_Title         to (CString(ToOEM( sFileTitle )))
9151>>>>>            
9151>>>>>            If (bMultiSelect) Begin
9153>>>>>                // If this is a multi-files dialog then parse out the array of selected files....
9153>>>>>                If (Right(sInitDir, 1) = "\") ;                    Move (Left(sInitDir, Length(sInitDir)-1)) to sInitDir     // Trim trailing :\". This is only there if 1 file was selected!
9156>>>>>                
9156>>>>>                // Get the null delimited string of file names into the sFiles array....
9156>>>>>                Move 0 to iCount
9157>>>>>                Move (Right(sFileName, Length(sFileName) - icInitDir)) to sFileName    // Strip the path info (we already have it)
9158>>>>>                
9158>>>>>                Repeat
9158>>>>>>
9158>>>>>                    // Get the next filename....
9158>>>>>                    Move (Pos(Character(0), sFileName)) to iPos   // Filenames are null delimeted
9159>>>>>                    
9159>>>>>                    If (iPos > 1) Begin
9161>>>>>                        Move (sInitDir + "\" + CString(Left(sFileName, iPos))) to sFiles[iCount]
9162>>>>>                        Move (ToOEM(sFiles[iCount])) to sFiles[iCount]
9163>>>>>                        Move (Right(sFileName, Length(sFileName) - iPos)) to sFileName
9164>>>>>                        Increment iCount
9165>>>>>                    End
9165>>>>>>
9165>>>>>                Until (iPos <= 1)
9167>>>>>            End
9167>>>>>>
9167>>>>>            Else Begin
9168>>>>>                Move (CString(ToOEM( sFileName ))) to sFiles[0]
9169>>>>>            End
9169>>>>>>
9169>>>>>            
9169>>>>>            Set private_Selected_Files to sFiles
9170>>>>>        End
9170>>>>>>
9170>>>>>        Function_Return (bOK)
9171>>>>>    End_Function
9172>>>>>End_Class
9173>>>>>
9173>>>>>Class OpenDialog is an AbstractFileDialog
9174>>>>>    Procedure Construct_Object
9176>>>>>        Forward Send Construct_Object
9178>>>>>        Set PrivateExternal_msg to get_GetOpenFileName
9179>>>>>    End_Procedure
9180>>>>>    
9180>>>>>    Procedure Set MultiSelect_State Boolean bState
9182>>>>>        Set private_MultiSelect_State to bState
9183>>>>>    End_Procedure
9184>>>>>    
9184>>>>>    Function MultiSelect_State Returns Boolean
9186>>>>>        Boolean bState
9186>>>>>        Get private_MultiSelect_State to bState
9187>>>>>        Function_Return bState
9188>>>>>    End_Function
9189>>>>>    
9189>>>>>    Function Selected_Files Returns String[]
9191>>>>>        String[] sFiles
9192>>>>>        Get private_Selected_Files to sFiles
9193>>>>>        Function_Return sFiles
9194>>>>>    End_Function
9195>>>>>End_Class
9196>>>>>
9196>>>>>Class SaveAsDialog is an AbstractFileDialog
9197>>>>>    Procedure Construct_Object
9199>>>>>        Forward Send Construct_Object
9201>>>>>        Set FileMustExist_State   to False
9202>>>>>        Set CreatePrompt_State    to False
9203>>>>>        Set ShowFileTitle_State   to True
9204>>>>>        Set OverwritePrompt_State to True
9205>>>>>        Set HideReadOnly_State    to True
9206>>>>>        Set PrivateExternal_msg to get_GetSaveFileName
9207>>>>>    End_Procedure
9208>>>>>End_Class
9209>>>>>
9209>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\cvFileDialogs.pkg)
9209>>>>>//***************************************************************************
9209>>>>>//*
9209>>>>>//* Class:        cvSaveAsDialog
9209>>>>>//* Package Name: cvFileDialogs.pkg
9209>>>>>//*
9209>>>>>//***************************************************************************
9209>>>>>
9209>>>>>Use File_dlg.pkg
9209>>>>>
9209>>>>>// *WvA: 13-01-1999 Created
9209>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
9209>>>>>// This function opens the Windows standard file open dialog and returns the selected
9209>>>>>// file_name.
9209>>>>>Class cvSelectFile_Dialog is an OpenDialog
9210>>>>>
9210>>>>>    Procedure Construct_Object Integer iImage_Id
9212>>>>>        Forward Send Construct_Object iImage_Id
9214>>>>>        Set HideReadOnly_State to True
9215>>>>>    End_Procedure
9216>>>>>
9216>>>>>    Function SelectedFileName Returns String
9218>>>>>        String sFileName
9218>>>>>        Move "" to sFileName
9219>>>>>        If (Show_Dialog(Self)) Begin
9221>>>>>            Move (RTrim(File_Name(Self))) to sFileName
9222>>>>>        End
9222>>>>>>
9222>>>>>        Function_Return sFileName
9223>>>>>    End_Function
9224>>>>>End_Class
9225>>>>>
9225>>>>>// *WvA: 13-01-1999 Created
9225>>>>>// This function opens the Windows standard file open dialog and returns the selected
9225>>>>>// file_name. Returns '' if the user didn't make a selection.
9225>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
9225>>>>>//                   file-open dialog
9225>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
9227>>>>>    String sSelectedFile
9227>>>>>    Integer hoOpenFileDialog
9227>>>>>
9227>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
9229>>>>>
9229>>>>>        Set Dialog_Caption    to sCaptionText
9230>>>>>        Set Filter_String     to sSupportedFileTypes
9231>>>>>        Set Initial_Folder    to sInitialFolder
9232>>>>>
9232>>>>>        Move Self       to hoOpenFileDialog
9233>>>>>    End_Object
9234>>>>>
9234>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
9235>>>>>    Send Destroy_Object to hoOpenFileDialog
9236>>>>>    Function_Return sSelectedFile
9237>>>>>End_Function
9238>>>>>
9238>>>>>Class cvSaveAsDialog is a SaveAsDialog
9239>>>>>
9239>>>>>    Procedure Construct_Object
9241>>>>>        Forward Send Construct_Object
9243>>>>>        Set HideReadOnly_State to True
9244>>>>>    End_Procedure
9245>>>>>
9245>>>>>    Function SelectedFileName Returns String
9247>>>>>        String sFileName
9247>>>>>        Move "" to sFileName
9248>>>>>        If (Show_Dialog(Self)) Begin
9250>>>>>            Move (RTrim(File_Name(Self))) to sFileName
9251>>>>>        End
9251>>>>>>
9251>>>>>        Function_Return sFileName
9252>>>>>    End_Function
9253>>>>>
9253>>>>>End_Class
9254>>>>>
9254>>>>>// Added optional default filename as suggested by Nils
9254>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
9256>>>>>    String sSelectedFile
9256>>>>>    Integer hoDialog
9256>>>>>
9256>>>>>    Move "" to sSelectedFile
9257>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
9258>>>>>    If (hoDialog) Begin
9260>>>>>    //Set NoChangeDir_State Of hoDialog To True
9260>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
9261>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
9262>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
9263>>>>>        If (Num_Arguments = 4) Begin
9265>>>>>            Set File_Title        of hoDialog to sDefaultFileName
9266>>>>>        End
9266>>>>>>
9266>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
9267>>>>>        Send Destroy of hoDialog
9268>>>>>    End
9268>>>>>>
9268>>>>>    Function_Return sSelectedFile
9269>>>>>End_Function
9270>>>Use Seq_chnl.pkg
9270>>>
9270>>>Use windows.pkg
9270>>>Use Dll.pkg
9270>>>
9270>>>Use vWin32fhA.pkg     // WinAPI ANSI legacy interface
Including file: vwin32fhA.pkg    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vwin32fhA.pkg)
9270>>>>>// This code is part of VDF GUIdance
9270>>>>>// Visit us @ http://www.vdf-guidance.com
9270>>>>>// e-Mail us @ info@vdf-guidance.com
9270>>>>>// VDF GUIdance is a mutual project of
9270>>>>>// Frank Vandervelpen - Vandervelpen Systems and
9270>>>>>// Wil van Antwerpen  - Antwise Solutions
9270>>>>>// All software source code should be used <<AS IS>> without any warranty.
9270>>>>>//
9270>>>>>//
9270>>>>>// *** Windows 32bit file handling wrapper class ***
9270>>>>>// ANSI variant
9270>>>>>
9270>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
9270>>>>>//                   This may be painfull for some of you, but it was really needed as it was
9270>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
9270>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
9270>>>>>//
9270>>>>>// The used naming-convention is:
9270>>>>>//     - a prefix of "vWin32_" for every external function declaration
9270>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
9270>>>>>//
9270>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
9270>>>>>// of DataAccess in the future.
9270>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
9270>>>>>//
9270>>>>>// mm-dd-yyyy Author Description
9270>>>>>//
9270>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
9270>>>>>//                   vGetWindowsDirectory
9270>>>>>//
9270>>>>>//                   vGetTempFileName
9270>>>>>//                   vGetTempPath
9270>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
9270>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
9270>>>>>//                   error in your application anyways. Changed this for:
9270>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
9270>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
9270>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
9270>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
9270>>>>>//                   It is renamed too avoid this.
9270>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
9270>>>>>//                   function vSelectedFileName is now just SelectedFileName
9270>>>>>//                   Removed the local keyword in the variable declarations
9270>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
9270>>>>>//                   created file-open dialog
9270>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
9270>>>>>//                   in that it didn't exactly return the correct filename of the file created.
9270>>>>>//                   This has now been taken care of.
9270>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
9270>>>>>//                   These declarations are now included from the vWin32fh header file.
9270>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
9270>>>>>//                   Before today one could always undo the operation, as of now you cannot as
9270>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
9270>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
9270>>>>>//                   One can however restore to the old way of handling by simply calling the
9270>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
9270>>>>>//                   filehandling operations
9270>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
9270>>>>>//                   as well as the StringFromRightOfChar function.
9270>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
9270>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
9270>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
9270>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
9270>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
9270>>>>>//                   extended characters are treated ok too.
9270>>>>>//                   Reported by Flemming from
9270>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
9270>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
9270>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
9270>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
9270>>>>>//                   Added vSelectSavefile function to create a file save dialog
9270>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
9270>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
9270>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
9270>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
9270>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
9270>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
9270>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
9270>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
9270>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
9270>>>>>
9270>>>>>Use vWin32fhA.h       // Header file with WinAPI ANSI declarations
Including file: vwin32fhA.h    (C:\Projects\DF18\DfRefactor\Libraries\vwin32fh\vwin32fhA.h)
9270>>>>>>>//TH-Header
9270>>>>>>>//*****************************************************************************************
9270>>>>>>>// Copyright (c)  2004 KURANT Project
9270>>>>>>>// All rights reserved.
9270>>>>>>>//
9270>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
9270>>>>>>>// $ProjectName : Windows 32 bits file handling
9270>>>>>>>// $Authors     : Wil van Antwerpen
9270>>>>>>>// $Created     : 19.02.2004  19:25
9270>>>>>>>// $Type        : BSD (as in do with it whatever you like)
9270>>>>>>>//
9270>>>>>>>// Contents:
9270>>>>>>>//  This file contains the Windows API external function call definitions and
9270>>>>>>>//  constants as they are used in the vWin32fh package.
9270>>>>>>>//*****************************************************************************************
9270>>>>>>>//TH-RevisionStart
9270>>>>>>>//TH-RevisionEnd
9270>>>>>>>
9270>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
9270>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
9270>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
9270>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
9270>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
9270>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
9270>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
9270>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
9270>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
9270>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
9270>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
9270>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
9270>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
9270>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
9270>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
9270>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
9270>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
9270>>>>>>>
9270>>>>>>>
9270>>>>>>>Define vMax_Path     For |CI260
9270>>>>>>>Define vMinChar      For |CI$80
9270>>>>>>>Define vMaxChar      For |CI$7F
9270>>>>>>>Define vMinShort     For |CI$8000
9270>>>>>>>Define vMaxShort     For |CI$7FFF
9270>>>>>>>Define vMinLong      For |CI$80000000
9270>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
9270>>>>>>>Define vMaxByte      For |CI$FF
9270>>>>>>>Define vMaxWord      For |CI$FFFF
9270>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
9270>>>>>>>
9270>>>>>>>
9270>>>>>>>
9270>>>>>>>// For FindFirstFile
9270>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
9270>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
9270>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
9270>>>>>>>
9270>>>>>>>// The defines below can be used to find out what kind of error has occurred if
9270>>>>>>>// the API-call ShellExecute is used.
9270>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
9270>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
9270>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
9270>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
9270>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
9270>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
9270>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
9270>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
9270>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
9270>>>>>>>Define vSE_ERR_FNF             For |CI0002
9270>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
9270>>>>>>>Define vSE_ERR_OOM             For |CI0008
9270>>>>>>>Define vSE_ERR_PNF             For |CI0003
9270>>>>>>>Define vSE_ERR_SHARE           For |CI0026
9270>>>>>>>
9270>>>>>>>
9270>>>>>>>// C-Structure
9270>>>>>>>//typedef struct _browseinfo {
9270>>>>>>>//    HWND hwndOwner;
9270>>>>>>>//    LPCITEMIDLIST pidlRoot;
9270>>>>>>>//    LPSTR pszDisplayName;
9270>>>>>>>//    LPCSTR lpszTitle;
9270>>>>>>>//    UINT ulFlags;
9270>>>>>>>//    BFFCALLBACK lpfn;
9270>>>>>>>//    LPARAM lParam;
9270>>>>>>>//    int iImage;
9270>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
9270>>>>>>>
9270>>>>>>>//declare C structure struct_browseinfo
9270>>>>>>>//as documented in MSDN under Windows Shell API
9270>>>>>>>Struct tvBrowseInfo
9270>>>>>>>  Handle    hWndOwner
9270>>>>>>>  Pointer   pIDLRoot
9270>>>>>>>  Pointer   pszDisplayName
9270>>>>>>>  Pointer   lpszTitle
9270>>>>>>>  dWord     ulFlags
9270>>>>>>>  Pointer   lpfnCallback
9270>>>>>>>  dWord     lParam
9270>>>>>>>  DWord     iImage
9270>>>>>>>End_Struct // tvBrowseInfo
9270>>>>>>>
9270>>>>>>>// Browsing for directory.
9270>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
9270>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
9270>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
9270>>>>>>>                                            // The callback function can set the status text by
9270>>>>>>>                                            // sending messages to the dialog box.
9270>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
9270>>>>>>>
9270>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
9270>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
9270>>>>>>>
9270>>>>>>>// message from browser
9270>>>>>>>//Define BFFM_INITIALIZED        1
9270>>>>>>>//Define BFFM_SELCHANGED         2
9270>>>>>>>
9270>>>>>>>// messages to browser
9270>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
9270>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
9270>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
9270>>>>>>>
9270>>>>>>>
9270>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
9271>>>>>>>
9271>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
9272>>>>>>>
9272>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
9273>>>>>>>
9273>>>>>>>
9273>>>>>>>
9273>>>>>>>
9273>>>>>>>Struct tvSecurity_attributes
9273>>>>>>>  DWord   nLength
9273>>>>>>>  Pointer lpDescriptor
9273>>>>>>>  Integer bInheritHandle
9273>>>>>>>End_Struct // tvSecurity_attributes
9273>>>>>>>
9273>>>>>>>//nLength:
9273>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
9273>>>>>>>// SECURITY_ATTRIBUTES structure.
9273>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
9273>>>>>>>// value of the nLength member. However, an application should still set it properly.
9273>>>>>>>// That ensures current, future, and cross-platform compatibility.
9273>>>>>>>//
9273>>>>>>>//lpSecurityDescriptor:
9273>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
9273>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
9273>>>>>>>// descriptor of the calling process.
9273>>>>>>>//
9273>>>>>>>//bInheritHandle:
9273>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
9273>>>>>>>// If this member is TRUE, the new process inherits the handle.
9273>>>>>>>
9273>>>>>>>
9273>>>>>>>// BOOL CreateDirectory(
9273>>>>>>>//    LPCTSTR lpPathName,
9273>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
9273>>>>>>>//   );
9273>>>>>>>//
9273>>>>>>>// lpPathName
9273>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
9273>>>>>>>//  to be created.
9273>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
9273>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
9273>>>>>>>// lpSecurityAttributes
9273>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
9273>>>>>>>//  determines whether the returned handle can be inherited by child processes.
9273>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
9273>>>>>>>// Returns:
9273>>>>>>>//  If the function succeeds, the return value is nonzero.
9273>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
9273>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
9274>>>>>>>
9274>>>>>>>
9274>>>>>>>// lpPathName
9274>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
9274>>>>>>>//  to be removed.
9274>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
9274>>>>>>>// Returns:
9274>>>>>>>//  If the function succeeds, the return value is nonzero.
9274>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
9274>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
9275>>>>>>>
9275>>>>>>>
9275>>>>>>>
9275>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
9275>>>>>>>// executable file or a document file.
9275>>>>>>>//
9275>>>>>>>// Operation can be one of the following:
9275>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
9275>>>>>>>//            The file can be an executable file or a document file.
9275>>>>>>>//            The file can be a folder to open.
9275>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
9275>>>>>>>//            The file should be a document file. If the file is an executable file,
9275>>>>>>>//            the function opens the file, as if "open" had been specified.
9275>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
9275>>>>>>>//
9275>>>>>>>// Return Values:
9275>>>>>>>//
9275>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
9275>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
9275>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
9275>>>>>>>//
9275>>>>>>>// The following table lists these error values:
9275>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
9275>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
9275>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
9275>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
9275>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
9275>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
9275>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
9275>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
9275>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
9275>>>>>>>// Public Const SE_ERR_FNF = 2
9275>>>>>>>// Public Const SE_ERR_NOASSOC = 31
9275>>>>>>>// Public Const SE_ERR_OOM = 8
9275>>>>>>>// Public Const SE_ERR_PNF = 3
9275>>>>>>>// Public Const SE_ERR_SHARE = 26
9275>>>>>>>
9275>>>>>>>
9275>>>>>>>
9275>>>>>>>// Code to open the program that is associated with the selected file.
9275>>>>>>>//
9275>>>>>>>// External function call used in Procedure DoStartDocument
9275>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
9276>>>>>>>
9276>>>>>>>
9276>>>>>>>
9276>>>>>>>
9276>>>>>>>Define vFO_MOVE                For |CI$0001
9276>>>>>>>Define vFO_COPY                For |CI$0002
9276>>>>>>>Define vFO_DELETE              For |CI$0003
9276>>>>>>>Define vFO_RENAME              For |CI$0004
9276>>>>>>>
9276>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
9276>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
9276>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
9276>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
9276>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
9276>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
9276>>>>>>>                                          // Must be freed using SHFreeNameMappings
9276>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
9276>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
9276>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
9276>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
9276>>>>>>>
9276>>>>>>>Struct tvShFileOpStruct
9276>>>>>>>  Handle  hWnd
9276>>>>>>>  Integer wFunc
9276>>>>>>>  Pointer pFrom
9276>>>>>>>  Pointer pTo
9276>>>>>>>  Short   fFlags
9276>>>>>>>  Short   fAnyOperationsAborted
9276>>>>>>>  Pointer hNameMappings
9276>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
9276>>>>>>>End_Struct // tvShFileOpStruct
9276>>>>>>>
9276>>>>>>>// hwnd
9276>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
9276>>>>>>>
9276>>>>>>>// wFunc
9276>>>>>>>//   Operation to perform. This member can be one of the following values:
9276>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
9276>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
9276>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
9276>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
9276>>>>>>>
9276>>>>>>>// pFrom
9276>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
9276>>>>>>>//   be null-separated. The list of names must be double null-terminated.
9276>>>>>>>
9276>>>>>>>// pTo
9276>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
9276>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
9276>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
9276>>>>>>>//   double null-terminated.
9276>>>>>>>
9276>>>>>>>// fAnyOperationsAborted
9276>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
9276>>>>>>>//   were completed or FALSE otherwise.
9276>>>>>>>
9276>>>>>>>
9276>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
9276>>>>>>>// This can be a file or a folder.
9276>>>>>>>// With thanks to Andrew S Kaplan
9276>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
9277>>>>>>>
9277>>>>>>>
9277>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
9277>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
9278>>>>>>>
9278>>>>>>>
9278>>>>>>>
9278>>>>>>>// Courtesy Of Vincent Oorsprong
9278>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
9278>>>>>>>//   Pointer lpPathName ;
9278>>>>>>>//   Pointer lpPrefixString ;
9278>>>>>>>//   Integer uUnique ;
9278>>>>>>>//   Pointer lpTempFileName ;
9278>>>>>>>//   Returns Integer
9278>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
9278>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
9279>>>>>>>
9279>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
9280>>>>>>>
9280>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
9281>>>>>>>
9281>>>>>>>// from:
9281>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
9281>>>>>>>//
9281>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
9281>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
9281>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
9281>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
9281>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
9281>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
9281>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
9281>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
9281>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
9281>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
9281>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
9281>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
9281>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
9281>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
9281>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
9281>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
9281>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
9281>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
9281>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
9281>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
9281>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
9281>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
9281>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
9281>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
9281>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
9281>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
9281>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
9281>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
9281>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
9281>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
9281>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
9281>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
9281>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
9281>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
9281>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
9281>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
9281>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
9281>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
9281>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
9281>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
9281>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
9281>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
9281>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
9281>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
9281>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
9281>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
9281>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
9281>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
9281>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
9281>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
9281>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
9281>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
9281>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
9281>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
9281>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
9281>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
9281>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
9281>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
9281>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
9281>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
9281>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
9281>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
9281>>>>>>>
9281>>>>>>>
9281>>>>>>>//HRESULT SHGetFolderPath(
9281>>>>>>>//    HWND hwndOwner,
9281>>>>>>>//    int nFolder,
9281>>>>>>>//    HANDLE hToken,
9281>>>>>>>//    DWORD dwFlags,
9281>>>>>>>//    LPTSTR pszPath
9281>>>>>>>//);
9281>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
9281>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
9281>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
9281>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
9281>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
9281>>>>>>>//
9281>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
9282>>>>>>>
9282>>>>>>>
9282>>>>>>>
9282>>>>>>>Struct tvWin32FindData
9282>>>>>>> Dword            dwFileAttributes
9282>>>>>>> Dword            ftCreationLowDateTime
9282>>>>>>> Dword            ftCreationHighDateTime
9282>>>>>>> dword            ftLastAccessLowDateTime
9282>>>>>>> Dword            ftLastAccessHighDateTime
9282>>>>>>> Dword            ftLastWriteLowDateTime
9282>>>>>>> Dword            ftLastWriteHighDateTime
9282>>>>>>> Dword            nFileSizeHigh
9282>>>>>>> Dword            nFileSizeLow
9282>>>>>>> Dword            dwReserved0
9282>>>>>>> Dword            dwReserved1
9282>>>>>>> UChar[vMax_Path] cFileName
9282>>>>>>> UChar[14]        cAlternateFileName
9282>>>>>>>End_Struct
9282>>>>>>>
9282>>>>>>>// Courtesy Of Vincent Oorsprong
9282>>>>>>>// lpFileName      : address of name of file to search for
9282>>>>>>>// lpFindFileData  : address of returned information
9282>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
9283>>>>>>>
9283>>>>>>>// Courtesy Of Vincent Oorsprong
9283>>>>>>>// hFindFile       : handle of search
9283>>>>>>>// lpFindFileData  : address of structure for data on found file
9283>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
9284>>>>>>>
9284>>>>>>>//
9284>>>>>>>// Unicode equivalents
9284>>>>>>>//
9284>>>>>>>// lpFileName      : address of name of file to search for
9284>>>>>>>// lpFindFileData  : address of returned information
9284>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
9285>>>>>>>
9285>>>>>>>// hFindFile       : handle of search
9285>>>>>>>// lpFindFileData  : address of structure for data on found file
9285>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
9286>>>>>>>
9286>>>>>>>
9286>>>>>>>// Courtesy Of Vincent Oorsprong
9286>>>>>>>//  hFindFile      : file search handle
9286>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
9287>>>>>>>
9287>>>>>>>
9287>>>>>>>
9287>>>>>>>Struct tvFileTime
9287>>>>>>>  DWord dwLowDateTime
9287>>>>>>>  DWord dwHighDateTime
9287>>>>>>>End_Struct
9287>>>>>>>
9287>>>>>>>
9287>>>>>>>Struct tvSystemTime
9287>>>>>>>  UShort wYear
9287>>>>>>>  UShort wMonth
9287>>>>>>>  UShort wDayOfWeek
9287>>>>>>>  UShort wDay
9287>>>>>>>  UShort wHour
9287>>>>>>>  UShort wMinute
9287>>>>>>>  UShort wSecond
9287>>>>>>>  UShort wMilliSeconds
9287>>>>>>>End_Struct
9287>>>>>>>
9287>>>>>>>
9287>>>>>>>// Courtesy Of Vincent Oorsprong
9287>>>>>>>//  lpFileTime     : pointer to file time to convert
9287>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
9287>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
9288>>>>>>>
9288>>>>>>>// Courtesy Of Vincent Oorsprong
9288>>>>>>>// This function formats the time in a picture-string passed
9288>>>>>>>//
9288>>>>>>>// Picture      Meaning
9288>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
9288>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
9288>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
9288>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
9288>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
9288>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
9288>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
9288>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
9288>>>>>>>//    t         One character time marker string, such as A or P
9288>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
9288>>>>>>>//
9288>>>>>>>// For example, to get the time string  "11:29:40 PM"
9288>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
9288>>>>>>>
9288>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
9289>>>>>>>
9289>>>>>>>
9289>>>>>>>// Courtesy Of Vincent Oorsprong
9289>>>>>>>// This function formats the date in a picture-string passed
9289>>>>>>>//
9289>>>>>>>// Picture      Meaning
9289>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
9289>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
9289>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
9289>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
9289>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
9289>>>>>>>//              value associated with the specified locale.
9289>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
9289>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
9289>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
9289>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
9289>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
9289>>>>>>>//              associated with the specified locale.
9289>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
9289>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
9289>>>>>>>//    yyyy      Year represented hy full four digits.
9289>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
9289>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
9289>>>>>>>//              does not have an associated era or period string.
9289>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
9289>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
9289>>>>>>>
9289>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
9290>>>>>>>
9290>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
9290>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
9290>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
9290>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
9290>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
9290>>>>>>>
9290>>>>>>>//  Date Flags for GetDateFormatW.
9290>>>>>>>//
9290>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
9290>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
9290>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
9290>>>>>>>
9290>>>>>>>
9290>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
9291>>>>>>>
9291>>>>>>>
9291>>>>>>>// **WvA: 20-02-2004
9291>>>>>>>// While i was testing the format capabilities i stumbled over a very
9291>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
9291>>>>>>>// incorrectly into an unsigned integer.
9291>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
9291>>>>>>>// It does smell a bit fishy though
9291>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
9291>>>>>>>
9291>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
9291>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
9291>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
9291>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
9291>>>>>>>
9291>>>>>>>// Possible errors that can be returned by the shellformat function
9291>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
9291>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
9291>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
9291>>>>>>>
9291>>>>>>>
9291>>>>>>> // Courtesy Of Steve Walter,
9291>>>>>>> // USA Software, Inc
9291>>>>>>> // Format a disk
9291>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
9291>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
9292>>>>>>>
9292>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
9292>>>>>>>
9292>>>>>>>// SHCreateDirectoryEx
9292>>>>>>>
9292>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
9292>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
9292>>>>>>>//
9292>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
9292>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
9292>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
9292>>>>>>>//
9292>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
9292>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
9292>>>>>>>//        ERROR_CANCELLED.
9292>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
9292>>>>>>>
9292>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
9292>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
9292>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
9292>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
9292>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
9292>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
9292>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
9292>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
9292>>>>>>>
9292>>>>>>>//        int SHCreateDirectoryEx(
9292>>>>>>>//            HWND hwnd,
9292>>>>>>>//            LPCTSTR pszPath,
9292>>>>>>>//            const SECURITY_ATTRIBUTES *psa
9292>>>>>>>//        );
9292>>>>>>>
9292>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
9293>>>>>>>
9293>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
9294>>>>>
9294>>>>>
9294>>>>>// Does the directory exist? - No = false, Yes = True
9294>>>>>// This also works with UNC path encoding and wildcards
9294>>>>>Function vFolderExists Global String sFolderName Returns Boolean
9296>>>>>    Boolean bFolderExists
9296>>>>>    Boolean bStop
9296>>>>>    String  sFolder sTmp
9296>>>>>    Integer iCh
9296>>>>>
9296>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
9296>>>>>    Move (ToANSI(Trim(sFolderName))) to sFolderName
9297>>>>>    If (sFolderName = "") Begin
9299>>>>>        Function_Return False
9300>>>>>    End
9300>>>>>>
9300>>>>>
9300>>>>>    Move True  to bFolderExists
9301>>>>>    Move False to bStop
9302>>>>>    Move "dir:" to sFolder
9303>>>>>    Append sFolder sFolderName
9304>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
9305>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
9307>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
9308>>>>>>
9308>>>>>        Function_Return False
9309>>>>>    End
9309>>>>>>
9309>>>>>    Direct_Input channel iCh sFolder
9311>>>>>    Repeat
9311>>>>>>
9311>>>>>        Readln channel iCh sTmp
9313>>>>>        Move (SeqEof) to bStop
9314>>>>>        If (Trim(sTmp)="") Begin
9316>>>>>            Move False to bFolderExists
9317>>>>>        End
9317>>>>>>
9317>>>>>        Else Begin
9318>>>>>            Move True to bFolderExists
9319>>>>>            Move True to bStop
9320>>>>>        End
9320>>>>>>
9320>>>>>    Until (bStop)
9322>>>>>    Close_Input channel iCh
9324>>>>>    Send Seq_Release_Channel iCh
9325>>>>>    Function_Return bFolderExists
9326>>>>>End_Function
9327>>>>>
9327>>>>>// returns folder name if a folder was selected, otherwise returns ""
9327>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
9329>>>>>    String sFolder sTitle sPath
9329>>>>>    Pointer lpItemIdList
9329>>>>>    Integer iFolderSelected iRetval
9329>>>>>    tvBrowseInfo BrowseInfo
9329>>>>>    tvBrowseInfo BrowseInfo
9329>>>>>
9329>>>>>    Move "" to sPath
9330>>>>>    If (sDialogTitle<>"") Begin
9332>>>>>        Move sDialogTitle to sTitle
9333>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
9333>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
9333>>>>>        // These chars are correctly shown if no toansi is used.
9333>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
9333>>>>>        // selected it will always be valid.
9333>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
9334>>>>>    End
9334>>>>>>
9334>>>>>
9334>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
9335>>>>>
9335>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
9335>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
9335>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
9336>>>>>
9336>>>>>    // null 128 chars into var (make space)
9336>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
9337>>>>>
9337>>>>>    // select folder
9337>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
9338>>>>>    // get selected folder name
9338>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
9339>>>>>
9339>>>>>    // release memory resources that are used by the ItemIdList
9339>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
9340>>>>>
9340>>>>>    If (iFolderSelected<>0) Begin
9342>>>>>        Move (CString(sFolder)) to sPath
9343>>>>>    End
9343>>>>>>
9343>>>>>    Function_Return  sPath
9344>>>>>End_Function
9345>>>>>
9345>>>>>// returns 0 if the folder is created.
9345>>>>>//         1 if the API-call returned an error.
9345>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
9347>>>>>    String  sFolder
9347>>>>>    Integer iRetval bFolderCreated
9347>>>>>    tvSecurity_attributes SA
9347>>>>>    tvSecurity_attributes SA
9347>>>>>
9347>>>>>    Move False to bFolderCreated
9348>>>>>
9348>>>>>    // null MAX_PATH chars into var (make space)
9348>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
9349>>>>>
9349>>>>>    If (sNewFolder <> "") Begin
9351>>>>>
9351>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
9352>>>>>        Move  0  to SA.lpDescriptor
9353>>>>>        Move  1  to SA.bInheritHandle
9354>>>>>
9354>>>>>        //
9354>>>>>        Move (sNewFolder+"") to sFolder
9355>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
9356>>>>>    End
9356>>>>>>
9356>>>>>
9356>>>>>    If (bFolderCreated=false) Begin
9358>>>>>        Move 1 to iRetVal
9359>>>>>    End
9359>>>>>>
9359>>>>>    Function_Return iRetVal
9360>>>>>End_Function
9361>>>>>
9361>>>>>// **WvA: 03-02-2002 Function created.
9361>>>>>// With this function one can remove a directory.
9361>>>>>// returns 0 if the folder is removed.
9361>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
9361>>>>>//         2 if the folder did not exist
9361>>>>>//         3 if the sFolder parameter passed is equal to ""
9361>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
9363>>>>>    Boolean bRemoved
9363>>>>>    String  sPath
9363>>>>>    Integer iRetval
9363>>>>>
9363>>>>>    Move 0     to iRetVal
9364>>>>>    Move False to bRemoved
9365>>>>>    Move (Trim(sFolder)) to sFolder
9366>>>>>    If (sFolder="") Begin
9368>>>>>        Move 3 to iRetVal
9369>>>>>    End
9369>>>>>>
9369>>>>>    If (vFolderExists(sFolder)=False) Begin
9371>>>>>        Move 2 to iRetVal
9372>>>>>    End
9372>>>>>>
9372>>>>>    If (iRetVal=0) Begin
9374>>>>>    // null MAX_PATH chars into var (make space)
9374>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
9375>>>>>        //
9375>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
9376>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
9377>>>>>    End
9377>>>>>>
9377>>>>>
9377>>>>>    If (iRetVal=0 And bRemoved=False) Begin
9379>>>>>        Move 1 to iRetVal
9380>>>>>    End
9380>>>>>>
9380>>>>>    Function_Return iRetVal
9381>>>>>End_Function
9382>>>>>
9382>>>>>// This will perform an operation on a file (e.g. open) with the application
9382>>>>>// registered in the Windows Registry to open that type of file (via its extension)
9382>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
9382>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
9384>>>>>    Handle  hInstance hWnd
9384>>>>>    // remove any leading/trailing spaces in the string
9384>>>>>    Move (Trim(sDocument)) to sDocument
9385>>>>>    Move (Trim(sPath))     to sPath
9386>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
9386>>>>>    Append sOperation   (Character(0))
9387>>>>>    Append sDocument    (Character(0))
9388>>>>>    Append sParameters  (Character(0))
9389>>>>>    Append sPath        (Character(0))
9390>>>>>
9390>>>>>    Get Window_Handle to hWnd
9391>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
9392>>>>>    If (hInstance <= 32) Begin
9394>>>>>        Send vDDE_Error_Handler hInstance
9395>>>>>    End
9395>>>>>>
9395>>>>>End_Procedure
9396>>>>>
9396>>>>>Class cShellFileOperations is a Array
9397>>>>>
9397>>>>>    Procedure Construct_Object
9399>>>>>        Forward Send Construct_Object
9401>>>>>        Property Integer piDeleteFlags        0
9402>>>>>        Property Integer piCopyFlags          0
9403>>>>>        Property Integer piMoveFlags          0
9404>>>>>        Property Integer piRenameFlags        0
9405>>>>>
9405>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
9406>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
9407>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
9408>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
9409>>>>>    End_Procedure
9410>>>>>
9410>>>>>    // This function uses the shell API to perform a file operation on the
9410>>>>>    // files supplied.
9410>>>>>    //
9410>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
9412>>>>>        Integer  iRetVal
9412>>>>>        Integer  iUserAbort
9412>>>>>        tvShFileOpStruct FOS
9412>>>>>        tvShFileOpStruct FOS
9412>>>>>
9412>>>>>        Move (ToAnsi(sSource)+Character(0)+Character(0))      to sSource
9413>>>>>        Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
9414>>>>>
9414>>>>>        If (eOperation <> vFO_DELETE) Begin
9416>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
9417>>>>>        End
9417>>>>>>
9417>>>>>
9417>>>>>        Move eOperation           to FOS.wFunc
9418>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
9419>>>>>        Move iFlags               to FOS.fFlags
9420>>>>>
9420>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
9421>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
9422>>>>>        If (iUserAbort <> 0) Begin
9424>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
9425>>>>>        End
9425>>>>>>
9425>>>>>        Function_Return (iRetVal)
9426>>>>>    End_Function
9427>>>>>
9427>>>>>    Function sfoDeleteFile String sFileName Returns Integer
9429>>>>>        Integer  iRetVal
9429>>>>>        Integer  iFlags
9429>>>>>
9429>>>>>        Get piDeleteFlags to iFlags
9430>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
9431>>>>>        Function_Return iRetVal
9432>>>>>    End_Function
9433>>>>>
9433>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
9435>>>>>        Integer  iRetVal
9435>>>>>        Integer  iFlags
9435>>>>>
9435>>>>>        Get piCopyFlags to iFlags
9436>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
9437>>>>>        Function_Return iRetVal
9438>>>>>    End_Function
9439>>>>>
9439>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
9441>>>>>        Integer  iRetVal
9441>>>>>        Integer  iFlags
9441>>>>>
9441>>>>>        Get piMoveFlags to iFlags
9442>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
9443>>>>>        Function_Return iRetVal
9444>>>>>    End_Function
9445>>>>>
9445>>>>>    // Rename a file or folder
9445>>>>>    // Returns a nonzero value if the operation failed.
9445>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
9447>>>>>        Integer  iRetVal
9447>>>>>        Integer  iFlags
9447>>>>>
9447>>>>>        Get piRenameFlags to iFlags
9448>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
9449>>>>>        Function_Return iRetVal
9450>>>>>    End_Function
9451>>>>>
9451>>>>>    // Courtesy Of Steve Walter
9451>>>>>    // Requires Windows 2000 and up according to msdn but it was
9451>>>>>    //  in fact available before that as an unpublished API call
9451>>>>>    //  a little google search shows that this was already available
9451>>>>>    //  in windows 95 and NT
9451>>>>>    //
9451>>>>>    // The format is controlled by the dialog interface.
9451>>>>>    // That is, the user must click the OK button To actually Begin the format
9451>>>>>    // the format cannot be started programmatically.
9451>>>>>    // An alternative to this functionality would be to use a controlpanel
9451>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
9451>>>>>    //
9451>>>>>    // hWnd = The windows handle of the object from which the format Function
9451>>>>>    //        is called.
9451>>>>>    // To Get this,
9451>>>>>    //          use:  Get Window_Handle Of <object>
9451>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
9451>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
9451>>>>>    //
9451>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
9451>>>>>    //
9451>>>>>    // iOptions = Format options.
9451>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
9451>>>>>    //  SHFMT_OPT_FULL    = Full Format
9451>>>>>    //  SHFMT_OPT_SYSONLY = System only
9451>>>>>    //  3                 = Full format with system. (unsupported)
9451>>>>>    //
9451>>>>>    // Return Values:
9451>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
9451>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
9451>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
9451>>>>>    //
9451>>>>>    //
9451>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
9451>>>>>    //                seem to work, i must have made a silly mistake
9451>>>>>    //                somewhere.
9451>>>>>    //
9451>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
9453>>>>>        Handle   hWnd
9453>>>>>        Integer  iObj
9453>>>>>        DWord    dwReturnVal
9453>>>>>        Integer iDrive
9453>>>>>
9453>>>>>        Function_Return 1 // STOP HERE
9454>>>>>
9454>>>>>        Move (Trim(sDrive)) to sDrive
9455>>>>>        If ( sDrive <> '' ) Begin
9457>>>>>            If ( sDrive Contains ':' ) Begin
9459>>>>>                Move (Replace(':',sDrive,'')) to sDrive
9460>>>>>            End
9460>>>>>>
9460>>>>>            If (Not( 'AB' Contains sDrive )) Begin
9462>>>>>                Function_Return (SHFMT_NOFORMAT)
9463>>>>>            End
9463>>>>>>
9463>>>>>            If ( sDrive = 'A' ) Begin
9465>>>>>                Move 0 to iDrive
9466>>>>>            End
9466>>>>>>
9466>>>>>            Else If ( sDrive = 'B' ) Begin
9469>>>>>                Move 1 to iDrive
9470>>>>>            End
9470>>>>>>
9470>>>>>            // Window_Handle Of Desktop equals to 0
9470>>>>>
9470>>>>>            Get focus of desktop to iObj
9471>>>>>            If (iObj>desktop) Begin
9473>>>>>                Get Container_Handle of iObj to hWnd
9474>>>>>            End
9474>>>>>>
9474>>>>>            While (hWnd=0 And iObj<>Desktop)
9478>>>>>                Get Parent of iObj to iObj
9479>>>>>                Get Container_Handle of iObj to hWnd
9480>>>>>            Loop
9481>>>>>>
9481>>>>>
9481>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
9481>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
9482>>>>>        End
9482>>>>>>
9482>>>>>        Else Begin
9483>>>>>            Move (SHFMT_ERROR) to dwReturnVal
9484>>>>>        End
9484>>>>>>
9484>>>>>        Function_Return dwReturnVal
9485>>>>>    End_Function
9486>>>>>
9486>>>>>    //Example:
9486>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
9486>>>>>    //                                          mode.
9486>>>>>
9486>>>>>End_Class
9487>>>>>
9487>>>>>Object oShellFileOperations is a cShellFileOperations
9489>>>>>End_Object
9490>>>>>
9490>>>>>// Restore to the old way of working with the shell file operations.
9490>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
9490>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
9490>>>>>Procedure vWin32fhCompatibilityMode
9492>>>>>    Integer hoSFO
9492>>>>>    Integer iFlags
9492>>>>>
9492>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
9493>>>>>    Move (oShellFileOperations(Self)) to hoSFO
9494>>>>>
9494>>>>>    Set piDeleteFlags of hoSFO to iFlags
9495>>>>>    Set piCopyFlags   of hoSFO to iFlags
9496>>>>>    Set piMoveFlags   of hoSFO to iFlags
9497>>>>>    Set piRenameFlags of hoSFO to iFlags
9498>>>>>End_Procedure
9499>>>>>
9499>>>>>// Delete a file or folder
9499>>>>>// Returns a nonzero value if the operation failed.
9499>>>>>Function vDeleteFile Global String sFileName Returns Integer
9501>>>>>    Integer  iRetVal
9501>>>>>
9501>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
9502>>>>>    Function_Return iRetVal
9503>>>>>End_Function
9504>>>>>
9504>>>>>// Copy a file or folder
9504>>>>>// Returns a nonzero value if the operation failed.
9504>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
9506>>>>>    Integer  iRetVal
9506>>>>>
9506>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
9507>>>>>    Function_Return iRetVal
9508>>>>>End_Function
9509>>>>>
9509>>>>>// Move a file or folder
9509>>>>>// Returns a nonzero value if the operation failed.
9509>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
9511>>>>>    Integer  iRetVal
9511>>>>>
9511>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
9512>>>>>    Function_Return iRetVal
9513>>>>>End_Function
9514>>>>>
9514>>>>>// Rename a file or folder
9514>>>>>// Returns a nonzero value if the operation failed.
9514>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
9516>>>>>    Integer  iRetVal
9516>>>>>
9516>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
9517>>>>>    Function_Return iRetVal
9518>>>>>End_Function
9519>>>>>
9519>>>>>Function vGetWindowsDirectory Returns String
9521>>>>>    String  sDirectory
9521>>>>>    Integer iVoid
9521>>>>>
9521>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
9522>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
9523>>>>>    Function_Return (CString(sDirectory))
9524>>>>>End_Function
9525>>>>>
9525>>>>>Function vGetTempPath Returns String
9527>>>>>    Integer iRetval
9527>>>>>    String  sTempPath
9527>>>>>
9527>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
9528>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
9529>>>>>    Function_Return (Cstring(sTempPath))
9530>>>>>End_Function
9531>>>>>
9531>>>>>// Courtesy of Marco Kuipers
9531>>>>>Function vMakeTempFile Returns String
9533>>>>>    Integer iRetval
9533>>>>>    String  sTempPath
9533>>>>>    String  sTempFileName
9533>>>>>    String  sPrefixString
9533>>>>>
9533>>>>>    Get vGetTempPath to sTempPath
9534>>>>>    If (sTempPath = "") Begin
9536>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
9537>>>>>        If (sTempPath<>"") Begin
9539>>>>>            Move (sTempPath+"\Temp\") to sTempPath
9540>>>>>        End
9540>>>>>>
9540>>>>>    End
9540>>>>>>
9540>>>>>
9540>>>>>    If (sTempPath = "") Begin
9542>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
9542>>>>>    // makes little sense. Leaving this in as it was old behavior.
9542>>>>>        Get_Current_Directory to sTempPath
9543>>>>>    End
9543>>>>>>
9543>>>>>
9543>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
9544>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
9546>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
9547>>>>>>
9547>>>>>    End
9547>>>>>>
9547>>>>>
9547>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
9548>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
9549>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
9550>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
9552>>>>>    //Get ShowLastError to iRetval
9552>>>>>        Move "" to sTempFileName
9553>>>>>    End
9553>>>>>>
9553>>>>>
9553>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
9554>>>>>End_Function
9555>>>>>
9555>>>>>// This function creates a uniquely named temporary file in folder sPath
9555>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
9555>>>>>// Note that you will have to cleanup the tempfile yourself as the function
9555>>>>>// does not take care of that.
9555>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
9557>>>>>    Integer iRetVal
9557>>>>>    String sTempFileName
9557>>>>>
9557>>>>>    Move (ToAnsi(sPath)+Character(0))   to sPath
9558>>>>>    Move (ToAnsi(sPrefix)+Character(0)) to sPrefix
9559>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
9560>>>>>
9560>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
9561>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
9562>>>>>    Function_Return sTempFileName
9563>>>>>End_Function
9564>>>>>
9564>>>>>//
9564>>>>>// Get a specific shell folder for example to get the desktop folder
9564>>>>>// simply call this function and pass it vCSIDL_DESKTOP
9564>>>>>//
9564>>>>>Function vSHGetFolderPath Integer eFolder Returns String
9566>>>>>    String  sFolder
9566>>>>>    Integer iVoid
9566>>>>>    Handle  hWnd
9566>>>>>
9566>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
9567>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
9568>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
9569>>>>>    Function_Return (CString(sFolder))
9570>>>>>End_Function
9571>>>>>
9571>>>>>// Courtesy Of Vincent Oorsprong
9571>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
9573>>>>>    String  sFormattedTime sFormattedDate
9573>>>>>    String  sFileDateTime
9573>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
9573>>>>>    tvFileTime   FileTime
9573>>>>>    tvFileTime   FileTime
9573>>>>>    tvSystemTime SystemTime
9573>>>>>    tvSystemTime SystemTime
9573>>>>>
9573>>>>>    Move "" to sFileDateTime
9574>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
9575>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
9576>>>>>
9576>>>>>    Move 0 to SystemTime.wYear
9577>>>>>
9577>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
9578>>>>>    If (iSuccess = 1) Begin
9580>>>>>        Move (ZeroString(255))        to sFormattedTime
9581>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
9582>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
9583>>>>>        Move (ZeroString(255))        to sFormattedDate
9584>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
9585>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
9586>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
9587>>>>>    End
9587>>>>>>
9587>>>>>    Function_Return sFileDateTime
9588>>>>>End_Function
9589>>>>>
9589>>>>>// **WvA:
9589>>>>>// A windows replacement for the standard function FileExists.
9589>>>>>// This version will also return (true) for a file when it is open by an application.
9589>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
9589>>>>>// Example: Get vFilePathExists "C:\config.sy?"
9589>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
9589>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
9591>>>>>    String  sDirSep
9591>>>>>    Handle  hFindFile
9591>>>>>    Integer iVoid
9591>>>>>    tvWin32FindData FindData
9591>>>>>    tvWin32FindData FindData
9591>>>>>
9591>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
9592>>>>>    Move (ToANSI(Trim(sFilePathMask))) to sFilePathMask
9593>>>>>
9593>>>>>    If (Length(sFilePathMask)>0) Begin
9595>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
9595>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
9596>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
9600>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
9601>>>>>        Loop
9602>>>>>>
9602>>>>>
9602>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
9603>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
9604>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
9605>>>>>    End
9605>>>>>>
9605>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
9606>>>>>End_Function
9607>>>>>
9607>>>>>//
9607>>>>>// Returns the amount of files in the folder (if it exists)
9607>>>>>// Returns -1 if folder doesn't exist.
9607>>>>>// The files "." and ".." are not counted.
9607>>>>>//
9607>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
9609>>>>>    Boolean bFound
9609>>>>>    Handle  hFindFile
9609>>>>>    Integer iCount  iVoid
9609>>>>>    Integer iSuccess
9609>>>>>    String  sFileName
9609>>>>>    tvWin32FindData FindData
9609>>>>>    tvWin32FindData FindData
9609>>>>>
9609>>>>>    Move -1 to iCount
9610>>>>>    Get vFolderFormat sFolderName to sFolderName
9611>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
9612>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
9613>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
9614>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
9615>>>>>    If (bFound) Begin
9617>>>>>        Move 0 to iCount
9618>>>>>    End
9618>>>>>>
9618>>>>>    While (bFound)
9622>>>>>        Increment iCount
9623>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
9624>>>>>        If (sFileName="." or sFileName="..") Begin
9626>>>>>            Decrement iCount
9627>>>>>        End
9627>>>>>>
9627>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
9628>>>>>        Move (iSuccess<>0) to bFound
9629>>>>>    Loop
9630>>>>>>
9630>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
9631>>>>>    Function_Return iCount
9632>>>>>End_Function
9633>>>>>
9633>>>>>// Create the folder, including intermediate directories.
9633>>>>>// Don't panic if the folder already exists.
9633>>>>>// Michael Mullan June 2009.
9633>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
9635>>>>>    String  sFolder
9635>>>>>    Integer iRetval iFolderCreated
9635>>>>>    tvSecurity_attributes SA
9635>>>>>    tvSecurity_attributes SA
9635>>>>>
9635>>>>>    Move 0 to iFolderCreated
9636>>>>>
9636>>>>>    // null MAX_PATH chars into var (make space)
9636>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
9637>>>>>    If (sNewFolder <> "") Begin
9639>>>>>
9639>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
9640>>>>>        Move  0  to SA.lpDescriptor
9641>>>>>        Move  1  to SA.bInheritHandle
9642>>>>>
9642>>>>>        //
9642>>>>>        Move (sNewFolder+"") to sFolder
9643>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
9644>>>>>    End
9644>>>>>>
9644>>>>>
9644>>>>>    If (iFolderCreated <> 0) Begin
9646>>>>>        Move 1 to iRetVal
9647>>>>>        Case Begin
9647>>>>>            Case (iFolderCreated = 161)
9649>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
9650>>>>>>
9650>>>>>                Case Break
9651>>>>>            Case (iFolderCreated = 206)
9654>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
9655>>>>>>
9655>>>>>                Case Break
9656>>>>>            Case (iFolderCreated = 3)
9659>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
9660>>>>>>
9660>>>>>                Case Break
9661>>>>>            Case (iFolderCreated = 80)
9664>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
9665>>>>>                Case Break
9666>>>>>            Case (iFolderCreated = 183)
9669>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
9670>>>>>                Case Break
9671>>>>>            Case (iFolderCreated = 1223)
9674>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
9675>>>>>>
9675>>>>>                Case Break
9676>>>>>            Case Else
9676>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
9677>>>>>>
9677>>>>>        Case End
9677>>>>>    End
9677>>>>>>
9677>>>>>    Function_Return iRetVal
9678>>>>>End_Function
9679>>>>>
9679>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
9681>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
9681>>>>>    Integer iFileSize iVoid
9681>>>>>    Handle  hFindFile
9681>>>>>    tvWin32FindData FindData
9681>>>>>    tvWin32FindData FindData
9681>>>>>
9681>>>>>    Move (sFileName+"") to sFileName
9682>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
9683>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
9684>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
9686>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
9687>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
9688>>>>>    End
9688>>>>>>
9688>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
9689>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
9690>>>>>
9690>>>>>    Function_Return iFileSize
9691>>>>>End_Function
9692>>>>>
9692>>>>>//
9692>>>>>// Based on code in Peter Crook's Browse folder workspace
9692>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
9692>>>>>//
9692>>>>>//=============================================================================
9692>>>>>// Verifies that a path is a valid directory.
9692>>>>>//
9692>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
9692>>>>>//
9692>>>>>// Parameters:
9692>>>>>//      sPath - Address of the path to verify.
9692>>>>>//=============================================================================
9692>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
9694>>>>>    Integer iResult
9694>>>>>    Boolean bRetVal
9694>>>>>
9694>>>>>    Move false to bRetVal
9695>>>>>    Move (ToAnsi(sPath) - Character (0)) to sPath
9696>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
9697>>>>>    If (iResult<>0) Begin
9699>>>>>        Move True to bRetVal
9700>>>>>    End
9700>>>>>>
9700>>>>>
9700>>>>>    Function_Return bRetVal
9701>>>>>End_Function
9702>>>
9702>>>//
9702>>>// Gets the string from the right of the last sStopChar in sFrom
9702>>>// If sStopChar has no occurences in the string an empty string is
9702>>>// returned.
9702>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
9704>>>    String  sRetVal
9704>>>    String  sChar
9704>>>    Integer iLength
9704>>>    Integer iPos
9704>>>    Boolean bStopChar
9704>>>    Move "" to sRetval
9705>>>    Move (Length(sFrom)) to iLength
9706>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
9708>>>        Move iLength   to iPos
9709>>>        Move (False)   to bStopChar
9710>>>        While Not bStopChar
9714>>>            Move (Mid(sFrom,1,iPos)) to sChar
9715>>>            Decrement iPos
9716>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
9718>>>                Move (True) to bStopChar
9719>>>            End
9719>>>>
9719>>>            Else Begin
9720>>>                Move (sChar+sRetVal) to sRetVal
9721>>>            End
9721>>>>
9721>>>        Loop
9722>>>>
9722>>>    End
9722>>>>
9722>>>    Function_Return sRetVal
9723>>>End_Function
9724>>>
9724>>>// Pre:  sFileName contains the complete path of the file.
9724>>>// Post: returns the complete path of the file.
9724>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
9724>>>Function ParseFolderName Global String sFileName Returns String
9726>>>    String sFile
9726>>>    String sFolderName
9726>>>    String sDirSep // this is "\" for windows, or "/" for unix
9726>>>
9726>>>    Move "" to sFolderName
9727>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
9728>>>    If sDirSep In sFileName Begin
9730>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
9731>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
9732>>>    End
9732>>>>
9732>>>    Else If ":" In sFileName Begin
9735>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
9736>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
9737>>>    End
9737>>>>
9737>>>    Function_Return sFolderName
9738>>>End_Function
9739>>>
9739>>>// Pre:  sFileName contains the complete path of the file.
9739>>>// post: The returned filename has it's path removed, but will have a extension
9739>>>Function ParseFileName Global String sFileName Returns String
9741>>>    String sFolderName
9741>>>    String sDirSep // this is "\" for windows, or "/" for unix
9741>>>
9741>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
9742>>>    Get ParseFolderName sFileName to sFolderName
9743>>>    If (sFolderName <> "") Begin
9745>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
9746>>>    End
9746>>>>
9746>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
9747>>>    Function_Return sFilename
9748>>>End_Function
9749>>>
9749>>>// Pre:  sFileName may contain the complete path of the file.
9749>>>//       or contain multiple dots in the filename, so temp.gif.bak will
9749>>>//       return "bak" as the extension and not "gif"
9749>>>// Post: returns the extension only, this extension can be a valid unixlike extension
9749>>>//       such as "html" or "java"
9749>>>Function ParseFileExtension Global String sFileName Returns String
9751>>>    String  sFileExtension
9751>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
9752>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
9753>>>    Function_Return sFileExtension
9754>>>End_Function
9755>>>
9755>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
9755>>>
9755>>>Function DDE_Error_To_String Integer iErrorID Returns String
9757>>>    String sMessage
9757>>>    Case Begin
9757>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
9759>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
9760>>>            Case Break
9761>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
9764>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
9765>>>            Case Break
9766>>>        Case (iErrorID = vERROR_BAD_FORMAT)
9769>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
9770>>>            Case Break
9771>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
9774>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
9775>>>            Case Break
9776>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
9779>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
9780>>>            Case Break
9781>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
9784>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
9785>>>            Case Break
9786>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
9789>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
9790>>>            Case Break
9791>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
9794>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
9795>>>            Case Break
9796>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
9799>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
9800>>>            Case Break
9801>>>        Case (iErrorID = vSE_ERR_NOASSOC)
9804>>>            Move CS_DDE_ERR_NOASSOC to sMessage
9805>>>            Case Break
9806>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
9809>>>            Move CS_DDE_ERR_OOM to sMessage
9810>>>            Case Break
9811>>>        Case (iErrorID = vSE_ERR_PNF)
9814>>>            Move CS_DDE_ERR_PNF to sMessage
9815>>>            Case Break
9816>>>        Case (iErrorID = vSE_ERR_SHARE)
9819>>>            Move CS_DDE_ERR_SHARE to sMessage
9820>>>            Case Break
9821>>>        Case Else
9821>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
9822>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
9823>>>            Case Break
9824>>>    Case End
9824>>>    Function_Return sMessage
9825>>>End_Function
9826>>>
9826>>>Procedure vDDE_Error_Handler Integer iErrorID
9828>>>    String sMessage
9828>>>    Get DDE_Error_To_String iErrorID to sMessage
9829>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
9830>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
9831>>>End_Procedure
9832>>>
9832>>>
9832>>>// This function informs the user that he entered a yet unknown folder and
9832>>>// asks if he/she wants to create the folder (Yes/No)
9832>>>// Choice: "Yes" - this creates the folder
9832>>>//                 if successful, the function returns false
9832>>>//                 else it will be true.
9832>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
9832>>>//                 For example: to stop a save
9832>>>// Precondition: A foldername must be entered. We do not check for empty paths
9832>>>// This function returns a non-zero value if the folder isn't created afterwards
9832>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
9834>>>    Integer bIsNotValid
9834>>>    Integer iUsers_Choice
9834>>>    String  sMessage
9834>>>
9834>>>    If (vFolderExists(sFolderName) Eq 0) Begin
9836>>>        Move "The folder '" to sMessage
9837>>>        Append sMessage sFolderName
9838>>>        Append sMessage "' does not yet exist,\n"
9839>>>        Append sMessage "Do you want to create it now?"
9840>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
9841>>>        Case Begin
9841>>>            Case (iUsers_Choice = MBR_Yes)
9843>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
9844>>>                If bIsNotValid Begin
9846>>>                    Move "An error occurred while trying to create folder '" to sMessage
9847>>>                    Append sMessage sFolderName "'.\n\n"
9849>>>                    Send Info_Box sMessage "Info"
9850>>>                End
9850>>>>
9850>>>                Case Break
9851>>>            Case (iUsers_Choice = MBR_No)
9854>>>                Move dfTrue to bIsNotValid // Cancel the save
9855>>>                Case Break
9856>>>        Case End
9856>>>    End
9856>>>>
9856>>>    Function_Return bIsNotValid
9857>>>End_Function
9858>>>
9858>>>// **WvA
9858>>>// Formats a foldername by first trimming it and after that by sticking a
9858>>>// directory separator (/\) to the end if it doesn't have one there already.
9858>>>// The folder may contain a drive letter or UNC encoding.
9858>>>Function vFolderFormat Global String sFolderName Returns String
9860>>>    String sDirSep
9860>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
9861>>>    Move (Trim(sFolderName)) to sFolderName
9862>>>    If (Right(sFolderName,1)<>sDirSep) Begin
9864>>>        Move (sFolderName+sDirSep) to sFolderName
9865>>>    End
9865>>>>
9865>>>    Function_Return sFolderName
9866>>>End_Function
9867>>>
9867>>>//
9867>>>// Gets the parent path of the currently supplied path
9867>>>// Returns "" when we are at the root folder.
9867>>>//
9867>>>Function vParentPath Global String sPath Returns String
9869>>>    String sStrip sDirSep
9869>>>
9869>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
9870>>>    Move (Trim(sPath)) to sPath
9871>>>    If (Right(sPath,1) = sDirSep) Begin
9873>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
9874>>>    End
9874>>>>
9874>>>    If (Pos(sDirSep, sPath)) Begin
9876>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
9877>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
9878>>>    End
9878>>>>
9878>>>    Else Begin
9879>>>        Move "" to sPath
9880>>>    End
9880>>>>
9880>>>    Function_Return sPath
9881>>>End_Function
9882>//Use Akefs.pkg
9882>Use cFilesystem.pkg
Including file: cFilesystem.pkg    (C:\Projects\DF18\DfRefactor\Libraries\cFileSystem\AppSrc\cFilesystem.pkg)
9882>>>//************************************************************************
9882>>>//*** FileSystem - Binary file operations For VDF15+.
9882>>>//************************************************************************
9882>>>//*** Based on original package: akefs.pkg
9882>>>//*** Version: 4.0
9882>>>//*** (C) NordTeam Gruppen, NOVAX A/S
9882>>>//***
9882>>>//*** Author......: Allan Kim Eriksen
9882>>>//*** Created.....: 23/08 2001
9882>>>//***
9882>>>//*** Rev History.: 31/08 2018 Nils Svedmyr. Added Functions from Akefs.pkg
9882>>>//***               to get/set file date/time and procedure SetFileLastWriteTime.
9882>>>//***               Refactored functions FileSize & FileDate to only have one Function_Return,
9882>>>//***               and changed a couple of While loops to end with a "loop" word instead of "End".
9882>>>//***
9882>>>//************************************************************************
9882>>>// cFilesystem class with functions and procedures to access binary files.
9882>>>// Filenumbers are not limited to 10 but only to system resources.
9882>>>// Also windows API calls For file copy, file move ect.
9882>>>// This class is For vdf 15 and up.
9882>>>// This class is not limited to 2 GB but can handle filesizes up $7FFFFFFFFFFFFFFF (9 exabyte)
9882>>>
9882>>>//************************************************************************
9882>>>// Be aware that argument_size has to be larger
9882>>>// than the requested amount of bytes read in the buffer for
9882>>>// BytesFromBinaryFile.
9882>>>//************************************************************************
9882>>>
9882>>>//************************************************************************
9882>>>// Constants used For the external functions.
9882>>>//************************************************************************
9882>>>// fsCreatefile.
9882>>>    Define GENERIC_READ for            |CI$80000000
9882>>>    Define GENERIC_WRITE for           |CI$40000000
9882>>>    Define GENERIC_RANDOM for          (GENERIC_READ + GENERIC_WRITE)
9882>>>    Define CREATE_NEW for              |CI$00000001
9882>>>    Define CREATE_ALWAYS for           |CI$00000002
9882>>>    Define OPEN_EXISTING for           |CI$00000003
9882>>>    Define OPEN_ALWAYS for             |CI$00000004
9882>>>    Define TRUNCATE_EXISTING for       |CI$00000005
9882>>>
9882>>>
9882>>>    Define FILE_SHARE_READ for         |CI$1
9882>>>    Define FILE_SHARE_WRITE for        |CI$2
9882>>>    Define FILE_SHARE_RANDOM for       (FILE_SHARE_READ + FILE_SHARE_WRITE)
9882>>>
9882>>>// Generel.
9882>>>Define FNULL For                   |CI$0
9882>>>
9882>>>// FormatString.
9882>>>
9882>>>// SetFilePosition.
9882>>>Define FILE_BEGIN For     0
9882>>>Define FILE_CURRENT For  1
9882>>>Define FILE_END For      2
9882>>>Define INVALID_SET_FILE_POINTER For |CI$FFFFFFFF
9882>>>
9882>>>// FindFile.
9882>>>
9882>>>Define ERROR_NO_MORE_FILES    For |CI18
9882>>>Define ERROR_MOD_NOT_FOUND    For |CI126
9882>>>
9882>>>
9882>>>
9882>>>// Flags For tsVS_FIXEDFILEINFO.dwFileFlags.
9882>>>
9882>>>// Flags For tsVS_FIXEDFILEINFO.dwFileOS.
9882>>>Define VOS_DOS          For |CI$10000
9882>>>Define VOS_NT           For |CI$40000
9882>>>Define VOS_WINDOWS16    For |CI$00001
9882>>>Define VOS_WINDOWS32    For |CI$00004
9882>>>Define VOS_OS216        For |CI$20000
9882>>>Define VOS_OS232        For |CI$30000
9882>>>Define VOS_PM16         For |CI$00002
9882>>>Define VOS_PM32         For |CI$00003
9882>>>Define VOS_UNKNOWN      For |CI$00000
9882>>>
9882>>>// Flags For tsVS_FIXEDFILEINFO.dwFileType.
9882>>>Define VFT_APP          For |CI$01
9882>>>Define VFT_DLL          For |CI$02
9882>>>Define VFT_DRV          For |CI$03
9882>>>Define VFT_FONT         For |CI$04
9882>>>Define VFT_STATIC_LIB   For |CI$07
9882>>>Define VFT_UNKNOWN      For |CI$00
9882>>>Define VFT_VXD          For |CI$05
9882>>>
9882>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_DRV.
9882>>>Define VFT2_DRV_COMM                For |CI$0A
9882>>>Define VFT2_DRV_DISPLAY             For |CI$04
9882>>>Define VFT2_DRV_INSTALLABLE         For |CI$08
9882>>>Define VFT2_DRV_KEYBOARD            For |CI$02
9882>>>Define VFT2_DRV_LANGUAGE            For |CI$03
9882>>>Define VFT2_DRV_MOUSE               For |CI$05
9882>>>Define VFT2_DRV_NETWORK             For |CI$06
9882>>>Define VFT2_DRV_PRINTER             For |CI$01
9882>>>Define VFT2_DRV_SOUND               For |CI$09
9882>>>Define VFT2_DRV_SYSTEM              For |CI$07
9882>>>Define VFT2_DRV_VERSIONED_PRINTER   For |CI$0C
9882>>>
9882>>>// Flags For tsVS_FIXEDFILEINFO.dwFileSubtype if tsVS_FIXEDFILEINFO.dwFileType = VFT_FONT.
9882>>>Define VFT2_FONT_RASTER             For |CI$01
9882>>>Define VFT2_FONT_TRUETYPE           For |CI$03
9882>>>Define VFT2_FONT_VECTOR             For |CI$02
9882>>>
9882>>>Define VFT2_UNKNOWN                 For |CI$00
9882>>>
9882>>>Define FS_FILEHANDLEMISSING For "The filehandle does not exists For the current filenumber."
9882>>>
9882>>>// Filesearch
9882>>>Enum_List
9882>>>    Define DIRMODE_FILES_ONLY For 1
9882>>>    Define DIRMODE_DIRECTORIES_ONLY
9882>>>    Define DIRMODE_FILES_AND_DIRECTORIES
9882>>>End_Enum_List
9882>>>
9882>>>//************************************************************************
9882>>>// Declarations of external functions.
9882>>>// Functions that needs variables For output are made global stings or
9882>>>// integers, and can be found on top of the declaration.
9882>>>//************************************************************************
9882>>>External_Function fsCreatefile "CreateFileA" kernel32.dll ;Pointer lpFile ;      //filenameDWord dwDesAccess ;   // access modeDWord dwShare ;       // share modePointer lpSecAtt ;    // SDDWord dwCrDisp ;      // how to createDWord dwFlags ;       // file attributesHandle hTempFile ;   // handle to template filReturns Integer      //Returns handle that can be used to access the object
9883>>>
9883>>>External_Function fsGetLastError "GetLastError" kernel32.dll Returns Integer
9884>>>
9884>>>External_Function fsFormatMessage "FormatMessageA" kernel32.dll ;DWord dwFlags ;         // source and processing optionsPointer lpSrc ;         // message sourceDWord dwMsgId ;         // message identifierDWord dwLngId ;         // language identifierPointer lpBuf ;         // message bufferDWord nSize ;           // maximum size of message bufferPointer Arg ;           // array of message insertsReturns Integer
9885>>>
9885>>>External_Function fsLocalFree "LocalFree" kernel32.dll ;Handle hMem ;   // A handle to the local memory object.Returns Integer
9886>>>
9886>>>External_Function fsCloseHandle "CloseHandle" kernel32.dll ;Handle hObject ;        // handle to objectReturns Integer
9887>>>
9887>>>External_Function fsReadFile "ReadFile" kernel32.dll ;Handle hFile ;          // handle to filePointer lpBuffer ;      // data bufferDWord nBytesToRead ;    // number of bytes to readPointer lpBytesRead ;   // number of bytes readPointer lpOverlapped ;  // overlapped bufferReturns Integer
9888>>>
9888>>>External_Function fsWriteFile "WriteFile" kernel32.dll ;Handle hFile ;              // handle to filePointer lpBuf ;             // data bufferDWord nNumBytesWrt ;        // number of bytes to writePointer lpNumBytesWritten ; // number of bytes writtenPointer lpOverlapped ;      // overlapped bufferReturns Integer
9889>>>
9889>>>External_Function fsGetFileSizeEx "GetFileSizeEx" kernel32.dll ;Handle hFile ;           // handle to filePointer lpFileSizeHigh ; // A pointer to a LARGE_INTEGER structure that receives the file size, in bytes.Returns Integer
9890>>>
9890>>>External_Function fsSetFilePointer "SetFilePointer" kernel32.dll ;Handle hFile ;              // handle to fileUInteger lDistanceToMove ;    // The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.Pointer lpDistanceToMoveHigh ;  // A pointer to the high order 32-bits of the signed 64-bit distance to move.DWord dwMoveMethod ;        // The starting point For the file pointer move.Returns UInteger
9891>>>
9891>>>External_Function fsSetEndOfFile "SetEndOfFile" kernel32.dll ;Handle hFile ;              // handle to the file to have its EOF position moved.Returns Integer             // nonzero if success
9892>>>
9892>>>External_Function fsDeleteFile "DeleteFileA" Kernel32.Dll ;Pointer lpFileName ;         // Pointer to a null-terminated string that specifies the file to be deleted.Returns Integer
9893>>>
9893>>>External_Function fsMoveFile "MoveFileA" Kernel32.Dll ;Pointer lpExistingFileName ;    // Pointer to a null-terminated string that names an existing file or directory.Pointer lpNewFileName ;         // Pointer to a null-terminated string that specifies the new name of a file or directory.Returns Integer                 // The new name must Not already exist. A new File may be on A different File system Or drive. A new directory must be on the same drive.
9894>>>
9894>>>External_Function fsCopyFile "CopyFileA" Kernel32.Dll ;Pointer lpExistingFileName ;    // Pointer to a null-terminated string that specifies the name of an existing file.Pointer lpNewFileName ;         // Pointer to a null-terminated string that specifies the name of the new file.Boolean bFailIfExists ;         // If bFailIfExists is TRUE and the new file specified by lpNewFileName already exists, the function fails.Returns Integer                 // If bFailIfExists is FALSE and the new file already exists, the function overwrites the existing file and succeeds.
9895>>>
9895>>>External_Function fsFindFirstFile "FindFirstFileA" Kernel32.Dll ;Pointer lpFileName ;            // Pointer to a null-terminated string that specifies a valid directory or path and file name, which can contain wildcard characters (* and ?).Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
9896>>>
9896>>>External_Function fsFindNextFile "FindNextFileA" Kernel32.Dll ;Handle hFindFile ;              // handle returned by a previous call to the FindFirstFile function.Pointer lpWin32_Find_Data ;     // Pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.Returns Integer
9897>>>
9897>>>External_Function fsFindClose "FindClose" Kernel32.dll ;Handle hFindFile ;              // File search handle. This handle must have been previously opened by the FindFirstFile function.Returns Integer
9898>>>
9898>>>External_Function fsGetFileTime "GetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with read accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
9899>>>
9899>>>External_Function fsSetFileTime "SetFileTime" Kernel32.dll ;Handle  hFile  ;                // Handle For a file from createfile with write accessPointer lpCreationtime ;        // Pointer to a FILETIME structure containing the file creation timePointer lpLastAccesstime ;      // Pointer to a FILETIME structure containing the file last access timePointer lpLastWritetime ;       // Pointer to a FILETIME structure containing the file last write timeReturns Integer
9900>>>
9900>>>External_function fsGetSystemTimeAsFileTime "GetSystemTimeAsFileTime" Kernel32.dll ;Pointer lpSystemTimeAsFileTime ;   // Pointer to a FILETIME structure containing the current system time in filetimme formatReturns Integer
9901>>>
9901>>>External_Function fsFileTimeToSystemTime "FileTimeToSystemTime" Kernel32.dll ;Pointer lpFiletime ;            // Pointer to a FILETIME structure containing the file time to convert to system date and time format.Pointer lpSystemtime ;          // Pointer to a SYSTEMTIME structure to receive the converted file time.Returns Integer
9902>>>
9902>>>External_Function fsSystemTimeToTzSpecificLocalTime "SystemTimeToTzSpecificLocalTime" Kernel32.dll ;Pointer lpTimeZone ;            // A pointer to a TIME_ZONE_INFORMATION structure that specifies the time zone of interest.Pointer lpUniversalTime ;       // A pointer to a SYSTEMTIME structure that specifies a time, in UTC.Pointer lpLocalTime ;           // A pointer to a SYSTEMTIME structure that receives the local time.Returns Integer
9903>>>
9903>>>External_Function fsGetTempFileName "GetTempFileNameA" kernel32.dll ;Pointer sPathname ;Pointer sPrefixString ;Integer iUnique ;Pointer sTempFileName ;Returns Integer
9904>>>
9904>>>External_Function fsGetTempPath "GetTempPathA" Kernel32.Dll ;Integer nBufferLength ;Pointer lpBuffer ;Returns Integer
9905>>>
9905>>>External_Function fsCreateDirectory "CreateDirectoryA" Kernel32.dll ;Pointer lpDirName ;             // Pointer to a null-terminated string that specifies the path of the directory to be created.Pointer lpSecAttributes ;       // Pointer to a SECURITY_ATTRIBUTES structure.Returns Integer
9906>>>
9906>>>External_Function fsRemoveDirectory "RemoveDirectoryA" Kernel32.dll ;Pointer lpDirName ;             // Pointer to a null-terminated string that specifies the path of the directory to be removed.Returns Integer
9907>>>
9907>>>External_Function fsExtractAssociatedIcon "ExtractAssociatedIconA" shell32.dll ;Handle hInst ;Pointer lpIconPath ;Integer lpiIcon ;Returns Handle
9908>>>
9908>>>External_Function fsDestroyIcon "DestroyIcon" User32.dll ;Handle hIcon ;Returns Integer
9909>>>
9909>>>External_Function fsGetFileVersionInfoSize "GetFileVersionInfoSizeA" Version.dll ;Pointer lpFilename ;            // The name of the file of interest. The function uses the search sequence specified by the LoadLibrary function.Pointer lpHandle ;              // A pointer to a variable that the function sets to zero.Returns UInteger
9910>>>
9910>>>External_Function fsGetFileVersionInfo "GetFileVersionInfoA" Version.dll ;Pointer lpFilename ;            // The name of the file. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.DWord dwHandle ;                // This parameter is ignored.DWord dwLen ;                   // The size, in bytes, of the buffer pointed to by the lpData parameter.Pointer lpData ;                // Pointer to a buffer that receives the file-version information.Returns Boolean
9911>>>
9911>>>External_Function fsVerQueryValue "VerQueryValueA" Version.dll ;Pointer lpBlock ;               // The version-information resource returned by the GetFileVersionInfo function.Pointer lpSubBlock ;            // The version-information value to be retrieved.Pointer lpBuffer ;              // When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by lpBlock.Pointer lpLen ;                 // When this method returns, contains a pointer to the size of the requested data pointed to by lpBuffer.Returns Boolean
9912>>>
9912>>>//************************************************************************
9912>>>// Structures
9912>>>//************************************************************************
9912>>>
9912>>>// Nils 2018-08-30 Added For the SourceCodeTools project
9912>>>// so we don't need to use both Akefs.pkg and this package.
9912>>>// A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
9912>>>Struct tFileTime
9912>>>    DWord dwLowDateTime    // Low-order part of the file time.
9912>>>    DWord dwHighDateTime   // High-order part of the file time.
9912>>>End_Struct
9912>>>
9912>>>Struct structWFD  // Used by FindFirstFile
9912>>>    DWord dwFileAttributes
9912>>>    UBigInt ftCreationDateTime
9912>>>    UBigInt ftLastAccessDateTime
9912>>>    UBigInt ftLastWriteDateTime
9912>>>    UInteger nFileSizeHigh
9912>>>    UInteger nFileSizeLow
9912>>>    DWord dares
9912>>>    DWord dbres
9912>>>    UChar[MAX_PATH] cFileName
9912>>>    UChar[14] cAlternateFileName
9912>>>End_Struct
9912>>>
9912>>>Struct structSystemTime
9912>>>    UShort wYear
9912>>>    UShort wMonth
9912>>>    UShort wDayOfWeek
9912>>>    UShort wDay
9912>>>    UShort wHour
9912>>>    UShort wMinute
9912>>>    UShort wSecond
9912>>>    UShort wMillieseconds
9912>>>End_Struct
9912>>>
9912>>>Struct structFile
9912>>>    Handle hFilehandle
9912>>>    String sFilename    // Assigned filename in OEM format.
9912>>>    Boolean bEndOfFile  // True then the end of the binary file had been read.
9912>>>End_Struct
9912>>>
9912>>>Struct structFileBufferPointer
9912>>>    Integer iBufferPointer
9912>>>    Integer iBufferSize
9912>>>    BigInt biFromFilePosition
9912>>>End_Struct
9912>>>
9912>>>Struct tsSearchResult
9912>>>    String sFilename
9912>>>    String sAlternateFileName   // 8.3 format
9912>>>    DateTime dtCreationDateTime
9912>>>    DateTime dtLastAccessDateTime
9912>>>    DateTime dtLastWriteDateTime
9912>>>    BigInt biFileSize
9912>>>    Integer iFileAttributes
9912>>>End_Struct
9912>>>
9912>>>Struct tsVS_FIXEDFILEINFO
9912>>>    DWord dwSignature
9912>>>    DWord dwStrucVersion
9912>>>    DWord dwFileVersionMS
9912>>>    DWord dwFileVersionLS
9912>>>    DWord dwProductVersionMS
9912>>>    DWord dwProductVersionLS
9912>>>    DWord dwFileFlagsMask
9912>>>    DWord dwFileFlags
9912>>>    DWord dwFileOS
9912>>>    DWord dwFileType
9912>>>    DWord dwFileSubtype
9912>>>    //    DWord dwFileDateMS
9912>>>    //    DWord dwFileDateLS
9912>>>    UBigInt ubiFileDate
9912>>>End_Struct
9912>>>
9912>>>Struct tsFileVersionInfo
9912>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
9912>>>    tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
9912>>>    Short[] siFileVersion
9912>>>    Short[] siProductVersion
9912>>>    DateTime dtCreationDateTime
9912>>>    String sComments
9912>>>    String sCompanyName
9912>>>    String sFileDescription
9912>>>    String sFileVersion
9912>>>    String sInternalName
9912>>>    String sLegalCopyright
9912>>>    String sLegalTrademarks
9912>>>    String sOriginalFilename
9912>>>    String sProductName
9912>>>    String sProductVersion
9912>>>    String sPrivateBuild
9912>>>    String sSpecialBuild
9912>>>End_Struct
9912>>>
9912>>>Struct tsLandAndCodePage
9912>>>    UShort wLanguage
9912>>>    UShort wCodePage
9912>>>End_Struct
9912>>>
9912>>>Register_Function FileErrorText Integer iFilenumber Returns String
9912>>>
9912>>>//************************************************************************
9912>>>// The filesystem class
9912>>>//************************************************************************
9912>>>Class cFilesystem is a cObject
9913>>>
9913>>>    Procedure Construct_Object
9915>>>        Forward Send Construct_Object
9917>>>
9917>>>        // True then the end of the binary file had been read - not when $1A (EOF) is met.
9917>>>        // Legacy property. Use the BinaryFileEndOfFile function instead.
9917>>>        Property Boolean pbEOF False
9918>>>
9918>>>        // True if any error has occured during fileoprerations.
9918>>>        Property Boolean pbError False
9919>>>
9919>>>        // If errormessages should be called with dataflex error command set this to true
9919>>>        Property Boolean pbErrorAsVDFError False
9920>>>
9920>>>        // Keeps assigned handles and filenames For each filenumber.
9920>>>        // private
9920>>>        Property structFile[] plsFile
9921>>>
9921>>>        // Keeps read cached buffers For each filenumer. Used For BinaryReadChcheu
9921>>>        // private
9921>>>        Property String[] psaCachedBuffer
9922>>>
9922>>>        // Pointers For cached buffers.
9922>>>        // private
9922>>>        Property structFileBufferPointer[] plsCachedPointer
9923>>>    End_Procedure
9924>>>
9924>>>    // Returns the next available filenumber For a binary file.
9924>>>    Function BinaryFileNextFilenumber Returns Integer
9926>>>        structFile[] lsFile
9926>>>        structFile[] lsFile
9927>>>        Integer iMaxFiles iCurrentFile iNextFileNumber
9927>>>        Get plsFile to lsFile
9928>>>        Move (SizeOfArray(lsFile)) to iMaxFiles
9929>>>        Move -1 to iNextFileNumber
9930>>>        Move 0 to iCurrentFile
9931>>>        While (iCurrentFile < iMaxFiles and iNextFileNumber = -1)
9935>>>            If (lsFile[iCurrentFile].hFilehandle = 0) Begin
9937>>>                Move iCurrentFile to iNextFileNumber
9938>>>            End
9938>>>>
9938>>>            Else Begin
9939>>>                Increment iCurrentFile
9940>>>            End
9940>>>>
9940>>>        Loop
9941>>>>
9941>>>        If (iNextFileNumber = -1) Begin
9943>>>            Move iMaxFiles to iNextFileNumber
9944>>>        End
9944>>>>
9944>>>        Function_Return iNextFileNumber
9945>>>    End_Function
9946>>>
9946>>>    // Opens a binary file.
9946>>>    // If bShared is false or not pharsed the file is opened in exclusive.
9946>>>    // If bShared is True the file is opened with both read and write shared mode
9946>>>    // If bCreate is True the file is created if it does not exist already.
9946>>>    // If bReadOnly is True the file is opened with only read access (and only read shared mode if bShared is also true).
9946>>>    // Returns true if the file was opened or created without error.
9946>>>    Function BinaryFileOpen Integer iFilenumber String sFilename Boolean bShared Boolean bCreate Boolean bReadOnly Returns Boolean
9948>>>        Integer iReturnValue iErrornumber
9948>>>        DWord dwSharedMode dwCreateMode dwAccessMode
9948>>>        structFile[] lsFile
9948>>>        structFile[] lsFile
9949>>>        String sFilenameANSI
9949>>>        Boolean bOk bFilehandleOK
9949>>>        Get plsFile to lsFile
9950>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
9952>>>            If (lsFile[iFilenumber].hFilehandle = 0) Begin
9954>>>                Move True to bFilehandleOK
9955>>>            End
9955>>>>
9955>>>        End
9955>>>>
9955>>>        Else Begin
9956>>>            Move True to bFilehandleOK
9957>>>        End
9957>>>>
9957>>>        If bFilehandleOK Begin
9959>>>            Move sFilename to lsFile[iFilenumber].sFilename
9960>>>            Move (ToAnsi(sFilename)) to sFilenameANSI
9961>>>            Set pbError to False
9962>>>            Move False to bOk
9963>>>            Move GENERIC_RANDOM to dwAccessMode
9964>>>            Move FNULL to dwSharedMode
9965>>>            If (num_arguments > 2) Begin
9967>>>                If (bShared = True) Begin
9969>>>                    Move FILE_SHARE_RANDOM to dwSharedMode
9970>>>                End
9970>>>>
9970>>>            End
9970>>>>
9970>>>            Move OPEN_EXISTING to dwCreateMode
9971>>>            If (num_arguments > 3) Begin
9973>>>                If (bCreate = True) Begin
9975>>>                    Move OPEN_ALWAYS to dwCreateMode
9976>>>                End
9976>>>>
9976>>>            End
9976>>>>
9976>>>            If (num_arguments > 4) Begin
9978>>>                If (bReadOnly = True) Begin
9980>>>                    Move GENERIC_READ to dwAccessMode
9981>>>                    If (bShared = True) Begin
9983>>>                        Move FILE_SHARE_READ to dwSharedMode
9984>>>                    End
9984>>>>
9984>>>                End
9984>>>>
9984>>>            End
9984>>>>
9984>>>            Append sFilenameANSI (Character(0)) (Character(0))
9986>>>            Move (fsCreatefile(AddressOf(sFilenameANSI), dwAccessMode, dwSharedMode, FNULL, dwCreateMode, FILE_ATTRIBUTE_NORMAL, FNULL)) to iReturnValue
9987>>>            If (iReturnValue = INVALID_HANDLE_VALUE) Begin
9989>>>                Move (fsGetLastError()) to iErrornumber
9990>>>                If iErrornumber Begin
9992>>>                    Send DoShowError iErrornumber ("File: "+ sFilename)
9993>>>                End
9993>>>>
9993>>>            End
9993>>>>
9993>>>            Else Begin
9994>>>                Move iReturnValue to lsFile[iFilenumber].hFilehandle
9995>>>                Move False to lsFile[iFilenumber].bEndOfFile
9996>>>                Set plsFile to lsFile
9997>>>                Set pbEOF to False
9998>>>                Move True to bOk
9999>>>            End
9999>>>>
9999>>>        End
9999>>>>
9999>>>        Else Begin
10000>>>            Send warning_box "The filenumber is already used."
10001>>>        End
10001>>>>
10001>>>        Function_Return bOk
10002>>>    End_Function
10003>>>
10003>>>    // Closing a binary file
10003>>>    // Returns true if the file could be closed.
10003>>>    Function BinaryFileClose Integer iFilenumber Returns Boolean
10005>>>        Integer iRetVal iErrorNumber
10005>>>        Handle hHandle
10005>>>        structFile[] lsFile
10005>>>        structFile[] lsFile
10006>>>        structFileBufferPointer[] lsFileBufferPointer
10006>>>        structFileBufferPointer[] lsFileBufferPointer
10007>>>        String[] saCachedBuffer
10008>>>        Boolean bOk
10008>>>        Get BinaryFileHandle iFilenumber to hHandle
10009>>>        Set pbError to False
10010>>>        Move False to bOk
10011>>>        If hHandle Begin
10013>>>            Move (fsCloseHandle(hHandle)) to iRetVal
10014>>>            If (iRetVal = 0) Begin           // Could not close
10016>>>                Move (fsGetLastError()) to iErrorNumber
10017>>>                If iErrorNumber Begin
10019>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10020>>>                End
10020>>>>
10020>>>            End
10020>>>>
10020>>>            Else Begin
10021>>>                Get plsFile to lsFile
10022>>>                Get plsCachedPointer to lsFileBufferPointer
10023>>>                Get psaCachedBuffer to saCachedBuffer
10024>>>                Move 0 to lsFile[iFilenumber].hFilehandle
10025>>>                Move "" to saCachedBuffer[iFilenumber]
10026>>>                Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
10027>>>                Move 0 to lsFileBufferPointer[iFilenumber].iBufferSize
10028>>>                Move 0 to lsFileBufferPointer[iFilenumber].biFromFilePosition
10029>>>                Set plsFile to lsFile
10030>>>                Set plsCachedPointer to lsFileBufferPointer
10031>>>                Set psaCachedBuffer to saCachedBuffer
10032>>>                Move True to bOk
10033>>>            End
10033>>>>
10033>>>        End
10033>>>>
10033>>>        Function_Return bOk
10034>>>    End_Function
10035>>>
10035>>>    // Reading from a binary file.
10035>>>    // The data read from the file is placed in sReadBuffer and the function returns the number of bytes read.
10035>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
10035>>>    // No errors occures if you try to read past end of file.
10035>>>    // To speed up reading process you should read in a block of data at a time (i.e. iNumberOfBytes = 2000) instead of
10035>>>    // reading one byte at a time. No errors occures if you try to read past end
10035>>>    // of file. Note that iNumberOfBytes must not exceed the argument size.
10035>>>    Function BinaryFileRead Integer iFilenumber Integer iNumberOfBytes String ByRef sReadBuffer Returns Integer
10037>>>        Handle hFileHandle
10037>>>        Integer iBytesRead iMaxBuffer iErrorNumber
10037>>>        Boolean bOk
10037>>>        structFile[] lsFile
10037>>>        structFile[] lsFile
10038>>>        Set pbError to False
10039>>>        Move 0 to iBytesRead
10040>>>        Get_Argument_Size to iMaxBuffer
10041>>>        If (iNumberOfBytes > iMaxBuffer) Begin
10043>>>            Send warning_box "Blocksize to read exceeds argument size!"
10044>>>            Function_Return iBytesRead
10045>>>        End
10045>>>>
10045>>>        If (iNumberOfBytes < 1) Begin
10047>>>            Send warning_box "Number of bytes to read can not be less than one."
10048>>>            Function_Return iBytesRead
10049>>>        End
10049>>>>
10049>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10050>>>        If hFileHandle Begin
10052>>>            Move (ZeroString(iNumberOfBytes)) to sReadBuffer
10053>>>            Move (fsReadFile(hFileHandle, AddressOf(sReadBuffer), iNumberOfBytes, (AddressOf(iBytesRead)), FNULL)) to bOk
10054>>>            If (bOk = False) Begin
10056>>>                Move (fsGetLastError()) to iErrorNumber
10057>>>                If iErrorNumber Begin
10059>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10060>>>                End
10060>>>>
10060>>>            End
10060>>>>
10060>>>            Else Begin
10061>>>                If (iBytesRead = 0 or iBytesRead <> iNumberOfBytes) Begin
10063>>>                    Get plsFile to lsFile
10064>>>                    Move True to lsFile[iFilenumber].bEndOfFile
10065>>>                    Set plsFile to lsFile
10066>>>                    Set pbEOF to True
10067>>>                    Move (Left(sReadBuffer, iBytesRead)) to sReadBuffer
10068>>>                End
10068>>>>
10068>>>            End
10068>>>>
10068>>>        End
10068>>>>
10068>>>        Else Begin
10069>>>            Send warning_box FS_FILEHANDLEMISSING
10070>>>        End
10070>>>>
10070>>>        Function_Return iBytesRead
10071>>>    End_Function
10072>>>
10072>>>    // Reading from a binary file until a string of bytes are matched.
10072>>>    // The data read from the file is placed in the sReturnBuffer and the function returns the number of bytes read until the match is read including the match.
10072>>>    // Then the function returns 0 the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
10072>>>    // The return string buffer would also be empty.
10072>>>    // No errors occures if you try to read past end of file.
10072>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
10072>>>    Function BinaryFileReadCachedUntilMatch Integer iFilenumber String sMatchString String ByRef sReturnBuffer Boolean ByRef bEndOfFile Returns Integer
10074>>>        Handle hFileHandle
10074>>>        Integer iBuffersize iMatchPos iLengthMatch
10074>>>        String sByte
10074>>>        structFile[] lsFile
10074>>>        structFile[] lsFile
10075>>>        structFileBufferPointer[] lsFileBufferPointer
10075>>>        structFileBufferPointer[] lsFileBufferPointer
10076>>>        String[] saCachedBuffer
10077>>>        Get plsFile to lsFile
10078>>>        Move "" to sReturnBuffer
10079>>>        Move 1 to iMatchPos
10080>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
10082>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
10083>>>            If (hFileHandle <> 0) Begin
10085>>>                Move (Length(sMatchString)) to iLengthMatch
10086>>>                Get plsCachedPointer to lsFileBufferPointer
10087>>>                Get psaCachedBuffer to saCachedBuffer
10088>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
10090>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
10091>>>                    Move "" to saCachedBuffer[iFilenumber]
10092>>>                End
10092>>>>
10092>>>                Repeat
10092>>>>
10092>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer > lsFileBufferPointer[iFilenumber].iBufferSize) Begin
10094>>>                        Get_Argument_Size to iBuffersize
10095>>>                        Get BinaryFilePosition iFilenumber to lsFileBufferPointer[iFilenumber].biFromFilePosition
10096>>>                        Get BinaryFileRead iFilenumber iBuffersize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer[iFilenumber].iBufferSize
10097>>>                        Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
10098>>>                        Set psaCachedBuffer to saCachedBuffer
10099>>>                    End
10099>>>>
10099>>>                    If (lsFileBufferPointer[iFilenumber].iBufferPointer =< lsFileBufferPointer[iFilenumber].iBufferSize) Begin
10101>>>                        Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer[iFilenumber].iBufferPointer)) to sByte
10102>>>                        Increment lsFileBufferPointer[iFilenumber].iBufferPointer
10103>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
10104>>>                        If (sByte = Mid(sMatchString, 1, iMatchPos)) Begin
10106>>>                            Increment iMatchPos
10107>>>                        End
10107>>>>
10107>>>                        Else Begin
10108>>>                            Move 1 to iMatchPos
10109>>>                        End
10109>>>>
10109>>>                    End
10109>>>>
10109>>>                Until (iMatchPos > iLengthMatch or lsFileBufferPointer[iFilenumber].iBufferSize = 0)
10111>>>                Set plsCachedPointer to lsFileBufferPointer
10112>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
10114>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
10115>>>                End
10115>>>>
10115>>>            End
10115>>>>
10115>>>            Else Begin
10116>>>                Send warning_box FS_FILEHANDLEMISSING
10117>>>            End
10117>>>>
10117>>>        End
10117>>>>
10117>>>        Function_Return (Length(sReturnBuffer))
10118>>>    End_Function
10119>>>
10119>>>    // Reading from a binary file as CSV file For next text field.
10119>>>    // The data read from the file is placed in the sReturnBuffer excluding the separator and the function returns true.
10119>>>    // Then the function returns false the end of file has been reached (pbEOF will then be true) or an error has occured (pbError will then be true).
10119>>>    // When the end of row data has been read the bEndOfRow is set true.
10119>>>    // The end of row is indicated with sCharEOL. If that is not applied the charactersequence character(13) + character(10) is used.
10119>>>    // The return string buffer would also be empty.
10119>>>    // No errors occures if you try to read past end of file.
10119>>>    // To speed up reading process the buffer will be read in sizes of the current argument_size.
10119>>>    Function BinaryFileReadCachedCSV Integer iFilenumber String sFieldseparator String sTextQualification String ByRef sReturnBuffer Boolean ByRef bEndOfRow Boolean ByRef bEndOfFile String sCharEOL Returns Integer
10121>>>        Handle hFileHandle
10121>>>        Integer iLengthSeparator iLengthTextQualification iEOLLength iTestLength
10121>>>        String sByte sEOL sTestBuffer
10121>>>        structFile[] lsFile
10121>>>        structFile[] lsFile
10122>>>        structFileBufferPointer[] lsFileBufferPointer
10122>>>        structFileBufferPointer[] lsFileBufferPointer
10123>>>        String[] saCachedBuffer
10124>>>        Boolean bInTextFieldMode bTextFieldReady bFieldSeparator bTextQualificator bEscapeTextQualificatorTest bByteOk
10124>>>        BigInt biAfterTextQualificator
10124>>>        Get plsFile to lsFile
10125>>>        If (num_arguments > 6) Begin
10127>>>            Move sCharEOL to sEOL
10128>>>        End
10128>>>>
10128>>>        Else Begin
10129>>>            Move ((Character(13))+(Character(10))) to sEOL
10130>>>        End
10130>>>>
10130>>>        Move (Length(sEOL)) to iEOLLength
10131>>>        Move "" to sReturnBuffer
10132>>>        Move "" to sByte
10133>>>        Move False to bInTextFieldMode
10134>>>        Move False to bTextFieldReady
10135>>>        Move False to bEndOfRow
10136>>>        Move False to bTextQualificator
10137>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
10139>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
10140>>>            If (hFileHandle <> 0) Begin
10142>>>                Move (Length(sFieldseparator)) to iLengthSeparator
10143>>>                Move (Length(sTextQualification)) to iLengthTextQualification
10144>>>                Get plsCachedPointer to lsFileBufferPointer
10145>>>                Get psaCachedBuffer to saCachedBuffer
10146>>>
10146>>>                If (iFilenumber >= SizeOfArray(lsFileBufferPointer)) Begin
10148>>>                    Move 1 to lsFileBufferPointer[iFilenumber].iBufferPointer
10149>>>                    Move "" to saCachedBuffer[iFilenumber]
10150>>>                End
10150>>>>
10150>>>                Repeat
10150>>>>
10150>>>                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
10151>>>                    If bByteOk Begin
10153>>>                        Move (sReturnBuffer + sByte) to sReturnBuffer
10154>>>                        Move (Right(sReturnBuffer, iLengthSeparator) = sFieldseparator) to bFieldSeparator
10155>>>                        If bFieldSeparator Begin
10157>>>                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthSeparator))) to sReturnBuffer
10158>>>                            Move True to bTextFieldReady
10159>>>                            Move False to bEscapeTextQualificatorTest
10160>>>                        End
10160>>>>
10160>>>                        If (not(bTextFieldReady)) Begin
10162>>>                            Move (Right(sReturnBuffer, iEOLLength) = sEOL) to bEndOfRow
10163>>>                            If bEndOfRow Begin
10165>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iEOLLength))) to sReturnBuffer
10166>>>                                Move True to bTextFieldReady
10167>>>                            End
10167>>>>
10167>>>                        End
10167>>>>
10167>>>                        If (not(bTextFieldReady)) Begin
10169>>>                            Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
10170>>>                            If bTextQualificator Begin
10172>>>                            // Read until end of text field. Place filepointer after text field.
10172>>>                                Move True to bInTextFieldMode
10173>>>                                Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
10174>>>                                Repeat
10174>>>>
10174>>>                                    Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
10175>>>                                    If bByteOk Begin
10177>>>                                        Move (sReturnBuffer + sByte) to sReturnBuffer
10178>>>                                        Move (Right(sReturnBuffer, iLengthTextQualification) = sTextQualification) to bTextQualificator
10179>>>                                        If bTextQualificator Begin
10181>>>                                        // Either it is the end of the text field or the escape text qualificator has been read.
10181>>>                                        // Read ahead to a new buffer to see if the next bytes are the text qualificator.
10181>>>                                        // If it is, add the new buffer to the return buffer.
10181>>>                                        // If not, restore the filebuffer to this position and mark the text field ended.
10181>>>                                            Move (Left(sReturnBuffer, (Length(sReturnBuffer) - iLengthTextQualification))) to sReturnBuffer
10182>>>                                            Set plsCachedPointer to lsFileBufferPointer
10183>>>                                            Get BinaryFileCachedPosition iFilenumber to biAfterTextQualificator
10184>>>                                            Move "" to sTestBuffer
10185>>>                                            Move 0 to iTestLength
10186>>>                                            Move True to bEscapeTextQualificatorTest
10187>>>                                            Repeat
10187>>>>
10187>>>                                                Get NextByteCSV (&iFilenumber) (&lsFileBufferPointer[iFilenumber]) (&saCachedBuffer) (&sByte) to bByteOk
10188>>>                                                If bByteOk Begin
10190>>>                                                    Move (sTestBuffer + sByte) to sTestBuffer
10191>>>                                                    Increment iTestLength
10192>>>                                                    If (Left(sTextQualification, iTestLength) = sTestBuffer) Begin
10194>>>                                                        If (iTestLength = iLengthTextQualification) Begin
10196>>>                                                            Move (sReturnBuffer + sTestBuffer) to sReturnBuffer
10197>>>                                                            Move False to bEscapeTextQualificatorTest
10198>>>                                                        End
10198>>>>
10198>>>                                                    End
10198>>>>
10198>>>                                                    Else Begin
10199>>>                                                        Set BinaryFileChachedPosition iFilenumber to biAfterTextQualificator
10200>>>                                                        Get plsCachedPointer to lsFileBufferPointer
10201>>>                                                        Move False to bEscapeTextQualificatorTest
10202>>>                                                        Move False to bInTextFieldMode
10203>>>                                                    End
10203>>>>
10203>>>                                                End
10203>>>>
10203>>>                                            Until (bEscapeTextQualificatorTest = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
10205>>>                                        End
10205>>>>
10205>>>                                    End
10205>>>>
10205>>>                                Until (bInTextFieldMode = False or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
10207>>>                            End
10207>>>>
10207>>>                        End
10207>>>>
10207>>>                    End
10207>>>>
10207>>>                Until (bTextFieldReady = True or lsFileBufferPointer[iFilenumber].iBufferSize = 0 or bByteOk = False)
10209>>>                Set plsCachedPointer to lsFileBufferPointer
10210>>>                If (lsFileBufferPointer[iFilenumber].iBufferSize = 0) Begin
10212>>>                    Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
10213>>>                    If (bEndOfFile = True) Begin
10215>>>                        Move True to bTextFieldReady
10216>>>                        Move True to bEndOfRow
10217>>>                    End
10217>>>>
10217>>>                End
10217>>>>
10217>>>            End
10217>>>>
10217>>>            Else Begin
10218>>>                Send warning_box FS_FILEHANDLEMISSING
10219>>>            End
10219>>>>
10219>>>        End
10219>>>>
10219>>>        Function_Return bTextFieldReady
10220>>>    End_Function
10221>>>
10221>>>    Function NextByteCSV Integer ByRef iFilenumber structFileBufferPointer ByRef lsFileBufferPointer String[] ByRef saCachedBuffer String ByRef sByte Returns String
10223>>>        Integer iBufferSize
10223>>>        Boolean bOk
10223>>>        If (lsFileBufferPointer.iBufferPointer > lsFileBufferPointer.iBufferSize) Begin
10225>>>            Get_Argument_Size to iBufferSize
10226>>>            Get BinaryFilePosition iFilenumber to lsFileBufferPointer.biFromFilePosition
10227>>>            Get BinaryFileRead iFilenumber iBufferSize (&saCachedBuffer[iFilenumber]) to lsFileBufferPointer.iBufferSize
10228>>>            Move 1 to lsFileBufferPointer.iBufferPointer
10229>>>            Set psaCachedBuffer to saCachedBuffer
10230>>>        End
10230>>>>
10230>>>        If (lsFileBufferPointer.iBufferPointer <= lsFileBufferPointer.iBufferSize) Begin
10232>>>            Move (Mid(saCachedBuffer[iFilenumber], 1, lsFileBufferPointer.iBufferPointer)) to sByte
10233>>>            Increment lsFileBufferPointer.iBufferPointer
10234>>>            Move True to bOk
10235>>>        End
10235>>>>
10235>>>        Function_Return bOk
10236>>>    End_Function
10237>>>
10237>>>    // Shortcut to read a binary file as lines from a textfile.
10237>>>    // Reads from cached file until sCharEOL are recieved.
10237>>>    // Data is returned without the ending sCharEOL
10237>>>    // If sCharEOL is not applied the charactersequence character(13) + character(10) is used.
10237>>>    // Returns True when the line has been read.
10237>>>    Function BinaryFileReadCachedLN Integer iFilenumber String ByRef sLine Boolean ByRef bEndOfFile String sCharEOL Returns Boolean
10239>>>        Boolean bEndOfRow
10239>>>        Integer iBytesRead iEOLLength
10239>>>        String sEOL
10239>>>        If (num_arguments > 3) Begin
10241>>>            Move sCharEOL to sEOL
10242>>>        End
10242>>>>
10242>>>        Else Begin
10243>>>            Move ((Character(13))+(Character(10))) to sEOL
10244>>>        End
10244>>>>
10244>>>        Move (Length(sEOL)) to iEOLLength
10245>>>        Get BinaryFileReadCachedUntilMatch iFilenumber sEOL (&sLine) (&bEndOfFile) to iBytesRead
10246>>>        If (iBytesRead > 0) Begin
10248>>>            If (Right(sLine, iEOLLength) = sEOL) Begin
10250>>>                Move (Left(sLine, (Length(sLine) - iEOLLength))) to sLine
10251>>>                Move True to bEndOfRow
10252>>>            End
10252>>>>
10252>>>        End
10252>>>>
10252>>>        Function_Return bEndOfRow
10253>>>    End_Function
10254>>>
10254>>>    // Writing to a binary file.
10254>>>    // Returns true if the data was written to the file without error.
10254>>>    Function BinaryFileWrite Integer iFilenumber String ByRef sWriteData Returns Boolean
10256>>>        Integer iBytesWritten iBytesToWrite iErrorNumber
10256>>>        Handle hFileHandle
10256>>>        Boolean bOk
10256>>>        Set pbError to False
10257>>>        Move False to bOk
10258>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10259>>>        If hFileHandle Begin
10261>>>            Move 0 to iBytesWritten
10262>>>            Move (Length(sWriteData)) to iBytesToWrite
10263>>>            Move (fsWriteFile(hFileHandle, AddressOf(sWriteData), iBytesToWrite, AddressOf(iBytesWritten), FNULL)) to bOk
10264>>>            If (bOk = False) Begin
10266>>>                Move (fsGetLastError()) to iErrorNumber
10267>>>                If iErrorNumber Begin
10269>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10270>>>                End
10270>>>>
10270>>>            End
10270>>>>
10270>>>            If (iBytesToWrite <> iBytesWritten) Begin
10272>>>                Send Warning_box "Not all data could be written!"
10273>>>                Move False to bOk
10274>>>            End
10274>>>>
10274>>>        End
10274>>>>
10274>>>        Else Begin
10275>>>            Send Warning_Box FS_FILEHANDLEMISSING
10276>>>        End
10276>>>>
10276>>>        Function_Return bOk
10277>>>    End_Function
10278>>>
10278>>>    // Write HEX values to a binary file as bytes.
10278>>>    // HEX values in sWriteHEX are first coverted to bytes and then written
10278>>>    // to the binary file.
10278>>>    // Returns true if the HEX data was written to the file without error.
10278>>>    Function BinaryFileWriteHex Integer iFilenumer String ByRef sWriteHex Returns Boolean
10280>>>        String sData
10280>>>        Integer iLength iCount iByte
10280>>>        Boolean bOk
10280>>>        Move (Length(sWritehex)) to iLength
10281>>>        Move 1 to iCount
10282>>>        While (iCount < iLength)
10286>>>            Move ("$"+Mid(sWriteHex, 2, iCount)) to iByte
10287>>>            Move (iCount + 2) to iCount
10288>>>            Move (sData + Character(iByte)) to sData
10289>>>        Loop
10290>>>>
10290>>>        Get BinaryFileWrite iFilenumer (&sData) to bOk
10291>>>        Function_Return bOk
10292>>>    End_Function
10293>>>
10293>>>    // Retrives the file size from a binary file.
10293>>>    Function BinaryFileSize Integer iFilenumber Returns BigInt
10295>>>        BigInt biFilesize
10295>>>        Handle hFileHandle
10295>>>        Boolean bOk
10295>>>        Integer iErrorNumber
10295>>>        Set pbError to False
10296>>>        Move -1 to biFilesize
10297>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10298>>>        If hFileHandle Begin
10300>>>        // The LARGE_INTEGER structure has the same structure as a BigInt.
10300>>>            Move (fsGetFileSizeEx(hFileHandle, AddressOf(biFilesize))) to bOk
10301>>>            If (bOk = -False) Begin
10303>>>                Move (fsGetLastError()) to iErrorNumber
10304>>>                If iErrorNumber Begin
10306>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10307>>>                End
10307>>>>
10307>>>            End
10307>>>>
10307>>>        End
10307>>>>
10307>>>        Else Begin
10308>>>            Send warning_box FS_FILEHANDLEMISSING
10309>>>        End
10309>>>>
10309>>>        Function_Return biFilesize
10310>>>    End_Function
10311>>>
10311>>>    // Retrives the file position from a binary file.
10311>>>    // Returns -1 if an error occured.
10311>>>    Function BinaryFilePosition Integer iFilenumber Returns BigInt
10313>>>        BigInt biFilePosition biBigHi
10313>>>        Handle hFileHandle
10313>>>        Boolean bOk
10313>>>        Integer iErrorNumber iLo iHi
10313>>>        UInteger iNewPos
10313>>>
10313>>>        Set pbError to False
10314>>>        Move -1 to biFilePosition
10315>>>        Move 0 to iHi
10316>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10317>>>        If hFileHandle Begin
10319>>>            Move (2^32) to biBigHi
10320>>>            Move (fsSetFilePointer(hFileHandle, ilo, AddressOf(iHi), FILE_CURRENT)) to iNewPos
10321>>>            If (iNewPos = (biBigHi - 1)) Begin
10323>>>                Move (fsGetLastError()) to iErrorNumber
10324>>>                If iErrorNumber Begin
10326>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10327>>>                End
10327>>>>
10327>>>                Else Begin
10328>>>                    Move True to bOk
10329>>>                End
10329>>>>
10329>>>            End
10329>>>>
10329>>>            Else Begin
10330>>>                Move True to bOk
10331>>>            End
10331>>>>
10331>>>            If bOk Begin
10333>>>                Move ((iHi * biBigHi) + iNewPos) to biFilePosition
10334>>>            End
10334>>>>
10334>>>        End
10334>>>>
10334>>>        Else Begin
10335>>>            Send warning_box FS_FILEHANDLEMISSING
10336>>>        End
10336>>>>
10336>>>        Function_Return biFilePosition
10337>>>    End_Function
10338>>>
10338>>>    // Sets the file position from a binary file to a new position.
10338>>>    Procedure Set BinaryFilePosition Integer iFilenumber BigInt biPosition
10340>>>        Handle hFileHandle
10340>>>        Integer iHi iErrorNumber
10340>>>        UInteger iLo iNewPos
10340>>>        Boolean bOk
10340>>>        BigInt biFileSize biBigHi
10340>>>        structFile[] lsFile
10340>>>        structFile[] lsFile
10341>>>
10341>>>        Set pbError to False
10342>>>        Move False to bOk
10343>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10344>>>        If hFileHandle Begin
10346>>>            Move (2^32) to biBigHi
10347>>>            Move (biPosition / biBigHi) to iHi
10348>>>            Move (biPosition - (iHi * biBigHi)) to iLo
10349>>>            Move (fsSetFilePointer(hFileHandle, iLo, AddressOf(iHi), FILE_BEGIN)) to iNewPos
10350>>>            If (iNewPos = (biBigHi - 1)) Begin
10352>>>                Move (fsGetLastError()) to iErrorNumber
10353>>>                If iErrorNumber Begin
10355>>>                    Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10356>>>                End
10356>>>>
10356>>>                Else Begin
10357>>>                    Move True to bOk
10358>>>                End
10358>>>>
10358>>>            End
10358>>>>
10358>>>            Else Begin
10359>>>                Move True to bOk
10360>>>            End
10360>>>>
10360>>>            If bOk Begin
10362>>>                Get BinaryFileSize iFilenumber to biFileSize
10363>>>                Get plsFile to lsFile
10364>>>                If (biFileSize > biPosition) Begin
10366>>>                    Move False to lsFile[iFilenumber].bEndOfFile
10367>>>                    Set pbEOF to False
10368>>>                End
10368>>>>
10368>>>                Else Begin
10369>>>                    Move True to lsFile[iFilenumber].bEndOfFile
10370>>>                    Set pbEOF to True
10371>>>                End
10371>>>>
10371>>>                Set plsFile to lsFile
10372>>>            End
10372>>>>
10372>>>        End
10372>>>>
10372>>>        Else Begin
10373>>>            Send warning_box FS_FILEHANDLEMISSING
10374>>>        End
10374>>>>
10374>>>        Set pbError to (not(bOk))
10375>>>    End_Procedure
10376>>>
10376>>>    // Returns -1 if an error occured.
10376>>>    Function BinaryFileCachedPosition Integer iFileNumber Returns BigInt
10378>>>        BigInt biPosition
10378>>>        structFileBufferPointer[] lsFileBufferPointer
10378>>>        structFileBufferPointer[] lsFileBufferPointer
10379>>>        Handle hFileHandle
10379>>>        Move -1 to biPosition
10380>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10381>>>        If hFileHandle Begin
10383>>>            Get plsCachedPointer to lsFileBufferPointer
10384>>>            If (iFilenumber < SizeOfArray(lsFileBufferPointer)) Begin
10386>>>                If (lsFileBufferPointer[iFileNumber].iBufferSize > 0) Begin
10388>>>                    Move (lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferPointer - 1) to biPosition
10389>>>                End
10389>>>>
10389>>>                Else Begin
10390>>>                    Get BinaryFilePosition iFileNumber to biPosition
10391>>>                End
10391>>>>
10391>>>            End
10391>>>>
10391>>>            Else Begin
10392>>>                Get BinaryFilePosition iFileNumber to biPosition
10393>>>            End
10393>>>>
10393>>>        End
10393>>>>
10393>>>        Else Begin
10394>>>            Send Warning_Box FS_FILEHANDLEMISSING
10395>>>        End
10395>>>>
10395>>>        Function_Return biPosition
10396>>>    End_Function
10397>>>
10397>>>    // Sets the pointer For the current file cache.
10397>>>    Procedure Set BinaryFileChachedPosition Integer iFileNumber BigInt biNewPosition
10399>>>        Handle hFileHandle
10399>>>        structFileBufferPointer[] lsFileBufferPointer
10399>>>        structFileBufferPointer[] lsFileBufferPointer
10400>>>        String[] saCachedBuffer
10401>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10402>>>        If hFileHandle Begin
10404>>>            Get plsCachedPointer to lsFileBufferPointer
10405>>>            If (lsFileBufferPointer[iFileNumber].biFromFilePosition > biNewPosition) Begin
10407>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
10408>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
10409>>>                Set plsCachedPointer to lsFileBufferPointer
10410>>>                Set BinaryFilePosition iFileNumber to biNewPosition
10411>>>                Get psaCachedBuffer to saCachedBuffer
10412>>>                Move "" to saCachedBuffer[iFileNumber]
10413>>>                Set psaCachedBuffer to saCachedBuffer
10414>>>            End
10414>>>>
10414>>>            Else If ((lsFileBufferPointer[iFileNumber].biFromFilePosition + lsFileBufferPointer[iFileNumber].iBufferSize) < biNewPosition) Begin
10417>>>                Move 1 to lsFileBufferPointer[iFileNumber].iBufferPointer
10418>>>                Move 0 to lsFileBufferPointer[iFileNumber].iBufferSize
10419>>>                Set plsCachedPointer to lsFileBufferPointer
10420>>>                Set BinaryFilePosition iFileNumber to biNewPosition
10421>>>                Get psaCachedBuffer to saCachedBuffer
10422>>>                Move "" to saCachedBuffer[iFileNumber]
10423>>>                Set psaCachedBuffer to saCachedBuffer
10424>>>            End
10424>>>>
10424>>>            Else Begin
10425>>>                Move (biNewPosition - lsFileBufferPointer[iFileNumber].biFromFilePosition + 1) to lsFileBufferPointer[iFileNumber].iBufferPointer
10426>>>                Set plsCachedPointer to lsFileBufferPointer
10427>>>            End
10427>>>>
10427>>>        End
10427>>>>
10427>>>        Else Begin
10428>>>            Send warning_box FS_FILEHANDLEMISSING
10429>>>        End
10429>>>>
10429>>>    End_Procedure
10430>>>
10430>>>    // Truncate or extend a binary file to the specified file position
10430>>>    // by setting the binary file End Of File position.
10430>>>    // If biPosition is -1 the current file position is used as EOF position.
10430>>>    Procedure Set BinaryFileEndOfFile Integer iFilenumber BigInt biPosition
10432>>>        Handle hFileHandle
10432>>>        Boolean bError bOk
10432>>>        Integer iErrorNumber
10432>>>        structFile[] lsFile
10432>>>        structFile[] lsFile
10433>>>        Set pbError to False
10434>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10435>>>        If hFileHandle Begin
10437>>>            If (biPosition > -1) Begin
10439>>>                Set BinaryFilePosition iFilenumber to biPosition
10440>>>            End
10440>>>>
10440>>>            Get pbError to bError
10441>>>            If (bError = False) Begin
10443>>>                Move (fsSetEndOfFile(hFileHandle)) to bOk
10444>>>                If (bOk = False) Begin
10446>>>                    Move (fsGetLastError()) to iErrorNumber
10447>>>                    If iErrorNumber Begin
10449>>>                        Send DoShowError iErrorNumber (FileErrorText(Self, iFilenumber))
10450>>>                    End
10450>>>>
10450>>>                End
10450>>>>
10450>>>                Else Begin
10451>>>                    Get plsFile to lsFile
10452>>>                    Move True to lsFile[iFilenumber].bEndOfFile
10453>>>                    Set plsFile to lsFile
10454>>>                    Set pbEOF to True
10455>>>                End
10455>>>>
10455>>>            End
10455>>>>
10455>>>        End
10455>>>>
10455>>>        Else Begin
10456>>>            Send warning_box FS_FILEHANDLEMISSING
10457>>>        End
10457>>>>
10457>>>        Set pbError to (not(bOk))
10458>>>    End_Procedure
10459>>>
10459>>>    // Returns true if the last read from the binary file had reached the end.
10459>>>    Function BinaryFileEndOfFile Integer iFilenumber Returns Boolean
10461>>>        structFile[] lsFile
10461>>>        structFile[] lsFile
10462>>>        Handle hFileHandle
10462>>>        Boolean bEndOfFile
10462>>>        Move True to bEndOfFile
10463>>>        Set pbError to False
10464>>>        Get BinaryFileHandle iFilenumber to hFileHandle
10465>>>        If hFileHandle Begin
10467>>>            Get plsFile to lsFile
10468>>>            Move lsFile[iFilenumber].bEndOfFile to bEndOfFile
10469>>>        End
10469>>>>
10469>>>        Else Begin
10470>>>            Send warning_box FS_FILEHANDLEMISSING
10471>>>        End
10471>>>>
10471>>>        Function_Return bEndOfFile
10472>>>    End_Function
10473>>>
10473>>>    // Returns the filehandle from the filenumber.
10473>>>    // Returns 0 if the filenumber is not used.
10473>>>    Function BinaryFileHandle Integer iFilenumber Returns Handle
10475>>>        Handle hFileHandle
10475>>>        structFile[] lsFile
10475>>>        structFile[] lsFile
10476>>>        Get plsFile to lsFile
10477>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
10479>>>            Move lsFile[iFilenumber].hFilehandle to hFileHandle
10480>>>        End
10480>>>>
10480>>>        Function_Return hFileHandle
10481>>>    End_Function
10482>>>
10482>>>    // Searches For a file
10482>>>    // iMode = DIRMODE_FILES_ONLY (default)
10482>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
10482>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES
10482>>>    // Returns True if found
10482>>>    Function FileExists String sFilePathMask Integer iFileDirMode Returns Boolean
10484>>>        Integer iMode
10484>>>        Boolean bFound
10484>>>        tsSearchResult[] lsResult
10484>>>        tsSearchResult[] lsResult
10485>>>        Move False to bFound
10486>>>        Set pbError to False
10487>>>        If (num_arguments < 2) Begin
10489>>>            Move DIRMODE_FILES_ONLY to iMode
10490>>>        End
10490>>>>
10490>>>        Else Begin
10491>>>            Move iFileDirMode to iMode
10492>>>        End
10492>>>>
10492>>>        Get FileSearch sFilePathMask iMode True to lsResult
10493>>>        If (SizeOfArray(lsResult) > 0) Begin
10495>>>            Move True to bFound
10496>>>        End
10496>>>>
10496>>>        Function_Return bFound
10497>>>    End_Function
10498>>>
10498>>>    // Deletes a file.
10498>>>    // Returns True if succeeds.
10498>>>    Function FileDelete String sFilename Integer iRetryAttempts Returns Boolean
10500>>>        Boolean bFound bDeleted
10500>>>        Integer iErrorNumber iRetryLeft
10500>>>        String sFilenameANSI
10500>>>        Set pbError to False
10501>>>        If (num_arguments > 1) Begin
10503>>>            Move iRetryAttempts to iRetryLeft
10504>>>        End
10504>>>>
10504>>>        Else Begin
10505>>>            Move 0 to iRetryLeft
10506>>>        End
10506>>>>
10506>>>        Get FileExists sFilename to bFound
10507>>>        If bFound Begin
10509>>>            Repeat
10509>>>>
10509>>>                Move (ToAnsi(sFilename)) to sFilenameANSI
10510>>>                Move (sFilenameANSI+(Character(0))) to sFilenameANSI
10511>>>                Move (fsDeleteFile(AddressOf(sFilenameANSI))) to bDeleted
10512>>>                If (bDeleted = False) Begin
10514>>>                    Decrement iRetryLeft
10515>>>                    If (iRetryLeft <= 0) Begin
10517>>>                        Move (fsGetLastError()) to iErrorNumber
10518>>>                        If iErrorNumber Begin
10520>>>                            Send DoShowError iErrorNumber ("Tried to delete file: "+sFilename)
10521>>>                        End
10521>>>>
10521>>>                    End
10521>>>>
10521>>>                    Else Begin
10522>>>                        Sleep 1
10523>>>                    End
10523>>>>
10523>>>                End
10523>>>>
10523>>>            Until (bDeleted = True or iRetryLeft <= 0)
10525>>>        End
10525>>>>
10525>>>        Function_Return bDeleted
10526>>>    End_Function
10527>>>
10527>>>    // Moves a file or directory.
10527>>>    // Returns True if succeeds.
10527>>>    Function FileMove String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
10529>>>        Boolean bMoved
10529>>>        Integer iErrorNumber iRetryLeft
10529>>>        String sExistingFilenameANSI sNewFileNameANSI
10529>>>        Set pbError to False
10530>>>        If (num_arguments > 2) Begin
10532>>>            Move iRetryAttempts to iRetryLeft
10533>>>        End
10533>>>>
10533>>>        Else Begin
10534>>>            Move 0 to iRetryLeft
10535>>>        End
10535>>>>
10535>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileNameANSI
10536>>>        Move (ToAnsi(sNewFileName)) to sNewFileNameANSI
10537>>>        Move (sExistingFilenameANSI+(Character(0))) to sExistingFilenameANSI
10538>>>        Move (sNewFileNameANSI+(Character(0))) to sNewFileNameANSI
10539>>>        Repeat
10539>>>>
10539>>>            Move (fsMoveFile(AddressOf(sExistingFilenameANSI), AddressOf(sNewFileNameANSI))) to bMoved
10540>>>            If (bMoved = False) Begin
10542>>>                Decrement iRetryLeft
10543>>>                If (iRetryLeft <= 0) Begin
10545>>>                    Move (fsGetLastError()) to iErrorNumber
10546>>>                    If iErrorNumber Begin
10548>>>                        Send DoShowError iErrorNumber ("Tried to move/rename file: "+sExistingFileName+" to "+sNewFileName)
10549>>>                    End
10549>>>>
10549>>>                End
10549>>>>
10549>>>                Else Begin
10550>>>                    Sleep 1
10551>>>                End
10551>>>>
10551>>>            End
10551>>>>
10551>>>        Until (bMoved = True or iRetryLeft <= 0)
10553>>>        Function_Return bMoved
10554>>>    End_Function
10555>>>
10555>>>    // Copies a file. Overwriting an existing file by default.
10555>>>    // Returns True if succeeds.
10555>>>    Function FileCopy String sExistingFileName String sNewFileName Boolean bFailIfExists Integer iRetryAttempts Returns Boolean
10557>>>        Boolean bCopied
10557>>>        String sExistingFileNameANSI sNewFileNameANSI
10557>>>        Boolean bDoNotOverwrite
10557>>>        Integer iErrorNumber iRetryLeft
10557>>>        Set pbError to False
10558>>>        Move (ToAnsi(sExistingFileName)) to sExistingFileNameANSI
10559>>>        Move (ToAnsi(sNewFileName)) to sNewFileNameANSI
10560>>>        Move (sExistingFileNameANSI+(Character(0))) to sExistingFileNameANSI
10561>>>        Move (sNewFileNameANSI+(Character(0))) to sNewFileNameANSI
10562>>>        If (Num_Arguments > 2) Begin
10564>>>            Move bFailIfExists to bDoNotOverwrite
10565>>>        End
10565>>>>
10565>>>        Else Begin
10566>>>            Move False to bDoNotOverwrite
10567>>>        End
10567>>>>
10567>>>        If (num_arguments > 3) Begin
10569>>>            Move iRetryAttempts to iRetryLeft
10570>>>        End
10570>>>>
10570>>>        Else Begin
10571>>>            Move 0 to iRetryLeft
10572>>>        End
10572>>>>
10572>>>        Repeat
10572>>>>
10572>>>            Move (fsCopyFile(AddressOf(sExistingFileNameANSI), AddressOf(sNewFileNameANSI), bDoNotOverwrite)) to bCopied
10573>>>            If (bCopied = False) Begin
10575>>>                Decrement iRetryLeft
10576>>>                If (iRetryLeft <= 0) Begin
10578>>>                    Move (fsGetLastError()) to iErrorNumber
10579>>>                    If iErrorNumber Begin
10581>>>                        Send DoShowError iErrorNumber ("Tried to copy file: "+sExistingFileName+" to "+sNewFileName)
10582>>>                    End
10582>>>>
10582>>>                End
10582>>>>
10582>>>                Else Begin
10583>>>                    Sleep 1
10584>>>                End
10584>>>>
10584>>>            End
10584>>>>
10584>>>        Until (bCopied = True or iRetryLeft <= 0)
10586>>>        Function_Return bCopied
10587>>>    End_Function
10588>>>
10588>>>    // Renames a file or directory.
10588>>>    // Returns True if succeeds.
10588>>>    Function FileRename String sExistingFileName String sNewFileName Integer iRetryAttempts Returns Boolean
10590>>>        Boolean bRenamed
10590>>>        If (num_arguments > 2) Begin
10592>>>            Get FileMove sExistingFileName sNewFileName iRetryAttempts to bRenamed
10593>>>        End
10593>>>>
10593>>>        Else Begin
10594>>>            Get FileMove sExistingFileName sNewFileName to bRenamed
10595>>>        End
10595>>>>
10595>>>        Function_Return bRenamed
10596>>>    End_Function
10597>>>
10597>>>    // Returns the file size of a file.
10597>>>    // Returns -1 if an error occured.
10597>>>    Function FileSize String sFilename Returns BigInt
10599>>>        tsSearchResult[] lsSearchResult
10599>>>        tsSearchResult[] lsSearchResult
10600>>>        BigInt iRetval
10600>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
10601>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
10603>>>            Move lsSearchResult[0].biFileSize to iRetval
10604>>>        End
10604>>>>
10604>>>        Else Begin
10605>>>            Move -1 to iRetval
10606>>>        End
10606>>>>
10606>>>        Function_Return iRetval
10607>>>    End_Function
10608>>>
10608>>>    // Returns the last write date of a file.
10608>>>    // Returns 0 if an error occured.
10608>>>    Function FileDate String sFilename Returns Date
10610>>>        tsSearchResult[] lsSearchResult
10610>>>        tsSearchResult[] lsSearchResult
10611>>>        Date dDate
10611>>>        Move 0 to dDate
10612>>>        Get FileSearch sFilename DIRMODE_FILES_ONLY to lsSearchResult
10613>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
10615>>>            Move lsSearchResult[0].dtLastWriteDateTime to dDate
10616>>>        End
10616>>>>
10616>>>        Function_Return dDate
10617>>>    End_Function
10618>>>
10618>>>    // Returns the fileversion info.
10618>>>    // Returns false if an error occured.
10618>>>    Function FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Boolean
10620>>>        Boolean bOk
10620>>>        Integer iErrorNumber iStatus
10620>>>        Get _FileVersion sFilename (&lsFileVersionInfo) to iStatus
10621>>>        If (iStatus = -1) Begin
10623>>>            Move (fsGetLastError()) to iErrorNumber
10624>>>            If iErrorNumber Begin
10626>>>                Send DoShowError iErrorNumber ("Tried to get fileversion info from file: "+sFilename)
10627>>>            End
10627>>>>
10627>>>        End
10627>>>>
10627>>>        Move (iStatus = 0) to bOk
10628>>>        Function_Return bOk
10629>>>    End_Function
10630>>>
10630>>>    Function _FileVersion String sFilename tsFileVersionInfo ByRef lsFileVersionInfo Returns Integer
10632>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
10632>>>        tsVS_FIXEDFILEINFO lsFIXEDFILEINFO
10632>>>        UInteger iBytesNeeded
10632>>>        Address aBuffer
10632>>>        Boolean bOk
10632>>>        String sSubBlock
10632>>>        DWord dwBufferLen dwBufferPointer
10632>>>        tsLandAndCodePage lsLandAndCodePage
10632>>>        tsLandAndCodePage lsLandAndCodePage
10632>>>        Move (ToANSI(sFilename)) to sFilename
10633>>>        Move (sFilename + (Character(0))) to sFilename
10634>>>        Move 0 to iBytesNeeded
10635>>>        Move 0 to aBuffer
10636>>>        Move 0 to lsFIXEDFILEINFO.dwStrucVersion    // Initialize the variable.
10637>>>        Move 0 to lsLandAndCodePage.wCodePage
10638>>>        Move (fsGetFileVersionInfoSize(AddressOf(sFilename), 0)) to iBytesNeeded
10639>>>        If (iBytesNeeded = 0) Begin
10641>>>            Function_Return False
10642>>>        End
10642>>>>
10642>>>        Move False to bOk
10643>>>        Move (Alloc(iBytesNeeded)) to aBuffer
10644>>>        Move (MemSet(aBuffer, 0, iBytesNeeded)) to bOk
10645>>>        Move (fsGetFileVersionInfo(AddressOf(sFilename), 0, iBytesNeeded, aBuffer)) to bOk
10646>>>        If (not(bOk)) Begin
10648>>>            Move (Free(aBuffer)) to bOk
10649>>>            Function_Return -1
10650>>>        End
10650>>>>
10650>>>        Move "\" to sSubBlock
10651>>>        Move (sSubBlock + (Character(0))) to sSubBlock
10652>>>        Move 0 to dwBufferLen
10653>>>        Move 0 to dwBufferPointer
10654>>>        Move (fsVerQueryValue(aBuffer, AddressOf(sSubBlock), AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
10655>>>        If (not(bOk)) Begin
10657>>>            Move (Free(aBuffer)) to bOk
10658>>>            Function_Return -1
10659>>>        End
10659>>>>
10659>>>        If (dwBufferLen <> 52) Begin
10661>>>            Send warning_box (SFormat("Length of bufferdata For VS_FIXEDFILEINFO struct are not in the expected size.\nLength is %1 and should have been 52.", dwBufferLen))
10662>>>            Move (Free(aBuffer)) to bOk
10663>>>            Function_Return -2
10664>>>        End
10664>>>>
10664>>>        Move (MemCopy(AddressOf(lsFIXEDFILEINFO), dwBufferPointer, dwBufferLen)) to bOk
10665>>>        If (not(bOk)) Begin
10667>>>            Move (Free(aBuffer)) to bOk
10668>>>            Function_Return -1
10669>>>        End
10669>>>>
10669>>>        Move lsFIXEDFILEINFO to lsFileVersionInfo.lsFIXEDFILEINFO
10670>>>        Get ConvertFileTileToLocalDateTime lsFIXEDFILEINFO.ubiFileDate to lsFileVersionInfo.dtCreationDateTime
10671>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[0]
10672>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionMS)) to lsFileVersionInfo.siFileVersion[1]
10673>>>        Move (Hi(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[2]
10674>>>        Move (Low(lsFIXEDFILEINFO.dwFileVersionLS)) to lsFileVersionInfo.siFileVersion[3]
10675>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[0]
10676>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionMS)) to lsFileVersionInfo.siProductVersion[1]
10677>>>        Move (Hi(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[2]
10678>>>        Move (Low(lsFIXEDFILEINFO.dwProductVersionLS)) to lsFileVersionInfo.siProductVersion[3]
10679>>>        Move "\VarFileInfo\Translation" to sSubBlock
10680>>>        Move (sSubBlock + (Character(0))) to sSubBlock
10681>>>        Move 0 to dwBufferLen
10682>>>        Move 0 to dwBufferPointer
10683>>>        Move (fsVerQueryValue(aBuffer, AddressOf(sSubBlock), AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
10684>>>        If (not(bOk)) Begin
10686>>>            Move (Free(aBuffer)) to bOk
10687>>>            Function_Return -1
10688>>>        End
10688>>>>
10688>>>        If (dwBufferLen <> 4) Begin
10690>>>            Send warning_box (SFormat("Length of bufferdata For land and codepage nunbers are not in the expected size.\nLength is %1 and should have been 4.", dwBufferLen))
10691>>>            Move (Free(aBuffer)) to bOk
10692>>>            Function_Return -2
10693>>>        End
10693>>>>
10693>>>        Move (MemCopy(AddressOf(lsLandAndCodePage), dwBufferPointer, dwBufferLen)) to bOk
10694>>>        Get VerQueryValueStringFileInfo aBuffer "Comments" lsLandAndCodePage to lsFileVersionInfo.sComments
10695>>>        Get VerQueryValueStringFileInfo aBuffer "CompanyName" lsLandAndCodePage to lsFileVersionInfo.sCompanyName
10696>>>        Get VerQueryValueStringFileInfo aBuffer "FileDescription" lsLandAndCodePage to lsFileVersionInfo.sFileDescription
10697>>>        Get VerQueryValueStringFileInfo aBuffer "FileVersion" lsLandAndCodePage to lsFileVersionInfo.sFileVersion
10698>>>        Get VerQueryValueStringFileInfo aBuffer "InternalName" lsLandAndCodePage to lsFileVersionInfo.sInternalName
10699>>>        Get VerQueryValueStringFileInfo aBuffer "LegalCopyright" lsLandAndCodePage to lsFileVersionInfo.sLegalCopyright
10700>>>        Get VerQueryValueStringFileInfo aBuffer "LegalTrademarks" lsLandAndCodePage to lsFileVersionInfo.sLegalTrademarks
10701>>>        Get VerQueryValueStringFileInfo aBuffer "OriginalFilename" lsLandAndCodePage to lsFileVersionInfo.sOriginalFilename
10702>>>        Get VerQueryValueStringFileInfo aBuffer "ProductName" lsLandAndCodePage to lsFileVersionInfo.sProductName
10703>>>        Get VerQueryValueStringFileInfo aBuffer "ProductVersion" lsLandAndCodePage to lsFileVersionInfo.sProductVersion
10704>>>        Get VerQueryValueStringFileInfo aBuffer "PrivateBuild" lsLandAndCodePage to lsFileVersionInfo.sPrivateBuild
10705>>>        Get VerQueryValueStringFileInfo aBuffer "SpecialBuild" lsLandAndCodePage to lsFileVersionInfo.sSpecialBuild
10706>>>        Move (Free(aBuffer)) to bOk
10707>>>        Function_Return 0
10708>>>    End_Function
10709>>>
10709>>>    // Convert an short integer to a 4-character hex string.
10709>>>    Function ShortToHex Short siValue Returns String
10711>>>        String sHex
10711>>>        Move "" to sHex
10712>>>        Repeat
10712>>>>
10712>>>            Move (Mid ("0123456789ABCDEF", 1, ((siValue iand |CI$0F) + 1)) + sHex) to sHex
10713>>>            Move (siValue / |CI$10) to siValue
10714>>>        Until (siValue = 0)
10716>>>        Move (Right("0000" + sHex, 4)) to sHex
10717>>>        Function_Return sHex
10718>>>    End_Function
10719>>>
10719>>>    Function VerQueryValueStringFileInfo Address aBuffer String sInfoName tsLandAndCodePage lsLandAndCodePage Returns String
10721>>>        String sSubBlock
10721>>>        String sValue
10721>>>        DWord dwBufferLen dwBufferPointer
10721>>>        Boolean bOk
10721>>>        Move (SFormat("\StringFileInfo\%1%2\%3", ShortToHex(Self, lsLandAndCodePage.wLanguage), ShortToHex(Self, lsLandAndCodePage.wCodePage), sInfoName)) to sSubBlock
10722>>>        Move (sSubBlock + (Character(0))) to sSubBlock
10723>>>        Move 0 to dwBufferLen
10724>>>        Move 0 to dwBufferPointer
10725>>>        Move (fsVerQueryValue(aBuffer, AddressOf(sSubBlock), AddressOf(dwBufferPointer), AddressOf(dwBufferLen))) to bOk
10726>>>        If (not(bOk)) Begin
10728>>>            Function_Return ""
10729>>>        End
10729>>>>
10729>>>        Move (ZeroString(dwBufferLen)) to sValue
10730>>>        Move (MemCopy(AddressOf(sValue), dwBufferPointer, dwBufferLen)) to bOk
10731>>>        Function_Return (ToOEM(CString(sValue)))
10732>>>    End_Function
10733>>>
10733>>>    // Returns the file extention without the leading "."
10733>>>    // Example sFile = "x:\text.txt". The function returns "txt".
10733>>>    Function FileExtention String sFilename Returns String
10735>>>        String sExtention
10735>>>        Integer iPos
10735>>>        Move (RightPos(".", sFilename)) to iPos
10736>>>        If (iPos > 0) Begin
10738>>>            Move (Right(sFilename, (Length(sFilename) - iPos))) to sExtention
10739>>>            If (sExtention contains "\" or sExtention contains " ") Begin
10741>>>                Move "" to sExtention
10742>>>            End
10742>>>>
10742>>>        End
10742>>>>
10742>>>        Function_Return sExtention
10743>>>    End_Function
10744>>>
10744>>>    // Gets a handle to an icon stored as a resource in a file or an icon
10744>>>    // stored in a file's associated executable file.
10744>>>    // When the icon handle is no longer needed, close it by using the DestroyFileIcon procedure.
10744>>>    Function FileIcon String sFilename Returns Handle
10746>>>        Handle hIcon
10746>>>        Integer iIcon
10746>>>        String sFilenameANSI
10746>>>        Move 0 to iIcon
10747>>>        Move (ToANSI(sFilename)) to sFilenameANSI
10748>>>        Move (Pad(sFilenameANSI, 128)) to sFilenameANSI
10749>>>        Move (fsExtractAssociatedIcon(0, AddressOf(sFilenameANSI), AddressOf(iIcon))) to hIcon
10750>>>        Function_Return hIcon
10751>>>    End_Function
10752>>>
10752>>>    // Destroy hIcon, created from FileIcon.
10752>>>    Procedure DestroyFileIcon Handle hIcon
10754>>>        Integer iResult
10754>>>        If (hIcon <> 0) Begin
10756>>>            Move (fsDestroyIcon(hIcon)) to iResult
10757>>>        End
10757>>>>
10757>>>    End_Procedure
10758>>>
10758>>>    // Search a directory For the files with normal windows mask-signs
10758>>>    // Returns an array of matching files and directories
10758>>>    // iMode = DIRMODE_FILES_ONLY
10758>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
10758>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
10758>>>    // If bReturnOnlyOne is true only one search result item is returned.
10758>>>    // If bReturnOnlyOne is true and no items where found no error is shown.
10758>>>    Function FileSearch String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
10760>>>        tsSearchResult[] lsSearchResult
10760>>>        tsSearchResult[] lsSearchResult
10761>>>        Integer iSearchResultCount iMode iErrorNumber
10761>>>        structWFD lsFindData
10761>>>        structWFD lsFindData
10761>>>        String sFilePathMaskANSI
10761>>>        Handle hFindFile
10761>>>        Boolean bError bStop bFound bOk bOnlyOne
10761>>>        BigInt biBigHi
10761>>>        Address aFileName
10761>>>
10761>>>        If (num_arguments < 2) Begin
10763>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
10764>>>        End
10764>>>>
10764>>>        Else Begin
10765>>>            Move iFileDirMode to iMode
10766>>>        End
10766>>>>
10766>>>        If (num_arguments < 3) Begin
10768>>>            Move False to bOnlyOne
10769>>>        End
10769>>>>
10769>>>        Else Begin
10770>>>            Move bReturnOnlyOne to bOnlyOne
10771>>>        End
10771>>>>
10771>>>        Move (ToAnsi(sFilePathMask)) to sFilePathMaskANSI
10772>>>        Move 0 to lsFindData.dwFileAttributes   // Initialize lsFindData
10773>>>        Move (fsFindFirstFile(AddressOf(sFilePathMaskANSI), AddressOf(lsFindData))) to hFindFile
10774>>>        If (hFindFile <> INVALID_HANDLE_VALUE) Begin
10776>>>            Move False to bError
10777>>>            Move False to bStop
10778>>>            Move (2^32) to biBigHi
10779>>>            Set pbError to bError
10780>>>            While (bError = False and bStop = False)
10784>>>                Move False to bFound
10785>>>                Case Begin
10785>>>                    Case (iMode = DIRMODE_FILES_ONLY)
10787>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = 0) Begin
10789>>>                            Move True to bFound
10790>>>                        End
10790>>>>
10790>>>                        Case Break
10791>>>                    Case (iMode = DIRMODE_DIRECTORIES_ONLY)
10794>>>                        If (lsFindData.dwFileAttributes iand FILE_ATTRIBUTE_DIRECTORY = FILE_ATTRIBUTE_DIRECTORY) Begin
10796>>>                            Move True to bFound
10797>>>                        End
10797>>>>
10797>>>                        Case Break
10798>>>                    Case Else
10798>>>                        Move True to bFound
10799>>>                        Case Break
10800>>>                Case End
10800>>>                If bFound Begin
10802>>>                    Move (AddressOf(lsFindData.cFileName)) to aFilename
10803>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sFilename
10804>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sFilename)) to lsSearchResult[iSearchResultCount].sFilename 
10805>>>                    Move (AddressOf(lsFindData.cAlternateFileName)) to aFilename
10806>>>                    Move aFilename to lsSearchResult[iSearchResultCount].sAlternateFileName
10807>>>                    Move (ToOEM(lsSearchResult[iSearchResultCount].sAlternateFileName)) to lsSearchResult[iSearchResultCount].sAlternateFileName
10808>>>                    Move lsFindData.dwFileAttributes to lsSearchResult[iSearchResultCount].iFileAttributes
10809>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftCreationDateTime to lsSearchResult[iSearchResultCount].dtCreationDateTime
10810>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftLastAccessDateTime to lsSearchResult[iSearchResultCount].dtLastAccessDateTime
10811>>>                    Get ConvertFileTileToLocalDateTime lsFindData.ftLastWriteDateTime to lsSearchResult[iSearchResultCount].dtLastWriteDateTime
10812>>>                    Move ((lsFindData.nFileSizeHigh * biBigHi) + lsFindData.nFileSizeLow) to lsSearchResult[iSearchResultCount].biFileSize
10813>>>                    Increment iSearchResultCount
10814>>>                    If bOnlyOne Begin
10816>>>                        Move True to bStop
10817>>>                    End
10817>>>>
10817>>>                End
10817>>>>
10817>>>                If (bStop = False) Begin
10819>>>                    Move (fsFindNextFile(hFindFile, AddressOf(lsFindData))) to bOk
10820>>>                End
10820>>>>
10820>>>                If (bOk = False) Begin
10822>>>                    Move True to bStop
10823>>>                    If (bOnlyOne = False) Begin
10825>>>                        Move (fsGetLastError()) to iErrorNumber
10826>>>                        If (iErrorNumber <> ERROR_NO_MORE_FILES and iErrorNumber <> ERROR_MOD_NOT_FOUND and iErrorNumber <> 0) Begin
10828>>>                            Send DoShowError iErrorNumber ("Search path: "+sFilePathMask)
10829>>>                        End
10829>>>>
10829>>>                    End
10829>>>>
10829>>>                End
10829>>>>
10829>>>                Get pbError to bError
10830>>>            Loop
10831>>>>
10831>>>            Move (fsFindClose(hFindFile)) to bOk
10832>>>        End
10832>>>>
10832>>>        Function_Return lsSearchResult
10833>>>    End_Function
10834>>>
10834>>>    // Search a directory and all subdirectories For the files with normal windows mask-signs.
10834>>>    // lsResult[?].sFileName contains full path and filename.
10834>>>    // iMode = DIRMODE_FILES_ONLY
10834>>>    // iMode = DIRMODE_DIRECTORIES_ONLY
10834>>>    // iMode = DIRMODE_FILES_AND_DIRECTORIES (default)
10834>>>    Function FileSearchRecursive String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne Returns tsSearchResult[]
10836>>>        Integer iMode
10836>>>        Boolean bOnlyOne
10836>>>        tsSearchResult[] lsFinalResult lsSearchResult
10836>>>        tsSearchResult[] lsFinalResult lsSearchResult
10838>>>        If (num_arguments < 2) Begin
10840>>>            Move DIRMODE_FILES_AND_DIRECTORIES to iMode
10841>>>        End
10841>>>>
10841>>>        Else Begin
10842>>>            Move iFileDirMode to iMode
10843>>>        End
10843>>>>
10843>>>        If (num_arguments < 3) Begin
10845>>>            Move False to bOnlyOne
10846>>>        End
10846>>>>
10846>>>        Else Begin
10847>>>            Move bReturnOnlyOne to bOnlyOne
10848>>>        End
10848>>>>
10848>>>        Get FileSearchRecursivePriv sFilePathMask iMode bOnlyOne (&lsFinalResult) to lsSearchResult
10849>>>        Function_Return lsFinalResult
10850>>>    End_Function
10851>>>
10851>>>    // Private
10851>>>    Function FileSearchRecursivePriv String sFilePathMask Integer iFileDirMode Boolean bReturnOnlyOne tsSearchResult[] ByRef lsFinalResult Returns tsSearchResult[]
10853>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
10853>>>        tsSearchResult[] lsSearchResultDir lsSearchResult
10855>>>        Integer iMax iCnt iLast iFinalMax
10855>>>        String sSearchInDir sFileMask
10855>>>        Boolean bStop      
10855>>>        
10855>>>        Move False to bStop
10856>>>        Move (RightPos("\", sFilePathMask)) to iLast
10857>>>        If (iLast > 0) Begin
10859>>>            Move (Left(sFilePathMask, iLast - 1)) to sSearchInDir
10860>>>            Move (Mid(sFilePathMask, Length(sFilePathMask), iLast + 1)) to sFileMask
10861>>>        End
10861>>>>
10861>>>        Get FileSearch (sSearchInDir + "\*.*") DIRMODE_DIRECTORIES_ONLY to lsSearchResultDir
10862>>>        Move (SizeOfArray(lsSearchResultDir)) to iMax
10863>>>        Move 0 to iCnt
10864>>>        While (iCnt < iMax and bStop = False)
10868>>>            If (lsSearchResultDir[iCnt].sFilename <> "." and lsSearchResultDir[iCnt].sFilename <> "..") Begin
10870>>>                Get FileSearchRecursivePriv (sSearchInDir + "\" + lsSearchResultDir[iCnt].sFilename + "\" + sFileMask) iFileDirMode bReturnOnlyOne (&lsFinalResult) to lsSearchResult
10871>>>            End
10871>>>>
10871>>>            Increment iCnt
10872>>>            If (bReturnOnlyOne = True) Begin
10874>>>                If (SizeOfArray(lsFinalResult) > 0) Begin
10876>>>                    Move True to bStop
10877>>>                End
10877>>>>
10877>>>            End
10877>>>>
10877>>>        Loop
10878>>>>
10878>>>        If (bStop = False) Begin
10880>>>            Get FileSearch sFilePathMask iFileDirMode to lsSearchResult
10881>>>            Move (SizeOfArray(lsSearchResult)) to iMax
10882>>>            Move (SizeOfArray(lsFinalResult)) to iFinalMax
10883>>>            Move 0 to iCnt
10884>>>            While (iCnt < iMax and bStop = False)
10888>>>                Move lsSearchResult[iCnt] to lsFinalResult[iFinalMax]
10889>>>                Move (sSearchInDir + "\" + lsSearchResult[iCnt].sFilename) to lsFinalResult[iFinalMax].sFilename
10890>>>                Increment iFinalMax
10891>>>                Increment iCnt
10892>>>                If (bReturnOnlyOne = True) Begin
10894>>>                    If (SizeOfArray(lsFinalResult) > 0) Begin
10896>>>                        Move True to bStop
10897>>>                    End
10897>>>>
10897>>>                End
10897>>>>
10897>>>            Loop
10898>>>>
10898>>>        End
10898>>>>
10898>>>        Function_Return lsSearchResult
10899>>>    End_Function
10900>>>
10900>>>    // Finds a list of files.
10900>>>    // sSearchFiles is a list of files to search For separated by semicolon (;).
10900>>>    // sSearchFiles may not contain paths but may contain wildcards.
10900>>>    // sSearchPaths may only contain paths.
10900>>>    // Returns a string array with the files
10900>>>    // Returns only files with full path.
10900>>>    // Use:
10900>>>    // Get ListOfFiles "path1;path2" "*.txt;*.asc"
10900>>>    // This will return all the .txt and .asc files with full path that exists in path1 and path2.
10900>>>    Function ListOfFiles String sSearchPaths String sSearchFiles Returns String[]
10902>>>        String[] saFileList
10903>>>        Integer iFilelistCount iSearchFilesCount iCurSearchFile
10903>>>        Integer iSearchPathsCount iCurSearchPath iFilesFound iCurFileFound
10903>>>        String sCurSearchFile sCurSearchPath
10903>>>        tsSearchResult[] lsSearchResult
10903>>>        tsSearchResult[] lsSearchResult
10904>>>        Get CountOfFields sSearchPaths to iSearchPathsCount
10905>>>        Get CountOfFields sSearchFiles to iSearchFilesCount
10906>>>        If (iSearchFilesCount > 0 and iSearchPathsCount > 0) Begin
10908>>>            For iCurSearchFile from 1 to iSearchFilesCount
10914>>>>
10914>>>                Get FieldAtIndex sSearchFiles iCurSearchFile to sCurSearchFile
10915>>>                Move (Trim(sCurSearchFile)) to sCurSearchFile
10916>>>                If (sCurSearchFile <> "") Begin
10918>>>                    For iCurSearchPath from 1 to iSearchPathsCount
10924>>>>
10924>>>                        Get FieldAtIndex sSearchPaths iCurSearchPath to sCurSearchPath
10925>>>                        If (Right(sCurSearchPath, 1) <> "\") Begin
10927>>>                            Move (sCurSearchPath + "\") to sCurSearchPath
10928>>>                        End
10928>>>>
10928>>>                        Get FileSearch (sCurSearchPath + sCurSearchFile) DIRMODE_FILES_ONLY to lsSearchResult
10929>>>                        Move (SizeOfArray(lsSearchResult)) to iFilesFound
10930>>>                        Decrement iFilesFound
10931>>>                        For iCurFileFound from 0 to iFilesFound
10937>>>>
10937>>>                            Move (sCurSearchPath + lsSearchResult[iCurFileFound].sFilename) to saFileList[iFilelistCount]
10938>>>                            Increment iFilelistCount
10939>>>                        Loop
10940>>>>
10940>>>                    Loop
10941>>>>
10941>>>                End
10941>>>>
10941>>>            Loop
10942>>>>
10942>>>        End
10942>>>>
10942>>>        Function_Return saFileList
10943>>>    End_Function
10944>>>
10944>>>    // Get Windows Temp path
10944>>>    Function FileTempPath Returns String
10946>>>        String sTempPath
10946>>>        Integer iRetVal
10946>>>        Move (ZeroString(MAX_PATH)) to sTempPath
10947>>>        Move (fsGetTempPath(MAX_PATH, AddressOf(sTempPath))) to iRetVal
10948>>>        If (iRetVal > MAX_PATH) Begin
10950>>>            Move (ZeroString(iRetval)) to sTempPath
10951>>>            Move (fsGetTempPath(iRetVal, AddressOf(sTempPath))) to iRetVal
10952>>>        End
10952>>>>
10952>>>        Move (ToOEM(sTempPath)) to sTempPath
10953>>>        Move (CString(sTempPath)) to sTempPath
10954>>>        Function_Return sTempPath
10955>>>    End_Function
10956>>>
10956>>>    // Generates a temporary file.
10956>>>    // Returns full path and filename or blank if no file could be created.
10956>>>    // sPathName is the place where the temporary file is generated. If it is
10956>>>    // not argumented the TEMP enviroment variable is used. If that is also not
10956>>>    // available the current directory is used.
10956>>>    // You can prefix the first 3 letters of the filename with sPrefix.
10956>>>    Function FileTempFileName String sPathName String sPrefix Returns String
10958>>>        String sPathNameTmp sPrefixTmp sTempFileName
10958>>>        Boolean bOk
10958>>>        Set pbError to False
10959>>>        If (num_arguments > 0) Begin
10961>>>            Move sPathName to sPathNameTmp
10962>>>        End
10962>>>>
10962>>>        Else Begin
10963>>>            Move "" to sPathNameTmp
10964>>>        End
10964>>>>
10964>>>        If (num_arguments > 1) Begin
10966>>>            Move sPrefix to sPrefixTmp
10967>>>        End
10967>>>>
10967>>>        Else Begin
10968>>>            Move "" to sPrefixTmp
10969>>>        End
10969>>>>
10969>>>        Move (Trim(sPathNameTmp)) to sPathNameTmp
10970>>>        If (sPathNameTmp = "") Begin
10972>>>            Get FileTempPath to sPathNameTmp
10973>>>            If (sPathNameTmp = "") Begin
10975>>>                Move "." to sPathNameTmp
10976>>>            End
10976>>>>
10976>>>        End
10976>>>>
10976>>>        Move (ZeroString(MAX_PATH)) to sTempFilename
10977>>>        Move (ToANSI(sPathNameTmp)) to sPathNameTmp
10978>>>        Move (ToANSI(sPrefixTmp)) to sPrefixTmp
10979>>>        Move (fsGetTempFileName(AddressOf(sPathNameTmp), AddressOf(sPrefixTmp), 0, AddressOf(sTempFileName))) to bOk
10980>>>        If bOk Begin
10982>>>            Move (ToOEM(sTempFileName)) to sTempFileName
10983>>>            Move (CString(sTempFileName)) to sTempFileName
10984>>>        End
10984>>>>
10984>>>        Function_Return sTempFileName
10985>>>    End_Function
10986>>>
10986>>>    // Creates a new directory.
10986>>>    // Returns True if succeeds.
10986>>>    Function DirectoryCreate String sDirectoryName Returns Boolean
10988>>>        String sDirectorynameANSI
10988>>>        Boolean bFound bOk
10988>>>        Integer iErrorNumber
10988>>>        Move False to bOk
10989>>>        Set pbError to False
10990>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
10991>>>        If (not(bFound)) Begin
10993>>>            Move (toAnsi(sDirectoryName)) to sDirectorynameANSI
10994>>>            Move (sDirectorynameANSI+(Character(0))) to sDirectorynameANSI
10995>>>            Move (fsCreateDirectory(AddressOf(sDirectorynameANSI), FNULL)) to bOk
10996>>>            If (bOk = False) Begin           // Could not create
10998>>>                Move (fsGetLastError()) to iErrorNumber
10999>>>                If iErrorNumber Begin
11001>>>                    Send DoShowError iErrorNumber ("Tried to create directory: "+sDirectoryname)
11002>>>                End
11002>>>>
11002>>>            End
11002>>>>
11002>>>        End
11002>>>>
11002>>>        Function_Return bOk
11003>>>    End_Function
11004>>>
11004>>>    // Removes an existing empty directory.
11004>>>    // Returns True if succeeds.
11004>>>    Function DirectoryRemove String sDirectoryName Returns Boolean
11006>>>        String sDirectorynameANSI
11006>>>        Boolean bFound bOk
11006>>>        Integer iErrorNumber
11006>>>        Move False to bOk
11007>>>        Set pbError to False
11008>>>        Get FileExists sDirectoryName DIRMODE_DIRECTORIES_ONLY to bFound
11009>>>        If bFound Begin
11011>>>            Move (toAnsi(sDirectoryName)) to sDirectorynameANSI
11012>>>            Move (sDirectorynameANSI+(Character(0))) to sDirectorynameANSI
11013>>>            Move (fsRemoveDirectory(AddressOf(sDirectorynameANSI))) to bOk
11014>>>            If (bOk = False) Begin           // Could not delete
11016>>>                Move (fsGetLastError()) to iErrorNumber
11017>>>                If iErrorNumber Begin
11019>>>                    Send DoShowError iErrorNumber ("Tried to remove directory: "+sDirectoryName)
11020>>>                End
11020>>>>
11020>>>            End
11020>>>>
11020>>>        End
11020>>>>
11020>>>        Function_Return bOk
11021>>>    End_Function
11022>>>
11022>>>    // Removes a directory and all its contents.
11022>>>    // Returns true on succes.
11022>>>    Function DirectoryRemoveRecursive String sDirectoryName Returns Boolean
11024>>>        tsSearchResult[] alsSearchResults
11024>>>        tsSearchResult[] alsSearchResults
11025>>>        Integer iIndex
11025>>>        Boolean bOk
11025>>>
11025>>>        If (Right(sDirectoryName, 1) = "\") Begin
11027>>>            Move (Left(sDirectoryName, Length(sDirectoryName) - 1)) to sDirectoryName
11028>>>        End
11028>>>>
11028>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_DIRECTORIES_ONLY to alsSearchResults
11029>>>        For iIndex from 2 to (SizeOfArray(alsSearchResults) - 1)
11035>>>>
11035>>>            Get DirectoryRemoveRecursive (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
11036>>>            If (not(bOk)) Begin
11038>>>                Function_Return False
11039>>>            End
11039>>>>
11039>>>        Loop
11040>>>>
11040>>>        Get FileSearch (sDirectoryName + "\*") DIRMODE_FILES_ONLY to alsSearchResults
11041>>>        For iIndex from 0 to (SizeOfArray(alsSearchResults) - 1)
11047>>>>
11047>>>            Get FileDelete (sDirectoryName + "\" + alsSearchResults[iIndex].sFilename) to bOk
11048>>>            If (not(bOk)) Begin
11050>>>                Function_Return False
11051>>>            End
11051>>>>
11051>>>        Loop
11052>>>>
11052>>>        Get DirectoryRemove sDirectoryName to bOk
11053>>>        Function_Return bOk
11054>>>    End_Function
11055>>>
11055>>>    // Converts the filetime in UTC and returns a datetime in local time.
11055>>>    // private
11055>>>    Function ConvertFileTileToLocalDateTime UBigInt ubiFileTime Returns DateTime
11057>>>        Boolean bOk
11057>>>        UBigInt ubiZero
11057>>>        structSystemTime lsSystemTime lsLocalTime
11057>>>        structSystemTime lsSystemTime lsLocalTime
11057>>>        DateTime dtLocalTime
11057>>>        Move 0 to lsSystemTime.wDay
11058>>>        Move 0 to lsLocalTime.wDay
11059>>>        Move 0 to ubiZero
11060>>>        If (ubiFileTime <> ubiZero) Begin
11062>>>            Move (fsFileTimeToSystemTime(AddressOf(ubiFileTime), AddressOf(lsSystemTime))) to bOk
11063>>>            If bOk Begin
11065>>>                Move (fsSystemTimeToTzSpecificLocalTime(FNULL, AddressOf(lsSystemTime), AddressOf(lsLocalTime))) to bOk
11066>>>                If bOk Begin
11068>>>                    Move (DateSetYear(dtLocalTime, lsLocalTime.wYear)) to dtLocalTime
11069>>>                    Move (DateSetMonth(dtLocalTime, lsLocalTime.wMonth)) to dtLocalTime
11070>>>                    Move (DateSetDay(dtLocalTime, lsLocalTime.wDay)) to dtLocalTime
11071>>>                    Move (DateSetHour(dtLocalTime, lsLocalTime.wHour)) to dtLocalTime
11072>>>                    Move (DateSetMinute(dtLocalTime, lsLocalTime.wMinute)) to dtLocalTime
11073>>>                    Move (DateSetSecond(dtLocalTime, lsLocalTime.wSecond)) to dtLocalTime
11074>>>                    Move (DateSetMillisecond(dtLocalTime, lsLocalTime.wMillieseconds)) to dtLocalTime
11075>>>                End
11075>>>>
11075>>>            End
11075>>>>
11075>>>        End
11075>>>>
11075>>>        Function_Return dtLocalTime
11076>>>    End_Function
11077>>>
11077>>>    // Returns the filename with full path where the casing is preserved from windows.
11077>>>    Function FilePreservedFilename String sFilename Returns String
11079>>>        Integer iNumOfDirectories iCurrentDirectory
11079>>>        String sPreservedFilename sCurDir sSearchName
11079>>>        tsSearchResult[] lsSearchResult
11079>>>        tsSearchResult[] lsSearchResult
11080>>>
11080>>>        Get CountOfFields sFilename "\" to iNumOfDirectories
11081>>>        For iCurrentDirectory from 1 to (iNumOfDirectories - 1)
11087>>>>
11087>>>            Get FieldAtIndex sFilename iCurrentDirectory "\" to sCurDir
11088>>>            If (sCurDir <> "") Begin
11090>>>                If (Right(sCurDir, 1) <> ":") Begin
11092>>>                    Move (sPreservedFilename + sCurDir) to sSearchName
11093>>>                    Get FileSearch sSearchName DIRMODE_DIRECTORIES_ONLY to lsSearchResult
11094>>>                    If (SizeOfArray(lsSearchResult) > 0) Begin
11096>>>                        Move (sPreservedFilename + lsSearchResult[0].sFilename + "\") to sPreservedFilename
11097>>>                    End
11097>>>>
11097>>>                    Else Begin
11098>>>                        Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
11099>>>                    End
11099>>>>
11099>>>                End
11099>>>>
11099>>>                Else Begin
11100>>>                    Move (sPreservedFilename + sCurDir + "\") to sPreservedFilename
11101>>>                End
11101>>>>
11101>>>            End
11101>>>>
11101>>>            Else Begin
11102>>>                Move (sPreservedFilename + "\") to sPreservedFilename
11103>>>            End
11103>>>>
11103>>>        Loop
11104>>>>
11104>>>        Get FileSearch sFilename DIRMODE_FILES_AND_DIRECTORIES to lsSearchResult
11105>>>        If (SizeOfArray(lsSearchResult) > 0) Begin
11107>>>            Move (sPreservedFilename + lsSearchResult[0].sFilename) to sPreservedFilename
11108>>>        End
11108>>>>
11108>>>        Else Begin
11109>>>            Function_Return ""
11110>>>        End
11110>>>>
11110>>>        Function_Return sPreservedFilename
11111>>>    End_Function
11112>>>
11112>>>    // Returns the number of fields present in a string of fields seperated by a delimiter.
11112>>>    // If sDelimiter is not applied the ";" will be used.
11112>>>    Function CountOfFields String sFields String sDelimiter Returns Integer
11114>>>        Integer iChar icChar iField
11114>>>        String sDlm
11114>>>        If (sFields ="") Begin
11116>>>            Function_Return 0
11117>>>        End
11117>>>>
11117>>>        If (num_arguments > 1) Begin
11119>>>            Move sDelimiter to sDlm
11120>>>        End
11120>>>>
11120>>>        Else Begin
11121>>>            Move ";" to sDlm
11122>>>        End
11122>>>>
11122>>>        Move (Length(sFields) -1) to icChar
11123>>>        For iChar from 1 to icChar
11129>>>>
11129>>>            If (Mid(sFields, 1, iChar) = sDlm) Begin
11131>>>                Increment iField
11132>>>            End
11132>>>>
11132>>>        Loop
11133>>>>
11133>>>        Function_Return (iField +1)
11134>>>    End_Function
11135>>>
11135>>>    // Returns a field from a string containing multiple delimited fields.
11135>>>    // Index is 1-based.
11135>>>    Function FieldAtIndex String sFields Integer iIndex String sDelimiter Returns String
11137>>>        Integer iField iPos
11137>>>        String sField sDlm
11137>>>        If (num_arguments > 2) Begin
11139>>>            Move sDelimiter to sDlm
11140>>>        End
11140>>>>
11140>>>        Else Begin
11141>>>            Move ";" to sDlm
11142>>>        End
11142>>>>
11142>>>        Move (sFields + sDlm) to sFields
11143>>>        For iField from 1 to iIndex
11149>>>>
11149>>>            Move (Pos(sDlm, sFields)) to iPos
11150>>>            If iPos Begin
11152>>>                Move (Left(sFields, iPos -1)) to sField
11153>>>                Move (Right(sFields, Length(sFields) -iPos)) to sFields
11154>>>            End
11154>>>>
11154>>>            Else Begin
11155>>>                Function_Return ""
11156>>>            End
11156>>>>
11156>>>        Loop
11157>>>>
11157>>>        Function_Return sField
11158>>>    End_Function
11159>>>
11159>>>    // Removes the file extention from the sFile string and returns the extention including "."
11159>>>    // Example sFile = "x:\text.txt". The function returns ".txt" and sFile = "x:\text".
11159>>>    Function RemoveExtention String ByRef sFilename Returns String
11161>>>        String sExtention
11161>>>        Integer iLengthExtention
11161>>>        Get FileExtention sFilename to sExtention
11162>>>        Move (Length(sExtention)) to iLengthExtention
11163>>>        If (iLengthExtention > 0) Begin
11165>>>            Move (Left(sFilename, (Length(sFilename) - iLengthExtention - 1))) to sFilename
11166>>>        End
11166>>>>
11166>>>        Function_Return sExtention
11167>>>    End_Function
11168>>>
11168>>>    // Add a directory separator if it is not present.
11168>>>    // Example sFoldername = "x:\FolderA". The function returns "x:\FolderA\"
11168>>>    Function AddFolderSeperator String sFolderName Returns String
11170>>>        String sDirSep
11170>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
11171>>>        Move (Trim(sFolderName)) to sFolderName
11172>>>        If (Right(sFolderName, 1) <> sDirSep) Begin
11174>>>            Move (sFolderName + sDirSep) to sFolderName
11175>>>        End
11175>>>>
11175>>>        Function_Return sFolderName
11176>>>    End_Function
11177>>>
11177>>>    // Removes a directory separator if it is present.
11177>>>    // Example sFoldername = "x:\FolderA\". The function returns "x:\FolderA"
11177>>>    Function RemoveFolderSeperator String sFolderName Returns String
11179>>>        String sDirSep
11179>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
11180>>>        Move (Trim(sFolderName)) to sFolderName
11181>>>        If (Right(sFolderName, 1) = sDirSep) Begin
11183>>>            Move (Left(sFolderName, Length(sFolderName) - 1)) to sFolderName
11184>>>        End
11184>>>>
11184>>>        Function_Return sFolderName
11185>>>    End_Function
11186>>>
11186>>>    Function FileLastWriteTime String sFileName Returns tFileTime
11188>>>        DWord dwAccess
11188>>>        DWord dwShared
11188>>>        DWord dwCreate
11188>>>        Handle hFile
11188>>>        Integer iRetval iErrorNumber
11188>>>        tFileTime ftLastWrite
11188>>>        tFileTime ftLastWrite
11188>>>        //
11188>>>        Append sFilename (Character(0)) (Character(0))
11190>>>        Move (GENERIC_READ iOr GENERIC_WRITE) To dwAccess
11191>>>        Move FILE_SHARE_RANDOM   To dwShared
11192>>>        Move OPEN_EXISTING       To dwCreate
11193>>>
11193>>>        Move (fsCreatefile(AddressOf(sFilename), dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) To hFile
11194>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
11196>>>            Move (fsGetLastError()) To iErrorNumber
11197>>>            If iErrorNumber Begin
11199>>>                Send DoShowError iErrorNumber sFileName
11200>>>            End
11200>>>>
11200>>>            Procedure_Return
11201>>>        End
11201>>>>
11201>>>        Else Begin
11202>>>            Move 0 To ftLastWrite.dwLowDateTime
11203>>>            Move (fsGetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) To iRetval
11204>>>            If (iRetVal = 0) Begin           //Could not close
11206>>>                Move (fsGetLastError()) To iErrorNumber
11207>>>                If iErrorNumber Begin
11209>>>                    Send DoShowError iErrorNumber sFileName
11210>>>                End
11210>>>>
11210>>>            End
11210>>>>
11210>>>            Move (fsCloseHandle(hFile)) To iRetVal
11211>>>            If (iRetVal = 0) Begin           //Could not close
11213>>>                Move (fsGetLastError()) To iErrorNumber
11214>>>                If iErrorNumber Begin
11216>>>                    Send DoShowError iErrorNumber sFileName
11217>>>                End
11217>>>>
11217>>>            End
11217>>>>
11217>>>        End
11217>>>>
11217>>>        Function_Return ftLastWrite
11218>>>    End_Function
11219>>>
11219>>>    Function CurrentSystemTimeAsFileTime Returns tFileTime
11221>>>        Integer iRetVal
11221>>>        Integer iErrorNumber
11221>>>        String  sFileName
11221>>>        tFileTime ftCurrentTime
11221>>>        tFileTime ftCurrentTime
11221>>>
11221>>>        Move 0 to ftCurrentTime.dwLowDateTime
11222>>>        Move (fsGetSystemTimeAsFileTime(AddressOf(ftCurrentTime))) to iRetVal
11223>>>        If (iRetVal = 0) Begin
11225>>>            Move (fsGetLastError()) to iErrorNumber
11226>>>            If iErrorNumber Begin
11228>>>                Send DoShowError iErrorNumber sFileName
11229>>>            End
11229>>>>
11229>>>        End
11229>>>>
11229>>>        Function_Return ftCurrentTime
11230>>>    End_Function
11231>>>
11231>>>    // Nils 2018-08-30 Added this message from Akefs.pkg as we need it For the
11231>>>    // SourceCodeTools project
11231>>>    Procedure Set FileLastWriteTime String sFileName tFileTime ftLastWrite
11233>>>        DWord dwAccess dwShared dwCreate
11233>>>        Handle hFile
11233>>>        Integer iRetval iErrorNumber
11233>>>
11233>>>        Append sFilename (Character(0)) (Character(0))
11235>>>        Move (GENERIC_READ ior GENERIC_WRITE) to dwAccess
11236>>>        Move FILE_SHARE_RANDOM   to dwShared
11237>>>        Move OPEN_EXISTING       to dwCreate
11238>>>
11238>>>        Move (fsCreatefile(AddressOf(sFilename), dwAccess, dwShared, FNULL, dwCreate, FILE_ATTRIBUTE_NORMAL, FNULL)) to hFile
11239>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
11241>>>            Move (fsGetLastError()) to iErrorNumber
11242>>>            If (iErrorNumber <> 0) Begin
11244>>>                Send DoShowError iErrorNumber sFileName
11245>>>            End
11245>>>>
11245>>>            Procedure_Return
11246>>>        End
11246>>>>
11246>>>        Else Begin
11247>>>            Move (fsSetFileTime(hFile,FNULL,FNULL,AddressOf(ftLastWrite))) to iRetval
11248>>>            If (iRetVal = 0) Begin           //Could not close
11250>>>                Move (fsGetLastError()) to iErrorNumber
11251>>>                If (iErrorNumber <> 0) Begin
11253>>>                    Send DoShowError iErrorNumber sFileName
11254>>>                End
11254>>>>
11254>>>            End
11254>>>>
11254>>>            Move (fsCloseHandle(hFile)) to iRetVal
11255>>>            If (iRetVal = 0) Begin           //Could not close
11257>>>                Move (fsGetLastError()) to iErrorNumber
11258>>>                If (iErrorNumber <> 0) Begin
11260>>>                    Send DoShowError iErrorNumber sFileName
11261>>>                End
11261>>>>
11261>>>            End
11261>>>>
11261>>>        End
11261>>>>
11261>>>    End_Procedure
11262>>>
11262>>>    // Fetch the error message from the system message table using the default language.
11262>>>    Procedure DoShowError Integer iErrorNumber String sAppendErrorText
11264>>>        Pointer lpOut
11264>>>        Integer iRetChars iRetVal
11264>>>        String sMsg
11264>>>        Boolean bOk
11264>>>
11264>>>        Move 0 to lpOut
11265>>>        Move (fsFormatMessage((FORMAT_MESSAGE_FROM_SYSTEM+FORMAT_MESSAGE_IGNORE_INSERTS+FORMAT_MESSAGE_ALLOCATE_BUFFER), FNULL, iErrorNumber, FNULL, AddressOf(lpOut), 0, FNULL)) to iRetChars
11266>>>        If (iRetChars > 0) Begin
11268>>>            Move (ZeroString(iRetChars)) to sMsg
11269>>>            Move (MemCopy(AddressOf(sMsg), lpOut, iRetChars)) to bOk
11270>>>            Move (fsLocalFree(lpOut)) to iRetVal
11271>>>            Move (ToOEM(sMsg)) to sMsg
11272>>>            If (num_arguments > 0) Begin
11274>>>                Move (Trim(sAppendErrorText)) to sAppendErrorText
11275>>>                If (sAppendErrorText <> "") Begin
11277>>>                    Append sMsg "\n" sAppendErrorText
11279>>>                End
11279>>>>
11279>>>            End
11279>>>>
11279>>>            Send warning_box sMsg
11280>>>        End
11280>>>>
11280>>>    End_Procedure
11281>>>
11281>>>    // Shows a warning message to user with OK button and a exclamation icon.
11281>>>    // private
11281>>>    Procedure Warning_Box String sWngMsg
11283>>>        Integer iVoid
11283>>>        Boolean bSendVdfError
11283>>>        Set pbError to True
11284>>>        Get pbErrorAsVDFError to bSendVdfError
11285>>>        If (bSendVdfError = False) Begin
11287>>>            Get Message_Box sWngMsg "Filesystem Error" MB_OK MB_ICONEXCLAMATION to iVoid
11288>>>        End
11288>>>>
11288>>>        Else Begin
11289>>>            Error DFERR_PROGRAM sWngMsg
11290>>>>
11290>>>        End
11290>>>>
11290>>>    End_Procedure
11291>>>
11291>>>    // Fetch the filename from the list of filenames associated with a filenumber.
11291>>>    // This function is used For reporting filenames during an error.
11291>>>    // private
11291>>>    Function FileErrorText Integer iFilenumber Returns String
11293>>>        String sErrorText
11293>>>        structFile[] lsFile
11293>>>        structFile[] lsFile
11294>>>        Get plsFile to lsFile
11295>>>        If (iFilenumber < SizeOfArray(lsFile)) Begin
11297>>>            Move ("File: "+lsFile[iFilenumber].sFilename) to sErrorText
11298>>>        End
11298>>>>
11298>>>        Function_Return sErrorText
11299>>>    End_Function
11300>>>
11300>>>End_Class
11301>
11301>Object oApplication is a cApplication
11303>    Set psAutoOpenWorkspace to "Config.ws"
11304>    Set pbPreserveEnvironment to False
11305>End_Object
11306>
11306>
11306>Define CS_CRLF For (Character(13)+character(10))
11306>
11306>
11306>Struct tFileList
11306>  Integer iFileNum
11306>  String  sRootName     // actual filename
11306>  String  sDisplayName  // description
11306>  String  sTable        // datadictionary name is based on sTable (see aliases)
11306>End_Struct
11306>
11306>Enum_List
11306>  Define eDDUnknown       for 0 // style unknown or not yet classified
11306>  Define eDDOldStyle      for 1 // <tablename>_DD
11306>  Define eDDLegacyStyle   for 2 // o<tablename>_DD
11306>  Define eDDNewStyle      for 3 // o<tablename>_dd
11306>End_Enum_List
11306>
11306>Struct tDDO
11306>  String  sDDO          // sDDO name
11306>  Boolean bVerified     // sDDO name has been verified against filelist
11306>  Integer eDDOStyle     // DDO naming style
11306>  Integer iLine         // source line where the DDO is declared
11306>  Integer iFileNum      // Not needed at this stage, but we got the data, so stick it in
11306>  String  sTableName    // Just as easy to have
11306>End_Struct
11306>
11306>
11306>Class cDataFiles is a cObject
11307>
11307>  Procedure Construct_Object
11309>    Forward Send Construct_Object
11311>    Property tFileList[] pFileList
11312>  End_Procedure // Construct_Object
11313>
11313>  //
11313>  // Loops through the file list and enumerates all of the files in there.
11313>  //
11313>  Procedure EnumerateAllFiles
11315>    Integer iFile
11315>    Integer iIndex
11315>    String  sRoot
11315>    String  sDisplay
11315>    String  sTable
11315>    tFileList[] filelist
11315>    tFileList[] filelist
11316>  
11316>    Move (ResizeArray(filelist,0)) To filelist
11317>    Move 0 To iFile
11318>    Move 0 To iIndex
11319>    Repeat
11319>      Get_Attribute DF_FILE_NEXT_USED Of iFile To iFile
11322>      If (iFile > 0) Begin
11324>        Get_Attribute DF_FILE_ROOT_NAME    Of iFile To sRoot
11327>        Get_Attribute DF_FILE_DISPLAY_NAME Of iFile To sDisplay
11330>        Get_Attribute DF_FILE_LOGICAL_NAME Of iFile To sTable
11333>        //Showln "   " iFile ": " sTable " (" sRoot ", " sDisplay ")"
11333>        Move iFile    To filelist[iIndex].iFileNum
11334>        Move sRoot    to filelist[iIndex].sRootName
11335>        Move sDisplay to filelist[iIndex].sDisplayName
11336>        Move sTable   to filelist[iIndex].sTable
11337>        Increment iIndex
11338>      End
11338>      Set pFileList to filelist
11339>    Until (iFile = 0)
11341>  End_Procedure // EnumerateAllFiles
11342>
11342>End_Class // cDataFiles
11343>
11343>
11343>
11343>Class cStylerFolder is a cObject // from Cleanmarkers project, could use a BPO here, but no GUI for the moment
11344>    
11344>    
11344>    Procedure Construct_Object
11346>      Forward Send Construct_Object
11348>      
11348>      Property Boolean pbOk
11349>      Property String  psFolderName  ""
11350>      Property String  psFileMask    ""
11351>      Property Integer peNewStyle    0
11352>    End_Procedure // Construct_Object
11353>
11353>
11353>    Procedure OnProcess
11355>        String sDirName
11355>        Boolean bOk
11355>
11355>        Get psFolderName to sDirName
11356>        Get RecursiveSearchDirectoryFiles sDirName to bOK
11357>
11357>        Set pbOk to bOk
11358>
11358>    End_Procedure
11359>
11359>
11359>    Function RecursiveSearchDirectoryFiles String sSourceDirname Returns Boolean
11361>        Boolean bOk bStop bFound
11361>        Integer iCnt iMax iTmp
11361>        String  sFile sLine sEval sExt //sSourceFile
11361>        Handle  hoDir
11361>        
11361>        Move 0 to iCnt
11362>        //Get value of oSourceFile to sSourceFile
11362>        Get Create U_cDirectory to hoDir
11363>        Move (sSourceDirname+"\*.*") to sFile
11364>        Get SearchSingleDirectory of hoDir sFile DIRMODE_DIRECTORIES_ONLY to iMax
11365>        Decrement iMax
11366>        For iCnt from 0 to iMax
11372>            Get Searchresult of hoDir item iCnt LIST_FILENAME to sLine
11373>            If (sLine <> "." and sLine <> "..") Begin
11375>                Get RecursiveSearchDirectoryFiles (sSourceDirname + "\" + sLine) to bOk
11376>                If (not(bOk)) Begin
11378>                    Send destroy of hoDir
11379>                    Function_Return False
11380>                End
11380>            End
11380>        Loop
11381>        Get SearchSingleDirectory of hoDir sFile DIRMODE_FILES_ONLY to iMax
11382>        Decrement iMax
11383>        For iCnt from 0 to iMax
11389>            Get Searchresult of hoDir item iCnt LIST_FILENAME to sLine
11390>            Move (right(sLine,3)) to sExt
11391>            Move (Lowercase(sExt)) to sExt
11392>            If (Pos(".", sExt)) Move (Remove(sExt, 1, 1)) to sExt
11395>            Get psFileMask to sEval
11396>            If (Pos(sExt, sEval)) Begin
11398>                Send DoRestyleDDObjects (sSourceDirname + "\" + sLine) (peNewStyle(Self))
11399>                If (not(bOk)) Begin
11401>                    Send destroy of hoDir
11402>                    Function_Return False
11403>                End
11403>            End
11403>        Loop
11404>        Send destroy of hoDir
11405>        Move True to bOk
11406>        Function_Return bOk
11407>    End_Function
11408>    
11408>    Procedure doRestyleDDObjects String sFileName Integer eDDStyle
11410>      Showln "Restyling " sFileName
11413>      Delegate Send doRestyleDDObjects sFileName eDDStyle
11415>    End_Procedure //
11416>
11416>
11416>End_Class // cStylerFolder
11417>
11417>
11417>
11417>Class cDDStylingParser is a cObject
11418>  Procedure Construct_Object
11420>    Forward Send Construct_Object
11422>    Property String   psFileName  ""
11423>    Property String[] psSource
11424>    Property tDDO[]   pDDObjects
11425>    Property Boolean  pbCreateBackup false  // NOT implemented as I depend on source code control
11426>    Property Boolean  pbStrict       True   // Only replace verified DDOs, non strict not supported atm (Search code if need)
11427>    Property Integer  peNewStyle     eDDUnknown
11428>    Property Boolean  pbCamelCaseTableName True // For new tablename Camel Case the TableName in the object
11429>        
11429>    Object oDataFiles is a cDataFiles
11431>    End_Object
11432>  End_Procedure // Construct_Object
11433>  
11433>  Procedure Read String sFileName
11435>    Integer  iChan
11435>    Integer  iLine
11435>    String   sLine
11435>    String[] sSource
11436>    
11436>    Move 0 To iLine
11437>    Move (ResizeArray(sSource,0)) To sSource
11438>    Get OpenInput sFileName To iChan
11439>    If (iChan>0) Begin
11441>      Set psFileName to sFileName
11442>      Repeat
11442>        Readln Channel iChan sLine
11444>        If (not(SeqEof)) Begin
11446>          Move (Rtrim(sLine)) To sSource[iLine]
11447>          Increment iLine
11448>        End
11448>      Until (Seqeof)
11450>      Send CloseInput iChan
11451>    End
11451>    Set psSource To sSource
11452>  End_Procedure // Read
11453>  
11453>  Procedure CreateBackup
11455>  End_Procedure // CreateBackup
11456>  
11456>  Procedure Write
11458>    Boolean  bBackup
11458>    Integer  iChan
11458>    Integer  iLine
11458>    Integer  iCount
11458>    String   sFileName
11458>    String   sLine
11458>    String[] sSource
11459>    
11459>    Get pbCreateBackup To bBackup
11460>    If (bBackup) Begin
11462>      Send Createbackup
11463>    End
11463>    Get psSource To sSource
11464>    Get psFileName To sFileName
11465>    If (sFileName<>"") Begin
11467>      Get OpenOutput sFileName To iChan
11468>      If (iChan>0) Begin
11470>        Move (SizeOfArray(sSource)-1) To iCount
11471>        If (iCount>=0) Begin
11473>          For iLine From 0 To iCount
11479>            Move sSource[iLine] To sLine
11480>            Writeln Channel iChan sLine
11483>          Loop
11484>        End
11484>        Send CloseOutput iChan
11485>      End
11485>    End
11485>  End_Procedure // Write
11486>  
11486>  //
11486>  // Scans the whole file and locates the declared datadictionary objects based on that
11486>  // the line will start with "Object" and ends with "_DataDictionary".
11486>  //
11486>  // The search is case insensitive, commented out source will be ignored.
11486>  //
11486>  // Example line that will be detected:
11486>  //  Object oCustomer_DD is a Customer_DataDictionary
11486>  //
11486>  Procedure FindCurrentDDObjects
11488>    Integer  iCount
11488>    Integer  iLine
11488>    Integer  iPos
11488>    Integer  iSpaceChars
11488>    Integer  iDDO
11488>    String   sLine
11488>    String   sNline   // normalized line, lowercase and trimmed
11488>    String   sDDObject
11488>    String[] sSource
11489>    tDDO[]   DDObjects
11489>    tDDO[]   DDObjects
11490>    
11490>    Move 0 To iDDO
11491>    Move (ResizeArray(DDObjects,0)) To DDObjects
11492>    Get psSource To sSource
11493>    Move (SizeOfArray(sSource)-1) To iCount
11494>    If (iCount>=0) begin
11496>      For iLine From 0 To iCount
11502>        Move sSource[iLine] To sLine
11503>        Move (lowercase(trim(sLine))) To sNline
11504>        If (Pos("object ",sNline)=1) Begin
11506>          Move (Pos("_datadictionary",sNline)) To iPos
11507>          If (iPos>0) Begin
11509>            Move (Replace("object ",sNline,"")) To sNline
11510>            // space characters on the left? count them
11510>            Move (length(sNline) - (length(ltrim(sNline)))) To iSpaceChars
11511>            Move (ltrim(sNline)) To sNline // remove them
11512>            Move (Pos(" ",sNline)) To iPos
11513>            If (iPos<>0) Begin
11515>              Move (Mid(ltrim(sLine),iPos-1,8+iSpaceChars)) To sDDObject
11516>              Move sDDObject  To DDObjects[iDDO].sDDO
11517>              Move iLine      To DDObjects[iDDO].iLine
11518>              Move false      To DDObjects[iDDO].bVerified
11519>              Move eDDUnknown To DDObjects[iDDO].eDDOStyle
11520>              Increment iDDO
11521>            End
11521>          End
11521>        End
11521>      Loop
11522>    End
11522>    Set pDDObjects To DDObjects
11523>  End_Procedure // FindCurrentDDObjects
11524>  
11524>  //
11524>  // Helper function for comparing tablenames in the filelist
11524>  //
11524>  // Custom comparison function:
11524>  //   Returns (GT) if struct value in first parameter > struct value in second parameter.
11524>  //   Returns (LT) if struct value in first parameter < struct value in second parameter.
11524>  //   Otherwise returns (EQ).
11524>  Function CompareTableNames tFileList  List1 tFileList List2 Returns Integer
11526>    Move (lowercase(List1.sTable)) To List1.sTable
11527>    Move (lowercase(List2.sTable)) To List2.sTable
11528>    If (List1.sTable > List2.sTable) Begin
11530>      Function_Return (GT)
11531>    End
11531>    Else If (List1.sTable < List2.sTable) Begin
11534>      Function_Return (LT)
11535>    End
11535>    Function_Return (EQ)
11536>  End_Function //
11537>  
11537>  //
11537>  // Looks at the DD Objects found in the source and
11537>  // tests them against the filelist plus determines the type
11537>  //
11537>  Procedure ClassifyDDObjects
11539>    Boolean    bHasObjectPrefix
11539>    Boolean    bHasDDPostfix
11539>    Boolean    bHasDataDictionaryPostfix
11539>    Integer    iListSize
11539>    Integer    iCount
11539>    Integer    iDDO
11539>    Integer    iFile
11539>    String     sDDO
11539>    String     sTableName
11539>    String     sTableNameO // exception if tablename actually starts with letter O
11539>    tDDO[]     DDObjects
11539>    tDDO[]     DDObjects
11540>    tFileList  SearchFile
11540>    tFileList  SearchFile
11540>    tFileList[]  FileList
11540>    tFileList[]  FileList
11541>    
11541>    Send EnumerateAllFiles of oDataFiles // not entirely optimal to run this in each source file but meh
11542>    Get pFileList of oDataFiles    To FileList
11543>    Move (SizeOfArray(FileList)-1) To iListSize
11544>    Get pDDObjects To DDObjects
11545>    Move (SizeOfArray(DDObjects)-1) to iCount
11546>    If (iListSize>=0 and iCount>=0) Begin
11548>      For iDDO from 0 To iCount
11554>        Move False To bHasObjectPrefix
11555>        Move False To bHasDDPostfix
11556>        Move False To bHasDataDictionaryPostfix
11557>        Move ""    To sTableNameO
11558>        Move DDObjects[iDDO].sDDO To sDDO
11559>        Move (trim(sDDO)) To sTableName
11560>        If (sTableName<>"") Begin
11562>          If (Lowercase(Left(sTableName,1))="o") Begin
11564>            Move True To bHasObjectPrefix
11565>            Move (Replace(Mid(sTableName,1,1),sTableName,"")) To sTableName
11566>            Move (trim(sDDO)) To sTableNameO // What if tablename actually starts with a letter "o" ?
11567>          End
11567>          If (Lowercase(Right(sTableName,3))="_dd") Begin
11569>            Move True To bHasDDPostFix
11570>            Move (Left(sTableName,Length(sTableName)-3)) To sTableName
11571>            If (sTableNameO<>"") Begin
11573>              Move (Left(sTableNameO,Length(sTableNameO)-3)) To sTableNameO
11574>            End
11574>          End
11574>          Else If (Lowercase(Right(sTableName,15))="_datadictionary") Begin
11577>            Move True To bHasDataDictionaryPostFix
11578>            Move (Left(sTableName,Length(sTableName)-15)) To sTableName
11579>            If (sTableNameO<>"") Begin
11581>              Move (Left(sTableNameO,Length(sTableNameO)-15)) To sTableNameO
11582>            End
11582>          End
11582>          Move sTableName To SearchFile.sTable
11583>          Move (SearchArray(SearchFile,FileList, Self, (RefFunc(CompareTableNames)) )) to iFile
11584>          If (iFile>-1) Begin
11586>            Move True  To DDObjects[iDDO].bVerified
11587>            Move FileList[iFile].iFileNum To DDObjects[iDDO].iFileNum
11588>            Move FileList[iFile].sTable   To DDObjects[iDDO].sTableName
11589>          End
11589>          Else If (sTableNameO<>"") Begin
11592>            Move sTableNameO To SearchFile.sTable
11593>            Move (SearchArray(SearchFile,FileList, Self, (RefFunc(CompareTableNames)) )) to iFile
11594>            If (iFile>-1) Begin
11596>              Move False To bHasObjectPrefix
11597>              Move True  To DDObjects[iDDO].bVerified
11598>              Move FileList[iFile].iFileNum To DDObjects[iDDO].iFileNum
11599>              Move FileList[iFile].sTable   To DDObjects[iDDO].sTableName
11600>            End
11600>          End
11600>          If (bHasObjectPrefix=false and bHasDDPostfix) Begin
11602>            Move eDDOldStyle To DDObjects[iDDO].eDDOStyle
11603>          End
11603>          Else If (bHasObjectPrefix) Begin
11606>            If (bHasDDPostfix) Begin
11608>              Move eDDLegacyStyle To DDObjects[iDDO].eDDOStyle
11609>            End
11609>            //Else If (bHasDataDictionaryPostfix) Begin
11609>            //  Move eDDNewStyle To DDObjects[iDDO].eDDOStyle
11609>            //End
11609>          End
11609>        End
11609>      Loop
11610>      Set pDDObjects To DDObjects
11611>    End
11611>  End_Procedure // ClassifyDDObjects
11612>  
11612>  Function NewStyleName String sTableName Integer eNewStyle Returns String
11614>    String  sDDStyle
11614>    Boolean bCamelCase
11614>    
11614>    Get pbCamelCaseTableName To bCamelCase
11615>    If (bCamelCase) Begin
11617>      // Camel Case makes the whole tablename lowercase except for the first Letter
11617>      Move (lowercase(sTableName)) To sTableName
11618>      Move (overstrike(Uppercase(Left(sTableName,1)),sTableName,1)) To sTableName
11619>    End
11619>    
11619>    Case Begin
11619>      Case (eNewStyle=eDDOldStyle)
11621>        Move (sTableName+"_DD") To sDDStyle
11622>        Case Break
11623>      Case (eNewStyle=eDDLegacyStyle)
11626>        Move ("o"+sTableName+"_DD") To sDDStyle
11627>        Case Break
11628>      Case (eNewStyle=eDDNewStyle)
11631>        Move ("o"+sTableName+"_DD") To sDDStyle
11632>        Case Break
11633>      Case Else
11633>        Showln ("Unexpected error new style"*trim(eNewStyle)*"is undefined.")
11635>    Case End
11635>    Function_Return sDDStyle
11636>  End_Function // NewStyleName
11637>  
11637>  Procedure ApplyNewStyleForTable tDDO DDObject
11639>    Boolean bUpdated
11639>    Integer eNewStyle
11639>    Integer eOldStyle
11639>    Integer iCount
11639>    Integer iLine
11639>    Integer iPos
11639>    Integer iLen
11639>    String  sLine
11639>    String  sNline
11639>    String  sNOldDDName
11639>    String  sNewDDName
11639>    String[] sSource
11640>
11640>    Get peNewStyle To eNewStyle
11641>    Move DDObject.eDDOStyle To eOldStyle
11642>    If (eNewStyle<>eOldStyle) Begin
11644>      Get psSource To sSource
11645>      Move (lowercase(DDObject.sDDO)) To sNOldDDName
11646>      Move (Length(sNOldDDName))      To iLen
11647>      Get NewStyleName DDObject.sTableName eNewStyle To sNewDDName
11648>      Move (SizeOfArray(sSource)-1)   To iCount
11649>      If (iCount>=0) begin
11651>        For iLine From 0 To iCount
11657>          Move False To bUpdated
11658>          Move sSource[iLine] To sLine
11659>          //
11659>          // end of line happens, see Set DDO_Server To <table>_DD
11659>          //
11659>          Move (sLine +" ") to sLine
11660>          Move (lowercase(sLine)) To sNline
11661>          // Valid separate characters are: " ",",","(",")", EOL
11661>          // The DDO objects are _never_ at the start of the line
11661>          Move (Replaces(",",sNline," ")) To sNline
11662>          Move (Replaces("(",sNline," ")) To sNline
11663>          Move (Replaces(")",sNline," ")) To sNline
11664>
11664>          // Only one type of replacement left, easy testing :)
11664>          Move (Pos(" "+sNOldDDName+" ",sNline)) To iPos
11665>          While (iPos<>0)
11669>            Move True To bUpdated
11670>            Move (Replace(" "+sNOldDDName+" ",sNline," "+sNewDDName+" ")) To sNline
11671>            // Don't know correct case in the actual line, use remove+insert
11671>            // Can't use replace on the real line as it will end up replacing replaced
11671>            Move (Remove(sLine,iPos+1,iLen))       To sLine
11672>            Move (Insert(sNewDDName,sLine,iPos+1)) To sLine
11673>            
11673>            Move (Pos(" "+sNOldDDName+" ",sNline)) To iPos
11674>          Loop
11675>          If (bUpdated) Begin
11677>            Move (RTrim(sLine)) To sSource[iLine]
11678>          End
11678>        Loop
11679>        Set psSource To sSource
11680>      End
11680>    End
11680>  End_Procedure // ApplyNewStyleForTable
11681>  
11681>  Procedure ApplyNewStyle
11683>    Boolean bStrict
11683>    Boolean bReplace
11683>    Integer iFile
11683>    Integer iCount
11683>    Integer eStyle
11683>    String  sFileName
11683>    tDDO[]  DDObjects
11683>    tDDO[]  DDObjects
11684>    
11684>    Get peNewStyle To eStyle
11685>    If (eStyle<>eDDUnknown) Begin
11687>      Get pbStrict To bStrict   // default is to only rename DDO's that exist in filelist
11688>      Get ParseFileName (psFileName(Self)) To sFileName
11689>      Get pDDObjects To DDObjects
11690>      Move (SizeOfArray(DDObjects)-1) To iCount
11691>      If (iCount>=0) Begin
11693>        For iFile from 0 To iCount
11699>          Move False To bReplace
11700>          If (bStrict) Begin
11702>            If (DDObjects[iFile].bVerified=True) Begin
11704>              Move True To bReplace
11705>            End
11705>            Else Begin
11706>              Showln ("DDO"*DDObjects[iFile].sDDO*"was not found in the filelist. File"*sFileName)
11708>            End
11708>          End
11708>          Else Begin
11709>            // if you want to do non strict, you need to fill in ddobject.sTableName still!
11709>            Move True To bReplace
11710>          End
11710>          If (DDObjects[iFile].eDDOStyle=eDDUnknown) Begin
11712>            Move False To bReplace
11713>            Showln ("DDO"*DDObjects[iFile].sDDO*"style is not recognized. File"*sFileName)
11715>          End
11715>          If (DDObjects[iFile].eDDOStyle=eStyle) Begin
11717>            Move False To bReplace
11718>            Showln ("DDO"*DDObjects[iFile].sDDO*"style already correct. File"*sFileName)
11720>          End
11720>          If (bReplace) Begin
11722>            Send ApplyNewStyleForTable DDObjects[iFile]
11723>          End
11723>        Loop
11724>      End
11724>    End // eStyle<>eDDUnknown
11724>  End_Procedure // ApplyNewStyle
11725>
11725>
11725>
11725>  Function OpenOutput String sFileName Returns Integer
11727>    Integer iChan
11727>
11727>    Get Seq_New_Channel to iChan
11728>    If (iChan <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
11730>      Direct_Output channel iChan sFileName
11732>    End
11732>    Function_Return iChan
11733>  End_Function
11734>  
11734>  Procedure CloseOutput Integer iChan
11736>    Close_Output Channel iChan
11738>    send Seq_Release_Channel iChan
11739>  End_Procedure
11740>
11740>  Function OpenInput String sFileName Returns Integer
11742>    Integer iChan
11742>
11742>    Get Seq_New_Channel to iChan
11743>    If (iChan<>DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
11745>      Direct_Input channel iChan ("binary:"+sFileName)
11747>    End
11747>    Function_Return iChan
11748>  End_Function
11749>  
11749>  Procedure CloseInput Integer iChan
11751>    Close_Input Channel iChan
11753>    send Seq_Release_Channel iChan
11754>  End_Procedure
11755>  
11755>  //
11755>  // Code that handles the restyle on the DD Object in the source filename supplied
11755>  // and changes it to the new style eDDStyle
11755>  //
11755>  Procedure doRestyleDDObjects String sFileName Integer eDDStyle
11757>    Send Read sFilename
11758>    Send FindCurrentDDObjects
11759>    Send ClassifyDDObjects
11760>    Set peNewStyle            To eDDStyle
11761>    Send ApplyNewStyle
11762>    Send Write
11763>  End_Procedure
11764>  
11764>  Procedure doRestyleFolder String sFolderName String sFileMask Integer eDDStyle
11766>    Handle hoStyler
11766>    
11766>    Get Create (RefClass(cStylerFolder)) To hoStyler
11767>    If (hoStyler) Begin
11769>      Set psFolderName of hoStyler To sFolderName
11770>      Set psFileMask   of hoStyler To sFileMask
11771>      Set peNewStyle   of hoStyler To eDDStyle
11772>      Send OnProcess Of hoStyler
11773>      
11773>      Send Destroy of hoStyler
11774>    End
11774>  End_Procedure // doRestyleFolder
11775>
11775>End_Class // cDDStylingParser
11776>
11776>         
11776>         
11776>
11776>Object oDDRestyler is a cDDStylingParser
11778>End_Object
11779>
11779>//Send doRestyleDDObjects of oDDRestyler "D:\Projects\Clients\NHS\NH\BeforeDDRestyler\ADALookup.sl" eDDLegacyStyle
11779>//Send doRestyleFolder of oDDRestyler "D:\Projects\Clients\NHS\NH\BeforeDDRestyler" "*.dg;*.sl;*.rv;*.bp;*.vw" eDDLegacyStyle
11779>//Send doRestyleFolder of oDDRestyler "D:\Projects\Clients\NHS\Orthobanc18\ORTHOBANC" "*.dg;*.sl;*.rv;*.bp;*.vw" eDDLegacyStyle
11779>
11779>
11779>Use VdfBase.pkg
11779>String sDummy  
11779>Winput "Click OK" sDummy
WARNING: 4533 Obsolete command: Winput. Use Message_Box ON LINE: 671 (11779) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
WARNING: 4533 Obsolete command: GetAddress. Use AddressOf Function ON LINE: 671 (11779) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
11781>
ERROR: 4306 Forward reference not resolved  MSG_U_CDIRECTORY ON LINE: 193 (11361) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
ERROR: 4306 Forward reference not resolved  GET_SEARCHSINGLEDIRECTORY ON LINE: 195 (11363) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
ERROR: 4306 Forward reference not resolved  GET_SEARCHRESULT ON LINE: 198 (11371) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
ERROR: 4306 Forward reference not resolved  MSG_LIST_FILENAME ON LINE: 198 (11371) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
ERROR: 4306 Forward reference not resolved  GET_SEARCHSINGLEDIRECTORY ON LINE: 207 (11380) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
ERROR: 4306 Forward reference not resolved  GET_SEARCHRESULT ON LINE: 210 (11388) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
ERROR: 4306 Forward reference not resolved  MSG_LIST_FILENAME ON LINE: 210 (11388) OF FILE: C:\Projects\DF18\DFRefactor\AppSrc\DDOReStyler.src
Summary
Memory Available: 2147483646
Total Warnings : 2
Total Errors   : 7
Total Symbols  : 11616
Total Resources: 0
Total Commands : 11780
Total Windows  : 0
Total Pages    : 0
Static Data    : 139082
Message area   : 61396
Total Blocks   : 6115
7 ERRORS HAVE BEEN FOUND.
