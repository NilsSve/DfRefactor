// Copyright (c) 2018 Nils Svedmyr, RDC Tools International
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to Do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in All
// copies or substantial portions of the Software.
//
// THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
// IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
// FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
// LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
// OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
// SOFTWARE.

Use cApplication.pkg
Use cCJCommandBarSystem.pkg
Use cIniFile.pkg
Use gFormatNumbers.pkg
Use vwin32fh.pkg          
Use cFilesystem.pkg
Use cSCWsGrid.pkg
Use DeleteWorkspaceHistory.dg
Use cRefactorFuncLib.pkg

#IFNDEF ghoFileSystem
    Global_Variable Integer ghoFileSystem
#ENDIF
#IFNDEF ghoRefactorFuncLib
    Global_Variable Handle ghoRefactorFuncLib
#ENDIF

Class cRefactorApplication is a cApplication
    
    Procedure Construct_Object
        Forward Send Construct_Object

        Property Integer piBackupDaysOverwriteCycle 2

        {Visibility=Private}
        Property String private.psFileCompareApp
        {Visibility=Private}
        Property String private.psStarZenSourceExplorer
        {Visibility=Private}
        Property Integer private.piToolbarIconSize 0
        {Visibility=Private}
        Property Integer private.peTabpagePosition xtpTabPositionLeft
        {Visibility=Private}
        Property String private.psGridRowBackgroundColor 0
        {Visibility=Private}
        Property String private.psSWSFile       ""
        {Visibility=Private}
        Property Handle private.phoFolderSelHeaDD
        {Visibility=Private}
        Property Boolean private.pbWorkspaceMode True
        {Visibility=Private}
        Property Integer private.piActiveView -1
        {Visibility=Private}
        Property Handle private.phoActiveView -1     
        {Visibility=Private}
        Property tSCLanguage pSCLanguage
        
        // Used by the DfAbout object to display the compile date & time.
        // See also: End_Construct_Object in this class.
        Property String psCompileDateAndTime ""
        Property String psUserName ""
        Property Handle phoEditorView 0
        Property Handle phoRefactorView 0
        Property Handle phoEditor 0
    
        Property String psHomePath  ""
        Property String psCurrentSourceFileName ""
        Property Integer piWorkspaceItems 9 // Zero based
    
        // For the Scintilla editor
        Property String psStartupProgramPath ""
        Property String psStartupBitmapPath  ""

        Get Create (RefClass(cFilesystem)) to ghoFileSystem  
        // This is used by the About object to display the compile date & time:
        Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
    End_Procedure

    Procedure InitUserName
        String sName
        Get_Environment "USERNAME" to sName
        Set psUserName to sName
    End_Procedure         
                                  
    // Note; This logic uses the Include_Resource info above to set the
    // ghoApplication property; psCompileDateAndTime that is used by the DfAbout object
    // to show the compiled date & time.
    // The includeded file CompileHeader.h is generated by the "Before Compilation Process",
    // setup in the project properties "Compiler" tab-page. 
    Procedure End_Construct_Object
        String sCompileTime  
        Integer iPos
        
        Forward Send End_Construct_Object
        Direct_Input "resource: res_CompileHeader"
        Readln sCompileTime
        Move (Pos('"', sCompileTime)) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
            Move (Replaces('"', sCompileTime, '')) to sCompileTime
            Set psCompileDateAndTime to sCompileTime
        End
        Close_Input
        
        Send InitUserName
        Open SysFile
        Open FunctionsA
        Set private.psStarZenSourceExplorer to (Trim(SysFile.PathStarZen)) 
        Set piBackupDaysOverwriteCycle      to SysFile.iBackupDaysOverwriteCycle

        // *** MAIN FUNCTION LIBRARY ***
        // We only need one copy of it per application.
        If (ghoRefactorFuncLib = 0) Begin
            Object oRefactorFunctionLibrary is a cRefactorFuncLib
                Move Self to ghoRefactorFuncLib
            End_Object
        End
        
    End_Procedure

    Function SourceFilePath Returns String
        String sFileName sPath

        Get psHomePath to sPath
        Get psCurrentSourceFileName to sFileName
        If (sFileName <> "") Begin
            Get ParseFolderName sFileName to sPath
        End
        Function_Return sPath
    End_Function

    { MethodType=Property }
    { EnumList="16, 24, 32" }
    Procedure Set piToolbarIconSize Integer iSize
        Send WriteInteger CS_Settings CS_ToolbarIconSize iSize
        Set private.piToolbarIconSize to iSize
    End_Procedure

    { MethodType=Property }
    Function piToolbarIconSize Returns Integer
        Integer iSize
        Get private.piToolbarIconSize to iSize
        If (iSize = 0) Begin
            Get ReadInteger CS_Settings CS_ToolbarIconSize 32 to iSize
            If (iSize = 0) Begin
                Move 32 to iSize
            End
            Set private.piToolbarIconSize to iSize
        End
        Function_Return iSize
    End_Function

    { MethodType=Property }
    { EnumList="xtpTabPositionTop, xtpTabPositionLeft, xtpTabPositionBottom, xtpTabPositionRight" }
    Procedure Set peTabpagePosition Integer eMode
        Set private.peTabpagePosition to eMode
        Send WriteInteger CS_Settings CS_TabPosition eMode   
    End_Procedure

    { MethodType=Property }
    Function peTabpagePosition Returns Integer
        Integer eMode
        Get ReadInteger CS_Settings CS_TabPosition xtpTabPositionLeft to eMode
        Function_Return eMode
    End_Function

    { MethodType=Property }
    Procedure Set psGridRowBackgroundColor String sColor
        Set private.psGridRowBackgroundColor to sColor
        Send WriteString CS_Settings CS_GridRowBackgroundColor sColor
        Broadcast Recursive Set piSelectedRowBackColor of (Client_Id(phoMainPanel(ghoApplication))) to sColor
        Broadcast Recursive Set piHighlightBackColor   of (Client_Id(phoMainPanel(ghoApplication))) to sColor
    End_Procedure

    { MethodType=Property }
    Function psGridRowBackgroundColor Returns String
        String sColor
        Get private.psGridRowBackgroundColor to sColor
        If (sColor = 0) Begin
            Get ReadString CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
            If (sColor contains "clBlueGrey") Begin
                Move (Replace("clBlueGrey", sColor, "clGreenGrey")) to sColor
            End
            Set private.psGridRowBackgroundColor to sColor
        End
        Function_Return sColor
    End_Function

    { MethodType=Property }
    Procedure Set psFileCompareApp String sProgramName
        Send WriteString CS_Settings CS_FileCompareProgram sProgramName
        Set private.psFileCompareApp to sProgramName
    End_Procedure

    { MethodType=Property }
    Function psFileCompareApp Returns String
        String sProgramName
        Get private.psFileCompareApp to sProgramName
        If (sProgramName = "") Begin
            Get ReadString CS_Settings CS_FileCompareProgram "" to sProgramName
            Set private.psFileCompareApp to sProgramName
        End
        Function_Return sProgramName
    End_Function

    { MethodType=Property }
    Procedure Set psStarZenSourceExplorer String sProgramName
        Send WriteString CS_Settings CS_StarZenSourceExplorer sProgramName
        Set private.psStarZenSourceExplorer to sProgramName
    End_Procedure

    { MethodType=Property }
    Function psStarZenSourceExplorer Returns String
        String sProgramName
        Get private.psStarZenSourceExplorer to sProgramName
        If (sProgramName = "") Begin
            Get ReadString CS_Settings CS_StarZenSourceExplorer "" to sProgramName
            Set private.psStarZenSourceExplorer to sProgramName
        End
        Function_Return sProgramName
    End_Function

    Procedure DisplayPerfCounters
    End_Procedure

    Function StartPerfCounter Integer eOperation String sComment Returns Integer
        Function_Return 0
    End_Function

    Procedure StopPerfCounter Integer iCounter
    End_Procedure

    Procedure Set piActiveView Integer iActiveViewID Handle hoActiveView
        Set Private.piActiveView  to iActiveViewID
        Set Private.phoActiveView to hoActiveView
    End_Procedure

    Function piActiveView Returns Integer
        Function_Return (Private.piActiveView(Self))
    End_Function

    Function phoActiveView Returns Integer
        Function_Return (Private.phoActiveView(Self))
    End_Function

    Procedure AddWorkSpaceFileToRegistry String sFileName
        Integer iCount iSize
        String[] sWorkspaces
        Boolean bFound

        Get piWorkspaceItems to iSize
        // Is the selected .sws file new?
        For iCount from 0 to iSize
            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) "" to sWorkspaces[iCount]
            If (Uppercase(sWorkspaces[iCount]) = Uppercase(sFilename)) Begin
                Move True to bFound
            End
        Loop

        // If new, save it to the registry. Push it to the top of the stack (LiFo).
        If (bFound = False) Begin
            Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + "0") sFilename
            Decrement iSize
            For iCount from 0 to iSize
                If (sWorkspaces[iCount] <> "") Begin
                    Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount + 1)) sWorkspaces[iCount]
                End
            Loop
        End
    End_Procedure

    Function ReadWorkspaceKeysFromRegistry Returns String[]
        Integer iCount iSize iItem
        String[] asWorkspaces
        String sWorkspace

        Move 0 to iItem
        Get piWorkspaceItems to iSize
        For iCount from 0 to iSize
            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) '' to sWorkspace
            If (sWorkspace <> "") Begin
                Move sWorkspace to asWorkspaces[iItem]
                Increment iItem
            End
        Loop
        Function_Return asWorkspaces
    End_Function

    Procedure DeleteWorkSpaceHistoryFromRegistry
        String[] asWorkspaces

        Get ReadWorkspaceKeysFromRegistry to asWorkspaces
        #IFDEF msg_ActivateDeleteWorkspaceHistoryDialog
        Send ActivateDeleteWorkspaceHistoryDialog of (Client_Id(phoMainPanel(ghoApplication))) asWorkspaces
        #ENDIF
    End_Procedure

    // Pass an SWS file with full path.
    // Returns the .ws file name of the Programs folder.
    Function WsFileNameFromSWSFileName String sSWSFilename Returns String
        Handle hoIni
        String sWs sWorkspaceFileName

        Get Create (RefClass(cIniFile)) to hoIni
        Set psFilename of hoIni  to sSWSFilename
        Get ReadString of hoIni CS_WorkspacePaths CS_ConfigFile "" to sWs
        Send Destroy   of hoIni
        Move (Replace(".\", sWs, ExtractFilePath(sSWSFilename))) to sWorkspaceFileName

        Function_Return sWorkspaceFileName
    End_Function

    Procedure ToggleWorkspaceAndFileMode
    End_Procedure

    Procedure Set pbWorkspaceMode Boolean bState
        Set private.pbWorkspaceMode to bState
        Send ToggleWorkspaceAndFileMode
    End_Procedure

    Function pbWorkspaceMode Returns Boolean
        Function_Return (private.pbWorkspaceMode(Self))
    End_Function

    { MethodType=Property }
    Function psSWSFile Returns String
        Function_Return (private.psSWSFile(Self))
    End_Function

    { MethodType=Property }
    Function psWorkspaceHomePath Returns String
        String sPath sSWSFile
        Get psSWSFile to sSWSFile
        Get ParseFolderName sSWSFile to sPath
        Function_Return sPath
    End_Function

    // Will create a backup-folder for the passed file, if-and-only-if it doesn't exists.
    // Returns the full path to the backup folder.
    Function CreateBackupFolder String sFile Returns String
        String sPath sHomePath sBackupFolder
        Boolean bFolderExists bSuccess
        Integer iRetval iPos

        Move "" to sPath
        Get psHomePath            to sHomePath
        If (sFile <> "") Begin
        Get ParseFolderName sFile to sPath
        Move (Replace(Lowercase(sHomePath), Lowercase(sPath), "")) to sPath // Only want the subfolder structure
        Move (Pos(":", sPath)) to iPos
        If (iPos > 0) Begin
            Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
            Move (Pos(CS_DirSeparator, sPath)) to iPos
            If (iPos > 0) Begin
                Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
            End
        End
        End

        Move (sHomePath + CS_BackupFolder + CS_DirSeparator + sPath) to sBackupFolder
        Get RemoveFolderSeperator of ghoFileSystem sBackupFolder to sBackupFolder
        Get vFolderExists sBackupFolder to bFolderExists
        If (bFolderExists = False) Begin
            Get DirectoryCreateEx of ghoFileSystem sBackupFolder False to bSuccess
            If (bSuccess = False) Begin
                Get YesNo_Box ("Warning! The" * String(sHomePath) + "\DFRefactor Backup folder could not be created. You should abort the program now, fix the cause and restart. Abort the program?") to iRetval
                If (iRetval = MBR_Yes) Begin
                    Send Exit_Application
                End
            End
        End
        Get vFolderFormat sBackupFolder to sBackupFolder
        Function_Return sBackupFolder
    End_Function

    Function IsBackupFolder Returns Boolean
        String sHomePath sBackupFolder
        Boolean bExists

        Get psHomePath to sHomePath
        Get vFolderFormat sHomePath to sHomePath
        Move (sHomePath + CS_BackupFolder) to sBackupFolder
        Get vFolderExists sBackupFolder to bExists

        Function_Return bExists
    End_Function

    // Takes a source file name with full path as parameter.
    // Returns a name with full path for it's backup file counterpart.
    // If the backup folder doesn't exist, it will be created, aka
    // the BackupFolder function is used.
    Function BackupFileName String sPathFileName Returns String
        String sBackupFolder sFileName sBackupFile
        Integer iPos

        Get CreateBackupFolder sPathFileName   to sBackupFolder
        Get vFolderFormat sBackupFolder  to sBackupFolder
        Get ParseFileName sPathFileName  to sFileName
        Move (Pos(":", sFileName))       to iPos
        If (iPos > 0) Begin
            Move (Mid(sFileName, CI_EOL, iPos)) to sFileName
        End
        Move (sBackupFolder + sFileName) to sBackupFile

        Function_Return sBackupFile
    End_Function

    Function HomeBackupFilePath Returns String
        Boolean bExist
        String sPath sPathBackup

        Get psHomePath to sPath
        If (sPath <> "") Begin
            Get vFolderFormat sPath to sPath
            Move (sPath + CS_BackupFolder) to sPathBackup
            Get FileExists of ghoFileSystem sPathBackup DIRMODE_DIRECTORIES_ONLY to bExist
            If (bExist) Begin
                Move sPathBackup to sPath
            End
            Else Begin
                Move "" to sPath
            End
        End
        Function_Return sPath
    End_Function

    Function SaveBackupFile String sSourceFile Returns Boolean
        Boolean bOK bExists bShouldBackup
        String sBackupFile
        Date dWriteSource dWriteBackup
        Integer iBackupDaysOverwriteCycle
        tFileTime ftCurrentTime
        
        Move True to bShouldBackup
        Get piBackupDaysOverwriteCycle to iBackupDaysOverwriteCycle
        Get BackupFileName sSourceFile to sBackupFile
        Get FileExists of ghoFileSystem sBackupFile to bExists
        If (bExists = True) Begin
            Get FileDate of ghoFileSystem sSourceFile to dWriteSource
            Get FileDate of ghoFileSystem sBackupFile to dWriteBackup
            Move ((dWriteSource - dWriteBackup) > iBackupDaysOverwriteCycle or (dWriteBackup - dWriteSource) > iBackupDaysOverwriteCycle) to bShouldBackup
        End

        // If we make a backup copy of the file we change the date & time,
        // to present time. This is so we later - if the 'Start Process' button is
        // pressed again - decide to _not_ backup the file again iif it has todays,
        // or yesterday's date. That way the user can press the "Start Process"
        // button several times without the backup file gets overwritten by a
        // file that has been changed all ready - keeping the original source file
        // intact.
        If (bShouldBackup = True) Begin
            Get FileCopy of ghoFileSystem sSourceFile sBackupFile False to bOK
            Get CurrentSystemTimeAsFileTime of ghoFileSystem to ftCurrentTime
            Set FileLastWriteTime of ghoFileSystem to sBackupFile ftCurrentTime
            Get FileExists of ghoFileSystem sBackupFile to bExists
        End

        Function_Return bExists
    End_Function

    // Does a backup copy of the current source file exist?
    Function IsBackupFile String sCurrentFileName Returns String
        String sPath sFile sHomePath sBackupFolder sBackupFile sExt
        Boolean bExists
        tsSearchResult[] SearchResultArray

        If (sCurrentFileName = "") Begin
            Function_Return ""
        End

        Get psHomePath to sHomePath
        Get ParseFolderName sCurrentFileName to sPath
        Move (sHomePath + CS_BackupFolder) to sBackupFolder
        Get vFolderExists sBackupFolder to bExists
        If (bExists = False) Begin
            Function_Return ""
        End

        Move "" to sBackupFile
        Get ParseFileName sCurrentFileName to sFile
        Get ParseFileExtension sFile to sExt
        Move (Replace(sExt, sFile, "")) to sFile
        Get vFolderFormat sBackupFolder to sBackupFolder
        Move (sBackupFolder + sFile + String("*")) to sFile
        Get FileSearchRecursive of ghoFileSystem sFile DIRMODE_FILES_ONLY True to SearchResultArray
        If (SizeOfArray(SearchResultArray)) Begin
            Move SearchResultArray[0].sFilename to sBackupFile
        End

        Function_Return sBackupFile
    End_Function

    Function AllBackupFolderFiles Returns tsSearchResult[]
        Boolean bExists
        String sBackupHomeFolder sBackupFolder sHomePath sFileMask sFileName
        String[] asNoFolderSearch asBackupFolders
        tsSearchResult[] asBackupFilesEmpty asBackupFiles asBackupFilesTotal
        Integer iFolder iFolders iFile iFiles

        Get psHomePath to sHomePath
        Get vFolderFormat sHomePath to sHomePath
        Move (sHomePath + CS_BackupFolder) to sBackupHomeFolder
        Get vFolderExists sBackupHomeFolder to bExists
        If (bExists = False) Begin
            Function_Return asBackupFilesEmpty
        End

        Get NoFolderListAsArray True to asNoFolderSearch
        Get RecursiveSearchFolders sBackupHomeFolder asNoFolderSearch to asBackupFolders
        Move (SizeOfArray(asBackupFolders)) to iFolders
        Decrement iFolders
        For iFolder from 0 to iFolders
            Move asBackupFolders[iFolder] to sBackupFolder
            Get vFolderFormat sBackupFolder to sBackupFolder
            Move (sBackupFolder + "*.*") to sFileMask

            // File loop:
            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asBackupFiles
            // Remove report files created by the DFRefactor tool.
            If (SizeOfArray(asBackupFiles)) Begin
                If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_SummaryLogfileName) Begin
                    Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
                    If (SizeOfArray(asBackupFiles)) Begin
                        If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_UnusedSourceLogFile) Begin
                            Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
                        End
                    End
                End
            End
            Move (SizeOfArray(asBackupFiles)) to iFiles
            Decrement iFiles
            For iFile from 0 to iFiles
                Move asBackupFiles[iFile].sFilename to sFileName
                // Store the path in the sAlternateFileName struct item
                Move sBackupFolder to asBackupFiles[iFile].sAlternateFileName
            Loop
            Move (AppendArray(asBackupFilesTotal, asBackupFiles)) to asBackupFilesTotal
        Loop

        Function_Return asBackupFilesTotal
    End_Function

    Function AllSourceFolders String[] asSelectedFolders Returns String[]
        String sHomePath
        String[] asNoFolderSearch asSourceFolders asAllSourceFolders
        Integer iSize iCount

        Get psHomePath to sHomePath
        Get vFolderFormat sHomePath to sHomePath

        Get NoFolderListAsArray False to asNoFolderSearch
        Move (SizeOfArray(asSelectedFolders)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Get RecursiveSearchFolders asSelectedFolders[iCount] asNoFolderSearch to asSourceFolders
            Move (AppendArray(asAllSourceFolders, asSourceFolders)) to asAllSourceFolders
        Loop

        Function_Return asAllSourceFolders
    End_Function

    Function AllSoceFiles String[] asSelectedFolders String sFileFilter Returns tsSearchResult[]
        Boolean bIsFileInFilter
        String sSourceFolder sFileMask sFileName
        String[] asAllSourceFolders
        tsSearchResult[] asSourceFilesEmpty asSourceFiles asSourceFilesTotal
        Integer iFolder iFolders iFile iFiles

        Move asSelectedFolders to asAllSourceFolders
        Move (SizeOfArray(asAllSourceFolders)) to iFolders
        Decrement iFolders

        // Folder loop:
        For iFolder from 0 to iFolders
            Move asAllSourceFolders[iFolder] to sSourceFolder
            Get vFolderFormat sSourceFolder to sSourceFolder
            Move (sSourceFolder + "*.*") to sFileMask

            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asSourceFiles
            Move (SizeOfArray(asSourceFiles)) to iFiles
            Decrement iFiles

            // File loop:
            For iFile from 0 to iFiles
                Move asSourceFiles[iFile].sFilename to sFileName
                Get IsFileInFilter sFileName sFileFilter to bIsFileInFilter
                If (bIsFileInFilter = True) Begin
                    // Store the path in the sAlternateFileName struct item
                    Move sSourceFolder to asSourceFiles[iFile].sAlternateFileName
                End
                Else Begin
                    Move (RemoveFromArray(asSourceFiles, iFile)) to asSourceFiles
                    Decrement iFile
                    Decrement iFiles
                End
            Loop
            Move (AppendArray(asSourceFilesTotal, asSourceFiles)) to asSourceFilesTotal
        Loop

        Function_Return asSourceFilesTotal
    End_Function

    Function IsFileInFilter String sFileName String sFileFilter Returns Boolean
        Integer iSearchIndex
        String sExtension sChar
        String[] asFileFilter

        Move (Lowercase(sFileName))      to sFileName
        Get ParseFileExtension sFileName to sExtension
        Move (Left(sExtension, 1))       to sChar
        If (sChar <> ".") Begin
            Move ("." + String(sExtension)) to sExtension
        End
        Move (Lowercase(sFileFilter))         to sFileFilter
        Move (Replaces("*", sFileFilter, "")) to sFileFilter
        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilter
        Move (SearchArray(sExtension, asFileFilter)) to iSearchIndex
        Function_Return (iSearchIndex <> -1)
    End_Function

    Function RecursiveSearchFolders String sSourceFolder String[] asNoFolderList Returns String[]
        Boolean bFound
        Integer iCount iSize iItem
        String sMask sPrevFolderName sHomePath
        tsSearchResult[] asSearchResult
        String[] saSearchFolders

        If (not(sSourceFolder contains ":")) Begin
            Get psHomePath to sHomePath
            Get vFolderFormat sHomePath to sHomePath
            Move (sHomePath + sSourceFolder) to sSourceFolder
        End
        Get vFolderFormat sSourceFolder to sSourceFolder
        Move (sSourceFolder + "*") to sMask

        Move 0 to iItem

        // Recursive folder search
        Get FileSearchRecursive of ghoFileSystem sMask DIRMODE_DIRECTORIES_ONLY False to asSearchResult
        Move (SizeOfArray(asSearchResult)) to iSize
        Decrement iSize

        // Remove folder names from array where we should not search for source files
        Move "" to sPrevFolderName
        For iCount from 0 to iSize
            Get IsFolderInNoFolderList of ghoApplication asNoFolderList asSearchResult[iCount].sFilename to bFound
            If (bFound = False) Begin
                If (asSearchResult[iCount].sFilename <> sPrevFolderName) Begin
                    Move asSearchResult[iCount].sFilename to saSearchFolders[iItem]
                    Increment iItem
                End
            End
            Move asSearchResult[iCount].sFilename to sPrevFolderName
        Loop

        Move sSourceFolder to saSearchFolders[SizeOfArray(saSearchFolders)]
        // Sort the folder array to get the top one first.
        Move (SortArray(saSearchFolders)) to saSearchFolders

        Function_Return saSearchFolders
    End_Function

    Procedure ComparePaths String sCompareApp
        String sPath sPathBackup

        Get psHomePath to sPath
        Get HomeBackupFilePath to sPathBackup
        If (sPath <> "" and sPathBackup <> "") Begin
            Runprogram Background ('"' + sCompareApp + '"') ('"' + sPath + '" "' + sPathBackup + '"')
        End
    End_Procedure

    Procedure CompareFiles String sCompareApp
        Boolean bExist
        String sFileName sFile sFileBackup sCurrentFileName

        Get psCurrentSourceFileName to sFileName
        If (sFileName <> "") Begin
            Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bExist
            If (bExist) Begin
                Get psCurrentSourceFileName to sCurrentFileName
                Get IsBackupFile sCurrentFileName to sFileBackup
                If (sFileBackup <> "") Begin
                    Runprogram Background ('"' + sCompareApp + '"') ('"' + sFileName + '" "' + sFileBackup + '"')
                End
                Else Begin
                    Send Info_Box ("Cannot find the backup file file" * sFileBackup)
                End
            End
            Else Begin
                Send Info_Box ("The file in the source file" * sFileName * "\nDoes not exist.")
            End
        End
        Else Begin
            Send Info_Box "You have to select a file first."
        End
    End_Procedure

    // Returns the current Studio "File mask" setting as a string. See
    Function StudioFileMaskSettings Returns String
        Handle hoReg
        String sStudioRegPath sRetval sDFVersion
        Boolean bExists bOk
        Integer iMajorVersion iMinorVersion

        Move FMAC_VERSION  to iMajorVersion
        Move FMAC_REVISION to iMinorVersion
        Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sDFVersion

        Get Create (RefClass(cRegistry)) to hoReg
        Set pfAccessRights of hoReg to Key_Read

        Move CS_StudioToolsPathStart to sStudioRegPath
        Move (sStudioRegPath + sDFVersion + CS_StudioToolsPathEnd) to sStudioRegPath
        Set phRootKey of hoReg to HKEY_CURRENT_USER

        // First check if the DF version is installed
        Get KeyExists of hoReg sStudioRegPath to bExists
        If (bExists = False) Begin
            Send Destroy of hoReg
            Function_Return cx_RegKeyDFKeyDoesNotExist
        End

        Get OpenKey of hoReg sStudioRegPath to bOk
        If (bOk = True) Begin
            Set pfAccessRights of hoReg to KEY_READ
            Get ReadString of hoReg CS_DFExtensionsKey to sRetval
        End

        Send CloseKey of hoReg
        Send Destroy of hoReg
        Function_Return sRetval
    End_Function

    Function StudioFileExtensions String sDFVersion Returns String
        Handle hoReg
        String sStudioRegPath  sRetval
        Boolean bExists bOk

        Get Create (RefClass(cRegistry)) to hoReg
        Move CS_StudioPath to sStudioRegPath
        If (sDFVersion > "17.1") Begin
            Move (Replace("Visual ", sStudioRegPath, "")) to sStudioRegPath
        End
        Move (sStudioRegPath + sDFVersion + CS_StudioPathEnd) to sStudioRegPath
        Set phRootKey of hoReg to HKEY_CURRENT_USER

        // First check if the DF version is installed
        Get KeyExists of hoReg sStudioRegPath to bExists
        If (bExists = False) Begin
            Send Destroy of hoReg
            Function_Return cx_RegKeyDFKeyDoesNotExist
        End

        Get OpenKey of hoReg sStudioRegPath to bOk
        If (bOk = True) Begin
            Set pfAccessRights of hoReg to KEY_READ
            // In the Studio this key is still call "VDF".
            Get ReadString of hoReg "VdfExtensions" to sRetval
        End

        Send CloseKey of hoReg
        Send Destroy of hoReg
        Function_Return (Trim(sRetval))
    End_Function

    Function NoFolderListAsArray Boolean bNoBackupFolder Returns String[]
        String sNoFolderList
        String[] saNoFolderList

        Move CS_NoFolderList to sNoFolderList
        If (bNoBackupFolder = False) Begin
            Move (sNoFolderList + "|" + CS_BackupFolder) to sNoFolderList
        End
        Move (Lowercase(sNoFolderList)) to sNoFolderList
        Move (StrSplitToArray(sNoFolderList, "|")) to saNoFolderList
        Function_Return saNoFolderList
    End_Function

    // Returns True if the passed sFolderName exists in the passed string array.
    Function IsFolderInNoFolderList String[] saNoFolderList String sFolderName Returns Boolean
        Integer iSize iCount iIndex iCurrentFolder
        Boolean bOK bFound
        String sNoFolder sFolderNameShort
        String[] asFolderList

        Move False to bOK
        Move (SearchArray(".",  saNoFolderList)) to iCurrentFolder
        Move (iCurrentFolder <> -1) to bFound
        If (bFound = True) Begin
            // We need to remove "." from the array to avoid problems with folders containing a "."
            Move (RemoveFromArray(saNoFolderList, iCurrentFolder)) to saNoFolderList
            // The rightmost folder name:
            Get ParseFileName sFolderName to sFolderNameShort
            Move (sFolderNameShort = ".." or sFolderNameShort = ".") to bOK // Then we're done
        End

        If (bOK = False) Begin
            Move (Lowercase(sFolderName)) to sFolderName
            Move (StrSplitToArray(sFolderName, CS_DirSeparator)) to asFolderList
            Move (Lowercase(sFolderName)) to sFolderName
            Move (SizeOfArray(saNoFolderList)) to iSize
            Decrement iSize
            For iCount from 0 to iSize
                Move (Lowercase(saNoFolderList[iCount])) to sNoFolder
                Move (SearchArray(sNoFolder, asFolderList)) to iIndex
                If (iIndex <> -1) Begin
                    Move True to bOK
                End
                If (bOK = True) Break
            Loop
        End

        Function_Return bOK
    End_Function

    Function IsFolderInDefaultsFolderList String sFolderName Returns Boolean
        Integer iSize iCount iIndex
        Boolean bOK
        String sDefaultFolders
        String[] asDefaultFolderList asFolderList
        
        Move False to bOK 
        Move -1 to iIndex
        
        Move CS_DefaultSourceFolders to sDefaultFolders
        Move (Lowercase(sDefaultFolders)) to sDefaultFolders
        Move (StrSplitToArray(sDefaultFolders, "|")) to asDefaultFolderList

        Move (Lowercase(sFolderName)) to sFolderName
        Move (StrSplitToArray(sFolderName, "\")) to asFolderList

        Move (SizeOfArray(asFolderList)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asFolderList[iCount] to sFolderName
            Move (SearchArray(sFolderName, asDefaultFolderList)) to iIndex
            If (iIndex <> -1) Begin
                Move True to bOK
            End
            If (bOK = True) Break
        Loop

        Function_Return bOK
    End_Function

End_Class
