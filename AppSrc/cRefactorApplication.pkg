// Copyright (c) 2018 Nils Svedmyr, RDC Tools International
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to Use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to Do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in All
// copies or substantial portions of the Software.
//
// THE SOFTWARE is PROVIDED "AS IS", WITHOUT WARRANTY of ANY KIND, EXPRESS or
// IMPLIED, INCLUDING BUT not LIMITED to THE WARRANTIES of MERCHANTABILITY,
// FITNESS for a PARTICULAR PURPOSE and NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS or COPYRIGHT HOLDERS BE LIABLE for ANY CLAIM, DAMAGES or OTHER
// LIABILITY, WHETHER IN an ACTION of CONTRACT, TORT or OTHERWISE, ARISING from,
// OUT of or IN CONNECTION WITH THE SOFTWARE or THE Use OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// *** Important about this class: *********************************************** 
//     - It creates a cRefactorFuncLib object and moves the object ID to the
//     global variable ghoRefactorFuncLib, for easy access .
//     - It also creates a cRefactorEngine object to the ghoRefactorEngine handle
//     See: End_Construct_Object
//     - It creates a cFilesystem object for file manipulation functions
// *******************************************************************************
//
Use cApplication.pkg
Use cCJCommandBarSystem.pkg
Use cIniFile.pkg
Use gFormatNumbers.pkg
Use File_dlg.pkg
Use Dfabout.pkg
Use vwin32fh.pkg          
Use cFilesystem.pkg
Use cSCWsGrid.pkg
Use cCJWorkspaceComboMenuItem.pkg

Global_Variable Integer ghoFileSystem
Move 0 to ghoFileSystem

Use cRefactorFuncLib.pkg
Use cRefactorEngine.pkg

Register_Procedure ActivateEngineLogFile
Register_Procedure ShowOtherLogFilesDialog
Register_Function SelectedFolders Returns String[]

Class cRefactorApplication is a cApplication
    
    Procedure Construct_Object   
        String sVal
        Forward Send Construct_Object

        Property Integer piBackupDaysOverwriteCycle 2

        {Visibility=Private}
        Property String private.psFileCompareApp
        {Visibility=Private}
        Property String private.psStarZenSourceExplorer
        {Visibility=Private}
        Property Integer private.piToolbarIconSize 0
        {Visibility=Private}
        Property Integer private.peTabpagePosition xtpTabPositionLeft
        {Visibility=Private}
        Property String private.psGridRowBackgroundColor 0
        {Visibility=Private}
        Property String private.psSWSFile       ""
        {Visibility=Private}
        Property Boolean private.pbWorkspaceMode True
        {Visibility=Private}
        Property Integer private.piActiveView -1
        {Visibility=Private}
        Property Handle private.phoActiveView -1     
        {Visibility=Private}
        Property tSCLanguage pSCLanguage
        
        Property Handle phoFolderSelHeaDD
        Property String psCompiler 
        Property String psCompOpt  CS_CompOptions
        Property String psUserName ""
        Property Handle phoEditorView 0
        Property Handle phoRefactorView 0
        Property Handle phoEditor 0
    
        Property String psHomePath  ""
        Property String psCurrentSourceFileName ""
        // Zero based. Note: If this is changed, the number of cCmdLnkButton's in the
        //                   SelectWorkspace.dg also needs to change.
        Property Integer piWorkspaceItems 9 
        Property String[] pasSelectedFolders
        
        // For the Scintilla editor
        Property String psStartupProgramPath ""
        Property String psStartupBitmapPath  ""

//        // This is used by the About object to display the compile date & time:
//        Include_Resource ..\Data\CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
        
        Property Handle phoWorkspaceSelector_Menuitem
        Property Handle phoSwsOpenDialog
        Property Handle phoOpenSourceFileDialog
        
        // Cretion of various objects:
        Get Create (RefClass(cFilesystem)) to ghoFileSystem  
        
        Object oSwsOpenDialog is an OpenDialog
            Set phoSwsOpenDialog to Self
            Set Dialog_Caption to CS_SelectWorkspaceFile
            Set Filter_String  to CS_WorkspaceFilterString
        End_Object

        Object oOpenSourceFileDialog is a OpenDialog
            Set Dialog_Caption to "Select a source file"
            Set phoOpenSourceFileDialog to Self
            Set Filter_String to (CS_SourceCodeFilters + "|All Files (*.*)|*.*")
        End_Object

    End_Procedure

    Procedure InitUserName
        String sName
        Get_Environment "USERNAME" to sName
        Set psUserName to sName
    End_Procedure         
                                  
    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        
        Send InitUserName
        Open SysFile  
        Open Functions
        Open FunctionsA
        Set private.psStarZenSourceExplorer to (Trim(SysFile.PathStarZen)) 
        Set piBackupDaysOverwriteCycle      to SysFile.iBackupDaysOverwriteCycle
        
        // These needs to be here; can't be in OnWorkspaceOpened (to early)
        // *** FUNCTION LIBRARY OBJECT ***
        Get Create (RefClass(cRefactorFuncLib)) to ghoRefactorFuncLib
        // *** REFACTOR ENGINE OBJECT ***
        Get Create (RefClass(cRefactorEngine)) to ghoRefactorEngine
    End_Procedure  
    
    // A variant of the ShellExecute Win API, but it waits until the process that is started
    // (the passed program), has finished
    // The DOS box does also _not_ flash briefly.
    Procedure RunProgramWait String sProgram String sParameter
        Handle hProcess
        Integer iVoid
        AboutSHELLEXECUTEINFO sInfo

        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize

        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
        Move SW_SHOW                 to sInfo.nShow

        Move (AddressOf(sProgram))   to sInfo.lpFile
        Move (AddressOf(sParameter)) to sInfo.lpParameters
        // This will "hide" the DOS box from showing (no flasing box):
        Move 0                       to sInfo.nShow

        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
        Move sInfo.hProcess to hProcess
        If (hProcess) Begin
            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
            Move (AboutCloseHandle(hProcess)) to iVoid
        End
    End_Procedure

    Function SourceFilePath Returns String
        String sFileName sPath

        Get psHomePath to sPath
        Get psCurrentSourceFileName to sFileName
        If (sFileName <> "") Begin
            Get ParseFolderName sFileName to sPath
        End
        Function_Return sPath
    End_Function

    { MethodType=Property }
    { EnumList="16, 24, 32" }
    Procedure Set piToolbarIconSize Integer iSize
        Send WriteInteger CS_Settings CS_ToolbarIconSize iSize
        Set private.piToolbarIconSize to iSize
    End_Procedure

    { MethodType=Property }
    Function piToolbarIconSize Returns Integer
        Integer iSize
        Get private.piToolbarIconSize to iSize
        If (iSize = 0) Begin
            Get ReadInteger CS_Settings CS_ToolbarIconSize 32 to iSize
            If (iSize = 0) Begin
                Move 32 to iSize
            End
            Set private.piToolbarIconSize to iSize
        End
        Function_Return iSize
    End_Function

    { MethodType=Property }
    { EnumList="xtpTabPositionTop, xtpTabPositionLeft, xtpTabPositionBottom, xtpTabPositionRight" }
    Procedure Set peTabpagePosition Integer eMode
        Set private.peTabpagePosition to eMode
        Send WriteInteger CS_Settings CS_TabPosition eMode   
    End_Procedure

    { MethodType=Property }
    Function peTabpagePosition Returns Integer
        Integer eMode
        Get ReadInteger CS_Settings CS_TabPosition xtpTabPositionLeft to eMode
        Function_Return eMode
    End_Function

    { MethodType=Property }
    Procedure Set psGridRowBackgroundColor String sColor
        Set private.psGridRowBackgroundColor to sColor
        Send WriteString CS_Settings CS_GridRowBackgroundColor sColor
        Broadcast Recursive Set piSelectedRowBackColor of (Client_Id(phoMainPanel(ghoApplication))) to sColor
        Broadcast Recursive Set piHighlightBackColor   of (Client_Id(phoMainPanel(ghoApplication))) to sColor
    End_Procedure

    { MethodType=Property }
    Function psGridRowBackgroundColor Returns String
        String sColor
        Get private.psGridRowBackgroundColor to sColor
        If (sColor = 0) Begin
            Get ReadString CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
            If (sColor contains "clBlueGrey") Begin
                Move (Replace("clBlueGrey", sColor, "clGreenGrey")) to sColor
            End
            Set private.psGridRowBackgroundColor to sColor
        End
        Function_Return sColor
    End_Function

    { MethodType=Property }
    Procedure Set psFileCompareApp String sProgramName
        Send WriteString CS_Settings CS_FileCompareProgram sProgramName
        Set private.psFileCompareApp to sProgramName
    End_Procedure

    { MethodType=Property }
    Function psFileCompareApp Returns String
        String sProgramName
        Get private.psFileCompareApp to sProgramName
        If (sProgramName = "") Begin
            Get ReadString CS_Settings CS_FileCompareProgram "" to sProgramName
            Set private.psFileCompareApp to sProgramName
        End
        Function_Return sProgramName
    End_Function

    { MethodType=Property }
    Procedure Set psStarZenSourceExplorer String sProgramName
        Send WriteString CS_Settings CS_StarZenSourceExplorer sProgramName
        Set private.psStarZenSourceExplorer to sProgramName
    End_Procedure

    { MethodType=Property }
    Function psStarZenSourceExplorer Returns String
        String sProgramName
        Get private.psStarZenSourceExplorer to sProgramName
        If (sProgramName = "") Begin
            Get ReadString CS_Settings CS_StarZenSourceExplorer "" to sProgramName
            Set private.psStarZenSourceExplorer to sProgramName
        End
        Function_Return sProgramName
    End_Function

    Procedure DisplayPerfCounters
    End_Procedure

    Function StartPerfCounter Integer eOperation String sComment Returns Integer
        Function_Return 0
    End_Function

    Procedure StopPerfCounter Integer iCounter
    End_Procedure

    Procedure Set piActiveView Integer iActiveViewID Handle hoActiveView
        Set Private.piActiveView  to iActiveViewID
        Set Private.phoActiveView to hoActiveView
    End_Procedure

    Function piActiveView Returns Integer
        Function_Return (Private.piActiveView(Self))
    End_Function

    Function phoActiveView Returns Integer
        Function_Return (Private.phoActiveView(Self))
    End_Function

    Function SelectWorkspaceFile Returns String
        Boolean bOpen
        String sFileName

        Move "" to sFileName
        Get Show_Dialog of (phoSwsOpenDialog(Self)) to bOpen
        If (bOpen = True) Begin
            Get File_Name of (phoSwsOpenDialog(Self)) to sFileName
            Send AddWorkSpaceFileToRegistry sFileName
        End
        Function_Return sFileName
    End_Function

    Procedure OnWorkspaceLoaded
    End_Procedure

    Procedure UpdateWorkspaceSelectorDisplay String sFileName
        String sText sVersion sWorkspaceText
        Handle hoIniFile
        Integer iPos
        Boolean bExists

        If (sFileName <> "") Begin
            Move (RightPos(". ", sFileName)) to iPos
            If (iPos <> 0) Begin
                Move (Mid(sFileName, CI_EOL, 4)) to sFileName
                Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bExists
                If (bExists = False) Begin
                    Send Info_Box "The .sws file doesn't exist! Please select another."
                    Procedure_Return
                End
            End
            Move CS_CurrentWorkspace to sWorkspaceText
            Get Create (RefClass(cIniFile)) to hoIniFile
            Set psFilename of hoIniFile to sFileName
            Get ReadString of hoIniFile CS_PropertiesKeyWord CS_VersionKeyWord "" to sVersion
            Send Destroy of hoIniFile

            // Remove any number pre-facing the .sws file path & name
            Move (Pos(":", sFileName)) to iPos
            If (iPos <> 2) Begin
                Move (Mid(sFileName, CI_EOL, 4)) to sFileName
            End
            Get ParseFileName sFileName to sText
        End
        Else Begin
            Move CS_OpenWorkspace to sWorkspaceText
            Move CS_NoActiveWorkspaceText to sText
            If ((phoWorkspaceSelector_Menuitem(Self))) Begin
                If (IsComObjectCreated(phoWorkspaceSelector_Menuitem(Self))) Begin
                    Send ResetComboForm of (phoWorkspaceSelector_Menuitem(Self))
                End
            End
        End
        
        // It is probably safest to clear all views when switching workspace.
        If (phoMainPanel(Self) <> 0) Begin
            Broadcast Send Request_Clear_All of (Client_Id(phoMainPanel(ghoApplication)))
            Set psCaption of (phoWorkspaceSelector_Menuitem(Self)) to sWorkspaceText
        End
        Set psSWSFile to sFileName
        If (phoMainPanel(Self) <> 0) Begin
            // Send to all views
            Broadcast Send OnWorkspaceLoaded of (Client_Id(phoMainPanel(ghoApplication)))
        End
        Send OnFileNameUpdate ""
    End_Procedure                           
    
    Procedure AddWorkSpaceFileToRegistry String sFileName
        Integer iCount iSize
        String[] sWorkspaces
        Boolean bFound

        Get piWorkspaceItems to iSize
        // Is the selected .sws file new?
        For iCount from 0 to iSize
            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) "" to sWorkspaces[iCount]
            If (Uppercase(sWorkspaces[iCount]) = Uppercase(sFilename)) Begin
                Move True to bFound
            End
        Loop

        // If new, save it to the registry. Push it to the top of the stack (LiFo).
        If (bFound = False) Begin
            Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + "0") sFilename
            Decrement iSize
            For iCount from 0 to iSize
                If (sWorkspaces[iCount] <> "") Begin
                    Send WriteString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount + 1)) sWorkspaces[iCount]
                End
            Loop
        End
    End_Procedure

    Function ReadWorkspaceKeysFromRegistry Returns String[]
        Integer iCount iSize iItem
        String[] asWorkspaces
        String sWorkspace

        Move 0 to iItem
        Get piWorkspaceItems to iSize
        For iCount from 0 to iSize
            Get ReadString CS_WorkspacesKey (CS_WorkspaceRecentKey + String(iCount)) '' to sWorkspace
            If (sWorkspace <> "") Begin
                Move sWorkspace to asWorkspaces[iItem]
                Increment iItem
            End
        Loop
        Function_Return asWorkspaces
    End_Function

    // Pass an SWS file with full path.
    // Returns the .ws file name of the Programs folder.
    Function WsFileNameFromSWSFileName String sSWSFilename Returns String
        Handle hoIni
        String sWs sWorkspaceFileName

        Get Create (RefClass(cIniFile)) to hoIni
        Set psFilename of hoIni  to sSWSFilename
        Get ReadString of hoIni CS_WorkspacePaths CS_ConfigFile "" to sWs
        Send Destroy   of hoIni
        Move (Replace(".\", sWs, ExtractFilePath(sSWSFilename))) to sWorkspaceFileName

        Function_Return sWorkspaceFileName
    End_Function

    // Finds a program icon file name for a "ProjectNN" in the .sws file.
    // The first icon file for a project is returned.
    Function AppIconFromSWSFileName String sSWSFilename Returns String
        Handle hoIni hoWorkspace
        String sPath sProgramFile sProgramConfigFile sIconFileName sWorkspaceFileName sBitmapPath sAppSrcPath s
        Integer iCount iSize
        Boolean bExists
        
        Move 20 to iSize        
        Get phoWorkspace to hoWorkspace
        // Get .ws file name
        Get WsFileNameFromSWSFileName sSWSFilename to sWorkspaceFileName
        Get ParseFolderName sSWSFilename to sPath
        Get vFolderFormat sPath to sPath
        
        // Get the first project file (program file)
        Get Create (RefClass(cIniFile)) to hoIni
        Set psFilename of hoIni  to sSWSFilename
        For iCount from 0 to iSize
            Get ReadString of hoIni CS_Projects (String(CS_Project + String(iCount))) "" to sProgramFile
            If (sProgramFile <> "") Begin
                Move (Replace(".src", Lowercase(sProgramFile), ".cfg")) to sProgramConfigFile
                // Open workspace file and get AppSrcPath + BitmapPath
                Set psFilename of hoIni  to sWorkspaceFileName
                Get ReadString of hoIni CS_Workspace CS_AppSrcPath CS_AppSrcPath to sAppSrcPath
                Get PathAtIndex of hoWorkspace sAppSrcPath 1 to sAppSrcPath
                Move (Replace(".\", sAppSrcPath, "")) to sAppSrcPath
                Get vFolderFormat sAppSrcPath to sAppSrcPath
                Get ReadString of hoIni CS_Workspace CS_BitmapPath CS_BitmapPath to sBitmapPath
                Get PathAtIndex of hoWorkspace sBitmapPath 1 to sBitmapPath
                Move (Replace(".\", sBitmapPath, "")) to sBitmapPath
                Get vFolderFormat sBitmapPath to sBitmapPath
                // Open .cfg file and get the icon file name
                Set psFileName of hoIni to  (sPath + sAppSrcPath + sProgramConfigFile)
                Get ReadString of hoIni CS_Application CS_Icon "" to sIconFileName 
                // Reset ini-file name so we can get the next project item
                Set psFilename of hoIni  to sSWSFilename
                // We keep checking until we find a project (program) with an icon.
                If (sIconFileName <> "") Begin
                    Move iSize to iCount // Get out of here.
                End                                     
            End
        Loop  
        
        Send Destroy   of hoIni
        // The icon file might not exist in the selected workspace BitmapPath, or no project icon
        // was ever set, in which case we use DataFlex default icon "Default.ico".
        Get vFilePathExists  (sPath + sBitmapPath + sIconFileName) to bExists
        If (bExists = False) Begin 
            Move "Default.ico" to sIconFileName
        End
        Else Begin
            Move (sPath + sBitmapPath + sIconFileName) to sIconFileName
        End
        
        Function_Return sIconFileName
    End_Function

    Procedure ToggleWorkspaceMode
    End_Procedure

    Procedure Set pbWorkspaceMode Boolean bState
        Set private.pbWorkspaceMode to bState
        Send ToggleWorkspaceMode
    End_Procedure

    Function pbWorkspaceMode Returns Boolean
        Function_Return (private.pbWorkspaceMode(Self))
    End_Function

    { MethodType=Property }
    Procedure Set psSWSFile String sSWSFile
        String sPath sExt
        
        Get ParseFoldername sSWSFile to sPath
        Get ParseFileExtension sSWSFile to sExt
        // Has the user selected a ".ws" instead of a ".sws" file? 
        // Then we need to adjust the path from "Programs" -> "Home"
        // aka one level up.
        If (Lowercase(sExt) = "ws") Begin 
            Move (Left(sPath, Length(sPath) -1)) to sPath
            Get ParseFolderName sPath to sPath        
        End
        If (sPath <> "") Begin
            Get vFolderFormat sPath to sPath
        End
        Set psHomePath to sPath
        Set private.psSWSFile to sSWSFile 
    End_Procedure

    { MethodType=Property }
    Function psSWSFile Returns String
        Function_Return (private.psSWSFile(Self))
    End_Function

    { MethodType=Property }
    Function psWorkspaceHomePath Returns String
        String sPath 
        Get psHomePath to sPath
        Function_Return sPath
    End_Function

    // Will create a backup-folder for the passed file, if-and-only-if it doesn't exists.
    // Returns the full path to the backup folder.
    Function CreateBackupFolder String sFile Returns String
        String sPath sHomePath sBackupFolder
        Boolean bFolderExists bSuccess
        Integer iRetval iPos

        Move "" to sPath
        Get psHomePath to sHomePath
        If (sFile <> "") Begin
        Get ParseFolderName sFile to sPath
        Move (Replace(Lowercase(sHomePath), Lowercase(sPath), "")) to sPath // Only want the subfolder structure
        Move (Pos(":", sPath)) to iPos
        If (iPos > 0) Begin
            Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
            Move (Pos(CS_DirSeparator, sPath)) to iPos
            If (iPos > 0) Begin
                Move (Mid(sPath, CI_EOL, (iPos + 1))) to sPath
            End
        End
        End

        Move (sHomePath + CS_BackupFolder + CS_DirSeparator + sPath) to sBackupFolder
        Get RemoveFolderSeperator of ghoFileSystem sBackupFolder to sBackupFolder
        Get vFolderExists sBackupFolder to bFolderExists
        If (bFolderExists = False) Begin
            Get DirectoryCreateEx of ghoFileSystem sBackupFolder False to bSuccess
            If (bSuccess = False) Begin
                Get YesNo_Box ("Warning! The" * String(sHomePath) + "\DFRefactor Backup folder could not be created. You should abort the program now, fix the cause and restart. Abort the program?") to iRetval
                If (iRetval = MBR_Yes) Begin
                    Send Exit_Application
                End
            End
        End
        Get vFolderFormat sBackupFolder to sBackupFolder
        Function_Return sBackupFolder
    End_Function

    Function IsBackupFolder Returns Boolean
        String sHomePath sBackupFolder
        Boolean bExists

        Get psHomePath to sHomePath
        Get vFolderFormat sHomePath to sHomePath
        Move (sHomePath + CS_BackupFolder) to sBackupFolder
        Get vFolderExists sBackupFolder to bExists

        Function_Return bExists
    End_Function

    // Takes a source file name with full path as parameter.
    // Returns a name with full path for it's backup file counterpart.
    // If the backup folder doesn't exist, it will be created, aka
    // the BackupFolder function is used.
    Function CreateBackupFileName String sPathFileName Returns String
        String sBackupFolder sFileName sBackupFile
        Integer iPos

        Get CreateBackupFolder sPathFileName   to sBackupFolder
        Get vFolderFormat sBackupFolder  to sBackupFolder
        Get ParseFileName sPathFileName  to sFileName
        Move (Pos(":", sFileName))       to iPos
        If (iPos > 0) Begin
            Move (Mid(sFileName, CI_EOL, iPos)) to sFileName
        End
        Move (sBackupFolder + sFileName) to sBackupFile

        Function_Return sBackupFile
    End_Function

    Function HomeBackupFilePath Returns String
        Boolean bExist
        String sPath sPathBackup

        Get psHomePath to sPath
        If (sPath <> "") Begin
            Get vFolderFormat sPath to sPath
            Move (sPath + CS_BackupFolder) to sPathBackup
            Get FileExists of ghoFileSystem sPathBackup DIRMODE_DIRECTORIES_ONLY to bExist
            If (bExist) Begin
                Move sPathBackup to sPath
            End
            Else Begin
                Move "" to sPath
            End
        End
        Function_Return sPath
    End_Function

    Function SaveBackupFile String sSourceFile Returns Boolean
        Boolean bOK bExists bShouldBackup
        String sBackupFile
        Date dWriteSource dWriteBackup
        Integer iBackupDaysOverwriteCycle
        tFileTime ftCurrentTime
        
        Move True to bShouldBackup
        Get piBackupDaysOverwriteCycle to iBackupDaysOverwriteCycle
        Get CreateBackupFileName sSourceFile to sBackupFile
        Get FileExists of ghoFileSystem sBackupFile to bExists
        If (bExists = True) Begin
            Get FileDate of ghoFileSystem sSourceFile to dWriteSource
            Get FileDate of ghoFileSystem sBackupFile to dWriteBackup
            Move ((dWriteSource - dWriteBackup) > iBackupDaysOverwriteCycle or (dWriteBackup - dWriteSource) > iBackupDaysOverwriteCycle) to bShouldBackup
        End

        // If we make a backup copy of the file we change the date & time,
        // to present time. This is so we later - if the 'Start Process' button is
        // pressed again - decide to _not_ backup the file again iif it has todays,
        // or yesterday's date. That way the user can press the "Start Process"
        // button several times without the backup file gets overwritten by a
        // file that has been changed all ready - keeping the original source file
        // intact.
        If (bShouldBackup = True) Begin
            Get FileCopy of ghoFileSystem sSourceFile sBackupFile False to bOK
            Get CurrentSystemTimeAsFileTime of ghoFileSystem to ftCurrentTime
            Set FileLastWriteTime of ghoFileSystem to sBackupFile ftCurrentTime
            Get FileExists of ghoFileSystem sBackupFile to bExists
        End

        Function_Return bExists
    End_Function

    // Does a backup copy of the current source file already exist?
    Function IsBackupFile String sCurrentFileName Returns String
        String sPath sFile sHomePath sBackupFolder sBackupFile sExt
        Boolean bExists
        tsSearchResult[] SearchResultArray

        If (sCurrentFileName = "") Begin
            Function_Return ""
        End

        Get psHomePath to sHomePath
        Get ParseFolderName sCurrentFileName to sPath
        Move (sHomePath + CS_BackupFolder) to sBackupFolder
        Get vFolderExists sBackupFolder to bExists
        If (bExists = False) Begin
            Function_Return ""
        End

        Move "" to sBackupFile
        Get ParseFileName sCurrentFileName to sFile
        Get ParseFileExtension sFile to sExt
        Move (Replace(sExt, sFile, "")) to sFile
        Get vFolderFormat sBackupFolder to sBackupFolder
        Move (sBackupFolder + sFile + String("*")) to sFile
        Get FileSearchRecursive of ghoFileSystem sFile DIRMODE_FILES_ONLY True to SearchResultArray
        If (SizeOfArray(SearchResultArray)) Begin
            Move SearchResultArray[0].sFilename to sBackupFile
        End

        Function_Return sBackupFile
    End_Function

    Function AllBackupFolderFiles Returns tsSearchResult[]
        Boolean bExists
        String sBackupHomeFolder sBackupFolder sHomePath sFileMask sFileName
        String[] asNoFolderSearch asBackupFolders
        tsSearchResult[] asBackupFilesEmpty asBackupFiles asBackupFilesTotal
        Integer iFolder iFolders iFile iFiles

        Get psHomePath to sHomePath
        Get vFolderFormat sHomePath to sHomePath
        Move (sHomePath + CS_BackupFolder) to sBackupHomeFolder
        Get vFolderExists sBackupHomeFolder to bExists
        If (bExists = False) Begin
            Function_Return asBackupFilesEmpty
        End

        Get NoFolderListAsArray True to asNoFolderSearch
        Get RecursiveSearchFolders sBackupHomeFolder asNoFolderSearch to asBackupFolders
        Move (SizeOfArray(asBackupFolders)) to iFolders
        Decrement iFolders
        For iFolder from 0 to iFolders
            Move asBackupFolders[iFolder] to sBackupFolder
            Get vFolderFormat sBackupFolder to sBackupFolder
            Move (sBackupFolder + "*.*") to sFileMask

            // File loop:
            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asBackupFiles
            // Remove report files created by the DFRefactor tool.
            If (SizeOfArray(asBackupFiles)) Begin
                If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_SummaryLogfileName) Begin
                    Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
                    If (SizeOfArray(asBackupFiles)) Begin
                        If (asBackupFiles[0].sFilename = CS_SummaryLogfileName or asBackupFiles[0].sFilename = CS_UnusedSourceLogFile) Begin
                            Move (RemoveFromArray(asBackupFiles, 0)) to asBackupFiles
                        End
                    End
                End
            End
            Move (SizeOfArray(asBackupFiles)) to iFiles
            Decrement iFiles
            For iFile from 0 to iFiles
                Move asBackupFiles[iFile].sFilename to sFileName
                // Store the path in the sAlternateFileName struct item
                Move sBackupFolder to asBackupFiles[iFile].sAlternateFileName
            Loop
            Move (AppendArray(asBackupFilesTotal, asBackupFiles)) to asBackupFilesTotal
        Loop

        Function_Return asBackupFilesTotal
    End_Function

    Function AllSourceFolders String[] asSelectedFolders Returns String[]
        String sHomePath
        String[] asNoFolderSearch asSourceFolders asAllSourceFolders
        Integer iSize iCount

        Get psHomePath to sHomePath
        Get vFolderFormat sHomePath to sHomePath

        Get NoFolderListAsArray False to asNoFolderSearch
        Move (SizeOfArray(asSelectedFolders)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Get RecursiveSearchFolders asSelectedFolders[iCount] asNoFolderSearch to asSourceFolders
            Move (AppendArray(asAllSourceFolders, asSourceFolders)) to asAllSourceFolders
        Loop

        Function_Return asAllSourceFolders
    End_Function

    Function AllSourceFiles String[] asFolders String sFileFilter Returns tRefactorFiles
        Boolean bIsFileInFilter
        String sFolderName sFileMask sFileName
        tsSearchResult[] asSourceFiles asSourceFilesTotal
        Integer iFolder iFolders iCount iSize iFile
        tRefactorFiles FileData
        
        Move (SizeOfArray(asFolders)) to iFolders  
        // There is a special function (SingleSourceFile) for a single file,
        // but in case this function is called make it work the same.
        If (iFolders = 0) Begin
            Get psCurrentSourceFileName   to sFileName
            Move                sFileName to FileData.asFullFileNames[0] 
            Get ParseFolderName sFileName to FileData.asFolders[0]
            Function_Return FileData
        End

        Decrement iFolders
        Move 0 to iFile
        // Folder loop:
        For iFolder from 0 to iFolders
            Move asFolders[iFolder] to sFolderName
            Get vFolderFormat sFolderName to sFolderName
            Move (sFolderName + "*.*") to sFileMask

            Get FileSearch of ghoFileSystem sFileMask DIRMODE_FILES_ONLY False to asSourceFiles
            Move (SizeOfArray(asSourceFiles)) to iSize
            Decrement iSize
            
            // File loop:
            For iCount from 0 to iSize
                Move asSourceFiles[iCount].sFilename to sFileName
                Get IsFileInFilter sFileName sFileFilter to bIsFileInFilter
                If (bIsFileInFilter = True) Begin
                    Move (sFolderName + String(sFileName)) to FileData.asFullFileNames[iFile]
                    Increment iFile
                End
            Loop
        Loop
        Move asFolders to FileData.asFolders

        Function_Return FileData
    End_Function    
    
    Function SingleSourceFile Returns tRefactorFiles
        String sFolder sFileName
        Integer iItem         
        String sFullFileName 
        tRefactorFiles RefactorFiles
        
        Move 0 to iItem
        Get psCurrentSourceFileName       to sFullFileName
        Get ParseFolderName sFullFileName to sFolder
        Get ParseFileName   sFullFileName to sFileName
        
        Move sFullFileName to RefactorFiles.asFullFileNames[iItem]
        Move sFolder       to RefactorFiles.asFolders[iItem]
        
        Function_Return RefactorFiles
    End_Function  
    
    Function CollectFileData Handle oFolderSelDtl_DD Returns tRefactorFiles
        tRefactorFiles RefactorFiles RefactorFilesEmpty
        String[] asFolders  
        
        If (SysFile.FileExtensionFilter = "") Begin
            Send UserError "SysFile.FileExtensionFilter is blank! (Function CollectAllFiles)"
            Function_Return RefactorFilesEmpty
        End
        If (pbWorkspaceMode(Self) = True) Begin
            Get pasSelectedFolders to asFolders
            If (SizeOfArray(asFolders) = 0) Begin
                Get SelectedFolders of oFolderSelDtl_DD to asFolders
                Set pasSelectedFolders to asFolders
            End
            Get AllSourceFiles asFolders SysFile.FileExtensionFilter to RefactorFiles
        End
        Else Begin     
            Get SingleSourceFile to RefactorFiles
        End
    
        Function_Return RefactorFiles    
    End_Function

    Function IsFileInFilter String sFileName String sFileFilter Returns Boolean
        Integer iSearchIndex
        String sExtension sChar
        String[] asFileFilter
        
        If (Lowercase(sFileName) =  Lowercase("LoginEncryptionKey.inc")) Begin
            Function_Return False
        End
        Move (Lowercase(sFileName))      to sFileName
        Get ParseFileExtension sFileName to sExtension
        Move (Left(sExtension, 1))       to sChar
        If (sChar <> ".") Begin
            Move ("." + String(sExtension)) to sExtension
        End
        Move (Trim(Lowercase(sFileFilter)))  to sFileFilter
        Move (Replaces("*", sFileFilter, "")) to sFileFilter
        Move (StrSplitToArray(sFileFilter, ";")) to asFileFilter
        Move (SearchArray(sExtension, asFileFilter)) to iSearchIndex
        Function_Return (iSearchIndex <> -1)
    End_Function

    Function RecursiveSearchFolders String sFolderName String[] asNoFolderList Returns String[]
        Boolean bFound
        Integer iCount iSize iItem
        String sMask sPrevFolderName sHomePath
        tsSearchResult[] asSearchResult
        String[] saSearchFolders

        If (not(sFolderName contains ":")) Begin
            Get psHomePath to sHomePath
            Get vFolderFormat sHomePath to sHomePath
            Move (sHomePath + sFolderName) to sFolderName
        End
        Get vFolderFormat sFolderName to sFolderName
        Move (sFolderName + "*") to sMask

        Move 0 to iItem

        // Recursive folder search
        Get FileSearchRecursive of ghoFileSystem sMask DIRMODE_DIRECTORIES_ONLY False to asSearchResult
        Move (SizeOfArray(asSearchResult)) to iSize
        Decrement iSize

        // Remove folder names from array where we should not search for source files
        Move "" to sPrevFolderName
        For iCount from 0 to iSize
            Get IsFolderInNoFolderList of ghoApplication asNoFolderList asSearchResult[iCount].sFilename to bFound
            If (bFound = False) Begin
                If (asSearchResult[iCount].sFilename <> sPrevFolderName) Begin
                    Move asSearchResult[iCount].sFilename to saSearchFolders[iItem]
                    Increment iItem
                End
            End
            Move asSearchResult[iCount].sFilename to sPrevFolderName
        Loop

        Move sFolderName to saSearchFolders[SizeOfArray(saSearchFolders)]
        // Sort the folder array to get the top one first.
        Move (SortArray(saSearchFolders)) to saSearchFolders

        Function_Return saSearchFolders
    End_Function

    Procedure ComparePaths String sCompareApp
        String sPath sPathBackup

        Get psHomePath to sPath
        Get HomeBackupFilePath to sPathBackup
        If (sPath <> "" and sPathBackup <> "") Begin
            Runprogram Background ('"' + sCompareApp + '"') ('"' + sPath + '" "' + sPathBackup + '"')
        End
    End_Procedure

    Procedure CompareFiles String sCompareApp
        Boolean bExist
        String sFileName sFile sFileBackup sCurrentFileName

        Get psCurrentSourceFileName to sFileName
        If (sFileName <> "") Begin
            Get FileExists of ghoFileSystem sFileName DIRMODE_FILES_ONLY to bExist
            If (bExist) Begin
                Get psCurrentSourceFileName to sCurrentFileName
                Get IsBackupFile sCurrentFileName to sFileBackup
                If (sFileBackup <> "") Begin
                    Runprogram Background ('"' + sCompareApp + '"') ('"' + sFileName + '" "' + sFileBackup + '"')
                End
                Else Begin
                    Send Info_Box ("Cannot find the backup file file" * sFileBackup)
                End
            End
            Else Begin
                Send Info_Box ("The file in the source file" * sFileName * "\nDoes not exist.")
            End
        End
        Else Begin
            Send Info_Box "You have to select a file first."
        End
    End_Procedure

    // Returns the current Studio "File mask" setting as a string. See
    Function StudioFileMaskSettings Returns String
        Handle hoReg
        String sStudioRegPath sRetval sDFVersion
        Boolean bExists bOk
        Integer iMajorVersion iMinorVersion

        Move FMAC_VERSION  to iMajorVersion
        Move FMAC_REVISION to iMinorVersion
        Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sDFVersion

        Get Create (RefClass(cRegistry)) to hoReg
        Set pfAccessRights of hoReg to Key_Read

        Move CS_StudioToolsPathStart to sStudioRegPath
        Move (sStudioRegPath + sDFVersion + CS_StudioToolsPathEnd) to sStudioRegPath
        Set phRootKey of hoReg to HKEY_CURRENT_USER

        // First check if the DF version is installed
        Get KeyExists of hoReg sStudioRegPath to bExists
        If (bExists = False) Begin
            Send Destroy of hoReg
            Function_Return cx_RegKeyDFKeyDoesNotExist
        End

        Get OpenKey of hoReg sStudioRegPath to bOk
        If (bOk = True) Begin
            Set pfAccessRights of hoReg to KEY_READ
            Get ReadString of hoReg CS_DFExtensionsKey to sRetval
        End

        Send CloseKey of hoReg
        Send Destroy of hoReg
        Function_Return sRetval
    End_Function

    Function StudioFileExtensions String sDFVersion Returns String
        Handle hoReg
        String sStudioRegPath  sRetval
        Boolean bExists bOk

        Get Create (RefClass(cRegistry)) to hoReg
        Move CS_StudioPath to sStudioRegPath
        If (sDFVersion > "17.1") Begin
            Move (Replace("Visual ", sStudioRegPath, "")) to sStudioRegPath
        End
        Move (sStudioRegPath + sDFVersion + CS_StudioPathEnd) to sStudioRegPath
        Set phRootKey of hoReg to HKEY_CURRENT_USER

        // First check if the DF version is installed
        Get KeyExists of hoReg sStudioRegPath to bExists
        If (bExists = False) Begin
            Send Destroy of hoReg
            Function_Return cx_RegKeyDFKeyDoesNotExist
        End

        Get OpenKey of hoReg sStudioRegPath to bOk
        If (bOk = True) Begin
            Set pfAccessRights of hoReg to KEY_READ
            // In the Studio this key is still call "VDF".
            Get ReadString of hoReg "VdfExtensions" to sRetval
        End

        Send CloseKey of hoReg
        Send Destroy of hoReg
        Function_Return (Trim(sRetval))
    End_Function

    Function NoFolderListAsArray Boolean bNoBackupFolder Returns String[]
        String sNoFolderList
        String[] saNoFolderList

        Move CS_NoFolderList to sNoFolderList
        If (bNoBackupFolder = False) Begin
            Move (sNoFolderList + "|" + CS_BackupFolder) to sNoFolderList
        End
        Move (Lowercase(sNoFolderList)) to sNoFolderList
        Move (StrSplitToArray(sNoFolderList, "|")) to saNoFolderList
        Function_Return saNoFolderList
    End_Function

    // Returns True if the passed sFolderName exists in the passed string array.
    Function IsFolderInNoFolderList String[] saNoFolderList String sFolderName Returns Boolean
        Integer iSize iCount iIndex iCurrentFolder
        Boolean bOK bFound
        String sNoFolder sFolderNameShort
        String[] asFolderList

        Move False to bOK
        Move (SearchArray(".",  saNoFolderList)) to iCurrentFolder
        Move (iCurrentFolder <> -1) to bFound
        If (bFound = True) Begin
            // We need to remove "." from the array to avoid problems with folders containing a "."
            Move (RemoveFromArray(saNoFolderList, iCurrentFolder)) to saNoFolderList
            // The rightmost folder name:
            Get ParseFileName sFolderName to sFolderNameShort
            Move (sFolderNameShort = ".." or sFolderNameShort = ".") to bOK // Then we're done
        End

        If (bOK = False) Begin
            Move (Lowercase(sFolderName)) to sFolderName
            Move (StrSplitToArray(sFolderName, CS_DirSeparator)) to asFolderList
            Move (Lowercase(sFolderName)) to sFolderName
            Move (SizeOfArray(saNoFolderList)) to iSize
            Decrement iSize
            For iCount from 0 to iSize
                Move (Lowercase(saNoFolderList[iCount])) to sNoFolder
                Move (SearchArray(sNoFolder, asFolderList)) to iIndex
                If (iIndex <> -1) Begin
                    Move True to bOK
                End
                If (bOK = True) Break
            Loop
        End

        Function_Return bOK
    End_Function

    Function IsFolderInDefaultsFolderList String sFolderName Returns Boolean
        Integer iSize iCount iIndex
        Boolean bOK
        String sDefaultFolders
        String[] asDefaultFolderList asFolderList
        
        Move False to bOK 
        Move -1 to iIndex
        
        Move CS_DefaultSourceFolders to sDefaultFolders
        Move (Lowercase(sDefaultFolders)) to sDefaultFolders
        Move (StrSplitToArray(sDefaultFolders, "|")) to asDefaultFolderList

        Move (Lowercase(sFolderName)) to sFolderName
        Move (StrSplitToArray(sFolderName, "\")) to asFolderList

        Move (SizeOfArray(asFolderList)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asFolderList[iCount] to sFolderName
            Move (SearchArray(sFolderName, asDefaultFolderList)) to iIndex
            If (iIndex <> -1) Begin
                Move True to bOK
            End
            If (bOK = True) Break
        Loop

        Function_Return bOK
    End_Function
    
    // Event for updating file name display.
    Procedure OnFileNameUpdate String sFileName
    End_Procedure
    
    Procedure ShowLogFile
        String sPath sLogFile
        Boolean bLogFileExists

        Get psHomePath of ghoApplication to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_BackupFolder + CS_DirSeparator + CS_SummaryLogfileName) to sLogFile
        Get vFilePathExists sLogFile to bLogFileExists
        If (bLogFileExists = False) Begin
            Send Info_Box "Can't find the log file"
            Procedure_Return
        End

        Send ActivateEngineLogFile of (Client_Id(phoMainPanel(Self))) sLogFile
    End_Procedure

    Procedure ShowOtherLogFiles
        String[] asOtherLogFiles
        Get pasOtherLogFiles of ghoRefactorFuncLib to asOtherLogFiles 
        Send ShowOtherLogFilesDialog of (Client_Id(ghoCommandBars)) asOtherLogFiles
    End_Procedure
    
End_Class
