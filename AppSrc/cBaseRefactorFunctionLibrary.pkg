Use UI
Use RefactorFunctionConstants.inc
Use cRemoveUnusedLocals.pkg
Use cUnusedSourceFiles.pkg
Use cDDOReStyler.pkg
Use cScintillaRefactorEditor.pkg
Use cRegex.pkg

Register_Function phoEditor Returns Handle 
Register_Function phoRemoveUnusedLocals Returns Handle
Register_Function phoReportUnusedSourceFiles Returns Handle

#IFNDEF ghoRefactorFunctionLibrary
Global_Variable Handle ghoRefactorFunctionLibrary
#ENDIF

#IFNDEF ghoStatusLog
Global_Variable Handle ghoStatusLog
#ENDIF

Use cSysFileDataDictionary.dd  
Open FunctionsA

Class cBaseRefactorFunctionLibrary is a cObject
    Procedure Construct_Object
        String[] asLocalVariableTypes asLocalVariableArrayTypes

        Forward Send Construct_Object
        Move Self to ghoRefactorFunctionLibrary

        Property Handle phoEditor
        Property Integer peNewStyle eDDUnknown

        Property tRefactorSettings pRefactorSettings
        //
        Property Boolean pbToggleState True     
        Property Boolean pbInRepeatLoop False
        
        Property String[] paCommands
        Property String[] paCommandFunctions    
        Property String[] pasLocalVariableTypes
        Property String[] pasLocalVariableArrayTypes

        Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
        Set pasLocalVariableTypes to asLocalVariableTypes
        Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes

        // Properties for the RemovePRoejctObjectStructure function:
        Property Boolean pbProjectObjectStructureStart False 
        Property Boolean pbProjectObjectStructureEnd False
        Property Boolean pbRegisterAllObjectsStart False    
        Property Boolean pbRegisterAllObjectsEnd False
        Property String[] pasObjectNames

        // Refactor object handles
        Property Handle phoRemoveUnusedLocals
        Property Handle phoReportUnusedSourceFiles 
        Property Handle phoDDOReStyler

        Object oRemoveUnusedLocals is a cRemoveUnusedLocals
            Set phoRemoveUnusedLocals to Self
        End_Object
    
        Object oReportUnusedSourceFiles is a cUnusedSourceFiles
            Set phoReportUnusedSourceFiles to Self
        End_Object
        
        Object oDDOReStyler is a cDDOReStyler
            Set phoDDOReStyler to Self
        End_Object

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        Send AddAllCommands  
        Send AddAllCommandFunctions
    End_Procedure
    
    Procedure ResetProjectObjectStructureProperties
        String[] asObjectNames
        Set pbProjectObjectStructureStart to False 
        Set pbProjectObjectStructureEnd   to False
        Set pbRegisterAllObjectsStart     to False    
        Set pbRegisterAllObjectsEnd       to False
        Set pasObjectNames                to asObjectNames
    End_Procedure

    // ToDo: *** HELPER FUNCTIONS ***   

    // Note: It must only be the code part of a source line that is passed here.
    //       Use the Tokenizer helper function first.
    Function _AddExpressionParenthesis String ByRef sLine Returns Boolean
        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
        Boolean bFound bChanged bStartOperators bIfCommand bSecondCommand bWhile
        Integer iPos iPos2
        
        Move sLine to sText    
        Move sLine to sOrg             
        // Do nothing if a Constrain command.
        Get HasCommand sText (CS_Constrain + " ") to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move "" to sStart
        Move "" to sLast                                  
        Get ExpressionExtractor sText CI_LeftExpression to sExpression
        If (Trim(sExpression) = "") Begin
            Get ExpressionExtractor sText CI_OfExpression to sExpression
            If (Trim(sExpression) = "") Begin
                Get ExpressionExtractor sText CI_ToTexpression to sExpression
            End
        End
        If (Trim(sExpression) = "") Begin
            Function_Return False
        End 
        Move (Pos(sExpression, sText)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sLine, (iPos - 1))) to sStart
            If (sStart <> "") Begin
                Move (Replace(sStart, sLine, "")) to sText
                Move (Replace(sExpression, sText, "")) to sLast
            End
        End
//        If (sStart <> "") Begin
//            Move sStart to sLine
//        End                     
        If (sExpression <> "") Begin               
            Move sExpression to sText
            Send StripConcatenatingSpaces (&sExpression)  
            Move (Trim(sExpression)) to sExpression 
            Get HasDoubleExpression sExpression to bFound
            Move (Left(sExpression, 1)) to sChar
            If (sChar <> "(" or bFound = True) Begin
                Move ("(" + sExpression + ")") to sExpression
            End                      
            If (sText = sLine) Begin
                Move sExpression to sLine
            End
        End                                                    
        If (sStart <> "" or sLast <> "") Begin    
            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
        End
        
        Function_Return (sLine <> sOrg)
    End_Function   
                   
    // Helper message for _ClearFirstCompoundBeforeMethod
    Procedure _WipeUntilPosition Integer iPos String ByRef sLine
        Integer iChar
        If (iPos > 0) Begin
            For iChar from 1 to (iPos - 1)
                Move (Overstrike(" ", sLine, iChar)) to sLine
            Loop
        End
    End_Procedure

    // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
    // send/get/set as the first string and that complicates our detection.
    // What this does is simply overwrite everything with spaces before our methods if
    // we have such a compound statement.
    // The variable sLine is not always lowercase.
    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
        Integer iPos
        String  sLtrimLine sOrgLine
        Boolean bChanged
        
        Move sLine to sOrgLine
        Move (Lowercase(LTrim(sLine))) to sLTrimLine
        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
            // A line that starts with an "if" or "else" can still call a method
            Move (Pos("send ", Lowercase(sLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos("get ", Lowercase(sLine))) to iPos
            End
            If (iPos = 0) Begin
                Move (Pos("set ", Lowercase(sLine))) to iPos
            End
            Send _WipeUntilPosition iPos (&sLine)
        End       
        
        Function_Return (sLine <> sOrgLine)
    End_Function
  
    // Helper function to return expressions from a source line;
    //   eExpressionMode can be any of; CI_LeftExpression, CI_OfExpression or CI_ToTexpression.
    // As expressions only expressions in rounded parenthesis "()" are acted upon and returned (Not square brackets)
    Function ExpressionExtractor String sLine Integer eExpressionMode Returns String
        String sExpression sText sChar sStart sLast sCommand 
        String[] asTokens asTokensLower
        Integer iStart iEnd iLength iLeftParantheses iRightParantheses iPos iCount iSize
        Boolean bFound bOperator bParenthesis 
        tOperatorsInfo OperatorsInfo
        tCodeComponents CodeComponents
        
        Get _RemoveEndComment sLine to sText
        Move (Trim(sText)) to sText
        Get _OverstrikeStrings sText to sText
        Move (Pos("(", sText)) to iStart
        Move (Pos(")", sText)) to iEnd 
        Get IsLogicalOperators sText to OperatorsInfo
        If (OperatorsInfo.bIsOperator = False and (iStart < 1 or iEnd < 1) ) Begin
            Function_Return sLine
        End
        
        Move (Trim(sLine)) to sText
//        Get StrSplitToArray sLine " " to asTokens
//        Move (Lowercase(sLine)) to sText
//        Get StrSplitToArray sText " " to asTokensLower
        
        Case Begin
            Case (eExpressionMode = CI_LeftExpression) 
                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Left(sText, (iPos -1))) to sText
                End                                       
                Else Begin
                    Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
                End                                            
                If (iPos > 0) Begin
                    Move (Left(sText, (iPos - 1))) to sText // XXX
                End
                Case Break   
            
            // ToDo: Needs to be finished after changes to the Tokenizer.    
            Case (eExpressionMode = CI_CommandExpression)
                Get Tokenizer sLine to CodeComponents 
                If (Lowercase(CodeComponents.sLeftCommand) = Lowercase(CS_If)) Begin
                    Move (lowercase(sLine) contains (" " + Lowercase(CS_Move) + " ")) to bFound
                    If (bFound) Begin
                        
                    End
                End
                Case Break
            Case (eExpressionMode = CI_OfExpression)
                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText
                    Move (Pos((" " + Lowercase(CS_to) + " "), Lowercase(sText))) to iPos
                    If (iPos > 0) Begin
                        Move (Left(sText, (iPos -1))) to sText
                    End
                    Get IsOperators sText to bOperator
                    Move (sText contains "(" and sText contains ")") to bParenthesis
                    If (bOperator = True or bParenthesis = True) Begin
                        Move (Trim(sText)) to sExpression
                    End
                End
                Else Begin
                    Move "" to sText // Nothing to do.
                End
                Case Break
            Case (eExpressionMode = CI_ToTexpression)
                Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText 
                    Get IsOperators sText to bOperator
                    Move (sText contains "(" and sText contains ")") to bParenthesis
                    If (bOperator = True or bParenthesis = True) Begin
                        Move (Trim(sText)) to sExpression
                    End
                End 
                Else Begin
                    Move "" to sText // Nothing to do.
                End
                Case Break 
            Case Else
                Move "" to sText
        Case End
        
//        Move "" to sExpression  
//        Move 0  to iLeftParantheses
//        Move 0  to iRightParantheses
        If (sText <> "") Begin
//            Move (Pos("(", sText)) to iStart
//            Move (Pos(")", sText)) to iEnd
//            Get IsOperators sText to bOperator
//            If (bOperator = False and (iStart = 0 or iEnd = 0) ) Begin
//                Function_Return ""
//            End 
//
            Get IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Get _ExtractParenthesisExpression sText to sExpression
                If (sExpression = "") Begin
                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to sExpression
                End
            End
//            Move (Length(sText)) to iLength
//            For iCount from iStart to iLength
//                Move (Mid(sText, 1, iCount)) to sChar
//                If (sChar = "(" or sChar = ")") Begin
//                    Add (sChar = "(") to iLeftParantheses
//                    Add (sChar = ")") to iRightParantheses
//                    Move iCount to iPos
//                End                        
//                If (sChar = " " and iLeftParantheses = iRightParantheses) Break
//            Loop
//            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
//            If (sExpression = "" and (bOperator = True) and (iStart <> 1 or iEnd <> 0)) Begin
//                Get _RemoveFirstWord sText to sText
//                Get IsOperators sText to bOperator
//                If (bOperator = True) Begin
//                    Move sText to sExpression 
//                    Move sLine to sText
//                End
//            End
        End
        
        // Check if we have an expression like; "If (psWrkSpcOpenFileName(ghoApplication)) <> "" Send WrkSpcDoForAllFiles"
        //   which in case we need to add "<>" to the sExpression.
        Get _RemoveLeft sExpression (&sText) to bFound
        If (bFound = True) Begin
            Get IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Move (Pos(sExpression, sLine)) to iPos
                If (iPos <> "") Begin        
                    Move (Left(sLine, (iPos - 1))) to sStart
                    Move (Replace(sStart, sLine, "")) to sLine
                    Move (Trim(sText)) to sText 
                    Move (Length(sText)) to iLength    
                    Get _OverstrikeStrings sText to sText
                    Get _FindFirstCommand sText to iPos
                    If (iPos <> 0) Begin
                        Move (Replace(sExpression, sLine, "")) to sLine 
                        Move (Trim(sLine)) to sLine
                        Move (Left(sLine, (iPos -1))) to sStart 
                        Move (Trim(sStart)) to sStart
                        If (sStart <> "") Begin
                            Move (Right(sStart, 1)) to sChar
                            If (sChar <> ")") Begin
                                Move (String(sExpression) * String(sStart)) to sExpression    
                            End
                        End
                    End
                End
            End
        End
        Function_Return sExpression
    End_Function

    // Rturns the first expression that exist in the passed sText string and that is within parenthesis,
    // else it returns a blank string.
    Function _ExtractParenthesisExpression String sText Returns String
        String sExpression sChar
        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
        tOperatorsInfo OperatorInfo
        
        Move "" to sExpression
        Move 0  to iLeftParantheses
        Move 0  to iRightParantheses
        
        If (sText <> "") Begin
            Move (Pos("(", sText)) to iStart
            Move (RightPos(")", sText)) to iEnd
            Get IsLogicalOperators sText to OperatorInfo
            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
                Function_Return ""
            End 

            Move (Length(sText)) to iLength
            For iCount from iStart to iLength
                Move (Mid(sText, 1, iCount)) to sChar
                If (sChar = "(" or sChar = ")") Begin
                    Add (sChar = "(") to iLeftParantheses
                    Add (sChar = ")") to iRightParantheses
                    Move iCount to iPos
                End                        
                If (iLeftParantheses = iRightParantheses) Break
            Loop
            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
        End
        Function_Return sExpression
    End_Function

    Function _ExtractExpressionNoParenthesis String sLine tOperatorsInfo OperatorsInfo Returns String
        String sText sExpression sChar sFirst sLast sLeft sRight
        Integer iCount iLength iSize iStart iEnd iPos
        Boolean bStop bSpace bParanthesis
        
        // ToDo: Is this really correct in all cases?
        If (OperatorsInfo.bIsOperator = False) Begin
            Function_Return ""
        End
        Move "" to sExpression  
//        Move (Pos(Lowercase(" " + CS_As + " "), sLine)) to iPos 
//        If (iPos <> 0) Begin
//            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sText    
//        End
//        Else Begin
            Move (OperatorsInfo.iPos - Length(OperatorsInfo.sOperator)) to iStart
            Move (Left(sLine, (iStart + 1))) to sText
//        End
        Send StripConcatenatingSpaces (&sText)
        Get _OverstrikeStrings (&sText) to sText
        Move (Length(sText)) to iLength   
        Move (Pos(Lowercase(" " + CS_As + " "), sText)) to iPos 
        If (iPos <> 0) Begin
            Move (Mid(sText, Length(sText), (iPos + 3))) to sText    
        End
        
        // First get the left part of the expression:
        Move iLength to iStart
        Move 0 to iCount
        Move False to bSpace
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sText, 1, (iStart - iCount))) to sChar
            If (bParanthesis = True) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar <> " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
        Move (Left(sText, (iStart - iCount + 1))) to sFirst  
        Move (Replace(sFirst, sText, "")) to sLeft
        If (sLeft = "") Begin
            Move sText to sLeft
        End
        Move (Length(sLine)) to iLength   
        
        // Then get the right part of the expression:
        Move 1 to iCount   
        Move False to bSpace
        Move (OperatorsInfo.iPos) to iStart
        Move (Mid(sLine, iLength, (iStart + 1))) to sText  
        Move (Length(sText)) to iLength
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sLine, 1, (iStart + iCount))) to sChar
            If (bParanthesis = False) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar = " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
                                                     
        Move (Left(sText, (iCount - 1))) to sRight
        Move (String(sLeft) * String(sRight)) to sExpression
        
        Function_Return (Trim(sExpression))
    End_Function

    // Syntax:
    //    Get Tokenizer sTest to "tCodeComponents"
    // Breaks up a source line into these tokens;
    //     tCodeComponents
    //  a) sIndentation = spaces or tab-characters to the left (start) of the source code line
    //  b) sLineStartIndicator = [Found] or other indicators within brackets placed at beginning of line.   
    //  c) sLeftCommand = "Move, Calc" etc. 
    // ToDo: Should we add a Second left command param???
    //  d) sCode = the source code itself (or left hand side code if a "of" or "to" or right comment)
    //  e) sOfStatement = " of xxx"
    //  f) sToStatement = " to xxx" 
    //  g) sRightComment = any comment placed at the end of the line.
    //
    // It does not Rtrim the end-of-line comment.  Should it??
    // Note: If the line is a compound statement (one that spans over several lines),
    //       aka it contains a ";", the function will NOT try to break up the source code line.
    //       Instead it returns a struct with empty members, except for the 
    //       bHasEndSemiColon member that will be true.
    Function Tokenizer String sLine Returns tCodeComponents
        tCodeComponents LineComponents
        String sText sChar sCommand
        Boolean bEndComment bStop bOfStatement bToStatement bIndicator bFound bMoveCommand
        Integer iPos iStart iEnd
                                                
        Move "" to LineComponents.sIndentation
        Move "" to LineComponents.sLineStartIndicator  
        Move "" to LineComponents.sLeftCommand
        Move "" to LineComponents.sCode
        Move "" to LineComponents.sOfStatement
        Move "" to LineComponents.sToStatement
        Move "" to LineComponents.sRightComment
        Move False to LineComponents.bHasEndSemiColon
        
        Get IsCommentLineOrBlank sLine to bStop
        If (bStop = True) Begin
            Function_Return LineComponents
        End  
        
        Get IsLineEndSemiColon sLine to bStop
        If (bStop = True) Begin
            Move True to LineComponents.bHasEndSemiColon
            Function_Return LineComponents
        End  
        
        // Get the indentation part
        Move (Ltrim(sLine)) to sText
        If (sText <> sLine) Begin
            Move (Replace(sText, sLine, "")) to LineComponents.sIndentation
            Move (Replace(LineComponents.sIndentation, sLine, "")) to sLine
        End     
        
        Get IsKeywordInLine (CS_Indicate + "|") sLine to bFound
        If (bFound = True) Begin
            Move True to LineComponents.bHasIndicateCommand
        End                                                
        
        Get IsIndicatorStatement sLine to bIndicator
        If (bIndicator = True) Begin
            // Get the start indicator part
            Move (Ltrim(sLine)) to sText
            Move (Left(sText, 1)) to sChar
            If (sChar = "[") Begin
                Move (Pos("]", sText)) to iPos
                Move (Left(sText, (iPos -1))) to LineComponents.sLineStartIndicator
                Move (Left(LineComponents.sLineStartIndicator, 1)) to sChar
                If (sChar = "[") Begin
                    Move (Replace("[", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
                End
                Move (Right(LineComponents.sLineStartIndicator, 1)) to sChar
                If (sChar = "]") Begin
                    Move (Replace("]", LineComponents.sLineStartIndicator, "")) to LineComponents.sLineStartIndicator
                End
            End
            
            // Get the End indicator part
            Move (Trim(sLine)) to sText    
            Get _RemoveEndComment sText to sText
            Move (Right(sText, 1)) to sChar
            If (sChar = "]") Begin  
                Move (Pos(Lowercase(" to "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 4))) to sText
                End
                // We need to check that this isn't an array/struct value.
                Move (Pos(" [", sText)) to iStart
                If (iStart > 0) Begin
                    Move (Pos("]", sText)) to iEnd
                    Move (Mid(sText, Length(sText), (iStart +1))) to LineComponents.sLineEndIndicator
                    Move (Left(LineComponents.sLineEndIndicator, 1)) to sChar
                    If (sChar = "[") Begin
                        Move (Replace("[", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
                    End
                    Move (Right(LineComponents.sLineEndIndicator, 1)) to sChar
                    If (sChar = "]") Begin
                        Move (Replace("]", LineComponents.sLineEndIndicator, "")) to LineComponents.sLineEndIndicator
                    End
                End
            End
        End

        Get IsMoveCommand sText to bMoveCommand
        If (bMoveCommand = True) Begin
            Move (Pos(" ", sText)) to iPos
            Move (Left(sText, (iPos - 1))) to sCommand
            Move sCommand to LineComponents.sLeftCommand
        End                                             
        
        // Get the end comment part
        Move sLine to sText
        Get _RemoveComments (&sText) to bEndComment
        If (bEndComment = True) Begin
            Move (Replace(sText, sLine, "")) to LineComponents.sRightComment
            Move (Replace(LineComponents.sRightComment, sLine, "")) to sLine
        End     
        
        // Get the " to " part
        Move (Lowercase(sLine)) to sText
        Move (sText contains (" " + Lowercase(CS_To) + " ")) to bToStatement
        If (bToStatement = True) Begin
            Move (Pos((" " + Lowercase(CS_To) + " "), sText)) to iPos
            Move (Mid(sLine, Length(sLine), (iPos +1))) to LineComponents.sToStatement
            Move (Replace(LineComponents.sToStatement, sLine, "")) to sLine
            Move (Replace((CS_To) + " ", LineComponents.sToStatement, "")) to LineComponents.sToStatement
            Move (Trim(LineComponents.sToStatement)) to LineComponents.sToStatement
        End
        
        // Get the " of xxxx " part
        Move (Lowercase(sLine)) to sText
        Move (sText contains (" " + Lowercase(CS_Of) + " ")) to bOfStatement
        If (bOfStatement = True) Begin
            Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sLine))) to iPos
            Move (Mid(sLine, (Length(sLine) -1), (iPos + Length(CS_Of) + 1))) to LineComponents.sOfStatement
            Move (Left(sLine, (iPos - 1))) to sLine
            Move (Trim(LineComponents.sOfStatement)) to LineComponents.sOfStatement
        End    
        
        // The reminder of the code line
        Move (Trim(sLine)) to LineComponents.sCode
                                      
        Function_Return LineComponents
    End_Function       
    
    // Helper function.
    Function _BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
        Boolean bChanged
        Integer iPos
        String  sLineIndent
        String  sIndent
        String  sLine1 sLine2
        String  sText

        Move False to bChanged
        Move (Lowercase(sLine)) to sText
        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
        Move (Repeat(" ", iLineIndent)) to sLineIndent
        Get _OverstrikeStrings sText to sText
        Get _FindFirstCommand sText to iPos
        If (iPos <> 0) Begin
            Move True to bChanged
            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitBySemiColumn) Begin
                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitByBeginEnd) Begin
                Move (Insert((" Begin" + CS_CRLF + sLineIndent + sIndent), sLine, iPos)) to sLine
                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
            End

            // Remove any spaces before the point on which we break the line
            Move (Left(sLine, iPos - 1)) to sLine1
            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
            Move (RTrim(sLine1)) to sLine1
            Move (sLine1 + sLine2) to sLine
        End
        Function_Return bChanged
    End_Function

    // Takes a string like: [not Seqeof] Begin
    // and returns struct as: True, True, "(not(Seqeof))" and "Begin",
    //   _but_ it doesn't do anything with a line that starts with a [Select] stetement;
    //   "[Select] Indicate Select as Windowindex Eq Fieldindex"
    // Note: The brackets _must_ be at the start of code line.
    //       bHasBracket denotes that the line starts with a "[", bHasNot denotes that the expression has a "not" in it.
    Function _ExtractIndicatorContent String sLine Returns tBooleanIndicator
        Integer iPos                                             
        String sText sChar sNot sBoolean sFirstWord sCommand sExpression
        Boolean bRightSideIndicator bFound bIndicateWord
        tBooleanIndicator BooleanIndicator  
        tOperatorsInfo OperatorsInfo
        
        Move False to BooleanIndicator.bHasBracket
        Move False to BooleanIndicator.bHasNot
        Move ""    to BooleanIndicator.sCode
        Move ""    to BooleanIndicator.sExpression
        
        Get IsIndicatorStatement sLine to bFound
        Move (Lowercase(sLine) contains Lowercase(CS_Indicate)) to bIndicateWord
        If (bFound = False and bIndicateWord = False) Begin
            Function_Return BooleanIndicator
        End
        Move (Trim(sLine)) to sText 
        Get _OverstrikeStrings sText to sText
        Move (sText contains "[" and sText contains "]") to BooleanIndicator.bHasBracket  
        
        Move "" to sNot
        Get _RetrieveFirstWord sText to sFirstWord
        // Is the indicator placed on the right hand side of the command?
        Move (Pos("[", sFirstWord) = 0) to bRightSideIndicator
        If (bRightSideIndicator = True) Begin
            Move (Pos("[", sText)) to iPos
            Move (Mid(sText, Length(sText), iPos)) to sBoolean
        End
        Else Begin
            Move (Pos("]", sText)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sText, iPos)) to sBoolean 
                Move (Mid(sText, Length(sText), (iPos + 1))) to sFirstWord
                Move sFirstWord to BooleanIndicator.sCode
            End
        End
        Move (Trim(sFirstWord)) to sCommand
        Move (Replaces("[", sBoolean, "")) to sBoolean
        Move (Replaces("]", sBoolean, "")) to sBoolean
        Move (Trim(sBoolean)) to sBoolean

        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sBoolean, Length(sBoolean), (iPos + 4))) to sBoolean
            Move (String(CS_Not)) to sNot
        End                    
        If (sNot <> "") Begin
            Move ("(" + String(sBoolean) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression 
            Move True to BooleanIndicator.bHasNot
        End 
        Else If (Lowercase(sBoolean) = Lowercase(CS_Finderr)) Begin
            Move ("(" + CS_Found * " = " * CS_False + ")") to BooleanIndicator.sExpression
        End
        Else Begin                
            Get IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Get _ExtractParenthesisExpression sText to BooleanIndicator.sExpression
                If (BooleanIndicator.sExpression = "") Begin
                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to BooleanIndicator.sExpression
                End
//                Move True to BooleanIndicator.bHasNot 
                Move sLine to sCommand
            End
            Else Begin
                Move ("(" + String(sBoolean) + ")") to BooleanIndicator.sExpression
                Move False to BooleanIndicator.bHasNot
            End
        End
        Move (Trim(sCommand)) to BooleanIndicator.sCode
            
        Function_Return BooleanIndicator
    End_Function
    
    // Tries to find the first DataFlex command found in the passed string.
    // Returns the starting pos of that same command (or 0 if not found).
    Function _FindFirstCommand String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommands

        Move 0 to iPos
        Move (" " + sTest) to sTest
        Get _RemoveComments (&sTest) to bRemoved
        Get paCommands to asCommands
        Move (SizeOfArray(asCommands)) to iSize
        If (iSize = 0) Begin
            Send AddAllCommands
            Get paCommands to asCommands
            Move (SizeOfArray(asCommands)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommands[iCount] to sCommand
            Move (Pos(" " + Lowercase(sCommand), Lowercase(sTest))) to iTest // The command MUST start with a space and MIGHT end with a space.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop              
        // We added a beginning " " at the top of this function, so adjust for that now.
//        If (iPos = 1) Begin
//            Move 0 to iPos
//        End
        Function_Return iPos
    End_Function
    
    // Parses the method name from the string
    Function _MethodName String sMethod Returns String
        Integer iPos
        Get _RemoveFirstWord sMethod to sMethod
        Move (Right(sMethod, (Length(sMethod) - iPos))) to sMethod
        If (Uppercase(Left(Trim(sMethod), 4)) = "SET ") Begin
            Get _RemoveFirstWord sMethod to sMethod
        End
        // Remove any trailing arguments
        Move (Pos(" ", sMethod)) to iPos
        Function_Return (Left(sMethod, (iPos - 1)))
    End_Function

    // For declarations like "string [] saAddress"
    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
        Boolean bChanged
        String sText
        Move sLine to sText
        While (Pos(" [", sText) > 0)
          Move (Replace(" [", sText, "[")) to sText
        Loop                                       
        Move (sLine = sText) to bChanged
        Function_Return bChanged
    End_Function

    //  This will pad out the strings in a line and overstrike them
    //  with _ characters for a "string" and + characters for a 'string'
    Function _OverstrikeStrings String sLine Returns String
        Boolean bDoubleQuote bSingleQuote bChanged
        Integer iChar iLength
        String  sChar sText

        Move False to bChanged 
        Move sLine to sText
        Move (Length(sText)) to iLength
        For iChar from 1 to iLength
            Move (Mid(sText, 1, iChar)) to sChar
            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
                Move True to bChanged
                Move " " to sChar
            End
            If (bDoubleQuote and sChar= '"') Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bDoubleQuote
            End
            If (bSingleQuote and sChar = "'") Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bSingleQuote
            End
            If (bSingleQuote = False and sChar ='"') Begin
                Move True to bDoubleQuote
            End
            If (bDoubleQuote = False and sChar = "'") Begin
                Move True to bSingleQuote
            End
            If bDoubleQuote Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
            End
            Else If bSingleQuote Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
            End
        Loop

        If (bChanged = True) Begin
            Move sText to sLine
        End
        Function_Return sLine
    End_Function

    Function _RemoveComments String ByRef sLine Returns Boolean
        Boolean bRemoved
        Integer iPos

        Move False to bRemoved
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, iPos - 1)) to sLine
            Move True to bRemoved
        End
        Function_Return bRemoved
    End_Function    

    // Returns an end comment if exists. It also removes the end comment
    // from the passed string.
    Function _RemoveEndComment String sLine Returns String
        Integer iPos
        String sTest

        Move (Trim(sLine)) to sTest
        Move (Pos(CS_CommentSymbol, sTest)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (Pos(CS_CommentSymbol, sLine)) to iPos
            Move (Left(sLine, iPos - 1)) to sLine
        End
        Function_Return sLine
    End_Function

    // Removes the first word of any input string
    // all up to the first space encountered
    Function _RemoveFirstWord String sLine Returns String
        Integer iPos
        Boolean bChanged
        Move (Trim(sLine)) to sLine
        Get _NormalizeArrayNotation (&sLine) to bChanged
        Move (Pos(" ", sLine)) to iPos
        Function_Return (Right(sLine, (Length(sLine) - iPos)))
    End_Function

    // Returns the first word of any input string
    // all up to the first space encountered
    Function _RetrieveFirstWord String sLine Returns String
        String sFirstWord
        Boolean bChanged
        Get _RemoveFirstWord sLine            to sFirstWord
        Move (Replace(sFirstWord, sLine, "")) to sFirstWord
        Move (Trim(sFirstWord))               to sFirstWord
        Get _NormalizeArrayNotation (&sFirstWord) to bChanged
        Function_Return sFirstWord
    End_Function

    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
    // RemoveLeft("D", "ABC")                   -> "ABC"
    // RemoveLeft("is ", "This is an example")  -> "an example"    
    // Note: It it also looks within strings aka "This is a string"
    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
        Integer iPosStart iPosEnd 
        String sText
        
        Move sHostString to sText
        Move (Pos(sSubString, sText)) to iPosStart
        Move (iPosStart + Length(sSubString) - 1) to iPosEnd

        If (iPosStart) Begin                                
            If (iPosEnd = Length(sText)) Begin
                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
            End 
            Else Begin
                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
            End
        End                                              
        
        Function_Return (sHostString <> sText)
    End_Function

    // Helper function
    Function _RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
        Boolean bChanged
        String sText
        Integer iPos

        Move False to bChanged
        Move (LTrim(sLine))     to sText
        Move (Left(sText, 9))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = "property ") Begin
            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
            If (iPos = 0) Begin // if there's a tab char instead of a space then..
                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
            End
            If (iPos > 0) Begin
                Move (Overstrike(Repeat(" ", Length(sPubPriv)), sLine, iPos + 1)) to sLine // skip first character, don't overwrite a tab with a space
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // helper function for IsKeywordInLine, when a keyword is found in a string declaration
    Function _RemoveStringsFromLine String sLine Returns String
        Integer iLength iPos
        Boolean bSep1 bSep2
        String  sChar sSep1 sSep2 sReturn

        Move False to bSep1
        Move False to bSep2
        Move "'" to sSep1
        Move '"' to sSep2
        Move ""  to sReturn
        Move (Length(sLine)) to iLength

        For iPos from 1 to iLength
            Move (Mid(sLine, 1, iPos)) to sChar
            If (bSep1 = False and bSep2 = False) Begin
                If (sChar = sSep1) Begin
                    Move True to bSep1
                End
                Else If (sChar = sSep2) Begin
                    Move True to bSep2
                End
                If (bSep1 = False and bSep2 = False) Begin
                    Move (sReturn + sChar) to sReturn
                End
            End
            Else Begin
                If (bSep1) Begin
                    If (sChar = sSep1) Begin
                        Move False to bSep1
                    End
                End
                Else If (bSep2) Begin
                    If (sChar = sSep2) Begin
                        Move False to bSep2
                    End
                End
            End
        Loop

        Function_Return sReturn
    End_Function

    Function _SingleCommandSyntaxToFunction String ByRef sLine String sKeyWord Returns Boolean
        Boolean bChanged bIsCommentOrBlank bFound bIfStatement bIsFirstKeyWord
        tCodeComponents CodeComponents
        String sText sLowerKeyWord sLowerCase sFirstWord sExpression
        Integer iPos
        
        Move False to bChanged
        Move False to bIsFirstKeyWord  
        Move "" to sExpression
        Move sLine to sText
        Get IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End      
        
        Get HasCommand sText sKeyWord to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Get IsIfCommand sText to bIfStatement
        Move (Lowercase(sKeyWord)) to sLowerKeyWord
        If (bIfStatement = False) Begin
            Get _RetrieveFirstWord sText to sFirstWord
            If (Lowercase(sFirstWord) = Lowercase(sKeyWord)) Begin
                Get _RemoveFirstWord sText to sText
            End    
//            If (Lowercase(sFirstWord) <> sLowerKeyWord) Begin
//                Function_Return False
//            End
        End
        If (bIfStatement = True) Begin
            Get ExpressionExtractor sText CI_LeftExpression to sExpression  
            If (Trim(sExpression) <> "") Begin
                Move (Pos(sExpression, sText)) to iPos
                Move (Mid(sText, Length(sText), (iPos + Length(sExpression)))) to sText
                Move (Mid(sLine, Length(sLine), (iPos + Length(sExpression)))) to sLine
            End
            // Do we still have the keyword in the line?
            Get HasCommand sText sKeyWord to bFound
            If (bFound = False) Begin   
                Move (String(sExpression) + String(sLine)) to sLine 
                If (bIfStatement = True) Begin
                    Move (CS_If * String(sLine)) to sLine
                End
                Function_Return False
            End
        End
        
//        Move (Pos(sLowerKeyWord, Lowercase(sText))) to iPos
        Move sLine to sText
        Get Tokenizer sText to CodeComponents
        
        // If the line starts with the Key word.
//        If (Pos(sLowerKeyWord, Lowercase(CodeComponents.sCode)) = 1) Begin
//            Move (sLowerKeyWord + " ") to sLowerKeyWord
//        End                                  
//        Else Begin
//            Move (" " + String(sLowerKeyWord) + " ") to sLowerKeyWord
//        End
//        Move (Lowercase(CodeComponents.sCode) contains sLowerKeyWord) to bFound
        Get _RetrieveFirstWord sText to sFirstWord
        Move (Lowercase(sFirstWord) = Lowercase(sKeyWord)) to bFound
        If (bFound = False) Begin      
//            If (sExpression <> "") Begin
//                Move (CS_If * String(sExpression) + String(sLine)) to sLine
//            End
            Function_Return False
        End
        
        Move (Lowercase(CodeComponents.sCode)) to sText
        Move (Mid(CodeComponents.sCode, (Length(CodeComponents.sCode)), (Length(sKeyWord) + 1))) to sText
        Move (Ltrim(sText)) to sText   
        If (sKeyWord = CS_Pos) Begin
            Move (Lowercase(sText)) to sLowerCase
            Move (Pos(" in ", sLowerCase)) to iPos
            If (iPos <> 0) Begin
                Move (Overstrike("____", sText, iPos)) to sText
                Move (Replace("____", sText, ", ")) to sText
                Move True to bChanged
            End
        End                                                                                                                              
        If (Length(CodeComponents.sRightComment)  > 0) Begin
            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement) * String(CodeComponents.sRightComment)) to sLine
            Move True to bChanged
        End
        Else Begin
            Move (CodeComponents.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(CodeComponents.sToStatement)) to sLine
            Move True to bChanged
        End
        
        Function_Return bChanged
    End_Function

    // Helper function. This is a list of commands that also exists as global build in functions.
    Function _TestCommandFunctions String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommandFunctions

        Move 0 to iPos
        Get _RemoveComments (&sTest) to bRemoved
        Get paCommandFunctions to asCommandFunctions
        Move (SizeOfArray(asCommandFunctions)) to iSize
        If (iSize = 0) Begin
            Send AddAllCommandFunctions
            Get paCommandFunctions to asCommandFunctions
            Move (SizeOfArray(asCommandFunctions)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommandFunctions[iCount] to sCommand
            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop

        Function_Return iPos
    End_Function

    Function HasDoubleExpression String sLine Returns Boolean
        Boolean bFound      
        Integer iCount iSize iOpCount iParanthesis
        String sChar sOperators
        
        Move False to bFound  
        Move 0 to iParanthesis           
        Move "<=>" to sOperators
        Move (Length(sLine)) to iSize
        For iCount from 1 to iSize
            Move (Mid(sLine, 1, iCount)) to sChar
            If (sChar = "(") Begin
                Increment iOpCount          
                Increment iParanthesis
            End
            If (sChar = ")") Begin
                Decrement iOpCount
            End
            If (iParanthesis <> 0 and sOperators contains sChar) Begin
                If (iOpCount = 0) Begin
                    Move True to bFound
                    Move iSize to iCount // We're done.
                End
            End
        Loop
        
        Function_Return bFound
    End_Function
    
    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
    Function HasCommand String sLine String sCommand Returns Boolean
        Boolean bFound bOk
        String sText
        
        Move False to bFound 
        Move sLine to sText
        Get _RemoveComments (&sText) to bOK
//        Move (Trim(sText)) to sText
        Get _OverstrikeStrings sText to sText
        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound
        
        Function_Return bFound
    End_Function
    
    // Returns True iif the source line contains a "Begin" statement.
    Function IsBeginStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Begin) to bFound
        Function_Return bFound
    End_Function   
    
    Function IsBlankLine String sLine Returns Boolean
        Boolean bIsBlank
        
        Move False to bIsBlank
        Move (Trim(sLine)) to sLine
        If (Length(sLine) = 0) Begin
            Move True to bIsBlank
        End
        
        Function_Return bIsBlank        
    End_Function
    
    Function IsCommentLine String sLine Returns Boolean
        Boolean bIsComment
        Integer iPos
        
        Move False to bIsComment
//        Move (Trim(sLine)) to sLine
//        Move (Pos(CS_CommentSymbol, sLine)) to iPos
//        If (iPos = 1) Begin
//            Move True to bIsComment
//        End
        // Replaces all quotes string contents to "_" so we don't get false positives.
        Get _OverstrikeStrings sLine to sLine
        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment
        
        Function_Return bIsComment
    End_Function

    // Returns True if this is a comment line with "//" to the left,
    // or if the line is blank.
    Function IsCommentLineOrBlank String sLine Returns Boolean
        Boolean bIsComment bIsBlank
        
        Get IsCommentLine sLine to bIsComment
        Get IsBlankLine sLine to bIsBlank
        
        Function_Return (bIsComment = True or bIsBlank = True)
    End_Function

    // Returns False if the first line in the passed file is _not_ an automatically generated
    // COM wrapper file created by the Studio.
    // If it returns True, we should not process that file.
    Function IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
        Boolean bIsDFCOMProxyClasses bExists        
        Integer iCh iPos
        String sLine
        
        Move False to bIsDFCOMProxyClasses  
        File_Exist sFileName bExists
        If (bExists = False) Begin
            Error ("The file doesn't exist:" * String(sFileName))
            Function_Return False
        End
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error "No Channel Available for Process: Procedure 'IsDataFlexCOMProxyClassesFile'"
            Function_Return False
        End
        
        Direct_Input channel iCh sFileName
        Readln channel iCh sLine
        Close_Input channel ich
        Send Seq_Release_Channel iCh
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End

        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses
        
        Function_Return bIsDFCOMProxyClasses
    End_Function
    
    // Returns True iif the source line starts with the sCommand statement.
    Function IsFirstWord String sLine String sCommand Returns Boolean
        Boolean bFound
        Integer iPos  
        String sFirstWord
        
        Move (Ltrim(Lowercase(sLine))) to sLine
        Move (Ltrim(Lowercase(sCommand))) to sCommand
        If (sLine = sCommand) Begin
            Function_Return True
        End
        Move (sCommand + " ") to sCommand
        Move (Pos(" ", sLine)) to iPos
        Move (Left(sLine, iPos)) to sFirstWord
        Move (sFirstWord = sCommand) to bFound
        Function_Return bFound
    End_Function   
    
    // Returns True if source line contains a "[Found]", or "[FindErr]".
    Function IsFoundOrFindErrIndicator String sLine Returns Boolean
        Boolean bFound
        Integer iLeft iRight iPos
        String sText
        
        Get IsIndicatorStatement sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get _RemoveComments (&sLine) to bFound
        Get _OverstrikeStrings sLine to sText  
        Send StripConcatenatingSpaces (&sText) sLine
        Move (Pos("[", sLine)) to iLeft
        Move (Pos("]", sLine)) to iRight
        Move (Pos(("[" + Lowercase(CS_Found)), sLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos(("[" + Lowercase(CS_Finderr)), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Finderr) + "]"), sLine)) to iPos
        End
            
        Function_Return (iPos <> 0)    
    End_Function
    
    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
    // Note: The source line must first have been stripped of any comments
    Function IsIfBeginStatement String sLine Returns Boolean
        Boolean bisIfBegin bIsBeginStatement 
        Get IsIfCommand sLine to bisIfBegin
        Get IsBeginStatement sLine to bIsBeginStatement
        Function_Return (bisIfBegin = True and bIsBeginStatement = True)
    End_Function   
    
    Function IsIfCommand String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (CS_If + " ") to bFound
        Function_Return bFound
    End_Function                                                  
    
    Function IsImagePageStartOrEnd String sLine Boolean bCheckImageStart Returns Boolean
        Boolean bFound
        Integer iPos

        Move False to bFound
        Move (Trim(sLine)) to sLine
        If (bCheckImageStart = True) Begin
            Get IsImageStart sLine to bFound
        End
        Else Begin
            Move (Pos(CS_ImageNameEnd, sLine)) to iPos
            If (iPos = 1) Begin
                Move True to bFound
            End
        End

        Function_Return bFound
    End_Function

    Function IsImageStart String sLine Returns Boolean
        Boolean bIsChar
        Integer iPos
        String sChar

        Move False to bIsChar
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_ImageNameStart, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Mid(sLine, 1, 2)) to sChar
            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsChar
        End

        Function_Return bIsChar
    End_Function

    // Returns True if source code contains both a "[" and a "]", but not a "[]"
    Function IsIndicatorStatement String sLine Returns Boolean
        Boolean bFound bIndicatorWord
        Integer iLeft iRight iPos
        String sChar sLeftBracket
        
        Get IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sLine) to bFound
        Get _OverstrikeStrings sLine to sLine
        Move (Left(sLine, 1)) to sChar
        If (sChar = "[") Begin
            Move "[" to sLeftBracket
        End                         
        Else Begin
            Move " [" to sLeftBracket
        End
//        Move (Lowercase(sLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
        Move (bIndicatorWord = True or (sLine contains sLeftBracket and sLine contains "]")) to bFound
        If (bFound = True) Begin
            Move (Pos(sLeftBracket, sLine)) to iLeft
            Move (Pos("]", sLine)) to iRight
            Move ((iRight - iLeft) > 1) to bFound
        End
        Function_Return (bIndicatorWord or bFound)
    End_Function

    // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
    Function IsKeywordInLine String sKeywords String sLine Returns Boolean
        String sKeyword sChar  
        Integer iPos   
        Boolean bOK

        Move (Lowercase(sKeywords)) to sKeywords
        Move (Lowercase(sLine)) to sLine
        Get _RemoveStringsFromLine sLine to sLine
        Move (Pos(" ", sLine)) to iPos
        // Then there is only one "word" in sLine. Check if the sKeywords = sLine
        If (iPos = 0) Begin
            Move (Replace("|", sKeywords, "")) to sKeyword
            If (Trim(sKeyword) = Trim(sLine)) Begin
                Function_Return True
            End
        End
        
        While (sKeywords <> "")
            Move (Left(sKeywords, (Pos("|", sKeywords)))) to sKeyword
            Move (Replace(sKeyword, sKeywords, "")) to sKeywords
            Move (Trim(Replace("|", sKeyword, ""))) to sKeyword
            Move ((sKeyword <> "") and ((Pos((" " + sKeyword + " "), sLine)) <> 0)) to bOK
            If (bOK = False) Begin
                Move ((sKeyword <> "") and ((Pos((sKeyword + " "), sLine)) <> 0) ) to bOK
            End
            // Also check if this might be the very first statement on the sLine 
            If (bOK = True) Begin    
                Move (Left(sKeyword, 1)) to sChar
                // Is this a command?
                If (sChar = "#") Begin
                    Function_Return False
                End
                Else Begin
                    Function_Return True
                End
            End
        Loop
        Function_Return False
    End_Function

    Function IsMethodStart String sLine Returns Boolean
        Boolean bMethodStart

        Get _OverstrikeStrings sLine to sLine
        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 10) = "procedure " or Left(sLine, 9) = "function ") to bMethodStart

        Function_Return bMethodStart
    End_Function

    Function IsMethodEnd String sLine Returns Boolean
        Boolean bMethodEnd

        Get _OverstrikeStrings sLine to sLine
        Get _RemoveEndComment  sLine to sLine
        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 14) = "end_procedure " or Left(sLine, 13) = "end_function ") to bMethodEnd

        Function_Return bMethodEnd
    End_Function

    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>" 
    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator. 
    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
    Function IsLogicalOperators String sLine Returns tOperatorsInfo
        Boolean bHas 
        tOperatorsInfo OperatorsInfo
        
        Get IsCommentLineOrBlank sLine to bHas
        If (bHas = True) Begin
            Function_Return OperatorsInfo
        End
        Get _RemoveComments (&sLine) to bHas
        Get _OverstrikeStrings sLine to sLine 
        Move (Lowercase(sLine)) to sLine

        Case Begin                
            // "Legacy" operators;
            Case (sLine contains " gt ")
                Move (Pos(" gt ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "gt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " ge ")
                Move (Pos(" ge ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ge"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " lt ")
                Move (Pos(" lt ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "lt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " le ")
                Move (Pos(" le ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "le"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " eq ")
                Move (Pos(" eq ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "eq"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " ne ")
                Move (Pos(" ne ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ne"                   to OperatorsInfo.sOperator
                Case Break
            
            // "Modern" operators;
            Case (sLine contains ">")
                Move (Pos(">", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">"                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains ">=")
                Move (Pos(">=", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">="                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<")
                Move (Pos("<", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<"                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<=")
                Move (Pos("<=", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<="                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "=")
                Move (Pos("=", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "="                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<>")
                Move (Pos("<>", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<>"                   to OperatorsInfo.sOperator
                Case Break
            Case Else
                Move -1                     to OperatorsInfo.iPos
                Move False                  to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ""                     to OperatorsInfo.sOperator
        Case End
                
        Function_Return OperatorsInfo
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
    Function IsLegacyOperators String sLine Returns Boolean
        Boolean bHas bFound
        
        Get IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sLine) to bHas
        Get _OverstrikeStrings sLine to sLine 
        Move (Lowercase(sLine)) to sLine

        Case Begin
            Case (sLine contains " gt ")
                Move True to bHas
                Case Break
            Case (sLine contains " ge ")
                Move True to bHas
                Case Break
            Case (sLine contains " lt ")
                Move True to bHas
                Case Break
            Case (sLine contains " le ")
                Move True to bHas
                Case Break
            Case (sLine contains " eq ")
                Move True to bHas
                Case Break
            Case (sLine contains " ne ")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
    Function IsOperators String sLine Returns Boolean
        Boolean bHas
        
        Get _RemoveComments (&sLine) to bHas 
        Get _OverstrikeStrings sLine to sLine

        Case Begin
            Case (sLine contains ">")
                Move True to bHas
                Case Break
            Case (sLine contains ">=")
                Move True to bHas
                Case Break
            Case (sLine contains "<")
                Move True to bHas
                Case Break
            Case (sLine contains "<=")
                Move True to bHas
                Case Break
            Case (sLine contains "=")
                Move True to bHas
                Case Break
            Case (sLine contains "<>")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    Function IsLineEndSemiColon String sLine Returns Boolean
        Boolean bRemoved
        String  sText
        
        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
        Get _RemoveComments (&sLine) to bRemoved
        Move (RTrim(sLine)) to sText
        If (Right(sText, 1) = ";") Begin
            Function_Return True
        End
        Function_Return False
    End_Function

    Function IsLineEndSemiColonOrBegin String sLine Returns Boolean
        Boolean bRemoved
        Boolean bStop
        String  sTest
        
        Move False to bStop
        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???)
        Get _RemoveComments (&sLine) to bRemoved
        Move (RTrim(sLine)) to sTest
        If (Right(sTest, 1) = ";") Begin
            Move True to bStop
        End
        If (bStop = False) Begin
            Move (Lowercase(sTest)) to sTest
            If (Right(sTest, 5) = "begin") Begin
                Move True to bStop
            End
        End
        Function_Return bStop
    End_Function    
    
    // Returns True iif the source line is a "Loop" statement.
    Function IsLoopStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Loop) to bFound
        Function_Return bFound
    End_Function   

    Function IsMoveCommand String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + String(CS_Move) + " ") to bFound
        If (bFound = False) Begin
            Get HasCommand sLine (String(CS_Move) + " ") to bFound
        End
        Function_Return bFound
    End_Function                                                  
    
    // Returns True iif the source line is a "Until" statement.
    Function IsUntilStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Until) to bFound
        If (bFound = False) Begin
            Get HasCommand sLine (CS_Until + " ") to bFound
            If (bFound = False) Begin
                Get HasCommand sLine (CS_Until) to bFound
            End
        End  
            
        Function_Return bFound
    End_Function   

    Function IsVariableDeclarationLine String sLine Returns Boolean
        Boolean bVariableDeclaration
        String[] asLocalVariableTypes asLocalVariableArrayTypes
        Integer iRetval
        String sFirstWord

        Move False to bVariableDeclaration
        Get pasLocalVariableTypes      to asLocalVariableTypes
        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
        Move (Trim(sLine)) to sLine
        Get _RetrieveFirstWord sLine to sFirstWord
        Move (Uppercase(sFirstWord)) to sFirstWord
        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
        If (iRetval <> -1) Begin
            Move True to bVariableDeclaration
        End
        Else Begin
            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
            If (iRetval <> -1) Begin
                Move True to bVariableDeclaration
            End
        End

        Function_Return bVariableDeclaration
    End_Function

    Function IsVariableInLine String sLine String sVariableName Returns Boolean
        Boolean bIsUseLine
        String sChar
        Integer iPos

        Move False to bIsUseLine
        Move (Uppercase(sLine)) to sLine
        Move (Uppercase(sVariableName)) to sVariableName

        If (sLine contains sVariableName) Begin
            Move (Pos(sVariableName, sLine)) to iPos
            If (iPos > 0) Begin
                Repeat
                    Move (Mid(sLine, 1, (iPos - 1))) to sChar
                    If (CS_ValidLeftCharacters contains sChar) Begin
                        Move True to bIsUseLine
                    End
                    If (bIsUseLine = False) Begin
                        Move (Replace(sVariableName, sLine, "")) to sLine
                        Move (Pos(sVariableName, sLine)) to iPos
                    End
                Until (bIsUseLine = True or iPos = 0)
            End
        End

        Function_Return bIsUseLine
    End_Function

    Function IsProjectObjectStructureLine String sLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine
        Integer iPos iSize
        String sObjectName

        Move (Trim(sLine)) to sLine
        Move True to bWriteLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Lowercase(sLine)) to sLine
            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
            If (bWriteLine = False) Begin
                Move (SizeOfArray(asObjectNames)) to iSize
                Move (Pos(" is a", sLine)) to iPos
                Move (Left(sLine, (iPos -1))) to sObjectName
                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
                Move (Trim(sObjectName)) to sObjectName
                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
            End
        End
        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
            Move False to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // Returns True iif the source line contains a "Repeat" statement.
    Function IsRepeatStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Repeat) to bFound
        Function_Return bFound
    End_Function   
    
    Function IsRegisterObjectInArray String sLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine bRegisterObjectStart
        Integer iPos

        Move False to bWriteLine
        Get IsRegisterAllObjectsStart sLine to bRegisterObjectStart
        If (bRegisterObjectStart = False) Begin
            Move (Lowercase(sLine)) to sLine
            Move (Replace("register_object", sLine, "")) to sLine
            Move (Trim(sLine)) to sLine
            Move (SearchArray(sLine, asObjectNames)) to iPos
            Move (iPos = -1) to bWriteLine
        End

        Function_Return bWriteLine
    End_Function

    Function IsStudioGeneratedComment String sLine String sComment Returns Boolean
        String sText
        
        Move (Lowercase(sLine)) to sText      
        
        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
            Function_Return True 
        End
        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) Begin
            Function_Return True 
        End                 
        
        Function_Return False
    End_Function
    
    // Returns True iif the source line contains a "While" statement.
    Function IsWhileStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (CS_While + " ") to bFound
        Function_Return bFound
    End_Function   
    
    Function IsProjectObjectStructureStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterAllObjectsStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterAllObjectsEnd String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        String sFirstWord

        Move False to bFound
        Move (Lowercase(sLine)) to sLine
        Move (Trim(sLine)) to sLine
        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
            Move (Pos(" ", sLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sLine, (iPos -1))) to sFirstWord
                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
            End
        End
        Function_Return bFound
    End_Function

    Function IsRegisterObjectLine String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        Move False to bFound
        Move (Pos(CS_RegisterObject, sLine)) to iPos
        If (iPos = 1) Begin
            Move True to bFound
        End
        Function_Return bFound
    End_Function

    // Tests if the lowercase character passed in sLine on position iPos is
    // a valid character for a class name
    Function IsValidClassCharacter String sLine Integer iPos Returns Boolean
        Boolean bIsValid
        String  sChar
        Move False to bIsValid
        Move (Mid(sLine, 1, iPos)) to sChar
        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
            Move True to bIsValid
        End
        Function_Return bIsValid
    End_Function
      
    // (nicked from cSciLexer.pkg)
    // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter counting.
    // We reduce the spaces here to just one.
    Procedure StripConcatenatingSpaces String ByRef sText
        While (Pos("  ", sText) <> 0)
            Move (Replaces("  ", sText, " ")) to sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
        Loop
    End_Procedure

    Procedure AddCommand String sCommand
        String[] Commands

        Get paCommands to Commands
        Move (Lowercase(sCommand)) to sCommand
        Move sCommand to Commands[SizeOfArray(Commands)]
        Set paCommands to Commands
    End_Procedure

    Procedure AddCommandFunction String sCommand
        String[] aCommandFunctions

        Get paCommandFunctions to aCommandFunctions
        Move (Lowercase(sCommand)) to sCommand
        Move sCommand to aCommandFunctions[SizeOfArray(aCommandFunctions)]
        Set paCommandFunctions to aCommandFunctions
    End_Procedure

    // Command list used for testing against inline if/else statements et. al.
    // Note that it is not a complete command list and that we should be careful
    // about commands that might be used as functions or in functions!
    // For example, it is by intention that none of the variable declaration commands
    // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
    //
    // All commands can be entered case insensitive
    // Standalone commands can end on a end of line, such as Abort.
    // Other commands need more parameters and in such case we can improve our success rate
    // by adding a space character.
    //
    Procedure AddAllCommands
        String[] Empty

        Set paCommands to Empty

        //Send AddCommand "Repeat"  // nope, it is a function too
        Send AddCommand "Abort"
        Send AddCommand "Abort_Transaction"
        Send AddCommand "Activate_View "
        Send AddCommand "Add "
        Send AddCommand "Address "
        Send AddCommand "Append "
        Send AddCommand "Append_Output "
        Send AddCommand "Attach "
        Send AddCommand "Begin_Constraints"
        Send AddCommand "Begin_Transaction"
        Send AddCommand "Broadcast "
        Send AddCommand "Broadcast_Focus "
        Send AddCommand "Calc "
        Send AddCommand "Calculate "
        Send AddCommand "Call_Driver "
        Send AddCommand "CallStackDump "
        Send AddCommand "Case "
        Send AddCommand "Clear "
        Send AddCommand "Close "
        Send AddCommand "Close_Input"
        Send AddCommand "Close_Output"
        Send AddCommand "Constrain "
        Send AddCommand "Constrained_Clear "
        Send AddCommand "Constrained_Find "
        Send AddCommand "Constraint_Set"
        Send AddCommand "Constraint_Validate"
        Send AddCommand "Copy_db "
        Send AddCommand "Copy_Records "
        Send AddCommand "Copyfile "
        Send AddCommand "Create_Field "
        Send AddCommand "Create_Index "
        Send AddCommand "Declare_DataFile "
        Send AddCommand "Decrement "
        Send AddCommand "Delegate "
        Send AddCommand "Delete "
        Send AddCommand "Delete_db "
        Send AddCommand "Delete_Field "
        Send AddCommand "Delete_Index "
        Send AddCommand "Direct_Input "
        Send AddCommand "Direct_Output "
        Send AddCommand "DiskFree "
        Send AddCommand "EraseFile "
        Send AddCommand "Error "
        Send AddCommand "Field_Map "
        Send AddCommand "File_Exist "
        Send AddCommand "Fill_Field "
        Send AddCommand "Find "
        Send AddCommand "For "
        Send AddCommand "For_All "
        Send AddCommand "Forward "
        Send AddCommand "Function_Return " // you might have code that does not return a value, I'd consider that a warning
        Send AddCommand "Get "
        Send AddCommand "Get_Argument_Size "
        Send AddCommand "Get_Attribute "
        Send AddCommand "Get_Channel_Position "
        Send AddCommand "Get_Channel_Size "
        Send AddCommand "Get_Current_Directory "
        Send AddCommand "Get_Current_Input_Channel "
        Send AddCommand "Get_Current_Output_Channel "
        Send AddCommand "Get_Current_User_Count "
        Send AddCommand "Get_Date_Attribute "
        Send AddCommand "Get_Directory "
        Send AddCommand "Get_Environment "
        Send AddCommand "Get_Field_Value "
        Send AddCommand "Get_FieldNumber "
        Send AddCommand "Get_File_Mod_Time "
        Send AddCommand "Get_File_Path "
        Send AddCommand "Get_FileNumber "
        Send AddCommand "Get_Licensed_Max_Users "
        Send AddCommand "Get_StrictEval "
        Send AddCommand "Get_Transaction_Retry "
        Send AddCommand "Get_Windows_Directory "
        Send AddCommand "GetAddress "
        Send AddCommand "GetBuff "
        Send AddCommand "GetBuff_String "
        Send AddCommand "GetDskInfo "
        Send AddCommand "Global_Variable "
        Send AddCommand "Include_Resource "
        Send AddCommand "Increment "
        Send AddCommand "Indicate "
        Send AddCommand "Indicator "
        Send AddCommand "Load_Def "
        Send AddCommand "Load_Driver "
        Send AddCommand "Lock"
        Send AddCommand "Login "
        Send AddCommand "Logout"
        Send AddCommand "Make_Directory "
        Send AddCommand "Make_File "
        Send AddCommand "Make_Temp_File "
        Send AddCommand "Move "
        Send AddCommand "Movedate "
        Send AddCommand "Moveint "
        Send AddCommand "Movenum "
        Send AddCommand "Movereal "
        Send AddCommand "Movestr "
        Send AddCommand "NewRecord "
        Send AddCommand "On_Item"
        Send AddCommand "On_key "
        Send AddCommand "Open "
        Send AddCommand "Output "
        Send AddCommand "Output_Aux_File "
        Send AddCommand "Output_Wrap"
        Send AddCommand "Playwave "
        Send AddCommand "Procedure_Return"
        Send AddCommand "Property "
        Send AddCommand "Put "
        Send AddCommand "Read "
        Send AddCommand "Read_Block "
        Send AddCommand "Read_hex "
        Send AddCommand "Readln "
        Send AddCommand "Reg_Close_Key "
        Send AddCommand "Reg_Enum_Key "
        Send AddCommand "Reg_Enum_Key_Info "
        Send AddCommand "Reg_Enum_Value "
        Send AddCommand "Relate "
        Send AddCommand "Remove_Directory "
        Send AddCommand "Renamefile "
        Send AddCommand "Report_Breaks "
        Send AddCommand "Reread"
        Send AddCommand "RunProgram "
        Send AddCommand "Save "
        Send AddCommand "SaveRecord "
        Send AddCommand "Send "
        Send AddCommand "Set "
        Send AddCommand "Set_Argument_Size "
        Send AddCommand "Set_Attribute "
        Send AddCommand "Set_Channel_Position "
        Send AddCommand "Set_Date_Attribute "
        Send AddCommand "Set_Directory "
        Send AddCommand "Set_Field_Value "
        Send AddCommand "Set_File_Mod_Time "
        Send AddCommand "Set_Foreign_Profile_String "
        Send AddCommand "set_registry_root "
        Send AddCommand "Set_Relate "
        Send AddCommand "Set_StrictEval "
        Send AddCommand "Set_Transaction_Retry "
        Send AddCommand "Shift_State "
        Send AddCommand "Show "
        Send AddCommand "Showln"
        Send AddCommand "Sleep "
        Send AddCommand "Sort "
        Send AddCommand "Start_UI"
        Send AddCommand "Structure_Abort "
        Send AddCommand "Structure_Copy "
        Send AddCommand "Structure_End "
        Send AddCommand "Structure_Start "
        Send AddCommand "Subtract "
        Send AddCommand "Sysdate "
        Send AddCommand "Sysdate4 "
        Send AddCommand "Unload_Driver "
        Send AddCommand "Unlock"   
        Send AddCommand "Until"
        Send AddCommand "Valid_Drive "
        Send AddCommand "ValueTreeDeserializeParameter "
        Send AddCommand "ValueTreeSerializeParameter "
        Send AddCommand "VConstrain "
        Send AddCommand "Version_Information "
        Send AddCommand "VFind "
        Send AddCommand "Virtual_Key "
        Send AddCommand "WebGet "
        Send AddCommand "WebPublishFunction "
        Send AddCommand "WebPublishProcedure "
        Send AddCommand "WebSet "
        Send AddCommand "WebSetResponsive "
        Send AddCommand "While "
        Send AddCommand "Write "
        Send AddCommand "Write_Hex "
        Send AddCommand "WriteLn"
        Send AddCommand "ZeroFile "
        Send AddCommand "ZeroString "
        Send AddCommand "ZeroType "
    End_Procedure

    Procedure AddAllCommandFunctions
        String[] Empty

        Set paCommandFunctions to Empty

        Send AddCommandFunction "Repeat"  
        Send AddCommandFunction "If "
        Send AddCommandFunction "Else "  
        Send AddCommandFunction "Pos"
        Send AddCommandFunction "Insert"
    End_Procedure

//    Procedure Activating
//        Send AddAllCommands  
//        Send AddAllCommandFunctions
//    End_Procedure

    // splits a line to a string array.
    // Ignores any special characters, spaces or new line, CR "multi line"
    Function SplitTextByLengthPure String sText Integer iCount Returns String[]
        String sLine
        String[] saText
    
        Move sText to sLine
    
        While (Length(sLine) > 0)
            Move (Mid(sLine, iCount, 1)) to saText[(SizeOfArray(saText))]
            Move (Mid(sLine, (Length(sLine) - iCount), (iCount + 1))) to sLine
        Loop
    
        Function_Return saText
    End_Function

    // Splits a string to a string array.
    Function Split String sSplitKey String sText Returns String[]
        String[] sArray
        Integer iLeftPos
        Boolean bAtLeastOneSplit
    
        Move (ResizeArray(sArray, 0)) to sArray
        If ((sSplitKey = "") and ((Length(sSplitKey)) = 0)) Begin
            For iLeftPos from 1 to ((Length(sText)))
                Move (Mid(sText, 1, iLeftPos)) to sArray[SizeOfArray(sArray)]
            Loop
        End
        Else Begin
            Move (Pos(sSplitKey, sText)) to iLeftPos
    
            While (iLeftPos > 0)
                Move True to bAtLeastOneSplit
                Move (Left(sText, iLeftPos - 1)) to sArray[SizeOfArray(sArray)]
                Move (Right(sText, ((Length(sText) - (iLeftPos + (Length(sSplitKey))) )+1))) to sText
                Move (Pos(sSplitKey, sText)) to iLeftPos
            Loop
    
            // Ta med text hger om sista splittecknet
            Move sText to sArray[SizeOfArray(sArray)]
        End
    
        Function_Return sArray
    End_Function

    // Create a string by joining array elements using a separator
    Function JoinArray Global String[] saValues String sSeparator Returns String
        Integer i iLength
        String sRet
        Move "" to sRet
        Move (SizeOfArray(saValues)-1) to iLength
        For i from 0 to iLength
            // First element
            If (i = 0) Begin
                Append sRet saValues[i]
            End
            // Other elements
            Else Begin
                Append sRet sSeparator saValues[i]
            End
        Loop
        Function_Return sRet
    End_Function

    // Convert Integer to a binary value
    // Courtesy of Frank Cheng.
    Function IntToBinary Global Integer i Returns String
        String sResult
        If (i < 0) Function_Return ""
        Move "" to sResult
        Repeat
            Move (String(Mod(i, 2)) + sResult) to sResult
            Move (i / 2) to i
        Until (i = 0)
        Function_Return sResult
    End_Function

    // Courtesy of Frank Cheng.
    // There is another verion (HexToInt) in mStrConv.pkg
    Function HexToInt2 Global String sNum Returns Integer
        Integer iLength iDigit iNum iPower
        Move (Length(sNum)) to iLength
        Move 1 to iPower
        Move 0 to iNum
        While (iLength > 0)
            Move (Ascii(Mid(sNum,1,iLength))) to iDigit
            Subtract (If(iDigit > 57, 55, 48)) from iDigit
            Add (iDigit * iPower) to iNum
            Move (iPower * 16) to iPower
            Decrement iLength
        Loop
        Function_Return iNum
    End_Function

    // Curtesy of Evertjan Dondergoor DAE
    Function SQLDateTimeToDFDateTime String s Returns DateTime
        DateTime dt
        Integer iYear iMonth iDay
        Integer iHour iMinute iSecond

        Move (Mid(s, 4,  1)) to iYear
        Move (Mid(s, 2,  6)) to iMonth
        Move (Mid(s, 2,  9)) to iDay
        Move (Mid(s, 2, 12)) to iHour
        Move (Mid(s, 2, 15)) to iMinute
        Move (Mid(s, 2, 18)) to iSecond

        Move (DateSetYear  (dt, iYear  )) to dt
        Move (DateSetMonth (dt, iMonth )) to dt
        Move (DateSetDay   (dt, iDay   )) to dt
        Move (DateSetHour  (dt, iHour  )) to dt
        Move (DateSetMinute(dt, iMinute)) to dt
        Move (DateSetSecond(dt, iSecond)) to dt

        Function_Return dt
    End_Function

    // Returns True if the "sCheckFieldName" field exists in the passed iFile datbase table.
    // If it doesn't exist, False is returned
    Function IsFieldExisting Integer iFile String sCheckFieldName Returns Boolean
        Integer iNumFields iCount                                      
        String sFieldName
      
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
        Decrement iNumFields
        For iCount from 0 to iNumFields  
            Get_Attribute DF_FIELD_NAME of iFile iCount to sFieldName        
            If ((Uppercase (sFieldName)) = (Uppercase (sCheckFieldName))) Begin
                Function_Return True
            End
        Loop
      
        Function_Return False
    End_Function

End_Class
