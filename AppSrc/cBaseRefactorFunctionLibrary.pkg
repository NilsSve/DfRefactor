Use Windows.pkg
Use RefactorFunctionConstants.inc
Use cRemoveUnusedLocals.pkg
Use cUnusedSourceFiles.pkg
Use cDDOReStyler.pkg
Use cScintillaRefactorEditor.pkg
Use cRegex.pkg

Register_Function phoEditor Returns Handle 
Register_Function phoRemoveUnusedLocals Returns Handle
Register_Function phoReportUnusedSourceFiles Returns Handle

#IFNDEF ghoRefactorFunctionLibrary
Global_Variable Handle ghoRefactorFunctionLibrary
#ENDIF

#IFNDEF ghoStatusLog
Global_Variable Handle ghoStatusLog
#ENDIF

Use cSysFileDataDictionary.dd  
Open FunctionsA

Class cBaseRefactorFunctionLibrary is a cObject
    Procedure Construct_Object
        String[] asLocalVariableTypes asLocalVariableArrayTypes

        Forward Send Construct_Object
        Move Self to ghoRefactorFunctionLibrary
        
        Property Integer piLastErr 0 
        Property Boolean pbErr False
        
        Property Handle phoEditor
        Property Integer peNewStyle eDDUnknown

        Property tRefactorSettings pRefactorSettings
        //
        Property Boolean pbToggleState True     
        Property Boolean pbInRepeatLoop False
        Property Boolean pbInMultiLineSemiColon False
        Property Boolean pbInMultiLineString False
        Property Boolean pbInAllignedMultiLineString False
        
        Property tTokenizer pTokenizer
        
        Property String[] paCommands
        Property String[] paCommandFunctions    
        Property String[] pasLocalVariableTypes
        Property String[] pasLocalVariableArrayTypes

        Get StrSplitToArray CS_VarTypes ";" to asLocalVariableTypes
        Set pasLocalVariableTypes to asLocalVariableTypes
        Get StrSplitToArray CS_VarArrayTypes ";" to asLocalVariableArrayTypes
        Set pasLocalVariableArrayTypes to asLocalVariableArrayTypes

        // Properties for the RemovePRoejctObjectStructure function:
        Property Boolean pbProjectObjectStructureStart False 
        Property Boolean pbProjectObjectStructureEnd False
        Property Boolean pbRegisterAllObjectsStart False    
        Property Boolean pbRegisterAllObjectsEnd False
        Property String[] pasObjectNames

        // Refactor object handles
        Property Handle phoRemoveUnusedLocals
        Property Handle phoReportUnusedSourceFiles 
        Property Handle phoDDOReStyler

        Object oRemoveUnusedLocals is a cRemoveUnusedLocals
            Set phoRemoveUnusedLocals to Self
        End_Object
    
        Object oReportUnusedSourceFiles is a cUnusedSourceFiles
            Set phoReportUnusedSourceFiles to Self
        End_Object
        
        Object oDDOReStyler is a cDDOReStyler
            Set phoDDOReStyler to Self
        End_Object

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        Send AddAllCommands  
        Send AddAllCommandFunctions
    End_Procedure
    
    Procedure SaveErrorState
        Set piLastErr to LastErr
        If (Err = True) Begin
            Set pbErr to True
        End
        Else Begin
            Set pbErr to False
        End   
        Move False to Err
        Move 0 to LastErr
    End_Procedure
    
    Procedure RestoreErrorState
        Get piLastErr to LastErr
        If (pbErr(Self)) Begin
            Move True to Err
        End
        Else Begin
            Move False to Err
        End
    End_Procedure
    
    Procedure ResetProjectObjectStructureProperties
        String[] asObjectNames
        Set pbProjectObjectStructureStart to False 
        Set pbProjectObjectStructureEnd   to False
        Set pbRegisterAllObjectsStart     to False    
        Set pbRegisterAllObjectsEnd       to False
        Set pasObjectNames                to asObjectNames
    End_Procedure

    // ToDo: *** HELPER FUNCTIONS ***   
    //
    // Syntax:
    //    Get Tokenizer sSourceLine to "TokenizerData" (struct)
    // It does not Rtrim the line.
    // ToDo: Rewrite the following;
    // Note: If the line is a compound statement (one that spans over several lines),
    //       aka it contains a ";", the function will NOT try to break up the source code line.
    //       Instead it returns a struct with empty members, except for the 
    //       bIsEndSemiColon member that will be true.
    Function Tokenizer String sLine Returns tTokenizer
        tTokenizer TokenizerData
        String sText sText2 sChar sCommand
        Boolean bEndComment bStop bOfStatement bToStatement bIndicator bFound bMoveCommand bInMultiLineString
        Integer iPos iStart iEnd
                                                
        Move sLine to TokenizerData.sLine
        // The _OverstrikeStrings is costly (slow) so it will only be called once for each source line.
        //  It will overstrike string characters with "_" characters for a "A text" and "+" characters for a 'B text'
        Get _OverstrikeStrings sLine to TokenizerData.sOverstrikeLine
        
        // Place all testings for cases when we are done;
        // at the top of this function, so we can jump out.
        Get _IsCommentLine TokenizerData.sOverstrikeLine to TokenizerData.bIsComment
        Get _IsBlankLine   TokenizerData.sOverstrikeLine to TokenizerData.bIsBlank
        If (TokenizerData.bIsComment = True or TokenizerData.bIsBlank = True) Begin
            Set pbInMultiLineSemiColon to False
            Set pbInMultiLineString    to False
            Move True                  to TokenizerData.bLineIsReady 
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End  
        
        Get _IsImageStart TokenizerData.sOverstrikeLine to TokenizerData.bIsImageStart
        Get _IsImageEnd   TokenizerData.sOverstrikeLine to TokenizerData.bIsImageEnd  
        If (TokenizerData.bIsImageStart = True or TokenizerData.bIsImageEnd = True) Begin 
            Set pbInMultiLineSemiColon to False
            Set pbInMultiLineString    to False
            Move True to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        
        // Multi-line strings for DF23 and up. (@, @SQL and """)
        // The property pbInMultiLineString is set as soon as a
        // multi-line string has been started (and not ended):
        If (pbInMultiLineString(Self) = True) Begin
            Get _IsMultLineStringEnd TokenizerData.sOverstrikeLine to bFound
            If (bFound = True) Begin
                Set pbInMultiLineString to False                
                Move True to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End
        
        If (pbInMultiLineString(Self) = False) Begin
            Get _IsMultiLineStringStart TokenizerData.sOverstrikeLine to bFound
            If (bFound = True) Begin
                Set pbInMultiLineString to True  
                Move True to TokenizerData.bIsMultiLineString  
                Move True to TokenizerData.bLineIsReady
                Set pTokenizer to TokenizerData
                Function_Return TokenizerData
            End
        End                       
        
        Get _IsFunction TokenizerData.sOverstrikeLine           to TokenizerData.bIsFunction
        Get _IsProcedure TokenizerData.sOverstrikeLine          to TokenizerData.bIsProcedure
        Get _IsCommandDeclaration TokenizerData.sOverstrikeLine to TokenizerData.bIsCommandDeclaration
        If (TokenizerData.bIsFunction = True or TokenizerData.bIsProcedure = True or TokenizerData.bIsCommandDeclaration = True) Begin
            Move True to TokenizerData.bLineIsReady
            Set pTokenizer to TokenizerData
            Function_Return TokenizerData
        End
        // *** End of tests that sets the TokenizerData.bLineIsReady = True.
             
        Get _IsLineEndSemiColon TokenizerData.sOverstrikeLine to bFound                    
        If (bFound = True) Begin
            Set pbInMultiLineString    to False
            Set pbInMultiLineSemiColon to True
            Move True to TokenizerData.bHasEndSemiColon
        End
        Else Begin
            // ToDo: Do we need this property?
            Set pbInMultiLineSemiColon to False
        End

        // Get the end comment part
        Get _EndComment sLine to TokenizerData.sEndComment
        
        // Get the indentation part
        Get _Indentation sLine to TokenizerData.sIndentation
        
        // Get start and end indicators
        Get IsKeywordInLine (CS_Indicate + "|") TokenizerData.sOverstrikeLine to bFound
        If (bFound = True) Begin
            Move True to TokenizerData.bHasIndicateCommand
        End                                                
        Get _LeftIndicatorStatement  TokenizerData.sOverstrikeLine to TokenizerData.sLineStartIndicator
        Get _RightIndicatorStatement TokenizerData.sOverstrikeLine to TokenizerData.sLineEndIndicator
            
        // Get the "of xxx" part
        Get _OfStatement sLine to TokenizerData.sOfStatement 
        
        // Get the "to xxx" part
        Get _ToStatement sLine to TokenizerData.sToStatement
        
        
        // ToDo: 
        Get IsMoveCommand sText to bMoveCommand
        If (bMoveCommand = True) Begin
            Move (Pos(" ", sText)) to iPos
            Move (Left(sText, (iPos - 1))) to sCommand
            Move sCommand to TokenizerData.sLeftCommand
        End                                             
        
        // The reminder of the code line
//        Move (Trim(sLine)) to TokenizerData.sCode
        Set pTokenizer to TokenizerData
                                      
        Function_Return TokenizerData
    End_Function   
    
    // Is it a Function declaration?
    // It is assumed that the past "sLine" is not a comment or blank line.
    // Pass a source line param with overstriked string constants.
    Function _IsFunction String sLine Returns Boolean
        Boolean bFound bComment 
        
        Move False to bFound
        Move (Trim(sLine)) to sLine
        Move (Pos(Lowercase("function "), Lowercase(sLine)) > 0) to bFound
        
        Function_Return bFound
    End_Function
    
    // Is it a Procedure declaration?
    // It is assumed that the past "sLine" is not a comment or blank line.
    // Pass a source line param with overstriked string constants.
    Function _IsProcedure String sLine Returns Boolean
        Boolean bFound bComment 
        
        Move False to bFound
        Get _IsCommentLine sLine to bComment
        If (bComment = True) Begin
            Function_Return bFound
        End
        Move (Trim(sLine)) to sLine
        Move (Pos(Lowercase("procedure "), Lowercase(sLine)) > 0) to bFound
        
        Function_Return bFound
    End_Function
    
    Function IsMethodStart String sLine Returns Boolean
        Boolean bMethodStart

        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 10) = "procedure " or Left(sLine, 9) = "function ") to bMethodStart

        Function_Return bMethodStart
    End_Function

    Function IsMethodEnd String sLine Returns Boolean
        Boolean bMethodEnd

        Get _OverstrikeStrings sLine to sLine
        Get _RemoveEndComment  sLine to sLine
        Move (Lowercase(Trim(sLine))) to sLine
        Move (Left(sLine, 14) = "end_procedure " or Left(sLine, 13) = "end_function ") to bMethodEnd

        Function_Return bMethodEnd
    End_Function

    // Is it a command declaration?
    Function _IsCommandDeclaration String sLine Returns Boolean
        Boolean bFound bComment 
        
        Move False to bFound
        Get _IsCommentLine sLine to bComment
        If (bComment = True) Begin
            Function_Return bFound
        End
        Move (Trim(sLine)) to sLine
        Move (Pos(Lowercase("#" + CS_Command), Lowercase(sLine)) > 0) to bFound
        
        Function_Return bFound
    End_Function
    
    Function _HasLeftCommand String sLine tTokenizer TokenizerData Returns String
        String sCommand
        String[] asCommands        
        
        Get paCommands to asCommands
        
    End_Function
    
    // Counts total number of source lines for the passed file name.
    // It does *not* count empty or commented lines. 
    // it does *not* count COM proxy class files generated by the Studio for COM/ActiveX components.
    Function CountNumberOfLines String sFullSourceFileName String sParameter Returns Integer
        Integer iLines iChannel 
        String sLine     
        Boolean bExists bBlank bIsCOM
        
        File_Exist sFullSourceFileName bExists
        If (bExists = False) Begin
            Send UserError ("Couldn't find file:" * String(sFullSourceFileName) * "No source lines added to counter for this file.")
            Function_Return 0
        End                  

        Get IsDataFlexCOMProxyClassesFile sFullSourceFileName to bIsCOM
        If (bIsCOM = True) Begin
            Function_Return 0
        End
        
        Get Seq_New_Channel to iChannel
        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Send UserError "No Channel Available for Process: Procedure 'CountNumberOfLines'"
            Function_Return 0
        End

        Move 0 to iLines
        Direct_Input channel iChannel sFullSourceFileName
        While (SeqEof = False)
            Readln channel iChannel sLine 
            Get _IsCommentLineOrBlank sLine to bBlank
            If (bBlank = False) Begin
                Increment iLines
            End
        Loop
        Close_Input channel iChannel
        Send Seq_Release_Channel iChannel
        
        Function_Return iLines
    End_Function

    // Note: It must only be the code part of a source line that is passed here.
    //       Use the Tokenizer helper function first.
    Function _AddExpressionParenthesis String ByRef sLine Returns Boolean
        String sText sStart sLast sExpression sExpression2 sLeft sRight sChar sPart1 sPart2 sOrg sCommand
        Boolean bFound bChanged bStartOperators bIfCommand bSecondCommand bWhile
        Integer iPos iPos2
        
        Move sLine to sText    
        Move sLine to sOrg             
        // Do nothing if a Constrain command.
        Get HasCommand sText (CS_Constrain + " ") to bFound
        If (bFound = True) Begin
            Function_Return False
        End

        Move "" to sStart
        Move "" to sLast                                  
        Get _ExpressionExtractor sText CI_LeftExpression to sExpression
        If (Trim(sExpression) = "") Begin
            Get _ExpressionExtractor sText CI_OfExpression to sExpression
            If (Trim(sExpression) = "") Begin
                Get _ExpressionExtractor sText CI_ToTexpression to sExpression
            End
        End
        If (Trim(sExpression) = "") Begin
            Function_Return False
        End 
        Move (Pos(sExpression, sText)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sLine, (iPos - 1))) to sStart
            If (sStart <> "") Begin
                Move (Replace(sStart, sLine, "")) to sText
                Move (Replace(sExpression, sText, "")) to sLast
            End
        End
//        If (sStart <> "") Begin
//            Move sStart to sLine
//        End                     
        If (sExpression <> "") Begin               
            Move sExpression to sText
            Send StripConcatenatingSpaces (&sExpression)  
            Move (Trim(sExpression)) to sExpression 
            Get HasDoubleExpression sExpression to bFound
            Move (Left(sExpression, 1)) to sChar
            If (sChar <> "(" or bFound = True) Begin
                Move ("(" + sExpression + ")") to sExpression
            End                      
            If (sText = sLine) Begin
                Move sExpression to sLine
            End
        End                                                    
        If (sStart <> "" or sLast <> "") Begin    
            Move (String(sStart) + String(sExpression) + String(sLast)) to sLine
        End
        
        Function_Return (sLine <> sOrg)
    End_Function   
                   
    // Helper message for _ClearFirstCompoundBeforeMethod
    Procedure _WipeUntilPosition Integer iPos String ByRef sLine
        Integer iChar
        If (iPos > 0) Begin
            For iChar from 1 to (iPos - 1)
                Move (Overstrike(" ", sLine, iChar)) to sLine
            Loop
        End
    End_Procedure

    // With our refactoring logic if a line starts with if, else or on_key then the logic won't see
    // send/get/set as the first string and that complicates our detection.
    // What this does is simply overwrite everything with spaces before our methods if
    // we have such a compound statement.
    // The variable sLine is not always lowercase.
    Function _ClearFirstCompoundBeforeMethod String ByRef sLine Returns Boolean
        Integer iPos
        String  sLtrimLine sOrgLine
        Boolean bChanged
        
        Move sLine to sOrgLine
        Move (Lowercase(LTrim(sLine))) to sLTrimLine
        If (Left(sLtrimLine, 3) = "if " or Left(sLtrimLine, 5) = "else " or Left(sLtrimLine, 7) = "on_key ") Begin
            // A line that starts with an "if" or "else" can still call a method
            Move (Pos("send ", Lowercase(sLine))) to iPos
            If (iPos = 0) Begin
                Move (Pos("get ", Lowercase(sLine))) to iPos
            End
            If (iPos = 0) Begin
                Move (Pos("set ", Lowercase(sLine))) to iPos
            End
            Send _WipeUntilPosition iPos (&sLine)
        End       
        
        Function_Return (sLine <> sOrgLine)
    End_Function
  
    // Helper function to return expressions from a source line;
    //   eExpressionMode can be any of; CI_LeftExpression, CI_OfExpression or CI_ToTexpression.
    // As expressions only expressions in rounded parenthesis "()" are acted upon and returned (Not square brackets)
    Function _ExpressionExtractor String sLine Integer eExpressionMode Returns String
        String sExpression sText sChar sStart sLast sCommand 
        String[] asTokens asTokensLower
        Integer iStart iEnd iLength iLeftParantheses iRightParantheses iPos iCount iSize
        Boolean bFound bOperator bParenthesis 
        tOperatorsInfo OperatorsInfo
        tTokenizer TokenizerData
        
        Get _RemoveEndComment sLine to sText
        Move (Trim(sText)) to sText
        Get _OverstrikeStrings sText to sText
        Move (Pos("(", sText)) to iStart
        Move (Pos(")", sText)) to iEnd 
        Get _IsLogicalOperators sText to OperatorsInfo
        If (OperatorsInfo.bIsOperator = False and (iStart < 1 or iEnd < 1) ) Begin
            Function_Return sLine
        End
        Move (Trim(sLine)) to sText
        
        Case Begin
            Case (eExpressionMode = CI_LeftExpression) 
                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Left(sText, (iPos -1))) to sText
                End                                       
                Else Begin
                    Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
                End                                            
                If (iPos > 0) Begin
                    Move (Left(sText, (iPos - 1))) to sText // XXX
                End
                Case Break   
            
            // ToDo: Needs to be finished after changes to the TokenizerData.    
            Case (eExpressionMode = CI_CommandExpression)
                Get Tokenizer sLine to TokenizerData 
                If (Lowercase(TokenizerData.sLeftCommand) = Lowercase(CS_If)) Begin
                    Move (lowercase(sLine) contains (" " + Lowercase(CS_Move) + " ")) to bFound
                    If (bFound) Begin
                        
                    End
                End
                Case Break
            Case (eExpressionMode = CI_OfExpression)
                Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText
                    Move (Pos((" " + Lowercase(CS_to) + " "), Lowercase(sText))) to iPos
                    If (iPos > 0) Begin
                        Move (Left(sText, (iPos -1))) to sText
                    End
                    Get IsOperators sText to bOperator
                    Move (sText contains "(" and sText contains ")") to bParenthesis
                    If (bOperator = True or bParenthesis = True) Begin
                        Move (Trim(sText)) to sExpression
                    End
                End
                Else Begin
                    Move "" to sText // Nothing to do.
                End
                Case Break
            Case (eExpressionMode = CI_ToTexpression)
                Move (Pos((" " + Lowercase(CS_To) + " "), Lowercase(sText))) to iPos
                If (iPos > 0) Begin
                    Move (Mid(sText, Length(sText), (iPos + 3))) to sText 
                    Get IsOperators sText to bOperator
                    Move (sText contains "(" and sText contains ")") to bParenthesis
                    If (bOperator = True or bParenthesis = True) Begin
                        Move (Trim(sText)) to sExpression
                    End
                End 
                Else Begin
                    Move "" to sText // Nothing to do.
                End
                Case Break 
            Case Else
                Move "" to sText
        Case End
        
//        Move "" to sExpression  
//        Move 0  to iLeftParantheses
//        Move 0  to iRightParantheses
        If (sText <> "") Begin
//            Move (Pos("(", sText)) to iStart
//            Move (Pos(")", sText)) to iEnd
//            Get IsOperators sText to bOperator
//            If (bOperator = False and (iStart = 0 or iEnd = 0) ) Begin
//                Function_Return ""
//            End 
//
            Get _IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Get _ExtractParenthesisExpression sText to sExpression
                If (sExpression = "") Begin
                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to sExpression
                End
            End
//            Move (Length(sText)) to iLength
//            For iCount from iStart to iLength
//                Move (Mid(sText, 1, iCount)) to sChar
//                If (sChar = "(" or sChar = ")") Begin
//                    Add (sChar = "(") to iLeftParantheses
//                    Add (sChar = ")") to iRightParantheses
//                    Move iCount to iPos
//                End                        
//                If (sChar = " " and iLeftParantheses = iRightParantheses) Break
//            Loop
//            Move (Mid(sText, (iPos - iStart + 1), iStart)) to sExpression
//            If (sExpression = "" and (bOperator = True) and (iStart <> 1 or iEnd <> 0)) Begin
//                Get _RemoveFirstWord sText to sText
//                Get IsOperators sText to bOperator
//                If (bOperator = True) Begin
//                    Move sText to sExpression 
//                    Move sLine to sText
//                End
//            End
        End
        
        // Check if we have an expression like; "If (psWrkSpcOpenFileName(ghoApplication)) <> "" Send WrkSpcDoForAllFiles"
        //   which in case we need to add "<>" to the sExpression.
        Get _RemoveLeft sExpression (&sText) to bFound
        If (bFound = True) Begin
            Get _IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Move (Pos(sExpression, sLine)) to iPos
                If (iPos <> "") Begin        
                    Move (Left(sLine, (iPos - 1))) to sStart
                    Move (Replace(sStart, sLine, "")) to sLine
                    Move (Trim(sText)) to sText 
                    Move (Length(sText)) to iLength    
                    Get _OverstrikeStrings sText to sText
                    Get _FindFirstCommand sText to iPos
                    If (iPos <> 0) Begin
                        Move (Replace(sExpression, sLine, "")) to sLine 
                        Move (Trim(sLine)) to sLine
                        Move (Left(sLine, (iPos -1))) to sStart 
                        Move (Trim(sStart)) to sStart
                        If (sStart <> "") Begin
                            Move (Right(sStart, 1)) to sChar
                            If (sChar <> ")") Begin
                                Move (String(sExpression) * String(sStart)) to sExpression    
                            End
                        End
                    End
                End
            End
        End
        Function_Return sExpression
    End_Function

    Function _FirstLeftExpression String sLine tTokenizer TokenizerData Returns String
        String sExpression
        
        Move "" to sExpression
        Get _ExtractParenthesisExpression sLine to sExpression
        If (sExpression = "") Begin
            Get _ExtractExpressionNoParenthesis sLine to sExpression
        End
        Function_Return sExpression    
    End_Function
    
    Function _SecondLeftExpression String sLine tTokenizer TokenizerData Returns String
        String sExpression
        Integer iPos
        
        Move "" to sExpression
        If (TokenizerData.sFirstLeftExpression = "") Begin
            Get _ExtractParenthesisExpression sLine to sExpression
            If (sExpression = "") Begin
                Get _ExtractExpressionNoParenthesis sLine to sExpression
            End
        End
        If (sExpression <> "") Begin
            Move (Pos(sExpression, sLine)) to iPos
            Move (Mid(sLine, Length(sLine), (iPos + 1))) to sLine
            Get _ExtractParenthesisExpression sLine to sExpression
            If (sExpression = "") Begin
                Get _ExtractExpressionNoParenthesis sLine to sExpression
            End
        End
        Function_Return sExpression    
    End_Function
    
    // Rturns the first expression that exist in the passed sText string and that is within parenthesis,
    // else it returns a blank string.
    Function _ExtractParenthesisExpression String sLine Returns String
        String sExpression sChar
        Integer iLeftParantheses iRightParantheses iStart iEnd iCount iLength iPos
        tOperatorsInfo OperatorInfo
        
        Move "" to sExpression
        Move 0  to iLeftParantheses
        Move 0  to iRightParantheses
        
        If (sLine <> "") Begin
            Move (Pos("(", sLine)) to iStart
            Move (RightPos(")", sLine)) to iEnd
            Get _IsLogicalOperators sLine to OperatorInfo
            If (OperatorInfo.bIsOperator = False or (iStart = 0 or iEnd = 0) ) Begin
                Function_Return ""
            End 

            Move (Length(sLine)) to iLength
            For iCount from iStart to iLength
                Move (Mid(sLine, 1, iCount)) to sChar
                If (sChar = "(" or sChar = ")") Begin
                    Add (sChar = "(") to iLeftParantheses
                    Add (sChar = ")") to iRightParantheses
                    Move iCount to iPos
                End                        
                If (iLeftParantheses = iRightParantheses) Break
            Loop
            Move (Mid(sLine, (iPos - iStart + 1), iStart)) to sExpression
        End
        Function_Return sExpression
    End_Function

    Function _ExtractExpressionNoParenthesis String sLine tOperatorsInfo OperatorsInfo Returns String
        String sText sExpression sChar sFirst sLast sLeft sRight
        Integer iCount iLength iSize iStart iEnd iPos
        Boolean bStop bSpace bParanthesis
        
        // ToDo: Is this really correct in all cases?
        If (OperatorsInfo.bIsOperator = False) Begin
            Function_Return ""
        End
        Move "" to sExpression  
//        Move (Pos(Lowercase(" " + CS_As + " "), sLine)) to iPos 
//        If (iPos <> 0) Begin
//            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sText    
//        End
//        Else Begin
            Move (OperatorsInfo.iPos - Length(OperatorsInfo.sOperator)) to iStart
            Move (Left(sLine, (iStart + 1))) to sText
//        End
        Send StripConcatenatingSpaces (&sText)
        Get _OverstrikeStrings (&sText) to sText
        Move (Length(sText)) to iLength   
        Move (Pos(Lowercase(" " + CS_As + " "), sText)) to iPos 
        If (iPos <> 0) Begin
            Move (Mid(sText, Length(sText), (iPos + 3))) to sText    
        End
        
        // First get the left part of the expression:
        Move iLength to iStart
        Move 0 to iCount
        Move False to bSpace
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sText, 1, (iStart - iCount))) to sChar
            If (bParanthesis = True) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar <> " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
        Move (Left(sText, (iStart - iCount + 1))) to sFirst  
        Move (Replace(sFirst, sText, "")) to sLeft
        If (sLeft = "") Begin
            Move sText to sLeft
        End
        Move (Length(sLine)) to iLength   
        
        // Then get the right part of the expression:
        Move 1 to iCount   
        Move False to bSpace
        Move (OperatorsInfo.iPos) to iStart
        Move (Mid(sLine, iLength, (iStart + 1))) to sText  
        Move (Length(sText)) to iLength
        Move (Pos(")", sText)) to bParanthesis
        Repeat
            Move (Mid(sLine, 1, (iStart + iCount))) to sChar
            If (bParanthesis = False) Begin
                Move ((iCount >= iLength) or (bSpace = True and sChar = " ")) to bStop
            End 
            Else Begin
                Move (sChar = " " and bSpace) to bStop
            End
            If (bSpace = False) Begin
                Move (sChar = " ") to bSpace
            End
            Increment iCount
        Until (bStop = True)
                                                     
        Move (Left(sText, (iCount - 1))) to sRight
        Move (String(sLeft) * String(sRight)) to sExpression
        
        Function_Return (Trim(sExpression))
    End_Function

    // Helper function.
    Function _BreakupCompoundStatement Integer iLineIndent String ByRef sLine Integer eSplitBy Integer iTabSize Returns Boolean
        Boolean bChanged
        Integer iPos
        String  sLineIndent sIndent sLine1 sLine2 sText

        Move False to bChanged
        Move (Lowercase(sLine)) to sText
        Move (Repeat(" ", iTabSize - 1)) to sIndent  // it's tabsize-1 because the text still has a space in front of it
        Move (Repeat(" ", iLineIndent)) to sLineIndent
        Get _OverstrikeStrings sText to sText
        Get _FindFirstCommand sText to iPos
        If (iPos <> 0) Begin
            Move True to bChanged
            If (eSplitBy = eSplitBySpaceSemiColumn) Begin
                Move (Insert(" ;" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitBySemiColumn) Begin
                Move (Insert(";" + CS_CRLF + sLineIndent + sIndent, sLine, iPos)) to sLine
            End
            Else If (eSplitBy = eSplitByBeginEnd) Begin
                Move (Insert((" Begin" + CS_CRLF + sLineIndent + sIndent), sLine, iPos)) to sLine
                Move (sLine + CS_CRLF + sLineIndent + "End") to sLine
            End

            // Remove any spaces before the point on which we break the line
            Move (Left(sLine, iPos - 1)) to sLine1
            Move (Right(sLine, Length(sLine) - (iPos - 1))) to sLine2
            Move (RTrim(sLine1)) to sLine1
            Move (sLine1 + sLine2) to sLine
        End
        Function_Return bChanged
    End_Function

    // ToDo: REDO!
    // Takes a string like: [not Seqeof] Begin
    // and returns struct as: True, True, "(not(Seqeof))" and "Begin",
    //   _but_ it doesn't do anything with a line that starts with a [Select] stetement;
    //   "[Select] Indicate Select as Windowindex Eq Fieldindex"
    // Note: The brackets _must_ be at the start of code line.
    //       bHasBracket denotes that the line starts with a "[", bHasNot denotes that the expression has a "not" in it.
    Function _ExtractIndicatorContent String sLine Returns tBooleanIndicator
        Integer iPos                                             
        String sText sChar sNot sBoolean sFirstWord sCommand sExpression
        Boolean bRightSideIndicator bFound bIndicateWord
        tBooleanIndicator BooleanIndicator  
        tOperatorsInfo OperatorsInfo
        
        Move False to BooleanIndicator.bHasBracket
        Move False to BooleanIndicator.bHasNot
        Move ""    to BooleanIndicator.sCode
        Move ""    to BooleanIndicator.sExpression
        
        Get IsIndicatorStatement sLine to bFound
        Move (Lowercase(sLine) contains Lowercase(CS_Indicate)) to bIndicateWord
        If (bFound = False and bIndicateWord = False) Begin
            Function_Return BooleanIndicator
        End
        Move (Trim(sLine)) to sText 
        Get _OverstrikeStrings sText to sText
        Move (sText contains "[" and sText contains "]") to BooleanIndicator.bHasBracket  
        
        Move "" to sNot
        Get _RetrieveFirstWord sText to sFirstWord
        // Is the indicator placed on the right hand side of the command?
        Move (Pos("[", sFirstWord) = 0) to bRightSideIndicator
        If (bRightSideIndicator = True) Begin
            Move (Pos("[", sText)) to iPos
            Move (Mid(sText, Length(sText), iPos)) to sBoolean
        End
        Else Begin
            Move (Pos("]", sText)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sText, iPos)) to sBoolean 
                Move (Mid(sText, Length(sText), (iPos + 1))) to sFirstWord
                Move sFirstWord to BooleanIndicator.sCode
            End
        End
        Move (Trim(sFirstWord)) to sCommand
        Move (Replaces("[", sBoolean, "")) to sBoolean
        Move (Replaces("]", sBoolean, "")) to sBoolean
        Move (Trim(sBoolean)) to sBoolean

        Move (Pos((Lowercase(CS_Not) + " "), Lowercase(sBoolean))) to iPos
        If (iPos <> 0) Begin
            Move (Mid(sBoolean, Length(sBoolean), (iPos + 4))) to sBoolean
            Move (String(CS_Not)) to sNot
        End                    
        If (sNot <> "") Begin
            Move ("(" + String(sBoolean) * "=" * String(CS_False) + ")") to BooleanIndicator.sExpression 
            Move True to BooleanIndicator.bHasNot
        End 
        Else If (Lowercase(sBoolean) = Lowercase(CS_Finderr)) Begin
            Move ("(" + CS_Found * " = " * CS_False + ")") to BooleanIndicator.sExpression
        End
        Else Begin                
            Get _IsLogicalOperators sText to OperatorsInfo
            If (OperatorsInfo.bIsOperator = True) Begin
                Get _ExtractParenthesisExpression sText to BooleanIndicator.sExpression
                If (BooleanIndicator.sExpression = "") Begin
                    Get _ExtractExpressionNoParenthesis sText OperatorsInfo to BooleanIndicator.sExpression
                End
//                Move True to BooleanIndicator.bHasNot 
                Move sLine to sCommand
            End
            Else Begin
                Move ("(" + String(sBoolean) + ")") to BooleanIndicator.sExpression
                Move False to BooleanIndicator.bHasNot
            End
        End
        Move (Trim(sCommand)) to BooleanIndicator.sCode
            
        Function_Return BooleanIndicator
    End_Function
    
    // Tries to find the first DataFlex command found in the passed string.
    // Returns the starting pos of that same command (or 0 if not found).
    Function _FindFirstCommand String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommands

        Move 0 to iPos
        Move (" " + sTest) to sTest
        Get _RemoveComments (&sTest) to bRemoved
        Get paCommands to asCommands
        Move (SizeOfArray(asCommands)) to iSize
        If (iSize = 0) Begin
//            Send AddAllCommands
            Get paCommands to asCommands
            Move (SizeOfArray(asCommands)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommands[iCount] to sCommand
            Move (Pos(" " + Lowercase(sCommand), Lowercase(sTest))) to iTest // The command MUST start with a space and MIGHT end with a space.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop              
        // We added a beginning " " at the top of this function, so adjust for that now.
//        If (iPos = 1) Begin
//            Move 0 to iPos
//        End
        Function_Return iPos
    End_Function
    
    // Parses the method name from the string
    Function _MethodName String sMethod Returns String
        Integer iPos
        Get _RemoveFirstWord sMethod to sMethod
        Move (Right(sMethod, (Length(sMethod) - iPos))) to sMethod
        If (Uppercase(Left(Trim(sMethod), 4)) = "SET ") Begin
            Get _RemoveFirstWord sMethod to sMethod
        End
        // Remove any trailing arguments
        Move (Pos(" ", sMethod)) to iPos
        Function_Return (Left(sMethod, (iPos - 1)))
    End_Function

    // For declarations like "string [] saAddress"
    Function _NormalizeArrayNotation String ByRef sLine Returns Boolean
        Boolean bChanged
        String sText
        Move sLine to sText
        While (Pos(" [", sText) > 0)
          Move (Replace(" [", sText, "[")) to sText
        Loop                                       
        Move (sLine = sText) to bChanged
        Function_Return bChanged
    End_Function

    //  This will pad out the strings in a line and overstrike them
    //  with _ characters for a "string" and + characters for a 'string'
    Function _OverstrikeStrings String sLine Returns String
        Boolean bDoubleQuote bSingleQuote bChanged
        Integer iChar iLength
        String  sChar sText

        Move False to bChanged 
        Move sLine to sText
        Move (Length(sText)) to iLength
        For iChar from 1 to iLength
            Move (Mid(sText, 1, iChar)) to sChar
            If (sChar = Character(9)) Begin                  // tab characters should be treated as a single space char, this keeps the
                Move (Overstrike(" ",sText, iChar)) to sText // position in the string the same.
                Move True to bChanged
                Move " " to sChar
            End
            If (bDoubleQuote and sChar= '"') Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bDoubleQuote
            End
            If (bSingleQuote and sChar = "'") Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
                Move "" to sChar
                Move False to bSingleQuote
            End
            If (bSingleQuote = False and sChar ='"') Begin
                Move True to bDoubleQuote
            End
            If (bDoubleQuote = False and sChar = "'") Begin
                Move True to bSingleQuote
            End
            If bDoubleQuote Begin
                Move (Overstrike("_", sText, iChar)) to sText
                Move True to bChanged
            End
            Else If bSingleQuote Begin
                Move (Overstrike("+", sText, iChar)) to sText
                Move True to bChanged
            End
        Loop

        If (bChanged = True) Begin
            Move sText to sLine
        End
        Function_Return sLine
    End_Function

    Function _RemoveComments String ByRef sLine Returns Boolean
        Boolean bRemoved
        Integer iPos

        Move False to bRemoved   
        Move sLine to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos > 0) Begin
            Move (Left(sLine, iPos - 1)) to sLine
            Move True to bRemoved
        End
        Function_Return bRemoved
    End_Function    

    Function _Indentation String sLine Returns String
        String sText sIndentation
        Move "" to sIndentation
        Move (Ltrim(sLine)) to sText
        If (sText <> sLine) Begin
            Move (Replace(sText, sLine, "")) to sIndentation
        End
        Function_Return sIndentation
    End_Function
        
    // Returns the start indicator part from a square bracket expression
    // E.g. Returns "Not Seqeof" from "[Not Seqeof]"
    // Returns a blank string if no such expression was found.
    Function _LeftIndicatorStatement String sLine Returns String
        String sIndicator sText sChar
        Integer iPos
        Boolean bFound        
        
        Move "" to sIndicator
        Get IsIndicatorStatement sLine to bFound
        If (bFound = False) Begin
            Function_Return sIndicator
        End

        Move (Ltrim(sLine)) to sText
        Move (Left(sText, 1)) to sChar
        If (sChar = "[") Begin
            Move (Pos("]", sText)) to iPos
            Move (Left(sText, (iPos -1))) to sIndicator
            Move (Left(sIndicator, 1)) to sChar
            If (sChar = "[") Begin
                Move (Replace("[", sIndicator, "")) to sIndicator
            End
            Move (Right(sIndicator, 1)) to sChar
            If (sChar = "]") Begin
                Move (Replace("]", sIndicator, "")) to sIndicator
            End
        End
        Function_Return sIndicator
    End_Function
        
    // Returns the end indicator part from square bracket expression(s).
    // E.g. Returns "Seqeof" from "Move [bFound] to [Seqeof]"
    // Returns a blank string if no such expression was found.
    Function _RightIndicatorStatement String sLine Returns String
        String sIndicator sText sChar
        Integer iPos iStart iEnd
        Boolean bFound
        
        Move "" to sIndicator
        Get IsIndicatorStatement sLine to bFound
        If (bFound = False) Begin
            Function_Return sIndicator
        End

        Move (Trim(sLine)) to sText    
        Get _RemoveEndComment sText to sText
        Move (Right(sText, 1)) to sChar
        If (sChar = "]") Begin  
            Move (Pos(Lowercase(" to "), Lowercase(sText))) to iPos
            If (iPos > 0) Begin
                Move (Mid(sText, Length(sText), (iPos + 4))) to sText
            End
            // We need also check that this isn't an array/struct value.
            Move (Pos(" [", sText)) to iStart
            If (iStart > 0) Begin
                Move (Pos("]", sText)) to iEnd
                Move (Mid(sText, Length(sText), (iStart +1))) to sIndicator
                Move (Left(sIndicator, 1)) to sChar
                If (sChar = "[") Begin
                    Move (Replace("[", sIndicator, "")) to sIndicator
                End
                Move (Right(sIndicator, 1)) to sChar
                If (sChar = "]") Begin
                    Move (Replace("]", sIndicator, "")) to sIndicator
                End
            End
        End
        
        Function_Return sIndicator
    End_Function

    // Get the " of xxxx " part from a source line
    Function _OfStatement String sLine Returns String
        String sOfStatement sText
        Boolean bOfStatement
        Integer iPos
        
        Move (Lowercase(sLine)) to sText
        Move (sText contains (" " + Lowercase(CS_Of) + " ")) to bOfStatement
        If (bOfStatement = True) Begin
            Move (Pos((" " + Lowercase(CS_Of) + " "), Lowercase(sLine))) to iPos
            Move (Mid(sLine, (Length(sLine) -1), (iPos + Length(CS_Of) + 1))) to sOfStatement
            Move (Left(sLine, (iPos - 1))) to sLine
            Move (Trim(sOfStatement)) to sOfStatement
        End    
    
        Function_Return sOfStatement    
    End_Function

    // Get the " to xxx" part
    Function _ToStatement String sLine Returns String
        Boolean bToStatement
        String sText sToStatement
        Integer iPos
        
        Move "" to sToStatement
        Move (Lowercase(sLine)) to sText
        Move (sText contains (" " + Lowercase(CS_To) + " ")) to bToStatement
        If (bToStatement = True) Begin
            Move (Pos((" " + Lowercase(CS_To) + " "), sText)) to iPos
            Move (Mid(sLine, Length(sLine), (iPos +1))) to sToStatement
            Move (Replace(sToStatement, sLine, "")) to sLine
            Move (Replace((CS_To) + " ", sToStatement, "")) to sToStatement
            Move (Trim(sToStatement)) to sToStatement
        End        
    
        Function_Return sToStatement
    End_Function
    
    // Returns the end comment if one exists.
    // Else returns an empty string
    Function _EndComment String sLine Returns String
        Integer iPos
        String sComment

        Move "" to sComment
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (Pos(CS_CommentSymbol, sLine)) to iPos
            Move (Mid(sLine, Length(sLine), iPos)) to sComment
        End
        Function_Return sComment
    End_Function

    // Returns an end comment if exists. It also removes the end comment
    // from the passed string.
    Function _RemoveEndComment String sLine Returns String
        Integer iPos
        String sTest

        Move (Trim(sLine)) to sTest
        Move (Pos(CS_CommentSymbol, sTest)) to iPos
        // Only remove comment if the line is not commented at the beginning.
        If (iPos > 1) Begin
            Move (Pos(CS_CommentSymbol, sLine)) to iPos
            Move (Left(sLine, iPos - 1)) to sLine
        End
        Function_Return sLine
    End_Function

    // Removes the first word of any input string
    // all up to the first space encountered
    Function _RemoveFirstWord String sLine Returns String
        Integer iPos
        Boolean bChanged
        Move (Trim(sLine)) to sLine
        Get _NormalizeArrayNotation (&sLine) to bChanged
        Move (Pos(" ", sLine)) to iPos
        Function_Return (Right(sLine, (Length(sLine) - iPos)))
    End_Function

    // Returns the first word of any input string
    // all up to the first space encountered
    Function _RetrieveFirstWord String sLine Returns String
        String sFirstWord
        Boolean bChanged
        Get _RemoveFirstWord sLine            to sFirstWord
        Move (Replace(sFirstWord, sLine, "")) to sFirstWord
        Move (Trim(sFirstWord))               to sFirstWord
        Get _NormalizeArrayNotation (&sFirstWord) to bChanged
        Function_Return sFirstWord
    End_Function

    // Remove everything left of the first occurrence of sSubString in the sHostString (Including removing sSubString)
    // RemoveLeft(":", "MSSQLDRV:JOBB")         -> "JOBB"
    // RemoveLeft("D", "ABC")                   -> "ABC"
    // RemoveLeft("is ", "This is an example")  -> "an example"    
    // Note: It it also looks within strings aka "This is a string"
    Function _RemoveLeft String sSubString String ByRef sHostString Returns Boolean
        Integer iPosStart iPosEnd 
        String sText
        
        Move sHostString to sText
        Move (Pos(sSubString, sText)) to iPosStart
        Move (iPosStart + Length(sSubString) - 1) to iPosEnd

        If (iPosStart) Begin                                
            If (iPosEnd = Length(sText)) Begin
                Move (Mid(sText, Length(sText), (iPosStart - 1))) to sHostString
            End 
            Else Begin
                Move (Mid(sHostString, Length(sText), (iPosStart + Length(sSubString)))) to sHostString
            End
        End                                              
        
        Function_Return (sHostString <> sText)
    End_Function

    // Helper function
    Function _RemovePropertyPublicPrivate String ByRef sLine String sPubPriv Returns Boolean
        Boolean bChanged
        String sText
        Integer iPos

        Move False to bChanged
        Move (LTrim(sLine))     to sText
        Move (Left(sText, 9))   to sText
        Move (Lowercase(sText)) to sText
        If (sText = "property ") Begin
            Move (Lowercase(sLine) + " ") to sText // add a space to the test at the end for if the keyword is at the end of the line.
            Move (Pos(" "+ sPubPriv + " ", sText)) to iPos
            If (iPos = 0) Begin // if there's a tab char instead of a space then..
                Move (Pos(Character(9) + sPubPriv + " ", sText)) to iPos
            End
            If (iPos > 0) Begin
                Move (Overstrike(Repeat(" ", Length(sPubPriv)), sLine, iPos + 1)) to sLine // skip first character, don't overwrite a tab with a space
                Move True to bChanged
            End
        End
        Function_Return bChanged
    End_Function

    // helper function for IsKeywordInLine, when a keyword is found in a string declaration
    Function _RemoveStringsFromLine String sLine Returns String
        Integer iLength iPos
        Boolean bSep1 bSep2
        String  sChar sSep1 sSep2 sReturn

        Move False to bSep1
        Move False to bSep2
        Move "'" to sSep1
        Move '"' to sSep2
        Move ""  to sReturn
        Move (Length(sLine)) to iLength

        For iPos from 1 to iLength
            Move (Mid(sLine, 1, iPos)) to sChar
            If (bSep1 = False and bSep2 = False) Begin
                If (sChar = sSep1) Begin
                    Move True to bSep1
                End
                Else If (sChar = sSep2) Begin
                    Move True to bSep2
                End
                If (bSep1 = False and bSep2 = False) Begin
                    Move (sReturn + sChar) to sReturn
                End
            End
            Else Begin
                If (bSep1) Begin
                    If (sChar = sSep1) Begin
                        Move False to bSep1
                    End
                End
                Else If (bSep2) Begin
                    If (sChar = sSep2) Begin
                        Move False to bSep2
                    End
                End
            End
        Loop

        Function_Return sReturn
    End_Function

    Function _SingleCommandSyntaxToFunction String ByRef sLine String sKeyWord Returns Boolean
        Boolean bChanged bIsCommentOrBlank bFound bIfStatement bIsFirstKeyWord
        tTokenizer TokenizerData
        String sText sLowerKeyWord sLowerCase sFirstWord sExpression
        Integer iPos
        
        Move False to bChanged
        Move False to bIsFirstKeyWord  
        Move "" to sExpression
        Move sLine to sText
        Get _IsCommentLineOrBlank sText to bIsCommentOrBlank
        If (bIsCommentOrBlank = True) Begin
            Function_Return False
        End      
        
        Get HasCommand sText sKeyWord to bFound
        If (bFound = False) Begin
            Function_Return False
        End
        
        Get _HasIfCommand sText to bIfStatement
        Move (Lowercase(sKeyWord)) to sLowerKeyWord
        If (bIfStatement = False) Begin
            Get _RetrieveFirstWord sText to sFirstWord
            If (Lowercase(sFirstWord) = Lowercase(sKeyWord)) Begin
                Get _RemoveFirstWord sText to sText
            End    
//            If (Lowercase(sFirstWord) <> sLowerKeyWord) Begin
//                Function_Return False
//            End
        End
        If (bIfStatement = True) Begin
            Get _ExpressionExtractor sText CI_LeftExpression to sExpression  
            If (Trim(sExpression) <> "") Begin
                Move (Pos(sExpression, sText)) to iPos
                Move (Mid(sText, Length(sText), (iPos + Length(sExpression)))) to sText
                Move (Mid(sLine, Length(sLine), (iPos + Length(sExpression)))) to sLine
            End
            // Do we still have the keyword in the line?
            Get HasCommand sText sKeyWord to bFound
            If (bFound = False) Begin   
                Move (String(sExpression) + String(sLine)) to sLine 
                If (bIfStatement = True) Begin
                    Move (CS_If * String(sLine)) to sLine
                End
                Function_Return False
            End
        End
        
//        Move (Pos(sLowerKeyWord, Lowercase(sText))) to iPos
        Move sLine to sText
        Get Tokenizer sText to TokenizerData
        
        // If the line starts with the Key word.
//        If (Pos(sLowerKeyWord, Lowercase(TokenizerData.sCode)) = 1) Begin
//            Move (sLowerKeyWord + " ") to sLowerKeyWord
//        End                                  
//        Else Begin
//            Move (" " + String(sLowerKeyWord) + " ") to sLowerKeyWord
//        End
//        Move (Lowercase(TokenizerData.sCode) contains sLowerKeyWord) to bFound
        Get _RetrieveFirstWord sText to sFirstWord
        Move (Lowercase(sFirstWord) = Lowercase(sKeyWord)) to bFound
        If (bFound = False) Begin      
//            If (sExpression <> "") Begin
//                Move (CS_If * String(sExpression) + String(sLine)) to sLine
//            End
            Function_Return False
        End
        
        Move (Lowercase(TokenizerData.sCode)) to sText
        Move (Mid(TokenizerData.sCode, (Length(TokenizerData.sCode)), (Length(sKeyWord) + 1))) to sText
        Move (Ltrim(sText)) to sText   
        If (sKeyWord = CS_Pos) Begin
            Move (Lowercase(sText)) to sLowerCase
            Move (Pos(" in ", sLowerCase)) to iPos
            If (iPos <> 0) Begin
                Move (Overstrike("____", sText, iPos)) to sText
                Move (Replace("____", sText, ", ")) to sText
                Move True to bChanged
            End
        End                                                                                                                              
        If (Length(TokenizerData.sEndComment)  > 0) Begin
            Move (TokenizerData.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(TokenizerData.sToStatement) * String(TokenizerData.sEndComment)) to sLine
            Move True to bChanged
        End
        Else Begin
            Move (TokenizerData.sIndentation + "Move" * "(" + String(sKeyWord) + "(" + String(sText) + "))" * CS_To * String(TokenizerData.sToStatement)) to sLine
            Move True to bChanged
        End
        
        Function_Return bChanged
    End_Function

    // Helper function. This is a list of commands that also exists as global build in functions.
    Function _TestCommandFunctions String sTest Returns Integer
        Boolean bRemoved
        Integer iCount iSize iPos iTest
        String  sCommand
        String[] asCommandFunctions

        Move 0 to iPos
        Get _RemoveComments (&sTest) to bRemoved
        Get paCommandFunctions to asCommandFunctions
        Move (SizeOfArray(asCommandFunctions)) to iSize
        If (iSize = 0) Begin
//            Send AddAllCommandFunctions
            Get paCommandFunctions to asCommandFunctions
            Move (SizeOfArray(asCommandFunctions)) to iSize        
        End
        Decrement iSize
        For iCount from 0 to iSize
            Move asCommandFunctions[iCount] to sCommand
            Move (Pos(" " + sCommand, sTest)) to iTest // The command MUST have a space before it.
            If (iTest <> 0) Begin
                If (iPos = 0) Begin
                    Move iTest to iPos
                End
                Else Begin
                    If (iTest < iPos) Begin
                        Move iTest to iPos
                    End
                End
            End
        Loop

        Function_Return iPos
    End_Function

    Function HasDoubleExpression String sLine Returns Boolean
        Boolean bFound      
        Integer iCount iSize iOpCount iParanthesis
        String sChar sOperators
        
        Move False to bFound  
        Move 0 to iParanthesis           
        Move "<=>" to sOperators
        Move (Length(sLine)) to iSize
        For iCount from 1 to iSize
            Move (Mid(sLine, 1, iCount)) to sChar
            If (sChar = "(") Begin
                Increment iOpCount          
                Increment iParanthesis
            End
            If (sChar = ")") Begin
                Decrement iOpCount
            End
            If (iParanthesis <> 0 and sOperators contains sChar) Begin
                If (iOpCount = 0) Begin
                    Move True to bFound
                    Move iSize to iCount // We're done.
                End
            End
        Loop
        
        Function_Return bFound
    End_Function
    
    // To check if an "If, Move, Calc etc." command exists in a source line pass source line and a "if " // Note the space _after_
    // To check if a "Begin" command exists in a source line pass source line and a " begin" // Note the space _before_
    Function HasCommand String sLine String sCommand Returns Boolean
        Boolean bFound bOk
        String sText
        
        Move False to bFound 
        Move sLine to sText
        Get _RemoveComments (&sText) to bOK
//        Move (Trim(sText)) to sText
        Get _OverstrikeStrings sText to sText
        Move (Lowercase(sText) contains (String(Lowercase(sCommand)))) to bFound
        
        Function_Return bFound
    End_Function
    
    // Returns True iif the source line contains a "Begin" statement.
    Function _HasBeginStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Begin) to bFound
        Function_Return bFound
    End_Function   
    
    Function _IsBlankLine String sLine Returns Boolean
        Boolean bIsBlank
        
        Move False to bIsBlank
        Move (Trim(sLine)) to sLine
        If (Length(sLine) = 0) Begin
            Move True to bIsBlank
        End
        
        Function_Return bIsBlank        
    End_Function
    
    Function _IsCommentLine String sLine Returns Boolean
        Boolean bIsComment
        Integer iPos
        
        Move False to bIsComment
        Move (Left(Trim(sLine), 2) = CS_CommentSymbol) to bIsComment
        
        Function_Return bIsComment
    End_Function

    // Returns True if this is a comment line with "//" to the left,
    // or if the line is blank.
    Function _IsCommentLineOrBlank String sLine Returns Boolean
        Boolean bIsComment bIsBlank
        
        Get _IsCommentLine sLine to bIsComment
        Get _IsBlankLine sLine to bIsBlank
        
        Function_Return (bIsComment = True or bIsBlank = True)
    End_Function

    // Returns False if the first line in the passed file is _not_ an automatically generated
    // COM wrapper file created by the Studio.
    // If it returns True, we should not process that file.
    Function IsDataFlexCOMProxyClassesFile String sFileName Returns Boolean
        Boolean bIsDFCOMProxyClasses bExists        
        Integer iCh iPos
        String sLine
        
        Move False to bIsDFCOMProxyClasses  
        File_Exist sFileName bExists
        If (bExists = False) Begin
            Error ("The file doesn't exist:" * String(sFileName))
            Function_Return False
        End
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error "No Channel Available for Process: Procedure 'IsDataFlexCOMProxyClassesFile'"
            Function_Return False
        End
        
        Direct_Input channel iCh sFileName
        Readln channel iCh sLine
        Close_Input channel ich
        Send Seq_Release_Channel iCh
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos <> 1) Begin
            Function_Return False
        End

        Move (Lowercase(sLine) contains Lowercase(CS_DFCOMProxyClasses)) to bIsDFCOMProxyClasses
        
        Function_Return bIsDFCOMProxyClasses
    End_Function
    
    // Returns True iif the source line starts with the sCommand statement.
    Function IsFirstWord String sLine String sCommand Returns Boolean
        Boolean bFound
        Integer iPos  
        String sFirstWord
        
        Move (Ltrim(Lowercase(sLine))) to sLine
        Move (Ltrim(Lowercase(sCommand))) to sCommand
        If (sLine = sCommand) Begin
            Function_Return True
        End
        Move (sCommand + " ") to sCommand
        Move (Pos(" ", sLine)) to iPos
        Move (Left(sLine, iPos)) to sFirstWord
        Move (sFirstWord = sCommand) to bFound
        Function_Return bFound
    End_Function   
    
    // Returns True if source line contains a "[Found]", or "[FindErr]".
    Function IsFoundOrFindErrIndicator String sLine Returns Boolean
        Boolean bFound
        Integer iLeft iRight iPos
        String sText
        
        Get IsIndicatorStatement sLine to bFound
        If (bFound = False) Begin
            Function_Return False
        End

        Get _RemoveComments (&sLine) to bFound
        Get _OverstrikeStrings sLine to sText  
        Send StripConcatenatingSpaces (&sText) sLine
        Move (Pos("[", sLine)) to iLeft
        Move (Pos("]", sLine)) to iRight
        Move (Pos(("[" + Lowercase(CS_Found)), sLine)) to iPos
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Found) + "]"), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos(("[" + Lowercase(CS_Finderr)), sLine)) to iPos
        End
        If (iPos = 0) Begin
            Move (Pos((Lowercase(CS_Finderr) + "]"), sLine)) to iPos
        End
            
        Function_Return (iPos <> 0)    
    End_Function
    
    // Returns True iif the source line contains both an "if" and a "begin", but NOT If-Else-Begin statement.
    // Note: The source line must first have been stripped of any comments
    Function _HasIfAndBeginStatement String sLine Returns Boolean
        Boolean bisIfBegin bHasBeginStatement 
        Get _HasIfCommand sLine to bisIfBegin
        Get _HasBeginStatement sLine to bHasBeginStatement
        Function_Return (bisIfBegin = True and bHasBeginStatement = True)
    End_Function   
    
    Function _HasIfCommand String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (CS_If + " ") to bFound
        Function_Return bFound
    End_Function                                                  
    
    Function _IsImagePageStartOrEnd String sLine Boolean bCheckImageStart Returns Boolean
        Boolean bFound
        Integer iPos

        Move False to bFound
        Move (Trim(sLine)) to sLine
        If (bCheckImageStart = True) Begin
            Get _IsImageStart sLine to bFound
        End
        Else Begin                 
            Get _IsImageEnd sLine to bFound
        End

        Function_Return bFound
    End_Function

    // Old DF syntax that used pages, e.g. "/MyPage"
    Function _IsImageStart String sLine Returns Boolean
        Boolean bIsChar
        Integer iPos
        String sChar

        Move False to bIsChar
        Move (Trim(sLine)) to sLine
        Move (Pos(CS_ImageNameStart, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Mid(sLine, 1, 2)) to sChar
            Move ("abcdefghijklmnopqrstuvwxyz" contains Lowercase(sChar)) to bIsChar
        End

        Function_Return bIsChar
    End_Function 
    
    // Old DF syntax that used pages. To mark end of a page these two characters were used: "/*"
    Function _IsImageEnd String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        Move (Pos(CS_ImageNameEnd, sLine)) to iPos
        Move (iPos = 1) to bFound
        Function_Return bFound
    End_Function

    // Returns True if source code contains both a "[" and a "]", but not a "[]"
    Function IsIndicatorStatement String sLine Returns Boolean
        Boolean bFound bIndicatorWord
        Integer iLeft iRight iPos
        String sChar sLeftBracket
        
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sLine) to bFound
        Get _OverstrikeStrings sLine to sLine
        Move (Left(sLine, 1)) to sChar
        If (sChar = "[") Begin
            Move "[" to sLeftBracket
        End                         
        Else Begin
            Move " [" to sLeftBracket
        End
//        Move (Lowercase(sLine) contains Lowercase(CS_Indicate + " ")) to bIndicatorWord
        Move (bIndicatorWord = True or (sLine contains sLeftBracket and sLine contains "]")) to bFound
        If (bFound = True) Begin
            Move (Pos(sLeftBracket, sLine)) to iLeft
            Move (Pos("]", sLine)) to iRight
            Move ((iRight - iLeft) > 1) to bFound
        End
        Function_Return (bIndicatorWord or bFound)
    End_Function

    // Note: The sKeywords string must be separated by "|" _and_ end with a "|".
    Function IsKeywordInLine String sKeywords String sLine Returns Boolean
        String sKeyword sChar  
        Integer iPos   
        Boolean bOK

        Move (Lowercase(sKeywords)) to sKeywords
        Move (Lowercase(sLine)) to sLine
        Get _RemoveStringsFromLine sLine to sLine
        Move (Pos(" ", sLine)) to iPos
        // Then there is only one "word" in sLine. Check if the sKeywords = sLine
        If (iPos = 0) Begin
            Move (Replace("|", sKeywords, "")) to sKeyword
            If (Trim(sKeyword) = Trim(sLine)) Begin
                Function_Return True
            End
        End
        
        While (sKeywords <> "")
            Move (Left(sKeywords, (Pos("|", sKeywords)))) to sKeyword
            Move (Replace(sKeyword, sKeywords, "")) to sKeywords
            Move (Trim(Replace("|", sKeyword, ""))) to sKeyword
            Move ((sKeyword <> "") and ((Pos((" " + sKeyword + " "), sLine)) <> 0)) to bOK
            If (bOK = False) Begin
                Move ((sKeyword <> "") and ((Pos((sKeyword + " "), sLine)) <> 0) ) to bOK
            End
            // Also check if this might be the very first statement on the sLine 
            If (bOK = True) Begin    
                Move (Left(sKeyword, 1)) to sChar
                // Is this a command?
                If (sChar = "#") Begin
                    Function_Return False
                End
                Else Begin
                    Function_Return True
                End
            End
        Loop
        Function_Return False
    End_Function

    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne" OR ">, >=, <, <=, =, <>" 
    // It returns a tOperatorsInfo struct with; bisOperator, bIsLegacy, iPos and sOperator. 
    // Note: It only looks for the first occurance of a logical operator in the passed sLine parameter.
    Function _IsLogicalOperators String sLine Returns tOperatorsInfo
        Boolean bHas 
        tOperatorsInfo OperatorsInfo
        
        Get _IsCommentLineOrBlank sLine to bHas
        If (bHas = True) Begin
            Function_Return OperatorsInfo
        End
        Get _RemoveComments (&sLine) to bHas
        Get _OverstrikeStrings sLine to sLine 
        Move (Lowercase(sLine)) to sLine

        Case Begin                
            // "Legacy" operators;
            Case (sLine contains " gt ")
                Move (Pos(" gt ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "gt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " ge ")
                Move (Pos(" ge ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ge"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " lt ")
                Move (Pos(" lt ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "lt"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " le ")
                Move (Pos(" le ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "le"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " eq ")
                Move (Pos(" eq ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "eq"                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains " ne ")
                Move (Pos(" ne ", sLine))   to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move True                   to OperatorsInfo.bIsLegacy
                Move "ne"                   to OperatorsInfo.sOperator
                Case Break
            
            // "Modern" operators;
            Case (sLine contains ">")
                Move (Pos(">", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">"                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains ">=")
                Move (Pos(">=", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ">="                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<")
                Move (Pos("<", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<"                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<=")
                Move (Pos("<=", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<="                   to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "=")
                Move (Pos("=", sLine))      to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "="                    to OperatorsInfo.sOperator
                Case Break
            Case (sLine contains "<>")
                Move (Pos("<>", sLine))     to OperatorsInfo.iPos
                Move True                   to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move "<>"                   to OperatorsInfo.sOperator
                Case Break
            Case Else
                Move -1                     to OperatorsInfo.iPos
                Move False                  to OperatorsInfo.bIsOperator
                Move False                  to OperatorsInfo.bIsLegacy
                Move ""                     to OperatorsInfo.sOperator
        Case End
                
        Function_Return OperatorsInfo
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of "gt, ge, lt, le, eq, ne", in other words it is an expression.
    Function IsLegacyOperators String sLine Returns Boolean
        Boolean bHas bFound
        
        Get _IsCommentLineOrBlank sLine to bFound
        If (bFound = True) Begin
            Function_Return False
        End
        Get _RemoveComments (&sLine) to bHas
        Get _OverstrikeStrings sLine to sLine 
        Move (Lowercase(sLine)) to sLine

        Case Begin
            Case (sLine contains " gt ")
                Move True to bHas
                Case Break
            Case (sLine contains " ge ")
                Move True to bHas
                Case Break
            Case (sLine contains " lt ")
                Move True to bHas
                Case Break
            Case (sLine contains " le ")
                Move True to bHas
                Case Break
            Case (sLine contains " eq ")
                Move True to bHas
                Case Break
            Case (sLine contains " ne ")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    // Pass only the code part of a source line.
    // Returns True if the code contains any of ">, >= <, <=, =, <>", in other words it is an expression.
    Function IsOperators String sLine Returns Boolean
        Boolean bHas
        
        Get _RemoveComments (&sLine) to bHas 
        Get _OverstrikeStrings sLine to sLine

        Case Begin
            Case (sLine contains ">")
                Move True to bHas
                Case Break
            Case (sLine contains ">=")
                Move True to bHas
                Case Break
            Case (sLine contains "<")
                Move True to bHas
                Case Break
            Case (sLine contains "<=")
                Move True to bHas
                Case Break
            Case (sLine contains "=")
                Move True to bHas
                Case Break
            Case (sLine contains "<>")
                Move True to bHas
                Case Break
            Case Else
                Move False to bHas
        Case End
                
        Function_Return bHas
    End_Function
    
    // It is assumed that blank and commented lines has been checked prior
    // using this function.
    // It will return True if the "sLine" parameter contains any of the DF23's new string's start.
    // If not found it returns false.
    Function _IsMultiLineStringStart String sLine Returns Boolean
        Integer iPos
        Boolean bFound  
        String sSource
        
        // No point in trying to check if property already set to True.
        If (pbInMultiLineString(Self) = True) Begin
            Function_Return False
        End                      
        
        Get _RemoveEndComment sLine to sLine
        Move (Trim(sLine)) to sLine  
        
        // Check first for tripple double-quotes:
        Move (Pos('"""', sLine)) to iPos
        Move (iPos <> 0) to bFound
        If (bFound = True) Begin
            // We must also check fora second tripple quote """ as in;
            // @SQL""" SELECT * FROM Customer WHERE Customer.Name = 'John Doe' """
            Move (Mid(sLine, Length(sLine), (iPos + 3))) to sSource
            Move (Pos('"""', sSource)) to iPos
            // If found we should return False as the line then is "finished"  
            If (iPos <> 0) Begin
                Function_Return False
            End
            Move (iPos = 0) to bFound        
        End  
        
        // Check for "@" type multi-line string:
        If (bFound = False) Begin
            Move (Pos("@", sLine) <> 0) to bFound
            If (bFound = True) Begin
                // Take anything inside quotes, single or double, out of the equation:
                Get _OverstrikeStrings sLine to sSource
                // We do this twice because the _OverstrikeStrings function is "costly".
                Move (Pos("@", sSource) <> 0) to bFound
                If (bFound = False) Begin
                    Move (Pos(Lowercase("@SQL"), Lowercase(sSource)) <> 0) to bFound
                End
            End
        End
        Function_Return bFound
    End_Function  
    
    // It is assumed that blank and commented lines has been checked prior
    // to using this function.
    // It will return True if the "sLine" parameter contains any of the DF23's new string's end,
    // which can be these characters; ', " or """.
    // If not found it returns false.
    Function _IsMultLineStringEnd String sLine Returns Boolean
        Boolean bFound
        String sChar
        
        // If a multi string hasn't been started; no point in testing further.
        If (pbInMultiLineString(Self) = False) Begin
            Function_Return False
        End
        
        // ToDo: The _OverstrikeStrings function is a *costly* operation as it will be 
        // called by each and every cRefactorFunctionLibrary function for every source line.
        // Do we need it? And if so, how do we optimize it?
        // Get _OverstrikeStrings sLine to sLine 
        
        Get _RemoveEndComment sLine to sLine
        Move (Trim(sLine)) to sLine
        Move (Right(sLine, 1)) to sChar
        Move (sChar = '"' or sChar = "'") to bFound
        If (bFound = False) Begin
            Move (Right(sLine, 3)) to sChar
            Move (sChar = '"""') to bFound        
        End
        
        Function_Return bFound
    End_Function

    Function _IsLineEndSemiColon String sLine Returns Boolean
        Boolean bRemoved

        Get _RemoveEndComment sLine to sLine
        Move (RTrim(sLine)) to sLine
        If (Right(sLine, 1) = ";") Begin
            Function_Return True
        End
        Function_Return False
    End_Function  
    
    // Used by the SplitInlineIfElseLine function.
    Function _IsLineEndSemiColonOrBegin String sLine Returns Boolean
        Boolean bRemoved
        Boolean bFound
        
        Move sLine to sLine // dummy line which appears to fix a runtime byref error (???) 
        Get _IsLineEndSemiColon sLine to bFound
        If (bFound = False) Begin
            Move (Lowercase(sLine)) to sLine
            If (Right(sLine, 5) = "begin") Begin
                Move True to bFound
            End
        End
        Function_Return bFound
    End_Function    
    
    // Returns True iif the source line is a "Loop" statement.
    Function IsLoopStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Loop) to bFound
        Function_Return bFound
    End_Function   

    Function IsMoveCommand String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + String(CS_Move) + " ") to bFound
        If (bFound = False) Begin
            Get HasCommand sLine (String(CS_Move) + " ") to bFound
        End
        Function_Return bFound
    End_Function                                                  
    
    // Returns True iif the source line is a "Until" statement.
    Function IsUntilStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Until) to bFound
        If (bFound = False) Begin
            Get HasCommand sLine (CS_Until + " ") to bFound
            If (bFound = False) Begin
                Get HasCommand sLine (CS_Until) to bFound
            End
        End  
            
        Function_Return bFound
    End_Function   

    Function IsVariableDeclarationLine String sLine Returns Boolean
        Boolean bVariableDeclaration
        String[] asLocalVariableTypes asLocalVariableArrayTypes
        Integer iRetval
        String sFirstWord

        Move False to bVariableDeclaration
        Get pasLocalVariableTypes      to asLocalVariableTypes
        Get pasLocalVariableArrayTypes to asLocalVariableArrayTypes
        Move (Trim(sLine)) to sLine
        Get _RetrieveFirstWord sLine to sFirstWord
        Move (Uppercase(sFirstWord)) to sFirstWord
        Move (SearchArray(sFirstWord, asLocalVariableTypes)) to iRetval
        If (iRetval <> -1) Begin
            Move True to bVariableDeclaration
        End
        Else Begin
            Move (SearchArray(sFirstWord, asLocalVariableArrayTypes)) to iRetval
            If (iRetval <> -1) Begin
                Move True to bVariableDeclaration
            End
        End

        Function_Return bVariableDeclaration
    End_Function

    Function IsVariableInLine String sLine String sVariableName Returns Boolean
        Boolean bIsUseLine
        String sChar
        Integer iPos

        Move False to bIsUseLine
        Move (Uppercase(sLine)) to sLine
        Move (Uppercase(sVariableName)) to sVariableName

        If (sLine contains sVariableName) Begin
            Move (Pos(sVariableName, sLine)) to iPos
            If (iPos > 0) Begin
                Repeat
                    Move (Mid(sLine, 1, (iPos - 1))) to sChar
                    If (CS_ValidLeftCharacters contains sChar) Begin
                        Move True to bIsUseLine
                    End
                    If (bIsUseLine = False) Begin
                        Move (Replace(sVariableName, sLine, "")) to sLine
                        Move (Pos(sVariableName, sLine)) to iPos
                    End
                Until (bIsUseLine = True or iPos = 0)
            End
        End

        Function_Return bIsUseLine
    End_Function

    Function IsProjectObjectStructureLine String sLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine
        Integer iPos iSize
        String sObjectName

        Move (Trim(sLine)) to sLine
        Move True to bWriteLine
        Move (Pos(CS_CommentSymbol, sLine)) to iPos
        If (iPos = 1) Begin
            Move (Lowercase(sLine)) to sLine
            Move (not(sLine contains " is a " or sLine contains " is an ")) to bWriteLine
            If (bWriteLine = False) Begin
                Move (SizeOfArray(asObjectNames)) to iSize
                Move (Pos(" is a", sLine)) to iPos
                Move (Left(sLine, (iPos -1))) to sObjectName
                Move (Replace(CS_CommentSymbol, sObjectName, "")) to sObjectName
                Move (Trim(sObjectName)) to sObjectName
                Move (Lowercase(sObjectName)) to asObjectNames[iSize]
            End
        End
        If (sLine = (CS_CommentSymbol * Lowercase(CS_ProjectObjectStructure))) Begin
            Move False to bWriteLine
        End
        Function_Return bWriteLine
    End_Function

    // Returns True iif the source line contains a "Repeat" statement.
    Function IsRepeatStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (" " + CS_Repeat) to bFound
        Function_Return bFound
    End_Function   
    
    Function IsRegisterObjectInArray String sLine String[] ByRef asObjectNames Returns Boolean
        Boolean bWriteLine bRegisterObjectStart
        Integer iPos

        Move False to bWriteLine
        Get IsRegisterAllObjectsStart sLine to bRegisterObjectStart
        If (bRegisterObjectStart = False) Begin
            Move (Lowercase(sLine)) to sLine
            Move (Replace("register_object", sLine, "")) to sLine
            Move (Trim(sLine)) to sLine
            Move (SearchArray(sLine, asObjectNames)) to iPos
            Move (iPos = -1) to bWriteLine
        End

        Function_Return bWriteLine
    End_Function

    Function IsStudioGeneratedComment String sLine String sComment Returns Boolean
        String sText
        
        Move (Lowercase(sLine)) to sText      
        
        If (sText contains (CS_CommentSymbol + Lowercase(sComment))) Begin
            Function_Return True 
        End
        Else If (sText contains (CS_CommentSymbol + " " + Lowercase(sComment))) Begin
            Function_Return True 
        End                 
        
        Function_Return False
    End_Function
    
    // Returns True iif the source line contains a "While" statement.
    Function _HasWhileStatement String sLine Returns Boolean
        Boolean bFound
        Get HasCommand sLine (CS_While + " ") to bFound
        Function_Return bFound
    End_Function   
    
    Function IsProjectObjectStructureStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_ProjectObjectStructure)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterAllObjectsStart String sLine Returns Boolean
        Boolean bFound
        Move (sLine contains (CS_CommentSymbol * CS_RegisterAllObjects)) to bFound
        Function_Return bFound
    End_Function

    Function IsRegisterAllObjectsEnd String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        String sFirstWord

        Move False to bFound
        Move (Lowercase(sLine)) to sLine
        Move (Trim(sLine)) to sLine
        If (Left(sLine, 2) <> CS_CommentSymbol) Begin
            Move (Pos(" ", sLine)) to iPos
            If (iPos <> 0) Begin
                Move (Left(sLine, (iPos -1))) to sFirstWord
                Move (sFirstWord = "object" or sFirstWord = "activate_view" or sFirstWord = "deferred_view") to bFound
            End
        End
        Function_Return bFound
    End_Function

    Function IsRegisterObjectLine String sLine Returns Boolean
        Boolean bFound
        Integer iPos
        Move False to bFound
        Move (Pos(CS_RegisterObject, sLine)) to iPos
        If (iPos = 1) Begin
            Move True to bFound
        End
        Function_Return bFound
    End_Function

    // Tests if the lowercase character passed in sLine on position iPos is
    // a valid character for a class name
    Function IsValidClassCharacter String sLine Integer iPos Returns Boolean
        Boolean bIsValid
        String  sChar
        Move False to bIsValid
        Move (Mid(sLine, 1, iPos)) to sChar
        If ("abcdefghijklmnopqrstuvwxyz1234567890_" contains sChar) Begin
            Move True to bIsValid
        End
        Function_Return bIsValid
    End_Function
      
    // (nicked from cSciLexer.pkg)
    // Sometimes a method has extra embedded spaces between its parameters. This confuses the parameter counting.
    // We reduce the spaces here to just one.
    Procedure StripConcatenatingSpaces String ByRef sText
        While (Pos("  ", sText) <> 0)
            Move (Replaces("  ", sText, " ")) to sText  // as doc says you can't reduce 3+ spaces to 1 without running a loop
        Loop
    End_Procedure

    Procedure AddCommand String sCommand
        String[] Commands

        Get paCommands to Commands
        Move (Lowercase(sCommand)) to sCommand
        Move sCommand to Commands[SizeOfArray(Commands)]
        Set paCommands to Commands
    End_Procedure

    Procedure AddCommandFunction String sCommand
        String[] aCommandFunctions

        Get paCommandFunctions to aCommandFunctions
        Move (Lowercase(sCommand)) to sCommand
        Move sCommand to aCommandFunctions[SizeOfArray(aCommandFunctions)]
        Set paCommandFunctions to aCommandFunctions
    End_Procedure

    // Command list used for testing against inline if/else statements et. al.
    // Note that it is not a complete command list and that we should be careful
    // about commands that might be used as functions or in functions!
    // For example, it is by intention that none of the variable declaration commands
    // are added as things like If (Convert(sVer,String)="ab") would complicate our testing
    //
    // All commands can be entered case insensitive
    // Standalone commands can end on a end of line, such as Abort.
    // Other commands need more parameters and in such case we can improve our success rate
    // by adding a space character.
    //
    Procedure AddAllCommands
        String[] Empty

        Set paCommands to Empty

        //Send AddCommand "Repeat"  // nope, it is a function too
        Send AddCommand "Abort"
        Send AddCommand "Abort_Transaction"
        Send AddCommand "Activate_View "
        Send AddCommand "Add "
        Send AddCommand "Address "
        Send AddCommand "Append "
        Send AddCommand "Append_Output "
        Send AddCommand "Attach "
        Send AddCommand "Begin_Constraints"
        Send AddCommand "Begin_Transaction"
        Send AddCommand "Broadcast "
        Send AddCommand "Broadcast_Focus "
        Send AddCommand "Calc "
        Send AddCommand "Calculate "
        Send AddCommand "Call_Driver "
        Send AddCommand "CallStackDump "
        Send AddCommand "Case "
        Send AddCommand "Clear "
        Send AddCommand "Close "
        Send AddCommand "Close_Input"
        Send AddCommand "Close_Output"
        Send AddCommand "Constrain "
        Send AddCommand "Constrained_Clear "
        Send AddCommand "Constrained_Find "
        Send AddCommand "Constraint_Set"
        Send AddCommand "Constraint_Validate"
        Send AddCommand "Copy_db "
        Send AddCommand "Copy_Records "
        Send AddCommand "Copyfile "
        Send AddCommand "Create_Field "
        Send AddCommand "Create_Index "
        Send AddCommand "Declare_DataFile "
        Send AddCommand "Decrement "
        Send AddCommand "Delegate "
        Send AddCommand "Delete "
        Send AddCommand "Delete_db "
        Send AddCommand "Delete_Field "
        Send AddCommand "Delete_Index "
        Send AddCommand "Direct_Input "
        Send AddCommand "Direct_Output "
        Send AddCommand "DiskFree "
        Send AddCommand "EraseFile "
        Send AddCommand "Error "
        Send AddCommand "Field_Map "
        Send AddCommand "File_Exist "
        Send AddCommand "Fill_Field "
        Send AddCommand "Find "
        Send AddCommand "For "
        Send AddCommand "For_All "
        Send AddCommand "Forward "
        Send AddCommand "Function_Return " // you might have code that does not return a value, I'd consider that a warning
        Send AddCommand "Get "
        Send AddCommand "Get_Argument_Size "
        Send AddCommand "Get_Attribute "
        Send AddCommand "Get_Channel_Position "
        Send AddCommand "Get_Channel_Size "
        Send AddCommand "Get_Current_Directory "
        Send AddCommand "Get_Current_Input_Channel "
        Send AddCommand "Get_Current_Output_Channel "
        Send AddCommand "Get_Current_User_Count "
        Send AddCommand "Get_Date_Attribute "
        Send AddCommand "Get_Directory "
        Send AddCommand "Get_Environment "
        Send AddCommand "Get_Field_Value "
        Send AddCommand "Get_FieldNumber "
        Send AddCommand "Get_File_Mod_Time "
        Send AddCommand "Get_File_Path "
        Send AddCommand "Get_FileNumber "
        Send AddCommand "Get_Licensed_Max_Users "
        Send AddCommand "Get_StrictEval "
        Send AddCommand "Get_Transaction_Retry "
        Send AddCommand "Get_Windows_Directory "
        Send AddCommand "GetAddress "
        Send AddCommand "GetBuff "
        Send AddCommand "GetBuff_String "
        Send AddCommand "GetDskInfo "
        Send AddCommand "Global_Variable "
        Send AddCommand "Include_Resource "
        Send AddCommand "Increment "
        Send AddCommand "Indicate "
        Send AddCommand "Indicator "
        Send AddCommand "Load_Def "
        Send AddCommand "Load_Driver "
        Send AddCommand "Lock"
        Send AddCommand "Login "
        Send AddCommand "Logout"
        Send AddCommand "Make_Directory "
        Send AddCommand "Make_File "
        Send AddCommand "Make_Temp_File "
        Send AddCommand "Move "
        Send AddCommand "Movedate "
        Send AddCommand "Moveint "
        Send AddCommand "Movenum "
        Send AddCommand "Movereal "
        Send AddCommand "Movestr "
        Send AddCommand "NewRecord "
        Send AddCommand "On_Item"
        Send AddCommand "On_key "
        Send AddCommand "Open "
        Send AddCommand "Output "
        Send AddCommand "Output_Aux_File "
        Send AddCommand "Output_Wrap"
        Send AddCommand "Playwave "
        Send AddCommand "Procedure_Return"
        Send AddCommand "Property "
        Send AddCommand "Put "
        Send AddCommand "Read "
        Send AddCommand "Read_Block "
        Send AddCommand "Read_hex "
        Send AddCommand "Readln "
        Send AddCommand "Reg_Close_Key "
        Send AddCommand "Reg_Enum_Key "
        Send AddCommand "Reg_Enum_Key_Info "
        Send AddCommand "Reg_Enum_Value "
        Send AddCommand "Relate "
        Send AddCommand "Remove_Directory "
        Send AddCommand "Renamefile "
        Send AddCommand "Report_Breaks "
        Send AddCommand "Reread"
        Send AddCommand "RunProgram "
        Send AddCommand "Save "
        Send AddCommand "SaveRecord "
        Send AddCommand "Send "
        Send AddCommand "Set "
        Send AddCommand "Set_Argument_Size "
        Send AddCommand "Set_Attribute "
        Send AddCommand "Set_Channel_Position "
        Send AddCommand "Set_Date_Attribute "
        Send AddCommand "Set_Directory "
        Send AddCommand "Set_Field_Value "
        Send AddCommand "Set_File_Mod_Time "
        Send AddCommand "Set_Foreign_Profile_String "
        Send AddCommand "set_registry_root "
        Send AddCommand "Set_Relate "
        Send AddCommand "Set_StrictEval "
        Send AddCommand "Set_Transaction_Retry "
        Send AddCommand "Shift_State "
        Send AddCommand "Show "
        Send AddCommand "Showln"
        Send AddCommand "Sleep "
        Send AddCommand "Sort "
        Send AddCommand "Start_UI"
        Send AddCommand "Structure_Abort "
        Send AddCommand "Structure_Copy "
        Send AddCommand "Structure_End "
        Send AddCommand "Structure_Start "
        Send AddCommand "Subtract "
        Send AddCommand "Sysdate "
        Send AddCommand "Sysdate4 "
        Send AddCommand "Unload_Driver "
        Send AddCommand "Unlock"   
        Send AddCommand "Until"
        Send AddCommand "Valid_Drive "
        Send AddCommand "ValueTreeDeserializeParameter "
        Send AddCommand "ValueTreeSerializeParameter "
        Send AddCommand "VConstrain "
        Send AddCommand "Version_Information "
        Send AddCommand "VFind "
        Send AddCommand "Virtual_Key "
        Send AddCommand "WebGet "
        Send AddCommand "WebPublishFunction "
        Send AddCommand "WebPublishProcedure "
        Send AddCommand "WebSet "
        Send AddCommand "WebSetResponsive "
        Send AddCommand "While "
        Send AddCommand "Write "
        Send AddCommand "Write_Hex "
        Send AddCommand "WriteLn"
        Send AddCommand "ZeroFile "
        Send AddCommand "ZeroString "
        Send AddCommand "ZeroType "
    End_Procedure

    Procedure AddAllCommandFunctions
        String[] Empty

        Set paCommandFunctions to Empty

        Send AddCommandFunction "Repeat"  
        Send AddCommandFunction "If "
        Send AddCommandFunction "Else "  
        Send AddCommandFunction "Pos"
        Send AddCommandFunction "Insert"
    End_Procedure

    // Splits a line to a string array.
    // Ignores any special characters, spaces or new line, CR "multi line"
    Function SplitTextByLengthPure String sText Integer iCount Returns String[]
        String sLine
        String[] saText
    
        Move sText to sLine
    
        While (Length(sLine) > 0)
            Move (Mid(sLine, iCount, 1)) to saText[(SizeOfArray(saText))]
            Move (Mid(sLine, (Length(sLine) - iCount), (iCount + 1))) to sLine
        Loop
    
        Function_Return saText
    End_Function

    // Splits a string to a string array.
    Function Split String sSplitKey String sText Returns String[]
        String[] sArray
        Integer iLeftPos
        Boolean bAtLeastOneSplit
    
        Move (ResizeArray(sArray, 0)) to sArray
        If ((sSplitKey = "") and ((Length(sSplitKey)) = 0)) Begin
            For iLeftPos from 1 to ((Length(sText)))
                Move (Mid(sText, 1, iLeftPos)) to sArray[SizeOfArray(sArray)]
            Loop
        End
        Else Begin
            Move (Pos(sSplitKey, sText)) to iLeftPos
    
            While (iLeftPos > 0)
                Move True to bAtLeastOneSplit
                Move (Left(sText, iLeftPos - 1)) to sArray[SizeOfArray(sArray)]
                Move (Right(sText, ((Length(sText) - (iLeftPos + (Length(sSplitKey))) )+1))) to sText
                Move (Pos(sSplitKey, sText)) to iLeftPos
            Loop
    
            // Ta med text hger om sista splittecknet
            Move sText to sArray[SizeOfArray(sArray)]
        End
    
        Function_Return sArray
    End_Function

    // Creates a string by joining array elements using a separator (e.g. ",")
    Function JoinArray Global String[] saValues String sSeparator Returns String
        Integer i iLength
        String sRet
        Move "" to sRet
        Move (SizeOfArray(saValues)-1) to iLength
        For i from 0 to iLength
            // First element
            If (i = 0) Begin
                Append sRet saValues[i]
            End
            // Other elements
            Else Begin
                Append sRet sSeparator saValues[i]
            End
        Loop
        Function_Return sRet
    End_Function

    // Convert Integer to a binary value
    // Courtesy of Frank Cheng.
    Function IntToBinary Global Integer i Returns String
        String sResult
        If (i < 0) Function_Return ""
        Move "" to sResult
        Repeat
            Move (String(Mod(i, 2)) + sResult) to sResult
            Move (i / 2) to i
        Until (i = 0)
        Function_Return sResult
    End_Function

    // Courtesy of Frank Cheng.
    // There is another verion (HexToInt) in mStrConv.pkg
    Function HexToInt2 Global String sNum Returns Integer
        Integer iLength iDigit iNum iPower
        Move (Length(sNum)) to iLength
        Move 1 to iPower
        Move 0 to iNum
        While (iLength > 0)
            Move (Ascii(Mid(sNum,1,iLength))) to iDigit
            Subtract (If(iDigit > 57, 55, 48)) from iDigit
            Add (iDigit * iPower) to iNum
            Move (iPower * 16) to iPower
            Decrement iLength
        Loop
        Function_Return iNum
    End_Function

    // Curtesy of Evertjan Dondergoor DAE
    Function SQLDateTimeToDFDateTime String s Returns DateTime
        DateTime dt
        Integer iYear iMonth iDay
        Integer iHour iMinute iSecond

        Move (Mid(s, 4,  1)) to iYear
        Move (Mid(s, 2,  6)) to iMonth
        Move (Mid(s, 2,  9)) to iDay
        Move (Mid(s, 2, 12)) to iHour
        Move (Mid(s, 2, 15)) to iMinute
        Move (Mid(s, 2, 18)) to iSecond

        Move (DateSetYear  (dt, iYear  )) to dt
        Move (DateSetMonth (dt, iMonth )) to dt
        Move (DateSetDay   (dt, iDay   )) to dt
        Move (DateSetHour  (dt, iHour  )) to dt
        Move (DateSetMinute(dt, iMinute)) to dt
        Move (DateSetSecond(dt, iSecond)) to dt

        Function_Return dt
    End_Function

    // Returns True if the "sCheckFieldName" field exists in the passed iFile datbase table.
    // If it doesn't exist, False is returned
    Function IsFieldExisting Integer iFile String sCheckFieldName Returns Boolean
        Integer iNumFields iCount                                      
        String sFieldName
      
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumFields
        Decrement iNumFields
        For iCount from 0 to iNumFields  
            Get_Attribute DF_FIELD_NAME of iFile iCount to sFieldName        
            If ((Uppercase (sFieldName)) = (Uppercase (sCheckFieldName))) Begin
                Function_Return True
            End
        Loop
      
        Function_Return False
    End_Function

End_Class
