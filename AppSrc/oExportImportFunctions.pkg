// Functions to support export & import of defined functions from one amchine to another.
// It exports the data from the Functions.dat table to a fixed format. It then scans the cRefactorfunctionLibrar.pkg global refactoring repository for the corresponding code base,
// and makes a copy of the function code text.
// When imported to another machine the selected Functions.dat records will be added that does *not* already exist, with the same function name. It does *not* attempt to make an update of existing data.
// The code base will be appended at the end of the cRefactorfunctionLibrar class.
Use Windows.pkg
Use File_dlg.pkg
Use cIniFile.pkg
Use seq_chnl.pkg
Use cJsonObject.pkg
Use cFilesystem.pkg
Use RefactorFunctionConstants.inc
Use vWin32fh.pkg

Open FunctionsA
Open SysFile

// Global handle to the import/Export functions.
#IFNDEF ghoImportExportFunctions
    Global_Variable Handle ghoImportExportFunctions
#ENDIF    

// Struct that mimics the Functions data table:
Struct tFunctionData
    String ID   
//    { Name = Function_Name}
    String Function_Name
    String Function_Description
    String Function_Help
    String Function_Summary
    Boolean Selected
    Integer Type
    Integer Count
    Boolean bHasParameter
    String Parameter
    String ParameterValidation
    String ParameterHelp
End_Struct

Struct tFunctionCode  
    String  sFunctionName
    Integer iSourceLines
    String[] CodeArray
End_Struct

Struct tUnitTestCode
    String  sFunctionName
    Integer iSourceLines
    String[] UnitArray
End_Struct

Struct tExportImport
    Integer iNoOfFunctions
    tFunctionData[] Data
    tFunctionCode[] Code
    tUnitTestCode[] Unit
End_Struct

Define CS_FunctionLibraryFile       for "cRefactorFunctionLibrary.pkg"
Define CS_UnitTestsFile             for "oRefactor_Unit_Tests.pkg"
Define CS_ImpExpFileJson            for "DFRefactorImportExportFile.json"
Define CS_FunctionLibraryClassStart for "Class cRefactorFunctionLibrary is a cBaseRefactorFunctionLibrary"
Define CS_EndClass                  for "End_Class"
Define CS_EndObject                 for "End_Object"
Define CS_FunctionEnd               for "End_Function"
Define CS_Comment1                  for '// NOTE: Do *not* add any code after this "End_Class"!'
Define CS_Comment2                  for '//       It will be removed by the Export/Import logic.'

Define CS_SelFunctionCount for "Selection Data"
    Define CS_CountKey     for "Number of Functions"

Define CS_ImpExpDataHeader for "Data"
    Define CS_IDKey for "ID"
    Define CS_Function_NameKey for "Name"
    Define CS_Function_DescriptionKey for "Description"
    Define CS_Function_HelpKey for "Help"
    Define CS_Function_SummaryKey for "Summary"
    Define CS_Function_SelectedKey for "Selected"
    Define CS_Function_TypeKey for "Type"
    Define CS_Function_CountKey for "Count"
    Define CS_Function_bHasParameterKey for "bHasParameter"
    Define CS_Function_ParameterKey for "Parameter"
    Define CS_Function_ParameterValidationKey for "ParameterValidation"
    Define CS_Function_ParameterHelpKey for "ParameterHelp"

    Define CS_ImpExtTextRows for "No of text rows"
    Define CS_ImpExtText  for "FunctionText"

Object oImportExportFunctions is a cObject
    Move Self to ghoImportExportFunctions 
    
    Property Integer piNoOfFunctions
    Property String  psLineBreak ""
    Property Boolean pbLastLineBreak False
    Property String[] pasMissingUnitFunctions
    
    // ToDo: *** Search Helper Functions ***
    //
    // Custom search functions for string arrays
    // Note that the compiler must have found these declarations before they can be used in code.
    Function _FindFunctionCode String sSourceLine String sSearchText Returns Integer  
        If (Lowercase(sSourceLine) contains Lowercase(sSearchText)) ;
            Function_Return (EQ)
        Function_Return (GT)
    End_Function
    
    Function _FindEndClassCode String sSourceLine String sSearchText Returns Integer  
        If (Trim(Lowercase(sSourceLine)) = Lowercase(sSearchText)) ;
            Function_Return (EQ)
        Function_Return (GT)
    End_Function
    
    Function GenerateJsonExportFile tExportImport ExportImport Returns Boolean
        Handle hoJson 
        Boolean bOK
        
        Move False to Err
        Get Create (RefClass(cJsonObject)) to hoJson
        Send DataTypeToJson of hoJson ExportImport
        Move (Err = False) to bOK
        If (bOK = True) Begin
            Get WriteJsonToFile hoJson to bOK 
        End
        Send Destroy of hoJson
        
        Function_Return bOK
    End_Function  
    
    // ToDo: *** Create Json Export File ***
    Function WriteJsonToFile Handle hoJson Returns Boolean
        UChar[] ucJson
        Boolean bExists
        Integer iCh
        String sPath sFileName 
        
        Set peWhiteSpace of hoJson to jpWhitespace_Pretty
        Get StringifyUtf8 of hoJson to ucJson
        
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Send Stop_Box "No free channel available for exporting data. Process interrupted."
            Function_Return False
        End
        
        Get psHome of (phoWorkspace(ghoApplication)) to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_ImpExpFileJson) to sFileName
        Direct_Output channel iCh sFileName

        Writeln channel iCh ucJson
        Close_Output channel iCh
        Send Seq_Release_Channel iCh
        File_Exist sFileName bExists
        
        Function_Return bExists
    End_Function
    
    // ToDo: *** Read Json file to Uchar array ***
    Function ReadJsonFile String sFileName Integer ByRef iErrors Returns UChar[]
        Integer iCh
        UChar[] uImportFileData
        
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Send Stop_Box "No free channel available for importing data. Process interrupted."
            Move 1 to iErrors
            Function_Return uImportFileData
        End
        
        Set piNoOfFunctions to 0
        Direct_Input channel iCh sFileName 
        Read_Block channel iCh uImportFileData -1
        
        Function_Return uImportFileData
    End_Function
    
    // Parse Uchar array to tExportImport struct and save data.
    Function ParseJsonData UChar[] uImportFileData String ByRef sParseError Returns Boolean
        Handle hoJson
        Boolean bOK
        tExportImport ExportImport 
        
        Get Create (RefClass(cJsonObject)) to hoJson
        Set pbRequireAllMembers of hoJson to False
        Get ParseUtf8 of hoJson uImportFileData to bOK
        If (bOK = False) Begin
            Get psParseError of hoJson to sParseError
            Send Destroy of hoJson
            Function_Return False
        End
        
        Get JsonToDataType of hoJson to ExportImport
        Get SaveImportData ExportImport to bOK
        
        Send Destroy of hoJson
        Function_Return bOK
    End_Function
    
    Function SaveImportData tExportImport ExportImport Returns Boolean
        Integer iCount iSize iRow iRows
        Boolean bOK bErr
        tFunctionData asData
        tFunctionCode asCode 
        tUnitTestCode asUnit
        String[] asFunctionLibraryFile asFunctionLibraryFileLC
        String[] asUnitTestsFile asUnitTestsFileLC
        
        Get ReadUnitTestsFile (&iSize) to asUnitTestsFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_UnitTestsFile) * "file")
            Function_Return False
        End
        
        // Needs to be after we have read the Unit test file:
        Get ReadCodeLibraryFile False (&iSize) to asFunctionLibraryFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_FunctionLibraryFile) * "file")
            Function_Return False
        End
        
        Get _LowercaseCodeLibrary asFunctionLibraryFile to asFunctionLibraryFileLC
        Get _LowercaseCodeLibrary asUnitTestsFile to asUnitTestsFileLC
        // Remove the two comment lines, the "End_Class" and any blank lines there after (if any)
        Move (SearchArray(CS_EndClass, asFunctionLibraryFileLC, Self, RefFunc(_FindEndClassCode))) to iRow
        If (iRow <> -1) Begin
            If (asFunctionLibraryFile[iRow -2] = CS_Comment1) Begin
                Move (iRow - 3) to iRow
            End
            Move (SizeOfArray(asFunctionLibraryFile)) to iSize
            Move (iSize - (iSize - iRow)) to iRows
            Move (ResizeArray(asFunctionLibraryFile,   iRows)) to asFunctionLibraryFile
            Move (ResizeArray(asFunctionLibraryFileLC, iRows)) to asFunctionLibraryFileLC
        End
    
        Move ExportImport.iNoOfFunctions to iSize
        Decrement iSize
        Set piNoOfFunctions to iSize
        For iCount from 0 to iSize
            Move ExportImport.Data[iCount] to asData
            Get SaveDataToTable asData to bOK
            Move ExportImport.Code[iCount] to asCode
            Get RemoveEndOfLineCharacters asCode.CodeArray to asCode.CodeArray
            Move ExportImport.Unit[iCount] to asUnit  
            Get RemoveEndOfLineCharacters asUnit.UnitArray to asUnit.UnitArray
            // Update the two source file arrays, so we can
            // write them to disk when loop has finished.
            Get UpdateSourceCodeArray asCode asFunctionLibraryFile iCount (&bErr) to asFunctionLibraryFile   
            Get UpdateUnitCodeArray   asUnit asUnitTestsFile       iCount (&bErr) to asUnitTestsFile
        Loop
        
        // Write the updated source files back to disk:
        Get WriteCodeLibraryFile asFunctionLibraryFile to bOK
        If (bOK = True) Begin
            Get WriteUnitTestsFile asUnitTestsFile to bOK
        End
        Function_Return bOK
    End_Function  
    
    Function SaveDataToTable tFunctionData asData Returns Boolean
        Boolean bNew  
        Integer iID 
        String sVal
        
        Move False to Err       
        Clear FunctionsA
        Move asData.Function_Name to FunctionsA.Function_Name
        Find eq FunctionsA.Function_Name
        Move (Found = False) to bNew    
        If (bNew = True) Begin
            Reread SysFile
                Increment SysFile.Next_Functions_ID
                SaveRecord SysFile 
            Unlock                
            Clear FunctionsA
            Move SysFile.Next_Functions_ID to FunctionsA.ID
            Move asData.Function_Name to FunctionsA.Function_Name
        End
        If (bNew = True) ;
            Lock
        Else ;
            Reread FunctionsA
                Move asData.Function_Description to FunctionsA.Function_Description
                Move asData.Function_Help        to FunctionsA.Function_Help
                Move asData.Function_Summary     to FunctionsA.Function_Summary
                Move asData.Selected             to FunctionsA.Selected
                Move asData.Type                 to FunctionsA.Type
                Move asData.Count                to FunctionsA.Count
                Move asData.bHasParameter        to FunctionsA.bHasParameter
                Move asData.Parameter            to FunctionsA.Parameter
                Move asData.ParameterValidation  to FunctionsA.ParameterValidation 
                Move asData.ParameterHelp        to FunctionsA.ParameterHelp
                SaveRecord FunctionsA
            Unlock                   
            
        Function_Return (Err = False)
    End_Function 

    // The JsonObject class/StringifyUtf8 function outputs data with a LineFeed, but the Studio always 
    // saves source with CR+LF as the line delimiter because that is want the compiler wants.
    // So we strip from CR or LF characters so we can Add them later when writing the file. 
    Function RemoveEndOfLineCharacters String[] asCode Returns String[]
        Integer iSize iCount
        String sLineBreak sLine
        
        Move (SizeOfArray(asCode)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move asCode[iCount] to sLine
            If (Right(sLine, 1) = CS_LF) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End                                               
            If (Right(sLine, 1) = CS_CR) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End                                               
            Move sLine to asCode[iCount]
        Loop
        Function_Return asCode        
    End_Function

    // ToDo: *** Main Export function ***
    Function ExportFile String[] asFunctions String ByRef sFileName Returns Boolean
        Integer iSize iCount iID iRetval  
        Handle hoExportImportFile
        Boolean bOK bExists
        String sPath sUnitFunctions
        String[] asFunctionLibraryFile asFunctionLibraryFileLC asFunctionText asMissingUnitFunctions
        tExportImport ExportImport
        
        Move (SizeOfArray(asFunctions)) to iSize
        Decrement iSize
        If (iSize < 0) Begin
            Send Info_Box "Found no selected funtions to Export!"
            Function_Return False
        End
        
        Set pasMissingUnitFunctions to asMissingUnitFunctions
        Get psHome of (phoWorkspace(ghoApplication)) to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_ImpExpFileJson) to sFileName

        Get FillExportImportStruct asFunctions to ExportImport
        Get GenerateJsonExportFile ExportImport to bOK
        
        Get pasMissingUnitFunctions to asMissingUnitFunctions
        Move (SizeOfArray(asMissingUnitFunctions)) to iSize
        Decrement iSize
        If (iSize >= 0) Begin
            for iCount from 0 to iSize
                Append sUnitFunctions (Trim(asMissingUnitFunctions[iCount])) CS_CRLF
            Loop
            Send Info_Box ("Warning! Unit Tests are missing from the file:" * String(CS_UnitTestsFile) * "for these functions.\n\nYou should really consider to add 'Unit Tests' for them all:\n" + String(sUnitFunctions) +"\n\nPress Ctrl+C to copy this text.")
        End
        
        Function_Return bOK
    End_Function   
    
    // ToDo: *** Main Import function ***
    Function ImportFile String sFileName Integer ByRef iFunctions Returns Integer 
        Integer iErrors iSize iCount
        UChar[] uImportFileData
        String sErrorText sUnitFunctions
        String[] asMissingUnitFunctions                                 
        Boolean bOK
        
        Move "" to sErrorText
        Set pasMissingUnitFunctions to asMissingUnitFunctions
        Get ReadJsonFile sFileName (&iErrors) to uImportFileData
        Get ParseJsonData uImportFileData (&sErrorText) to bOK
        If (bOK = False) Begin
            Send Info_Box ("Json parsing error:\n\n" + String(sErrorText))
            Function_Return 1
        End 

        Get pasMissingUnitFunctions to asMissingUnitFunctions
        Move (SizeOfArray(asMissingUnitFunctions)) to iSize
        Decrement iSize
        If (iSize >= 0) Begin
            For iCount from 0 to iSize
                Append sUnitFunctions (Trim(asMissingUnitFunctions[iCount])) CS_CRLF
            Loop
            Send Info_Box ("Warning! Unit Tests are missing from the file:" * String(CS_UnitTestsFile) * "for these functions.\n\nYou should really consider to add 'Unit Tests' for them all:\n" + String(sUnitFunctions) +"\n\nPress Ctrl+C to copy this text.")
        End
        
        Get piNoOfFunctions to iFunctions
        Function_Return 0
    End_Function
    
    // ToDo: *** Structure Fill Functions ***
    Function FillExportImportStruct String[] asFunctions Returns tExportImport
        tExportImport ExportImport
        tFunctionData[] FunctionDataArray
        tFunctionCode[] FunctionCodeArray
        Integer iSize iCount iSizeLines iCountLines
        
        Move (SizeOfArray(asFunctions)) to ExportImport.iNoOfFunctions
        Get FillFunctionDataArray asFunctions to ExportImport.Data
        Get FillFunctionCodeArray asFunctions to ExportImport.Code
        Get FillFunctionUnitArray asFunctions to ExportImport.Unit
        
        Function_Return ExportImport
    End_Function
    
    Function FillFunctionDataArray String[] asFunctionArray Returns tFunctionData[]
        tFunctionData[] FunctionDataArray
        Integer iSize iCount
        
        Move (SizeOfArray(asFunctionArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Clear FunctionsA
            Move asFunctionArray[iCount] to FunctionsA.Function_Name
            Find eq FunctionsA.Function_Name
            If (Found) Begin
                Move FunctionsA.ID                              to FunctionDataArray[iCount].ID
                Move (Trim(FunctionsA.Function_Name))           to FunctionDataArray[iCount].Function_Name
                Move (Trim(FunctionsA.Function_Description))    to FunctionDataArray[iCount].Function_Description
                Move (Trim(FunctionsA.Function_Help))           to FunctionDataArray[iCount].Function_Help
                Move (Trim(FunctionsA.Function_Summary))        to FunctionDataArray[iCount].Function_Summary
                Move FunctionsA.Selected                        to FunctionDataArray[iCount].Selected
                Move FunctionsA.Type                            to FunctionDataArray[iCount].Type
                Move FunctionsA.Count                           to FunctionDataArray[iCount].Count
                Move FunctionsA.bHasParameter                   to FunctionDataArray[iCount].bHasParameter
                Move (Trim(FunctionsA.Parameter))               to FunctionDataArray[iCount].Parameter
                Move (Trim(FunctionsA.ParameterValidation))     to FunctionDataArray[iCount].ParameterValidation
                Move (Trim(FunctionsA.ParameterHelp))           to FunctionDataArray[iCount].ParameterHelp
            End
        Loop  
        
        Function_Return FunctionDataArray
    End_Function
    
    Function FillFunctionCodeArray String[] asFunctionArray Returns tFunctionCode[]
        tFunctionCode[] FunctionCodeArray
        String[] asCodeArray asFunctionLibraryFile asFunctionLibraryFileLC
        Integer iSize iCount
        
        Get ReadCodeLibraryFile False (&iSize) to asFunctionLibraryFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_FunctionLibraryFile) * "file")
            Function_Return FunctionCodeArray
        End
        Get _LowercaseCodeLibrary asFunctionLibraryFile to asFunctionLibraryFileLC 
        Move (SizeOfArray(asFunctionArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Clear FunctionsA
            Move asFunctionArray[iCount] to FunctionsA.Function_Name
            Find eq FunctionsA.Function_Name
            If (Found) Begin
                Get CopyFunctionCode asFunctionLibraryFile asFunctionLibraryFileLC FunctionsA.Function_Name to asCodeArray
                Move (Trim(FunctionsA.Function_Name))   to FunctionCodeArray[iCount].sFunctionName
                Move (SizeOfArray(asCodeArray))         to FunctionCodeArray[iCount].iSourceLines
                Move asCodeArray                        to FunctionCodeArray[iCount].CodeArray
            End
        Loop
        
        Function_Return FunctionCodeArray
    End_Function
    
    Function FillFunctionUnitArray String[] asFunctionArray Returns tUnitTestCode[]
        tUnitTestCode[] UnitTestCodeArray
        String[] asUnitArray asUnitTestFile asUnitTestFileLC
        Integer iSize iCount
        
        Get ReadUnitTestsFile (&iSize) to asUnitTestFile
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_UnitTestsFile) * "file")
            Function_Return UnitTestCodeArray
        End
        Get _LowercaseCodeLibrary asUnitTestFile to asUnitTestFileLC 
        Move (SizeOfArray(asFunctionArray)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Clear FunctionsA
            Move asFunctionArray[iCount] to FunctionsA.Function_Name
            Find eq FunctionsA.Function_Name
            If (Found) Begin
                Get CopyUnitCode asUnitTestFile asUnitTestFileLC FunctionsA.Function_Name to asUnitArray
                Move (Trim(FunctionsA.Function_Name))   to UnitTestCodeArray[iCount].sFunctionName
                Move (SizeOfArray(asUnitArray))         to UnitTestCodeArray[iCount].iSourceLines
                Move asUnitArray                        to UnitTestCodeArray[iCount].UnitArray
            End
        Loop
        
        Function_Return UnitTestCodeArray
    End_Function
    
    // Make a backup-copy of the passed Filename.
    // Note: The filename must include the full path.
    Function CreateBackupFile String sFileName Returns Boolean         
        Integer iRetVal
        String sPath sBackupFile sSourceFile
        
        Get ParseFolderName sFileName to sPath
        Get vFolderFormat sPath to sPath 
        Get ParseFileName   sFileName to sSourceFile
        Move (Replace(".pkg", sSourceFile, "")) to sBackupFile
        Move (sBackupFile + "." + String(CurrentDateTime()) + ".pkg") to sBackupFile 
        Move (Replaces(",", sBackupFile, "_")) to sBackupFile
        Move (Replaces(":", sBackupFile, "_")) to sBackupFile
        Move (Replaces("/", sBackupFile, "-")) to sBackupFile
        Get vCopyFile (sPath + sSourceFile) (sPath + sBackupFile) to iRetVal
        
        Function_Return (iRetVal = 0)    
    End_Function

    // ToDo: *** cRefactorFunctionLibrary Source Code Functions ***
    //    
    // Returns -1 is the passed sFunctionName doesn't exist in the asFunctionLibraryFile string array.
    // Else it returns the array item where it was found.
    Function FunctionCodeExists String[] asFunctionLibraryFile String[] asFunctionLibraryFileLC String sFunctionName Returns Integer
        Integer iRow
        String[] asFunctionCode
        
        Move (Trim(sFunctionName)) to sFunctionName
        Move ("function" * Lowercase(sFunctionName)) to sFunctionName 
        Move (SearchArray(sFunctionName, asFunctionLibraryFileLC, Self, RefFunc(_FindFunctionCode))) to iRow 

        Function_Return iRow
    End_Function  
    
    // Copies the code text for the passed sFunctionName from the cRefactorFunctionLibrary class,
    // and returns a string array as the result. 
    // It alsoo tries to include comments above/before the function declaration.
    // Note: For comments to be successfully "included" the comment lines must be immediately above
    //       the function declaration, without any "empty" line. A commend line must start with either "//" or the meta-tag "{"
    // If sFunctionName was not found, the returned array will be empty.
    Function CopyFunctionCode String[] asFunctionLibraryFile String[] asFunctionLibraryFileLC String sFunctionName Returns String[]
        Integer iCh iRow iCount iSize
        String[] asFunctionCode asComments
        String sEndFunctionLC sSourceLineLC
        Boolean bFound bEnd
        
        Get FunctionCodeExists asFunctionLibraryFile asFunctionLibraryFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Function_Return asFunctionCode    
        End
        
        Get CopyFunctionComment asFunctionLibraryFile iRow to asComments
        Move (iRow - SizeOfArray(asComments)) to iRow
        
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_FunctionEnd)) to sEndFunctionLC
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        Repeat
            Move asFunctionLibraryFile[iRow]   to asFunctionCode[iCount] 
            Move asFunctionLibraryFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndFunctionLC) to bEnd
            Increment iCount 
            Increment iRow
        Until (bEnd = True or iCount >= iSize)
        
        Function_Return asFunctionCode
    End_Function
    
    // Removes the code text for the passed "sFunctionName" from the cRefactorFunctionLibrary class,
    // and returns a string array excluding the code for the passed "sFunctionName".
    // If "sFunctionName" was not found, the returned array will be empty.
    Function RemoveFunctionCode String[] asFunctionLibraryFile String[] ByRef asFunctionLibraryFileLC String sFunctionName Boolean ByRef bErr Returns String[]
        Integer iRow iCount iSize
        String sEndFunctionLC sSourceLineLC sLine                  
        String[] asComments
        Boolean bFound bEnd
        
        Get FunctionCodeExists asFunctionLibraryFile asFunctionLibraryFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Move True to bErr
            Function_Return asFunctionLibraryFile    
        End
        
        // We also need to remove any comment lines above the "Function xxx" declaration line:
        Get CopyFunctionComment asFunctionLibraryFile iRow to asComments
        Move (iRow - SizeOfArray(asComments)) to iRow
        
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_FunctionEnd)) to sEndFunctionLC
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        Repeat
            Move (RemoveFromArray(asFunctionLibraryFile, iRow))   to asFunctionLibraryFile 
            Move (RemoveFromArray(asFunctionLibraryFileLC, iRow)) to asFunctionLibraryFileLC 
            Move asFunctionLibraryFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndFunctionLC) to bEnd
            Increment iCount 
        Until (bEnd = True or iCount > iSize)
        
        // Remove the "Function_End" and the blank line after the function:
        Move (RemoveFromArray(asFunctionLibraryFile, iRow))       to asFunctionLibraryFile 
        Move (RemoveFromArray(asFunctionLibraryFileLC, iRow))     to asFunctionLibraryFileLC 
        Move (RemoveFromArray(asFunctionLibraryFile, iRow))       to asFunctionLibraryFile 
        Move (RemoveFromArray(asFunctionLibraryFileLC, iRow))     to asFunctionLibraryFileLC 
        Move False to bErr
        Function_Return asFunctionLibraryFile
    End_Function   

    // Adds the content of the asNewCode text array to the asFunctionLibraryFile array.
    // Note: Code for the passed sFunctionName value (in asFunctionLibraryFile), should have been 
    //       removed prior calling this message.
    Function AddFunctionCode tFunctionCode asCode String[] asFunctionLibraryFile String[] asFunctionLibraryFileLC Boolean ByRef bErr Returns String[]
        Integer iCount iSize iRow
        String[] asNewCode 
        
        Move asCode.iSourceLines to iSize
        Decrement iSize
        // Add new function code to the bottom of the source code array:
        For iCount from 0 to iSize
            Move asCode.CodeArray[iCount] to asFunctionLibraryFile[SizeOfArray(asFunctionLibraryFile)]
        Loop 
        
        // Add one empty row.
        Move "" to asFunctionLibraryFile[SizeOfArray(asFunctionLibraryFile)]
        Function_Return asFunctionLibraryFile
    End_Function

    Function CopyFunctionComment String[] asFunctionLibraryFile Integer iRow Returns String[]
        String[] asComments
        String sLine sMetaTag sCommentTag
        Integer iCount iSize
        Boolean bComment
        
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Move "{" to sMetaTag
        Move "//" to sCommentTag
        Move 1 to iCount
        Repeat
            Move asFunctionLibraryFile[iRow - iCount] to sLine
            Move (Trim(sLine)) to sLine
            Move (Left(sLine, 1) = sMetaTag) to bComment
            If (bComment = False) Begin
                Move (Left(sLine, 2) = sCommentTag) to bComment
            End
            If (bComment = True) Begin
                Move sLine to asComments[SizeOfArray(asComments)]
            End
            Increment iCount
        Until (sLine = "" or iCount >= iSize) // Last part is just for extra safety!
        
        Function_Return asComments
    End_Function
    
    // Reads the top of - or - the full content of the CS_FunctionLibraryFile class, starting with the 
    // the class declaration line, including the "End_Class" line and returns the result as a string array.
    // Pass a bTopOnly = True to only return the top part of the file (until the "Class xxx" start.
    Function ReadCodeLibraryFile Boolean bTopOnly Integer ByRef iSize Returns String[]
        String[] asSourceFile   
        String sPath sFileName 
        Boolean bExists

        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath   
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        // Make the filename fully qualified: (Full path)
        Move (sPath + CS_FunctionLibraryFile) to sFileName          

        File_Exist sFileName bExists
        If (bExists = False) Begin  
            Move -1 to iSize
            Send Info_Box ("Could not find the Code Library repository file:" * (String(sFileName)))
            Function_Return asSourceFile
        End  
        
        Get _ReadSourceFile sFileName bTopOnly False (&iSize) to asSourceFile
        
        Function_Return asSourceFile
    End_Function  
    
    Function WriteCodeLibraryFile String[] asFunctionLibraryFile Returns Boolean    
        String sPath sFileName sFunctionName sLine sLineBreak
        String[] asFunctionLibraryTop
        Integer iCount iSize iCh iErrors iRow
        Boolean bOK bLastLineBreak
        
        Get psLineBreak     to sLineBreak
        Get pbLastLineBreak to bLastLineBreak
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Send Stop_Box "No free channel available for exporting data. Process interrupted."
            Function_Return False
        End
        
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath   
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_FunctionLibraryFile) to sFileName  
        
        Get CreateBackupFile sFileName to bOK
        If (bOk = False) Begin
            Send Info_Box ("Could not make a backup copy of the" * CS_FunctionLibraryFile * "class library. Process stopped.") 
            Function_Return False
        End
        
        // Note that this needs to be above the Direct_Output below, because that
        // will reset the size of the file to zero.
        Get ReadCodeLibraryFile True (&iSize) to asFunctionLibraryTop
        If (iSize < 0) Begin
            Send Info_Box ("Could not read the:" * String(CS_FunctionLibraryFile) * "file")
            Function_Return False
        End
        
        Direct_Output channel iCh sFilename
        
        // 1. Write the top part of the cRefactorFunctionLibrary.pkg file:
        Move (SizeOfArray(asFunctionLibraryTop)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Write channel iCh asFunctionLibraryTop[iCount] sLineBreak
        Loop
        
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        // 2. Write the class code part of the cRefactorFunctionLibrary.pkg file:
        for iCount from 0 to iSize
            Write channel iCh asFunctionLibraryFile[iCount] sLineBreak
        Loop

        // End by adding the two comments, the "Enc_Class" + one empty line:
        Writeln channel iCh CS_Comment1
        Writeln channel iCh CS_Comment2
        Writeln channel iCh CS_EndClass
    
        Close_Output channel iCh
        Send Seq_Release_Channel iCh
        Function_Return True
    End_Function
                                 
    Function UpdateSourceCodeArray tFunctionCode asCode String[] asFunctionLibraryFile Integer iFunction Boolean ByRef bErr Returns String[]
        String sFunctionName 
        String[] asFunctionLibraryFileLC asFunctionLibraryTop
        Integer iRow iCount iSize
        
        // For the very first function code we add a blank item at the end,
        // so that we get a blank line before the imported functions, when
        // printed to file.
        If (iFunction = 0) Begin
            Move "" to asFunctionLibraryFile[SizeOfArray(asFunctionLibraryFile)
        End
        
        Get _LowercaseCodeLibrary asFunctionLibraryFile to asFunctionLibraryFileLC
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        If (iSize = 0) Begin
            Move True to bErr
            Function_Return asFunctionLibraryFile
        End
        
        Move asCode.sFunctionName to sFunctionName
        // If the function code already exists, that old code will first be removed, then the new function code will be added to the end.
        Get FunctionCodeExists asFunctionLibraryFile asFunctionLibraryFileLC sFunctionName to iRow
        If (iRow <> -1) Begin
            Get RemoveFunctionCode asFunctionLibraryFile (&asFunctionLibraryFileLC) sFunctionName (&bErr) to asFunctionLibraryFile 
            If (bErr = True) Begin
                Function_Return asFunctionLibraryFile
            End
        End
        
        // 2. Add code for the function to the cRefactorFunctionLibrary class array:
        Move asCode.iSourceLines to iCount
        Get AddFunctionCode asCode asFunctionLibraryFile asFunctionLibraryFileLC (&bErr) to asFunctionLibraryFile
        If (bErr = True) Begin
            Function_Return asFunctionLibraryFile
        End
    
        Function_Return asFunctionLibraryFile 
    End_Function
    
    // ToDo: *** Unit Code Source Code Functions ***
    //    
    // Returns -1 is the passed sFunctionName doesn't exist in the asUnitCodeFile string array.
    // Else it returns the array item where it was found.
    Function UnitCodeExists String[] asUnitCodeFile String[] asUnitCodeFileLC String sFunctionName Returns Integer
        Integer iRow
        String[] asUnitCode
        
        Move (Trim(sFunctionName)) to sFunctionName
        Move ('set psfunctionname to "' + Lowercase(sFunctionName) + '"') to sFunctionName 
        Move (SearchArray(sFunctionName, asUnitCodeFileLC, Self, RefFunc(_FindFunctionCode))) to iRow 

        Function_Return iRow
    End_Function  
    
    Function CopyUnitCode String[] asUnitCodeFile String[] asUnitCodeFileLC String sFunctionName Returns String[]
        Integer iCh iRow iCount iSize
        String[] asUnitCode asMissingUnitFunctions
        String sEndObjectLC sSourceLineLC
        Boolean bFound bEnd
        
        Get UnitCodeExists asUnitCodeFile asUnitCodeFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Get pasMissingUnitFunctions to asMissingUnitFunctions
            Move sFunctionName to asMissingUnitFunctions[SizeOfArray(asMissingUnitFunctions)]
            Set pasMissingUnitFunctions to asMissingUnitFunctions
            Function_Return asUnitCode    
        End
        
        // Note! We assume that the "Object oxxx is a cTestFixture" is directly above the
        //      'Set psFunctionName to "xxx"' source code line! So substract by 1.
        Decrement iRow
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_EndObject)) to sEndObjectLC
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        Decrement iSize
        Repeat
            Move asUnitCodeFile[iRow]   to asUnitCode[iCount] 
            Move asUnitCodeFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndObjectLC) to bEnd
            Increment iCount 
            Increment iRow
        Until (bEnd = True or iCount >= iSize)
        
        Function_Return asUnitCode
    End_Function
         
    // Removes the code text for the passed "sFunctionName" from the CS_UnitTestsFile,
    // and returns a string array excluding the code for the passed "sFunctionName".
    // If "sFunctionName" was not found, the returned array will be empty.
    Function RemoveUnitCode String[] asUnitCodeFile String[] ByRef asUnitCodeFileLC String sFunctionName Boolean ByRef bErr Returns String[]
        Integer iRow iCount iSize
        String sEndObjectLC sSourceLineLC
        Boolean bFound bEnd
        
        Get FunctionCodeExists asUnitCodeFile asUnitCodeFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Move True to bErr
            Function_Return asUnitCodeFile    
        End
        
        Move False to bEnd  
        Move 0 to iCount   
        Move (Lowercase(CS_EndObject)) to sEndObjectLC
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        Decrement iSize
        Repeat
            Move (RemoveFromArray(asUnitCodeFile, iRow))   to asUnitCodeFile
            Move (RemoveFromArray(asUnitCodeFileLC, iRow)) to asUnitCodeFileLC
            Move asUnitCodeFileLC[iRow] to sSourceLineLC
            Move (Trim(sSourceLineLC) = sEndObjectLC) to bEnd
            Increment iCount 
        Until (bEnd = True or iCount >= iSize)
        
        // Remove the last "End_Object" line and next empty line:
        Move (RemoveFromArray(asUnitCodeFile, iRow))       to asUnitCodeFile
        Move (RemoveFromArray(asUnitCodeFileLC, iRow))     to asUnitCodeFileLC 
        Move (RemoveFromArray(asUnitCodeFile, iRow))       to asUnitCodeFile
        Move (RemoveFromArray(asUnitCodeFileLC, iRow))     to asUnitCodeFileLC 
        Move False to bErr

        Function_Return asUnitCodeFile
    End_Function   

    // Adds the content of the asNewCode text array to the asUnitCode array.
    // Note: Code for the passed sFunctionName value (in asUnitCode), should have been 
    //       removed prior calling this message.
    Function AddUnitCode tUnitTestCode asUnit String[] asUnitCodeFile String[] asUnitCodeFileLC Boolean ByRef bErr Returns String[]
        Integer iCount iSize iRow
        String[] asNewCode 
        
        Move asUnit.iSourceLines to iSize
        Decrement iSize
        // Add new function code to the bottom of the source code array:
        For iCount from 0 to iSize
            Move asUnit.UnitArray[iCount] to asUnitCodeFile[SizeOfArray(asUnitCodeFile)]
        Loop 
        
        // Add one empty row.
        Move "" to asUnitCodeFile[SizeOfArray(asUnitCodeFile)]
        Function_Return asUnitCodeFile
    End_Function

    // Reads the content of the Unit Testing source file: CS_UnitTestsFile,
    // and returns it as a string array.
    Function ReadUnitTestsFile Integer ByRef iSize Returns String[]
        String[] asSourceFile
        String sPath sFileName
        Boolean bExists
        
        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        // Make the filename fully qualified: (Full path)
        Move (sPath + CS_UnitTestsFile) to sFileName          

        File_Exist sFileName bExists
        If (bExists = False) Begin
            Send Info_Box ("Could not find the Unit testing source file:" * (String(sFileName)))
            Function_Return asSourceFile
        End  
        
        Get _ReadSourceFile sFileName False True (&iSize) to asSourceFile
        
        Function_Return asSourceFile
    End_Function

    // ToDo: Is this getting cvalled? The unit test file looks the same after an import"
    Function WriteUnitTestsFile String[] asUnitCodeFile Returns Boolean    
        String sPath sFileName sFunctionName sLine sLineBreak
        Integer iCount iSize iCh iErrors iRow
        Boolean bOK bLastLineBreak
        
        Get psLineBreak     to sLineBreak
        Get pbLastLineBreak to bLastLineBreak
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Send Stop_Box "No free channel available for exporting data. Process interrupted. (WriteUnitTestsFile)"
            Function_Return False
        End
        
        // If a multi-path psAppSrc is used, we assume the first parameter is the "AppSrc" folder name.
        Get psAppSrcPath of (phoWorkspace(ghoApplication)) to sPath   
        Get PathAtIndex of (phoWorkspace(ghoApplication)) sPath 1 to sPath
        Get vFolderFormat sPath to sPath
        Move (sPath + CS_UnitTestsFile) to sFileName  
        
        Get CreateBackupFile sFileName to bOK
        If (bOk = False) Begin
            Send Info_Box ("Could not make a backup copy of the" * CS_UnitTestsFile * "file. Process stopped.") 
            Function_Return False
        End
        
        Direct_Output channel iCh sFilename
        
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        // Somewhere there was one to many lines added to the string array - remove last one.
        Decrement iSize
        Decrement iSize
        for iCount from 0 to iSize
            Write channel iCh asUnitCodeFile[iCount] sLineBreak
        Loop

        Close_Output channel iCh
        Send Seq_Release_Channel iCh
    
        Function_Return True
    End_Function

    Function UpdateUnitCodeArray tUnitTestCode asUnit String[] asUnitCodeFile Integer iFunction Boolean ByRef bErr Returns String[]
        String sFunctionName 
        String[] asUnitCodeFileLC asMissingUnitFunctions
        Integer iRow iCount iSize
        
        // For the very first function code we add a blank item at the end,
        // so that we get a blank line before the imported functions, when
        // printed to file.
        If (iFunction = 0) Begin
            Move "" to asUnitCodeFile[SizeOfArray(asUnitCodeFile)
        End
        
        Get _LowercaseCodeLibrary asUnitCodeFile to asUnitCodeFileLC
        Move (SizeOfArray(asUnitCodeFile)) to iSize
        If (iSize = 0) Begin
            Move True to bErr
            Function_Return asUnitCodeFile
        End
        
        Move asUnit.sFunctionName to sFunctionName
        // If the function code already exists, that old code will first be removed, then the new function code will be added to the end.
        Get UnitCodeExists asUnitCodeFile asUnitCodeFileLC sFunctionName to iRow
        If (iRow = -1) Begin
            Get pasMissingUnitFunctions to asMissingUnitFunctions
            Move sFunctionName to asMissingUnitFunctions[SizeOfArray(asMissingUnitFunctions)]
            Set pasMissingUnitFunctions to asMissingUnitFunctions
        End
        Get RemoveUnitCode asUnitCodeFile (&asUnitCodeFileLC) sFunctionName (&bErr) to asUnitCodeFile
        If (bErr = True) Begin
            Function_Return asUnitCodeFile
        End
        
        // 2. Add code for the function to the oRefactor_Unit_Tests object array:
        Move asUnit.iSourceLines to iCount
        Get AddUnitCode asUnit asUnitCodeFile asUnitCodeFileLC (&bErr) to asUnitCodeFile
        If (bErr = True) Begin
            Function_Return asUnitCodeFile
        End
    
        Function_Return asUnitCodeFile
    End_Function
    
    // ToDo: *** Helper Functions ***    
    //
    // Lower cases the function library to make searches/compares easier:
    // String arrays using this method all ends with the "LC" suffix.
    Function _LowercaseCodeLibrary String[] asFunctionLibraryFile Returns String[]
        String[] asFunctionLibraryFileLC
        Integer iSize iCount
        
        Move (SizeOfArray(asFunctionLibraryFile)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move (Lowercase(asFunctionLibraryFile[iCount])) to asFunctionLibraryFileLC[iCount]
        Loop
        
        Function_Return asFunctionLibraryFileLC   
    End_Function  

    // Reads the content of the passed sFileName source file and returns it as a string array.
    // The sFileName must contain full path.
    // Line-ending characters like CR and LF are stripped for each line.
    // No checking is done if the file exists or not.
    // If something went wrong an empty string array will be returned.
    Function _ReadSourceFile String sFileName Boolean bTopOnly Boolean bUnitTest Integer ByRef iSize Returns String[]
        Integer iCh iFileSize iCount
        String[] asSourceFile   
        String sLine sLastLine sLineBreak
        Boolean bStart bEnd bLastLineBreak bEndOfFile   
        Handle hoFunctionLibrary

        Move False to bEndOfFile
        Move False to bLastLineBreak
        Move ""    to sLastLine
        Move False to bStart
        Move False to bEnd
        Move 0 to iCount

        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin                 
            Send Info_Box "No free channel available for input. (ReadSourceFile function)."
            Move -1 to iSize
            Function_Return asSourceFile
        End

        Get vWin32_APIFileSize sFilename to iFileSize
        Move (ResizeArray(asSourceFile, iFileSize)) to asSourceFile

        // Set the linebreak character to use for the file to CR + LF,
        // because that is what the Studio uses when saving a file. And it seems to be because
        // the compiler can get confused when there is only a LF.
        // The readline automatically reads until LF, but does not include it in the read string.
        Move CS_CRLF to sLineBreak
        Set psLineBreak to sLineBreak

        // Need to use binary read mode as we want to use CR+LF as the line delimiter.
        // The filemode options don't seem to work as documented, not sure why.
        Direct_Input channel iCh ("binary:" + sFilename)

        While (bEndOfFile = False)
            Readln channel iCh sLine
            Move (SeqEof) to bEndOfFile

            If (bEndOfFile and Length(sLastLine) > 0) Begin
                If (Right(sLastLine, 1) = CS_CR) Begin
                    Move True to bLastLineBreak
                End
            End
            Move sLine to sLastLine
            
            // Remove any CR or LF at the end of line.
            // The Line_Feed character is already removed by the Readln command.
            // When the WriteCodeLibraryFile is called, it will add CR+LF for each array item.
            // All this hazzle because the Compiler is expecting each line to end with a CR+LF,
            // else it gets confused and generates errors on what seems to be a perfectly normal
            // source code line.
            If (Right(sLine, 1) = CS_CR) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End
            If (Right(sLine, 1) = CS_LF) Begin
                Move (Left(sLine, Length(sLine) - 1)) to sLine
            End

            If (bEndOfFile = False) Begin
                If (bTopOnly = True) Begin
                    Move (Trim(sLine) = CS_FunctionLibraryClassStart) to bEnd
                    If (bEnd = True) Begin 
                        Move True to bEndOfFile
                    End
                    Else Begin
                        Move sLine to asSourceFile[iCount]
                        Increment iCount
                    End
                End
                Else If (bUnitTest = False) Begin
                    If (bStart = False) Begin
                        Move (Trim(sLine) = CS_FunctionLibraryClassStart) to bStart
                    End
                    If (bStart = True and bEnd = False) Begin
                        Move sLine to asSourceFile[iCount]
                        Increment iCount
                    End
                    Move (Trim(sLine) = CS_EndClass) to bEnd
                    If (bStart = True and bEnd = True) Begin      
                        Move True to bEndOfFile
                    End
                End
                Else Begin
                    Move sLine to asSourceFile[iCount]
                    Increment iCount
                End
            End
        Loop
        
        Move (ResizeArray(asSourceFile, iCount)) to asSourceFile
        Set pbLastLineBreak to bLastLineBreak
        Move iCount to iSize
        Close_Input channel iCh
        Send Seq_Release_Channel iCh

        Function_Return asSourceFile
    End_Function  
    
End_Object
